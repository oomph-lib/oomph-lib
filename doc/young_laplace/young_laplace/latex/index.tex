This document discusses the finite-\/element-\/based solution of the \href{http://en.wikipedia.org/wiki/Young-Laplace_equation}{\texttt{ Young Laplace equation}}, a nonlinear PDE that determines the static equilibrium shapes of droplets or bubbles. We start by reviewing the relevant theory and then present the solution of a simple model problem.

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{Acknowledgement\+:}} \end{center}  This tutorial and the associated driver codes were developed jointly with Cedric Ody (Ecole Polytechnique, Paris; now Rennes). ~\newline
~\newline
  \\\cline{1-1}
\end{longtabu}
\end{center} \hypertarget{index_theory}{}\doxysection{Theory}\label{index_theory}
The figure below illustrates a representative problem\+: A small droplet is extruded slowly from the outlet of a cylindrical tube. The air-\/liquid interface is pinned at the end of the tube. We assume that the size of the droplet and the rate of extrusion are so small that gravitational, viscous and inertial forces may be neglected compared to the interfacial forces acting at the air-\/liquid interface.

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{spherical_cap}
\doxyfigcaption{A typical problem\+: The extrusion of a small droplet from a cylindrical tube. }
\end{DoxyImage}


The shape of the air-\/liquid interface (the meniscus) is then determined by Laplace\textquotesingle{}s law which expresses the balance between the (spatially constant) pressure drop across the meniscus, $ \Delta p^* $, and the surface tension forces acting at the air-\/liquid interface, \[ \Delta p^* = \sigma \kappa^*, \] where $ \kappa^* $ is the mean curvature and $ \sigma $ the surface tension.

Non-\/dimensionalising all lengths on some problem-\/specific lengthscale $ {\cal L} $ (e.\+g. the radius of the cylindrical tube) and scaling the pressure on the associated capillary scale, $ \Delta p^* = \sigma/{\cal L} \ \Delta p $, yields the non-\/dimensional form of the Young-\/\+Laplace equation \[ \Delta p = \kappa. \] This must be augmented by suitable boundary conditions, to be applied at the contact line -- the line along which the meniscus meets the solid surface. We can either \char`\"{}pin\char`\"{} the position of the contact line (as in the above example), or prescribe the ~\newline
 \href{http://en.wikipedia.org/wiki/Contact_angle}{\texttt{ contact angle}} at which the air-\/liquid interface meets the solid surface.

The mathematical problem may be interpreted as follows\+: Given the prescribed pressure drop $ \Delta p $ (and thus $ \kappa $), we wish to determine an interface shape of the required mean curvature $ \kappa $ that satisfies the boundary conditions along the contact line.\hypertarget{index_cartesian}{}\doxysubsection{Cartesian PDE-\/based formulation}\label{index_cartesian}
Expressing the (non-\/dimensional) height of the interface above the $ (x_1, x_2) $-\/plane as $ x_3 = u(x_1,x_2) $ yields the cartesian form of the Young-\/\+Laplace equation\+: \[ \Delta p = \kappa = - \nabla \cdot \frac{\nabla u}{\sqrt{1+|\nabla u|^2}}, \] where $ \nabla = (\partial/\partial x_1,\partial/\partial x_2)^T $ Given the imposed pressure drop across the interface, this equation must be solved for $ u(x_1, x_2) $. Note that this is only possible if the interface can be projected onto the $ (x_1, x_2) $-\/plane.\hypertarget{index_pvd}{}\doxysubsection{The principle of virtual displacements}\label{index_pvd}
The interface shape can also be determined from the \href{http://en.wikipedia.org/wiki/Virtual_displacement}{\texttt{ principle of virtual displacements}} \[ \delta \left( \int_S \mathit{\, d} s \right)= \int_S \Delta p {\bf N} \cdot \delta {\bf N} \mathit{\, d} s + \oint_{L} \ \ {\bf T}_n \cdot \delta {\bf R } \mathit{\, d} l \ \ \ \ \ \ \ \ \ \ \ \ (1) \] which may be derived from energetic considerations. Here the symbol $ \delta $ denotes a variation, $ {\bf R } $ is the position vector to the interface, and the vector $ {\bf N} $ is the unit normal to the meniscus. The left hand side of this equation represents the variation of the interfacial energy during a virtual displacement, and $ ds $ is an infinitesimal element of the meniscus surface, $S$. The terms on the right hand side represent the virtual work done by the pressure and the virtual work done by the surface tension forces acting at the free contact line, respectively. $ dl $ is the length of an element of the contact line $L$, and $ {\bf T}_n $ is the vector tangent to the interface and normal to the contact line. Note that, if the contact line is pinned, the variation of its position is zero, $ \delta {\bf R} = {\bf 0} $, and the line integral vanishes.

The variational formulation of the problem is particularly convenient for a finite-\/element-\/based solution; see, e.\+g. the \href{../../../solid/solid_theory/html/index.html\#CartesianLagrangian}{\texttt{ Solid Mechanics Theory document}} for a discussion of how to discretise variational principles with finite elements. The variational and PDE-\/based formulations are, of course, related to each other\+: The Young-\/\+Laplace equation is the Euler-\/\+Lagrange equation of the variational principle.\hypertarget{index_intrinsic}{}\doxysubsection{Parametric representation}\label{index_intrinsic}
To deal with cases in which the interface cannot be projected onto the $ (x_1, x_2) $-\/plane, we parametrise the meniscus by two intrinsic coordinates as $ {\bf R}(\zeta_1,\zeta_2) \in { R}^3$, where $(\zeta_1,\zeta_2) \in D \in { R}^2$. Furthermore, we parametrise the domain boundary, $\partial D$, by a scalar coordinate $\xi$ so that, \[ {\partial D} = \bigg\{ (\zeta_1,\zeta_2) \ \bigg| \ (\zeta_1,\zeta_2) = \left( \zeta_1^{[\partial D]}(\xi), \ \zeta_2^{[\partial D]}(\xi) \right) \bigg\}. \] The normal to the meniscus is then given by \[ {\bf N} = \frac{{\bf R}_{,1} \times {\bf R}_{,2} } {\mathcal{A}^{1/2}}, \] where the commas denote partial differentiation with respect to the intrinsic coordinates, and $ \mathcal{A}^{1/2}= |{\bf R}_{,1} \times {\bf R}_{,2}| $ is the square root of the surface metric tensor.

The area and length differentials required in variational principle are \[ d s=\mathcal{A}^{1/2} d \zeta_1 d \zeta_2 \] and \[ d l=\left| \frac{d {\bf R}\left( \zeta_1^{[\partial D]}(\xi), \ \zeta_2^{[\partial D]}(\xi) \right)}{d \xi} \right| d \xi, \] allowing us to write the principle of virtual displacements as \[ \int_S \left( \frac{\delta \mathcal{A}^{1/2}}{\mathcal{A}^{1/2}} - \kappa \ {\bf N} \cdot \delta {\bf R} \right) \mathcal{A}^{1/2} d \zeta_1 d \zeta_2 = \oint_{L} {\bf T}_n \cdot \delta {\bf R} \ \left| \frac{d {\bf R}\left( \zeta_1^{[\partial D]}(\xi), \ \zeta_2^{[\partial D]}(\xi) \right)}{d \xi} \right| d \xi. \]\hypertarget{index_spines}{}\doxysubsection{The method of spines}\label{index_spines}
In the current form, the variational principle cannot yield a unique solution because there are infinitely many vector fields $ {\bf R}(\zeta_1,\zeta_2) $ that parametrise the same interface shape. To remove this ambiguity, and to allow for interface shapes that cannot be projected onto the $ (x_1,x_2) $-\/plane, we employ the so-\/called \char`\"{}\+Method of Spines\char`\"{}. This method was originally proposed by Kistler and Scriven for the computation of free surface flows. We decompose the vector $ {\bf R} $ into two parts by writing it as \[ {\bf R}(\zeta_1,\zeta_2) = {\bf B}(\zeta_1,\zeta_2) + \mathit{u}(\zeta_1,\zeta_2) \ {\bf S}(\zeta_1,\zeta_2). \] Here the \char`\"{}spine basis\char`\"{} ${\bf B}(\zeta_1,\zeta_2)$ and the \char`\"{}spines\char`\"{} ${\bf S}(\zeta_1,\zeta_2)$ are pre-\/determined vector fields that must be chosen by the user. Using this decomposition, the meniscus shape is determined by the scalar function $\mathit{u}(\zeta_1,\zeta_2)$ which represents the meniscus\textquotesingle{} displacement along the spines ${\bf S}$.

The idea is illustrated in the simple 2D sketch below\+: the spine basis vectors, $ {\bf B}(\zeta), $ parametrise the straight line corresponding to a flat meniscus. Positive values of $ u $ displace the meniscus along the spines, $ {\bf S}(\zeta) $ (the red vectors), whose orientation allows the representation of meniscus shapes that cannot be represented in cartesian form as $ x_2 = u(x_1). $

 
\begin{DoxyImage}
\includegraphics[width=0.35\textwidth]{spine_sketch}
\doxyfigcaption{Sketch illustrating the parametrisation of the meniscus by the Method of Spines. }
\end{DoxyImage}


The spine basis and the spines themselves must be chosen such that the mapping from $(\zeta_1,\zeta_2)$ to ${\bf R}(\zeta_1,\zeta_2)$ is one-\/to-\/one, at least for the meniscus shapes of interest. Pinned boundary conditions of the form $ \left. {\bf R}\right|_{\partial D} = {\bf R}_{\rm pinned} $ are most easily imposed by choosing the spine basis such that $ \left. {\bf B}\right|_{\partial D} = {\bf R}_{\rm pinned}, $ implying that $ \left. u\right|_{\partial D} = 0. $

The simplest possible choice for the spines and spine basis is one that returns the problem to its original cartesian formulation. This is achieved by setting $ {\bf B}(\zeta_1,\zeta_2) = (\zeta_1,\zeta_2,0)^T $ and $ {\bf S}(\zeta_1,\zeta_2) = (0,0,1)^T. $\hypertarget{index_displ}{}\doxysubsection{Displacement Control}\label{index_displ}
The Young-\/\+Laplace equation is a highly nonlinear PDE. We therefore require a good initial guess for the solution in order to ensure the convergence of the Newton iteration. In many cases good initial guesses can be provided by a simple, physically motivated continuation method. For instance in the model problem shown above, the computation was started by computing the solution for $ \Delta p = \kappa = 0 $ -- a flat interface. This solution was then used as the initial guess for the solution at a small positive value of $ \Delta p $. This process was continued, allowing us to compute strongly deformed meniscus shapes. This method works well, provided small increments in the control parameter $ \Delta p $ (or equivalently, $ \kappa $) create small changes in the interface shape. This is not always the case, however, as we shall see in the example below. In such cases it is often possible to re-\/formulate the problem, using the displacement control method discussed in the \href{../../../beam/steady_ring/html/index.html}{\texttt{ solid mechanics tutorials}}. Rather than prescribing the pressure drop $ \Delta p $ we prescribe the displacement of a control point on the meniscus and regard the pressure drop required to achieve this displacement as an unknown. Since the implementation of the method is very similar to that used for solid mechanics problems, we shall not discuss it in detail here but refer to the appropriate \href{../../../beam/steady_ring/html/index.html}{\texttt{ solid mechanics tutorial.}}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_barrel}{}\doxysection{An example problem\+: A barrel-\/shaped meniscus}\label{index_barrel}
As an example, we consider the following problem\+: Fluid is extruded from an infinitely long, parallel-\/sided slot of width $ 2a $. If we assume that the air-\/liquid interface is pinned at the edges of the slot, as shown in the sketch below, the problem has an obvious exact solution. The air-\/liquid interface must have constant mean curvature, so, assuming that its shape does not vary along the slot, the meniscus must be a circular cylinder. If we characterise the meniscus\textquotesingle{} shape by its vertical displacement along the centreline, $ H $, the (dimensional) curvature of the air-\/liquid interface is given by \[ \kappa^* = \frac{2/a}{H/a + a/H}. \] The plot of this function, shown in the right half of the figure below, may be interpreted as a \char`\"{}load-\/displacement diagram\char`\"{} as it shows the deflection of the meniscus as a function of the imposed non-\/dimensional pressure drop across the air-\/liquid interface, $ \Delta p = a \kappa^*. $

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{meniscus_sketch_and_limit_point}
\doxyfigcaption{Sketch of the meniscus above a slot of width 2a. The figure on the right illustrates the relation between the meniscus curvature and its vertical displacement along the centreline. }
\end{DoxyImage}


The plot shows that the load-\/displacement curve is not single-\/valued. Furthermore, the presence of a limit point at $ a \kappa^* = 1 $ indicates that the maximum curvature of the meniscus is given by $ \kappa_{max}^* = 1/a. $ This implies that the maximum (dimensional) pressure that the meniscus can withstand is given by $ \Delta p^*_{max} = \sigma \kappa_{max}^* = \sigma/a $.

The presence of the limit point makes it impossible to compute the entire solution curve by simply increasing $ \kappa $ in small increments. However, use of a displacement control approach, by prescribing $ H $ while regarding $ \Delta p $ (and thus $\kappa$) as an unknown, yields a single-\/valued function that can be computed by a straightforward continuation method in which $ H $ is increased in small increments.

This approach was employed to compute the meniscus shapes shown in the plot below. The initial, zero-\/curvature configuration of the meniscus (corresponding to a vanishing pressure drop across the air-\/liquid interface) is the unit square. The meniscus is pinned along the lines $ y=0 $ and $ y=1 $, and symmetry (natural) boundary conditions were applied along the lines $ x=0 $ and $ x=1; $ see \mbox{\hyperlink{index_comm_ex}{Comments and Exercises}} for further details on the natural boundary conditions. As the pressure drop increases, the meniscus is deflected upwards until it reaches the configuration of maximum curvature when $ H/a=1 $. Beyond this point, the pressure drop has to be reduced to compute the \char`\"{}bulging\char`\"{} meniscus shapes obtained for $ H/a > 1. $

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{barrel}
\doxyfigcaption{Deformation of a meniscus that is pinned along the lines y=0 and y=1. }
\end{DoxyImage}


The comparison of the computed \char`\"{}load-\/displacement curve\char`\"{} against the exact solution, shown below, indicates that the two agree to within plotting accuracy.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{trace}
\doxyfigcaption{Load-\/displacement diagram for a meniscus that is pinned along the lines y=0 and y=1. }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_impl}{}\doxysection{Implementation}\label{index_impl}
We shall now discuss the solution of the above problem with {\ttfamily oomph-\/lib\textquotesingle{}s} Young Laplace elements.\hypertarget{index_namespace}{}\doxysubsection{The global namespace}\label{index_namespace}
As usual we define the problem parameters in a global namespace. The key parameter is the value of the prescribed control displacement which we initialise to zero. The function {\ttfamily \mbox{\hyperlink{namespaceGlobalParameters_a4571d41514b16946dd31d075d44c5593}{get\+\_\+exact\+\_\+kappa()}}} returns the exact solution for the mean curvature of the meniscus. We will use this function for the validation of our results.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===== start\_of\_namespace========================================}}
\DoxyCodeLine{\textcolor{comment}{/// Namespace for "{}global"{} problem parameters}}
\DoxyCodeLine{\textcolor{comment}{//================================================================}}
\DoxyCodeLine{\textcolor{keyword}{namespace }\mbox{\hyperlink{namespaceGlobalParameters}{GlobalParameters}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Displacement control:}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Height control value}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobalParameters_a3731f24a02ce4f306d65a9a488f85c96}{Controlled\_height}} = 0.0;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Exact kappa }}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobalParameters_a4571d41514b16946dd31d075d44c5593}{get\_exact\_kappa}}()}
\DoxyCodeLine{ \{ }
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Mean curvature of barrel-\/shaped meniscus}}
\DoxyCodeLine{  \textcolor{keywordflow}{return} 2.0*\mbox{\hyperlink{namespaceGlobalParameters_a3731f24a02ce4f306d65a9a488f85c96}{Controlled\_height}}/}
\DoxyCodeLine{   (\mbox{\hyperlink{namespaceGlobalParameters_a3731f24a02ce4f306d65a9a488f85c96}{Controlled\_height}}*\mbox{\hyperlink{namespaceGlobalParameters_a3731f24a02ce4f306d65a9a488f85c96}{Controlled\_height}}+1.0/4.0);}
\DoxyCodeLine{}
\DoxyCodeLine{ \} \textcolor{comment}{//end exact kappa}}

\end{DoxyCodeInclude}
 Next we define the orientation of the spines. Anticipating the shape of the meniscus, we set $ {\bf B}(\zeta_1,\zeta_2)= (\zeta_1,\zeta_2,0) $ so that $ u=0 $ corresponds to a flat meniscus in the $ (x,y) $-\/plane,


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Spine basis}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Spine basis: The position vector to the basis of the spine}}
\DoxyCodeLine{\textcolor{comment}{ /// as a function of the two coordinates x\_1 and x\_2, and its}}
\DoxyCodeLine{\textcolor{comment}{ /// derivatives w.r.t. to these coordinates. }}
\DoxyCodeLine{\textcolor{comment}{ /// dspine\_B[i][j] = d spine\_B[j] / dx\_i}}
\DoxyCodeLine{\textcolor{comment}{ /// Spines start in the (x\_1,x\_2) plane at (x\_1,x\_2).}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespaceGlobalParameters_ac81daf87f8d3f075d9fd108427e70c4f}{spine\_base\_function}}(\textcolor{keyword}{const} Vector<double>\& x, }
\DoxyCodeLine{                          Vector<double>\& spine\_B, }
\DoxyCodeLine{                          Vector< Vector<double> >\& dspine\_B)}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  }
\DoxyCodeLine{  \textcolor{comment}{// Bspines and derivatives }}
\DoxyCodeLine{  spine\_B[0]     = x[0];}
\DoxyCodeLine{  spine\_B[1]     = x[1];}
\DoxyCodeLine{  spine\_B[2]     = 0.0 ;}
\DoxyCodeLine{  dspine\_B[0][0] = 1.0 ;}
\DoxyCodeLine{  dspine\_B[1][0] = 0.0 ;}
\DoxyCodeLine{  dspine\_B[0][1] = 0.0 ; }
\DoxyCodeLine{  dspine\_B[1][1] = 1.0 ;}
\DoxyCodeLine{  dspine\_B[0][2] = 0.0 ;}
\DoxyCodeLine{  dspine\_B[1][2] = 0.0 ;}
\DoxyCodeLine{  }
\DoxyCodeLine{ \} \textcolor{comment}{// End of bspine functions}}

\end{DoxyCodeInclude}
 and rotate the spines in the $ y $ direction by setting \[ {\bf S}(\zeta_1,\zeta_2) = \left( \begin{array}{c} 0 \\ -\sin\big(\alpha(\zeta_2)\big) \\ \ \ \cos\big(\alpha(\zeta_2)\big) \\ \end{array} \right) \] where $ \alpha(\zeta_2) = \alpha_{min} + (\alpha_{max}-\alpha_{min}) \zeta_2 $. With this choice, the spines are unit vectors that form an angle $ \alpha $ (varying between $ \alpha_{min} $ and $ \alpha_{max} $) with the y-\/axis.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Spines rotate in the y-\/direction}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Min. spine angle against horizontal plane}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}} = MathematicalConstants::Pi/2.0*1.5;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Max. spine angle against horizontal plane}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}} = MathematicalConstants::Pi/2.0*0.5;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Spine: The spine vector field as a function of the two }}
\DoxyCodeLine{\textcolor{comment}{ /// coordinates x\_1 and x\_2, and its derivatives w.r.t. to these coordinates:}}
\DoxyCodeLine{\textcolor{comment}{ /// dspine[i][j] = d spine[j] / dx\_i}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespaceGlobalParameters_a82df8c67f58e78a236fb6a0cc8bf8284}{spine\_function}}(\textcolor{keyword}{const} Vector<double>\& x, }
\DoxyCodeLine{                     Vector<double>\& spine, }
\DoxyCodeLine{                     Vector< Vector<double> >\& dspine)}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{  /// Spines (and derivatives)  are independent of x[0] and rotate }}
\DoxyCodeLine{\textcolor{comment}{  /// in the x[1]-\/direction}}
\DoxyCodeLine{\textcolor{comment}{}  spine[0]=0.0;}
\DoxyCodeLine{  dspine[0][0]=0.0; }
\DoxyCodeLine{  dspine[1][0]=0.0; }
\DoxyCodeLine{  }
\DoxyCodeLine{  spine[1]=cos(\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}}+(\mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}}-\/\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}})*x[1]); }
\DoxyCodeLine{  dspine[0][1]=0.0;                                   }
\DoxyCodeLine{  dspine[1][1]=-\/sin(\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}}+(\mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}}-\/\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}})*x[1])}
\DoxyCodeLine{   *(\mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}}-\/\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}});            }
\DoxyCodeLine{  }
\DoxyCodeLine{  spine[2]=sin(\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}}+(\mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}}-\/\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}})*x[1]);}
\DoxyCodeLine{  dspine[0][2]=0.0;                                  }
\DoxyCodeLine{  dspine[1][2]=cos(\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}}+(\mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}}-\/\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}})*x[1]) }
\DoxyCodeLine{   *(\mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}}-\/\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}});            }
\DoxyCodeLine{}
\DoxyCodeLine{ \} \textcolor{comment}{// End spine function}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysubsection{The driver code}\label{index_main}
We start by preparing an output directory and open a trace file to record the control displacement, and the computed and exact values of the interface curvature $ \kappa $.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===================start\_of\_main========================================}}
\DoxyCodeLine{\textcolor{comment}{/// Driver code}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keywordtype}{int} \mbox{\hyperlink{barrel_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Create label for output}}
\DoxyCodeLine{ DocInfo doc\_info;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Set output directory}}
\DoxyCodeLine{ doc\_info.set\_directory(\textcolor{stringliteral}{"{}RESLT"{}});}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{//Open a trace file}}
\DoxyCodeLine{ ofstream trace\_file;}
\DoxyCodeLine{ \textcolor{keywordtype}{char} filename[100];}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/trace.dat"{}},doc\_info.directory().c\_str());}
\DoxyCodeLine{ trace\_file.open(filename);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Write kappa, exact kappa and height values}}
\DoxyCodeLine{ trace\_file}
\DoxyCodeLine{  << \textcolor{stringliteral}{"{}VARIABLES=\(\backslash\)"{}<GREEK>k</GREEK>\(\backslash\)"{},\(\backslash\)"{}<GREEK>k</GREEK>\_\{ex\}\(\backslash\)"{},\(\backslash\)"{}h\(\backslash\)"{}"{}} }
\DoxyCodeLine{  << std::endl;}
\DoxyCodeLine{ trace\_file << \textcolor{stringliteral}{"{}ZONE"{}} << std::endl;}

\end{DoxyCodeInclude}
 Next we build the problem object and document the initial configuration\+: a flat meniscus.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{  }
\DoxyCodeLine{ \textcolor{comment}{// Create the problem}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Create the problem with 2D nine-\/node elements from the}}
\DoxyCodeLine{ \textcolor{comment}{// QYoungLaplaceElement family. }}
\DoxyCodeLine{ \mbox{\hyperlink{classYoungLaplaceProblem}{YoungLaplaceProblem<QYoungLaplaceElement<3>}} > problem;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{//Output the solution}}
\DoxyCodeLine{ problem.\mbox{\hyperlink{classYoungLaplaceProblem_a16f10e66457718eca76d1335dbed8f12}{doc\_solution}}(doc\_info,trace\_file);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{//Increment counter for solutions }}
\DoxyCodeLine{ doc\_info.number()++;}

\end{DoxyCodeInclude}
 Finally, we perform a parameter study by increasing the control displacement in small increments and re-\/computing the meniscus shapes and the associated interface curvatures.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Parameter incrementation}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ }}
\DoxyCodeLine{ \textcolor{keywordtype}{double} increment=0.1;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Loop over steps}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nstep=2; \textcolor{comment}{// 10;}}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} istep=0;istep<nstep;istep++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Increment prescribed height value}}
\DoxyCodeLine{   \mbox{\hyperlink{namespaceGlobalParameters_a3731f24a02ce4f306d65a9a488f85c96}{GlobalParameters::Controlled\_height}}+=increment;}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Solve the problem}}
\DoxyCodeLine{   problem.newton\_solve();}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{//Output the solution}}
\DoxyCodeLine{   problem.\mbox{\hyperlink{classYoungLaplaceProblem_a16f10e66457718eca76d1335dbed8f12}{doc\_solution}}(doc\_info,trace\_file);}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{//Increment counter for solutions }}
\DoxyCodeLine{   doc\_info.number()++;}
\DoxyCodeLine{   }
\DoxyCodeLine{  \}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Close output file}}
\DoxyCodeLine{ trace\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of main}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_class}{}\doxysubsection{The problem class}\label{index_class}
The problem class has the usual member functions. (Ignore the lines in {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+solve()} as they are irrelevant in the current context. They are discussed in one of the exercises in \mbox{\hyperlink{index_comm_ex}{Comments and Exercises}}.) The problem\textquotesingle{}s private member data include a pointer to the node at which the meniscus displacement is controlled by the displacement control element, and a pointer to the {\ttfamily Data} object whose one-\/and-\/only value contains the unknown interface curvature, $ \kappa. $

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//====== start\_of\_problem\_class=======================================}}
\DoxyCodeLine{\textcolor{comment}{/// 2D YoungLaplace problem on rectangular domain, discretised with}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{/// 2D QYoungLaplace elements. The specific type of element is}}
\DoxyCodeLine{\textcolor{comment}{/// specified via the template parameter.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT> }
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{classYoungLaplaceProblem}{YoungLaplaceProblem}} : \textcolor{keyword}{public} Problem}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Constructor: }}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classYoungLaplaceProblem_a4ea552f351994849e9ab597ef2da797a}{YoungLaplaceProblem}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Destructor (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classYoungLaplaceProblem_aa3482606bfd86a3db9d2dec86ba75f14}{\string~YoungLaplaceProblem}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem before solve }}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classYoungLaplaceProblem_a93dd45313d28c3b9b0b51e34d14ebd24}{actions\_before\_newton\_solve}}()}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// This only has an effect if displacement control is disabled}}
\DoxyCodeLine{   \textcolor{keywordtype}{double} new\_kappa=\mbox{\hyperlink{classYoungLaplaceProblem_a78d1ae3b73777674003b2c9794ea9b43}{Kappa\_pt}}-\/>value(0)-\/0.5;}
\DoxyCodeLine{   \mbox{\hyperlink{classYoungLaplaceProblem_a78d1ae3b73777674003b2c9794ea9b43}{Kappa\_pt}}-\/>set\_value(0,new\_kappa);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem after solve: Empty}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classYoungLaplaceProblem_a8eed49ad1c6247cc293a584ab9262efc}{actions\_after\_newton\_solve}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Doc the solution. DocInfo object stores flags/labels for where the}}
\DoxyCodeLine{\textcolor{comment}{ /// output gets written to and the trace file}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classYoungLaplaceProblem_a16f10e66457718eca76d1335dbed8f12}{doc\_solution}}(DocInfo\& doc\_info, ofstream\& trace\_file);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Node at which the height (displacement along spine) is controlled/doced}}
\DoxyCodeLine{\textcolor{comment}{} Node* \mbox{\hyperlink{classYoungLaplaceProblem_a1d659f1b2d73140a5d52889f9581d12f}{Control\_node\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to Data object that stores the prescribed curvature}}
\DoxyCodeLine{\textcolor{comment}{} Data* \mbox{\hyperlink{classYoungLaplaceProblem_a78d1ae3b73777674003b2c9794ea9b43}{Kappa\_pt}};}
\DoxyCodeLine{}
\DoxyCodeLine{\}; \textcolor{comment}{// end of problem class}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_constr}{}\doxysubsection{The problem constructor}\label{index_constr}
We start by building the mesh, discretising the two-\/dimensional parameter space $ (\zeta_1,\zeta_2) \in [0,1] \times [0,1]$ with 8x8 elements.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//=====start\_of\_constructor===============================================}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{/// Constructor for YoungLaplace problem}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\mbox{\hyperlink{classYoungLaplaceProblem_a4ea552f351994849e9ab597ef2da797a}{YoungLaplaceProblem<ELEMENT>::YoungLaplaceProblem}}()}
\DoxyCodeLine{\{ }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup mesh}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// \# of elements in x-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_x=8;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// \# of elements in y-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_y=8;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Domain length in x-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} l\_x=1.0;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Domain length in y-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} l\_y=1.0;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Build and assign mesh}}
\DoxyCodeLine{ Problem::mesh\_pt()=\textcolor{keyword}{new} SimpleRectangularQuadMesh<ELEMENT>(n\_x,n\_y,l\_x,l\_y);}

\end{DoxyCodeInclude}
 Next, we choose the central node in the mesh as the node whose displacement is imposed by the displacement control method.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Check that we've got an even number of elements otherwise}}
\DoxyCodeLine{ \textcolor{comment}{// out counting doesn't work...}}
\DoxyCodeLine{ \textcolor{keywordflow}{if} ((n\_x\%2!=0)||(n\_y\%2!=0))}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   cout << \textcolor{stringliteral}{"{}n\_x n\_y should be even"{}} << endl;}
\DoxyCodeLine{   abort();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  }
\DoxyCodeLine{ \textcolor{comment}{//  This is the element that contains the central node:}}
\DoxyCodeLine{ ELEMENT* prescribed\_height\_element\_pt= \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(}
\DoxyCodeLine{  mesh\_pt()-\/>element\_pt(n\_y*n\_x/2+n\_x/2));}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// The central node is node 0 in that element}}
\DoxyCodeLine{ Control\_node\_pt= \textcolor{keyword}{static\_cast<}Node*\textcolor{keyword}{>}(prescribed\_height\_element\_pt-\/>node\_pt(0));}
\DoxyCodeLine{}
\DoxyCodeLine{ std::cout << \textcolor{stringliteral}{"{}Controlling height at (x,y) : ("{}} << Control\_node\_pt-\/>x(0) }
\DoxyCodeLine{           << \textcolor{stringliteral}{"{},"{}} << Control\_node\_pt-\/>x(1)  << \textcolor{stringliteral}{"{})"{}} << \textcolor{stringliteral}{"{}\(\backslash\)n"{}} << endl;}

\end{DoxyCodeInclude}
 We pass the pointer to that node and the pointer to the double that specifies the imposed displacement to the constructor of the displacement control element. The constructor automatically creates a {\ttfamily Data} object whose one-\/and-\/only value stores the unknown curvature, $ \kappa. $ We store the pointer to this {\ttfamily Data} object in the private member data to facilitate its output.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Create a height control element}}
\DoxyCodeLine{ HeightControlElement* height\_control\_element\_pt=\textcolor{keyword}{new} HeightControlElement(}
\DoxyCodeLine{  Control\_node\_pt,\&\mbox{\hyperlink{namespaceGlobalParameters_a3731f24a02ce4f306d65a9a488f85c96}{GlobalParameters::Controlled\_height}});}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Store pointer to kappa data}}
\DoxyCodeLine{ \mbox{\hyperlink{namespaceGlobalParameters_ac6234184cce40ab2c6bec92b37e4ae41}{Kappa\_pt}}=height\_control\_element\_pt-\/>kappa\_pt();}

\end{DoxyCodeInclude}
 The meniscus is pinned along mesh boundaries 0 and 2\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Boundary conditions}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}}
\DoxyCodeLine{ \textcolor{comment}{// free by default -\/-\/ only need to pin the ones that have Dirichlet conditions}}
\DoxyCodeLine{ \textcolor{comment}{// here. }}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_bound = mesh\_pt()-\/>nboundary(); }
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} b=0;b<n\_bound;b++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Pin meniscus displacement at all nodes boundaries  0 and 2}}
\DoxyCodeLine{   \textcolor{keywordflow}{if} ((b==0)||(b==2))}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{keywordtype}{unsigned} n\_node = mesh\_pt()-\/>nboundary\_node(b);}
\DoxyCodeLine{     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       mesh\_pt()-\/>boundary\_node\_pt(b,n)-\/>pin(0); }
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \} \textcolor{comment}{// end bc}}

\end{DoxyCodeInclude}
 We complete the build of the Young Laplace elements by passing the pointer to the spine functions, and the prescribed curvature.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Complete build of elements}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Complete the build of all elements so they are fully functional }}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nelement = mesh\_pt()-\/>nelement();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<nelement;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Upcast from GeneralsedElement to YoungLaplace element}}
\DoxyCodeLine{   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()-\/>element\_pt(i));}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{//Set the spine function pointers}}
\DoxyCodeLine{   el\_pt-\/>spine\_base\_fct\_pt() = \mbox{\hyperlink{namespaceGlobalParameters_ac81daf87f8d3f075d9fd108427e70c4f}{GlobalParameters::spine\_base\_function}};}
\DoxyCodeLine{   el\_pt-\/>spine\_fct\_pt() =  \mbox{\hyperlink{namespaceGlobalParameters_a82df8c67f58e78a236fb6a0cc8bf8284}{GlobalParameters::spine\_function}};}
\DoxyCodeLine{  }
\DoxyCodeLine{   \textcolor{comment}{// Set the curvature data for the element}}
\DoxyCodeLine{   el\_pt-\/>set\_kappa(\mbox{\hyperlink{namespaceGlobalParameters_ac6234184cce40ab2c6bec92b37e4ae41}{Kappa\_pt}}); }
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
 Finally, we add the displacement control element to the mesh and assign the equation numbers.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Add the height control element to mesh (comment this out}}
\DoxyCodeLine{ \textcolor{comment}{// if you're not using displacement control)}}
\DoxyCodeLine{ mesh\_pt()-\/>add\_element\_pt(height\_control\_element\_pt);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Setup equation numbering scheme}}
\DoxyCodeLine{ cout <<\textcolor{stringliteral}{"{}\(\backslash\)nNumber of equations: "{}} << assign\_eqn\_numbers() << endl; }
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of constructor}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_post}{}\doxysubsection{Postprocessing}\label{index_post}
We document the exact and computed meniscus curvatures in the trace file and output the meniscus shape.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===============start\_of\_doc=============================================}}
\DoxyCodeLine{\textcolor{comment}{/// Doc the solution: doc\_info contains labels/output directory etc.}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classYoungLaplaceProblem_a16f10e66457718eca76d1335dbed8f12}{YoungLaplaceProblem<ELEMENT>::doc\_solution}}(DocInfo\& doc\_info,}
\DoxyCodeLine{                                                ofstream\& trace\_file)}
\DoxyCodeLine{\{ }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Output kappa vs height of the apex }}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ trace\_file << -\/1.0*\mbox{\hyperlink{namespaceGlobalParameters_ac6234184cce40ab2c6bec92b37e4ae41}{Kappa\_pt}}-\/>value(0) << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{ trace\_file << \mbox{\hyperlink{namespaceGlobalParameters_a4571d41514b16946dd31d075d44c5593}{GlobalParameters::get\_exact\_kappa}}()  << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{ trace\_file << Control\_node\_pt-\/>value(0) ;}
\DoxyCodeLine{ trace\_file << endl; }
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Number of plot points: npts x npts}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} npts=5;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Output full solution }}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ ofstream some\_file;}
\DoxyCodeLine{ \textcolor{keywordtype}{char} filename[100];}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/soln\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ mesh\_pt()-\/>output(some\_file,npts);}
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of doc}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comm_ex}{}\doxysection{Comments and Exercises}\label{index_comm_ex}

\begin{DoxyEnumerate}
\item {\bfseries{Choice of spines\+:}} ~\newline
~\newline
 We discussed earlier that the spine basis and the spines themselves must be chosen such that the mapping from $(\zeta_1,\zeta_2)$ to ${\bf R}(\zeta_1,\zeta_2)$ is one-\/to-\/one, at least for the meniscus shapes of interest. This requires some prior knowledge of the expected interface shapes. ~\newline
 ~\newline
 The spine basis and the spines must be defined via function pointers that are passed to the Young Laplace elements. If the function pointers are not specified, the Young-\/\+Laplace elements revert to a cartesian formulation. ~\newline
~\newline
 Experiment with different spine orientations and explore the interface shapes that are obtained if no spines are specified (by commenting out the lines in the constructor that pass the relevant function pointers to the Young Laplace elements). ~\newline
 ~\newline
~\newline

\item {\bfseries{Natural boundary conditions\+:}} ~\newline
~\newline
 As usual in any finite-\/element computation, we only enforced the essential boundary conditions by pinning the meniscus displacement along the \char`\"{}pinned contact lines\char`\"{} at $ y=0 $ and $ y=1. $ No constraints were applied along the two other domain boundaries (at $ x=0 $ and $ x=1 $), indicating that these boundaries are controlled by implied, \char`\"{}natural\char`\"{} boundary conditions. The variational principle (1) shows what these are\+: since we neglected the boundary integral on the right hand side of equation (1), the meniscus shape must satisfy $ {\bf T}_n \cdot \delta {\bf R} = \delta u \ {\bf T}_n \cdot {\bf S} = 0, $ implying that outer unit normal to the meniscus boundary, $ {\bf T}_n, $ must be orthogonal to the direction of the spines. Since the spines do not have an $ x $ -\/ component, the meniscus must therefore have zero slope in that direction -- just what we need for our problem. ~\newline
~\newline
 To convince yourself that the this argument is correct, rotate the spines in the $ x $ -\/direction, e.\+g. by changing their definition to \[ {\bf S}(\zeta_1,\zeta_2) = \left( \begin{array}{c} 1/2 \\ -\sin\big(\alpha(\zeta_2)\big) \\ \ \ \cos\big(\alpha(\zeta_2)\big) \\ \end{array} \right). \] The natural boundary condition will still force the meniscus to be normal to the spines along the \char`\"{}free\char`\"{} contact line, resulting in interface shapes similar to the one shown in the figure below.  
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{funky_meniscus}
\doxyfigcaption{Meniscus shape created by the natural boundary conditions when the spines (shown as vectors) are rotated in the x-\/direction. }
\end{DoxyImage}
 This demonstrates yet again that the orientation of spines must reflect the relevant features of the problem. We refer to \href{../../contact_angle/html/index.html}{\texttt{ another tutorial}} for a more detailed discussion of the boundary condition and its relation to contact angles. ~\newline
~\newline

\item {\bfseries{Displacement control\+:}} ~\newline
~\newline
 Explore what happens if you disable displacement control and prescribe the pressure drop (i.\+e. $ \kappa $) directly. The relevant code is already contained in the driver code. You\textquotesingle{}ll have to comment out the lines in the problem constructor that create the displacement control element and the line that adds it to the problem\textquotesingle{}s mesh. Replace them by the lines ~\newline
~\newline
  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Comment out the previous two commands and uncomment the following two}}
\DoxyCodeLine{ \textcolor{comment}{// to prescribe the pressure drop (the curvature) directly}}
\DoxyCodeLine{ \textcolor{comment}{//Kappa\_pt=new Data(1);}}
\DoxyCodeLine{ \textcolor{comment}{//Kappa\_pt-\/>pin(0);}}

\end{DoxyCodeInclude}
 ~\newline
~\newline
 which create the {\ttfamily Data} object that stores the prescribed curvature. (Note that the value of $ \kappa $ is already incremented in {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+step()}. With displacement control this step has no real effect as the Newton method will overwrite this assignment). Check what happens if the prescribed curvature exceeds the maximum possible curvature of the meniscus. ~\newline
~\newline

\item {\bfseries{Inefficient implementation\+:}} ~\newline
~\newline
 Note that the current implementation of the Young Laplace elements ~\newline
 is inefficient as the elemental Jacobian matrices are computed by finite-\/differencing. You are invited to implement the analytical computation of the Jacobian matrix as an exercise. ~\newline
~\newline

\item {\bfseries{Other problems\+:}} ~\newline
~\newline
 We provide a number of additional demo driver codes that demonstrate the solution of other, related problems. ~\newline
~\newline

\begin{DoxyItemize}
\item The code ~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/young_laplace/young_laplace.cc}{\texttt{ demo\+\_\+drivers/young\+\_\+laplace/young\+\_\+laplace.\+cc }} \end{center}  ~\newline
~\newline
 and its adaptive counterpart ~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/young_laplace/refineable_young_laplace.cc}{\texttt{ demo\+\_\+drivers/young\+\_\+laplace/refineable\+\_\+young\+\_\+laplace.\+cc }} \end{center}  ~\newline
~\newline
 demonstrate the solution of three problems\+: (i) the barrel-\/shaped meniscus problem already discussed above; (ii) the deformation of a meniscus that is pinned at all four edges of a square tube; and (iii) the solution of a problem with contact-\/angle boundary conditions. The latter one is discussed in a \href{../../contact_angle/html/index.html}{\texttt{ separate tutorial.}} ~\newline
 ~\newline
~\newline

\item The spherical meniscus that emanates from a circular tube, shown in the animation at the beginning of current document, was computed with\+: ~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/young_laplace/spherical_cap_in_cylinder.cc}{\texttt{ demo\+\_\+drivers/young\+\_\+laplace/spherical\+\_\+cap\+\_\+in\+\_\+cylinder.\+cc }} \end{center}  ~\newline
~\newline

\end{DoxyItemize}
\end{DoxyEnumerate}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/young_laplace/}{\texttt{ demo\+\_\+drivers/young\+\_\+laplace/ }} \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/young_laplace/barrel.cc}{\texttt{ demo\+\_\+drivers/young\+\_\+laplace/barrel.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{PDF file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
