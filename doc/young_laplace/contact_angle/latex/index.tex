In this document we demonstrate the adaptive solution of the Young Laplace equation with contact angle boundary conditions. We start by reviewing the physical background in the context of a representative model problem, and then discuss the spine-\/based representation of free contact lines and the implementation of the contact angle boundary condition along such lines.

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{Acknowledgement\+:}} \end{center}  This tutorial and the associated driver codes were developed jointly with Cedric Ody (Ecole Polytechnique, Paris; now Rennes). ~\newline
~\newline
  \\\cline{1-1}
\end{longtabu}
\end{center} 

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_model}{}\doxysection{A model problem}\label{index_model}
The figure below shows a sketch of a T-\/junction in a microchannel with a rectangular cross-\/section. (The front wall has been removed for clarity). Fluid is being pushed quasi-\/steadily along the (vertical) main channel and is in the process of entering the T-\/junction. We assume that the air-\/liquid interface (shown in red) remains pinned at the two sharp edges (at $ y=const.$) where the channels meet, while the meniscus forms a quasi-\/static contact angle, $ \gamma $, with the smooth front and back walls.

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{t_junction_contact_angle_sketch}
\doxyfigcaption{A typical problem\+: Fluid propagates quasi-\/steadily through a T-\/junction that connects two channels of rectangular cross-\/section. }
\end{DoxyImage}


It is of interest to determine the maximum pressure that the meniscus can withstand\+: if the driving pressure is less than that value, the fluid will not be able to propagate past the T-\/junction.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_theory}{}\doxysection{Theory and implementation}\label{index_theory}
\hypertarget{index_spine}{}\doxysubsection{Spine-\/based representation of the meniscus}\label{index_spine}
\href{../../young_laplace/html/index.html}{\texttt{ Recall}} that we parametrised the meniscus by two intrinsic coordinates as $ {\bf R}(\zeta_1,\zeta_2) \in {R}^3 $, where $(\zeta_1,\zeta_2) \in D \in {R}^2$. Furthermore, we parametrised the domain boundary, $\partial D$, by a scalar coordinate $\xi$ so that, \[ {\partial D} = \bigg\{ (\zeta_1,\zeta_2) \ \bigg| \ (\zeta_1,\zeta_2) = \left( \zeta_1^{[\partial D]}(\xi), \ \zeta_2^{[\partial D]}(\xi) \right) \bigg\}. \] The normal to the meniscus is then given by \[ {\bf N} = \frac{{\bf R}_{,1} \times {\bf R}_{,2} } {|{\bf R}_{,1} \times {\bf R}_{,2}|}, \] where a comma denotes partial differentiation with respect to one of the intrinsic coordinates, $ (\zeta_1, \zeta_2). $

Along the contact line we define two unit vectors, ${\bf T}_t$ and ${\bf T}_n$, that are tangential to the meniscus. ${\bf T}_t$ is tangent to the contact line while ${\bf T}_n$ is normal to it and points away from the meniscus, as shown in the sketch below.

We split the domain boundary $ \partial D $ so that $ \partial D = \partial D_{\rm pinned} \cup \partial D_{\rm angle} $ and assume that along $\partial D_{\rm pinned}$ the meniscus is pinned, \[ \left. {\bf R} \right|_{\partial D_{\rm pinned}} = {\bf R}_{\rm pinned}(\xi), \] where ${\bf R}_{\rm pinned}(\xi) $ is given. On $\partial D_{\rm angle}$ the meniscus meets the wall at a prescribed contact angle $\gamma$ so that \[ \left. \left( ({\bf T}_t \times {\bf N}_{\rm wall}) \cdot {\bf T}_n\right) \right|_{\partial D_{angle}} = \cos \gamma, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (1) \] where ${\bf N}_{\rm wall}$ is the outer unit normal to the wall as shown in this sketch\+:

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{contact_angle_sketch}
\doxyfigcaption{Sketch of the meniscus, the contact line along which it meets the wall, and the spine-\/based representation of the meniscus. }
\end{DoxyImage}


The figure also illustrates the spine-\/based representation of the meniscus in the form \[ {\bf R}(\zeta_1,\zeta_2) = {\bf B}(\zeta_1,\zeta_2) + u(\zeta_1,\zeta_2) \ {\bf S}(\zeta_1,\zeta_2) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2) \] where the spine basis ${\bf R}(\zeta_1,\zeta_2)$ and spines ${\bf S}(\zeta_1,\zeta_2)$ are pre-\/determined vector fields, chosen such that ~\newline

\begin{DoxyItemize}
\item The mapping from $(\zeta_1,\zeta_2)$ to ${\bf R}(\zeta_1,\zeta_2)$ ~\newline
 is one-\/to-\/one, at least for the meniscus shapes of interest. ~\newline
~\newline

\item Along the parts of the boundary where the contact line is pinned we have \[ \left. {\bf B}\right|_{\partial D_{\rm pinned}} = {\bf R}_{\rm pinned} \] so that the pinned boundary condition may be enforced by setting $ u|_{\partial D_{\rm pinned}} = 0.$ ~\newline
~\newline

\end{DoxyItemize}\hypertarget{index_contact_angle_term}{}\doxysubsection{Computation of the contact-\/angle term in the variational principle}\label{index_contact_angle_term}
\href{../../young_laplace/html/index.html}{\texttt{ Recall}} that the variational principle that determines the shape of the meniscus contained the line term \[ \delta \Pi_{\rm contact \ line} = \oint_{\partial D } {\bf T}_n \cdot \delta {\bf R} \left| \frac{\partial {\bf R}} {\partial \xi}\right| \ d\xi. \] Along $ \partial D_{pinned} $ the line integral vanishes because $ \delta {\bf R}\big|_{ \partial D_{pinned} } ={\bf 0} $. The line integral can therefore be written as \[ \delta \Pi_{\rm contact \ line} = \int_{\partial D_{\rm angle}} {\bf T}_n \cdot \delta {\bf R} \left| \frac{\partial {\bf R}}{\partial \xi}\right| \ d\xi, \] or, using the spine-\/based representation of the meniscus, (2), \[ \delta \Pi_{\rm contact\ line} = \int_{\partial D_{\rm angle}} {\bf T}_n \cdot {\bf S} \ \delta u \left| \frac{\partial {\bf R}}{\partial \xi}\right| \ d\xi. \]

We shall now demonstrate that the integrand in this expression can be expressed in terms of the contact angle boundary condition (1). We start with several observations\+:
\begin{DoxyEnumerate}
\item ${\bf T}_t$ is tangential to the wall. ~\newline
~\newline

\item Since ${\bf N}_{\rm wall}$ is normal to the wall, ${\bf T}_t \times {\bf N}_{\rm wall}$ is tangential to the wall and orthogonal to ${\bf T}_t$. ~\newline
~\newline

\item ${\bf S}$ is tangential to the wall and can therefore be decomposed into its components parallel to $ {\bf T}_t $ and ${\bf T}_t \times {\bf N}_{\rm wall} $ as \[ {\bf S} = \alpha {\bf T}_t + \beta ( {\bf T}_t \times {\bf N}_{\rm wall} ) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (3) \] for some values of $\alpha$ and $\beta$. In fact, \[ \beta = {\bf S} \cdot ( {\bf T}_t \times {\bf N}_{\rm wall} ) \]
\item During the computation it is most convenient to perform all calculations in terms of quantities that are easily obtained from the parametrisation of the meniscus as this avoids having to specify ${\bf N}_{\rm wall}$ explicitly. For this purpose we exploit that ${\bf T}_t$ and ${\bf S}$ are tangential to the wall and not parallel to each other (unless the parametrisation of the meniscus by (2) is no longer one-\/to-\/one). Therefore ${\bf N}_{\rm wall}$ can be obtained from quantities that are intrinsic to the meniscus representation via ~\newline
~\newline
 \[ {\bf N}_{\rm wall} = \frac{ {\bf S} \times {\bf T}_t } {|{\bf S} \times {\bf T}_t|} \] and thus \[ \beta = {\bf S} \cdot \left( {\bf T}_t \times \frac{ {\bf S} \times {\bf T}_t } {|{\bf S} \times {\bf T}_t|} \right) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4) \]
\item Given (3) and the fact that ${\bf T}_t \cdot {\bf T}_n =0$, we have ~\newline
~\newline
 \[ {\bf S} \cdot {\bf T}_n = \beta ( {\bf T}_t \times {\bf N}_{\rm wall} ) \cdot {\bf T}_n \] and with (1)\+: \[ {\bf S} \cdot {\bf T}_n = \beta \cos \gamma. \] Hence, the line integral may be written as \[ \delta \Pi_{\rm contact\ line} = \int_{\partial D_{\rm angle}} \beta \cos \gamma \ \delta u \left| \frac{\partial {\bf R}}{\partial \xi}\right| \ d\xi, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5) \] where $ \beta $ is given by (4).
\end{DoxyEnumerate}Equation (5) is easily discretised by finite elements. Within {\ttfamily oomph-\/lib}, the line integral is decomposed into {\ttfamily Face\+Elements} that are attached to the \char`\"{}bulk\char`\"{} Young-\/\+Laplace elements that are adjacent to the contact line. The imposition of the contact angle boundary condition for the Young Laplace equation is therefore as easy as the application of Neumann boundary conditions for a Poisson equation, say.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_results}{}\doxysection{Results}\label{index_results}
The animation below illustrates the variation in the quasi-\/steady meniscus shape as the fluid enters the T-\/junction.

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{t_junction_meniscus}
\doxyfigcaption{Animation of the meniscus shapes. }
\end{DoxyImage}


The computation was performed with full spatial adaptivity. The plot below illustrates how the automatic mesh adaptation has strongly refined the mesh towards the corners of the domain where the meniscus shape has a singularity. (The singularity develops because in the corners of the domain the contact angle boundary condition along the side walls is inconsistent with the $ 90^o $ contact angle enforced by the pinned boundary condition along the sharp edges.)

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{t_junction_meniscus_adapt}
\doxyfigcaption{Illustration of the adaptive mesh refinement. }
\end{DoxyImage}


Finally, here is a plot of the \char`\"{}load-\/displacement diagram\char`\"{}, i.\+e. a plot of the meniscus deflection as a function of its curvature (i.\+e. the applied pressure drop). The limit point indicates the maximum pressure that can be withstood by the static meniscus.

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{t_junction_trace}
\doxyfigcaption{The load-\/displacement diagram for the meniscus. }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_code}{}\doxysection{The driver code}\label{index_code}
The modifications to the driver code required to impose the contact angle boundary conditions are very similar to those used in other driver codes for problems with Neumann-\/type boundary conditions. We attach {\ttfamily Face\+Elements} to the appropriate faces of the \char`\"{}bulk\char`\"{} Young-\/\+Laplace elements detach/re-\/attach them before and after any spatial adaptation of the \char`\"{}bulk\char`\"{} mesh.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_namespace}{}\doxysubsection{The global namespace}\label{index_namespace}
The namespace that defines the problem parameters is very similar to that used in the \href{../../young_laplace/html/index.html}{\texttt{ previous example}} without contact angle boundary conditions. We provide storage for the cosine of the contact angle, and the prescribed meniscus height that is used by the displacement control method.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//======start\_of\_namespace========================================}}
\DoxyCodeLine{\textcolor{comment}{/// Namespace for "{}global"{} problem parameters}}
\DoxyCodeLine{\textcolor{comment}{//================================================================}}
\DoxyCodeLine{\textcolor{keyword}{namespace }\mbox{\hyperlink{namespaceGlobalParameters}{GlobalParameters}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Cos of contact angle }}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobalParameters_ae982fcb894e82c683d07d3c2fbbead3d}{Cos\_gamma}}=cos(MathematicalConstants::Pi/6.0);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Height control value for displacement control}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobalParameters_a3731f24a02ce4f306d65a9a488f85c96}{Controlled\_height}} = 0.0;}

\end{DoxyCodeInclude}
 \href{../../young_laplace/html/index.html}{\texttt{ As before}}, we use the spine basis $ {\bf B}(\zeta_1,\zeta_2)=(\zeta_1,\zeta_2,0)^T, $ to establish a reference configuration in which the flat meniscus is located in the plane $ z=0 $ and occupies the domain $ (x,y) \in [0,L_x] \times [0,L_y]. $


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Length of domain}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobalParameters_a36ebf514fdd1e78fff69907b39e25af6}{L\_x}} = 1.0; }
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Width of domain}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobalParameters_ac8774b3418c4551091d64ec72c169b2e}{L\_y}} = 5.0; }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Spine basis}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Spine basis: The position vector to the basis of the spine}}
\DoxyCodeLine{\textcolor{comment}{ /// as a function of the two coordinates x\_1 and x\_2, and its}}
\DoxyCodeLine{\textcolor{comment}{ /// derivatives w.r.t. to these coordinates. }}
\DoxyCodeLine{\textcolor{comment}{ /// dspine\_B[i][j] = d spine\_B[j] / dx\_i}}
\DoxyCodeLine{\textcolor{comment}{ /// Spines start in the (x\_1,x\_2) plane at (x\_1,x\_2).}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespaceGlobalParameters_ac81daf87f8d3f075d9fd108427e70c4f}{spine\_base\_function}}(\textcolor{keyword}{const} Vector<double>\& x, }
\DoxyCodeLine{                          Vector<double>\& spine\_B, }
\DoxyCodeLine{                          Vector< Vector<double> >\& dspine\_B)}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  }
\DoxyCodeLine{  \textcolor{comment}{// Bspines and derivatives }}
\DoxyCodeLine{  spine\_B[0]     = x[0];}
\DoxyCodeLine{  spine\_B[1]     = x[1];}
\DoxyCodeLine{  spine\_B[2]     = 0.0 ;}
\DoxyCodeLine{  dspine\_B[0][0] = 1.0 ;}
\DoxyCodeLine{  dspine\_B[1][0] = 0.0 ;}
\DoxyCodeLine{  dspine\_B[0][1] = 0.0 ; }
\DoxyCodeLine{  dspine\_B[1][1] = 1.0 ;}
\DoxyCodeLine{  dspine\_B[0][2] = 0.0 ;}
\DoxyCodeLine{  dspine\_B[1][2] = 0.0 ;}
\DoxyCodeLine{  }
\DoxyCodeLine{ \} \textcolor{comment}{// End of bspine functions}}

\end{DoxyCodeInclude}


As in the \href{../../young_laplace/html/index.html}{\texttt{ previous example}}, we rotate the spines in the $ y $ -\/direction to allow the representation of meniscus shapes that cannot be projected onto the $ (x,y) $ -\/plane.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Spines rotate in the y-\/direction}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Min. spine angle against horizontal plane}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}} = MathematicalConstants::Pi/2.0*1.5;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Max. spine angle against horizontal plane}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}} = MathematicalConstants::Pi/2.0*0.5;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Spine: The spine vector field as a function of the two }}
\DoxyCodeLine{\textcolor{comment}{ /// coordinates x\_1 and x\_2, and its derivatives w.r.t. to these coordinates:}}
\DoxyCodeLine{\textcolor{comment}{ /// dspine[i][j] = d spine[j] / dx\_i}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespaceGlobalParameters_a82df8c67f58e78a236fb6a0cc8bf8284}{spine\_function}}(\textcolor{keyword}{const} Vector<double>\& x, }
\DoxyCodeLine{                     Vector<double>\& spine, }
\DoxyCodeLine{                     Vector< Vector<double> >\& dspine)}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{  /// Spines (and derivatives)  are independent of x[0] and rotate }}
\DoxyCodeLine{\textcolor{comment}{  /// in the x[1]-\/direction}}
\DoxyCodeLine{\textcolor{comment}{}  spine[0]=0.0;}
\DoxyCodeLine{  dspine[0][0]=0.0; }
\DoxyCodeLine{  dspine[1][0]=0.0; }
\DoxyCodeLine{  }
\DoxyCodeLine{  spine[1]=cos(\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}}+(\mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}}-\/\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}})*x[1]/\mbox{\hyperlink{namespaceGlobalParameters_ac8774b3418c4551091d64ec72c169b2e}{L\_y}}); }
\DoxyCodeLine{  dspine[0][1]=0.0;                                   }
\DoxyCodeLine{  dspine[1][1]=-\/sin(\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}}+(\mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}}-\/\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}})*x[1]/\mbox{\hyperlink{namespaceGlobalParameters_ac8774b3418c4551091d64ec72c169b2e}{L\_y}})}
\DoxyCodeLine{   *(\mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}}-\/\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}})/\mbox{\hyperlink{namespaceGlobalParameters_ac8774b3418c4551091d64ec72c169b2e}{L\_y}};            }
\DoxyCodeLine{  }
\DoxyCodeLine{  spine[2]=sin(\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}}+(\mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}}-\/\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}})*x[1]/\mbox{\hyperlink{namespaceGlobalParameters_ac8774b3418c4551091d64ec72c169b2e}{L\_y}});}
\DoxyCodeLine{  dspine[0][2]=0.0;                                  }
\DoxyCodeLine{  dspine[1][2]=cos(\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}}+(\mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}}-\/\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}})*x[1]/\mbox{\hyperlink{namespaceGlobalParameters_ac8774b3418c4551091d64ec72c169b2e}{L\_y}}) }
\DoxyCodeLine{   *(\mbox{\hyperlink{namespaceGlobalParameters_a19d04a02b0b5ef5c72e9c30d822e4dc7}{Alpha\_max}}-\/\mbox{\hyperlink{namespaceGlobalParameters_ae8fa7610a34b7a2a8223eade99a5c22f}{Alpha\_min}})/\mbox{\hyperlink{namespaceGlobalParameters_ac8774b3418c4551091d64ec72c169b2e}{L\_y}};            }
\DoxyCodeLine{}
\DoxyCodeLine{ \} \textcolor{comment}{// End spine function}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of namespace}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysubsection{The driver code}\label{index_main}
We start by defining the output directory and open a trace file to record the load-\/displacement curve.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===============start\_of\_main============================================}}
\DoxyCodeLine{\textcolor{comment}{/// Drive code}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keywordtype}{int} \mbox{\hyperlink{refineable__t__junction_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Create label for output}}
\DoxyCodeLine{ DocInfo doc\_info;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Trace file}}
\DoxyCodeLine{ ofstream trace\_file;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Set output directory}}
\DoxyCodeLine{ doc\_info.set\_directory(\textcolor{stringliteral}{"{}RESLT"{}});}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Open a trace file}}
\DoxyCodeLine{ \textcolor{keywordtype}{char} filename[100];}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/trace.dat"{}},doc\_info.directory().c\_str());}
\DoxyCodeLine{ trace\_file.open(filename);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Tecplot header for trace file: kappa and height value}}
\DoxyCodeLine{ trace\_file << \textcolor{stringliteral}{"{}VARIABLES=\(\backslash\)"{}<GREEK>k</GREEK>\(\backslash\)"{},\(\backslash\)"{}h\(\backslash\)"{}"{}} << std::endl;}
\DoxyCodeLine{ trace\_file << \textcolor{stringliteral}{"{}ZONE"{}} << std::endl;}

\end{DoxyCodeInclude}


Next, we create the problem object, refine the mesh uniformly and output the initial guess for the solution\+: a flat interface which, unlike the \href{../../young_laplace/html/index.html}{\texttt{ previous case}}, is not a solution of the problem because it does not satisfy the contact-\/angle boundary condition; see the section \mbox{\hyperlink{index_comm_ex}{Comments and Exercises}} for a more detailed discussion of this issue.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{//Set up the problem}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Create the problem with 2D nine-\/node elements from the}}
\DoxyCodeLine{ \textcolor{comment}{// RefineableQYoungLaplaceElement family. }}
\DoxyCodeLine{ \mbox{\hyperlink{classRefineableYoungLaplaceProblem}{RefineableYoungLaplaceProblem<RefineableQYoungLaplaceElement<3>}} > problem;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Perform one uniform refinement}}
\DoxyCodeLine{ problem.refine\_uniformly();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{//Output the solution}}
\DoxyCodeLine{ problem.\mbox{\hyperlink{classRefineableYoungLaplaceProblem_a4ec7313c8e4015b0c2af0bbef789e70f}{doc\_solution}}(doc\_info,trace\_file);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{//Increment counter for solutions }}
\DoxyCodeLine{ doc\_info.number()++;}

\end{DoxyCodeInclude}
 Finally, we perform a parameter study by slowly incrementing the control displacement and recomputing the meniscus shape.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Parameter incrementation}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ }}
\DoxyCodeLine{ \textcolor{keywordtype}{double} increment=0.1;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Loop over steps}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nstep=2; \textcolor{comment}{// 10;}}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} istep=0;istep<nstep;istep++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \mbox{\hyperlink{namespaceGlobalParameters_a3731f24a02ce4f306d65a9a488f85c96}{GlobalParameters::Controlled\_height}}+=increment;}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Solve the problem  }}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} max\_adapt=1;}
\DoxyCodeLine{   problem.newton\_solve(max\_adapt);}
\DoxyCodeLine{ }
\DoxyCodeLine{   \textcolor{comment}{//Output the solution}}
\DoxyCodeLine{   problem.\mbox{\hyperlink{classRefineableYoungLaplaceProblem_a4ec7313c8e4015b0c2af0bbef789e70f}{doc\_solution}}(doc\_info,trace\_file);}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{//Increment counter for solutions }}
\DoxyCodeLine{   doc\_info.number()++;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Close output file}}
\DoxyCodeLine{ trace\_file.close();}
\DoxyCodeLine{ }
\DoxyCodeLine{\} \textcolor{comment}{//end of main}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_class}{}\doxysubsection{The problem class}\label{index_class}
The problem class contains the usual member functions. The functions {\ttfamily actions\+\_\+before\+\_\+adapt()} and {\ttfamily actions\+\_\+after\+\_\+adapt()} are used to detach and re-\/attach (and rebuild) the contact angle elements on the appropriate boundaries of the \char`\"{}bulk\char`\"{} mesh.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//====== start\_of\_problem\_class=======================================}}
\DoxyCodeLine{\textcolor{comment}{/// 2D RefineableYoungLaplace problem on rectangular domain, discretised with}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{/// 2D QRefineableYoungLaplace elements. The specific type of element is}}
\DoxyCodeLine{\textcolor{comment}{/// specified via the template parameter.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT> }
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{classRefineableYoungLaplaceProblem}{RefineableYoungLaplaceProblem}} : \textcolor{keyword}{public} Problem}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Constructor: }}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a78f77a299f2770a82378fcccf86a0b71}{RefineableYoungLaplaceProblem}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Destructor (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a24b45d5ecdd1d7dbb678e7f74777bf41}{\string~RefineableYoungLaplaceProblem}}()\{\};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem specs before solve: Empty}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a2807bb8cddbfa553df9f5dd170c8645d}{actions\_before\_newton\_solve}}()\{\};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem after solve: Empty}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a0791c90a16016372e09faf3f5721ecbe}{actions\_after\_newton\_solve}}()\{\};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Actions before adapt: Wipe the mesh of contact angle elements}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableYoungLaplaceProblem_ab64eb0b58beb3bb096ecc81b1a3f8a4f}{actions\_before\_adapt}}()}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Kill the contact angle elements and wipe contact angle mesh}}
\DoxyCodeLine{   \textcolor{keywordflow}{if} (\mbox{\hyperlink{classRefineableYoungLaplaceProblem_a36f5dc0f7071ac15fd63c7c477f77fb0}{Contact\_angle\_mesh\_pt}}!=0) \mbox{\hyperlink{classRefineableYoungLaplaceProblem_aaa270ba8da395897a5a99d052f076e0c}{delete\_contact\_angle\_elements}}();}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-\/meshes}}
\DoxyCodeLine{   rebuild\_global\_mesh();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ ///  Actions after adapt: Rebuild the mesh of contact angle elements}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableYoungLaplaceProblem_aa2eab8da1b83091df804ede7c60fac87}{actions\_after\_adapt}}()}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a00d1304e030120e76d9f316dd4053116}{create\_contact\_angle\_elements}}(1);}
\DoxyCodeLine{   \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a00d1304e030120e76d9f316dd4053116}{create\_contact\_angle\_elements}}(3);}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Set function pointers for contact-\/angle elements}}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} nel=\mbox{\hyperlink{classRefineableYoungLaplaceProblem_a36f5dc0f7071ac15fd63c7c477f77fb0}{Contact\_angle\_mesh\_pt}}-\/>nelement();}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<nel;e++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{comment}{// Upcast from GeneralisedElement to YoungLaplace contact angle}}
\DoxyCodeLine{     \textcolor{comment}{// element}}
\DoxyCodeLine{     YoungLaplaceContactAngleElement<ELEMENT> *el\_pt = }
\DoxyCodeLine{      \textcolor{keyword}{dynamic\_cast<}YoungLaplaceContactAngleElement<ELEMENT>*\textcolor{keyword}{>}(}
\DoxyCodeLine{       \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a36f5dc0f7071ac15fd63c7c477f77fb0}{Contact\_angle\_mesh\_pt}}-\/>element\_pt(e));}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Set the pointer to the prescribed contact angle}}
\DoxyCodeLine{     el\_pt-\/>prescribed\_cos\_gamma\_pt() = \&\mbox{\hyperlink{namespaceGlobalParameters_ae982fcb894e82c683d07d3c2fbbead3d}{GlobalParameters::Cos\_gamma}};}
\DoxyCodeLine{    \}}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-\/meshes}}
\DoxyCodeLine{   rebuild\_global\_mesh();}
\DoxyCodeLine{   }
\DoxyCodeLine{  \}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Doc the solution. DocInfo object stores flags/labels for where the}}
\DoxyCodeLine{\textcolor{comment}{ /// output gets written to and the trace file}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a4ec7313c8e4015b0c2af0bbef789e70f}{doc\_solution}}(DocInfo\& doc\_info, ofstream\& trace\_file);}

\end{DoxyCodeInclude}


Two private helper functions are provided to create and delete the contact angle elements. The class also provides storage for the pointers to the various meshes, to the node at which the meniscus displacement is prescribed by the displacement control method, and to the {\ttfamily Data} object whose one-\/and-\/only value stores the (unknown) meniscus curvature.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Create YoungLaplace contact angle elements on the }}
\DoxyCodeLine{\textcolor{comment}{ /// b-\/th boundary of the bulk mesh and add them to contact angle mesh}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} create\_contact\_angle\_elements(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& b);}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Delete contact angle elements }}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} delete\_contact\_angle\_elements();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to the "{}bulk"{} mesh}}
\DoxyCodeLine{\textcolor{comment}{} RefineableRectangularQuadMesh<ELEMENT>* Bulk\_mesh\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to the contact angle mesh}}
\DoxyCodeLine{\textcolor{comment}{} Mesh* Contact\_angle\_mesh\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to mesh containing the height control element}}
\DoxyCodeLine{\textcolor{comment}{} Mesh* Height\_control\_mesh\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Node at which the height (displacement along spine) is controlled/doced}}
\DoxyCodeLine{\textcolor{comment}{} Node* Control\_node\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to Data object that stores the prescribed curvature}}
\DoxyCodeLine{\textcolor{comment}{} Data* \mbox{\hyperlink{namespaceGlobalParameters_ac6234184cce40ab2c6bec92b37e4ae41}{Kappa\_pt}};}
\DoxyCodeLine{}
\DoxyCodeLine{\}; \textcolor{comment}{// end of problem class}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_constr}{}\doxysubsection{The problem constructor}\label{index_constr}
We start by creating the \char`\"{}bulk\char`\"{} mesh of refineable Young Laplace elements and specify the error estimator.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====start\_of\_constructor===============================================}}
\DoxyCodeLine{\textcolor{comment}{/// Constructor for RefineableYoungLaplace problem}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\mbox{\hyperlink{classRefineableYoungLaplaceProblem_a78f77a299f2770a82378fcccf86a0b71}{RefineableYoungLaplaceProblem<ELEMENT>::RefineableYoungLaplaceProblem}}()}
\DoxyCodeLine{\{ }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup bulk mesh}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// \# of elements in x-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_x=8;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// \# of elements in y-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_y=8;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Domain length in x-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} l\_x=\mbox{\hyperlink{namespaceGlobalParameters_a36ebf514fdd1e78fff69907b39e25af6}{GlobalParameters::L\_x}};}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Domain length in y-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} l\_y=\mbox{\hyperlink{namespaceGlobalParameters_ac8774b3418c4551091d64ec72c169b2e}{GlobalParameters::L\_y}};}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Build and assign mesh}}
\DoxyCodeLine{ Bulk\_mesh\_pt=\textcolor{keyword}{new} RefineableRectangularQuadMesh<ELEMENT>(n\_x,n\_y,l\_x,l\_y);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Create/set error estimator}}
\DoxyCodeLine{ Bulk\_mesh\_pt-\/>spatial\_error\_estimator\_pt()=\textcolor{keyword}{new} Z2ErrorEstimator;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set targets for spatial adaptivity}}
\DoxyCodeLine{ Bulk\_mesh\_pt-\/>max\_permitted\_error()=1.0e-\/4;}
\DoxyCodeLine{ Bulk\_mesh\_pt-\/>min\_permitted\_error()=1.0e-\/6;}

\end{DoxyCodeInclude}
 We identify the node (in the centre of the mesh) at which we apply displacement control. We pass a pointer to this node to the constructor of the displacement control element and store that element in its own mesh.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Check that we've got an even number of elements otherwise}}
\DoxyCodeLine{ \textcolor{comment}{// out counting doesn't work...}}
\DoxyCodeLine{ \textcolor{keywordflow}{if} ((n\_x\%2!=0)||(n\_y\%2!=0))}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   cout << \textcolor{stringliteral}{"{}n\_x n\_y should be even"{}} << endl;}
\DoxyCodeLine{   abort();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  }
\DoxyCodeLine{ \textcolor{comment}{//  This is the element that contains the central node:}}
\DoxyCodeLine{ ELEMENT* prescribed\_height\_element\_pt= \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(}
\DoxyCodeLine{  Bulk\_mesh\_pt-\/>element\_pt(n\_y*n\_x/2+n\_x/2));}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// The central node is node 0 in that element}}
\DoxyCodeLine{ Control\_node\_pt= \textcolor{keyword}{static\_cast<}Node*\textcolor{keyword}{>}(prescribed\_height\_element\_pt-\/>node\_pt(0));}
\DoxyCodeLine{}
\DoxyCodeLine{ std::cout << \textcolor{stringliteral}{"{}Controlling height at (x,y) : ("{}} << Control\_node\_pt-\/>x(0) }
\DoxyCodeLine{           << \textcolor{stringliteral}{"{},"{}} << Control\_node\_pt-\/>x(1)  << \textcolor{stringliteral}{"{})"{}} << \textcolor{stringliteral}{"{}\(\backslash\)n"{}} << endl;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Create a height control element and store the}}
\DoxyCodeLine{ \textcolor{comment}{// pointer to the Kappa Data created by this object}}
\DoxyCodeLine{ HeightControlElement* height\_control\_element\_pt=\textcolor{keyword}{new} HeightControlElement(}
\DoxyCodeLine{  Control\_node\_pt,\&\mbox{\hyperlink{namespaceGlobalParameters_a3731f24a02ce4f306d65a9a488f85c96}{GlobalParameters::Controlled\_height}});}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Add to mesh}}
\DoxyCodeLine{ Height\_control\_mesh\_pt = \textcolor{keyword}{new} Mesh;}
\DoxyCodeLine{ Height\_control\_mesh\_pt-\/>add\_element\_pt(height\_control\_element\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Store curvature data}}
\DoxyCodeLine{ \mbox{\hyperlink{namespaceGlobalParameters_ac6234184cce40ab2c6bec92b37e4ae41}{Kappa\_pt}}=height\_control\_element\_pt-\/>kappa\_pt();}

\end{DoxyCodeInclude}
 Next we create the mesh that stores the contact-\/angle elements. We attach these elements to boundaries 1 and 3 of the \char`\"{}bulk\char`\"{} mesh.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Contact angle elements}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Create prescribed-\/contact-\/angle elements from all elements that are }}
\DoxyCodeLine{ \textcolor{comment}{// adjacent to boundary 1 and 3 and add them to their own mesh}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// set up new mesh}}
\DoxyCodeLine{ Contact\_angle\_mesh\_pt=\textcolor{keyword}{new} Mesh;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// creation of contact angle elements}}
\DoxyCodeLine{ create\_contact\_angle\_elements(1);}
\DoxyCodeLine{ create\_contact\_angle\_elements(3);}

\end{DoxyCodeInclude}
 The various sub-\/meshes are now added to the problem and the global mesh is built.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Add various meshes and build the global mesh}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ add\_sub\_mesh(Bulk\_mesh\_pt);}
\DoxyCodeLine{ add\_sub\_mesh(Height\_control\_mesh\_pt);}
\DoxyCodeLine{ add\_sub\_mesh(Contact\_angle\_mesh\_pt);}
\DoxyCodeLine{ build\_global\_mesh();}

\end{DoxyCodeInclude}
 As usual, we enforce only the essential boundary conditions directly by pinning the meniscus displacement along mesh boundaries 0 and 2\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Boundary conditions}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}}
\DoxyCodeLine{ \textcolor{comment}{// free by default -\/-\/ only need to pin the ones that have Dirichlet conditions}}
\DoxyCodeLine{ \textcolor{comment}{// here. }}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_bound = Bulk\_mesh\_pt-\/>nboundary(); }
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} b=0;b<n\_bound;b++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Pin all boundaries for three cases and only boundaries}}
\DoxyCodeLine{   \textcolor{comment}{// 0 and 2 in all others:}}
\DoxyCodeLine{   \textcolor{keywordflow}{if} ((b==0)||(b==2))}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt-\/>nboundary\_node(b);}
\DoxyCodeLine{     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       Bulk\_mesh\_pt-\/>boundary\_node\_pt(b,n)-\/>pin(0); }
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \} \textcolor{comment}{// end bcs}}

\end{DoxyCodeInclude}
 The build of the \char`\"{}bulk\char`\"{} Young Laplace elements is completed by specifying the function pointers to the spine functions and the pointer to the {\ttfamily Data} object that stores the curvature.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Complete build of elements}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Complete the build of all elements so they are fully functional }}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_bulk=Bulk\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_bulk;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Upcast from GeneralsedElement to the present element}}
\DoxyCodeLine{   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt-\/>element\_pt(i));}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{//Set the spine function pointers}}
\DoxyCodeLine{   el\_pt-\/>spine\_base\_fct\_pt() = \mbox{\hyperlink{namespaceGlobalParameters_ac81daf87f8d3f075d9fd108427e70c4f}{GlobalParameters::spine\_base\_function}};}
\DoxyCodeLine{   el\_pt-\/>spine\_fct\_pt() =  \mbox{\hyperlink{namespaceGlobalParameters_a82df8c67f58e78a236fb6a0cc8bf8284}{GlobalParameters::spine\_function}};}
\DoxyCodeLine{  }
\DoxyCodeLine{   \textcolor{comment}{// Set the curvature data for the element}}
\DoxyCodeLine{   el\_pt-\/>set\_kappa(\mbox{\hyperlink{namespaceGlobalParameters_ac6234184cce40ab2c6bec92b37e4ae41}{Kappa\_pt}}); }
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
 Finally, we complete the build of the contact line elements by passing the pointer to the double that stores the cosine of the contact angle.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Set function pointers for contact-\/angle elements}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nel=Contact\_angle\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<nel;e++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Upcast from GeneralisedElement to YoungLaplace contact angle }}
\DoxyCodeLine{   \textcolor{comment}{// element}}
\DoxyCodeLine{   YoungLaplaceContactAngleElement<ELEMENT> *el\_pt = }
\DoxyCodeLine{    \textcolor{keyword}{dynamic\_cast<}YoungLaplaceContactAngleElement<ELEMENT>*\textcolor{keyword}{>}(}
\DoxyCodeLine{     Contact\_angle\_mesh\_pt-\/>element\_pt(e));}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Set the pointer to the prescribed contact angle}}
\DoxyCodeLine{   el\_pt-\/>prescribed\_cos\_gamma\_pt() = \&\mbox{\hyperlink{namespaceGlobalParameters_ae982fcb894e82c683d07d3c2fbbead3d}{GlobalParameters::Cos\_gamma}};}
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
 All that\textquotesingle{}s now left to do is to assign the equation numbers\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup equation numbering scheme}}
\DoxyCodeLine{ cout <<\textcolor{stringliteral}{"{}\(\backslash\)nNumber of equations: "{}} << assign\_eqn\_numbers() << endl; }
\DoxyCodeLine{ cout << \textcolor{stringliteral}{"{}\(\backslash\)n********************************************\(\backslash\)n"{}} <<  endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of constructor}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_create}{}\doxysubsection{Creating the contact angle elements}\label{index_create}
The function {\ttfamily create\+\_\+contact\+\_\+angle\+\_\+elements()} attaches the {\ttfamily Face\+Elements} that apply the contact angle boundary condition to the specified boundary of the \char`\"{}bulk\char`\"{} mesh. Pointers to the newly-\/created {\ttfamily Face\+Elements} are stored in a separate mesh.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//============start\_of\_create\_contact\_angle\_elements=====================}}
\DoxyCodeLine{\textcolor{comment}{/// Create YoungLaplace contact angle elements on the b-\/th boundary of the }\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{/// bulk mesh and add them to the contact angle mesh}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//=======================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a00d1304e030120e76d9f316dd4053116}{RefineableYoungLaplaceProblem<ELEMENT>::create\_contact\_angle\_elements}}(}
\DoxyCodeLine{ \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \&b)}
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_element = Bulk\_mesh\_pt-\/>nboundary\_element(b);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b?}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}}
\DoxyCodeLine{   ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(}
\DoxyCodeLine{    Bulk\_mesh\_pt-\/>boundary\_element\_pt(b,e));}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// What is the index of the face of the bulk element at the boundary}}
\DoxyCodeLine{   \textcolor{keywordtype}{int} face\_index = Bulk\_mesh\_pt-\/>face\_index\_at\_boundary(b,e);}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Build the corresponding contact angle element}}
\DoxyCodeLine{   YoungLaplaceContactAngleElement<ELEMENT>* contact\_angle\_element\_pt = \textcolor{keyword}{new} }
\DoxyCodeLine{   YoungLaplaceContactAngleElement<ELEMENT>(bulk\_elem\_pt,face\_index);}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{//Add the contact angle element to the contact angle mesh}}
\DoxyCodeLine{   Contact\_angle\_mesh\_pt-\/>add\_element\_pt(contact\_angle\_element\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{  \} \textcolor{comment}{//end of loop over bulk elements adjacent to boundary b}}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of create\_contact\_angle\_elements}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_delete}{}\doxysubsection{Deleting the contact angle elements}\label{index_delete}
The function {\ttfamily delete\+\_\+contact\+\_\+angle\+\_\+elements()} deletes the contact angle elements and flushes the associated mesh.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//============start\_of\_delete\_contact\_angle\_elements=====================}}
\DoxyCodeLine{\textcolor{comment}{/// Delete YoungLaplace contact angle elements}}
\DoxyCodeLine{\textcolor{comment}{//=======================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableYoungLaplaceProblem_aaa270ba8da395897a5a99d052f076e0c}{RefineableYoungLaplaceProblem<ELEMENT>::delete\_contact\_angle\_elements}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// How many contact angle elements are there?}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_element = Contact\_angle\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Loop over the surface elements}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Kill surface element}}
\DoxyCodeLine{   \textcolor{keyword}{delete} Contact\_angle\_mesh\_pt-\/>element\_pt(e);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Wipe the mesh}}
\DoxyCodeLine{ Contact\_angle\_mesh\_pt-\/>flush\_element\_and\_node\_storage();}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of delete\_contact\_angle\_elements}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_doc}{}\doxysubsection{Post-\/processing}\label{index_doc}
We output the load-\/displacement data, the meniscus shape, and various contact line quantities.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===============start\_of\_doc=============================================}}
\DoxyCodeLine{\textcolor{comment}{/// Doc the solution: doc\_info contains labels/output directory etc.}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableYoungLaplaceProblem_a4ec7313c8e4015b0c2af0bbef789e70f}{RefineableYoungLaplaceProblem<ELEMENT>::doc\_solution}}(DocInfo\& doc\_info,}
\DoxyCodeLine{                                              ofstream\& trace\_file)}
\DoxyCodeLine{\{ }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Output kappa vs height}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ trace\_file << -\/1.0*\mbox{\hyperlink{namespaceGlobalParameters_ac6234184cce40ab2c6bec92b37e4ae41}{Kappa\_pt}}-\/>value(0) << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{ trace\_file << Control\_node\_pt-\/>value(0) ;}
\DoxyCodeLine{ trace\_file << endl;}
\DoxyCodeLine{  }
\DoxyCodeLine{ \textcolor{comment}{// Number of plot points: npts x npts}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} npts=5;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Output full solution }}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ ofstream some\_file;}
\DoxyCodeLine{ \textcolor{keywordtype}{char} filename[100];}
\DoxyCodeLine{ \textcolor{comment}{//YoungLaplaceEquations::Output\_meniscus\_and\_spines=false;}}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/soln\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ Bulk\_mesh\_pt-\/>output(some\_file,npts);}
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Output contact angle }}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ ofstream tangent\_file;}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/tangent\_to\_contact\_line\%i.dat"{}},}
\DoxyCodeLine{         doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ tangent\_file.open(filename);}
\DoxyCodeLine{ }
\DoxyCodeLine{ ofstream normal\_file;}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/normal\_to\_contact\_line\%i.dat"{}},}
\DoxyCodeLine{         doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ normal\_file.open(filename);}
\DoxyCodeLine{ }
\DoxyCodeLine{ }
\DoxyCodeLine{ ofstream contact\_angle\_file;}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/contact\_angle\%i.dat"{}},}
\DoxyCodeLine{         doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ contact\_angle\_file.open(filename);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Tangent and normal vectors to contact line}}
\DoxyCodeLine{ Vector<double> tangent(3);}
\DoxyCodeLine{ Vector<double> normal(3);}
\DoxyCodeLine{ Vector<double> r\_contact(3);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// How many contact angle elements are there?}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_element = Contact\_angle\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Loop over the surface elements}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   }
\DoxyCodeLine{   tangent\_file << \textcolor{stringliteral}{"{}ZONE"{}} << std::endl;}
\DoxyCodeLine{   normal\_file << \textcolor{stringliteral}{"{}ZONE"{}} << std::endl;}
\DoxyCodeLine{   contact\_angle\_file << \textcolor{stringliteral}{"{}ZONE"{}} << std::endl;}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Upcast from GeneralisedElement to YoungLaplace contact angle element}}
\DoxyCodeLine{   YoungLaplaceContactAngleElement<ELEMENT>* el\_pt = }
\DoxyCodeLine{    \textcolor{keyword}{dynamic\_cast<}YoungLaplaceContactAngleElement<ELEMENT>*\textcolor{keyword}{>}(}
\DoxyCodeLine{     Contact\_angle\_mesh\_pt-\/>element\_pt(e));}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Loop over a few points in the contact angle element}}
\DoxyCodeLine{   Vector<double> s(1);}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<npts;i++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     s[0]=-\/1.0+2.0*double(i)/double(npts-\/1);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(el\_pt-\/>bulk\_element\_pt())-\/>}
\DoxyCodeLine{      position(el\_pt-\/>local\_coordinate\_in\_bulk(s),r\_contact);}
\DoxyCodeLine{     }
\DoxyCodeLine{     el\_pt-\/>contact\_line\_vectors(s,tangent,normal);}
\DoxyCodeLine{     tangent\_file << r\_contact[0] << \textcolor{stringliteral}{"{} "{}} }
\DoxyCodeLine{                  << r\_contact[1] << \textcolor{stringliteral}{"{} "{}} }
\DoxyCodeLine{                  << r\_contact[2] << \textcolor{stringliteral}{"{} "{}} }
\DoxyCodeLine{                  << tangent[0] << \textcolor{stringliteral}{"{} "{}} }
\DoxyCodeLine{                  << tangent[1] << \textcolor{stringliteral}{"{} "{}} }
\DoxyCodeLine{                  << tangent[2] << \textcolor{stringliteral}{"{} "{}}  << std::endl;}
\DoxyCodeLine{     }
\DoxyCodeLine{     normal\_file << r\_contact[0] << \textcolor{stringliteral}{"{} "{}} }
\DoxyCodeLine{                 << r\_contact[1] << \textcolor{stringliteral}{"{} "{}} }
\DoxyCodeLine{                 << r\_contact[2] << \textcolor{stringliteral}{"{} "{}} }
\DoxyCodeLine{                 << normal[0] << \textcolor{stringliteral}{"{} "{}} }
\DoxyCodeLine{                 << normal[1] << \textcolor{stringliteral}{"{} "{}} }
\DoxyCodeLine{                 << normal[2] << \textcolor{stringliteral}{"{} "{}}  << std::endl;}
\DoxyCodeLine{     }
\DoxyCodeLine{     contact\_angle\_file << r\_contact[1] << \textcolor{stringliteral}{"{} "{}} }
\DoxyCodeLine{                        << el\_pt-\/>actual\_cos\_contact\_angle(s)}
\DoxyCodeLine{                        << std::endl;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{   }
\DoxyCodeLine{   }
\DoxyCodeLine{  \} \textcolor{comment}{// end of loop over both boundaries}}
\DoxyCodeLine{ }
\DoxyCodeLine{ tangent\_file.close();}
\DoxyCodeLine{ normal\_file.close();}
\DoxyCodeLine{ contact\_angle\_file.close();}
\DoxyCodeLine{ }
\DoxyCodeLine{}
\DoxyCodeLine{cout << \textcolor{stringliteral}{"{}\(\backslash\)n********************************************"{}} << endl <<  endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of doc}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comm_ex}{}\doxysection{Comments and Exercises}\label{index_comm_ex}
\hypertarget{index_ic}{}\doxysubsection{How to generate a good initial guess for the solution}\label{index_ic}
We already commented on the need to provide a \char`\"{}good\char`\"{} initial guess for the solution in order to ensure the convergence of the Newton iteration. In the \href{../../young_laplace/html/index.html}{\texttt{ previous example}} this was easy because the flat meniscus (clearly a solution of the Young-\/\+Laplace equations for zero curvature) also satisfied the boundary conditions. In the present example, and in many others, this is not the case. In such problems it may be difficult to generate initial guesses for the meniscus shape that are sufficiently close to actual solution.

In such cases it may be necessary to compute the initial solution to the problem whose behaviour we wish to investigate during the actual parameter study via a preliminary auxiliary continuation procedure that transforms an easier-\/solve-\/problem (for which a good initial guess can be found) into the actual problem.

Explore this approach in the present problem by implementing the following steps\+:
\begin{DoxyEnumerate}
\item Set the contact angle to $ 90^o $ and solve the problem, using the \char`\"{}flat\char`\"{} meniscus as the initial guess. The \char`\"{}flat\char`\"{} meniscus is, of course, the exact solution for zero control displacement and/or zero curvature. ~\newline
~\newline

\item Now start a preliminary continuation procedure in which the contact angle is adjusted in small steps until it reaches the desired value. Keep the prescribed control displacement (or the meniscus curvature) constant during this procedure. ~\newline
~\newline

\item The solution for the desired contact angle may now be used as the initial guess for the actual parameter study in which the control displacement (or the meniscus curvature) are increased while the contact angle is kept fixed.
\end{DoxyEnumerate}\hypertarget{index_lim}{}\doxysubsection{Limitations of the current approach  suggestions for improvement}\label{index_lim}
One of the main disadvantages of the approach adopted here is that the spine vector fields $ {\bf B} $ and $ {\bf S} $ must be specified {\itshape a priori}. For sufficiently complicated meniscus shapes (or for menisci that undergo large changes in shape as their curvature is varied) the choice of suitable spines may be very difficult. ~\newline
~\newline
One (possible) solution to this problem could be (we haven\textquotesingle{}t tried it!) to occasionally update the spine representation. For instance, assume that we have computed a meniscus shape in the form ~\newline
~\newline
 \[ \widehat{\bf R} = {\bf R}(\zeta_1,\zeta_2) = {\bf B}(\zeta_1,\zeta_2) + u(\zeta_1,\zeta_2) \ {\bf S}(\zeta_1,\zeta_2) \] with an associated normal vector $ \widehat{\bf N} $. We can reparametrise this shape by setting \[ {\bf B} := \widehat{\bf R}, \] \[ {\bf S} := \widehat{\bf N}, \] and ~\newline
 \[ u := 0 \] before continuing the computation. Provided this is done sufficiently frequently, i.\+e. long before the displacement along the spines has become so large that the mapping from $ (\zeta_1,\zeta_2) $ to $ {\bf R}(\zeta_1,\zeta_2)$ is about to become non-\/one-\/to-\/one, this should allow the computation of arbitrarily large meniscus deflections. Try it out and let us know how it works! ~\newline
~\newline
 \hypertarget{index_zero}{}\doxysubsection{Zero contact angles}\label{index_zero}
Our problem formulation suffers from an additional, more fundamental problem\+: it cannot be used to solve problems with zero contact angle. This is because for zero contact angles the equilibrium solution is no longer a minimiser of the variational principle\+: given a solution at which the meniscus meets the wall at zero contact angle, it is always possible to extend the meniscus with an arbitrary-\/length \char`\"{}collar\char`\"{} along the wall without changing the overall energy of the system. As a result, the position of the contact line becomes increasingly ill-\/defined as the contact angle $ \gamma $ is reduced, causing the Newton method to converge very slowly (and ultimately not at all) as $ \gamma \to 0. $

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/young_laplace/}{\texttt{ demo\+\_\+drivers/young\+\_\+laplace/ }} \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/young_laplace/refineable_t_junction.cc}{\texttt{ demo\+\_\+drivers/young\+\_\+laplace/refineable\+\_\+t\+\_\+junction.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{PDF file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
