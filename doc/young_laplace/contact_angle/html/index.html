<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Example problem: The Young Laplace equation with contact angle boundary conditions</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Get it <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/subversion/html/index.html">Get code from subversion repository</a></li>
            <li><a href="../../../../doc/download/html/index.html">Get code as tar file</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Example problem: The Young Laplace equation with contact angle boundary conditions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this document we demonstrate the adaptive solution of the Young Laplace equation with contact angle boundary conditions. We start by reviewing the physical background in the context of a representative model problem, and then discuss the spine-based representation of free contact lines and the implementation of the contact angle boundary condition along such lines.</p>
<center> <table border="1," width="500px">
<tr>
<td bgcolor="cornsilk"><center> <b>Acknowledgement:</b> </center> This tutorial and the associated driver codes were developed jointly with Cedric Ody (Ecole Polytechnique, Paris; now Rennes). <br  />
<br  />
  </td></tr>
</table>
</center><hr  />
 <hr  />
<h1><a class="anchor" id="model"></a>
A model problem</h1>
<p>The figure below shows a sketch of a T-junction in a microchannel with a rectangular cross-section. (The front wall has been removed for clarity). Fluid is being pushed quasi-steadily along the (vertical) main channel and is in the process of entering the T-junction. We assume that the air-liquid interface (shown in red) remains pinned at the two sharp edges (at <img class="formulaInl" alt="$ y=const.$" src="form_0.png"/>) where the channels meet, while the meniscus forms a quasi-static contact angle, <img class="formulaInl" alt="$ \gamma $" src="form_1.png"/>, with the smooth front and back walls.</p>
<div class="image">
<img src="t_junction_contact_angle_sketch.gif" alt=""/>
<div class="caption">
A typical problem: Fluid propagates quasi-steadily through a T-junction that connects two channels of rectangular cross-section. </div></div>
 <p>It is of interest to determine the maximum pressure that the meniscus can withstand: if the driving pressure is less than that value, the fluid will not be able to propagate past the T-junction.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="theory"></a>
Theory and implementation</h1>
<h2><a class="anchor" id="spine"></a>
Spine-based representation of the meniscus</h2>
<p><a href="../../young_laplace/html/index.html">Recall</a> that we parametrised the meniscus by two intrinsic coordinates as <img class="formulaInl" alt="$ {\bf R}(\zeta_1,\zeta_2) \in {R}^3 $" src="form_2.png"/>, where <img class="formulaInl" alt="$(\zeta_1,\zeta_2) \in D \in {R}^2$" src="form_3.png"/>. Furthermore, we parametrised the domain boundary, <img class="formulaInl" alt="$\partial D$" src="form_4.png"/>, by a scalar coordinate <img class="formulaInl" alt="$\xi$" src="form_5.png"/> so that, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\partial D} = \bigg\{ (\zeta_1,\zeta_2) \ \bigg| \ (\zeta_1,\zeta_2) = \left( \zeta_1^{[\partial D]}(\xi), \ \zeta_2^{[\partial D]}(\xi) \right) \bigg\}. \]" src="form_6.png"/>
</p>
<p> The normal to the meniscus is then given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf N} = \frac{{\bf R}_{,1} \times {\bf R}_{,2} } {|{\bf R}_{,1} \times {\bf R}_{,2}|}, \]" src="form_7.png"/>
</p>
<p> where a comma denotes partial differentiation with respect to one of the intrinsic coordinates, <img class="formulaInl" alt="$ (\zeta_1, \zeta_2). $" src="form_8.png"/></p>
<p>Along the contact line we define two unit vectors, <img class="formulaInl" alt="${\bf T}_t$" src="form_9.png"/> and <img class="formulaInl" alt="${\bf T}_n$" src="form_10.png"/>, that are tangential to the meniscus. <img class="formulaInl" alt="${\bf T}_t$" src="form_9.png"/> is tangent to the contact line while <img class="formulaInl" alt="${\bf T}_n$" src="form_10.png"/> is normal to it and points away from the meniscus, as shown in the sketch below.</p>
<p>We split the domain boundary <img class="formulaInl" alt="$ \partial D $" src="form_11.png"/> so that <img class="formulaInl" alt="$ \partial D = \partial D_{\rm pinned} \cup \partial D_{\rm angle} $" src="form_12.png"/> and assume that along <img class="formulaInl" alt="$\partial D_{\rm pinned}$" src="form_13.png"/> the meniscus is pinned, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left. {\bf R} \right|_{\partial D_{\rm pinned}} = {\bf R}_{\rm pinned}(\xi), \]" src="form_14.png"/>
</p>
<p> where <img class="formulaInl" alt="${\bf R}_{\rm pinned}(\xi) $" src="form_15.png"/> is given. On <img class="formulaInl" alt="$\partial D_{\rm angle}$" src="form_16.png"/> the meniscus meets the wall at a prescribed contact angle <img class="formulaInl" alt="$\gamma$" src="form_17.png"/> so that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left. \left( ({\bf T}_t \times {\bf N}_{\rm wall}) \cdot {\bf T}_n\right) \right|_{\partial D_{angle}} = \cos \gamma, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (1) \]" src="form_18.png"/>
</p>
<p> where <img class="formulaInl" alt="${\bf N}_{\rm wall}$" src="form_19.png"/> is the outer unit normal to the wall as shown in this sketch:</p>
<div class="image">
<img src="contact_angle_sketch.gif" alt=""/>
<div class="caption">
Sketch of the meniscus, the contact line along which it meets the wall, and the spine-based representation of the meniscus. </div></div>
 <p>The figure also illustrates the spine-based representation of the meniscus in the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf R}(\zeta_1,\zeta_2) = {\bf B}(\zeta_1,\zeta_2) + u(\zeta_1,\zeta_2) \ {\bf S}(\zeta_1,\zeta_2) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2) \]" src="form_20.png"/>
</p>
<p> where the spine basis <img class="formulaInl" alt="${\bf R}(\zeta_1,\zeta_2)$" src="form_21.png"/> and spines <img class="formulaInl" alt="${\bf S}(\zeta_1,\zeta_2)$" src="form_22.png"/> are pre-determined vector fields, chosen such that <br  />
</p><ul>
<li>The mapping from <img class="formulaInl" alt="$(\zeta_1,\zeta_2)$" src="form_23.png"/> to <img class="formulaInl" alt="${\bf R}(\zeta_1,\zeta_2)$" src="form_21.png"/> <br  />
 is one-to-one, at least for the meniscus shapes of interest. <br  />
<br  />
</li>
<li>Along the parts of the boundary where the contact line is pinned we have <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left. {\bf B}\right|_{\partial D_{\rm pinned}} = {\bf R}_{\rm pinned} \]" src="form_24.png"/>
</p>
 so that the pinned boundary condition may be enforced by setting <img class="formulaInl" alt="$ u|_{\partial D_{\rm pinned}} = 0.$" src="form_25.png"/> <br  />
<br  />
</li>
</ul>
<h2><a class="anchor" id="contact_angle_term"></a>
Computation of the contact-angle term in the variational principle</h2>
<p><a href="../../young_laplace/html/index.html">Recall</a> that the variational principle that determines the shape of the meniscus contained the line term </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \delta \Pi_{\rm contact \ line} = \oint_{\partial D } {\bf T}_n \cdot \delta {\bf R} \left| \frac{\partial {\bf R}} {\partial \xi}\right| \ d\xi. \]" src="form_26.png"/>
</p>
<p> Along <img class="formulaInl" alt="$ \partial D_{pinned} $" src="form_27.png"/> the line integral vanishes because <img class="formulaInl" alt="$ \delta {\bf R}\big|_{ \partial D_{pinned} } ={\bf 0} $" src="form_28.png"/>. The line integral can therefore be written as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \delta \Pi_{\rm contact \ line} = \int_{\partial D_{\rm angle}} {\bf T}_n \cdot \delta {\bf R} \left| \frac{\partial {\bf R}}{\partial \xi}\right| \ d\xi, \]" src="form_29.png"/>
</p>
<p> or, using the spine-based representation of the meniscus, (2), </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \delta \Pi_{\rm contact\ line} = \int_{\partial D_{\rm angle}} {\bf T}_n \cdot {\bf S} \ \delta u \left| \frac{\partial {\bf R}}{\partial \xi}\right| \ d\xi. \]" src="form_30.png"/>
</p>
<p>We shall now demonstrate that the integrand in this expression can be expressed in terms of the contact angle boundary condition (1). We start with several observations:</p><ol type="1">
<li><img class="formulaInl" alt="${\bf T}_t$" src="form_9.png"/> is tangential to the wall. <br  />
<br  />
</li>
<li>Since <img class="formulaInl" alt="${\bf N}_{\rm wall}$" src="form_19.png"/> is normal to the wall, <img class="formulaInl" alt="${\bf T}_t \times {\bf N}_{\rm wall}$" src="form_31.png"/> is tangential to the wall and orthogonal to <img class="formulaInl" alt="${\bf T}_t$" src="form_9.png"/>. <br  />
<br  />
</li>
<li><img class="formulaInl" alt="${\bf S}$" src="form_32.png"/> is tangential to the wall and can therefore be decomposed into its components parallel to <img class="formulaInl" alt="$ {\bf T}_t $" src="form_33.png"/> and <img class="formulaInl" alt="${\bf T}_t \times {\bf N}_{\rm wall} $" src="form_34.png"/> as <p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf S} = \alpha {\bf T}_t + \beta ( {\bf T}_t \times {\bf N}_{\rm wall} ) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (3) \]" src="form_35.png"/>
</p>
 for some values of <img class="formulaInl" alt="$\alpha$" src="form_36.png"/> and <img class="formulaInl" alt="$\beta$" src="form_37.png"/>. In fact, <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \beta = {\bf S} \cdot ( {\bf T}_t \times {\bf N}_{\rm wall} ) \]" src="form_38.png"/>
</p>
</li>
<li>During the computation it is most convenient to perform all calculations in terms of quantities that are easily obtained from the parametrisation of the meniscus as this avoids having to specify <img class="formulaInl" alt="${\bf N}_{\rm wall}$" src="form_19.png"/> explicitly. For this purpose we exploit that <img class="formulaInl" alt="${\bf T}_t$" src="form_9.png"/> and <img class="formulaInl" alt="${\bf S}$" src="form_32.png"/> are tangential to the wall and not parallel to each other (unless the parametrisation of the meniscus by (2) is no longer one-to-one). Therefore <img class="formulaInl" alt="${\bf N}_{\rm wall}$" src="form_19.png"/> can be obtained from quantities that are intrinsic to the meniscus representation via <br  />
<br  />
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf N}_{\rm wall} = \frac{ {\bf S} \times {\bf T}_t } {|{\bf S} \times {\bf T}_t|} \]" src="form_39.png"/>
</p>
 and thus <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \beta = {\bf S} \cdot \left( {\bf T}_t \times \frac{ {\bf S} \times {\bf T}_t } {|{\bf S} \times {\bf T}_t|} \right) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4) \]" src="form_40.png"/>
</p>
</li>
<li>Given (3) and the fact that <img class="formulaInl" alt="${\bf T}_t \cdot {\bf T}_n =0$" src="form_41.png"/>, we have <br  />
<br  />
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf S} \cdot {\bf T}_n = \beta ( {\bf T}_t \times {\bf N}_{\rm wall} ) \cdot {\bf T}_n \]" src="form_42.png"/>
</p>
 and with (1): <p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf S} \cdot {\bf T}_n = \beta \cos \gamma. \]" src="form_43.png"/>
</p>
 Hence, the line integral may be written as <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \delta \Pi_{\rm contact\ line} = \int_{\partial D_{\rm angle}} \beta \cos \gamma \ \delta u \left| \frac{\partial {\bf R}}{\partial \xi}\right| \ d\xi, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5) \]" src="form_44.png"/>
</p>
 where <img class="formulaInl" alt="$ \beta $" src="form_45.png"/> is given by (4).</li>
</ol>
<p>Equation (5) is easily discretised by finite elements. Within <code>oomph-lib</code>, the line integral is decomposed into <code>FaceElements</code> that are attached to the "bulk" Young-Laplace elements that are adjacent to the contact line. The imposition of the contact angle boundary condition for the Young Laplace equation is therefore as easy as the application of Neumann boundary conditions for a Poisson equation, say.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="results"></a>
Results</h1>
<p>The animation below illustrates the variation in the quasi-steady meniscus shape as the fluid enters the T-junction.</p>
<div class="image">
<img src="t_junction_meniscus.gif" alt=""/>
<div class="caption">
Animation of the meniscus shapes. </div></div>
 <p>The computation was performed with full spatial adaptivity. The plot below illustrates how the automatic mesh adaptation has strongly refined the mesh towards the corners of the domain where the meniscus shape has a singularity. (The singularity develops because in the corners of the domain the contact angle boundary condition along the side walls is inconsistent with the <img class="formulaInl" alt="$ 90^o $" src="form_46.png"/> contact angle enforced by the pinned boundary condition along the sharp edges.)</p>
<div class="image">
<img src="t_junction_meniscus_adapt.gif" alt=""/>
<div class="caption">
Illustration of the adaptive mesh refinement. </div></div>
 <p>Finally, here is a plot of the "load-displacement diagram", i.e. a plot of the meniscus deflection as a function of its curvature (i.e. the applied pressure drop). The limit point indicates the maximum pressure that can be withstood by the static meniscus.</p>
<div class="image">
<img src="t_junction_trace.gif" alt=""/>
<div class="caption">
The load-displacement diagram for the meniscus. </div></div>
 <hr  />
 <hr  />
<h1><a class="anchor" id="code"></a>
The driver code</h1>
<p>The modifications to the driver code required to impose the contact angle boundary conditions are very similar to those used in other driver codes for problems with Neumann-type boundary conditions. We attach <code>FaceElements</code> to the appropriate faces of the "bulk" Young-Laplace elements detach/re-attach them before and after any spatial adaptation of the "bulk" mesh.</p>
<hr  />
 <hr  />
<h2><a class="anchor" id="namespace"></a>
The global namespace</h2>
<p>The namespace that defines the problem parameters is very similar to that used in the <a href="../../young_laplace/html/index.html">previous example</a> without contact angle boundary conditions. We provide storage for the cosine of the contact angle, and the prescribed meniscus height that is used by the displacement control method.</p>
 <div class="fragment"><div class="line"><span class="comment">//======start_of_namespace========================================</span></div>
<div class="line"><span class="comment">/// Namespace for &quot;global&quot; problem parameters</span></div>
<div class="line"><span class="comment"></span><span class="comment">//================================================================</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceGlobalParameters.html">GlobalParameters</a></div>
<div class="line">{</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Cos of contact angle </span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobalParameters.html#ae982fcb894e82c683d07d3c2fbbead3d">Cos_gamma</a>=cos(MathematicalConstants::Pi/6.0);</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Height control value for displacement control</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobalParameters.html#a3731f24a02ce4f306d65a9a488f85c96">Controlled_height</a> = 0.0;</div>
</div><!-- fragment --><p><a href="../../young_laplace/html/index.html">As before</a>, we use the spine basis <img class="formulaInl" alt="$ {\bf B}(\zeta_1,\zeta_2)=(\zeta_1,\zeta_2,0)^T, $" src="form_47.png"/> to establish a reference configuration in which the flat meniscus is located in the plane <img class="formulaInl" alt="$ z=0 $" src="form_48.png"/> and occupies the domain <img class="formulaInl" alt="$ (x,y) \in [0,L_x] \times [0,L_y]. $" src="form_49.png"/></p>
<div class="fragment"><div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Length of domain</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobalParameters.html#a36ebf514fdd1e78fff69907b39e25af6">L_x</a> = 1.0; </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Width of domain</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobalParameters.html#ac8774b3418c4551091d64ec72c169b2e">L_y</a> = 5.0; </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Spine basis</span></div>
<div class="line"> <span class="comment">//------------</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// \short Spine basis: The position vector to the basis of the spine</span></div>
<div class="line"><span class="comment"> /// as a function of the two coordinates x_1 and x_2, and its</span></div>
<div class="line"><span class="comment"> /// derivatives w.r.t. to these coordinates. </span></div>
<div class="line"><span class="comment"> /// dspine_B[i][j] = d spine_B[j] / dx_i</span></div>
<div class="line"><span class="comment"> /// Spines start in the (x_1,x_2) plane at (x_1,x_2).</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceGlobalParameters.html#ac81daf87f8d3f075d9fd108427e70c4f">spine_base_function</a>(<span class="keyword">const</span> Vector&lt;double&gt;&amp; x, </div>
<div class="line">                          Vector&lt;double&gt;&amp; spine_B, </div>
<div class="line">                          Vector&lt; Vector&lt;double&gt; &gt;&amp; dspine_B)</div>
<div class="line"> {</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Bspines and derivatives </span></div>
<div class="line">  spine_B[0]     = x[0];</div>
<div class="line">  spine_B[1]     = x[1];</div>
<div class="line">  spine_B[2]     = 0.0 ;</div>
<div class="line">  dspine_B[0][0] = 1.0 ;</div>
<div class="line">  dspine_B[1][0] = 0.0 ;</div>
<div class="line">  dspine_B[0][1] = 0.0 ; </div>
<div class="line">  dspine_B[1][1] = 1.0 ;</div>
<div class="line">  dspine_B[0][2] = 0.0 ;</div>
<div class="line">  dspine_B[1][2] = 0.0 ;</div>
<div class="line">  </div>
<div class="line"> } <span class="comment">// End of bspine functions</span></div>
</div><!-- fragment --><p>As in the <a href="../../young_laplace/html/index.html">previous example</a>, we rotate the spines in the <img class="formulaInl" alt="$ y $" src="form_50.png"/> -direction to allow the representation of meniscus shapes that cannot be projected onto the <img class="formulaInl" alt="$ (x,y) $" src="form_51.png"/> -plane.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Spines rotate in the y-direction</span></div>
<div class="line"> <span class="comment">//---------------------------------</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Min. spine angle against horizontal plane</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobalParameters.html#ae8fa7610a34b7a2a8223eade99a5c22f">Alpha_min</a> = MathematicalConstants::Pi/2.0*1.5;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Max. spine angle against horizontal plane</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobalParameters.html#a19d04a02b0b5ef5c72e9c30d822e4dc7">Alpha_max</a> = MathematicalConstants::Pi/2.0*0.5;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// \short Spine: The spine vector field as a function of the two </span></div>
<div class="line"><span class="comment"> /// coordinates x_1 and x_2, and its derivatives w.r.t. to these coordinates:</span></div>
<div class="line"><span class="comment"> /// dspine[i][j] = d spine[j] / dx_i</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceGlobalParameters.html#a82df8c67f58e78a236fb6a0cc8bf8284">spine_function</a>(<span class="keyword">const</span> Vector&lt;double&gt;&amp; x, </div>
<div class="line">                     Vector&lt;double&gt;&amp; spine, </div>
<div class="line">                     Vector&lt; Vector&lt;double&gt; &gt;&amp; dspine)</div>
<div class="line"> {</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Spines (and derivatives)  are independent of x[0] and rotate </span></div>
<div class="line"><span class="comment">  /// in the x[1]-direction</span></div>
<div class="line"><span class="comment"></span>  spine[0]=0.0;</div>
<div class="line">  dspine[0][0]=0.0; </div>
<div class="line">  dspine[1][0]=0.0; </div>
<div class="line">  </div>
<div class="line">  spine[1]=cos(<a class="code" href="namespaceGlobalParameters.html#ae8fa7610a34b7a2a8223eade99a5c22f">Alpha_min</a>+(<a class="code" href="namespaceGlobalParameters.html#a19d04a02b0b5ef5c72e9c30d822e4dc7">Alpha_max</a>-<a class="code" href="namespaceGlobalParameters.html#ae8fa7610a34b7a2a8223eade99a5c22f">Alpha_min</a>)*x[1]/<a class="code" href="namespaceGlobalParameters.html#ac8774b3418c4551091d64ec72c169b2e">L_y</a>); </div>
<div class="line">  dspine[0][1]=0.0;                                   </div>
<div class="line">  dspine[1][1]=-sin(<a class="code" href="namespaceGlobalParameters.html#ae8fa7610a34b7a2a8223eade99a5c22f">Alpha_min</a>+(<a class="code" href="namespaceGlobalParameters.html#a19d04a02b0b5ef5c72e9c30d822e4dc7">Alpha_max</a>-<a class="code" href="namespaceGlobalParameters.html#ae8fa7610a34b7a2a8223eade99a5c22f">Alpha_min</a>)*x[1]/<a class="code" href="namespaceGlobalParameters.html#ac8774b3418c4551091d64ec72c169b2e">L_y</a>)</div>
<div class="line">   *(<a class="code" href="namespaceGlobalParameters.html#a19d04a02b0b5ef5c72e9c30d822e4dc7">Alpha_max</a>-<a class="code" href="namespaceGlobalParameters.html#ae8fa7610a34b7a2a8223eade99a5c22f">Alpha_min</a>)/<a class="code" href="namespaceGlobalParameters.html#ac8774b3418c4551091d64ec72c169b2e">L_y</a>;            </div>
<div class="line">  </div>
<div class="line">  spine[2]=sin(<a class="code" href="namespaceGlobalParameters.html#ae8fa7610a34b7a2a8223eade99a5c22f">Alpha_min</a>+(<a class="code" href="namespaceGlobalParameters.html#a19d04a02b0b5ef5c72e9c30d822e4dc7">Alpha_max</a>-<a class="code" href="namespaceGlobalParameters.html#ae8fa7610a34b7a2a8223eade99a5c22f">Alpha_min</a>)*x[1]/<a class="code" href="namespaceGlobalParameters.html#ac8774b3418c4551091d64ec72c169b2e">L_y</a>);</div>
<div class="line">  dspine[0][2]=0.0;                                  </div>
<div class="line">  dspine[1][2]=cos(<a class="code" href="namespaceGlobalParameters.html#ae8fa7610a34b7a2a8223eade99a5c22f">Alpha_min</a>+(<a class="code" href="namespaceGlobalParameters.html#a19d04a02b0b5ef5c72e9c30d822e4dc7">Alpha_max</a>-<a class="code" href="namespaceGlobalParameters.html#ae8fa7610a34b7a2a8223eade99a5c22f">Alpha_min</a>)*x[1]/<a class="code" href="namespaceGlobalParameters.html#ac8774b3418c4551091d64ec72c169b2e">L_y</a>) </div>
<div class="line">   *(<a class="code" href="namespaceGlobalParameters.html#a19d04a02b0b5ef5c72e9c30d822e4dc7">Alpha_max</a>-<a class="code" href="namespaceGlobalParameters.html#ae8fa7610a34b7a2a8223eade99a5c22f">Alpha_min</a>)/<a class="code" href="namespaceGlobalParameters.html#ac8774b3418c4551091d64ec72c169b2e">L_y</a>;            </div>
<div class="line"> </div>
<div class="line"> } <span class="comment">// End spine function</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of namespace</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h2><a class="anchor" id="main"></a>
The driver code</h2>
<p>We start by defining the output directory and open a trace file to record the load-displacement curve.</p>
 <div class="fragment"><div class="line"><span class="comment">//===============start_of_main============================================</span></div>
<div class="line"><span class="comment">/// Drive code</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="refineable__t__junction_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create label for output</span></div>
<div class="line"> DocInfo doc_info;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Trace file</span></div>
<div class="line"> ofstream trace_file;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set output directory</span></div>
<div class="line"> doc_info.set_directory(<span class="stringliteral">&quot;RESLT&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Open a trace file</span></div>
<div class="line"> <span class="keywordtype">char</span> filename[100];</div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/trace.dat&quot;</span>,doc_info.directory().c_str());</div>
<div class="line"> trace_file.open(filename);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Tecplot header for trace file: kappa and height value</span></div>
<div class="line"> trace_file &lt;&lt; <span class="stringliteral">&quot;VARIABLES=\&quot;&lt;GREEK&gt;k&lt;/GREEK&gt;\&quot;,\&quot;h\&quot;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> trace_file &lt;&lt; <span class="stringliteral">&quot;ZONE&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Next, we create the problem object, refine the mesh uniformly and output the initial guess for the solution: a flat interface which, unlike the <a href="../../young_laplace/html/index.html">previous case</a>, is not a solution of the problem because it does not satisfy the contact-angle boundary condition; see the section <a class="el" href="index.html#comm_ex">Comments and Exercises</a> for a more detailed discussion of this issue.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Set up the problem</span></div>
<div class="line"> <span class="comment">//------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create the problem with 2D nine-node elements from the</span></div>
<div class="line"> <span class="comment">// RefineableQYoungLaplaceElement family. </span></div>
<div class="line"> <a class="code" href="classRefineableYoungLaplaceProblem.html">RefineableYoungLaplaceProblem&lt;RefineableQYoungLaplaceElement&lt;3&gt;</a> &gt; <a class="code" href="contact__angle_8txt.html#a831d1ad5f0468950f29fbf410fa323b0">problem</a>;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Perform one uniform refinement</span></div>
<div class="line"> <a class="code" href="contact__angle_8txt.html#a831d1ad5f0468950f29fbf410fa323b0">problem</a>.refine_uniformly();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Output the solution</span></div>
<div class="line"> <a class="code" href="contact__angle_8txt.html#a831d1ad5f0468950f29fbf410fa323b0">problem</a>.doc_solution(doc_info,trace_file);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Increment counter for solutions </span></div>
<div class="line"> doc_info.number()++;</div>
</div><!-- fragment --><p>Finally, we perform a parameter study by slowly incrementing the control displacement and recomputing the meniscus shape.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Parameter incrementation</span></div>
<div class="line"> <span class="comment">//------------------------- </span></div>
<div class="line"> <span class="keywordtype">double</span> increment=0.1;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over steps</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nstep=2; <span class="comment">// 10;</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> istep=0;istep&lt;nstep;istep++)</div>
<div class="line">  {</div>
<div class="line">   <a class="code" href="namespaceGlobalParameters.html#a3731f24a02ce4f306d65a9a488f85c96">GlobalParameters::Controlled_height</a>+=increment;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Solve the problem  </span></div>
<div class="line">   <span class="keywordtype">unsigned</span> max_adapt=1;</div>
<div class="line">   <a class="code" href="contact__angle_8txt.html#a831d1ad5f0468950f29fbf410fa323b0">problem</a>.newton_solve(max_adapt);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Output the solution</span></div>
<div class="line">   <a class="code" href="contact__angle_8txt.html#a831d1ad5f0468950f29fbf410fa323b0">problem</a>.doc_solution(doc_info,trace_file);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Increment counter for solutions </span></div>
<div class="line">   doc_info.number()++;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Close output file</span></div>
<div class="line"> trace_file.close();</div>
<div class="line"> </div>
<div class="line">} <span class="comment">//end of main</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h2><a class="anchor" id="class"></a>
The problem class</h2>
<p>The problem class contains the usual member functions. The functions <code><a class="el" href="contact__angle_8txt.html#ad1c3b5a5aba86a7883b7915e8bdd7c21">actions_before_adapt()</a></code> and <code>actions_after_adapt()</code> are used to detach and re-attach (and rebuild) the contact angle elements on the appropriate boundaries of the "bulk" mesh.</p>
 <div class="fragment"><div class="line"><span class="comment">//====== start_of_problem_class=======================================</span></div>
<div class="line"><span class="comment">/// 2D RefineableYoungLaplace problem on rectangular domain, discretised with</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// 2D QRefineableYoungLaplace elements. The specific type of element is</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// specified via the template parameter.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt; </div>
<div class="line"><span class="keyword">class </span><a class="code" href="classRefineableYoungLaplaceProblem.html">RefineableYoungLaplaceProblem</a> : <span class="keyword">public</span> Problem</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Constructor: </span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classRefineableYoungLaplaceProblem.html#a78f77a299f2770a82378fcccf86a0b71">RefineableYoungLaplaceProblem</a>();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Destructor (empty)</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classRefineableYoungLaplaceProblem.html#a24b45d5ecdd1d7dbb678e7f74777bf41">~RefineableYoungLaplaceProblem</a>(){};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Update the problem specs before solve: Empty</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classRefineableYoungLaplaceProblem.html#a2807bb8cddbfa553df9f5dd170c8645d">actions_before_newton_solve</a>(){};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Update the problem after solve: Empty</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classRefineableYoungLaplaceProblem.html#a0791c90a16016372e09faf3f5721ecbe">actions_after_newton_solve</a>(){};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Actions before adapt: Wipe the mesh of contact angle elements</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classRefineableYoungLaplaceProblem.html#ab64eb0b58beb3bb096ecc81b1a3f8a4f">actions_before_adapt</a>()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Kill the contact angle elements and wipe contact angle mesh</span></div>
<div class="line">   <span class="keywordflow">if</span> (<a class="code" href="classRefineableYoungLaplaceProblem.html#a36f5dc0f7071ac15fd63c7c477f77fb0">Contact_angle_mesh_pt</a>!=0) <a class="code" href="classRefineableYoungLaplaceProblem.html#aaa270ba8da395897a5a99d052f076e0c">delete_contact_angle_elements</a>();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Rebuild the Problem&#39;s global mesh from its various sub-meshes</span></div>
<div class="line">   rebuild_global_mesh();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> ///  Actions after adapt: Rebuild the mesh of contact angle elements</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classRefineableYoungLaplaceProblem.html#aa2eab8da1b83091df804ede7c60fac87">actions_after_adapt</a>()</div>
<div class="line">  {</div>
<div class="line">   <a class="code" href="classRefineableYoungLaplaceProblem.html#a00d1304e030120e76d9f316dd4053116">create_contact_angle_elements</a>(1);</div>
<div class="line">   <a class="code" href="classRefineableYoungLaplaceProblem.html#a00d1304e030120e76d9f316dd4053116">create_contact_angle_elements</a>(3);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Set function pointers for contact-angle elements</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> nel=<a class="code" href="classRefineableYoungLaplaceProblem.html#a36f5dc0f7071ac15fd63c7c477f77fb0">Contact_angle_mesh_pt</a>-&gt;nelement();</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> e=0;e&lt;nel;e++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Upcast from GeneralisedElement to YoungLaplace contact angle</span></div>
<div class="line">     <span class="comment">// element</span></div>
<div class="line">     YoungLaplaceContactAngleElement&lt;ELEMENT&gt; *el_pt = </div>
<div class="line">      <span class="keyword">dynamic_cast&lt;</span>YoungLaplaceContactAngleElement&lt;ELEMENT&gt;*<span class="keyword">&gt;</span>(</div>
<div class="line">       <a class="code" href="classRefineableYoungLaplaceProblem.html#a36f5dc0f7071ac15fd63c7c477f77fb0">Contact_angle_mesh_pt</a>-&gt;element_pt(e));</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Set the pointer to the prescribed contact angle</span></div>
<div class="line">     el_pt-&gt;prescribed_cos_gamma_pt() = &amp;<a class="code" href="namespaceGlobalParameters.html#ae982fcb894e82c683d07d3c2fbbead3d">GlobalParameters::Cos_gamma</a>;</div>
<div class="line">    }</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Rebuild the Problem&#39;s global mesh from its various sub-meshes</span></div>
<div class="line">   rebuild_global_mesh();</div>
<div class="line">   </div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// \short Doc the solution. DocInfo object stores flags/labels for where the</span></div>
<div class="line"><span class="comment"> /// output gets written to and the trace file</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classRefineableYoungLaplaceProblem.html#a4ec7313c8e4015b0c2af0bbef789e70f">doc_solution</a>(DocInfo&amp; doc_info, ofstream&amp; trace_file);</div>
</div><!-- fragment --><p>Two private helper functions are provided to create and delete the contact angle elements. The class also provides storage for the pointers to the various meshes, to the node at which the meniscus displacement is prescribed by the displacement control method, and to the <code>Data</code> object whose one-and-only value stores the (unknown) meniscus curvature.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// \short Create YoungLaplace contact angle elements on the </span></div>
<div class="line"><span class="comment"> /// b-th boundary of the bulk mesh and add them to contact angle mesh</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> create_contact_angle_elements(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; b);</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Delete contact angle elements </span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> delete_contact_angle_elements();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to the &quot;bulk&quot; mesh</span></div>
<div class="line"><span class="comment"></span> RefineableRectangularQuadMesh&lt;ELEMENT&gt;* Bulk_mesh_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to the contact angle mesh</span></div>
<div class="line"><span class="comment"></span> Mesh* Contact_angle_mesh_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to mesh containing the height control element</span></div>
<div class="line"><span class="comment"></span> Mesh* Height_control_mesh_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Node at which the height (displacement along spine) is controlled/doced</span></div>
<div class="line"><span class="comment"></span> Node* Control_node_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to Data object that stores the prescribed curvature</span></div>
<div class="line"><span class="comment"></span> Data* <a class="code" href="namespaceGlobalParameters.html#ac6234184cce40ab2c6bec92b37e4ae41">Kappa_pt</a>;</div>
<div class="line"> </div>
<div class="line">}; <span class="comment">// end of problem class</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h2><a class="anchor" id="constr"></a>
The problem constructor</h2>
<p>We start by creating the "bulk" mesh of refineable Young Laplace elements and specify the error estimator.</p>
<div class="fragment"><div class="line"><span class="comment">//=====start_of_constructor===============================================</span></div>
<div class="line"><span class="comment">/// Constructor for RefineableYoungLaplace problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><a class="code" href="classRefineableYoungLaplaceProblem.html#a78f77a299f2770a82378fcccf86a0b71">RefineableYoungLaplaceProblem&lt;ELEMENT&gt;::RefineableYoungLaplaceProblem</a>()</div>
<div class="line">{ </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Setup bulk mesh</span></div>
<div class="line"> <span class="comment">//----------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// # of elements in x-direction</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_x=8;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// # of elements in y-direction</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_y=8;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Domain length in x-direction</span></div>
<div class="line"> <span class="keywordtype">double</span> l_x=<a class="code" href="namespaceGlobalParameters.html#a36ebf514fdd1e78fff69907b39e25af6">GlobalParameters::L_x</a>;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Domain length in y-direction</span></div>
<div class="line"> <span class="keywordtype">double</span> l_y=<a class="code" href="namespaceGlobalParameters.html#ac8774b3418c4551091d64ec72c169b2e">GlobalParameters::L_y</a>;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build and assign mesh</span></div>
<div class="line"> Bulk_mesh_pt=<span class="keyword">new</span> RefineableRectangularQuadMesh&lt;ELEMENT&gt;(n_x,n_y,l_x,l_y);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create/set error estimator</span></div>
<div class="line"> Bulk_mesh_pt-&gt;spatial_error_estimator_pt()=<span class="keyword">new</span> Z2ErrorEstimator;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set targets for spatial adaptivity</span></div>
<div class="line"> Bulk_mesh_pt-&gt;max_permitted_error()=1.0e-4;</div>
<div class="line"> Bulk_mesh_pt-&gt;min_permitted_error()=1.0e-6;</div>
</div><!-- fragment --><p>We identify the node (in the centre of the mesh) at which we apply displacement control. We pass a pointer to this node to the constructor of the displacement control element and store that element in its own mesh.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Check that we&#39;ve got an even number of elements otherwise</span></div>
<div class="line"> <span class="comment">// out counting doesn&#39;t work...</span></div>
<div class="line"> <span class="keywordflow">if</span> ((n_x%2!=0)||(n_y%2!=0))</div>
<div class="line">  {</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;n_x n_y should be even&quot;</span> &lt;&lt; endl;</div>
<div class="line">   abort();</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line"> <span class="comment">//  This is the element that contains the central node:</span></div>
<div class="line"> ELEMENT* prescribed_height_element_pt= <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(</div>
<div class="line">  Bulk_mesh_pt-&gt;element_pt(n_y*n_x/2+n_x/2));</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// The central node is node 0 in that element</span></div>
<div class="line"> Control_node_pt= <span class="keyword">static_cast&lt;</span>Node*<span class="keyword">&gt;</span>(prescribed_height_element_pt-&gt;node_pt(0));</div>
<div class="line"> </div>
<div class="line"> std::cout &lt;&lt; <span class="stringliteral">&quot;Controlling height at (x,y) : (&quot;</span> &lt;&lt; Control_node_pt-&gt;x(0) </div>
<div class="line">           &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; Control_node_pt-&gt;x(1)  &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create a height control element and store the</span></div>
<div class="line"> <span class="comment">// pointer to the Kappa Data created by this object</span></div>
<div class="line"> HeightControlElement* height_control_element_pt=<span class="keyword">new</span> HeightControlElement(</div>
<div class="line">  Control_node_pt,&amp;<a class="code" href="namespaceGlobalParameters.html#a3731f24a02ce4f306d65a9a488f85c96">GlobalParameters::Controlled_height</a>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Add to mesh</span></div>
<div class="line"> Height_control_mesh_pt = <span class="keyword">new</span> Mesh;</div>
<div class="line"> Height_control_mesh_pt-&gt;add_element_pt(height_control_element_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Store curvature data</span></div>
<div class="line"> <a class="code" href="namespaceGlobalParameters.html#ac6234184cce40ab2c6bec92b37e4ae41">Kappa_pt</a>=height_control_element_pt-&gt;kappa_pt();</div>
</div><!-- fragment --><p>Next we create the mesh that stores the contact-angle elements. We attach these elements to boundaries 1 and 3 of the "bulk" mesh.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Contact angle elements</span></div>
<div class="line"> <span class="comment">//-----------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create prescribed-contact-angle elements from all elements that are </span></div>
<div class="line"> <span class="comment">// adjacent to boundary 1 and 3 and add them to their own mesh</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// set up new mesh</span></div>
<div class="line"> Contact_angle_mesh_pt=<span class="keyword">new</span> Mesh;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// creation of contact angle elements</span></div>
<div class="line"> create_contact_angle_elements(1);</div>
<div class="line"> create_contact_angle_elements(3);</div>
</div><!-- fragment --><p>The various sub-meshes are now added to the problem and the global mesh is built.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Add various meshes and build the global mesh</span></div>
<div class="line"> <span class="comment">//----------------------------------------------</span></div>
<div class="line"> add_sub_mesh(Bulk_mesh_pt);</div>
<div class="line"> add_sub_mesh(Height_control_mesh_pt);</div>
<div class="line"> add_sub_mesh(Contact_angle_mesh_pt);</div>
<div class="line"> <a class="code" href="contact__angle_8txt.html#a770d352b78a60074a229f760bc2e0179">build_global_mesh</a>();</div>
</div><!-- fragment --><p>As usual, we enforce only the essential boundary conditions directly by pinning the meniscus displacement along mesh boundaries 0 and 2:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Boundary conditions</span></div>
<div class="line"> <span class="comment">//--------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set the boundary conditions for this problem: All nodes are</span></div>
<div class="line"> <span class="comment">// free by default -- only need to pin the ones that have Dirichlet conditions</span></div>
<div class="line"> <span class="comment">// here. </span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_bound = Bulk_mesh_pt-&gt;nboundary(); </div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> b=0;b&lt;n_bound;b++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Pin all boundaries for three cases and only boundaries</span></div>
<div class="line">   <span class="comment">// 0 and 2 in all others:</span></div>
<div class="line">   <span class="keywordflow">if</span> ((b==0)||(b==2))</div>
<div class="line">    {</div>
<div class="line">     <span class="keywordtype">unsigned</span> n_node = Bulk_mesh_pt-&gt;nboundary_node(b);</div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> n=0;n&lt;n_node;n++)</div>
<div class="line">      {</div>
<div class="line">       Bulk_mesh_pt-&gt;boundary_node_pt(b,n)-&gt;pin(0); </div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">// end bcs</span></div>
</div><!-- fragment --><p>The build of the "bulk" Young Laplace elements is completed by specifying the function pointers to the spine functions and the pointer to the <code>Data</code> object that stores the curvature.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Complete build of elements</span></div>
<div class="line"> <span class="comment">//---------------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Complete the build of all elements so they are fully functional </span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_bulk=Bulk_mesh_pt-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_bulk;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from GeneralsedElement to the present element</span></div>
<div class="line">   ELEMENT *el_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(Bulk_mesh_pt-&gt;element_pt(i));</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Set the spine function pointers</span></div>
<div class="line">   el_pt-&gt;spine_base_fct_pt() = <a class="code" href="namespaceGlobalParameters.html#ac81daf87f8d3f075d9fd108427e70c4f">GlobalParameters::spine_base_function</a>;</div>
<div class="line">   el_pt-&gt;spine_fct_pt() =  <a class="code" href="namespaceGlobalParameters.html#a82df8c67f58e78a236fb6a0cc8bf8284">GlobalParameters::spine_function</a>;</div>
<div class="line">  </div>
<div class="line">   <span class="comment">// Set the curvature data for the element</span></div>
<div class="line">   el_pt-&gt;set_kappa(<a class="code" href="namespaceGlobalParameters.html#ac6234184cce40ab2c6bec92b37e4ae41">Kappa_pt</a>); </div>
<div class="line">  }</div>
</div><!-- fragment --><p>Finally, we complete the build of the contact line elements by passing the pointer to the double that stores the cosine of the contact angle.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Set function pointers for contact-angle elements</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nel=Contact_angle_mesh_pt-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> e=0;e&lt;nel;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from GeneralisedElement to YoungLaplace contact angle </span></div>
<div class="line">   <span class="comment">// element</span></div>
<div class="line">   YoungLaplaceContactAngleElement&lt;ELEMENT&gt; *el_pt = </div>
<div class="line">    <span class="keyword">dynamic_cast&lt;</span>YoungLaplaceContactAngleElement&lt;ELEMENT&gt;*<span class="keyword">&gt;</span>(</div>
<div class="line">     Contact_angle_mesh_pt-&gt;element_pt(e));</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Set the pointer to the prescribed contact angle</span></div>
<div class="line">   el_pt-&gt;prescribed_cos_gamma_pt() = &amp;<a class="code" href="namespaceGlobalParameters.html#ae982fcb894e82c683d07d3c2fbbead3d">GlobalParameters::Cos_gamma</a>;</div>
<div class="line">  }</div>
</div><!-- fragment --><p>All that's now left to do is to assign the equation numbers:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Setup equation numbering scheme</span></div>
<div class="line"> cout &lt;&lt;<span class="stringliteral">&quot;\nNumber of equations: &quot;</span> &lt;&lt; assign_eqn_numbers() &lt;&lt; endl; </div>
<div class="line"> cout &lt;&lt; <span class="stringliteral">&quot;\n********************************************\n&quot;</span> &lt;&lt;  endl;</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of constructor</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h2><a class="anchor" id="create"></a>
Creating the contact angle elements</h2>
<p>The function <code>create_contact_angle_elements()</code> attaches the <code>FaceElements</code> that apply the contact angle boundary condition to the specified boundary of the "bulk" mesh. Pointers to the newly-created <code>FaceElements</code> are stored in a separate mesh.</p>
<div class="fragment"><div class="line"><span class="comment">//============start_of_create_contact_angle_elements=====================</span></div>
<div class="line"><span class="comment">/// Create YoungLaplace contact angle elements on the b-th boundary of the </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// bulk mesh and add them to the contact angle mesh</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=======================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classRefineableYoungLaplaceProblem.html#a00d1304e030120e76d9f316dd4053116">RefineableYoungLaplaceProblem&lt;ELEMENT&gt;::create_contact_angle_elements</a>(</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;b)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// How many bulk elements are adjacent to boundary b?</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_element = Bulk_mesh_pt-&gt;nboundary_element(b);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over the bulk elements adjacent to boundary b?</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Get pointer to the bulk element that is adjacent to boundary b</span></div>
<div class="line">   ELEMENT* bulk_elem_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(</div>
<div class="line">    Bulk_mesh_pt-&gt;boundary_element_pt(b,e));</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// What is the index of the face of the bulk element at the boundary</span></div>
<div class="line">   <span class="keywordtype">int</span> face_index = Bulk_mesh_pt-&gt;face_index_at_boundary(b,e);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Build the corresponding contact angle element</span></div>
<div class="line">   YoungLaplaceContactAngleElement&lt;ELEMENT&gt;* contact_angle_element_pt = <span class="keyword">new</span> </div>
<div class="line">   YoungLaplaceContactAngleElement&lt;ELEMENT&gt;(bulk_elem_pt,face_index);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Add the contact angle element to the contact angle mesh</span></div>
<div class="line">   Contact_angle_mesh_pt-&gt;add_element_pt(contact_angle_element_pt);</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">//end of loop over bulk elements adjacent to boundary b</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of create_contact_angle_elements</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h2><a class="anchor" id="delete"></a>
Deleting the contact angle elements</h2>
<p>The function <code>delete_contact_angle_elements()</code> deletes the contact angle elements and flushes the associated mesh.</p>
<div class="fragment"><div class="line"><span class="comment">//============start_of_delete_contact_angle_elements=====================</span></div>
<div class="line"><span class="comment">/// Delete YoungLaplace contact angle elements</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=======================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classRefineableYoungLaplaceProblem.html#aaa270ba8da395897a5a99d052f076e0c">RefineableYoungLaplaceProblem&lt;ELEMENT&gt;::delete_contact_angle_elements</a>()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// How many contact angle elements are there?</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_element = Contact_angle_mesh_pt-&gt;nelement();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over the surface elements</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Kill surface element</span></div>
<div class="line">   <span class="keyword">delete</span> Contact_angle_mesh_pt-&gt;element_pt(e);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Wipe the mesh</span></div>
<div class="line"> Contact_angle_mesh_pt-&gt;flush_element_and_node_storage();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of delete_contact_angle_elements</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h2><a class="anchor" id="doc"></a>
Post-processing</h2>
<p>We output the load-displacement data, the meniscus shape, and various contact line quantities.</p>
<div class="fragment"><div class="line"><span class="comment">//===============start_of_doc=============================================</span></div>
<div class="line"><span class="comment">/// Doc the solution: doc_info contains labels/output directory etc.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classRefineableYoungLaplaceProblem.html#a4ec7313c8e4015b0c2af0bbef789e70f">RefineableYoungLaplaceProblem&lt;ELEMENT&gt;::doc_solution</a>(DocInfo&amp; doc_info,</div>
<div class="line">                                              ofstream&amp; trace_file)</div>
<div class="line">{ </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output kappa vs height</span></div>
<div class="line"> <span class="comment">//-----------------------</span></div>
<div class="line"> trace_file &lt;&lt; -1.0*<a class="code" href="namespaceGlobalParameters.html#ac6234184cce40ab2c6bec92b37e4ae41">Kappa_pt</a>-&gt;value(0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"> trace_file &lt;&lt; Control_node_pt-&gt;value(0) ;</div>
<div class="line"> trace_file &lt;&lt; endl;</div>
<div class="line">  </div>
<div class="line"> <span class="comment">// Number of plot points: npts x npts</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> npts=5;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output full solution </span></div>
<div class="line"> <span class="comment">//---------------------</span></div>
<div class="line"> ofstream some_file;</div>
<div class="line"> <span class="keywordtype">char</span> filename[100];</div>
<div class="line"> <span class="comment">//YoungLaplaceEquations::Output_meniscus_and_spines=false;</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/soln%i.dat&quot;</span>,doc_info.directory().c_str(),</div>
<div class="line">         doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> Bulk_mesh_pt-&gt;output(some_file,npts);</div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output contact angle </span></div>
<div class="line"> <span class="comment">//---------------------</span></div>
<div class="line"> </div>
<div class="line"> ofstream tangent_file;</div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/tangent_to_contact_line%i.dat&quot;</span>,</div>
<div class="line">         doc_info.directory().c_str(),</div>
<div class="line">         doc_info.number());</div>
<div class="line"> tangent_file.open(filename);</div>
<div class="line"> </div>
<div class="line"> ofstream normal_file;</div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/normal_to_contact_line%i.dat&quot;</span>,</div>
<div class="line">         doc_info.directory().c_str(),</div>
<div class="line">         doc_info.number());</div>
<div class="line"> normal_file.open(filename);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> ofstream contact_angle_file;</div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/contact_angle%i.dat&quot;</span>,</div>
<div class="line">         doc_info.directory().c_str(),</div>
<div class="line">         doc_info.number());</div>
<div class="line"> contact_angle_file.open(filename);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Tangent and normal vectors to contact line</span></div>
<div class="line"> Vector&lt;double&gt; tangent(3);</div>
<div class="line"> Vector&lt;double&gt; normal(3);</div>
<div class="line"> Vector&lt;double&gt; r_contact(3);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// How many contact angle elements are there?</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_element = Contact_angle_mesh_pt-&gt;nelement();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over the surface elements</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   </div>
<div class="line">   tangent_file &lt;&lt; <span class="stringliteral">&quot;ZONE&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">   normal_file &lt;&lt; <span class="stringliteral">&quot;ZONE&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">   contact_angle_file &lt;&lt; <span class="stringliteral">&quot;ZONE&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Upcast from GeneralisedElement to YoungLaplace contact angle element</span></div>
<div class="line">   YoungLaplaceContactAngleElement&lt;ELEMENT&gt;* el_pt = </div>
<div class="line">    <span class="keyword">dynamic_cast&lt;</span>YoungLaplaceContactAngleElement&lt;ELEMENT&gt;*<span class="keyword">&gt;</span>(</div>
<div class="line">     Contact_angle_mesh_pt-&gt;element_pt(e));</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Loop over a few points in the contact angle element</span></div>
<div class="line">   Vector&lt;double&gt; s(1);</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;npts;i++)</div>
<div class="line">    {</div>
<div class="line">     s[0]=-1.0+2.0*double(i)/double(npts-1);</div>
<div class="line">     </div>
<div class="line">     <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(el_pt-&gt;bulk_element_pt())-&gt;</div>
<div class="line">      position(el_pt-&gt;local_coordinate_in_bulk(s),r_contact);</div>
<div class="line">     </div>
<div class="line">     el_pt-&gt;contact_line_vectors(s,tangent,normal);</div>
<div class="line">     tangent_file &lt;&lt; r_contact[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div>
<div class="line">                  &lt;&lt; r_contact[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div>
<div class="line">                  &lt;&lt; r_contact[2] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div>
<div class="line">                  &lt;&lt; tangent[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div>
<div class="line">                  &lt;&lt; tangent[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div>
<div class="line">                  &lt;&lt; tangent[2] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>  &lt;&lt; std::endl;</div>
<div class="line">     </div>
<div class="line">     normal_file &lt;&lt; r_contact[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div>
<div class="line">                 &lt;&lt; r_contact[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div>
<div class="line">                 &lt;&lt; r_contact[2] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div>
<div class="line">                 &lt;&lt; normal[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div>
<div class="line">                 &lt;&lt; normal[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div>
<div class="line">                 &lt;&lt; normal[2] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>  &lt;&lt; std::endl;</div>
<div class="line">     </div>
<div class="line">     contact_angle_file &lt;&lt; r_contact[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div>
<div class="line">                        &lt;&lt; el_pt-&gt;actual_cos_contact_angle(s)</div>
<div class="line">                        &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">   </div>
<div class="line">   </div>
<div class="line">  } <span class="comment">// end of loop over both boundaries</span></div>
<div class="line"> </div>
<div class="line"> tangent_file.close();</div>
<div class="line"> normal_file.close();</div>
<div class="line"> contact_angle_file.close();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;\n********************************************&quot;</span> &lt;&lt; endl &lt;&lt;  endl;</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of doc</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="comm_ex"></a>
Comments and Exercises</h1>
<h2><a class="anchor" id="ic"></a>
How to generate a good initial guess for the solution</h2>
<p>We already commented on the need to provide a "good" initial guess for the solution in order to ensure the convergence of the Newton iteration. In the <a href="../../young_laplace/html/index.html">previous example</a> this was easy because the flat meniscus (clearly a solution of the Young-Laplace equations for zero curvature) also satisfied the boundary conditions. In the present example, and in many others, this is not the case. In such problems it may be difficult to generate initial guesses for the meniscus shape that are sufficiently close to actual solution.</p>
<p>In such cases it may be necessary to compute the initial solution to the problem whose behaviour we wish to investigate during the actual parameter study via a preliminary auxiliary continuation procedure that transforms an easier-solve-problem (for which a good initial guess can be found) into the actual problem.</p>
<p>Explore this approach in the present problem by implementing the following steps:</p><ol type="1">
<li>Set the contact angle to <img class="formulaInl" alt="$ 90^o $" src="form_46.png"/> and solve the problem, using the "flat" meniscus as the initial guess. The "flat" meniscus is, of course, the exact solution for zero control displacement and/or zero curvature. <br  />
<br  />
</li>
<li>Now start a preliminary continuation procedure in which the contact angle is adjusted in small steps until it reaches the desired value. Keep the prescribed control displacement (or the meniscus curvature) constant during this procedure. <br  />
<br  />
</li>
<li>The solution for the desired contact angle may now be used as the initial guess for the actual parameter study in which the control displacement (or the meniscus curvature) are increased while the contact angle is kept fixed.</li>
</ol>
<h2><a class="anchor" id="lim"></a>
Limitations of the current approach  suggestions for improvement</h2>
<p>One of the main disadvantages of the approach adopted here is that the spine vector fields <img class="formulaInl" alt="$ {\bf B} $" src="form_52.png"/> and <img class="formulaInl" alt="$ {\bf S} $" src="form_53.png"/> must be specified <em>a priori</em>. For sufficiently complicated meniscus shapes (or for menisci that undergo large changes in shape as their curvature is varied) the choice of suitable spines may be very difficult. <br  />
<br  />
One (possible) solution to this problem could be (we haven't tried it!) to occasionally update the spine representation. For instance, assume that we have computed a meniscus shape in the form <br  />
<br  />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \widehat{\bf R} = {\bf R}(\zeta_1,\zeta_2) = {\bf B}(\zeta_1,\zeta_2) + u(\zeta_1,\zeta_2) \ {\bf S}(\zeta_1,\zeta_2) \]" src="form_54.png"/>
</p>
<p> with an associated normal vector <img class="formulaInl" alt="$ \widehat{\bf N} $" src="form_55.png"/>. We can reparametrise this shape by setting </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf B} := \widehat{\bf R}, \]" src="form_56.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf S} := \widehat{\bf N}, \]" src="form_57.png"/>
</p>
<p> and <br  />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u := 0 \]" src="form_58.png"/>
</p>
<p> before continuing the computation. Provided this is done sufficiently frequently, i.e. long before the displacement along the spines has become so large that the mapping from <img class="formulaInl" alt="$ (\zeta_1,\zeta_2) $" src="form_59.png"/> to <img class="formulaInl" alt="$ {\bf R}(\zeta_1,\zeta_2)$" src="form_60.png"/> is about to become non-one-to-one, this should allow the computation of arbitrarily large meniscus deflections. Try it out and let us know how it works! <br  />
<br  />
 </p>
<h2><a class="anchor" id="zero"></a>
Zero contact angles</h2>
<p>Our problem formulation suffers from an additional, more fundamental problem: it cannot be used to solve problems with zero contact angle. This is because for zero contact angles the equilibrium solution is no longer a minimiser of the variational principle: given a solution at which the meniscus meets the wall at zero contact angle, it is always possible to extend the meniscus with an arbitrary-length "collar" along the wall without changing the overall energy of the system. As a result, the position of the contact line becomes increasingly ill-defined as the contact angle <img class="formulaInl" alt="$ \gamma $" src="form_1.png"/> is reduced, causing the Newton method to converge very slowly (and ultimately not at all) as <img class="formulaInl" alt="$ \gamma \to 0. $" src="form_61.png"/></p>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory:<br  />
<br  />
 <center> <a href="../../../../demo_drivers/young_laplace/">demo_drivers/young_laplace/ </a> </center><br  />
</li>
<li>The driver code is: <br  />
<br  />
 <center> <a href="../../../../demo_drivers/young_laplace/refineable_t_junction.cc">demo_drivers/young_laplace/refineable_t_junction.cc </a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="aclassRefineableYoungLaplaceProblem_html_aaa270ba8da395897a5a99d052f076e0c"><div class="ttname"><a href="classRefineableYoungLaplaceProblem.html#aaa270ba8da395897a5a99d052f076e0c">RefineableYoungLaplaceProblem::delete_contact_angle_elements</a></div><div class="ttdeci">void delete_contact_angle_elements()</div><div class="ttdoc">Delete contact angle elements.</div><div class="ttdef"><b>Definition:</b> <a href="refineable__t__junction_8cc_source.html#l00405">refineable_t_junction.cc:405</a></div></div>
<div class="ttc" id="anamespaceGlobalParameters_html_ac6234184cce40ab2c6bec92b37e4ae41"><div class="ttname"><a href="namespaceGlobalParameters.html#ac6234184cce40ab2c6bec92b37e4ae41">GlobalParameters::Kappa_pt</a></div><div class="ttdeci">Data * Kappa_pt</div><div class="ttdoc">Pointer to Data object that stores the prescribed curvature.</div><div class="ttdef"><b>Definition:</b> <a href="common__young__laplace__stuff_8h_source.html#l00064">common_young_laplace_stuff.h:64</a></div></div>
<div class="ttc" id="aclassRefineableYoungLaplaceProblem_html_a2807bb8cddbfa553df9f5dd170c8645d"><div class="ttname"><a href="classRefineableYoungLaplaceProblem.html#a2807bb8cddbfa553df9f5dd170c8645d">RefineableYoungLaplaceProblem::actions_before_newton_solve</a></div><div class="ttdeci">void actions_before_newton_solve()</div><div class="ttdoc">Update the problem specs before solve: Empty.</div><div class="ttdef"><b>Definition:</b> <a href="refineable__t__junction_8cc_source.html#l00150">refineable_t_junction.cc:150</a></div></div>
<div class="ttc" id="anamespaceGlobalParameters_html_ae982fcb894e82c683d07d3c2fbbead3d"><div class="ttname"><a href="namespaceGlobalParameters.html#ae982fcb894e82c683d07d3c2fbbead3d">GlobalParameters::Cos_gamma</a></div><div class="ttdeci">double Cos_gamma</div><div class="ttdoc">Cos of contact angle.</div><div class="ttdef"><b>Definition:</b> <a href="common__young__laplace__stuff_8h_source.html#l00061">common_young_laplace_stuff.h:61</a></div></div>
<div class="ttc" id="anamespaceGlobalParameters_html"><div class="ttname"><a href="namespaceGlobalParameters.html">GlobalParameters</a></div><div class="ttdoc">Namespace for &quot;global&quot; problem parameters.</div><div class="ttdef"><b>Definition:</b> <a href="barrel_8cc_source.html#l00044">barrel.cc:44</a></div></div>
<div class="ttc" id="aclassRefineableYoungLaplaceProblem_html_a78f77a299f2770a82378fcccf86a0b71"><div class="ttname"><a href="classRefineableYoungLaplaceProblem.html#a78f77a299f2770a82378fcccf86a0b71">RefineableYoungLaplaceProblem::RefineableYoungLaplaceProblem</a></div><div class="ttdeci">RefineableYoungLaplaceProblem()</div><div class="ttdoc">Constructor:</div><div class="ttdef"><b>Definition:</b> <a href="refineable__t__junction_8cc_source.html#l00226">refineable_t_junction.cc:226</a></div></div>
<div class="ttc" id="aclassRefineableYoungLaplaceProblem_html_a4ec7313c8e4015b0c2af0bbef789e70f"><div class="ttname"><a href="classRefineableYoungLaplaceProblem.html#a4ec7313c8e4015b0c2af0bbef789e70f">RefineableYoungLaplaceProblem::doc_solution</a></div><div class="ttdeci">void doc_solution(DocInfo &amp;doc_info, ofstream &amp;trace_file)</div><div class="ttdoc">Doc the solution. DocInfo object stores flags/labels for where the output gets written to and the tra...</div><div class="ttdef"><b>Definition:</b> <a href="refineable__t__junction_8cc_source.html#l00430">refineable_t_junction.cc:430</a></div></div>
<div class="ttc" id="aclassRefineableYoungLaplaceProblem_html_a24b45d5ecdd1d7dbb678e7f74777bf41"><div class="ttname"><a href="classRefineableYoungLaplaceProblem.html#a24b45d5ecdd1d7dbb678e7f74777bf41">RefineableYoungLaplaceProblem::~RefineableYoungLaplaceProblem</a></div><div class="ttdeci">~RefineableYoungLaplaceProblem()</div><div class="ttdoc">Destructor (empty)</div><div class="ttdef"><b>Definition:</b> <a href="refineable__t__junction_8cc_source.html#l00147">refineable_t_junction.cc:147</a></div></div>
<div class="ttc" id="anamespaceGlobalParameters_html_ac8774b3418c4551091d64ec72c169b2e"><div class="ttname"><a href="namespaceGlobalParameters.html#ac8774b3418c4551091d64ec72c169b2e">GlobalParameters::L_y</a></div><div class="ttdeci">double L_y</div><div class="ttdoc">Width of domain.</div><div class="ttdef"><b>Definition:</b> <a href="common__young__laplace__stuff_8h_source.html#l00097">common_young_laplace_stuff.h:97</a></div></div>
<div class="ttc" id="aclassRefineableYoungLaplaceProblem_html_ab64eb0b58beb3bb096ecc81b1a3f8a4f"><div class="ttname"><a href="classRefineableYoungLaplaceProblem.html#ab64eb0b58beb3bb096ecc81b1a3f8a4f">RefineableYoungLaplaceProblem::actions_before_adapt</a></div><div class="ttdeci">void actions_before_adapt()</div><div class="ttdoc">Actions before adapt: Wipe the mesh of contact angle elements.</div><div class="ttdef"><b>Definition:</b> <a href="refineable__t__junction_8cc_source.html#l00156">refineable_t_junction.cc:156</a></div></div>
<div class="ttc" id="aclassRefineableYoungLaplaceProblem_html"><div class="ttname"><a href="classRefineableYoungLaplaceProblem.html">RefineableYoungLaplaceProblem</a></div><div class="ttdef"><b>Definition:</b> <a href="refineable__t__junction_8cc_source.html#l00138">refineable_t_junction.cc:138</a></div></div>
<div class="ttc" id="acontact__angle_8txt_html_a831d1ad5f0468950f29fbf410fa323b0"><div class="ttname"><a href="contact__angle_8txt.html#a831d1ad5f0468950f29fbf410fa323b0">problem</a></div><div class="ttdeci">mainpage Example problem</div><div class="ttdef"><b>Definition:</b> <a href="contact__angle_8txt_source.html#l00007">contact_angle.txt:7</a></div></div>
<div class="ttc" id="arefineable__t__junction_8cc_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="refineable__t__junction_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdoc">Drive code.</div><div class="ttdef"><b>Definition:</b> <a href="refineable__t__junction_8cc_source.html#l00543">refineable_t_junction.cc:543</a></div></div>
<div class="ttc" id="aclassRefineableYoungLaplaceProblem_html_a36f5dc0f7071ac15fd63c7c477f77fb0"><div class="ttname"><a href="classRefineableYoungLaplaceProblem.html#a36f5dc0f7071ac15fd63c7c477f77fb0">RefineableYoungLaplaceProblem::Contact_angle_mesh_pt</a></div><div class="ttdeci">Mesh * Contact_angle_mesh_pt</div><div class="ttdoc">Pointer to the contact angle mesh.</div><div class="ttdef"><b>Definition:</b> <a href="refineable__t__junction_8cc_source.html#l00208">refineable_t_junction.cc:208</a></div></div>
<div class="ttc" id="anamespaceGlobalParameters_html_a19d04a02b0b5ef5c72e9c30d822e4dc7"><div class="ttname"><a href="namespaceGlobalParameters.html#a19d04a02b0b5ef5c72e9c30d822e4dc7">GlobalParameters::Alpha_max</a></div><div class="ttdeci">double Alpha_max</div><div class="ttdoc">Max. spine angle against horizontal plane.</div><div class="ttdef"><b>Definition:</b> <a href="barrel_8cc_source.html#l00099">barrel.cc:99</a></div></div>
<div class="ttc" id="aclassRefineableYoungLaplaceProblem_html_aa2eab8da1b83091df804ede7c60fac87"><div class="ttname"><a href="classRefineableYoungLaplaceProblem.html#aa2eab8da1b83091df804ede7c60fac87">RefineableYoungLaplaceProblem::actions_after_adapt</a></div><div class="ttdeci">void actions_after_adapt()</div><div class="ttdoc">Actions after adapt: Rebuild the mesh of contact angle elements.</div><div class="ttdef"><b>Definition:</b> <a href="refineable__t__junction_8cc_source.html#l00167">refineable_t_junction.cc:167</a></div></div>
<div class="ttc" id="anamespaceGlobalParameters_html_ac81daf87f8d3f075d9fd108427e70c4f"><div class="ttname"><a href="namespaceGlobalParameters.html#ac81daf87f8d3f075d9fd108427e70c4f">GlobalParameters::spine_base_function</a></div><div class="ttdeci">void spine_base_function(const Vector&lt; double &gt; &amp;x, Vector&lt; double &gt; &amp;spine_B, Vector&lt; Vector&lt; double &gt; &gt; &amp;dspine_B)</div><div class="ttdoc">Spine basis: The position vector to the basis of the spine as a function of the two coordinates x_1 a...</div><div class="ttdef"><b>Definition:</b> <a href="barrel_8cc_source.html#l00072">barrel.cc:72</a></div></div>
<div class="ttc" id="anamespaceGlobalParameters_html_a36ebf514fdd1e78fff69907b39e25af6"><div class="ttname"><a href="namespaceGlobalParameters.html#a36ebf514fdd1e78fff69907b39e25af6">GlobalParameters::L_x</a></div><div class="ttdeci">double L_x</div><div class="ttdoc">Length and width of the domain.</div><div class="ttdef"><b>Definition:</b> <a href="common__young__laplace__stuff_8h_source.html#l00096">common_young_laplace_stuff.h:96</a></div></div>
<div class="ttc" id="acontact__angle_8txt_html_a770d352b78a60074a229f760bc2e0179"><div class="ttname"><a href="contact__angle_8txt.html#a770d352b78a60074a229f760bc2e0179">build_global_mesh</a></div><div class="ttdeci">The various sub meshes are now added to the problem and the global mesh is built until build_global_mesh()</div></div>
<div class="ttc" id="aclassRefineableYoungLaplaceProblem_html_a00d1304e030120e76d9f316dd4053116"><div class="ttname"><a href="classRefineableYoungLaplaceProblem.html#a00d1304e030120e76d9f316dd4053116">RefineableYoungLaplaceProblem::create_contact_angle_elements</a></div><div class="ttdeci">void create_contact_angle_elements(const unsigned &amp;b)</div><div class="ttdoc">Create YoungLaplace contact angle elements on the b-th boundary of the bulk mesh and add them to cont...</div><div class="ttdef"><b>Definition:</b> <a href="refineable__t__junction_8cc_source.html#l00373">refineable_t_junction.cc:373</a></div></div>
<div class="ttc" id="anamespaceGlobalParameters_html_a3731f24a02ce4f306d65a9a488f85c96"><div class="ttname"><a href="namespaceGlobalParameters.html#a3731f24a02ce4f306d65a9a488f85c96">GlobalParameters::Controlled_height</a></div><div class="ttdeci">double Controlled_height</div><div class="ttdoc">Height control value.</div><div class="ttdef"><b>Definition:</b> <a href="barrel_8cc_source.html#l00051">barrel.cc:51</a></div></div>
<div class="ttc" id="anamespaceGlobalParameters_html_a82df8c67f58e78a236fb6a0cc8bf8284"><div class="ttname"><a href="namespaceGlobalParameters.html#a82df8c67f58e78a236fb6a0cc8bf8284">GlobalParameters::spine_function</a></div><div class="ttdeci">void spine_function(const Vector&lt; double &gt; &amp;x, Vector&lt; double &gt; &amp;spine, Vector&lt; Vector&lt; double &gt; &gt; &amp;dspine)</div><div class="ttdoc">Spine: The spine vector field as a function of the two coordinates x_1 and x_2, and its derivatives w...</div><div class="ttdef"><b>Definition:</b> <a href="barrel_8cc_source.html#l00104">barrel.cc:104</a></div></div>
<div class="ttc" id="aclassRefineableYoungLaplaceProblem_html_a0791c90a16016372e09faf3f5721ecbe"><div class="ttname"><a href="classRefineableYoungLaplaceProblem.html#a0791c90a16016372e09faf3f5721ecbe">RefineableYoungLaplaceProblem::actions_after_newton_solve</a></div><div class="ttdeci">void actions_after_newton_solve()</div><div class="ttdoc">Update the problem after solve: Empty.</div><div class="ttdef"><b>Definition:</b> <a href="refineable__t__junction_8cc_source.html#l00153">refineable_t_junction.cc:153</a></div></div>
<div class="ttc" id="anamespaceGlobalParameters_html_ae8fa7610a34b7a2a8223eade99a5c22f"><div class="ttname"><a href="namespaceGlobalParameters.html#ae8fa7610a34b7a2a8223eade99a5c22f">GlobalParameters::Alpha_min</a></div><div class="ttdeci">double Alpha_min</div><div class="ttdoc">Min. spine angle against horizontal plane.</div><div class="ttdef"><b>Definition:</b> <a href="barrel_8cc_source.html#l00096">barrel.cc:96</a></div></div>

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Mon Aug 9 2021 09:14:48
        </div>
      </div>
    </footer>
</body>
</html>
