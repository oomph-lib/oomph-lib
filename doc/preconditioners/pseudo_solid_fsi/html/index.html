<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Demo problem: A preconditioner for the solution of fluid-structure interaction problems with (pseudo-)solid fluid mesh updates</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.8 -->
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Demo problem: A preconditioner for the solution of fluid-structure interaction problems with (pseudo-)solid fluid mesh updates </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this tutorial we re-visit the solution of fluid-structure interaction problems with (pseudo-)solid fluid mesh updates, focusing on the efficient solution of the governing equations by GMRES, using the problem-specific block-preconditioner developed in </p><center> Muddle, R.L., Mihajlovic, M. &amp; Heil, M. (2012) An efficient preconditioner for monolithically-coupled large-displacement fluid-structure interaction problems with pseudo-solid mesh updates. <em>Journal of Computational Physics</em> <b>231</b>, 7315-7334. DOI: <a href="http://dx.doi.org/10.1016/j.jcp.2012.07.001">10.1016/j.jcp.2012.07.001</a> </center><p> where full details of the analysis and further results from a variety of other test problems can be found.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="model"></a>
Background: Problem formulation, the resulting linear system and the preconditioner</h1>
<p>We will demonstrate the development and application of the preconditioner using the problem of flow in a 2D channel with an elastic leaflet discussed in <a href="../../../interaction/fsi_channel_with_leaflet/html/index.html">another tutorial</a> and illustrated in the sketch below:</p>
<div class="image">
<img src="fsi_channel_with_leaflet.gif" alt=""/>
<div class="caption">
Sketch of the problem. </div></div>
 <p>Flow is driven (via an imposed parabolic inflow profile) through a 2D channel which is partially obstructed by a thin-walled elastic leaflet. The fluid leaves the domain at the far downstream end of the channel where we assume parallel, axially traction-free outflow.</p>
<p>We use the same discretisation (2D quadrilateral Taylor-Hood elements for the fluid; 1D Hermite beam elements for the leaflet) as in the <a href="../../../interaction/fsi_channel_with_leaflet/html/index.html">original tutorial</a>. However, here we perform the fluid mesh update in response to the deformation of the elastic leaflet using a pseudo-elastic approach. This is done by "wrapping" the underlying <code>QTaylorHoodElement</code> into a <code>PseudoSolidNodeUpdateElement</code> and employing <code>ImposeDisplacementByLagrangeMultiplierElements</code> to impose the deformation of the elastic leaflet onto the (pseudo-solid) fluid mesh. The following tutorials discuss the relevant methodologies:</p><ul>
<li><a href="../../../solid/prescribed_displ_lagr_mult/html/index.html">The use of Lagrange multipliers to impose displacement constraints onto (pseudo-)solids.</a><br  />
<br  />
</li>
<li><a href="../../../interaction/unstructured_fsi/html/index.html">The use of pseudo-elasticity to deform the fluid mesh in FSI problems.</a> <br  />
<br  />
</li>
</ul>
<p>The discretised problem contains the following types of discrete unknowns:</p><ul>
<li>The fluid degrees of freedom (velocities and pressures).<br  />
<br  />
</li>
<li>The nodal positions (real and generalised; the latter representing derivative degrees of freedom in the Hermite elements used to discretise the leaflet; see the <a href="../../../beam/tensioned_string/html/index.html">beam theory tutorial</a> for details) of the elastic leaflet.<br  />
<br  />
</li>
<li>The nodal positions in the fluid mesh. <br  />
<br  />
</li>
<li>The nodal values representing the components of the (vector-valued) Lagrange multipliers which impose the motion of the elastic leaflet on the pseudo-elastic fluid mesh. These unknowns only exist for the fluid nodes on the FSI boundary.</li>
</ul>
<p>Using this classification of the unknowns, the linear system to be solved in the course of the Newton iteration can be re-ordered into the following block structure:  </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[
J_{\rm FSI} \ \Delta {\bf x} = 
 \left[
\begin{array}{c|c|cc}
F&amp; &amp;C_{\rm fx}&amp;\\ \hline C_{\rm sf}&amp;S&amp;C_{\rm sx}&amp;\\ \hline
&amp;&amp;E&amp;C_{\rm xl}\\ &amp;C_{\rm ls}&amp;C_{\rm lx}&amp;\\
\end{array}
\right] \left[
\begin{array}{c}
 \Delta {\bf F}\\ 
\hline \Delta {\bf S}\\ 
\hline \Delta {\bf X}\\ 
\Delta {\bf L}\\
\end{array}
\right] =- \left[
\begin{array}{c}
{\bf r}_{\rm f}\\ 
\hline {\bf r}_{\rm s}\\ 
\hline {\bf r}_{\rm x}\\ 
{\bf r}_{\rm l}\\
\end{array}
\right] 
\ \ \ \ \ \ \ \ (1)
\]" src="form_0.png" width="370" height="63"/>
</p>
<p> where the vector <img class="formulaInl" alt="${\bf F}$" src="form_1.png" width="10" height="10"/> contains the Navier-Stokes (fluid) unknowns (velocities and pressure), <img class="formulaInl" alt="${\bf S}$" src="form_2.png" width="8" height="10"/> represents unknowns describing the deformation of the fluid-loaded solid, <img class="formulaInl" alt="${\bf X}$" src="form_3.png" width="11" height="10"/> represents the nodal positions in the fluid mesh, and <img class="formulaInl" alt="${\bf L}$" src="form_4.png" width="10" height="10"/> contains the discrete Lagrange multipliers which impose the deformation of the FSI boundary in the fluid mesh. The three diagonal blocks in the Jacobian matrix, <img class="formulaInl" alt="$J_{\rm FSI}$" src="form_5.png" width="23" height="13"/>, are the two `&lsquo;single-physics&rsquo;' Jacobian matrices ( <img class="formulaInl" alt="$F$" src="form_6.png" width="10" height="10"/>, the Navier-Stokes Jacobian; <img class="formulaInl" alt="$S$" src="form_7.png" width="9" height="10"/>, the tangent stiffness matrix of the fluid-loaded solid) and the Jacobian,  </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[
J_{\rm PS} = 
\left[
\begin{array}{cc}
E&amp;C_{\rm xl}\\ 
C_{\rm lx}&amp;\\
\end{array}
\right]
\]" src="form_8.png" width="106" height="31"/>
</p>
<p> associated with the Lagrange-multiplier-constrained pseudo-elasticity problem governing the fluid mesh update, discussed in more detail in <a href="../../prescribed_displ_lagr_mult/html/index.html">another tutorial</a>. The non-zero off-diagonal blocks arise through the interactions between the various single-physics problems: <img class="formulaInl" alt="$C_{\rm fx}$" src="form_9.png" width="18" height="13"/> represents the effect of the pseudo-solid unknowns (the nodal positions in the fluid mesh) on the discretised Navier&ndash;Stokes equations &ndash; this incorporates the so-called shape-derivatives and the time-discretised version of the no-slip condition on the FSI boundary which expresses the fluid velocities in terms of the nodal velocities of the fluid mesh. <img class="formulaInl" alt="$C_{\rm sf}$" src="form_10.png" width="16" height="13"/> captures the effect of the fluid traction (pressure and shear stresses) on the fluid-loaded solid. Since the shear stresses depend on gradients of the fluid velocity, the traction is also affected by the nodal positions in the fluid mesh &ndash; this dependency gives rise to the matrix <img class="formulaInl" alt="$C_{\rm sx}$" src="form_11.png" width="18" height="13"/>. Finally, <img class="formulaInl" alt="$C_{\rm
ls}$" src="form_12.png" width="15" height="13"/> arises because the prescribed boundary displacement of the fluid mesh depends on the displacement field in the fluid-loaded solid. The zero <img class="formulaInl" alt="$ &quot;fs&quot;
$" src="form_13.png" width="25" height="13"/> block reflects the fact that the discretised Navier-Stokes equations do not depend directly on the displacement field of the actual solid. The zero <img class="formulaInl" alt="$ &quot;xf&quot; $" src="form_14.png" width="26" height="13"/> block indicates that the pseudo-solid equations are not affected by the fluid unknowns. The <img class="formulaInl" alt="$ &quot;xs&quot;$" src="form_15.png" width="25" height="10"/> block is zero because the real solid affects the pseudo-solid only indirectly via the Lagrange multiplier constraint (which gives rise to <img class="formulaInl" alt="$C_{\rm
ls}$" src="form_12.png" width="15" height="13"/>). Finally, the non-zero blocks in the last block column reflect the fact that the Lagrange multiplier is only used to enforce the displacement constraint in a one-way coupling in which the real solid affects the pseudo-solid but not vice versa. See <a href="http://dx.doi.org/10.1016/j.jcp.2012.07.001">Muddle, Mihajlovic &amp; Heil (2012) </a> for more detail.</p>
<p>To construct a preconditioner for the linear system (1) we replace the bottom-right <img class="formulaInl" alt="$2 \times 2$" src="form_16.png" width="28" height="9"/> block in the Jacobian with the pseudo-solid preconditioner,  </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[
{\cal P}_{\rm PS} = \left[
\begin{array}{cc}
E_{\rm aug}&amp;\\
&amp;W
\end{array}
\right]
\ \ \ \ \ \ \ \ \ \ \ \ \ \ (2)
\]" src="form_17.png" width="191" height="31"/>
</p>
<p> which we discussed in <a href="../../prescribed_displ_lagr_mult/html/index.html">another tutorial</a>. This yields the pseudo-solid FSI preconditioner  </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[
{\cal P}_{\rm FSI}=\left[
\begin{array}{c|c|cc}
F&amp; &amp;C_{\rm fx}&amp;\\ \hline
C_{\rm sf}&amp;S&amp;C_{\rm sx}&amp;\\ \hline
&amp;&amp;E_{\rm aug}&amp;\\
&amp;C_{\rm ls}&amp;&amp;W
\end{array}
\right].
\ \ \ \ \ \ (3)
\]" src="form_18.png" width="226" height="63"/>
</p>
<p>The preconditioner can be shown to have a block triangular structure. Its application therefore requires the solution of four subsidiary linear systems involving the matrices <img class="formulaInl" alt="$F$" src="form_6.png" width="10" height="10"/>, <img class="formulaInl" alt="$S$" src="form_7.png" width="9" height="10"/>, <img class="formulaInl" alt="$E_{\rm aug}$" src="form_19.png" width="25" height="14"/> and <img class="formulaInl" alt="$W$" src="form_20.png" width="14" height="10"/> and four sparse matrix-vector products with the interaction matrices <img class="formulaInl" alt="$C_{\rm fx}$" src="form_9.png" width="18" height="13"/>, <img class="formulaInl" alt="$C_{\rm sx}$" src="form_11.png" width="18" height="13"/>, <img class="formulaInl" alt="$C_{\rm sf}$" src="form_10.png" width="16" height="13"/> and <img class="formulaInl" alt="$C_{ls}$" src="form_21.png" width="16" height="13"/>.</p>
<p>Numerical experiments in <a href="http://dx.doi.org/10.1016/j.jcp.2012.07.001">Muddle, Mihajlovic &amp; Heil (2012) </a> show that an efficient implementation of the preconditioner is obtained by</p><ul>
<li>replacing the solution of the linear system involving <img class="formulaInl" alt="${\cal P}_{\rm PS}$" src="form_22.png" width="21" height="13"/> by the approximation <img class="formulaInl" alt="$\widetilde{\cal P}_{\rm PS}$" src="form_23.png" width="21" height="15"/> discussed in <a href="../../prescribed_displ_lagr_mult/html/index.html">another tutorial,</a> <br  />
<br  />
</li>
<li>replacing the solution of the linear system involving the Navier-Stokes Jacobian <img class="formulaInl" alt="$ F $" src="form_24.png" width="10" height="10"/> by an application of Elman, Silvester and Wathen's <a href="../../lsc_navier_stokes/html/index.html">Least-Squares Commutator (LSC) preconditioner</a>,</li>
</ul>
<p>and by replacing the remaining block-solves within these preconditioners by a small number of AMG cycles or CG iterations. We retain SuperLU as the (exact) direct solver for the linear system involving the real solid's tangent stiffness matrix <img class="formulaInl" alt="$ S $" src="form_25.png" width="9" height="10"/>.</p>
<p>With these approximations, the computational cost of one application of the preconditioner is linear in the number of unknowns (see <a class="el" href="index.html#comm_and_ex">Comments and Exercises</a> for a more detailed discussion of this issue). The optimality of the preconditioner can therefore be assessed by demonstrating that the number of GMRES iterations remains constant under mesh refinement.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="implementation"></a>
Implementation and use of the preconditioner</h1>
<p>The preconditioner described above is implemented within <code>oomph-lib's</code> (parallel) block preconditioning framework which is described in <a href="../../../mpi/block_preconditioners/html/index.html">another tutorial</a>. For the purpose of the implementation, we decompose the preconditioning matrix into the 3x3 main blocks indicated by the vertical and horizontal lines in (1) and (3).</p>
<p>The degrees of freedom within these sub-blocks are classified into "dof-types" on an element-by-element basis, using the functions</p><ul>
<li><code>GeneralisedElement::ndof_types(...)</code> which returns the number of dof types classified by that element.</li>
<li><code>GeneralisedElement::get_block_numbers_for_unknowns(...)</code> which associates each degree of freedom (identified by its global equation number) with the dof type within its block. <br  />
<br  />
</li>
</ul>
<p>The default implementation of these functions within the Navier-Stokes elements (which differentiate between the fluid velocity components and the pressure) and the beam elements (which do not distinguish between the different types of degree of freedom) is appropriate for the use with the (subsidiary) preconditioners employed here. The degrees of freedom representing the nodal positions in the (pseudo-solid) fluid mesh need to be sub-divided into those that are and are not constrained by the Lagrange multipliers that impose the deformation of the FSI boundary. This is most conveniently done by overloading the relevant functions in a templated wrapper element, <code>PseudoElasticBulkElement&lt;...&gt;</code>, <br  />
 as discussed in <a href="../../prescribed_displ_lagr_mult/html/index.html">another tutorial.</a></p>
<hr  />
 <hr  />
<h1><a class="anchor" id="results"></a>
Results</h1>
<p>We examine the performance of the preconditioner in steady and unsteady test problems. First we perform a sequence of steady solves, incrementing the Reynolds number in steps of 25. The final steady solution is then used as the initial condition for an unsteady simulation in which the inflow is subjected to a time-periodic oscillation. The tables below show the GMRES iteration counts (averaged over all linear solves performed in the course of all Newton iterations) as a function of the mesh refinement (represented by the total number of unknowns) for different implementations of the preconditioner.</p>
<center>Average GMRES iteration counts (steady runs)<table border="1">
<tr>
<td><code>n_dof</code>  </td><td>9570  </td><td>38724  </td><td>87462  </td><td>155784   </td></tr>
<tr>
<td>GMRES (blocks solved by SuperLU) </td><td>5.88889  </td><td>5.88889  </td><td>5.88889  </td><td>6.11111   </td></tr>
<tr>
<td>GMRES (LSC; blocks solved by SuperLU) </td><td>27.8889  </td><td>36.1111  </td><td>42.3333  </td><td>47.2222   </td></tr>
<tr>
<td>GMRES (LSC; pseudo-solid; blocks solved by Hypre/CG) </td><td>37.3333  </td><td>43.2222  </td><td>49.3333  </td><td>55.3333   </td></tr>
</table>
</center><center><br  />
<br  />
Average GMRES iteration counts (unsteady runs)<table border="1">
<tr>
<td><code>n_dof</code>  </td><td>9570  </td><td>38724  </td><td>87462  </td><td>155784   </td></tr>
<tr>
<td>GMRES (blocks solved by SuperLU) </td><td>6.5124  </td><td>6.95868  </td><td>7.15323  </td><td>7.2619   </td></tr>
<tr>
<td>GMRES (LSC; blocks solved by SuperLU) </td><td>15  </td><td>15.9256  </td><td>16.2097  </td><td>16.6429   </td></tr>
<tr>
<td>GMRES (LSC; pseudo-solid; blocks solved by Hypre/CG) </td><td>22.2066  </td><td>25.3967  </td><td>27.0484  </td><td>27.9921   </td></tr>
</table>
</center><p>As expected from the theory (see <a href="http://dx.doi.org/10.1016/j.jcp.2012.07.001">Muddle, Mihajlovic &amp; Heil (2012)</a>), the GMRES iteration counts are small and virtually mesh independent for the exact implementation of the preconditioner. Replacing the (costly) exact solves by (faster) approximate solves leads to a modest increase in the (absolute) number of GMRES iterations. The most significant deterioration of the iteration counts results from the use of the LSC Navier Stokes preconditioner as the inexact solver (subsidiary preconditioner) for the Navier-Stokes block. The behaviour observed here (slight mesh dependence for steady solves; virtual mesh independence (once the mesh is sufficiently fine) for unsteady solves) mirrors that observed in single-physics Navier-Stokes problems.</p>
<p>The benefit of switching to the approximate solves becomes apparent in the next two tables which shows the average cpu times required for the solution of the linear systems by GMRES. (For comparison the times labelled as <b>"SuperLU"</b> show the times when the linear systems (1) are solved directly by SuperLU rather than by GMRES; they illustrate how quickly direct solvers become uncompetitive.) For sufficiently fine discretisations the larger number of GMRES iterations for the inexact solves is more than compensated for by the much lower cost of the preconditioning operations. The final implementation yields cpu times that (at least for unsteady problems) are proportional to the number of unknowns &ndash; the hallmark of an optimal solver.</p>
<center>Average linear solver times (steady runs; sec)<table border="1">
<tr>
<td><code>n_dof</code>  </td><td>9570  </td><td>38724  </td><td>87462  </td><td>155784   </td></tr>
<tr>
<td>SuperLU </td><td>2.71863  </td><td>33.7939  </td><td>129.248  </td><td>325.384   </td></tr>
<tr>
<td>GMRES (blocks solved by SuperLU) </td><td>2.31567  </td><td>15.1042  </td><td>58.5491  </td><td>147.531   </td></tr>
<tr>
<td>GMRES (LSC; blocks solved by SuperLU) </td><td>2.8051  </td><td>18.3197  </td><td>58.7335  </td><td>138.558   </td></tr>
<tr>
<td>GMRES (LSC; pseudo-solid; blocks solved by Hypre/CG) </td><td>3.47733  </td><td>15.1812  </td><td>37.6856  </td><td>73.0526   </td></tr>
</table>
</center><center><br  />
<br  />
Average linear solver times (unsteady runs; sec)<table border="1">
<tr>
<td><code>n_dof</code>  </td><td>9570  </td><td>38724  </td><td>87462  </td><td>155784   </td></tr>
<tr>
<td>SuperLU </td><td>2.06807  </td><td>25.7064  </td><td>99.7166  </td><td>248.082   </td></tr>
<tr>
<td>GMRES (blocks solved by SuperLU) </td><td>1.73668  </td><td>11.1679  </td><td>42.2051  </td><td>105.97   </td></tr>
<tr>
<td>GMRES (LSC; blocks solved by SuperLU) </td><td>1.87403  </td><td>11.0113  </td><td>34.2697  </td><td>81.4382   </td></tr>
<tr>
<td>GMRES (LSC; pseudo-solid; blocks solved by Hypre/CG) </td><td>2.26537  </td><td>9.40194  </td><td>22.5644  </td><td>41.8251   </td></tr>
</table>
</center><hr  />
 <hr  />
<h1><a class="anchor" id="modifications"></a>
Modifications to the driver code</h1>
<p>Most of the driver code is unchanged from the implementation discussed in the <a href="../../../interaction/fsi_channel_with_leaflet/html/index.html">original tutorial.</a> We therefore only discuss the modifications required</p><ul>
<li>to perform the fluid mesh update using (pseudo-)elasticity,</li>
</ul>
<p>and</p><ul>
<li>to employ preconditioned GMRES as the linear solver in the Newton method.</li>
</ul>
<hr  />
<h2><a class="anchor" id="pseudo-solid"></a>
Fluid-mesh udate by pseudo-elasticity</h2>
<p>To perform the node update in the fluid mesh in response to the deformation of the leaflet using the equations of large-displacement elasticity we "wrap" the Navier-Stokes element in the doubly-templated <code>PseudoSolidNodeUpdateElement&lt;WRAPPED_ELEMENT, SOLID_ELEMENT&gt;</code> class. The first template argument of this class, <code>WRAPPED_ELEMENT</code>, specifies the type of the "wrapped" element &ndash; here the nine-node, 2D quadrilateral <code>QTaylorHoodElement&lt;2&gt;</code>. The second template argument, <code>SOLID_ELEMENT</code>, specifies the <code>SolidElement</code> used to perform the node update &ndash; here the nine-node, 2D quadrilateral <code>QPVDElement&lt;2,3&gt;</code>. Since the preconditioner requires the (re-)classification of the pseudo-solid degrees of freedom into constrained and unconstrained nodal positions, we wrap this element too, using the <code>PseudoElasticBulkElement</code> already discussed in <a href="../../prescribed_displ_lagr_mult/html/index.html">another tutorial</a>. The full specification of the fluid element is therefore given by </p><div class="fragment"><div class="line">PseudoSolidNodeUpdateElement&lt;QTaylorHoodElement&lt;2&gt;,</div>
<div class="line">                             PseudoElasticBulkElement&lt;QPVDElement&lt;2,3&gt; &gt; &gt; </div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="driver"></a>
Modifications to the main code</h2>
<p>The main code only requires minor changes, all associated with the specification of different solver options. Since we provide the option to use Hypre and Trilinos solvers, we need to activate MPI if <code>oomph-lib</code> has been compiled with MPI support (even if the code is run in serial):</p>
 <div class="fragment"><div class="line"><span class="comment">//=======start_of_main=====================================================</span></div>
<div class="line"><span class="comment">/// Driver code </span></div>
<div class="line"><span class="comment">//=========================================================================</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="fsi__channel__with__leaflet__precond_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#ifdef OOMPH_HAS_MPI</span></div>
<div class="line"> MPI_Helpers::init(argc,argv);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="ttc" id="afsi__channel__with__leaflet__precond_8cc_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="fsi__channel__with__leaflet__precond_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdoc">Driver code.</div><div class="ttdef"><b>Definition</b> <a href="fsi__channel__with__leaflet__precond_8cc_source.html#l01068">fsi_channel_with_leaflet_precond.cc:1068</a></div></div>
</div><!-- fragment --><p> Next we define and process the possible command line flags which are used to select solver options and to specify the spatial resolution</p>
<div class="fragment"><div class="line"> <span class="comment">// Store command line arguments</span></div>
<div class="line"> CommandLineArgs::setup(argc,argv);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Multiplier for number of elements in coordinate directions.</span></div>
<div class="line"> <span class="comment">// Used for uniform mesh refinement studies.</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> mesh_multiplier = 2; </div>
<div class="line"> CommandLineArgs::specify_command_line_flag(<span class="stringliteral">&quot;--mesh_multiplier&quot;</span>,</div>
<div class="line">                                            &amp;mesh_multiplier);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Suppress use of LSC preconditioner for Navier Stokes block</span></div>
<div class="line"> CommandLineArgs::specify_command_line_flag(<span class="stringliteral">&quot;--suppress_lsc&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Use direct solver (SuperLU)</span></div>
<div class="line"> CommandLineArgs::specify_command_line_flag(<span class="stringliteral">&quot;--use_direct_solver&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Use SuperLU for all block solves</span></div>
<div class="line"> CommandLineArgs::specify_command_line_flag(<span class="stringliteral">&quot;--superlu_for_blocks&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Validation only?</span></div>
<div class="line"> CommandLineArgs::specify_command_line_flag(<span class="stringliteral">&quot;--validate&quot;</span>);</div>
</div><!-- fragment --><p> We then assign the command line flags that were specified and document the ones that were recognised, before building the problem, specifying the heavily wrapped version of the <code>Navier-Stokes</code> element as the template parameter.</p>
<div class="fragment"><div class="line"> <span class="comment">// Parse command line</span></div>
<div class="line"> CommandLineArgs::parse_and_assign(); </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Doc what has actually been specified on the command line</span></div>
<div class="line"> CommandLineArgs::doc_specified_flags();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Set up the problem</span></div>
<div class="line"> <a class="code hl_class" href="classFSIChannelWithLeafletProblem.html">FSIChannelWithLeafletProblem</a>&lt;PseudoSolidNodeUpdateElement</div>
<div class="line">                              &lt;QTaylorHoodElement&lt;2&gt;,</div>
<div class="line">                               PseudoElasticBulkElement&lt;QPVDElement&lt;2,3&gt; &gt; &gt; &gt;* </div>
<div class="line">  problem_pt = <span class="keyword">new</span>  </div>
<div class="line">  <a class="code hl_class" href="classFSIChannelWithLeafletProblem.html">FSIChannelWithLeafletProblem</a>&lt;PseudoSolidNodeUpdateElement</div>
<div class="line">                               &lt;QTaylorHoodElement&lt;2&gt;,</div>
<div class="line">                                PseudoElasticBulkElement&lt;QPVDElement&lt;2,3&gt; &gt; &gt; &gt;</div>
<div class="line">  (mesh_multiplier);</div>
<div class="ttc" id="aclassFSIChannelWithLeafletProblem_html"><div class="ttname"><a href="classFSIChannelWithLeafletProblem.html">FSIChannelWithLeafletProblem</a></div><div class="ttdoc">FSI leaflet in channel. Mesh update with pseudo-elasticity and solved with pseudo-elastic fsi precond...</div><div class="ttdef"><b>Definition</b> <a href="fsi__channel__with__leaflet__precond_8cc_source.html#l00347">fsi_channel_with_leaflet_precond.cc:348</a></div></div>
</div><!-- fragment --><p> The rest of the main code is very similar to the original version discussed in <a href="../../../interaction/fsi_channel_with_leaflet/html/index.html">another tutorial</a> and is therefore omitted here.</p>
<hr  />
<h2><a class="anchor" id="it_solve"></a>
Choosing the iterative solver and preconditioner</h2>
<p>We provide a new function, <code>set_iterative_solver()</code> to switch the solver to GMRES and to instantiate the FSI preconditioner. We start by creating the GMRES solver, using Trilinos' implementation if it is available:</p>
 <div class="fragment"><div class="line"><span class="comment">//===========start_iterative_solver=========================================</span></div>
<div class="line"><span class="comment">/// Set iterative solver </span></div>
<div class="line"><span class="comment">//==========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="classFSIChannelWithLeafletProblem.html#a8ca939c0edc4194e4e5cb7d1404f27de">FSIChannelWithLeafletProblem&lt;ELEMENT&gt;::set_iterative_solver</a>()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Create the linear solver</span></div>
<div class="line"> IterativeLinearSolver* solver_pt=0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// If we have trilinos, use it</span></div>
<div class="line"><span class="preprocessor">#ifdef OOMPH_HAS_TRILINOS</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create solver</span></div>
<div class="line"> solver_pt = <span class="keyword">new</span> TrilinosAztecOOSolver;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Use GMRES</span></div>
<div class="line"> <span class="keyword">dynamic_cast&lt;</span>TrilinosAztecOOSolver*<span class="keyword">&gt;</span>(solver_pt)-&gt;solver_type() </div>
<div class="line">  = TrilinosAztecOOSolver::GMRES;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Use oomph-lib&#39;s own GMRES</span></div>
<div class="line"> solver_pt = <span class="keyword">new</span> GMRES&lt;CRDoubleMatrix&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set solver</span></div>
<div class="line"> linear_solver_pt() = solver_pt;</div>
<div class="ttc" id="aclassFSIChannelWithLeafletProblem_html_a8ca939c0edc4194e4e5cb7d1404f27de"><div class="ttname"><a href="classFSIChannelWithLeafletProblem.html#a8ca939c0edc4194e4e5cb7d1404f27de">FSIChannelWithLeafletProblem::set_iterative_solver</a></div><div class="ttdeci">void set_iterative_solver()</div><div class="ttdoc">Set iterative solver.</div><div class="ttdef"><b>Definition</b> <a href="fsi__channel__with__leaflet__precond_8cc_source.html#l00733">fsi_channel_with_leaflet_precond.cc:733</a></div></div>
</div><!-- fragment --><p> Next, we create an instance of the FSI preconditioner for a 2D problem and pass it to the solver:</p>
<div class="fragment"><div class="line">  </div>
<div class="line"> <span class="comment">// Create preconditioner for 2D problem</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> dim=2;</div>
<div class="line"> PseudoElasticFSIPreconditioner* prec_pt=</div>
<div class="line">  <span class="keyword">new</span> PseudoElasticFSIPreconditioner(dim, <span class="keyword">this</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set preconditioner</span></div>
<div class="line"> solver_pt-&gt;preconditioner_pt() = prec_pt;</div>
</div><!-- fragment --><p> The classification of the degrees of freedom within the block preconditioning framework requires the specification of the (pseudo-solid) fluid mesh, the "real" solid mesh and the mesh containing the Lagrange multiplier elements that impose the deformation of the FSI boundary in the fluid mesh:</p>
<div class="fragment"><div class="line"> <span class="comment">// Specify meshes that contain elements which classify the various</span></div>
<div class="line"> <span class="comment">// degrees of freedom:</span></div>
<div class="line"> prec_pt-&gt;set_fluid_and_pseudo_elastic_mesh_pt(Bulk_mesh_pt);</div>
<div class="line"> prec_pt-&gt;set_solid_mesh_pt(Wall_mesh_pt);</div>
<div class="line"> prec_pt-&gt;set_lagrange_multiplier_mesh_pt(Lagrange_multiplier_mesh_pt);</div>
</div><!-- fragment --><p> We provide the option to bypass the use of the LSC Schur complement preconditioner as the subsidiary preconditioner (inexact solver) for the Navier-Stokes block:</p>
<div class="fragment"><div class="line"> <span class="comment">// Use oomph-lib&#39;s Schur complement preconditioner as Navier-Stokes</span></div>
<div class="line"> <span class="comment">// subsidiary preconditioner</span></div>
<div class="line"> <span class="keywordflow">if</span> (!CommandLineArgs::command_line_flag_has_been_set(<span class="stringliteral">&quot;--suppress_lsc&quot;</span>))</div>
<div class="line">  {</div>
<div class="line">   oomph_info &lt;&lt; <span class="stringliteral">&quot;Enabling LSC preconditioner\n&quot;</span>;</div>
<div class="line">   prec_pt-&gt;enable_navier_stokes_schur_complement_preconditioner();</div>
<div class="line">  }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">   prec_pt-&gt;disable_navier_stokes_schur_complement_preconditioner();</div>
<div class="line">   oomph_info &lt;&lt; <span class="stringliteral">&quot;Not using LSC preconditioner\n&quot;</span>;</div>
<div class="line">  } <span class="comment">// done disable lsc</span></div>
</div><!-- fragment --><p> By default the preconditioner performs the preconditioning operations as described above, using SuperLU for the block solves in (3). It is possible to specify alternative (approximate) solvers for these. For instance, the behaviour of the LSC preconditioner can be modified by following the pointer to the Schur complement preconditioner</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Use approximate block solves?</span></div>
<div class="line"> <span class="comment">//------------------------------</span></div>
<div class="line"> <span class="keywordflow">if</span> (CommandLineArgs::command_line_flag_has_been_set(<span class="stringliteral">&quot;--superlu_for_blocks&quot;</span>))</div>
<div class="line">  {</div>
<div class="line">   oomph_info &lt;&lt; <span class="stringliteral">&quot;Use SuperLU for block solves\n&quot;</span>;</div>
<div class="line">  }</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">   oomph_info &lt;&lt; <span class="stringliteral">&quot;Use optimal block solves\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Get pointer to Navier-Stokes Schur complement preconditioner</span></div>
<div class="line">   NavierStokesSchurComplementPreconditioner* ns_prec_pt = </div>
<div class="line">    prec_pt-&gt;navier_stokes_schur_complement_preconditioner_pt();</div>
</div><!-- fragment --><p> whose behaviour can be modified as discussed in <a href="../../../preconditioners/lsc_navier_stokes/html/index.html">LSC preconditioner tutorial</a>. For instance, to use a block-triangular approximation for the Navier-Stokes momentum block we specify</p>
<div class="fragment"><div class="line"> </div>
<div class="line">   <span class="comment">// Navier Stokes momentum block</span></div>
<div class="line">   <span class="comment">//-----------------------------</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Block triangular for momentum block in LSC precond</span></div>
<div class="line">   BlockTriangularPreconditioner&lt;CRDoubleMatrix&gt;*</div>
<div class="line">    f_prec_pt = <span class="keyword">new</span> BlockTriangularPreconditioner&lt;CRDoubleMatrix&gt;;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set it</span></div>
<div class="line">   ns_prec_pt-&gt;set_f_preconditioner(f_prec_pt);  </div>
</div><!-- fragment --><p> If Hypre is available, we can then (approximately) solve the diagonal blocks using a small number of AMG V-cycles (with settings specified in the helper function <code><a class="el" href="namespaceLSC__Preconditioner__Helper.html#a3ddbb4dc9864cc9ce3901001447560a0" title="Create instance of Hypre preconditioner with settings that are appropriate for serial solution of Nav...">LSC_Preconditioner_Helper::set_hypre_preconditioner</a></code>):</p>
<div class="fragment"><div class="line">   </div>
<div class="line"><span class="preprocessor">#ifdef OOMPH_HAS_HYPRE</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Use Hypre for diagonal blocks</span></div>
<div class="line">   f_prec_pt-&gt;set_subsidiary_preconditioner_function</div>
<div class="line">    (<a class="code hl_function" href="namespaceLSC__Preconditioner__Helper.html#a3ddbb4dc9864cc9ce3901001447560a0">LSC_Preconditioner_Helper::set_hypre_preconditioner</a>);</div>
<div class="ttc" id="anamespaceLSC__Preconditioner__Helper_html_a3ddbb4dc9864cc9ce3901001447560a0"><div class="ttname"><a href="namespaceLSC__Preconditioner__Helper.html#a3ddbb4dc9864cc9ce3901001447560a0">LSC_Preconditioner_Helper::set_hypre_preconditioner</a></div><div class="ttdeci">Preconditioner * set_hypre_preconditioner()</div><div class="ttdoc">Create instance of Hypre preconditioner with settings that are appropriate for serial solution of Nav...</div><div class="ttdef"><b>Definition</b> <a href="fsi__channel__with__leaflet__precond_8cc_source.html#l00165">fsi_channel_with_leaflet_precond.cc:165</a></div></div>
</div><!-- fragment --><p>Similarly, we can use Hypre (with settings appropriate for a 2D Poisson problem) to approximately solve the pressure Poisson systems in the computations of the Schur complement approximation:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Navier Stokes Schur complement/pressure block</span></div>
<div class="line">   <span class="comment">//----------------------------------------------</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Build/set Hypre for Schur complement (pressure) block</span></div>
<div class="line">   HyprePreconditioner* p_prec_pt = <span class="keyword">new</span> HyprePreconditioner;</div>
<div class="line">   p_prec_pt-&gt;disable_doc_time();   </div>
<div class="line">   Hypre_default_settings::set_defaults_for_2D_poisson_problem(p_prec_pt);   </div>
<div class="line">   ns_prec_pt-&gt;set_p_preconditioner(p_prec_pt); </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> Approximate solvers for the diagonal blocks in the preconditioner (2) for the the Lagrange-multiplier constrained pseudo-elastic equations can be chosen as discussed in <a href="../../prescribed_displ_lagr_mult/html/index.html">another tutorial</a>. For instance, we can employ a block-upper triangular approximation for the augmented pseudo-elastic block <img class="formulaInl" alt="$E_{\rm aug}$" src="form_19.png" width="25" height="14"/>:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">   <span class="comment">// Pseudo elastic block</span></div>
<div class="line">   <span class="comment">//---------------------</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Use block upper triangular preconditioner for (pseudo-)elastic block</span></div>
<div class="line">   prec_pt-&gt;pseudo_elastic_preconditioner_pt()-&gt;elastic_preconditioner_type()</div>
<div class="line">    = PseudoElasticPreconditioner::Block_upper_triangular_preconditioner;</div>
</div><!-- fragment --><p> Its diagonal blocks can then again be solved by Hypre,</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef OOMPH_HAS_HYPRE</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Use Hypre for diagonal blocks of (pseudo-)elastic preconditioner</span></div>
<div class="line">   prec_pt-&gt;pseudo_elastic_preconditioner_pt()-&gt;</div>
<div class="line">    set_elastic_subsidiary_preconditioner(</div>
<div class="line">     Pseudo_Elastic_Preconditioner_Subsidiary_Operator_Helper::</div>
<div class="line">     get_elastic_preconditioner_hypre);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> Similarly, the linear systems involving the mass matrices in <img class="formulaInl" alt="$ W $" src="form_26.png" width="14" height="10"/> can be solved using diagonally preconditioned CG:</p>
<div class="fragment"><div class="line">   </div>
<div class="line"><span class="preprocessor">#ifdef OOMPH_HAS_TRILINOS</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Use Trilinos CG as subsidiary preconditioner (inexact solver) for</span></div>
<div class="line">   <span class="comment">// linear (sub-)systems to be solved in the Lagrange multiplier block</span></div>
<div class="line">   prec_pt-&gt;pseudo_elastic_preconditioner_pt()-&gt;</div>
<div class="line">    set_lagrange_multiplier_subsidiary_preconditioner</div>
<div class="line">    (Pseudo_Elastic_Preconditioner_Subsidiary_Operator_Helper::</div>
<div class="line">     get_lagrange_multiplier_preconditioner);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">//end set_iterative_solver</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="comm_and_ex"></a>
Comments and Exercises</h1>
<h2><a class="anchor" id="comm"></a>
Comments</h2>
<ul>
<li>Further details of the theory, such as the proof of the optimality of the preconditioner, can be found in <a href="http://dx.doi.org/10.1016/j.jcp.2012.07.001">Muddle, Mihajlovic &amp; Heil (2012).</a><br  />
<br  />
</li>
<li>Note that we retained SuperLU as the solver for the linear system involving the tangent stiffness matrix <img class="formulaInl" alt="$ S $" src="form_25.png" width="9" height="10"/> of the actual, fluid-load solid. In the present example this still leads to an optimal solver since the leaflet is modelled as a 1D beam structure whose number of unknowns increases much more slowly than the number of unknowns in the fluid mesh when the meshes are refined uniformly. If the solid is modelled as a "proper" solid, the use of a direct solver for the solution of the linear systems involving <img class="formulaInl" alt="$ S $" src="form_25.png" width="9" height="10"/> becomes sub-optimal. The member function <div class="fragment"><div class="line">PseudoElasticFSIPreconditioner::set_solid_preconditioner(...)</div>
</div><!-- fragment --> can then be used to specify a subsidiary preconditioner (inexact solver) for the linear systems involving <img class="formulaInl" alt="$ S $" src="form_25.png" width="9" height="10"/>. <br  />
<br  />
</li>
</ul>
<h2><a class="anchor" id="ex"></a>
Exercises</h2>
<ol type="1">
<li>Experiment with different preconditioner settings and explore the performance of the preconditioner at different Reynolds numbers. The script <a href="../../../../demo_drivers/interaction/pseudo_solid_fsi_channel_with_leaflet/run.sh"><code>run.sh</code></a> used to generate the data presented above, may be helpful.</li>
</ol>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory:<br  />
<br  />
<center> <a href="../../../../demo_drivers/interaction/pseudo_solid_fsi_channel_with_leaflet">demo_drivers/interaction/pseudo_solid_fsi_channel_with_leaflet </a> </center><br  />
</li>
<li>The driver code is: <br  />
<br  />
<center> <a href="../../../../demo_drivers/interaction/pseudo_solid_fsi_channel_with_leaflet/fsi_channel_with_leaflet_precond.cc">demo_drivers/interaction/pseudo_solid_fsi_channel_with_leaflet/fsi_channel_with_leaflet_precond.cc</a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. \ </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Tue Jan 13 2026 16:28:42
        </div>
      </div>
    </footer>
</body>
</html>
