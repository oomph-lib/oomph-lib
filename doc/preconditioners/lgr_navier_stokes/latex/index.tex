The purpose of this tutorial is to show how to use {\ttfamily oomph-\/lib\textquotesingle{}s} Lagrange Enforced Flow Navier-\/\+Stokes preconditioner. Similarly to the problem considered in the \href{../../../navier_stokes/vmtk_fluid/html/index.html}{\texttt{ Steady finite-\/\+Reynolds-\/number flow through an iliac bifurcation}} tutorial, the outflow boundary of the demo problem (discussed below) are not aligned with any coordinate planes. Parallel outflow is therefore enforced by a Lagrange multiplier method, implemented using {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Face\+Element} framework.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_model}{}\doxysection{The model problem, theory and preconditioner}\label{index_model}
We will demonstrate the development and application of the preconditioner using the Poiseuille flow through a unit square domain $\Omega^{[\alpha]} \in \mathbb{R}^2$ rotated by an arbitrary angle $\alpha$ (see the figure below). The domain $\Omega^{[\alpha]}$ is obtained by rotating the discrete points $(x_1,x_2)$ in the unit square $\Omega = [0,1]^2$ by the following transformation \[ R(\alpha)= \left( \begin{array}{cc} {\cos(\alpha)} & {-\sin(\alpha)} \\ {\sin(\alpha)} & {\cos(\alpha)} \end{array} \right), \ \ \ \ \ \ \ \ \ \ (1) \] where $\alpha$ is the angle of rotation. The figure below show the flow field (velocity vectors and pressure contours) for a unit square domain rotated by an angle of $\alpha=30^\circ $ and a Reynolds number of $ Re = 100 $. The flow is driven by a prescribed parabolic boundary condition.

 
\begin{DoxyImage}
\includegraphics[width=0.4\textwidth]{SimAng30Rey100Noel4}
\doxyfigcaption{Velocity field and pressure }
\end{DoxyImage}


For convenience, we present the boundary conditions for the non-\/rotated unit square $\alpha = 0^{\circ}$. In order to obtain the boundary conditions for $\alpha \ne 0^\circ$, we only have to apply the rotation (1). The flow is driven by imposing a parabolic velocity profile along the inflow boundary $\Omega_I$. Along the characteristic boundary, $\Omega_C$, the no-\/slip condition $u_i = 0$, $i = 1,2$, is prescribed. We impose `parallel outflow' along the outlet $\Omega_O$ by insisting that \[ {\bf u}\cdot {\bf t}_{} = 0 \mbox{\ \ \ \ on $\Omega_{O}$,} \ \ \ \ \ \ \ \ \ \ (2) \] where $ {\bf t}$ is the tangent vector at each discrete point on the boundary $ \Omega_{O}$. We weakly enforce the flow constraint by augmenting the Navier-\/\+Stokes momentum residual equation (introduced in the \href{../../../navier_stokes/rayleigh_traction_channel/html/index.html}{\texttt{ Unsteady flow in a 2D channel, driven by an applied traction}} tutorial) with a Lagrange multiplier term so that it becomes \[ r_{il}^{u} = \int_\Omega \left[ Re \left( St\frac{\partial u_i}{\partial t} + u_j\frac{\partial u_i}{\partial x_j} \right) \psi_l + \tau_{ij}\frac{\partial \psi_l}{\partial x_j} \right] d\Omega - \int_{\partial\Omega} \tau_{ij} n_j\psi_l dS + \delta \Pi_{constraint} = 0, \ \ \ \ \ \ \ \ \ \ (3) \] where \[ \Pi_{constraint} = \int_{\partial \Omega} \lambda u_i t_i dS, \ \ \ \ \ \ \ \ \ \ (4) \] and $\lambda$ is the Lagrange multiplier. Upon taking the first variation of the constraint with respect to the unknown velocity and the Lagrange multiplier, the residual form of the constrained momentum equation is \[ r_{il}^{u} = \int_\Omega \left[ Re \left( St\frac{\partial u_i}{\partial t} + u_j\frac{\partial u_i}{\partial x_j} \right) \psi_l + \tau_{ij}\frac{\partial \psi_l}{\partial x_j} \right] d\Omega - \int_{\partial\Omega} \tau_{ij} n_j\psi_l dS + \int_{\partial\Omega} \lambda\psi_l t_i = 0. \ \ \ \ \ \ \ \ \ \ (5) \] The weak formulation of (2) is simply \[ r_{l}^{\lambda} = \int_\Omega u_i t_i \psi^\lambda dS = 0, \ \ \ \ \ \ \ \ \ \ (6) \] where $\psi^\lambda$ is a suitable basis function. Equation (5) reveals that the Lagrange multipliers act as the (negative) tangential traction $(\lambda = -{\mathbf{n}}^T{\mathbf{\tau}}{\mathbf{t}})$ that enforce the parallel flow across the boundary $\partial\Omega_{O}$. We discretise this constraint by attaching {\ttfamily Impose\+Parallel\+Outflow\+Elements} to the boundaries of the \char`\"{}bulk\char`\"{} Navier-\/\+Stokes elements that are adjacent to $ \partial \Omega_O $ as shown in the \href{../../../navier_stokes/vmtk_fluid/html/index.html}{\texttt{ Steady finite-\/\+Reynolds-\/number flow through an iliac bifurcation}} tutorial, also see the \href{../../../solid/prescribed_displ_lagr_mult/html/index.html}{\texttt{ Deformation of a solid by a prescribed boundary motion }} tutorial which employs a similar technique used to enforce prescribed boundary displacements in solid mechanics problems. We discretise the Navier-\/\+Stokes equations using {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily QTaylor\+Hood\+Elements}, see the \href{../../../navier_stokes/driven_cavity/html/index.html}{\texttt{ 2D Driven Cavity Problem}} tutorial for more information.

The discretised problem therefore contains the following types of discrete unknowns\+:
\begin{DoxyItemize}
\item The fluid degrees of freedom (velocity and pressure).~\newline
~\newline

\item The nodal values representing the components of the (vector-\/valued) Lagrange multipliers. These only exist for the nodes on $ \partial \Omega_O$. (The nodes are re-\/sized to accommodate the additional unknowns when the {\ttfamily Impose\+Parallel\+Outflow\+Elements} are attached to the bulk elements.)
\end{DoxyItemize}

The preconditioner requires a further sub-\/division of these degrees of freedom into the following categories\+:
\begin{DoxyItemize}
\item the unconstrained velocity in the x-\/direction
\item the unconstrained velocity in the y-\/direction
\item \mbox{[}the unconstrained velocity in the z-\/direction (only in 3D)\mbox{]}
\item the constrained velocity in the x-\/direction
\item the constrained velocity in the y-\/direction
\item \mbox{[}the constrained velocity in the z-\/direction (only in 3D)\mbox{]}
\item the Lagrange multiplier at the constrained nodes
\item \mbox{[}the other Lagrange multiplier at the constrained nodes (only in 3D)\mbox{]}.
\end{DoxyItemize}For a 2D problem, the linear system to be solved in the course of the Newton iteration can then be (formally) re-\/ordered into the following block structure\+:

\[ \left[ \begin{array}{ccccc|c} { F_{\rm xx}}&{ F_{\rm x\bar{\rm x}}}&{ F_{\rm xy}}&{ F_{\rm x\bar{\rm y}}}&{ B_{\rm x}^{T}}&\\ { F_{\bar{\rm x}\rm x}}&{ F_{\bar{\rm x}\bar{\rm x}}}&{ F_{\bar{\rm x}\rm y}}&{ F_{\bar{\rm x}\bar{\rm y}}}&{ B_{\bar{\rm x}}^{T}}&{ M_{\rm x}}\\ { F_{\rm yx}}&{ F_{\rm y\bar{\rm x}}}&{ F_{\rm yy}}&{ F_{\rm y\bar{\rm y}}}&{ B_{\rm y}^{T}}&\\ { F_{\bar{\rm y}\rm x}}&{ F_{\bar{\rm y}\bar{\rm x}}}&{ F_{\bar{\rm y}\rm y}}&{ F_{\bar{\rm y}\bar{\rm y}}}&{ B_{\bar{\rm y}}^{T}}&{ M_{\rm y}}\\ { B_{\rm x}}&{ B_{\bar{\rm x}}}&{ B_{\rm y}}&{ B_{\bar{\rm y}}}&\\ \hline &{ M_{\rm x}}&&{ M_{\rm y}}&& \end{array} \right] \left[ \begin{array}{c} \Delta \mathbf{U}_{\rm x}\\ \Delta \mathbf{\overline{U}}_{\rm x}\\ \Delta \mathbf{U}_{\rm y}\\ \Delta \mathbf{\overline{U}}_{\rm y}\\ \Delta \mathbf{P}\\ \Delta \mathbf{\Lambda} \end{array} \right] = - \left[ \begin{array}{c} \mathbf{r}_{\rm x}\\ \mathbf{r}_{\bar{\rm x}}\\ \mathbf{r}_{\rm y}\\ \mathbf{r}_{\bar{\rm y}}\\ \mathbf{r}_{\rm p}\\ \mathbf{r}_{\rm \Lambda} \end{array} \right]. \ \ \ \ \ \ (7) \] Here the vectors ${\bf U}_{\rm x}$, ${\bf U}_{\rm y}$, ${\bf P}$ and ${\bf \Lambda}$ contain the $x$ and $y$ components of the velocity unknowns, the pressure unknowns and Lagrange multipliers unknowns, respectively. The overbars identify the unknown nodal positions that are constrained by the Lagrange multiplier. The matrices $M_{\rm x}$ and $M_{\rm y}$ are mass-\/like matrices whose entries are formed from products of the basis functions multiplied by a component of the tangent vector at each discrete point on $\partial\Omega_{O}$, for example, $[M_{{\rm x}}]_{ij} = \int_{\partial \Omega_{O}} t_x {\psi_i} \ {\psi_j} \ dS $. Denote \[ J_{\rm NS} = \left[ \begin{array}{ccccc} { F_{\rm xx}}&{ F_{\rm x\bar{\rm x}}}&{ F_{\rm xy}}&{ F_{\rm x\bar{\rm y}}}&{ B_{\rm x}^{T}}\\ { F_{\bar{\rm x}\rm x}}&{ F_{\bar{\rm x}\bar{\rm x}}}&{ F_{\bar{\rm x}\rm y}}&{ F_{\bar{\rm x}\bar{\rm y}}}&{ B_{\bar{\rm x}}^{T}}\\ { F_{\rm yx}}&{ F_{\rm y\bar{\rm x}}}&{ F_{\rm yy}}&{ F_{\rm y\bar{\rm y}}}&{ B_{\rm y}^{T}}\\ { F_{\bar{\rm y}\rm x}}&{ F_{\bar{\rm y}\bar{\rm x}}}&{ F_{\bar{\rm y}\rm y}}&{ F_{\bar{\rm y}\bar{\rm y}}}&{ B_{\bar{\rm y}}^{T}}\\ { B_{\rm x}}&{ B_{\bar{\rm x}}}&{ B_{\rm y}}&{ B_{\bar{\rm y}}} \end{array} \right], \ \ \ L = \left[ \begin{array}{ccccc} &{M_{\rm x}}& &{ M_{\rm x}} & \end{array} \right], \ \ \ \Delta \mathbf{X}_{\rm NS} = \left[ \begin{array}{c} \Delta \mathbf{U}_{\rm x}\\ \Delta \mathbf{\overline{U}}_{\rm x}\\ \Delta \mathbf{U}_{\rm y}\\ \Delta \mathbf{\overline{U}}_{\rm y}\\ \Delta \mathbf{P} \end{array} \right],\mbox{\ \ \ \ and } \ \ \ \mathbf{r}_{\rm NS} = \left[ \begin{array}{c} \mathbf{r}_{\rm x}\\ \mathbf{r}_{\bar{\rm x}}\\ \mathbf{r}_{\rm y}\\ \mathbf{r}_{\bar{\rm y}}\\ \mathbf{r}_{\rm p} \end{array} \right]. \] Then we can re-\/write (7) as \[ \left[ \begin{array}{cc} { J_{\rm NS}}&L^{T}\\ L& \end{array} \right] \left[ \begin{array}{c} \Delta \mathbf{X}_{\rm NS}\\ \Delta \mathbf{\Lambda} \end{array} \right] = - \left[ \begin{array}{c} \mathbf{r}_{\rm NS}\\ \mathbf{r}_{\rm \Lambda} \end{array} \right]. \ \ \ \ \ \ (8) \] We have shown that \[ P= \left[ \begin{array}{cc} { J_{\rm NS}} + L^{T}W^{-1} L& \\ & W \end{array} \right], \ \ \ \ \ \ (9) \] where $W = \frac{1}{\sigma}LL^{T}$ is an optimal preconditioner for the linear system (8) if we set $ \sigma=\|F\|_{\infty} $ where $F$ is the compound $4\times 4$ top-\/left block \[ F = \left[ \begin{array}{ccccc} { F_{\rm xx}}&{ F_{\rm x\bar{\rm x}}}&{ F_{\rm xy}}&{ F_{\rm x\bar{\rm y}}}\\ { F_{\bar{\rm x}\rm x}}&{ F_{\bar{\rm x}\bar{\rm x}}}&{ F_{\bar{\rm x}\rm y}}&{ F_{\bar{\rm x}\bar{\rm y}}}\\ { F_{\rm yx}}&{ F_{\rm y\bar{\rm x}}}&{ F_{\rm yy}}&{ F_{\rm y\bar{\rm y}}}\\ { F_{\bar{\rm y}\rm x}}&{ F_{\bar{\rm y}\bar{\rm x}}}&{ F_{\bar{\rm y}\rm y}}&{ F_{\bar{\rm y}\bar{\rm y}}} \end{array} \right] \] in the Jacobian matrix. Application of the preconditioner $P$ requires the repeated solution of linear systems involving the diagonal blocks ${J_{\rm NS}} + L^{T}W^{-1} L$ and $W$. The matrix $W^{-1} = \sigma (LL^{T})^{-1} = \sigma ({M_{\rm x}}^{2}+{M_{\rm y}^{2}})^{-1}$ is dense and will cause the addition of dense sub-\/matrices to the Jacobian matrix\+: \[ \sigma L^{T}(LL^{T})^{-1}L = \sigma \left[ \begin{array}{ccccc} \cal O &\cal O &\cal O &\cal O &\cal O \\ \cal O&{M_{\rm x}}({M_{\rm x}}^{2}+{M_{\rm y}^{2}})^{-1}{M_{\rm x}}&\cal O &{M_{\rm x}}({M_{\rm x}}^{2}+{M_{\rm y}^{2}})^{-1}{M_{\rm y}}&\cal O \\ \cal O&\cal O &\cal O &\cal O &\cal O \\ \cal O&{M_{\rm y}}({M_{\rm x}}^{2}+{M_{\rm y}^{2}})^{-1}{M_{\rm x}}&\cal O &{M_{\rm y}}({M_{\rm x}}^{2}+{M_{\rm y}^{2}})^{-1}{M_{\rm y}}& \cal O\\ \cal O&\cal O &\cal O &\cal O &\cal O \end{array} \right]. \] Numerical experiments show that an efficient implementation can be obtained by replacing $W$ by its diagonal approximation $\widehat{W} = \mbox{diag}(M_{\rm x}^{2}+M_{\rm y}^{2})$. Then the inversion of $W$ is straight forward and the addition of $L^{T}{\widehat{W}}^{-1}L$ to the Jacobian does not significantly increase the number of non-\/zero entries in the matrix $J_{\rm NS}$. Denote the efficient implementation by \[ \tilde{P} = \left[ \begin{array}{cc} { \tilde{J}_{\rm NS}}& \\ & \widehat{W} \end{array} \right], \ \ \ \ \ \ (10) \] where $\tilde{J}_{\rm NS} =J_{\rm NS}+ L^{T}{\widehat{W}}^{-1}L$ is the augmented Navier-\/\+Stokes Jacobian matrix. In our implementation of the preconditioner, the linear system involving $\tilde{J}_{\rm NS}$ can either be solved \char`\"{}exactly\char`\"{}, using {\ttfamily Super\+LU} (in its incarnation as an exact preconditioner; this is the default) or by any other {\ttfamily Preconditioner} (interpreted as an \char`\"{}inexact solver\char`\"{}) specified via the access function 
\begin{DoxyCode}{0}
\DoxyCodeLine{LagrangeEnforcedFlowPreconditioner::set\_navier\_stokes\_preconditioner(...)}

\end{DoxyCode}
 Numerical experiments show that a nearly optimal preconditioner is obtained by replacing the solution of the linear system involving the augmented Navier-\/\+Stokes Jacobian $ \tilde{J}_{\rm NS} $ by an application of Elman, Silvester and Wathen\textquotesingle{}s \href{../../lsc_navier_stokes/html/index.html}{\texttt{ Least-\/\+Squares Commutator (LSC) preconditioner}}, and by replacing the remaining block-\/solves within these preconditioners by a small number of AMG cycles.

With these approximations, the computational cost of one application of $\tilde P$ is linear in the number of unknowns. The optimality of the preconditioner can therefore be assessed by demonstrating that the number of GMRES iterations remains constant under mesh refinement.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_example}{}\doxysection{Demo driver and use of the preconditioner}\label{index_example}
To demonstrate how to use the preconditioner, here are the relevant extracts from the driver code \href{../../../../demo_drivers/navier_stokes/lagrange_enforced_flow_preconditioner/two_d_tilted_square.cc}{\texttt{ two\+\_\+d\+\_\+tilted\+\_\+square.\+cc}} which solves the model problem described above. As explained in the \href{../../../linear_solvers/html/index.html}{\texttt{ Linear Solvers Tutorial}} switching to an iterative linear solver is typically performed in the {\ttfamily Problem} constructor and involves a few straightforward steps\+:


\begin{DoxyEnumerate}
\item {\bfseries{Create an instance of the Iterative\+Linear\+Solver and pass it to the Problem}} ~\newline
~\newline
 In our problem, we choose right preconditioned {\ttfamily GMRES} as the linear solver\+: ~\newline
~\newline
  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \textcolor{comment}{// Create oomph-\/lib iterative linear solver.}}
\DoxyCodeLine{    IterativeLinearSolver* solver\_pt = \textcolor{keyword}{new} GMRES<CRDoubleMatrix>;}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{comment}{// We use RHS preconditioning. Note that by default,}}
\DoxyCodeLine{    \textcolor{comment}{// left hand preconditioning is used.}}
\DoxyCodeLine{    \textcolor{keyword}{static\_cast<}GMRES<CRDoubleMatrix>*\textcolor{keyword}{>}(solver\_pt)}
\DoxyCodeLine{      -\/>set\_preconditioner\_RHS();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Store the solver pointer.}}
\DoxyCodeLine{    Solver\_pt = solver\_pt;}

\end{DoxyCodeInclude}
 ~\newline
~\newline

\item {\bfseries{Create an instance of the Preconditioner and give it access to the meshes}} ~\newline
~\newline
 The {\ttfamily Lagrange\+Enforce\+Flow\+Preconditioner} takes a pointer of meshes. It is important that the bulk mesh is in position {\ttfamily 0} \+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{  \textcolor{comment}{// Create the preconditioner}}
\DoxyCodeLine{  LagrangeEnforcedFlowPreconditioner* lgr\_prec\_pt}
\DoxyCodeLine{    = \textcolor{keyword}{new} LagrangeEnforcedFlowPreconditioner;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Create the vector of mesh pointers!}}
\DoxyCodeLine{  Vector<Mesh*> mesh\_pt;}
\DoxyCodeLine{  mesh\_pt.resize(2,0);}
\DoxyCodeLine{  mesh\_pt[0] = Bulk\_mesh\_pt;}
\DoxyCodeLine{  mesh\_pt[1] = Surface\_mesh\_P\_pt;}
\DoxyCodeLine{}
\DoxyCodeLine{  lgr\_prec\_pt-\/>set\_meshes(mesh\_pt);}

\end{DoxyCodeInclude}
 By default, {\ttfamily Super\+LUPreconditioner} is used for all subsidiary block solves. To use the LSC preconditioner to approximately solve the sub-\/block system involving the momentum block, we invoke the following\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \textcolor{comment}{// Create the NS LSC preconditioner.}}
\DoxyCodeLine{    lsc\_prec\_pt = \textcolor{keyword}{new} NavierStokesSchurComplementPreconditioner(\textcolor{keyword}{this});}
\DoxyCodeLine{    lsc\_prec\_pt-\/>set\_navier\_stokes\_mesh(Bulk\_mesh\_pt);}
\DoxyCodeLine{    lsc\_prec\_pt-\/>use\_lsc();}
\DoxyCodeLine{    lgr\_prec\_pt-\/>set\_navier\_stokes\_preconditioner(lsc\_prec\_pt);}

\end{DoxyCodeInclude}
 The LSC preconditioner is discussed in \href{../../lsc_navier_stokes/html/index.html}{\texttt{ another tutorial}}. ~\newline
~\newline

\item {\bfseries{Pass the preconditioner to the solver, and the solver to the problem }} ~\newline
~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{  \textcolor{comment}{// Pass the preconditioner to the solver.}}
\DoxyCodeLine{  Solver\_pt-\/>preconditioner\_pt() = lgr\_prec\_pt;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Pass the solver to the problem.}}
\DoxyCodeLine{  this-\/>linear\_solver\_pt() = Solver\_pt;}

\end{DoxyCodeInclude}
 ~\newline
~\newline

\end{DoxyEnumerate}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/navier_stokes/lagrange_enforced_flow_preconditioner}{\texttt{ demo\+\_\+drivers/navier\+\_\+stokes/lagrange\+\_\+enforced\+\_\+flow\+\_\+preconditioner }} \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/navier_stokes/lagrange_enforced_flow_preconditioner/two_d_tilted_square.cc}{\texttt{ demo\+\_\+drivers/navier\+\_\+stokes/lagrange\+\_\+enforced\+\_\+flow\+\_\+preconditioner/two\+\_\+d\+\_\+tilted\+\_\+square.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{PDF file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
