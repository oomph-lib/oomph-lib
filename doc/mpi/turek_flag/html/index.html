<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Parallel solution of Turek &amp; Hron&#39;s FSI benchmark problem with spatial adaptivity for the fluid and solid meshes</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Parallel solution of Turek &amp; Hron's FSI benchmark problem with spatial adaptivity for the fluid and solid meshes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document provides an overview of</p><ul>
<li>how to change the serial driver code for <a href="../../../interaction/turek_flag/html/index.html">Turek &amp; Hron's FSI benchmark problem</a> so that both the fluid and solid meshes can be adapted,</li>
</ul>
<ul>
<li>how to distribute the problem across multiple processors,</li>
</ul>
<p>and</p><ul>
<li>how to enable load balancing of the problem once it is distributed.</li>
</ul>
<p>The document is part of a <a href="../../../example_code_list/html/index.html#distributed">series of tutorials</a> that discuss how to modify existing serial driver codes so that the <code>Problem</code> object can be distributed across multiple processors.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="double_adapt"></a>
Enabling spatial adaptivity for the fluid and solid meshes</h1>
<p>In the original (serial) driver code for <a href="../../../interaction/turek_flag/html/index.html">Turek &amp; Hron's FSI benchmark problem</a> we only adapted the fluid mesh. Before discussing how to modify the code to refine the fluid and solid meshes simultaneously, we provide a brief reminder of the procedure used to discretise fluid-structure interaction problems that involve fluid and solid domains of equal spatial dimension (e.g. a 2D fluid domain interacting with a 2D solid domain) when using algebraic node update methods to adjust the position of the nodes in the fluid mesh. <br  />
 We refer to <a href="../../fsi_channel_with_leaflet/html/index.html">another tutorial</a> for a discussion of FSI problems involving the interaction of fluids with (lower-dimensional) shell and beam structures.</p>
<h2><a class="anchor" id="orig"></a>
General methodology</h2>
<p>The figure below shows a sketch of a simple(r) fluid-structure interaction problem involving fluid and solid domains that meet along a single mesh boundary. We assume that the fluid mesh uses an algebraic node update function to adjust the position of its nodes in response to changes in the domain boundary, represented by the <code>GeomObject</code> shown in magenta. (You may wish to consult <a href="../../../interaction/fsi_collapsible_channel_algebraic/html/index.html">another tutorial</a> for a reminder of how <code>oomph-lib's</code> algebraic node update methods work).</p>
<div class="image">
<img src="fsi_with_adaptive_wall_basic.gif" alt=""/>
<div class="caption">
Basic setup for FSI problems involving algebraic node updates for the fluid mesh. </div></div>
 <p>In an FSI problem, the fluid mesh's free boundary is a boundary of the solid mesh, <em> i.e. </em> the boundary along which the fluid exerts a traction onto the solid. Within <code>oomph-lib</code>, the fluid traction is applied to the solid domain by attaching <code>FSISolidTractionElements</code> to the faces of the "bulk" solid elements adjacent to the FSI boundary. (In the above sketch the <code>FSISolidTractionElements</code> are shown in blue.) The deformation of the fluid and solid meshes is coupled by using the <code>MeshAsGeomObject</code> formed from the <code>FSISolidTractionElements</code> as the <code>GeomObject</code> that defines the moving boundary of the fluid mesh. (In sketch above, this is indicated by the magenta arrow.)</p>
<h2><a class="anchor" id="modification1"></a>
Modifications to allow adaptivity of the fluid and solid meshes</h2>
<p>If the solid mesh is not adapted, the adaptation for the fluid mesh is straightforward and proceeds fully automatically as described <a href="../../../interaction/fsi_collapsible_channel_algebraic/html/index.html">elsewhere</a>. In particular, the node update data for newly-created fluid nodes is created automatically by a call to the <code>AlgebraicMesh::update_node_update(...)</code> function during the adaptation. This function obtains the required information about the boundary by using the <code>MeshAsGeomObject</code> built from the <code>FSISolidTractionElements</code>.</p>
<p>If the solid mesh is also adapted, then the existing <code>FSISolidTractionElements</code> must (at some point) be deleted and new ones must be attached to the adapted "bulk" solid mesh. In all other problems, this is done by deleting the <code>FSISolidTractionElements</code> in <code>Problem::actions_before_adapt()</code> and attaching new ones in <code>Problem::actions_after_adapt()</code>; see, e.g. the <a href="../../../poisson/two_d_poisson_flux_bc/html/index.html">tutorial on the solution of a Poisson problem with flux boundary conditions.</a> However, in the present problem this is not possible because, once the <code>FSISolidTractionElements</code> have been deleted, the <code>MeshAsGeomObject</code> can no longer be used to represent the shape and position of the FSI boundary, which would cause the adaptation of the fluid mesh to fail.</p>
<p>To avoid this problem, we adopt the following strategy:</p><ol type="1">
<li>When adding the various meshes to the <code>Problem's</code> collection of sub-meshes, we add the fluid mesh <b>before</b> the solid mesh. (This happens to be what was done already in the original driver code.) Usually, the order in which sub-meshes are added to the <code>Problem</code> is irrelevant. Here the order <b>does</b> matter because we will exploit the fact that the sub-meshes are adapted individually, in the order in which they were added to the <code>Problem</code>. <br  />
<br  />
</li>
<li>The <code>FSISolidTractionElements</code> are not deleted in <code>Problem::actions_before_adapt()</code> and remain attached to the "bulk" solid elements throughout the "bulk" mesh adaptation procedure. When the fluid mesh is adapted, the appropriate <code>MeshAsGeomObject</code> is, therefore, still fully-functional (and refers to the boundary as represented by the solid domain <b>before</b> the "bulk" solid mesh is adapted). <br  />
<br  />
 Here is a sketch of problem after adaptation of the fluid mesh: <br  />
<br  />
<div class="image">
<img src="fsi_with_adaptive_wall_adapted_fluid.gif" alt=""/>
<div class="caption">
Sketch of the problem following the adaptation of the fluid mesh. The solid mesh has not yet been refined. </div></div>
  <br  />
<br  />
</li>
<li>The subsequent adaptation of the "bulk" solid mesh is likely to turn some of the <code>FSISolidTractionElements</code> into "dangling" elements. (This occurs whenever a <code>FSISolidTractionElements</code> is attached to a "bulk" solid elements that disappears during the adaptation, <em> e.g. </em> by being refined.) <br  />
<br  />
 Here is a plot of the problem following the adaptation of the solid mesh : <br  />
<br  />
<div class="image">
<img src="fsi_with_adaptive_wall_adapted_solid.gif" alt=""/>
<div class="caption">
Sketch of the problem following the adaptation of the solid mesh -- the `dangling' FSISolidTractionElements are represented by dotted lines. </div></div>
  <br  />
<br  />
</li>
<li>Hence, in <code>Problem::actions_after_adapt()</code> we delete the existing <code>FSISolidTractionElements</code> and immediately (re-)attach new ones. Now, the <code>MeshAsGeomObject</code> that represents the FSI boundary is broken because it still refers to the just deleted <code>FSISolidTractionElements</code>. <br  />
<br  />
<div class="image">
<img src="fsi_with_adaptive_wall_new_face_elements.gif" alt=""/>
<div class="caption">
Sketch of the problem following the creation of new FSISolidTractionElements. The fact that the MeshAsGeomObject is broken is indicated by the dashed lines. </div></div>
  <br  />
<br  />
</li>
<li>Thus, we rebuild the <code>MeshAsGeomObject</code> from the newly-created <code>FSISolidTractionElements</code>, and update the fluid mesh's pointer to this new <code>GeomObject</code> that describes the boundary shape. <br  />
<br  />
<div class="image">
<img src="fsi_with_adaptive_wall_done.gif" alt=""/>
<div class="caption">
Sketch of the problem with re-built MeshAsGeomObject. </div></div>
  <br  />
<br  />
</li>
<li>Finally, we execute the <code>AlgebraicMesh::update_node_update(...)</code> function for all nodes in the fluid mesh to ensure that their node update data refers to the new <code>FSISolidTractionElements</code>. <br  />
<br  />
</li>
<li>The remaining tasks (such as the renewed setup of the fluid load on the <code>FSISolidTractionElements</code> via a call to <code>FSI_functions::setup_fluid_load_info_for_solid_elements(...)</code>, etc.) remain the same as in the previous version of the code.</li>
</ol>
<hr  />
 <hr  />
<h1><a class="anchor" id="distr"></a>
Distributing the Problem</h1>
<p>In the present example, there are two "bulk" meshes corresponding to the fluid and solid domains and three "surface" meshes of traction elements. The traction elements are <code>FaceElements</code> created from the "bulk" fluid elements and should be deleted before the problem is distributed, see the tutorial on applying <a href="../../two_d_poisson_flux_bc_adapt/html/index.html">flux boundary conditions in a Poisson problem </a> for more details. In the <a href="../../fsi_channel_with_leaflet/html/index.html">previous example</a> involving the interaction of a 2D fluid domain with a 1D beam structure there were only two meshes: a "bulk" fluid mesh and a "surface" solid mesh. In that problem <b>all</b> elements in the 1D mesh of <code>FSIHermiteBeamElements</code> were retained on all processors as halo elements by using the function <code>Mesh::keep_all_elements_as_halos()</code>. The same methodology could be used here, but it would be extremely wasteful to retain all the solid elements in the "bulk" solid mesh because only the elements next to the FSI boundary are required. Instead, we use a more fine-grained method of retaining elements via the function <code>GeneralisedElement::must_be_kept_as_halo()</code>.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="impl"></a>
Implementation</h1>
<p>Most of the driver code is identical to the original serial version discussed in <a href="../../fsi_channel_with_leaflet/html/index.html">another tutorial</a>. We therefore only discuss those parts of the code that have to be changed to allow (i) the simultaneous adaptation of the fluid and solid meshes, and (ii) the problem distribution.</p>
<hr  />
<h2><a class="anchor" id="main_body"></a>
The main function</h2>
<p>As usual in a parallel driver code, the only addition to the <code>main()</code> function is the inclusion of calls to <code>MPI_Helpers::init()</code>, <code>MPI_Helpers::finalize()</code>, and the <code>Problem::distribute()</code> functions.</p>
<hr  />
<h2><a class="anchor" id="problem_class"></a>
The problem class</h2>
<p>The only additions to the serial version of the problem class are the functions <code>actions_before_distribute()</code> and <code>actions_after_distribute()</code>, and the helper function <code>delete_fsi_traction_elements()</code>, discussed below.</p>
<hr  />
<h2><a class="anchor" id="delete_fsi"></a>
Deleting the FSISolidTractionElements</h2>
<p>To facilitate the deletion and re-creation of the <code>FSISolidTractionElements</code> before and after the adaptation (and distribution) we provide a new helper function <code>delete_fsi_traction_elements()</code> which complements the already-existing <code>create_fsi_traction_elements()</code> function:</p>
 <div class="fragment"><div class="line"><span class="comment">//============start_of_delete_traction_elements==========================</span></div>
<div class="line"><span class="comment">/// Delete FSI traction elements </span></div>
<div class="line"><span class="comment"></span><span class="comment">//=======================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> FLUID_ELEMENT,<span class="keyword">class</span> SOLID_ELEMENT &gt;</div>
<div class="line"><span class="keywordtype">void</span> TurekProblem&lt;FLUID_ELEMENT,SOLID_ELEMENT&gt;::delete_fsi_traction_elements()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// There are 3 traction meshes</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> b=0;b&lt;3;b++)</div>
<div class="line">  {</div>
<div class="line">   <span class="keywordtype">unsigned</span> n_element=Traction_mesh_pt[b]-&gt;nelement();</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Kill the element</span></div>
<div class="line">     <span class="keyword">delete</span> Traction_mesh_pt[b]-&gt;element_pt(e);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Wipe the mesh</span></div>
<div class="line">   Traction_mesh_pt[b]-&gt;flush_element_and_node_storage();</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// end of delete traction elements</span></div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="actions_before_distribute"></a>
Actions before distribute</h2>
<p>As discussed above, we must ensure that the "bulk" solid elements adjacent to the FSI boundary are retained on all processors. Hence, the <code>actions_before_distribute()</code> function starts with a loop over the <code>FSISolidTractionElements</code> within which we use the function <code>GeneralisedElement::must_be_kept_as_halo()</code> to indicate that the associated bulk elements must be retained.</p>
 <div class="fragment"><div class="line"><span class="comment">//==================start_of_actions_before_distribute====================</span></div>
<div class="line"><span class="comment">/// Actions before distribute: Make sure that the bulk solid elements </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// attached to the FSISolidTractionElements are kept as halo elements.</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// Unlike in most other parallel codes we DON&#39;T delete the </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// FSISolidTractionElements here, though, because they need to </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// be around while the fluid mesh is adapted.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> FLUID_ELEMENT,<span class="keyword">class</span> SOLID_ELEMENT &gt;</div>
<div class="line"><span class="keywordtype">void</span> TurekProblem&lt;FLUID_ELEMENT,SOLID_ELEMENT&gt;::actions_before_distribute()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// The bulk elements attached to the traction elements need to be kept</span></div>
<div class="line"> <span class="comment">// as halo elements</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// There are 3 traction meshes</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> b=0;b&lt;3;b++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Loop over elements in traction meshes</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_element=Traction_mesh_pt[b]-&gt;nelement();</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">    {</div>
<div class="line">     FSISolidTractionElement&lt;SOLID_ELEMENT,2&gt;* traction_elem_pt=</div>
<div class="line">      <span class="keyword">dynamic_cast&lt;</span>FSISolidTractionElement&lt;SOLID_ELEMENT,2&gt;* <span class="keyword">&gt;</span></div>
<div class="line">      (Traction_mesh_pt[b]-&gt;element_pt(e));</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Get the bulk element (which is a SOLID_ELEMENT)</span></div>
<div class="line">     SOLID_ELEMENT* solid_elem_pt = <span class="keyword">dynamic_cast&lt;</span>SOLID_ELEMENT*<span class="keyword">&gt;</span></div>
<div class="line">      (traction_elem_pt-&gt;bulk_element_pt());</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Require bulk to be kept as a (possible) halo element</span></div>
<div class="line">     <span class="comment">// Note: The traction element itself will &quot;become&quot; a halo element </span></div>
<div class="line">     <span class="comment">// when it is recreated after the distribution has taken place</span></div>
<div class="line">     solid_elem_pt-&gt;set_must_be_kept_as_halo();</div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">// end of loop over meshes of fsi traction elements</span></div>
</div><!-- fragment --><p>Next, we flush all the meshes from the problem's collection of sub-meshes and add only the "bulk" fluid and solid meshes (in that order!). The <code>FaceElements</code> do not need to be distributed, because they will be re-created in <code>actions_after_distribute()</code>.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Flush all the submeshes out but keep the meshes of FSISolidTractionElements</span></div>
<div class="line"> <span class="comment">// alive (i.e. don&#39;t delete them)</span></div>
<div class="line"> flush_sub_meshes();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Add the fluid mesh and the solid mesh back again</span></div>
<div class="line"> <span class="comment">// Remember that it&#39;s important that the fluid mesh is</span></div>
<div class="line"> <span class="comment">// added before the solid mesh!</span></div>
<div class="line"> add_sub_mesh(fluid_mesh_pt());</div>
<div class="line"> add_sub_mesh(solid_mesh_pt());</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Rebuild global mesh</span></div>
<div class="line"> rebuild_global_mesh();</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of actions before distribute</span></div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="actions_after_distribute"></a>
Actions after distribute</h2>
<p>Following the problem distribution, we delete the old <code>FSISolidTractionElements</code> and then (re-)attach new ones, which will be created as halo elements where necessary.</p>
 <div class="fragment"><div class="line"><span class="comment">//==================start_of_actions_after_distribute=====================</span></div>
<div class="line"><span class="comment">///  Actions after distribute: Re-setup FSI</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> FLUID_ELEMENT,<span class="keyword">class</span> SOLID_ELEMENT &gt;</div>
<div class="line"><span class="keywordtype">void</span> TurekProblem&lt;FLUID_ELEMENT,SOLID_ELEMENT&gt;::actions_after_distribute()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// The solid mesh has now been distributed, so it now has halo elements</span></div>
<div class="line"> <span class="comment">// on certain processors. The traction elements attached to these new</span></div>
<div class="line"> <span class="comment">// halo elements need to be halo themselves, so we need to delete the</span></div>
<div class="line"> <span class="comment">// old ones and re-attach new ones. Recall that FaceElements attached</span></div>
<div class="line"> <span class="comment">// to bulk halo elements become halos themselves.</span></div>
<div class="line"> delete_fsi_traction_elements();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// (Re-)Build the FSI traction elements</span></div>
<div class="line"> create_fsi_traction_elements();</div>
</div><!-- fragment --><p>We complete the build of the <code>FSISolidTractionElements</code> by passing the FSI parameter and the boundary number in the bulk mesh. The relevant code is identical to the serial version and we omit its listing here.</p>
<p>Next, we create new <code>MeshAsGeomObjects</code> from the newly-created <code>FSISolidTractionElements</code> and pass them to the (algebraic) fluid mesh:</p>
<div class="fragment"><div class="line"> <span class="comment">// Turn the three meshes of FSI traction elements into compound</span></div>
<div class="line"> <span class="comment">// geometric objects (one Lagrangian, two Eulerian coordinates)</span></div>
<div class="line"> <span class="comment">// that determine particular boundaries of the fluid mesh</span></div>
<div class="line"> MeshAsGeomObject*</div>
<div class="line">  bottom_flag_pt=</div>
<div class="line">  <span class="keyword">new</span> MeshAsGeomObject</div>
<div class="line">  (Traction_mesh_pt[0]);</div>
<div class="line"> </div>
<div class="line"> MeshAsGeomObject* tip_flag_pt=</div>
<div class="line">  <span class="keyword">new</span> MeshAsGeomObject</div>
<div class="line">  (Traction_mesh_pt[1]);</div>
<div class="line"> </div>
<div class="line"> MeshAsGeomObject* top_flag_pt=</div>
<div class="line">  <span class="keyword">new</span> MeshAsGeomObject</div>
<div class="line">  (Traction_mesh_pt[2]);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Delete the old MeshAsGeomObjects and tell the fluid mesh </span></div>
<div class="line"> <span class="comment">// about the new ones.</span></div>
<div class="line"> <span class="keyword">delete</span> fluid_mesh_pt()-&gt;bottom_flag_pt();</div>
<div class="line"> fluid_mesh_pt()-&gt;set_bottom_flag_pt(bottom_flag_pt);</div>
<div class="line"> <span class="keyword">delete</span> fluid_mesh_pt()-&gt;top_flag_pt();</div>
<div class="line"> fluid_mesh_pt()-&gt;set_top_flag_pt(top_flag_pt);</div>
<div class="line"> <span class="keyword">delete</span> fluid_mesh_pt()-&gt;tip_flag_pt();</div>
<div class="line"> fluid_mesh_pt()-&gt;set_tip_flag_pt(tip_flag_pt);</div>
</div><!-- fragment --><p>The <code>MeshAsGeomObjects</code> have changed, so we must call the <code>update_node_update()</code> function again for each node in the fluid mesh:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Call update_node_update for all the fluid mesh nodes, as the</span></div>
<div class="line"> <span class="comment">// geometric objects representing the fluid mesh boundaries have changed</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_fluid_node=fluid_mesh_pt()-&gt;nnode();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> n=0;n&lt;n_fluid_node;n++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Get the (algebraic) node</span></div>
<div class="line">   AlgebraicNode* alg_nod_pt=<span class="keyword">dynamic_cast&lt;</span>AlgebraicNode*<span class="keyword">&gt;</span></div>
<div class="line">    (fluid_mesh_pt()-&gt;node_pt(n));</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Call update_node_update for this node</span></div>
<div class="line">   fluid_mesh_pt()-&gt;update_node_update(alg_nod_pt);</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Now we add the FSI traction meshes back to the problem and rebuild the global mesh.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Add the traction meshes back to the problem</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;3;i++)</div>
<div class="line">  {</div>
<div class="line">   add_sub_mesh(traction_mesh_pt(i));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Rebuild global mesh</span></div>
<div class="line"> rebuild_global_mesh();</div>
</div><!-- fragment --><p>Finally, we re-set the fluid load on the solid elements by calling <code>FSI_functions::setup_fluid_load_info_for_solid_elements(...)</code> before re-assigning the auxiliary node update function that imposes the no-slip condition for all fluid nodes on the FSI boundaries. [<a href="../../fsi_channel_with_leaflet/html/index.html#action_after_adapt">Recall</a> that the (re-)assignment of the auxiliary node-update function must be performed <b>after</b> the call to <code>FSI_functions::setup_fluid_load_info_for_solid_elements(...)</code>.]</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// If the solid is to be loaded by the fluid, then set up the interaction</span></div>
<div class="line"> <span class="comment">// and specify the velocity of the fluid nodes based on the wall motion</span></div>
<div class="line"> <span class="keywordflow">if</span> (!Global_Parameters::Ignore_fluid_loading)</div>
<div class="line">  {</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef OLD_FSI</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Re-setup the fluid load information for fsi solid traction elements</span></div>
<div class="line">   FSI_functions::setup_fluid_load_info_for_solid_elements&lt;FLUID_ELEMENT,2&gt;</div>
<div class="line">    (<span class="keyword">this</span>,5,Fluid_mesh_pt,Traction_mesh_pt[0]); </div>
<div class="line"> </div>
<div class="line">   FSI_functions::setup_fluid_load_info_for_solid_elements&lt;FLUID_ELEMENT,2&gt;</div>
<div class="line">    (<span class="keyword">this</span>,6,Fluid_mesh_pt,Traction_mesh_pt[2]); </div>
<div class="line"> </div>
<div class="line">   FSI_functions::setup_fluid_load_info_for_solid_elements&lt;FLUID_ELEMENT,2&gt;</div>
<div class="line">    (<span class="keyword">this</span>,7,Fluid_mesh_pt,Traction_mesh_pt[1]); </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Package fsi solid traction meshes and boundary IDs in </span></div>
<div class="line">   <span class="comment">// fluid mesh</span></div>
<div class="line">   Vector&lt;unsigned&gt; fluid_fsi_boundary_id(3);</div>
<div class="line">   Vector&lt;Mesh*&gt; traction_mesh_pt(3);</div>
<div class="line">   fluid_fsi_boundary_id[0]=5;</div>
<div class="line">   traction_mesh_pt[0]=Traction_mesh_pt[0];</div>
<div class="line">   fluid_fsi_boundary_id[1]=6;</div>
<div class="line">   traction_mesh_pt[1]=Traction_mesh_pt[2];</div>
<div class="line">   fluid_fsi_boundary_id[2]=7;</div>
<div class="line">   traction_mesh_pt[2]=Traction_mesh_pt[1];</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Vector based FSI setup</span></div>
<div class="line">   FSI_functions::setup_fluid_load_info_for_solid_elements&lt;FLUID_ELEMENT,2&gt;</div>
<div class="line">    (<span class="keyword">this</span>,fluid_fsi_boundary_id,Fluid_mesh_pt,</div>
<div class="line">     traction_mesh_pt);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The velocity of the fluid nodes on the wall (fluid mesh boundary 5,6,7)</span></div>
<div class="line">   <span class="comment">// is set by the wall motion -- hence the no-slip condition must be</span></div>
<div class="line">   <span class="comment">// re-applied whenever a node update is performed for these nodes. </span></div>
<div class="line">   <span class="comment">// Such tasks may be performed automatically by the auxiliary node update </span></div>
<div class="line">   <span class="comment">// function specified by a function pointer:</span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibound=5;ibound&lt;8;ibound++ )</div>
<div class="line">    { </div>
<div class="line">     <span class="keywordtype">unsigned</span> num_nod= Fluid_mesh_pt-&gt;nboundary_node(ibound);</div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">      {   </div>
<div class="line">       Fluid_mesh_pt-&gt;boundary_node_pt(ibound, inod)-&gt;</div>
<div class="line">        set_auxiliary_node_update_fct_pt(</div>
<div class="line">         FSI_functions::apply_no_slip_on_moving_wall);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// end of (re-)assignment of the auxiliary node update fct</span></div>
</div><!-- fragment --><p>The remainder of the function identifies which processors contain the fluid control node whose velocities we document in the trace file.</p>
<hr  />
<h2><a class="anchor" id="actions_after_adapt"></a>
Actions after adapt</h2>
<p>The <code>actions_after_adapt()</code> function is very similar to <code>actions_after_distribute()</code> function, so we omit is listing here. The only significant differences are that (i) the redundant fluid and solid pressures are (re)-pinned; (ii) the identification of the fluid control node does not need to be setup; and (iii) the traction meshes were never removed from the problem, so do not need to be added back in.</p>
<hr  />
<h2><a class="anchor" id="doc_solution"></a>
The doc_solution() function</h2>
<p>As with the other parallel driver codes, the main modification to the post-processing function is the addition of the processor number to all output files. Furthermore, we only write the trace file on the processors that contain the fluid control node. In the interest of brevity we omit the listing of the modified function.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="result"></a>
Results</h1>
<p>The figure below illustrates the distribution of the problem across four processors, represented by the four colours, with the fluid elements outlined in black and the solid elements outlined in white.</p>
<div class="image">
<img src="turek_partition.gif" alt=""/>
<div class="caption">
Distribution of the Turek &amp; Hron benchmark problem over four processors. </div></div>
 <p>Zooming in near the "flag" shows how both fluid and solid meshes are refined and distributed independently:</p>
<div class="image">
<img src="turek_partition_zoom.gif" alt=""/>
<div class="caption">
Distribution of the Turek &amp; Hron benchmark problem over four processors; zoomed in view near the `flag'. </div></div>
 <hr  />
 <hr  />
<h1><a class="anchor" id="load_balance"></a>
Load balancing</h1>
<p>When employing load balancing in this problem, we modify the time-stepping loop to perform the procedure after each timestep:</p>
 <div class="fragment"><div class="line"> <span class="comment">// Start of timestepping loop</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;nstep;i++)</div>
<div class="line">  { </div>
<div class="line">   <span class="comment">// Solve the problem</span></div>
<div class="line">   <a class="code" href="turek__flag_8txt.html#a79d1068e3e03fa416aafdf51c6509bab">problem</a>.unsteady_newton_solve(dt,max_adapt,first); </div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Output the solution</span></div>
<div class="line">   <a class="code" href="turek__flag_8txt.html#a79d1068e3e03fa416aafdf51c6509bab">problem</a>.doc_solution(doc_info,trace_file);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Step number</span></div>
<div class="line">   doc_info.number()++;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Load balance the problem</span></div>
<div class="line">   DocInfo load_doc_info;</div>
<div class="line">   <a class="code" href="turek__flag_8txt.html#a79d1068e3e03fa416aafdf51c6509bab">problem</a>.load_balance(load_doc_info,report_stats);</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// end of timestepping loop</span></div>
</div><!-- fragment --><h2><a class="anchor" id="build_mesh"></a>
The build_mesh() function</h2>
<p>The function <code>Problem::build_mesh()</code> must be supplied by the user if they wish to use the load balancing capability. Thus, in this driver code, we move all the required code to build the entire global mesh into this function, and call it from within the problem constructor:</p>
 <div class="fragment"><div class="line"><span class="comment">//=====start_of_constructor============================================= </span></div>
<div class="line"><span class="comment">/// Constructor: Pass length and height of domain</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================== </span></div>
<div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> FLUID_ELEMENT,<span class="keyword">class</span> SOLID_ELEMENT &gt;</div>
<div class="line">TurekProblem&lt;FLUID_ELEMENT,SOLID_ELEMENT&gt;::</div>
<div class="line">TurekProblem(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;length,</div>
<div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;height) :  Domain_height(height),</div>
<div class="line">                                      Domain_length(length)</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Tell us how well the load balancing is doing...</span></div>
<div class="line"> enable_doc_imbalance_in_parallel_assembly();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Increase max. number of iterations in Newton solver to</span></div>
<div class="line"> <span class="comment">// accomodate possible poor initial guesses</span></div>
<div class="line"> Max_newton_iterations=20;</div>
<div class="line"> Max_residuals=1.0e4;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create the flag timestepper (consistent with BDF&lt;2&gt; for fluid)</span></div>
<div class="line"> Flag_time_stepper_pt=<span class="keyword">new</span> Newmark&lt;2&gt;;</div>
<div class="line"> add_time_stepper_pt(Flag_time_stepper_pt); </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create error estimator for the solid mesh</span></div>
<div class="line"> Solid_error_estimator_pt=<span class="keyword">new</span> Z2ErrorEstimator;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Create a new Circle object as the central cylinder</span></div>
<div class="line"> Cylinder_pt = <span class="keyword">new</span> Circle(Global_Parameters::Centre_x,</div>
<div class="line">                          Global_Parameters::Centre_y,</div>
<div class="line">                          Global_Parameters::Radius);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Allocate the fluid timestepper</span></div>
<div class="line"> Fluid_time_stepper_pt=<span class="keyword">new</span> BDF&lt;2&gt;;</div>
<div class="line"> add_time_stepper_pt(Fluid_time_stepper_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create error estimator for the fluid mesh</span></div>
<div class="line"> Fluid_error_estimator_pt=<span class="keyword">new</span> Z2ErrorEstimator;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the meshes for this problem</span></div>
<div class="line"> build_mesh();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Setup FSI</span></div>
<div class="line"> <span class="comment">//----------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Pass Strouhal number to the helper function that automatically applies</span></div>
<div class="line"> <span class="comment">// the no-slip condition</span></div>
<div class="line"> FSI_functions::Strouhal_for_no_slip=Global_Parameters::St;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// If the solid is to be loaded by the fluid, then set up the interaction</span></div>
<div class="line"> <span class="comment">// and specify the velocity of the fluid nodes based on the wall motion</span></div>
<div class="line"> <span class="keywordflow">if</span> (!Global_Parameters::Ignore_fluid_loading)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Work out which fluid dofs affect the residuals of the wall elements:</span></div>
<div class="line">   <span class="comment">// We pass the boundary between the fluid and solid meshes and </span></div>
<div class="line">   <span class="comment">// pointers to the meshes. The interaction boundary are boundaries 5,6,7</span></div>
<div class="line">   <span class="comment">// of the 2D fluid mesh.</span></div>
<div class="line">   FSI_functions::setup_fluid_load_info_for_solid_elements&lt;FLUID_ELEMENT,2&gt;</div>
<div class="line">    (<span class="keyword">this</span>,5,Fluid_mesh_pt,Traction_mesh_pt[0]);</div>
<div class="line">   </div>
<div class="line">   FSI_functions::setup_fluid_load_info_for_solid_elements&lt;FLUID_ELEMENT,2&gt;</div>
<div class="line">    (<span class="keyword">this</span>,6,Fluid_mesh_pt,Traction_mesh_pt[2]);</div>
<div class="line"> </div>
<div class="line">   FSI_functions::setup_fluid_load_info_for_solid_elements&lt;FLUID_ELEMENT,2&gt;</div>
<div class="line">    (<span class="keyword">this</span>,7,Fluid_mesh_pt,Traction_mesh_pt[1]); </div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The velocity of the fluid nodes on the wall (fluid mesh boundary 5,6,7)</span></div>
<div class="line">   <span class="comment">// is set by the wall motion -- hence the no-slip condition must be</span></div>
<div class="line">   <span class="comment">// re-applied whenever a node update is performed for these nodes. </span></div>
<div class="line">   <span class="comment">// Such tasks may be performed automatically by the auxiliary node update </span></div>
<div class="line">   <span class="comment">// function specified by a function pointer:</span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibound=5;ibound&lt;8;ibound++ )</div>
<div class="line">    { </div>
<div class="line">     <span class="keywordtype">unsigned</span> num_nod= Fluid_mesh_pt-&gt;nboundary_node(ibound);</div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">      {   </div>
<div class="line">       Fluid_mesh_pt-&gt;boundary_node_pt(ibound, inod)-&gt;</div>
<div class="line">        set_auxiliary_node_update_fct_pt(</div>
<div class="line">         FSI_functions::apply_no_slip_on_moving_wall);</div>
<div class="line">      }</div>
<div class="line">    } <span class="comment">// done automatic application of no-slip</span></div>
<div class="line">  } <span class="comment">// end of FSI setup</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Use SuperLU_dist as the solver</span></div>
<div class="line"> linear_solver_pt() = <span class="keyword">new</span> SuperLUSolver;</div>
<div class="line"> <span class="keyword">static_cast&lt;</span>SuperLUSolver*<span class="keyword">&gt;</span>(linear_solver_pt())</div>
<div class="line">  -&gt;set_solver_type(SuperLUSolver::Distributed);</div>
<div class="line"> <span class="keyword">static_cast&lt;</span>SuperLUSolver*<span class="keyword">&gt;</span>(linear_solver_pt())</div>
<div class="line">  -&gt;use_distributed_solve_in_superlu_dist();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Assign equation numbers</span></div>
<div class="line"> cout &lt;&lt; assign_eqn_numbers() &lt;&lt; std::endl; </div>
<div class="line"> </div>
<div class="line">}<span class="comment">//end_of_constructor</span></div>
</div><!-- fragment --><p>The <code>build_mesh()</code> function itself contains all the relevant code from within the previous parallel driver code's problem constructor.</p>
<h2><a class="anchor" id="actions_functions"></a>
Actions before and after load balancing</h2>
<p>In this example, all that is required for the <code><a class="el" href="turek__flag_8txt.html#a4a925627256eb5f23489996ef5609813">actions_after_load_balance()</a></code> function is the addition of the unpin-repin procedure from the <code>actions_after_adapt()</code> function to the appropriate part of the <code>actions_after_distribute()</code> function, since all the other functionality is already identical. The <code>actions_before_load_balance()</code> function is identical to the <code>actions_before_distribute()</code> function.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory:<br  />
<br  />
<center> <a href="../../../../demo_drivers/mpi/multi_domain/turek_flag/">demo_drivers/mpi/multi_domain/turek_flag/ </a> </center><br  />
</li>
<li>The main driver code is: <br  />
<br  />
<center> <a href="../../../../demo_drivers/mpi/multi_domain/turek_flag/turek_flag.cc">demo_drivers/mpi/multi_domain/turek_flag/turek_flag.cc </a> </center></li>
<li>The driver code for the load balancing example is: <br  />
<br  />
<center> <a href="../../../../demo_drivers/mpi/multi_domain/turek_flag/turek_flag_load_balance.cc">demo_drivers/mpi/multi_domain/turek_flag/turek_flag_load_balance.cc </a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="aturek__flag_8txt_html_a79d1068e3e03fa416aafdf51c6509bab"><div class="ttname"><a href="turek__flag_8txt.html#a79d1068e3e03fa416aafdf51c6509bab">problem</a></div><div class="ttdeci">e g the&lt; a href=&quot;../../../poisson/two_d_poisson_flux_bc/html/index.html&quot;&gt; tutorial on the solution of a Poisson problem with flux boundary conditions&lt;/a &gt; in the present problem this is not possible once the c FSISolidTractionElements have been the c MeshAsGeomObject can no longer be used to represent the shape and position of the FSI which would cause the adaptation of the fluid mesh to fail To avoid this problem</div><div class="ttdef"><b>Definition:</b> <a href="turek__flag_8txt_source.html#l00105">turek_flag.txt:105</a></div></div>

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Fri Aug 27 2021 17:51:18
        </div>
      </div>
    </footer>
</body>
</html>
