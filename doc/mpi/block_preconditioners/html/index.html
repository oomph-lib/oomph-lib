<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: oomph-lib&#39;s Block Preconditioning Framework</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">oomph-lib's Block Preconditioning Framework </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><code>oomph-lib's</code> block preconditioning framework provides an environment for the development of block preconditioners for the iterative solution of linear systems by Krylov subspace methods. The framework is based on the classification of the problem's unknowns (degrees of freedom; here abbreviated as dofs) into different "dof types" which, in a multi-physics context, typically represent different physical quantities. A key feature of the framework is that it allows existing block preconditioners (which were developed for a particular single-physics application, say) to be re-used, in a hierarchical fashion, in block preconditioners for related multi-physics problems. This means that existing Navier-Stokes and solid mechanics preconditioners can be used to create preconditioners for fluid-structure interaction problems, say.</p>
<p>Following a brief overview of the underlying ideas and their implementation in <code>oomph-lib</code> this tutorial discusses a sequence of increasingly complex block preconditioners that illustrate the framework's capabilities in the context of a (rather artificial) model problem. The final example illustrates a simple implementation of a block preconditioner for an FSI problem. We conclude with a few comments on the use of block preconditioners in parallel. Other tutorials discuss how the methodology is used in "real" preconditioners. See, for instance, the tutorials discussing</p>
<ul>
<li><code>oomph-lib's</code> <a href="../../distributed_general_purpose_block_preconditioners/html/index.html">"general purpose" block preconditioners.</a> <br  />
<br  />
</li>
<li>The <a href="../../../preconditioners/lsc_navier_stokes/html/index.html">NavierStokesSchurComplementPreconditioner for Navier-Stokes problems </a> <br  />
<br  />
</li>
<li>The <a href="../../../preconditioners/fsi/html/index.html">FSIPreconditioner for monolithically-discretised fluid-structure interaction problems.</a> <br  />
<br  />
</li>
<li>The <a href="../../../preconditioners/prescribed_displ_lagr_mult/html/index.html">preconditioner for large-displacement solid mechanics problems in which boundary displacements are prescribed.</a><br  />
<br  />
</li>
<li>The previous preconditioner is mainly used as a subsidiary block preconditioner for the <a href="../../../preconditioners/pseudo_solid_fsi/html/index.html">solution of fluid-structure interaction problems with (pseudo-)solid fluid mesh updates.</a> <br  />
<br  />
</li>
</ul>
<h1><a class="anchor" id="theory"></a>
Theoretical background</h1>
<p>In <code>oomph-lib</code>, all problems are solved by Newton's method, which requires the repeated solution of linear systems of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf J}\;{\bf \delta x}=-{\bf r} \]" src="form_0.png" width="58" height="10"/>
</p>
<p>for the Newton correction <img class="formulaInl" alt="$\bf \delta x$" src="form_1.png" width="14" height="10"/> where <img class="formulaInl" alt="${\bf J}$" src="form_2.png" width="8" height="10"/> is the Jacobian matrix and <img class="formulaInl" alt="$\bf r$" src="form_3.png" width="8" height="6"/> is the vector of residuals. (Left) preconditioning represents a transformation of the original linear system to</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf P}^{-1}{\bf J}\;{\bf \delta x}=-{\bf P}^{-1}{\bf r}, \]" src="form_4.png" width="106" height="15"/>
</p>
<p>introduced with the aim of accelerating the convergence of Krylov subspace solvers such as GMRES or CG. The application of the preconditioner requires the solution of</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf P}{\bf z}={\bf y} \]" src="form_5.png" width="41" height="13"/>
</p>
<p>for <img class="formulaInl" alt="$\bf z$" src="form_6.png" width="8" height="6"/> at each Krylov iteration.</p>
<p>Block preconditioners are based (at least formally) on a reordering of the linear system such that related unknowns (e.g. dofs representing the same physical quantity) are grouped together and enumerated consecutively.</p>
<p>For instance, in linear elasticity problems (discussed in <a href="../../../linear_elasticity/periodic_load/html/index.html">another tutorial</a>) where we compute the displacement field of an elastic body in response to an applied traction, the (discrete) unknowns can be sub-divided according to which component of the displacement vector they represent. Using this classification of the dofs, the re-ordered linear system for a two-dimensional problem then has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left[ \begin{array}{cc} {\bf J}_{xx}&amp;{\bf J}_{xy}\\ {\bf J}_{xy}&amp;{\bf J}_{yy} \end{array} \right] \left[ \begin{array}{c} \bf \delta x_x\\ \bf \delta x_y\\ \end{array} \right] = - \left[ \begin{array}{c} \bf r_x\\ \bf r_y\\ \end{array} \right]. \]" src="form_7.png" width="194" height="31"/>
</p>
<p>A simple (and, in fact, quite effective) block preconditioner for this linear system can be formed by retaining only the diagonal blocks of the system matrix, leading to the block diagonal preconditioner</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf P}_{diag}= \left[ \begin{array}{cc} {\bf J}_{xx}&amp; \\ &amp;{\bf J}_{yy} \end{array} \right]. \]" src="form_8.png" width="128" height="31"/>
</p>
<p>The application of this preconditioner requires the solution of the linear system</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left[ \begin{array}{cc} {\bf J}_{xx}&amp; \\ &amp;{\bf J}_{yy} \end{array} \right] \left[ \begin{array}{c} {\bf z_x}\\ \bf z_y\\ \end{array} \right] = \left[ \begin{array}{c} \bf y_x\\ \bf y_y \end{array} \right], \]" src="form_9.png" width="176" height="31"/>
</p>
<p>which requires the (exact or approximate) solution of the two smaller linear systems <img class="formulaInl" alt="$ {\bf J}_{xx} \ {\bf z_x} = {\bf y_x}$" src="form_10.png" width="68" height="13"/> and <img class="formulaInl" alt="$ {\bf J}_{yy} \ {\bf z_y} = {\bf y_y}$" src="form_11.png" width="68" height="14"/>.</p>
<h1><a class="anchor" id="generic_implementation"></a>
Overview</h1>
<p>The above example shows that the application of block preconditioners typically require several generic steps:</p>
<ol type="1">
<li>The classification of the dofs.</li>
<li>The application of subsidiary preconditioning operations such as the solution of (smaller) linear systems or the evaluation of matrix-vector products with some of the blocks that are extracted from the original linear system.</li>
</ol>
<p>The following subsections describe how these tasks are performed within <code>oomph-lib's</code> block preconditioning framework.</p>
<h2><a class="anchor" id="block_preconditionable_elements"></a>
The classification of dof types via block preconditionable elements</h2>
<p>The classification of dofs is specified by the elements since they are the only objects within <code>oomph-lib's</code> data structure that "know" what role a specific dof plays in "their" equations. During the setup phase, the block preconditioner loops over "all
elements" (specified via one or more <code>Meshes</code> &ndash; here simply used as containers for elements; see below for further details) to establish the "dof type" for each global unknown.</p>
<p>To achieve this, the class <code>GeneralisedElement</code> contains two broken virtual methods that must be re-implemented/overloaded to label each of the element's dofs with its type. These methods are:</p>
<ul>
<li><code>GeneralisedElement::ndof_types()</code> must return the number of dof types associated with an element.</li>
<li><code>GeneralisedElement::get_dof_numbers_for_unknowns(...)</code> must return a list of pairs comprising a map from global equation number to dof type for all unknowns in the element.</li>
</ul>
<p>These are already implemented for many elements. If not, the functions are easy to write. For instance, <code>oomph-lib's</code> <code>DIM</code>-dimensional linear elasticity elements from the <code>QLinearElasticityElement</code> family can be made block-preconditionable by using the following wrapper class:</p>
 <div class="fragment"><div class="line"><span class="comment">//==start_of_mylinearelasticityelement===============================</span></div>
<div class="line"><span class="comment">/// Wrapper to make quadratic linear elasticity element block</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// preconditionable </span></div>
<div class="line"><span class="comment"></span><span class="comment">//===================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> DIM&gt;</div>
<div class="line"><span class="keyword">class </span>MyLinearElasticityElement : <span class="keyword">public</span> <span class="keyword">virtual</span> QLinearElasticityElement&lt;DIM,3&gt;</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>: </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// The number of &quot;DOF types&quot; that degrees of freedom in this element</span></div>
<div class="line"><span class="comment"> /// are sub-divided into: The displacement components</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">unsigned</span> ndof_types()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">   <span class="keywordflow">return</span> DIM;</div>
<div class="line">  }</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">/// Create a list of pairs for all unknowns in this element,</span></div>
<div class="line"><span class="comment">/// so the first entry in each pair contains the global equation</span></div>
<div class="line"><span class="comment">/// number of the unknown, while the second one contains the number</span></div>
<div class="line"><span class="comment">/// of the &quot;DOF type&quot; that this unknown is associated with.</span></div>
<div class="line"><span class="comment">/// (Function can obviously only be called if the equation numbering</span></div>
<div class="line"><span class="comment">/// scheme has been set up.)</span></div>
<div class="line"><span class="comment">/// </span></div>
<div class="line"><span class="comment">/// The dof type enumeration (in 3D) is as follows:</span></div>
<div class="line"><span class="comment">/// S_x = 0</span></div>
<div class="line"><span class="comment">/// S_y = 1</span></div>
<div class="line"><span class="comment">/// S_z = 2</span></div>
<div class="line"><span class="comment">/// </span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> get_dof_numbers_for_unknowns(</div>
<div class="line">  std::list&lt;std::pair&lt;unsigned long,unsigned&gt; &gt;&amp; dof_lookup_list)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">   <span class="comment">// number of nodes</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_node = this-&gt;nnode();</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// temporary pair (used to store dof lookup prior to being added to list)</span></div>
<div class="line">   std::pair&lt;unsigned,unsigned&gt; dof_lookup;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// loop over the nodes</span></div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0;j&lt;n_node;j++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">//loop over displacement components</span></div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;DIM;i++)</div>
<div class="line">      {</div>
<div class="line">       <span class="comment">// determine local eqn number</span></div>
<div class="line">       <span class="keywordtype">int</span> local_eqn_number = this-&gt;nodal_local_eqn(j,i);</div>
<div class="line">       </div>
<div class="line">       <span class="comment">// ignore pinned values - far away degrees of freedom resulting </span></div>
<div class="line">       <span class="comment">// from hanging nodes can be ignored since these are be dealt</span></div>
<div class="line">       <span class="comment">// with by the element containing their master nodes</span></div>
<div class="line">       <span class="keywordflow">if</span> (local_eqn_number &gt;= 0)</div>
<div class="line">        {</div>
<div class="line">         <span class="comment">// store dof lookup in temporary pair: Global equation number</span></div>
<div class="line">         <span class="comment">// is the first entry in pair</span></div>
<div class="line">         dof_lookup.first = this-&gt;eqn_number(local_eqn_number);</div>
<div class="line">         </div>
<div class="line">         <span class="comment">// set dof numbers: Dof number is the second entry in pair</span></div>
<div class="line">         dof_lookup.second = i;</div>
<div class="line">         </div>
<div class="line">         <span class="comment">// add to list</span></div>
<div class="line">         dof_lookup_list.push_front(dof_lookup);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><p> Thus, in the two-dimensional <code>MyLinearElasticityElement&lt;2&gt;</code> we have two types of dofs, corresponding to the displacements in the <img class="formulaInl" alt="$x$" src="form_12.png" width="8" height="6"/> and <img class="formulaInl" alt="$ y $" src="form_13.png" width="8" height="9"/> directions, respectively. They are enumerated as dof types 0 and 1, respectively.</p>
<h2><a class="anchor" id="dof_types_and_block_types"></a>
dof types, blocks, compound blocks and meshes</h2>
<p>In the block diagonal preconditioner for the two-dimensional linear elasticity problem, discussed above, we have dof types that correspond directly to the blocks in the (re-ordered) Jacobian matrix. However, as we will demonstrate <a href="#compound">below</a>, it is also possible to combine the blocks associated with multiple dofs into a single (compound) block in which case the number of blocks is smaller than the number of dof types. The relationship between dof types, block types, the elemental dof type classification and meshes are as follows</p>
<ul>
<li><b>Elemental</b> <b>dof</b> <b>type</b> <b>classification:</b> Each element classifies its own dof types in the function <code>get_dof_numbers_for_unknowns(...)</code>. In the case of the two-dimensional <code>MyLinearElasticityElement&lt;2&gt;</code> elements, the dof types are classified as <code>0</code> and <code>1</code>; for two-dimensional <code>QTaylorHoodElement&lt;2&gt;</code> Navier-Stokes elements, the dof types are classified as <code>0</code> and <code>1</code> for the <img class="formulaInl" alt="$ x $" src="form_14.png" width="8" height="6"/> and <img class="formulaInl" alt="$y $" src="form_15.png" width="8" height="9"/>-velocities, and <code>2</code> for the pressure <img class="formulaInl" alt="$ p $" src="form_16.png" width="8" height="9"/>; etc. <br  />
<br  />
</li>
<li><b>Role</b> <b>of</b> <b>meshes:</b> When classifying the degrees of freedom into dof types, the block preconditioning framework visits all elements that make contributions to the Jacobian matrix and associates the global equation number of each dof with the dof type specified by the element. The block preconditioning framework is given access to the elements via (possibly multiple) meshes (here simply interpreted as containers for elements), each of which is assumed to contain elements of a single type. The total number of dof types in the block preconditioner is the sum of the dof types of the elements in the meshes. For instance, in a 2D fluid-structure interaction problem we have two different element types, the solid elements (which contain the <img class="formulaInl" alt="$ x $" src="form_14.png" width="8" height="6"/> and <img class="formulaInl" alt="$ y$" src="form_17.png" width="8" height="9"/> solid displacements, <img class="formulaInl" alt="$ u_x $" src="form_18.png" width="14" height="9"/> and <img class="formulaInl" alt="$ u_y $" src="form_19.png" width="14" height="10"/>, respectively, assumed to be enumerated as dof types 0 and 1 by these elements) and the fluid elements (which contain the <img class="formulaInl" alt="$ x $" src="form_14.png" width="8" height="6"/>- and <img class="formulaInl" alt="$ y $" src="form_13.png" width="8" height="9"/> - fluid velocities, <img class="formulaInl" alt="$ v_x $" src="form_20.png" width="13" height="9"/> and <img class="formulaInl" alt="$ v_y $" src="form_21.png" width="13" height="10"/> , and the pressure, <img class="formulaInl" alt="$ p $" src="form_16.png" width="8" height="9"/>, assumed to be enumerated as dof types 0, 1 and 2 by these elements). Assuming the mesh of solid elements is specified as mesh 0 and the mesh of fluid elements is mesh 1, the block preconditioner has a total of five dof types which represent, in order, <img class="formulaInl" alt="$ u_x, u_y, v_x, v_y, p$" src="form_22.png" width="80" height="10"/>. Note that if certain degrees of freedom are classified by multiple elements, the most recent assignment of the dof type over-writes previous assignments. The order in which meshes are specified therefore matters. <br  />
 A corollary to this is that a block preconditioner does not need to "know" about elements that do not introduce any new unknowns. For instance, <code>FaceElements</code> that apply Neumann/flux boundary conditions operate on dofs that are already contained in (and therefore classified by) the elements in the "bulk" mesh. Conversely, if a <code>FaceElement</code> imposes a boundary condition via Lagrange-multipliers, the dofs that represent these Lagrange multipliers must be classified by the <code>FaceElements</code> since the "bulk elements" are not aware of them. <br  />
 If <code>oomph-lib</code> is compiled with the <code>PARANOID</code> flag, an error is thrown if any of the global unknowns are not associated with a dof type.<br  />
<br  />
</li>
<li><b>Blocks:</b> The blocks are the sub-blocks of the system matrix (usually the Jacobian matrix from the Newton method) that the block preconditioner works with. By default, each block is associated with exactly one dof type. However, it is possible create "compound blocks" that are associated with more than one dof type. For example, in the Navier-Stokes LSC preconditioner (in 2D) we have three dof types (the <img class="formulaInl" alt="$x$" src="form_12.png" width="8" height="6"/> and <img class="formulaInl" alt="$y$" src="form_23.png" width="8" height="9"/>-velocities and the pressure), but the preconditioner works with just two block types (forming the velocity and pressure blocks). The setup of the block types is handled by the function <code>block_setup(...)</code> discussed below.</li>
</ul>
<h1><a class="anchor" id="multi_poisson"></a>
Simple preconditioner examples</h1>
<p>We will now illustrate the capabilities of the block preconditioning framework by considering the system of <img class="formulaInl" alt="$ N $" src="form_24.png" width="11" height="10"/> coupled PDEs </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left( \frac{\partial^2 u_i}{\partial x_j^2} + \beta \sum_{k=1}^{N} u_k \right) = f_i(x_j) \ \ \ \ i=1,...,N \ \ \ \ \ \ \ \ \ \ \ \ (1) \]" src="form_25.png" width="294" height="39"/>
</p>
<p> for the <img class="formulaInl" alt="$ N $" src="form_24.png" width="11" height="10"/> fields <img class="formulaInl" alt="$ u_i(x_j) $" src="form_26.png" width="34" height="14"/>. If <img class="formulaInl" alt="$ \beta=0 $" src="form_27.png" width="31" height="13"/>, the system represents <img class="formulaInl" alt="$ N $" src="form_24.png" width="11" height="10"/> (uncoupled) Poisson equations, each with their own source function <img class="formulaInl" alt="$ f_i(x_j). $" src="form_28.png" width="35" height="14"/> If <img class="formulaInl" alt="$ \beta \ne 0 $" src="form_29.png" width="31" height="13"/> the PDE for <img class="formulaInl" alt="$ u_i(x_j) $" src="form_26.png" width="34" height="14"/> is affected by all other fields via the Helmholtz-like second term on the left-hand-side.</p>
<p>The <code>MultiPoissonElements</code> discretise the equations with standard Galerkin-type finite elements in which each field is treated as its own dof type. If <img class="formulaInl" alt="$ N = 5, $" src="form_30.png" width="38" height="13"/> the linear system to be solved in the course of the Newton method, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\bf J} \ \delta {\bf x} = -{\bf r}, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2) \]" src="form_31.png" width="254" height="14"/>
</p>
<p> has a <img class="formulaInl" alt="$5 \times 5$" src="form_32.png" width="28" height="9"/> block structure implying that, following a formal re-numbering of the unknowns, the matrix and the vectors can be written as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hspace{3cm} {\bf J} = \left( \begin{array}{ccccc} J_{11} &amp; J_{12} &amp; J_{13} &amp; J_{14} &amp; J_{15} \\ J_{21} &amp; J_{22} &amp; J_{23} &amp; J_{24} &amp; J_{25} \\ J_{31} &amp; J_{32} &amp; J_{33} &amp; J_{34} &amp; J_{35} \\ J_{41} &amp; J_{42} &amp; J_{43} &amp; J_{44} &amp; J_{45} \\ J_{51} &amp; J_{52} &amp; J_{53} &amp; J_{54} &amp; J_{55} \\ \end{array} \right), \ \ \delta {\bf x} = \left( \begin{array}{c} \delta x_{1} \\ \delta x_{2} \\ \delta x_{3} \\ \delta x_{4} \\ \delta x_{5} \\ \end{array} \right) \ \mbox{ and } \ {\bf r} = \left( \begin{array}{c} r_{1} \\ r_{2} \\ r_{3} \\ r_{4} \\ r_{5} \\ \end{array} \right). \hspace{3cm} (3) \]" src="form_33.png" width="401" height="76"/>
</p>
<p> We wish to solve this linear system by preconditioned Krylov subspace methods, using a block preconditioner <img class="formulaInl" alt="${\bf P}$" src="form_34.png" width="10" height="10"/> formed (formally) from the blocks of the system matrix <img class="formulaInl" alt="${\bf }J$" src="form_35.png" width="8" height="10"/>. As discussed above, the application of the preconditioner (typically once per iteration of the Krylov solver) then requires the solution of linear systems of the form <img class="formulaInl" alt="$ {\bf P} {\bf y} = {\bf z}, $" src="form_36.png" width="45" height="13"/> for <img class="formulaInl" alt="${\bf y}$" src="form_37.png" width="9" height="9"/>. The preconditioning operation can also be written as <img class="formulaInl" alt="$ {\bf y} = {\bf P}^{-1} {\bf z} $" src="form_38.png" width="55" height="14"/> where the operator <img class="formulaInl" alt="${\bf P}^{-1}$" src="form_39.png" width="24" height="11"/> represents the application of the preconditioner to a vector <img class="formulaInl" alt="${\bf z}$" src="form_40.png" width="8" height="6"/>. Formally, the operator <img class="formulaInl" alt="${\bf P}^{-1}$" src="form_39.png" width="24" height="11"/> represents the inverse of the matrix <img class="formulaInl" alt="${\bf P}$" src="form_34.png" width="10" height="10"/> but its application may, of course, be performed <br  />
 approximately by another `&lsquo;subsidiary&rsquo;' preconditioner/inexact solver e.g. by performing a small number of multigrid cycles, say. (Note that we say `&lsquo;formally&rsquo;' because the preconditioner does not actually have to be associated with a specific matrix &ndash; it simply has to act as a linear operator that `&lsquo;turns <img class="formulaInl" alt="${\bf z}$" src="form_40.png" width="8" height="6"/> into <img class="formulaInl" alt="${\bf y}$" src="form_37.png" width="9" height="9"/>&rsquo;').</p>
<p>A specific block preconditioner must be derived from the <code>BlockPreconditioner</code> base class and must implement two pure virtual member functions of the underlying <code>Preconditioner</code> class:</p><ul>
<li><code>void</code> <code>Preconditioner::setup()</code>: This function is called once during the solution of a given linear system by any of <code>oomph-lib</code> 's Krylov subspace solvers. It typically extracts a certain number of blocks from the matrix <img class="formulaInl" alt="${\bf J}$" src="form_2.png" width="8" height="10"/>, possibly manipulates its local copies of these blocks, and performs any preliminary computations required to allow the rapid subsequent application of <img class="formulaInl" alt="${\bf P}^{-1}$" src="form_39.png" width="24" height="11"/>.</li>
<li><code>void</code> <code>Preconditioner::preconditioner_solve</code>( <img class="formulaInl" alt="$\bf{z}$" src="form_41.png" width="8" height="6"/>, <img class="formulaInl" alt="$\bf{y}$" src="form_42.png" width="9" height="9"/>): This function applies <img class="formulaInl" alt="${\bf P}^{-1}$" src="form_39.png" width="24" height="11"/> to the input argument <img class="formulaInl" alt="${\bf z}$" src="form_40.png" width="8" height="6"/> and computes <img class="formulaInl" alt="${\bf y}$" src="form_37.png" width="9" height="9"/>, typically using some data that has been pre-computed in the <code>setup()</code> function.</li>
</ul>
<p>To allow a block preconditioner to classify all dofs, the preconditioner must be given access to all elements that contribute to the linear system to be solved. This is done by specifying pointers to these elements via one or more <code>Mesh</code> objects (which simply act as containers for the element pointers), using the functions <code>set_nmesh(...)</code> (which specifies how many meshes the preconditioner works with) and <code>set_mesh(...)</code>.</p>
<p>We will discuss the implementation of the required functions (and associated capabilities of the block preconditioning framework) in a number of increasingly complex block preconditioners for the solution of the <img class="formulaInl" alt="$5 \times 5$" src="form_32.png" width="28" height="9"/> linear system defined by equations (2) and (3). We stress that the purpose of this exercise is not the development of particularly clever preconditioners but simply an excuse to demonstrate the use of the available `&lsquo;machinery&rsquo;'. Specifically we will demonstrate how to:</p>
<ul>
<li>extract selected blocks from the system matrix (usually the Jacobian matrix assembled by the Newton solver).</li>
<li>perform matrix vector products with selected off-diagonal blocks.</li>
<li>solve linear systems associated with selected blocks, using either a direct solver and/or subsidiary preconditioners (inexact solvers), including cases where the subsidiary preconditioners are block preconditioners themselves.</li>
<li>replace and modify selected blocks and how to make such modified blocks available to subsidiary block preconditioners.</li>
<li>concatenate and coarsen blocks.</li>
</ul>
<hr  />
 <hr  />
<h2><a class="anchor" id="diagonal"></a>
A block diagonal preconditioner</h2>
<p>NEW FEATURES: How to extract matrix blocks and corresponding block vectors from their full-size counterparts</p>
<h3><a class="anchor" id="diag_theory"></a>
Theory</h3>
<p>The simplest possible block preconditioner is a block-diagonal preconditioner, formed by retaining only the diagonal blocks of <img class="formulaInl" alt="${\bf J}$" src="form_2.png" width="8" height="10"/>, so that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hspace{3cm} {\bf P} = \left( \begin{array}{ccccc} J_{11} &amp; &amp; &amp; &amp; \\ &amp; J_{22} &amp; &amp; &amp; \\ &amp; &amp; J_{33} &amp; &amp; \\ &amp; &amp; &amp; J_{44} &amp; \\ &amp; &amp; &amp; &amp; J_{55} \\ \end{array} \right). \hspace{3cm} (4) \]" src="form_43.png" width="325" height="76"/>
</p>
<p> The application of this preconditioner (i.e. the solution of the linear system <img class="formulaInl" alt="${\bf P} {\bf y} ={\bf z}$" src="form_44.png" width="41" height="13"/> for <img class="formulaInl" alt="${\bf y}$" src="form_37.png" width="9" height="9"/>) requires the solution of the five much smaller linear systems </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hspace{3cm} \begin{array}{c} {\bf J}_{11} \ {\bf y}_1 = {\bf z}_1, \\ {\bf J}_{22} \ {\bf y}_2 = {\bf z}_2, \\ {\bf J}_{33} \ {\bf y}_3 = {\bf z}_3, \\ {\bf J}_{44} \ {\bf y}_4 = {\bf z}_4, \\ {\bf J}_{55} \ {\bf y}_5 = {\bf z}_5, \\ \end{array} \hspace{3cm} (5) \]" src="form_45.png" width="195" height="71"/>
</p>
<p> where we have assumed that the two vectors <img class="formulaInl" alt="${\bf y}$" src="form_37.png" width="9" height="9"/> and <img class="formulaInl" alt="${\bf z}$" src="form_40.png" width="8" height="6"/> are re-ordered into `&lsquo;block vectors&rsquo;' in the same way as the vectors <img class="formulaInl" alt="$\delta {\bf x}$" src="form_46.png" width="14" height="10"/> and <img class="formulaInl" alt="${\bf r}$" src="form_47.png" width="8" height="6"/> in "the original linear system" (2) are re-ordered into the `&lsquo;block vectors&rsquo;' in (3).</p>
<p>The implementation of the preconditioning operations in (5) can naturally be subdivided into two distinct <code>setup()</code> and <code>preconditioner_solve(...)</code> phases. Assuming that the linear systems in (5) are solved exactly by a direct solver (an `&lsquo;exact preconditioner&rsquo;') that can pre-compute and store the LU decomposition of the diagonal matrix blocks, the <code>setup()</code> phase involves the following operations [text in square brackets refers to their <code>oomph-lib</code> -specific implementation]:</p><ul>
<li>Set up any data structures/lookup tables that are required to extract matrix blocks from the original matrix <img class="formulaInl" alt="${\bf J}$" src="form_2.png" width="8" height="10"/> [by calling the <code>BlockPreconditioner::block_setup()</code> function].</li>
<li>Extract the five diagonal blocks <img class="formulaInl" alt="${\bf J}_{ii}$" src="form_48.png" width="15" height="13"/> (for <img class="formulaInl" alt="$i=1,...,5$" src="form_49.png" width="56" height="11"/>) [using the <code>BlockPreconditioner::get_block(...)</code> function].</li>
<li>Compute and store the LU decomposition of the diagonal blocks to allow the rapid solution of the systems <img class="formulaInl" alt="${\bf J}_{ii} \ {\bf y}_i = {\bf z}_i$" src="form_50.png" width="59" height="13"/> (for <img class="formulaInl" alt="$i=1,...,5$" src="form_49.png" width="56" height="11"/>) during the <code>preconditioner_solve(...)</code> phase by back-substitution. [This is done by calling the <code>setup(...)</code> function of the subsidiary preconditioner/inexact solver. Following this, the diagonal matrix blocks are longer required and can be deleted.]</li>
</ul>
<p>Once the <code>setup()</code> phase has been completed, the solution of the linear system <img class="formulaInl" alt="${\bf P} {\bf y} = {\bf z}$" src="form_51.png" width="41" height="13"/> by the <code>preconditioner_solve(...)</code> function involves the following steps:</p><ul>
<li>Extract the five `&lsquo;block vectors&rsquo;' <img class="formulaInl" alt="${\bf z}_i$" src="form_52.png" width="11" height="9"/> (for <img class="formulaInl" alt="$i=1,...,5$" src="form_49.png" width="56" height="11"/>) from the vector <img class="formulaInl" alt="${\bf z}$" src="form_40.png" width="8" height="6"/> [using the <code>BlockPreconditioner::get_block_vectors(...)</code> function].</li>
<li>Solve the linear systems <img class="formulaInl" alt="${\bf J}_{ii} \ {\bf y}_i = {\bf z}_i$" src="form_50.png" width="59" height="13"/> for the vectors <img class="formulaInl" alt="${\bf y}_i$" src="form_53.png" width="13" height="9"/> (for <img class="formulaInl" alt="$i=1,...,5$" src="form_49.png" width="56" height="11"/>) using the precomputed LU decomposition of the diagonal blocks <img class="formulaInl" alt="${\bf J}_{ii}$" src="form_48.png" width="15" height="13"/> (for <img class="formulaInl" alt="$i=1,...,5$" src="form_49.png" width="56" height="11"/>) created during the <code>setup()</code> phase.</li>
<li>Combine the five `&lsquo;block vectors&rsquo;' <img class="formulaInl" alt="${\bf y}_i$" src="form_53.png" width="13" height="9"/> (for <img class="formulaInl" alt="$i=1,...,5$" src="form_49.png" width="56" height="11"/>) to the full-length vector <img class="formulaInl" alt="${\bf y}$" src="form_37.png" width="9" height="9"/> [using the <code>BlockPreconditioner::return_block_vectors(...)</code> function].</li>
</ul>
<h3><a class="anchor" id="diag_implementation"></a>
Implementation as a BlockPreconditioner</h3>
<p>Here is a sample implementation of the diagonal block preconditioner as a class <code>Diagonal</code>, derived from the <code>BlockPreconditioner</code> base class. The class provides storage for the subsidiary preconditioners that solve the linear systems associated with the diagonal blocks, implements the <code>setup()</code> and <code>preconditioner_solve(...)</code> functions, and provides a helper function <code>clean_up_my_memory()</code> which does what it says. We also provide an access function which allows the user to specify the pointer to the <code>Mesh</code> that contains the <code>MultiPoissonElements</code> which classify the dofs.</p>
 <div class="fragment"><div class="line"><span class="comment">//=========================start_of_diagonal_class=============================</span></div>
<div class="line"><span class="comment">/// Simple proof-of-concept block diagonal preconditioner for</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// demo purposes. There&#39;s a much better version in src/generic!</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keyword">class </span>Diagonal : <span class="keyword">public</span> BlockPreconditioner&lt;MATRIX&gt;</div>
<div class="line"> {</div>
<div class="line">  </div>
<div class="line"> public :</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Constructor for Diagonal preconditioner</span></div>
<div class="line"><span class="comment"></span>  Diagonal() : BlockPreconditioner&lt;MATRIX&gt;()</div>
<div class="line">   {</div>
<div class="line">    Multi_poisson_mesh_pt=0;</div>
<div class="line">   } <span class="comment">// end_of_constructor</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Destructor - delete the subsidiary preconditioners (solvers for</span></div>
<div class="line"><span class="comment">  /// linear systems involving diagonal block)</span></div>
<div class="line"><span class="comment"></span>  ~Diagonal()</div>
<div class="line">   {</div>
<div class="line">    this-&gt;clean_up_my_memory();</div>
<div class="line">   }</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// clean up the memory</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> clean_up_my_memory();</div>
<div class="line">     <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Broken copy constructor</span></div>
<div class="line"><span class="comment"></span>  Diagonal(<span class="keyword">const</span> Diagonal&amp;) </div>
<div class="line">   { </div>
<div class="line">    BrokenCopy::broken_copy(<span class="stringliteral">&quot;Diagonal&quot;</span>);</div>
<div class="line">   } </div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Broken assignment operator</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> Diagonal&amp;) </div>
<div class="line">   {</div>
<div class="line">    BrokenCopy::broken_assign(<span class="stringliteral">&quot;Diagonal&quot;</span>);</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Setup the preconditioner </span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> setup();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Use the version in the Preconditioner base class for the alternative</span></div>
<div class="line">  <span class="comment">// setup function that takes a matrix pointer as an argument.</span></div>
<div class="line">  <span class="keyword">using</span> Preconditioner::setup;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Apply preconditioner to r, i.e. return solution of P z = r</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> preconditioner_solve(<span class="keyword">const</span> DoubleVector &amp;r, DoubleVector &amp;z);</div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Specify the mesh that contains multi-poisson elements</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> set_multi_poisson_mesh(Mesh* multi_poisson_mesh_pt)</div>
<div class="line">  {</div>
<div class="line">   Multi_poisson_mesh_pt=multi_poisson_mesh_pt;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> private :</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Vector of pointers to preconditioners/inexact solvers </span></div>
<div class="line"><span class="comment">  /// for each diagonal block</span></div>
<div class="line"><span class="comment"></span>  Vector&lt;Preconditioner*&gt; Diagonal_block_preconditioner_pt;</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Mesh pointers with preconditionable elements used</span></div>
<div class="line"><span class="comment">  /// for classification of dof types.</span></div>
<div class="line"><span class="comment"></span>  Mesh* Multi_poisson_mesh_pt;</div>
<div class="line"> </div>
<div class="line"> };</div>
</div><!-- fragment --><h3><a class="anchor" id="diag_setup"></a>
The setup() function</h3>
<p>As mentioned above, a <code>Preconditioner's</code> <code>setup()</code> function is called at the beginning of the <code>IterativeLinearSolver's</code> <code>solve(...)</code> function. In time-dependent and/or nonlinear problems many (different) linear systems have to be solved by the same linear solver (and the associated preconditioner) throughout the code execution. To avoid memory leaks it is therefore important to free up any memory that may have been allocated in any previous use of the preconditioner. The <code>setup()</code> function of all block preconditioner should therefore always start by freeing up such memory. This is best done by using a helper function that can also be called from the destructor.</p>
<div class="fragment"><div class="line"> <span class="comment">//=========================start_of_setup_for_simple========================</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// The setup function.</span></div>
<div class="line"><span class="comment"></span> <span class="comment">//============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> Diagonal&lt;MATRIX&gt;::setup()</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// clean the memory</span></div>
<div class="line">  this-&gt;clean_up_my_memory();</div>
</div><!-- fragment --><p> Next we set the pointer to the preconditioner's one-and-only mesh, and call the <code>block_setup()</code> function to set up the internal data structures and lookup tables required to extract blocks from the system matrix.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line">  <span class="keywordflow">if</span> (Multi_poisson_mesh_pt == 0)</div>
<div class="line">   {</div>
<div class="line">    std::stringstream err;</div>
<div class="line">    err &lt;&lt; <span class="stringliteral">&quot;Please set pointer to mesh using set_multi_poisson_mesh(...).\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">throw</span> OomphLibError(err.str(),</div>
<div class="line">                        OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                        OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">   }</div>
<div class="line"><span class="preprocessor">#endif </span></div>
<div class="line">  </div>
<div class="line">  <span class="comment">// The preconditioner works with one mesh; set it!</span></div>
<div class="line">  this-&gt;set_nmesh(1);</div>
<div class="line">  this-&gt;set_mesh(0,Multi_poisson_mesh_pt);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Set up the generic block lookup scheme</span></div>
<div class="line">  this-&gt;block_setup();</div>
</div><!-- fragment --><p> We create five subsidiary preconditioners (all exact solvers &ndash; SuperLU in its incarnation as an "exact" preconditioner) for the solution of the linear systems involving the diagonal blocks:</p>
<div class="fragment"><div class="line">  <span class="comment">// Extract the number of blocks</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> nblock_types = this-&gt;nblock_types();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create the subsidiary preconditioners</span></div>
<div class="line">  Diagonal_block_preconditioner_pt.resize(nblock_types);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;nblock_types;i++)</div>
<div class="line">   {</div>
<div class="line">    Diagonal_block_preconditioner_pt[i] = <span class="keyword">new</span> SuperLUPreconditioner;</div>
<div class="line">   }</div>
</div><!-- fragment --><p>Next we set up the subsidiary preconditioner by extracting the diagonal blocks from the system matrix and passing them to the subsidiary preconditioners.</p>
<p>Note that each preconditioner is expected to retain a copy of whatever data it needs to subsequently perform its <code>preconditioner_solve(...)</code> function. The deep copy of the block that is returned by the <code>get_block(...)</code> function can therefore be deleted (here simply go out of scope) once the subsidiary preconditioner has been set up. (In the specific case of the <code>SuperLUPreconditioner</code>, the <code>setup(...)</code> function computes and stores the LU decomposition of the matrix; the matrix itself is then no longer required).</p>
<div class="fragment"><div class="line">  <span class="comment">// Setup preconditioners</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;nblock_types;i++)</div>
<div class="line">   {</div>
<div class="line">    <span class="comment">// Get block -- this makes a deep copy of the relevant entries in the</span></div>
<div class="line">    <span class="comment">// full Jacobian (i.e. the matrix of the linear system we&#39;re</span></div>
<div class="line">    <span class="comment">// actually trying to solve); we can do with this copy whatever</span></div>
<div class="line">    <span class="comment">// we want...</span></div>
<div class="line">    CRDoubleMatrix block;</div>
<div class="line">    this-&gt;get_block(i,i,block);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Set up preconditioner (i.e. lu-decompose the block)</span></div>
<div class="line">    Diagonal_block_preconditioner_pt[i]-&gt;setup(&amp;block);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Done with this block now, so the diagonal block that we extracted</span></div>
<div class="line">    <span class="comment">// above can go out of scope. Its LU decomposition (which is the only </span></div>
<div class="line">    <span class="comment">// thing we need to apply the preconditioner in the preconditioner_solve(...)</span></div>
<div class="line">    <span class="comment">// function) is retained in the associated sub-preconditioner/(in)exact </span></div>
<div class="line">    <span class="comment">// solver(SuperLU).</span></div>
<div class="line">   }</div>
</div><!-- fragment --><h3><a class="anchor" id="diag_solve"></a>
The preconditioner_solve() function</h3>
<p>To apply the preconditioner to a given vector, r, we first extract the five block-vectors whose sizes (and permutations) match that of the diagonal matrix blocks, using the <code>get_block_vectors(...)</code> function.</p>
<div class="fragment"><div class="line"> <span class="comment">//============================================================================</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// Preconditioner solve for the diagonal preconditioner: </span></div>
<div class="line"><span class="comment"> /// Apply preconditioner to r and return z, so that P z = r, where</span></div>
<div class="line"><span class="comment"> /// P is the block diagonal matrix constructed from the original </span></div>
<div class="line"><span class="comment"> /// linear system.</span></div>
<div class="line"><span class="comment"></span> <span class="comment">//============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> Diagonal&lt;MATRIX&gt;::</div>
<div class="line"> preconditioner_solve(<span class="keyword">const</span> DoubleVector&amp; r, DoubleVector&amp; z)</div>
<div class="line"> {   </div>
<div class="line">  <span class="comment">// Get number of blocks</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> nblock_types = this-&gt;nblock_types();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Split up rhs vector into sub-vectors, re-arranged to match</span></div>
<div class="line">  <span class="comment">// the matrix blocks</span></div>
<div class="line">  Vector&lt;DoubleVector&gt; block_r;</div>
<div class="line">  this-&gt;get_block_vectors(r,block_r);</div>
</div><!-- fragment --><p> We then provide storage for the five solution vectors and compute them by applying the subsidiary preconditioners' <code>preconditioner_solve(...)</code> function:</p>
<div class="fragment"><div class="line">  <span class="comment">// Solution of block solves</span></div>
<div class="line">  Vector&lt;DoubleVector&gt; block_z(nblock_types);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; nblock_types; i++)</div>
<div class="line">   {</div>
<div class="line">    Diagonal_block_preconditioner_pt[i]-&gt;preconditioner_solve(block_r[i],</div>
<div class="line">                                                              block_z[i]);</div>
<div class="line">   }</div>
</div><!-- fragment --><p> Finally the solutions in <code>block_z</code> are returned into the full-length solution vector <code>z</code> via a call to <code>return_block_vectors(...)</code>.</p>
<div class="fragment"><div class="line">  <span class="comment">// Copy solution in block vectors block_z back to z</span></div>
<div class="line">  this-&gt;return_block_vectors(block_z,z);</div>
<div class="line"> }</div>
</div><!-- fragment --> <h3><a class="anchor" id="diag_clean"></a>
The clean_up_my_memory() function</h3>
<p>This function (which is called by the <code>setup()</code> function and the destructor) frees the memory that is allocated when a new linear system is solved &ndash; here the subsidiary preconditioners and their associated data (the LU decompositions of the diagonal blocks).</p>
<div class="fragment"><div class="line"> <span class="comment">//=========================start_of_clean_up_for_simple=======================</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// The clean up function.</span></div>
<div class="line"><span class="comment"></span> <span class="comment">//============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> Diagonal&lt;MATRIX&gt;::clean_up_my_memory()</div>
<div class="line"> { </div>
<div class="line">  <span class="comment">// Delete diagonal preconditioners (approximate solvers)</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> n_block = Diagonal_block_preconditioner_pt.size();</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n_block;i++)</div>
<div class="line">   {</div>
<div class="line">    <span class="keywordflow">if</span>(Diagonal_block_preconditioner_pt[i]!=0)</div>
<div class="line">     {</div>
<div class="line">      <span class="keyword">delete</span> Diagonal_block_preconditioner_pt[i];</div>
<div class="line">      Diagonal_block_preconditioner_pt[i]=0;</div>
<div class="line">     }</div>
<div class="line">   }</div>
<div class="line"> } <span class="comment">// End of clean_up_my_memory function.</span></div>
</div><!-- fragment --> <h3><a class="anchor" id="diag_comments"></a>
Comments and Exercises</h3>
<ul>
<li><code>The</code> function <code>get_block_vectors(r,block_r)</code> extracts the five (or, in general, <code>nblock_type()</code> ) block vectors <code>block_r</code> from the full-length vector <code>r</code>. The sizes of the block vectors (and the permutation of their entries relative to their order in the full length vector <code>r</code>) match that of the matrix blocks. There is an alternative function <code>get_block_vector(...)</code> (note the missing s) which extracts a single block vector. An equivalent version exists for the <code>return_block_vector</code>[s] functions.</li>
<li>In the example above we used an "exact preconditioner" (direct solver) to solve the five linear systems associated with the diagonal blocks. However, the (approximate) solution of these linear systems can be performed by any other matrix-based preconditioner, such as <code>oomph-lib's</code> diagonal preconditioner, <code>MatrixBasedDiagPreconditioner</code>, discussed in <a href="../../../linear_solvers/html/index.html">another tutorial</a>. The setup and application of this preconditioner is obviously much faster than for the <code>SuperLUPreconditioner</code>. Its setup merely requires the extraction of the diagonal entries and storage of their inverses (rather than the computation of the LU decomposition), while the application simply requires the multiplication of the input vector by the pre-computed inverses of the diagonal entries (rather than a back-substitution). However, the preconditioner is clearly not "as good" and therefore results in a larger number of iterations in the iterative linear solver. In fact, using the diagonal preconditioner for the approximate solution of the five linear systems involving the diagonal blocks is mathematically equivalent to using the diagonal preconditioner on the entire matrix. Try it out!</li>
</ul>
<hr  />
 <hr  />
<h2><a class="anchor" id="upper_triangular"></a>
A block upper triangular preconditioner</h2>
<p>NEW FEATURES: How to set up matrix vector products with off-diagonal blocks</p>
<h3><a class="anchor" id="upper_triangular_theory"></a>
Theory</h3>
<p>Next we consider the implementation of an upper triangular preconditioner, formed by retaining only the blocks in the upper right hand part of <img class="formulaInl" alt="${\bf J}$" src="form_2.png" width="8" height="10"/>, including the diagonals. </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hspace{3cm} {\bf P} = \left( \begin{array}{ccccc} J_{11} &amp; J_{12} &amp; J_{13} &amp; J_{14} &amp; J_{15} \\ &amp; J_{22} &amp; J_{23} &amp; J_{24} &amp; J_{25} \\ &amp; &amp; J_{33} &amp; J_{34} &amp; J_{35} \\ &amp; &amp; &amp; J_{44} &amp; J_{45} \\ &amp; &amp; &amp; &amp; J_{55} \\ \end{array} \right). \hspace{3cm} (6) \]" src="form_54.png" width="325" height="76"/>
</p>
<p> The application of this preconditioner (i.e. the solution of the linear system <img class="formulaInl" alt="${\bf P} {\bf y} ={\bf z}$" src="form_44.png" width="41" height="13"/> for <img class="formulaInl" alt="${\bf y}$" src="form_37.png" width="9" height="9"/>) again requires the solution of five much smaller linear systems </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hspace{3cm} \begin{array}{l} {\bf J}_{11} \ {\bf y}_1 = \widetilde{\bf z}_1 = {\bf z}_1 - {\bf J}_{15} \ {\bf y}_5 - {\bf J}_{14} \ {\bf y}_4 - {\bf J}_{13} \ {\bf y}_3 - {\bf J}_{12} \ {\bf y}_2, \\ {\bf J}_{22} \ {\bf y}_2 = \widetilde{\bf z}_2 = {\bf z}_2 - {\bf J}_{25} \ {\bf y}_5 - {\bf J}_{24} \ {\bf y}_4 - {\bf J}_{23} \ {\bf y}_3, \\ {\bf J}_{33} \ {\bf y}_3 = \widetilde{\bf z}_3 ={\bf z}_3 - {\bf J}_{35} \ {\bf y}_5 - {\bf J}_{34} \ {\bf y}_4, \\ {\bf J}_{44} \ {\bf y}_4 = \widetilde{\bf z}_4 ={\bf z}_4 - {\bf J}_{45} \ {\bf y}_5, \\ {\bf J}_{55} \ {\bf y}_5 = \widetilde{\bf z}_5 = {\bf z}_5, \\ \end{array} \hspace{3cm} (7) \]" src="form_55.png" width="426" height="73"/>
</p>
<p> where we have again assumed that the two vectors <img class="formulaInl" alt="${\bf y}$" src="form_37.png" width="9" height="9"/> and <img class="formulaInl" alt="${\bf z}$" src="form_40.png" width="8" height="6"/> are re-ordered into `&lsquo;block vectors&rsquo;' in the same way as the vectors <img class="formulaInl" alt="$\delta {\bf x}$" src="form_46.png" width="14" height="10"/> and <img class="formulaInl" alt="${\bf r}$" src="form_47.png" width="8" height="6"/> in "the original linear system" (2) are re-ordered into the `&lsquo;block vectors&rsquo;' in (3).</p>
<p>The main difference to the block diagonal preconditioner considered before is that the right hand sides of the linear systems have to be modified. We start by solving the final equation for <img class="formulaInl" alt="$ {\bf y}_5 $" src="form_56.png" width="14" height="9"/>. We then multiply this vector by the off-diagonal block <img class="formulaInl" alt="$ {\bf J}_{45} $" src="form_57.png" width="19" height="13"/>, subtract the result from <img class="formulaInl" alt="$ {\bf z}_4 $" src="form_58.png" width="13" height="9"/> and use the result of this operation as the right-hand-side for the linear system that determines <img class="formulaInl" alt="$ {\bf y}_4$" src="form_59.png" width="14" height="9"/>, etc.</p>
<p>The implementation of the preconditioning operations in (7) can again be subdivided into two distinct <code>setup()</code> and <code>preconditioner_solve(...)</code> phases. Assuming that the linear systems in (7) are solved exactly by a direct solver (an `&lsquo;exact preconditioner&rsquo;') that can pre-compute and store the LU decomposition of the diagonal matrix blocks, the <code>setup()</code> phase involves the following operations [text in square brackets refers to their <code>oomph-lib</code> specific implementation]:</p><ul>
<li>Set up any data structures/lookup tables that are required to extract matrix blocks from the original matrix <img class="formulaInl" alt="${\bf J}$" src="form_2.png" width="8" height="10"/> [by calling the <code>BlockPreconditioner::block_setup()</code> function].</li>
<li>Extract the five diagonal blocks <img class="formulaInl" alt="${\bf J}_{ii}$" src="form_48.png" width="15" height="13"/> (for <img class="formulaInl" alt="$i=1,...,5$" src="form_49.png" width="56" height="11"/>) [using the <code>BlockPreconditioner::get_block(...)</code> function].</li>
<li>Compute and store the LU decomposition of the diagonal blocks to allow the rapid solution of the systems <img class="formulaInl" alt="${\bf J}_{ii} \ {\bf y}_i = \widetilde{\bf z}_i$" src="form_60.png" width="59" height="13"/> (for <img class="formulaInl" alt="$i=1,...,5$" src="form_49.png" width="56" height="11"/>) during the <code>preconditioner_solve(...)</code> phase by back-substitution. [This is done by calling the <code>setup(...)</code> function of the subsidiary preconditioner/inexact solver. Following this, the diagonal matrix blocks are longer required and can be deleted.]</li>
<li>Extract the relevant off-diagonal blocks from <img class="formulaInl" alt="${\bf J}$" src="form_2.png" width="8" height="10"/> and create <code>MatrixVectorProduct</code> operators. [The matrix vector products are set up using the <code>setup_matrix_vector_product(...)</code> function. As with the subsidiary preconditioners, the <code>MatrixVectorProduct</code> operators retain their own copy of any required data, so the off-diagonal matrix blocks can be deleted (or be allowed to go out of scope) following the setup.]</li>
</ul>
<h3><a class="anchor" id="upper_triangular_implementation"></a>
Implementation as a BlockPreconditioner</h3>
<p>Here is a sample implementation of the upper triangular block preconditioner as a class <code>UpperTriangular</code>, derived from the <code>BlockPreconditioner</code> base class. The class provides storage for the subsidiary preconditioners that solve the linear systems associated with the diagonal blocks, and the <code>MatrixVectorProduct</code> operators. We also implement the <code>setup()</code> and <code>preconditioner_solve(...)</code> functions, and provide a helper function <code>clean_up_my_memory()</code> which does what it says. As before we also provide an access function which allows the user to specify the pointer to the <code>Mesh</code> that contains the <code>MultiPoissonElements</code> which classify the dofs.</p>
 <div class="fragment"><div class="line"><span class="comment">//=========================start_of_upper_triangular_class=====================</span></div>
<div class="line"><span class="comment">/// Upper triangular preconditioner for a system </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// with any number of dof types.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keyword">class </span>UpperTriangular : <span class="keyword">public</span> BlockPreconditioner&lt;MATRIX&gt;</div>
<div class="line"> {</div>
<div class="line"> </div>
<div class="line"> public :</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Constructor.</span></div>
<div class="line"><span class="comment"></span>  UpperTriangular() : BlockPreconditioner&lt;MATRIX&gt;()</div>
<div class="line">   {</div>
<div class="line">    Multi_poisson_mesh_pt=0;</div>
<div class="line">   }</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Destructor - delete the preconditioner matrices</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> ~UpperTriangular()</div>
<div class="line">   {</div>
<div class="line">    this-&gt;clean_up_my_memory();</div>
<div class="line">   }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// clean up the memory</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> clean_up_my_memory();</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Broken copy constructor</span></div>
<div class="line"><span class="comment"></span>  UpperTriangular(<span class="keyword">const</span> UpperTriangular&amp;) </div>
<div class="line">   { </div>
<div class="line">    BrokenCopy::broken_copy(<span class="stringliteral">&quot;UpperTriangular&quot;</span>);</div>
<div class="line">   } </div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Broken assignment operator</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> UpperTriangular&amp;) </div>
<div class="line">   {</div>
<div class="line">    BrokenCopy::broken_assign(<span class="stringliteral">&quot;UpperTriangular&quot;</span>);</div>
<div class="line">   }</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Apply preconditioner to r</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> preconditioner_solve(<span class="keyword">const</span> DoubleVector &amp;r, DoubleVector &amp;z);</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Setup the preconditioner </span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> setup();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Use the version in the Preconditioner base class for the alternative</span></div>
<div class="line">  <span class="comment">// setup function that takes a matrix pointer as an argument.</span></div>
<div class="line">  <span class="keyword">using</span> Preconditioner::setup;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Specify the mesh that contains multi-poisson elements</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> set_multi_poisson_mesh(Mesh* multi_poisson_mesh_pt)</div>
<div class="line">  {</div>
<div class="line">   Multi_poisson_mesh_pt=multi_poisson_mesh_pt;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:  </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Pointers to matrix vector product operators for the off diagonals</span></div>
<div class="line"><span class="comment"></span>  DenseMatrix&lt;MatrixVectorProduct*&gt; Off_diagonal_matrix_vector_product_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Vector of pointers to preconditioners/inexact solvers </span></div>
<div class="line"><span class="comment">  /// for each diagonal block</span></div>
<div class="line"><span class="comment"></span>  Vector&lt;Preconditioner*&gt; Block_preconditioner_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Pointer to mesh with preconditionable elements used</span></div>
<div class="line"><span class="comment">  /// for classification of dof types.</span></div>
<div class="line"><span class="comment"></span>  Mesh* Multi_poisson_mesh_pt;</div>
<div class="line"> </div>
<div class="line"> };</div>
</div><!-- fragment --> <h3><a class="anchor" id="upper_triangular_setup"></a>
The setup() function</h3>
<p>As before, we start by cleaning up the memory, set the pointer to the mesh, and set up the generic block preconditioner functionality by calling <code>block_setup()</code>.</p>
<div class="fragment"><div class="line"> <span class="comment">//========================start_of_setup_for_upper_triangular_class===========</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// The setup function.</span></div>
<div class="line"><span class="comment"></span> <span class="comment">//============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> UpperTriangular&lt;MATRIX&gt;::setup()</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// clean the memory</span></div>
<div class="line">  this-&gt;clean_up_my_memory();</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line">  <span class="keywordflow">if</span> (Multi_poisson_mesh_pt == 0)</div>
<div class="line">   {</div>
<div class="line">    std::stringstream err;</div>
<div class="line">    err &lt;&lt; <span class="stringliteral">&quot;Please set pointer to mesh using set_multi_poisson_mesh(...).\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">throw</span> OomphLibError(err.str(),</div>
<div class="line">                        OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                        OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">   }</div>
<div class="line"><span class="preprocessor">#endif </span></div>
<div class="line">  </div>
<div class="line">  <span class="comment">// The preconditioner works with one mesh; set it!</span></div>
<div class="line">  this-&gt;set_nmesh(1);</div>
<div class="line">  this-&gt;set_mesh(0,Multi_poisson_mesh_pt);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set up the block look up schemes</span></div>
<div class="line">  this-&gt;block_setup();</div>
</div><!-- fragment --><p> We provide storage for the (pointers to the) matrix vector products and the subsidiary preconditioners.</p>
<div class="fragment"><div class="line">  <span class="comment">// Number of block types  </span></div>
<div class="line">  <span class="keywordtype">unsigned</span> nblock_types = this-&gt;nblock_types();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Storage for the pointers to the off diagonal matrix vector products</span></div>
<div class="line">  <span class="comment">// and the the subsidiary preconditioners (inexact solvers) for the diagonal </span></div>
<div class="line">  <span class="comment">// blocks</span></div>
<div class="line">  Off_diagonal_matrix_vector_product_pt.resize(nblock_types,nblock_types,0);</div>
<div class="line">  Block_preconditioner_pt.resize(nblock_types);</div>
</div><!-- fragment --><p> Next we create the subsidiary preconditioners which we will use to solve the linear systems involving the diagonal blocks.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">// Build the preconditioners and matrix vector products</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0; i &lt; nblock_types; i++)</div>
<div class="line">   {</div>
<div class="line">    <span class="comment">// Create the subsidiary preconditioners</span></div>
<div class="line">    Block_preconditioner_pt[i] = <span class="keyword">new</span> SuperLUPreconditioner;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Put in braces so block matrix goes out of scope when done...</span></div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Get block -- this makes a deep copy of the relevant entries in the</span></div>
<div class="line">     <span class="comment">// full Jacobian (i.e. the matrix of the linear system we&#39;re</span></div>
<div class="line">     <span class="comment">// actually trying to solve); we can do with this copy whatever</span></div>
<div class="line">     <span class="comment">// we want...</span></div>
<div class="line">     CRDoubleMatrix block;</div>
<div class="line">     this-&gt;get_block(i,i,block);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Set up preconditioner (i.e. lu-decompose the block)</span></div>
<div class="line">     Block_preconditioner_pt[i]-&gt;setup(&amp;block);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Done with this block now, so the diagonal block that we extracted</span></div>
<div class="line">     <span class="comment">// above can go out of scope. Its LU decomposition (which is the only </span></div>
<div class="line">     <span class="comment">// thing we need to apply the preconditioner in the </span></div>
<div class="line">     <span class="comment">// preconditioner_solve(...) function) is retained in the associated </span></div>
<div class="line">     <span class="comment">// sub-preconditioner/(in)exact solver(SuperLU).</span></div>
<div class="line"> </div>
<div class="line">    } <span class="comment">// end of brace to make block go out of scope</span></div>
</div><!-- fragment --><p> We then extract the relevant off-diagonal blocks (those above the diagonal) from the full matrix, create a <code>MatrixVectorProduct</code> operator for each and use the <code>BlockPreconditioner::setup_matrix_vector_product(...)</code> function to make them fully functional. Note that the final argument to this function (the column index of the off-diagonal block in its block enumeration within the current preconditioner) is required to set up additional lookup tables that are required to ensure the correct operation of this object in cases when the preconditioner operates in parallel. The details are messy and not worth explaining here &ndash; just do it!</p>
<div class="fragment"><div class="line">    <span class="comment">// Next set up the off diagonal mat vec operators</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=i+1;j&lt;nblock_types;j++)</div>
<div class="line">     {</div>
<div class="line">      <span class="comment">// Get the off diagonal block</span></div>
<div class="line">      CRDoubleMatrix block_matrix = this-&gt;get_block(i,j);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Create a matrix vector product operator</span></div>
<div class="line">      Off_diagonal_matrix_vector_product_pt(i,j) = <span class="keyword">new</span> MatrixVectorProduct;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Setup the matrix vector product for the currrent block matrix</span></div>
<div class="line">      <span class="comment">// and specify the column in the &quot;big matrix&quot; as final argument.</span></div>
<div class="line">      <span class="comment">// This is needed for things to work properly in parallel -- don&#39;t ask!</span></div>
<div class="line">      this-&gt;setup_matrix_vector_product(</div>
<div class="line">       Off_diagonal_matrix_vector_product_pt(i,j),&amp;block_matrix,j);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Done with this block now, so the diagonal block that we extracted</span></div>
<div class="line">      <span class="comment">// above can go out of scope. The MatrixVectorProduct operator retains</span></div>
<div class="line">      <span class="comment">// its own copy of whatever data it needs.</span></div>
<div class="line"> </div>
<div class="line">     } <span class="comment">// End for loop over j</span></div>
<div class="line">   } <span class="comment">// End for loop over i</span></div>
<div class="line"> } <span class="comment">// End setup(...)</span></div>
</div><!-- fragment --> <h3><a class="anchor" id="upper_triangular_solve"></a>
The preconditioner_solve() function</h3>
<p>As in the block diagonal preconditioner, we start by extracting the block vectors from the full-length vector, <code>r</code>.</p>
<div class="fragment"><div class="line"> <span class="comment">//=============================================================================</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// Preconditioner solve for the upper triangular preconditioner: </span></div>
<div class="line"><span class="comment"> /// Apply preconditioner to r and return z, so that P z = r, where</span></div>
<div class="line"><span class="comment"> /// P is the block diagonal matrix constructed from the original </span></div>
<div class="line"><span class="comment"> /// linear system.</span></div>
<div class="line"><span class="comment"></span> <span class="comment">//=============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; <span class="keywordtype">void</span> UpperTriangular&lt;MATRIX&gt;::</div>
<div class="line"> preconditioner_solve(<span class="keyword">const</span> DoubleVector&amp; r, DoubleVector&amp; z)</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// Get number of blocks</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> n_block = this-&gt;nblock_types();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// vector of vectors for each section of rhs vector</span></div>
<div class="line">  Vector&lt;DoubleVector&gt; block_r;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// rearrange the vector r into the vector of block vectors block_r</span></div>
<div class="line">  this-&gt;get_block_vectors(r,block_r);</div>
</div><!-- fragment --><p> Next we provide storage for the solution vectors and work backwards through the (block)-rows of the (block-)linear system (7). Following each linear solve we update the right-hand-side of the next linear system, as discussed above.</p>
<div class="fragment"><div class="line">  <span class="comment">// Vector of vectors for the solution block vectors</span></div>
<div class="line">  Vector&lt;DoubleVector&gt; block_z(n_block);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Required to be an int due to an unsigned being unable to be compared to a</span></div>
<div class="line">  <span class="comment">// negative number (because it would roll over).</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=n_block-1;i&gt;-1;i--)</div>
<div class="line">   {</div>
<div class="line">    <span class="comment">// Back substitute</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=i+1;j&lt;n_block;j++)</div>
<div class="line">     {</div>
<div class="line">      DoubleVector temp;</div>
<div class="line">      Off_diagonal_matrix_vector_product_pt(i,j)-&gt;multiply(block_z[j],temp);</div>
<div class="line">      block_r[i] -= temp;</div>
<div class="line">     } <span class="comment">// End for over j</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Solve on the block</span></div>
<div class="line">    this-&gt;Block_preconditioner_pt[i]-&gt;</div>
<div class="line">     preconditioner_solve(block_r[i], block_z[i]);</div>
<div class="line">   } <span class="comment">// End for over i</span></div>
</div><!-- fragment --><p> Finally, the solutions in <code>block_z</code> are combined via <code>return_block_vectors(...)</code> which places the results back into the full-length vector <code>z</code> that is returned by this function.</p>
<div class="fragment"><div class="line">  <span class="comment">// Copy solution in block vectors block_r back to z</span></div>
<div class="line">  this-&gt;return_block_vectors(block_z,z);</div>
<div class="line"> }</div>
</div><!-- fragment --> <h3><a class="anchor" id="upper_triangular_clean"></a>
The clean_up_my_memory() function</h3>
<p>This function again deletes any data that was allocated in the setup function &ndash; here the subsidiary preconditioners (and their LU decompositions) and the matrix-vector product operators.</p>
<div class="fragment"><div class="line"> <span class="comment">//========================start_of_clean_up_for_upper_triangular_class========</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// The clean up function.</span></div>
<div class="line"><span class="comment"></span> <span class="comment">//============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> UpperTriangular&lt;MATRIX&gt;::clean_up_my_memory()</div>
<div class="line"> {     </div>
<div class="line">  <span class="comment">// Delete anything in Off_diagonal_matrix_vector_products</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0,ni=Off_diagonal_matrix_vector_product_pt.nrow();i&lt;ni;i++)</div>
<div class="line">   {</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0,nj=Off_diagonal_matrix_vector_product_pt.ncol();j&lt;nj;j++)</div>
<div class="line">     {</div>
<div class="line">      <span class="keywordflow">if</span>(Off_diagonal_matrix_vector_product_pt(i,j) != 0)</div>
<div class="line">       {    </div>
<div class="line">        <span class="keyword">delete</span> Off_diagonal_matrix_vector_product_pt(i,j);</div>
<div class="line">        Off_diagonal_matrix_vector_product_pt(i,j) = 0;</div>
<div class="line">       }</div>
<div class="line">     }</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Delete preconditioners (approximate solvers)</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> n_block = Block_preconditioner_pt.size();</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n_block;i++)</div>
<div class="line">   {</div>
<div class="line">    <span class="keywordflow">if</span>(Block_preconditioner_pt[i]!=0)</div>
<div class="line">     {</div>
<div class="line">      <span class="keyword">delete</span> Block_preconditioner_pt[i];</div>
<div class="line">      Block_preconditioner_pt[i]=0;</div>
<div class="line">     }</div>
<div class="line">   }</div>
<div class="line"> } <span class="comment">// End of clean_up_my_memory function.</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<p><a class="anchor" id="compound"></a> </p>
<h2><a class="anchor" id="two_plus_three"></a>
Combining multiple dof types into compound blocks. Part 1</h2>
<p>NEW FEATURES: How to combine multiple dof types into compound blocks</p>
<h3><a class="anchor" id="two_plus_three_theory"></a>
Theory</h3>
<p>So far we have illustrated how to implement block preconditioners for cases where the dof types (as identified by the elements) correspond directly to the block types. This is appropriate for our model PDE system (1) in which the five fields (and the governing equations) are all of the same type. In many applications, particularly in multi-physics problems, it may be desirable to combine similar/related dof types into single blocks. For instance, in a 2D fluid-structure interaction problem, we may wish to distinguish between the two solid (x and y solid displacements) and three fluid (x and y fluid velocities and the pressure) dofs and employ subsidiary preconditioners that act directly on the two distinct solid and fluid blocks. A basic block diagonal preconditioner for such a problem that ignores the coupling between fluid and solid dofs has the following structure </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hspace{3cm} {\bf P} = \left( \begin{array}{cc|ccc} J_{11} &amp; J_{12} &amp; &amp; &amp; \\ J_{21} &amp; J_{22} &amp; &amp; &amp; \\ \hline &amp; &amp; J_{33} &amp; J_{34} &amp; J_{35} \\ &amp; &amp; J_{43} &amp; J_{44} &amp; J_{45} \\ &amp; &amp; J_{53} &amp; J_{54} &amp; J_{55} \\ \end{array} \right) = \left( \begin{array}{c|c} B_{11} &amp; \\ \hline &amp; B_{22} \\ \end{array} \right) \hspace{3cm} \]" src="form_61.png" width="295" height="76"/>
</p>
<p> where <img class="formulaInl" alt="$ B_{11} $" src="form_62.png" width="19" height="13"/> and <img class="formulaInl" alt="$ B_{22} $" src="form_63.png" width="19" height="13"/> are the blocks formed from the corresponding "dof blocks" (the <img class="formulaInl" alt="$ J_{ij} $" src="form_64.png" width="15" height="14"/> matrices). The application of this preconditioner (i.e. the solution of the linear system <img class="formulaInl" alt="${\bf P} {\bf y} ={\bf z}$" src="form_44.png" width="41" height="13"/> for <img class="formulaInl" alt="${\bf y}$" src="form_37.png" width="9" height="9"/>) requires the solution of the two smaller linear systems </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hspace{3cm} \left( \begin{array}{cc} J_{11} &amp; J_{12} \\ J_{21} &amp; J_{22} \\ \end{array} \right) \left( \begin{array}{c} y_1 \\ y_2 \\ \end{array} \right) = \left( \begin{array}{c} z_1 \\ z_2 \\ \end{array} \right) \mbox{\ \ \ \ \ \ \ or \ \ \ \ \ \ } B_{11} \ Y_1 = Z_1 \hspace{3cm} (8) \]" src="form_65.png" width="439" height="31"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hspace{3cm} \left( \begin{array}{ccc} J_{33} &amp; J_{34} &amp; J_{35} \\ J_{43} &amp; J_{44} &amp; J_{45} \\ J_{53} &amp; J_{54} &amp; J_{55} \\ \end{array} \right) \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) = \left( \begin{array}{c} z_3 \\ z_4 \\ z_5 \\ \end{array} \right) \mbox{\ \ \ \ \ \ \ or \ \ \ \ \ \ } B_{22} \ Y_2 = Z_2. \hspace{3cm} (9) \]" src="form_66.png" width="481" height="46"/>
</p>
<p>A key feature of the block preconditioning framework is the ability to combine dof types in this manner so that the preconditioner can operate directly with blocks <img class="formulaInl" alt="$ B_{11} $" src="form_62.png" width="19" height="13"/> and <img class="formulaInl" alt="$ B_{22} $" src="form_63.png" width="19" height="13"/> and the corresponding block vectors <img class="formulaInl" alt="$ Y_1, Y_2, Z_1 $" src="form_67.png" width="51" height="13"/> and <img class="formulaInl" alt="$ Z_2 $" src="form_68.png" width="14" height="13"/>.</p>
<p>Assuming again that the linear systems in (8) and (9) are solved exactly by a direct solver (an `&lsquo;exact preconditioner&rsquo;') that can pre-compute and store the LU decomposition of the diagonal matrix blocks, <img class="formulaInl" alt="$ B_{11} $" src="form_62.png" width="19" height="13"/> and <img class="formulaInl" alt="$ B_{22} $" src="form_63.png" width="19" height="13"/>, the <code>setup()</code> phase involves the following operations [text in square brackets refers to their <code>oomph-lib</code> specific implementation]:</p><ul>
<li>Set up any data structures/lookup tables that are required to extract the matrix blocks <img class="formulaInl" alt="$ B_{11} $" src="form_62.png" width="19" height="13"/> and <img class="formulaInl" alt="$ B_{22} $" src="form_63.png" width="19" height="13"/> and the associated block vectors [by calling the <code>BlockPreconditioner::block_setup(...)</code> function &ndash; this time with arguments that specify the mapping between "dof types" and "block types"].</li>
<li>Extract the two diagonal blocks, <img class="formulaInl" alt="$ B_{11} $" src="form_62.png" width="19" height="13"/> and <img class="formulaInl" alt="$ B_{22}$" src="form_69.png" width="19" height="13"/> [using the <code>BlockPreconditioner::get_block(...)</code> function].</li>
<li>Compute and store the LU decomposition of the diagonal blocks to allow the rapid solution of the systems during the <code>preconditioner_solve(...)</code> phase by back-substitution. [This is done by calling the <code>setup(...)</code> function of the subsidiary preconditioner/inexact solver. Following this, the diagonal matrix blocks are longer required and can be deleted.]</li>
</ul>
<p>Once the <code>setup()</code> phase has been completed, the solution of the linear system <img class="formulaInl" alt="${\bf P} {\bf y} = {\bf z}$" src="form_51.png" width="41" height="13"/> by the <code>preconditioner_solve(...)</code> function involves the following steps:</p><ul>
<li>Extract the two `&lsquo;block vectors&rsquo;' <img class="formulaInl" alt="${\bf Z}_i$" src="form_70.png" width="13" height="13"/> (for <img class="formulaInl" alt="$i=1,2$" src="form_71.png" width="40" height="11"/>) from the vector <img class="formulaInl" alt="${\bf z}$" src="form_40.png" width="8" height="6"/> [using the <code>BlockPreconditioner::get_block_vectors(...)</code> function].</li>
<li>Solve the linear systems <img class="formulaInl" alt="${\bf B}_{ii} \ {\bf Y}_i = {\bf Z}_i$" src="form_72.png" width="68" height="13"/> for the vectors <img class="formulaInl" alt="${\bf Y}_i$" src="form_73.png" width="15" height="13"/> (for <img class="formulaInl" alt="$i=1,2$" src="form_71.png" width="40" height="11"/>) using the precomputed LU decomposition of the diagonal blocks <img class="formulaInl" alt="${\bf B}_{ii}$" src="form_74.png" width="19" height="13"/> (for <img class="formulaInl" alt="$i=1,2$" src="form_71.png" width="40" height="11"/>) created during the <code>setup()</code> phase.</li>
<li>Combine the two `&lsquo;block vectors&rsquo;' <img class="formulaInl" alt="${\bf Y}_i$" src="form_73.png" width="15" height="13"/> (for <img class="formulaInl" alt="$i=1,...,2$" src="form_75.png" width="56" height="11"/>) to the full-length vector <img class="formulaInl" alt="${\bf y}$" src="form_37.png" width="9" height="9"/> [using the <code>BlockPreconditioner::return_block_vectors(...)</code> function].</li>
</ul>
<h3><a class="anchor" id="two_plus_three_implementation"></a>
Implementation as a BlockPreconditioner</h3>
<p>The implementation of the preconditioner closely follows that of the block diagonal preconditioner discussed above, the main difference being that the current preconditioner only ever operates with exactly two blocks. Therefore we store pointers to the two subsidiary preconditioners (rather than a vector of pointers that can store an arbitrary number of these).</p>
<div class="fragment"><div class="line"><span class="comment">//=======================start_of_two_plus_three_class=========================</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// Block diagonal preconditioner for system with 5 dof types</span></div>
<div class="line"><span class="comment">/// assembled into a 2x2 block system, with (0,0) block containing the </span></div>
<div class="line"><span class="comment">/// first two dof types and the (1,1) block the remaining three dof types.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keyword">class </span>TwoPlusThree : <span class="keyword">public</span> BlockPreconditioner&lt;MATRIX&gt;</div>
<div class="line">  {</div>
<div class="line">    public :</div>
<div class="line">   <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Constructor for TwoPlusThree</span></div>
<div class="line"><span class="comment"></span>  TwoPlusThree() : BlockPreconditioner&lt;MATRIX&gt;(),</div>
<div class="line">   First_subsidiary_preconditioner_pt(0),</div>
<div class="line">   Second_subsidiary_preconditioner_pt(0)</div>
<div class="line">    {</div>
<div class="line">     Multi_poisson_mesh_pt=0;</div>
<div class="line">    } <span class="comment">// end_of_constructor</span></div>
<div class="line">    <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Destructor - delete the diagonal solvers (subsidiary preconditioners)</span></div>
<div class="line"><span class="comment"></span>  ~TwoPlusThree()</div>
<div class="line">   {</div>
<div class="line">    this-&gt;clean_up_my_memory();</div>
<div class="line">   }<span class="comment"></span></div>
<div class="line"><span class="comment">  /// clean up the memory</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> clean_up_my_memory();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Broken copy constructor</span></div>
<div class="line"><span class="comment"></span>  TwoPlusThree</div>
<div class="line">  (<span class="keyword">const</span> TwoPlusThree&amp;) </div>
<div class="line">   { </div>
<div class="line">    BrokenCopy::broken_copy(<span class="stringliteral">&quot;TwoPlusThree&quot;</span>);</div>
<div class="line">   } </div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Broken assignment operator</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> TwoPlusThree&amp;) </div>
<div class="line">   {</div>
<div class="line">    BrokenCopy::broken_assign(<span class="stringliteral">&quot;TwoPlusThree&quot;</span>);</div>
<div class="line">   }</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Apply preconditioner to r, i.e. return z such that P z = r</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> preconditioner_solve(<span class="keyword">const</span> DoubleVector &amp;r, DoubleVector &amp;z);</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Setup the preconditioner </span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> setup();</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Specify the mesh that contains multi-poisson elements</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> set_multi_poisson_mesh(Mesh* multi_poisson_mesh_pt)</div>
<div class="line">  {</div>
<div class="line">   Multi_poisson_mesh_pt=multi_poisson_mesh_pt;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> private :</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Pointer to preconditioners/inexact solver</span></div>
<div class="line"><span class="comment">  /// for (0,0) block</span></div>
<div class="line"><span class="comment"></span>  Preconditioner* First_subsidiary_preconditioner_pt;</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Pointer to preconditioners/inexact solver</span></div>
<div class="line"><span class="comment">  /// for (1,1) block</span></div>
<div class="line"><span class="comment"></span>  Preconditioner* Second_subsidiary_preconditioner_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Pointer to mesh with preconditionable elements used</span></div>
<div class="line"><span class="comment">  /// for classification of dof types.  </span></div>
<div class="line"><span class="comment"></span>  Mesh* Multi_poisson_mesh_pt; </div>
<div class="line"> };</div>
</div><!-- fragment --> <h3><a class="anchor" id="two_plus_three_setup"></a>
The setup() function</h3>
<p>As usual, we start by freeing up any previously allocated memory, and set the pointer to the mesh:</p>
<div class="fragment"><div class="line"> <span class="comment">//====================start_of_setup_for_two_plus_three=======================</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// The setup function.</span></div>
<div class="line"><span class="comment"></span> <span class="comment">//============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> TwoPlusThree&lt;MATRIX&gt;::setup()</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// Clean up memory.</span></div>
<div class="line">  this-&gt;clean_up_my_memory();</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line">  <span class="keywordflow">if</span> (Multi_poisson_mesh_pt == 0)</div>
<div class="line">   {</div>
<div class="line">    std::stringstream err;</div>
<div class="line">    err &lt;&lt; <span class="stringliteral">&quot;Please set pointer to mesh using set_multi_poisson_mesh(...).\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">throw</span> OomphLibError(err.str(),</div>
<div class="line">                        OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                        OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">   }</div>
<div class="line"><span class="preprocessor">#endif </span></div>
<div class="line">  </div>
<div class="line">  <span class="comment">// The preconditioner works with one mesh; set it!</span></div>
<div class="line">  this-&gt;set_nmesh(1);</div>
<div class="line">  this-&gt;set_mesh(0,Multi_poisson_mesh_pt);</div>
</div><!-- fragment --><p>Since this preconditioner assumes explicitly that the problem involves five dof types we check that this is actually the case.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">// How many dof types do we have?</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> n_dof_types = this-&gt;ndof_types();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line">  <span class="comment">// This preconditioner only works for 5 dof types</span></div>
<div class="line">  <span class="keywordflow">if</span> (n_dof_types!=5)</div>
<div class="line">   {</div>
<div class="line">    std::stringstream tmp;</div>
<div class="line">    tmp &lt;&lt; <span class="stringliteral">&quot;This preconditioner only works for problems with 5 dof types\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;Yours has &quot;</span> &lt;&lt; n_dof_types;</div>
<div class="line">    <span class="keywordflow">throw</span> OomphLibError(tmp.str(),</div>
<div class="line">                        OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                        OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">   }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> To indicate that several dof types are to be combined into single blocks, we specify the mapping between dof types and block types as an argument to the <code>block_setup(...)</code> function This is done by creating vector of length <code>ndof_type()</code> in which each entry indicates the block that the corresponding dof is supposed to end up in:</p>
<div class="fragment"><div class="line">  <span class="comment">// Combine into two blocks, one containing dof types 0 and 1, the</span></div>
<div class="line">  <span class="comment">// final one dof types 2-4. In general we want:</span></div>
<div class="line">  <span class="comment">// dof_to_block_map[dof_type] = block type</span></div>
<div class="line">  Vector&lt;unsigned&gt; dof_to_block_map(n_dof_types);</div>
<div class="line">  dof_to_block_map[0]=0;</div>
<div class="line">  dof_to_block_map[1]=0;</div>
<div class="line">  dof_to_block_map[2]=1;</div>
<div class="line">  dof_to_block_map[3]=1;</div>
<div class="line">  dof_to_block_map[4]=1;</div>
<div class="line">  this-&gt;block_setup(dof_to_block_map);</div>
</div><!-- fragment --><p> To show that this actually worked, we output the number of blocks (which should be &ndash; and indeed is &ndash; equal to two).</p>
<div class="fragment"><div class="line">  <span class="comment">// Show that it worked ok:</span></div>
<div class="line">  oomph_info &lt;&lt; <span class="stringliteral">&quot;Preconditioner has &quot;</span> </div>
<div class="line">             &lt;&lt; this-&gt;nblock_types() &lt;&lt; <span class="stringliteral">&quot; block types\n&quot;</span>;</div>
</div><!-- fragment --><p> Next we create the two subsidiary preconditioners and call their <code>setup(...)</code> functions, passing the two diagonal blocks <img class="formulaInl" alt="${\bf B}_{11} $" src="form_76.png" width="21" height="13"/> and <img class="formulaInl" alt="${\bf B}_{22} $" src="form_77.png" width="21" height="13"/> to them.</p>
<div class="fragment"><div class="line">  <span class="comment">// Create the subsidiary preconditioners</span></div>
<div class="line">  First_subsidiary_preconditioner_pt= <span class="keyword">new</span> SuperLUPreconditioner;</div>
<div class="line">  Second_subsidiary_preconditioner_pt= <span class="keyword">new</span> SuperLUPreconditioner;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Set diagonal solvers/preconditioners; put in own scope</span></div>
<div class="line">  <span class="comment">// so variable block goes out of scope</span></div>
<div class="line">  {</div>
<div class="line">   CRDoubleMatrix block;</div>
<div class="line">   this-&gt;get_block(0,0,block);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set up preconditioner (i.e. lu-decompose the block)</span></div>
<div class="line">   First_subsidiary_preconditioner_pt-&gt;setup(&amp;block);</div>
<div class="line">  }</div>
<div class="line">  {</div>
<div class="line">   CRDoubleMatrix block;</div>
<div class="line">   this-&gt;get_block(1,1,block);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Set up preconditioner (i.e. lu-decompose the block)</span></div>
<div class="line">   Second_subsidiary_preconditioner_pt-&gt;setup(&amp;block);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> } <span class="comment">// End of setup</span></div>
</div><!-- fragment --> <h3><a class="anchor" id="two_plus_three_solve"></a>
The preconditioner_solve() function</h3>
<p>The <code>preconditioner_solve(...)</code> function is equivalent to that in the <code>Diagonal</code> preconditioner discussed above, though here it simply acts on a 2x2 block system.</p>
<div class="fragment"><div class="line"> <span class="comment">//=============================================================================</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// Preconditioner solve for the two plus three diagonal preconditioner: </span></div>
<div class="line"><span class="comment"> /// Apply preconditioner to r and return z, so that P r = z, where</span></div>
<div class="line"><span class="comment"> /// P is the block diagonal matrix constructed from the original </span></div>
<div class="line"><span class="comment"> /// linear system.</span></div>
<div class="line"><span class="comment"></span> <span class="comment">//=============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> TwoPlusThree&lt;MATRIX&gt;::</div>
<div class="line"> preconditioner_solve(<span class="keyword">const</span> DoubleVector&amp; r, DoubleVector&amp; z)</div>
<div class="line"> {   </div>
<div class="line">  <span class="comment">// Get number of blocks</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> n_block = this-&gt;nblock_types();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Split up rhs vector into sub-vectors, arranged to match the matrix blocks.</span></div>
<div class="line">  Vector&lt;DoubleVector&gt; block_r;</div>
<div class="line">  this-&gt;get_block_vectors(r,block_r);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create storage for solution of block solves</span></div>
<div class="line">  Vector&lt;DoubleVector&gt; block_z(n_block);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Solve (0,0) diagonal block system</span></div>
<div class="line">  First_subsidiary_preconditioner_pt-&gt;preconditioner_solve(block_r[0],</div>
<div class="line">                                                           block_z[0]);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Solve (1,1) diagonal block system</span></div>
<div class="line">  Second_subsidiary_preconditioner_pt-&gt;preconditioner_solve(block_r[1],</div>
<div class="line">                                                            block_z[1]);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Copy solution in block vectors block_z back to z</span></div>
<div class="line">  this-&gt;return_block_vectors(block_z,z);</div>
<div class="line"> }</div>
</div><!-- fragment --> <h3><a class="anchor" id="two_plus_three_clean"></a>
The clean_up_my_memory() function</h3>
<p>This function again deletes the allocated storage &ndash; here the subsidiary preconditioners.</p>
<div class="fragment"><div class="line"> <span class="comment">//====================start_of_clean_up_for_two_plus_three====================</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// The clean up function.</span></div>
<div class="line"><span class="comment"></span> <span class="comment">//============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> TwoPlusThree&lt;MATRIX&gt;::clean_up_my_memory()</div>
<div class="line"> {     </div>
<div class="line">  <span class="comment">//Clean up subsidiary preconditioners.</span></div>
<div class="line">  <span class="keywordflow">if</span>(First_subsidiary_preconditioner_pt!=0)</div>
<div class="line">   {</div>
<div class="line">    <span class="keyword">delete</span> First_subsidiary_preconditioner_pt;</div>
<div class="line">    First_subsidiary_preconditioner_pt = 0;</div>
<div class="line">   }</div>
<div class="line">  <span class="keywordflow">if</span>(Second_subsidiary_preconditioner_pt!=0)</div>
<div class="line">   {</div>
<div class="line">    <span class="keyword">delete</span> Second_subsidiary_preconditioner_pt;</div>
<div class="line">    Second_subsidiary_preconditioner_pt = 0;</div>
<div class="line">   }</div>
<div class="line"> } <span class="comment">// End of clean_up_my_memory function.</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h2><a class="anchor" id="two_plus_three_upper_triangular"></a>
Combining multiple dof types into compound blocks. Part 2: How to deal with off-diagonal blocks</h2>
<p>NEW FEATURES: How to set up matrix vector products when multiple dof types have been combined into compound blocks</p>
<h3><a class="anchor" id="two_plus_three_upper_triangular_theory"></a>
Theory</h3>
<p>The extension of the preconditioner introduced in the previous section to block-triangular form is straightforward: We use the same dof-to-block mapping as before but now retain the off-diagonal block <img class="formulaInl" alt="$ B_{12} $" src="form_78.png" width="19" height="13"/> so that the preconditioner has the structure: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hspace{3cm} {\bf P} = \left( \begin{array}{cc|ccc} J_{11} &amp; J_{12} &amp; J_{13} &amp; J_{14} &amp; J_{15} \\ J_{21} &amp; J_{22} &amp; J_{13} &amp; J_{14} &amp; J_{15} \\ \hline &amp; &amp; J_{33} &amp; J_{34} &amp; J_{35} \\ &amp; &amp; J_{43} &amp; J_{44} &amp; J_{45} \\ &amp; &amp; J_{53} &amp; J_{54} &amp; J_{55} \\ \end{array} \right) = \left( \begin{array}{c|c} B_{11} &amp; B_{12}\\ \hline &amp; B_{22} \\ \end{array} \right). \hspace{3cm} (10) \]" src="form_79.png" width="431" height="76"/>
</p>
<p>In the FSI context where <img class="formulaInl" alt="$ B_{11} $" src="form_62.png" width="19" height="13"/> and <img class="formulaInl" alt="$ B_{22} $" src="form_63.png" width="19" height="13"/> represent the solid and fluid sub-blocks, respectively, the inclusion of the off-diagonal block <img class="formulaInl" alt="$ B_{12} $" src="form_78.png" width="19" height="13"/> incorporates the effect of fluid dofs (via pressure and shear stress) onto the solid equations. Since this captures "more of the physics" the preconditioner can be expected to be better than its block diagonal counterpart.</p>
<p>The application of the preconditioner (i.e. the solution of the linear system <img class="formulaInl" alt="${\bf P} {\bf y} ={\bf z}$" src="form_44.png" width="41" height="13"/> for <img class="formulaInl" alt="${\bf y}$" src="form_37.png" width="9" height="9"/>) requires the solution of the two smaller linear systems </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \ \ \ \ \ \left( \begin{array}{cc} J_{11} &amp; J_{12} \\ J_{21} &amp; J_{22} \\ \end{array} \right) \left( \begin{array}{c} y_1 \\ y_2 \\ \end{array} \right) = \left( \begin{array}{c} z_1 \\ z_2 \\ \end{array} \right) - \left( \begin{array}{ccc} J_{13} &amp; J_{14} &amp; J_{15} \\ J_{23} &amp; J_{24} &amp; J_{25} \\ \end{array} \right) \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) \mbox{\ \ \ \ \ \ \ \ \ or \ \ \ \ \ \ \ \ } B_{11} Y_1 = Z_1 - B_{12} Y_2 \hspace{3cm} (11) \]" src="form_80.png" width="539" height="46"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \left( \begin{array}{ccc} J_{33} &amp; J_{34} &amp; J_{35} \\ J_{43} &amp; J_{44} &amp; J_{45} \\ J_{53} &amp; J_{54} &amp; J_{55} \\ \end{array} \right) \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) = \left( \begin{array}{c} z_3 \\ z_4 \\ z_5 \\ \end{array} \right) \mbox{\ \ \ \ \ \ \ \ \ or \ \ \ \ \ \ \ \ } B_{22} Y_2 = Z_2. \hspace{3cm} (12) \]" src="form_81.png" width="374" height="46"/>
</p>
<h3><a class="anchor" id="two_plus_three_upper_triangular_implementation"></a>
Implementation as a BlockPreconditioner</h3>
<p>The implementation is very similar to that in the previous example &ndash; we simply provide additional storage for the (single) matrix vector product operator required for the multiplication with <img class="formulaInl" alt="$ B_{12} $" src="form_78.png" width="19" height="13"/> when updating the right-hand-side in equation (11).</p>
<div class="fragment"><div class="line"><span class="comment">//=================start_of_two_plus_three_upper_triangular_class==============</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// Upper triangular two plus three triangular preconditioner for a </span></div>
<div class="line"><span class="comment">/// system with  5 dof types.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keyword">class </span>TwoPlusThreeUpperTriangular </div>
<div class="line">  : <span class="keyword">public</span> BlockPreconditioner&lt;MATRIX&gt;</div>
<div class="line"> {</div>
<div class="line"> </div>
<div class="line"> public :</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Constructor.</span></div>
<div class="line"><span class="comment"></span>  TwoPlusThreeUpperTriangular()  :</div>
<div class="line">   BlockPreconditioner&lt;MATRIX&gt;(),</div>
<div class="line">    Off_diagonal_matrix_vector_product_pt(0),</div>
<div class="line">    First_subsidiary_preconditioner_pt(0),</div>
<div class="line">    Second_subsidiary_preconditioner_pt(0)</div>
<div class="line">   { </div>
<div class="line">    Multi_poisson_mesh_pt=0;</div>
<div class="line">   }</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Destructor - delete the preconditioner matrices</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> ~TwoPlusThreeUpperTriangular()</div>
<div class="line">   {</div>
<div class="line">    this-&gt;clean_up_my_memory();</div>
<div class="line">   }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// clean up the memory</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> clean_up_my_memory();</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Broken copy constructor</span></div>
<div class="line"><span class="comment"></span>  TwoPlusThreeUpperTriangular(<span class="keyword">const</span> TwoPlusThreeUpperTriangular&amp;) </div>
<div class="line">   { </div>
<div class="line">    BrokenCopy::broken_copy(<span class="stringliteral">&quot;TwoPlusThreeUpperTriangular&quot;</span>);</div>
<div class="line">   } </div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Broken assignment operator</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> TwoPlusThreeUpperTriangular&amp;) </div>
<div class="line">   {</div>
<div class="line">    BrokenCopy::broken_assign(<span class="stringliteral">&quot;TwoPlusThreeUpperTriangular&quot;</span>);</div>
<div class="line">   }</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Apply preconditioner to r</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> preconditioner_solve(<span class="keyword">const</span> DoubleVector &amp;r, DoubleVector &amp;z);</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Setup the preconditioner </span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> setup();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Use the version in the Preconditioner base class for the alternative</span></div>
<div class="line">  <span class="comment">// setup function that takes a matrix pointer as an argument.</span></div>
<div class="line">  <span class="keyword">using</span> Preconditioner::setup;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Specify the mesh that contains multi-poisson elements</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> set_multi_poisson_mesh(Mesh* multi_poisson_mesh_pt)</div>
<div class="line">  {</div>
<div class="line">   Multi_poisson_mesh_pt=multi_poisson_mesh_pt;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:  </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Pointer to matrix vector product operator for the single off diagonals</span></div>
<div class="line"><span class="comment"></span>  MatrixVectorProduct* Off_diagonal_matrix_vector_product_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Pointer to preconditioners/inexact solver</span></div>
<div class="line"><span class="comment">  /// for (0,0) block</span></div>
<div class="line"><span class="comment"></span>  Preconditioner* First_subsidiary_preconditioner_pt;</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Pointer to preconditioners/inexact solver</span></div>
<div class="line"><span class="comment">  /// for (1,1) block</span></div>
<div class="line"><span class="comment"></span>  Preconditioner* Second_subsidiary_preconditioner_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Pointer to mesh with preconditionable elements used</span></div>
<div class="line"><span class="comment">  /// for classification of dof types.</span></div>
<div class="line"><span class="comment"></span>  Mesh* Multi_poisson_mesh_pt;</div>
<div class="line"> </div>
<div class="line"> };</div>
</div><!-- fragment --> <h3><a class="anchor" id="two_plus_three_upper_triangular_setup"></a>
The setup() function</h3>
<p>As before, we start by freeing up any previously allocated memory and set the pointer to the mesh,</p>
<div class="fragment"><div class="line"> <span class="comment">//==============start_of_setup_for_two_plus_three_upper_triangular_class=======</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// The setup function.</span></div>
<div class="line"><span class="comment"></span> <span class="comment">//============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> TwoPlusThreeUpperTriangular&lt;MATRIX&gt;::setup()</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// clean the memory</span></div>
<div class="line">  this-&gt;clean_up_my_memory();</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line">  <span class="keywordflow">if</span> (Multi_poisson_mesh_pt == 0)</div>
<div class="line">   {</div>
<div class="line">    std::stringstream err;</div>
<div class="line">    err &lt;&lt; <span class="stringliteral">&quot;Please set pointer to mesh using set_multi_poisson_mesh(...).\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">throw</span> OomphLibError(err.str(),</div>
<div class="line">                        OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                        OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">   }</div>
<div class="line"><span class="preprocessor">#endif </span></div>
<div class="line">  </div>
<div class="line">  <span class="comment">// The preconditioner works with one mesh; set it!</span></div>
<div class="line">  this-&gt;set_nmesh(1);</div>
<div class="line">  this-&gt;set_mesh(0,Multi_poisson_mesh_pt);</div>
</div><!-- fragment --><p> and check that the number of dof types is correct. </p><div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">// Get number of degrees of freedom.</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> n_dof_types = this-&gt;ndof_types();</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line">  <span class="comment">// This preconditioner only works for 5 dof types</span></div>
<div class="line">  <span class="keywordflow">if</span> (n_dof_types!=5)</div>
<div class="line">   {</div>
<div class="line">    std::stringstream tmp;</div>
<div class="line">    tmp &lt;&lt; <span class="stringliteral">&quot;This preconditioner only works for problems with 5 dof types\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;Yours has &quot;</span> &lt;&lt; n_dof_types;</div>
<div class="line">    <span class="keywordflow">throw</span> OomphLibError(tmp.str(),</div>
<div class="line">                        OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                        OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">   }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> The block setup is again performed with a dof-to-block mapping that results in a block preconditioner with 2x2 blocks.</p>
<div class="fragment"><div class="line">  <span class="comment">// Combine into two major blocks, one containing dof types 0 and 1, the</span></div>
<div class="line">  <span class="comment">// final one dof types 2-4. In general we want</span></div>
<div class="line">  <span class="comment">// dof_to_block_map[dof_type] = block_type</span></div>
<div class="line">  Vector&lt;unsigned&gt; dof_to_block_map(n_dof_types);</div>
<div class="line">  dof_to_block_map[0]=0;</div>
<div class="line">  dof_to_block_map[1]=0;</div>
<div class="line">  dof_to_block_map[2]=1;</div>
<div class="line">  dof_to_block_map[3]=1;</div>
<div class="line">  dof_to_block_map[4]=1;</div>
<div class="line">  this-&gt;block_setup(dof_to_block_map);</div>
</div><!-- fragment --><p> We create the two subsidiary preconditioners and pass the two diagonal blocks <img class="formulaInl" alt="$ B_{11} $" src="form_62.png" width="19" height="13"/> and <img class="formulaInl" alt="$ B_{22} $" src="form_63.png" width="19" height="13"/> to their <code>setup()</code> functions. As before, the deep copies of these matrices are then allowed to go out of scope, freeing up the memory, since the subsidiary preconditioners retain whatever information they require.</p>
<div class="fragment"><div class="line">  <span class="comment">// Create the subsidiary preconditioners</span></div>
<div class="line">  First_subsidiary_preconditioner_pt= <span class="keyword">new</span> SuperLUPreconditioner;</div>
<div class="line">  Second_subsidiary_preconditioner_pt= <span class="keyword">new</span> SuperLUPreconditioner;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set diagonal solvers/preconditioners; put in own scope</span></div>
<div class="line">  <span class="comment">// so block goes out of scope</span></div>
<div class="line">  {</div>
<div class="line"> </div>
<div class="line">   CRDoubleMatrix block;</div>
<div class="line">   this-&gt;get_block(0,0,block);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Set up preconditioner (i.e. lu-decompose the block)</span></div>
<div class="line">   First_subsidiary_preconditioner_pt-&gt;setup(&amp;block);</div>
<div class="line"> </div>
<div class="line">  }</div>
<div class="line">  {</div>
<div class="line"> </div>
<div class="line">   CRDoubleMatrix block;</div>
<div class="line">   this-&gt;get_block(1,1,block);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Set up preconditioner (i.e. lu-decompose the block)</span></div>
<div class="line">   Second_subsidiary_preconditioner_pt-&gt;setup(&amp;block);</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// end setup of last subsidiary preconditioner</span></div>
</div><!-- fragment --><p> Finally we create and set up the off-diagonal vector product. Note that the block column index refers to the block enumeration, so the block column index of <img class="formulaInl" alt="$ B_{12} $" src="form_78.png" width="19" height="13"/> is 1 (in a C++ zero-based enumeration!).</p>
<div class="fragment"><div class="line">  <span class="comment">// next setup the off diagonal mat vec operators</span></div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Get the block</span></div>
<div class="line">   CRDoubleMatrix block_matrix = this-&gt;get_block(0,1);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Create matrix vector product</span></div>
<div class="line">   Off_diagonal_matrix_vector_product_pt = <span class="keyword">new</span> MatrixVectorProduct;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set it up -- note that the block column index refers to the</span></div>
<div class="line">   <span class="comment">// block enumeration (not the dof enumeration)</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> block_column_index=1;</div>
<div class="line">   this-&gt;setup_matrix_vector_product(</div>
<div class="line">    Off_diagonal_matrix_vector_product_pt,&amp;block_matrix,block_column_index);</div>
<div class="line">  }</div>
</div><!-- fragment --><h3><a class="anchor" id="two_plus_three_upper_triangular_solve"></a>
The preconditioner_solve() function</h3>
<p>The application of the preconditioner is the exact equivalent of that of the general-purpose block triangular preconditioner discussed above, restricted to a 2x2 system:</p>
<div class="fragment"><div class="line"> <span class="comment">//=============================================================================</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// Preconditioner solve for the two plus three upper block triangular </span></div>
<div class="line"><span class="comment"> /// preconditioner: </span></div>
<div class="line"><span class="comment"> /// Apply preconditioner to r and return z, so that P z = r, where</span></div>
<div class="line"><span class="comment"> /// P is the block diagonal matrix constructed from the original </span></div>
<div class="line"><span class="comment"> /// linear system.</span></div>
<div class="line"><span class="comment"></span> <span class="comment">//=============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> TwoPlusThreeUpperTriangular&lt;MATRIX&gt;::</div>
<div class="line"> preconditioner_solve(<span class="keyword">const</span> DoubleVector&amp; r, DoubleVector&amp; z)</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// Get number of blocks</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> n_block = this-&gt;nblock_types();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Split up rhs vector into sub-vectors, rarranged to match the matrix blocks.</span></div>
<div class="line">  Vector&lt;DoubleVector&gt; block_r;</div>
<div class="line">  this-&gt;get_block_vectors(r,block_r);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create storage for solution of block solves</span></div>
<div class="line">  Vector&lt;DoubleVector&gt; block_z(n_block);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Solve (1,1) diagonal block system</span></div>
<div class="line">  Second_subsidiary_preconditioner_pt-&gt;preconditioner_solve(block_r[1],</div>
<div class="line">                                                            block_z[1]);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Solve (0,1) off diagonal.</span></div>
<div class="line">  <span class="comment">// Substitute</span></div>
<div class="line">  DoubleVector temp;</div>
<div class="line">  Off_diagonal_matrix_vector_product_pt-&gt;multiply(block_z[1],temp);</div>
<div class="line">  block_r[0] -= temp;   </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Solve (0,0) diagonal block system</span></div>
<div class="line">  First_subsidiary_preconditioner_pt-&gt;preconditioner_solve(block_r[0],</div>
<div class="line">                                                           block_z[0]); </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Copy solution in block vectors block_z back to z</span></div>
<div class="line">  this-&gt;return_block_vectors(block_z,z);</div>
<div class="line"> }</div>
</div><!-- fragment --> <h3><a class="anchor" id="two_plus_three_upper_triangular_clean"></a>
The clean_up_my_memory() function</h3>
<p>As before, this function frees up any memory that has been allocated in the <code>setup()</code> function.</p>
<div class="fragment"><div class="line"> <span class="comment">//===========start_of_clean_up_for_two_plus_three_upper_triangular_class======</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// The clean up function.</span></div>
<div class="line"><span class="comment"></span> <span class="comment">//============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> TwoPlusThreeUpperTriangular&lt;MATRIX&gt;::clean_up_my_memory()</div>
<div class="line"> {     </div>
<div class="line">  <span class="comment">// Delete of diagonal matrix vector product</span></div>
<div class="line">  <span class="keywordflow">if</span> (Off_diagonal_matrix_vector_product_pt != 0)</div>
<div class="line">   {</div>
<div class="line">    <span class="keyword">delete</span> Off_diagonal_matrix_vector_product_pt;</div>
<div class="line">    Off_diagonal_matrix_vector_product_pt = 0;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Clean up subsidiary preconditioners.</span></div>
<div class="line">  <span class="keywordflow">if</span>(First_subsidiary_preconditioner_pt!=0)</div>
<div class="line">   {</div>
<div class="line">    <span class="keyword">delete</span> First_subsidiary_preconditioner_pt;</div>
<div class="line">    First_subsidiary_preconditioner_pt = 0;</div>
<div class="line">   }</div>
<div class="line">  <span class="keywordflow">if</span>(Second_subsidiary_preconditioner_pt!=0)</div>
<div class="line">   {</div>
<div class="line">    <span class="keyword">delete</span> Second_subsidiary_preconditioner_pt;</div>
<div class="line">    Second_subsidiary_preconditioner_pt = 0;</div>
<div class="line">   }</div>
<div class="line"> } <span class="comment">// End of clean_up_my_memory function.</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h2><a class="anchor" id="two_plus_three_upper_triangular_with_sub"></a>
Using subsidiary block preconditioners</h2>
<p>NEW FEATURES: How to use subsidiary block preconditioners to (approximately) solve linear systems constructed from subsets of dof-blocks.</p>
<h3><a class="anchor" id="two_plus_three_upper_triangular_with_sub_theory"></a>
Theory</h3>
<p>The two previous examples were motivated by the observation that in multi-physics problems (such as fluid-structure interaction) it is natural to combine "related" dof blocks into compound block matrices. We showed that the block preconditioning framework makes it easy to extract such matrices from the original system matrix and demonstrated how to solve linear systems involving these matrices with separate subsidiary preconditioners. <br  />
 One problem with this approach is that, once a compound matrix has been created (by the <code>get_block(...)</code> function), all information about its dof types is lost, making it impossible to employ block preconditioners as subsidiary preconditioners.</p>
<p>We will now revisit the 2x2 block triangular preconditioner described in the previous example and demonstrate how to employ subsidiary block preconditioners to (approximately) solve linear systems involving matrices formed (formally) by compound matrices that are constructed from multiple dof-level blocks. From a mathematical point of view, the structure of the preconditioner therefore remains unchanged and is given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hspace{3cm} {\bf P} = \left( \begin{array}{cc|ccc} J_{11} &amp; J_{12} &amp; J_{13} &amp; J_{14} &amp; J_{15} \\ J_{21} &amp; J_{22} &amp; J_{13} &amp; J_{14} &amp; J_{15} \\ \hline &amp; &amp; J_{33} &amp; J_{34} &amp; J_{35} \\ &amp; &amp; J_{43} &amp; J_{44} &amp; J_{45} \\ &amp; &amp; J_{53} &amp; J_{54} &amp; J_{55} \\ \end{array} \right)= \left( \begin{array}{c|c} B_{11} &amp; B_{12}\\ \hline &amp; B_{22} \\ \end{array} \right). \hspace{3cm} (13) \]" src="form_82.png" width="431" height="76"/>
</p>
<p> We will continue to use a dof-to-block mapping to view this as the 2x2 block matrix shown on the right. This makes it easy to extract the compound off-diagonal block <img class="formulaInl" alt="$ B_{12} $" src="form_78.png" width="19" height="13"/> from the system matrix when setting up the matrix-vector product (as before). The setup of the subsidiary block preconditioners used to (approximately) solve the linear systems involving <img class="formulaInl" alt="$ B_{11} $" src="form_62.png" width="19" height="13"/> and <img class="formulaInl" alt="$ B_{22}$" src="form_69.png" width="19" height="13"/> is handled differently:</p><ul>
<li>When calling the subsidiary block preconditioner's <code>setup(...)</code> function we pass a pointer to the entire system matrix, i.e. the matrix containing, formally, all the dof-level blocks in equation (3).</li>
</ul>
<ul>
<li>We then turn the preconditioner into a subsidiary block preconditioner, using its member function <code>turn_into_subsidiary_block_preconditioner(...)</code> whose arguments specify which of the dof-level blocks in the current (master) preconditioner are to be used by the subsidiary block preconditioner.</li>
</ul>
<p>The subsidiary block preconditioner is thus given access to all the information required to extract the relevant data directly from the original system matrix (and any associated full-length vectors). It is in fact a key design principle of the block preconditioning framework that <b>subsidiary block preconditioners are given access to the "full size" matrices and vectors, but only operate on the subset of data that they are "in charge of".</b></p>
<p>When employing subsidiary block preconditioners for the approximate solution of the two smaller linear systems </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{array}{c} \underbrace{ \left( \begin{array}{cc} J_{11} &amp; J_{12} \\ J_{21} &amp; J_{22} \\ \end{array} \right) }_{B_{11}} \underbrace{ \left( \begin{array}{c} y_1 \\ y_2 \\ \end{array} \right) }_{Y_{1}} = \underbrace{ \left( \begin{array}{c} z_1 \\ z_2 \\ \end{array} \right) }_{{\bf Z}_1} - \underbrace{ \left( \begin{array}{ccc} J_{13} &amp; J_{14} &amp; J_{15} \\ J_{23} &amp; J_{24} &amp; J_{25} \\ \end{array} \right) }_{B_{12}} \underbrace{ \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) }_{{\bf Y}_2} \\ \hspace{3cm} (14) \\ \underbrace{ \left( \begin{array}{ccc} J_{33} &amp; J_{34} &amp; J_{35} \\ J_{43} &amp; J_{44} &amp; J_{45} \\ J_{53} &amp; J_{54} &amp; J_{55} \\ \end{array} \right) }_{B_{22}} \underbrace{ \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) }_{{\bf Y}_2} = \underbrace{ \left( \begin{array}{c} z_3 \\ z_4 \\ z_5 \\ \end{array} \right) }_{{\bf Z}_2}, \end{array} \]" src="form_83.png" width="354" height="144"/>
</p>
<p> the subsidiary preconditioners that operate on the linear systems involving <img class="formulaInl" alt="$ B_{11} $" src="form_62.png" width="19" height="13"/> and <img class="formulaInl" alt="$ B_{22} $" src="form_63.png" width="19" height="13"/> therefore retain access to the relevant dof-level blocks. Hence, if we employ the block triangular preconditioner discussed above to (approximately) solve the two linear systems in equation (14), the complete preconditioning operation is described by the following equations: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{array}{c} \left( \begin{array}{cc} J_{11} &amp; J_{12} \\ &amp; J_{22} \\ \end{array} \right) \left( \begin{array}{c} y_1 \\ y_2 \\ \end{array} \right) = \underbrace{ \underbrace{ \left( \begin{array}{c} z_1 \\ z_2 \\ \end{array} \right) }_{{\bf Z}_1} - \underbrace{ \left( \begin{array}{ccc} J_{13} &amp; J_{14} &amp; J_{15} \\ J_{23} &amp; J_{24} &amp; J_{25} \\ \end{array} \right) }_{B_{12}} \underbrace{ \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) }_{{\bf Y}_2} }_{\widehat{\bf Z}_1} \\ \left( \begin{array}{ccc} J_{33} &amp; J_{34} &amp; J_{35} \\ &amp; J_{44} &amp; J_{45} \\ &amp; &amp; J_{55} \\ \end{array} \right) \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) = \left( \begin{array}{c} z_3 \\ z_4 \\ z_5 \\ \end{array} \right). \end{array} \]" src="form_84.png" width="350" height="134"/>
</p>
<p> Note that when we wrote the block triangular preconditioner we did not have to be aware of the fact that it may subsequently be used as a subsidiary block preconditioner. The internal data structures implemented in the <code>BlockPreconditioner</code> base class ensure that when we call <code>get_block(0,0,block_matrix)</code> in the subsidiary block preconditioner acting on <img class="formulaInl" alt="$ B_{22} $" src="form_63.png" width="19" height="13"/>, <code>block_matrix</code> will receive a deep copy of <img class="formulaInl" alt="$ J_{33} $" src="form_85.png" width="16" height="13"/>, extracted from the full system matrix. Similarly, a call to <code>get_block_vectors(r,block_r)</code> will extract the three block vectors <img class="formulaInl" alt="$ {\bf r}_3, {\bf r}_4 $" src="form_86.png" width="29" height="9"/> and <img class="formulaInl" alt="${\bf r}_5 $" src="form_87.png" width="11" height="9"/> from the full-length vector <img class="formulaInl" alt="$ {\bf r} $" src="form_88.png" width="8" height="6"/>, while <code>return_block_vectors(block_z,z)</code> will return the three solution vectors <img class="formulaInl" alt="$ {\bf z_3}, {\bf z_4} $" src="form_89.png" width="31" height="9"/> and <img class="formulaInl" alt="$ {\bf z_5} $" src="form_90.png" width="13" height="9"/> to the appropriate entries in the full-length vector <img class="formulaInl" alt="$ {\bf z}. $" src="form_91.png" width="10" height="6"/></p>
<p>The implementation of the preconditioning operations can again be subdivided into two distinct <code>setup()</code> and <code>preconditioner_solve(...)</code> phases.</p><ul>
<li>Set up the data structures/lookup tables that map dof types 0 and 1 to block 0 and dof types 2, 3 and 4 to block 1 [by calling the <code>BlockPreconditioner::block_setup(...)</code> function with arguments that specify the mapping between "dof types" and "block types" as before].</li>
<li>Create two instances of the block triangular preconditioner (or any other block preconditioner) and turn them into the subsidiary preconditioners for the current (master) preconditioner, specifying which dof types in the master preconditioner the subsidiary block preconditioners are to work with.</li>
<li>Extract the compound off-diagonal block <img class="formulaInl" alt="$ B_{12}$" src="form_92.png" width="19" height="13"/> and create a <code>MatrixVectorProduct</code> operator.</li>
</ul>
<p>Once the <code>setup()</code> phase has been completed, the solution of the linear system <img class="formulaInl" alt="${\bf P} {\bf y} = {\bf z}$" src="form_51.png" width="41" height="13"/> by the <code>preconditioner_solve(...)</code> function involves the following steps:</p><ul>
<li>Solve the linear systems <img class="formulaInl" alt="$ {\bf B}_{22} \ {\bf Y}_2 = {\bf Z}_2$" src="form_93.png" width="73" height="13"/> using the subsidiary block preconditioner that works with <img class="formulaInl" alt="$ {\bf B}_{22} $" src="form_94.png" width="21" height="13"/>. [The subsidiary block preconditioner's <code>preconditioner_solve(...)</code> function is given access to the full-size vectors <img class="formulaInl" alt="$ {\bf z} $" src="form_95.png" width="8" height="6"/> and <img class="formulaInl" alt="$ {\bf y} $" src="form_96.png" width="9" height="9"/> and extracts/returns <img class="formulaInl" alt="$ {\bf Z}_2 $" src="form_97.png" width="14" height="13"/> and <img class="formulaInl" alt="$ {\bf Y}_2$" src="form_98.png" width="16" height="13"/> directly from/into these.]</li>
<li>Extract the solution vector <img class="formulaInl" alt="$ {\bf Y}_2 $" src="form_99.png" width="16" height="13"/> from the just undated full-length vector <img class="formulaInl" alt="$ {\bf y} $" src="form_96.png" width="9" height="9"/>, perform the matrix vector product with <img class="formulaInl" alt="$ B_{12} $" src="form_78.png" width="19" height="13"/> and store the result in a temporary vector <img class="formulaInl" alt="$ {\bf t} $" src="form_100.png" width="6" height="9"/>.</li>
<li>Extract the block vector <img class="formulaInl" alt="$ {\bf Z}_1$" src="form_101.png" width="13" height="13"/> from the full-length vector <img class="formulaInl" alt="$ {\bf z} $" src="form_95.png" width="8" height="6"/>, subtract <img class="formulaInl" alt="$ {\bf t} $" src="form_100.png" width="6" height="9"/> from it, and return the result, <img class="formulaInl" alt="$ \widehat{\bf Z}_1 = {\bf Z}_1 - B_{12} {\bf Z}_2 $" src="form_102.png" width="94" height="16"/> into the appropriate entries into the full-length vector <img class="formulaInl" alt="$ {\bf z} $" src="form_95.png" width="8" height="6"/>.</li>
<li>Solve the linear systems <img class="formulaInl" alt="$ {\bf B}_{11} \ {\bf Y}_1 = \widehat{\bf Z}_1 = {\bf Z}_1 - B_{12} {\bf Z}_2 $" src="form_103.png" width="153" height="16"/> using the subsidiary block preconditioner that works with <img class="formulaInl" alt="$ {\bf B}_{11} $" src="form_104.png" width="21" height="13"/>. [The subsidiary block preconditioner's <code>preconditioner_solve(...)</code> function is given access to the full-size vectors <img class="formulaInl" alt="$ {\bf z} $" src="form_95.png" width="8" height="6"/> and <img class="formulaInl" alt="$ {\bf y} $" src="form_96.png" width="9" height="9"/> and extracts/returns <img class="formulaInl" alt="$ \widehat{\bf Z}_1 $" src="form_105.png" width="13" height="16"/> and <img class="formulaInl" alt="$ {\bf Y}_1$" src="form_106.png" width="16" height="13"/> directly from/into these; recall that the relevant entries in <img class="formulaInl" alt="$ {\bf z}$" src="form_107.png" width="8" height="6"/> have been over-written in the previous step so that <img class="formulaInl" alt="$ \widehat{\bf Z}_1 $" src="form_105.png" width="13" height="16"/> contains the updated right hand side.]</li>
</ul>
<h3><a class="anchor" id="two_plus_three_upper_triangular_with_sub_implementation"></a>
Implementation as a BlockPreconditioner</h3>
<p>The implementation of the preconditioner is completely equivalent to the corresponding block triangular preconditioner considered in the previous example:</p>
<div class="fragment"><div class="line"><span class="comment">//=========start_of_two_plus_three_upper_triangular_with_sub_class=============</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// Upper block triangular with subsidiary block preconditioners </span></div>
<div class="line"><span class="comment">/// for a system with 5 dof types.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keyword">class </span>TwoPlusThreeUpperTriangularWithOneLevelSubsidiary </div>
<div class="line">  : <span class="keyword">public</span> BlockPreconditioner&lt;MATRIX&gt;</div>
<div class="line"> {</div>
<div class="line"> </div>
<div class="line"> public :</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Constructor.</span></div>
<div class="line"><span class="comment"></span>  TwoPlusThreeUpperTriangularWithOneLevelSubsidiary() :</div>
<div class="line">   BlockPreconditioner&lt;MATRIX&gt;(),</div>
<div class="line">    Off_diagonal_matrix_vector_product_pt(0),</div>
<div class="line">    First_subsidiary_preconditioner_pt(0),</div>
<div class="line">    Second_subsidiary_preconditioner_pt(0)</div>
<div class="line">   {</div>
<div class="line">    Multi_poisson_mesh_pt=0;</div>
<div class="line">   }</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Destructor - delete the preconditioner matrices</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> ~TwoPlusThreeUpperTriangularWithOneLevelSubsidiary()</div>
<div class="line">   {</div>
<div class="line">    this-&gt;clean_up_my_memory();</div>
<div class="line">   }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Clean up the memory</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> clean_up_my_memory();</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Broken copy constructor</span></div>
<div class="line"><span class="comment"></span>  TwoPlusThreeUpperTriangularWithOneLevelSubsidiary</div>
<div class="line">  (<span class="keyword">const</span> TwoPlusThreeUpperTriangularWithOneLevelSubsidiary&amp;) </div>
<div class="line">   { </div>
<div class="line">    BrokenCopy::broken_copy</div>
<div class="line">     (<span class="stringliteral">&quot;TwoPlusThreeUpperTriangularWithOneLevelSubsidiary&quot;</span>);</div>
<div class="line">   } </div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Broken assignment operator</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> </div>
<div class="line">                 TwoPlusThreeUpperTriangularWithOneLevelSubsidiary&amp;) </div>
<div class="line">   {</div>
<div class="line">    BrokenCopy::broken_assign(</div>
<div class="line">     <span class="stringliteral">&quot;TwoPlusThreeUpperTriangularWithOneLevelSubsidiary&quot;</span>);</div>
<div class="line">   }</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Apply preconditioner to r</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> preconditioner_solve(<span class="keyword">const</span> DoubleVector &amp;r, DoubleVector &amp;z);</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Setup the preconditioner </span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> setup();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Use the version in the Preconditioner base class for the alternative</span></div>
<div class="line">  <span class="comment">// setup function that takes a matrix pointer as an argument.</span></div>
<div class="line">  <span class="keyword">using</span> Preconditioner::setup;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Specify the mesh that contains multi-poisson elements</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> set_multi_poisson_mesh(Mesh* multi_poisson_mesh_pt)</div>
<div class="line">  {</div>
<div class="line">   Multi_poisson_mesh_pt=multi_poisson_mesh_pt;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:  </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Pointer to matrix vector product operators for the off diagonal block</span></div>
<div class="line"><span class="comment"></span>  MatrixVectorProduct* Off_diagonal_matrix_vector_product_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Pointer to preconditioners/inexact solver</span></div>
<div class="line"><span class="comment">  /// for (0,0) block</span></div>
<div class="line"><span class="comment"></span>  Preconditioner* First_subsidiary_preconditioner_pt;</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Pointer to preconditioners/inexact solver</span></div>
<div class="line"><span class="comment">  /// for (1,1) block</span></div>
<div class="line"><span class="comment"></span>  Preconditioner* Second_subsidiary_preconditioner_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Pointer to mesh with preconditionable elements used</span></div>
<div class="line"><span class="comment">  /// for classification of dof types.</span></div>
<div class="line"><span class="comment"></span>  Mesh* Multi_poisson_mesh_pt;</div>
<div class="line"> </div>
<div class="line"> };</div>
</div><!-- fragment --><h3><a class="anchor" id="two_plus_three_upper_triangular_with_sub_setup"></a>
The setup() function</h3>
<p>As usual we free up any memory and set the pointer to the mesh:</p>
<div class="fragment"><div class="line"> <span class="comment">//=======start_of_setup_for_two_plus_three_upper_triangular_with_sub_class====</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// The setup function.</span></div>
<div class="line"><span class="comment"></span> <span class="comment">//============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> TwoPlusThreeUpperTriangularWithOneLevelSubsidiary&lt;MATRIX&gt;::setup()</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// clean the memory</span></div>
<div class="line">  this-&gt;clean_up_my_memory();</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line">  <span class="keywordflow">if</span> (Multi_poisson_mesh_pt == 0)</div>
<div class="line">   {</div>
<div class="line">    std::stringstream err;</div>
<div class="line">    err &lt;&lt; <span class="stringliteral">&quot;Please set pointer to mesh using set_multi_poisson_mesh(...).\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">throw</span> OomphLibError(err.str(),</div>
<div class="line">                        OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                        OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">   }</div>
<div class="line"><span class="preprocessor">#endif </span></div>
<div class="line">  </div>
<div class="line">  <span class="comment">// The preconditioner works with one mesh; set it!</span></div>
<div class="line">  this-&gt;set_nmesh(1);</div>
<div class="line">  this-&gt;set_mesh(0,Multi_poisson_mesh_pt);</div>
</div><!-- fragment --><p> We check that the number of dof types is appropriate for this preconditioner: </p><div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">// number of dof types  </span></div>
<div class="line">  <span class="keywordtype">unsigned</span> n_dof_types = this-&gt;ndof_types();</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line">  <span class="comment">// This preconditioner only works for 5 dof types</span></div>
<div class="line">  <span class="keywordflow">if</span> (n_dof_types!=5)</div>
<div class="line">   {</div>
<div class="line">    std::stringstream tmp;</div>
<div class="line">    tmp &lt;&lt; <span class="stringliteral">&quot;This preconditioner only works for problems with 5 dof types\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;Yours has &quot;</span> &lt;&lt; n_dof_types;</div>
<div class="line">    <span class="keywordflow">throw</span> OomphLibError(tmp.str(),</div>
<div class="line">                        OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                        OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">   }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> Next we define the block structure of the preconditioner, using a dof-to-block mapping to combine dofs 0 and 1 into block 0, and dofs 2, 3 and 4 into block 1:</p>
<div class="fragment"><div class="line">  <span class="comment">// Combine &quot;dof blocks&quot; into two compound blocks, one containing dof </span></div>
<div class="line">  <span class="comment">// types 0 and 1, the final one dof types 2-4. In general we want:</span></div>
<div class="line">  <span class="comment">// dof_to_block_map[dof_type] = block type</span></div>
<div class="line">  Vector&lt;unsigned&gt; dof_to_block_map(n_dof_types);</div>
<div class="line">  dof_to_block_map[0]=0;</div>
<div class="line">  dof_to_block_map[1]=0;</div>
<div class="line">  dof_to_block_map[2]=1;</div>
<div class="line">  dof_to_block_map[3]=1;</div>
<div class="line">  dof_to_block_map[4]=1;</div>
<div class="line">  this-&gt;block_setup(dof_to_block_map);</div>
</div><!-- fragment --><p> Next we create the block triangular preconditioner used to (approximately) solve linear systems involving the compound "top left" 2x2 block: </p><div class="fragment"><div class="line">  <span class="comment">// Create the subsidiary block preconditioners.  </span></div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Block upper triangular block preconditioner for compound </span></div>
<div class="line">   <span class="comment">// 2x2 top left block in &quot;big&quot; 5x5 matrix</span></div>
<div class="line">   UpperTriangular&lt;CRDoubleMatrix&gt;* block_prec_pt=</div>
<div class="line">    <span class="keyword">new</span> UpperTriangular&lt;CRDoubleMatrix&gt;;</div>
<div class="line">   First_subsidiary_preconditioner_pt=block_prec_pt;</div>
</div><!-- fragment --><p> Next we specify the pointer to the mesh that contains the elements that classify the degrees of freedom. We note, that, strictly speaking this is not necessary since the preconditioner will only be used as a subsidiary preconditioner &ndash; the enumeration of the dof types is always handled by the top-most master preconditioner. One (or more) mesh pointers must be set for the master preconditioner, and, if compiled in <code>PARANOID</code> mode, <code>oomph-lib</code> will throw an error if this is not done. Some (but not all!) <code>oomph-lib</code> developers regard it as "good practice" to set the mesh pointer anyway, so one is less likely to forget...</p>
<div class="fragment"><div class="line">   <span class="comment">// Set mesh</span></div>
<div class="line">   block_prec_pt-&gt;set_multi_poisson_mesh(Multi_poisson_mesh_pt);</div>
</div><!-- fragment --><p>We turn this preconditioner into a subsidiary block preconditioner, specifying the pointer to the current (master) preconditioner and the mapping between dof types in the present and the subsidiary block preconditioners (here the identity): </p><div class="fragment"><div class="line">   </div>
<div class="line">   <span class="comment">// Turn into a subsidiary preconditioner, declaring which</span></div>
<div class="line">   <span class="comment">// of the five dof types in the present (master) preconditioner</span></div>
<div class="line">   <span class="comment">// correspond to the dof types in the subsidiary block preconditioner:</span></div>
<div class="line">   <span class="comment">// dof_map[dof_block_ID_in_subsdiary] = dof_block_ID_in_master. Also </span></div>
<div class="line">   <span class="comment">// pass pointer to present (master) preconditioner.</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_sub_dof_types=2;</div>
<div class="line">   Vector&lt;unsigned&gt; dof_map(n_sub_dof_types);</div>
<div class="line">   dof_map[0]=0;</div>
<div class="line">   dof_map[1]=1;</div>
<div class="line">   block_prec_pt-&gt;turn_into_subsidiary_block_preconditioner(<span class="keyword">this</span>,dof_map);</div>
</div><!-- fragment --><p> When calling the subsidiary block preconditioners <code>setup(...)</code> function we pass a pointer to the full matrix: </p><div class="fragment"><div class="line">    </div>
<div class="line">   <span class="comment">// Setup: Pass pointer to full-size matrix!</span></div>
<div class="line">   block_prec_pt-&gt;setup(this-&gt;matrix_pt());</div>
<div class="line">  }</div>
</div><!-- fragment --><p>The second subsidiary block preconditioner (for the 3x3 "bottom right" compound matrix) is created similarly, though the mapping between dof-types is now no longer the identity but maps dof types 2, 3 and 4 in the current (master) preconditioner to dof types 0, 1 and 2 in the subsidiary block preconditioner: </p><div class="fragment"><div class="line"> </div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Block upper triangular for 3x3 bottom right block in &quot;big&quot; 5x5 matrix</span></div>
<div class="line">   UpperTriangular&lt;CRDoubleMatrix&gt;* block_prec_pt=</div>
<div class="line">    <span class="keyword">new</span> UpperTriangular&lt;CRDoubleMatrix&gt;;</div>
<div class="line">   Second_subsidiary_preconditioner_pt=block_prec_pt;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Set mesh</span></div>
<div class="line">   block_prec_pt-&gt;set_multi_poisson_mesh(Multi_poisson_mesh_pt);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Turn second_sub into a subsidiary preconditioner, declaring which</span></div>
<div class="line">   <span class="comment">// of the five dof types in the present (master) preconditioner</span></div>
<div class="line">   <span class="comment">// correspond to the dof types in the subsidiary block preconditioner:</span></div>
<div class="line">   <span class="comment">// dof_map[dof_block_ID_in_subsdiary] = dof_block_ID_in_master. Also </span></div>
<div class="line">   <span class="comment">// pass pointer to present (master) preconditioner.</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_sub_dof_types=3;</div>
<div class="line">   Vector&lt;unsigned&gt; dof_map(n_sub_dof_types);</div>
<div class="line">   dof_map[0]=2;</div>
<div class="line">   dof_map[1]=3;</div>
<div class="line">   dof_map[2]=4;</div>
<div class="line">   block_prec_pt-&gt;turn_into_subsidiary_block_preconditioner(<span class="keyword">this</span>,dof_map);    </div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Setup: Pass pointer to full-size matrix!</span></div>
<div class="line">   block_prec_pt-&gt;setup(this-&gt;matrix_pt());</div>
<div class="line">  }</div>
</div><!-- fragment --><p> The setup of the matrix-vector product with the off-diagonal matrix is unchanged from the previous example:</p>
<div class="fragment"><div class="line">  <span class="comment">// Setup the off-diagonal mat vec operator</span></div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Get the off-diagonal block: the top-right block in the present</span></div>
<div class="line">   <span class="comment">// block preconditioner (which views the system matrix as comprising</span></div>
<div class="line">   <span class="comment">// 2x2 blocks).</span></div>
<div class="line">   CRDoubleMatrix block_matrix = this-&gt;get_block(0,1);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Create matrix vector product</span></div>
<div class="line">   Off_diagonal_matrix_vector_product_pt = <span class="keyword">new</span> MatrixVectorProduct;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Setup: Final argument indicates block column in the present</span></div>
<div class="line">   <span class="comment">// block preconditioner (which views the system matrix as comprising</span></div>
<div class="line">   <span class="comment">// 2x2 blocks).</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> block_column_index=1;</div>
<div class="line">   this-&gt;setup_matrix_vector_product(</div>
<div class="line">    Off_diagonal_matrix_vector_product_pt,&amp;block_matrix,block_column_index);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> }</div>
</div><!-- fragment --> <h3><a class="anchor" id="two_plus_three_upper_triangular_with_sub_solve"></a>
The preconditioner_solve() function</h3>
<p>As discussed in the theory section, we start by (approximately) solving the system <img class="formulaInl" alt="$ B_{22} Y_2 = Z_2 $" src="form_108.png" width="63" height="13"/>, using the second subsidiary block preconditioner which automatically extracts <img class="formulaInl" alt="$ Z_2 $" src="form_68.png" width="14" height="13"/> from the full length vector <code>z</code> and returns the result <img class="formulaInl" alt="$ Y_2 $" src="form_109.png" width="13" height="13"/> into the appropriate entries of the full length vector <code>y</code>.</p>
<div class="fragment"><div class="line"> <span class="comment">//=============================================================================</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// Preconditioner solve </span></div>
<div class="line"><span class="comment"></span> <span class="comment">//=============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> TwoPlusThreeUpperTriangularWithOneLevelSubsidiary&lt;MATRIX&gt;::</div>
<div class="line"> preconditioner_solve(<span class="keyword">const</span> DoubleVector&amp; z, DoubleVector&amp; y)</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// Solve &quot;bottom right&quot; (1,1) diagonal block system, using the </span></div>
<div class="line">  <span class="comment">// subsidiary block preconditioner that acts on the</span></div>
<div class="line">  <span class="comment">// &quot;bottom right&quot; 3x3 sub-system (only!). The subsidiary preconditioner </span></div>
<div class="line">  <span class="comment">// will extract the relevant (3x1) &quot;sub-vectors&quot; from the &quot;big&quot; (5x1)</span></div>
<div class="line">  <span class="comment">// vector z and treat it as the rhs, r, of P y = z</span></div>
<div class="line">  <span class="comment">// where P is 3x3 a block matrix. Once the system is solved,</span></div>
<div class="line">  <span class="comment">// the result is automatically put back into the appropriate places </span></div>
<div class="line">  <span class="comment">// of the &quot;big&quot; (5x1) vector y:</span></div>
<div class="line">  Second_subsidiary_preconditioner_pt-&gt;preconditioner_solve(z,y);</div>
</div><!-- fragment --><p> We now extract the block vector <img class="formulaInl" alt="$ Y_2 $" src="form_109.png" width="13" height="13"/> from the full-length vector <code>y</code>, </p><div class="fragment"><div class="line">    </div>
<div class="line">  <span class="comment">// Now extract the &quot;bottom&quot; (3x1) block vector from the full-size (5x1)</span></div>
<div class="line">  <span class="comment">// solution vector that we&#39;ve just computed -- note that index 1</span></div>
<div class="line">  <span class="comment">// refers to the block enumeration in the current preconditioner</span></div>
<div class="line">  <span class="comment">// (which has two blocks!)</span></div>
<div class="line">  DoubleVector block_y;</div>
<div class="line">  this-&gt;get_block_vector(1,y,block_y);</div>
</div><!-- fragment --><p> multiply it by <img class="formulaInl" alt="$ B_{12} $" src="form_78.png" width="19" height="13"/>, using the <code>MatrixVectorProduct</code> operator, </p><div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">// Evaluate matrix vector product of just-extracted (3x1) solution </span></div>
<div class="line">  <span class="comment">// vector with off-diagonal block and store in temporary vector</span></div>
<div class="line">  DoubleVector temp;</div>
<div class="line">  Off_diagonal_matrix_vector_product_pt-&gt;multiply(block_y,temp);</div>
</div><!-- fragment --><p> and subtract the result from <img class="formulaInl" alt="$ Z_1 $" src="form_110.png" width="13" height="13"/> (which we extract from the full length vector <code>z</code> ):</p>
<div class="fragment"><div class="line">  <span class="comment">// Extract &quot;upper&quot; (2x1) block vector from full-size (5x1) rhs </span></div>
<div class="line">  <span class="comment">// vector (as passed into this function)...</span></div>
<div class="line">  DoubleVector block_z;</div>
<div class="line">  this-&gt;get_block_vector(0,z,block_z);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ...and subtract matrix vector product computed above</span></div>
<div class="line">  block_z -= temp;   </div>
</div><!-- fragment --><p> <code>block_z</code> now contains the updated right hand side, <img class="formulaInl" alt="$ \widehat{{\bf Z}_1}$" src="form_111.png" width="14" height="16"/>, for the linear system to be (approximately) solved by the first subsidiary block preconditioner. We therefore return <img class="formulaInl" alt="$ \widehat{{\bf Z}_1}$" src="form_111.png" width="14" height="16"/> to the appropriate entries into a full length vector of the same size as right hand side vector <code>z:</code> </p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">// Block solve for first diagonal block. Since the associated subsidiary </span></div>
<div class="line">  <span class="comment">// preconditioner is a block preconditioner itself, it will extract </span></div>
<div class="line">  <span class="comment">// the required (2x1) block from a &quot;big&quot; (5x1) rhs vector.</span></div>
<div class="line">  <span class="comment">// Therefore we first put the actual (2x1) rhs vector block_z into a</span></div>
<div class="line">  <span class="comment">// &quot;big&quot; (5x1) vector big_z whose row distribution matches that of the</span></div>
<div class="line">  <span class="comment">// &quot;big&quot; right hand side vector, z, that was passed into this function.</span></div>
<div class="line">  DoubleVector big_z(z.distribution_pt());</div>
<div class="line">  this-&gt;return_block_vector(0,block_z,big_z);</div>
</div><!-- fragment --><p> We then pass this vector to first subsidiary preconditioner which updates the appropriate entries in the full-length solution vector <code>y</code> which can therefore be returned directly by this function:</p>
<div class="fragment"><div class="line">  <span class="comment">// Now apply the subsidiary block preconditioner that acts on the</span></div>
<div class="line">  <span class="comment">// &quot;upper left&quot; (2x2) sub-system (only!). The subsidiary preconditioner </span></div>
<div class="line">  <span class="comment">// will extract the relevant (2x1) block vector from the &quot;big&quot; (5x1)</span></div>
<div class="line">  <span class="comment">// vector big_r and treat it as the rhs, z, of its P y = z</span></div>
<div class="line">  <span class="comment">// where P is upper left 2x2 block diagonal of the big system. </span></div>
<div class="line">  <span class="comment">// Once the system is solved, the result is automatically put back </span></div>
<div class="line">  <span class="comment">// into the appropriate places of the &quot;big&quot; (5x1) vector y which is </span></div>
<div class="line">  <span class="comment">// returned by the current function, so no further action is required.</span></div>
<div class="line">  First_subsidiary_preconditioner_pt-&gt;preconditioner_solve(big_z,y);</div>
<div class="line"> }</div>
</div><!-- fragment --> <h3><a class="anchor" id="two_plus_three_upper_triangular_with_sub_clean"></a>
The clean_up_my_memory() function</h3>
<p>As usual, we use this helper function to free up any memory allocated in the <code>setup()</code> function to avoid memory leaks.</p>
<div class="fragment"><div class="line"> <span class="comment">//====start_of_clean_up_for_two_plus_three_upper_triangular_with_sub_class=====</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// The clean up function.</span></div>
<div class="line"><span class="comment"></span> <span class="comment">//============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> TwoPlusThreeUpperTriangularWithOneLevelSubsidiary&lt;MATRIX&gt;::</div>
<div class="line"> clean_up_my_memory()</div>
<div class="line"> {     </div>
<div class="line">  <span class="comment">// Delete off-diagonal matrix vector product</span></div>
<div class="line">  <span class="keywordflow">if</span>(Off_diagonal_matrix_vector_product_pt!= 0)</div>
<div class="line">   {</div>
<div class="line">    <span class="keyword">delete</span> Off_diagonal_matrix_vector_product_pt;</div>
<div class="line">    Off_diagonal_matrix_vector_product_pt = 0;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Clean up subsidiary preconditioners.</span></div>
<div class="line">  <span class="keywordflow">if</span>(First_subsidiary_preconditioner_pt!=0)</div>
<div class="line">   {</div>
<div class="line">    <span class="keyword">delete</span> First_subsidiary_preconditioner_pt;</div>
<div class="line">    First_subsidiary_preconditioner_pt = 0;</div>
<div class="line">   }</div>
<div class="line">  <span class="keywordflow">if</span>(Second_subsidiary_preconditioner_pt!=0)</div>
<div class="line">   {</div>
<div class="line">    <span class="keyword">delete</span> Second_subsidiary_preconditioner_pt;</div>
<div class="line">    Second_subsidiary_preconditioner_pt = 0;</div>
<div class="line">   }</div>
<div class="line"> } <span class="comment">// End of clean_up_my_memory function.</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h2><a class="anchor" id="two_plus_three_upper_triangular_with_replace"></a>
Replacing/modifying blocks</h2>
<p>NEW FEATURES: How to replace/modify matrix blocks</p>
<h3><a class="anchor" id="two_plus_three_upper_triangular_with_replace_theory"></a>
Theory</h3>
<p>So far, we have demonstrated how to extract matrix blocks from the full-sized system matrix (typically the Jacobian matrix used in Newton's method) and how to apply a preconditioner via operations involving these blocks. Many preconditioners do not operate directly with the matrix blocks themselves, but on matrices that are derived from them. For instance, <code>oomph-lib</code>'s <a href="../../../preconditioners/lsc_navier_stokes/html/index.html">Schur complement Navier-Stokes preconditioner</a> operates on an (approximate) Schur complement; augmentation preconditioners involve operations on matrices that are obtained by the addition of a diagonal matrix to some of the matrix blocks; etc. Within a given preconditioner such derived matrices are typically pre-computed by the preconditioner's <code>setup()</code> function and then stored as private member data which makes them available to the <code>preconditioner_solve()</code> function. Unfortunately, this approach does not work if the modified block is to be used in a subsidiary block preconditioner because, as discussed in the previous example, by default the subsidiary block preconditioner will extract its block matrices directly from the full-size system matrix and will therefore ignore any (local) modifications made by its master preconditioner(s). What is therefore required is a method that indicates to the block preconditioning framework that a given sub-block is not to be extracted from the full system matrix but to be represented by suitable replacement matrix.</p>
<p>We demonstrate this methodology by re-visiting the preconditioner considered in the previous example, namely </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hspace{3cm} {\bf P}_{\rm previous} = \left( \begin{array}{cc|ccc} J_{11} &amp; J_{12} &amp; J_{13} &amp; J_{14} &amp; J_{15} \\ J_{21} &amp; J_{22} &amp; J_{13} &amp; J_{14} &amp; J_{15} \\ \hline &amp; &amp; J_{33} &amp; J_{34} &amp; J_{35} \\ &amp; &amp; J_{43} &amp; J_{44} &amp; J_{45} \\ &amp; &amp; J_{53} &amp; J_{54} &amp; J_{55} \\ \end{array} \right). \hspace{3cm} (15) \]" src="form_112.png" width="368" height="76"/>
</p>
<p> However, here we want to modify the off-diagonal blocks by "replacing" each block <img class="formulaInl" alt="$J_{ij}$" src="form_113.png" width="15" height="14"/> (for <img class="formulaInl" alt="$ i \ne j $" src="form_114.png" width="28" height="13"/>) by a "replacement matrix" <img class="formulaInl" alt="$R_{ij}$" src="form_115.png" width="18" height="14"/> so that the preconditioner becomes </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf P} = \left( \begin{array}{cc|ccc} J_{11} &amp; R_{12} &amp; R_{13} &amp; R_{14} &amp; R_{15} \\ R_{21} &amp; J_{22} &amp; R_{23} &amp; R_{24} &amp; R_{25} \\ \hline &amp; &amp; J_{33} &amp; R_{34} &amp; R_{35} \\ &amp; &amp; R_{43} &amp; J_{44} &amp; R_{45} \\ &amp; &amp; R_{53} &amp; R_{54} &amp; J_{55} \\ \end{array} \right) = \left( \begin{array}{c|c} B_{11} &amp; B_{12}\\ \hline &amp; B_{22} \\ \end{array} \right). \hspace{3cm} (16) \]" src="form_116.png" width="444" height="76"/>
</p>
<p> The application of this preconditioner (i.e. the solution of the linear system <img class="formulaInl" alt="${\bf P} {\bf y} ={\bf z}$" src="form_44.png" width="41" height="13"/> for <img class="formulaInl" alt="${\bf y}$" src="form_37.png" width="9" height="9"/>) still requires the solution of the two smaller linear systems </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{array}{c} \underbrace{ \left( \begin{array}{cc} J_{11} &amp; R_{12} \\ R_{21} &amp; J_{22} \\ \end{array} \right) }_{B_{11}} \left( \begin{array}{c} y_1 \\ y_2 \\ \end{array} \right) = \left( \begin{array}{c} z_1 \\ z_2 \\ \end{array} \right) - \underbrace{ \left( \begin{array}{ccc} R_{13} &amp; R_{14} &amp; R_{15} \\ R_{23} &amp; R_{24} &amp; R_{25} \\ \end{array} \right) }_{B_{12}} \left( \begin{array}{c} z_3 \\ z_4 \\ z_5 \\ \end{array} \right) \\ \hspace{3cm} (17) \\ \underbrace{ \left( \begin{array}{ccc} J_{33} &amp; R_{34} &amp; R_{35} \\ R_{43} &amp; J_{44} &amp; R_{45} \\ R_{53} &amp; R_{54} &amp; J_{55} \\ \end{array} \right) }_{B_{22}} \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) = \left( \begin{array}{c} z_3 \\ z_4 \\ z_5 \\ \end{array} \right) \end{array} \]" src="form_117.png" width="363" height="136"/>
</p>
<p> where we have again assumed that the two vectors <img class="formulaInl" alt="${\bf y}$" src="form_37.png" width="9" height="9"/> and <img class="formulaInl" alt="${\bf z}$" src="form_40.png" width="8" height="6"/> are re-ordered into `&lsquo;block vectors&rsquo;' in the same way as the vectors <img class="formulaInl" alt="$\delta {\bf x}$" src="form_46.png" width="14" height="10"/> and <img class="formulaInl" alt="${\bf r}$" src="form_47.png" width="8" height="6"/> in "the original linear system" (3) are re-ordered into the `&lsquo;block vectors&rsquo;' in (17). We wish to continue to solve the linear systems involving the compound matrices <img class="formulaInl" alt="$ B_{11} $" src="form_62.png" width="19" height="13"/> and <img class="formulaInl" alt="$ B_{22} $" src="form_63.png" width="19" height="13"/> (which involve "replaced" blocks) by two subsidiary block preconditioners (which operate on 3x3 and 2x2 dof blocks, respectively).</p>
<p>In the specific example below we replace all of the diagonal matrices by suitably sized zero matrices, so that the actual preconditioning operation is defined by the following linear systems </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{array}{c} \underbrace{ \left( \begin{array}{cc} J_{11} &amp; \\ &amp; J_{22} \\ \end{array} \right) }_{B_{11}} \left( \begin{array}{c} y_1 \\ y_2 \\ \end{array} \right) = \left( \begin{array}{c} z_1 \\ z_2 \\ \end{array} \right) - \underbrace{ \left( \begin{array}{ccc} &amp; &amp; \\ &amp; &amp; \\ \end{array} \right) }_{B_{12}} \left( \begin{array}{c} z_3 \\ z_4 \\ z_5 \\ \end{array} \right) \\ \underbrace{ \left( \begin{array}{ccc} J_{33} &amp; &amp; \\ &amp; J_{44} &amp; \\ &amp; &amp; J_{55} \\ \end{array} \right) }_{B_{22}} \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) = \left( \begin{array}{c} z_3 \\ z_4 \\ z_5 \\ \end{array} \right) \end{array} \]" src="form_118.png" width="298" height="121"/>
</p>
<p> which, in effect, turns the preconditioner into the block-diagonal preconditioner considered at the very beginning of this tutorial.</p>
<h3><a class="anchor" id="two_plus_three_upper_triangular_with_replace_implementation"></a>
Implementation as a BlockPreconditioner</h3>
<p>The implementation of the preconditioner is completely equivalent to the preconditioner considered in the previous example. The only additional feature is the provision a matrix of pointers to the replacement matrices, <code>Replacement_matrix_pt</code>.</p>
<div class="fragment"><div class="line"><span class="comment">//=============start_of_two_plus_three_upper_triangular_with_replace_class=====</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// Block diagonal preconditioner for system with 5 dof types</span></div>
<div class="line"><span class="comment">/// assembled into a 2x2 block system, with (0,0) block containing</span></div>
<div class="line"><span class="comment">/// the first two dof types, the (1,1) block the remaining dof types.</span></div>
<div class="line"><span class="comment">/// The blocks are solved by upper block triangular preconditioners.</span></div>
<div class="line"><span class="comment">/// However, the overall system is modified by replacing all off-diagonal </span></div>
<div class="line"><span class="comment">/// blocks by replacement matrices (zero matrices, so the preconditioner </span></div>
<div class="line"><span class="comment">/// again behaves like a 5x5 block diagonal preconditioner).</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keyword">class </span>TwoPlusThreeUpperTriangularWithReplace : </div>
<div class="line">  <span class="keyword">public</span> BlockPreconditioner&lt;MATRIX&gt;</div>
<div class="line"> {</div>
<div class="line">  </div>
<div class="line"> public :</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Constructor for TwoPlusThreeUpperTriangularWithReplace</span></div>
<div class="line"><span class="comment"></span>  TwoPlusThreeUpperTriangularWithReplace() : </div>
<div class="line">   BlockPreconditioner&lt;MATRIX&gt;(),</div>
<div class="line">   First_subsidiary_preconditioner_pt(0),</div>
<div class="line">   Second_subsidiary_preconditioner_pt(0),</div>
<div class="line">   Off_diagonal_matrix_vector_product_pt(0)</div>
<div class="line">   {    </div>
<div class="line">    Multi_poisson_mesh_pt=0;</div>
<div class="line">   } <span class="comment">// end_of_constructor</span></div>
<div class="line">  </div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Destructor clean up memory</span></div>
<div class="line"><span class="comment"></span>  ~TwoPlusThreeUpperTriangularWithReplace()</div>
<div class="line">   {</div>
<div class="line">    this-&gt;clean_up_my_memory();</div>
<div class="line">   }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Clean up the memory</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> clean_up_my_memory();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Broken copy constructor</span></div>
<div class="line"><span class="comment"></span>  TwoPlusThreeUpperTriangularWithReplace</div>
<div class="line">  (<span class="keyword">const</span> TwoPlusThreeUpperTriangularWithReplace&amp;) </div>
<div class="line">   { </div>
<div class="line">    BrokenCopy::</div>
<div class="line">     broken_copy(<span class="stringliteral">&quot;TwoPlusThreeUpperTriangularWithReplace&quot;</span>);</div>
<div class="line">   } </div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Broken assignment operator</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> TwoPlusThreeUpperTriangularWithReplace&amp;) </div>
<div class="line">   {</div>
<div class="line">    BrokenCopy::</div>
<div class="line">     broken_assign(<span class="stringliteral">&quot;TwoPlusThreeUpperTriangularWithReplace&quot;</span>);</div>
<div class="line">   }</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Apply preconditioner to r, i.e. return z such that P z = r</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> preconditioner_solve(<span class="keyword">const</span> DoubleVector &amp;r, DoubleVector &amp;z);</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Setup the preconditioner </span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> setup();</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Specify the mesh that contains multi-poisson elements</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> set_multi_poisson_mesh(Mesh* multi_poisson_mesh_pt)</div>
<div class="line">  {</div>
<div class="line">   Multi_poisson_mesh_pt=multi_poisson_mesh_pt;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">   private :</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Pointer to preconditioners/inexact solver</span></div>
<div class="line"><span class="comment">  /// for compound  (0,0) block</span></div>
<div class="line"><span class="comment"></span>  Preconditioner* First_subsidiary_preconditioner_pt;</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Pointer to preconditioners/inexact solver</span></div>
<div class="line"><span class="comment">  /// for compound (1,1) block</span></div>
<div class="line"><span class="comment"></span>  Preconditioner* Second_subsidiary_preconditioner_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Matrix vector product operator with the compound </span></div>
<div class="line"><span class="comment">  /// (0,1) off diagonal block.</span></div>
<div class="line"><span class="comment"></span>  MatrixVectorProduct* Off_diagonal_matrix_vector_product_pt;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Matrix of pointers to replacement matrix blocks</span></div>
<div class="line">  DenseMatrix&lt;CRDoubleMatrix*&gt; Replacement_matrix_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Pointer to mesh with preconditionable elements used</span></div>
<div class="line"><span class="comment">  /// for classification of dof types.</span></div>
<div class="line"><span class="comment"></span>  Mesh* Multi_poisson_mesh_pt;</div>
<div class="line">  </div>
<div class="line"> };</div>
</div><!-- fragment --><h3><a class="anchor" id="two_plus_three_upper_triangular_with_replace_setup"></a>
The setup() function</h3>
<p>As usual, we start by cleaning up any memory using a call to a <code>clean_up_my_memory()</code> function, and set the pointer to the mesh</p>
<div class="fragment"><div class="line"> <span class="comment">//==start_of_setup_for_two_plus_three_upper_triangular_with_replace===========</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// The setup function.</span></div>
<div class="line"><span class="comment"></span> <span class="comment">//============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> TwoPlusThreeUpperTriangularWithReplace&lt;MATRIX&gt;::setup()</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// Clean up memory.</span></div>
<div class="line">  this-&gt;clean_up_my_memory();</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line">  <span class="keywordflow">if</span> (Multi_poisson_mesh_pt == 0)</div>
<div class="line">   {</div>
<div class="line">    std::stringstream err;</div>
<div class="line">    err &lt;&lt; <span class="stringliteral">&quot;Please set pointer to mesh using set_multi_poisson_mesh(...).\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">throw</span> OomphLibError(err.str(),</div>
<div class="line">                        OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                        OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">   }</div>
<div class="line"><span class="preprocessor">#endif </span></div>
<div class="line">  </div>
<div class="line">  <span class="comment">// The preconditioner works with one mesh; set it!</span></div>
<div class="line">  this-&gt;set_nmesh(1);</div>
<div class="line">  this-&gt;set_mesh(0,Multi_poisson_mesh_pt);</div>
</div><!-- fragment --><p> Next we check that the number of dof types is 5, as the preconditioner is designed to only work for that number.</p>
<div class="fragment"><div class="line">  <span class="comment">// How many dof types do we have?</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_dof_types = this-&gt;ndof_types();</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line">  <span class="comment">// This preconditioner only works for 5 dof types</span></div>
<div class="line">  <span class="keywordflow">if</span> (n_dof_types!=5)</div>
<div class="line">   {</div>
<div class="line">    std::stringstream tmp;</div>
<div class="line">    tmp &lt;&lt; <span class="stringliteral">&quot;This preconditioner only works for problems with 5 dof types\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;Yours has &quot;</span> &lt;&lt; n_dof_types;</div>
<div class="line">    <span class="keywordflow">throw</span> OomphLibError(tmp.str(),</div>
<div class="line">                        OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                        OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">   }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> The block setup follows exactly the same pattern as in the previous example: Dof types 0 and 1 are combined into compound block 0, while dof types 2, 3 and 4 are combined into compound block 1. <br  />
 On return from the block setup function we should therefore have two block types: </p><div class="fragment"><div class="line">  <span class="comment">// Call block setup with the Vector [0,0,1,1,1] to:</span></div>
<div class="line">  <span class="comment">// Merge DOF types 0 and 1 into block type 0</span></div>
<div class="line">  <span class="comment">// Merge DOF types 2, 3, and 4 into block type 1.</span></div>
<div class="line">  Vector&lt;unsigned&gt; dof_to_block_map(n_dof_types,0);</div>
<div class="line">  dof_to_block_map[0] = 0;</div>
<div class="line">  dof_to_block_map[1] = 0;</div>
<div class="line">  dof_to_block_map[2] = 1;</div>
<div class="line">  dof_to_block_map[3] = 1;</div>
<div class="line">  dof_to_block_map[4] = 1;</div>
<div class="line">  this-&gt;block_setup(dof_to_block_map);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We should now have two block types -- do we?</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nblocks = this-&gt;nblock_types();</div>
<div class="line">  <span class="keywordflow">if</span> (nblocks!=2)</div>
<div class="line">   {</div>
<div class="line">    std::stringstream tmp;</div>
<div class="line">    tmp &lt;&lt; <span class="stringliteral">&quot;Expected number of block types is 2.\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;Yours has &quot;</span> &lt;&lt; nblocks &lt;&lt; <span class="stringliteral">&quot;.\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;Perhaps your argument to block_setup(...) is not correct.\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">throw</span> OomphLibError(tmp.str(),</div>
<div class="line">                        OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                        OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> Now we perform the replacement of the off-diagonal dof blocks. (Note that there are still five of these. Dof-blocks and compound blocks are not the same &ndash; if you get them confused you will get into trouble!). We allocate storage for the pointers to the replacement matrices and loop over the off-diagonal blocks:</p>
<div class="fragment"><div class="line">  <span class="comment">// Now replace all the off-diagonal DOF blocks.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Storage for the replacement DOF blocks</span></div>
<div class="line">  Replacement_matrix_pt.resize(n_dof_types,n_dof_types,0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set off-diagonal DOF blocks to zero, loop over the number of DOF blocks.</span></div>
<div class="line">  <span class="comment">// NOTE: There are two (compound) blocks, but the replacement functionality</span></div>
<div class="line">  <span class="comment">// works with DOF blocks.</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_dof_types;i++)</div>
<div class="line">   {</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;n_dof_types;j++)</div>
<div class="line">     {</div>
<div class="line">      <span class="keywordflow">if</span>(i!=j)</div>
<div class="line">       {</div>
</div><!-- fragment --><p>Given that the replacement matrices are zero matrices, we could simply create them without ever looking at the original blocks. Sadly the creation of zero matrices turns out to be slightly more painful than one would wish because they have to be created as a (possibly distributed) <code>CRDoubleMatrix</code>. The relevant code is contained in the source code but we won't discuss it here since the more common situation is one where we actually want to modify the already existing entries of an already existing block matrix. Therefore we simply extract the matrix and set its initially nonzero entries to zero (admittedly a bit silly &ndash; we now have a sparse matrix full of zeroes, but it's just a demonstration!):</p>
<div class="fragment"><div class="line">        <span class="comment">// Modify matrix</span></div>
<div class="line">        <span class="keywordtype">bool</span> modify_existing_matrix=<span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (modify_existing_matrix)</div>
<div class="line">         {</div>
<div class="line">          <span class="comment">// Get the dof-block and make a deep copy of it</span></div>
<div class="line">          Replacement_matrix_pt(i,j)=<span class="keyword">new</span> CRDoubleMatrix;</div>
<div class="line">          this-&gt;get_dof_level_block(i,j,(*Replacement_matrix_pt(i,j))); </div>
<div class="line">          </div>
<div class="line">          <span class="comment">// Set all its entries to zero</span></div>
<div class="line">          <span class="keywordtype">unsigned</span> nnz=Replacement_matrix_pt(i,j)-&gt;nnz();</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0;k&lt;nnz;k++)</div>
<div class="line">           {</div>
<div class="line">            Replacement_matrix_pt(i,j)-&gt;value()[k]=0.0;</div>
<div class="line">           }</div>
<div class="line">         } <span class="comment">// done -- quite wasteful, we&#39;re actually storing lots of zeroes, but</span></div>
<div class="line">           <span class="comment">// this is just an example!</span></div>
</div><!-- fragment --><p> We then pass the pointer to the replacement dof block to the block preconditioner</p>
<div class="fragment"><div class="line">        <span class="comment">// Replace (i,j)-th dof block</span></div>
<div class="line">        this-&gt;set_replacement_dof_block(i,j,Replacement_matrix_pt(i,j));</div>
<div class="line">       }</div>
<div class="line">     }<span class="comment">// end for loop of j</span></div>
<div class="line">   }<span class="comment">// end for loop of i</span></div>
</div><!-- fragment --><p> The rest of the setup works exactly as in the previous example, only this time, the subsidiary preconditioners and the matrix vector products will work with the replacement dof blocks that we've just defined.</p>
<p>We create and set up the first subsidiary block preconditioner which operates on our dof types 0 and 1 (and treats them as its own dof types 0 and 1): </p><div class="fragment"><div class="line">  <span class="comment">// First subsidiary precond is a block triangular preconditioner</span></div>
<div class="line">  {</div>
<div class="line">   UpperTriangular&lt;CRDoubleMatrix&gt;* block_prec_pt=</div>
<div class="line">    <span class="keyword">new</span> UpperTriangular&lt;CRDoubleMatrix&gt;;</div>
<div class="line">   First_subsidiary_preconditioner_pt=block_prec_pt;</div>
<div class="line">  </div>
<div class="line">   <span class="comment">// Set mesh</span></div>
<div class="line">   block_prec_pt-&gt;set_multi_poisson_mesh(Multi_poisson_mesh_pt);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Turn it into a subsidiary preconditioner, declaring which</span></div>
<div class="line">   <span class="comment">// of the five dof types in the present (master) preconditioner</span></div>
<div class="line">   <span class="comment">// correspond to the dof types in the subsidiary block preconditioner</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_sub_dof_types=2;</div>
<div class="line">   Vector&lt;unsigned&gt; dof_map(n_sub_dof_types);</div>
<div class="line">   dof_map[0]=0;</div>
<div class="line">   dof_map[1]=1;</div>
<div class="line">   block_prec_pt-&gt;turn_into_subsidiary_block_preconditioner(<span class="keyword">this</span>,dof_map);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Perform setup. Note that because the subsidiary</span></div>
<div class="line">   <span class="comment">// preconditioner is a block preconditioner itself it is given</span></div>
<div class="line">   <span class="comment">// the pointer to the &quot;full&quot; matrix</span></div>
<div class="line">   block_prec_pt-&gt;setup(this-&gt;matrix_pt());</div>
<div class="line">  }</div>
</div><!-- fragment --><p> The second subsidiary block preconditioner which operates on our dof types 2, 3 and 4 (and treats them as its own dof types 0, 1 and 2):</p>
<div class="fragment"><div class="line">  <span class="comment">// Second subsidiary precond is a block triangular preconditioner</span></div>
<div class="line">  {</div>
<div class="line">   UpperTriangular&lt;CRDoubleMatrix&gt;* block_prec_pt=</div>
<div class="line">    <span class="keyword">new</span> UpperTriangular&lt;CRDoubleMatrix&gt;;</div>
<div class="line">   Second_subsidiary_preconditioner_pt=block_prec_pt;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Set mesh</span></div>
<div class="line">   block_prec_pt-&gt;set_multi_poisson_mesh(Multi_poisson_mesh_pt);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Turn it into a subsidiary preconditioner, declaring which</span></div>
<div class="line">   <span class="comment">// of the five dof types in the present (master) preconditioner</span></div>
<div class="line">   <span class="comment">// correspond to the dof types in the subsidiary block preconditioner</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_sub_dof_types=3;</div>
<div class="line">   Vector&lt;unsigned&gt; dof_map(n_sub_dof_types);</div>
<div class="line">   dof_map[0]=2;</div>
<div class="line">   dof_map[1]=3;</div>
<div class="line">   dof_map[2]=4;</div>
<div class="line">   block_prec_pt-&gt;turn_into_subsidiary_block_preconditioner(<span class="keyword">this</span>,dof_map);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Perform setup. Note that because the subsidiary</span></div>
<div class="line">   <span class="comment">// preconditioner is a block preconditioner itself it is given</span></div>
<div class="line">   <span class="comment">// the pointer to the &quot;full&quot; matrix</span></div>
<div class="line">   block_prec_pt-&gt;setup(this-&gt;matrix_pt());</div>
<div class="line">  }</div>
</div><!-- fragment --><p> Finally, we create the matrix vector product operator: </p><div class="fragment"><div class="line">  <span class="comment">// Next setup the off diagonal mat vec operators:</span></div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Get the block</span></div>
<div class="line">   CRDoubleMatrix block_matrix = this-&gt;get_block(0,1);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Create matrix vector product operator</span></div>
<div class="line">   Off_diagonal_matrix_vector_product_pt = <span class="keyword">new</span> MatrixVectorProduct;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Setup: Final argument indicates block column in the present</span></div>
<div class="line">   <span class="comment">// block preconditioner (which views the system matrix as comprising</span></div>
<div class="line">   <span class="comment">// 2x2 blocks).</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> block_column_index=1;</div>
<div class="line">   this-&gt;setup_matrix_vector_product(</div>
<div class="line">   Off_diagonal_matrix_vector_product_pt,&amp;block_matrix,block_column_index);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Extracted block can now go out of scope since the matrix vector</span></div>
<div class="line">   <span class="comment">// product retains whatever information it needs</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> }</div>
</div><!-- fragment --><h3><a class="anchor" id="two_plus_three_upper_triangular_with_replace_solve"></a>
The preconditioner_solve() function</h3>
<p>The <code>preconditioner_solve()</code> function is completely identical to the one used in the previous preconditioner, so we omit the code listing &ndash; the subsidiary preconditioners and the matrix vector product operator work in the same way but now simply operate on the replacement dof blocks where they have been set.</p>
<h3><a class="anchor" id="two_plus_three_upper_triangular_with_replace_clean"></a>
The clean_up_my_memory() function</h3>
<p>Memory is cleaned up as before, so we omit the code listing.</p>
<hr  />
 <hr  />
<h2><a class="anchor" id="coarse_two_plus_two_plus_one"></a>
Coarsening/combining dof types</h2>
<p>NEW FEATURES: How to coarsen/combine dof types for use by subsidiary block preconditioners.</p>
<h3><a class="anchor" id="coarse_two_plus_two_plus_one_theory"></a>
Theory</h3>
<p>In the examples presented so far we have demonstrated how to combine various dof-blocks into compound blocks in order to facilitate the application of certain preconditioning operations. For instance, in many of the previous examples we performed a matrix vector product using the compound matrix <img class="formulaInl" alt="$ B_{12} $" src="form_78.png" width="19" height="13"/> that was (formally) formed by the concatenation of the 2x3 "top right" off-diagonal dof blocks in the full-sized system.</p>
<p>We also showed how subsidiary block preconditioners which operate on a specific number of dof blocks can be instructed to operate on selected dof types from the full-sized system. Our standard example for this was a 2D Navier-Stokes preconditioner which operates on three dof types (two fluid velocities and one pressure) and is used as a subsidiary block preconditioner in an FSI problem that also involves additional dofs associated with the solid mechanics (e.g. the two solid displacement components). This was done by informing the subsidiary preconditioner which of the dof types in the full-sized system to regard as "its own" when calling its <code>turn_into_subsidiary_block_preconditioner(...)</code> function. This implies that the subsidiary block preconditioner remains unaware of any compound blocks that may have been formed in its master preconditioner. The functionality presented so far only allows us to associate dof-blocks in the master preconditioner with dof blocks in the subsidiary block preconditioner. It is therefore not possible (without further functionality which we explain in this example) to use a subsidiary block preconditioner if the dof-types in the master preconditioner are "too fine-grained". This arises, for instance, in Navier-Stokes problems where the master preconditioner sub-divides the two components of the fluid velocity into degrees of freedom on the domain boundary and those in the interior. It is then necessary to make the subsidiary preconditioner act on the combined dof types, a process that we describe as "coarsening".</p>
<p>We illustrate the procedure by returning, yet again, to our 5x5 block linear system that we wish to precondition with </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hspace{3cm} {\bf P}_{\rm previous} = \left( \begin{array}{cc|ccc} J_{11} &amp; J_{12} &amp; J_{13} &amp; J_{14} &amp; J_{15} \\ J_{21} &amp; J_{22} &amp; J_{13} &amp; J_{14} &amp; J_{15} \\ \hline &amp; &amp; J_{33} &amp; J_{34} &amp; J_{35} \\ &amp; &amp; J_{43} &amp; J_{44} &amp; J_{45} \\ &amp; &amp; J_{53} &amp; J_{54} &amp; J_{55} \\ \end{array} \right) = \left( \begin{array}{c|c} B_{11} &amp; B_{12}\\ \hline &amp; B_{22} \\ \end{array} \right). \hspace{3cm} (18) \]" src="form_119.png" width="468" height="76"/>
</p>
<p> However, now we wish to solve the two linear systems involving the compound matrices <img class="formulaInl" alt="$ B_{11} $" src="form_62.png" width="19" height="13"/> and <img class="formulaInl" alt="$ B_{22} $" src="form_63.png" width="19" height="13"/> with a 2x2 upper triangular subsidiary block preconditioner. To make this possible, we "coarsen" the dof types such that the subsidiary block preconditioner acting on <img class="formulaInl" alt="$ B_{22}$" src="form_69.png" width="19" height="13"/> treats the global dof types 3 and 4 as a single dof type so that the block structure can be viewed as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf P} = \left( \begin{array}{c||c} \begin{array}{cc} J_{11} &amp; J_{12} \\ J_{21} &amp; J_{22} \\ \end{array} &amp; \begin{array}{ccc} J_{13} &amp; J_{14} &amp; J_{15} \\ J_{23} &amp; J_{24} &amp; J_{25} \\ \end{array} \\ \hline \hline &amp; \begin{array}{cc|c} J_{33} &amp; J_{34} &amp; J_{35} \\ J_{43} &amp; J_{44} &amp; J_{45} \\ \hline J_{53} &amp; J_{54} &amp; J_{55} \\ \end{array} \end{array} \right) = \left( \begin{array}{c|c} B_{11} &amp; B_{12}\\ \hline &amp; B_{22} \\ \end{array} \right). \hspace{3cm} (19) \]" src="form_120.png" width="459" height="80"/>
</p>
<p>If we now use a 2x2 upper triangular block preconditioner to (approximately) solve the linear systems involving the diagonal blocks <img class="formulaInl" alt="$ B_{11} $" src="form_62.png" width="19" height="13"/> and <img class="formulaInl" alt="$ B_{22} $" src="form_63.png" width="19" height="13"/> the preconditioner is given (mathematically) by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf P} = \left( \begin{array}{ccccc} J_{11} &amp; J_{12} &amp; J_{13} &amp; J_{14} &amp; J_{15} \\ &amp; J_{22} &amp; J_{23} &amp; J_{24} &amp; J_{25} \\ &amp; &amp; J_{33} &amp; J_{34} &amp; J_{35} \\ &amp; &amp; J_{34} &amp; J_{44} &amp; J_{45} \\ &amp; &amp; &amp; &amp; J_{55} \\ \end{array} \right). \]" src="form_121.png" width="204" height="76"/>
</p>
<p>[Note that, In the actual implementation discussed below, we also set the off diagonal dof-blocks to zero, using the replacement methodology discussed in the previous example. The preconditioner therefore becomes mathematically equivalent to the <img class="formulaInl" alt="$ 5x5 $" src="form_122.png" width="19" height="9"/> block diagonal preconditioner discussed at the very beginning of this tutorial.]</p>
<h3><a class="anchor" id="coarse_two_plus_two_plus_one_implementation"></a>
Implementation as a BlockPreconditioner</h3>
<p>The implementation of the preconditioner is completely equivalent to the preconditioner considered in the previous examples:</p>
<div class="fragment"><div class="line"><span class="comment">//==================start_of_coarse_two_plus_two_plus_one_class================</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// Block diagonal preconditioner for system with 5 dof types</span></div>
<div class="line"><span class="comment">/// assembled into a 2x2 block system, with the (0,0) block containing</span></div>
<div class="line"><span class="comment">/// the first two dof types, the (1,1) block containing the three remaining </span></div>
<div class="line"><span class="comment">/// ones.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keyword">class </span>CoarseTwoPlusTwoPlusOne : </div>
<div class="line">  <span class="keyword">public</span> BlockPreconditioner&lt;MATRIX&gt;</div>
<div class="line"> {</div>
<div class="line">  </div>
<div class="line"> public :</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Constructor for CoarseTwoPlusTwoPlusOne</span></div>
<div class="line"><span class="comment"></span>   CoarseTwoPlusTwoPlusOne() : </div>
<div class="line">  BlockPreconditioner&lt;MATRIX&gt;(),</div>
<div class="line">   First_subsidiary_preconditioner_pt(0),</div>
<div class="line">   Second_subsidiary_preconditioner_pt(0),</div>
<div class="line">   Off_diagonal_matrix_vector_product_pt(0)</div>
<div class="line">    {    </div>
<div class="line">     Multi_poisson_mesh_pt=0;</div>
<div class="line">    } <span class="comment">// end_of_constructor</span></div>
<div class="line">  </div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Destructor - delete the diagonal solvers (subsidiary preconditioners)</span></div>
<div class="line"><span class="comment"></span>  ~CoarseTwoPlusTwoPlusOne()</div>
<div class="line">   {</div>
<div class="line">    this-&gt;clean_up_my_memory();</div>
<div class="line">   }    </div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// clean up the memory</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> clean_up_my_memory();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Broken copy constructor</span></div>
<div class="line"><span class="comment"></span>  CoarseTwoPlusTwoPlusOne</div>
<div class="line">  (<span class="keyword">const</span> CoarseTwoPlusTwoPlusOne&amp;) </div>
<div class="line">   { </div>
<div class="line">    BrokenCopy::broken_copy(</div>
<div class="line">     <span class="stringliteral">&quot;CoarseTwoPlusTwoPlusOne&quot;</span>);</div>
<div class="line">   } </div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Broken assignment operator</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> </div>
<div class="line">                 CoarseTwoPlusTwoPlusOne&amp;) </div>
<div class="line">   {</div>
<div class="line">    BrokenCopy::broken_assign(</div>
<div class="line">     <span class="stringliteral">&quot;CoarseTwoPlusTwoPlusOne&quot;</span>);</div>
<div class="line">   }</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Apply preconditioner to r, i.e. return z such that P z = r</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> preconditioner_solve(<span class="keyword">const</span> DoubleVector &amp;r, DoubleVector &amp;z);</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Setup the preconditioner </span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> setup();</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Specify the mesh that contains multi-poisson elements</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> set_multi_poisson_mesh(Mesh* multi_poisson_mesh_pt)</div>
<div class="line">  {</div>
<div class="line">   Multi_poisson_mesh_pt=multi_poisson_mesh_pt;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> private :</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Pointer to preconditioners/inexact solver</span></div>
<div class="line"><span class="comment">  /// for (0,0) block</span></div>
<div class="line"><span class="comment"></span>  Preconditioner* First_subsidiary_preconditioner_pt;</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Pointer to preconditioners/inexact solver</span></div>
<div class="line"><span class="comment">  /// for (1,1) block</span></div>
<div class="line"><span class="comment"></span>  Preconditioner* Second_subsidiary_preconditioner_pt;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Matrix of pointers to replacement matrix blocks</span></div>
<div class="line">  DenseMatrix&lt;CRDoubleMatrix*&gt; Replacement_matrix_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Matrix vector product operator</span></div>
<div class="line"><span class="comment"></span>  MatrixVectorProduct* Off_diagonal_matrix_vector_product_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Pointer to mesh with preconditionable elements used</span></div>
<div class="line"><span class="comment">  /// for classification of dof types.  </span></div>
<div class="line"><span class="comment"></span>  Mesh* Multi_poisson_mesh_pt;</div>
<div class="line"> };</div>
</div><!-- fragment --> <h3><a class="anchor" id="coarse_two_plus_two_plus_one_setup"></a>
The setup() function</h3>
<p>As usual we clean up any previously allocated memory and set the pointer to the mesh:</p>
<div class="fragment"><div class="line"> <span class="comment">//===============start_of_setup_for_coarse_two_plus_two_plus_one=============</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// The setup function.</span></div>
<div class="line"><span class="comment"></span> <span class="comment">//===========================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> CoarseTwoPlusTwoPlusOne&lt;MATRIX&gt;::setup()</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// Clean up memory</span></div>
<div class="line">  this-&gt;clean_up_my_memory();</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line">  <span class="keywordflow">if</span> (Multi_poisson_mesh_pt == 0)</div>
<div class="line">   {</div>
<div class="line">    std::stringstream err;</div>
<div class="line">    err &lt;&lt; <span class="stringliteral">&quot;Please set pointer to mesh using set_multi_poisson_mesh(...).\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">throw</span> OomphLibError(err.str(),</div>
<div class="line">                        OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                        OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">   }</div>
<div class="line"><span class="preprocessor">#endif </span></div>
<div class="line">  </div>
<div class="line">  <span class="comment">// The preconditioner works with one mesh; set it!</span></div>
<div class="line">  this-&gt;set_nmesh(1);</div>
<div class="line">  this-&gt;set_mesh(0,Multi_poisson_mesh_pt);</div>
</div><!-- fragment --><p> Next we check that the number of degrees of freedom is 5, as the preconditioner is designed to only work for that number.</p>
<div class="fragment"><div class="line">  <span class="comment">// This preconditioner only works for 5 dof types</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> n_dof_types = this-&gt;ndof_types();</div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line">  <span class="keywordflow">if</span> (n_dof_types!=5)</div>
<div class="line">   {</div>
<div class="line">    std::stringstream tmp;</div>
<div class="line">    tmp &lt;&lt; <span class="stringliteral">&quot;This preconditioner only works for problems with 5 dof types\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;Yours has &quot;</span> &lt;&lt; n_dof_types;</div>
<div class="line">    <span class="keywordflow">throw</span> OomphLibError(tmp.str(),</div>
<div class="line">                        OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                        OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">   }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> The block setup follows exactly the same pattern as in the previous examples: Dof types 0 and 1 are combined into compound block 0, while dof types 2, 3 and 4 are combined into compound block 1.</p>
<div class="fragment"><div class="line">  <span class="comment">// Call block setup with the Vector [0,0,1,1,1] to:</span></div>
<div class="line">  <span class="comment">// Merge DOF types 0 and 1 into block type 0.</span></div>
<div class="line">  <span class="comment">// Merge DOF types 2, 3 and 4 into block type 1.</span></div>
<div class="line">  Vector&lt;unsigned&gt; dof_to_block_map(n_dof_types,0);</div>
<div class="line">  dof_to_block_map[0] = 0;</div>
<div class="line">  dof_to_block_map[1] = 0;</div>
<div class="line">  dof_to_block_map[2] = 1;</div>
<div class="line">  dof_to_block_map[3] = 1;</div>
<div class="line">  dof_to_block_map[4] = 1;</div>
<div class="line">  this-&gt;block_setup(dof_to_block_map);</div>
</div><!-- fragment --><p> [We omit the code listing the replacement of the off-diagonal dof blocks with zero matrices since it is identical to what we already discussed in the previous example.]</p>
<p>Next we create the two subsidiary preconditioners that (approximately) solve the linear systems involving the diagonal blocks <img class="formulaInl" alt="$ B_{11} $" src="form_62.png" width="19" height="13"/> and <img class="formulaInl" alt="$ B_{22} $" src="form_63.png" width="19" height="13"/>. The first subsidiary preconditioner is a standard upper triangular block preconditioner which acts on the compound block formed by dof types 0 and 1:</p>
<div class="fragment"><div class="line">  <span class="comment">// Create the subsidiary preconditioners</span></div>
<div class="line">  <span class="comment">//--------------------------------------</span></div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// First subsidiary precond is a block diagonal preconditioner itself.</span></div>
<div class="line">   UpperTriangular&lt;CRDoubleMatrix&gt;* block_prec_pt=</div>
<div class="line">    <span class="keyword">new</span> UpperTriangular&lt;CRDoubleMatrix&gt;;</div>
<div class="line">   First_subsidiary_preconditioner_pt=block_prec_pt;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set mesh</span></div>
<div class="line">   block_prec_pt-&gt;set_multi_poisson_mesh(Multi_poisson_mesh_pt);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Turn first_sub into a subsidiary preconditioner, declaring which</span></div>
<div class="line">   <span class="comment">// of the five dof types in the present (master) preconditioner</span></div>
<div class="line">   <span class="comment">// correspond to the dof types in the subsidiary block preconditioner</span></div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_sub_dof_types=2;</div>
<div class="line">   Vector&lt;unsigned&gt; dof_map(n_sub_dof_types);</div>
<div class="line">   dof_map[0]=0;</div>
<div class="line">   dof_map[1]=1;</div>
<div class="line">   block_prec_pt-&gt;turn_into_subsidiary_block_preconditioner(<span class="keyword">this</span>,dof_map);    </div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Perform setup. Note that because the subsidiary</span></div>
<div class="line">   <span class="comment">// preconditioner is a block preconditioner itself it is given</span></div>
<div class="line">   <span class="comment">// the pointer to the &quot;full&quot; matrix</span></div>
<div class="line">   block_prec_pt-&gt;setup(this-&gt;matrix_pt());</div>
<div class="line">  }</div>
</div><!-- fragment --><p> The second subsidiary preconditioner is more interesting. It's a block preconditioner that only operates on a 2x2 block system, yet we want to use it to solve the linear system involving the compound block formed the three dof types 2, 3 and 4. To do this we wish to combine the dof blocks associated with dof types 2 and 3 into a single block. We start by setting the mesh pointer and by setting up the usual mapping that identifies the dof types (in the current preconditioner) that we wish the subsidiary preconditioner to act on.</p>
<div class="fragment"><div class="line">  <span class="comment">// Second subsidiary preconditioner is also a block preconditioner </span></div>
<div class="line">  {</div>
<div class="line">   SimpleTwoDofOnly&lt;CRDoubleMatrix&gt;* block_prec_pt=</div>
<div class="line">    <span class="keyword">new</span> SimpleTwoDofOnly&lt;CRDoubleMatrix&gt;;</div>
<div class="line">   Second_subsidiary_preconditioner_pt=block_prec_pt;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Set mesh</span></div>
<div class="line">   block_prec_pt-&gt;set_multi_poisson_mesh(Multi_poisson_mesh_pt);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// This is the usual mapping between the subsidiary and master dof types.</span></div>
<div class="line">   Vector&lt;unsigned&gt; dof_map(3);</div>
<div class="line">   dof_map[0]=2;</div>
<div class="line">   dof_map[1]=3;</div>
<div class="line">   dof_map[2]=4;</div>
</div><!-- fragment --><p> To combine/coarsen dof types 2 and 3 (in the current preconditioner) into a single dof type for the subsidiary preconditioner we create a vector of vectors, <code> doftype_coarsening </code> whose entries are to be interpreted as</p>
<p><code> doftype_coarsening[coarsened_dof_type][i]=dof_type</code></p>
<p>where <code>i</code> ranges from 0 to the number of dof types (minus one, because of the zero-based indexing...) in the enumeration of the subsidiary preconditioner that are to be combined/coarsened into dof type <code>coarsened_dof_type:</code> </p>
<div class="fragment"><div class="line">   <span class="comment">// The subsidiary block preconditioner SimpleTwoDofOnly accepts only two</span></div>
<div class="line">   <span class="comment">// dof types. We therefore have to &quot;coarsen&quot; the 3 dof types into two</span></div>
<div class="line">   <span class="comment">// by specifying the vector of vectors doftype_coarsening whose</span></div>
<div class="line">   <span class="comment">// entries are to be interpreted as</span></div>
<div class="line">   <span class="comment">// </span></div>
<div class="line">   <span class="comment">//    doftype_coarsening[coarsened_dof_type][i]=dof_type</span></div>
<div class="line">   <span class="comment">//</span></div>
<div class="line">   <span class="comment">// where i ranges from 0 to the number of dof types (minus one, because</span></div>
<div class="line">   <span class="comment">// of the zero-based indexing...) that are to be</span></div>
<div class="line">   <span class="comment">// combined/coarsened into dof type dof_type_in_coarsed_block_preconditioner</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Number of dof types the subsidiary block preconditioner expects.</span></div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_sub_dof_types=2;</div>
<div class="line">   Vector&lt;Vector&lt;unsigned&gt; &gt; doftype_coarsening(n_sub_dof_types);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Subsidiary dof type 0 contains 2 dof types.</span></div>
<div class="line">   doftype_coarsening[0].resize(2);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Coarsen subsidiary dof types 0 and 1 into subsidiary dof type 0.</span></div>
<div class="line">   doftype_coarsening[0][0]=0;</div>
<div class="line">   doftype_coarsening[0][1]=1;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Subsidiary dof type 1 contains 1 dof types. </span></div>
<div class="line">   doftype_coarsening[1].resize(1);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Subsidiary Dof type 1 contains subsidiary dof type 2.</span></div>
<div class="line">   doftype_coarsening[1][0]=2;</div>
</div><!-- fragment --><p> We pass both lookup schemes to the function that turns the preconditioner into a subsidiary block preconditioner and then call its own setup function, as usual.</p>
<div class="fragment"><div class="line">      </div>
<div class="line">   <span class="comment">// Turn into subdiary preconditioner</span></div>
<div class="line">   block_prec_pt-&gt;</div>
<div class="line">    turn_into_subsidiary_block_preconditioner(<span class="keyword">this</span>,dof_map,</div>
<div class="line">                                              doftype_coarsening);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Perform setup. Note that because the subsidiary</span></div>
<div class="line">   <span class="comment">// preconditioner is a block preconditioner itself it is given</span></div>
<div class="line">   <span class="comment">// the pointer to the &quot;full&quot; matrix</span></div>
<div class="line">   block_prec_pt-&gt;setup(this-&gt;matrix_pt());</div>
<div class="line">  }</div>
</div><!-- fragment --><p> Finally, we set up the of diagonal matrix-vector product which acts on the compound (0,1) block (formed from dof types {0,1}x{2,3,4}) in the current preconditioner.</p>
<div class="fragment"><div class="line">   </div>
<div class="line">   </div>
<div class="line">  <span class="comment">// Set up off diagonal matrix vector product</span></div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Get the off diagonal block.</span></div>
<div class="line">   CRDoubleMatrix block_matrix = this-&gt;get_block(0,1);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Create matrix vector product operator</span></div>
<div class="line">   Off_diagonal_matrix_vector_product_pt = <span class="keyword">new</span> MatrixVectorProduct;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Setup: Final argument indicates block column in the present</span></div>
<div class="line">   <span class="comment">// block preconditioner (which views the system matrix as comprising</span></div>
<div class="line">   <span class="comment">// 2x2 blocks).</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> block_column_index=1;</div>
<div class="line">   this-&gt;setup_matrix_vector_product(</div>
<div class="line">    Off_diagonal_matrix_vector_product_pt,&amp;block_matrix,block_column_index);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// extracted block can now go out of scope; the matrix vector product</span></div>
<div class="line">   <span class="comment">// retains its own (deep) copy.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> }<span class="comment">// End of setup</span></div>
</div><!-- fragment --><h3><a class="anchor" id="coarse_two_plus_two_plus_one__solve"></a>
The preconditioner_solve() function</h3>
<p>The <code>preconditioner_solve()</code> function is completely identical to the one used in the previous example, so we omit the code listing.</p>
<h3><a class="anchor" id="coarse_two_plus_two_plus_one_clean"></a>
The clean_up_my_memory() function</h3>
<p>Memory is cleaned up as before, so we omit the code listing.</p>
<hr  />
 <hr  />
<h2><a class="anchor" id="fsi_multiple_meshes"></a>
Using multiple meshes – explained for a genuine fluid-structure interaction problem</h2>
<p>NEW FEATURES: How to use multiple meshes</p>
<h3><a class="anchor" id="fsi_multiple_meshes_theory"></a>
Theory</h3>
<p>Finally, we demonstrate the use of multiple meshes by discussing a simple implementation of the FSI preconditioner described in the <a href="../../../preconditioners/fsi/html/index.html">FSI Preconditioner Tutorial</a>. We refer to the tutorial discussing the <a href="../../../interaction/fsi_channel_with_leaflet/html/index.html">FSI channel with leaflet problem</a> for the overall problem setup.</p>
<p>FSI problems involve fluid (velocities and pressures from the Navier-Stokes equations) and solid (the nodal positions in the solid domain) degrees of freedom (dofs). We begin by reordering the linear system to group together the two types of dof</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left[ \begin{array}{cc} F&amp;C_{fs}\\ C_{sf}&amp;S \end{array} \right] \left[ \begin{array}{c} \bf \delta f\\ \bf \delta s \end{array} \right] = - \left[ \begin{array}{c} \bf r_f\\ \bf r_s \end{array} \right] , \]" src="form_123.png" width="186" height="31"/>
</p>
<p>where <img class="formulaInl" alt="$\bf f$" src="form_124.png" width="8" height="10"/> and <img class="formulaInl" alt="$\bf s$" src="form_125.png" width="6" height="6"/> denote the fluid and solid dofs, <img class="formulaInl" alt="$F$" src="form_126.png" width="10" height="9"/> is the Navier-Stokes Jacobian (representing the derivatives of the discretised fluid equations with respect to the fluid dofs), <img class="formulaInl" alt="$S$" src="form_127.png" width="9" height="10"/> is the solid Jacobian, and the blocks <img class="formulaInl" alt="$C_{fs}$" src="form_128.png" width="19" height="14"/> and <img class="formulaInl" alt="$C_{sf}$" src="form_129.png" width="19" height="14"/> arise from the interaction between fluid and solid equations.</p>
<p>The Navier Stokes Jacobian <img class="formulaInl" alt="$F$" src="form_126.png" width="10" height="9"/> has its own block structure. Decomposing the fluid dofs into velocity and pressure dofs so that</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf f}= \left[ \begin{array}{c} \bf u\\ \bf p \end{array} \right], \]" src="form_130.png" width="61" height="31"/>
</p>
<p>we obtain the well known saddle-point structure of <img class="formulaInl" alt="$F$" src="form_126.png" width="10" height="9"/></p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ F= \left[ \begin{array}{cc} A&amp;B^T\\ B&amp; \end{array} \right], \]" src="form_131.png" width="99" height="31"/>
</p>
<p>where <img class="formulaInl" alt="$A$" src="form_132.png" width="10" height="10"/> is the momentum block, <img class="formulaInl" alt="$B^T$" src="form_133.png" width="18" height="11"/> the discrete gradient operator, and <img class="formulaInl" alt="$B$" src="form_134.png" width="10" height="10"/> the discrete divergence operator (see <a href="../../../preconditioners/lsc_navier_stokes/html/index.html">Navier Stokes Preconditioner Tutorial</a>).</p>
<p>This FSI preconditioner takes the form of a block triangular preconditioner. Here we only consider the lower block triangular version </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P_{FSI}= \left[ \begin{array}{cc} F&amp; \\ C_{sf}&amp;S \end{array} \right] \]" src="form_135.png" width="109" height="31"/>
</p>
<p> obtained by omitting the <img class="formulaInl" alt="$C_{fs}$" src="form_128.png" width="19" height="14"/> block from the Jacobian.</p>
<p>The application of the preconditioner requires the solution of the linear system</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left[ \begin{array}{cc} F&amp; \\ C_{sf}&amp;S \end{array} \right] \left[ \begin{array}{c} \bf z_f\\ \bf z_s \end{array} \right] = \left[ \begin{array}{c} \bf y_f\\ \bf y_s \end{array} \right]. \]" src="form_136.png" width="164" height="31"/>
</p>
<p>However, for preconditioning purposes this system does not have to be solved exactly. We therefore replace the solution of the linear systems involving the diagonal blocks (representing the single-physics fluid and solid Jacobians <img class="formulaInl" alt="$F$" src="form_126.png" width="10" height="9"/> and <img class="formulaInl" alt="$S$" src="form_127.png" width="9" height="10"/>) by existing preconditioners (interpreted as inexact solvers). Formally, we write this as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left[ \begin{array}{cc} \tilde F&amp; \\ C_{sf}&amp;\tilde S \end{array} \right] \left[ \begin{array}{c} \bf z_f\\ \bf z_s \end{array} \right] = \left[ \begin{array}{c} \bf y_f\\ \bf y_s \end{array} \right] . \ \ \ \ \ \ \ \ \ \ \ \ (20) \]" src="form_137.png" width="235" height="33"/>
</p>
<p>where <img class="formulaInl" alt="$ \tilde F $" src="form_138.png" width="10" height="13"/> is the fluid preconditioner and <img class="formulaInl" alt="$ \tilde{S} $" src="form_139.png" width="9" height="13"/> the solid preconditioner, both used as subsidiary preconditioners.</p>
<p>The application of the preconditioner can be accomplished in four distinct steps:</p>
<ol type="1">
<li>Apply the fluid preconditioner <img class="formulaInl" alt="$ \tilde F $" src="form_138.png" width="10" height="13"/> to the fluid dofs of the RHS vector <img class="formulaInl" alt="$ \bf y_f $" src="form_140.png" width="14" height="9"/> and store the result in the fluid solution <img class="formulaInl" alt="$ {\bf z_f}=\tilde F^{-1}{\bf y_f} $" src="form_141.png" width="65" height="15"/> .</li>
<li>Multiply the fluid-solid coupling matrix <img class="formulaInl" alt="$ C_{sf} $" src="form_142.png" width="19" height="14"/> with the fluid solution <img class="formulaInl" alt="$ \bf z_f $" src="form_143.png" width="13" height="9"/> and store the result in the temporary vector <img class="formulaInl" alt="$ {\bf w}=C_{sf}\bf z_f $" src="form_144.png" width="59" height="14"/> .</li>
<li>Subtract <img class="formulaInl" alt="$ \bf w $" src="form_145.png" width="11" height="6"/> from the solid dofs of the RHS vector <img class="formulaInl" alt="$ \bf y_s $" src="form_146.png" width="13" height="9"/> and store the result in the temporary <img class="formulaInl" alt="$ \bf w $" src="form_145.png" width="11" height="6"/> to complete the action of the <img class="formulaInl" alt="$ C_{sf} $" src="form_142.png" width="19" height="14"/> matrix vector product, <img class="formulaInl" alt="$ {\bf w}={\bf y_s}-{\bf w} $" src="form_147.png" width="66" height="9"/> .</li>
<li>Apply the solid preconditioner <img class="formulaInl" alt="$\tilde S$" src="form_148.png" width="9" height="13"/> to the temporary <img class="formulaInl" alt="$ \bf w $" src="form_145.png" width="11" height="6"/> to compute the solid solution <img class="formulaInl" alt="$ {\bf z_s}=\tilde S^{-1}{\bf w} $" src="form_149.png" width="61" height="15"/> .</li>
</ol>
<p>This is, of course, extremely similar to the methodology explained in the section <a class="el" href="index.html#two_plus_three_upper_triangular_with_sub">Using subsidiary block preconditioners</a>, the main difference being that the fluid and solid dofs are classified by two different elements. In the two-dimensional <a href="../../../interaction/fsi_channel_with_leaflet/html/index.html">FSI channel with leaflet problem</a> these are:</p><ul>
<li>The fluid elements are of type <code>RefineableQTaylorHoodElement&lt;2&gt;</code>. These elements have three types of dof; <img class="formulaInl" alt="$x$" src="form_12.png" width="8" height="6"/>-velocity dofs are labelled <code>0</code>, <img class="formulaInl" alt="$y$" src="form_23.png" width="8" height="9"/>-velocity dofs are labelled <code>1</code> and the pressure dofs are labelled <code>2</code>.<br  />
<br  />
</li>
<li>The solid elements are of type <code>FSIHermiteBeamElement</code>. <br  />
 They have one type of dof (the nodal position) labelled <code>0</code>.</li>
</ul>
<p>When classifying the dofs we specify the elements via two separate meshes, the first one containing the pointers to the fluid elements, the second one the pointers to the solid elements. This means that in the global enumeration of the dof types the fluid dofs appear before the solid dofs.</p>
<h3><a class="anchor" id="implementing_the_fsi_preconditioner"></a>
The Implementation of the FSI Preconditioner</h3>
<p>We implement the FSI preconditioner in the class <code>SimpleFSIPreconditioner</code>. This class inherits from the base class <code>BlockPreconditioner</code> which provides the generic functionality required for common block preconditioning operations.</p>
<p>The overall structure of the class is similar to that of the preconditioners considered before, the main difference being that we now store pointers to two meshes.</p>
 <div class="fragment"><div class="line"><span class="comment">//=start_of_simple_fsi_preconditioner========================================== </span></div>
<div class="line"><span class="comment">/// Simple FSI preconditioner. A block uppper triangular preconditioner</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// for the 2x2 FSI block system -- DOFs are decomposed into fluid DOFs and </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// solid DOFs. The fluid subisidiary system is solved with the </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// Navier Stokes Preconditioner and the solid subsidiary system with the</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"><span class="keyword">class </span>SimpleFSIPreconditioner </div>
<div class="line"> : <span class="keyword">public</span> <span class="keyword">virtual</span> BlockPreconditioner&lt;MATRIX&gt;</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">public :</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Constructor for SimpleFSIPreconditioner</span></div>
<div class="line"><span class="comment"></span> SimpleFSIPreconditioner(Problem* problem_pt)</div>
<div class="line">  : BlockPreconditioner&lt;MATRIX&gt;(), Navier_stokes_preconditioner_pt(0),</div>
<div class="line">    Solid_preconditioner_pt(0), Fluid_solid_coupling_matvec_pt(0),</div>
<div class="line">    Navier_stokes_mesh_pt(0), Solid_mesh_pt(0)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Create the Navier Stokes Schur Complement preconditioner</span></div>
<div class="line">   Navier_stokes_preconditioner_pt = </div>
<div class="line">    <span class="keyword">new</span> NavierStokesSchurComplementPreconditioner(problem_pt);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Create the Solid preconditioner</span></div>
<div class="line">   Solid_preconditioner_pt = <span class="keyword">new</span> SuperLUPreconditioner;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Create the matrix-vector product operator</span></div>
<div class="line">   Fluid_solid_coupling_matvec_pt = <span class="keyword">new</span> MatrixVectorProduct;</div>
<div class="line"> </div>
<div class="line">  }<span class="comment">// end_of_constructor</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Destructor: Clean up.</span></div>
<div class="line"><span class="comment"></span> ~SimpleFSIPreconditioner()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Delete the Navier-Stokes preconditioner</span></div>
<div class="line">   <span class="keyword">delete</span> Navier_stokes_preconditioner_pt; Navier_stokes_preconditioner_pt = 0;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Delete the solid preconditioner</span></div>
<div class="line">   <span class="keyword">delete</span> Solid_preconditioner_pt; Solid_preconditioner_pt = 0;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Delete the matrix vector product operator</span></div>
<div class="line">   <span class="keyword">delete</span> Fluid_solid_coupling_matvec_pt; Fluid_solid_coupling_matvec_pt = 0;</div>
<div class="line">  }</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Broken copy constructor</span></div>
<div class="line"><span class="comment"></span> SimpleFSIPreconditioner(<span class="keyword">const</span> SimpleFSIPreconditioner&amp;)</div>
<div class="line">  {</div>
<div class="line">   BrokenCopy::broken_copy(<span class="stringliteral">&quot;SimpleFSIPreconditioner&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Access function to mesh containing the block-preconditionable</span></div>
<div class="line"><span class="comment"> /// Navier-Stokes elements. </span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> set_navier_stokes_mesh(Mesh* mesh_pt) </div>
<div class="line">  {</div>
<div class="line">   Navier_stokes_mesh_pt = mesh_pt;</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Access function to mesh containing the block-preconditionable</span></div>
<div class="line"><span class="comment"> /// FSI solid elements. </span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> set_solid_mesh(Mesh* mesh_pt) </div>
<div class="line">  {</div>
<div class="line">   Solid_mesh_pt = mesh_pt;</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Setup the preconditioner</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> setup();</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Apply preconditioner to r</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> preconditioner_solve(<span class="keyword">const</span> DoubleVector &amp;r,</div>
<div class="line">                           DoubleVector &amp;z);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer the Navier Stokes preconditioner.</span></div>
<div class="line"><span class="comment"></span> NavierStokesSchurComplementPreconditioner* Navier_stokes_preconditioner_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to the solid preconditioner.</span></div>
<div class="line"><span class="comment"></span> Preconditioner* Solid_preconditioner_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to the fluid onto solid matrix vector product.</span></div>
<div class="line"><span class="comment"></span> MatrixVectorProduct* Fluid_solid_coupling_matvec_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to the navier stokes mesh.</span></div>
<div class="line"><span class="comment"></span> Mesh* Navier_stokes_mesh_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to the solid mesh.</span></div>
<div class="line"><span class="comment"></span> Mesh* Solid_mesh_pt;</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --> <h3><a class="anchor" id="setup"></a>
Preconditioner Setup</h3>
<p>We start by setting up the meshes, choosing the fluid mesh to be mesh <code>0</code> and the solid mesh to be mesh <code>1</code>. The preconditioner therefore has four dof types enumerated in mesh order:</p>
<ul>
<li><code>0</code> fluid <img class="formulaInl" alt="$x$" src="form_12.png" width="8" height="6"/> velocity (dof type 0 in mesh 0)</li>
<li><code>1</code> fluid <img class="formulaInl" alt="$y$" src="form_23.png" width="8" height="9"/> velocity (dof type 1 in mesh 0)</li>
<li><code>2</code> fluid pressure (dof type 2 in mesh 0)</li>
<li><code>3</code> solid (dof type 0 in mesh 1)</li>
</ul>
 <div class="fragment"><div class="line"><span class="comment">//=start_of_setup===============================================================</span></div>
<div class="line"><span class="comment">/// Setup the preconditioner.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//==============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> SimpleFSIPreconditioner&lt;MATRIX&gt;::setup()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// setup the meshes for BlockPreconditioner and get the number of types of</span></div>
<div class="line"> <span class="comment">// DOF assoicated with each Mesh.</span></div>
<div class="line"> <span class="comment">// Mesh 0 is the fluid mesh, and hence DOFs 0 to n_fluid_dof_type-1 </span></div>
<div class="line"> <span class="comment">// are the fluid DOFs. Mesh 1 is the solid mesh and therefore DOFs </span></div>
<div class="line"> <span class="comment">// n_fluid_dof_type to n_total_dof_type-1 are solid DOFs</span></div>
<div class="line"> <span class="comment">// set the mesh pointers</span></div>
<div class="line"> this-&gt;set_nmesh(2);</div>
<div class="line"> this-&gt;set_mesh(0,Navier_stokes_mesh_pt);</div>
<div class="line"> this-&gt;set_mesh(1,Solid_mesh_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">unsigned</span> n_fluid_dof_type = this-&gt;ndof_types_in_mesh(0);</div>
<div class="line"> <span class="keywordtype">unsigned</span> n_total_dof_type = n_fluid_dof_type + this-&gt;ndof_types_in_mesh(1);</div>
</div><!-- fragment --><p>Next we define the mapping from dof number to block number. The preconditioner has two block types &ndash; fluid and solid &ndash; therefore we group the fluid dofs into block type <code>0</code> and the solid dofs into block type <code>1</code>. We define a map from dof type to block type in a vector (the vector indices denote the dof type and the vector elements denote the block type) and pass it to <code>block_setup(...)</code> to complete the setup of the <code>BlockPreconditioner</code> infrastructure.</p>
 <div class="fragment"><div class="line"> <span class="comment">// This fsi preconditioner has two types of block -- fluid and solid.</span></div>
<div class="line"> <span class="comment">// Create a map from DOF number to block type. The fluid block is labelled</span></div>
<div class="line"> <span class="comment">// 0 and the solid block 1.</span></div>
<div class="line"> Vector&lt;unsigned&gt; dof_to_block_map(n_total_dof_type,0);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = n_fluid_dof_type; i &lt; n_total_dof_type; i++)</div>
<div class="line">  {</div>
<div class="line">   dof_to_block_map[i] = 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Call the BlockPreconditioner method block_setup(...) to assemble the data</span></div>
<div class="line"> <span class="comment">// structures required for block preconditioning.</span></div>
<div class="line"> this-&gt;block_setup(dof_to_block_map);</div>
</div><!-- fragment --><p> Next we set up the subsidiary operators required by the preconditioner. We start with the solid subsidiary preconditioner ( <img class="formulaInl" alt="$\tilde S$" src="form_148.png" width="9" height="13"/>). We extract the solid matrix block <img class="formulaInl" alt="$S$" src="form_127.png" width="9" height="10"/> from the Jacobian using the <code>BlockPreconditioner</code> method <code>get_block(...)</code> and then set up the solid subsidiary preconditioner:</p>
 <div class="fragment"><div class="line"> <span class="comment">// First the solid preconditioner</span></div>
<div class="line"> <span class="comment">//===============================</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// get the solid block matrix (1,1)</span></div>
<div class="line"> CRDoubleMatrix* solid_matrix_pt = <span class="keyword">new</span> CRDoubleMatrix;</div>
<div class="line"> this-&gt;get_block(1,1,*solid_matrix_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// setup the solid preconditioner</span></div>
<div class="line"> <span class="comment">// (perform the LU decomposition)</span></div>
<div class="line"> Solid_preconditioner_pt-&gt;setup(solid_matrix_pt);</div>
<div class="line"> <span class="keyword">delete</span> solid_matrix_pt; solid_matrix_pt = 0;</div>
</div><!-- fragment --><p> Note that, compared to the previous examples, we have used an alternative, pointer-based version of the <code>get_block(...)</code> function. However, as before, the block matrix can be deleted once the subsidiary preconditioner has been set up since the latter retains whatever data it requires.</p>
<p>The fluid subsidiary preconditioner ( <img class="formulaInl" alt="$\tilde F$" src="form_150.png" width="10" height="13"/>) a block preconditioner itself. Its setup is therefore performed in two steps:</p>
<ol type="1">
<li>First we turn the <code>NavierStokesSchurComplementPreconditioner</code> into a subsidiary block preconditioner. We assemble a list a fluid dof types in the current (master) preconditioner, and pass this list to the Navier-Stokes preconditioner to indicate that dof type <code>i</code> in the master FSI preconditioner is dof type <code>i</code> in the subsidiary fluid preconditioner (for <code>i</code> <code>=</code> <code>0</code>, <code>1</code>, <code>2</code>) (Note that the fact that this mapping is the identity mapping is a result of choosing the fluid mesh to be mesh <code>0</code>; in general the index of <code>ns_dof_list</code> corresponds to the dof type number in the Navier Stokes subsidiary preconditioner and the value corresponds to the index in this master preconditioner).  <div class="fragment"><div class="line"> <span class="comment">// Next the fluid preconditioner</span></div>
<div class="line"> <span class="comment">//==============================</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Specify the relationship between the enumeration of DOF types in the </span></div>
<div class="line"> <span class="comment">// master preconditioner and the Schur complement subsidiary preconditioner </span></div>
<div class="line"> <span class="comment">// so that ns_dof_type[i_nst] contains i_master</span></div>
<div class="line"> Vector&lt;unsigned&gt; ns_dof_list(n_fluid_dof_type);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n_fluid_dof_type; i++)</div>
<div class="line">  {</div>
<div class="line">   ns_dof_list[i] = i;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Turn the NavierStokesSchurComplement preconditioner into a subsidiary </span></div>
<div class="line"> <span class="comment">// preconditioner of this (FSI) preconditioner</span></div>
<div class="line"> Navier_stokes_preconditioner_pt-&gt;</div>
<div class="line">  turn_into_subsidiary_block_preconditioner(<span class="keyword">this</span>,ns_dof_list);</div>
</div><!-- fragment --></li>
<li>Next we set up the <code>NavierStokesSchurComplementPreconditioner</code>. We pass the Navier-Stokes mesh to the the subsidiary preconditioner and set up the preconditioner. Note that the pointer to the full FSI Jacobian is passed to the subsidiary block preconditioner. This allows the subsidiary preconditioner to extract the relevant sub-blocks, using the lookup schemes established by the call to <code>turn_into_subsidiary_block_preconditioner(...)</code>.  <div class="fragment"><div class="line"> <span class="comment">// Set up the NavierStokesSchurComplement preconditioner. </span></div>
<div class="line"> <span class="comment">// (Pass it a pointer to the Navier Stokes mesh)</span></div>
<div class="line"> Navier_stokes_preconditioner_pt-&gt;</div>
<div class="line">  set_navier_stokes_mesh(Navier_stokes_mesh_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Navier Stokes preconditioner is a subsidiary block preconditioner.</span></div>
<div class="line"> <span class="comment">// It therefore needs a pointer to the full matrix.</span></div>
<div class="line"> Navier_stokes_preconditioner_pt-&gt;setup(this-&gt;matrix_pt());</div>
</div><!-- fragment --> Finally, we set up is the matrix-vector product. This mirrors the set up of the solid subsidiary preconditioner. First the subsidiary matrix is extracted from the Jacobian and then the operator is set up:</li>
</ol>
 <div class="fragment"><div class="line"> <span class="comment">// Finally the fluid onto solid matrix vector product operator</span></div>
<div class="line"> <span class="comment">//============================================================</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Similar to the solid preconditioner get the matrix</span></div>
<div class="line"> CRDoubleMatrix* fluid_onto_solid_matrix_pt = <span class="keyword">new</span> CRDoubleMatrix;</div>
<div class="line"> this-&gt;get_block(1,0,*fluid_onto_solid_matrix_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// And setup the matrix vector product operator</span></div>
<div class="line"> this-&gt;setup_matrix_vector_product(Fluid_solid_coupling_matvec_pt,</div>
<div class="line">                                   fluid_onto_solid_matrix_pt,</div>
<div class="line">                                   0);</div>
<div class="line"> <span class="comment">// Clean up</span></div>
<div class="line"> <span class="keyword">delete</span> fluid_onto_solid_matrix_pt; fluid_onto_solid_matrix_pt = 0;</div>
</div><!-- fragment --><p> Again, the extracted block can be deleted since the matrix vector product operator retains the relevant data. The FSI preconditioner is now ready to be used.</p>
<h2><a class="anchor" id="solve"></a>
Preconditioner Solve</h2>
<p>The <code>preconditioner_solve(...)</code> method applies <br  />
 the preconditioner to the input vector <img class="formulaInl" alt="$\bf y$" src="form_151.png" width="9" height="9"/> and returns the result in <img class="formulaInl" alt="$\bf z$" src="form_6.png" width="8" height="6"/>.</p>
<p>We start by applying the Navier-Stokes preconditioner <img class="formulaInl" alt="$\tilde F$" src="form_150.png" width="10" height="13"/> to the fluid elements <code>y_f</code> of <code>y</code>. Since <img class="formulaInl" alt="$\tilde F$" src="form_150.png" width="10" height="13"/> is a subsidiary block preconditioner we apply it to the full-length <code>y</code> and <code>z</code> vectors which contain both the fluid and solid unknowns. The block preconditioning infrastructure utilised within the <code>NavierStokesSchurComplementPreconditioner</code> will ensure that the preconditioner only operates on fluid dofs.</p>
 <div class="fragment"><div class="line"><span class="comment">//=start_of_preconditioner_solve================================================</span></div>
<div class="line"><span class="comment">/// Apply preconditioner.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//==============================================================================</span></div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MATRIX&gt; </div>
<div class="line"> <span class="keywordtype">void</span> SimpleFSIPreconditioner&lt;MATRIX&gt;::preconditioner_solve(</div>
<div class="line">  <span class="keyword">const</span> DoubleVector &amp;y, DoubleVector &amp;z)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Fluid Subsidiary Preconditioner</span></div>
<div class="line"> <span class="comment">//=================================</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Start by applying the Fluid subsidiary preconditioner</span></div>
<div class="line"> <span class="comment">// The fluid subsidiary preconditioner is a block preconditioner and</span></div>
<div class="line"> <span class="comment">// hence we pass it the global residual and solution vectors (y and z)</span></div>
<div class="line"> Navier_stokes_preconditioner_pt-&gt;preconditioner_solve(y,z);</div>
</div><!-- fragment --><p> The fluid elements <code>z_f</code> of the vector <code>z</code> will now have been updated to contain the action of the SchurComplement preconditioner on the fluid elements <code>y_f</code> of the vector <code>y</code>.</p>
<p>To apply the fluid-solid coupling matrix vector product <img class="formulaInl" alt="$C_{sf}$" src="form_129.png" width="19" height="14"/>, we copy the fluid elements from <code>z</code> into another vector <code>z_f</code>. We then apply the matrix-vector product operator to <code>z_f</code> and store the result in a vector <code>w</code>. Finally, we subtract <code>w</code> from the solid residuals <code>y_s</code> and store the result in <code>w</code> to complete the application of the matrix-vector product.</p>
 <div class="fragment"><div class="line"> <span class="comment">// Fluid Onto Solid Matrix Vector Product Operator</span></div>
<div class="line"> <span class="comment">//================================================</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// The vector z_f contains the result of the action of the </span></div>
<div class="line"> <span class="comment">// NavierStokesPreconditioner on a subset of  the elements of z.</span></div>
<div class="line"> <span class="comment">// Remember the fluid block index is 0 and the solid block index is 1.</span></div>
<div class="line"> DoubleVector z_f;</div>
<div class="line"> this-&gt;get_block_vector(0,z,z_f);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Apply the matrix vector product to z_f and store the results in w</span></div>
<div class="line"> DoubleVector w;</div>
<div class="line"> Fluid_solid_coupling_matvec_pt-&gt;multiply(z_f,w);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// The vector y_s contains the solid residuals</span></div>
<div class="line"> DoubleVector y_s;</div>
<div class="line"> this-&gt;get_block_vector(1,y,y_s);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Subtract the action of the fluid onto solid matrix vector product from y_s</span></div>
<div class="line"> y_s -= w;</div>
<div class="line"> w = y_s; </div>
</div><!-- fragment --><p>Finally, we apply the solid subsidiary preconditioner <img class="formulaInl" alt="$\tilde S$" src="form_148.png" width="9" height="13"/> to <code>w</code> and return the result to <code>z</code>. We note that because the solid subsidiary preconditioner is not a block preconditioner, the preconditioner solve method must be called with the solid block vectors. The result is then copied to the full-length vector <code>z</code> which contains the fluid and solid dofs.</p>
 <div class="fragment"><div class="line"> <span class="comment">// Solid Subsidiary Preconditioner</span></div>
<div class="line"> <span class="comment">//================================</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Apply the solid preconditioner to s and return the result to the </span></div>
<div class="line"> <span class="comment">// global solution vector z</span></div>
<div class="line"> DoubleVector z_s;</div>
<div class="line"> Solid_preconditioner_pt-&gt;preconditioner_solve(w,z_s);</div>
<div class="line"> this-&gt;return_block_vector(1,z_s,z);</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="para"></a>
Parallelisation</h1>
<p>We note that the above discussion did not address the parallelisation of the preconditioners. This is because all the required parallel features are "hidden" within the block preconditioning framework which relies heavily on the library's <a href="../../../mpi/distributed_linear_algebra_infrastructure/html/index.html">distributed linear algebra infrastructure.</a> Any of the preconditioners discussed in this tutorial can therefore be used without change when <code>oomph-lib</code> is compiled with MPI support and if the the executable is run on multiple processes.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source file for the simple block diagonal preconditioner for the linear elasticity problem is <center> <a href="../../../../demo_drivers/linear_solvers/simple_block_preconditioners.h">demo_drivers/linear_solvers/simple_block_preconditioners.h </a> </center> <br  />
</li>
<li>The driver code demonstrating the use of the simple block diagonal preconditioner for the linear elasticity problem is <center> <a href="../../../../demo_drivers/linear_solvers/two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc">demo_drivers/linear_solvers/two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc </a> </center> <br  />
</li>
<li>The source files for the "multi-poisson" preconditioners and the serial driver codes are located in the directory: <center> <a href="../../../../demo_drivers/linear_solvers/">demo_drivers/linear_solvers/ </a> </center> <br  />
</li>
<li>The serial "multi-poisson" driver code (which demonstrates the use of the various "multi-poisson" preconditioners discussed above) is: <center> <a href="../../../../demo_drivers/linear_solvers/two_d_multi_poisson.cc">demo_drivers/poisson/two_d_multi_poisson.cc </a> </center> <br  />
</li>
<li>The parallel counterpart is here (note that, as claimed, this code uses exactly the same preconditioners as the serial version): <center> <a href="../../../../demo_drivers/mpi/solvers/two_d_multi_poisson.cc">demo_drivers/mpi/solvers/two_d_multi_poisson.cc </a> </center> <br  />
</li>
<li>The (parallel) driver code which demonstrates the implementation and use of the simple FSI preconditioner (for the "channel with leaflet" problem) is here: <center> <a href="../../../../demo_drivers/mpi/solvers/fsi_channel_with_leaflet.cc">demo_drivers/mpi/solvers/fsi_channel_with_leaflet.cc </a> </center> <br  />
</li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:38:28
        </div>
      </div>
    </footer>
</body>
</html>
