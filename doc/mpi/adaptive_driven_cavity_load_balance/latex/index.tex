In this tutorial we demonstrate how to perform load balancing to (re-\/)distribute elements between processors in parallel, distributed computations. Following a brief discussion of the underlying methodology, we illustrate the application in the \href{../../../navier_stokes/adaptive_driven_cavity/html/index.html}{\texttt{ adaptive driven cavity problem}} where the spatially non-\/uniform refinement of the mesh leads to a significant load imbalance.

Most of the driver code is identical to the codes discussed in the tutorials explaining the \href{../../../navier_stokes/adaptive_driven_cavity/html/index.html}{\texttt{ serial}} and \href{../../adaptive_driven_cavity/html/index.html}{\texttt{ distributed, parallel }} solution of the problem. Therefore we only discuss the changes required to perform load balancing on the problem.

\DoxyHorRuler{0}
\hypertarget{index_load_balance}{}\doxysection{Load balancing}\label{index_load_balance}
The initial distribution of a problem via a call to 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::distribute(...)}

\end{DoxyCode}
 attempts to distribute the elements in the Problem\textquotesingle{}s mesh over the available processors such that (i) each processor stores approximately the same number of elements and (ii) the anticipated volume of inter-\/processor communication required to synchronise the solution across processor boundaries is minimised. Typically, this procedure works very well in the sense that the assembly times for the Jacobian matrix in a distributed computation scale extremely well with the number of processors.

A re-\/distribution of elements may be required because
\begin{DoxyEnumerate}
\item strongly non-\/uniform mesh adaptation may lead to a drastic increase in the number of elements on some processors; ~\newline
~\newline

\item in multi-\/physics computations the cpu times required to compute the elements\textquotesingle{} contributions to the global Jacobian matrix may differ significantly between different element types. In such cases, the mere equidistribution of elements between processors will not achieve good parallel scaling; ~\newline
~\newline

\item when restarting a computation on a larger number of processors, elements need to be re-\/distributed to populate the (otherwise empty) additional processors.
\end{DoxyEnumerate}As with other methods within {\ttfamily oomph-\/lib}, load balancing is implemented such that only minimal user intervention is required. The function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::load\_balance() }

\end{DoxyCode}
 may be called at any point following the distribution of the problem. The only change required to an existing driver code is the provision (via overloading of a broken virtual function in the Problem base class) of the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::build\_mesh()}

\end{DoxyCode}
 This function must
\begin{DoxyEnumerate}
\item Build the mesh (and in the case of multiple sub-\/meshes, build these and combine them to a global mesh using the {\ttfamily Problem\+::build\+\_\+global\+\_\+mesh()} function). ~\newline
~\newline

\item Complete the build of the elements by setting pointers to physical parameters (such as Reynolds numbers) or functions (such as source function pointers), etc. ~\newline
~\newline

\item Apply the boundary conditions. ~\newline
~\newline

\item Perform any uniform mesh refinement that was applied before calling {\ttfamily Problem\+::distribute()}.
\end{DoxyEnumerate}Typically this requires no more than a straightforward cut-\/and-\/paste of code from the problem constructor into the {\ttfamily Problem\+::build\+\_\+mesh()} function; see also the discussion \mbox{\hyperlink{index_What}{What goes into the build\+\_\+mesh() function?}} for more details.

The load balancing routines then perform the following steps\+:
\begin{DoxyEnumerate}
\item Take the current (distributed) global mesh, and calculate a new partition for each of the current elements, taking into account the cpu time that each element spent on the most recent computation of its contribution to the problem\textquotesingle{}s Jacobian matrix. ~\newline
~\newline

\item Build a new (global) mesh using the {\ttfamily Problem\+::build\+\_\+mesh()} function. ~\newline
~\newline

\item Distribute the new (global) mesh according to the new partitioning. ~\newline
~\newline

\item Once distributed, refine the new (global) mesh on each processor to achieve the same refinement pattern as in the original problem. ~\newline
~\newline

\item Copy the {\ttfamily Data} values from the old to the new (global) meshes. ~\newline
~\newline

\end{DoxyEnumerate}We note that for \char`\"{}structured\char`\"{} meshes (i.\+e. meshes whose refinement pattern is represented by \href{../../../the_data_structure/html/index.html\#RefineableQuadMesh_setup_section}{\texttt{ \char`\"{}tree forests\char`\"{}}}) only complete trees can be moved between processors. If the mesh was refined uniformly after being distributed, a more fine-\/grained tree-\/forest (which may allow better load balancing) can be built by calling {\ttfamily Problem\+::prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes()} as discussed in \href{../../../mpi/general_mpi/html/index.html\#how_it_works}{\texttt{ another tutorial.}} \DoxyHorRuler{0}
\hypertarget{index_example}{}\doxysection{An example\+: Revisiting the adaptive driven cavity problem}\label{index_example}
In this section we outline the required changes to the \href{../../adaptive_driven_cavity/html/index.html}{\texttt{ parallel version of the adaptive driven cavity problem}} so that the problem can use the load balancing method described above.

The figure below demonstrates the advantages of load balancing in that problem\+: The left hand panel shows the distribution of the mesh across four processors (indicated by the colours) after three spatially adaptive solves. Note how the singularities in the bottom corners result in a strongly non-\/uniform spatial refinement which leads to a significant load imbalance because the \char`\"{}pink\char`\"{} and \char`\"{}grey\char`\"{} processors contain far more elements than then \char`\"{}green\char`\"{} and \char`\"{}cyan\char`\"{} ones. The right hand panel shows the distribution of the mesh across four processors when load balancing is performed in between the second and third mesh adaptation.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{load_balance_partition}
\doxyfigcaption{Plot illustrating the distribution of the mesh for the adaptive driven cavity problem, both without (left image) and with (right image) the use of load balancing. }
\end{DoxyImage}
\hypertarget{index_build_mesh}{}\doxysubsection{The build\+\_\+mesh() function}\label{index_build_mesh}
As discussed above, the function {\ttfamily Problem\+::build\+\_\+mesh()} is created most easily by moving the code that (i) creates the mesh, (ii) applies the relevant boundary conditions, and (iii) completes the build of all the elements in the problem from the problem constructor.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_build\_mesh===================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Build the mesh for RefineableDrivenCavity problem }}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{///}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} RefineableDrivenCavityProblem<ELEMENT>::build\_mesh()}
\DoxyCodeLine{\{ }
\DoxyCodeLine{ \textcolor{comment}{// Setup mesh}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// \# of elements in x-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_x=10;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// \# of elements in y-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_y=10;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Domain length in x-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} l\_x=1.0;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Domain length in y-\/direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} l\_y=1.0;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Build and assign mesh}}
\DoxyCodeLine{ Problem::mesh\_pt() = }
\DoxyCodeLine{  \textcolor{keyword}{new} RefineableRectangularQuadMesh<ELEMENT>(n\_x,n\_y,l\_x,l\_y);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set error estimator}}
\DoxyCodeLine{ Z2ErrorEstimator* error\_estimator\_pt=\textcolor{keyword}{new} Z2ErrorEstimator;}
\DoxyCodeLine{ \textcolor{keyword}{dynamic\_cast<}RefineableRectangularQuadMesh<ELEMENT>*\textcolor{keyword}{>}(mesh\_pt())-\/>}
\DoxyCodeLine{  spatial\_error\_estimator\_pt()=error\_estimator\_pt;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Fine tune error targets to get "{}interesting"{} refinement pattern}}
\DoxyCodeLine{ \textcolor{keyword}{dynamic\_cast<}RefineableRectangularQuadMesh<ELEMENT>*\textcolor{keyword}{>}(mesh\_pt())-\/>}
\DoxyCodeLine{  max\_permitted\_error()=1.0e-\/5;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{keyword}{dynamic\_cast<}RefineableRectangularQuadMesh<ELEMENT>*\textcolor{keyword}{>}(mesh\_pt())-\/>}
\DoxyCodeLine{  min\_permitted\_error()=1.0e-\/6;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}}
\DoxyCodeLine{ \textcolor{comment}{// free by default -\/-\/ just pin the ones that have Dirichlet conditions}}
\DoxyCodeLine{ \textcolor{comment}{// here: All boundaries are Dirichlet boundaries.}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} num\_bound = mesh\_pt()-\/>nboundary();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()-\/>nboundary\_node(ibound);}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{comment}{// Loop over values (u and v velocities)}}
\DoxyCodeLine{     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<2;i++)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       mesh\_pt()-\/>boundary\_node\_pt(ibound,inod)-\/>pin(i); }
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \} \textcolor{comment}{// end loop over boundaries}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{//Find number of elements in mesh}}
\DoxyCodeLine{ \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_element = mesh\_pt()-\/>nelement();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Loop over the elements to set up element-\/specific }}
\DoxyCodeLine{ \textcolor{comment}{// things that cannot be handled by constructor: Pass pointer to Reynolds}}
\DoxyCodeLine{ \textcolor{comment}{// number}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Upcast from GeneralisedElement to the present element}}
\DoxyCodeLine{   ELEMENT* el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()-\/>element\_pt(e));}
\DoxyCodeLine{   \textcolor{comment}{//Set the Reynolds number}}
\DoxyCodeLine{   el\_pt-\/>re\_pt() = \&Global\_Physical\_Variables::Re;}
\DoxyCodeLine{  \} \textcolor{comment}{// end loop over elements}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Pin pressure at origin no matter which processor contains that node}}
\DoxyCodeLine{ pin\_only\_pressure\_at\_origin();}
\DoxyCodeLine{}
\DoxyCodeLine{\}\textcolor{comment}{// end\_of\_build\_mesh}}

\end{DoxyCodeInclude}
 \hypertarget{index_problem_constructor}{}\doxysubsection{Changes to the problem constructor}\label{index_problem_constructor}
The problem constructor becomes very short since the bulk of the code has been moved into the {\ttfamily Problem\+::build\+\_\+mesh()} function.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_constructor==================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Constructor for RefineableDrivenCavity problem }}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{///}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{RefineableDrivenCavityProblem<ELEMENT>::RefineableDrivenCavityProblem()}
\DoxyCodeLine{\{ }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set output directory}}
\DoxyCodeLine{ Doc\_info.set\_directory(\textcolor{stringliteral}{"{}RESLT\_LOAD\_BALANCE"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Build the mesh}}
\DoxyCodeLine{ build\_mesh();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup equation numbering scheme}}
\DoxyCodeLine{ cout <<\textcolor{stringliteral}{"{}Number of equations: "{}} << assign\_eqn\_numbers() << std::endl; }
\DoxyCodeLine{ }
\DoxyCodeLine{\} \textcolor{comment}{// end\_of\_constructor}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
\hypertarget{index_customising_load_balance}{}\doxysection{Customising the load balancing}\label{index_customising_load_balance}
The \href{../../../../demo_drivers/mpi/distribution/adaptive_driven_cavity/adaptive_driven_cavity_load_balance.cc}{\texttt{ driver code}} demonstrates some of the different options available for the {\ttfamily Problem\+::load\+\_\+balance(...)} function.
\begin{DoxyItemize}
\item Passing a boolean argument to {\ttfamily Problem\+::load\+\_\+balance(...)} enables the output of extended statistics. ~\newline
~\newline

\item By default, the mesh partitioning for the initial problem distribution and any subsequent load balancing operations is determined by METIS. Unfortunately, METIS is not completely deterministic. This makes it difficult to compute reference data that can be used to assert the correct execution of the code during self-\/tests. When the driver code is run with the {\ttfamily --validate} command line flag, we therefore call the {\ttfamily Problem\+::distribute(...)} function with a pre-\/determined (and deterministic but non-\/optimal) distribution of the elements. The use of METIS during the load balancing operations can be bypassed by calling 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::set\_default\_partition\_in\_load\_balance()}

\end{DoxyCode}

\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comm_and_ex}{}\doxysection{Comments and Exercises}\label{index_comm_and_ex}
\hypertarget{index_comm}{}\doxysubsection{Comments}\label{index_comm}
\hypertarget{index_What}{}\doxysubsubsection{What goes into the build\+\_\+mesh() function?}\label{index_What}
The main rule regarding what should (and should not) be moved from the problem constructor into the {\ttfamily build\+\_\+mesh()} function is that following the return from the {\ttfamily build\+\_\+mesh()} function, all meshes should be re-\/generated (and refined to the same degree as when {\ttfamily Problem\+::distribute()} was called), their constituent elements made fully functional, and all boundary conditions applied.

It is {\bfseries{not}} necessary (and would, in fact, be undesirable) to re-\/create {\ttfamily Timesteppers} and/or {\ttfamily Geom\+Objects} that are used to define curvilinear mesh boundaries. We recommend generating such objects once (in the Problem constructor) and making them available to the {\ttfamily build\+\_\+mesh()} function by storing pointers to them in the problem\textquotesingle{}s private member data.

It is not necessary to re-\/generate the error estimator, though the pointer to it (and any non-\/default target errors) need to be passed to all (newly re-\/generated) adaptive meshes.\hypertarget{index_pointers}{}\doxysubsubsection{Updating pointers}\label{index_pointers}
Since load balancing re-\/generates the meshes -- and thus their constituent elements and nodes -- pointers to such objects must be re-\/assigned on return from {\ttfamily Problem\+::load\+\_\+balance()}. In our experience such pointers tend to be used predominantly in
\begin{DoxyItemize}
\item Post-\/processing functions (e.\+g. to document the solution at a fixed node) ~\newline
~\newline

\item Multi-\/physics/block preconditioners which tend to use pointers to meshes to classify the degrees of freedom. ~\newline
~\newline

\end{DoxyItemize}Failure to re-\/assign any dangling pointers will cause segmentation faults -- recompile {\ttfamily oomph-\/lib} with debugging enabled and use \href{http://www.gnu.org/software/ddd}{\texttt{ ddd}} to see where the code crashes.\hypertarget{index_ex}{}\doxysubsection{Exercises}\label{index_ex}

\begin{DoxyEnumerate}
\item Explore what happens if you \char`\"{}forget\char`\"{} to implement the {\ttfamily Problem\+::build\+\_\+mesh()} function (e.\+g. by renaming it {\ttfamily my\+\_\+build\+\_\+mesh()}, say, so that it no longer overloads the function the {\ttfamily Problem} base class. ~\newline
~\newline

\item The {\ttfamily Problem\+::build\+\_\+mesh()} shown above (accidentally) illustrates a common problem with a mere cut-\/and-\/paste approach -- it creates a memory leak! Where is it and how would you fix it? ~\newline
~\newline

\item The {\ttfamily demo\+\_\+drivers} directory contains a few additional driver codes that employ load balancing. These codes exist mainly for self-\/test purposes and do not have separate tutorials. It may be instructive to compare the different versions of these codes to further clarify the modifications required to enable load balancing. We suggest you compare ~\newline
~\newline

\begin{DoxyItemize}
\item The original version of the distributed, adaptive driven cavity code ~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/mpi/distribution/adaptive_driven_cavity/adaptive_driven_cavity.cc}{\texttt{ demo\+\_\+drivers/mpi/distribution/adaptive\+\_\+driven\+\_\+cavity/adaptive\+\_\+driven\+\_\+cavity.\+cc }} \end{center}  ~\newline
~\newline
 and the version with load balancing ~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/mpi/distribution/adaptive_driven_cavity/adaptive_driven_cavity_load_balance.cc}{\texttt{ demo\+\_\+drivers/mpi/distribution/adaptive\+\_\+driven\+\_\+cavity/adaptive\+\_\+driven\+\_\+cavity\+\_\+load\+\_\+balance.\+cc }} \end{center}  ~\newline
~\newline

\item The original version of the distributed code for the doubly-\/adaptive solution of the unsteady heat equation, ~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/unsteady_heat/two_d_unsteady_heat_2adapt/two_d_unsteady_heat_2adapt.cc}{\texttt{ demo\+\_\+drivers/unsteady\+\_\+heat/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+2adapt/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+2adapt.\+cc }} \end{center}  ~\newline
~\newline
 and the version with load balancing ~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/mpi/distribution/restart/two_d_unsteady_heat_2adapt_load_balance.cc}{\texttt{ demo\+\_\+drivers/mpi/distribution/restart/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+2adapt\+\_\+load\+\_\+balance.\+cc }} \end{center}  ~\newline
~\newline

\item The original version of the distributed code for the solution of Turek \& Hron\textquotesingle{}s FSI benchmark problem heat equation, ~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/mpi/multi_domain/turek_flag/turek_flag.cc}{\texttt{ demo\+\_\+drivers/mpi/multi\+\_\+domain/turek\+\_\+flag/turek\+\_\+flag.\+cc }} \end{center}  ~\newline
~\newline
 and the version with load balancing ~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/mpi/multi_domain/turek_flag/turek_flag_load_balance.cc}{\texttt{ demo\+\_\+drivers/mpi/multi\+\_\+domain/turek\+\_\+flag/turek\+\_\+flag\+\_\+load\+\_\+balance.\+cc }} \end{center}  ~\newline
~\newline

\end{DoxyItemize}Comparing the codes with sdiff is particularly instructive.
\end{DoxyEnumerate}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/mpi/distribution/adaptive_driven_cavity}{\texttt{ demo\+\_\+drivers/mpi/distribution/adaptive\+\_\+driven\+\_\+cavity }} \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/mpi/distribution/adaptive_driven_cavity/adaptive_driven_cavity_load_balance.cc}{\texttt{ demo\+\_\+drivers/mpi/distribution/adaptive\+\_\+driven\+\_\+cavity/adaptive\+\_\+driven\+\_\+cavity\+\_\+load\+\_\+balance.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{PDF file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
