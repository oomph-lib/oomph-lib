The purpose of this document is to provide a \char`\"{}quick\char`\"{} introduction to the fundamental objects in {\ttfamily oomph-\/lib}. Assuming that you
\begin{DoxyItemize}
\item have a basic understanding of the finite element method
\end{DoxyItemize}and
\begin{DoxyItemize}
\item are reasonably familiar with object-\/oriented programming in C++,
\end{DoxyItemize}the Quick Guide should enable you to solve basic PDE problems using {\ttfamily oomph-\/lib}. You should also consult the extensive \href{../../example_code_list/html/index.html}{\texttt{ list of example codes}} distributed with the library.\hypertarget{index_main_how_to}{}\doxysection{How to solve simple PDEs with oomph-\/lib}\label{index_main_how_to}
To solve a given PDE with {\ttfamily oomph-\/lib}, its discretisation needs to be specified in a {\ttfamily Problem} object. This usually involves the specification of the {\ttfamily Mesh} and the element types, followed by the application of the boundary conditions. If these steps are performed in the {\ttfamily Problem} constructor, the driver code itself can be as simple as\+:  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{comment}{//Build the problem }}
\DoxyCodeLine{  DemoPoissonProblem problem;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{//Solve the problem, using Newton's method}}
\DoxyCodeLine{  problem.newton\_solve();}
\DoxyCodeLine{}
\DoxyCodeLine{ \}}

\end{DoxyCodeInclude}
 The amount of work required to represent a given PDE as a {\ttfamily Problem} object is problem-\/dependent\+:
\begin{DoxyItemize}
\item If {\ttfamily oomph-\/lib\textquotesingle{}s} existing {\ttfamily Mesh} objects and element types are sufficient to discretise the problem, the generation of a fully-\/functional {\ttfamily Problem} object is straightforward. We shall discuss this case in the section \mbox{\hyperlink{index_problem}{How to build a Problem}}.
\item If {\ttfamily oomph-\/lib} provides the required element type but none of the available meshes are suitable, you will have to write your own {\ttfamily Mesh} object. We shall discuss this in the section \mbox{\hyperlink{index_mesh}{How to build a Mesh}}. It is also possible to create {\ttfamily oomph-\/lib} meshes based on the output from third-\/party (commercial) mesh generators. This is illustrated in \href{../../meshes/third_party_meshes/html/index.html}{\texttt{ another example.}}
\item Finally, the problem might involve a PDE for which {\ttfamily oomph-\/lib} does not provide any suitable elements. In this case you will need to write your own element. When implementing elements in {\ttfamily oomph-\/lib} the element formulation is generally sub-\/divided into (at least) two levels. Geometric elements implement the element geometry (e.\+g. 2D quad elements, 3D brick elements, etc); these geometric elements act as base classes for specific {\ttfamily Finite\+Elements} that implement the discretisation of particular PDEs. We discuss the implementation of the two types of elements in two separate sections\+:
\begin{DoxyItemize}
\item In the section \mbox{\hyperlink{index_FEequations}{How to implement a new system of equations as a specific Finite\+Element}} we describe how to discretise a new system of equations, using existing geometric elements.
\item In the section \mbox{\hyperlink{index_FEgeom}{How to build a new geometric element}} we discuss how to formulate new geometric elements.
\end{DoxyItemize}
\end{DoxyItemize}In all cases, we start with a brief description of the minimum functionality that must be implemented for the various objects. The general principles are then illustrated by considering the discretisation of the model problem

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{One-\/dimensional model Poisson problem}} \end{center}   Solve \[ \frac{\mbox{d}^2u}{\mbox{d}x^2} = \pm 30 \sin(\sqrt{30} x), \ \ \ \ \ \ \ \ \ \ (1) \] in the one-\/dimensional domain $x\in[0,1]$, subject to \[ u(0)=0 \ \mbox{\ \ \ and \ \ \ } \ \ u(1)=\mp 1, \ \ \ \ \ \ \ \ \ \ (2) \]    \\\cline{1-1}
\end{longtabu}
\end{center} 

by isoparametric two-\/node elements. (Please consult the \href{../../intro/html/index.html}{\texttt{ Introduction}} for a review of the relevant finite element theory.) The source code for this example (\href{../../../demo_drivers/poisson/one_d_poisson_generic_only/one_d_poisson_generic_only.cc}{\texttt{ one\+\_\+d\+\_\+poisson\+\_\+generic\+\_\+only.\+cc}}) is self-\/contained and uses only objects from the \char`\"{}generic\char`\"{} part of the {\ttfamily oomph-\/lib} library. \mbox{[}{\ttfamily oomph-\/lib} does, of course, provide 1D meshes and Poisson elements but we deliberately ignore these because we wish to illustrate how to build such objects from scratch. The alternative example code \href{../../../demo_drivers/poisson/one_d_poisson/one_d_poisson.cc}{\texttt{ one\+\_\+d\+\_\+poisson.\+cc}}, discussed in \href{../../poisson/one_d_poisson/html/index.html}{\texttt{ another example}} illustrates the implementation of the same problem using existing library objects.\mbox{]}

The main purpose of this document is to provide a {\itshape \char`\"{}quick\char`\"{}} introduction to {\ttfamily oomph-\/lib\textquotesingle{}s} fundamental objects, so the example classes presented below are fully-\/functional but very basic. We provide exercises at the end of each section to allow the reader to explore various straightforward improvements, most of which are implemented in the corresponding objects in the library. Finally, the section \mbox{\hyperlink{index_comments}{Further comments}} provides a discussion of some general design principles that should be respected when creating new classes for use with the library.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_problem}{}\doxysection{How to build a Problem}\label{index_problem}
All specific {\ttfamily Problems} should be implemented as objects that inherit from the generic {\ttfamily Problem} class. These specific {\ttfamily Problem} objects will vary considerably depending on the exact details of the problem being solved.

Only a few member functions {\itshape must} be implemented for each specific {\ttfamily Problem} class\+:
\begin{DoxyItemize}
\item The problem constructor 
\begin{DoxyCode}{0}
\DoxyCodeLine{SomeSpecificProblem(...) }

\end{DoxyCode}

\item and the member functions 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::actions\_before\_newton\_solve() }

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::actions\_after\_newton\_solve() }

\end{DoxyCode}

\end{DoxyItemize}\hypertarget{index_spec}{}\doxysubsection{The constructor\+: Some\+Specific\+Problem(...)}\label{index_spec}
The Problem constructor {\ttfamily Some\+Specific\+Problem(...)} usually contains the following steps\+:
\begin{DoxyItemize}
\item Construction of the timestepper (if required), e.\+g. 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::add\_time\_stepper\_pt(\textcolor{keyword}{new} SomeTimeStepper()); }

\end{DoxyCode}
 ~\newline

\item Construction of the {\ttfamily Mesh} (which may involve passing a particular element type as a template parameter), e.\+g. 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::mesh\_pt() = \textcolor{keyword}{new} SomeMesh<SomeElement>(...); }

\end{DoxyCode}

\item Specification of the boundary conditions. By default, all nodal values are assumed to be free and their values are initialised to zero. Therefore, we only need to \char`\"{}pin\char`\"{} the values that are prescribed by boundary conditions and assign any nonzero boundary values. For instance, the following instruction \char`\"{}pins\char`\"{} the (single) nodal value at node \char`\"{}0\char`\"{}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::mesh\_pt()-\/>node\_pt(0)-\/>pin(0); }

\end{DoxyCode}
 A non-\/zero boundary value can be set by 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::mesh\_pt()-\/>node\_pt(0)-\/>set\_value(0,1.0); }

\end{DoxyCode}
 This statement sets the first (= zero-\/th in C++\textquotesingle{}s zero-\/based indexing) nodal value to 1.\+0.
\item Completion of the build of the elements\+: Elements are typically constructed during the mesh generation process. To allow a generic implementation of this process, mesh constructors use an argument-\/free constructor to create the elements. Thus, element constructors must not have any arguments. (See the section `new\+\_\+mesh\&rsquo;, below, for an illustration of this process.) If an element requires any global parameters (such as pointers to physical parameters, function pointers to source functions, etc.), these parameters should be passed to the element via suitable access functions, {\itshape after} the element has been created by the mesh constructor.
\item Assignment of the global and local equation numbers 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::assign\_eqn\_numbers(); }

\end{DoxyCode}

\end{DoxyItemize}\hypertarget{index_actbef}{}\doxysubsection{The function Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve()}\label{index_actbef}
{\ttfamily oomph-\/lib} treats all problems as non-\/linear problems and employs Newton\textquotesingle{}s method to solve the system of nonlinear algebraic equations that results from its spatial (and, in time-\/dependent problems, temporal) discretisation. Within this framework, linear problems are special cases for which Newton\textquotesingle{}s method converges in one step.

The (pure virtual) member function {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve()} should contain everything that {\itshape must} be done before a nonlinear solve to complete the specification of the problem. For example, the function may contain a call to update the boundary conditions. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} actions\_before\_newton\_solve() \{update\_boundary\_conditions();\}}

\end{DoxyCode}


If desired, finer granularity may be obtained by overloading the empty virtual functions {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()}, {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+step()} and/or {\ttfamily Problem\+::actions\+\_\+before\+\_\+implicit\+\_\+timestep()}, which are executed before each calculation of the maximum value of the residuals, each Newton step or each timestep, respectively. We refer to a \href{../../order_of_action_functions/html/index.html}{\texttt{ separate document}} for a more detailed discussion of the various \char`\"{}action functions\char`\"{} executed by {\ttfamily oomph-\/lib\textquotesingle{}s} Newton solver.\hypertarget{index_actafter}{}\doxysubsection{The function Problem\+::actions\+\_\+after\+\_\+newton\+\_\+solve()}\label{index_actafter}
The (pure virtual) member function {\ttfamily Problem\+::actions\+\_\+after\+\_\+newton\+\_\+solve()} should contain everything that is to take place after each nonlinear solve. For example, the function might contain commands to update the values of any \char`\"{}dependent\char`\"{} variables, or post-\/processing commands. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} actions\_after\_newton\_solve()}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{comment}{//Update value of the slave variable in namespace GlobalVariables}}
\DoxyCodeLine{  GlobalVariables::slave = node\_pt(0)-\/>value(0) + node\_pt(0)-\/>value(1);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{//Call the output function}}
\DoxyCodeLine{  ofstream output\_file(\textcolor{stringliteral}{"{}result.dat"{}});}
\DoxyCodeLine{  output(output\_file); }
\DoxyCodeLine{ \}}

\end{DoxyCode}


Again, the finer-\/grained member functions {\ttfamily Problem\+::actions\+\_\+after\+\_\+newton\+\_\+step()} and ~\newline
 {\ttfamily Problem\+::actions\+\_\+after\+\_\+implicit\+\_\+timestep()} are provided.

\DoxyHorRuler{0}
\hypertarget{index_full}{}\doxysubsection{An example of a \char`\"{}complete\char`\"{} specific Problem}\label{index_full}
Here is the full specification for the {\ttfamily Demo\+Poisson\+Problem} class (taken from \href{../../../demo_drivers/poisson/one_d_poisson_generic_only/one_d_poisson_generic_only.cc}{\texttt{ one\+\_\+d\+\_\+poisson\+\_\+generic\+\_\+only.\+cc}}) which implements the discretisation of the 1D Poisson problem described above, using a {\ttfamily Mesh} of type {\ttfamily One\+Dim\+Mesh}, with elements of type {\ttfamily Two\+Node\+Poisson\+Elements}.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{keyword}{class }DemoPoissonProblem : \textcolor{keyword}{public} Problem }
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{  /// Problem constructor: Pass the sign of the source function (default}}
\DoxyCodeLine{\textcolor{comment}{  /// is +1)}}
\DoxyCodeLine{\textcolor{comment}{}  DemoPoissonProblem(\textcolor{keyword}{const} \textcolor{keywordtype}{int}\& sign=1) : Sign(sign)}
\DoxyCodeLine{   \{}
\DoxyCodeLine{    \textcolor{comment}{//Create a OneDimMesh Mesh object and set it to be the problem's mesh.}}
\DoxyCodeLine{    \textcolor{comment}{//The element type, TwoNodePoissonElement, is passed  as a template }}
\DoxyCodeLine{    \textcolor{comment}{//parameter to the mesh. The argument to the constructor indicates}}
\DoxyCodeLine{    \textcolor{comment}{//the number of elements in the mesh.}}
\DoxyCodeLine{    Problem::mesh\_pt() = \textcolor{keyword}{new} OneDimMesh<TwoNodePoissonElement>(10);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//Pin the unknowns at the ends of the 1D domain:}}
\DoxyCodeLine{    \textcolor{comment}{//The 1D mesh has 2 boundaries, each of which contains a single node;}}
\DoxyCodeLine{    \textcolor{comment}{//the nodes on the boundary are available from Mesh::boundary\_node\_pt(...)}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//Pin the single nodal value at the single node on mesh }}
\DoxyCodeLine{    \textcolor{comment}{//boundary 0 (= the left domain boundary at x=0)}}
\DoxyCodeLine{    mesh\_pt()-\/>boundary\_node\_pt(0,0)-\/>pin(0);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//Pin the single nodal value at the single node on mesh }}
\DoxyCodeLine{    \textcolor{comment}{//boundary 1 (= the right domain boundary at x=1)}}
\DoxyCodeLine{    mesh\_pt()-\/>boundary\_node\_pt(1,0)-\/>pin(0);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// All values are initialised to zero. This is consistent with the}}
\DoxyCodeLine{    \textcolor{comment}{// boundary condition at x=0 and no further action is required}}
\DoxyCodeLine{    \textcolor{comment}{// at that node.}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Apply the boundary condition at x=1: u(x=1)=-\//+1}}
\DoxyCodeLine{    mesh\_pt()-\/>boundary\_node\_pt(1,0)-\/>set\_value(0,-\/\textcolor{keywordtype}{double}(Sign));}
\DoxyCodeLine{}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{comment}{// Finish problem setup: Set the sign for the source function}}
\DoxyCodeLine{    \textcolor{comment}{// in all elements}}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{comment}{//Find number of elements in mesh}}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} n\_element = mesh\_pt()-\/>nelement();}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{comment}{// Loop over the elements }}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)}
\DoxyCodeLine{     \{}
\DoxyCodeLine{      \textcolor{comment}{// The sign() member function is defined in the }}
\DoxyCodeLine{      \textcolor{comment}{// TwoNodePoissonElement class not the base GeneralisedElement class.}}
\DoxyCodeLine{      \textcolor{comment}{// In order to use it, we must}}
\DoxyCodeLine{      \textcolor{comment}{// upcast from GeneralisedElement to the specific element type,}}
\DoxyCodeLine{      \textcolor{comment}{// which is achieved by a C++ dynamic\_cast.}}
\DoxyCodeLine{      TwoNodePoissonElement *specific\_element\_pt }
\DoxyCodeLine{       = \textcolor{keyword}{dynamic\_cast<}TwoNodePoissonElement*\textcolor{keyword}{>}(mesh\_pt()-\/>element\_pt(i));}
\DoxyCodeLine{      }
\DoxyCodeLine{      \textcolor{comment}{// Set the sign of the source function}}
\DoxyCodeLine{      specific\_element\_pt-\/>sign() = Sign;}
\DoxyCodeLine{     \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//Assign the global and local equations numbers for the problem}}
\DoxyCodeLine{    cout << \textcolor{stringliteral}{"{}Number of equations is "{}} << assign\_eqn\_numbers() << std::endl;}
\DoxyCodeLine{   \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{  /// Check that everything has been set up properly}}
\DoxyCodeLine{\textcolor{comment}{}  \textcolor{keywordtype}{void} actions\_before\_newton\_solve()}
\DoxyCodeLine{   \{}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (0==self\_test())}
\DoxyCodeLine{     \{}
\DoxyCodeLine{      cout << \textcolor{stringliteral}{"{}Problem has been set up correctly and can be solved."{}} }
\DoxyCodeLine{           << std::endl;}
\DoxyCodeLine{     \}}
\DoxyCodeLine{    \textcolor{keywordflow}{else}}
\DoxyCodeLine{     \{}
\DoxyCodeLine{      \textcolor{keywordflow}{throw} }
\DoxyCodeLine{       OomphLibError(\textcolor{stringliteral}{"{}Trouble! Check error messages and fix the problems.\(\backslash\)n"{}},}
\DoxyCodeLine{                     \textcolor{stringliteral}{"{}DemoPoissonProblem::actions\_before\_newton\_solve()"{}},}
\DoxyCodeLine{                     OOMPH\_EXCEPTION\_LOCATION);}
\DoxyCodeLine{     \}}
\DoxyCodeLine{   \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{  /// Print out the result after the solve}}
\DoxyCodeLine{\textcolor{comment}{}  \textcolor{keywordtype}{void} actions\_after\_newton\_solve() }
\DoxyCodeLine{   \{}
\DoxyCodeLine{    ofstream file (\textcolor{stringliteral}{"{}result.dat"{}});}
\DoxyCodeLine{    mesh\_pt()-\/>output(file);}
\DoxyCodeLine{   \}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{keyword}{private}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{  /// The sign of the source function}}
\DoxyCodeLine{\textcolor{comment}{}  \textcolor{keywordtype}{int} Sign;}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\}; \textcolor{comment}{//End of problem definition}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \hypertarget{index_problem_exercise}{}\doxysubsection{Exercises\+:}\label{index_problem_exercise}

\begin{DoxyItemize}
\item Compile and run the example code \href{../../../demo_drivers/poisson/one_d_poisson_generic_only/one_d_poisson_generic_only.cc}{\texttt{ one\+\_\+d\+\_\+poisson\+\_\+generic\+\_\+only.\+cc}} and compare the numerical results against the (fish-\/shaped) exact solution \[ u_{fish}(x) = \pm \left[ \left(\sin(\sqrt{30})-1\right) x - \sin(\sqrt{30} x)\right]. \] (The sign of the source function is an optional argument to the problem constructor. If no argument is specified, the + sign is used.) Modify the {\ttfamily actions\+\_\+after\+\_\+newton\+\_\+solve()} function so that it writes the exact solution into another file, \char`\"{}exact\+\_\+solution.\+dat\char`\"{}, say.
\item Vary the number of elements and observe how the numerical results converge to the exact solution.
\item Adjust the boundary conditions\+:
\begin{DoxyItemize}
\item Change the boundary condition at the left end of the domain to $ u(0)=1$.
\item What happens when you don\textquotesingle{}t apply a boundary condition at $ x=1 $? (Hint\+: What are the natural boundary conditions for the Poisson equation?)
\item What happens when no boundary conditions are applied?
\end{DoxyItemize}
\item Suppress the assignment of the equation numbers in the problem constructor and observe what happens. Check the error messages produced by {\ttfamily Problem\+::self\+\_\+test()}.
\end{DoxyItemize}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_mesh}{}\doxysection{How to build a Mesh}\label{index_mesh}
{\ttfamily oomph-\/lib} provides a large number of fully-\/functional {\ttfamily Mesh} objects. Many of these meshes can easily be adapted to discretise other domains, provided the domain has the same topology as the original {\ttfamily Mesh}. We shall illustrate this in section \mbox{\hyperlink{index_distorted_mesh}{How to adapt an existing Mesh to a different domain shape}} below.\hypertarget{index_new_mesh}{}\doxysubsection{How to build a completely new Mesh}\label{index_new_mesh}
If the domain is too different from any of the existing meshes, a new, customised {\ttfamily Mesh} object, {\ttfamily Specific\+Mesh}, say, must be created. The specific mesh should be created as an object that inherits from the generic {\ttfamily Mesh} class. To maximise the potential for code-\/reuse, we recommended making the element type a template parameter of the {\ttfamily Specific\+Mesh} class.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keyword}{class }SpecificMesh : \textcolor{keyword}{public} Mesh}

\end{DoxyCode}


This allows the {\ttfamily Specific\+Mesh} to be used with any {\ttfamily Finite\+Element} that is based on the same geometric element type (see the section \mbox{\hyperlink{index_FEgeom}{How to build a new geometric element}} for a more detailed discussion of geometric elements).

The minimum requirements for a specific mesh object are that it must\+:
\begin{DoxyItemize}
\item Construct the elements and the {\ttfamily Nodes},
\item Store pointers to the elements in the {\ttfamily Mesh\+::\+Element\+\_\+pt} vector,
\item Store pointers to the {\ttfamily Nodes} in the {\ttfamily Mesh\+::\+Node\+\_\+pt} vector,
\item Set the elements\textquotesingle{} pointers to their local {\ttfamily Nodes} 
\item Set the positions of the {\ttfamily Nodes}.
\end{DoxyItemize}We suggest that all specific {\ttfamily Mesh} constructors also set up an auxiliary lookup scheme that stores information about the mesh boundaries. While this is not strictly required, it greatly facilitates the application of boundary conditions in complex domains. Firstly, the function {\ttfamily Mesh\+::set\+\_\+nboundary(...)} must be called to specify the number of mesh boundaries. In addition, the generic {\ttfamily Mesh} class provides a function {\ttfamily Mesh\+::add\+\_\+boundary\+\_\+node(i,node\+\_\+pt)}, which adds the {\ttfamily Node} pointed to by {\ttfamily node\+\_\+pt} to the {\ttfamily Mesh\textquotesingle{}s} i-\/th boundary and constructs the required look-\/up schemes, including a reverse lookup scheme that informs all {\ttfamily Nodes} which mesh boundaries (if any) they are located on. (In our simple 1D example there are only two boundaries, each consisting of a single Node.) Although this step is optional, it {\itshape is} required during mesh adaptation -- if the reverse lookup scheme has not been set up, a warning is issued and the code execution stops when any mesh adaptation is attempted. {\bfseries{Implementation}} {\bfseries{detail\+:}} {\ttfamily Nodes} that are located on mesh boundaries must be defined as {\ttfamily Boundary\+Nodes}. ~\newline


The majority of the work required to build a specific {\ttfamily Mesh} takes place in its constructor. Typically, the constructor creates the elements (of the type specified by the template parameter {\ttfamily ELEMENT}) and uses the elements\textquotesingle{} member function {\ttfamily Finite\+Element\+::construct\+\_\+node(...)} to create the new {\ttfamily Nodes}. The equivalent member function {\ttfamily Finite\+Element\+::construct\+\_\+boundary\+\_\+node(...)} is used to create new {\ttfamily Boundary\+Nodes}.

Here is the complete class definition for a simple, one-\/dimensional (line) mesh which discretises the 1D domain $x\in [0,1]$ using a specified number of equally-\/spaced elements.  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keyword}{class }OneDimMesh : \textcolor{keyword}{public} Mesh}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Mesh Constructor. The argument is the desired number of elements}}
\DoxyCodeLine{\textcolor{comment}{} OneDimMesh(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \&n\_element)}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{comment}{//Resize the vector of pointers to elements: there are n\_element elements}}
\DoxyCodeLine{  Element\_pt.resize(n\_element); }
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{//Construct the first element (Note the use of the template parameter)}}
\DoxyCodeLine{  Element\_pt[0] = \textcolor{keyword}{new} ELEMENT;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{//Construct the first node and add it to the Mesh::Node\_pt vector}}
\DoxyCodeLine{  \textcolor{comment}{//Note: The FiniteElement::construct\_boundary\_node(j) function}}
\DoxyCodeLine{  \textcolor{comment}{//builds the element's j-\/th local node, and provides the functionality}}
\DoxyCodeLine{  \textcolor{comment}{//that allows it to be located on a Mesh boundary -\/-\/ essentially this}}
\DoxyCodeLine{  \textcolor{comment}{//involves allocating additional storage to the Node.}}
\DoxyCodeLine{  \textcolor{comment}{//The function obtains the Node's}}
\DoxyCodeLine{  \textcolor{comment}{//characteristics (e.g. its spatial dimension, the number of}}
\DoxyCodeLine{  \textcolor{comment}{//values to be stored, etc) from various virtual FiniteElement}}
\DoxyCodeLine{  \textcolor{comment}{//member functions, such as FiniteElement::required\_nvalue(). }}
\DoxyCodeLine{  \textcolor{comment}{//FiniteElement::construct\_boundary\_node(...) also}}
\DoxyCodeLine{  \textcolor{comment}{//stores a pointer to the newly created Node in the element's own}}
\DoxyCodeLine{  \textcolor{comment}{//Node\_pt vector.}}
\DoxyCodeLine{  \textcolor{comment}{//Finally, the function returns the pointer to the}}
\DoxyCodeLine{  \textcolor{comment}{//newly created Node, so that it can be stored in the Mesh's Node\_pt}}
\DoxyCodeLine{  \textcolor{comment}{//vector, as done here:}}
\DoxyCodeLine{  Node\_pt.push\_back(finite\_element\_pt(0)-\/>construct\_boundary\_node(0));}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{//Find the number of nodes per element (N.B. all elements are identical}}
\DoxyCodeLine{  \textcolor{comment}{//so we can determine this value once and for all). }}
\DoxyCodeLine{  \textcolor{keywordtype}{unsigned} n\_node = finite\_element\_pt(0)-\/>nnode();}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{//Loop over the remaning nodes of the first element}}
\DoxyCodeLine{  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=1;n<n\_node;n++)}
\DoxyCodeLine{   \{}
\DoxyCodeLine{    \textcolor{comment}{//Construct the next node and add it to the Mesh::Node\_pt vector}}
\DoxyCodeLine{    \textcolor{comment}{//Note that these interior nodes need not (and should not)}}
\DoxyCodeLine{    \textcolor{comment}{//be boundary nodes, so they are created using the construct\_node}}
\DoxyCodeLine{    \textcolor{comment}{//function, which has the same interface as}}
\DoxyCodeLine{    \textcolor{comment}{//construct\_boundary\_node()}}
\DoxyCodeLine{    Node\_pt.push\_back(finite\_element\_pt(0)-\/>construct\_node(n));}
\DoxyCodeLine{   \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{//Loop over the remaining elements apart from the last}}
\DoxyCodeLine{  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=1;e<(n\_element-\/1);e++)}
\DoxyCodeLine{   \{}
\DoxyCodeLine{    \textcolor{comment}{//Construct the e-\/th element}}
\DoxyCodeLine{    Element\_pt[e] = \textcolor{keyword}{new} ELEMENT;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//The first local node of the e-\/th element is the last local node}}
\DoxyCodeLine{    \textcolor{comment}{//of the (e-\/1)-\/th element. We MUST NOT construct the node twice.}}
\DoxyCodeLine{    \textcolor{comment}{//Instead, we set the pointer in the e-\/th element to point to the}}
\DoxyCodeLine{    \textcolor{comment}{//previously created node in the (e-\/1)-\/th element.}}
\DoxyCodeLine{    finite\_element\_pt(e)-\/>node\_pt(0) = }
\DoxyCodeLine{      finite\_element\_pt(e-\/1)-\/>node\_pt(n\_node-\/1);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//Loop over the remaining nodes of the e-\/th element}}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=1;n<n\_node;n++)}
\DoxyCodeLine{     \{}
\DoxyCodeLine{      \textcolor{comment}{//Construct the next node and add it to the Mesh::Node\_pt vector}}
\DoxyCodeLine{      \textcolor{comment}{//Note that these interior nodes need not (and should not)}}
\DoxyCodeLine{      \textcolor{comment}{//be boundary nodes, so they are created using the construct\_node}}
\DoxyCodeLine{      \textcolor{comment}{//function, which has the same interface as}}
\DoxyCodeLine{      \textcolor{comment}{//construct\_boundary\_node()}}
\DoxyCodeLine{      Node\_pt.push\_back(finite\_element\_pt(e)-\/>construct\_node(n));}
\DoxyCodeLine{     \}}
\DoxyCodeLine{   \} \textcolor{comment}{//End of loop over elements}}
\DoxyCodeLine{  }
\DoxyCodeLine{  }
\DoxyCodeLine{  \textcolor{comment}{//Construct the final element}}
\DoxyCodeLine{  Element\_pt[n\_element-\/1] = \textcolor{keyword}{new} ELEMENT;}
\DoxyCodeLine{  }
\DoxyCodeLine{  \textcolor{comment}{//The first local node of the final element is the last local node}}
\DoxyCodeLine{  \textcolor{comment}{//of the penultimate element. We MUST NOT construct the node twice.}}
\DoxyCodeLine{  \textcolor{comment}{//Instead, we set the pointer in the final element to point to the}}
\DoxyCodeLine{  \textcolor{comment}{//previously created node in the penultimate element.}}
\DoxyCodeLine{  finite\_element\_pt(n\_element-\/1)-\/>node\_pt(0) = }
\DoxyCodeLine{   finite\_element\_pt(n\_element-\/2)-\/>node\_pt(n\_node-\/1);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{//Loop over the remaining central nodes of the final element}}
\DoxyCodeLine{  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=1;n<(n\_node-\/1);n++)}
\DoxyCodeLine{   \{}
\DoxyCodeLine{    \textcolor{comment}{//Construct the next node and add it to the Mesh::Node\_pt vector}}
\DoxyCodeLine{    \textcolor{comment}{//Note that these interior nodes need not (and should not)}}
\DoxyCodeLine{    \textcolor{comment}{//be boundary nodes, so they are created using the construct\_node}}
\DoxyCodeLine{    \textcolor{comment}{//function()}}
\DoxyCodeLine{    Node\_pt.push\_back(finite\_element\_pt(n\_element-\/1)-\/>construct\_node(n));}
\DoxyCodeLine{   \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{//Construct the final node and add it to the Mesh::Node\_pt vector.}}
\DoxyCodeLine{  \textcolor{comment}{//This node will be located on a boundary, and hence we use}}
\DoxyCodeLine{  \textcolor{comment}{//the construct\_boundary\_node function.}}
\DoxyCodeLine{  Node\_pt.push\_back(finite\_element\_pt(n\_element-\/1)}
\DoxyCodeLine{                    -\/>construct\_boundary\_node(n\_node-\/1));}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{//We've now created all the nodes -\/-\/ let's set their positions:}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{//Find the total number of nodes}}
\DoxyCodeLine{  \textcolor{keywordtype}{unsigned} n\_global\_node = nnode();}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{//Loop over all nodes}}
\DoxyCodeLine{  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_global\_node;n++)}
\DoxyCodeLine{   \{}
\DoxyCodeLine{    \textcolor{comment}{//Set the position of the node (equally spaced through the unit interval)}}
\DoxyCodeLine{    Node\_pt[n]-\/>x(0) = double(n)/double(n\_global\_node-\/1);}
\DoxyCodeLine{   \}}
\DoxyCodeLine{ }
\DoxyCodeLine{  \textcolor{comment}{//Set the boundary data:}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{//There are two boundaries in this mesh}}
\DoxyCodeLine{  set\_nboundary(2);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{//Boundary 0 contains the first node in the mesh:}}
\DoxyCodeLine{  add\_boundary\_node(0,Node\_pt[0]);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{//Boundary 1 contains the final node in the mesh:}}
\DoxyCodeLine{  add\_boundary\_node(1,Node\_pt[n\_global\_node-\/1]); }
\DoxyCodeLine{}
\DoxyCodeLine{ \} \textcolor{comment}{// End of constructor}}
\DoxyCodeLine{}
\DoxyCodeLine{\}; \textcolor{comment}{// End of OneDimMesh class.}}

\end{DoxyCodeInclude}


To build a {\ttfamily One\+Dim\+Mesh} with ten elements of type {\ttfamily Some\+Element}, say, the {\ttfamily Problem} constructor would contain the following 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::mesh\_pt() = \textcolor{keyword}{new} OneDimMesh<SomeElement>(10);}

\end{DoxyCode}
\hypertarget{index_distorted_mesh}{}\doxysubsection{How to adapt an existing Mesh to a different domain shape}\label{index_distorted_mesh}
Given that mesh generation tends to be a fairly tedious process, one should always check whether it is possible to deform an existing {\ttfamily Mesh} into a shape that matches the required domain. Provided that the new domain has the same topology as the domain represented by the original {\ttfamily Mesh}, this can always be done by re-\/positioning the Nodes. Such \char`\"{}deformed\char`\"{} {\ttfamily Meshes} should be implemented via inheritance, by deriving the new {\ttfamily Mesh} from an existing one.

Here is an example that illustrates the procedure. Assume we wish to solve an equation in the 2D annular domain bounded (in polar coordinates) by $ r \in [r_{min}, r_{max}] $ and $ \varphi \in [\varphi_{min}, \varphi_{max}] $. Inspection of the \href{../../meshes/mesh_list/html/index.html}{\texttt{ list of available meshes }} shows that {\ttfamily oomph-\/lib} does not provide a mesh for this geometry. However, there is a {\ttfamily Mesh} object, {\ttfamily Simple\+Rectangular\+Mesh}, which provides a uniform discretisation of a 2D rectangular domain $ x\in [0,L_x] $ and $ y \in [0,L_y] $ with $ N_x \times N_y $ quadrilateral elements. Since the topology of the two domains is identical, the annular mesh can be implemented in a few lines of code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//====================================================================}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{/// AnnularQuadMesh, derived from SimpleRectangularQuadMesh.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT> }
\DoxyCodeLine{\textcolor{keyword}{class }AnnularQuadMesh : \textcolor{keyword}{public} SimpleRectangularQuadMesh<ELEMENT>}
\DoxyCodeLine{\{}
\DoxyCodeLine{ }
\DoxyCodeLine{  \textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// \(\backslash\)short Constructor for angular mesh with n\_r x n\_phi }}
\DoxyCodeLine{\textcolor{comment}{ /// 2D quad elements. Calls constructor for the underlying }}
\DoxyCodeLine{\textcolor{comment}{ /// SimpleRectangularQuadMesh; then deforms the mesh so that it fits }}
\DoxyCodeLine{\textcolor{comment}{ /// into the annular region bounded by the radii r\_min and r\_max}}
\DoxyCodeLine{\textcolor{comment}{ /// and angles (in degree) of phi\_min and phi\_max.}}
\DoxyCodeLine{\textcolor{comment}{} AnnularQuadMesh(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& n\_r, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& n\_phi,}
\DoxyCodeLine{                 \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& r\_min, \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& r\_max,}
\DoxyCodeLine{                 \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& phi\_min, \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& phi\_max) :}
\DoxyCodeLine{  SimpleRectangularQuadMesh<ELEMENT>(n\_r,n\_phi,1.0,1.0)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// The constructor for the  SimpleRectangularQuadMesh has}}
\DoxyCodeLine{   \textcolor{comment}{// built the mesh with n\_x x n\_y = n\_r x n\_phi elements in the unit}}
\DoxyCodeLine{   \textcolor{comment}{// square. Let's reposition the nodal points so that the mesh}}
\DoxyCodeLine{   \textcolor{comment}{// gets mapped into the required annular region:}}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Find out how many nodes there are}}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} n\_node=nnode();}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Calculate the value of pi}}
\DoxyCodeLine{   \textcolor{keyword}{const} \textcolor{keywordtype}{double} pi = 4.0*atan(1.0);}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Loop over all nodes}}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{comment}{// Pointer to node:}}
\DoxyCodeLine{     Node* nod\_pt=node\_pt(n);}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Get the x/y coordinates}}
\DoxyCodeLine{     \textcolor{keywordtype}{double} x\_old=nod\_pt-\/>x(0);}
\DoxyCodeLine{     \textcolor{keywordtype}{double} y\_old=nod\_pt-\/>x(1);}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Map from the old x/y to the new r/phi:}}
\DoxyCodeLine{     \textcolor{keywordtype}{double} r=r\_min+(r\_max-\/r\_min)*x\_old;}
\DoxyCodeLine{     \textcolor{keywordtype}{double} phi=(phi\_min+(phi\_max-\/phi\_min)*y\_old)*pi/180.0;}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Set new nodal coordinates}}
\DoxyCodeLine{     nod\_pt-\/>x(0)=r*cos(phi);}
\DoxyCodeLine{     nod\_pt-\/>x(1)=r*sin(phi);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{\};}

\end{DoxyCode}


\DoxyHorRuler{0}
\hypertarget{index_mes_exercise}{}\doxysubsection{Exercise\+:}\label{index_mes_exercise}
Modify the {\ttfamily One\+Dim\+Mesh} object so that it provides a piecewise uniform discretisation of the domain $ x \in [0,1]$\+: $ N_0 $ equally spaced elements are to be placed in the the region $ x \in [0,\hat{x}]$, while $ N_1 $ elements are to be placed in the the region $ x \in [\hat{x},1]$. Pass the parameters $ N_0, N_1 $ and $\hat{x} $ to the mesh constructor. Construct the modified mesh via inheritance from the basic {\ttfamily One\+Dim\+Mesh} and include an error check to confirm that $ 0 < \hat{x} < 1 $.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_finiteelement}{}\doxysection{How to build a Finite\+Element}\label{index_finiteelement}
{\ttfamily oomph-\/lib} provides fully-\/functional {\ttfamily Finite\+Elements} for the discretisation of a wide range of PDEs. Most of the existing elements are constructed in a three-\/level hierarchy, the base being the generic {\ttfamily Finite\+Element} class. The next level in the hierarchy contains geometric elements (e.\+g. 1D line elements, 2D quad or triangular elements, 3D brick elements, etc.). These geometric classes form the bases for elements that implement the discretisation of particular PDEs. This hierarchy maximises the potential for code-\/reuse, because it allows many different specific elements to be derived from the same geometric element.

We shall discuss the implementation of new element types in two sections\+:
\begin{DoxyItemize}
\item \mbox{\hyperlink{index_FEequations}{How to implement a new system of equations as a specific Finite\+Element}}
\item \mbox{\hyperlink{index_FEgeom}{How to build a new geometric element}}
\end{DoxyItemize}

\DoxyHorRuler{0}
\hypertarget{index_FEequations}{}\doxysubsection{How to implement a new system of equations as a specific Finite\+Element}\label{index_FEequations}
Assume that we wish to design a new element type, {\ttfamily Specific\+Element}, say, that implements the discretisation of a system of PDEs on an existing geometric element. The {\ttfamily Specific\+Element} class needs to implement the following functions\+:
\begin{DoxyItemize}
\item The function that specifies the number of nodal values required at each of the element\textquotesingle{}s nodes\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::required\_nvalue(n) }

\end{DoxyCode}

\item The function that computes the element\textquotesingle{}s residual vector\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::get\_residuals(residuals) }

\end{DoxyCode}

\item The function that computes the element\textquotesingle{}s Jacobian matrix and its residual vector\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::get\_jacobian(residuals,jacobian) }

\end{DoxyCode}

\item The output function\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::output(ostream) }

\end{DoxyCode}

\end{DoxyItemize}

Most specific finite element classes will contain further member functions and member data to provide additional, problem-\/specific functionality. As a concrete example, we consider the {\ttfamily Two\+Node\+Poisson\+Element}, a specific {\ttfamily Finite\+Element} that provides an isoparametric discretisation of the 1D Poisson equation (1), based on the geometric element {\ttfamily Two\+Node\+Geometric\+Element}, to be discussed below\+:  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{keyword}{class }TwoNodePoissonElement : \textcolor{keyword}{public} TwoNodeGeometricElement}

\end{DoxyCodeInclude}
 In addition to the {\ttfamily Finite\+Element} member functions discussed above, this element provides a function that defines the source function $ f(x) $,  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{  \textcolor{keywordtype}{double} f(\textcolor{keyword}{const} \textcolor{keywordtype}{double} \&x) \textcolor{keyword}{const} }
\DoxyCodeLine{   \{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} double(Sign)*30.0*sin(sqrt(30.0)*x);}
\DoxyCodeLine{   \}}

\end{DoxyCodeInclude}
 where the sign of the source function is stored as private member data  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{  \textcolor{keywordtype}{int} Sign;}

\end{DoxyCodeInclude}
 and can be set by the access function  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{  \textcolor{keywordtype}{int}\& sign() \{\textcolor{keywordflow}{return} Sign;\}}

\end{DoxyCodeInclude}
 We provide a member function that returns the (single) nodal value stored at a specified local node in the element,  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{  \textcolor{keywordtype}{double} u(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \&n) \{\textcolor{keywordflow}{return} node\_pt(n)-\/>value(0);\}}

\end{DoxyCodeInclude}
 Finally, it is good practice to implement a self-\/test function that provides a sanity check of all data before the problem is solved. {\ttfamily oomph-\/lib} already provides self-\/test functions for all fundamental objects. Additional tests can be added by overloading these. For instance, in our Poisson element, the {\ttfamily Sign} variable should only take the values $ \pm 1 $. This can be tested with the following function, which also executes the {\ttfamily self\+\_\+test()} function of the underlying {\ttfamily Finite\+Element\+:}  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{  /// Self test function: The sign in the source function should}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{  /// only have the values +/-\/ 1. Following the general oomph-\/lib convention,}}
\DoxyCodeLine{\textcolor{comment}{  /// the self\_test() returns 0 for success, and 1 for failure:}}
\DoxyCodeLine{\textcolor{comment}{}  \textcolor{keywordtype}{unsigned} self\_test()}
\DoxyCodeLine{   \{}
\DoxyCodeLine{    \textcolor{comment}{// Initialise success flag}}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} success=0;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Run the generic FiniteElement self test}}
\DoxyCodeLine{    success=FiniteElement::self\_test();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Do additional test for this function}}
\DoxyCodeLine{    \textcolor{keywordflow}{if} ((Sign!=1)\&\&(Sign!=-\/1))}
\DoxyCodeLine{     \{}
\DoxyCodeLine{      cout << \textcolor{stringliteral}{"{}Sign of source function should be +/-\/ 1,"{}} << std::endl;}
\DoxyCodeLine{      cout << \textcolor{stringliteral}{"{}but it is:"{}} << Sign << std::endl;}
\DoxyCodeLine{      success=1;}
\DoxyCodeLine{     \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Return success flag}}
\DoxyCodeLine{    \textcolor{keywordflow}{return} success;}
\DoxyCodeLine{}
\DoxyCodeLine{   \} \textcolor{comment}{// End of self test}}

\end{DoxyCodeInclude}
 We will now discuss the implementation of the generic {\ttfamily Finite\+Element} member functions for the specific {\ttfamily Two\+Node\+Poisson\+Element\+:} \hypertarget{index_Fereq_nvalue}{}\doxysubsubsection{The function Finite\+Element\+::required\+\_\+nvalue(n)}\label{index_Fereq_nvalue}
The function returns the number of values that are stored at the element\textquotesingle{}s {\ttfamily n-\/th} local node. In our scalar Poisson problem, each node stores one value\+:

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{  /// For the Poisson equation, only one value is stored at each node}}
\DoxyCodeLine{  \textcolor{keywordtype}{unsigned} required\_nvalue(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \&n)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{return} 1;\}}

\end{DoxyCodeInclude}
 The function is used by {\ttfamily Finite\+Element\+::construct\+\_\+node(...)} to determine the amount of storage to be allocated at each of the element\textquotesingle{}s {\ttfamily Nodes}.\hypertarget{index_residuals}{}\doxysubsubsection{The function Finite\+Element\+::get\+\_\+residuals(residuals)}\label{index_residuals}
This function calculates the element\textquotesingle{}s residual vector whose entries are labelled by the {\itshape local} equation numbers. (Consult the \href{../../intro/html/index.html}{\texttt{ Introduction}} for a detailed discussion of the weak form of Poisson\textquotesingle{}s equation and its finite element discretisation which produces the discrete residual implemented here.) The spatial integration over the element is performed by the (default) integration scheme specified in the underlying geometric element. Note that it should (must) not be assumed that the residuals vector has been set to zero before the function call. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{  \textcolor{keywordtype}{void} get\_residuals(Vector<double> \&residuals)}
\DoxyCodeLine{   \{}
\DoxyCodeLine{    \textcolor{comment}{//Find the number of degrees of freedom (unpinned values) in the element}}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} n\_dof = ndof();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//Initialise all the residuals to zero}}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_dof;i++) \{residuals[i] = 0.0;\}}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{comment}{//Find the number of nodes in the element}}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} n\_node = nnode();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//Allocate memory for shape functions and their derivatives:}}
\DoxyCodeLine{    \textcolor{comment}{// There's one shape function for each node:}}
\DoxyCodeLine{    Shape psi(n\_node);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Each of the n\_node shape functions has one derivative with }}
\DoxyCodeLine{    \textcolor{comment}{// respect to the single local coordinate:}}
\DoxyCodeLine{    DShape dpsidx(n\_node,1);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//Storage for the single local coordinate}}
\DoxyCodeLine{    Vector<double> s(1);}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{comment}{//Find the number of integration points in the underlying }}
\DoxyCodeLine{    \textcolor{comment}{//geometric element's integration scheme }}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} n\_intpt = integral\_pt()-\/>nweight();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//Loop over the integration points}}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ipt=0;ipt<n\_intpt;ipt++)}
\DoxyCodeLine{     \{}
\DoxyCodeLine{      \textcolor{comment}{//Set the value of the local coordinate to be the integration }}
\DoxyCodeLine{      \textcolor{comment}{//scheme's knot point}}
\DoxyCodeLine{      s[0] = integral\_pt()-\/>knot(ipt,0);}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{//Find the weight of the integration scheme at this knot point}}
\DoxyCodeLine{      \textcolor{keywordtype}{double} w = integral\_pt()-\/>weight(ipt);}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{//Find the shape functions and their derivatives at the knot point. }}
\DoxyCodeLine{      \textcolor{comment}{//This function is implemented in FiniteElement.}}
\DoxyCodeLine{      \textcolor{comment}{//It also returns the Jacobian of the mapping from local to }}
\DoxyCodeLine{      \textcolor{comment}{//global coordinates.}}
\DoxyCodeLine{      \textcolor{keywordtype}{double} J = dshape\_eulerian(s,psi,dpsidx);}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{//Premultiply the weight and the Jacobian}}
\DoxyCodeLine{      \textcolor{keywordtype}{double} W = w*J;}
\DoxyCodeLine{      }
\DoxyCodeLine{      \textcolor{comment}{//Allocate storage for the value of the field variable u,}}
\DoxyCodeLine{      \textcolor{comment}{//its derivative and the global position at the knot point.}}
\DoxyCodeLine{      \textcolor{comment}{//Initialise them all to zero.}}
\DoxyCodeLine{      \textcolor{keywordtype}{double} interpolated\_x=0.0, interpolated\_u=0.0, interpolated\_dudx=0.0;}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{//Calculate the interpolated values by  looping over the shape }}
\DoxyCodeLine{      \textcolor{comment}{//functions and summing the appropriate contributions}}
\DoxyCodeLine{      \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++) }
\DoxyCodeLine{       \{}
\DoxyCodeLine{        interpolated\_x += nodal\_position(n,0)*psi[n];}
\DoxyCodeLine{        interpolated\_u += u(n)*psi[n];}
\DoxyCodeLine{        interpolated\_dudx += u(n)*dpsidx(n,0);}
\DoxyCodeLine{       \}}
\DoxyCodeLine{      }
\DoxyCodeLine{      \textcolor{comment}{// Evaluate the source function}}
\DoxyCodeLine{      \textcolor{keywordtype}{double} source=f(interpolated\_x);}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{//ASSEMBLE THE RESIDUALS}}
\DoxyCodeLine{      }
\DoxyCodeLine{      \textcolor{comment}{//Loop over the test functions (same as the shape functions}}
\DoxyCodeLine{      \textcolor{comment}{//since we're implementing an isoparametric element)}}
\DoxyCodeLine{      \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} l=0;l<n\_node;l++)}
\DoxyCodeLine{       \{}
\DoxyCodeLine{        \textcolor{comment}{//Get the local equation number}}
\DoxyCodeLine{        \textcolor{comment}{//The variable is the first (only) value stored at the nodes}}
\DoxyCodeLine{        \textcolor{keywordtype}{int} local\_eqn\_number = nodal\_local\_eqn(l,0);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{//If the equation is not a Dirichlet boundary condition}}
\DoxyCodeLine{        \textcolor{keywordflow}{if}(local\_eqn\_number >= 0)}
\DoxyCodeLine{         \{}
\DoxyCodeLine{          \textcolor{comment}{//Add body force/source term here }}
\DoxyCodeLine{          residuals[local\_eqn\_number] += source*psi[l]*W;}
\DoxyCodeLine{}
\DoxyCodeLine{          \textcolor{comment}{//Add the Poisson bit itself}}
\DoxyCodeLine{          residuals[local\_eqn\_number] += interpolated\_dudx*dpsidx(l,0)*W;}
\DoxyCodeLine{         \}}
\DoxyCodeLine{       \}}
\DoxyCodeLine{}
\DoxyCodeLine{     \} \textcolor{comment}{//End of loop over the integration points}}
\DoxyCodeLine{}
\DoxyCodeLine{   \} \textcolor{comment}{//End of function}}

\end{DoxyCodeInclude}
 \hypertarget{index_jac}{}\doxysubsubsection{The function Finite\+Element\+::get\+\_\+jacobian(residuals,jacobian)}\label{index_jac}
This function calculates the element\textquotesingle{}s Jacobian matrix and its residual vector, performing the spatial integration with the (default) integration scheme defined in the underlying geometric element. The entries in the Jacobian matrix and the residual vector are labelled by the {\itshape local} equation numbers. Note that neither the residuals vector nor the Jacobian matrix should be assumed to have been initialised to zero before the function call. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{  \textcolor{keywordtype}{void} get\_jacobian(Vector<double> \&residuals, DenseMatrix<double> \&jacobian)}
\DoxyCodeLine{   \{}
\DoxyCodeLine{    \textcolor{comment}{//First, calculate the residuals}}
\DoxyCodeLine{    get\_residuals(residuals);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//Find the number of degrees of freedom (unpinned values) in the element}}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} n\_dof = ndof();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//Initialise all entries of the Jacobian matrix to zero}}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_dof;i++) }
\DoxyCodeLine{     \{}
\DoxyCodeLine{      \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} j=0;j<n\_dof;j++) \{jacobian(i,j) = 0.0;\}}
\DoxyCodeLine{     \}}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{comment}{//Find the number of nodes in the element}}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} n\_node = nnode();}
\DoxyCodeLine{    \textcolor{comment}{//Allocate memory for shape functions and their derivatives}}
\DoxyCodeLine{    Shape psi(n\_node);}
\DoxyCodeLine{    DShape dpsidx(n\_node,1);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//Storage for the local coordinate}}
\DoxyCodeLine{    Vector<double> s(1);}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{comment}{//Find the number of integration points in the underlying}}
\DoxyCodeLine{    \textcolor{comment}{//geometric element's integration scheme }}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} n\_intpt = integral\_pt()-\/>nweight();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//Loop over the integration points}}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ipt=0;ipt<n\_intpt;ipt++)}
\DoxyCodeLine{     \{}
\DoxyCodeLine{      \textcolor{comment}{//Set the value of the local coordinate to be the integration }}
\DoxyCodeLine{      \textcolor{comment}{//scheme's knot point}}
\DoxyCodeLine{      s[0] = integral\_pt()-\/>knot(ipt,0);}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{//Find the weight of the integration scheme at this knot point}}
\DoxyCodeLine{      \textcolor{keywordtype}{double} w = integral\_pt()-\/>weight(ipt);}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{//Find the shape functions and their derivatives at the knot point. }}
\DoxyCodeLine{      \textcolor{comment}{//This function is implemented in FiniteElement.}}
\DoxyCodeLine{      \textcolor{comment}{//It also returns the Jacobian of the mapping from local to }}
\DoxyCodeLine{      \textcolor{comment}{//global coordinates.}}
\DoxyCodeLine{      \textcolor{keywordtype}{double} J = dshape\_eulerian(s,psi,dpsidx);}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{//Premultiply the weight and the Jacobian}}
\DoxyCodeLine{      \textcolor{keywordtype}{double} W = w*J;}
\DoxyCodeLine{            }
\DoxyCodeLine{      \textcolor{comment}{//ASSEMBLE THE JACOBIAN TERMS}}
\DoxyCodeLine{      }
\DoxyCodeLine{      \textcolor{comment}{//Loop over the test (shape) functions}}
\DoxyCodeLine{      \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} l=0;l<n\_node;l++)}
\DoxyCodeLine{       \{}
\DoxyCodeLine{        \textcolor{comment}{//Get the local equation number}}
\DoxyCodeLine{        \textcolor{comment}{//The variable is the first (only) value stored at the nodes}}
\DoxyCodeLine{        \textcolor{keywordtype}{int} local\_eqn\_number = nodal\_local\_eqn(l,0);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{//If the equation is not a Dirichlet boundary condition}}
\DoxyCodeLine{        \textcolor{keywordflow}{if}(local\_eqn\_number >= 0)}
\DoxyCodeLine{         \{}
\DoxyCodeLine{          \textcolor{comment}{//Loop over the degrees of freedom}}
\DoxyCodeLine{          \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} l2=0;l2<n\_node;l2++)}
\DoxyCodeLine{           \{}
\DoxyCodeLine{            \textcolor{comment}{//Get the local degree of freedom number}}
\DoxyCodeLine{            \textcolor{comment}{//The variable is the first (only) value stored at the nodes}}
\DoxyCodeLine{            \textcolor{keywordtype}{int} local\_dof\_number = nodal\_local\_eqn(l2,0);}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{//If the degree of freedom is not pinned}}
\DoxyCodeLine{            \textcolor{keywordflow}{if}(local\_dof\_number >= 0)}
\DoxyCodeLine{             \{}
\DoxyCodeLine{              \textcolor{comment}{//Add the contribution to the Jacobian}}
\DoxyCodeLine{              jacobian(local\_eqn\_number,local\_dof\_number) += }
\DoxyCodeLine{               dpsidx(l2,0)*dpsidx(l,0)*W;}
\DoxyCodeLine{             \}}
\DoxyCodeLine{           \}}
\DoxyCodeLine{         \}}
\DoxyCodeLine{       \}}
\DoxyCodeLine{     \} \textcolor{comment}{//End of loop over the integration points}}
\DoxyCodeLine{}
\DoxyCodeLine{   \} \textcolor{comment}{//End of function}}

\end{DoxyCodeInclude}
 {\bfseries{Note\+:}} There is a large amount of code duplication between the {\ttfamily get\+\_\+residuals()} and {\ttfamily get\+\_\+jacobian()} functions. To avoid this, we usually implement the computation of the residual vector and the Jacobian matrix in a single function containing the loop over the integration points. We then use a boolean flag as an additional argument to determine whether the Jacobian matrix should be assembled, e.\+g. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} get\_generic\_residual\_contribution(Vector<double>\& residuals,}
\DoxyCodeLine{                                       DenseMatrix<double>\& jacobian,}
\DoxyCodeLine{                                       \textcolor{keywordtype}{bool} flag)         }

\end{DoxyCode}
\hypertarget{index_FEout}{}\doxysubsubsection{The function Finite\+Element\+::output(out\+\_\+stream)}\label{index_FEout}
The output function is used to print the nodal values over the element 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{  \textcolor{keywordtype}{void} output(ostream \&output) }
\DoxyCodeLine{   \{}
\DoxyCodeLine{    \textcolor{comment}{//Read out the number of nodes in the element   }}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} n\_node = nnode();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{//Loop over the nodes and print out the global coordinate }}
\DoxyCodeLine{    \textcolor{comment}{//and value of the field variable, u, at each node}}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)}
\DoxyCodeLine{     \{}
\DoxyCodeLine{      output << nodal\_position(n,0) << \textcolor{stringliteral}{"{} "{}} << u(n) << std::endl;}
\DoxyCodeLine{     \}}
\DoxyCodeLine{   \} \textcolor{comment}{//End of function}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \hypertarget{index_FE_exercise}{}\doxysubsection{Exercises\+:}\label{index_FE_exercise}

\begin{DoxyItemize}
\item Implement the function {\ttfamily get\+\_\+generic\+\_\+residual\+\_\+contribution(...)} as a private member function of the {\ttfamily Two\+Node\+Poisson\+Element}. Use the function to avoid the large amount of code duplication between {\ttfamily get\+\_\+residuals(...)} and {\ttfamily get\+\_\+jacobian(...)} by re-\/writing these functions as follows\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{/// \(\backslash\)short Calculate the elemental contributions to the residuals for }\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{/// the weak form of the Poisson equation}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{keywordtype}{void} get\_residuals(Vector<double> \&residuals)}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{comment}{// Set flag for not computing the Jacobian}}
\DoxyCodeLine{  \textcolor{keywordtype}{bool} flag=\textcolor{keyword}{false};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Dummy Jacobian}}
\DoxyCodeLine{  DenseMatrix<double> jacobian;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Compute the residuals only:}}
\DoxyCodeLine{  get\_generic\_residual\_contribution(residuals,jacobian,flag);}
\DoxyCodeLine{ \}}

\end{DoxyCode}
 and 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{/// \(\backslash\)short Calculate the elemental contribution to the Jacobian }\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{/// matrix dR\_\{i\}/du\_\{j\} used in the Newton method}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{keywordtype}{void} get\_jacobian(Vector<double> \&residuals, DenseMatrix<double> \&jacobian)}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{comment}{// Set flag for computing the Jacobian matrix}}
\DoxyCodeLine{  \textcolor{keywordtype}{bool} flag=\textcolor{keyword}{true};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Compute the residuals and the Jacobian matrix:}}
\DoxyCodeLine{  get\_generic\_residual\_contribution(residuals,jacobian,flag);}
\DoxyCodeLine{ \}}

\end{DoxyCode}

\item The implementation of the specific source function ~\newline
 $ f(x) $ in {\ttfamily Two\+Node\+Poisson\+Element\+::f(...)} makes it impossible to use the {\ttfamily Two\+Node\+Poisson\+Element} to solve the Poisson equation with any other source functions, even though the discretisation of the ODE would otherwise be completely identical. A better implementation would allow the \char`\"{}user\char`\"{} to specify a different source function without having to change the implementation of the element class itself. ~\newline
 ~\newline
 Here is a suggestion for an improved implementation, which illustrates the procedure employed in the existing elements in {\ttfamily oomph-\/lib}\+:
\begin{DoxyItemize}
\item Introduce a public typedef into the element class to define the required format of the function pointer\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{/// \(\backslash\)short Function pointer to source function: }\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{/// The source function returns the value of the }}
\DoxyCodeLine{\textcolor{comment}{/// source function at the global coordinate x.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{keyword}{typedef} double (*PoissonSourceFctPt)(\textcolor{keyword}{const} \textcolor{keywordtype}{double}\& x);}

\end{DoxyCode}

\item Add a function pointer to the private data of the {\ttfamily Two\+Node\+Poisson\+Element} class and initialise it to NULL in the constructor\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{/// \(\backslash\)short Function pointer to source function (initialised to}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{/// NULL in the constructor)}}
\DoxyCodeLine{\textcolor{comment}{}PoissonSourceFctPt Source\_fct\_pt;}

\end{DoxyCode}

\item Provide an access function for the source function pointer\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{/// \(\backslash\)short Access function to pointer to source function}}
\DoxyCodeLine{PoissonSourceFctPt\& source\_fct\_pt() \{\textcolor{keywordflow}{return} Source\_fct\_pt;\}}

\end{DoxyCode}

\item Re-\/write the {\ttfamily Two\+Node\+Poisson\+Element\+::f(...)} function, so that it evaluates the (global) function pointed to by the source function pointer. If possible, provide a default value for the case when the function pointer has not been set\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{/// Evaluate source function at Eulerian position x}}
\DoxyCodeLine{\textcolor{keywordtype}{double} f(\textcolor{keyword}{const} \textcolor{keywordtype}{double}\& x)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{ }\{ }
\DoxyCodeLine{  \textcolor{comment}{//If no source function has been set, return zero}}
\DoxyCodeLine{  \textcolor{comment}{//so that the Poisson equation defaults to a Laplace equation.}}
\DoxyCodeLine{  \textcolor{keywordtype}{double} source=0.0;}
\DoxyCodeLine{  \textcolor{keywordflow}{if}(Source\_fct\_pt!=0)}
\DoxyCodeLine{   \{}
\DoxyCodeLine{    \textcolor{comment}{// Evaluate source function }}
\DoxyCodeLine{    source = (*Source\_fct\_pt)(x);}
\DoxyCodeLine{   \}}
\DoxyCodeLine{  \textcolor{keywordflow}{return} source;}
\DoxyCodeLine{ \}}

\end{DoxyCode}

\end{DoxyItemize}The pointer to the source function (typically defined in a suitable namespace in the \char`\"{}user\textquotesingle{}s\char`\"{} driver code) can now be set in the Problem constructor.
\item Generalise the {\ttfamily Two\+Node\+Poisson\+Element} to a {\ttfamily Two\+Node\+Self\+Adjoint\+Element} that implements the isoparametric discretisation of the self-\/adjoint ODE \[ \frac{\mbox{d}}{\mbox{d}x} \left( a(x) \frac{\mbox{d}u}{\mbox{d}x} \right) + b(x) u(x) = f(x). \ \ \ \ \ \ \ \ \ (3) \] Use function pointers to allow the \char`\"{}user\char`\"{} to specify the coefficient functions $ a(x), \ b(x) $ and $ f(x) $.
\end{DoxyItemize}

\DoxyHorRuler{0}
\hypertarget{index_FEgeom}{}\doxysubsection{How to build a new geometric element}\label{index_FEgeom}
Geometric elements define the geometry of a {\ttfamily Finite\+Element}. They are usually implemented as distinct classes that can then be used to create a number of {\ttfamily Finite\+Elements} each discretising a specific PDE, but with the same underlying geometrical representation. For this purpose, each geometric {\ttfamily Finite\+Element} must implement the following functions\+:
\begin{DoxyItemize}
\item The constructor 
\begin{DoxyCode}{0}
\DoxyCodeLine{SomeGeometricFiniteElement::SomeGeometricFiniteElement() }

\end{DoxyCode}
 must perform the following actions\+:
\begin{DoxyItemize}
\item Set the number of Nodes by calling the protected member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::set\_n\_node(n\_node). }

\end{DoxyCode}

\item Set the dimension of the element by calling the protected member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::set\_dimension(dim)}

\end{DoxyCode}
 Here the dimension of the element is defined as the number of local coordinates required to parametrise its shape. (Note that this is not necessarily the same as the spatial dimension of the problem -- we can have one-\/dimensional {\ttfamily Finite\+Elements} in 3D space, say.)
\item {\bfseries{Optional\+:}} Set the spatial integration scheme by calling the protected member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::set\_integration\_scheme(\&integration\_scheme) }

\end{DoxyCode}

\item {\bfseries{Optional\+:}} If the spatial dimension (= the number of Eulerian coordinates) required at all Nodes in the element is different from the spatial dimension of the element then set the \char`\"{}nodal dimension\char`\"{} by calling the protected member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::set\_nodal\_dimension(dim)}

\end{DoxyCode}
 For example in shell elements, a two-\/dimensional surface is embedded in a three-\/dimensional space, so the elemental dimension is two, but the nodal dimension is three.
\item {\bfseries{Optional\+:}} If the Eulerian coordinate (position) is interpolated using generalised coordinates, e.\+g. vector-\/valued shape functions, or Hermite-\/type interpolation, set the number of generalised coordinates or \char`\"{}position types\char`\"{} by using the protected member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::set\_n\_nodal\_position\_type(n\_position\_type)}

\end{DoxyCode}

\end{DoxyItemize}
\item The function that computes the element\textquotesingle{}s (geometric) shape functions at specified values of the local coordinates. These shape functions are primarily used to implement the mapping between the element\textquotesingle{}s local coordinates and the global (Eulerian) coordinates. ~\newline
 The geometric shape functions {\itshape can} be (and often are) also used in specific {\ttfamily Finite\+Elements} to interpolate the unknown function(s) between the nodal values. 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::shape(s,psi) }

\end{DoxyCode}

\end{DoxyItemize}

It is usually necessary to implement the following additional functions\+:
\begin{DoxyItemize}
\item The function that computes the derivatives of the element\textquotesingle{}s shape functions with respect to the local coordinates, 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::dshape\_local(s,psi,dpsids) }

\end{DoxyCode}

\item The function that specifies the number of Nodes along the element\textquotesingle{}s 1D \char`\"{}edges\char`\"{} ~\newline
 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::nnode\_1d() }

\end{DoxyCode}

\end{DoxyItemize}Further member functions and member data may be defined as and when required. For instance, all specific {\ttfamily Finite\+Elements} must store a pointer to an (instantiated) spatial integration scheme. It is good practice to provide a default integration scheme for each geometric element and to ensure its instantiation by making it a static data member of the geometric element class. This allows the constructor of the geometric element to set the pointer to the default integration scheme. If the default is not appropriate for a specific derived {\ttfamily Finite\+Element}, the default assignment can be over-\/written in the constructor of the derived class.

As a concrete example, we consider the implementation of the one-\/dimensional, two-\/node geometric element, {\ttfamily Two\+Node\+Geometric\+Element}, that uses linear shape functions to define the mapping between the element\textquotesingle{}s local and global coordinates. The element is derived from the {\ttfamily Finite\+Element} base class,  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{keyword}{class }TwoNodeGeometricElement : \textcolor{keyword}{public} FiniteElement}

\end{DoxyCodeInclude}
 and it uses a one-\/dimensional, two-\/point Gauss rule as the default spatial integration scheme 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{ /// Integration scheme that will be used to integrate over the element.}}
\DoxyCodeLine{\textcolor{comment}{ /// Simple Gaussian quadrature in one dimension, with two Gauss points.}}
\DoxyCodeLine{ \textcolor{keyword}{static} Gauss<1,2> Default\_spatial\_integration\_scheme;}

\end{DoxyCodeInclude}
 Here is the implementation of the generic {\ttfamily Finite\+Element} member functions for our specific geometric {\ttfamily Finite\+Element\+:} \hypertarget{index_Geomconst}{}\doxysubsubsection{The constructor\+: Two\+Node\+Geometric\+Element()}\label{index_Geomconst}
The constructor sets the number of local nodes in the element (2), sets the dimension of the element (1) and sets the pointer to the spatial integration scheme to be the default that is defined and instantiated as a static data member of the class\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ TwoNodeGeometricElement()}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{//Linear interpolation requires two Nodes per element.}}
\DoxyCodeLine{   \textcolor{comment}{//In fact, calling this function merely provides storage for }}
\DoxyCodeLine{   \textcolor{comment}{//the pointers to the Nodes and initialises the pointers to NULL. }}
\DoxyCodeLine{   \textcolor{comment}{//The Nodes themselves are created during the mesh generation }}
\DoxyCodeLine{   \textcolor{comment}{//process by the functions FiniteElement::construct\_node(...) }}
\DoxyCodeLine{   \textcolor{comment}{//which stores the pointers to the newly created Nodes }}
\DoxyCodeLine{   \textcolor{comment}{//in the element's own internal storage.}}
\DoxyCodeLine{   this-\/>set\_n\_node(2);}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{//The element is one-\/dimensional }}
\DoxyCodeLine{   this-\/>set\_dimension(1);}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{//Set the pointer to the spatial integration scheme}}
\DoxyCodeLine{   set\_integration\_scheme(\&Default\_spatial\_integration\_scheme);}
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
 \hypertarget{index_shape}{}\doxysubsubsection{The function Finite\+Element\+::shape(s,psi)}\label{index_shape}
This function returns the shape functions at the local element coordinate, s. The shape functions are used to interpolate the position, and also, any data values stored at nodes in derived, isoparametric elements. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{keywordtype}{void} shape(\textcolor{keyword}{const} Vector<double> \&s, Shape \&psi) \textcolor{keyword}{const}}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{//There are two shape functions (one per node)}}
\DoxyCodeLine{   \textcolor{comment}{//In terms of the local coordinate, s[0]:}}
\DoxyCodeLine{   \textcolor{comment}{//Node 0 is at s[0] = -\/1.0}}
\DoxyCodeLine{   \textcolor{comment}{//Node 1 is at s[0] =  1.0}}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{//psi[0] takes the value one at node 0 and zero at node 1}}
\DoxyCodeLine{   psi[0] = 0.5*(1.0 -\/ s[0]);}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{//psi[1] takes the value one at node 1 and zero at node 0}}
\DoxyCodeLine{   psi[1] = 0.5*(1.0 + s[0]);}
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
 \hypertarget{index_dshape}{}\doxysubsubsection{The function Finite\+Element\+::dshape\+\_\+local(s,psi,dpsids)}\label{index_dshape}
This function returns the shape functions and their derivatives with respect to the local coordinates 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{keywordtype}{void} dshape\_local(\textcolor{keyword}{const} Vector<double> \&s, Shape \&psi, DShape \&dpsids) \textcolor{keyword}{const}}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{//Call the shape functions}}
\DoxyCodeLine{   shape(s,psi);}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{//The derivative of psi[0] wrt s[0] is -\/0.5}}
\DoxyCodeLine{   dpsids(0,0) = -\/0.5;}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{//The derivative of psi[0] wrt s[0] is 0.5}}
\DoxyCodeLine{   dpsids(1,0) = 0.5;}
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
\hypertarget{index_nnode_1d}{}\doxysubsubsection{The function Finite\+Element\+::nnode\+\_\+1d()}\label{index_nnode_1d}
Return the number of nodes along the element\textquotesingle{}s 1d \char`\"{}edge\char`\"{} -- for a one-\/dimensional element, this is obviously the same as the number of nodes\+: 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nnode\_1d()\textcolor{keyword}{ const }\{\textcolor{keywordflow}{return} 2;\}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \hypertarget{index_geom_element_exercise}{}\doxysubsection{Exercises\+:}\label{index_geom_element_exercise}

\begin{DoxyItemize}
\item Change the {\ttfamily Two\+Node\+Geometric\+Element} to a {\ttfamily Three\+Node\+Geometric\+Element} in which quadratic interpolation is used to interpolate the Eulerian coordinates between the nodal points. Use this element as a basis for a {\ttfamily Three\+Node\+Poisson\+Element} and convince yourself that changing the {\ttfamily Two\+Node\+Poisson\+Element} to a {\ttfamily Three\+Node\+Poisson\+Element} only requires the change of a single line of code!
\item Use templating to generalise the geometric elements to an arbitrary number of nodes so that the class 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keywordtype}{unsigned} NNODE>}
\DoxyCodeLine{\textcolor{keyword}{class }GeometricLineElement : \textcolor{keyword}{public} FiniteElement}

\end{DoxyCode}
 represents 1D line elements with {\ttfamily NNODE} nodes. Consider carefully which member functions you can implement in generality and which member functions require specialised implementations. Provide the specialised member functions for elements with two, three and four nodes.
\item Use the templated {\ttfamily Geometric\+Line\+Elements} to implement an equivalent generalisation of the {\ttfamily Two\+Node\+Poisson\+Element} and {\ttfamily Three\+Node\+Poisson\+Element} classes to the general class 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keywordtype}{unsigned} NNODE>}
\DoxyCodeLine{\textcolor{keyword}{class }PoissonLineElement : \textcolor{keyword}{public} GeometricLineElement<NNODE>}

\end{DoxyCode}

\item Validate all elements against the exact solution and confirm the theoretical error estimate which predicts that if the domain $ x \in [0,1]$ is discretised with $ N $ equally spaced $n$-\/node line elements, we have \[ e = \sqrt{ \int_0^1 \left( u_{FE}(x) - u_{exact}(x) \right) ^2 dx } \sim h^{(n-1)} \mbox{ \ \ \ \ as $N \to \infty$} \] where $ h = 1/N $.
\end{DoxyItemize}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comments}{}\doxysection{Further comments}\label{index_comments}
We reiterate that the main purpose of this document is to provide a {\itshape quick} introduction to {\ttfamily oomph-\/lib\textquotesingle{}s} fundamental objects. The exercises have already highlighted several undesirable features of the simple example classes which could easily be improved to facilitate the (re-\/)use of the classes in different problems. Here we shall briefly discuss some further modifications that we regard as good practice, and which tend to be implemented in the existing classes in {\ttfamily oomph-\/lib}\+:
\begin{DoxyItemize}
\item \mbox{\hyperlink{index_dim_independent}{Dimension-\/independent implementation}}
\item \mbox{\hyperlink{index_pre_compute_psi}{Using pre-\/computed shape functions and the Storable\+Shape\+Element$<$\+ELEMENT$>$ class}}
\item \mbox{\hyperlink{index_equation_classes}{Further sub-\/division of specific element classes -- equation classes.}}
\item \mbox{\hyperlink{index_paranoia}{Implement extensive (but optional) self tests in all classes}}
\item \mbox{\hyperlink{index_magic}{The use of \char`\"{}magic numbers\char`\"{}}}
\item \mbox{\hyperlink{index_multi_physics}{Facilitating the use of specific elements in multi-\/physics problems}}
\end{DoxyItemize}

\DoxyHorRuler{0}
\hypertarget{index_dim_independent}{}\doxysubsection{Dimension-\/independent implementation}\label{index_dim_independent}
The exercises in the section \mbox{\hyperlink{index_FEgeom}{How to build a new geometric element}} suggest the use of templating to implement families of objects. This idea also permits the implementation of (geometric and specific) {\ttfamily Finite\+Elements} in arbitrary spatial dimensions. For instance, {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily QElement} class represents the family of (line/quadrilateral/brick-\/shaped) geometric elements with an arbitrary number of nodes along the elements\textquotesingle{} 1D edges. Thus, a {\ttfamily QElement$<$1,3$>$} is a three-\/node 1D line element, a {\ttfamily QElement$<$3,2$>$} is an eight-\/node 3D brick element, etc.

These geometric elements naturally form the basis for corresponding specific elements, such as the {\ttfamily QPoisson\+Element} family which provides an isoparametric discretisation of the Poisson equation (in an arbitrary spatial dimension), based on the {\ttfamily QElements} with the same template parameters.

\DoxyHorRuler{0}
\hypertarget{index_pre_compute_psi}{}\doxysubsection{Using pre-\/computed shape functions and the Storable\+Shape\+Element$<$\+ELEMENT$>$ class}\label{index_pre_compute_psi}
The computation of the element\textquotesingle{}s residual vector and the Jacobian matrix requires the evaluation of the element\textquotesingle{}s shape functions, $ \psi_j $, and their derivatives with respect to the global coordinate, $ \mbox{d}\psi_j/\mbox{d}x $, at the element\textquotesingle{}s integration points. In our simple example class, {\ttfamily Two\+Node\+Poisson\+Element}, we (re-\/)compute these functions \char`\"{}on the fly\char`\"{}, using the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::dshape\_eulerian(s,psi,dpsidx)}

\end{DoxyCode}
 where the local coordinate of the integration point is passed in the (one-\/dimensional) vector {\ttfamily s}.

The re-\/computation is wasteful because\+:
\begin{DoxyItemize}
\item The values of the shape functions and their derivatives, evaluated at the integration point, are independent of the value of the {\ttfamily Sign} variable. Their re-\/computation during the second solve could therefore be avoided if we stored their values in a suitable container.
\item The values of the shape functions at the integration points are identical for all elements. Therefore we only need to provide storage for the shape function values in a single, representative element. The other elements can access the values via pointers.
\end{DoxyItemize}To circumvent these potential inefficiencies, {\ttfamily oomph-\/lib} provides alternative interfaces for various functions that compute shape functions and their derivatives\+:
\begin{DoxyItemize}
\item Calls to the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::shape(s,psi)}

\end{DoxyCode}
 which computes the shape function at a given local coordinate, {\ttfamily s}, can be replaced by 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::shape\_at\_knot(int\_point,psi)}

\end{DoxyCode}
 where the {\ttfamily unsigned} argument {\ttfamily int\+\_\+point} identifies the integration point (as specified by the element\textquotesingle{}s spatial integration scheme). In \char`\"{}standard\char`\"{} {\ttfamily Finite\+Elements} the function {\ttfamily Finite\+Element\+::shape\+\_\+at\+\_\+knot(...)} simply determines the position of the integration point and calls {\ttfamily Finite\+Element\+::shape(...)} and so the shape functions are still computed \char`\"{}on the fly\char`\"{}. The templated class {\ttfamily Storable\+Shape\+Element$<$\+ELEMENT$>$}, however, may be used to upgrade any class derived from {\ttfamily Finite\+Element} into a class that {\bfseries{can}} store the values of the shape functions and their derivatives at the integration points. The function {\ttfamily shape\+\_\+at\+\_\+knot(...)} is overloaded so that when called for the first time, it computes the values of the shape function at all integration points and stores them for future reference. In subsequent calls, the function returns the stored values, rather than re-\/computing them.
\item There are equivalent alternatives for the functions that compute the shape functions and their derivatives with respect to the local coordinates\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::dshape(s,psi,dpsids)}

\end{DoxyCode}
 can be replaced by 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::dshape\_at\_knot(int\_point,psi,dpsids)}

\end{DoxyCode}
 while 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::d2shape(s,psi,dpsids,d2psids)}

\end{DoxyCode}
 can be replaced by 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::d2shape\_at\_knot(int\_point,psi,dpsids,d2psids)}

\end{DoxyCode}

\end{DoxyItemize}These functions are all overloaded in the {\ttfamily Storable\+Shape\+Element$<$\+ELEMENT$>$} class and by default the overloaded functions store the pre-\/computed values of the shape functions and their derivatives locally within each element. This implementation ensures data locality and should increase the speed of access to the stored values. However, it can also create significant storage overheads. {\ttfamily oomph-\/lib} therefore provides the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{StorableShapeElement<ELEMENT>::set\_shape\_local\_stored\_from\_element(...)}

\end{DoxyCode}
 which frees up the storage in the element and replaces it by pointer-\/based access to the values stored in another element. Typically, all elements in a mesh are of the same type and use the same spatial integration scheme and so the values of the shape functions need only be stored in one element.

Derivatives of the element\textquotesingle{}s shape functions with respect to the global Eulerian coordinates are generally computed by 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::dshape\_eulerian(s,psi,dpsidx)}

\end{DoxyCode}
 and 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::d2shape\_eulerian(s,psi,dpsidx,d2psidx)}

\end{DoxyCode}
 These functions also return the Jacobian of the mapping between the local and global coordinates -- the Jacobian can also be computed independently from 
\begin{DoxyCode}{0}
\DoxyCodeLine{FiniteElement::J\_eulerian(s)}

\end{DoxyCode}
 The derivatives of the shape functions with respect the global coordinates depend on the nodal positions, and it is not safe to assume that they will remain constant. For instance in moving boundary problems, the position of the nodes is determined as part of the solution. By default, the functions 
\begin{DoxyCode}{0}
\DoxyCodeLine{StorableShapeElement<ELEMENT>::dshape\_eulerian\_at\_knot(int\_point,psi,dpsidx)}

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{StorableShapeElement<ELEMENT>::d2shape\_eulerian\_at\_knot(int\_point,psi,dpsidx,d2psidx)}

\end{DoxyCode}
 and 
\begin{DoxyCode}{0}
\DoxyCodeLine{StorableShapeElement<ELEMENT>::J\_eulerian\_at\_knot(int\_point)}

\end{DoxyCode}
 re-\/compute the derivatives at the specified integration point \char`\"{}on the fly\char`\"{}. If the \char`\"{}user\char`\"{} is confident that in his/her problem, the nodal positions will not change, the values can be pre-\/computed by calling 
\begin{DoxyCode}{0}
\DoxyCodeLine{StorableShapeElement<ELEMENT>::pre\_compute\_dshape\_eulerian\_at\_knots()}

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{StorableShapeElement<ELEMENT>::pre\_compute\_d2shape\_eulerian\_at\_knots()}

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{StorableShapeElement<ELEMENT>::pre\_compute\_J\_eulerian\_at\_knots()}

\end{DoxyCode}
 Once these functions have been called, any subsequent calls to the {\ttfamily $\ast$\+\_\+eulerian\+\_\+at\+\_\+knot}(...) functions return the stored values. To revert to the case in which the derivatives are re-\/computed \char`\"{}on the fly\char`\"{}, the storage for the derivatives must be deleted by ~\newline
 calling 
\begin{DoxyCode}{0}
\DoxyCodeLine{StorableShapeElement<ELEMENT>::delete\_dshape\_eulerian\_stored()}

\end{DoxyCode}


{\bfseries{Notes\+:}} 
\begin{DoxyItemize}
\item In the (unlikely!) case that an element\textquotesingle{}s spatial integration scheme is changed during the code execution, all stored values are automatically re-\/computed.
\item The class {\ttfamily Storable\+Shape\+Solid\+Element$<$\+ELEMENT$>$} provides equivalent overloaded functions for derivatives with respect to the element\textquotesingle{}s Lagrangian coordinates that are used in solid mechanics problems.
\end{DoxyItemize}

\DoxyHorRuler{0}
\hypertarget{index_equation_classes}{}\doxysubsection{Further sub-\/division of specific element classes  equation classes.}\label{index_equation_classes}
We suggested that any newly developed elements should be constructed in a three-\/level hierarchy, {\ttfamily Finite\+Element} -- Geometric Element -- Specific {\ttfamily Finite\+Element}. Most finite elements in {\ttfamily oomph-\/lib} incorporate an additional intermediate \char`\"{}equation class\char`\"{} which implements the computation of the element residual vector and the element Jacobian matrix in terms of abstract shape and test functions, defined as pure virtual functions in the \char`\"{}equation class\char`\"{}. This makes it easy to change the specific element formulation, without having to re-\/implement the weak form of the governing equation.

Note that different element types may store the same physical variable at different locations. For example, the pressure in the Navier--Stokes equations may be stored as internal {\ttfamily Data} (discontinuous) or nodal {\ttfamily Data} (continuous). Particular equation classes may require internal numbering schemes that store the appropriate local equation numbers for each physical variable. These schemes must be assembled for each specific element in the function {\ttfamily Generalised\+Element\+::assign\+\_\+additional\+\_\+local\+\_\+eqn\+\_\+numbers()}, which is called from within {\ttfamily Problem\+::assign\+\_\+eqn\+\_\+numbers()}.

As an example, consider the weak form of the 2D advection diffusion equation \[ \int \left(\mbox{Pe} \ \sum_{i=1}^2 w_i \frac{\partial u}{\partial x_i} \psi^{(test)}_l + \sum_{i=1}^2 \frac{\partial u}{\partial x_i} \frac{\partial \psi^{(test)}_l}{\partial x_i} \right) dA = 0, \] where the Peclet number, $ Pe $ , and the \char`\"{}wind\char`\"{} $w_i \ (i=1,2)$ are given. We expand the unknown function $u(x_1,x_2)$ in terms of the (global) basis functions $ \psi^{(basis)}_k(x_1,x_2), \ (k=1,...,N)$, \[ u(x_1,x_2) = \sum_{k=1}^N U_k \ \psi^{(basis)}_k(x_1,x_2), \] where $N$ is the total number of nodes in the mesh. The mapping between the element\textquotesingle{}s local and global coordinates is represented in terms of the local shape functions $\psi^{(shape)}_j(s_1,s_2)$ as \[ x_i = \sum_{j=1}^n X_{ij} \ \psi^{(shape)}_j(s_1,s_2) \] where $ n $ is the number of nodes in the element.

The following sketch illustrates how this discretisation is implemented in {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily QAdvection\+Diffusion\+Element} -- an isoparametric, quadrilateral element, based on the Galerkin discretisation of the weak form with $ \psi^{(shape)}_j = \psi^{(test)}_j = \psi^{(basis)}_j $

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{advection_diffusion_element_inheritance}
\doxyfigcaption{Typical inheritance diagram for oomph-\/lib elements }
\end{DoxyImage}


At large Peclet number, the Galerkin discretisation of the advection diffusion equation is well-\/known to produce spurious \char`\"{}wiggles\char`\"{} in the solution. These can be suppressed by SUPG stabilisation which employs test functions, $ \psi_j^{(test)} $, that differ from the basis function, $ \psi_j^{(basis)} $, \[ \psi_j^{(test)} = \psi_j^{(basis)} + \tau^{(SUPG)} \sum_{i=1}^2 w_i \frac{\partial \psi_j^{(basis)}}{\partial x_i}, \] where $ \tau^{(SUPG)} $ is a stabilisation parameter. This can be implemented with a trivial change to the {\ttfamily QAdvection\+Diffusion\+Element} class -- the {\ttfamily QSUPGAdvection\+Diffusion\+Element} simply provides a different implementation of the test functions.

\DoxyHorRuler{0}
\hypertarget{index_paranoia}{}\doxysubsection{Implement extensive (but optional) self tests in all classes}\label{index_paranoia}
We have already illustrated the use of {\ttfamily oomph-\/lib\textquotesingle{}s} generic {\ttfamily self\+\_\+test()} functions. The top-\/level {\ttfamily Problem\+::self\+\_\+test()} function performs a systematic test of all fundamental objects involved in a specific problem and can be used to diagnose any problems. It is good practise to implement further {\ttfamily self\+\_\+test()} functions in any newly developed classes. The generic {\ttfamily self\+\_\+test()} functions are defined to be virtual functions in {\ttfamily oomph-\/lib\textquotesingle{}s} fundamental objects and can be overloaded. Obviously, the {\ttfamily self\+\_\+test()} function in a specific derived object should still call the {\ttfamily self\+\_\+test()} function of the underlying fundamental object. The {\ttfamily Two\+Node\+Poisson\+Element\+::self\+\_\+test()} function, listed in in the section \mbox{\hyperlink{index_FEequations}{How to implement a new system of equations as a specific Finite\+Element}} illustrates the procedure.

While frequent sanity checks are helpful during code-\/development, they can introduce significant overheads into the code execution. {\ttfamily oomph-\/lib} therefore provides a compiler flag PARANOID, which allows the execution of sanity checks to be switched on or off. When developing new classes, sanity checks should be implemented to catch any potential problems, but the relevant code should be surrounded by {\ttfamily ifdef/endif} statements to allow the tests to be disabled. Here is an example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{ \#include <typeinfo>}}
\DoxyCodeLine{}
\DoxyCodeLine{  [...]}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Recast to a different pointer type}}
\DoxyCodeLine{  SomeOtherObject* other\_pt=\textcolor{keyword}{dynamic\_cast<}SomeOtherObject*\textcolor{keyword}{>}(some\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{ \#ifdef PARANOID}}
\DoxyCodeLine{  \textcolor{keywordflow}{if} (other\_pt==0)}
\DoxyCodeLine{   \{}
\DoxyCodeLine{   std::ostringstream error\_stream;}
\DoxyCodeLine{     error\_stream << \textcolor{stringliteral}{"{}Failed to cast some\_pt to SomeOtherObject* "{}}  }
\DoxyCodeLine{                  << std::endl;}
\DoxyCodeLine{     error\_stream << \textcolor{stringliteral}{"{}The pointer some\_pt points to an object of type: "{}} <<}
\DoxyCodeLine{                  << \textcolor{keyword}{typeid}(some\_pt).name() << std::endl; }
\DoxyCodeLine{     \textcolor{keywordflow}{throw} OomphLibError(error\_stream.str(),}
\DoxyCodeLine{                         OOMPH\_CURRENT\_FUNCTION,}
\DoxyCodeLine{                         OOMPH\_EXCEPTION\_LOCATION);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\textcolor{preprocessor}{ \#endif }}
\DoxyCodeLine{}
\DoxyCodeLine{[...]}

\end{DoxyCode}
 Note that we throw a specific {\ttfamily Oomph\+Lib\+Error} object after catching the error -- this allows the provision of more explicit (and hopefully more meaningful) error messages.

Many access functions that provide indexed access to a private container, do, in fact, access a private STL vector. Explicit range checking for these (frequent!) cases can be avoided by changing the container to {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Vector} class. The {\ttfamily Vector} class performs automatic range checking, if {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily generic} library is compiled with the {\ttfamily RANGE\+\_\+\+CHECKING} flag set (i.\+e. if {\ttfamily -\/DRANGE\+\_\+\+CHECKING} is specified as a compilation flag for the C++ compiler). For access functions that do not use the {\ttfamily Vector} class you should implement your own range checks using the RANGE\+\_\+\+CHECKING compiler flag.

\DoxyHorRuler{0}
\hypertarget{index_magic}{}\doxysubsection{The use of \char`\"{}magic numbers\char`\"{}}\label{index_magic}
In general, we set the equation number to -\/1 to indicate that a nodal value is pinned, i.\+e. prescribed by boundary conditions. This convention is used throughout {\ttfamily oomph-\/lib}, but the direct use of -\/1 as a (bad!) \char`\"{}magic number\char`\"{} is generally avoided. Instead we refer to the static data member of the {\ttfamily Data} class 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{static} \textcolor{keywordtype}{long} Data::Is\_pinned }

\end{DoxyCode}
 which is (of course) set to -\/1. Similarly, when nodes are created, the equation numbers of their value(s) are initialised to a value of -\/10, represented by the static data member 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{static} \textcolor{keywordtype}{int} Data::Is\_unclassified }

\end{DoxyCode}
 This allows the function {\ttfamily Problem\+::self\+\_\+test()} to check if any values have not been classified as pinned or free.

\DoxyHorRuler{0}
\hypertarget{index_multi_physics}{}\doxysubsection{Facilitating the use of specific elements in multi-\/physics problems}\label{index_multi_physics}
As the name of the library suggests, {\ttfamily oomph-\/lib\textquotesingle{}s} existing \char`\"{}single-\/physics\char`\"{} elements are (and any newly designed ones should be) designed so that they can easily be used in multi-\/physics problems. We anticipate two types of multi-\/physics interactions\+:
\begin{DoxyItemize}
\item The solution of one system of equations affects the geometry of the domain in which another equation is solved -- this occurs, for instance, in fluid-\/structure interaction problems.
\item Two physical phenomena occur in the same domain and interact with each other, so that forcing terms in one equation depend on the solution of another -- this occurs, for instance, in thermo-\/elasticity problems where the temperature distribution (determined by the solution of an unsteady heat equation, say) affects the \char`\"{}growth term\char`\"{} in the equations of elasticity.
\end{DoxyItemize}Multi-\/physics elements for such problems are usually implemented by combining two (or more) single-\/physics elements via multiple inheritance. The combined, multi-\/physics element will obviously have a larger number of degrees of freedom than the constituent single-\/physics elements. The combined element typically calls the {\ttfamily get\+\_\+residuals(...)} function of the two constituent elements and concatenates their residual vectors. When computing the Jacobian matrix, the \char`\"{}single physics\char`\"{} elements provide the diagonal blocks for the Jacobian matrix of the multi-\/physics element, while the off-\/diagonal interaction blocks must be computed separately. The details of the implementation vary from problem to problem. However, any single-\/physics element must satisfy the following requirements if it is to be used as a base class for derived multi-\/physics elements\+:
\begin{DoxyItemize}
\item \mbox{\hyperlink{index_dont_wipe}{Rule 1\+: Elements must only initialise their own entries in the element residual vector and the element Jacobian matrix}}
\item \mbox{\hyperlink{index_virtual}{Rule 2\+: Forcing functions, etc. should be implemented as uniquely-\/named virtual functions}}
\item \mbox{\hyperlink{index_index_fcts}{Rule 3\+: Nodal values should only be accessed indirectly via index functions that can be overloaded in derived multi-\/physics elements}}
\item \mbox{\hyperlink{index_mesh_movement}{Rule 4\+: Time derivatives should be implemented in the ALE formulation to allow for moving meshes.}}
\end{DoxyItemize}

\DoxyHorRuler{0}
\hypertarget{index_dont_wipe}{}\doxysubsubsection{Rule 1\+: Elements must only initialise their own entries in the element residual vector and the element Jacobian matrix}\label{index_dont_wipe}
The computation of the element residual vector and the element Jacobian matrix typically involves a loop over the element\textquotesingle{}s integration points, in which each integration point adds a further contribution to the entries. In multi-\/physics problems it is crucial that the initialisation of the residual vector and the Jacobian matrix only sets the element\textquotesingle{}s \char`\"{}own\char`\"{} entries to zero.

To illustrate this point, consider what would happen if we used the {\ttfamily Two\+Node\+Poisson\+Element\+::get\+\_\+jacobian(...)} function, discussed in the section \mbox{\hyperlink{index_jac}{The function Finite\+Element\+::get\+\_\+jacobian(residuals,jacobian)}}, in a derived multi-\/physics element, which combines the {\ttfamily Two\+Node\+Poisson\+Element} with another element, {\ttfamily Two\+Node\+Some\+Other\+Equation\+Element}, say. Assume that we implement the function {\ttfamily get\+\_\+jacobian(...)} of the combined element so that it first calls the function {\ttfamily Two\+Node\+Some\+Other\+Equation\+Element\+::get\+\_\+jacobian(...)} to determine the first diagonal block in the combined Jacobian matrix. When we call {\ttfamily Two\+Node\+Poisson\+Element\+::get\+\_\+jacobian(...)} to compute the entries in the second diagonal block, the initialisation loop


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//Find the number of degrees of freedom (unpinned values) in the element}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_dof = ndof();}
\DoxyCodeLine{\textcolor{comment}{//Initialise all entries of the Jacobian matrix to zero}}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_dof;i++) }
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} j=0;j<n\_dof;j++) \{jacobian(i,j) = 0.0;\}}
\DoxyCodeLine{ \}}

\end{DoxyCode}


would initialise the {\itshape entire} Jacobian matrix, thus wiping out the entries that were already computed by ~\newline
 {\ttfamily Two\+Node\+Some\+Other\+Equation\+Element\+::get\+\_\+jacobian(...)}.

The strategy used in {\ttfamily oomph-\/lib} to permit the easy combination of elements is to use the two protected member functions of the {\ttfamily Generalised\+Element} class\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{virtual} \textcolor{keywordtype}{void} GeneralisedElement::fill\_in\_contribution\_to\_residuals(Vector<double>\&residuals);}

\end{DoxyCode}


and


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{virtual} \textcolor{keywordtype}{void} GeneralisedElement::fill\_in\_contribution\_to\_jacobian(Vector<double> \&residuals,}
\DoxyCodeLine{                                                                  DenseMatrix<double> \&jacobian); }

\end{DoxyCode}


These functions DO NOT initialise the entries of the residuals vector or the Jacobian matrix. Instead, the functions merely add the appropriate contributions to the vector and the matrix entries. The default version of the {\ttfamily get\+\_\+residuals()} and {\ttfamily get\+\_\+jacobian()} functions, defined in {\ttfamily Generalised\+Element}, are simple wrappers that initialise the residuals and Jacobian to zero and then call the appropriate {\ttfamily fill\+\_\+in\+\_\+contribution}... function. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{virtual} \textcolor{keywordtype}{void} GeneralisedElement::get\_residuals(Vector<double> \&residuals) }
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{//Zero the residuals vector}}
\DoxyCodeLine{ residuals.initialise(0.0);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{//Add the elemental contribution to the residuals vector}}
\DoxyCodeLine{ fill\_in\_contribution\_to\_residuals(residuals);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{virtual} \textcolor{keywordtype}{void} GeneralisedElement::get\_jacobian(Vector<double> \&residuals, }
\DoxyCodeLine{                                              DenseMatrix<double> \&jacobian) }
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{//Zero the residuals vector}}
\DoxyCodeLine{ residuals.initialise(0.0);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{//Zero the Jacobian matrix}}
\DoxyCodeLine{ jacobian.initialise(0.0);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{//Add the elemental contribution to the residuals vector and Jacobian}}
\DoxyCodeLine{ fill\_in\_contribution\_to\_jacobian(residuals,jacobian);}
\DoxyCodeLine{\} }

\end{DoxyCode}


The {\ttfamily get\+\_\+residuals} function, for example, can thus be overloaded in a multi-\/physics element, as follows\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{/// Multi-\/physics element, created by multiple inheritance}}
\DoxyCodeLine{\textcolor{keyword}{class }SomeMultiPhysicsElement : \textcolor{keyword}{public} \textcolor{keyword}{virtual} TwoNodePoissonElement,}
\DoxyCodeLine{                                \textcolor{keyword}{public} \textcolor{keyword}{virtual} TwoNodeSomeOtherEquationElement}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ [...]}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Residual vector of the combined element is made from the entries}}
\DoxyCodeLine{\textcolor{comment}{ /// of the constituent single-\/physics elements}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} get\_residuals(Vector<double> \&residuals) }
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{//Zero the residuals vector}}
\DoxyCodeLine{   residuals.initialise(0.0);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{//Add the first elemental contribution to the residuals vector}}
\DoxyCodeLine{  TwoNodePoissonElement::fill\_in\_contribution\_to\_residuals(residuals);}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{//Add the second elemental contribution to the residuals vector}}
\DoxyCodeLine{   TwoNodeSomeOtherEquationElement::fill\_in\_contribution\_to\_residuals(residuals);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{  [...]}
\DoxyCodeLine{}
\DoxyCodeLine{ \};}

\end{DoxyCode}


It is, therefore, recommended that authors of \char`\"{}single-\/physics\char`\"{} elements, overload {\ttfamily fill\+\_\+in\+\_\+contribution\+\_\+to\+\_\+residuals(...)} and {\ttfamily fill\+\_\+in\+\_\+contribution\+\_\+to\+\_\+jacobian(...)}, rather than {\ttfamily get\+\_\+residuals()} and {\ttfamily get\+\_\+jacobian(...)}, respectively. A further advantage of the implementation is that the author need not worry about initialisation of the residuals vector or the Jacobian matrix when using the {\ttfamily \char`\"{}fill\+\_\+in\+\_\+\char`\"{}} rather than the {\ttfamily \char`\"{}get\+\_\+\char`\"{}} functions.\hypertarget{index_virtual}{}\doxysubsubsection{Rule 2\+: Forcing functions, etc. should be implemented as  uniquely-\/named virtual functions}\label{index_virtual}
To allow for an interaction between multiple equations, any forcing functions (such as the source function in the Poisson equation) should be implemented as virtual functions. This allows them to be overloaded in derived, multi-\/physics elements where the forcing function in one equation might depend on the unknowns in another one.

Furthermore, to avoid clashes of function names that may occur when two single-\/physics elements are combined, member functions that can be expected to have counterparts in the context of other equations should be given suitable modifiers. For instance, 
\begin{DoxyCode}{0}
\DoxyCodeLine{AdvectionDiffusionEquation::source\_fct\_adv\_diff(...)}

\end{DoxyCode}
 is a better name for a member function that returns the source function in the advection-\/diffusion equations than 
\begin{DoxyCode}{0}
\DoxyCodeLine{AdvectionDiffusionEquation::source\_fct(...)}

\end{DoxyCode}
 since many other equations are likely to have source functions, too. It is obviously impossible to completely avoid such clashes but this strategy makes them less likely to occur. We are fairly confident that the relevant member functions of all existing elements in {\ttfamily oomph-\/lib} have been given suitable modifiers to avoid clashes of this type. Therefore, you should be able to combine any element with any other element in the library. If you find a counter-\/example \href{../../contact/html/index.html}{\texttt{ let us know}}, and we will rectify this in the next release. In the meantime exploit the fact that {\ttfamily oomph-\/lib} is an open source library; you can change anything you want!\hypertarget{index_index_fcts}{}\doxysubsubsection{Rule 3\+: Nodal values should only be accessed indirectly via index functions that can be overloaded in derived multi-\/physics elements}\label{index_index_fcts}
When implementing the single-\/physics {\ttfamily Two\+Node\+Poisson\+Element}, discussed above, we provided an access function {\ttfamily u(n)} that returns the (single) nodal value, stored at the element\textquotesingle{}s {\ttfamily n} -\/th {\ttfamily Node}. The function was implemented as a simple wrapper that followed the pointer to the element\textquotesingle{}s {\ttfamily n} -\/th {\ttfamily Node} and returned the zero-\/th nodal value stored at that {\ttfamily Node\+:} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{double} TwoNodePoissonElement::u(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \&n) }
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} node\_pt(n)-\/>value(0);}
\DoxyCodeLine{ \}}

\end{DoxyCode}


In a single-\/physics context, this implementation is perfectly acceptable since we know {\itshape a} {\itshape priori} that in a scalar problem each {\ttfamily Node} only stores a single value.

The same logic suggests that a {\ttfamily Two\+Node\+Advection\+Diffusion\+Element} would have a member function 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{double} TwoNodeAdvectionDiffusionElement::u(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \&n) }
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} node\_pt(n)-\/>value(0);}
\DoxyCodeLine{ \}}

\end{DoxyCode}


However, merging these two elements via multiple inheritance creates two problems. First we have clash of names which could have been avoided by following rule 2 above and calling the two functions {\ttfamily Two\+Node\+Poisson\+Element\+::u\+\_\+poisson(...)} and {\ttfamily Two\+Node\+Advection\+Diffusion\+Element\+::u\+\_\+adv\+\_\+diff(...)}, say. More serious is that both elements regard the zero-\/th nodal value as \char`\"{}their own\char`\"{}. This can (and should!) be avoided by the following re-\/implementation\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{double} TwoNodePoissonElement::u(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \&n) }
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} node\_pt(n)-\/>value(u\_index\_poisson());}
\DoxyCodeLine{ \}}

\end{DoxyCode}


where the virtual function {\ttfamily u\+\_\+index\+\_\+poisson()} provides the default index at which the Poisson nodal values are stored in a single-\/physics context\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{virtual} \textcolor{keywordtype}{unsigned} TwoNodePoissonElement::u\_index\_poisson()}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{comment}{// By default (i.e. in a single-\/physics context) the Poisson }}
\DoxyCodeLine{  \textcolor{comment}{// value is stored at the zero-\/th nodal value:}}
\DoxyCodeLine{  \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{ \}}

\end{DoxyCode}


The advection-\/diffusion element can be modified in the same way\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{double} TwoNodeAdvectionDiffusionElement::u(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \&n) }
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} node\_pt(n)-\/>value(u\_index\_adv\_diff());}
\DoxyCodeLine{ \}}

\end{DoxyCode}


with


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{virtual} \textcolor{keywordtype}{unsigned} TwoNodeAdvectionDiffusionElement::u\_index\_adv\_diff()}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{comment}{// By default (i.e. in a single-\/physics context) the advection-\/diffusion}}
\DoxyCodeLine{  \textcolor{comment}{// value is stored at the zero-\/th nodal value:}}
\DoxyCodeLine{  \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{ \}}

\end{DoxyCode}


In a combined multi-\/physics problem, we can now merge the two elements by multiple inheritance,


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }TwoNodeAdvDiffAndPoissonElement : }
\DoxyCodeLine{       \textcolor{keyword}{public} \textcolor{keyword}{virtual} TwoNodePoissonElement,}
\DoxyCodeLine{       \textcolor{keyword}{public} \textcolor{keyword}{virtual} TwoNodeAdvectionDiffusionElement}

\end{DoxyCode}


Name clashes are already avoided, so we only have to overwrite the two index functions to indicate which (scalar) value is stored as which nodal value\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{unsigned} TwoNodeAdvDiffAndPoissonElement::u\_index\_adv\_diff()}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{comment}{// In the combined multi-\/physics element we continue to store the }}
\DoxyCodeLine{  \textcolor{comment}{// advection-\/diffusion value at the zero-\/th nodal value}}
\DoxyCodeLine{  \textcolor{comment}{// [as a result it is not actually necessary to re-\/implement this}}
\DoxyCodeLine{  \textcolor{comment}{// function!]}}
\DoxyCodeLine{  \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{ \}}

\end{DoxyCode}


and


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{unsigned} TwoNodeAdvDiffAndPoissonElement::u\_index\_poisson()}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{comment}{// In the combined multi-\/physics element we store the Poisson}}
\DoxyCodeLine{  \textcolor{comment}{// value at the first nodal value:}}
\DoxyCodeLine{  \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{ \}}

\end{DoxyCode}


Specific examples that illustrate the creation of (non-\/trivial) multi-\/physics elements by multiple inheritance are provided in the \href{../../example_code_list/html/index.html\#multi}{\texttt{ list of example codes.}}\hypertarget{index_mesh_movement}{}\doxysubsubsection{Rule 4\+: Time derivatives should be implemented in the ALE formulation to allow for moving meshes.}\label{index_mesh_movement}
In moving mesh problems, the time-\/derivative of a nodal value (approximated by the Node\textquotesingle{}s {\ttfamily Time\+Stepper}) is not the same as the Eulerian time-\/derivative $ \partial/ \partial t $ that \char`\"{}usually\char`\"{} occurs in the governing equation. The former represents the rate of change when following the moving node; the latter is the rate of change evaluated at a fixed Eulerian position. The two time-\/derivatives are related to each other via the ALE relation \[ \left. \frac{\partial (.)}{\partial t} \right|_{Eulerian} = \left. \frac{\partial (.) }{\partial t} \right|_{at \ node} - \ \sum_{i=1}^D v_i^{(Mesh)} \ \frac{\partial (.) }{ \partial x_i} \] where $ D $ is the spatial dimension of the problem and $ v_i^{(Mesh)} \ (i=1,...,D) $ is the velocity of the node. Any Eulerian time-\/derivatives in the governing equation should be implemented in the above form to ensure that the element remains functional in moving mesh problems. See the \href{../../unsteady_heat/two_d_unsteady_heat_ALE/html/index.html}{\texttt{ example describing the solution of the unsteady heat equation in a moving domain}} for further details.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{PDF file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
