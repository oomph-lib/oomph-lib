<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: (Not-So-)Quick Users Guide</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../figures/manifest.json">
<link rel="mask-icon" href="../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../html/index.html"><img alt="oomph-lib" src="../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">(Not-So-)Quick Users Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The purpose of this document is to provide a "quick" introduction to the fundamental objects in <code>oomph-lib</code>. Assuming that you</p><ul>
<li>have a basic understanding of the finite element method</li>
</ul>
<p>and</p><ul>
<li>are reasonably familiar with object-oriented programming in C++,</li>
</ul>
<p>the Quick Guide should enable you to solve basic PDE problems using <code>oomph-lib</code>. You should also consult the extensive <a href="../../example_code_list/html/index.html">list of example codes</a> distributed with the library.</p>
<h1><a class="anchor" id="main_how_to"></a>
How to solve simple PDEs with oomph-lib</h1>
<p>To solve a given PDE with <code>oomph-lib</code>, its discretisation needs to be specified in a <code>Problem</code> object. This usually involves the specification of the <code>Mesh</code> and the element types, followed by the application of the boundary conditions. If these steps are performed in the <code>Problem</code> constructor, the driver code itself can be as simple as:  </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">//Build the problem </span></div>
<div class="line">  DemoPoissonProblem problem;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">//Solve the problem, using Newton&#39;s method</span></div>
<div class="line">  problem.newton_solve();</div>
<div class="line"> </div>
<div class="line"> }</div>
</div><!-- fragment --><p> The amount of work required to represent a given PDE as a <code>Problem</code> object is problem-dependent:</p><ul>
<li>If <code>oomph-lib's</code> existing <code>Mesh</code> objects and element types are sufficient to discretise the problem, the generation of a fully-functional <code>Problem</code> object is straightforward. We shall discuss this case in the section <a class="el" href="index.html#problem">How to build a Problem</a>.</li>
<li>If <code>oomph-lib</code> provides the required element type but none of the available meshes are suitable, you will have to write your own <code>Mesh</code> object. We shall discuss this in the section <a class="el" href="index.html#mesh">How to build a Mesh</a>. It is also possible to create <code>oomph-lib</code> meshes based on the output from third-party (commercial) mesh generators. This is illustrated in <a href="../../meshes/third_party_meshes/html/index.html">another example.</a></li>
<li>Finally, the problem might involve a PDE for which <code>oomph-lib</code> does not provide any suitable elements. In this case you will need to write your own element. When implementing elements in <code>oomph-lib</code> the element formulation is generally sub-divided into (at least) two levels. Geometric elements implement the element geometry (e.g. 2D quad elements, 3D brick elements, etc); these geometric elements act as base classes for specific <code>FiniteElements</code> that implement the discretisation of particular PDEs. We discuss the implementation of the two types of elements in two separate sections:<ul>
<li>In the section <a class="el" href="index.html#FEequations">How to implement a new system of equations as a specific FiniteElement</a> we describe how to discretise a new system of equations, using existing geometric elements.</li>
<li>In the section <a class="el" href="index.html#FEgeom">How to build a new geometric element</a> we discuss how to formulate new geometric elements.</li>
</ul>
</li>
</ul>
<p>In all cases, we start with a brief description of the minimum functionality that must be implemented for the various objects. The general principles are then illustrated by considering the discretisation of the model problem</p>
<center> <table class="oomph-table">
<tr>
<td class="panel panel-default"><center class="panel-heading"> <b>One-dimensional model Poisson problem</b> </center> <div class="panel-body"> Solve <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\mbox{d}^2u}{\mbox{d}x^2} = \pm 30 \sin(\sqrt{30} x), \ \ \ \ \ \ \ \ \ \ (1) \]" src="form_0.png" width="180" height="30"/>
</p>
 in the one-dimensional domain <img class="formulaInl" alt="$x\in[0,1]$" src="form_1.png" width="48" height="14"/>, subject to <p class="formulaDsp">
<img class="formulaDsp" alt="\[ u(0)=0 \ \mbox{\ \ \ and \ \ \ } \ \ u(1)=\mp 1, \ \ \ \ \ \ \ \ \ \ (2) \]" src="form_2.png" width="226" height="14"/>
</p>
 </div>   </td></tr>
</table>
</center><p>by isoparametric two-node elements. (Please consult the <a href="../../intro/html/index.html">Introduction</a> for a review of the relevant finite element theory.) The source code for this example (<a href="../../../demo_drivers/poisson/one_d_poisson_generic_only/one_d_poisson_generic_only.cc">one_d_poisson_generic_only.cc</a>) is self-contained and uses only objects from the "generic" part of the <code>oomph-lib</code> library. [<code>oomph-lib</code> does, of course, provide 1D meshes and Poisson elements but we deliberately ignore these because we wish to illustrate how to build such objects from scratch. The alternative example code <a href="../../../demo_drivers/poisson/one_d_poisson/one_d_poisson.cc">one_d_poisson.cc</a>, discussed in <a href="../../poisson/one_d_poisson/html/index.html">another example</a> illustrates the implementation of the same problem using existing library objects.]</p>
<p>The main purpose of this document is to provide a <em>"quick"</em> introduction to <code>oomph-lib's</code> fundamental objects, so the example classes presented below are fully-functional but very basic. We provide exercises at the end of each section to allow the reader to explore various straightforward improvements, most of which are implemented in the corresponding objects in the library. Finally, the section <a class="el" href="index.html#comments">Further comments</a> provides a discussion of some general design principles that should be respected when creating new classes for use with the library.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="problem"></a>
How to build a Problem</h1>
<p>All specific <code>Problems</code> should be implemented as objects that inherit from the generic <code>Problem</code> class. These specific <code>Problem</code> objects will vary considerably depending on the exact details of the problem being solved.</p>
<p>Only a few member functions <em>must</em> be implemented for each specific <code>Problem</code> class:</p><ul>
<li>The problem constructor<div class="fragment"><div class="line">SomeSpecificProblem(...) </div>
</div><!-- fragment --></li>
<li>and the member functions <div class="fragment"><div class="line">Problem::actions_before_newton_solve() </div>
</div><!-- fragment --> <div class="fragment"><div class="line">Problem::actions_after_newton_solve() </div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="spec"></a>
The constructor: SomeSpecificProblem(...)</h2>
<p>The Problem constructor <code>SomeSpecificProblem(...)</code> usually contains the following steps:</p><ul>
<li>Construction of the timestepper (if required), e.g. <div class="fragment"><div class="line">Problem::add_time_stepper_pt(<span class="keyword">new</span> SomeTimeStepper()); </div>
</div><!-- fragment --> <br  />
</li>
<li>Construction of the <code>Mesh</code> (which may involve passing a particular element type as a template parameter), e.g. <div class="fragment"><div class="line">Problem::mesh_pt() = <span class="keyword">new</span> SomeMesh&lt;SomeElement&gt;(...); </div>
</div><!-- fragment --></li>
<li>Specification of the boundary conditions. By default, all nodal values are assumed to be free and their values are initialised to zero. Therefore, we only need to "pin" the values that are prescribed by boundary conditions and assign any nonzero boundary values. For instance, the following instruction "pins" the (single) nodal value at node "0": <div class="fragment"><div class="line">Problem::mesh_pt()-&gt;node_pt(0)-&gt;pin(0); </div>
</div><!-- fragment --> A non-zero boundary value can be set by <div class="fragment"><div class="line">Problem::mesh_pt()-&gt;node_pt(0)-&gt;set_value(0,1.0); </div>
</div><!-- fragment --> This statement sets the first (= zero-th in C++'s zero-based indexing) nodal value to 1.0.</li>
<li>Completion of the build of the elements: Elements are typically constructed during the mesh generation process. To allow a generic implementation of this process, mesh constructors use an argument-free constructor to create the elements. Thus, element constructors must not have any arguments. (See the section &lsquo;new_mesh&amp;rsquo;, below, for an illustration of this process.) If an element requires any global parameters (such as pointers to physical parameters, function pointers to source functions, etc.), these parameters should be passed to the element via suitable access functions, <em>after</em> the element has been created by the mesh constructor.</li>
<li>Assignment of the global and local equation numbers <div class="fragment"><div class="line">Problem::assign_eqn_numbers(); </div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="actbef"></a>
The function Problem::actions_before_newton_solve()</h2>
<p><code>oomph-lib</code> treats all problems as non-linear problems and employs Newton's method to solve the system of nonlinear algebraic equations that results from its spatial (and, in time-dependent problems, temporal) discretisation. Within this framework, linear problems are special cases for which Newton's method converges in one step.</p>
<p>The (pure virtual) member function <code>Problem::actions_before_newton_solve()</code> should contain everything that <em>must</em> be done before a nonlinear solve to complete the specification of the problem. For example, the function may contain a call to update the boundary conditions. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> actions_before_newton_solve() {update_boundary_conditions();}</div>
</div><!-- fragment --><p>If desired, finer granularity may be obtained by overloading the empty virtual functions <code>Problem::actions_before_newton_convergence_check()</code>, <code>Problem::actions_before_newton_step()</code> and/or <code>Problem::actions_before_implicit_timestep()</code>, which are executed before each calculation of the maximum value of the residuals, each Newton step or each timestep, respectively. We refer to a <a href="../../order_of_action_functions/html/index.html">separate document</a> for a more detailed discussion of the various "action functions" executed by <code>oomph-lib's</code> Newton solver.</p>
<h2><a class="anchor" id="actafter"></a>
The function Problem::actions_after_newton_solve()</h2>
<p>The (pure virtual) member function <code>Problem::actions_after_newton_solve()</code> should contain everything that is to take place after each nonlinear solve. For example, the function might contain commands to update the values of any "dependent" variables, or post-processing commands. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> actions_after_newton_solve()</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">//Update value of the slave variable in namespace GlobalVariables</span></div>
<div class="line">  GlobalVariables::slave = node_pt(0)-&gt;value(0) + node_pt(0)-&gt;value(1);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Call the output function</span></div>
<div class="line">  ofstream output_file(<span class="stringliteral">&quot;result.dat&quot;</span>);</div>
<div class="line">  output(output_file); </div>
<div class="line"> }</div>
</div><!-- fragment --><p>Again, the finer-grained member functions <code>Problem::actions_after_newton_step()</code> and <br  />
 <code>Problem::actions_after_implicit_timestep()</code> are provided.</p>
<hr  />
<h2><a class="anchor" id="full"></a>
An example of a "complete" specific Problem</h2>
<p>Here is the full specification for the <code>DemoPoissonProblem</code> class (taken from <a href="../../../demo_drivers/poisson/one_d_poisson_generic_only/one_d_poisson_generic_only.cc">one_d_poisson_generic_only.cc</a>) which implements the discretisation of the 1D Poisson problem described above, using a <code>Mesh</code> of type <code>OneDimMesh</code>, with elements of type <code>TwoNodePoissonElements</code>.</p>
 <div class="fragment"><div class="line"><span class="keyword">class </span>DemoPoissonProblem : <span class="keyword">public</span> Problem </div>
<div class="line"> {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Problem constructor: Pass the sign of the source function (default</span></div>
<div class="line"><span class="comment">  /// is +1)</span></div>
<div class="line"><span class="comment"></span>  DemoPoissonProblem(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; sign=1) : Sign(sign)</div>
<div class="line">   {</div>
<div class="line">    <span class="comment">//Create a OneDimMesh Mesh object and set it to be the problem&#39;s mesh.</span></div>
<div class="line">    <span class="comment">//The element type, TwoNodePoissonElement, is passed  as a template </span></div>
<div class="line">    <span class="comment">//parameter to the mesh. The argument to the constructor indicates</span></div>
<div class="line">    <span class="comment">//the number of elements in the mesh.</span></div>
<div class="line">    Problem::mesh_pt() = <span class="keyword">new</span> OneDimMesh&lt;TwoNodePoissonElement&gt;(10);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Pin the unknowns at the ends of the 1D domain:</span></div>
<div class="line">    <span class="comment">//The 1D mesh has 2 boundaries, each of which contains a single node;</span></div>
<div class="line">    <span class="comment">//the nodes on the boundary are available from Mesh::boundary_node_pt(...)</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Pin the single nodal value at the single node on mesh </span></div>
<div class="line">    <span class="comment">//boundary 0 (= the left domain boundary at x=0)</span></div>
<div class="line">    mesh_pt()-&gt;boundary_node_pt(0,0)-&gt;pin(0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Pin the single nodal value at the single node on mesh </span></div>
<div class="line">    <span class="comment">//boundary 1 (= the right domain boundary at x=1)</span></div>
<div class="line">    mesh_pt()-&gt;boundary_node_pt(1,0)-&gt;pin(0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// All values are initialised to zero. This is consistent with the</span></div>
<div class="line">    <span class="comment">// boundary condition at x=0 and no further action is required</span></div>
<div class="line">    <span class="comment">// at that node.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Apply the boundary condition at x=1: u(x=1)=-/+1</span></div>
<div class="line">    mesh_pt()-&gt;boundary_node_pt(1,0)-&gt;set_value(0,-<span class="keywordtype">double</span>(Sign));</div>
<div class="line"> </div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Finish problem setup: Set the sign for the source function</span></div>
<div class="line">    <span class="comment">// in all elements</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">//Find number of elements in mesh</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> n_element = mesh_pt()-&gt;nelement();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Loop over the elements </span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_element;i++)</div>
<div class="line">     {</div>
<div class="line">      <span class="comment">// The sign() member function is defined in the </span></div>
<div class="line">      <span class="comment">// TwoNodePoissonElement class not the base GeneralisedElement class.</span></div>
<div class="line">      <span class="comment">// In order to use it, we must</span></div>
<div class="line">      <span class="comment">// upcast from GeneralisedElement to the specific element type,</span></div>
<div class="line">      <span class="comment">// which is achieved by a C++ dynamic_cast.</span></div>
<div class="line">      TwoNodePoissonElement *specific_element_pt </div>
<div class="line">       = <span class="keyword">dynamic_cast&lt;</span>TwoNodePoissonElement*<span class="keyword">&gt;</span>(mesh_pt()-&gt;element_pt(i));</div>
<div class="line">      </div>
<div class="line">      <span class="comment">// Set the sign of the source function</span></div>
<div class="line">      specific_element_pt-&gt;sign() = Sign;</div>
<div class="line">     }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Assign the global and local equations numbers for the problem</span></div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Number of equations is &quot;</span> &lt;&lt; assign_eqn_numbers() &lt;&lt; std::endl;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Check that everything has been set up properly</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> actions_before_newton_solve()</div>
<div class="line">   {</div>
<div class="line">    <span class="keywordflow">if</span> (0==self_test())</div>
<div class="line">     {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Problem has been set up correctly and can be solved.&quot;</span> </div>
<div class="line">           &lt;&lt; std::endl;</div>
<div class="line">     }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">     {</div>
<div class="line">      <span class="keywordflow">throw</span> </div>
<div class="line">       OomphLibError(<span class="stringliteral">&quot;Trouble! Check error messages and fix the problems.\n&quot;</span>,</div>
<div class="line">                     <span class="stringliteral">&quot;DemoPoissonProblem::actions_before_newton_solve()&quot;</span>,</div>
<div class="line">                     OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">     }</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Print out the result after the solve</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">void</span> actions_after_newton_solve() </div>
<div class="line">   {</div>
<div class="line">    ofstream file(<span class="stringliteral">&quot;result.dat&quot;</span>);</div>
<div class="line">    mesh_pt()-&gt;output(file);</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// The sign of the source function</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">int</span> Sign;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">}; <span class="comment">//End of problem definition</span></div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="problem_exercise"></a>
Exercises:</h2>
<ul>
<li>Compile and run the example code <a href="../../../demo_drivers/poisson/one_d_poisson_generic_only/one_d_poisson_generic_only.cc">one_d_poisson_generic_only.cc</a> and compare the numerical results against the (fish-shaped) exact solution <p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_{fish}(x) = \pm \left[ \left(\sin(\sqrt{30})-1\right) x - \sin(\sqrt{30} x)\right]. \]" src="form_3.png" width="254" height="24"/>
</p>
 (The sign of the source function is an optional argument to the problem constructor. If no argument is specified, the + sign is used.) Modify the <code>actions_after_newton_solve()</code> function so that it writes the exact solution into another file, "exact_solution.dat", say.</li>
<li>Vary the number of elements and observe how the numerical results converge to the exact solution.</li>
<li>Adjust the boundary conditions:<ul>
<li>Change the boundary condition at the left end of the domain to <img class="formulaInl" alt="$ u(0)=1$" src="form_4.png" width="46" height="14"/>.</li>
<li>What happens when you don't apply a boundary condition at <img class="formulaInl" alt="$ x=1 $" src="form_5.png" width="30" height="9"/>? (Hint: What are the natural boundary conditions for the Poisson equation?)</li>
<li>What happens when no boundary conditions are applied?</li>
</ul>
</li>
</ul>
<ul>
<li>Suppress the assignment of the equation numbers in the problem constructor and observe what happens. Check the error messages produced by <code>Problem::self_test()</code>.</li>
</ul>
<hr  />
 <hr  />
<h1><a class="anchor" id="mesh"></a>
How to build a Mesh</h1>
<p><code>oomph-lib</code> provides a large number of fully-functional <code>Mesh</code> objects. Many of these meshes can easily be adapted to discretise other domains, provided the domain has the same topology as the original <code>Mesh</code>. We shall illustrate this in section <a class="el" href="index.html#distorted_mesh">How to adapt an existing Mesh to a different domain shape</a> below.</p>
<h2><a class="anchor" id="new_mesh"></a>
How to build a completely new Mesh</h2>
<p>If the domain is too different from any of the existing meshes, a new, customised <code>Mesh</code> object, <code>SpecificMesh</code>, say, must be created. The specific mesh should be created as an object that inherits from the generic <code>Mesh</code> class. To maximise the potential for code-reuse, we recommended making the element type a template parameter of the <code>SpecificMesh</code> class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keyword">class </span>SpecificMesh : <span class="keyword">public</span> Mesh</div>
</div><!-- fragment --><p>This allows the <code>SpecificMesh</code> to be used with any <code>FiniteElement</code> that is based on the same geometric element type (see the section <a class="el" href="index.html#FEgeom">How to build a new geometric element</a> for a more detailed discussion of geometric elements).</p>
<p>The minimum requirements for a specific mesh object are that it must:</p><ul>
<li>Construct the elements and the <code>Nodes</code>,</li>
<li>Store pointers to the elements in the <code>Mesh::Element_pt</code> vector,</li>
<li>Store pointers to the <code>Nodes</code> in the <code>Mesh::Node_pt</code> vector,</li>
<li>Set the elements' pointers to their local <code>Nodes</code> </li>
<li>Set the positions of the <code>Nodes</code>.</li>
</ul>
<p>We suggest that all specific <code>Mesh</code> constructors also set up an auxiliary lookup scheme that stores information about the mesh boundaries. While this is not strictly required, it greatly facilitates the application of boundary conditions in complex domains. Firstly, the function <code>Mesh::set_nboundary(...)</code> must be called to specify the number of mesh boundaries. In addition, the generic <code>Mesh</code> class provides a function <code>Mesh::add_boundary_node(i,node_pt)</code>, which adds the <code>Node</code> pointed to by <code>node_pt</code> to the <code>Mesh's</code> i-th boundary and constructs the required look-up schemes, including a reverse lookup scheme that informs all <code>Nodes</code> which mesh boundaries (if any) they are located on. (In our simple 1D example there are only two boundaries, each consisting of a single Node.) Although this step is optional, it <em>is</em> required during mesh adaptation &ndash; if the reverse lookup scheme has not been set up, a warning is issued and the code execution stops when any mesh adaptation is attempted. <b>Implementation</b> <b>detail:</b> <code>Nodes</code> that are located on mesh boundaries must be defined as <code>BoundaryNodes</code>. <br  />
</p>
<p>The majority of the work required to build a specific <code>Mesh</code> takes place in its constructor. Typically, the constructor creates the elements (of the type specified by the template parameter <code>ELEMENT</code>) and uses the elements' member function <code>FiniteElement::construct_node(...)</code> to create the new <code>Nodes</code>. The equivalent member function <code>FiniteElement::construct_boundary_node(...)</code> is used to create new <code>BoundaryNodes</code>.</p>
<p>Here is the complete class definition for a simple, one-dimensional (line) mesh which discretises the 1D domain <img class="formulaInl" alt="$x\in [0,1]$" src="form_6.png" width="48" height="14"/> using a specified number of equally-spaced elements.  </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keyword">class </span>OneDimMesh : <span class="keyword">public</span> Mesh</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Mesh Constructor. The argument is the desired number of elements</span></div>
<div class="line"><span class="comment"></span> OneDimMesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;n_element)</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">//Resize the vector of pointers to elements: there are n_element elements</span></div>
<div class="line">  Element_pt.resize(n_element); </div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Construct the first element (Note the use of the template parameter)</span></div>
<div class="line">  Element_pt[0] = <span class="keyword">new</span> ELEMENT;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Construct the first node and add it to the Mesh::Node_pt vector</span></div>
<div class="line">  <span class="comment">//Note: The FiniteElement::construct_boundary_node(j) function</span></div>
<div class="line">  <span class="comment">//builds the element&#39;s j-th local node, and provides the functionality</span></div>
<div class="line">  <span class="comment">//that allows it to be located on a Mesh boundary -- essentially this</span></div>
<div class="line">  <span class="comment">//involves allocating additional storage to the Node.</span></div>
<div class="line">  <span class="comment">//The function obtains the Node&#39;s</span></div>
<div class="line">  <span class="comment">//characteristics (e.g. its spatial dimension, the number of</span></div>
<div class="line">  <span class="comment">//values to be stored, etc) from various virtual FiniteElement</span></div>
<div class="line">  <span class="comment">//member functions, such as FiniteElement::required_nvalue(). </span></div>
<div class="line">  <span class="comment">//FiniteElement::construct_boundary_node(...) also</span></div>
<div class="line">  <span class="comment">//stores a pointer to the newly created Node in the element&#39;s own</span></div>
<div class="line">  <span class="comment">//Node_pt vector.</span></div>
<div class="line">  <span class="comment">//Finally, the function returns the pointer to the</span></div>
<div class="line">  <span class="comment">//newly created Node, so that it can be stored in the Mesh&#39;s Node_pt</span></div>
<div class="line">  <span class="comment">//vector, as done here:</span></div>
<div class="line">  Node_pt.push_back(finite_element_pt(0)-&gt;construct_boundary_node(0));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Find the number of nodes per element (N.B. all elements are identical</span></div>
<div class="line">  <span class="comment">//so we can determine this value once and for all). </span></div>
<div class="line">  <span class="keywordtype">unsigned</span> n_node = finite_element_pt(0)-&gt;nnode();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Loop over the remaning nodes of the first element</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> n=1;n&lt;n_node;n++)</div>
<div class="line">   {</div>
<div class="line">    <span class="comment">//Construct the next node and add it to the Mesh::Node_pt vector</span></div>
<div class="line">    <span class="comment">//Note that these interior nodes need not (and should not)</span></div>
<div class="line">    <span class="comment">//be boundary nodes, so they are created using the construct_node</span></div>
<div class="line">    <span class="comment">//function, which has the same interface as</span></div>
<div class="line">    <span class="comment">//construct_boundary_node()</span></div>
<div class="line">    Node_pt.push_back(finite_element_pt(0)-&gt;construct_node(n));</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Loop over the remaining elements apart from the last</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=1;e&lt;(n_element-1);e++)</div>
<div class="line">   {</div>
<div class="line">    <span class="comment">//Construct the e-th element</span></div>
<div class="line">    Element_pt[e] = <span class="keyword">new</span> ELEMENT;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//The first local node of the e-th element is the last local node</span></div>
<div class="line">    <span class="comment">//of the (e-1)-th element. We MUST NOT construct the node twice.</span></div>
<div class="line">    <span class="comment">//Instead, we set the pointer in the e-th element to point to the</span></div>
<div class="line">    <span class="comment">//previously created node in the (e-1)-th element.</span></div>
<div class="line">    finite_element_pt(e)-&gt;node_pt(0) = </div>
<div class="line">      finite_element_pt(e-1)-&gt;node_pt(n_node-1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Loop over the remaining nodes of the e-th element</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> n=1;n&lt;n_node;n++)</div>
<div class="line">     {</div>
<div class="line">      <span class="comment">//Construct the next node and add it to the Mesh::Node_pt vector</span></div>
<div class="line">      <span class="comment">//Note that these interior nodes need not (and should not)</span></div>
<div class="line">      <span class="comment">//be boundary nodes, so they are created using the construct_node</span></div>
<div class="line">      <span class="comment">//function, which has the same interface as</span></div>
<div class="line">      <span class="comment">//construct_boundary_node()</span></div>
<div class="line">      Node_pt.push_back(finite_element_pt(e)-&gt;construct_node(n));</div>
<div class="line">     }</div>
<div class="line">   } <span class="comment">//End of loop over elements</span></div>
<div class="line">  </div>
<div class="line">  </div>
<div class="line">  <span class="comment">//Construct the final element</span></div>
<div class="line">  Element_pt[n_element-1] = <span class="keyword">new</span> ELEMENT;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">//The first local node of the final element is the last local node</span></div>
<div class="line">  <span class="comment">//of the penultimate element. We MUST NOT construct the node twice.</span></div>
<div class="line">  <span class="comment">//Instead, we set the pointer in the final element to point to the</span></div>
<div class="line">  <span class="comment">//previously created node in the penultimate element.</span></div>
<div class="line">  finite_element_pt(n_element-1)-&gt;node_pt(0) = </div>
<div class="line">   finite_element_pt(n_element-2)-&gt;node_pt(n_node-1);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Loop over the remaining central nodes of the final element</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> n=1;n&lt;(n_node-1);n++)</div>
<div class="line">   {</div>
<div class="line">    <span class="comment">//Construct the next node and add it to the Mesh::Node_pt vector</span></div>
<div class="line">    <span class="comment">//Note that these interior nodes need not (and should not)</span></div>
<div class="line">    <span class="comment">//be boundary nodes, so they are created using the construct_node</span></div>
<div class="line">    <span class="comment">//function()</span></div>
<div class="line">    Node_pt.push_back(finite_element_pt(n_element-1)-&gt;construct_node(n));</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Construct the final node and add it to the Mesh::Node_pt vector.</span></div>
<div class="line">  <span class="comment">//This node will be located on a boundary, and hence we use</span></div>
<div class="line">  <span class="comment">//the construct_boundary_node function.</span></div>
<div class="line">  Node_pt.push_back(finite_element_pt(n_element-1)</div>
<div class="line">                    -&gt;construct_boundary_node(n_node-1));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//We&#39;ve now created all the nodes -- let&#39;s set their positions:</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Find the total number of nodes</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> n_global_node = nnode();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Loop over all nodes</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> n=0;n&lt;n_global_node;n++)</div>
<div class="line">   {</div>
<div class="line">    <span class="comment">//Set the position of the node (equally spaced through the unit interval)</span></div>
<div class="line">    Node_pt[n]-&gt;x(0) = double(n)/double(n_global_node-1);</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Set the boundary data:</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">//There are two boundaries in this mesh</span></div>
<div class="line">  set_nboundary(2);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Boundary 0 contains the first node in the mesh:</span></div>
<div class="line">  add_boundary_node(0,Node_pt[0]);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Boundary 1 contains the final node in the mesh:</span></div>
<div class="line">  add_boundary_node(1,Node_pt[n_global_node-1]); </div>
<div class="line">  </div>
<div class="line"> } <span class="comment">// End of constructor</span></div>
<div class="line"> </div>
<div class="line">}; <span class="comment">// End of OneDimMesh class.</span></div>
</div><!-- fragment --><p>To build a <code>OneDimMesh</code> with ten elements of type <code>SomeElement</code>, say, the <code>Problem</code> constructor would contain the following </p><div class="fragment"><div class="line">Problem::mesh_pt() = <span class="keyword">new</span> OneDimMesh&lt;SomeElement&gt;(10);</div>
</div><!-- fragment --><h2><a class="anchor" id="distorted_mesh"></a>
How to adapt an existing Mesh to a different domain shape</h2>
<p>Given that mesh generation tends to be a fairly tedious process, one should always check whether it is possible to deform an existing <code>Mesh</code> into a shape that matches the required domain. Provided that the new domain has the same topology as the domain represented by the original <code>Mesh</code>, this can always be done by re-positioning the Nodes. Such "deformed" <code>Meshes</code> should be implemented via inheritance, by deriving the new <code>Mesh</code> from an existing one.</p>
<p>Here is an example that illustrates the procedure. Assume we wish to solve an equation in the 2D annular domain bounded (in polar coordinates) by <img class="formulaInl" alt="$ r \in [r_{min}, r_{max}] $" src="form_7.png" width="85" height="14"/> and <img class="formulaInl" alt="$ \varphi \in [\varphi_{min}, \varphi_{max}] $" src="form_8.png" width="90" height="14"/>. Inspection of the <a href="../../meshes/mesh_list/html/index.html">list of available meshes </a> shows that <code>oomph-lib</code> does not provide a mesh for this geometry. However, there is a <code>Mesh</code> object, <code>SimpleRectangularMesh</code>, which provides a uniform discretisation of a 2D rectangular domain <img class="formulaInl" alt="$ x\in [0,L_x] $" src="form_9.png" width="56" height="14"/> and <img class="formulaInl" alt="$ y \in [0,L_y] $" src="form_10.png" width="55" height="14"/> with <img class="formulaInl" alt="$ N_x \times N_y $" src="form_11.png" width="46" height="14"/> quadrilateral elements. Since the topology of the two domains is identical, the annular mesh can be implemented in a few lines of code:</p>
<div class="fragment"><div class="line"><span class="comment">//====================================================================</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// AnnularQuadMesh, derived from SimpleRectangularQuadMesh.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt; </div>
<div class="line"><span class="keyword">class </span>AnnularQuadMesh : <span class="keyword">public</span> SimpleRectangularQuadMesh&lt;ELEMENT&gt;</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// \short Constructor for angular mesh with n_r x n_phi </span></div>
<div class="line"><span class="comment"> /// 2D quad elements. Calls constructor for the underlying </span></div>
<div class="line"><span class="comment"> /// SimpleRectangularQuadMesh; then deforms the mesh so that it fits </span></div>
<div class="line"><span class="comment"> /// into the annular region bounded by the radii r_min and r_max</span></div>
<div class="line"><span class="comment"> /// and angles (in degree) of phi_min and phi_max.</span></div>
<div class="line"><span class="comment"></span> AnnularQuadMesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; n_r, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; n_phi,</div>
<div class="line">                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; r_min, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; r_max,</div>
<div class="line">                 <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; phi_min, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; phi_max) :</div>
<div class="line">  SimpleRectangularQuadMesh&lt;ELEMENT&gt;(n_r,n_phi,1.0,1.0)</div>
<div class="line">  {</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The constructor for the  SimpleRectangularQuadMesh has</span></div>
<div class="line">   <span class="comment">// built the mesh with n_x x n_y = n_r x n_phi elements in the unit</span></div>
<div class="line">   <span class="comment">// square. Let&#39;s reposition the nodal points so that the mesh</span></div>
<div class="line">   <span class="comment">// gets mapped into the required annular region:</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Find out how many nodes there are</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_node=nnode();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Calculate the value of pi</span></div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">double</span> pi = 4.0*atan(1.0);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Loop over all nodes</span></div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> n=0;n&lt;n_node;n++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Pointer to node:</span></div>
<div class="line">     Node* nod_pt=node_pt(n);</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Get the x/y coordinates</span></div>
<div class="line">     <span class="keywordtype">double</span> x_old=nod_pt-&gt;x(0);</div>
<div class="line">     <span class="keywordtype">double</span> y_old=nod_pt-&gt;x(1);</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Map from the old x/y to the new r/phi:</span></div>
<div class="line">     <span class="keywordtype">double</span> r=r_min+(r_max-r_min)*x_old;</div>
<div class="line">     <span class="keywordtype">double</span> phi=(phi_min+(phi_max-phi_min)*y_old)*pi/180.0;</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Set new nodal coordinates</span></div>
<div class="line">     nod_pt-&gt;x(0)=r*cos(phi);</div>
<div class="line">     nod_pt-&gt;x(1)=r*sin(phi);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="mes_exercise"></a>
Exercise:</h2>
<p>Modify the <code>OneDimMesh</code> object so that it provides a piecewise uniform discretisation of the domain <img class="formulaInl" alt="$ x \in [0,1]$" src="form_12.png" width="48" height="14"/>: <img class="formulaInl" alt="$ N_0 $" src="form_13.png" width="15" height="13"/> equally spaced elements are to be placed in the the region <img class="formulaInl" alt="$ x \in [0,\hat{x}]$" src="form_14.png" width="49" height="14"/>, while <img class="formulaInl" alt="$ N_1 $" src="form_15.png" width="15" height="13"/> elements are to be placed in the the region <img class="formulaInl" alt="$ x \in [\hat{x},1]$" src="form_16.png" width="49" height="14"/>. Pass the parameters <img class="formulaInl" alt="$ N_0, N_1 $" src="form_17.png" width="35" height="13"/> and <img class="formulaInl" alt="$\hat{x} $" src="form_18.png" width="8" height="10"/> to the mesh constructor. Construct the modified mesh via inheritance from the basic <code>OneDimMesh</code> and include an error check to confirm that <img class="formulaInl" alt="$ 0 &lt; \hat{x} &lt; 1 $" src="form_19.png" width="54" height="11"/>.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="finiteelement"></a>
How to build a FiniteElement</h1>
<p><code>oomph-lib</code> provides fully-functional <code>FiniteElements</code> for the discretisation of a wide range of PDEs. Most of the existing elements are constructed in a three-level hierarchy, the base being the generic <code>FiniteElement</code> class. The next level in the hierarchy contains geometric elements (e.g. 1D line elements, 2D quad or triangular elements, 3D brick elements, etc.). These geometric classes form the bases for elements that implement the discretisation of particular PDEs. This hierarchy maximises the potential for code-reuse, because it allows many different specific elements to be derived from the same geometric element.</p>
<p>We shall discuss the implementation of new element types in two sections:</p><ul>
<li><a class="el" href="index.html#FEequations">How to implement a new system of equations as a specific FiniteElement</a></li>
<li><a class="el" href="index.html#FEgeom">How to build a new geometric element</a></li>
</ul>
<hr  />
<h2><a class="anchor" id="FEequations"></a>
How to implement a new system of equations as a specific FiniteElement</h2>
<p>Assume that we wish to design a new element type, <code>SpecificElement</code>, say, that implements the discretisation of a system of PDEs on an existing geometric element. The <code>SpecificElement</code> class needs to implement the following functions:</p><ul>
<li>The function that specifies the number of nodal values required at each of the element's nodes: <div class="fragment"><div class="line">FiniteElement::required_nvalue(n) </div>
</div><!-- fragment --></li>
<li>The function that computes the element's residual vector: <div class="fragment"><div class="line">FiniteElement::get_residuals(residuals) </div>
</div><!-- fragment --></li>
<li>The function that computes the element's Jacobian matrix and its residual vector: <div class="fragment"><div class="line">FiniteElement::get_jacobian(residuals,jacobian) </div>
</div><!-- fragment --></li>
<li>The output function: <div class="fragment"><div class="line">FiniteElement::output(ostream) </div>
</div><!-- fragment --></li>
</ul>
<p>Most specific finite element classes will contain further member functions and member data to provide additional, problem-specific functionality. As a concrete example, we consider the <code>TwoNodePoissonElement</code>, a specific <code>FiniteElement</code> that provides an isoparametric discretisation of the 1D Poisson equation (1), based on the geometric element <code>TwoNodeGeometricElement</code>, to be discussed below:  </p><div class="fragment"><div class="line"><span class="keyword">class </span>TwoNodePoissonElement : <span class="keyword">public</span> TwoNodeGeometricElement</div>
</div><!-- fragment --><p> In addition to the <code>FiniteElement</code> member functions discussed above, this element provides a function that defines the source function <img class="formulaInl" alt="$ f(x) $" src="form_20.png" width="24" height="14"/>,  </p><div class="fragment"><div class="line">  <span class="keywordtype">double</span> f(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;x) <span class="keyword">const</span> </div>
<div class="line">   {</div>
<div class="line">    <span class="keywordflow">return</span> double(Sign)*30.0*sin(sqrt(30.0)*x);</div>
<div class="line">   }</div>
</div><!-- fragment --><p> where the sign of the source function is stored as private member data  </p><div class="fragment"><div class="line">  <span class="keywordtype">int</span> Sign;</div>
</div><!-- fragment --><p> and can be set by the access function  </p><div class="fragment"><div class="line">  <span class="keywordtype">int</span>&amp; sign() {<span class="keywordflow">return</span> Sign;}</div>
</div><!-- fragment --><p> We provide a member function that returns the (single) nodal value stored at a specified local node in the element,  </p><div class="fragment"><div class="line">  <span class="keywordtype">double</span> u(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;n) {<span class="keywordflow">return</span> node_pt(n)-&gt;value(0);}</div>
</div><!-- fragment --><p> Finally, it is good practice to implement a self-test function that provides a sanity check of all data before the problem is solved. <code>oomph-lib</code> already provides self-test functions for all fundamental objects. Additional tests can be added by overloading these. For instance, in our Poisson element, the <code>Sign</code> variable should only take the values <img class="formulaInl" alt="$ \pm 1 $" src="form_21.png" width="15" height="9"/>. This can be tested with the following function, which also executes the <code>self_test()</code> function of the underlying <code>FiniteElement:</code>  </p><div class="fragment"><div class="line"><span class="comment">  /// Self test function: The sign in the source function should</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// only have the values +/- 1. Following the general oomph-lib convention,</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// the self_test() returns 0 for success, and 1 for failure:</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">unsigned</span> self_test()</div>
<div class="line">   {</div>
<div class="line">    <span class="comment">// Initialise success flag</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> success=0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Run the generic FiniteElement self test</span></div>
<div class="line">    success=FiniteElement::self_test();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Do additional test for this function</span></div>
<div class="line">    <span class="keywordflow">if</span> ((Sign!=1)&amp;&amp;(Sign!=-1))</div>
<div class="line">     {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Sign of source function should be +/- 1,&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;but it is:&quot;</span> &lt;&lt; Sign &lt;&lt; std::endl;</div>
<div class="line">      success=1;</div>
<div class="line">     }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Return success flag</span></div>
<div class="line">    <span class="keywordflow">return</span> success;</div>
<div class="line"> </div>
<div class="line">   } <span class="comment">// End of self test</span></div>
</div><!-- fragment --><p> We will now discuss the implementation of the generic <code>FiniteElement</code> member functions for the specific <code>TwoNodePoissonElement:</code> </p>
<h3><a class="anchor" id="Fereq_nvalue"></a>
The function FiniteElement::required_nvalue(n)</h3>
<p>The function returns the number of values that are stored at the element's <code>n-th</code> local node. In our scalar Poisson problem, each node stores one value:</p>
 <div class="fragment"><div class="line"><span class="comment">  /// For the Poisson equation, only one value is stored at each node</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">unsigned</span> required_nvalue(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;n)<span class="keyword"> const </span>{<span class="keywordflow">return</span> 1;}</div>
</div><!-- fragment --><p> The function is used by <code>FiniteElement::construct_node(...)</code> to determine the amount of storage to be allocated at each of the element's <code>Nodes</code>.</p>
<h3><a class="anchor" id="residuals"></a>
The function FiniteElement::get_residuals(residuals)</h3>
<p>This function calculates the element's residual vector whose entries are labelled by the <em>local</em> equation numbers. (Consult the <a href="../../intro/html/index.html">Introduction</a> for a detailed discussion of the weak form of Poisson's equation and its finite element discretisation which produces the discrete residual implemented here.) The spatial integration over the element is performed by the (default) integration scheme specified in the underlying geometric element. Note that it should (must) not be assumed that the residuals vector has been set to zero before the function call. </p><div class="fragment"><div class="line">  <span class="keywordtype">void</span> get_residuals(Vector&lt;double&gt; &amp;residuals)</div>
<div class="line">   {</div>
<div class="line">    <span class="comment">//Find the number of degrees of freedom (unpinned values) in the element</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> n_dof = ndof();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Initialise all the residuals to zero</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_dof;i++) {residuals[i] = 0.0;}</div>
<div class="line">    </div>
<div class="line">    <span class="comment">//Find the number of nodes in the element</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> n_node = nnode();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Allocate memory for shape functions and their derivatives:</span></div>
<div class="line">    <span class="comment">// There&#39;s one shape function for each node:</span></div>
<div class="line">    Shape psi(n_node);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Each of the n_node shape functions has one derivative with </span></div>
<div class="line">    <span class="comment">// respect to the single local coordinate:</span></div>
<div class="line">    DShape dpsidx(n_node,1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Storage for the single local coordinate</span></div>
<div class="line">    Vector&lt;double&gt; s(1);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">//Find the number of integration points in the underlying </span></div>
<div class="line">    <span class="comment">//geometric element&#39;s integration scheme </span></div>
<div class="line">    <span class="keywordtype">unsigned</span> n_intpt = integral_pt()-&gt;nweight();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Loop over the integration points</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ipt=0;ipt&lt;n_intpt;ipt++)</div>
<div class="line">     {</div>
<div class="line">      <span class="comment">//Set the value of the local coordinate to be the integration </span></div>
<div class="line">      <span class="comment">//scheme&#39;s knot point</span></div>
<div class="line">      s[0] = integral_pt()-&gt;knot(ipt,0);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">//Find the weight of the integration scheme at this knot point</span></div>
<div class="line">      <span class="keywordtype">double</span> w = integral_pt()-&gt;weight(ipt);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">//Find the shape functions and their derivatives at the knot point. </span></div>
<div class="line">      <span class="comment">//This function is implemented in FiniteElement.</span></div>
<div class="line">      <span class="comment">//It also returns the Jacobian of the mapping from local to </span></div>
<div class="line">      <span class="comment">//global coordinates.</span></div>
<div class="line">      <span class="keywordtype">double</span> J = dshape_eulerian(s,psi,dpsidx);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">//Premultiply the weight and the Jacobian</span></div>
<div class="line">      <span class="keywordtype">double</span> W = w*J;</div>
<div class="line">      </div>
<div class="line">      <span class="comment">//Allocate storage for the value of the field variable u,</span></div>
<div class="line">      <span class="comment">//its derivative and the global position at the knot point.</span></div>
<div class="line">      <span class="comment">//Initialise them all to zero.</span></div>
<div class="line">      <span class="keywordtype">double</span> interpolated_x=0.0, interpolated_u=0.0, interpolated_dudx=0.0;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">//Calculate the interpolated values by  looping over the shape </span></div>
<div class="line">      <span class="comment">//functions and summing the appropriate contributions</span></div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> n=0;n&lt;n_node;n++) </div>
<div class="line">       {</div>
<div class="line">        interpolated_x += nodal_position(n,0)*psi[n];</div>
<div class="line">        interpolated_u += u(n)*psi[n];</div>
<div class="line">        interpolated_dudx += u(n)*dpsidx(n,0);</div>
<div class="line">       }</div>
<div class="line">      </div>
<div class="line">      <span class="comment">// Evaluate the source function</span></div>
<div class="line">      <span class="keywordtype">double</span> source=f(interpolated_x);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">//ASSEMBLE THE RESIDUALS</span></div>
<div class="line">      </div>
<div class="line">      <span class="comment">//Loop over the test functions (same as the shape functions</span></div>
<div class="line">      <span class="comment">//since we&#39;re implementing an isoparametric element)</span></div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> l=0;l&lt;n_node;l++)</div>
<div class="line">       {</div>
<div class="line">        <span class="comment">//Get the local equation number</span></div>
<div class="line">        <span class="comment">//The variable is the first (only) value stored at the nodes</span></div>
<div class="line">        <span class="keywordtype">int</span> local_eqn_number = nodal_local_eqn(l,0);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//If the equation is not a Dirichlet boundary condition</span></div>
<div class="line">        <span class="keywordflow">if</span>(local_eqn_number &gt;= 0)</div>
<div class="line">         {</div>
<div class="line">          <span class="comment">//Add body force/source term here </span></div>
<div class="line">          residuals[local_eqn_number] += source*psi[l]*W;</div>
<div class="line"> </div>
<div class="line">          <span class="comment">//Add the Poisson bit itself</span></div>
<div class="line">          residuals[local_eqn_number] += interpolated_dudx*dpsidx(l,0)*W;</div>
<div class="line">         }</div>
<div class="line">       }</div>
<div class="line"> </div>
<div class="line">     } <span class="comment">//End of loop over the integration points</span></div>
<div class="line"> </div>
<div class="line">   } <span class="comment">//End of function</span></div>
</div><!-- fragment --> <h3><a class="anchor" id="jac"></a>
The function FiniteElement::get_jacobian(residuals,jacobian)</h3>
<p>This function calculates the element's Jacobian matrix and its residual vector, performing the spatial integration with the (default) integration scheme defined in the underlying geometric element. The entries in the Jacobian matrix and the residual vector are labelled by the <em>local</em> equation numbers. Note that neither the residuals vector nor the Jacobian matrix should be assumed to have been initialised to zero before the function call. </p><div class="fragment"><div class="line">  <span class="keywordtype">void</span> get_jacobian(Vector&lt;double&gt; &amp;residuals, DenseMatrix&lt;double&gt; &amp;jacobian)</div>
<div class="line">   {</div>
<div class="line">    <span class="comment">//First, calculate the residuals</span></div>
<div class="line">    get_residuals(residuals);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Find the number of degrees of freedom (unpinned values) in the element</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> n_dof = ndof();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Initialise all entries of the Jacobian matrix to zero</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_dof;i++) </div>
<div class="line">     {</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;n_dof;j++) {jacobian(i,j) = 0.0;}</div>
<div class="line">     }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">//Find the number of nodes in the element</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> n_node = nnode();</div>
<div class="line">    <span class="comment">//Allocate memory for shape functions and their derivatives</span></div>
<div class="line">    Shape psi(n_node);</div>
<div class="line">    DShape dpsidx(n_node,1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Storage for the local coordinate</span></div>
<div class="line">    Vector&lt;double&gt; s(1);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">//Find the number of integration points in the underlying</span></div>
<div class="line">    <span class="comment">//geometric element&#39;s integration scheme </span></div>
<div class="line">    <span class="keywordtype">unsigned</span> n_intpt = integral_pt()-&gt;nweight();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Loop over the integration points</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ipt=0;ipt&lt;n_intpt;ipt++)</div>
<div class="line">     {</div>
<div class="line">      <span class="comment">//Set the value of the local coordinate to be the integration </span></div>
<div class="line">      <span class="comment">//scheme&#39;s knot point</span></div>
<div class="line">      s[0] = integral_pt()-&gt;knot(ipt,0);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">//Find the weight of the integration scheme at this knot point</span></div>
<div class="line">      <span class="keywordtype">double</span> w = integral_pt()-&gt;weight(ipt);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">//Find the shape functions and their derivatives at the knot point. </span></div>
<div class="line">      <span class="comment">//This function is implemented in FiniteElement.</span></div>
<div class="line">      <span class="comment">//It also returns the Jacobian of the mapping from local to </span></div>
<div class="line">      <span class="comment">//global coordinates.</span></div>
<div class="line">      <span class="keywordtype">double</span> J = dshape_eulerian(s,psi,dpsidx);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">//Premultiply the weight and the Jacobian</span></div>
<div class="line">      <span class="keywordtype">double</span> W = w*J;</div>
<div class="line">            </div>
<div class="line">      <span class="comment">//ASSEMBLE THE JACOBIAN TERMS</span></div>
<div class="line">      </div>
<div class="line">      <span class="comment">//Loop over the test (shape) functions</span></div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> l=0;l&lt;n_node;l++)</div>
<div class="line">       {</div>
<div class="line">        <span class="comment">//Get the local equation number</span></div>
<div class="line">        <span class="comment">//The variable is the first (only) value stored at the nodes</span></div>
<div class="line">        <span class="keywordtype">int</span> local_eqn_number = nodal_local_eqn(l,0);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//If the equation is not a Dirichlet boundary condition</span></div>
<div class="line">        <span class="keywordflow">if</span>(local_eqn_number &gt;= 0)</div>
<div class="line">         {</div>
<div class="line">          <span class="comment">//Loop over the degrees of freedom</span></div>
<div class="line">          <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> l2=0;l2&lt;n_node;l2++)</div>
<div class="line">           {</div>
<div class="line">            <span class="comment">//Get the local degree of freedom number</span></div>
<div class="line">            <span class="comment">//The variable is the first (only) value stored at the nodes</span></div>
<div class="line">            <span class="keywordtype">int</span> local_dof_number = nodal_local_eqn(l2,0);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">//If the degree of freedom is not pinned</span></div>
<div class="line">            <span class="keywordflow">if</span>(local_dof_number &gt;= 0)</div>
<div class="line">             {</div>
<div class="line">              <span class="comment">//Add the contribution to the Jacobian</span></div>
<div class="line">              jacobian(local_eqn_number,local_dof_number) += </div>
<div class="line">               dpsidx(l2,0)*dpsidx(l,0)*W;</div>
<div class="line">             }</div>
<div class="line">           }</div>
<div class="line">         }</div>
<div class="line">       }</div>
<div class="line">     } <span class="comment">//End of loop over the integration points</span></div>
<div class="line"> </div>
<div class="line">   } <span class="comment">//End of function</span></div>
</div><!-- fragment --><p> <b>Note:</b> There is a large amount of code duplication between the <code>get_residuals()</code> and <code>get_jacobian()</code> functions. To avoid this, we usually implement the computation of the residual vector and the Jacobian matrix in a single function containing the loop over the integration points. We then use a boolean flag as an additional argument to determine whether the Jacobian matrix should be assembled, e.g. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> get_generic_residual_contribution(Vector&lt;double&gt;&amp; residuals,</div>
<div class="line">                                       DenseMatrix&lt;double&gt;&amp; jacobian,</div>
<div class="line">                                       <span class="keywordtype">bool</span> flag)         </div>
</div><!-- fragment --><h3><a class="anchor" id="FEout"></a>
The function FiniteElement::output(out_stream)</h3>
<p>The output function is used to print the nodal values over the element </p><div class="fragment"><div class="line">  <span class="keywordtype">void</span> output(ostream &amp;output) </div>
<div class="line">   {</div>
<div class="line">    <span class="comment">//Read out the number of nodes in the element   </span></div>
<div class="line">    <span class="keywordtype">unsigned</span> n_node = nnode();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Loop over the nodes and print out the global coordinate </span></div>
<div class="line">    <span class="comment">//and value of the field variable, u, at each node</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> n=0;n&lt;n_node;n++)</div>
<div class="line">     {</div>
<div class="line">      output &lt;&lt; nodal_position(n,0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; u(n) &lt;&lt; std::endl;</div>
<div class="line">     }</div>
<div class="line">   } <span class="comment">//End of function</span></div>
</div><!-- fragment --> <hr  />
 <h2><a class="anchor" id="FE_exercise"></a>
Exercises:</h2>
<ul>
<li>Implement the function <code>get_generic_residual_contribution(...)</code> as a private member function of the <code>TwoNodePoissonElement</code>. Use the function to avoid the large amount of code duplication between <code>get_residuals(...)</code> and <code>get_jacobian(...)</code> by re-writing these functions as follows: <div class="fragment"><div class="line"><span class="comment">/// \short Calculate the elemental contributions to the residuals for </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// the weak form of the Poisson equation</span></div>
<div class="line"><span class="comment"></span><span class="keywordtype">void</span> get_residuals(Vector&lt;double&gt; &amp;residuals)</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// Set flag for not computing the Jacobian</span></div>
<div class="line">  <span class="keywordtype">bool</span> flag=<span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Dummy Jacobian</span></div>
<div class="line">  DenseMatrix&lt;double&gt; jacobian;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute the residuals only:</span></div>
<div class="line">  get_generic_residual_contribution(residuals,jacobian,flag);</div>
<div class="line"> }</div>
</div><!-- fragment --> and <div class="fragment"><div class="line"><span class="comment">/// \short Calculate the elemental contribution to the Jacobian </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// matrix dR_{i}/du_{j} used in the Newton method</span></div>
<div class="line"><span class="comment"></span><span class="keywordtype">void</span> get_jacobian(Vector&lt;double&gt; &amp;residuals, DenseMatrix&lt;double&gt; &amp;jacobian)</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// Set flag for computing the Jacobian matrix</span></div>
<div class="line">  <span class="keywordtype">bool</span> flag=<span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute the residuals and the Jacobian matrix:</span></div>
<div class="line">  get_generic_residual_contribution(residuals,jacobian,flag);</div>
<div class="line"> }</div>
</div><!-- fragment --></li>
<li>The implementation of the specific source function <br  />
 <img class="formulaInl" alt="$ f(x) $" src="form_20.png" width="24" height="14"/> in <code>TwoNodePoissonElement::f(...)</code> makes it impossible to use the <code>TwoNodePoissonElement</code> to solve the Poisson equation with any other source functions, even though the discretisation of the ODE would otherwise be completely identical. A better implementation would allow the "user" to specify a different source function without having to change the implementation of the element class itself. <br  />
 <br  />
 Here is a suggestion for an improved implementation, which illustrates the procedure employed in the existing elements in <code>oomph-lib</code>:<ul>
<li>Introduce a public typedef into the element class to define the required format of the function pointer: <div class="fragment"><div class="line"><span class="comment">/// \short Function pointer to source function: </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// The source function returns the value of the </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// source function at the global coordinate x.</span></div>
<div class="line"><span class="comment"></span><span class="keyword">typedef</span> double (*PoissonSourceFctPt)(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; x);</div>
</div><!-- fragment --></li>
<li>Add a function pointer to the private data of the <code>TwoNodePoissonElement</code> class and initialise it to NULL in the constructor: <div class="fragment"><div class="line"><span class="comment">/// \short Function pointer to source function (initialised to</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// NULL in the constructor)</span></div>
<div class="line"><span class="comment"></span>PoissonSourceFctPt Source_fct_pt;</div>
</div><!-- fragment --></li>
<li>Provide an access function for the source function pointer: <div class="fragment"><div class="line"><span class="comment">/// \short Access function to pointer to source function</span></div>
<div class="line"><span class="comment"></span>PoissonSourceFctPt&amp; source_fct_pt() {<span class="keywordflow">return</span> Source_fct_pt;}</div>
</div><!-- fragment --></li>
<li>Re-write the <code>TwoNodePoissonElement::f(...)</code> function, so that it evaluates the (global) function pointed to by the source function pointer. If possible, provide a default value for the case when the function pointer has not been set: <div class="fragment"><div class="line"><span class="comment">/// Evaluate source function at Eulerian position x</span></div>
<div class="line"><span class="comment"></span><span class="keywordtype">double</span> f(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; x)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{ </div>
<div class="line">  <span class="comment">//If no source function has been set, return zero</span></div>
<div class="line">  <span class="comment">//so that the Poisson equation defaults to a Laplace equation.</span></div>
<div class="line">  <span class="keywordtype">double</span> source=0.0;</div>
<div class="line">  <span class="keywordflow">if</span>(Source_fct_pt!=0)</div>
<div class="line">   {</div>
<div class="line">    <span class="comment">// Evaluate source function </span></div>
<div class="line">    source = (*Source_fct_pt)(x);</div>
<div class="line">   }</div>
<div class="line">  <span class="keywordflow">return</span> source;</div>
<div class="line"> }</div>
</div><!-- fragment --></li>
</ul>
</li>
</ul>
<p>The pointer to the source function (typically defined in a suitable namespace in the "user's" driver code) can now be set in the Problem constructor.</p><ul>
<li>Generalise the <code>TwoNodePoissonElement</code> to a <code>TwoNodeSelfAdjointElement</code> that implements the isoparametric discretisation of the self-adjoint ODE <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\mbox{d}}{\mbox{d}x} \left( a(x) \frac{\mbox{d}u}{\mbox{d}x} \right) + b(x) u(x) = f(x). \ \ \ \ \ \ \ \ \ (3) \]" src="form_22.png" width="235" height="31"/>
</p>
 Use function pointers to allow the "user" to specify the coefficient functions <img class="formulaInl" alt="$ a(x), \ b(x) $" src="form_23.png" width="54" height="14"/> and <img class="formulaInl" alt="$ f(x) $" src="form_20.png" width="24" height="14"/>.</li>
</ul>
<hr  />
<h2><a class="anchor" id="FEgeom"></a>
How to build a new geometric element</h2>
<p>Geometric elements define the geometry of a <code>FiniteElement</code>. They are usually implemented as distinct classes that can then be used to create a number of <code>FiniteElements</code> each discretising a specific PDE, but with the same underlying geometrical representation. For this purpose, each geometric <code>FiniteElement</code> must implement the following functions:</p><ul>
<li>The constructor <div class="fragment"><div class="line">SomeGeometricFiniteElement::SomeGeometricFiniteElement() </div>
</div><!-- fragment --> must perform the following actions:<ul>
<li>Set the number of Nodes by calling the protected member function <div class="fragment"><div class="line">FiniteElement::set_n_node(n_node). </div>
</div><!-- fragment --></li>
<li>Set the dimension of the element by calling the protected member function<div class="fragment"><div class="line">FiniteElement::set_dimension(dim)</div>
</div><!-- fragment --> Here the dimension of the element is defined as the number of local coordinates required to parametrise its shape. (Note that this is not necessarily the same as the spatial dimension of the problem &ndash; we can have one-dimensional <code>FiniteElements</code> in 3D space, say.)</li>
<li><b>Optional:</b> Set the spatial integration scheme by calling the protected member function<div class="fragment"><div class="line">FiniteElement::set_integration_scheme(&amp;integration_scheme) </div>
</div><!-- fragment --></li>
<li><b>Optional:</b> If the spatial dimension (= the number of Eulerian coordinates) required at all Nodes in the element is different from the spatial dimension of the element then set the "nodal dimension" by calling the protected member function<div class="fragment"><div class="line">FiniteElement::set_nodal_dimension(dim)</div>
</div><!-- fragment --> For example in shell elements, a two-dimensional surface is embedded in a three-dimensional space, so the elemental dimension is two, but the nodal dimension is three.</li>
<li><b>Optional:</b> If the Eulerian coordinate (position) is interpolated using generalised coordinates, e.g. vector-valued shape functions, or Hermite-type interpolation, set the number of generalised coordinates or "position types" by using the protected member function <div class="fragment"><div class="line">FiniteElement::set_n_nodal_position_type(n_position_type)</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>The function that computes the element's (geometric) shape functions at specified values of the local coordinates. These shape functions are primarily used to implement the mapping between the element's local coordinates and the global (Eulerian) coordinates. <br  />
 The geometric shape functions <em>can</em> be (and often are) also used in specific <code>FiniteElements</code> to interpolate the unknown function(s) between the nodal values. <div class="fragment"><div class="line">FiniteElement::shape(s,psi) </div>
</div><!-- fragment --></li>
</ul>
<p>It is usually necessary to implement the following additional functions:</p><ul>
<li>The function that computes the derivatives of the element's shape functions with respect to the local coordinates, <div class="fragment"><div class="line">FiniteElement::dshape_local(s,psi,dpsids) </div>
</div><!-- fragment --></li>
<li>The function that specifies the number of Nodes along the element's 1D "edges" <br  />
 <div class="fragment"><div class="line">FiniteElement::nnode_1d() </div>
</div><!-- fragment --></li>
</ul>
<p>Further member functions and member data may be defined as and when required. For instance, all specific <code>FiniteElements</code> must store a pointer to an (instantiated) spatial integration scheme. It is good practice to provide a default integration scheme for each geometric element and to ensure its instantiation by making it a static data member of the geometric element class. This allows the constructor of the geometric element to set the pointer to the default integration scheme. If the default is not appropriate for a specific derived <code>FiniteElement</code>, the default assignment can be over-written in the constructor of the derived class.</p>
<p>As a concrete example, we consider the implementation of the one-dimensional, two-node geometric element, <code>TwoNodeGeometricElement</code>, that uses linear shape functions to define the mapping between the element's local and global coordinates. The element is derived from the <code>FiniteElement</code> base class,  </p><div class="fragment"><div class="line"><span class="keyword">class </span>TwoNodeGeometricElement : <span class="keyword">public</span> FiniteElement</div>
</div><!-- fragment --><p> and it uses a one-dimensional, two-point Gauss rule as the default spatial integration scheme </p><div class="fragment"><div class="line"> <span class="comment">/// Integration scheme that will be used to integrate over the element.</span></div>
<div class="line"><span class="comment"> /// Simple Gaussian quadrature in one dimension, with two Gauss points.</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">static</span> Gauss&lt;1,2&gt; Default_spatial_integration_scheme;</div>
</div><!-- fragment --><p> Here is the implementation of the generic <code>FiniteElement</code> member functions for our specific geometric <code>FiniteElement:</code> </p>
<h3><a class="anchor" id="Geomconst"></a>
The constructor: TwoNodeGeometricElement()</h3>
<p>The constructor sets the number of local nodes in the element (2), sets the dimension of the element (1) and sets the pointer to the spatial integration scheme to be the default that is defined and instantiated as a static data member of the class: </p><div class="fragment"><div class="line"> TwoNodeGeometricElement()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Linear interpolation requires two Nodes per element.</span></div>
<div class="line">   <span class="comment">//In fact, calling this function merely provides storage for </span></div>
<div class="line">   <span class="comment">//the pointers to the Nodes and initialises the pointers to NULL. </span></div>
<div class="line">   <span class="comment">//The Nodes themselves are created during the mesh generation </span></div>
<div class="line">   <span class="comment">//process by the functions FiniteElement::construct_node(...) </span></div>
<div class="line">   <span class="comment">//which stores the pointers to the newly created Nodes </span></div>
<div class="line">   <span class="comment">//in the element&#39;s own internal storage.</span></div>
<div class="line">   this-&gt;set_n_node(2);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//The element is one-dimensional </span></div>
<div class="line">   this-&gt;set_dimension(1);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Set the pointer to the spatial integration scheme</span></div>
<div class="line">   set_integration_scheme(&amp;Default_spatial_integration_scheme);</div>
<div class="line">  }</div>
</div><!-- fragment --> <h3><a class="anchor" id="shape"></a>
The function FiniteElement::shape(s,psi)</h3>
<p>This function returns the shape functions at the local element coordinate, s. The shape functions are used to interpolate the position, and also, any data values stored at nodes in derived, isoparametric elements. </p><div class="fragment"><div class="line"> <span class="keywordtype">void</span> shape(<span class="keyword">const</span> Vector&lt;double&gt; &amp;s, Shape &amp;psi) <span class="keyword">const</span></div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//There are two shape functions (one per node)</span></div>
<div class="line">   <span class="comment">//In terms of the local coordinate, s[0]:</span></div>
<div class="line">   <span class="comment">//Node 0 is at s[0] = -1.0</span></div>
<div class="line">   <span class="comment">//Node 1 is at s[0] =  1.0</span></div>
<div class="line">   </div>
<div class="line">   <span class="comment">//psi[0] takes the value one at node 0 and zero at node 1</span></div>
<div class="line">   psi[0] = 0.5*(1.0 - s[0]);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//psi[1] takes the value one at node 1 and zero at node 0</span></div>
<div class="line">   psi[1] = 0.5*(1.0 + s[0]);</div>
<div class="line">  }</div>
</div><!-- fragment --> <h3><a class="anchor" id="dshape"></a>
The function FiniteElement::dshape_local(s,psi,dpsids)</h3>
<p>This function returns the shape functions and their derivatives with respect to the local coordinates </p><div class="fragment"><div class="line"> <span class="keywordtype">void</span> dshape_local(<span class="keyword">const</span> Vector&lt;double&gt; &amp;s, Shape &amp;psi, DShape &amp;dpsids) <span class="keyword">const</span></div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Call the shape functions</span></div>
<div class="line">   shape(s,psi);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//The derivative of psi[0] wrt s[0] is -0.5</span></div>
<div class="line">   dpsids(0,0) = -0.5;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//The derivative of psi[0] wrt s[0] is 0.5</span></div>
<div class="line">   dpsids(1,0) = 0.5;</div>
<div class="line">  }</div>
</div><!-- fragment --><h3><a class="anchor" id="nnode_1d"></a>
The function FiniteElement::nnode_1d()</h3>
<p>Return the number of nodes along the element's 1d "edge" &ndash; for a one-dimensional element, this is obviously the same as the number of nodes: </p><div class="fragment"><div class="line"> <span class="keywordtype">unsigned</span> nnode_1d()<span class="keyword"> const </span>{<span class="keywordflow">return</span> 2;}</div>
</div><!-- fragment --> <hr  />
 <h2><a class="anchor" id="geom_element_exercise"></a>
Exercises:</h2>
<ul>
<li>Change the <code>TwoNodeGeometricElement</code> to a <code>ThreeNodeGeometricElement</code> in which quadratic interpolation is used to interpolate the Eulerian coordinates between the nodal points. Use this element as a basis for a <code>ThreeNodePoissonElement</code> and convince yourself that changing the <code>TwoNodePoissonElement</code> to a <code>ThreeNodePoissonElement</code> only requires the change of a single line of code!</li>
<li>Use templating to generalise the geometric elements to an arbitrary number of nodes so that the class <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> NNODE&gt;</div>
<div class="line"><span class="keyword">class </span>GeometricLineElement : <span class="keyword">public</span> FiniteElement</div>
</div><!-- fragment --> represents 1D line elements with <code>NNODE</code> nodes. Consider carefully which member functions you can implement in generality and which member functions require specialised implementations. Provide the specialised member functions for elements with two, three and four nodes.</li>
<li>Use the templated <code>GeometricLineElements</code> to implement an equivalent generalisation of the <code>TwoNodePoissonElement</code> and <code>ThreeNodePoissonElement</code> classes to the general class <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> NNODE&gt;</div>
<div class="line"><span class="keyword">class </span>PoissonLineElement : <span class="keyword">public</span> GeometricLineElement&lt;NNODE&gt;</div>
</div><!-- fragment --></li>
<li>Validate all elements against the exact solution and confirm the theoretical error estimate which predicts that if the domain <img class="formulaInl" alt="$ x \in [0,1]$" src="form_12.png" width="48" height="14"/> is discretised with <img class="formulaInl" alt="$ N $" src="form_24.png" width="11" height="10"/> equally spaced <img class="formulaInl" alt="$n$" src="form_25.png" width="9" height="6"/>-node line elements, we have <p class="formulaDsp">
<img class="formulaDsp" alt="\[ e = \sqrt{ \int_0^1 \left( u_{FE}(x) - u_{exact}(x) \right) ^2 dx } \sim h^{(n-1)} \mbox{ \ \ \ \ as $N \to \infty$} \]" src="form_26.png" width="321" height="38"/>
</p>
 where <img class="formulaInl" alt="$ h = 1/N $" src="form_27.png" width="46" height="14"/>.</li>
</ul>
<hr  />
 <hr  />
<h1><a class="anchor" id="comments"></a>
Further comments</h1>
<p>We reiterate that the main purpose of this document is to provide a <em>quick</em> introduction to <code>oomph-lib's</code> fundamental objects. The exercises have already highlighted several undesirable features of the simple example classes which could easily be improved to facilitate the (re-)use of the classes in different problems. Here we shall briefly discuss some further modifications that we regard as good practice, and which tend to be implemented in the existing classes in <code>oomph-lib</code>:</p><ul>
<li><a class="el" href="index.html#dim_independent">Dimension-independent implementation</a></li>
<li><a class="el" href="index.html#pre_compute_psi">Using pre-computed shape functions and the StorableShapeElement&lt;ELEMENT&gt; class</a></li>
<li><a class="el" href="index.html#equation_classes">Further sub-division of specific element classes &ndash; equation classes.</a></li>
<li><a class="el" href="index.html#paranoia">Implement extensive (but optional) self tests in all classes</a></li>
<li><a class="el" href="index.html#magic">The use of "magic numbers"</a></li>
<li><a class="el" href="index.html#multi_physics">Facilitating the use of specific elements in multi-physics problems</a></li>
</ul>
<hr  />
<h2><a class="anchor" id="dim_independent"></a>
Dimension-independent implementation</h2>
<p>The exercises in the section <a class="el" href="index.html#FEgeom">How to build a new geometric element</a> suggest the use of templating to implement families of objects. This idea also permits the implementation of (geometric and specific) <code>FiniteElements</code> in arbitrary spatial dimensions. For instance, <code>oomph-lib's</code> <code>QElement</code> class represents the family of (line/quadrilateral/brick-shaped) geometric elements with an arbitrary number of nodes along the elements' 1D edges. Thus, a <code>QElement&lt;1,3&gt;</code> is a three-node 1D line element, a <code>QElement&lt;3,2&gt;</code> is an eight-node 3D brick element, etc.</p>
<p>These geometric elements naturally form the basis for corresponding specific elements, such as the <code>QPoissonElement</code> family which provides an isoparametric discretisation of the Poisson equation (in an arbitrary spatial dimension), based on the <code>QElements</code> with the same template parameters.</p>
<hr  />
<h2><a class="anchor" id="pre_compute_psi"></a>
Using pre-computed shape functions and the StorableShapeElement&lt;ELEMENT&gt; class</h2>
<p>The computation of the element's residual vector and the Jacobian matrix requires the evaluation of the element's shape functions, <img class="formulaInl" alt="$ \psi_j $" src="form_28.png" width="14" height="14"/>, and their derivatives with respect to the global coordinate, <img class="formulaInl" alt="$ \mbox{d}\psi_j/\mbox{d}x $" src="form_29.png" width="41" height="14"/>, at the element's integration points. In our simple example class, <code>TwoNodePoissonElement</code>, we (re-)compute these functions "on the fly", using the function </p><div class="fragment"><div class="line">FiniteElement::dshape_eulerian(s,psi,dpsidx)</div>
</div><!-- fragment --><p> where the local coordinate of the integration point is passed in the (one-dimensional) vector <code>s</code>.</p>
<p>The re-computation is wasteful because:</p><ul>
<li>The values of the shape functions and their derivatives, evaluated at the integration point, are independent of the value of the <code>Sign</code> variable. Their re-computation during the second solve could therefore be avoided if we stored their values in a suitable container.</li>
<li>The values of the shape functions at the integration points are identical for all elements. Therefore we only need to provide storage for the shape function values in a single, representative element. The other elements can access the values via pointers.</li>
</ul>
<p>To circumvent these potential inefficiencies, <code>oomph-lib</code> provides alternative interfaces for various functions that compute shape functions and their derivatives:</p><ul>
<li>Calls to the function <div class="fragment"><div class="line">FiniteElement::shape(s,psi)</div>
</div><!-- fragment --> which computes the shape function at a given local coordinate, <code>s</code>, can be replaced by <div class="fragment"><div class="line">FiniteElement::shape_at_knot(int_point,psi)</div>
</div><!-- fragment --> where the <code>unsigned</code> argument <code>int_point</code> identifies the integration point (as specified by the element's spatial integration scheme). In "standard" <code>FiniteElements</code> the function <code>FiniteElement::shape_at_knot(...)</code> simply determines the position of the integration point and calls <code>FiniteElement::shape(...)</code> and so the shape functions are still computed "on the fly". The templated class <code>StorableShapeElement&lt;ELEMENT&gt;</code>, however, may be used to upgrade any class derived from <code>FiniteElement</code> into a class that <b>can</b> store the values of the shape functions and their derivatives at the integration points. The function <code>shape_at_knot(...)</code> is overloaded so that when called for the first time, it computes the values of the shape function at all integration points and stores them for future reference. In subsequent calls, the function returns the stored values, rather than re-computing them.</li>
<li>There are equivalent alternatives for the functions that compute the shape functions and their derivatives with respect to the local coordinates: <div class="fragment"><div class="line">FiniteElement::dshape(s,psi,dpsids)</div>
</div><!-- fragment --> can be replaced by <div class="fragment"><div class="line">FiniteElement::dshape_at_knot(int_point,psi,dpsids)</div>
</div><!-- fragment --> while <div class="fragment"><div class="line">FiniteElement::d2shape(s,psi,dpsids,d2psids)</div>
</div><!-- fragment --> can be replaced by <div class="fragment"><div class="line">FiniteElement::d2shape_at_knot(int_point,psi,dpsids,d2psids)</div>
</div><!-- fragment --></li>
</ul>
<p>These functions are all overloaded in the <code>StorableShapeElement&lt;ELEMENT&gt;</code> class and by default the overloaded functions store the pre-computed values of the shape functions and their derivatives locally within each element. This implementation ensures data locality and should increase the speed of access to the stored values. However, it can also create significant storage overheads. <code>oomph-lib</code> therefore provides the function </p><div class="fragment"><div class="line">StorableShapeElement&lt;ELEMENT&gt;::set_shape_local_stored_from_element(...)</div>
</div><!-- fragment --><p> which frees up the storage in the element and replaces it by pointer-based access to the values stored in another element. Typically, all elements in a mesh are of the same type and use the same spatial integration scheme and so the values of the shape functions need only be stored in one element.</p>
<p>Derivatives of the element's shape functions with respect to the global Eulerian coordinates are generally computed by </p><div class="fragment"><div class="line">FiniteElement::dshape_eulerian(s,psi,dpsidx)</div>
</div><!-- fragment --><p> and </p><div class="fragment"><div class="line">FiniteElement::d2shape_eulerian(s,psi,dpsidx,d2psidx)</div>
</div><!-- fragment --><p> These functions also return the Jacobian of the mapping between the local and global coordinates &ndash; the Jacobian can also be computed independently from </p><div class="fragment"><div class="line">FiniteElement::J_eulerian(s)</div>
</div><!-- fragment --><p> The derivatives of the shape functions with respect the global coordinates depend on the nodal positions, and it is not safe to assume that they will remain constant. For instance in moving boundary problems, the position of the nodes is determined as part of the solution. By default, the functions </p><div class="fragment"><div class="line">StorableShapeElement&lt;ELEMENT&gt;::dshape_eulerian_at_knot(int_point,psi,dpsidx)</div>
</div><!-- fragment --> <div class="fragment"><div class="line">StorableShapeElement&lt;ELEMENT&gt;::d2shape_eulerian_at_knot(int_point,psi,dpsidx,d2psidx)</div>
</div><!-- fragment --><p> and </p><div class="fragment"><div class="line">StorableShapeElement&lt;ELEMENT&gt;::J_eulerian_at_knot(int_point)</div>
</div><!-- fragment --><p> re-compute the derivatives at the specified integration point "on the fly". If the "user" is confident that in his/her problem, the nodal positions will not change, the values can be pre-computed by calling </p><div class="fragment"><div class="line">StorableShapeElement&lt;ELEMENT&gt;::pre_compute_dshape_eulerian_at_knots()</div>
</div><!-- fragment --> <div class="fragment"><div class="line">StorableShapeElement&lt;ELEMENT&gt;::pre_compute_d2shape_eulerian_at_knots()</div>
</div><!-- fragment --> <div class="fragment"><div class="line">StorableShapeElement&lt;ELEMENT&gt;::pre_compute_J_eulerian_at_knots()</div>
</div><!-- fragment --><p> Once these functions have been called, any subsequent calls to the <code>*_eulerian_at_knot</code>(...) functions return the stored values. To revert to the case in which the derivatives are re-computed "on the fly", the storage for the derivatives must be deleted by <br  />
 calling </p><div class="fragment"><div class="line">StorableShapeElement&lt;ELEMENT&gt;::delete_dshape_eulerian_stored()</div>
</div><!-- fragment --><p><b>Notes:</b> </p><ul>
<li>In the (unlikely!) case that an element's spatial integration scheme is changed during the code execution, all stored values are automatically re-computed.</li>
<li>The class <code>StorableShapeSolidElement&lt;ELEMENT&gt;</code> provides equivalent overloaded functions for derivatives with respect to the element's Lagrangian coordinates that are used in solid mechanics problems.</li>
</ul>
<hr  />
<h2><a class="anchor" id="equation_classes"></a>
Further sub-division of specific element classes – equation classes.</h2>
<p>We suggested that any newly developed elements should be constructed in a three-level hierarchy, <code>FiniteElement</code> &ndash; Geometric Element &ndash; Specific <code>FiniteElement</code>. Most finite elements in <code>oomph-lib</code> incorporate an additional intermediate "equation class" which implements the computation of the element residual vector and the element Jacobian matrix in terms of abstract shape and test functions, defined as pure virtual functions in the "equation class". This makes it easy to change the specific element formulation, without having to re-implement the weak form of the governing equation.</p>
<p>Note that different element types may store the same physical variable at different locations. For example, the pressure in the Navier&ndash;Stokes equations may be stored as internal <code>Data</code> (discontinuous) or nodal <code>Data</code> (continuous). Particular equation classes may require internal numbering schemes that store the appropriate local equation numbers for each physical variable. These schemes must be assembled for each specific element in the function <code>GeneralisedElement::assign_additional_local_eqn_numbers()</code>, which is called from within <code>Problem::assign_eqn_numbers()</code>.</p>
<p>As an example, consider the weak form of the 2D advection diffusion equation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int \left(\mbox{Pe} \ \sum_{i=1}^2 w_i \frac{\partial u}{\partial x_i} \psi^{(test)}_l + \sum_{i=1}^2 \frac{\partial u}{\partial x_i} \frac{\partial \psi^{(test)}_l}{\partial x_i} \right) dA = 0, \]" src="form_30.png" width="289" height="39"/>
</p>
<p> where the Peclet number, <img class="formulaInl" alt="$ Pe $" src="form_31.png" width="15" height="10"/> , and the "wind" <img class="formulaInl" alt="$w_i \ (i=1,2)$" src="form_32.png" width="66" height="14"/> are given. We expand the unknown function <img class="formulaInl" alt="$u(x_1,x_2)$" src="form_33.png" width="48" height="14"/> in terms of the (global) basis functions <img class="formulaInl" alt="$ \psi^{(basis)}_k(x_1,x_2), \ (k=1,...,N)$" src="form_34.png" width="163" height="19"/>, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u(x_1,x_2) = \sum_{k=1}^N U_k \ \psi^{(basis)}_k(x_1,x_2), \]" src="form_35.png" width="188" height="38"/>
</p>
<p> where <img class="formulaInl" alt="$N$" src="form_36.png" width="11" height="10"/> is the total number of nodes in the mesh. The mapping between the element's local and global coordinates is represented in terms of the local shape functions <img class="formulaInl" alt="$\psi^{(shape)}_j(s_1,s_2)$" src="form_37.png" width="81" height="20"/> as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_i = \sum_{j=1}^n X_{ij} \ \psi^{(shape)}_j(s_1,s_2) \]" src="form_38.png" width="151" height="38"/>
</p>
<p> where <img class="formulaInl" alt="$ n $" src="form_39.png" width="9" height="6"/> is the number of nodes in the element.</p>
<p>The following sketch illustrates how this discretisation is implemented in <code>oomph-lib's</code> <code>QAdvectionDiffusionElement</code> &ndash; an isoparametric, quadrilateral element, based on the Galerkin discretisation of the weak form with <img class="formulaInl" alt="$ \psi^{(shape)}_j = \psi^{(test)}_j = \psi^{(basis)}_j $" src="form_40.png" width="149" height="20"/></p>
<div class="image">
<img src="advection_diffusion_element_inheritance.gif" alt=""/>
<div class="caption">
Typical inheritance diagram for oomph-lib elements </div></div>
 <p>At large Peclet number, the Galerkin discretisation of the advection diffusion equation is well-known to produce spurious "wiggles" in the solution. These can be suppressed by SUPG stabilisation which employs test functions, <img class="formulaInl" alt="$ \psi_j^{(test)} $" src="form_41.png" width="34" height="20"/>, that differ from the basis function, <img class="formulaInl" alt="$ \psi_j^{(basis)} $" src="form_42.png" width="39" height="20"/>, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \psi_j^{(test)} = \psi_j^{(basis)} + \tau^{(SUPG)} \sum_{i=1}^2 w_i \frac{\partial \psi_j^{(basis)}}{\partial x_i}, \]" src="form_43.png" width="239" height="39"/>
</p>
<p> where <img class="formulaInl" alt="$ \tau^{(SUPG)} $" src="form_44.png" width="45" height="13"/> is a stabilisation parameter. This can be implemented with a trivial change to the <code>QAdvectionDiffusionElement</code> class &ndash; the <code>QSUPGAdvectionDiffusionElement</code> simply provides a different implementation of the test functions.</p>
<hr  />
<h2><a class="anchor" id="paranoia"></a>
Implement extensive (but optional) self tests in all classes</h2>
<p>We have already illustrated the use of <code>oomph-lib's</code> generic <code>self_test()</code> functions. The top-level <code>Problem::self_test()</code> function performs a systematic test of all fundamental objects involved in a specific problem and can be used to diagnose any problems. It is good practise to implement further <code>self_test()</code> functions in any newly developed classes. The generic <code>self_test()</code> functions are defined to be virtual functions in <code>oomph-lib's</code> fundamental objects and can be overloaded. Obviously, the <code>self_test()</code> function in a specific derived object should still call the <code>self_test()</code> function of the underlying fundamental object. The <code>TwoNodePoissonElement::self_test()</code> function, listed in in the section <a class="el" href="index.html#FEequations">How to implement a new system of equations as a specific FiniteElement</a> illustrates the procedure.</p>
<p>While frequent sanity checks are helpful during code-development, they can introduce significant overheads into the code execution. <code>oomph-lib</code> therefore provides a compiler flag PARANOID, which allows the execution of sanity checks to be switched on or off. When developing new classes, sanity checks should be implemented to catch any potential problems, but the relevant code should be surrounded by <code>ifdef/endif</code> statements to allow the tests to be disabled. Here is an example: </p><div class="fragment"><div class="line"><span class="preprocessor"> #include &lt;typeinfo&gt;</span></div>
<div class="line"> </div>
<div class="line">  [...]</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Recast to a different pointer type</span></div>
<div class="line">  SomeOtherObject* other_pt=<span class="keyword">dynamic_cast&lt;</span>SomeOtherObject*<span class="keyword">&gt;</span>(some_pt);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"> #ifdef PARANOID</span></div>
<div class="line">  <span class="keywordflow">if</span> (other_pt==0)</div>
<div class="line">   {</div>
<div class="line">   std::ostringstream error_stream;</div>
<div class="line">     error_stream &lt;&lt; <span class="stringliteral">&quot;Failed to cast some_pt to SomeOtherObject* &quot;</span>  </div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">     error_stream &lt;&lt; <span class="stringliteral">&quot;The pointer some_pt points to an object of type: &quot;</span> &lt;&lt;</div>
<div class="line">                  &lt;&lt; <span class="keyword">typeid</span>(some_pt).name() &lt;&lt; std::endl; </div>
<div class="line">     <span class="keywordflow">throw</span> OomphLibError(error_stream.str(),</div>
<div class="line">                         OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                         OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor"> #endif </span></div>
<div class="line"> </div>
<div class="line">[...]</div>
</div><!-- fragment --><p> Note that we throw a specific <code>OomphLibError</code> object after catching the error &ndash; this allows the provision of more explicit (and hopefully more meaningful) error messages.</p>
<p>Many access functions that provide indexed access to a private container, do, in fact, access a private STL vector. Explicit range checking for these (frequent!) cases can be avoided by changing the container to <code>oomph-lib's</code> <code>Vector</code> class. The <code>Vector</code> class performs automatic range checking, if <code>oomph-lib's</code> <code>generic</code> library is compiled with the <code>RANGE_CHECKING</code> flag set (i.e. if <code>-DRANGE_CHECKING</code> is specified as a compilation flag for the C++ compiler). For access functions that do not use the <code>Vector</code> class you should implement your own range checks using the RANGE_CHECKING compiler flag.</p>
<hr  />
<h2><a class="anchor" id="magic"></a>
The use of "magic numbers"</h2>
<p>In general, we set the equation number to -1 to indicate that a nodal value is pinned, i.e. prescribed by boundary conditions. This convention is used throughout <code>oomph-lib</code>, but the direct use of -1 as a (bad!) "magic number" is generally avoided. Instead we refer to the static data member of the <code>Data</code> class </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">long</span> Data::Is_pinned </div>
</div><!-- fragment --><p> which is (of course) set to -1. Similarly, when nodes are created, the equation numbers of their value(s) are initialised to a value of -10, represented by the static data member </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> Data::Is_unclassified </div>
</div><!-- fragment --><p> This allows the function <code>Problem::self_test()</code> to check if any values have not been classified as pinned or free.</p>
<hr  />
<h2><a class="anchor" id="multi_physics"></a>
Facilitating the use of specific elements in multi-physics problems</h2>
<p>As the name of the library suggests, <code>oomph-lib's</code> existing "single-physics" elements are (and any newly designed ones should be) designed so that they can easily be used in multi-physics problems. We anticipate two types of multi-physics interactions:</p><ul>
<li>The solution of one system of equations affects the geometry of the domain in which another equation is solved &ndash; this occurs, for instance, in fluid-structure interaction problems.</li>
<li>Two physical phenomena occur in the same domain and interact with each other, so that forcing terms in one equation depend on the solution of another &ndash; this occurs, for instance, in thermo-elasticity problems where the temperature distribution (determined by the solution of an unsteady heat equation, say) affects the "growth term" in the equations of elasticity.</li>
</ul>
<p>Multi-physics elements for such problems are usually implemented by combining two (or more) single-physics elements via multiple inheritance. The combined, multi-physics element will obviously have a larger number of degrees of freedom than the constituent single-physics elements. The combined element typically calls the <code>get_residuals(...)</code> function of the two constituent elements and concatenates their residual vectors. When computing the Jacobian matrix, the "single physics" elements provide the diagonal blocks for the Jacobian matrix of the multi-physics element, while the off-diagonal interaction blocks must be computed separately. The details of the implementation vary from problem to problem. However, any single-physics element must satisfy the following requirements if it is to be used as a base class for derived multi-physics elements:</p><ul>
<li><a class="el" href="index.html#dont_wipe">Rule 1: Elements must only initialise their own entries in the element residual vector and the element Jacobian matrix</a></li>
<li><a class="el" href="index.html#virtual">Rule 2: Forcing functions, etc. should be implemented as uniquely-named virtual functions</a></li>
<li><a class="el" href="index.html#index_fcts">Rule 3: Nodal values should only be accessed indirectly via index functions that can be overloaded in derived multi-physics elements</a></li>
<li><a class="el" href="index.html#mesh_movement">Rule 4: Time derivatives should be implemented in the ALE formulation to allow for moving meshes.</a></li>
</ul>
<hr  />
<h3><a class="anchor" id="dont_wipe"></a>
Rule 1: Elements must only initialise their own entries in the element residual vector and the element Jacobian matrix</h3>
<p>The computation of the element residual vector and the element Jacobian matrix typically involves a loop over the element's integration points, in which each integration point adds a further contribution to the entries. In multi-physics problems it is crucial that the initialisation of the residual vector and the Jacobian matrix only sets the element's "own" entries to zero.</p>
<p>To illustrate this point, consider what would happen if we used the <code>TwoNodePoissonElement::get_jacobian(...)</code> function, discussed in the section <a class="el" href="index.html#jac">The function FiniteElement::get_jacobian(residuals,jacobian)</a>, in a derived multi-physics element, which combines the <code>TwoNodePoissonElement</code> with another element, <code>TwoNodeSomeOtherEquationElement</code>, say. Assume that we implement the function <code>get_jacobian(...)</code> of the combined element so that it first calls the function <code>TwoNodeSomeOtherEquationElement::get_jacobian(...)</code> to determine the first diagonal block in the combined Jacobian matrix. When we call <code>TwoNodePoissonElement::get_jacobian(...)</code> to compute the entries in the second diagonal block, the initialisation loop</p>
<div class="fragment"><div class="line"><span class="comment">//Find the number of degrees of freedom (unpinned values) in the element</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_dof = ndof();</div>
<div class="line"><span class="comment">//Initialise all entries of the Jacobian matrix to zero</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_dof;i++) </div>
<div class="line"> {</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;n_dof;j++) {jacobian(i,j) = 0.0;}</div>
<div class="line"> }</div>
</div><!-- fragment --><p>would initialise the <em>entire</em> Jacobian matrix, thus wiping out the entries that were already computed by <br  />
 <code>TwoNodeSomeOtherEquationElement::get_jacobian(...)</code>.</p>
<p>The strategy used in <code>oomph-lib</code> to permit the easy combination of elements is to use the two protected member functions of the <code>GeneralisedElement</code> class: </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> GeneralisedElement::fill_in_contribution_to_residuals(Vector&lt;double&gt;&amp;residuals);</div>
</div><!-- fragment --><p>and</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> GeneralisedElement::fill_in_contribution_to_jacobian(Vector&lt;double&gt; &amp;residuals,</div>
<div class="line">                                                                  DenseMatrix&lt;double&gt; &amp;jacobian); </div>
</div><!-- fragment --><p>These functions DO NOT initialise the entries of the residuals vector or the Jacobian matrix. Instead, the functions merely add the appropriate contributions to the vector and the matrix entries. The default version of the <code>get_residuals()</code> and <code>get_jacobian()</code> functions, defined in <code>GeneralisedElement</code>, are simple wrappers that initialise the residuals and Jacobian to zero and then call the appropriate <code>fill_in_contribution</code>... function. </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> GeneralisedElement::get_residuals(Vector&lt;double&gt; &amp;residuals) </div>
<div class="line">{</div>
<div class="line"> <span class="comment">//Zero the residuals vector</span></div>
<div class="line"> residuals.initialise(0.0);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Add the elemental contribution to the residuals vector</span></div>
<div class="line"> fill_in_contribution_to_residuals(residuals);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> GeneralisedElement::get_jacobian(Vector&lt;double&gt; &amp;residuals, </div>
<div class="line">                                              DenseMatrix&lt;double&gt; &amp;jacobian) </div>
<div class="line">{</div>
<div class="line"> <span class="comment">//Zero the residuals vector</span></div>
<div class="line"> residuals.initialise(0.0);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Zero the Jacobian matrix</span></div>
<div class="line"> jacobian.initialise(0.0);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Add the elemental contribution to the residuals vector and Jacobian</span></div>
<div class="line"> fill_in_contribution_to_jacobian(residuals,jacobian);</div>
<div class="line">} </div>
</div><!-- fragment --><p>The <code>get_residuals</code> function, for example, can thus be overloaded in a multi-physics element, as follows: </p><div class="fragment"><div class="line"><span class="comment">/// Multi-physics element, created by multiple inheritance</span></div>
<div class="line"><span class="comment"></span><span class="keyword">class </span>SomeMultiPhysicsElement : <span class="keyword">public</span> <span class="keyword">virtual</span> TwoNodePoissonElement,</div>
<div class="line">                                <span class="keyword">public</span> <span class="keyword">virtual</span> TwoNodeSomeOtherEquationElement</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> [...]</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Residual vector of the combined element is made from the entries</span></div>
<div class="line"><span class="comment"> /// of the constituent single-physics elements</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> get_residuals(Vector&lt;double&gt; &amp;residuals) </div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Zero the residuals vector</span></div>
<div class="line">   residuals.initialise(0.0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Add the first elemental contribution to the residuals vector</span></div>
<div class="line">  TwoNodePoissonElement::fill_in_contribution_to_residuals(residuals);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Add the second elemental contribution to the residuals vector</span></div>
<div class="line">   TwoNodeSomeOtherEquationElement::fill_in_contribution_to_residuals(residuals);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  [...]</div>
<div class="line"> </div>
<div class="line"> };</div>
</div><!-- fragment --><p>It is, therefore, recommended that authors of "single-physics" elements, overload <code>fill_in_contribution_to_residuals(...)</code> and <code>fill_in_contribution_to_jacobian(...)</code>, rather than <code>get_residuals()</code> and <code>get_jacobian(...)</code>, respectively. A further advantage of the implementation is that the author need not worry about initialisation of the residuals vector or the Jacobian matrix when using the <code>"fill_in_"</code> rather than the <code>"get_"</code> functions.</p>
<h3><a class="anchor" id="virtual"></a>
Rule 2: Forcing functions, etc. should be implemented as  uniquely-named virtual functions</h3>
<p>To allow for an interaction between multiple equations, any forcing functions (such as the source function in the Poisson equation) should be implemented as virtual functions. This allows them to be overloaded in derived, multi-physics elements where the forcing function in one equation might depend on the unknowns in another one.</p>
<p>Furthermore, to avoid clashes of function names that may occur when two single-physics elements are combined, member functions that can be expected to have counterparts in the context of other equations should be given suitable modifiers. For instance, </p><div class="fragment"><div class="line">AdvectionDiffusionEquation::source_fct_adv_diff(...)</div>
</div><!-- fragment --><p> is a better name for a member function that returns the source function in the advection-diffusion equations than </p><div class="fragment"><div class="line">AdvectionDiffusionEquation::source_fct(...)</div>
</div><!-- fragment --><p> since many other equations are likely to have source functions, too. It is obviously impossible to completely avoid such clashes but this strategy makes them less likely to occur. We are fairly confident that the relevant member functions of all existing elements in <code>oomph-lib</code> have been given suitable modifiers to avoid clashes of this type. Therefore, you should be able to combine any element with any other element in the library. If you find a counter-example <a href="../../contact/html/index.html">let us know</a>, and we will rectify this in the next release. In the meantime exploit the fact that <code>oomph-lib</code> is an open source library; you can change anything you want!</p>
<h3><a class="anchor" id="index_fcts"></a>
Rule 3: Nodal values should only be accessed indirectly via index functions that can be overloaded in derived multi-physics elements</h3>
<p>When implementing the single-physics <code>TwoNodePoissonElement</code>, discussed above, we provided an access function <code>u(n)</code> that returns the (single) nodal value, stored at the element's <code>n</code> -th <code>Node</code>. The function was implemented as a simple wrapper that followed the pointer to the element's <code>n</code> -th <code>Node</code> and returned the zero-th nodal value stored at that <code>Node:</code> </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> TwoNodePoissonElement::u(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;n) </div>
<div class="line"> {</div>
<div class="line">  <span class="keywordflow">return</span> node_pt(n)-&gt;value(0);</div>
<div class="line"> }</div>
</div><!-- fragment --><p>In a single-physics context, this implementation is perfectly acceptable since we know <em>a</em> <em>priori</em> that in a scalar problem each <code>Node</code> only stores a single value.</p>
<p>The same logic suggests that a <code>TwoNodeAdvectionDiffusionElement</code> would have a member function </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> TwoNodeAdvectionDiffusionElement::u(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;n) </div>
<div class="line"> {</div>
<div class="line">  <span class="keywordflow">return</span> node_pt(n)-&gt;value(0);</div>
<div class="line"> }</div>
</div><!-- fragment --><p>However, merging these two elements via multiple inheritance creates two problems. First we have clash of names which could have been avoided by following rule 2 above and calling the two functions <code>TwoNodePoissonElement::u_poisson(...)</code> and <code>TwoNodeAdvectionDiffusionElement::u_adv_diff(...)</code>, say. More serious is that both elements regard the zero-th nodal value as "their own". This can (and should!) be avoided by the following re-implementation:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> TwoNodePoissonElement::u(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;n) </div>
<div class="line"> {</div>
<div class="line">  <span class="keywordflow">return</span> node_pt(n)-&gt;value(u_index_poisson());</div>
<div class="line"> }</div>
</div><!-- fragment --><p>where the virtual function <code>u_index_poisson()</code> provides the default index at which the Poisson nodal values are stored in a single-physics context:</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> TwoNodePoissonElement::u_index_poisson()</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// By default (i.e. in a single-physics context) the Poisson </span></div>
<div class="line">  <span class="comment">// value is stored at the zero-th nodal value:</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line"> }</div>
</div><!-- fragment --><p>The advection-diffusion element can be modified in the same way:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> TwoNodeAdvectionDiffusionElement::u(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;n) </div>
<div class="line"> {</div>
<div class="line">  <span class="keywordflow">return</span> node_pt(n)-&gt;value(u_index_adv_diff());</div>
<div class="line"> }</div>
</div><!-- fragment --><p>with</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> TwoNodeAdvectionDiffusionElement::u_index_adv_diff()</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// By default (i.e. in a single-physics context) the advection-diffusion</span></div>
<div class="line">  <span class="comment">// value is stored at the zero-th nodal value:</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line"> }</div>
</div><!-- fragment --><p>In a combined multi-physics problem, we can now merge the two elements by multiple inheritance,</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>TwoNodeAdvDiffAndPoissonElement : </div>
<div class="line">       <span class="keyword">public</span> <span class="keyword">virtual</span> TwoNodePoissonElement,</div>
<div class="line">       <span class="keyword">public</span> <span class="keyword">virtual</span> TwoNodeAdvectionDiffusionElement</div>
</div><!-- fragment --><p>Name clashes are already avoided, so we only have to overwrite the two index functions to indicate which (scalar) value is stored as which nodal value:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> TwoNodeAdvDiffAndPoissonElement::u_index_adv_diff()</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// In the combined multi-physics element we continue to store the </span></div>
<div class="line">  <span class="comment">// advection-diffusion value at the zero-th nodal value</span></div>
<div class="line">  <span class="comment">// [as a result it is not actually necessary to re-implement this</span></div>
<div class="line">  <span class="comment">// function!]</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line"> }</div>
</div><!-- fragment --><p>and</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> TwoNodeAdvDiffAndPoissonElement::u_index_poisson()</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// In the combined multi-physics element we store the Poisson</span></div>
<div class="line">  <span class="comment">// value at the first nodal value:</span></div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line"> }</div>
</div><!-- fragment --><p>Specific examples that illustrate the creation of (non-trivial) multi-physics elements by multiple inheritance are provided in the <a href="../../example_code_list/html/index.html#multi">list of example codes.</a></p>
<h3><a class="anchor" id="mesh_movement"></a>
Rule 4: Time derivatives should be implemented in the ALE formulation to allow for moving meshes.</h3>
<p>In moving mesh problems, the time-derivative of a nodal value (approximated by the Node's <code>TimeStepper</code>) is not the same as the Eulerian time-derivative <img class="formulaInl" alt="$ \partial/ \partial t $" src="form_45.png" width="25" height="14"/> that "usually" occurs in the governing equation. The former represents the rate of change when following the moving node; the latter is the rate of change evaluated at a fixed Eulerian position. The two time-derivatives are related to each other via the ALE relation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left. \frac{\partial (.)}{\partial t} \right|_{Eulerian} = \left. \frac{\partial (.) }{\partial t} \right|_{at \ node} - \ \sum_{i=1}^D v_i^{(Mesh)} \ \frac{\partial (.) }{ \partial x_i} \]" src="form_46.png" width="256" height="38"/>
</p>
<p> where <img class="formulaInl" alt="$ D $" src="form_47.png" width="10" height="10"/> is the spatial dimension of the problem and <img class="formulaInl" alt="$ v_i^{(Mesh)} \ (i=1,...,D) $" src="form_48.png" width="114" height="19"/> is the velocity of the node. Any Eulerian time-derivatives in the governing equation should be implemented in the above form to ensure that the element remains functional in moving mesh problems. See the <a href="../../unsteady_heat/two_d_unsteady_heat_ALE/html/index.html">example describing the solution of the unsteady heat equation in a moving domain</a> for further details.</p>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:13:46
        </div>
      </div>
    </footer>
</body>
</html>
