<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: quick_guide.txt_doxygenified.h Source File</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../figures/manifest.json">
<link rel="mask-icon" href="../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../html/index.html"><img alt="oomph-lib" src="../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Get it <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../doc/subversion/html/index.html">Get code from subversion repository</a></li>
            <li><a href="../../../doc/download/html/index.html">Get code as tar file</a></li>
            <li><a href="../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">quick_guide.txt_doxygenified.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="quick__guide_8txt__doxygenified_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">\mainpage (Not-So-)Quick Users Guide</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">The purpose of this document is to provide a &quot;quick&quot; introduction to the</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">fundamental objects in \c oomph-lib. Assuming that you </span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">- have a basic understanding of the finite element method</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">.</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">and</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">- are reasonably familiar with object-oriented programming in C++,</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">.</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">the Quick Guide should enable you to solve basic PDE </span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">problems using \c oomph-lib. You should also consult</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">the extensive &lt;A HREF=&quot;../../example_code_list/html/index.html&quot;&gt;</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">list of example codes&lt;/A&gt; distributed with the library. </span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">\section main_how_to How to solve simple PDEs with oomph-lib</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">  To solve a given PDE with \c oomph-lib, its discretisation </span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">needs to be specified in a \c Problem object. </span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">This usually involves the specification of the \c Mesh and </span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment">the element types, followed by the application of the boundary conditions. </span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">If these steps are performed in the \c Problem constructor,</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment">the driver code itself can be as simple as:</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">\dontinclude one_d_poisson_generic_only.cc</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">\skipline main(</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">\until } </span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment">The amount of work required to represent a given PDE as</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">a \c Problem object is problem-dependent:</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment">- If \c oomph-lib&#39;s existing \c Mesh objects and element types</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment">  are sufficient to discretise the problem, the generation of</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment">  a fully-functional \c Problem object is straightforward. We shall discuss</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment">  this case in the section \ref problem. </span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment">- If \c oomph-lib provides the required element type but none of the</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment">  available meshes are suitable, </span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment">  you will have to write your own \c Mesh object. We shall discuss this in </span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment">  the section \ref mesh. It is also possible to create</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">  \c oomph-lib meshes based on the output from third-party (commercial)</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">  mesh generators. This is illustrated in </span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment">  &lt;A HREF=&quot;../../meshes/third_party_meshes/html/index.html&quot;&gt;</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment">  another example.&lt;/A&gt; </span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment">- Finally, the problem might involve a PDE for which \c oomph-lib</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment">  does not provide any suitable elements. In this case you </span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="comment">  will need to write your own element. When implementing elements</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment">  in \c oomph-lib the element formulation is generally sub-divided into </span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment">  (at least) two levels. Geometric elements implement the element geometry</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">  (e.g. 2D quad elements, 3D brick elements, etc); these geometric elements</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment">  act as base classes for specific \c FiniteElements that implement</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment">  the discretisation of particular PDEs. We discuss the</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment">  implementation of the two types of elements in two separate sections:</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">  - In the section \ref FEequations we describe how to</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment">    discretise a new system of equations, using existing</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment">    geometric elements.</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment">  - In the section \ref FEgeom we discuss how to formulate new geometric</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment">    elements.</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment">.</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">  </span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment">In all cases, we start with a brief description of</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment">the minimum functionality that must be implemented for the</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment">various objects. The general principles are then illustrated</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment">by considering the discretisation of the model problem</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment">&lt;CENTER&gt;</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment">&lt;TABLE class=&quot;oomph-table&quot;&gt;</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment">&lt;TR&gt;</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment">&lt;TD class=&quot;panel panel-default&quot;&gt;</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment">&lt;CENTER class=&quot;panel-heading&quot;&gt;</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment">&lt;B&gt;One-dimensional model Poisson problem&lt;/B&gt;</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="comment">&lt;/CENTER&gt;</span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="comment">&lt;div class=&quot;panel-body&quot;&gt;</span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment">Solve</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="comment">\f[</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="comment">\frac{\mbox{d}^2u}{\mbox{d}x^2} = \pm 30 \sin(\sqrt{30} x),</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="comment"> \ \ \ \ \ \ \ \ \ \ (1)</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment">\f]</span></div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment">in the one-dimensional domain \f$x\in[0,1]\f$, subject to </span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="comment">\f[</span></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="comment">u(0)=0 \ \mbox{\ \ \ and \ \ \ } \ \ u(1)=\mp 1, </span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="comment">\ \ \ \ \ \ \ \ \ \ (2)</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="comment">\f]</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="comment">&lt;/div&gt;</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="comment">&lt;/TD&gt;</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="comment">&lt;/TR&gt;</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="comment">&lt;/TABLE&gt;</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="comment">&lt;/CENTER&gt;</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="comment">by isoparametric two-node elements. (Please consult the</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="comment">&lt;A HREF=&quot;../../intro/html/index.html&quot;&gt;Introduction&lt;/A&gt; for a review of</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="comment">the relevant finite element theory.) The source code for this example</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment">(&lt;A HREF=&quot;../../../demo_drivers/poisson/one_d_poisson_generic_only/one_d_poisson_generic_only.cc&quot;&gt;one_d_poisson_generic_only.cc&lt;/A&gt;)</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment">is  self-contained and uses only objects from the &quot;generic&quot; part of</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment">the \c oomph-lib library. [\c oomph-lib does, of course, provide </span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment">1D meshes and Poisson elements but we deliberately ignore these </span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment">because we wish to illustrate how to build such objects from scratch.</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment">The alternative example code </span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="comment">&lt;A HREF=&quot;../../../demo_drivers/poisson/one_d_poisson/one_d_poisson.cc&quot;&gt;</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="comment">one_d_poisson.cc&lt;/A&gt;,</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="comment">discussed in &lt;A HREF=&quot;../../poisson/one_d_poisson/html/index.html&quot;&gt;</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="comment">another example&lt;/A&gt; illustrates the implementation of the same problem using </span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="comment">existing library objects.]</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="comment">The main purpose of this document is to </span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="comment">provide a \e &quot;quick&quot; introduction to \c oomph-lib&#39;s fundamental objects,</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="comment">so the example classes presented below are fully-functional but very</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="comment">basic. We provide exercises at the end of each section</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="comment">to allow the reader to explore various straightforward improvements,</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="comment">most of which are implemented in the corresponding objects</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="comment">in the library. Finally, the section \ref comments provides a </span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment">discussion of some general design principles that should</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="comment">be respected when creating new classes for use with the library. </span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment">\section problem How to build a Problem</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">All specific \c Problems should be implemented as </span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment">objects that inherit from the generic \c Problem class. These</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment">specific \c Problem objects will vary considerably depending</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment">on the exact details of the problem being solved. </span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment">Only a few member functions \e must be implemented for each specific</span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment">\c Problem class:</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment">- The problem constructor \code SomeSpecificProblem(...) \endcode</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="comment">- and the member functions</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment">  \code Problem::actions_before_newton_solve() \endcode</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment">  \code Problem::actions_after_newton_solve() \endcode</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment">.</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment">\subsection spec The constructor: SomeSpecificProblem(...)</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment">The Problem constructor  \c SomeSpecificProblem(...) </span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="comment">usually contains the following steps:</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="comment">- Construction of the timestepper (if required), e.g. </span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="comment">  \code Problem::add_time_stepper_pt(new SomeTimeStepper()); \endcode   </span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="comment">- Construction of the \c Mesh (which may involve passing a particular</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="comment">  element type as a template parameter), e.g.</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="comment">  \code Problem::mesh_pt() = new SomeMesh&lt;SomeElement&gt;(...); \endcode</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="comment">- Specification of the boundary conditions. By default, all nodal</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="comment">  values are assumed to be free and their values are initialised to zero. </span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="comment">  Therefore, we only need to &quot;pin&quot; the values that are prescribed</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="comment">  by boundary conditions and assign any nonzero boundary values.</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="comment">  For instance, the following instruction &quot;pins&quot; the (single) nodal </span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="comment">  value at node &quot;0&quot;:</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="comment">  \code Problem::mesh_pt()-&gt;node_pt(0)-&gt;pin(0); \endcode</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="comment">  A non-zero boundary value can be set by</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="comment">  \code Problem::mesh_pt()-&gt;node_pt(0)-&gt;set_value(0,1.0); \endcode</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="comment">  This statement sets the first (= zero-th in C++&#39;s zero-based indexing)</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="comment">  nodal value to 1.0.</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment">- Completion of the build of the elements: Elements are typically</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment">  constructed during the mesh generation process. To allow a </span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment">  generic implementation of this process, mesh constructors </span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment">  use an argument-free constructor to</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="comment">  create the elements. Thus, element constructors must not</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="comment">  have any arguments. (See the section `\ref new_mesh&#39;, below, for an </span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="comment">  illustration of this process.) If an element requires any global parameters</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="comment">  (such as pointers to physical parameters, function pointers </span></div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="comment">  to source functions, etc.), these parameters should be passed to the</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="comment">  element via suitable access functions, \e after the element has been </span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="comment">  created by the mesh constructor.</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="comment">- Assignment of the global and local equation numbers </span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="comment">  \code Problem::assign_eqn_numbers(); \endcode</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="comment">\subsection actbef The function Problem::actions_before_newton_solve()</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="comment">\c oomph-lib treats all problems as non-linear problems and </span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="comment">employs Newton&#39;s method to solve the system of nonlinear algebraic</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="comment">equations that results from its spatial (and, in time-dependent</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="comment">problems, temporal) discretisation. Within this framework, linear</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="comment">problems are special cases for which Newton&#39;s method converges</span></div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="comment">in one step.</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="comment">The (pure virtual) member function \c Problem::actions_before_newton_solve() </span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="comment">should contain everything that \e must be done before a nonlinear </span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="comment">solve to complete the</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="comment">specification of the problem. For example, the function may contain a call to</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="comment">update the boundary conditions.</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="comment">\code void actions_before_newton_solve() {update_boundary_conditions();}</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="comment">\endcode</span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="comment">If desired, finer granularity may be obtained by overloading the </span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="comment">empty virtual </span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="comment">functions \c Problem::actions_before_newton_convergence_check(),</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="comment">\c Problem::actions_before_newton_step() and/or </span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="comment">\c Problem::actions_before_implicit_timestep(), which are executed </span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment">before each calculation of the maximum value of the residuals,</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment">each Newton step or each timestep, respectively. We refer to a </span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="comment">&lt;A HREF=&quot;../../order_of_action_functions/html/index.html&quot;&gt;separate</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="comment">document&lt;/A&gt; for a more detailed discussion of the various</span></div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment">&quot;action functions&quot; executed by \c oomph-lib&#39;s Newton solver. </span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment">\subsection actafter The function Problem::actions_after_newton_solve()</span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="comment">The (pure virtual) member function \c Problem::actions_after_newton_solve() </span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="comment">should contain</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="comment">everything that is to take place after each nonlinear solve. For</span></div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;<span class="comment">example, the function might</span></div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="comment">contain commands to update the values of any &quot;dependent&quot; variables, or </span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="comment">post-processing commands.</span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="comment">\code </span></div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="comment">void actions_after_newton_solve()</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="comment"> {</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="comment">  //Update value of the slave variable in namespace GlobalVariables</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="comment">  GlobalVariables::slave = node_pt(0)-&gt;value(0) + node_pt(0)-&gt;value(1);</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="comment">  //Call the output function</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="comment">  ofstream output_file(&quot;result.dat&quot;);</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="comment">  output(output_file); </span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment"> }</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment"> \endcode</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="comment">Again, the finer-grained member functions </span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="comment">\c Problem::actions_after_newton_step() and  </span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="comment">\c Problem::actions_after_implicit_timestep() are provided.</span></div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="comment">\subsection full An example of a &quot;complete&quot; specific Problem</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment">Here is the full specification for the \c DemoPoissonProblem class</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="comment">(taken from &lt;A HREF=&quot;../../../demo_drivers/poisson/one_d_poisson_generic_only/one_d_poisson_generic_only.cc&quot;&gt;one_d_poisson_generic_only.cc&lt;/A&gt;)</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="comment">which implements the discretisation of the 1D Poisson problem</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="comment">described above, using a \c Mesh of type  \c OneDimMesh, with </span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="comment">elements of type \c TwoNodePoissonElements.</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment">\dontinclude one_d_poisson_generic_only.cc</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment">\skipline DemoPoissonProblem</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment">\until End of problem </span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="comment">\subsection problem_exercise Exercises:</span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="comment">- Compile and run the example code </span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="comment">  &lt;A HREF=&quot;../../../demo_drivers/poisson/one_d_poisson_generic_only/one_d_poisson_generic_only.cc&quot;&gt;one_d_poisson_generic_only.cc&lt;/A&gt; and compare the numerical </span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="comment">  results against the (fish-shaped) exact solution</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="comment">  \f[</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="comment">  u_{fish}(x) =  </span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="comment">  \pm \left[ \left(\sin(\sqrt{30})-1\right) x - \sin(\sqrt{30} x)\right].</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="comment">  \f]</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="comment">  (The sign of the source function is an optional argument to the</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="comment">  problem constructor. If no argument is specified, the + sign</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="comment">  is used.)  Modify the \c actions_after_newton_solve() function so that it</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment">  writes the exact solution into another file, &quot;exact_solution.dat&quot;, say.</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="comment">- Vary the number of elements and observe how the numerical results</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment">  converge to the exact solution.</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="comment">- Adjust the boundary conditions:</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="comment">  - Change the boundary condition at the left end of the domain </span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="comment">    to \f$ u(0)=1\f$.</span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="comment">  - What happens when you don&#39;t apply a boundary condition </span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment">    at \f$ x=1  \f$? (Hint: What are the natural boundary conditions</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="comment">    for the Poisson equation?) </span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="comment">  - What happens when no boundary conditions are applied?</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="comment">  .</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="comment">- Suppress the assignment of the equation numbers in the problem</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="comment">  constructor and observe what happens. Check the error messages</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="comment">  produced by \c Problem::self_test().</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="comment">.</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="comment">\section mesh How to build a Mesh</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="comment">\c oomph-lib provides a large number of fully-functional \c Mesh objects. </span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment">Many of these meshes can easily be adapted to discretise other</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment">domains, provided the domain has the same topology as the</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="comment">original \c Mesh. We shall illustrate this in section \ref distorted_mesh </span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="comment">below.</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="comment">\subsection new_mesh How to build a completely new Mesh</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment">If the domain is too different from any of the existing meshes, a new,</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="comment">customised \c Mesh object, \c SpecificMesh, say, must be created. </span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="comment">The specific mesh should be created as an object that inherits from the </span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment">generic \c Mesh class. To maximise the potential for code-reuse, we</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="comment">recommended making the element type a template parameter</span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment">of the \c SpecificMesh class.</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="comment">\code</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="comment">template&lt;class ELEMENT&gt;</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="comment">class SpecificMesh : public Mesh</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="comment">\endcode</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="comment">This allows the \c SpecificMesh to be used</span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="comment">with any \c FiniteElement that is based on the same geometric</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="comment">element type (see the section \ref FEgeom for a more detailed discussion of </span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="comment">geometric elements).</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="comment">The minimum requirements for a specific mesh object are that it must:</span></div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="comment">- Construct the elements and the \c Nodes,</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="comment">- Store pointers to the elements in the \c Mesh::Element_pt vector,</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="comment">- Store pointers to the \c Nodes in the \c Mesh::Node_pt vector,</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="comment">- Set the elements&#39; pointers to their local \c Nodes</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="comment">- Set the positions of the \c Nodes.</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="comment">.</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;<span class="comment">We suggest that all specific \c Mesh constructors also set up </span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="comment">an auxiliary lookup scheme that stores information about the mesh</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;<span class="comment">boundaries. While this is not strictly required, it greatly facilitates</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;<span class="comment">the application of boundary conditions in complex domains. Firstly,</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;<span class="comment">the function \c Mesh::set_nboundary(...) must be called to specify the</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="comment">number of mesh boundaries. In addition, the generic \c Mesh class </span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="comment">provides a function \c Mesh::add_boundary_node(i,node_pt), </span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="comment">which adds the \c Node pointed to by \c node_pt to the \c Mesh&#39;s i-th </span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="comment">boundary and constructs the required</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="comment">look-up schemes, including a reverse lookup scheme that informs all </span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="comment">\c Nodes which mesh boundaries (if any) they are located on. </span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<span class="comment">(In our simple 1D example there are only</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="comment">two boundaries, each consisting of a single Node.) </span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="comment">Although this step is optional, it \e is required </span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="comment">during mesh adaptation -- if the reverse lookup scheme has not been </span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="comment">set up, a warning is issued and the code execution stops when any mesh </span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="comment">adaptation is attempted. \b Implementation \b detail: \c Nodes that are</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="comment">located on mesh boundaries must be defined as \c BoundaryNodes.  </span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<span class="comment">The majority of the work required to build a specific \c Mesh</span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="comment">takes place in its constructor. Typically, the constructor creates</span></div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;<span class="comment">the elements (of the type specified by the template parameter \c</span></div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;<span class="comment">ELEMENT)  and uses the elements&#39; member function \c</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="comment">FiniteElement::construct_node(...) to create the new \c Nodes. The</span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="comment">equivalent member function \c</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="comment">FiniteElement::construct_boundary_node(...) </span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="comment">is used to create new \c BoundaryNodes. </span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="comment">Here is the complete class definition for a simple, one-dimensional </span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="comment">(line) mesh which discretises the 1D domain \f$x\in [0,1]\f$ using </span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="comment">a specified number of equally-spaced elements.</span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment">\dontinclude one_d_poisson_generic_only.cc</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="comment">\skipline template&lt;</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="comment">\until };</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="comment">To build a \c OneDimMesh with ten elements of type \c SomeElement, say, the </span></div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="comment">\c Problem constructor would contain the following</span></div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="comment">\code</span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="comment">Problem::mesh_pt() = new OneDimMesh&lt;SomeElement&gt;(10);</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="comment">\endcode</span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="comment">\subsection distorted_mesh How to adapt an existing Mesh to a different domain shape</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="comment">Given that mesh generation tends to be a fairly tedious process, one should</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="comment">always check whether it is possible to deform an existing \c Mesh</span></div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="comment">into a shape that matches the required domain. Provided that the </span></div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="comment">new domain has the same topology as the domain represented </span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="comment">by the original \c Mesh, this can always be done by </span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="comment">re-positioning the Nodes. Such &quot;deformed&quot; \c Meshes should be implemented</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="comment">via inheritance, by deriving the new \c Mesh from an existing one.</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="comment">Here is an example that illustrates the procedure. Assume we wish to </span></div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="comment">solve an equation in the 2D annular domain bounded (in polar</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="comment">coordinates) by \f$ r \in [r_{min}, r_{max}] \f$ and  \f$ \varphi \in </span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="comment">[\varphi_{min}, \varphi_{max}] \f$. Inspection of the </span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;<span class="comment">&lt;A HREF=&quot;../../meshes/mesh_list/html/index.html&quot;&gt; list of available</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="comment">meshes &lt;/A&gt; shows that \c oomph-lib does not provide a mesh for </span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="comment">this geometry. However, there is a \c Mesh object,</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="comment"> \c SimpleRectangularMesh, which provides a uniform </span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<span class="comment">discretisation of a 2D rectangular domain \f$ x\in [0,L_x] \f$</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;<span class="comment">and \f$ y \in [0,L_y] \f$ with \f$ N_x \times N_y \f$</span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="comment">quadrilateral elements. Since the topology of the two domains</span></div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="comment">is identical, the annular mesh can be implemented in a few </span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="comment">lines of code:</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;<span class="comment">\code</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;<span class="comment">//====================================================================</span><span class="comment"></span></div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;<span class="comment">/// AnnularQuadMesh, derived from SimpleRectangularQuadMesh.</span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;<span class="comment"></span>//====================================================================</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;template&lt;class ELEMENT&gt; </div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;class AnnularQuadMesh : public SimpleRectangularQuadMesh&lt;ELEMENT&gt;</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;{</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160; </div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;  public:</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;<span class="comment"> /// \short Constructor for angular mesh with n_r x n_phi </span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="comment"> /// 2D quad elements. Calls constructor for the underlying </span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="comment"> /// SimpleRectangularQuadMesh; then deforms the mesh so that it fits </span></div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;<span class="comment"> /// into the annular region bounded by the radii r_min and r_max</span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;<span class="comment"> /// and angles (in degree) of phi_min and phi_max.</span></div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;<span class="comment"></span> AnnularQuadMesh(const unsigned&amp; n_r, const unsigned&amp; n_phi,</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;                 const double&amp; r_min, const double&amp; r_max,</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;                 const double&amp; phi_min, const double&amp; phi_max) :</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;  SimpleRectangularQuadMesh&lt;ELEMENT&gt;(n_r,n_phi,1.0,1.0)</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;  {</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160; </div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;   // The constructor for the  SimpleRectangularQuadMesh has</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;   // built the mesh with n_x x n_y = n_r x n_phi elements in the unit</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;   // square. Let&#39;s reposition the nodal points so that the mesh</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;   // gets mapped into the required annular region:</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160; </div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;   // Find out how many nodes there are</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;   unsigned n_node=nnode();</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160; </div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;   // Calculate the value of pi</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;   const double pi = 4.0*atan(1.0);</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160; </div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;   // Loop over all nodes</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;   for (unsigned n=0;n&lt;n_node;n++)</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    {</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;     // Pointer to node:</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;     Node* nod_pt=node_pt(n);</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160; </div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;     // Get the x/y coordinates</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;     double x_old=nod_pt-&gt;x(0);</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;     double y_old=nod_pt-&gt;x(1);</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160; </div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;     // Map from the old x/y to the new r/phi:</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;     double r=r_min+(r_max-r_min)*x_old;</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;     double phi=(phi_min+(phi_max-phi_min)*y_old)*pi/180.0;</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160; </div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;     // Set new nodal coordinates</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;     nod_pt-&gt;x(0)=r*cos(phi);</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;     nod_pt-&gt;x(1)=r*sin(phi);</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    }</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;  }</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160; </div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;};</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;\endcode</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160; </div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160; </div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160; </div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;&lt;HR&gt;</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160; </div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;\subsection mes_exercise Exercise:</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;Modify the \c OneDimMesh object so that it provides a piecewise </div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;uniform discretisation of the domain</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;\f$ x \in [0,1]\f$: \f$ N_0 \f$ equally spaced elements </div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;are to be placed in the the region \f$ x \in [0,\hat{x}]\f$, while</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;\f$ N_1 \f$ elements are to be placed in the the region \f$ x \in</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;[\hat{x},1]\f$. Pass the parameters \f$ N_0, N_1  \f$</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;and \f$\hat{x} \f$ to the mesh constructor.</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;Construct the modified mesh via inheritance from the basic \c OneDimMesh</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;and include an error check to confirm that \f$ 0 &lt; \hat{x} &lt; 1 \f$. </div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160; </div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160; </div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;&lt;HR&gt;</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;&lt;HR&gt;</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160; </div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;\section finiteelement How to build a FiniteElement</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160; </div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;\c oomph-lib provides fully-functional \c FiniteElements for </div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;the discretisation of a wide range of PDEs. Most of the existing</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;elements are constructed in a</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;three-level hierarchy, the base being the generic </div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;\c FiniteElement class. The next level in the hierarchy contains</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;geometric elements (e.g. 1D line elements, 2D quad or triangular</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;elements, 3D brick elements, etc.). These geometric</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;classes form the bases for elements that implement</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;the discretisation of particular PDEs. This hierarchy maximises</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;the potential for code-reuse, because it allows many different</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;specific elements to be derived from the same geometric element.</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160; </div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;We shall discuss the implementation of new element types in</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;two sections:</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;- \ref FEequations</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;- \ref FEgeom</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160; </div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;&lt;HR&gt;</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160; </div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;\subsection FEequations How to implement a new system of equations as a specific FiniteElement</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160; </div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;Assume that we wish to design a new element type, \c SpecificElement,</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;say, that implements the discretisation of a system of PDEs on an existing</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;geometric element. The \c SpecificElement class needs to implement</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;the following functions:</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;- The function that specifies the number of nodal values</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;  required at each of the element&#39;s nodes:</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;  \code FiniteElement::required_nvalue(n) \endcode </div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;- The function that computes the element&#39;s residual vector:</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;  \code FiniteElement::get_residuals(residuals) \endcode</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;- The function that computes the element&#39;s Jacobian matrix and</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;  its residual vector:</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;  \code FiniteElement::get_jacobian(residuals,jacobian) \endcode </div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;- The output function:</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;  \code FiniteElement::output(ostream) \endcode</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;.</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160; </div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160; </div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;Most specific finite element classes will contain further</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;member functions and member data to provide </div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;additional, problem-specific functionality.</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;As a concrete example, we consider the \c TwoNodePoissonElement,</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;a specific \c FiniteElement that provides an isoparametric</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;discretisation of the 1D Poisson equation (1), based on </div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;the geometric element \c TwoNodeGeometricElement, to be discussed below:</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;\dontinclude one_d_poisson_generic_only.cc</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;\skipline TwoNodePoisson</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160; </div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;In addition to the \c FiniteElement member functions discussed above, </div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;this element provides a function that defines the source function</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;\f$ f(x) \f$,</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;\dontinclude one_d_poisson_generic_only.cc</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;\skipline f(</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;\until }</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160; </div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;where the sign of the source function is stored as private member data</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;\dontinclude one_d_poisson_generic_only.cc</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;\skipline int Sign</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160; </div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;and can be set by the access function</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;\dontinclude one_d_poisson_generic_only.cc</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;\skipline sign(</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160; </div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;We provide a member function that returns the (single) </div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;nodal value stored at a specified local node in the element,</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;\dontinclude one_d_poisson_generic_only.cc</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;\skipline u(</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160; </div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;Finally, it is good practice to implement a self-test function </div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;that provides a sanity check of all data before</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;the problem is solved. \c oomph-lib already provides self-test functions</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;for all fundamental objects. Additional tests can be added</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;by overloading these. For instance, in our Poisson element, the</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;\c Sign variable should only take the values \f$ \pm 1 \f$.</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;This can be tested with the following function,</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;which also executes the \c self_test() function of the underlying</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;\c FiniteElement:</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;\dontinclude one_d_poisson_generic_only.cc</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;\skip Self test function</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;\until End of self test</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160; </div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;We will now discuss the implementation of the generic \c FiniteElement </div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;member functions for the specific \c TwoNodePoissonElement:</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160; </div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;\subsubsection Fereq_nvalue The function FiniteElement::required_nvalue(n)</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;The function returns the number of values that are stored at the </div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;element&#39;s \c n-th</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;local node. In our scalar Poisson problem, each node stores one value:</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160; </div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;\dontinclude one_d_poisson_generic_only.cc</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;\skip For the Poisson </div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;\until required_nvalue(</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160; </div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;The function is used by \c FiniteElement::construct_node(...) to</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;determine the amount of storage to be allocated at</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;each of the element&#39;s \c Nodes.</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160; </div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;\subsubsection residuals The function FiniteElement::get_residuals(residuals)</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;This function calculates the element&#39;s residual vector whose entries</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;are labelled by the \e local equation numbers. (Consult the </div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;&lt;A HREF=&quot;../../intro/html/index.html&quot;&gt;Introduction&lt;/A&gt; for</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;a detailed discussion of the weak form of Poisson&#39;s equation and its finite</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;element discretisation which produces the discrete residual</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;implemented here.) The spatial integration over the element is </div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;performed by the (default) integration scheme specified in the </div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;underlying geometric element. Note that it should (must) not be</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;assumed that the residuals vector has been set to zero before the</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;function call.</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;\skipline get_residuals(</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;\until End of function</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160; </div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;\subsubsection jac The function FiniteElement::get_jacobian(residuals,jacobian)</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;This function calculates the element&#39;s Jacobian matrix and its </div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;residual vector, performing the spatial integration with the</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;(default) integration scheme defined in the underlying geometric element. </div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;The entries in the Jacobian matrix and the residual vector are labelled </div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;by the \e local equation numbers. Note that neither the residuals</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;vector nor the Jacobian matrix should be assumed to have been initialised to</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;zero before the function call.</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;\skipline get_jacobian(</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;\until End of function</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160; </div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;\b Note: There is a large amount of code duplication between </div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;the \c get_residuals()</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;and \c get_jacobian() functions. To avoid this, we usually </div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;implement the computation of the residual vector and the </div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;Jacobian matrix in a single</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;function containing the loop over the integration points. We then</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;use a boolean flag as an additional argument to determine whether the</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;Jacobian matrix should be assembled, e.g.</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;\code</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;void get_generic_residual_contribution(Vector&lt;double&gt;&amp; residuals,</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;                                       DenseMatrix&lt;double&gt;&amp; jacobian,</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;                                       bool flag)         </div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;\endcode</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160; </div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160; </div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;\subsubsection FEout The function FiniteElement::output(out_stream)</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;The output function is used to print the nodal values over the element</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;\skipline output(</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;\until End of function</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160; </div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;&lt;HR&gt;</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;\subsection FE_exercise Exercises:</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;- Implement the function \c get_generic_residual_contribution(...) as a private</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;  member function of the \c TwoNodePoissonElement. Use the function to avoid</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;  the large amount of code duplication between \c get_residuals(...) and</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;  \c get_jacobian(...) by re-writing these functions as follows:</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;  \code<span class="comment"></span></div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;<span class="comment">  /// \short Calculate the elemental contributions to the residuals for </span></div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;<span class="comment">  /// the weak form of the Poisson equation</span></div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;<span class="comment"></span>  void get_residuals(Vector&lt;double&gt; &amp;residuals)</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;   {</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    // Set flag for not computing the Jacobian</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    bool flag=false;</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160; </div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    // Dummy Jacobian</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    DenseMatrix&lt;double&gt; jacobian;</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160; </div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;    // Compute the residuals only:</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;    get_generic_residual_contribution(residuals,jacobian,flag);</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;   }</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;  \endcode</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;  and </div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;  \code<span class="comment"></span></div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="comment">  /// \short Calculate the elemental contribution to the Jacobian </span></div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;<span class="comment">  /// matrix dR_{i}/du_{j} used in the Newton method</span></div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;<span class="comment"></span>  void get_jacobian(Vector&lt;double&gt; &amp;residuals, DenseMatrix&lt;double&gt; &amp;jacobian)</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;   {</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    // Set flag for computing the Jacobian matrix</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;    bool flag=true;</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160; </div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;    // Compute the residuals and the Jacobian matrix:</div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;    get_generic_residual_contribution(residuals,jacobian,flag);</div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;   }</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;  \endcode</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160; </div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;- The implementation of the specific source function  </div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;  \f$ f(x) \f$ in \c TwoNodePoissonElement::f(...) </div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;  makes it impossible to use the \c TwoNodePoissonElement to solve</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;  the Poisson equation with any other source functions, even though</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;  the discretisation of the ODE would otherwise be completely identical. </div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;  A better implementation would allow the &quot;user&quot; to specify a different source</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;  function without having to change the implementation of the </div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;  element class itself. </div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;  \n \n</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;  Here is a suggestion for an improved implementation, which illustrates the</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;  procedure employed in the existing elements in \c oomph-lib:</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;  - Introduce a public typedef into the element class to define</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;    the required format of the function pointer:</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;    \code<span class="comment"></span></div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;<span class="comment">    /// \short Function pointer to source function: </span></div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;<span class="comment">    /// The source function returns the value of the </span></div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;<span class="comment">    /// source function at the global coordinate x.</span></div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;<span class="comment"></span>    typedef double (*PoissonSourceFctPt)(const double&amp; x);</div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;    \endcode</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;  - Add a function pointer to the private data of the \c</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;    TwoNodePoissonElement class and initialise it to NULL</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;    in the constructor:</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    \code<span class="comment"></span></div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;<span class="comment">    /// \short Function pointer to source function (initialised to</span></div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;<span class="comment">    /// NULL in the constructor)</span></div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;<span class="comment"></span>    PoissonSourceFctPt Source_fct_pt;</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    \endcode</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;  - Provide an access function for the source function pointer:</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;    \code<span class="comment"></span></div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;<span class="comment">    /// \short Access function to pointer to source function</span></div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;<span class="comment"></span>    PoissonSourceFctPt&amp; source_fct_pt() {return Source_fct_pt;}</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;    \endcode</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;  - Re-write the \c TwoNodePoissonElement::f(...) function,</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;    so that it evaluates the (global) function pointed to by</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;    the source function pointer.  If possible, provide a default value </div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;    for the case when the function pointer has not been set:</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;    \code<span class="comment"></span></div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;<span class="comment">    /// Evaluate source function at Eulerian position x</span></div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;<span class="comment"></span>    double f(const double&amp; x) const</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;     { </div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;      //If no source function has been set, return zero</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;      //so that the Poisson equation defaults to a Laplace equation.</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;      double source=0.0;</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;      if(Source_fct_pt!=0)</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;       {</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;        // Evaluate source function </div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;        source = (*Source_fct_pt)(x);</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;       }</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;      return source;</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;     }</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;    \endcode</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;  .</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;  The pointer to the source function (typically defined in a suitable</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;  namespace in the &quot;user&#39;s&quot; driver code) can now be set in the </div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;  Problem constructor.</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;- Generalise the \c TwoNodePoissonElement to a \c</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;  TwoNodeSelfAdjointElement that implements the isoparametric</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;  discretisation of the self-adjoint ODE</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;  \f[</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;  \frac{\mbox{d}}{\mbox{d}x} </div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;  \left( a(x) \frac{\mbox{d}u}{\mbox{d}x} \right) + b(x) u(x)</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;  = f(x). \ \ \ \ \ \ \ \ \  (3)</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;  \f]</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;  Use function pointers to allow the &quot;user&quot; to specify </div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;  the coefficient functions \f$ a(x), \ b(x) \f$ and \f$ f(x) \f$.</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;.</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160; </div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160; </div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;&lt;HR&gt;</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160; </div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;\subsection FEgeom How to build a new geometric element</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160; </div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;Geometric elements define the geometry of a \c FiniteElement. They are</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;usually implemented as distinct classes that can then be used to create</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;a number of \c FiniteElements each discretising a specific PDE, but </div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;with the same underlying geometrical representation. </div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;For this purpose, each geometric \c FiniteElement must </div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;implement the following functions:</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;- The constructor</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;  \code SomeGeometricFiniteElement::SomeGeometricFiniteElement() \endcode </div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;  must perform the following actions:</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;  - Set the number of Nodes by calling the protected member function</div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;    \code FiniteElement::set_n_node(n_node). \endcode</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;  - Set the dimension of the element by calling the protected member</div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;  function \code FiniteElement::set_dimension(dim)\endcode </div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;  Here the dimension of the element is defined as the number of </div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;  local coordinates required to parametrise its shape.</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;  (Note that this is not necessarily the same as the spatial dimension</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;  of the problem -- we can have one-dimensional \c FiniteElements </div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;  in 3D space, say.) </div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;  - \b Optional: </div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;  Set the spatial integration scheme by calling the protected member</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;  function \code</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;  FiniteElement::set_integration_scheme(&amp;integration_scheme) \endcode</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;  - \b Optional: </div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;  If the spatial dimension (= the number of Eulerian coordinates)</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;  required at all Nodes in the element is different from the spatial</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;  dimension of the element then set the &quot;nodal dimension&quot; </div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;  by calling the protected </div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;  member function \code FiniteElement::set_nodal_dimension(dim)\endcode</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;  For example in shell elements, a two-dimensional surface is embedded</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;  in a three-dimensional space, so the elemental dimension is two, but</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;  the nodal dimension is three.</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;  - \b Optional: If the Eulerian coordinate (position) is interpolated using</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;  generalised coordinates, e.g. vector-valued shape functions, or</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;  Hermite-type interpolation, set the number of generalised</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;  coordinates or &quot;position types&quot;  by using the protected member function</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;  \code FiniteElement::set_n_nodal_position_type(n_position_type)\endcode</div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160; </div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;- The function that computes the element&#39;s (geometric) shape functions</div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;  at specified values of the local coordinates. These shape</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;  functions are primarily used to implement the mapping between the</div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;  element&#39;s local coordinates and the global (Eulerian) coordinates.  </div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;  The geometric shape functions \e can be (and often are) also used in </div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;  specific \c FiniteElements to interpolate the unknown </div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;  function(s) between the nodal values. </div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;  \code FiniteElement::shape(s,psi) \endcode</div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160; </div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;It is usually necessary to implement the following additional functions:</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;- The function that computes the derivatives of the element&#39;s shape</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;  functions with respect to the local coordinates,</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;  \code FiniteElement::dshape_local(s,psi,dpsids) \endcode</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;- The function that specifies the number of Nodes along the</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;  element&#39;s 1D &quot;edges&quot;  </div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;  \code FiniteElement::nnode_1d() \endcode </div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;.</div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;Further member functions and member data may be defined as and when required.</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;For instance, all specific \c FiniteElements must store a pointer to an</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;(instantiated) spatial integration scheme. It is good practice to</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;provide a default integration scheme for each geometric element and </div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;to ensure its instantiation by making it</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;a static data member of the geometric element class. This allows the </div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;constructor of the geometric element to set the pointer to the default </div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;integration scheme. If the default is not appropriate for a </div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;specific derived \c FiniteElement, the default assignment</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;can be over-written in the constructor of the derived class.</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160; </div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;As a concrete example, we consider the implementation of the</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;one-dimensional, two-node geometric element, \c TwoNodeGeometricElement, </div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;that uses linear shape functions to define the mapping between</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;the element&#39;s local and global coordinates. The element is derived</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;from the \c FiniteElement base class,</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;\dontinclude one_d_poisson_generic_only.cc</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;\skipline TwoNodeGeometric</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160; </div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;and it uses a one-dimensional, two-point Gauss rule</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;as the default spatial integration scheme </div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;\skipline Integration</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;\until static </div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160; </div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;Here is the implementation of the generic \c FiniteElement member</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;functions for our specific geometric \c FiniteElement:</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160; </div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;\subsubsection Geomconst The constructor: TwoNodeGeometricElement()</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;The constructor sets the number of local nodes in the element (2),</div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;sets the dimension of the element (1) and </div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;sets the pointer to the spatial integration scheme </div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;to be the default that is defined and instantiated as a static data</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;member of the class: </div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;\skipline TwoNodeGeometric</div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;\until }</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160; </div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;\subsubsection shape The function FiniteElement::shape(s,psi)</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;This function returns the shape functions at the local</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;element coordinate, s. The shape functions are used</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;to interpolate the position, and also, any data values stored at </div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;nodes in derived, isoparametric elements.</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;\skipline shape(</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;\until }</div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160; </div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;\subsubsection dshape The function FiniteElement::dshape_local(s,psi,dpsids)</div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;This function returns the shape functions and their derivatives with</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;respect to the local coordinates</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;\skipline dshape_</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;\until }</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160; </div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160; </div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;\subsubsection nnode_1d The function FiniteElement::nnode_1d()</div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;Return the number of nodes along the element&#39;s 1d &quot;edge&quot; -- for</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;a one-dimensional element, this is obviously the </div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;same as the number of nodes:</div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;\skipline nnode_1d()</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160; </div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;&lt;HR&gt;</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;\subsection geom_element_exercise Exercises:</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;- Change the \c TwoNodeGeometricElement to a \c</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;  ThreeNodeGeometricElement in which quadratic interpolation</div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;  is used to interpolate the Eulerian coordinates</div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;  between the nodal points. Use this element as a basis</div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;  for a \c ThreeNodePoissonElement and convince yourself that</div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;  changing the \c TwoNodePoissonElement </div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;  to a  \c ThreeNodePoissonElement only requires the change of</div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;  a single line of code!</div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;- Use templating to generalise the geometric elements to </div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;  an arbitrary number of nodes so that the class</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;  \code</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;  template &lt;unsigned NNODE&gt;</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;  class GeometricLineElement : public FiniteElement</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;  \endcode</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;  represents 1D line elements with \c NNODE nodes. Consider carefully</div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;  which member functions you can implement in generality and</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;  which member functions require specialised implementations.</div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;  Provide the specialised member functions for elements</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;  with two, three and four nodes.</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;- Use the templated  \c GeometricLineElements to implement an equivalent</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;  generalisation of the \c TwoNodePoissonElement and </div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;  \c ThreeNodePoissonElement classes to the general class</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;  \code</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;  template &lt;unsigned NNODE&gt;</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;  class PoissonLineElement : public GeometricLineElement&lt;NNODE&gt;</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;  \endcode </div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;- Validate all elements against the exact solution and</div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;  confirm the theoretical error estimate which predicts that </div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;  if the domain \f$ x \in [0,1]\f$ is discretised with \f$ N \f$</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;  equally spaced \f$n\f$-node line elements, we have</div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;  \f[</div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;  e = \sqrt{ \int_0^1 \left( u_{FE}(x) - u_{exact}(x)  \right) ^2 dx }</div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;  \sim h^{(n-1)} \mbox{ \ \ \ \ as $N \to \infty$}</div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;  \f]       </div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;  where \f$ h = 1/N \f$.</div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;.</div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;&lt;HR&gt;</div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;&lt;HR&gt;</div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160; </div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;\section comments Further comments</div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;We reiterate that the main purpose of this document is to </div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;provide a \e quick introduction to \c oomph-lib&#39;s fundamental objects.</div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;The exercises have already highlighted several undesirable features</div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;of the simple example classes which could easily be improved to </div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;facilitate the (re-)use of the classes in different problems. </div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;Here we shall briefly discuss some further modifications that </div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;we regard as good practice, and which tend to be implemented </div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;in the existing classes in \c oomph-lib:</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;- \ref dim_independent</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;- \ref pre_compute_psi</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;- \ref equation_classes</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;- \ref paranoia </div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;- \ref magic</div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;- \ref multi_physics</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160; </div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;&lt;HR&gt;</div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160; </div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;\subsection dim_independent Dimension-independent implementation</div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160; </div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;The exercises in the section \ref FEgeom suggest the</div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;use of templating to implement families of objects. This idea</div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;also permits the implementation of (geometric and specific)</div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;\c FiniteElements in arbitrary spatial dimensions. For instance,</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;\c oomph-lib&#39;s \c QElement class represents the family of </div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;(line/quadrilateral/brick-shaped) geometric elements</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;with an arbitrary number of nodes along the elements&#39; 1D edges.</div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;Thus, a \c QElement&lt;1,3&gt; is a three-node 1D line element,</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;a  \c QElement&lt;3,2&gt; is an eight-node 3D brick element, etc.</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160; </div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;These geometric elements naturally form the basis for </div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;corresponding specific elements, such as the \c QPoissonElement family</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;which provides an isoparametric discretisation of the Poisson</div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;equation (in an arbitrary spatial dimension), based on the</div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;\c QElements with the same template parameters.</div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160; </div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;&lt;HR&gt;</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160; </div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;\subsection pre_compute_psi Using pre-computed shape functions and the StorableShapeElement&lt;ELEMENT&gt; class</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160; </div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160; The computation of the element&#39;s residual vector and the Jacobian</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;matrix requires the evaluation of the element&#39;s shape functions,</div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;\f$ \psi_j \f$, and their derivatives with respect to the global</div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;coordinate, \f$ \mbox{d}\psi_j/\mbox{d}x \f$, at the </div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;element&#39;s integration points. In our simple example class, </div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;\c TwoNodePoissonElement, we (re-)compute these functions</div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;&quot;on the fly&quot;, using the function</div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;\code</div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;FiniteElement::dshape_eulerian(s,psi,dpsidx)</div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;\endcode</div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;where the local coordinate of the integration point is passed</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;in the (one-dimensional) vector \c s.</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160; </div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;  The re-computation is wasteful because:</div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;- The values of the shape functions and their derivatives, evaluated</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;  at the integration point, are independent of the value of the </div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;  \c Sign variable. Their re-computation during the second</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;  solve could therefore be avoided if we stored their values</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;  in a suitable container.</div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;- The values of the shape functions at the integration points</div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;  are identical for all elements. Therefore we only need to provide</div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;  storage for the shape function values in a single, representative</div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;  element. The other elements can access the values via pointers.</div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;.</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;To circumvent these potential inefficiencies, \c oomph-lib </div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;provides alternative interfaces for various functions that compute</div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;shape functions and their derivatives:</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;- Calls to the function </div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;  \code</div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;  FiniteElement::shape(s,psi)</div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;  \endcode</div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;  which computes the shape function at a given local coordinate, \c s,</div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;  can be replaced by</div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;  \code</div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;  FiniteElement::shape_at_knot(int_point,psi)</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;  \endcode</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;  where the \c unsigned argument \c int_point identifies</div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;  the integration point (as specified by the</div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;  element&#39;s spatial integration scheme).</div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160; In &quot;standard&quot; \c FiniteElements the function </div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160; \c FiniteElement::shape_at_knot(...) simply determines the position</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160; of the integration point and calls \c FiniteElement::shape(...) and</div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160; so the shape functions are still computed &quot;on the fly&quot;. </div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160; The templated class \c StorableShapeElement&lt;ELEMENT&gt;, however,</div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;  may be used to</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160; upgrade any class derived from \c FiniteElement into a class that \b</div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160; can store the values of the shape functions and their derivatives at</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160; the integration points. The function \c shape_at_knot(...) is</div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160; overloaded so that when called for the first</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160; time, it computes the values of the shape function</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160; at all integration points and stores them for future reference.</div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160; In subsequent calls, the function returns the stored values, rather </div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160; than re-computing them. </div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;- There are equivalent alternatives for the functions that</div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;  compute the shape functions and their derivatives with respect</div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;  to the local coordinates:</div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;  \code</div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;  FiniteElement::dshape(s,psi,dpsids)</div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;  \endcode</div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;  can be replaced by</div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;  \code</div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;  FiniteElement::dshape_at_knot(int_point,psi,dpsids)</div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;  \endcode</div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;  while</div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;  \code</div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;  FiniteElement::d2shape(s,psi,dpsids,d2psids)</div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;  \endcode</div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;  can be replaced by</div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;  \code</div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;  FiniteElement::d2shape_at_knot(int_point,psi,dpsids,d2psids)</div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;  \endcode</div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;.</div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;These functions are all overloaded in the \c</div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;StorableShapeElement&lt;ELEMENT&gt; class and by default the </div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;overloaded functions store the pre-computed values of the</div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;shape functions and their derivatives locally within each element. </div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;This implementation ensures data locality and should increase </div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;the speed of access to the stored values. However, it</div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;can also create significant storage overheads. \c oomph-lib </div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;therefore provides the function </div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;\code </div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;StorableShapeElement&lt;ELEMENT&gt;::set_shape_local_stored_from_element(...)</div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;\endcode</div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;which frees up the storage in the element and replaces it by </div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;pointer-based access to the values stored in another element.</div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;Typically, all elements in a mesh are of the same type and use</div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;the same spatial integration scheme and so the values of the shape</div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;functions need only be stored in one element.</div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160; </div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;Derivatives of the element&#39;s shape functions with respect to </div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;the global Eulerian coordinates are generally</div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;computed by</div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;\code</div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;FiniteElement::dshape_eulerian(s,psi,dpsidx)</div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;\endcode</div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;and </div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;\code</div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;FiniteElement::d2shape_eulerian(s,psi,dpsidx,d2psidx)</div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;\endcode</div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;These functions also return the Jacobian of the mapping between</div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;the local and global coordinates -- the Jacobian can also be</div>
<div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;computed independently from </div>
<div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;\code</div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;FiniteElement::J_eulerian(s)</div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;\endcode</div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;The derivatives of the shape functions with respect the</div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;global coordinates depend on the nodal positions, and it is not safe</div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;to assume that they will remain constant. For instance</div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;in moving boundary problems, the position of the nodes is</div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;determined as part of the solution. By default, the functions </div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;\code</div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;StorableShapeElement&lt;ELEMENT&gt;::dshape_eulerian_at_knot(int_point,psi,dpsidx)</div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;\endcode</div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;\code</div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;StorableShapeElement&lt;ELEMENT&gt;::d2shape_eulerian_at_knot(int_point,psi,dpsidx,d2psidx)</div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;\endcode</div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;and</div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;\code</div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;StorableShapeElement&lt;ELEMENT&gt;::J_eulerian_at_knot(int_point)</div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;\endcode</div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;re-compute the derivatives at the specified integration </div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;point &quot;on the fly&quot;. If the &quot;user&quot; is confident</div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;that in his/her problem, the nodal positions will not change, the values</div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;can be pre-computed by calling </div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;\code</div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;StorableShapeElement&lt;ELEMENT&gt;::pre_compute_dshape_eulerian_at_knots()</div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;\endcode</div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;\code</div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;StorableShapeElement&lt;ELEMENT&gt;::pre_compute_d2shape_eulerian_at_knots()</div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;\endcode</div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;\code</div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;StorableShapeElement&lt;ELEMENT&gt;::pre_compute_J_eulerian_at_knots()</div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;\endcode</div>
<div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;Once these functions have been called, any subsequent calls to </div>
<div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;the \c *_eulerian_at_knot(...) functions return the stored values.</div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;To revert to the case in which the derivatives are re-computed</div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;&quot;on the fly&quot;, the storage for the derivatives must be deleted by  </div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;calling </div>
<div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;\code </div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;StorableShapeElement&lt;ELEMENT&gt;::delete_dshape_eulerian_stored()</div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;\endcode</div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160; </div>
<div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;\b Notes: </div>
<div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;- In the (unlikely!) case that an element&#39;s spatial integration</div>
<div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;  scheme is changed during the code execution, all stored</div>
<div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;  values are automatically re-computed.</div>
<div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;- The class </div>
<div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;  \c StorableShapeSolidElement&lt;ELEMENT&gt; provides equivalent overloaded</div>
<div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;  functions for derivatives</div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;  with respect to the element&#39;s Lagrangian coordinates that are used in solid</div>
<div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;  mechanics problems. </div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160; </div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160; </div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;&lt;HR&gt;</div>
<div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160; </div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;\subsection equation_classes Further sub-division of specific element classes -- equation classes.</div>
<div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160; </div>
<div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;We suggested that any newly developed elements should be constructed</div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;in a three-level hierarchy, \c FiniteElement -- Geometric Element --</div>
<div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;Specific \c FiniteElement. Most finite elements in \c oomph-lib</div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;incorporate an additional intermediate &quot;equation class&quot; which implements the</div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;computation of the element residual vector and the element Jacobian</div>
<div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;matrix in terms of abstract shape and test functions, defined</div>
<div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;as pure virtual functions in the &quot;equation class&quot;. This makes it</div>
<div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;easy to change the specific element formulation, without having to</div>
<div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;re-implement the weak form of the governing equation. </div>
<div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160; </div>
<div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;Note that different element types may store the same physical variable at</div>
<div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;different locations. For example, the pressure in the Navier--Stokes</div>
<div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;equations may be stored as internal \c Data (discontinuous) or nodal</div>
<div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;\c Data</div>
<div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;(continuous). Particular equation classes may require </div>
<div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;internal numbering schemes that store the appropriate </div>
<div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;local equation numbers for each physical variable. </div>
<div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;These schemes must be assembled for each specific element in</div>
<div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;the function </div>
<div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;\c GeneralisedElement::assign_additional_local_eqn_numbers(), which is called</div>
<div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;from within \c Problem::assign_eqn_numbers(). </div>
<div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160; </div>
<div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;  As an example, consider the weak form of the 2D advection diffusion</div>
<div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;equation</div>
<div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;\f[</div>
<div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;\int \left(\mbox{Pe} \ \sum_{i=1}^2 w_i \frac{\partial u}{\partial x_i} \psi^{(test)}_l  + </div>
<div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;\sum_{i=1}^2 \frac{\partial u}{\partial x_i}</div>
<div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;             \frac{\partial \psi^{(test)}_l}{\partial x_i} \right) dA</div>
<div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;             = 0,</div>
<div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;\f]</div>
<div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;where the Peclet number, \f$ Pe \f$ , and the &quot;wind&quot; \f$w_i \ (i=1,2)\f$</div>
<div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;are given. We expand the unknown function \f$u(x_1,x_2)\f$ in terms of </div>
<div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;the (global) basis functions  \f$ \psi^{(basis)}_k(x_1,x_2), \ (k=1,...,N)\f$,</div>
<div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;\f[</div>
<div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;u(x_1,x_2) = \sum_{k=1}^N U_k \ \psi^{(basis)}_k(x_1,x_2),</div>
<div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;\f]</div>
<div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;where \f$N\f$ is the total number of nodes in the mesh. </div>
<div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;The mapping between the element&#39;s local and global coordinates</div>
<div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;is represented in terms of the local shape functions</div>
<div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;\f$\psi^{(shape)}_j(s_1,s_2)\f$ as</div>
<div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;\f[</div>
<div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;x_i = \sum_{j=1}^n X_{ij} \ \psi^{(shape)}_j(s_1,s_2)</div>
<div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;\f]</div>
<div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;where \f$ n \f$ is the number of nodes in the element. </div>
<div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160; </div>
<div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160; The following sketch illustrates how  this discretisation</div>
<div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;is implemented in \c oomph-lib&#39;s \c QAdvectionDiffusionElement --</div>
<div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;an isoparametric, quadrilateral element, based on the Galerkin</div>
<div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;discretisation of the weak form with</div>
<div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;\f$ \psi^{(shape)}_j =   \psi^{(test)}_j =   \psi^{(basis)}_j \f$</div>
<div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160; </div>
<div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;\image html advection_diffusion_element_inheritance.gif &quot;Typical inheritance diagram for oomph-lib elements &quot; </div>
<div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;\image latex advection_diffusion_element_inheritance.eps &quot;Typical inheritance diagram for oomph-lib elements &quot; width=0.75\textwidth</div>
<div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160; </div>
<div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;At large Peclet number, the Galerkin discretisation of the advection</div>
<div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;diffusion equation is well-known to  produce spurious &quot;wiggles&quot; in the </div>
<div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;solution. These can be suppressed by SUPG stabilisation which </div>
<div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;employs test functions,  \f$ \psi_j^{(test)}</div>
<div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;\f$, that differ from the basis function, \f$ \psi_j^{(basis)} \f$,</div>
<div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;\f[</div>
<div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;\psi_j^{(test)} = \psi_j^{(basis)} + </div>
<div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;\tau^{(SUPG)} \sum_{i=1}^2 w_i \frac{\partial</div>
<div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;\psi_j^{(basis)}}{\partial x_i},</div>
<div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;\f]</div>
<div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;where \f$ \tau^{(SUPG)} \f$ is a stabilisation parameter.</div>
<div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;This can be implemented with a trivial change to the</div>
<div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;\c QAdvectionDiffusionElement class -- the </div>
<div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;\c QSUPGAdvectionDiffusionElement simply provides a different</div>
<div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;implementation of the test functions.</div>
<div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160; </div>
<div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160; </div>
<div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;&lt;HR&gt;</div>
<div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160; </div>
<div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;\subsection paranoia Implement extensive (but optional) self tests in all classes</div>
<div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160; </div>
<div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;We have already illustrated the use of \c oomph-lib&#39;s generic \c self_test()</div>
<div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;functions. The top-level \c Problem::self_test() function </div>
<div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;performs a systematic test of all fundamental objects</div>
<div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;involved in a specific problem and can be used to diagnose</div>
<div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;any problems. It is good practise to implement </div>
<div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;further \c self_test() functions in any newly developed classes.</div>
<div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;The generic \c self_test() functions are defined to be virtual</div>
<div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;functions in \c oomph-lib&#39;s fundamental objects and can</div>
<div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;be overloaded. Obviously, the \c self_test() function in a</div>
<div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;specific derived object should still call the \c self_test()</div>
<div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;function of the underlying fundamental object. The </div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;\c TwoNodePoissonElement::self_test() function, listed in</div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;in the section \ref FEequations illustrates the procedure. </div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160; </div>
<div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;  While frequent sanity checks are helpful during code-development,</div>
<div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;they can introduce significant overheads into the</div>
<div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;code execution. \c oomph-lib therefore provides a compiler flag PARANOID,</div>
<div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;which allows the execution of sanity checks to be switched on</div>
<div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;or off. When developing new classes, sanity checks should</div>
<div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;be implemented to catch any potential problems, but the relevant</div>
<div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;code should be surrounded by &lt;CODE&gt;ifdef/endif&lt;/CODE&gt; statements to allow</div>
<div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;the tests to be disabled. Here is an example:</div>
<div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;\code</div>
<div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160; </div>
<div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160; #include &lt;typeinfo&gt;</div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160; </div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;  [...]</div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160; </div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;  // Recast to a different pointer type</div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;  SomeOtherObject* other_pt=dynamic_cast&lt;SomeOtherObject*&gt;(some_pt);</div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160; </div>
<div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160; #ifdef PARANOID</div>
<div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;  if (other_pt==0)</div>
<div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;   {</div>
<div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;   std::ostringstream error_stream;</div>
<div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;     error_stream &lt;&lt; &quot;Failed to cast some_pt to SomeOtherObject* &quot;  </div>
<div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;                  &lt;&lt; std::endl;</div>
<div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;     error_stream &lt;&lt; &quot;The pointer some_pt points to an object of type: &quot; &lt;&lt;</div>
<div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;                  &lt;&lt; typeid(some_pt).name() &lt;&lt; std::endl; </div>
<div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;     throw OomphLibError(error_stream.str(),</div>
<div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;                         OOMPH_CURRENT_FUNCTION,</div>
<div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;                         OOMPH_EXCEPTION_LOCATION);</div>
<div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;    }</div>
<div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160; #endif </div>
<div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160; </div>
<div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;[...]</div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160; </div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;\endcode </div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;Note that we throw a specific \c OomphLibError object after catching </div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;the error -- this allows the provision of more explicit (and hopefully more</div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;meaningful) error messages.</div>
<div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160; </div>
<div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;   Many access functions that provide indexed access to</div>
<div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;a private container, do, in fact, access a private STL vector.</div>
<div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;Explicit range checking for these (frequent!) cases can be avoided</div>
<div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;by changing the container to \c oomph-lib&#39;s \c Vector class. The </div>
<div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;\c Vector class</div>
<div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;performs automatic range checking, if \c oomph-lib&#39;s \c generic library is compiled</div>
<div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;with the \c RANGE_CHECKING flag set (i.e. if</div>
<div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;\c -DRANGE_CHECKING is specified as a compilation flag for the</div>
<div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;C++ compiler). For access functions that do not use the \c Vector</div>
<div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;class you should implement your own range checks using the</div>
<div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;RANGE_CHECKING compiler flag.</div>
<div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160; </div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;&lt;HR&gt;</div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160; </div>
<div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;\subsection magic The use of &quot;magic numbers&quot;</div>
<div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160; </div>
<div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160; In general, we set the equation number to -1 to indicate </div>
<div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;that a nodal value is </div>
<div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;pinned, i.e. prescribed by boundary conditions. This convention is used</div>
<div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;throughout \c oomph-lib, but the direct use of -1 as a (bad!) &quot;magic number&quot;</div>
<div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;is generally avoided. Instead we refer to the static data member of </div>
<div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;the \c Data class</div>
<div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;\code static long Data::Is_pinned \endcode</div>
<div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;which is (of course) set to -1. Similarly, when nodes are created,</div>
<div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;the equation numbers of their value(s) are initialised to a value of -10,</div>
<div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;represented by the static data member </div>
<div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;\code static int Data::Is_unclassified \endcode</div>
<div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;This allows the function \c Problem::self_test() to check if</div>
<div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;any values have not been classified as pinned or free.</div>
<div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160; </div>
<div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160; </div>
<div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;&lt;HR&gt;</div>
<div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160; </div>
<div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;\subsection multi_physics Facilitating the use of specific elements in multi-physics problems</div>
<div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160; </div>
<div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;As the name of the library suggests, \c oomph-lib&#39;s existing</div>
<div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;&quot;single-physics&quot; elements are (and any newly designed ones should be) </div>
<div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;designed so that they can easily be used in multi-physics problems. </div>
<div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;We anticipate two types of multi-physics interactions:</div>
<div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;- The solution of one system of equations affects the geometry of </div>
<div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;  the domain in which another equation is solved -- this </div>
<div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;  occurs, for instance, in fluid-structure interaction problems.</div>
<div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;- Two physical phenomena occur in the same domain and</div>
<div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;  interact with each other, so that forcing terms in one</div>
<div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;  equation depend on the solution of another -- this occurs, for</div>
<div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;  instance, in thermo-elasticity problems where the temperature</div>
<div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;  distribution (determined by the solution of an unsteady heat</div>
<div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;  equation, say) affects the &quot;growth term&quot; in the equations of</div>
<div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;  elasticity. </div>
<div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;.</div>
<div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160; </div>
<div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160; Multi-physics elements for such problems are usually implemented by combining</div>
<div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;two (or more) single-physics elements via multiple inheritance. The combined, </div>
<div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;multi-physics element will obviously have a larger number of degrees</div>
<div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;of freedom than the constituent single-physics elements. The combined element</div>
<div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;typically calls the \c get_residuals(...) function of the two </div>
<div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;constituent elements and concatenates their residual vectors. </div>
<div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;When computing the Jacobian matrix, the &quot;single physics&quot; elements </div>
<div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;provide the diagonal blocks for the Jacobian matrix of the</div>
<div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;multi-physics element, while the off-diagonal interaction blocks must </div>
<div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;be computed separately. The details of the implementation vary</div>
<div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;from problem to problem. However, any single-physics element </div>
<div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;must satisfy the following requirements if it is to be used</div>
<div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;as a base class for derived multi-physics elements: </div>
<div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;- \ref dont_wipe </div>
<div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;- \ref virtual </div>
<div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;- \ref index_fcts </div>
<div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;- \ref mesh_movement </div>
<div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;.</div>
<div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160; </div>
<div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160; </div>
<div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;&lt;HR&gt;</div>
<div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160; </div>
<div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;\subsubsection dont_wipe Rule 1: Elements must only initialise their own entries in the element residual vector and the element Jacobian matrix</div>
<div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160; </div>
<div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;The computation of the element residual vector and</div>
<div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;the element Jacobian matrix typically involves a loop over the</div>
<div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;element&#39;s integration points, in which each integration point adds</div>
<div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;a further contribution to the entries. In multi-physics problems</div>
<div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;it is crucial that the initialisation of the residual vector</div>
<div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;and the Jacobian matrix only sets  the element&#39;s &quot;own&quot; entries to zero. </div>
<div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160; </div>
<div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160; </div>
<div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;To illustrate this point, consider what would happen if we used </div>
<div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;the \c TwoNodePoissonElement::get_jacobian(...) function,</div>
<div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;discussed in the section \ref jac, in a derived multi-physics element,</div>
<div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;which combines the  \c TwoNodePoissonElement with another</div>
<div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;element,  \c TwoNodeSomeOtherEquationElement, say. </div>
<div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;Assume that we implement the function \c get_jacobian(...) of the </div>
<div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;combined element so that it first calls the function \c</div>
<div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;TwoNodeSomeOtherEquationElement::get_jacobian(...) to determine</div>
<div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;the first diagonal block in the combined Jacobian matrix.</div>
<div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;When we call  \c TwoNodePoissonElement::get_jacobian(...)</div>
<div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;to compute the entries in the second diagonal block,</div>
<div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;the initialisation loop</div>
<div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160; </div>
<div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;\code</div>
<div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;//Find the number of degrees of freedom (unpinned values) in the element</div>
<div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160; unsigned n_dof = ndof();</div>
<div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;//Initialise all entries of the Jacobian matrix to zero</div>
<div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;for(unsigned i=0;i&lt;n_dof;i++) </div>
<div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160; {</div>
<div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;  for(unsigned j=0;j&lt;n_dof;j++) {jacobian(i,j) = 0.0;}</div>
<div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160; }</div>
<div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;\endcode </div>
<div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160; </div>
<div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;would initialise the \e entire Jacobian matrix, thus wiping out</div>
<div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;the entries that were already computed by  </div>
<div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;\c TwoNodeSomeOtherEquationElement::get_jacobian(...).</div>
<div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160; </div>
<div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160; The strategy used in \c oomph-lib to permit the easy combination of</div>
<div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160; elements is to use the two protected member functions of the</div>
<div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160; \c GeneralisedElement class:</div>
<div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;\code</div>
<div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;virtual void GeneralisedElement::fill_in_contribution_to_residuals(Vector&lt;double&gt;&amp;residuals);</div>
<div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;\endcode</div>
<div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160; </div>
<div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;and</div>
<div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160; </div>
<div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;\code</div>
<div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;virtual void GeneralisedElement::fill_in_contribution_to_jacobian(Vector&lt;double&gt; &amp;residuals,</div>
<div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;                                                                  DenseMatrix&lt;double&gt; &amp;jacobian); </div>
<div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;\endcode</div>
<div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160; </div>
<div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160; These functions DO NOT initialise the entries of the residuals vector</div>
<div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160; or the Jacobian matrix. Instead, the functions merely add the </div>
<div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160; appropriate contributions to the vector and the matrix entries. The</div>
<div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160; default version of</div>
<div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160; the \c get_residuals() and \c get_jacobian() functions, defined in</div>
<div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160; \c GeneralisedElement, are simple</div>
<div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160; wrappers that initialise the residuals and Jacobian to zero and then</div>
<div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160; call the appropriate \c fill_in_contribution... function.</div>
<div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;\code</div>
<div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;  virtual void GeneralisedElement::get_residuals(Vector&lt;double&gt; &amp;residuals) </div>
<div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;  {</div>
<div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;   //Zero the residuals vector</div>
<div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;   residuals.initialise(0.0);</div>
<div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160; </div>
<div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;   //Add the elemental contribution to the residuals vector</div>
<div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;   fill_in_contribution_to_residuals(residuals);</div>
<div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;  }</div>
<div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160; </div>
<div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;  virtual void GeneralisedElement::get_jacobian(Vector&lt;double&gt; &amp;residuals, </div>
<div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;                                                DenseMatrix&lt;double&gt; &amp;jacobian) </div>
<div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;  {</div>
<div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;   //Zero the residuals vector</div>
<div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;   residuals.initialise(0.0);</div>
<div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160; </div>
<div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;   //Zero the Jacobian matrix</div>
<div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;   jacobian.initialise(0.0);</div>
<div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160; </div>
<div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;   //Add the elemental contribution to the residuals vector and Jacobian</div>
<div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;   fill_in_contribution_to_jacobian(residuals,jacobian);</div>
<div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;  } </div>
<div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;\endcode</div>
<div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160; </div>
<div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160; The \c get_residuals function, for example, can thus be overloaded </div>
<div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160; in a multi-physics element, as follows:</div>
<div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;\code </div>
<div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;<span class="comment"> /// Multi-physics element, created by multiple inheritance</span></div>
<div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;<span class="comment"></span> class SomeMultiPhysicsElement : public virtual TwoNodePoissonElement,</div>
<div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;                                 public virtual TwoNodeSomeOtherEquationElement</div>
<div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160; {</div>
<div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160; </div>
<div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;  [...]</div>
<div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;<span class="comment">  /// Residual vector of the combined element is made from the entries</span></div>
<div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;<span class="comment">  /// of the constituent single-physics elements</span></div>
<div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;<span class="comment"></span>  virtual void get_residuals(Vector&lt;double&gt; &amp;residuals) </div>
<div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;   {</div>
<div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;    //Zero the residuals vector</div>
<div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;    residuals.initialise(0.0);</div>
<div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160; </div>
<div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;   //Add the first elemental contribution to the residuals vector</div>
<div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;   TwoNodePoissonElement::fill_in_contribution_to_residuals(residuals);</div>
<div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160; </div>
<div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;    //Add the second elemental contribution to the residuals vector</div>
<div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;    TwoNodeSomeOtherEquationElement::fill_in_contribution_to_residuals(residuals);</div>
<div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;   }</div>
<div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160; </div>
<div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160; </div>
<div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;   [...]</div>
<div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160; </div>
<div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;  };</div>
<div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160; </div>
<div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;\endcode</div>
<div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160; </div>
<div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160; It is, therefore, recommended that authors of &quot;single-physics&quot;</div>
<div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160; elements, overload \c fill_in_contribution_to_residuals(...) and </div>
<div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160; \c fill_in_contribution_to_jacobian(...), rather than \c</div>
<div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160; get_residuals() and \c get_jacobian(...), respectively. A further</div>
<div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160; advantage of the implementation is that the author need not</div>
<div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160; worry about initialisation of the residuals vector or the Jacobian </div>
<div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160; matrix when using the \c &quot;fill_in_&quot; rather than the \c &quot;get_&quot; functions.</div>
<div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160; </div>
<div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;\subsubsection virtual Rule 2: Forcing functions, etc. should be implemented as  uniquely-named virtual functions</div>
<div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160; </div>
<div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;To allow for an interaction between multiple equations, any</div>
<div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;forcing functions (such as the source function in the Poisson</div>
<div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;equation) should be implemented as virtual functions. This allows</div>
<div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;them to be overloaded in derived, multi-physics elements where the</div>
<div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;forcing function in one equation might depend on the unknowns in</div>
<div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;another one.</div>
<div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160; </div>
<div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;Furthermore, to avoid clashes of function names that may occur when two</div>
<div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;single-physics elements are combined, member functions that can </div>
<div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;be expected to have counterparts in the context of other equations should </div>
<div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;be given suitable modifiers. For instance, </div>
<div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;\code</div>
<div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;AdvectionDiffusionEquation::source_fct_adv_diff(...)</div>
<div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;\endcode</div>
<div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;is a better name for a member function that returns the source function</div>
<div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;in the advection-diffusion equations than</div>
<div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;\code</div>
<div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;AdvectionDiffusionEquation::source_fct(...)</div>
<div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;\endcode</div>
<div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;since many other equations are likely to have source functions, too. </div>
<div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;It is obviously impossible to completely avoid such clashes but</div>
<div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;this strategy makes them less likely to occur. We are fairly confident</div>
<div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;that the relevant member functions of all existing elements </div>
<div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;in \c oomph-lib have been given suitable modifiers  to avoid</div>
<div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;clashes of this type. Therefore, you should be able to combine any</div>
<div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;element with any other element in the library. If you find a counter-example </div>
<div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160; &lt;A HREF=&quot;../../contact/html/index.html&quot;&gt;let us know&lt;/A&gt;, and</div>
<div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;we will rectify this in the next release. In the meantime</div>
<div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;exploit the fact that \c oomph-lib is an open source library; you can</div>
<div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;change anything you want!</div>
<div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160; </div>
<div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;\subsubsection index_fcts Rule 3: Nodal values should only be accessed indirectly via index functions that can be overloaded in derived multi-physics elements</div>
<div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160; </div>
<div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;When implementing the single-physics \c TwoNodePoissonElement,</div>
<div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;discussed above, we provided an access function \c u(n) </div>
<div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;that returns the (single) nodal value, stored at the element&#39;s</div>
<div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;\c n -th \c Node. The function was implemented as a simple wrapper </div>
<div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;that followed the pointer to the element&#39;s \c n -th \c Node and </div>
<div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;returned the zero-th nodal value stored at that \c Node:</div>
<div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;\code</div>
<div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;double TwoNodePoissonElement::u(const unsigned &amp;n) </div>
<div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160; {</div>
<div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;  return node_pt(n)-&gt;value(0);</div>
<div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160; }</div>
<div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;\endcode</div>
<div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160; </div>
<div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;In a single-physics context, this implementation is perfectly</div>
<div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;acceptable since we know \e a \e priori that in a scalar problem</div>
<div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;each \c Node only stores a single value. </div>
<div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160; </div>
<div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;The same logic suggests that a \c TwoNodeAdvectionDiffusionElement</div>
<div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;would have a member function </div>
<div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;\code</div>
<div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;double TwoNodeAdvectionDiffusionElement::u(const unsigned &amp;n) </div>
<div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160; {</div>
<div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;  return node_pt(n)-&gt;value(0);</div>
<div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160; }</div>
<div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;\endcode</div>
<div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160; </div>
<div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;However, merging these two elements via multiple inheritance</div>
<div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;creates two problems. First we have clash of names which could</div>
<div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;have been avoided by following rule 2 above and calling the two functions</div>
<div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;\c TwoNodePoissonElement::u_poisson(...) and </div>
<div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;\c TwoNodeAdvectionDiffusionElement::u_adv_diff(...), say.</div>
<div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;More serious is that both elements regard the zero-th nodal value</div>
<div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;as &quot;their own&quot;. This can (and should!) be avoided</div>
<div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;by the following re-implementation:</div>
<div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160; </div>
<div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;\code</div>
<div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;double TwoNodePoissonElement::u(const unsigned &amp;n) </div>
<div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160; {</div>
<div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;  return node_pt(n)-&gt;value(u_index_poisson());</div>
<div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160; }</div>
<div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;\endcode</div>
<div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160; </div>
<div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;where the virtual function \c u_index_poisson() provides the </div>
<div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;default index at which the Poisson nodal values are stored in a </div>
<div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;single-physics context:</div>
<div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160; </div>
<div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;\code</div>
<div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;virtual unsigned TwoNodePoissonElement::u_index_poisson()</div>
<div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160; {</div>
<div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;  // By default (i.e. in a single-physics context) the Poisson </div>
<div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;  // value is stored at the zero-th nodal value:</div>
<div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;  return 0;</div>
<div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160; }</div>
<div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;\endcode</div>
<div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160; </div>
<div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;The advection-diffusion element can be modified in the same way:</div>
<div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160; </div>
<div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;\code</div>
<div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;double TwoNodeAdvectionDiffusionElement::u(const unsigned &amp;n) </div>
<div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160; {</div>
<div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;  return node_pt(n)-&gt;value(u_index_adv_diff());</div>
<div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160; }</div>
<div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;\endcode</div>
<div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160; </div>
<div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;with</div>
<div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160; </div>
<div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;\code</div>
<div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;virtual unsigned TwoNodeAdvectionDiffusionElement::u_index_adv_diff()</div>
<div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160; {</div>
<div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;  // By default (i.e. in a single-physics context) the advection-diffusion</div>
<div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;  // value is stored at the zero-th nodal value:</div>
<div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;  return 0;</div>
<div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160; }</div>
<div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;\endcode</div>
<div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160; </div>
<div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;In a combined multi-physics problem, we can now merge the two elements by</div>
<div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;multiple inheritance,</div>
<div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160; </div>
<div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;\code</div>
<div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;class TwoNodeAdvDiffAndPoissonElement : </div>
<div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;       public virtual TwoNodePoissonElement,</div>
<div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;       public virtual TwoNodeAdvectionDiffusionElement</div>
<div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;\endcode</div>
<div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160; </div>
<div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;Name clashes are already avoided, so we only have to  overwrite the two index </div>
<div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;functions to indicate which (scalar) value is stored as which </div>
<div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;nodal value:</div>
<div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160; </div>
<div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;\code</div>
<div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;unsigned TwoNodeAdvDiffAndPoissonElement::u_index_adv_diff()</div>
<div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160; {</div>
<div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;  // In the combined multi-physics element we continue to store the </div>
<div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;  // advection-diffusion value at the zero-th nodal value</div>
<div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;  // [as a result it is not actually necessary to re-implement this</div>
<div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;  // function!]</div>
<div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;  return 0;</div>
<div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160; }</div>
<div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;\endcode</div>
<div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160; </div>
<div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;and </div>
<div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160; </div>
<div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;\code</div>
<div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;unsigned TwoNodeAdvDiffAndPoissonElement::u_index_poisson()</div>
<div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160; {</div>
<div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;  // In the combined multi-physics element we store the Poisson</div>
<div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;  // value at the first nodal value:</div>
<div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;  return 1;</div>
<div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160; }</div>
<div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;\endcode</div>
<div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160; </div>
<div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;Specific examples that illustrate the creation of (non-trivial) </div>
<div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;multi-physics elements by multiple inheritance are provided</div>
<div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;in the &lt;A HREF=&quot;../../example_code_list/html/index.html#multi&quot;&gt;</div>
<div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;list of example codes.&lt;/A&gt;</div>
<div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160; </div>
<div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160; </div>
<div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160; </div>
<div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;\subsubsection mesh_movement Rule 4: Time derivatives should be implemented in the ALE formulation to allow for moving meshes. </div>
<div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160; </div>
<div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;In moving mesh problems, the time-derivative of a nodal value </div>
<div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;(approximated by the Node&#39;s \c TimeStepper) is not the same as</div>
<div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;the Eulerian time-derivative \f$ \partial/ \partial t \f$</div>
<div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;that &quot;usually&quot; occurs in the governing equation.</div>
<div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;The former represents the rate of change when following the </div>
<div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;moving node; the latter is the rate of change evaluated at a fixed </div>
<div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;Eulerian position.  The two time-derivatives are related to each other</div>
<div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;via the ALE relation</div>
<div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;\f[</div>
<div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;\left. \frac{\partial (.)}{\partial t} \right|_{Eulerian} </div>
<div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;= \left. \frac{\partial (.) }{\partial t} \right|_{at \ node} - \ </div>
<div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;\sum_{i=1}^D v_i^{(Mesh)} \  \frac{\partial (.) }{ \partial x_i} </div>
<div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;\f]</div>
<div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;where \f$ D \f$ is the spatial dimension of the problem and</div>
<div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;\f$ v_i^{(Mesh)}  \ (i=1,...,D) \f$ is the velocity of the node. </div>
<div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;Any Eulerian time-derivatives in the governing equation should</div>
<div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;be implemented in the above form to ensure that the</div>
<div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;element remains functional in moving mesh problems.</div>
<div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;See the &lt;A HREF=&quot;../../unsteady_heat/two_d_unsteady_heat_ALE/html/index.html&quot;&gt;</div>
<div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;example describing the solution of the unsteady heat equation in a</div>
<div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;moving domain&lt;/A&gt; for further details.</div>
<div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160; </div>
<div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160; </div>
<div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160; </div>
<div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160; </div>
<div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160; </div>
<div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160; </div>
<div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;&lt;hr&gt;</div>
<div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;&lt;hr&gt;</div>
<div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;\section pdf PDF file</div>
<div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;A &lt;a href=&quot;../latex/refman.pdf&quot;&gt;pdf version&lt;/a&gt; of this document is available.</div>
<div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;**/</div>
<div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160; </div>
</div><!-- fragment --></div><!-- contents -->
<div class="ttc" id="aquick__guide_8txt_html_a9646ddcfbc2f9bc39d1cf1982e289472"><div class="ttname"><a href="quick__guide_8txt.html#a9646ddcfbc2f9bc39d1cf1982e289472">r_</a></div><div class="ttdeci">r_</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00352">quick_guide.txt:352</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a79ef5533024c5cca04a9ad7ff4689107"><div class="ttname"><a href="quick__guide_8txt.html#a79ef5533024c5cca04a9ad7ff4689107">identical</a></div><div class="ttdeci">L_x f and f y in[0, L_y] f with f N_x times N_y f quadrilateral elements Since the topology of the two domains is identical</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00361">quick_guide.txt:361</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a4d0781152eba93dda92287ed2b1550a8"><div class="ttname"><a href="quick__guide_8txt.html#a4d0781152eba93dda92287ed2b1550a8">default</a></div><div class="ttdeci">endcode Specification of the boundary conditions By default</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00137">quick_guide.txt:137</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_ad0d8d5a7b9f9ffb2f59a7322a31eb771"><div class="ttname"><a href="quick__guide_8txt.html#ad0d8d5a7b9f9ffb2f59a7322a31eb771">N_0</a></div><div class="ttdeci">endcode&lt; HR &gt; subsection mes_exercise f Pass the parameters f N_0</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00430">quick_guide.txt:430</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a29cd0618a88c307916802833ae667965"><div class="ttname"><a href="quick__guide_8txt.html#a29cd0618a88c307916802833ae667965">varphi_</a></div><div class="ttdeci">varphi_</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00353">quick_guide.txt:353</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a3cc40741e259335e99d97bb624c09eed"><div class="ttname"><a href="quick__guide_8txt.html#a3cc40741e259335e99d97bb624c09eed">Again</a></div><div class="ttdeci">endcode Again</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00211">quick_guide.txt:211</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a22617638d13e02e2355396f0efac6441"><div class="ttname"><a href="quick__guide_8txt.html#a22617638d13e02e2355396f0efac6441">SomeElement</a></div><div class="ttdeci">endcode the finer grained member functions c Problem::actions_after_newton_step() and \c Problem To build a c OneDimMesh with ten elements of type c SomeElement</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00212">quick_guide.txt:212</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a78d8afa5582b00e09020ac467b127397"><div class="ttname"><a href="quick__guide_8txt.html#a78d8afa5582b00e09020ac467b127397">r_min</a></div><div class="ttdeci">L_x f and f y in[0, L_y] f with f N_x times N_y f quadrilateral elements Since the topology of the two domains is the annular mesh can be implemented in a few lines of const unsigned const double &amp; r_min</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00380">quick_guide.txt:380</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_ac839063c3988d3908e1455a2213bc073"><div class="ttname"><a href="quick__guide_8txt.html#ac839063c3988d3908e1455a2213bc073">phi_max</a></div><div class="ttdeci">L_x f and f y in[0, L_y] f with f N_x times N_y f quadrilateral elements Since the topology of the two domains is the annular mesh can be implemented in a few lines of const unsigned const double const double const double const double &amp; phi_max</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00382">quick_guide.txt:382</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a554d25b3b938ef393a362cb50a68ca30"><div class="ttname"><a href="quick__guide_8txt.html#a554d25b3b938ef393a362cb50a68ca30">desired</a></div><div class="ttdeci">endcode If desired</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00181">quick_guide.txt:181</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a82cfecd465e2d249c843fd678debe61b"><div class="ttname"><a href="quick__guide_8txt.html#a82cfecd465e2d249c843fd678debe61b">mainpage</a></div><div class="ttdeci">mainpage(Not-So-) Quick Users Guide The purpose of this document is to provide a &quot;quick&quot; introduction to the fundamental objects in \c oomph-lib. Assuming that you - have a basic understanding of the finite element method . and - are reasonably familiar with object-oriented programming in C++</div></div>
<div class="ttc" id="aquick__guide_8txt_html_a3cf0d45f1e422b066836c6b451d8f938"><div class="ttname"><a href="quick__guide_8txt.html#a3cf0d45f1e422b066836c6b451d8f938">say</a></div><div class="ttdeci">endcode the finer grained member functions c Problem::actions_after_newton_step() and \c Problem To build a c OneDimMesh with ten elements of type c say</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00334">quick_guide.txt:334</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_ac17939ce74bee1d9d5e41f861c653489"><div class="ttname"><a href="quick__guide_8txt.html#ac17939ce74bee1d9d5e41f861c653489">f</a></div><div class="ttdeci">endcode&lt; HR &gt; subsection mes_exercise f</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00428">quick_guide.txt:428</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a4648272fb56eaaebdcdfc9f50f47daba"><div class="ttname"><a href="quick__guide_8txt.html#a4648272fb56eaaebdcdfc9f50f47daba">pi</a></div><div class="ttdeci">L_x f and f y in[0, L_y] f with f N_x times N_y f quadrilateral elements Since the topology of the two domains is the annular mesh can be implemented in a few lines of const unsigned const double const double const double const double const double pi</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00394">quick_guide.txt:394</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a28c512be778574961174106e95825c6d"><div class="ttname"><a href="quick__guide_8txt.html#a28c512be778574961174106e95825c6d">n_phi</a></div><div class="ttdeci">L_x f and f y in[0, L_y] f with f N_x times N_y f quadrilateral elements Since the topology of the two domains is the annular mesh can be implemented in a few lines of const unsigned &amp; n_phi</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00379">quick_guide.txt:379</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a63e01640fb0d539d1b7d6f6f9a381274"><div class="ttname"><a href="quick__guide_8txt.html#a63e01640fb0d539d1b7d6f6f9a381274">The</a></div><div class="ttdeci">endcode This statement sets the first(=zero-th in C++ 's zero-based indexing) nodal value to 1.0. - Completion of the build of the elements endcode subsection actbef The function in time dependent temporal discretisation Within this linear problems are special cases for which Newton s method converges in one step The(pure virtual) member function \c Problem</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00173">quick_guide.txt:173</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a87d98d9383cf4ede5d237d15f8b45b54"><div class="ttname"><a href="quick__guide_8txt.html#a87d98d9383cf4ede5d237d15f8b45b54">Mesh</a></div><div class="ttdeci">endcode subsection distorted_mesh How to adapt an existing Mesh to a different domain shape Given that mesh generation tends to be a fairly tedious one should always check whether it is possible to deform an existing c Mesh into a shape that matches the required domain Provided that the new domain has the same topology as the domain represented by the original c Mesh</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00346">quick_guide.txt:346</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_aa1930459dda66e6f5cc5abde6217fd8b"><div class="ttname"><a href="quick__guide_8txt.html#aa1930459dda66e6f5cc5abde6217fd8b">instance</a></div><div class="ttdeci">endcode Specification of the boundary conditions By all nodal values are assumed to be free and their values are initialised to zero we only need to pin the values that are prescribed by boundary conditions and assign any nonzero boundary values For instance</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00141">quick_guide.txt:141</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a4b4416668e498cab1d80a1242381c0f2"><div class="ttname"><a href="quick__guide_8txt.html#a4b4416668e498cab1d80a1242381c0f2">problems</a></div><div class="ttdeci">endcode This statement sets the first(=zero-th in C++ 's zero-based indexing) nodal value to 1.0. - Completion of the build of the elements endcode subsection actbef The function in time dependent problems</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00169">quick_guide.txt:169</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_adf1cb6924dd6da8c2881c34e811bffad"><div class="ttname"><a href="quick__guide_8txt.html#adf1cb6924dd6da8c2881c34e811bffad">for</a></div><div class="ttdeci">for(unsigned n=0;n&lt; n_node;n++)</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00397">quick_guide.txt:397</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a7d40451f6364de6fea6dcc6058ffe213"><div class="ttname"><a href="quick__guide_8txt.html#a7d40451f6364de6fea6dcc6058ffe213">hat</a></div><div class="ttdeci">endcode&lt; HR &gt; subsection mes_exercise hat</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00428">quick_guide.txt:428</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a2a9a5d0af7e32f1db04179a574e86c90"><div class="ttname"><a href="quick__guide_8txt.html#a2a9a5d0af7e32f1db04179a574e86c90">sections</a></div><div class="ttdeci">these geometric elements act as base classes for specific c FiniteElements that implement the discretisation of particular PDEs We discuss the implementation of the two types of elements in two separate sections</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00050">quick_guide.txt:50</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_ad24e4b91f35d2da58d987fd895983a0c"><div class="ttname"><a href="quick__guide_8txt.html#ad24e4b91f35d2da58d987fd895983a0c">class</a></div><div class="ttdeci">&quot;oomph-table&quot;&gt;&lt; TR &gt;&lt; TD class=&quot;panel panel-default&quot;&gt;&lt; CENTER class=&quot;panel-heading&quot;&gt;&lt; B &gt;One-dimensional model Poisson problem&lt;/B &gt;&lt;/CENTER &gt;&lt; div class=&quot;panel-body&quot;&gt; Solve \f[\frac{\mbox{d}^2u}{\mbox{d}x^2}=\pm 30 \sin(\sqrt{30} x), \ \ \ \ \ \ \ \ \ \ @E[1DPoisson]@ \f] in the one-dimensional domain \f $x\in[0, 1]\f$, subject to \f[u(0)=0 \ \mbox{\ \ \ and \ \ \ } \ \ u(1)=\mp 1, \ \ \ \ \ \ \ \ \ \ @E[1DPoisson_BC]@ \f]&lt;/div &gt;&lt;/TD &gt;&lt;/TR &gt;&lt;/TABLE &gt;&lt;/CENTER &gt; by isoparametric two-node elements.(Please consult the&lt; A HREF=&quot;../../intro/html/index.html&quot;&gt;Introduction&lt;/A &gt; for a review of the relevant finite element theory.) The source code for this example(&lt; A HREF=&quot;../../../demo_drivers/poisson/one_d_poisson_generic_only/one_d_poisson_generic_only.cc&quot;&gt;one_d_poisson_generic_only.cc&lt;/A &gt;) is self-contained and uses only objects from the &quot;generic&quot; part of the \c oomph-lib library.[\c oomph-lib does, of course, provide 1D meshes and Poisson elements but we deliberately ignore these because we wish to illustrate how to build such objects from scratch. The alternative example code&lt; A HREF=&quot;../../../demo_drivers/poisson/one_d_poisson/one_d_poisson.cc&quot;&gt; one_d_poisson.cc&lt;/A &gt;, discussed in&lt; A HREF=&quot;../../poisson/one_d_poisson/html/index.html&quot;&gt; another example&lt;/A &gt; illustrates the implementation of the same problem using existing library objects.] The main purpose of this document is to provide a \e &quot;quick&quot; introduction to \c oomph-lib 's fundamental objects, so the example classes presented below are fully-functional but very basic. We provide exercises at the end of each section to allow the reader to explore various straightforward improvements, most of which are implemented in the corresponding objects in the library. Finally, the section \ref comments provides a discussion of some general design principles that should be respected when creating new classes for use with the library.&lt; HR &gt;&lt; HR &gt; \section problem How to build a Problem All specific \c Problems should be implemented as objects that inherit from the generic \c Problem class. These specific \c Problem objects will vary considerably depending on the exact details of the problem being solved. Only a few member functions \e must be implemented for each specific \c Problem class:- The problem constructor \code SomeSpecificProblem(...) \endcode - and the member functions \code Problem::actions_before_newton_solve() \endcode \code Problem::actions_after_newton_solve() \endcode . \subsection spec The constructor:SomeSpecificProblem(...) The Problem constructor \c SomeSpecificProblem(...) usually contains the following steps:- Construction of the timestepper(if required), e.g. \code Problem::add_time_stepper_pt(new SomeTimeStepper()) class</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00131">quick_guide.txt:131</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a6da34e5fa987afcf75ad6a5f57a3002a"><div class="ttname"><a href="quick__guide_8txt.html#a6da34e5fa987afcf75ad6a5f57a3002a">framework</a></div><div class="ttdeci">endcode This statement sets the first(=zero-th in C++ 's zero-based indexing) nodal value to 1.0. - Completion of the build of the elements endcode subsection actbef The function in time dependent temporal discretisation Within this framework</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00169">quick_guide.txt:169</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a2776bbc2bbeace0b362c3df824fe8eb4"><div class="ttname"><a href="quick__guide_8txt.html#a2776bbc2bbeace0b362c3df824fe8eb4">Therefore</a></div><div class="ttdeci">endcode Specification of the boundary conditions By all nodal values are assumed to be free and their values are initialised to zero Therefore</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00139">quick_guide.txt:139</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_af10de6107417dc48a16cf00b58d00fc7"><div class="ttname"><a href="quick__guide_8txt.html#af10de6107417dc48a16cf00b58d00fc7">phi_min</a></div><div class="ttdeci">L_x f and f y in[0, L_y] f with f N_x times N_y f quadrilateral elements Since the topology of the two domains is the annular mesh can be implemented in a few lines of const unsigned const double const double const double &amp; phi_min</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00381">quick_guide.txt:381</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_af0a739cc0ae056a11b0d9a30b87be62a"><div class="ttname"><a href="quick__guide_8txt.html#af0a739cc0ae056a11b0d9a30b87be62a">inheritance</a></div><div class="ttdeci">endcode subsection distorted_mesh How to adapt an existing Mesh to a different domain shape Given that mesh generation tends to be a fairly tedious one should always check whether it is possible to deform an existing c Mesh into a shape that matches the required domain Provided that the new domain has the same topology as the domain represented by the original c this can always be done by re positioning the Nodes Such deformed c Meshes should be implemented via inheritance</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00348">quick_guide.txt:348</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a9ed426cbbaefff05802e5157f6e8bd88"><div class="ttname"><a href="quick__guide_8txt.html#a9ed426cbbaefff05802e5157f6e8bd88">HREF</a></div><div class="ttdeci">&quot;../../example_code_list/html/index.html&quot;&gt; list of example codes&lt;/A &gt; distributed with the library. \section main_how_to How to solve simple PDEs with oomph-lib To solve a given PDE with \c oomph-lib, its discretisation needs to be specified in a \c Problem object. This usually involves the specification of the \c Mesh and the element types, followed by the application of the boundary conditions. If these steps are performed in the \c Problem constructor, the driver code itself can be as simple as:\dontinclude one_d_poisson_generic_only.cc \skipline main(\until } The amount of work required to represent a given PDE as a \c Problem object is problem-dependent:- If \c oomph-lib 's existing \c Mesh objects and element types are sufficient to discretise the problem, the generation of a fully-functional \c Problem object is straightforward. We shall discuss this case in the section \ref problem. - If \c oomph-lib provides the required element type but none of the available meshes are suitable, you will have to write your own \c Mesh object. We shall discuss this in the section \ref mesh. It is also possible to create \c oomph-lib meshes based on the output from third-party(commercial) mesh generators. This is illustrated in&lt; A HREF=&quot;../../meshes/third_party_meshes/html/index.html&quot;&gt; another example.&lt;/A &gt; - Finally, the problem might involve a PDE for which \c oomph-lib does not provide any suitable elements. In this case you will need to write your own element. When implementing elements in \c oomph-lib the element formulation is generally sub-divided into(at least) two levels. Geometric elements implement the element geometry(e.g. 2D quad elements, 3D brick elements, etc) HREF</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00045">quick_guide.txt:45</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a9a75da5e2f56dd5571b8a556e1a6c500"><div class="ttname"><a href="quick__guide_8txt.html#a9a75da5e2f56dd5571b8a556e1a6c500">r_max</a></div><div class="ttdeci">L_x f and f y in[0, L_y] f with f N_x times N_y f quadrilateral elements Since the topology of the two domains is the annular mesh can be implemented in a few lines of const unsigned const double const double &amp; r_max</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00380">quick_guide.txt:380</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a405d86defb546a9435e2ef1714834112"><div class="ttname"><a href="quick__guide_8txt.html#a405d86defb546a9435e2ef1714834112">Exercise</a></div><div class="ttdeci">endcode&lt; HR &gt; subsection mes_exercise Exercise</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00416">quick_guide.txt:416</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_aa2d00a6560c109390f77f64ad86fd601"><div class="ttname"><a href="quick__guide_8txt.html#aa2d00a6560c109390f77f64ad86fd601">bounded</a></div><div class="ttdeci">endcode subsection distorted_mesh How to adapt an existing Mesh to a different domain shape Given that mesh generation tends to be a fairly tedious one should always check whether it is possible to deform an existing c Mesh into a shape that matches the required domain Provided that the new domain has the same topology as the domain represented by the original c this can always be done by re positioning the Nodes Such deformed c Meshes should be implemented via by deriving the new c Mesh from an existing one Here is an example that illustrates the procedure Assume we wish to solve an equation in the annular domain bounded(in polar coordinates) by \f$ r \in[r_</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00351">quick_guide.txt:351</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a6ed4f14a2273ad89cd15c532cba12f6e"><div class="ttname"><a href="quick__guide_8txt.html#a6ed4f14a2273ad89cd15c532cba12f6e">process</a></div><div class="ttdeci">endcode subsection distorted_mesh How to adapt an existing Mesh to a different domain shape Given that mesh generation tends to be a fairly tedious process</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00342">quick_guide.txt:342</a></div></div>
<div class="ttc" id="aquick__guide_8txt_html_a5e3164cb91556c51fc6ca3aa4de05205"><div class="ttname"><a href="quick__guide_8txt.html#a5e3164cb91556c51fc6ca3aa4de05205">code</a></div><div class="ttdeci">L_x f and f y in[0, L_y] f with f N_x times N_y f quadrilateral elements Since the topology of the two domains is the annular mesh can be implemented in a few lines of code</div><div class="ttdef"><b>Definition:</b> <a href="quick__guide_8txt_source.html#l00379">quick_guide.txt:379</a></div></div>

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Fri Jul 9 2021 00:30:57
        </div>
      </div>
    </footer>
</body>
</html>
