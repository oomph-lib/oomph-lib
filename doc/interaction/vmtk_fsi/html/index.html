<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Demo problem: Steady finite-Reynolds-number flow through an elastic iliac bifurcation</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Demo problem: Steady finite-Reynolds-number flow through an elastic iliac bifurcation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><br  />
 This tutorial demonstrates how to simulate physiological fluid-structure interaction problems, based on medical imaging data, processed with the <a href="http://www.vmtk.org">Vascular Modeling Toolkit.</a></p>
<p>We combine two single-physics problems, namely</p><ul>
<li><a href="../../../solid/vmtk_solid/html/index.html">The inflation of a blood vessel</a></li>
<li><a href="../../../navier_stokes/vmtk_fluid/html/index.html">Finite-Reynolds number flow through a rigid iliac bifurcation</a></li>
</ul>
<p>to study the steady flow through an elastic iliac bifurcation. (Please refer to <code>oomph-lib's</code> <a href="../../../meshes/mesh_from_vmtk/html/index.html">VMTK tutorial</a> to find out how to generate <code>oomph-lib</code> meshes from medical images.)</p>
<p>The tutorial also provides a detailed discussion of the mechanism by which <code>FaceElements</code> introduce additional unknowns into a problem. This is important in the problem considered here because we employ two different types of <code>FaceElements</code>, both of which introduce additional unknowns. When dealing with nodes that are attached to both types of <code>FaceElements</code> we must therefore be able to determine which nodal values are associated with which <code>FaceElement</code>. The section <a class="el" href="index.html#face">How FaceElements introduce additional unknowns into a problem</a> below shows how this is done.</p>
<center> <table border="1," width="500px">
<tr>
<td bgcolor="cornsilk"><center> <b>Acknowledgement:</b> </center> This tutorial and the associated driver codes were developed jointly with Amine Massit (ENSTA, Paris).   </td></tr>
</table>
</center><hr  />
 <hr  />
<h1><a class="anchor" id="prob"></a>
The problem (and some results)</h1>
<p>The animations below show the deformation of an iliac bifurcation that conveys viscous fluid and deforms in response to the traction that the fluid exerts onto it. As in the previous examples where we considered the constituent single-physics <a href="../../../navier_stokes/vmtk_fluid/html/index.html">fluid</a> and <a href="../../../solid/vmtk_solid/html/index.html">solid</a> problems, the meshes are obviously very coarse and the boundary conditions are far from "physiologically realistic": We keep the upstream and downstream "ends" of the vessel wall in a fixed position and drive the (steady!) flow by applying a constant pressure drop between the in- and outflow cross sections. The different frames shown in the animation show results for different wall stiffnesses, using the same setup as in <a href="../../unstructured_three_d_fsi/html/index.html">another tutorial.</a></p>
<p>We stress that the computations presented here serve as quick-to-compute proof of concept and refer to the section <a class="el" href="index.html#comm_ex">Comments and Exercises</a> at the end of this tutorial for a discussion on how to make the simulation more "realistic".</p>
<div class="image">
<img src="elastic_iliac_solid.gif" alt=""/>
<div class="caption">
The flow-induced deformation of an iliac bifurcation. The animation shows the effect of variations in the wall stiffness. The arrows show the magnitude of the fluid traction on the wall. </div></div>
 <div class="image">
<img src="elastic_iliac_fluid.gif" alt=""/>
<div class="caption">
Steady finite-Reynolds number flow through an elastic iliac bifurcation (velocity vectors and pressure contours). The animation shows the effect of variations in the wall stiffness. </div></div>
 <p>The driver code used for this computation is very similar to the one discussed in <a href="../../unstructured_three_d_fsi/html/index.html">another tutorial</a> where we used a much simpler geometry in which the three branches of the bifurcation had rectangular cross-sections. Before discussing the changes to the driver code in section <a class="el" href="index.html#driver_code">The driver code for the FSI problem</a> below, we provide a more detailed discussion of the way in which <code>FaceElements</code> introduce additional unknowns into a problem. Feel free to skip the next section if you're not keen on theory.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="face"></a>
How FaceElements introduce additional unknowns into a problem</h1>
<p><code>FaceElements</code> are used widely throughout <code>oomph-lib</code> to apply Neumann/flux/traction-type boundary conditions on the faces of higher-dimensional "bulk" elements. Examples include:</p><ul>
<li><a href="../../../poisson/two_d_poisson_flux_bc2/html/index.html">the application of a flux boundary condition in a Poisson problem;</a></li>
<li>the application of traction boundary conditions in <a href="../../../navier_stokes/rayleigh_traction_channel/html/index.html">fluid</a> and <a href="../../../solid/airy_cantilever/html/index.html">solid</a> mechanics problems;</li>
<li><a href="../../../young_laplace/contact_angle/html/index.html">the application of a contact-angle boundary condition for the Young-Laplace equation.</a></li>
</ul>
<p>In all the examples listed above, the boundary conditions simply add a contribution to the elements' residuals but they do not introduce any additional unknowns into the problem.</p>
<p><code>FaceElements</code> may also be used to apply boundary conditions via Lagrange multipliers. An example is given in the tutorial that discusses</p><ul>
<li><a href="../../../solid/prescribed_displ_lagr_mult/html/index.html">the application of displacement boundary conditions for solid mechanics problems</a></li>
</ul>
<p>In such problems, the Lagrange multipliers must be determined as part of the solution, and storage for the associated discrete unknowns is created at the nodes of the <code>FaceElements</code>.</p>
<p>To explain the relevant details of the implementation we consider a simple 2D Navier-Stokes problem discretised using nine-node Taylor-Hood elements (in these elements each vertex node stores two discrete velocities and one pressure; the other nodes store only two velocity degrees of freedom). We assume that boundaries 0 and 1 are subject to boundary conditions imposed via <code>FaceElements</code>, and that each boundary condition introduces its own Lagrange multipliers field<b>s</b>. [Yes, the plural is correct. As an example, consider the case of imposing displacement constraints in a 2D solid mechanics problem via Lagrange multipliers. In this approach the imposition of the boundary condition requires <em>two</em> Lagrange multipliers along each constrained boundary. Physically, the Lagrange multipliers represent the two components of the surface traction required to deform the boundary into the required shape; see <a href="../../../solid/prescribed_displ_lagr_mult/html/index.html">the relevant solid mechanics problem</a> for details.]</p>
<p>The sketch below shows the discretisation of the domain, with the black circles representing the nodes. The enlargement of the top right corner also shows the discrete unknowns (nodal velocities and pressures) stored at each node after the creation of the "bulk" Navier-Stokes elements.</p>
<div class="image">
<img src="multiple_face_elements1.gif" alt=""/>
<div class="caption">
Sketch of a problem that is subject to flux-type boundary conditions along boundaries 0 and 1. The sketch illustrates the degrees of freedom at each node before any FaceElements are attached. </div></div>
 <p>The next figure shows the nodal degrees of freedom after the <code>FaceElements</code> on boundary 0 (shown in red) have been attached. The <code>FaceElements</code> share the existing nodes of the underlying "bulk" elements and automatically create storage for any additional nodal unknowns. Here we provide storage for two discrete Lagrange multipliers, <img class="formulaInl" alt="$ \Lambda_x $" src="form_0.png"/> and <img class="formulaInl" alt="$ \Lambda_y. $" src="form_1.png"/> Provided that a single <code>FaceElement</code> is attached to a node, the function </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> FaceElement::nbulk_value(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; j)</div>
</div><!-- fragment --><p> can be used to determine the number of nodal values at the <code>FaceElement's</code> <code>j</code> -th node created by the underlying "bulk" element <em>before</em> the <code>FaceElement</code> was attached. It is then easy to identify the additional nodal values associated with the <code>FaceElement</code> in order to apply the boundary conditions for the Lagrange multipliers, say. The methodology is illustrated in the <a href="../../../solid/prescribed_displ_lagr_mult/html/index.html#bcs_for_lagrange_multipliers">the solid mechanics problem referred to earlier.</a></p>
<div class="image">
<img src="multiple_face_elements2.gif" alt=""/>
<div class="caption">
Sketch illustrating the degrees of freedom at each node after FaceElements have been attached to boundary 0. </div></div>
 <p>The next figure shows the degrees of freedom after the <code>FaceElements</code> on boundary 1 (shown in green) have also been attached. These <code>FaceElements</code> must create storage for their own two Lagrange multipliers, <img class="formulaInl" alt="$ \lambda_x $" src="form_2.png"/> and <img class="formulaInl" alt="$ \lambda_y $" src="form_3.png"/>. Thus, the corner node (which is attached to both types of <code>FaceElements</code>) has four additional degrees of freedom after all the <code>FaceElements</code> have been created.</p>
<div class="image">
<img src="multiple_face_elements3.gif" alt=""/>
<div class="caption">
Sketch illustrating the degrees of freedom at each node after all FaceElements have been attached. </div></div>
 <p>The identification of the additional degrees of freedom via a simple offset from the degrees of freedom created by the "bulk" element is now no longer possible. We therefore provide an alternative mechanism to access the relevant information from the nodes themselves via the function </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> BoundaryNodeBase::index_of_first_value_assigned_by_face_element()</div>
</div><!-- fragment --><p> which does exactly what it says. If only a single type of <code>FaceElement</code> is attached to a (boundary) node, the unsigned that is returned by this function is exactly the same as the unsigned that is returned by the corresponding call to <code>FaceElement::nbulk_value(...)</code>. To cater for the case where multiple <code>FaceElements</code> are attached to the same node, the above function can take an ID (which defaults to zero) that identifies which type of <code>FaceElement</code> we are dealing with, so the full interface is, in fact, </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> BoundaryNodeBase::index_of_first_value_assigned_by_face_element(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; <span class="keywordtype">id</span>=0)</div>
</div><!-- fragment --><p> The ID must be established by the user, typically when the constructor of the specific <code>FaceElement</code> is called. It can then be passed on to the <code>Nodes</code> when the number of values at the nodes is adjusted to accommodate the additional values required by the <code>FaceElement</code>.</p>
<p>To illustrate this, the code extract shown below provides a (partial) listing of the constructor of the <code>ImposeDisplacementByLagrangeMultiplierElement</code> that was used in <a href="../../../solid/prescribed_displ_lagr_mult/html/index.html">the solid mechanics problem referred to earlier</a>. The constructor has the usual two arguments that specify the pointer to the "bulk" element, and the index of the face that the <code>FaceElement</code> is to be attached to. The final (optional) argument allows the specification of the ID referred to above. We store the ID in a private the element's private member data.</p>
 <div class="fragment"><div class="line">    <span class="comment">/// \short Constructor takes a &quot;bulk&quot; element and the</span></div>
<div class="line"><span class="comment">    /// index that identifies which face the FaceElement is supposed</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// to be attached to. The optional identifier can be used</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// to distinguish the additional nodal values created by</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// this element from thos created by other FaceElements.</span></div>
<div class="line"><span class="comment"></span>    ImposeDisplacementByLagrangeMultiplierElement(</div>
<div class="line">      FiniteElement* <span class="keyword">const</span>&amp; element_pt,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; face_index,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; <span class="keywordtype">id</span> = 0,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; called_from_refineable_constructor = <span class="keyword">false</span>)</div>
<div class="line">      : FaceGeometry&lt;ELEMENT&gt;(), FaceElement(), Boundary_shape_geom_object_pt(0)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">//  Store the ID of the FaceElement -- this is used to distinguish</span></div>
<div class="line">      <span class="comment">// it from any others</span></div>
<div class="line">      Id = id;</div>
</div><!-- fragment --><p>[We omit a few lines of code that are irrelevant for the present discussion]. Next we specify the number of additional values required at each of the element's nodes and store them in a vector. For a <code>dim</code> -dimensional bulk element, we need <code>dim</code> additional values at each node to store the Lagrange multipliers.</p>
<div class="fragment"><div class="line">      <span class="comment">// Dimension of the bulk element</span></div>
<div class="line">      <span class="keywordtype">unsigned</span> dim = element_pt-&gt;dim();</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// We need dim additional values for each FaceElement node</span></div>
<div class="line">      <span class="comment">// to store the dim Lagrange multipliers.</span></div>
<div class="line">      Vector&lt;unsigned&gt; n_additional_values(nnode(), dim);</div>
</div><!-- fragment --><p>Finally, we pass this vector, together with ID that identifies the type of the <code>FaceElement</code> to the function <code>FaceElement::add_additional_values(...)</code>:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">      <span class="comment">// Now add storage for Lagrange multipliers and set the map containing</span></div>
<div class="line">      <span class="comment">// the position of the first entry of this face element&#39;s</span></div>
<div class="line">      <span class="comment">// additional values.</span></div>
<div class="line">      add_additional_values(n_additional_values, <span class="keywordtype">id</span>);</div>
<div class="line">    }</div>
</div><!-- fragment --><p>This function creates the additional storage at each node and updates the node's internal lookup scheme that provides access to the first value associated with the specified ID.</p>
<p>The fact that the ID is specified as an optional argument means that the user does not have to provide a dummy ID in cases where none is required, i.e. in problems involving just a single type of <code>FaceElement</code>, as in <a href="../../../solid/prescribed_displ_lagr_mult/html/index.html">the solid mechanics problem referred to earlier.</a> If a problem does involve multiple <code>FaceElements</code>, the user will be aware of this when writing the driver code and can then provide distinct IDs as and when required; see the section <a class="el" href="index.html#face_elements_code">Creating the Lagrange multiplier elements</a> below.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="driver_code"></a>
The driver code for the FSI problem</h1>
<p>The driver code for the flow through the elastic iliac is almost identical to that in the <a href="../../unstructured_three_d_fsi/html/index.html">tutorial considering the same problem in a more simplistic geometry.</a> Comparing the two driver codes using</p>
<div class="fragment"><div class="line">sdiff demo_drivers/interaction/vmtk_fsi/vmtk_fsi.cc \
      demo_drivers/interaction/unstructured_three_d_fsi/unstructured_three_d_fsi.cc</div>
</div><!-- fragment --><p>shows that the only differences relate to the facts that:</p><ul>
<li>although the meshes for the two problems are topologically equivalent, the boundary numbers assigned by <code>Tetgen</code> are different.</li>
<li>we impose parallel flow at the vessel's in- and outflow cross-sections, none of which are not aligned with any of the Cartesian coordinate planes. The parallel flow and the imposed pressure drop are therefore enforced by attaching <code>ImposeParallelOutflowElements</code>, rather than <code>NavierStokesTractionElements</code> to the in- and outflow boundaries. We refer to the corresponding <a href="../../../navier_stokes/vmtk_fluid/html/index.html#parallel_flow">single-physics fluids problem</a> for more details on this aspect.</li>
<li>The problem involves two different types of <code>FaceElements:</code> <ul>
<li><code>ImposeParallelOutflowElements</code> are used to impose parallel flow at the in- and outflow cross-sections.</li>
<li><code>ImposeDisplacementByLagrangeMultiplerElements</code> are used to deform the boundary of the pseudo-solid fluid mesh to reflect the changes in the geometry of the vessel wall.</li>
</ul>
Since both <code>FaceElements</code> introduce additional unknowns into the problem, we use the methodology described <a href="#face">above</a> to distinguish between the two types of Lagrange multipliers.</li>
</ul>
<p>Once again, we shall discuss only those aspects of the code that are changed from the driver code discussed in the <a href="../../unstructured_three_d_fsi/html/index.html">previous tutorial.</a></p>
<hr  />
<h2><a class="anchor" id="namespace"></a>
The namespace for global parameters</h2>
<p>As usual, global parameters are specified in a namespace, which now includes an <code>enum</code> that specifies the IDs for the two different <code>FaceElements</code>.</p>
 <div class="fragment"><div class="line"><span class="comment">//=======start_of_namespace==========================================</span></div>
<div class="line"><span class="comment">/// Global variables</span></div>
<div class="line"><span class="comment"></span><span class="comment">//================================================================</span></div>
<div class="line"><span class="keyword">namespace </span>Global_Parameters</div>
<div class="line">{</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Default Reynolds number</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> Re=50.0; </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Default FSI parameter</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> Q=0.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to constitutive law</span></div>
<div class="line"><span class="comment"></span> ConstitutiveLaw* Constitutive_law_pt=0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Poisson&#39;s ratio for generalised Hookean constitutive equation</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> Nu=0.3;</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Fluid pressure on inflow boundary</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> P_in=0.25;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Fluid pressure on outflow boundary</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> P_out=-0.25; </div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// \short IDs for the two types of Lagrange multipliers used</span></div>
<div class="line"><span class="comment"> /// in this problem</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">enum</span>{Parallel_flow_lagrange_multiplier_id, </div>
<div class="line">      FSI_interface_displacement_lagrange_multiplier_id};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">//end_of_namespace</span></div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="constructor"></a>
The Problem constructor</h2>
<p>The general structure of the problem constructor remains unchanged. There are a few trivial changes in the import of fluid and solid meshes to reflect the fact that the tetgen boundary numbers are different.</p>
<p>When imposing the boundary conditions for the fluid mesh we do <b> not </b> pin the transverse velocities at the in- and outlets because the parallel flow is now imposed by Lagrange multiplier elements. Hence the only boundary condition to be applied at the in- and outflow cross-sections is the pinning of the nodal positions.</p>
<p>The only significant change arises in the application of the boundary conditions for the Lagrange multipliers. Recall that <code>ImposeDisplacementByLagrangeMultiplierElements</code> are used to deform the FSI boundary of the fluid mesh so that it stays in contact with the vessel wall. This constraint must be applied along the entire FSI boundary, apart from the lines along which it meets the in- and outflow boundaries where the position of the fluid nodes is already pinned. Consequently, we pin the Lagrange multipliers in this part of the mesh.</p>
<p>Similarly, the <code>ImposeParallelOutflowElements</code> ensure that the velocity in the in- and outflow cross-sections is orthogonal to these cross-sections. This constraint must be applied along the entirety of the in- and outflow boundaries, apart from the lines along which they meet the FSI interface where the fluid velocity is already determined by the no-slip condition. Consequently, we also pin the second set of Lagrange multipliers along this part of the fluid mesh boundary.</p>
<p>We loop over all the fluid nodes on the FSI boundary:</p>
<div class="fragment"><div class="line"> <span class="comment">// Loop over nodes on the FSI boundary in the fluid mesh</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nbound=nfluid_fsi_boundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;nbound;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Get the mesh boundary</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> b = Fluid_fsi_boundary_id[i];</div>
<div class="line">   <span class="keywordtype">unsigned</span> num_nod=Fluid_mesh_pt-&gt;nboundary_node(b);</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Get node</span></div>
<div class="line">     Node* nod_pt= Fluid_mesh_pt-&gt;boundary_node_pt(b,inod);</div>
</div><!-- fragment --><p>For each node we apply the no-slip condition on the wall by pinning all three velocity components,</p>
<div class="fragment"><div class="line">     </div>
<div class="line">     <span class="comment">// Pin all velocities</span></div>
<div class="line">     nod_pt-&gt;pin(0); </div>
<div class="line">     nod_pt-&gt;pin(1); </div>
<div class="line">     nod_pt-&gt;pin(2); </div>
</div><!-- fragment --><p>and determine whether the node also happens to be located on the in- or outflow cross-sections:</p>
<div class="fragment"><div class="line">     </div>
<div class="line">     <span class="comment">// Find out whether node is also on in/outflow</span></div>
<div class="line">     <span class="keywordtype">bool</span> is_in_or_outflow_node=<span class="keyword">false</span>;</div>
<div class="line">     <span class="keywordtype">unsigned</span> n=nfluid_inflow_traction_boundary();</div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0;k&lt;n;k++)</div>
<div class="line">      {</div>
<div class="line">       <span class="keywordflow">if</span> (nod_pt-&gt;is_on_boundary(Inflow_boundary_id[k]))</div>
<div class="line">        {</div>
<div class="line">         is_in_or_outflow_node=<span class="keyword">true</span>;</div>
<div class="line">         <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">     <span class="keywordflow">if</span> (!is_in_or_outflow_node)</div>
<div class="line">      {</div>
<div class="line">       <span class="keywordtype">unsigned</span> n=nfluid_outflow_traction_boundary();</div>
<div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0;k&lt;n;k++)</div>
<div class="line">        {</div>
<div class="line">         <span class="keywordflow">if</span> (nod_pt-&gt;is_on_boundary(Outflow_boundary_id[k]))</div>
<div class="line">          {</div>
<div class="line">           is_in_or_outflow_node=<span class="keyword">true</span>;</div>
<div class="line">           <span class="keywordflow">break</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      } <span class="comment">// ...now we know if the node is on an in- or outflow boundary</span></div>
</div><!-- fragment --><p>If it is, we pin the Lagrange multipliers associated with the <code>ImposeParallelFlowElements</code>, using the <code>BoundaryNodeBase::index_of_first_value_assigned_by_face_element(...)</code> function referred to <a href="#face">above</a>, and specifying the appropriate ID.</p>
<div class="fragment"><div class="line">     </div>
<div class="line">     <span class="comment">// Pin the Lagrange multipliers for the imposition of</span></div>
<div class="line">     <span class="comment">// parallel flow if the nodes is also on the in/outflow boundaries</span></div>
<div class="line">     <span class="keywordflow">if</span>(is_in_or_outflow_node)</div>
<div class="line">      {</div>
<div class="line">       <span class="comment">//Cast to a boundary node</span></div>
<div class="line">       BoundaryNode&lt;SolidNode&gt; *bnod_pt = </div>
<div class="line">        <span class="keyword">dynamic_cast&lt;</span>BoundaryNode&lt;SolidNode&gt;*<span class="keyword">&gt;</span></div>
<div class="line">        ( Fluid_mesh_pt-&gt;boundary_node_pt(b,inod) );</div>
<div class="line">       </div>
<div class="line">       <span class="comment">// Get the index of the first Lagrange multiplier</span></div>
<div class="line">       <span class="keywordtype">unsigned</span> first_index=bnod_pt-&gt;</div>
<div class="line">        index_of_first_value_assigned_by_face_element(</div>
<div class="line">         Global_Parameters::Parallel_flow_lagrange_multiplier_id);</div>
<div class="line"> </div>
<div class="line">       <span class="comment">//Pin the Lagrange multipliers (as the velocity is already</span></div>
<div class="line">       <span class="comment">//determined via the no slip condition on the fsi boundary</span></div>
<div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0;l&lt;2;l++)</div>
<div class="line">        {</div>
<div class="line">         nod_pt-&gt;pin(first_index+l);</div>
<div class="line">        }</div>
</div><!-- fragment --><p>We repeat the same procedure for the Lagrange multipliers associated with the <code>ImposeDisplacementByLagrangeMultiplierElements:</code> </p>
<div class="fragment"><div class="line"> </div>
<div class="line">       </div>
<div class="line">       <span class="comment">// Get the first index of the second Lagrange multiplier </span></div>
<div class="line">       first_index=bnod_pt-&gt;index_of_first_value_assigned_by_face_element(</div>
<div class="line">        Global_Parameters::FSI_interface_displacement_lagrange_multiplier_id);</div>
<div class="line"> </div>
<div class="line">       <span class="comment">// Loop over the Lagrange multipliers that deform the FSI boundary</span></div>
<div class="line">       <span class="comment">// of the pseudo-solid fluid mesh.</span></div>
<div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0;l&lt;3;l++)</div>
<div class="line">        {</div>
<div class="line">         <span class="comment">// Pin the Lagrange multipliers that impose the displacement</span></div>
<div class="line">         <span class="comment">// because the positon of the fluid nodes at the in/outflow</span></div>
<div class="line">         <span class="comment">// is already determined. </span></div>
<div class="line">         nod_pt-&gt;pin(first_index+l);</div>
<div class="line">        }</div>
</div><!-- fragment --><p>As usual we document the position of the nodes at which we pinned the Lagrange multipliers in a file to allow for an external sanity check.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">       <span class="comment">// Doc that we&#39;ve pinned the Lagrange multipliers at this node</span></div>
<div class="line">       pinned_file &lt;&lt; nod_pt-&gt;x(0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">                   &lt;&lt; nod_pt-&gt;x(1) &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">                   &lt;&lt; nod_pt-&gt;x(2) &lt;&lt; endl;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">// end of BC for fluid mesh</span></div>
</div><!-- fragment --><p>The rest of the problem constructor is unchanged.</p>
<hr  />
<h2><a class="anchor" id="face_elements_code"></a>
Creating the Lagrange multiplier elements</h2>
<p>The creation of the <code>ImposeDisplacementByLagrangeMultiplierElements</code> is virtually identical to that in the <a href="../../unstructured_three_d_fsi/html/index.html">previous tutorial.</a></p>
<div class="fragment"><div class="line"><span class="comment">//============start_of_create_lagrange_multiplier_elements===============</span></div>
<div class="line"><span class="comment">/// Create elements that impose the prescribed boundary displacement</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// for the pseudo-solid fluid mesh</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=======================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> FLUID_ELEMENT, <span class="keyword">class</span> SOLID_ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> UnstructuredFSIProblem&lt;FLUID_ELEMENT,SOLID_ELEMENT&gt;::</div>
<div class="line">create_lagrange_multiplier_elements()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Make space</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n=nfluid_fsi_boundary();</div>
<div class="line"> Solid_fsi_boundary_pt.resize(n);</div>
<div class="line">    </div>
<div class="line"> <span class="comment">// Loop over FSI interfaces in fluid</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n;i++)</div>
<div class="line">  {   </div>
<div class="line">   <span class="comment">// Get boundary ID</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> b=Fluid_fsi_boundary_id[i];</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Create  GeomObject incarnation of fsi boundary in solid mesh</span></div>
<div class="line">   Solid_fsi_boundary_pt[i]=</div>
<div class="line">    <span class="keyword">new</span> MeshAsGeomObject</div>
<div class="line">    (Solid_fsi_traction_mesh_pt[i]);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// How many bulk fluid elements are adjacent to boundary b?</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_element = Fluid_mesh_pt-&gt;nboundary_element(b);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Loop over the bulk fluid elements adjacent to boundary b?</span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Get pointer to the bulk fluid element that is adjacent to boundary b</span></div>
<div class="line">     FLUID_ELEMENT* bulk_elem_pt = <span class="keyword">dynamic_cast&lt;</span>FLUID_ELEMENT*<span class="keyword">&gt;</span>(</div>
<div class="line">      Fluid_mesh_pt-&gt;boundary_element_pt(b,e));</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//Find the index of the face of element e along boundary b</span></div>
<div class="line">     <span class="keywordtype">int</span> face_index = Fluid_mesh_pt-&gt;face_index_at_boundary(b,e);</div>
</div><!-- fragment --><p>The only difference is that we pass the ID that identifies the type of the <code>FaceElement</code> to the constructor of the <code>ImposeDisplacementByLagrangeMultiplierElements:</code> </p>
<div class="fragment"><div class="line">     </div>
<div class="line">     <span class="comment">// Create new element</span></div>
<div class="line">     ImposeDisplacementByLagrangeMultiplierElement&lt;FLUID_ELEMENT&gt;* el_pt =</div>
<div class="line">      <span class="keyword">new</span>  ImposeDisplacementByLagrangeMultiplierElement&lt;FLUID_ELEMENT&gt;(</div>
<div class="line">       bulk_elem_pt,face_index, </div>
<div class="line">       Global_Parameters::FSI_interface_displacement_lagrange_multiplier_id);   </div>
</div><!-- fragment --><p>The rest of the function is unchanged:</p>
<div class="fragment"><div class="line">     </div>
<div class="line">     <span class="comment">// Add it to the mesh</span></div>
<div class="line">     Lagrange_multiplier_mesh_pt[i]-&gt;add_element_pt(el_pt);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Set the GeomObject that defines the boundary shape and set</span></div>
<div class="line">     <span class="comment">// which bulk boundary we are attached to (needed to extract</span></div>
<div class="line">     <span class="comment">// the boundary coordinate from the bulk nodes)</span></div>
<div class="line">     el_pt-&gt;set_boundary_shape_geom_object_pt(Solid_fsi_boundary_pt[i],b);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of create_lagrange_multiplier_elements</span></div>
</div><!-- fragment --><p>An equivalent procedure is adopted in the function <code>create_parallel_flow_lagrange_elements()</code> which follows exactly the same steps as in the corresponding <a href="../../../navier_stokes/vmtk_fluid/html/index.html#parallel_flow">single-physics fluids problem</a>, apart from the fact that we pass the other enumerated ID to the constructor of the <code>ImposeParallelFlowElements</code>. We therefore omit the listing of the function and refer to <a href="../../../../demo_drivers/interaction/vmtk_fsi/vmtk_fsi.cc">the source code.</a></p>
<hr  />
 <hr  />
<h1><a class="anchor" id="comm_ex"></a>
Comments and Exercises</h1>
<h2><a class="anchor" id="realism"></a>
Making the simulation more "realistic"</h2>
<p>The simulation shown at the beginning of this tutorial is obviously very crude and suffers from (at least) the sum of the shortcomings that we identified in the tutorials for the constituent single-physics <a href="../../../navier_stokes/vmtk_fluid/html/index.html#realism">fluid</a> and <a href="../../../solid/vmtk_solid/html/index.html#finer">solid</a> problems. You should consider repeating the computation using finer meshes (consult <code>oomph-lib's</code> <a href="../../../meshes/mesh_from_vmtk/html/index.html">VMTK tutorial</a> for details) and explore the use of "flow extensions" which allow the (inevitably artificial) boundary conditions to be applied further from the region of interest. Adding time-dependence to the problem, e.g. by subjecting the flow to a periodic fluctuation in the applied pressure drop would be another interesting exercise.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory: <center> <a href="../../../../demo_drivers/interaction/vmtk_fsi/">demo_drivers/interaction/vmtk_fsi/ </a> </center></li>
<li>The driver code is: <center> <a href="../../../../demo_drivers/interaction/vmtk_fsi/vmtk_fsi.cc">demo_drivers/interaction/vmtk_fsi/vmtk_fsi.cc </a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Fri Aug 27 2021 17:43:45
        </div>
      </div>
    </footer>
</body>
</html>
