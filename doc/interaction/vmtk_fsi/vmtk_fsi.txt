\mainpage Demo problem: Steady finite-Reynolds-number flow through an elastic iliac bifurcation   
This tutorial demonstrates how to simulate physiological
fluid-structure interaction problems, based on the medical imaging
data, processed with the <a href="http://www.vmtk.org/Main/HomePage">Vascular 
Modeling Toolkit.</a> 

 We combine two single-physics problems, namely
- <a href="../../../solid/vmtk_solid/html/index.html">
  The inflation of a blood vessel</a>
  \n\n
- <a href="../../../navier_stokes/vmtk_fluid/html/index.html">
  Finite-Reynolds number flow through a rigid iliac bifurcation</a>
.
to study the steady flow through an elastic iliac bifurcation.
(Please refer to \c oomph-lib's 
<a href="../../../meshes/mesh_from_vmtk/html/index.html">VMTK
tutorial</a> to find out how to generate \c oomph-lib meshes
from medical images.)

The tutorial also provides a detailed discussion of the mechanism by which
\c FaceElements introduce additional unknowns into a problem. 
This is important in the problem considered here because we
employ two different types of \c FaceElements, both of which
introduce additional unknowns. When dealing with nodes that
are attached to both types of \c FaceElements we must therefore be able 
to determine which nodal values are associated with which \c FaceElement.
Section \ref face below shows how this is done.


<CENTER>
<TABLE BORDER=1, WIDTH=500px>
<TR>
<TD bgcolor="cornsilk">
\n\n
<CENTER>
<B>Ackowledgement:</B>
</CENTER>
\n\n
This tutorial and the associated driver codes were developed jointly
with Amine Massit (ENSTA, Paris).
\n\n
</TD>
</TR>
</TABLE>
</CENTER>


<hr>
<hr>
  

\section prob The problem (and some results)
The animations below show the deformation of an iliac bifurcation
that conveys viscous fluid and deforms in response to the traction 
that the fluid exerts onto it. As in the previous examples
where we considered the constituent single-physics 
<a href="../../../navier_stokes/vmtk_fluid/html/index.html">
fluid</a> and <a href="../../../solid/vmtk_solid/html/index.html">
solid</a> problems, the meshes are obviously very coarse and the
boundary conditions are far from "physiologically realistic":
We keep the upstream and downstream "ends" of the vessel
wall in a fixed position and drive the (steady!) flow by applying
a constant pressure drop between the in- and outflow cross sections.
The different frames shown in the animation show results
for different wall stiffnesses, using the same setup as in
<a href="../../unstructured_three_d_fsi/html/index.html">another
tutorial.</a> 

We stress that the computations presented here serve as
quick-to-compute proof of concept and refer to the section 
\ref comm_ex  at the end of this tutorial for a discussion 
on how to make the simulation more "realistic". 

@I w 0.75\textwidth elastic_iliac_solid "The flow-induced deformation of an iliac bifurcation. The animation shows the effect of variations in the wall stiffness. The arrows show the magnitude of the fluid traction on the wall. "

@I w 0.75\textwidth elastic_iliac_fluid "Steady finite-Reynolds number flow through an elastic iliac bifucation (velocity vectors and pressure contours). The animation shows the effect of variations in the wall stiffness. "


The driver code used for this computation is very similar to the one
discussed in <a href="../../unstructured_three_d_fsi/html/index.html">another
tutorial</a> where we used a much simpler geometry in which the
three branches of the bifurcation had rectangular cross-sections. 
Before discussing the changes to the driver code in section
\ref driver_code below, we provide a more detailed discussion
of the way in which \c FaceElements introduce additional unknowns into 
a problem. Feel free to skip the next section if you're not keen on theory.

 

<HR>
<HR>

\section face How FaceElements introduce additional unknowns into a problem

\c FaceElements are used widely throughout \c oomph-lib to apply 
Neumann/flux-type boundary conditions on the faces of
higher-dimensional "bulk" elements. Examples include:
- <a href="../../../poisson/two_d_poisson_flux_bc2/html/index.html">
  the application of a flux bounday condition in a Poisson problem;</a> 
  \n\n
- the application of traction boundary conditions in 
  <a href="../../../navier_stokes/rayleigh_traction_channel/html/index.html">
  fluid</a> and 
  <a href="../../../solid/airy_cantilever/html/index.html">solid</a>
  mechanics problems;
  \n\n
- <a href="../../../young_laplace/contact_angle/html/index.html">the
  application of a contact-angle boundary condition for the
  Young-Laplace equation.</a>
.
In all the examples listed above, the boundary conditions simply
add a contribution to the elements' residuals but they do not
introduce any additional unknowns into the problem.

\c FaceElements may also be used to apply boundary conditions
via Lagrange multipliers. An example is given in the tutorial
that discusses
- <a href="../../../solid/prescribed_displ_lagr_mult/html/index.html">
   the application of displacement boundary conditions for solid
   mechanics problems</a>
.
In such problems, the Lagrange multipliers must be determined
as part of the solution, and storage for associated discrete
unknowns is created at the nodes of the \c FaceElements.

 To explain the relevant details of the implementation we consider a 
simple 2D Navier-Stokes problem discretised using nine-node Taylor-Hood
elements (each vertex node stores two discrete velocities and
one pressure; the other nodes store only two velocity degrees of
freedom). We assume that boundaries 0 and 1 are subject to 
boundary conditions imposed via \c FaceElements, and that
each boundary condition introduces its own Lagrange multipliers field<b>s</b>. 
[Yes, the plural is correct. As an example, consider the case of 
imposing displacement constraints in a 2D solid mechanics problem via 
Lagrange multipliers. In this approach 
the imposition of the boundary condition requires \e two Lagrange 
multipliers along each constrained boundary. Physically, the Lagrange
multipliers represent the two components of the surface traction required to 
deform the boundary into the required shape; see 
<a href="../../../solid/prescribed_displ_lagr_mult/html/index.html">
the relevant solid mechanics problem</a> for details.]

The sketch below shows the discretisation of the domain, with the black 
circles representing the nodes. The enlargement of the top right
corner also shows the discrete unknowns (nodal velocities and
pressures) stored at each node after the creation of the 
"bulk" Navier-Stokes elements.



@I w 0.75\textwidth multiple_face_elements1 "Sketch of a problem that is subject to flux-type boundary conditions along boundaries 0 and 1. The sketch illustrates the degrees of freedom at each node before any FaceElements are attached.  "


The next figure shows the nodal degrees of freedom after the \c
FaceElements on boundary 0 (shown in red) have been attached. The
\c FaceElements share the existing nodes of the underlying
"bulk" elements and automatically create storage for any additional
nodal unknowns. Here we provide storage for two discrete Lagrange multipliers, 
\f$ \Lambda_x \f$ and \f$ \Lambda_y. \f$ Provided that a single
\c FaceElement is attached to a node, the function
\code
unsigned FaceElement::nbulk_value(const unsigned& j)
\endcode
can be used to determine the number of nodal values at the \c
FaceElement's \c j -th node created by the underlying 
"bulk" element \e before the \c FaceElement was attached. 
It is then easy to identify the additional nodal values associated 
with the \c FaceElement in order to apply the boundary conditions.
The methodology is illustrated in the application of boundary 
conditions for the Lagrange multipliers in the 
<a href="../../../solid/prescribed_displ_lagr_mult/html/index.html#bcs_for_lagrange_multipliers">
the solid mechanics problem referred to earlier.</a>
 



@I w 0.75\textwidth multiple_face_elements2 "Sketch illustrating the degrees of freedom at each node after FaceElements have been attached to boundary 0.  "



The next figure shows the degrees of freedom after the \c
FaceElements on boundary 1 (shown in green) have also been attached.
These \c FaceElements must create storage for their own
two Lagrange multipliers, \f$ \lambda_x \f$ and 
\f$ \lambda_y \f$. Thus, the corner node (attached
to both types of \c FaceElements) has four additional degrees of
freedom after all the \c FaceElements have been created.



@I w 0.75\textwidth multiple_face_elements3 "Sketch illustrating the degrees of freedom at each node after all FaceElements have been attached.  "

 
The identification of the additional degrees of freedom via a simple
offset from the degrees of freedom created by the "bulk" element
is now longer possible. We therefore provide an alternative
mechanism to access the relevant information from the nodes
themselves via the function
\code
unsigned BoundaryNodeBase::index_of_first_value_assigned_by_face_element()
\endcode
which does exactly what it says. If only a single type of \c
FaceElement is attached to a (boundary) node, the unsigned that is returned
by this function is exactly the same as the unsigned that is returned
by the corresponding call to \c FaceElement::nbulk_value(...). 
To cater for the case where multiple \c FaceElements are 
attached to the same node, the above function can take an ID
(which defaults to zero) that identifies which type of
\c FaceElement we are dealing with, so the full interface is, in fact,
\code
unsigned BoundaryNodeBase::index_of_first_value_assigned_by_face_element(const unsigned& id=0)
\endcode
The ID must be passed to the constructor of the specific 
\c FaceElement. It can then be passed on to the \c Nodes
when the number of values at the nodes is 
adjusted to accomodate the additional values required by the
\c FaceElement. 


To illustrate this, the code extract shown below provides a 
(partial) listing of the constructor of 
the \c ImposeDisplacementByLagrangeMultiplierElement
that was used in 
<a href="../../../solid/prescribed_displ_lagr_mult/html/index.html">
the solid mechanics problem referred to earlier</a>. The constructor
has the usual two arguments that specify the pointer to the "bulk"
element, and the index of the face that the \c FaceElement is to 
be attached to. The final (optional) argument allows the specification
of the ID referred to above. We store the ID in a private 
the element's private member data.
 
\dontinclude solid_traction_elements.h
\skipline Constructor takes a "bulk"
\until FaceElement()
\skipline {
\until Id=


[We omit a few lines of code that are irrelevant for the
present discussion]. Next we specify the number of additional
values required at each of the element's nodes and store them
in a vector. For a \c dim -dimensional bulk element, we need \c dim 
additional values at each node to store the Lagrange multipliers. 

\skipline Dimension of the bulk
\until n_additional_values

Finally, we pass this vector, together with ID that identifies the
type of the \c FaceElement to the function
\c  FaceElement::add_additional_values(...):

\until }

This function creates the additional storage at each node and
updates the node's internal lookup scheme that provides access to the
first value associated with the specified ID.


The fact that the ID is specified as an optional argument means that
the user does not have to provide a dummy ID in cases where
none is required, i.e. in problems involving just a single type 
of \c FaceElement, as in
<a href="../../../solid/prescribed_displ_lagr_mult/html/index.html">
the solid mechanics problem referred to earlier.</a>
If a problem does involve multiple \c FaceElements, the 
user will be aware of this when writing the driver code and
can then provide distinct IDs as and when required, see the 
section \ref constructor below.



<HR>
<HR>

\section driver_code The driver code

 The driver code is almost identical to that in the tutorial describing 
<a href="../../unstructured_three_d_fsi/html/index.html">
three-dimensional fluid-structure-interaction on an unstructured
mesh.</a>  In fact, the only differences relate to the facts that:
- although topologically identical, the boundary numbering assigned by
\c Tetgen is not the same for the two bifurcation geometries;
- we are imposing a parallel-outflow condition rather than prescribing 
  a traction at the two outflow boundaries.
.

The \c SolidTetMesh and \c FluidTetMesh classes and 
\c main() function are completely unchanged from the
<a href="../../unstructured_three_d_fsi/html/index.html">
previous tutorial.</a> 
As usual, global parameters are specified in a namespace, which now
includes an \c enum to label the ID's of the two different
\c FaceElements that share a common (line) boundary.
\dontinclude vmtk_fsi.cc
\skipline Global_Parameters
\until end_of_namespace

\section class The Problem class

Once again, we shall
discuss only the differences from the Problem class in the 
<a href="../../unstructured_three_d_fsi/html/index.html">
previous tutorial.</a> 

\section constructor The Problem constructor

The general structure of the problem constructor remains
unchanged. There are trivial changes in the import of fluid and solid
meshes to reflect the fact that the boundary numbering is different
between the two bifurcation geometries. The only significant changes
are in the imposition of boundary conditions on the fluid mesh in
which the transverse velocities are <b> not </b> pinned on the
outflow. In addition, the second set of Lagrange multipliers 
associated with the
parallel-outflow condition should be pinned on the boundary between the
outlets and the arterial wall. As described above,
we use the IDs assigned to the \c
FaceElements on their construction, see \ref face_elements_code,  
to determine the value indices of
the Lagrange multipliers corresponding to each different \c FaceElement.
\dontinclude vmtk_fsi.cc
\skipline Doc bcs for Lagrange
\until pinned_file.close()

 

\section face_elements_code Creating the FaceElements

The use of two different types of \c FaceElement each of which assigns
additional storage means that we must use IDs to distinguish the
two. The IDs are given names in a \c Global_Parameters::enum and must
be passed to the \c FaceElements when the are constructed. 

The \c create_lagrange_multiplier_elements() function 
is slightly modified so that the
appropriate ID is passed to the 
\c ImposeDisplacementByLagrangeMultiplierElement on construction.
\dontinclude vmtk_fsi.cc
\skipline ImposeDisplacement
\until )
In addition, the \c create_parallel_outflow_lagrange_element()
function replaces the equivalent function
\c create_fluid_traction_elements() and creates the 
\c ImposeParallelOutflowElements passing the appropriate ID to the
constructor and passing the desired pressures to the newly created 
elements.
\dontinclude vmtk_fsi.cc
\skipline corresponding lagrange element
\until end of element setup


<HR>
<HR>

\section comm_ex Comments and Exercises

\subsection realism Making the simulation more "realistic"
The simulation shown at the beginning of this tutorial is 
obviously very crude and suffers from (at least) the sum of the 
shortcomings that we identified in the tutorials for the constituent 
single-physics 
<a href="../../../navier_stokes/vmtk_fluid/html/index.html#realism">fluid</a>
and <a href="../../../solid/vmtk_solid/html/index.html#finer"> solid</a>
problems. You should consider repeating the computation using finer
meshes (consult \c oomph-lib's 
<a href="../../../meshes/mesh_from_vmtk/html/index.html">VMTK
tutorial</a> for details) and explore the use of "flow extensions" 
which allow the (inevitably artificial) boundary conditions to be applied 
further from the region of interest. Adding time-dependence to the
problem, e.g. by subjecting the flow to a periodic fluctuation
in the applied pressure drop would be another interesting
exercise.

 
<HR>
<HR>

\section sources Source files for this tutorial
- The source files for this tutorial are located in the directory:\n\n
<CENTER>
<A HREF="../../../../demo_drivers/interaction/vmtk_fsi/">
demo_drivers/interaction/vmtk_fsi/
</A>
</CENTER>\n
- The driver code is: \n\n
<CENTER>
<A HREF="../../../../demo_drivers/interaction/vmtk_fsi/vmtk_fsi.cc">
demo_drivers/interaction/vmtk_fsi/vmtk_fsi.cc
</A>
</CENTER>
.
