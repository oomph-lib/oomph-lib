<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Flow in a 2D collapsible channel revisited &ndash; enabling adaptivity in FSI problems</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Flow in a 2D collapsible channel revisited &ndash; enabling adaptivity in FSI problems </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this document we re-visit the collapsible channel problem yet again &ndash; this time to demonstrate the use of spatial adaptivity in fluid-structure interaction problems. In such problems, two additional issues have to be addressed:</p><ol type="1">
<li><a class="el" href="index.html#history">The assignment of positional history values for newly-created nodes</a></li>
<li><a class="el" href="index.html#update_node_update">Updating the node-update data in refineable AlgebraicMeshes</a></li>
</ol>
<p>We start with a brief reminder of <code>oomph-lib's</code> mesh adaptation procedures to highlight what additional complications arise in fluid-structure interaction problems, and then explain how these problems are addressed.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="history"></a>
The assignment of positional history values for newly-created nodes</h1>
<h2><a class="anchor" id="what"></a>
What is the problem?</h2>
<p>We first discussed the use of spatial adaptivity for time-dependent problems in the context of <a href="../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html#spatial_adapt">the unsteady heat equation</a>. We showed that whenever a new node is created, <code>oomph-lib's</code> mesh adaptation procedures automatically assign the nodal values and "history values" (the auxiliary values that are used by the <code>Node's</code> <code>TimeStepper</code> to approximate time-derivatives of the nodal values) for the newly-created <code>Node</code> by interpolating between the corresponding values in the new <code>Node's</code> father element.</p>
<p>Similarly, an initial assignment for the newly-created <code>Node's</code> current and previous positions (required for the evaluation of the mesh-velocities in the ALE formulation of the time-derivatives) is made by interpolating between the current and previous nodal positions of the new <code>Node's</code> father element. This default assignment is subsequently overwritten if the father element is associated with a <code>MacroElement</code>, in which case the newly-created <code>Node's</code> current position is determined by the father element's <code>MacroElement</code> representation. This ensures that the mesh refinement process respects curvilinear domain boundaries, as discussed <br  />
 <a href="../../../poisson/fish_poisson2/html/index.html">elsewhere.</a> The same strategy is used to over-write the default assignment for a new <code>Node's</code> previous positions: They are re-assigned, based on the father element's <code>MacroElement</code> - representation, evaluated at the relevant previous timesteps.</p>
<p>To illustrate the process, consider the sketch below and assume that the time-integration of the Navier-Stokes equations is performed with a <code>BDF&lt;2&gt;</code> timestepper &ndash; a timestepper that requires two history values (the solution and the nodal positions at two previous timesteps) to evaluate the time-derivative <img class="formulaInl" alt="$ \partial u_i/\partial t $" src="form_0.png" width="36" height="14"/> in the momentum equations. The position of the nodes in the collapsible part of the channel is determined by the <code>MacroElement</code> - based representation of the <code>CollapsibleChannelDomain</code>, using the wall shape obtained from the compound <code>MeshAsGeomObject</code> that we created from the discretisation of the elastic wall, shown in green.</p>
<p>Assume that the initial mesh is sufficiently fine to resolve the solution at <img class="formulaInl" alt="$ t=t_0 $" src="form_1.png" width="31" height="11"/> and <img class="formulaInl" alt="$ t=t_0 + \Delta t $" src="form_2.png" width="63" height="13"/>. At <img class="formulaInl" alt="$ t=t_0 + 2 \Delta t $" src="form_3.png" width="69" height="13"/>, the automatic mesh adaptation splits one of the fluid elements, creating the five new <code>Nodes</code>, shown in red (for simplicity we only show the fluid elements' vertex nodes). Their position is determined by the father element's <code>MacroElement</code> mapping, using the current position of the <code>MeshAsGeomObject</code>, obtained from the interpolation between the nodal positions of its <code>SolidNodes</code> (shown as green circles).</p>
<div class="image">
<img src="history_values.gif" alt=""/>
<div class="caption">
Sketch illustrating the assignment of positional history values for newly-created nodes in FSI problems. The positional history values of the newly-created Nodes (shown in red) are given by the positions they would have had if they had already existed at previous timesteps. </div></div>
 <p>So far, so good! A subtle problem arises when we try to assign the positional history values for the newly-created <code>Nodes</code>. The evaluation of the <code>MacroElement</code> mapping at the previous timesteps (required to determine the positions the newly-created <code>Nodes</code> would have had, if they had already existed at previous timesteps) requires access to the previous wall shapes. In <a href="../../../navier_stokes/collapsible_channel/html/index.html">the non-FSI problem discussed earlier</a>, the wall shape was given analytically and could therefore be evaluated at arbitrary times. In the FSI problem considered here, the previous wall shape is not available as the previous positions of the <code>SolidNodes</code> are not required (and are therefore not stored) for the solution of the (steady!) wall equations.</p>
<hr  />
<h2><a class="anchor" id="soln"></a>
The solution: The Steady&lt;NSTEPS&gt; timestepper</h2>
<p>The solution to the problem is simple: Recall that the final entry in the argument list of <code>oomph-lib's</code> mesh constructors specifies the <code>TimeStepper</code> to be used for the evaluation of any time-derivatives. The <code>TimeStepper's</code> member function <code>TimeStepper::ntstorage()</code> specifies the total number of values (the current value plus the number of history values) required to evaluate the time-derivatives; it is used by the <code>FiniteElement::construct_node(...)</code> function to create the required amount of storage at the elements' <code>Nodes</code> when the <code>Nodes</code> are created in the mesh constructor. To maximise the potential for code-reuse, we always provide a default argument for the pointer to the <code>TimeStepper</code> &ndash; a pointer to a static instantiation of <code>oomph-lib's</code> dummy <code>TimeStepper</code>, <code>Steady&lt;0&gt;</code>. This ensures that the "user" can use the mesh for steady problems without having to artificially create a dummy <code>TimeStepper</code> that would be completely irrelevant for his/her problem.</p>
<p>For instance, the full interface to the constructor of the <code>OneDLagrangianMesh</code>, defined in <a href="../../../../src/meshes/one_d_lagrangian_mesh.template.h">one_d_lagrangian_mesh.template.h</a> is given by</p>
 <div class="fragment"><div class="line">    <span class="comment">/// Constructor: Pass number of elements, length,</span></div>
<div class="line"><span class="comment">    /// pointer to GeomObject that defines the undeformed Eulerian position,</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// and the timestepper -- defaults to (Steady) default timestepper defined</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// in the Mesh base class</span></div>
<div class="line"><span class="comment"></span>    OneDLagrangianMesh(</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; n_element,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; length,</div>
<div class="line">      GeomObject* undef_eulerian_posn_pt,</div>
<div class="line">      TimeStepper* time_stepper_pt = &amp;Mesh::Default_TimeStepper);</div>
</div><!-- fragment --><p> Thus, when we constructed the wall mesh in the non-adaptive version of the driver code <a href="../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc">fsi_collapsible_channel.cc,</a> using the statements</p>
<div class="fragment"><div class="line"><span class="comment">//Create the &quot;wall&quot; mesh with FSI Hermite beam elements</span></div>
<div class="line">Wall_mesh_pt = <span class="keyword">new</span> OneDLagrangianMesh&lt;FSIHermiteBeamElement&gt;</div>
<div class="line"> (Ncollapsible,Lcollapsible,undeformed_wall_pt);</div>
</div><!-- fragment --><p>the use of the dummy <code>TimeStepper</code>, <code>Steady&lt;0&gt;</code> was implied. All time-derivatives computed by this <code>TimeStepper</code> evaluate to zero, and the <code>TimeStepper</code> does not require (or request) any storage for history values. This is a sensible default for problems that are either inherently steady (such as problems involving the Poisson equations, say) or for steady versions of time-dependent PDEs (such as the steady Navier-Stokes equations). In the present problem, we wish to retain the dummy character of the <code>TimeStepper</code> so that all time-derivatives in the <code>FSIHermiteBeamElements</code> are set to zero, while retaining a limited history of the <code>SolidNode's</code> previous positions so that the wall shape at previous timesteps can be evaluated. This is possible by creating a <code>Steady</code> timestepper with a non-zero template argument: The class</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> NSTEPS&gt;</div>
<div class="line"><span class="keyword">class </span>Steady : <span class="keyword">public</span> TimeStepper</div>
</div><!-- fragment --><p>provides a dummy <code>TimeStepper</code> that requires (and maintains) <code>NSTEPS</code> history values that represent the nodal positions (or nodal values) at <code>NSTEPS</code> previous timesteps. However, these history values are not used to evaluate any time-derivatives &ndash; all time-derivatives computed by this <code>TimeStepper</code> are zero.</p>
<p>If the Navier-Stokes equations are discretised with a <code>BDF&lt;2&gt;</code> timestepper, the evaluation of the mesh velocity in the ALE representation of the time-derivatives <img class="formulaInl" alt="$ \partial u_i/\partial t $" src="form_0.png" width="36" height="14"/> requires the nodal position at the two previous timesteps. This is achieved by passing a pointer to a specifically-constructed <code>Steady&lt;2&gt;</code> timestepper to the wall mesh. Here is the relevant code fragment from the Problem constructor in the driver code <a href="../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel_adapt.cc">fsi_collapsible_channel_adapt.cc</a>:</p>
 <div class="fragment"><div class="line"> <span class="comment">// Allocate the timestepper for the Navier-Stokes equations</span></div>
<div class="line"> BDF&lt;2&gt;* fluid_time_stepper_pt=<span class="keyword">new</span> BDF&lt;2&gt;;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Add the fluid timestepper to the Problem&#39;s collection of timesteppers.</span></div>
<div class="line"> add_time_stepper_pt(fluid_time_stepper_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create a dummy Steady timestepper that stores two history values</span></div>
<div class="line"> Steady&lt;2&gt;* wall_time_stepper_pt = <span class="keyword">new</span> Steady&lt;2&gt;;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Add the wall timestepper to the Problem&#39;s collection of timesteppers.</span></div>
<div class="line"> add_time_stepper_pt(wall_time_stepper_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Geometric object that represents the undeformed wall: </span></div>
<div class="line"> <span class="comment">// A straight line at height y=ly; starting at x=lup.</span></div>
<div class="line"> <a class="code" href="classUndeformedWall.html">UndeformedWall</a>* undeformed_wall_pt=<span class="keyword">new</span> <a class="code" href="classUndeformedWall.html">UndeformedWall</a>(lup,ly);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Create the &quot;wall&quot; mesh with FSI Hermite beam elements, passing the</span></div>
<div class="line"> <span class="comment">//dummy wall timestepper to the constructor</span></div>
<div class="line"> Wall_mesh_pt = <span class="keyword">new</span> OneDLagrangianMesh&lt;FSIHermiteBeamElement&gt;</div>
<div class="line">  (Ncollapsible,Lcollapsible,undeformed_wall_pt,wall_time_stepper_pt);</div>
<div class="ttc" id="aclassUndeformedWall_html"><div class="ttname"><a href="classUndeformedWall.html">UndeformedWall</a></div><div class="ttdoc">/////////////////////////////////////////////////////////////////////// /////////////////////////////...</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00096">fsi_collapsible_channel.cc:97</a></div></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="update_node_update"></a>
Updating the node-update data in refineable AlgebraicMeshes</h1>
<p>When discussing <a href="../../../navier_stokes/algebraic_collapsible_channel/html/index.html">the non-FSI version of the collapsible channel problem</a> we explained how <code>oomph-lib's</code> mesh adaptation procedures assign the node-update data for newly-created <code>AlgebraicNodes</code>. Recall that the node-update data comprises:</p><ul>
<li>A pointer to the <code>AlgebraicMesh</code> that implements the node-update function. <br  />
<br  />
</li>
<li>An ID for the node-update function. This is used in cases in which different regions of the <code>AlgebraicMesh</code> are updated by different node-update functions. The ID has a default value of 0; this is used if there is only a single node-update function, as in the <code>AlgebraicCollapsibleChannelMesh</code>. <br  />
<br  />
</li>
<li>A vector of (pointers to) <code>GeomObjects</code> that are involved in the node update. <br  />
<br  />
</li>
<li>A vector of reference values, such as the intrinsic coordinates of reference points on the <code>GeomObjects</code>. <br  />
<br  />
</li>
</ul>
<p>By default, we assume that a newly-created <code>AlgebraicNode</code> is updated by the same node-update function as the <code>AlgebraicNodes</code> in its father element. Therefore we pass the pointer to the <code>AlgebraicMesh</code>, the node-update function ID, and the vector of pointers to <code>GeomObjects</code> to the newly-created <code>AlgebraicNodes</code>, and interpolate the reference values between those stored at the <code>AlgebraicNodes</code> in the father elements.</p>
<p>In most cases this provides a sensible default. For instance, it is hard to imagine a situation in which it would be sensible to update the position of newly-created <code>AlgebraicNodes</code> by a procedure that differs from that used for the surrounding <code>AlgebraicNodes</code> that already existed in the father element. Similarly, since the reference values vary from node to node (if they were constant we would not store them in the <code>AlgebraicNodes'</code> node-update data but in the <code>AlgebraicMesh</code> that implements the node update!) it makes sense to assign the values at newly-created <code>AlgebraicNodes</code> by interpolation. For instance, in the <code>AlgebraicCollapsibleChannelMesh</code> one of the reference values is the <img class="formulaInl" alt="$ x_1 $" src="form_4.png" width="13" height="9"/> - coordinate of the reference point on the fixed lower wall. For the <code>AlgebraicNodes</code> that already existed in the coarse base mesh, this value is given by the the <code>AlgebraicNodes'</code> <img class="formulaInl" alt="$ x_1 $" src="form_4.png" width="13" height="9"/> - coordinate in the undeformed mesh. Interpolation of this value for the newly-created <code>AlgebraicNodes</code> results in an axially uniform subdivision of the refined elements.</p>
<p>The same procedure may be used to assign the reference value that represents the intrinsic coordinate of the reference point on the upper wall &ndash; at least as long as the upper wall is only ever addressed as a compound <code>GeomObject</code>, as in our original (slow!) code that employed a <code>MacroElement</code> - based node update. The procedure is illustrated in the sketch below: The upper wall is parametrised by a compound <code>GeomObject</code> in which the beam's Lagrangian coordinate <img class="formulaInl" alt="$ \xi $" src="form_5.png" width="8" height="13"/> doubles as the <code>GeomObject's</code> intrinsic coordinate <img class="formulaInl" alt="$ \zeta. $" src="form_6.png" width="9" height="13"/> The green arrows indicate the reference points for nodes I, II, III, IV and V in the coarse initial mesh. The reference values <img class="formulaInl" alt="$ \zeta_{I}^{[ref]}, ... , \zeta_{V}^{[ref]} $" src="form_7.png" width="76" height="19"/> are stored in the node-update data of nodes I,...,V, respectively. The red arrow identifies the reference point for the newly-created node VI whose reference coordinate <img class="formulaInl" alt="$ \zeta_{IV}^{[ref]} $" src="form_8.png" width="26" height="19"/> is created by interpolation between the reference values of nodes II, III, IV and V, i.e. the nodes in its father element.</p>
<div class="image">
<img src="update_single.gif" alt=""/>
<div class="caption">
Illustration of the default update procedure for the node-update data: The reference value for newly created node VI is created by interpolation from the reference values for nodes II, III, IV and V in its father element. </div></div>
 <p>Unfortunately, the default assignment is not appropriate for nodes that are updated by the (much faster) algebraic node update procedure implemented in the <code>AlgebraicCollapsibleChannelMesh</code>. Its <code>AlgebraicNodes</code> store pointers to the sub-<code>GeomObjects</code> (i.e. the <code>FSIHermiteBeamElements</code> in the wall mesh) that contain their reference points, and the values of the local coordinate at which the reference points are located. This is illustrated in the sketch below in which the sub- <code>GeomObjects</code>, parametrised by their local coordinates <img class="formulaInl" alt="$ s = \zeta, $" src="form_9.png" width="31" height="13"/> are shown in magenta. Note that the reference points for nodes II and IV are located in one sub- <code>GeomObject</code>, those for nodes III and V are located in another.</p>
<div class="image">
<img src="update_compound.gif" alt=""/>
<div class="caption">
Illustration of the revised update procedure for the node-update data: The intrinsic coordinate within the compound GeomObject can be created by interpolation. The coordinate within the sub-GeomObject has to be determined via the GeomObject::locate_zeta(...) function. </div></div>
 <p>It obviously does not make sense to create the reference value for the newly-created node VI by interpolation. The node update data must be created from scratch in two steps:</p><ol type="1">
<li>Determine the newly-created Node's intrinsic reference coordinate within the compound <code>MeshAsGeomObject</code> (i.e. the continuous beam's Lagrangian coordinate), <img class="formulaInl" alt="$ \xi_{VI}^{[ref]}$" src="form_10.png" width="28" height="19"/> by interpolation. (<a href="../../fsi_collapsible_channel_algebraic/html/index.html">Recall </a> that the <code>AlgebraicNodes</code> in the non-refineable <code>AlgebraicCollapsibleChannelMesh</code> already stored this coordinate, even though it was not used during the node-update itself). <br  />
<br  />
</li>
<li>Use the <code>GeomObject::locate_zeta(...)</code> function to determine sub-<code>GeomObject</code> and the local coordinate within it, at which the reference point with Lagrangian coordinate <img class="formulaInl" alt="$ \xi_{VI}^{[ref]}$" src="form_10.png" width="28" height="19"/> is located.</li>
</ol>
<p>To ensure that this procedure is performed automatically after every mesh adaptation, it should be implemented in the function <code>AlgebraicMesh::update_node_update(...)</code>. This function is defined as a pure virtual function in the <code>AlgebraicMesh</code> base class in order to force the mesh writer to assess if the default procedure for the assignment of the node-update data for newly-created <code>AlgebraicNodes</code>, described above, is appropriate. If it is, the function may, of course, be implemented as an empty function. We note that the function <code>AlgebraicMesh::update_node_update(...)</code> is called <b>after</b> the default values for the node-update data have been assigned. It is therefore only necessary to correct those values for which the default procedure is inappropriate.</p>
<p>To illustrate the procedure, here is the class definition for the <code>RefineableAlgebraicCollapsibleChannelMesh</code>. The mesh is derived by multiple inheritance from the non-refineable <code>AlgebraicCollapsibleChannelMesh</code> and the <code>RefineableQuadMesh</code> base class. The constructor calls the constructors of both underlying meshes and then sets up the <code>QuadTreeForest:</code> </p>
 <div class="fragment"><div class="line">  <span class="comment">//=====start_of_refineable_algebraic_collapsible_channel_mesh=====</span></div>
<div class="line"><span class="comment">  /// Refineable version of the CollapsibleChannel mesh with</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// algebraic node update.</span></div>
<div class="line"><span class="comment"></span>  <span class="comment">//=================================================================</span></div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line">  <span class="keyword">class </span>RefineableAlgebraicCollapsibleChannelMesh</div>
<div class="line">    : <span class="keyword">public</span> RefineableQuadMesh&lt;ELEMENT&gt;,</div>
<div class="line">      <span class="keyword">public</span> <span class="keyword">virtual</span> AlgebraicCollapsibleChannelMesh&lt;ELEMENT&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">    /// Constructor: Pass number of elements in upstream/collapsible/</span></div>
<div class="line"><span class="comment">    /// downstream segment and across the channel; lengths of upstream/</span></div>
<div class="line"><span class="comment">    /// collapsible/downstream segments and width of channel, pointer to</span></div>
<div class="line"><span class="comment">    /// GeomObject that defines the collapsible segment and pointer to</span></div>
<div class="line"><span class="comment">    /// TimeStepper (defaults to the default timestepper, Steady).</span></div>
<div class="line"><span class="comment"></span>    RefineableAlgebraicCollapsibleChannelMesh(</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; nup,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ncollapsible,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ndown,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ny,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; lup,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; lcollapsible,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ldown,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ly,</div>
<div class="line">      GeomObject* wall_pt,</div>
<div class="line">      TimeStepper* time_stepper_pt = &amp;Mesh::Default_TimeStepper)</div>
<div class="line">      : CollapsibleChannelMesh&lt;ELEMENT&gt;(nup,</div>
<div class="line">                                        ncollapsible,</div>
<div class="line">                                        ndown,</div>
<div class="line">                                        ny,</div>
<div class="line">                                        lup,</div>
<div class="line">                                        lcollapsible,</div>
<div class="line">                                        ldown,</div>
<div class="line">                                        ly,</div>
<div class="line">                                        wall_pt,</div>
<div class="line">                                        time_stepper_pt),</div>
<div class="line">        AlgebraicCollapsibleChannelMesh&lt;ELEMENT&gt;(nup,</div>
<div class="line">                                                 ncollapsible,</div>
<div class="line">                                                 ndown,</div>
<div class="line">                                                 ny,</div>
<div class="line">                                                 lup,</div>
<div class="line">                                                 lcollapsible,</div>
<div class="line">                                                 ldown,</div>
<div class="line">                                                 ly,</div>
<div class="line">                                                 wall_pt,</div>
<div class="line">                                                 time_stepper_pt)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Build quadtree forest</span></div>
<div class="line">      this-&gt;setup_quadtree_forest();</div>
<div class="line">    }</div>
</div><!-- fragment --><p> We overload the (empty) previous implementations of <code>AlgebraicMesh::update_node_update(...)</code> with our own function:</p>
<div class="fragment"><div class="line">    <span class="comment">/// Update the node update data for specified node following</span></div>
<div class="line"><span class="comment">    /// any mesh adapation</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> update_node_update(AlgebraicNode*&amp; node_pt);</div>
<div class="line">  };</div>
</div><!-- fragment --><p> Here is the actual implementation of this function. We start by extracting the reference values that were already assigned by the default procedure:</p>
 <div class="fragment"><div class="line">  <span class="comment">//========start_update_node_update=================================</span></div>
<div class="line"><span class="comment">  /// Update the geometric references that are used</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// to update node after mesh adaptation.</span></div>
<div class="line"><span class="comment"></span>  <span class="comment">//=================================================================</span></div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line">  <span class="keywordtype">void</span> RefineableAlgebraicCollapsibleChannelMesh&lt;ELEMENT&gt;::update_node_update(</div>
<div class="line">    AlgebraicNode*&amp; node_pt)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Extract reference values for node update by copy construction</span></div>
<div class="line">    Vector&lt;double&gt; ref_value(node_pt-&gt;vector_ref_value());</div>
</div><!-- fragment --><p> Recall from the discussion of the algebraic node-update strategy <a href="../../fsi_collapsible_channel_algebraic/html/index.html#mesh">for the non-refineable version of the problem</a> that reference values 0 and 1 store the <img class="formulaInl" alt="$ x_1 $" src="form_4.png" width="13" height="9"/> - coordinate along the fixed bottom wall, and the fractional height of the node in the cross-channel direction, respectively. These values are interpolated correctly and do not have to be corrected. The third reference value is the intrinsic coordinate of the reference point in its sub-<code>GeomObject</code>. This needs to be re-computed and we will assign the corrected value below. The fourth reference value is the intrinsic coordinate of the reference point within the compound <code>MeshAsGeomObject</code>. We store this in a temporary variable:</p>
<div class="fragment"><div class="line">    <span class="comment">// Fourth reference value: intrinsic coordinate on the (possibly</span></div>
<div class="line">    <span class="comment">// compound) wall.</span></div>
<div class="line">    <span class="keywordtype">double</span> zeta = ref_value[3];</div>
</div><!-- fragment --><p> Next, we extract vector of (pointers to the) <code>GeomObjects</code> involved in this node's node-update from the node.</p>
<div class="fragment"><div class="line">    <span class="comment">// Extract geometric objects for update by copy construction</span></div>
<div class="line">    Vector&lt;GeomObject*&gt; geom_object_pt(node_pt-&gt;vector_geom_object_pt());</div>
</div><!-- fragment --><p> Now we use the <code>GeomObject::locate_zeta(...)</code> function to obtain the pointer to the (sub-)<code>GeomObject</code> and the intrinsic coordinate within it, at which the reference point (identified by its intrinsic coordinate <code>zeta</code> in the compound <code>GeomObject</code>) is located:</p>
<div class="fragment"><div class="line">    <span class="comment">// Get pointer to geometric (sub-)object and Lagrangian coordinate</span></div>
<div class="line">    <span class="comment">// on that sub-object. For a wall that is represented by</span></div>
<div class="line">    <span class="comment">// a single geom object, this simply returns the input.</span></div>
<div class="line">    <span class="comment">// If the geom object consists of sub-objects (e.g.</span></div>
<div class="line">    <span class="comment">// if it is a finite element mesh representing a wall,</span></div>
<div class="line">    <span class="comment">// then we&#39;ll obtain the pointer to the finite element</span></div>
<div class="line">    <span class="comment">// (in its incarnation as a GeomObject) and the</span></div>
<div class="line">    <span class="comment">// local coordinate in that element.</span></div>
<div class="line">    Vector&lt;double&gt; s(1);</div>
<div class="line">    GeomObject* geom_obj_pt;</div>
<div class="line">    this-&gt;Wall_pt-&gt;locate_zeta(zeta_wall, geom_obj_pt, s);</div>
</div><!-- fragment --><p> We over-write the first (and, in fact, only) entry in the vector of <code>GeomObjects</code> that are involved in this node's node-update with the pointer to the (sub-)<code>GeomObject</code> just located:</p>
<div class="fragment"><div class="line">    <span class="comment">// Update the pointer to the (sub-)GeomObject within which the</span></div>
<div class="line">    <span class="comment">// reference point is located. (If the wall is simple GeomObject</span></div>
<div class="line">    <span class="comment">// this is the same as Wall_pt; if it&#39;s a compound GeomObject</span></div>
<div class="line">    <span class="comment">// this points to the sub-object)</span></div>
<div class="line">    geom_object_pt[0] = geom_obj_pt;</div>
</div><!-- fragment --><p> Similarly, we over-write the third reference value with the local coordinate of the reference point within its (sub-)<code>GeomObject</code>.</p>
<div class="fragment"><div class="line">    <span class="comment">// Update third reference value: Reference local coordinate</span></div>
<div class="line">    <span class="comment">// in wall element (local coordinate in FE if we&#39;re dealing</span></div>
<div class="line">    <span class="comment">// with a wall mesh)</span></div>
<div class="line">    ref_value[2] = s[0];</div>
</div><!-- fragment --><p> The incorrect entries in the two vectors <code>geom_object_pt</code> and <code>ref_value</code> have now been corrected. We can wipe the node's node-update data and re-assign it:</p>
<div class="fragment"><div class="line">    <span class="comment">// Kill the existing node update info</span></div>
<div class="line">    node_pt-&gt;kill_node_update_info();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Setup algebraic update for node: Pass update information</span></div>
<div class="line">    node_pt-&gt;add_node_update_info(<span class="keyword">this</span>, <span class="comment">// mesh</span></div>
<div class="line">                                  geom_object_pt, <span class="comment">// vector of geom objects</span></div>
<div class="line">                                  ref_value); <span class="comment">// vector of ref. values</span></div>
<div class="line">  }</div>
</div><!-- fragment --><p> That's it!</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="results"></a>
Results</h1>
<p>The figure below shows a snapshot of the flow field during the early stages of the oscillation. The computation was performed with refineable Crouzeix-Raviart elements, using the <code>RefineableAlgebraicCollapsibleChannelMesh</code>. Note how the automatic mesh adaptation has refined the mesh in the regions in which the Stokes layers create steep velocity gradients.</p>
<div class="image">
<img src="fsi_CR_algebraic_adapt.gif" alt=""/>
<div class="caption">
Snapshot from the animation of the flow field. </div></div>
 <hr  />
 <hr  />
<h1><a class="anchor" id="driver"></a>
The driver code</h1>
<p>The driver code <a href="../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel_adapt.cc">fsi_collapsible_channel_adapt.cc</a> for the spatially adaptive problem is a trivial extension of the non-adaptive code <a href="../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc">fsi_collapsible_channel.cc,</a> therefore we will not provide a detailed listing here. Comparing the two source codes (e.g. with <code>sdiff</code>) shows that spatial adaptivity may be enabled with a few straightforward changes:</p><ul>
<li>Change the fluid mesh from the <code>MacroElementNodeUpdateCollapsibleChannelMesh</code> to the <code>MacroElementNodeUpdateRefineableCollapsibleChannelMesh</code> (or from the <code>AlgebraicCollapsibleChannelMesh</code> to the <code>RefineableAlgebraicCollapsibleChannelMesh</code>). <br  />
<br  />
</li>
<li>Change the element type from <code>TaylorHoodElement&lt;2&gt;</code> to <code>RefineableQTaylorHoodElement&lt;2&gt;</code> (or <code>QCrouzeixRaviartElement&lt;2&gt;</code> to <code>RefineableQCrouzeixRaviartElement&lt;2&gt;</code>). <br  />
<br  />
</li>
<li>Add the functions <code>Problem::actions_before_adapt()</code> and <code>Problem::actions_after_adapt()</code>; see below. <br  />
<br  />
</li>
<li>Explicitly specify the <code>Steady&lt;2&gt;</code> timestepper for the wall mesh, as discussed above. <br  />
<br  />
</li>
<li>Create an error estimator, specify the target errors for the adaptation, and call the spatially adaptive Newton solver.</li>
</ul>
<hr  />
<h2><a class="anchor" id="before_and_after"></a>
Actions before and after solve</h2>
<p>As in the <a href="../../../navier_stokes/collapsible_channel/html/index.html">non-FSI problem</a>, we use the function <code>Problem::actions_before_adapt()</code> to delete the applied traction elements before the mesh adaptation:</p>
 <div class="fragment"><div class="line"><span class="comment">//=========start_of_actions_before_adapt==================================</span></div>
<div class="line"><span class="comment">/// Actions before adapt: Wipe the mesh of prescribed traction elements</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classFSICollapsibleChannelProblem.html#a91b30b3d0369c178d3a79f5658644f1b">FSICollapsibleChannelProblem&lt;ELEMENT&gt;::actions_before_adapt</a>()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Kill the traction elements and wipe surface mesh</span></div>
<div class="line"> delete_traction_elements(Applied_fluid_traction_mesh_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Rebuild the global mesh. </span></div>
<div class="line"> rebuild_global_mesh();</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of actions_before_adapt</span></div>
<div class="ttc" id="aclassFSICollapsibleChannelProblem_html_a91b30b3d0369c178d3a79f5658644f1b"><div class="ttname"><a href="classFSICollapsibleChannelProblem.html#a91b30b3d0369c178d3a79f5658644f1b">FSICollapsibleChannelProblem::actions_before_adapt</a></div><div class="ttdeci">void actions_before_adapt()</div><div class="ttdoc">Actions before adapt: Wipe the mesh of prescribed traction elements.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8cc_source.html#l00881">fsi_collapsible_channel_adapt.cc:881</a></div></div>
</div><!-- fragment --><p>As usual, we then employ the function <code>Problem::actions_after_adapt()</code> to re-attach traction elements to the fluid elements that are located at the mesh's inflow boundary (mesh boundary 5) when the mesh adaptation is complete.</p>
 <div class="fragment"><div class="line"><span class="comment">//==========start_of_actions_after_adapt==================================</span></div>
<div class="line"><span class="comment">/// Actions after adapt: Rebuild the mesh of prescribed traction elements</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classFSICollapsibleChannelProblem.html#ae20eb7ed895e0063ade5a6d0c6f9af2f">FSICollapsibleChannelProblem&lt;ELEMENT&gt;::actions_after_adapt</a>()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Create prescribed-flux elements from all elements that are </span></div>
<div class="line"> <span class="comment">// adjacent to boundary 5 and add them to surface mesh</span></div>
<div class="line"> create_traction_elements(5,Bulk_mesh_pt,Applied_fluid_traction_mesh_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Rebuild the global mesh</span></div>
<div class="line"> rebuild_global_mesh();</div>
<div class="ttc" id="aclassFSICollapsibleChannelProblem_html_ae20eb7ed895e0063ade5a6d0c6f9af2f"><div class="ttname"><a href="classFSICollapsibleChannelProblem.html#ae20eb7ed895e0063ade5a6d0c6f9af2f">FSICollapsibleChannelProblem::actions_after_adapt</a></div><div class="ttdeci">void actions_after_adapt()</div><div class="ttdoc">Actions after adapt: Rebuild the mesh of prescribed traction elements and reset FSI.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8cc_source.html#l00897">fsi_collapsible_channel_adapt.cc:897</a></div></div>
</div><!-- fragment --><p> Next, we pin the redundant pressure degrees of freedom (see <a href="../../../navier_stokes/adaptive_driven_cavity/html/index.html">another tutorial</a> for details) and pass the function pointer to the function that defines the prescribed traction to the applied traction elements:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Unpin all pressure dofs</span></div>
<div class="line"> RefineableNavierStokesEquations&lt;2&gt;::</div>
<div class="line">  unpin_all_pressure_dofs(Bulk_mesh_pt-&gt;element_pt());</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Pin redundant pressure dofs</span></div>
<div class="line"> RefineableNavierStokesEquations&lt;2&gt;::</div>
<div class="line">  pin_redundant_nodal_pressures(Bulk_mesh_pt-&gt;element_pt());</div>
<div class="line">   </div>
<div class="line"> <span class="comment">// Loop over the traction elements to pass pointer to prescribed </span></div>
<div class="line"> <span class="comment">// traction function</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_element=Applied_fluid_traction_mesh_pt-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from GeneralisedElement to NavierStokesTractionElement element</span></div>
<div class="line">   NavierStokesTractionElement&lt;ELEMENT&gt; *el_pt = </div>
<div class="line">    <span class="keyword">dynamic_cast&lt;</span>NavierStokesTractionElement&lt;ELEMENT&gt;*<span class="keyword">&gt;</span>(</div>
<div class="line">     Applied_fluid_traction_mesh_pt-&gt;element_pt(e));</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Set the pointer to the prescribed traction function</span></div>
<div class="line">   el_pt-&gt;traction_fct_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a0de42ee6d39e85c77c16a04c3a05f7a2">Global_Physical_Variables::prescribed_traction</a>;</div>
<div class="line">  }</div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a0de42ee6d39e85c77c16a04c3a05f7a2"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a0de42ee6d39e85c77c16a04c3a05f7a2">Global_Physical_Variables::prescribed_traction</a></div><div class="ttdeci">void prescribed_traction(const double &amp;t, const Vector&lt; double &gt; &amp;x, const Vector&lt; double &gt; &amp;n, Vector&lt; double &gt; &amp;traction)</div><div class="ttdoc">Traction applied on the fluid at the left (inflow) boundary.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00186">fsi_collapsible_channel.cc:186</a></div></div>
</div><!-- fragment --><p> We specify the function <code>FSI_functions::apply_no_slip_on_moving_wall()</code> as the auxiliary node-update function for all fluid nodes that are located on the FSI boundary (mesh boundary 3) &ndash; this ensures that the fluid velocity is updated (via the no-slip condition) whenever the position of a fluid node on this boundary is updated. For fluid nodes that already existed before the mesh adaptation this statement over-writes the function pointers already stored at those nodes. Note the use of compiler flags to distinguish between the two node-update strategies.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// The functions used to update the no slip boundary conditions </span></div>
<div class="line"> <span class="comment">// must be set on any new nodes that have been created during the </span></div>
<div class="line"> <span class="comment">// mesh adaptation process. </span></div>
<div class="line"> <span class="comment">// There is no mechanism by which auxiliary update functions </span></div>
<div class="line"> <span class="comment">// are copied to newly created nodes.</span></div>
<div class="line"> <span class="comment">// (because, unlike boundary conditions, they don&#39;t occur exclusively </span></div>
<div class="line"> <span class="comment">// at boundaries)</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// The velocity of the fluid nodes on the wall (fluid mesh boundary 3)</span></div>
<div class="line"> <span class="comment">// is set by the wall motion -- hence the no-slip condition needs to be</span></div>
<div class="line"> <span class="comment">// re-applied whenever a node update is performed for these nodes. </span></div>
<div class="line"> <span class="comment">// Such tasks may be performed automatically by the auxiliary node update </span></div>
<div class="line"> <span class="comment">// function specified by a function pointer:</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> ibound=3; </div>
<div class="line"> <span class="keywordtype">unsigned</span> num_nod= bulk_mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">  {</div>
<div class="line">   bulk_mesh_pt()-&gt;boundary_node_pt(ibound, inod)-&gt;</div>
<div class="line">    set_auxiliary_node_update_fct_pt(</div>
<div class="line">     FSI_functions::apply_no_slip_on_moving_wall);</div>
<div class="line">  }</div>
</div><!-- fragment --><p> Finally, we re-generate the FSI lookup scheme that establishes which fluid elements are located next to the Gauss points in the beam elements. This is necessary because the previous lookup scheme, set up in the problem constructor, becomes invalid if any of the fluid elements next the wall are split during the refinement process.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// (Re-)setup fsi: Work out which fluid dofs affect wall elements</span></div>
<div class="line"> <span class="comment">// the correspondance between wall dofs and fluid elements is handled</span></div>
<div class="line"> <span class="comment">// during the remeshing, but the &quot;reverse&quot; association must be done</span></div>
<div class="line"> <span class="comment">// separately. We need to set up the interaction every time because the fluid</span></div>
<div class="line"> <span class="comment">// element adjacent to a given solid element&#39;s integration point may have </span></div>
<div class="line"> <span class="comment">// changed.We pass the boundary between the fluid and solid meshes and </span></div>
<div class="line"> <span class="comment">// pointers to the meshes. The interaction boundary is boundary 3 of </span></div>
<div class="line"> <span class="comment">// the Fluid mesh.</span></div>
<div class="line"> FSI_functions::setup_fluid_load_info_for_solid_elements&lt;ELEMENT,2&gt;</div>
<div class="line">  (<span class="keyword">this</span>,3,Bulk_mesh_pt,Wall_mesh_pt);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of actions_after_adapt</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="comments"></a>
Comments and Exercises</h1>
<h2><a class="anchor" id="ex"></a>
Exercises</h2>
<ol type="1">
<li>The post-processing function <code>doc_solution(...)</code> outputs the wall shape at the present and the two previous timesteps: The output file <code>wall<em>i-<em>j</em>.<code>dat</code> is</em> created</code> at the <em>i</em> - th timestep and contains the wall shape at the <em>j</em> - th previous timestep. To check that the <code>Steady&lt;2&gt;</code> timestepper correctly maintains the time-history of the wall displacement field, confirm that <code>wall3-2.dat</code> is identical to <code>wall2-0.dat</code>, say. <br  />
<br  />
</li>
<li>Explore what happens if the <code>Steady&lt;2&gt;</code> timestepper is not specified explicitly. [Hint: Unless you have compiled the library with <code>-DRANGE_CHECKING</code>, the code will die with a segmentation fault &ndash; use the debugger to determine where the segmentation fault occurs and explain what goes wrong.] <br  />
<br  />
</li>
<li>Explain why refineable <code>MacroElementNodeUpdateMeshes</code> do not require a <code>update_node_update()</code> function. <br  />
<br  />
</li>
<li>Explore what happens if the empty function <code>AlgebraicCollapsibleChannelMesh::update_node_update(...)</code> is not overloaded in the derived refineable mesh <code>RefineableAlgebraicCollapsibleChannelMesh</code>. [Hint: Inspect the plot of the initial conditions in the output file <code>soln0.dat</code> to see how the uniform refinement performed in the problem constructor fails if the function <code>RefineableAlgebraicCollapsibleChannelMesh::update_node_update(...)</code> is not executed.]</li>
</ol>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory:<br  />
<br  />
<center> <a href="../../../../demo_drivers/interaction/fsi_collapsible_channel/">demo_drivers/interaction/fsi_collapsible_channel/ </a> </center><br  />
</li>
<li>The driver code is: <br  />
<br  />
<center> <a href="../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel_adapt.cc">demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel_adapt.cc </a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:29:56
        </div>
      </div>
    </footer>
</body>
</html>
