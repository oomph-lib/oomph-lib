<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: fsi_collapsible_channel_adapt.txt_doxygenified.h Source File</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Get it <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/subversion/html/index.html">Get code from subversion repository</a></li>
            <li><a href="../../../../doc/download/html/index.html">Get code as tar file</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">fsi_collapsible_channel_adapt.txt_doxygenified.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="fsi__collapsible__channel__adapt_8txt__doxygenified_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">\mainpage  Flow in a 2D collapsible channel revisited -- enabling adaptivity in FSI problems</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"> In this document we re-visit the collapsible channel problem yet</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">again -- this time to demonstrate the use of spatial adaptivity in </span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">fluid-structure interaction problems. In such problems, two</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">additional issues have to be addressed:</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">-# \ref history</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">-# \ref update_node_update</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">. </span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">We start with a brief reminder of \c oomph-lib&#39;s mesh adaptation </span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">procedures to highlight what additional complications arise</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">in fluid-structure interaction problems, and then explain how these </span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">problems are addressed.</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">&lt;HR&gt; </span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">\section history The assignment of positional history values for newly-created nodes</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">\subsection what What is the problem?</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">We first discussed the use of spatial adaptivity for time-dependent </span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">problems in the context of </span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">&lt;A HREF=&quot;../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html#spatial_adapt&quot;&gt;</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment">the unsteady heat equation&lt;/A&gt;. We showed that whenever a new node is created,</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment">\c oomph-lib&#39;s mesh adaptation procedures automatically assign the</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">nodal values and &quot;history values&quot; (the auxiliary values that are used </span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment">by the \c Node&#39;s \c TimeStepper to approximate</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment">time-derivatives of the nodal values) for the newly-created \c Node </span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment">by interpolating between the corresponding values in the new </span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment">\c Node&#39;s father element. </span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment">Similarly, an initial assignment for the newly-created \c Node&#39;s current</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment">and previous positions (required for the evaluation of the mesh-velocities </span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment">in the ALE formulation of the time-derivatives) is made by interpolating </span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">between the current and previous nodal positions of the new \c Node&#39;s father </span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">element.  This default assignment is subsequently overwritten if the </span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment">father element is associated with a \c MacroElement, in which case the</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment">newly-created \c Node&#39;s current position is determined by the</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment">father element&#39;s \c MacroElement representation. This ensures</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment">that the mesh refinement process respects curvilinear domain </span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="comment">boundaries, as discussed  </span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment">&lt;A HREF=&quot;../../../poisson/fish_poisson2/html/index.html&quot;&gt;elsewhere.&lt;/A&gt;</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment">The same strategy is used to over-write the default assignment for</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">a new \c Node&#39;s previous positions: They are re-assigned, based on the</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment">father element&#39;s \c MacroElement - representation, evaluated at the</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment">relevant previous timesteps.</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">To illustrate the process, consider the sketch below and </span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment">assume that the time-integration of the Navier-Stokes equations is </span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment">performed with a \c BDF&lt;2&gt; timestepper -- a timestepper that requires </span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment">two history values (the solution and the nodal positions at two</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment">previous timesteps) to evaluate the time-derivative </span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment">\f$ \partial u_i/\partial t \f$ in the momentum equations. The</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">position of the nodes in the collapsible </span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment">part of the channel is determined by the \c MacroElement - based</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment">representation of the \c CollapsibleChannelDomain, using the </span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment">wall shape obtained from the compound \c MeshAsGeomObject that</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment">we created from the discretisation of the elastic wall, </span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">shown in green.</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment">Assume that the initial mesh is sufficiently </span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment">fine to resolve the solution at \f$ t=t_0 \f$ and \f$ t=t_0 + \Delta</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment">t \f$. At \f$ t=t_0 + 2 \Delta t \f$, the automatic mesh adaptation </span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment">splits one of the fluid elements, creating the five new \c Nodes,</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment">shown in red (for simplicity we only show the fluid elements&#39; vertex</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="comment">nodes). Their position is determined by the father element&#39;s</span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="comment">\c MacroElement mapping, using the current position of the </span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment">\c MeshAsGeomObject, obtained from the interpolation between the </span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="comment">nodal positions of its \c SolidNodes (shown as green circles). </span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="comment">\image html history_values.gif &quot;Sketch illustrating the assignment of positional history values for newly-created nodes in FSI problems. The positional history values of the newly-created Nodes (shown in red) are given by the positions they would have had if they had already existed at previous timesteps. &quot; </span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment">\image latex history_values.eps &quot;Sketch illustrating the assignment of positional history values for newly-created nodes in FSI problems. The positional history values of the newly-created Nodes (shown in red) are given by the positions they would have had if they had already existed at previous timesteps. &quot; width=0.75\textwidth</span></div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="comment">So far, so good! A subtle problem arises when we try to assign</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="comment">the positional history values for the newly-created \c Nodes. The evaluation</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="comment">of the \c MacroElement mapping at the previous timesteps </span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="comment">(required to determine the positions the newly-created \c Nodes would have</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="comment">had, if they had already existed at previous timesteps) requires</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="comment">access to the previous wall shapes. In </span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="comment">&lt;A HREF=&quot;../../../navier_stokes/collapsible_channel/html/index.html&quot;&gt;</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="comment">the non-FSI problem discussed earlier&lt;/A&gt;, the wall shape was given </span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="comment">analytically and could therefore</span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="comment">be evaluated at arbitrary times. In the FSI problem considered here,</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="comment">the previous wall shape is not available as the previous positions</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="comment">of the \c SolidNodes are not required (and are therefore not stored)</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment">for the solution of the (steady!) wall equations.</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment">\subsection soln The solution: The Steady&lt;NSTEPS&gt; timestepper</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="comment">The solution to the problem is simple: Recall that the final entry in</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="comment">the argument list of \c oomph-lib&#39;s mesh constructors specifies the </span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="comment">\c TimeStepper to be used for the evaluation of any time-derivatives.</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="comment">The \c TimeStepper&#39;s member function </span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="comment">\c TimeStepper::ntstorage() specifies the total number of</span></div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="comment">values (the current value plus the number of history values) required </span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="comment">to evaluate the time-derivatives; it is used by the \c</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="comment">FiniteElement::construct_node(...) function to create the required</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="comment">amount of storage at the elements&#39; \c Nodes when the \c Nodes are</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="comment">created in the mesh constructor. To maximise the</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="comment">potential for code-reuse, we always provide a default argument for</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="comment">the pointer to the \c TimeStepper -- a pointer</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment">to a static instantiation of \c oomph-lib&#39;s dummy \c TimeStepper, \c</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="comment">Steady&lt;0&gt;. This ensures that the &quot;user&quot; can use the mesh for steady problems</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment">without having to artificially create a dummy \c TimeStepper that</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment">would be completely irrelevant for his/her problem.</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="comment">For instance, the full interface to the</span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment">constructor of the \c OneDLagrangianMesh, defined in</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment">&lt;A HREF=&quot;../../../../src/meshes/one_d_lagrangian_mesh.template.h&quot;&gt;</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">one_d_lagrangian_mesh.template.h&lt;/A&gt; is given by</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment">\dontinclude one_d_lagrangian_mesh.template.h</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment">\skipline Constructor:</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment">\until &amp;Mesh::Default_TimeStepper);</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment">Thus, when we constructed the wall mesh in the non-adaptive</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment">version of the driver code </span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="comment">&lt;A HREF=&quot;../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc&quot;&gt;fsi_collapsible_channel.cc,&lt;/A&gt; using the statements</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment">\code</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment"> //Create the &quot;wall&quot; mesh with FSI Hermite beam elements</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment"> Wall_mesh_pt = new OneDLagrangianMesh&lt;FSIHermiteBeamElement&gt;</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment">  (Ncollapsible,Lcollapsible,undeformed_wall_pt);</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="comment">\endcode</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="comment">the use of the dummy \c TimeStepper, \c Steady&lt;0&gt; was implied. </span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="comment">All time-derivatives computed by this \c TimeStepper </span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="comment">evaluate to zero, and the \c TimeStepper does not require (or request)</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="comment">any storage for history values. This is a sensible default for problems </span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="comment">that are either inherently steady (such as problems involving the </span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="comment">Poisson equations, say) or for steady versions of time-dependent PDEs </span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="comment">(such as the steady Navier-Stokes equations). In the present</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="comment">problem, we wish to retain the dummy character of the \c TimeStepper</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="comment">so that all time-derivatives in the \c FSIHermiteBeamElements</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="comment">are set to zero, while retaining a </span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="comment">limited history of the \c SolidNode&#39;s previous positions so that</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="comment">the wall shape at previous timesteps can be evaluated. This is</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="comment">possible by creating a \c Steady timestepper with </span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="comment">a non-zero template argument: The class</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="comment">\code</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="comment">template&lt;unsigned NSTEPS&gt;</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="comment">class Steady : public TimeStepper</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment">\endcode</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment">provides a dummy \c TimeStepper that requires (and maintains) \c</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment">NSTEPS history values that represent the nodal positions </span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="comment">(or nodal values) at \c NSTEPS previous timesteps. However, these</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="comment">history values are not used to evaluate any time-derivatives --</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="comment">all time-derivatives computed by this \c TimeStepper are zero. </span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="comment">If the Navier-Stokes equations are discretised with a \c BDF&lt;2&gt;</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="comment">timestepper, the evaluation of the mesh velocity in the </span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="comment">ALE representation of the time-derivatives \f$ \partial u_i/\partial t</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="comment">\f$ requires the nodal position at the two previous timesteps.</span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="comment">This is achieved by passing a pointer to a specifically-constructed</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="comment">\c Steady&lt;2&gt; timestepper to the wall mesh. Here is the relevant</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="comment">code fragment from the Problem constructor in the driver code</span></div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="comment">&lt;A HREF=&quot;../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel_adapt.cc&quot;&gt;fsi_collapsible_channel_adapt.cc&lt;/A&gt;:</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="comment">\dontinclude fsi_collapsible_channel_adapt.cc</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="comment">\skipline Allocate the timestepper </span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="comment">\until undeformed_wall_pt,wall_time_stepper_pt);</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="comment">\section update_node_update Updating the node-update data in refineable AlgebraicMeshes</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment">When discussing </span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="comment">&lt;A HREF=&quot;../../../navier_stokes/algebraic_collapsible_channel/html/index.html&quot;&gt;</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="comment">the non-FSI version of the collapsible channel problem&lt;/A&gt;</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="comment">we explained how \c oomph-lib&#39;s mesh adaptation procedures</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="comment">assign the node-update data for newly-created \c AlgebraicNodes.</span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="comment">Recall that the node-update data comprises:</span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment">- A pointer to the \c AlgebraicMesh that implements the </span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment">  node-update function.  \n\n</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="comment">- An ID for the node-update function. This is used in cases in which</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="comment">  different regions of the \c AlgebraicMesh are updated by different</span></div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment">  node-update functions. The ID has a default value of 0; this is</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment">  used if there is only a single node-update function, as in </span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment">  the \c AlgebraicCollapsibleChannelMesh. \n\n</span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="comment">- A vector of (pointers to) \c GeomObjects that are involved in</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="comment">  the node update. \n\n</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="comment">- A vector of reference values, such as the intrinsic coordinates</span></div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;<span class="comment">  of reference points on the \c GeomObjects. \n\n</span></div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="comment">.</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="comment">By default, we assume that a newly-created \c AlgebraicNode</span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="comment">is updated by the same node-update function as the \c AlgebraicNodes</span></div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="comment">in its father element. Therefore we pass the pointer to the \c AlgebraicMesh,</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="comment">the node-update function ID, and the vector of pointers to \c</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="comment">GeomObjects to the newly-created \c AlgebraicNodes, and interpolate </span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="comment">the reference values between those stored at the \c AlgebraicNodes </span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="comment">in the father elements. </span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="comment">In most cases this provides a sensible default. For instance, it </span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="comment">is hard to imagine a situation in which it would be sensible to update the</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment">position of newly-created \c AlgebraicNodes by a procedure that</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment">differs from that used for the surrounding </span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment">\c AlgebraicNodes that already existed in the father element. </span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="comment">Similarly, since the reference values vary from node to node</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="comment">(if they were constant we would not store them in the \c AlgebraicNodes&#39; </span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="comment">node-update data but in the \c AlgebraicMesh that implements the node</span></div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="comment">update!) it makes sense to assign the values at newly-created </span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="comment">\c AlgebraicNodes by interpolation. For instance, in the</span></div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="comment">\c AlgebraicCollapsibleChannelMesh one of the reference values</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="comment">is the \f$ x_1 \f$ - coordinate of the reference point on the fixed</span></div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="comment">lower wall. For the \c AlgebraicNodes that already existed in the</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment">coarse base mesh, this value is given by the the \c AlgebraicNodes&#39; </span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="comment">\f$ x_1 \f$ - coordinate in the undeformed mesh. Interpolation</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="comment">of this value for the newly-created \c AlgebraicNodes results in </span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="comment">an axially uniform subdivision of the refined elements.</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="comment">  The same procedure may be used to assign the reference value that</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment">represents the intrinsic coordinate of the reference point on the</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment">upper wall -- at least as long as the upper wall is only ever</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment">addressed as a compound \c GeomObject, as in our original (slow!) code </span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="comment">that employed a \c MacroElement - based node update.  The</span></div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="comment">procedure is illustrated in the sketch below: The upper wall is </span></div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="comment">parametrised by a compound \c GeomObject in which the beam&#39;s Lagrangian</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="comment">coordinate \f$ \xi \f$ doubles as the \c GeomObject&#39;s intrinsic </span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="comment">coordinate \f$ \zeta. \f$</span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="comment">The green arrows indicate the reference points for nodes I, II, III,</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="comment">IV and V in the coarse initial mesh. The reference values</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="comment">\f$ \zeta_{I}^{[ref]}, ... , \zeta_{V}^{[ref]} \f$ are stored</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="comment">in the node-update data of nodes I,...,V, respectively. </span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="comment">The red arrow identifies the reference point for the newly-created </span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="comment">node VI whose reference coordinate \f$ \zeta_{IV}^{[ref]} \f$ is created by </span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="comment">interpolation between the reference values of nodes II, III, IV and V,</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="comment">i.e. the nodes in its father element.</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="comment">\image html update_single.gif &quot;Illustration of the default update procedure for the node-update data: The reference value for newly created node VI is created by interpolation from the reference values for nodes II, III, IV and V in its father element. &quot; </span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment">\image latex update_single.eps &quot;Illustration of the default update procedure for the node-update data: The reference value for newly created node VI is created by interpolation from the reference values for nodes II, III, IV and V in its father element. &quot; width=0.75\textwidth</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="comment">Unfortunately, the default assignment is not appropriate for nodes</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment">that are updated by the (much faster) algebraic node update procedure </span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="comment">implemented in the \c AlgebraicCollapsibleChannelMesh. Its</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="comment">\c AlgebraicNodes store pointers to the sub-\c GeomObjects (i.e. the </span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="comment">\c FSIHermiteBeamElements in the wall mesh) that contain their </span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="comment">reference points,  and the values of the local coordinate at which </span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="comment">the reference points are located. This is illustrated in the sketch</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="comment">below in which the sub- \c GeomObjects, parametrised by their local </span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="comment">coordinates \f$ s = \zeta, \f$ are shown in magenta. Note that </span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="comment">the reference points for nodes II and IV are located in one </span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment">sub- \c GeomObject, those for nodes III and V are located in another. </span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="comment">\image html update_compound.gif &quot;Illustration of the revised update procedure for the node-update data: The intrinsic coordinate within the compound GeomObject can be created by interpolation. The coordinate within the sub-GeomObject has to be determined via the GeomObject::locate_zeta(...) function. &quot; </span></div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="comment">\image latex update_compound.eps &quot;Illustration of the revised update procedure for the node-update data: The intrinsic coordinate within the compound GeomObject can be created by interpolation. The coordinate within the sub-GeomObject has to be determined via the GeomObject::locate_zeta(...) function. &quot; width=0.75\textwidth</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment">It obviously does not make sense to create the reference value for</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment">the newly-created node VI by interpolation. The node update data must be</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="comment">created from scratch in two steps:</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="comment">-# Determine the newly-created Node&#39;s intrinsic reference coordinate within</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="comment">   the compound \c MeshAsGeomObject (i.e. the continuous beam&#39;s</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="comment">   Lagrangian coordinate), \f$ \xi_{VI}^{[ref]}\f$ by interpolation.</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="comment">   (&lt;A HREF=&quot;../../fsi_collapsible_channel_algebraic/html/index.html&quot;&gt;Recall </span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="comment">   &lt;/A&gt; that the \c AlgebraicNodes in the non-refineable</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment">   \c AlgebraicCollapsibleChannelMesh already stored this coordinate,</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment">   even though it was not used during the node-update itself). </span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="comment">   \n\n</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="comment">-# Use the \c GeomObject::locate_zeta(...) function to determine</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment">   sub-\c GeomObject and the local coordinate within it, at which</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="comment">   the reference point with Lagrangian coordinate \f$</span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment">   \xi_{VI}^{[ref]}\f$  is located.</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="comment">.</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="comment">To ensure that this procedure is performed automatically after</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="comment">every mesh adaptation, it should be implemented in the</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="comment">function \c AlgebraicMesh::update_node_update(...). This function is defined</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="comment">as a pure virtual function in the \c AlgebraicMesh base class in order to </span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="comment">force the mesh writer to assess if the default procedure</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="comment">for the assignment of the node-update data for newly-created</span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="comment">\c AlgebraicNodes, described above, is appropriate. If it </span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="comment">is, the function may, of course, be implemented as an empty function.</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="comment">We note that the function \c AlgebraicMesh::update_node_update(...)</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="comment">is called \b after the default values for the node-update</span></div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="comment">data have been assigned. It is therefore only necessary to correct</span></div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="comment">those values for which the default procedure is inappropriate.</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="comment">To illustrate the procedure, here is the class definition for the</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="comment">\c RefineableAlgebraicCollapsibleChannelMesh. The mesh</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="comment">is derived by multiple inheritance from the non-refineable</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="comment">\c AlgebraicCollapsibleChannelMesh and the \c RefineableQuadMesh </span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;<span class="comment">base class. The constructor calls the constructors of both underlying</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;<span class="comment">meshes and then sets up the \c QuadTreeForest: </span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;<span class="comment">\dontinclude collapsible_channel_mesh.template.h</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;<span class="comment">\skipline start_of_refineable_algebraic</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;<span class="comment">\until }</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="comment">We overload the (empty) previous implementations of</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="comment">\c AlgebraicMesh::update_node_update(...) with our own function:</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="comment">\skipline Update the node update</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="comment">\until };</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="comment">Here is the actual implementation of this function. We start by </span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="comment">extracting the reference values that were already assigned</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="comment">by the default procedure:</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="comment">\dontinclude collapsible_channel_mesh.template.cc</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="comment">\skipline start_update_node_update</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="comment">\until Vector&lt;double&gt; ref_value</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="comment">Recall from the discussion of the algebraic node-update strategy</span></div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;<span class="comment">&lt;A HREF=&quot;../../fsi_collapsible_channel_algebraic/html/index.html#mesh&quot;&gt;</span></div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;<span class="comment">for the non-refineable version of the problem&lt;/A&gt; that reference values</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="comment">0 and 1 store the \f$ x_1 \f$ - coordinate along the fixed bottom</span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="comment">wall, and the fractional height of the node in the cross-channel</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="comment">direction, respectively. These values are interpolated</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="comment">correctly and do not have to be corrected. The third reference</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="comment">value is the intrinsic coordinate of the reference point</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="comment">in its sub-\c GeomObject. This needs to be re-computed and we </span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="comment">will assign the corrected value below. The fourth reference value </span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="comment">is the intrinsic coordinate of the reference point within </span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment">the compound \c MeshAsGeomObject. We store this in a temporary </span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="comment">variable:</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="comment">\skipline Fourth reference value:</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="comment">\until double zeta</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="comment">Next, we extract vector of (pointers to the) \c GeomObjects involved </span></div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="comment">in this node&#39;s node-update from the node.</span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="comment">\skipline Extract geometric objects</span></div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="comment">\until Vector&lt;GeomObject*&gt;</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="comment">Now we use the \c GeomObject::locate_zeta(...) function to obtain</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="comment">the pointer to the (sub-)\c GeomObject and the intrinsic coordinate</span></div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="comment">within it, at which the reference point (identified by its</span></div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="comment">intrinsic coordinate \c zeta in the compound \c GeomObject) is</span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="comment">located:</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="comment">\skipline Get pointer to geometric</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="comment">\until this-&gt;Wall_pt</span></div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="comment">We over-write the first (and, in fact, only) entry in the </span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="comment">vector of \c GeomObjects that are involved in this node&#39;s node-update</span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="comment">with the pointer to the (sub-)\c GeomObject just located:</span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="comment">\skipline Update the pointer to the (sub-)</span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="comment">\until geom_object_pt[0]=</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<span class="comment">Similarly, we over-write the third reference value with the local</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;<span class="comment">coordinate of the reference point within its (sub-)\c GeomObject.</span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="comment">\skipline Update third reference value</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="comment">\until ref_value[2]=</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;<span class="comment">The incorrect entries in the two vectors </span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;<span class="comment">\c geom_object_pt and \c ref_value have now been corrected. We can</span></div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;<span class="comment">wipe the node&#39;s node-update data and re-assign it:</span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="comment">\skipline Kill the existing</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;<span class="comment">\until }</span></div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;<span class="comment">That&#39;s it!</span></div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;<span class="comment">\section results Results</span></div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<span class="comment">The figure below shows a snapshot of the flow field during the</span></div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;<span class="comment">early stages of the oscillation. The computation was performed with</span></div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;<span class="comment">refineable Crouzeix-Raviart elements, using the </span></div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;<span class="comment">\c RefineableAlgebraicCollapsibleChannelMesh. Note how the automatic </span></div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;<span class="comment">mesh adaptation has refined the mesh in the regions in which the </span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="comment">Stokes layers create steep velocity gradients.</span></div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;<span class="comment">\image html fsi_CR_algebraic_adapt.gif &quot;Snapshot from the animation of the flow field. &quot; </span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;<span class="comment">\image latex fsi_CR_algebraic_adapt.eps &quot;Snapshot from the animation of the flow field. &quot; width=0.8\textwidth</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;<span class="comment">\section driver The driver code</span></div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;<span class="comment">The driver code </span></div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;<span class="comment">&lt;A HREF=&quot;../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel_adapt.cc&quot;&gt;fsi_collapsible_channel_adapt.cc&lt;/A&gt;</span></div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;<span class="comment">for the spatially adaptive problem is a trivial extension of the </span></div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;<span class="comment">non-adaptive code </span></div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;<span class="comment">&lt;A HREF=&quot;../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc&quot;&gt;fsi_collapsible_channel.cc,&lt;/A&gt;</span></div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;<span class="comment">therefore we will not provide a detailed listing here.</span></div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;<span class="comment">Comparing the two source codes (e.g. with \c sdiff) shows that </span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="comment">spatial adaptivity may be enabled with a few straightforward changes:</span></div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="comment">- Change the fluid mesh from the \c</span></div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="comment">  MacroElementNodeUpdateCollapsibleChannelMesh to  the</span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="comment">  \c MacroElementNodeUpdateRefineableCollapsibleChannelMesh</span></div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="comment">  (or from the \c AlgebraicCollapsibleChannelMesh to the</span></div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="comment">  \c RefineableAlgebraicCollapsibleChannelMesh). \n\n</span></div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="comment">- Change the element type from \c TaylorHoodElement&lt;2&gt; </span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="comment">  to  \c RefineableQTaylorHoodElement&lt;2&gt; (or </span></div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="comment">  \c QCrouzeixRaviartElement&lt;2&gt; to \c</span></div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="comment">  RefineableQCrouzeixRaviartElement&lt;2&gt;). \n\n</span></div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="comment">- Add the functions \c Problem::actions_before_adapt() and</span></div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;<span class="comment">  \c Problem::actions_after_adapt(); see below. \n\n</span></div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;<span class="comment">- Explicitly specify the \c Steady&lt;2&gt; timestepper for the</span></div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="comment">  wall mesh, as discussed above. \n\n</span></div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;<span class="comment">- Create an error estimator, specify the target errors for</span></div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;<span class="comment">  the adaptation, and call the spatially adaptive Newton solver.</span></div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;<span class="comment">.</span></div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;<span class="comment">\subsection before_and_after Actions before and after solve</span></div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="comment">As in the &lt;A HREF=&quot;../../../navier_stokes/collapsible_channel/html/index.html&quot;&gt;</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="comment">non-FSI problem&lt;/A&gt;, we use the function \c</span></div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="comment">Problem::actions_before_adapt() to delete the applied traction</span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="comment">elements before the mesh adaptation:</span></div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;<span class="comment">\dontinclude fsi_collapsible_channel_adapt.cc</span></div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;<span class="comment">\skipline start_of_actions_before_adapt</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;<span class="comment">\until end of actions_before_adapt</span></div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;<span class="comment">As usual, we then employ the function \c Problem::actions_after_adapt()</span></div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;<span class="comment">to re-attach traction elements to the fluid elements that are located </span></div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;<span class="comment">at the mesh&#39;s inflow boundary (mesh boundary 5) when the mesh </span></div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;<span class="comment">adaptation is complete. </span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="comment">\dontinclude fsi_collapsible_channel_adapt.cc</span></div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;<span class="comment">\skipline start_of_actions_after_adapt</span></div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<span class="comment">\until rebuild_global_mesh();</span></div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;<span class="comment">Next, we pin the redundant pressure degrees of freedom</span></div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;<span class="comment">(see &lt;A HREF=&quot;../../../navier_stokes/adaptive_driven_cavity/html/index.html&quot;&gt;</span></div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;<span class="comment">another tutorial&lt;/A&gt; for details) and pass the</span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;<span class="comment">function pointer to the function that defines the prescribed</span></div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;<span class="comment">traction to the applied traction elements:</span></div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="comment">\until }</span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="comment">We specify the function </span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="comment">\c FSI_functions::apply_no_slip_on_moving_wall() as the</span></div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="comment">auxiliary node-update function for all fluid nodes that are located</span></div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="comment">on the FSI boundary (mesh boundary 3) -- this ensures that</span></div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="comment">the fluid velocity is updated (via the no-slip condition)</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="comment">whenever the position of a fluid node on this boundary is updated.</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="comment">For fluid nodes that already existed before the mesh adaptation</span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;<span class="comment">this statement over-writes the function pointers already stored</span></div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<span class="comment">at those nodes. Note the use of compiler flags to distinguish between</span></div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="comment">the two node-update strategies.</span></div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;<span class="comment">\until }</span></div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;<span class="comment">Finally, we re-generate the FSI lookup scheme that establishes which</span></div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;<span class="comment">fluid elements are located next to the Gauss points in the beam</span></div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;<span class="comment">elements. This is necessary because the previous lookup scheme, set </span></div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;<span class="comment">up in the problem constructor, becomes invalid if any of the fluid</span></div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;<span class="comment">elements next the wall are split during the refinement process.</span></div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;<span class="comment">\until end of actions_after_adapt</span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="comment">\section comments Comments and Exercises</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;<span class="comment">\subsection ex Exercises</span></div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;<span class="comment">-# The post-processing function \c doc_solution(...) outputs the </span></div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;<span class="comment">   wall shape at the present and the two previous timesteps: The</span></div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="comment">   output file \c wall\e i-\e j.\c dat is created at the \e i - th </span></div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;<span class="comment">   timestep and contains the wall shape at the \e j - th previous</span></div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;<span class="comment">   timestep.  To check that the \c Steady&lt;2&gt; timestepper correctly </span></div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;<span class="comment">   maintains the time-history of the wall displacement field, confirm that</span></div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="comment">   \c wall3-2.dat is identical to \c wall2-0.dat, say.</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;<span class="comment">   \n\n</span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="comment">-# Explore what happens if the \c Steady&lt;2&gt; timestepper is not specified</span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;<span class="comment">   explicitly. [Hint: Unless you have compiled the library with</span></div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;<span class="comment">   \c -DRANGE_CHECKING, the code will die with a segmentation fault -- use </span></div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;<span class="comment">   the debugger to determine where the segmentation fault occurs </span></div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;<span class="comment">   and explain what goes wrong.] \n\n</span></div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;<span class="comment">-# Explain why refineable \c MacroElementNodeUpdateMeshes do not require</span></div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;<span class="comment">   a \c update_node_update() function.  \n\n</span></div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;<span class="comment">-# Explore what happens if the empty function \c</span></div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;<span class="comment">   AlgebraicCollapsibleChannelMesh::update_node_update(...) is not</span></div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;<span class="comment">   overloaded in the derived refineable mesh </span></div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;<span class="comment">   \c RefineableAlgebraicCollapsibleChannelMesh.</span></div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;<span class="comment">   [Hint: Inspect the plot of the initial conditions in</span></div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;<span class="comment">   the output file \c soln0.dat to see how the </span></div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;<span class="comment">   uniform refinement performed in the problem constructor</span></div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;<span class="comment">   fails if the function \c</span></div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;<span class="comment">   RefineableAlgebraicCollapsibleChannelMesh::update_node_update(...)</span></div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;<span class="comment">   is not executed.]</span></div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;<span class="comment">.</span></div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;<span class="comment">&lt;HR&gt;</span></div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;<span class="comment">\section sources Source files for this tutorial</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="comment">- The source files for this tutorial are located in the directory:\n\n</span></div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;<span class="comment">&lt;CENTER&gt;</span></div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;<span class="comment">&lt;A HREF=&quot;../../../../demo_drivers/interaction/fsi_collapsible_channel/&quot;&gt;</span></div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;<span class="comment">demo_drivers/interaction/fsi_collapsible_channel/</span></div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;<span class="comment">&lt;/A&gt;</span></div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;<span class="comment">&lt;/CENTER&gt;\n</span></div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;<span class="comment">- The driver code is: \n\n</span></div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;<span class="comment">&lt;CENTER&gt;</span></div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;<span class="comment">&lt;A HREF=&quot;../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel_adapt.cc&quot;&gt;</span></div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;<span class="comment">demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel_adapt.cc</span></div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;<span class="comment">&lt;/A&gt;</span></div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;<span class="comment">&lt;/CENTER&gt;</span></div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;<span class="comment">.</span></div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;<span class="comment">&lt;hr&gt;</span></div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;<span class="comment">&lt;hr&gt;</span></div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;<span class="comment">\section pdf PDF file</span></div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;<span class="comment">A &lt;a href=&quot;../latex/refman.pdf&quot;&gt;pdf version&lt;/a&gt; of this document is available.</span></div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;<span class="comment">**/</span></div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160; </div>
</div><!-- fragment --></div><!-- contents -->
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_adced636e1609d83cd4f8bac99930f86a"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#adced636e1609d83cd4f8bac99930f86a">wall_time_stepper_pt</a></div><div class="ttdeci">endcode the use of the dummy c c Steady&lt; 0 &gt; was implied All time derivatives computed by this c TimeStepper evaluate to and the c TimeStepper does not say or for steady versions of time dependent we wish to retain the dummy character of the c TimeStepper so that all time derivatives in the c FSIHermiteBeamElements are set to while retaining a limited history of the c SolidNode s previous positions so that the wall shape at previous timesteps can be evaluated This is possible by creating a c Steady timestepper with a non zero template these history values are not used to evaluate any time derivatives all time derivatives computed by this c TimeStepper are zero If the Navier Stokes equations are discretised with a c BDF&lt; 2 &gt; the evaluation of the mesh velocity in the ALE representation of the time derivatives f partial u_i partial t f requires the nodal position at the two previous timesteps This is achieved by passing a pointer to a specifically constructed c Steady&lt; 2 &gt; timestepper to the wall mesh Here is the relevant code fragment from the Problem constructor in the driver code&lt; A HREF=&quot;../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel_adapt.cc&quot;&gt; fsi_collapsible_channel_adapt wall_time_stepper_pt</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00167">fsi_collapsible_channel_adapt.txt:167</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_acda514cea3a9c2f66fa88e3a79a01f8e"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#acda514cea3a9c2f66fa88e3a79a01f8e">zero</a></div><div class="ttdeci">endcode the use of the dummy c c Steady&lt; 0 &gt; was implied All time derivatives computed by this c TimeStepper evaluate to zero</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00132">fsi_collapsible_channel_adapt.txt:132</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_ad8ea802d1207fcbca474c4d872bda182"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#ad8ea802d1207fcbca474c4d872bda182">may</a></div><div class="ttdeci">respectively The red arrow identifies the reference point for the newly created node VI whose reference coordinate f IV and i e the nodes in its father element I w textwidth update_single Illustration of the default update procedure for the node update IV and V in its father element the default assignment is not appropriate for nodes that are updated by and the values of the coordinate at which the reference points are located This is illustrated in the sketch below in which the sub c parametrised by their coordinates f f are shown in magenta Note that the reference points for nodes II and IV are located in one sub c those for nodes III and V are located in another I w textwidth update_compound Illustration of the revised update procedure for the node update f at which the reference point with Lagrangian coordinate f it should be implemented in the function c described is appropriate If it the function may</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00284">fsi_collapsible_channel_adapt.txt:284</a></div></div>
<div class="ttc" id="anamespaceBL__Squash_html_a3c4183891049bca81f3a011db24fc579"><div class="ttname"><a href="namespaceBL__Squash.html#a3c4183891049bca81f3a011db24fc579">BL_Squash::Delta</a></div><div class="ttdeci">double Delta</div><div class="ttdoc">Boundary layer width.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00052">fsi_collapsible_channel.cc:52</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_ac2247a4bf2cae0628b2de4c37e1f81a4"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#ac2247a4bf2cae0628b2de4c37e1f81a4">zeta_</a></div><div class="ttdeci">zeta_</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00234">fsi_collapsible_channel_adapt.txt:234</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a5d3bd6bd19ae6bd122701a4f212d0e05"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a5d3bd6bd19ae6bd122701a4f212d0e05">Constructor</a></div><div class="ttdeci">it is used by the c we always provide a default argument for the pointer to the c TimeStepper a pointer to static a instantiation of c oomph lib s dummy c c Steady&lt; 0 &gt; This ensures that the user can use the mesh for steady problems without having to artificially create a dummy c TimeStepper that would be completely irrelevant for his her problem For the full interface to the constructor of the c defined in&lt; A HREF=&quot;../../../../src/meshes/one_d_lagrangian_mesh.template.h&quot;&gt; one_d_lagrangian_mesh template h&lt;/A &gt; is given by dontinclude one_d_lagrangian_mesh template h skipline Constructor</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00118">fsi_collapsible_channel_adapt.txt:118</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a2af1470836f846deff698521fbf5a2c9"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a2af1470836f846deff698521fbf5a2c9">instance</a></div><div class="ttdeci">it is used by the c we always provide a default argument for the pointer to the c TimeStepper a pointer to static a instantiation of c oomph lib s dummy c c Steady&lt; 0 &gt; This ensures that the user can use the mesh for steady problems without having to artificially create a dummy c TimeStepper that would be completely irrelevant for his her problem For instance</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00111">fsi_collapsible_channel_adapt.txt:111</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a47e912772d16f35bacf97094a2948f5f"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a47e912772d16f35bacf97094a2948f5f">function</a></div><div class="ttdeci">this is used if there is only a single node update function</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00190">fsi_collapsible_channel_adapt.txt:190</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_af6873b0727abfbb225ff73d92ca1536e"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#af6873b0727abfbb225ff73d92ca1536e">adaptation</a></div><div class="ttdeci">Here is the actual implementation of this function We start by extracting the reference values that were already assigned by the default and the fractional height of the node in the cross channel respectively These values are interpolated correctly and do not have to be corrected The third reference value is the intrinsic coordinate of the reference point in its sub c GeomObject This needs to be re computed and we will assign the corrected value below The fourth reference value is the intrinsic coordinate of the reference point within the compound c MeshAsGeomObject We store this in a temporary we extract vector of(pointers to the) \c GeomObjects involved in this node 's node-update from the node. \skipline Extract geometric objects \until Vector&lt; GeomObject * &gt; Now we use the \c GeomObject see below n n Explicitly specify the c Steady&lt; 2 &gt; timestepper for the wall as discussed above n n Create an error specify the target errors for the adaptation</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00415">fsi_collapsible_channel_adapt.txt:415</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_ae7fcf55d2d681c8608503e5fe449ce94"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#ae7fcf55d2d681c8608503e5fe449ce94">Unfortunately</a></div><div class="ttdeci">respectively The red arrow identifies the reference point for the newly created node VI whose reference coordinate f IV and i e the nodes in its father element I w textwidth update_single Illustration of the default update procedure for the node update IV and V in its father element Unfortunately</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00246">fsi_collapsible_channel_adapt.txt:246</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_aa9c1f817fb9aac6f4e87db1448c55cac"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#aa9c1f817fb9aac6f4e87db1448c55cac">positions</a></div><div class="ttdeci">mainpage Flow in a collapsible channel revisited enabling adaptivity in FSI problems In this document we re visit the collapsible channel problem yet again this time to demonstrate the use of spatial adaptivity in fluid structure interaction problems In such two additional issues have to be and then explain how these problems are addressed&lt; HR &gt;&lt; HR &gt; section history The assignment of positional history values for newly created nodes subsection what What is the problem We first discussed the use of spatial adaptivity for time dependent problems in the context of&lt; A HREF=&quot;../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html#spatial_adapt&quot;&gt; the unsteady heat equation&lt;/A &gt; We showed that whenever a new node is c oomph lib s mesh adaptation procedures automatically assign the nodal values and history an initial assignment for the newly created c Node s current and previous in which case the newly created c Node s current position is determined by the father element s c MacroElement representation This ensures that the mesh refinement process respects curvilinear domain as discussed&lt; A HREF=&quot;../../../poisson/fish_poisson2/html/index.html&quot;&gt; elsewhere&lt;/A &gt; The same strategy is used to over write the default assignment for a new c Node s previous positions</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00045">fsi_collapsible_channel_adapt.txt:45</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_ac0a561a993baa270f3981e92d9845db3"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#ac0a561a993baa270f3981e92d9845db3">problems</a></div><div class="ttdeci">mainpage Flow in a collapsible channel revisited enabling adaptivity in FSI problems In this document we re visit the collapsible channel problem yet again this time to demonstrate the use of spatial adaptivity in fluid structure interaction problems In such problems</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00005">fsi_collapsible_channel_adapt.txt:5</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a152339e6ee653f666802b0f8708a0ec3"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a152339e6ee653f666802b0f8708a0ec3">t</a></div><div class="ttdeci">t_0 \f$ and \f$ t=t_0+\Delta t \f$. At \f$ t=t_0+2 \Delta t \f$, the automatic mesh adaptation splits one of the fluid elements, creating the five new \c Nodes, shown in red(for simplicity we only show the fluid elements' vertex nodes). Their position is determined by the father element 's \c MacroElement mapping, using the current position of the \c MeshAsGeomObject, obtained from the interpolation between the nodal positions of its \c SolidNodes(shown as green circles). @I w 0.75\textwidth history_values &quot;Sketch illustrating the assignment of positional history values for newly-created nodes in FSI problems. The positional history values of the newly-created Nodes (shown in red) are given by the positions they would have had if they had already existed at previous timesteps. &quot; So far, so good! A subtle problem arises when we try to assign the positional history values for the newly-created \c Nodes. The evaluation of the \c MacroElement mapping at the previous timesteps(required to determine the positions the newly-created \c Nodes would have had, if they had already existed at previous timesteps) requires access to the previous wall shapes. In&lt; A HREF=&quot;../../../navier_stokes/collapsible_channel/html/index.html&quot;&gt; the non-FSI problem discussed earlier&lt;/A &gt;, the wall shape was given analytically and could therefore be evaluated at arbitrary times. In the FSI problem considered here, the previous wall shape is not available as the previous positions of the \c SolidNodes are not required(and are therefore not stored) for the solution of the(steady!) wall equations.&lt; HR &gt; \subsection soln The solution:The Steady&lt; NSTEPS &gt; timestepper The solution to the problem is simple:Recall that the final entry in the argument list of \c oomph-lib 's mesh constructors specifies the \c TimeStepper to be used for the evaluation of any time-derivatives. The \c TimeStepper 's member function \c TimeStepper::ntstorage() specifies the total number of values(the current value plus the number of history values) required to evaluate the time-derivatives t</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00100">fsi_collapsible_channel_adapt.txt:100</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_ab4245b039ac02a06623ed4b11252853e"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#ab4245b039ac02a06623ed4b11252853e">argument</a></div><div class="ttdeci">endcode the use of the dummy c c Steady&lt; 0 &gt; was implied All time derivatives computed by this c TimeStepper evaluate to and the c TimeStepper does not say or for steady versions of time dependent we wish to retain the dummy character of the c TimeStepper so that all time derivatives in the c FSIHermiteBeamElements are set to while retaining a limited history of the c SolidNode s previous positions so that the wall shape at previous timesteps can be evaluated This is possible by creating a c Steady timestepper with a non zero template argument</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00152">fsi_collapsible_channel_adapt.txt:152</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a366b2d3f9c2a1871cf9b30b6eb47c3a9"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a366b2d3f9c2a1871cf9b30b6eb47c3a9">original</a></div><div class="ttdeci">this is used if there is only a single node update as in the c AlgebraicCollapsibleChannelMesh n n A vector such as the intrinsic coordinates of reference points on the c GeomObjects n n By we assume that a newly created c AlgebraicNode is updated by the same node update function as the c AlgebraicNodes in its father element Therefore we pass the pointer to the c the node update function and the vector of pointers to c GeomObjects to the newly created c and interpolate the reference values between those stored at the c AlgebraicNodes in the father elements In most cases this provides a sensible default For it is hard to imagine a situation in which it would be sensible to update the position of newly created c AlgebraicNodes by a procedure that differs from that used for the surrounding c AlgebraicNodes that already existed in the father element since the reference values vary from node to in the c AlgebraicCollapsibleChannelMesh one of the reference values is the f x_1 f coordinate of the reference point on the fixed lower wall For the c AlgebraicNodes that already existed in the coarse base this value is given by the the c AlgebraicNodes f x_1 f coordinate in the undeformed mesh Interpolation of this value for the newly created c AlgebraicNodes results in an axially uniform subdivision of the refined elements The same procedure may be used to assign the reference value that represents the intrinsic coordinate of the reference point on the upper wall at least as long as the upper wall is only ever addressed as a compound c as in our original(slow!) code that employed a \c MacroElement - based node update. The procedure is illustrated in the sketch below</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00226">fsi_collapsible_channel_adapt.txt:226</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a76005d00b12acac8677ecc7c968ff865"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a76005d00b12acac8677ecc7c968ff865">TimeStepper</a></div><div class="ttdeci">it is used by the c we always provide a default argument for the pointer to the c TimeStepper a pointer to static a instantiation of c oomph lib s dummy c TimeStepper</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00106">fsi_collapsible_channel_adapt.txt:106</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_ac3e1d33bfb11ff9a51d0d55df81b7b83"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#ac3e1d33bfb11ff9a51d0d55df81b7b83">course</a></div><div class="ttdeci">respectively The red arrow identifies the reference point for the newly created node VI whose reference coordinate f IV and i e the nodes in its father element I w textwidth update_single Illustration of the default update procedure for the node update IV and V in its father element the default assignment is not appropriate for nodes that are updated by and the values of the coordinate at which the reference points are located This is illustrated in the sketch below in which the sub c parametrised by their coordinates f f are shown in magenta Note that the reference points for nodes II and IV are located in one sub c those for nodes III and V are located in another I w textwidth update_compound Illustration of the revised update procedure for the node update f at which the reference point with Lagrangian coordinate f it should be implemented in the function c described is appropriate If it the function of course</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00284">fsi_collapsible_channel_adapt.txt:284</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a3201af29f6e8f2173dfce881a8ffe402"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a3201af29f6e8f2173dfce881a8ffe402">process</a></div><div class="ttdeci">mainpage Flow in a collapsible channel revisited enabling adaptivity in FSI problems In this document we re visit the collapsible channel problem yet again this time to demonstrate the use of spatial adaptivity in fluid structure interaction problems In such two additional issues have to be and then explain how these problems are addressed&lt; HR &gt;&lt; HR &gt; section history The assignment of positional history values for newly created nodes subsection what What is the problem We first discussed the use of spatial adaptivity for time dependent problems in the context of&lt; A HREF=&quot;../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html#spatial_adapt&quot;&gt; the unsteady heat equation&lt;/A &gt; We showed that whenever a new node is c oomph lib s mesh adaptation procedures automatically assign the nodal values and history an initial assignment for the newly created c Node s current and previous in which case the newly created c Node s current position is determined by the father element s c MacroElement representation This ensures that the mesh refinement process respects curvilinear domain as discussed&lt; A HREF=&quot;../../../poisson/fish_poisson2/html/index.html&quot;&gt; elsewhere&lt;/A &gt; The same strategy is used to over write the default assignment for a new c Node s previous based on the father element s c MacroElement evaluated at the relevant previous timesteps To illustrate the process</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00049">fsi_collapsible_channel_adapt.txt:49</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a63db2bdb4f52051f8eedaa4d840052a0"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a63db2bdb4f52051f8eedaa4d840052a0">of</a></div><div class="ttdeci">this is used if there is only a single node update as in the c AlgebraicCollapsibleChannelMesh n n A vector of(pointers to) \c GeomObjects that are involved in the node update. \n\n - A vector of reference values</div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_ae3472ac0ca382c5891ce00bc933b3d82"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#ae3472ac0ca382c5891ce00bc933b3d82">the</a></div><div class="ttdeci">respectively The red arrow identifies the reference point for the newly created node VI whose reference coordinate f IV and i e the nodes in its father element I w textwidth update_single Illustration of the default update procedure for the node update IV and V in its father element the default assignment is not appropriate for nodes that are updated by the(much faster) algebraic node update procedure implemented in the \c AlgebraicCollapsibleChannelMesh. Its \c AlgebraicNodes store pointers to the sub-\c GeomObjects(i.e. the \c FSIHermiteBeamElements in the wall mesh) that contain their reference points</div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a0649c02e803dc777d23f36fbd74b0180"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a0649c02e803dc777d23f36fbd74b0180">Thus</a></div><div class="ttdeci">Thus</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00120">fsi_collapsible_channel_adapt.txt:120</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_af4a843e31874b7114234b5e822ef44aa"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#af4a843e31874b7114234b5e822ef44aa">above</a></div><div class="ttdeci">respectively The red arrow identifies the reference point for the newly created node VI whose reference coordinate f IV and i e the nodes in its father element I w textwidth update_single Illustration of the default update procedure for the node update IV and V in its father element the default assignment is not appropriate for nodes that are updated by and the values of the coordinate at which the reference points are located This is illustrated in the sketch below in which the sub c parametrised by their coordinates f f are shown in magenta Note that the reference points for nodes II and IV are located in one sub c those for nodes III and V are located in another I w textwidth update_compound Illustration of the revised update procedure for the node update f at which the reference point with Lagrangian coordinate f it should be implemented in the function c described above</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00283">fsi_collapsible_channel_adapt.txt:283</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a6e3fb3f587ba78c78f5637c4cd8cb189"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a6e3fb3f587ba78c78f5637c4cd8cb189">data</a></div><div class="ttdeci">respectively The red arrow identifies the reference point for the newly created node VI whose reference coordinate f IV and i e the nodes in its father element I w textwidth update_single Illustration of the default update procedure for the node update data</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00242">fsi_collapsible_channel_adapt.txt:242</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_af2d66f9241d0dbe70895113b7f62a71b"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#af2d66f9241d0dbe70895113b7f62a71b">timestepper</a></div><div class="ttdeci">endcode the use of the dummy c c Steady&lt; 0 &gt; was implied All time derivatives computed by this c TimeStepper evaluate to and the c TimeStepper does not say or for steady versions of time dependent we wish to retain the dummy character of the c TimeStepper so that all time derivatives in the c FSIHermiteBeamElements are set to while retaining a limited history of the c SolidNode s previous positions so that the wall shape at previous timesteps can be evaluated This is possible by creating a c Steady timestepper with a non zero template these history values are not used to evaluate any time derivatives all time derivatives computed by this c TimeStepper are zero If the Navier Stokes equations are discretised with a c BDF&lt; 2 &gt; timestepper</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00157">fsi_collapsible_channel_adapt.txt:157</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a449da76d5dfb079f488ac6c63f87b195"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a449da76d5dfb079f488ac6c63f87b195">node</a></div><div class="ttdeci">this is used if there is only a single node update as in the c AlgebraicCollapsibleChannelMesh n n A vector such as the intrinsic coordinates of reference points on the c GeomObjects n n By we assume that a newly created c AlgebraicNode is updated by the same node update function as the c AlgebraicNodes in its father element Therefore we pass the pointer to the c the node update function and the vector of pointers to c GeomObjects to the newly created c and interpolate the reference values between those stored at the c AlgebraicNodes in the father elements In most cases this provides a sensible default For it is hard to imagine a situation in which it would be sensible to update the position of newly created c AlgebraicNodes by a procedure that differs from that used for the surrounding c AlgebraicNodes that already existed in the father element since the reference values vary from node to node(if they were constant we would not store them in the \c AlgebraicNodes' node-update data but in the \c AlgebraicMesh that implements the node update!) it makes sense to assign the values at new ly-created \c AlgebraicNodes by interpolation. For instance</div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a5f945dbbdba0f203d7dc799f9bfe9bf9"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a5f945dbbdba0f203d7dc799f9bfe9bf9">AlgebraicMesh</a></div><div class="ttdeci">this is used if there is only a single node update as in the c AlgebraicCollapsibleChannelMesh n n A vector such as the intrinsic coordinates of reference points on the c GeomObjects n n By we assume that a newly created c AlgebraicNode is updated by the same node update function as the c AlgebraicNodes in its father element Therefore we pass the pointer to the c AlgebraicMesh</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00199">fsi_collapsible_channel_adapt.txt:199</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a16c5b1918f8e50274913964a344d7f7c"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a16c5b1918f8e50274913964a344d7f7c">OneDLagrangianMesh</a></div><div class="ttdeci">it is used by the c we always provide a default argument for the pointer to the c TimeStepper a pointer to static a instantiation of c oomph lib s dummy c c Steady&lt; 0 &gt; This ensures that the user can use the mesh for steady problems without having to artificially create a dummy c TimeStepper that would be completely irrelevant for his her problem For the full interface to the constructor of the c OneDLagrangianMesh</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00112">fsi_collapsible_channel_adapt.txt:112</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_ad9d615b9d1a9f7f817979e18d6141477"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#ad9d615b9d1a9f7f817979e18d6141477">procedure</a></div><div class="ttdeci">Here is the actual implementation of this function We start by extracting the reference values that were already assigned by the default procedure</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00290">fsi_collapsible_channel_adapt.txt:290</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_adefa98606068200be8aecbc9e4c83e1a"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#adefa98606068200be8aecbc9e4c83e1a">Similarly</a></div><div class="ttdeci">this is used if there is only a single node update as in the c AlgebraicCollapsibleChannelMesh n n A vector such as the intrinsic coordinates of reference points on the c GeomObjects n n By we assume that a newly created c AlgebraicNode is updated by the same node update function as the c AlgebraicNodes in its father element Therefore we pass the pointer to the c the node update function and the vector of pointers to c GeomObjects to the newly created c and interpolate the reference values between those stored at the c AlgebraicNodes in the father elements In most cases this provides a sensible default For it is hard to imagine a situation in which it would be sensible to update the position of newly created c AlgebraicNodes by a procedure that differs from that used for the surrounding c AlgebraicNodes that already existed in the father element Similarly</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00210">fsi_collapsible_channel_adapt.txt:210</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a1524c35ac1b2d58c3987908e5ced7143"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a1524c35ac1b2d58c3987908e5ced7143">direction</a></div><div class="ttdeci">Here is the actual implementation of this function We start by extracting the reference values that were already assigned by the default and the fractional height of the node in the cross channel direction</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00320">fsi_collapsible_channel_adapt.txt:320</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a85eafce65164bf7b4bd902815d256796"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a85eafce65164bf7b4bd902815d256796">comprises</a></div><div class="ttdeci">&lt; HR &gt;&lt; HR &gt; section update_node_update Updating the node update data in refineable AlgebraicMeshes When discussing&lt; A HREF=&quot;../../../navier_stokes/algebraic_collapsible_channel/html/index.html&quot;&gt; the non FSI version of the collapsible channel problem&lt;/A &gt; we explained how c oomph lib s mesh adaptation procedures assign the node update data for newly created c AlgebraicNodes Recall that the node update data comprises</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00189">fsi_collapsible_channel_adapt.txt:189</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a1e702be7b8fb86940e0450ccbdcf2b37"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a1e702be7b8fb86940e0450ccbdcf2b37">representation</a></div><div class="ttdeci">mainpage Flow in a collapsible channel revisited enabling adaptivity in FSI problems In this document we re visit the collapsible channel problem yet again this time to demonstrate the use of spatial adaptivity in fluid structure interaction problems In such two additional issues have to be and then explain how these problems are addressed&lt; HR &gt;&lt; HR &gt; section history The assignment of positional history values for newly created nodes subsection what What is the problem We first discussed the use of spatial adaptivity for time dependent problems in the context of&lt; A HREF=&quot;../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html#spatial_adapt&quot;&gt; the unsteady heat equation&lt;/A &gt; We showed that whenever a new node is c oomph lib s mesh adaptation procedures automatically assign the nodal values and history an initial assignment for the newly created c Node s current and previous in which case the newly created c Node s current position is determined by the father element s c MacroElement representation This ensures that the mesh refinement process respects curvilinear domain as discussed&lt; A HREF=&quot;../../../poisson/fish_poisson2/html/index.html&quot;&gt; elsewhere&lt;/A &gt; The same strategy is used to over write the default assignment for a new c Node s previous based on the father element s c MacroElement representation</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00046">fsi_collapsible_channel_adapt.txt:46</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a49be44790d1fd707f63d0d1065196e8e"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a49be44790d1fd707f63d0d1065196e8e">xi_</a></div><div class="ttdeci">respectively The red arrow identifies the reference point for the newly created node VI whose reference coordinate f IV and i e the nodes in its father element I w textwidth update_single Illustration of the default update procedure for the node update IV and V in its father element the default assignment is not appropriate for nodes that are updated by and the values of the coordinate at which the reference points are located This is illustrated in the sketch below in which the sub c parametrised by their coordinates f f are shown in magenta Note that the reference points for nodes II and IV are located in one sub c those for nodes III and V are located in another I w textwidth update_compound Illustration of the revised update procedure for the node update f xi_</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00266">fsi_collapsible_channel_adapt.txt:266</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_acf8e02420cce3bbd3c38ba43dad60356"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#acf8e02420cce3bbd3c38ba43dad60356">III</a></div><div class="ttdeci">respectively The red arrow identifies the reference point for the newly created node VI whose reference coordinate f III</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00238">fsi_collapsible_channel_adapt.txt:238</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_ad8a01f7025d090c6b28ca935f5f71bc6"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#ad8a01f7025d090c6b28ca935f5f71bc6">is</a></div><div class="ttdeci">respectively The red arrow identifies the reference point for the newly created node VI whose reference coordinate f IV and i e the nodes in its father element I w textwidth update_single Illustration of the default update procedure for the node update IV and V in its father element the default assignment is not appropriate for nodes that are updated by and the values of the coordinate at which the reference points are located This is illustrated in the sketch below in which the sub c parametrised by their coordinates f f are shown in magenta Note that the reference points for nodes II and IV are located in one sub c those for nodes III and V are located in another I w textwidth update_compound Illustration of the revised update procedure for the node update f at which the reference point with Lagrangian coordinate f it should be implemented in the function c described is appropriate If it is</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00284">fsi_collapsible_channel_adapt.txt:284</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_ab920f261305869e1ee7c086c9bd2a03f"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#ab920f261305869e1ee7c086c9bd2a03f">variable</a></div><div class="ttdeci">Here is the actual implementation of this function We start by extracting the reference values that were already assigned by the default and the fractional height of the node in the cross channel respectively These values are interpolated correctly and do not have to be corrected The third reference value is the intrinsic coordinate of the reference point in its sub c GeomObject This needs to be re computed and we will assign the corrected value below The fourth reference value is the intrinsic coordinate of the reference point within the compound c MeshAsGeomObject We store this in a temporary variable</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00332">fsi_collapsible_channel_adapt.txt:332</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a9c6741891789e8156d85c39d4e3adaa7"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a9c6741891789e8156d85c39d4e3adaa7">GeomObject</a></div><div class="ttdeci">this is used if there is only a single node update as in the c AlgebraicCollapsibleChannelMesh n n A vector such as the intrinsic coordinates of reference points on the c GeomObjects n n By we assume that a newly created c AlgebraicNode is updated by the same node update function as the c AlgebraicNodes in its father element Therefore we pass the pointer to the c the node update function and the vector of pointers to c GeomObjects to the newly created c and interpolate the reference values between those stored at the c AlgebraicNodes in the father elements In most cases this provides a sensible default For it is hard to imagine a situation in which it would be sensible to update the position of newly created c AlgebraicNodes by a procedure that differs from that used for the surrounding c AlgebraicNodes that already existed in the father element since the reference values vary from node to in the c AlgebraicCollapsibleChannelMesh one of the reference values is the f x_1 f coordinate of the reference point on the fixed lower wall For the c AlgebraicNodes that already existed in the coarse base this value is given by the the c AlgebraicNodes f x_1 f coordinate in the undeformed mesh Interpolation of this value for the newly created c AlgebraicNodes results in an axially uniform subdivision of the refined elements The same procedure may be used to assign the reference value that represents the intrinsic coordinate of the reference point on the upper wall at least as long as the upper wall is only ever addressed as a compound c GeomObject</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00226">fsi_collapsible_channel_adapt.txt:226</a></div></div>
<div class="ttc" id="anamespaceoomph_html"><div class="ttname"><a href="namespaceoomph.html">oomph</a></div><div class="ttdef"><b>Definition:</b> <a href="annular__domain_8h_source.html#l00034">annular_domain.h:34</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_ad232b3d0fbed94e36f57f362fbbc6b30"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#ad232b3d0fbed94e36f57f362fbbc6b30">ID</a></div><div class="ttdeci">this is used if there is only a single node update as in the c AlgebraicCollapsibleChannelMesh n n A vector such as the intrinsic coordinates of reference points on the c GeomObjects n n By we assume that a newly created c AlgebraicNode is updated by the same node update function as the c AlgebraicNodes in its father element Therefore we pass the pointer to the c the node update function ID</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00200">fsi_collapsible_channel_adapt.txt:200</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a3da09cd6cac3e7c49c4902e8d97bf957"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a3da09cd6cac3e7c49c4902e8d97bf957">boundaries</a></div><div class="ttdeci">mainpage Flow in a collapsible channel revisited enabling adaptivity in FSI problems In this document we re visit the collapsible channel problem yet again this time to demonstrate the use of spatial adaptivity in fluid structure interaction problems In such two additional issues have to be and then explain how these problems are addressed&lt; HR &gt;&lt; HR &gt; section history The assignment of positional history values for newly created nodes subsection what What is the problem We first discussed the use of spatial adaptivity for time dependent problems in the context of&lt; A HREF=&quot;../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html#spatial_adapt&quot;&gt; the unsteady heat equation&lt;/A &gt; We showed that whenever a new node is c oomph lib s mesh adaptation procedures automatically assign the nodal values and history an initial assignment for the newly created c Node s current and previous in which case the newly created c Node s current position is determined by the father element s c MacroElement representation This ensures that the mesh refinement process respects curvilinear domain boundaries</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00042">fsi_collapsible_channel_adapt.txt:42</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_acda814bc7a06a83f836e4a6ed25afdd5"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#acda814bc7a06a83f836e4a6ed25afdd5">V</a></div><div class="ttdeci">V</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00235">fsi_collapsible_channel_adapt.txt:235</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_abfb18846a4072af6d25a14fedc27e1e2"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#abfb18846a4072af6d25a14fedc27e1e2">Wall_mesh_pt</a></div><div class="ttdeci">new OneDLagrangianMesh&lt; FSIHermiteBeamElement &gt;(Ncollapsible, Lcollapsible, undeformed_wall_pt) Wall_mesh_pt</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00127">fsi_collapsible_channel_adapt.txt:127</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a191d7a7c6c3749a8441de3ad55469b68"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a191d7a7c6c3749a8441de3ad55469b68">require</a></div><div class="ttdeci">endcode the use of the dummy c c Steady&lt; 0 &gt; was implied All time derivatives computed by this c TimeStepper evaluate to and the c TimeStepper does not require(or request) any storage for history values. This is a sensible default for problems that are either inherently steady(such as problems involving the Poisson equations</div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_af4e8340fd7aa46320380e59dd7582d0f"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#af4e8340fd7aa46320380e59dd7582d0f">AlgebraicNodes</a></div><div class="ttdeci">this is used if there is only a single node update as in the c AlgebraicCollapsibleChannelMesh n n A vector such as the intrinsic coordinates of reference points on the c GeomObjects n n By we assume that a newly created c AlgebraicNode is updated by the same node update function as the c AlgebraicNodes in its father element Therefore we pass the pointer to the c the node update function and the vector of pointers to c GeomObjects to the newly created c AlgebraicNodes</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00201">fsi_collapsible_channel_adapt.txt:201</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a3c3c37917f22777ec182f90eb76a7322"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a3c3c37917f22777ec182f90eb76a7322">addressed</a></div><div class="ttdeci">mainpage Flow in a collapsible channel revisited enabling adaptivity in FSI problems In this document we re visit the collapsible channel problem yet again this time to demonstrate the use of spatial adaptivity in fluid structure interaction problems In such two additional issues have to be addressed</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00012">fsi_collapsible_channel_adapt.txt:12</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_abf750b8569ba0accd1c8ea606f8bd508"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#abf750b8569ba0accd1c8ea606f8bd508">mesh</a></div><div class="ttdeci">this is used if there is only a single node update as in the c AlgebraicCollapsibleChannelMesh n n A vector such as the intrinsic coordinates of reference points on the c GeomObjects n n By we assume that a newly created c AlgebraicNode is updated by the same node update function as the c AlgebraicNodes in its father element Therefore we pass the pointer to the c the node update function and the vector of pointers to c GeomObjects to the newly created c and interpolate the reference values between those stored at the c AlgebraicNodes in the father elements In most cases this provides a sensible default For it is hard to imagine a situation in which it would be sensible to update the position of newly created c AlgebraicNodes by a procedure that differs from that used for the surrounding c AlgebraicNodes that already existed in the father element since the reference values vary from node to in the c AlgebraicCollapsibleChannelMesh one of the reference values is the f x_1 f coordinate of the reference point on the fixed lower wall For the c AlgebraicNodes that already existed in the coarse base mesh</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00218">fsi_collapsible_channel_adapt.txt:218</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_adac1ddaca32a41f261539626a2f293f7"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#adac1ddaca32a41f261539626a2f293f7">PDEs</a></div><div class="ttdeci">endcode the use of the dummy c c Steady&lt; 0 &gt; was implied All time derivatives computed by this c TimeStepper evaluate to and the c TimeStepper does not say or for steady versions of time dependent PDEs(such as the steady Navier-Stokes equations). In the present problem</div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_ad18eda8a8289a23f203d46f9cf3f0b26"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#ad18eda8a8289a23f203d46f9cf3f0b26">GeomObjects</a></div><div class="ttdeci">respectively The red arrow identifies the reference point for the newly created node VI whose reference coordinate f IV and i e the nodes in its father element I w textwidth update_single Illustration of the default update procedure for the node update IV and V in its father element the default assignment is not appropriate for nodes that are updated by and the values of the coordinate at which the reference points are located This is illustrated in the sketch below in which the sub c GeomObjects</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00253">fsi_collapsible_channel_adapt.txt:253</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a51364c60bb1aef0b40e03fc2ae5f8eda"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a51364c60bb1aef0b40e03fc2ae5f8eda">cc</a></div><div class="ttdeci">when we constructed the wall mesh in the non adaptive version of the driver code&lt; A HREF=&quot;../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc&quot;&gt; fsi_collapsible_channel cc</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00122">fsi_collapsible_channel_adapt.txt:122</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a7d27fa68953601fd272c90a700826f3c"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a7d27fa68953601fd272c90a700826f3c">estimator</a></div><div class="ttdeci">Here is the actual implementation of this function We start by extracting the reference values that were already assigned by the default and the fractional height of the node in the cross channel respectively These values are interpolated correctly and do not have to be corrected The third reference value is the intrinsic coordinate of the reference point in its sub c GeomObject This needs to be re computed and we will assign the corrected value below The fourth reference value is the intrinsic coordinate of the reference point within the compound c MeshAsGeomObject We store this in a temporary we extract vector of(pointers to the) \c GeomObjects involved in this node 's node-update from the node. \skipline Extract geometric objects \until Vector&lt; GeomObject * &gt; Now we use the \c GeomObject see below n n Explicitly specify the c Steady&lt; 2 &gt; timestepper for the wall as discussed above n n Create an error estimator</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00414">fsi_collapsible_channel_adapt.txt:414</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_af8cca7e5cfa060a6d8d8b0bdcfcb35c9"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#af8cca7e5cfa060a6d8d8b0bdcfcb35c9">default</a></div><div class="ttdeci">this is used if there is only a single node update as in the c AlgebraicCollapsibleChannelMesh n n A vector such as the intrinsic coordinates of reference points on the c GeomObjects n n By default</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00197">fsi_collapsible_channel_adapt.txt:197</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_ad0f97bbb898bc0419c63336bbbe3f61b"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#ad0f97bbb898bc0419c63336bbbe3f61b">values</a></div><div class="ttdeci">mainpage Flow in a collapsible channel revisited enabling adaptivity in FSI problems In this document we re visit the collapsible channel problem yet again this time to demonstrate the use of spatial adaptivity in fluid structure interaction problems In such two additional issues have to be and then explain how these problems are addressed&lt; HR &gt;&lt; HR &gt; section history The assignment of positional history values for newly created nodes subsection what What is the problem We first discussed the use of spatial adaptivity for time dependent problems in the context of&lt; A HREF=&quot;../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html#spatial_adapt&quot;&gt; the unsteady heat equation&lt;/A &gt; We showed that whenever a new node is c oomph lib s mesh adaptation procedures automatically assign the nodal values and history values(the auxiliary values that are used by the \c Node 's \c TimeStepper to approximate time-derivatives of the nodal values) for the new ly-created \c Node by interpolating between the corresponding values in the new \c Node 's father element. Similarly</div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_abe1a872647b7cfc1c732b57adef7d1b9"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#abe1a872647b7cfc1c732b57adef7d1b9">s</a></div><div class="ttdeci">respectively The red arrow identifies the reference point for the newly created node VI whose reference coordinate f IV and i e the nodes in its father element I w textwidth update_single Illustration of the default update procedure for the node update IV and V in its father element the default assignment is not appropriate for nodes that are updated by and the values of the coordinate at which the reference points are located This is illustrated in the sketch below in which the sub c parametrised by their coordinates f s</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00254">fsi_collapsible_channel_adapt.txt:254</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_ad4e59dc52f697b1186d8a14191c9c8c9"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#ad4e59dc52f697b1186d8a14191c9c8c9">created</a></div><div class="ttdeci">mainpage Flow in a collapsible channel revisited enabling adaptivity in FSI problems In this document we re visit the collapsible channel problem yet again this time to demonstrate the use of spatial adaptivity in fluid structure interaction problems In such two additional issues have to be and then explain how these problems are addressed&lt; HR &gt;&lt; HR &gt; section history The assignment of positional history values for newly created nodes subsection what What is the problem We first discussed the use of spatial adaptivity for time dependent problems in the context of&lt; A HREF=&quot;../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html#spatial_adapt&quot;&gt; the unsteady heat equation&lt;/A &gt; We showed that whenever a new node is created</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00025">fsi_collapsible_channel_adapt.txt:25</a></div></div>
<div class="ttc" id="afsi__collapsible__channel__adapt_8txt_html_a8777c08bd1fcdb23881e9032a32fe104"><div class="ttname"><a href="fsi__collapsible__channel__adapt_8txt.html#a8777c08bd1fcdb23881e9032a32fe104">Next</a></div><div class="ttdeci">Here is the actual implementation of this function We start by extracting the reference values that were already assigned by the default and the fractional height of the node in the cross channel respectively These values are interpolated correctly and do not have to be corrected The third reference value is the intrinsic coordinate of the reference point in its sub c GeomObject This needs to be re computed and we will assign the corrected value below The fourth reference value is the intrinsic coordinate of the reference point within the compound c MeshAsGeomObject We store this in a temporary we extract vector of(pointers to the) \c GeomObjects involved in this node 's node-update from the node. \skipline Extract geometric objects \until Vector&lt; GeomObject * &gt; Now we use the \c GeomObject see below n n Explicitly specify the c Steady&lt; 2 &gt; timestepper for the wall as discussed above n n Create an error specify the target errors for the and call the spatially adaptive Newton solver&lt; HR &gt; subsection before_and_after Actions before and after solve As in the&lt; A HREF=&quot;../../../navier_stokes/collapsible_channel/html/index.html&quot;&gt; non FSI we use the function c Problem::actions_before_adapt() to delete the applied traction elements before the mesh adaptation Next</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel__adapt_8txt_source.html#l00424">fsi_collapsible_channel_adapt.txt:424</a></div></div>

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Fri Jul 16 2021 19:46:23
        </div>
      </div>
    </footer>
</body>
</html>
