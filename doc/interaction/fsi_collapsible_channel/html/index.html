<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: A fluid-structure-interaction problem: Flow in a 2D collapsible channel</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">A fluid-structure-interaction problem: Flow in a 2D collapsible channel </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this document we discuss the solution of a standard fluid-structure interaction problem &ndash; finite-Reynolds-number flow in a 2D collapsible channel. We shall demonstrate that the driver code for this multi-physics problem is a straightforward combination of the driver codes for the two corresponding single-physics problems discussed earlier:</p><ul>
<li><b><a href="../../../navier_stokes/collapsible_channel/html/index.html">Flow in a 2D channel with prescribed wall motion:</a></b><br  />
<br  />
 In this single-physics problem, we represented the moving wall by a <code>GeomObject</code>, and created a <code>Domain</code> object to provide <br  />
 an analytical representation of the domain boundary. We discretised the Navier-Stokes equations with 2D Crouzeix-Raviart elements and updated their nodal positions (in response to the prescribed changes in the wall position) by their <code>MacroElement</code> representation.</li>
</ul>
<p>and</p><ul>
<li><b><a href="../../../beam/tensioned_string/html/index.html">The deformation of a pressure-loaded elastic beam:</a></b> <br  />
<br  />
 In this single-physics problem, we discretised the elastic beam with <code>HermiteBeamElements</code> and computed its deformation (determined by the positional degrees of freedom, stored at the <code>HermiteBeamElement's</code> <code>SolidNodes</code>) in response to the prescribed pressure load.</li>
</ul>
<hr  />
 <hr  />
<h1><a class="anchor" id="problem"></a>
The problem</h1>
<center> <table class="doxtable">
<tr>
<td><center> <b>Flow in a 2D collapsible channel </b> </center><p class="intertd">The figure below shows a sketch of the problem: Flow is driven by a prescribed pressure drop through a 2D channel of width <img class="formulaInl" alt="$ H^* $" src="form_0.png" width="16" height="10"/> and total length <img class="formulaInl" alt="$ L^*_{total} = L^*_{up} + L^*_{collapsible} + L^*_{down}. $" src="form_1.png" width="189" height="15"/> The upstream and downstream lengths of the channel are rigid, whereas the upper wall in the central section is an elastic membrane whose shape is parametrised by a Lagrangian coordinate, <img class="formulaInl" alt="$ \xi^* $" src="form_2.png" width="11" height="13"/> , so that the position vector to the moving wall is given by <img class="formulaInl" alt="$ {\bf R}_w^*(\xi^*,t^*) $" src="form_3.png" width="56" height="14"/> . The wall is loaded by the external pressure <img class="formulaInl" alt="$ p_{ext}^* $" src="form_4.png" width="21" height="14"/> and by the traction that the viscous fluid exerts on it. The components of the load vector <img class="formulaInl" alt="$ {\bf f}^* $" src="form_5.png" width="11" height="10"/> that acts on the wall are therefore given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ f^*_{i} = (p^* - p^*_{ext}) N_i - \mu \left( \frac{\partial u^*_i}{\partial x^*_j} + \frac{\partial u^*_j}{\partial x^*_i} \right) N_j \ \ \ \ \ \ \mbox{for $i=1,2$,} \]" src="form_6.png" width="311" height="39"/>
</p>
<p><br  />
 where <img class="formulaInl" alt="$ N_i \ (\mbox{\ for \ } i=1,2) $" src="form_7.png" width="94" height="14"/> are the components of the outer unit normal on the fluid domain.</p>
<div class="image">
<img src="collapsible_channel_sketch.gif" alt=""/>
<div class="caption">
Sketch of the problem. </div></div>
 <p class="intertd">We scale all lengths on the channel width, <img class="formulaInl" alt="$ H^* $" src="form_0.png" width="16" height="10"/> , use the average velocity through the undeformed channel, <img class="formulaInl" alt="$ U =P^*_{up} H^{*2}/(12 \mu L^*_{total}) $" src="form_8.png" width="133" height="16"/> , to scale the velocities, and use <img class="formulaInl" alt="$ H^{*}/U $" src="form_9.png" width="33" height="14"/> to non-dimensionalise time. Finally, the fluid pressure is non-dimensionalised on the viscous scale <img class="formulaInl" alt="$ p^{*} = p \mu U/H^{*}$" src="form_10.png" width="75" height="14"/>. (As usual, asterisks distinguish dimensional parameters from their non-dimensional equivalents.)</p>
<p class="intertd">With this non-dimensionalisation, the Navier-Stokes equations have the same form as in the <a href="../../../navier_stokes/collapsible_channel/html/index.html">earlier example with prescribed wall motion:</a> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ Re\left(St\frac{\partial u_i}{\partial t} + u_j\frac{\partial u_i}{\partial x_j}\right) = - \frac{\partial p}{\partial x_i} + \frac{\partial }{\partial x_j} \left( \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right) \ \ \ \ \ \ \ \ \ \ (1) \]" src="form_11.png" width="346" height="31"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial u_i}{\partial x_i} = 0, \ \ \ \ \ \ \ \ \ \ (2) \]" src="form_12.png" width="106" height="29"/>
</p>
<p> with <img class="formulaInl" alt="$ St=1 $" src="form_13.png" width="35" height="10"/>. As <a href="../../../navier_stokes/collapsible_channel/html/index.html">before</a>, the flow is subject to the following boundary and initial conditions:</p><ul>
<li>Initial condition: Poiseuille flow, i.e. <p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf u}(x_1,x_2,t=0) = {\bf u}_{Poiseuille}(x_1,x_2) = 6 \ x_2 \ (1-x_2) \ {\bf e}_1. \ \ \ \ \ \ \ \ \ \ (3) \]" src="form_14.png" width="358" height="14"/>
</p>
</li>
<li>Parallel inflow, <img class="formulaInl" alt="$ {\bf u} \cdot {\bf e}_2 = {\bf 0}, $" src="form_15.png" width="56" height="11"/> and an applied axial traction of <img class="formulaInl" alt="$ {\bf t} \cdot {\bf e}_1 = p_{up} = 12 \ L_{total} $" src="form_16.png" width="125" height="14"/> at the upstream end, <img class="formulaInl" alt="$ x_1=0$" src="form_17.png" width="36" height="11"/>.</li>
<li>Parallel, axially traction-free outflow at the downstream end, i.e. <img class="formulaInl" alt="$ {\bf u} \cdot {\bf e}_2 = {\bf 0} $" src="form_18.png" width="53" height="11"/> and <br  />
 <img class="formulaInl" alt="$ {\bf t} \cdot {\bf e}_1 = p_{down} = 0 $" src="form_19.png" width="98" height="11"/> at <img class="formulaInl" alt="$ x_1=L_{total}. $" src="form_20.png" width="64" height="13"/></li>
<li>No slip on all channel walls, i.e. <img class="formulaInl" alt="$ {\bf u} = {\bf 0} $" src="form_21.png" width="31" height="9"/> on the rigid walls and <p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf u} = \frac{\partial {\bf R}_w}{\partial t} \mbox{\ \ \ \ on the moving wall,} \ \ \ \ \ \ \ \ \ \ (4) \]" src="form_22.png" width="235" height="28"/>
</p>
 These boundary conditions are identical to those in the problem with prescribed wall motion, apart from the fact that in the present problem the wall motion, described by <img class="formulaInl" alt="$ {\bf R}_w(\xi, t), $" src="form_23.png" width="49" height="14"/> has to be determined as part of the solution.</li>
</ul>
<p class="endtd">We model the elastic membrane as a thin-walled elastic Kirchhoff-Love beam of wall thickness <img class="formulaInl" alt="$ h^* $" src="form_24.png" width="11" height="10"/> , subject to an axial (2nd Piola-Kirchhoff) pre-stress <img class="formulaInl" alt="$ \sigma^*_0. $" src="form_25.png" width="16" height="14"/> The beam' effective (1D) elastic modulus is given by <img class="formulaInl" alt="$ E_{eff} = E/(1-\nu^2), $" src="form_26.png" width="105" height="15"/> where <img class="formulaInl" alt="$ E $" src="form_27.png" width="10" height="9"/> and <img class="formulaInl" alt="$ \nu $" src="form_28.png" width="6" height="6"/> are its 3D Young's modulus and Poisson's ratio, respectively. The beam's deformation is governed by the principle of virtual displacements, discussed in detail <a href="../../../beam/tensioned_string/html/index.html">elsewhere.</a> As in the Navier-Stokes equations, we scale all lengths in the beam problem on the channel's width, <img class="formulaInl" alt="$ H^*. $" src="form_29.png" width="20" height="10"/> The non-dimensional position vector <img class="formulaInl" alt="$ {\bf r}_w(\xi) $" src="form_30.png" width="30" height="14"/> to the undeformed wall is then given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf r}_w(\xi) = \left( \begin{array}{c} L_{up} + \xi \\ 1 \end{array} \right) \ \ \ \ \ \ \mbox{where $\xi \in [0,L_{collapsible}].$} \ \ \ \ \ \ \ \ \ \ (5) \]" src="form_31.png" width="338" height="31"/>
</p>
<p> Our non-dimensionalisation of the principle of virtual displacements requires all stresses and tractions to be non-dimensionalised on the beam's (effective 1D) elastic modulus, <img class="formulaInl" alt="$ E_{eff} $" src="form_32.png" width="25" height="13"/> , therefore we define the non-dimensional external pressure as <img class="formulaInl" alt="$ p_{ext} = p_{ext}^{*}/E_{eff}. $" src="form_33.png" width="95" height="14"/> The non-dimensional load vector <img class="formulaInl" alt="$ {\bf f} = {\bf f}^{*}/E_{eff} $" src="form_34.png" width="66" height="14"/> that acts on the wall is then given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_i = - p_{ext} N_i + Q \left( p N_i - \left( \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right) N_j \right) \ \ \ \ \ \ \mbox{for $i=1,2,$} \]" src="form_35.png" width="338" height="31"/>
</p>
<p> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ Q = \frac{\mu U^*}{E_{eff} H^*_{tot}} \]" src="form_36.png" width="79" height="31"/>
</p>
<p> is the ratio of the fluid pressure scale, <img class="formulaInl" alt="$ \mu U/H^* $" src="form_37.png" width="40" height="14"/> , used to non-dimensionalise the Navier-Stokes equations, to the beam's effective elastic modulus, <img class="formulaInl" alt="$ E_{eff} $" src="form_32.png" width="25" height="13"/>. The parameter <img class="formulaInl" alt="$ Q $" src="form_38.png" width="10" height="13"/> therefore indicates the strength of the fluid-structure interaction. In particular, if <img class="formulaInl" alt="$ Q=0 $" src="form_39.png" width="33" height="13"/> the wall deformation is not affected by the fluid flow.   </p>
</td></tr>
</table>
<br  />
 </center><hr  />
 <hr  />
<h1><a class="anchor" id="reslt"></a>
Results</h1>
<p>The figure below shows a snapshot of the flow field, taken from <a href="../figures/fsi_taylor_hood_flow8.avi">the animation of the computational results</a>. The first four figures show (from top left to bottom right) "carpet plots" of the axial and transverse velocities, the axial component of the perturbation velocity <img class="formulaInl" alt="$ {\bf u} - {\bf u}_{Poiseuille} $" src="form_40.png" width="76" height="9"/> , and the pressure distribution. The 2D contour plot at the bottom of the figure shows a contour plot of the pressure and a few instantaneous streamlines.</p>
<p>The overall structure of the flow field is very similar to that observed in the corresponding <br  />
 <a href="../../../navier_stokes/collapsible_channel/html/index.html">problem with prescribed wall motion:</a> The wall oscillation generates a large-amplitude sloshing flow that is superimposed on the pressure-driven Poiseuille flow. At the instant shown in this figure, the wall is moving inwards. Consequently, the sloshing flow generated in the upstream (downstream) rigid sections is directed against (in the same) <br  />
 direction as that of the pressure-driven mean flow.</p>
<div class="image">
<img src="fsi_taylor_hood_flow.gif" alt=""/>
<div class="caption">
Snapshot from the animation of the flow field. </div></div>
 <p>In the present problem, the wall motion is, of course, not prescribed but determined as part of the overall solution. <a href="http://www.maths.man.ac.uk/~mheil/MATTHIAS/PDF/JensenHeil2003.pdf">Jensen &amp; Heil's (2003)</a> asymptotic analysis of the problem shows that the period of the oscillations is determined by the balance between fluid inertia and the elastic restoring forces. In certain parameter regimes (at sufficiently large Reynolds number), the wall can extract energy from the pressure-driven mean flow, causing the oscillations to grow in amplitude. In the present example, the Reynolds number is too small for this to happen and viscous dissipation causes the oscillations to decay, as shown in this plot.</p>
<div class="image">
<img src="trace_fsi_taylor_hood.gif" alt=""/>
<div class="caption">
Time-trace of the axial velocities at two control points in the upstream and downstream cross-sections, and the vertical position of a control point on the wall. </div></div>
 <hr  />
 <hr  />
<h1><a class="anchor" id="overview"></a>
Overview: How to solve fluid-structure interaction problems with oomph-lib</h1>
<p>Before attempting to solve a fluid-structure interaction problem, we generally recommend to first study the constituent single-physics problems in isolation, i.e.</p><ul>
<li>Discretise the solid mechanics problem with a suitable <code>SolidFiniteElement</code> (e.g. a <code>HermiteBeamElement</code>) and determine the wall deformation in response to a prescribed external load. If possible, choose a load that is vaguely "representative" of the loads expected in the actual fluid-structure interaction problem.</li>
<li>Discretise the fluid mechanics problem in a domain in which the deformation of the "elastic boundary" is described by a <code>GeomObject</code> that performs a prescribed motion. Choose a suitable node-update strategy to adjust the position of the fluid nodes in response to the (prescribed) motion of the "elastic boundary". (As demonstrated in many previous examples, a <code>Domain/MacroElement</code> - based node-update method is very easy to implement.) If possible, try to impose a wall motion that is "representative" of the type of wall motion expected in the actual fluid-structure interaction problem.</li>
</ul>
<p>Once the behaviour of the two isolated single-physics problems is sufficiently well understood (e.g. what spatial discretisations are required, etc.), combine the two single-physics problems to a fully-coupled problem. The coupling introduces two types of interactions that must be incorporated into the computational framework:</p><ol type="1">
<li>The position of the nodes in the fluid mesh depends on the wall shape. Since the wall shape is now determined by the degrees of freedom in the <code>SolidFiniteElements</code> that we use to discretise the wall, we must ensure that:<ol type="a">
<li>The node-update operations that we developed for problems with prescribed wall motion (in which the position of the curvilinear domain boundaries is determined by <code>GeomObjects</code>) also work for problems in which the curvilinear domain boundaries are represented by <code>SolidFiniteElements</code>.</li>
<li>The dependence of the residuals of the fluid elements on the solid-mechanics degrees of freedom that affect the positions of the fluid nodes (via the node-update operation) are taken into account when computing the fluid elements' Jacobian matrices. (See the discussion of the "shape derivatives" in the <a href="../../macro_element_free_boundary_poisson/html/index.html">"toy" free-boundary Poisson problem</a> for details.) <br  />
</li>
</ol>
</li>
<li>The <code>SolidFiniteElements</code> are not only loaded by the external load but also by the traction that the fluid exerts on them. When computing the residuals of the <code>SolidFiniteElements</code> we have to evaluate the combined load vector at the <code>SolidFiniteElement's</code> Gauss points. We therefore have to provide a lookup scheme that specifies:<ol type="a">
<li>which fluid element is adjacent to a given Gauss point in the <code>SolidFiniteElements</code>, and</li>
<li>which (fluid) degrees of freedom affect the fluid traction at that point.</li>
</ol>
</li>
</ol>
<p>The dependence of the residuals of the <code>SolidFiniteElements</code> on these (fluid) degrees of freedom must be taken into account when computing the <code>SolidFiniteElement's</code> Jacobian matrix.</p>
<p><code>oomph-lib</code> provides a number of high-level functions that allow the required lookup schemes to be generated completely automatically. In the following sections we shall provide a brief discussion of the methodology but we stress that the details are not particularly important for the "user". If you just want to "use" <code>oomph-lib's</code> fluid-structure interaction capabilities and don't care too much about the technical details, you may wish to skip the next few sections and continue with the <a class="el" href="index.html#driver_code">Overview of the driver code</a>, where we demonstrate that, apart from a few trivial modifications, the driver code for the fully-coupled fluid-structure interaction problem is a straightforward combination of the two single-physics driver codes.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="how_its_done"></a>
Brief discussion of the implementation</h1>
<h2><a class="anchor" id="mesh"></a>
MacroElement-based (fluid-)node updates in FSI problems</h2>
<h3><a class="anchor" id="shape_deriv"></a>
The shape derivatives</h3>
<p>When discussing our <a href="../../macro_element_free_boundary_poisson/html/index.html">"toy" free-boundary Poisson problem</a> we demonstrated how a "bulk" element's <code>MacroElement</code> - representation allows the efficient automatic evaluation of the "shape derivatives" &ndash; the derivatives of the "bulk" equations (here the Navier-Stokes equations) with respect to the <code>Data</code> values (here the nodal positions in the beam elements) that determine the shape of the domain boundary. The methodology discussed in the context of the "toy" problem may also be used for genuine fluid-structure interaction problems, such as the problem considered here, provided</p><ol type="1">
<li>A <code>MacroElement/Domain</code> - based Mesh is used to discretise the fluid domain.</li>
<li>The moving boundary is represented by a <code>GeomObject</code> whose member function <code>GeomObject::geom_data_pt(...)</code> provides access to its "geometric" <code>Data</code>, i.e. the <code>Data</code> that affects its shape.</li>
</ol>
<p>Condition 1 is satisfied as the <a href="../../../meshes/mesh_list/html/index.html#collapsible_channel"><code>CollapsibleChannelMesh</code></a> used for the simulation of the <a href="../../../navier_stokes/collapsible_channel/html/index.html">single-physics fluids problem with prescribed wall motion</a> employs the <code>CollapsibleChannelDomain</code> to perform the node update in response to changes in the domain boundary. Multiple inheritance may therefore be used to upgrade the existing <a href="../../../meshes/mesh_list/html/index.html#collapsible_channel"><code>CollapsibleChannelMesh</code></a> to a mesh that is derived from the <code>MacroElementNodeUpdateMesh</code> base class. The dependence of the residuals of the "bulk" (fluid) elements on the geometric <code>Data</code> that affects its nodal positions is automatically taken into account if the "bulk" (fluid) elements (of type <code>BULK_ELEMENT</code>, say) are "upgraded" to the "wrapped" class <code>MacroElementNodeUpdateElement&lt;BULK_ELEMENT&gt;</code>. We refer to the discussion of the <a href="../../macro_element_free_boundary_poisson/html/index.html">"toy" free-boundary Poisson problem</a> for details of this methodology.</p>
<h3><a class="anchor" id="wall_geom_object"></a>
Representing the wall mesh as a GeomObject</h3>
<p>What remains to be done is to represent the wall (discretised by the <code>SolidFiniteElements</code> contained in the wall mesh) as a <code>GeomObject</code>. For this purpose, <code>oomph-lib</code> provides the class</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MeshAsGeomObject : <span class="keyword">public</span> GeomObject</div>
</div><!-- fragment --><p>whose constructor takes a pointer to the <code>Mesh</code> that is to be represented as a <code>GeomObject</code>. The Lagrangian and Eulerian dimensions of the mesh are taken to be the dimension of elements and the dimension of the nodes, respectively. The conversion from <code>Mesh</code> into <code>GeomObject</code> only makes sense if the element is derived from a <code>FiniteElement</code>, itself a <code>GeomObject</code>, which has associated Lagrangian (local) and Eulerian coordinate systems. In our collapsible channel problem, the Lagrangian dimension is one because the wall is parametrised by a single intrinsic coordinate (the shape of the mesh's constituent elements is parametrised by a single local coordinate), and the Eulerian dimension is two because the nodes in the wall mesh have two Eulerian coordinates. Assuming that <code>Wall_mesh_pt</code> stores a pointer to the wall mesh, the code</p>
 <div class="fragment"><div class="line"> <span class="comment">// Build a geometric object (one Lagrangian, two Eulerian coordinates)</span></div>
<div class="line"> <span class="comment">// from the wall mesh</span></div>
<div class="line"> MeshAsGeomObject* wall_geom_object_pt=</div>
<div class="line">  <span class="keyword">new</span> MeshAsGeomObject(Wall_mesh_pt); </div>
</div><!-- fragment --><p> creates a <code>GeomObject</code> representation of the wall mesh that allows us to obtain the position of a material point on the wall (parametrised by its Lagrangian coordinate <img class="formulaInl" alt="$\xi $" src="form_41.png" width="8" height="13"/>) from the <code>GeomObject::position(...)</code> function. For instance, the following code computes the position vector <img class="formulaInl" alt="$ {\bf r} $" src="form_42.png" width="8" height="6"/> to the material point on the deformed wall, located at <img class="formulaInl" alt="$ \xi=0.5. $" src="form_43.png" width="43" height="13"/> </p><div class="fragment"><div class="line">Vector&lt;double&gt; xi(1);</div>
<div class="line">xi[0]=0.5;</div>
<div class="line">Vector&lt;double&gt; r(2);</div>
<div class="line">wall_geom_object-&gt;position(xi,r);</div>
</div><!-- fragment --><p>Here is a graphical illustration of the various representations of the domain boundary:</p>
<p><b>1. A "normal" GeomObject</b></p>
<p>In single-physics problems with prescribed boundary motion the domain boundary may be represented by a <code>GeomObject</code>. The <code>GeomObject</code> provides a parametrisation of its shape in terms of an intrinsic coordinate, <img class="formulaInl" alt="$ \zeta $" src="form_44.png" width="6" height="13"/> , as shown in this sketch:</p>
<div class="image">
<img src="wall_mesh_geometry_sketch1.gif" alt=""/>
<div class="caption">
A geometric object parametrised by an intrinsic coordinate. </div></div>
 <p>The function <code>GeomObject::position(zeta,r)</code> computes the position vector <code>r</code> to a point on the <code>GeomObject</code>, as identified by its intrinsic coordinate <code>zeta</code>.</p>
<p><b>2. A beam/shell structure</b></p>
<p>In beam/shell problems, the shape of the deformed structure is parametrised by its Lagrangian coordinate , <img class="formulaInl" alt="$\xi. $" src="form_45.png" width="10" height="13"/></p>
<div class="image">
<img src="wall_mesh_geometry_sketch2.gif" alt=""/>
<div class="caption">
A (continuous) beam structure, parametrised by a Lagrangian coordinate. </div></div>
 <p>Beam/shell structures may therefore act as <code>GeomObjects</code> if we interpret their Lagrangian coordinate, <img class="formulaInl" alt="$ \xi $" src="form_46.png" width="8" height="13"/> , as the <code>GeomObject's</code> intrinsic coordinate, <img class="formulaInl" alt="$ \zeta $" src="form_44.png" width="6" height="13"/>.</p>
<p><b>3. A discretised beam/shell structure</b></p>
<p>In an <code>oomph-lib</code> computation, the beam/shell structure will, of course, have been discretised by a number of <code>SolidFiniteElements</code>. The <code>MeshAsGeomObject</code> discussed above, is therefore a "compound" <code>GeomObject</code> that contains a number of sub-objects &ndash; the mesh's constituent <code>SolidFiniteElements</code>. Within the "compound" <code>GeomObject</code> each sub-object acts as a <code>GeomObject</code> in its own right &ndash; the shape of a <code>SolidFiniteElement</code> is parametrised by its local coordinate <code>s</code>.</p>
<div class="image">
<img src="wall_mesh_geometry_sketch3.gif" alt=""/>
<div class="caption">
A discretised beam structure. </div></div>
 <p>The <code>MeshAsGeomObject::position(...)</code> function therefore determines the position vector to the point labelled by the Lagrangian coordinate <img class="formulaInl" alt="$ \xi $" src="form_46.png" width="8" height="13"/> (i.e. the <code>GeomObject's</code> intrinsic coordinate, <img class="formulaInl" alt="$ \zeta $" src="form_44.png" width="6" height="13"/>) in a two-stage process: First it determines which of its constituent <code>SolidFiniteElements</code> "contains" the relevant material point (This is possible because the function <code>SolidFiniteElement::interpolated_xi(...)</code> provides access to the Lagrangian coordinate inside the element) and then uses the <code>SolidFiniteElement::interpolated_x(...)</code> function to determine the Eulerian coordinates of that point.</p>
<hr  />
<h2><a class="anchor" id="fsi_wall_elements"></a>
Applying the fluid-traction to the wall elements: FSIWallElements</h2>
<p>Next, we shall discuss how the fluid traction is added to the load terms in the wall equations. As mentioned above, the computation of the residuals of the wall equations requires the evaluation of the combined load vector at the Gauss points in the wall elements. Furthermore, the dependence of the residuals on those (fluid) degrees of freedom that affect the traction must be taken into account when computing the wall element's Jacobian matrix. Storage for the various lookup schemes required for such computations is provided in the virtual base class <code>FSIWallElement</code> whose inheritance structure is as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FSIWallElement : <span class="keyword">public</span> <span class="keyword">virtual</span> SolidFiniteElement, </div>
<div class="line">                       <span class="keyword">public</span> <span class="keyword">virtual</span> ElementWithExternalElement</div>
</div><!-- fragment --><p>The <code>FiniteElement</code> class inherits from <code>GeomObject</code> and by default the <code>GeomObject::position(...)</code> function calls the function <code>FiniteElement::interpolate_x</code>(..); in other words, the element's local coordinate is regarded as the intrinsic coordinate that parametrises its shape. Thus we already have a standard interface through which an <code>FSIWallElement</code> can be used to parametrise the shape of (part of) the domain boundary.</p>
<p>By inheriting from the <code>SolidFiniteElement</code> class, we establish that the shape of the <code>FSIWallElement</code> is determined by the positional <code>Data</code> stored at its constituent <code>SolidNodes</code>. Recall that this information is required during the computation of the shape derivatives of the fluid equations.</p>
<p>The <code>ElementWithExternalElement</code> class provides the generic storage and helper functions required to keep track of the external elements that are adjacent to Gauss points in any <code>FiniteElement</code>, see also the tutorial on <a href="../../../multi_physics/multi_domain_ref_b_convect/html/index.html">Boussinesq convection with a multi-domain approach. </a> In the <code>FSIWallElement</code>, it is the fluid elements that load the structure which are adjacent to the Gauss points. The various lookup schemes required to determine these fluid elements may be generated completely automatically by the helper function</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> FLUID_ELEMENT, <span class="keywordtype">unsigned</span> DIM_FLUID&gt;</div>
<div class="line"><span class="keywordtype">void</span> FSI_functions::setup_fluid_load_info_for_solid_elements(</div>
<div class="line">     Problem* problem_pt,</div>
<div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;boundary_in_fluid_mesh,</div>
<div class="line">     Mesh* <span class="keyword">const</span>&amp; fluid_mesh_pt,</div>
<div class="line">     Mesh* <span class="keyword">const</span>&amp; solid_mesh_pt);</div>
</div><!-- fragment --><p>which is defined in the namespace <code>FSI_functions</code>. The template parameters <code>FLUID_ELEMENT</code> and <code>DIM_FLUID</code> specify the type of the fluid element and its spatial (Eulerian) dimension, respectively. The arguments are the pointer to the problem, the number of the boundary in the fluid mesh adjacent to the elastic wall, and the pointers to the fluid and wall meshes. The function assumes that boundary coordinates have been set for the fluid nodes on the mesh boundary specified by the argument <code>boundary_in_fluid_mesh</code>, and that these boundary coordinates are consistent with the parametrisation of the wall mesh by its Lagrangian coordinate. (See <a href="../../../poisson/fish_poisson2/html/index.html#boundary_coords">the discussion of the mesh generation procedures for domains with curvilinear boundaries</a> for a more detailed discussion of boundary coordinates for nodes.)</p>
<p>The <code>FSIWallElement</code> provides the protected member function <code>FSIWallElement::fluid_load_vector(...)</code> which may be used in a specific <code>FSIWallElement</code> (such as the <code>FSIHermiteBeamElement</code>) to compute the fluid traction (on the solid mechanics stress scale), and to add it to any external load that may already be acting on the element. The conversion from the fluid to the solid non-dimensionalisation of the traction is performed automatically by multiplying the traction vector (on the fluid stress scale) obtained from the "adjacent" <code>FSIFluidElement</code> by the stress ratio <img class="formulaInl" alt="$ Q $" src="form_38.png" width="10" height="13"/> which has a default value of <img class="formulaInl" alt="$ Q=1. $" src="form_47.png" width="35" height="13"/> This default assignment may be overwritten by setting a pointer to a variable that specifies <img class="formulaInl" alt="$ Q $" src="form_38.png" width="10" height="13"/> by using the function <code>FSIWallElement::q_pt()</code>.</p>
<p>The class also overloads the <code>SolidFiniteElement::fill_in_contribution_to_jacobian(...)</code> function so that the derivatives of the residuals with respect to those unknowns that affect the fluid traction on the wall are included when computing the element's Jacobian matrix.</p>
<p>In the driver code, discussed below, we will discretise the wall with <code>FSHermiteBeamElements</code>, a class that is composed (by multiple inheritance) from the single-physics <code>HermiteBeamElement</code> and the <code>FSIWallElement</code> base class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FSIHermiteBeamElement : <span class="keyword">public</span> <span class="keyword">virtual</span> HermiteBeamElement, </div>
<div class="line">                              <span class="keyword">public</span> <span class="keyword">virtual</span> FSIWallElement</div>
</div><!-- fragment --><h3><a class="anchor" id="fsi_fluid_elements"></a>
Obtaining the fluid traction from "adjacent" fluid elements: FSIFluidElements</h3>
<p>Having provided a function that allows us to determine which fluid elements are located next to a given <code>FSIWallElement</code>, we have to define standard interfaces through which we can obtain the traction that the "adjacent" fluid element exerts onto the wall. Furthermore, we have to determine which unknowns affect the fluid traction to enable us to evaluate the derivatives of the wall residuals with respect to these unknowns. Interfaces for the relevant functions are provided in the base class <code>FSIFluidElement</code>, whose most important member function (for the purpose of the present discussion) is <code>FSIFluidElement::get_load(...)</code>. The purpose of this function is to compute the traction exerted by the <code>FSIFluidElement</code> onto the adjacent <code>FSIWallElement</code>, given the outer unit vector onto the <code>FSIFluidElement</code>. The <code>FSIFluidElement</code> class has two further pure virtual member functions whose role is to determine the unknowns (e.g. velocity and pressure values) that affect the fluid traction. For newly developed fluid elements these functions have to implemented on a case-by-case basis. However, all existing fluid elements in <code>oomph-lib</code> are already derived from the <code>FSIFluidElement</code> class and therefore provide a suitable implementation of these functions. It is therefore not necessary to explicitly "upgrade" <code>oomph-lib's</code> fluid elements before using them in FSI computations.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="driver_code"></a>
Overview of the driver code</h1>
<p>The driver code for the fully-coupled fluid-structure interaction problem is a straightforward combination of the two single-physics codes with a few trivial additional steps. The main steps in the problem setup are:</p><ol type="1">
<li>Create the wall mesh, using <code>FSIHermiteBeamElements</code> instead of <code>HermiteBeamElements</code>.</li>
<li><b>NEW:</b> Create a <code>GeomObject</code> representation of the wall mesh, using the <code>MeshAsGeomObject</code> class.</li>
<li>Create the fluid mesh, using elements of type <code>MacroElementNodeUpdateElement&lt;QCrouzeixRaviartElement&lt;2&gt;&gt;</code> instead of <code>QCrouzeixRaviartElement&lt;2&gt;</code>. Use the <code>MeshAsGeomObject</code> representation of the elastic wall, created in the previous step to represent the curvilinear domain boundary.</li>
<li>Build a mesh of traction elements that apply the prescribed-traction boundary condition at the inflow. Add all three meshes (fluid, solid and traction mesh) to the <code>Problem's</code> collection of sub-meshes and build the global mesh.</li>
<li>Pass the relevant function pointers (for Reynolds number, external loads, etc) to the various elements and apply the boundary conditions.</li>
<li><b>NEW:</b> Call the function <code>FSI_functions::setup_fluid_load_info_for_solid_elements(...)</code> to set up the lookup scheme that establishes which fluid elements affect the traction on the wall.</li>
<li>Set up the equation numbering scheme.</li>
<li>Done! .</li>
</ol>
<p>Most steps in this sequence are either identical to those in the corresponding single-physics codes, or require only trivial modifications. Each of the two new steps (2 and 6) can be implemented with a single line of code. Consequently, most of the driver code, discussed in detail below, contains verbatim copies of code segments from the respective single-physics codes.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="variables"></a>
Namespace for the global physical variables</h1>
<p>The namespace for the "global" physical parameters contains the same fluid parameters as in the <a href="../../../navier_stokes/collapsible_channel/html/index.html">collapsible channel problem with prescribed wall motion</a>: We define the Reynolds and Womersley numbers and the fluid pressure at the upstream end, and provide a function that specifies the applied traction at the inflow:</p>
 <div class="fragment"><div class="line"><span class="comment">//====start_of_physical_parameters=====================</span></div>
<div class="line"><span class="comment">/// Namespace for phyical parameters</span></div>
<div class="line"><span class="comment"></span><span class="comment">//======================================================</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceGlobal__Physical__Variables.html">Global_Physical_Variables</a></div>
<div class="line">{<span class="comment"></span></div>
<div class="line"><span class="comment"> /// Reynolds number</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#ab814e627d2eb5bc50318879d19ab16b9">Re</a>=50.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Womersley = Reynolds times Strouhal</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#a085ee4bf968ffdd01a41b8c41864f907">ReSt</a>=50.0;</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Default pressure on the left boundary</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#ae1a493695b7f4619af32f405b0b28861">P_up</a>=0.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Traction applied on the fluid at the left (inflow) boundary</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#a0de42ee6d39e85c77c16a04c3a05f7a2">prescribed_traction</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; t,</div>
<div class="line">                          <span class="keyword">const</span> Vector&lt;double&gt;&amp; x,</div>
<div class="line">                          <span class="keyword">const</span> Vector&lt;double&gt;&amp; n,</div>
<div class="line">                          Vector&lt;double&gt;&amp; traction)</div>
<div class="line"> {</div>
<div class="line">  traction.resize(2);</div>
<div class="line">  traction[0]=<a class="code" href="namespaceGlobal__Physical__Variables.html#ae1a493695b7f4619af32f405b0b28861">P_up</a>;</div>
<div class="line">  traction[1]=0.0;</div>
<div class="line"> </div>
<div class="line"> } <span class="comment">//end traction</span></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html">Global_Physical_Variables</a></div><div class="ttdoc">Namespace for phyical parameters.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00174">fsi_collapsible_channel.cc:175</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a085ee4bf968ffdd01a41b8c41864f907"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a085ee4bf968ffdd01a41b8c41864f907">Global_Physical_Variables::ReSt</a></div><div class="ttdeci">double ReSt</div><div class="ttdoc">Womersley = Reynolds times Strouhal.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00180">fsi_collapsible_channel.cc:180</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a0de42ee6d39e85c77c16a04c3a05f7a2"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a0de42ee6d39e85c77c16a04c3a05f7a2">Global_Physical_Variables::prescribed_traction</a></div><div class="ttdeci">void prescribed_traction(const double &amp;t, const Vector&lt; double &gt; &amp;x, const Vector&lt; double &gt; &amp;n, Vector&lt; double &gt; &amp;traction)</div><div class="ttdoc">Traction applied on the fluid at the left (inflow) boundary.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00186">fsi_collapsible_channel.cc:186</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_ab814e627d2eb5bc50318879d19ab16b9"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#ab814e627d2eb5bc50318879d19ab16b9">Global_Physical_Variables::Re</a></div><div class="ttdeci">double Re</div><div class="ttdoc">Reynolds number.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00177">fsi_collapsible_channel.cc:177</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_ae1a493695b7f4619af32f405b0b28861"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#ae1a493695b7f4619af32f405b0b28861">Global_Physical_Variables::P_up</a></div><div class="ttdeci">double P_up</div><div class="ttdoc">Default pressure on the left boundary.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00183">fsi_collapsible_channel.cc:183</a></div></div>
</div><!-- fragment --><p> Next we define the wall parameters (wall thickness, prestress and external pressure) and assign default values. Note that the function that specifies the load on the wall contains only the load due to the external pressure &ndash; the additional load due to the fluid traction will be added automatically by the <code>FSIWallElements</code>, using the lookup scheme set up by the function <code>FSI_functions::setup_fluid_load_info_for_solid_elements(...)</code> discussed earlier.</p>
<div class="fragment"><div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Non-dimensional wall thickness. As in Jensen &amp; Heil (2003) paper.</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#af6e07423e22c0991084d9a2f43727805">H</a>=1.0e-2;</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// 2nd Piola Kirchhoff pre-stress. As in Jensen &amp; Heil (2003) paper.</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#a417dc688a70c4f06ef0faed047068ba2">Sigma0</a>=1.0e3;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// External pressure</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#a0406c0cbd463d1df2458fe5de98a00eb">P_ext</a>=0.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Load function: Apply a constant external pressure to the wall.</span></div>
<div class="line"><span class="comment"> /// Note:  This is the load without the fluid contribution!</span></div>
<div class="line"><span class="comment"> /// Fluid load gets added on by FSIWallElement.</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#a321267e1efb30b5d586302509354fb07">load</a>(<span class="keyword">const</span> Vector&lt;double&gt;&amp; xi, <span class="keyword">const</span> Vector&lt;double&gt;&amp; x,</div>
<div class="line">           <span class="keyword">const</span> Vector&lt;double&gt;&amp; N, Vector&lt;double&gt;&amp; <a class="code" href="namespaceGlobal__Physical__Variables.html#a321267e1efb30b5d586302509354fb07">load</a>)</div>
<div class="line"> { </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;2;i++) </div>
<div class="line">   {</div>
<div class="line">    <a class="code" href="namespaceGlobal__Physical__Variables.html#a321267e1efb30b5d586302509354fb07">load</a>[i] = -<a class="code" href="namespaceGlobal__Physical__Variables.html#a0406c0cbd463d1df2458fe5de98a00eb">P_ext</a>*N[i];</div>
<div class="line">   }</div>
<div class="line"> } <span class="comment">//end of load</span></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a0406c0cbd463d1df2458fe5de98a00eb"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a0406c0cbd463d1df2458fe5de98a00eb">Global_Physical_Variables::P_ext</a></div><div class="ttdeci">double P_ext</div><div class="ttdoc">External pressure.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00204">fsi_collapsible_channel.cc:204</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a321267e1efb30b5d586302509354fb07"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a321267e1efb30b5d586302509354fb07">Global_Physical_Variables::load</a></div><div class="ttdeci">void load(const Vector&lt; double &gt; &amp;xi, const Vector&lt; double &gt; &amp;x, const Vector&lt; double &gt; &amp;N, Vector&lt; double &gt; &amp;load)</div><div class="ttdoc">Load function: Apply a constant external pressure to the wall. Note: This is the load without the flu...</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00209">fsi_collapsible_channel.cc:209</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a417dc688a70c4f06ef0faed047068ba2"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a417dc688a70c4f06ef0faed047068ba2">Global_Physical_Variables::Sigma0</a></div><div class="ttdeci">double Sigma0</div><div class="ttdoc">2nd Piola Kirchhoff pre-stress. As in Jensen &amp; Heil (2003) paper.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00201">fsi_collapsible_channel.cc:201</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_af6e07423e22c0991084d9a2f43727805"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#af6e07423e22c0991084d9a2f43727805">Global_Physical_Variables::H</a></div><div class="ttdeci">double H</div><div class="ttdoc">Non-dimensional wall thickness. As in Jensen &amp; Heil (2003) paper.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00198">fsi_collapsible_channel.cc:198</a></div></div>
</div><!-- fragment --><p> Finally, we define the interaction parameter <img class="formulaInl" alt="$ Q $" src="form_38.png" width="10" height="13"/> and give it a default value.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Fluid structure interaction parameter: Ratio of stresses used for</span></div>
<div class="line"><span class="comment"> /// non-dimensionalisation of fluid to solid stresses. </span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#a66cb7ecda9ba0cd72367dd697f154545">Q</a>=1.0e-5;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of namespace</span></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a66cb7ecda9ba0cd72367dd697f154545"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a66cb7ecda9ba0cd72367dd697f154545">Global_Physical_Variables::Q</a></div><div class="ttdeci">double Q</div><div class="ttdoc">Fluid structure interaction parameter: Ratio of stresses used for non-dimensionalisation of fluid to ...</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00221">fsi_collapsible_channel.cc:221</a></div></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="undeformed"></a>
The undeformed wall</h1>
<p>We represent the undeformed geometry of the elastic wall, defined by equation (5), as a <code>GeomObject</code>, specifying the <img class="formulaInl" alt="$ x $" src="form_48.png" width="8" height="6"/>-coordinate of its left end and its (constant) <img class="formulaInl" alt="$ y $" src="form_49.png" width="8" height="9"/>-coordinate as arguments to the constructor:</p>
 <div class="fragment"><div class="line"><span class="comment">//====start_of_underformed_wall============================================</span></div>
<div class="line"><span class="comment">/// Undeformed wall is a steady, straight 1D line in 2D space </span></div>
<div class="line"><span class="comment"></span><span class="comment">///  \f[ x = X_0 + \zeta \f]</span></div>
<div class="line"><span class="comment"></span><span class="comment">///  \f[ y = H \f]</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=========================================================================</span></div>
<div class="line"><span class="keyword">class </span><a class="code" href="classUndeformedWall.html">UndeformedWall</a> : <span class="keyword">public</span> GeomObject</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Constructor: arguments are the starting point and the height</span></div>
<div class="line"><span class="comment"> /// above y=0.</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classUndeformedWall.html#ad09cfdcd234be0ab47eb97a8a470602a">UndeformedWall</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; x0, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; h): GeomObject(1,2)</div>
<div class="line">  {</div>
<div class="line">   <a class="code" href="classUndeformedWall.html#a7ab875c46fef905df33eb47e0336581b">X0</a>=x0;</div>
<div class="line">   <a class="code" href="classUndeformedWall.html#a4525dbe0b5d2108ee51f16bee9af88ef">H</a>=h;</div>
<div class="line">  }</div>
<div class="ttc" id="aclassUndeformedWall_html"><div class="ttname"><a href="classUndeformedWall.html">UndeformedWall</a></div><div class="ttdoc">/////////////////////////////////////////////////////////////////////// /////////////////////////////...</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00096">fsi_collapsible_channel.cc:97</a></div></div>
<div class="ttc" id="aclassUndeformedWall_html_a4525dbe0b5d2108ee51f16bee9af88ef"><div class="ttname"><a href="classUndeformedWall.html#a4525dbe0b5d2108ee51f16bee9af88ef">UndeformedWall::H</a></div><div class="ttdeci">double H</div><div class="ttdoc">Height of the undeformed wall above y=0.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00161">fsi_collapsible_channel.cc:161</a></div></div>
<div class="ttc" id="aclassUndeformedWall_html_a7ab875c46fef905df33eb47e0336581b"><div class="ttname"><a href="classUndeformedWall.html#a7ab875c46fef905df33eb47e0336581b">UndeformedWall::X0</a></div><div class="ttdeci">double X0</div><div class="ttdoc">x position of the undeformed beam's left end.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00158">fsi_collapsible_channel.cc:158</a></div></div>
<div class="ttc" id="aclassUndeformedWall_html_ad09cfdcd234be0ab47eb97a8a470602a"><div class="ttname"><a href="classUndeformedWall.html#ad09cfdcd234be0ab47eb97a8a470602a">UndeformedWall::UndeformedWall</a></div><div class="ttdeci">UndeformedWall(const double &amp;x0, const double &amp;h)</div><div class="ttdoc">Constructor: arguments are the starting point and the height above y=0.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00103">fsi_collapsible_channel.cc:103</a></div></div>
</div><!-- fragment --><p> The two versions of the <code>position(...)</code> function are straightforward:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Position vector at Lagrangian coordinate zeta </span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> position(<span class="keyword">const</span> Vector&lt;double&gt;&amp; zeta, Vector&lt;double&gt;&amp; r)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">   <span class="comment">// Position Vector</span></div>
<div class="line">   r[0] = zeta[0]+X0;</div>
<div class="line">   r[1] = <a class="code" href="namespaceGlobal__Physical__Variables.html#af6e07423e22c0991084d9a2f43727805">H</a>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Parametrised position on object: r(zeta). Evaluated at</span></div>
<div class="line"><span class="comment"> /// previous timestep. t=0: current time; t&gt;0: previous</span></div>
<div class="line"><span class="comment"> /// timestep. Calls steady version.</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> position(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; t, <span class="keyword">const</span> Vector&lt;double&gt;&amp; zeta,</div>
<div class="line">               Vector&lt;double&gt;&amp; r)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">   <span class="comment">// Use the steady version</span></div>
<div class="line">   position(zeta,r);</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// end of position</span></div>
</div><!-- fragment --><p> Since the <code>GeomObject</code> is used to specify the undeformed shape of a <code>HermiteBeamElement</code>, the function <code>GeomObject::d2position(...)</code> must be implemented to define the beam's curvature in the undeformed configuration.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Posn vector and its  1st &amp; 2nd derivatives</span></div>
<div class="line"><span class="comment"> /// w.r.t. to coordinates:</span></div>
<div class="line"><span class="comment"> /// \f$ \frac{dR_i}{d \zeta_\alpha}\f$ = drdzeta(alpha,i). </span></div>
<div class="line"><span class="comment"> /// \f$ \frac{d^2R_i}{d \zeta_\alpha d \zeta_\beta}\f$ = </span></div>
<div class="line"><span class="comment"> /// ddrdzeta(alpha,beta,i). Evaluated at current time.</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> d2position(<span class="keyword">const</span> Vector&lt;double&gt;&amp; zeta,</div>
<div class="line">                 Vector&lt;double&gt;&amp; r,</div>
<div class="line">                 DenseMatrix&lt;double&gt; &amp;drdzeta,</div>
<div class="line">                 RankThreeTensor&lt;double&gt; &amp;ddrdzeta)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">   <span class="comment">// Position vector</span></div>
<div class="line">   r[0] = zeta[0]+X0;</div>
<div class="line">   r[1] = <a class="code" href="namespaceGlobal__Physical__Variables.html#af6e07423e22c0991084d9a2f43727805">H</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Tangent vector</span></div>
<div class="line">   drdzeta(0,0)=1.0;</div>
<div class="line">   drdzeta(0,1)=0.0;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Derivative of tangent vector</span></div>
<div class="line">   ddrdzeta(0,0,0)=0.0;</div>
<div class="line">   ddrdzeta(0,0,1)=0.0;</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// end of d2position</span></div>
</div><!-- fragment --><p> The private member data contains the two geometric parameters.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> private :</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// x position of the undeformed beam&#39;s left end. </span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> X0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Height of the undeformed wall above y=0.</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#af6e07423e22c0991084d9a2f43727805">H</a>;</div>
<div class="line"> </div>
<div class="line">}; <span class="comment">//end_of_undeformed_wall</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="main"></a>
The driver code</h1>
<p>As with most previous time-dependent codes, we use command line arguments to indicate if the code is run during <code>oomph-lib's</code> self-test procedures. If command line arguments are specified, we use a coarser discretisation and perform fewer timesteps. After storing the command line arguments, we choose the number of elements in the mesh, and set the lengths of the domain.</p>
 <div class="fragment"><div class="line"><span class="comment">//============start_of_main====================================================</span></div>
<div class="line"><span class="comment">/// Driver code for a collapsible channel problem with FSI.</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// Presence of command line arguments indicates validation run with </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// coarse resolution and small number of timesteps.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=============================================================================</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="fsi__collapsible__channel_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Store command line arguments</span></div>
<div class="line"> CommandLineArgs::setup(argc,argv);</div>
<div class="line">  </div>
<div class="line"> <span class="comment">// Reduction in resolution for validation run?</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> coarsening_factor=1;</div>
<div class="line"> <span class="keywordflow">if</span> (CommandLineArgs::Argc&gt;1)</div>
<div class="line">  {</div>
<div class="line">   coarsening_factor=4;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Number of elements in the domain</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nup=20/coarsening_factor;</div>
<div class="line"> <span class="keywordtype">unsigned</span> ncollapsible=40/coarsening_factor;</div>
<div class="line"> <span class="keywordtype">unsigned</span> ndown=40/coarsening_factor;</div>
<div class="line"> <span class="keywordtype">unsigned</span> ny=16/coarsening_factor;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Length of the domain</span></div>
<div class="line"> <span class="keywordtype">double</span> lup=5.0;</div>
<div class="line"> <span class="keywordtype">double</span> lcollapsible=10.0;</div>
<div class="line"> <span class="keywordtype">double</span> ldown=10.0;</div>
<div class="line"> <span class="keywordtype">double</span> ly=1.0;</div>
<div class="ttc" id="afsi__collapsible__channel_8cc_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="fsi__collapsible__channel_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdoc">Driver code for a collapsible channel problem with FSI. Presence of command line arguments indicates ...</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00811">fsi_collapsible_channel.cc:811</a></div></div>
</div><!-- fragment --><p> We assign values for the external pressure (on the wall stiffness scale) and for the upstream fluid pressure (on the fluid pressure scale). The latter is again chosen so that in the absence of any wall deformation, the applied pressure difference would drive steady Poiseuille flow through the channel.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Set external pressure (on the wall stiffness scale). </span></div>
<div class="line"> <a class="code" href="namespaceGlobal__Physical__Variables.html#a0406c0cbd463d1df2458fe5de98a00eb">Global_Physical_Variables::P_ext</a> = 1.0e-1;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Pressure on the left boundary: This is consistent with steady</span></div>
<div class="line"> <span class="comment">// Poiseuille flow</span></div>
<div class="line"> <a class="code" href="namespaceGlobal__Physical__Variables.html#ae1a493695b7f4619af32f405b0b28861">Global_Physical_Variables::P_up</a>=12.0*(lup+lcollapsible+ldown);</div>
</div><!-- fragment --><p> We build the problem with 2D quadrilateral Crouzeix-Raviart elements, "upgraded" to <code>MacroElementNodeUpdateElements</code>. This ensures that the "shape
derivatives" (the derivatives of the fluid residuals with respect to the solid mechanics degrees of freedom that affect the nodal positions in the fluid elements), are incorporated into the fluid elements' Jacobian matrices.</p>
<div class="fragment"><div class="line"> <span class="comment">// Build the problem with QCrouzeixRaviartElements</span></div>
<div class="line"> <a class="code" href="classFSICollapsibleChannelProblem.html">FSICollapsibleChannelProblem</a></div>
<div class="line">  &lt;MacroElementNodeUpdateElement&lt;QCrouzeixRaviartElement&lt;2&gt; &gt; &gt; </div>
<div class="line">  problem(nup, ncollapsible, ndown, ny, </div>
<div class="line">          lup, lcollapsible, ldown, ly);</div>
<div class="ttc" id="aclassFSICollapsibleChannelProblem_html"><div class="ttname"><a href="classFSICollapsibleChannelProblem.html">FSICollapsibleChannelProblem</a></div><div class="ttdoc">Problem class.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00233">fsi_collapsible_channel.cc:234</a></div></div>
</div><!-- fragment --><p> We choose the timestepping parameters before assigning the initial conditions. (Preliminary computations showed that the system performs oscillations with approximately <br  />
 unit period, so the chosen value for the timestep <code>dt</code> corresponds to a time-integration with about 40 timesteps per period.)</p>
<div class="fragment"><div class="line"> <span class="comment">// Timestep. Note: Preliminary runs indicate that the period of</span></div>
<div class="line"> <span class="comment">// the oscillation is about 1 so this gives us 40 steps per period.</span></div>
<div class="line"> <span class="keywordtype">double</span> dt=1.0/40.0; </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Initial time for the simulation</span></div>
<div class="line"> <span class="keywordtype">double</span> t_min=0.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Maximum time for simulation</span></div>
<div class="line"> <span class="keywordtype">double</span> t_max=3.5; </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Initialise timestep </span></div>
<div class="line"> problem.time_pt()-&gt;time()=t_min;</div>
<div class="line"> problem.initialise_dt(dt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Apply initial condition</span></div>
<div class="line"> problem.set_initial_condition();</div>
</div><!-- fragment --><p>Next we specify the output directory, open a trace file and document the initial conditions</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">//Set output directory</span></div>
<div class="line"> DocInfo doc_info;</div>
<div class="line"> doc_info.set_directory(<span class="stringliteral">&quot;RESLT&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Open a trace file </span></div>
<div class="line"> ofstream trace_file;</div>
<div class="line"> <span class="keywordtype">char</span> filename[100];   </div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/trace.dat&quot;</span>,doc_info.directory().c_str());</div>
<div class="line"> trace_file.open(filename);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output the initial solution</span></div>
<div class="line"> problem.doc_solution(doc_info, trace_file);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Increment step number</span></div>
<div class="line"> doc_info.number()++;</div>
</div><!-- fragment --><p> The timestepping loop is identical to that in <a href="../../../navier_stokes/collapsible_channel/html/index.html">the problem with prescribed wall motion:</a></p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Find number of timesteps (reduced for validation)</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nstep = unsigned((t_max-t_min)/dt);</div>
<div class="line"> <span class="keywordflow">if</span> (CommandLineArgs::Argc&gt;1)</div>
<div class="line">  {</div>
<div class="line">   nstep=3;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Timestepping loop</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> istep=0;istep&lt;nstep;istep++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Solve the problem</span></div>
<div class="line">   problem.unsteady_newton_solve(dt);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Outpt the solution</span></div>
<div class="line">   problem.doc_solution(doc_info, trace_file);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Step number</span></div>
<div class="line">   doc_info.number()++;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Close trace file.</span></div>
<div class="line"> trace_file.close();</div>
<div class="line"> </div>
<div class="line">}<span class="comment">//end of main</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="problemclass"></a>
The problem class</h1>
<p>The problem class is very similar to that used for the <a href="../../../navier_stokes/collapsible_channel/html/index.html">problem with prescribed wall motion</a>. We specify the type of the fluid element as a template parameter and pass the number of elements and the lengths of the domain to the constructor:</p>
 <div class="fragment"><div class="line"><span class="comment">//====start_of_problem_class==========================================</span></div>
<div class="line"><span class="comment">/// Problem class</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classFSICollapsibleChannelProblem.html">FSICollapsibleChannelProblem</a> : <span class="keyword">public</span> Problem</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> public :</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/// Constructor: The arguments are the number of elements and</span></div>
<div class="line"><span class="comment">/// the lengths of the domain.</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classFSICollapsibleChannelProblem.html#afe14ae0d2bdfc9a15969c9bdcd6e2512">FSICollapsibleChannelProblem</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; nup, </div>
<div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ncollapsible,</div>
<div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ndown,</div>
<div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ny,</div>
<div class="line">                       <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; lup,</div>
<div class="line">                       <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; lcollapsible, </div>
<div class="line">                       <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ldown,</div>
<div class="line">                       <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ly);</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Destructor (empty)</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classFSICollapsibleChannelProblem.html#abe33aaaae15ea3eb10885527a1d1ad9a">~FSICollapsibleChannelProblem</a>(){}</div>
<div class="ttc" id="aclassFSICollapsibleChannelProblem_html_abe33aaaae15ea3eb10885527a1d1ad9a"><div class="ttname"><a href="classFSICollapsibleChannelProblem.html#abe33aaaae15ea3eb10885527a1d1ad9a">FSICollapsibleChannelProblem::~FSICollapsibleChannelProblem</a></div><div class="ttdeci">~FSICollapsibleChannelProblem()</div><div class="ttdoc">Destructor (empty)</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00250">fsi_collapsible_channel.cc:250</a></div></div>
<div class="ttc" id="aclassFSICollapsibleChannelProblem_html_afe14ae0d2bdfc9a15969c9bdcd6e2512"><div class="ttname"><a href="classFSICollapsibleChannelProblem.html#afe14ae0d2bdfc9a15969c9bdcd6e2512">FSICollapsibleChannelProblem::FSICollapsibleChannelProblem</a></div><div class="ttdeci">FSICollapsibleChannelProblem(const unsigned &amp;nup, const unsigned &amp;ncollapsible, const unsigned &amp;ndown, const unsigned &amp;ny, const double &amp;lup, const double &amp;lcollapsible, const double &amp;ldown, const double &amp;ly)</div><div class="ttdoc">Constructor: The arguments are the number of elements and the lengths of the domain.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00378">fsi_collapsible_channel.cc:378</a></div></div>
</div><!-- fragment --><p> We provide access functions to the (pointers to) the fluid mesh, </p><div class="fragment"><div class="line"> <span class="comment">/// Access function for the specific bulk (fluid) mesh</span></div>
<div class="line"> MacroElementNodeUpdateCollapsibleChannelMesh&lt;ELEMENT&gt;* bulk_mesh_pt() </div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from pointer to the Mesh base class to the specific </span></div>
<div class="line">   <span class="comment">// element type that we&#39;re using here.</span></div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span></div>
<div class="line">    MacroElementNodeUpdateCollapsibleChannelMesh&lt;ELEMENT&gt;*<span class="keyword">&gt;</span></div>
<div class="line">    (Bulk_mesh_pt);</div>
<div class="line">  }</div>
</div><!-- fragment --><p> and the wall mesh:</p>
<div class="fragment"><div class="line"> <span class="comment">/// Access function for the wall mesh</span></div>
<div class="line"> OneDLagrangianMesh&lt;FSIHermiteBeamElement&gt;* wall_mesh_pt() </div>
<div class="line">  {</div>
<div class="line">   <span class="keywordflow">return</span> Wall_mesh_pt;</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// end of access to wall mesh</span></div>
</div><!-- fragment --><p>Unlike the <a href="../../../navier_stokes/collapsible_channel/html/index.html">problem with prescribed wall motion,</a> the FSI problem does not have any time-dependent boundary conditions, therefore the pure virtual functions <code>Problem::action_before_solve()</code> and <code>Problem::action_after_solve()</code> can remain empty, and the function <code>Problem::actions_before_implicit_timestep()</code> is not needed.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Update the problem specs before solve (empty) </span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> actions_before_newton_solve(){}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Update the problem after solve (empty)</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> actions_after_newton_solve(){}</div>
</div><!-- fragment --><p> However, since the wall displacement (which is determined as part of the solution!) affects the nodal positions in the fluid mesh via the <code>MacroElement/<code>Domain</code> -</code> based node-update, the position of the fluid nodes must be updated whenever the Newton solver updates the unknowns. This is precisely what the function <code>Problem::actions_before_newton_convergence_check()</code> is for; see <a href="../../../order_of_action_functions/html/index.html">the discussion of <code>oomph-lib's</code> various "action" functions</a> for more details.</p>
<div class="fragment"><div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Update before checking Newton convergence: Update the</span></div>
<div class="line"><span class="comment"> /// nodal positions in the fluid mesh in response to possible </span></div>
<div class="line"><span class="comment"> /// changes in the wall shape</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> actions_before_newton_convergence_check()</div>
<div class="line">  {</div>
<div class="line">   Bulk_mesh_pt-&gt;node_update();</div>
<div class="line">  }</div>
</div><!-- fragment --><p> The functions <code>doc_solution(...)</code> and <code>set_initial_condition()</code> do what they always do.</p>
<div class="fragment"><div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Doc the solution</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> doc_solution(DocInfo&amp; doc_info,ofstream&amp; trace_file);</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Apply initial conditions</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> set_initial_condition();</div>
</div><!-- fragment --><p> The private member function <code>create_traction_elements(...)</code> is used to attach the applied traction elements to the upstream end of the channel, exactly as in the <a href="../../../navier_stokes/collapsible_channel/html/index.html">problem with prescribed wall motion.</a></p>
<div class="fragment"><div class="line"> </div>
<div class="line">private : </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Create the prescribed traction elements on boundary b</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> create_traction_elements(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;b, </div>
<div class="line">                               Mesh* <span class="keyword">const</span> &amp;bulk_mesh_pt,</div>
<div class="line">                               Mesh* <span class="keyword">const</span> &amp;traction_mesh_pt);</div>
</div><!-- fragment --><p> The private member data stores the problem parameters,</p>
<div class="fragment"><div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Number of elements in the x direction in the upstream part of the channel</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">unsigned</span> Nup;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Number of elements in the x direction in the collapsible part of </span></div>
<div class="line"><span class="comment"> /// the channel</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">unsigned</span> Ncollapsible;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Number of elements in the x direction in the downstream part of the channel</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">unsigned</span> Ndown;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Number of elements across the channel</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">unsigned</span> Ny;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// x-length in the upstream part of the channel</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> Lup;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// x-length in the collapsible part of the channel</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> Lcollapsible;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// x-length in the downstream part of the channel</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> Ldown;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Transverse length</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> Ly;</div>
</div><!-- fragment --><p> the pointers to the fluid mesh,</p>
<div class="fragment"><div class="line"> <span class="comment">/// Pointer to the &quot;bulk&quot; mesh</span></div>
<div class="line"> MacroElementNodeUpdateCollapsibleChannelMesh&lt;ELEMENT&gt;* Bulk_mesh_pt;</div>
</div><!-- fragment --><p> the surface mesh that contains the applied-traction elements,</p>
<div class="fragment"><div class="line"> <span class="comment">/// Pointer to the &quot;surface&quot; mesh that applies the traction at the</span></div>
<div class="line"><span class="comment"> /// inflow</span></div>
<div class="line"><span class="comment"></span> Mesh* Applied_fluid_traction_mesh_pt; </div>
</div><!-- fragment --><p> and the wall mesh,</p>
<div class="fragment"><div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Pointer to the &quot;wall&quot; mesh</span></div>
<div class="line"><span class="comment"></span> OneDLagrangianMesh&lt;FSIHermiteBeamElement&gt;* Wall_mesh_pt; </div>
</div><!-- fragment --><p> as well as pointers to various control nodes</p>
<div class="fragment"><div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to the left control node</span></div>
<div class="line"><span class="comment"></span> Node* Left_node_pt;</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Pointer to right control node</span></div>
<div class="line"><span class="comment"></span> Node* Right_node_pt;</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Pointer to control node on the wall</span></div>
<div class="line"><span class="comment"></span> Node* Wall_node_pt;</div>
<div class="line"> </div>
<div class="line">};<span class="comment">//end of problem class</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="problemcontr"></a>
The problem constructor</h1>
<p>We copy the various mesh parameters to the Problem's private data</p>
 <div class="fragment"><div class="line"><span class="comment">//=====start_of_constructor======================================</span></div>
<div class="line"><span class="comment">/// Constructor for the collapsible channel problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//===============================================================</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><a class="code" href="classFSICollapsibleChannelProblem.html#afe14ae0d2bdfc9a15969c9bdcd6e2512">FSICollapsibleChannelProblem&lt;ELEMENT&gt;::FSICollapsibleChannelProblem</a>(</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; nup, </div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ncollapsible,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ndown,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ny,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; lup,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; lcollapsible, </div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ldown,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ly)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Store problem parameters</span></div>
<div class="line"> Nup=nup;</div>
<div class="line"> Ncollapsible=ncollapsible;</div>
<div class="line"> Ndown=ndown;</div>
<div class="line"> Ny=ny;</div>
<div class="line"> Lup=lup;</div>
<div class="line"> Lcollapsible=lcollapsible;</div>
<div class="line"> Ldown=ldown;</div>
<div class="line"> Ly=ly;</div>
</div><!-- fragment --><p> and increase the maximum value of the residual that is permitted during the Newton iteration to accommodate possible poor initial guesses for the solution. </p><div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Overwrite maximum allowed residual to accomodate bad initial guesses</span></div>
<div class="line"> Problem::Max_residuals=1000.0;</div>
</div><!-- fragment --><p>We construct a <code>BDF&lt;2&gt;</code> - timestepper for the time-integration of the fluid equations and add it to the Problem's collection of timesteppers:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Allocate the timestepper -- this constructs the Problem&#39;s </span></div>
<div class="line"> <span class="comment">// time object with a sufficient amount of storage to store the</span></div>
<div class="line"> <span class="comment">// previous timsteps. </span></div>
<div class="line"> add_time_stepper_pt(<span class="keyword">new</span> BDF&lt;2&gt;);</div>
</div><!-- fragment --><p> The wall mesh is built as in the corresponding <a href="../../../beam/tensioned_string/html/index.html">single-physics beam problem:</a> We create the <code>GeomObject</code> that describes the undeformed wall shape and construct the wall mesh, this time with <code>FSIHermiteBeamElements:</code> </p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Geometric object that represents the undeformed wall: </span></div>
<div class="line"> <span class="comment">// A straight line at height y=ly; starting at x=lup.</span></div>
<div class="line"> <a class="code" href="classUndeformedWall.html">UndeformedWall</a>* undeformed_wall_pt=<span class="keyword">new</span> <a class="code" href="classUndeformedWall.html">UndeformedWall</a>(lup,ly);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Create the &quot;wall&quot; mesh with FSI Hermite elements</span></div>
<div class="line"> Wall_mesh_pt = <span class="keyword">new</span> OneDLagrangianMesh&lt;FSIHermiteBeamElement&gt;</div>
<div class="line">  <span class="comment">//(2*Ncollapsible+5,Lcollapsible,undeformed_wall_pt);</span></div>
<div class="line">  (Ncollapsible,Lcollapsible,undeformed_wall_pt);</div>
</div><!-- fragment --><p> We note that even though the same number of fluid and beam elements are used to discretise the common boundary, the discretisation of the two domains is <b>not</b> matching as the shape of the domain boundary is represented by piecewise cubic Hermite polynomials within the beam elements, and by piecewise quadratic Lagrange polynomials within the fluid elements. Mathematically, this does not cause any problems as both representations converge to the same boundary shape as the meshes are refined further and further. We stress that <code>oomph-lib</code> does not even require the number of elements along the interface to match; see <a class="el" href="index.html#ex">Exercises</a> .</p>
<p>The <code>MacroElement/Domain</code> - based fluid-mesh update requires the wall shape (which is now parametrised by the wall mesh's constituent elements) to be represented by single <code>GeomObject</code>. We create the required "compound" <code>GeomObject</code> using the <code>MeshAsGeomObject</code> class:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build a geometric object (one Lagrangian, two Eulerian coordinates)</span></div>
<div class="line"> <span class="comment">// from the wall mesh</span></div>
<div class="line"> MeshAsGeomObject* wall_geom_object_pt=</div>
<div class="line">  <span class="keyword">new</span> MeshAsGeomObject(Wall_mesh_pt); </div>
</div><!-- fragment --><p> This "compound" <code>GeomObject</code> can now be used to build the fluid mesh, exactly as in <br  />
 <a href="../../../navier_stokes/collapsible_channel/html/index.html">the corresponding single-physics fluids problem.</a> (The <code>MacroElementNodeUpdateCollapsibleChannelMesh</code> is a trivial extension of the <code>CollapsibleChannelMesh</code> from which it is derived; see the discussion of the <a href="../../macro_element_free_boundary_poisson/html/index.html#mesh">"toy" free-boundary Poisson problem</a> for details.)</p>
<div class="fragment"><div class="line"> <span class="comment">//Build bulk (fluid) mesh</span></div>
<div class="line"> Bulk_mesh_pt = </div>
<div class="line">  <span class="keyword">new</span> MacroElementNodeUpdateCollapsibleChannelMesh&lt;ELEMENT&gt;</div>
<div class="line">  (nup, ncollapsible, ndown, ny,</div>
<div class="line">   lup, lcollapsible, ldown, ly,</div>
<div class="line">   wall_geom_object_pt,</div>
<div class="line">   time_stepper_pt());</div>
</div><!-- fragment --><p> As in <a href="../../../navier_stokes/collapsible_channel/html/index.html">the fluids problem with prescribed wall motion </a> we use a "boundary-layer squash function" to distribute the fluid elements non-uniformly across the channel so that more elements are located inside the thin Stokes layers that are likely to develop near the wall.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Set a non-trivial boundary-layer-squash function...</span></div>
<div class="line"> Bulk_mesh_pt-&gt;bl_squash_fct_pt() = &amp;<a class="code" href="namespaceBL__Squash.html#a0fdaf7661591150041b7102dbe578cdc">BL_Squash::squash_fct</a>; </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// ... and update the nodal positions accordingly</span></div>
<div class="line"> Bulk_mesh_pt-&gt;node_update();</div>
<div class="ttc" id="anamespaceBL__Squash_html_a0fdaf7661591150041b7102dbe578cdc"><div class="ttname"><a href="namespaceBL__Squash.html#a0fdaf7661591150041b7102dbe578cdc">BL_Squash::squash_fct</a></div><div class="ttdeci">double squash_fct(const double &amp;s)</div><div class="ttdoc">Mapping [0,1] -&gt; [0,1] that re-distributes nodal points across the channel width.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00059">fsi_collapsible_channel.cc:59</a></div></div>
</div><!-- fragment --><p> We create the sub-mesh that stores the applied traction elements and attach the elements to the upstream end of the channel. The three sub-meshes are then combined into the <code>Problem's</code> single global mesh.</p>
<div class="fragment"><div class="line"> <span class="comment">// Create &quot;surface mesh&quot; that will contain only the prescribed-traction </span></div>
<div class="line"> <span class="comment">// elements. The constructor just creates the mesh without</span></div>
<div class="line"> <span class="comment">// giving it any elements, nodes, etc.</span></div>
<div class="line"> Applied_fluid_traction_mesh_pt = <span class="keyword">new</span> Mesh;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create prescribed-traction elements from all elements that are </span></div>
<div class="line"> <span class="comment">// adjacent to boundary 5 (left boundary), but add them to a separate mesh.</span></div>
<div class="line"> create_traction_elements(5,Bulk_mesh_pt,Applied_fluid_traction_mesh_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Add the sub meshes to the problem</span></div>
<div class="line"> add_sub_mesh(Bulk_mesh_pt);</div>
<div class="line"> add_sub_mesh(Applied_fluid_traction_mesh_pt);</div>
<div class="line"> add_sub_mesh(Wall_mesh_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Combine all submeshes into a single Mesh</span></div>
<div class="line"> build_global_mesh();</div>
</div><!-- fragment --><p> We complete the build process for the fluid elements by passing the pointers to the relevant problem parameters to the elements,</p>
<div class="fragment"><div class="line">   </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Complete build of fluid mesh</span></div>
<div class="line"> <span class="comment">//----------------------------- </span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over the elements to set up element-specific </span></div>
<div class="line"> <span class="comment">// things that cannot be handled by constructor</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_element=Bulk_mesh_pt-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from GeneralisedElement to the present element</span></div>
<div class="line">   ELEMENT* el_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(Bulk_mesh_pt-&gt;element_pt(e));</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Set the Reynolds number</span></div>
<div class="line">   el_pt-&gt;re_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#ab814e627d2eb5bc50318879d19ab16b9">Global_Physical_Variables::Re</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set the Womersley number</span></div>
<div class="line">   el_pt-&gt;re_st_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a085ee4bf968ffdd01a41b8c41864f907">Global_Physical_Variables::ReSt</a>;</div>
<div class="line">   </div>
<div class="line">  } <span class="comment">// end loop over elements</span></div>
</div><!-- fragment --><p> then we apply the boundary conditions for the fluid velocities:</p><ul>
<li>both axial and transverse velocities are pinned along the bottom and the top boundaries (boundaries 0, 2, 3 and 4)</li>
<li>the transverse velocity is pinned along the in- and outflow (boundaries 1 and 5).</li>
</ul>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Apply boundary conditions for fluid</span></div>
<div class="line"> <span class="comment">//------------------------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Pin the velocity on the boundaries</span></div>
<div class="line"> <span class="comment">//x and y-velocities pinned along boundary 0 (bottom boundary) :</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> ibound=0; </div>
<div class="line"> <span class="keywordtype">unsigned</span> num_nod= bulk_mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">  {</div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;2;i++)</div>
<div class="line">    {</div>
<div class="line">     bulk_mesh_pt()-&gt;boundary_node_pt(ibound, inod)-&gt;pin(i);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line"> <span class="comment">//x and y-velocities pinned along boundaries 2, 3, 4 (top boundaries) :</span></div>
<div class="line"> <span class="keywordflow">for</span>(ibound=2;ibound&lt;5;ibound++)</div>
<div class="line">  { </div>
<div class="line">   num_nod= bulk_mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">    {</div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;2;i++)</div>
<div class="line">      {</div>
<div class="line">       bulk_mesh_pt()-&gt;boundary_node_pt(ibound, inod)-&gt;pin(i);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//y-velocity pinned along boundary 1 (right boundary):</span></div>
<div class="line"> ibound=1; </div>
<div class="line"> num_nod= bulk_mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">  {</div>
<div class="line">   bulk_mesh_pt()-&gt;boundary_node_pt(ibound, inod)-&gt;pin(1);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">//y-velocity pinned along boundary 5 (left boundary):</span></div>
<div class="line"> ibound=5; </div>
<div class="line"> num_nod= bulk_mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">  {</div>
<div class="line">   bulk_mesh_pt()-&gt;boundary_node_pt(ibound, inod)-&gt;pin(1);</div>
<div class="line">  }</div>
<div class="line"><span class="comment">//end of pin_velocity</span></div>
</div><!-- fragment --><p>The applied traction elements require a pointer to the prescribed traction function:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Complete build of applied traction elements</span></div>
<div class="line"> <span class="comment">//--------------------------------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over the traction elements to pass pointer to prescribed </span></div>
<div class="line"> <span class="comment">// traction function</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_el=Applied_fluid_traction_mesh_pt-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_el;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from GeneralisedElement to NavierStokes traction element</span></div>
<div class="line">   NavierStokesTractionElement&lt;ELEMENT&gt; *el_pt = </div>
<div class="line">    <span class="keyword">dynamic_cast&lt;</span> NavierStokesTractionElement&lt;ELEMENT&gt;*<span class="keyword">&gt;</span>(</div>
<div class="line">     Applied_fluid_traction_mesh_pt-&gt;element_pt(e));</div>
<div class="line">    </div>
<div class="line">   <span class="comment">// Set the pointer to the prescribed traction function</span></div>
<div class="line">   el_pt-&gt;traction_fct_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a0de42ee6d39e85c77c16a04c3a05f7a2">Global_Physical_Variables::prescribed_traction</a>;</div>
<div class="line">  }</div>
</div><!-- fragment --><p> The wall elements require pointers to the various problem parameters and the pointer to the <code>GeomObject</code> that defines the beam's undeformed shape. Depending on the relative orientation of the fluid and solid meshes, the normal vector used by the <code>FSIWallElement</code> to determine the traction exerted by the adjacent <code>FSIFluidElement</code> may either point into or out of the fluid domain. By default, it is assumed that the normal points into the fluid &ndash; in this case the traction computed by the adjacent <code>FSIFluidElement</code> is added to the external load that acts on the <code>FSIWallElement</code>. Evaluating the direction of the normal (e.g by plotting the vector obtained from <code>FSIHermiteBeamElement::get_normal(...)</code> ) in the present problem shows that the normal to the wall elements actually points out of the fluid domain, therefore the fluid traction acts in the opposite direction to that assumed in the original formulation. This may be rectified by setting the boolean flag <code>FSIHermiteBeamElement::normal_points_into_fluid()</code> to <code>false</code>.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Complete build of wall elements</span></div>
<div class="line"> <span class="comment">//--------------------------------</span></div>
<div class="line">  </div>
<div class="line"> <span class="comment">//Loop over the elements to set physical parameters etc.</span></div>
<div class="line"> n_element = wall_mesh_pt()-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast to the specific element type</span></div>
<div class="line">   FSIHermiteBeamElement *elem_pt = </div>
<div class="line">    <span class="keyword">dynamic_cast&lt;</span>FSIHermiteBeamElement*<span class="keyword">&gt;</span>(wall_mesh_pt()-&gt;element_pt(e));</div>
<div class="line">    </div>
<div class="line">   <span class="comment">// Set physical parameters for each element:</span></div>
<div class="line">   elem_pt-&gt;sigma0_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a417dc688a70c4f06ef0faed047068ba2">Global_Physical_Variables::Sigma0</a>;</div>
<div class="line">   elem_pt-&gt;h_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#af6e07423e22c0991084d9a2f43727805">Global_Physical_Variables::H</a>;</div>
<div class="line">    </div>
<div class="line">   <span class="comment">// Set the load vector for each element</span></div>
<div class="line">   elem_pt-&gt;load_vector_fct_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a321267e1efb30b5d586302509354fb07">Global_Physical_Variables::load</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Function that specifies the load ratios</span></div>
<div class="line">   elem_pt-&gt;q_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a66cb7ecda9ba0cd72367dd697f154545">Global_Physical_Variables::Q</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set the undeformed shape for each element</span></div>
<div class="line">   elem_pt-&gt;undeformed_beam_pt() = undeformed_wall_pt;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The normal on the wall elements as computed by the FSIHermiteElements</span></div>
<div class="line">   <span class="comment">// points away from the fluid rather than into the fluid (as assumed</span></div>
<div class="line">   <span class="comment">// by default)</span></div>
<div class="line">   elem_pt-&gt;set_normal_pointing_out_of_fluid();</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// end of loop over elements</span></div>
</div><!-- fragment --><p> Both ends of the beam are pinned:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Boundary conditions for wall mesh</span></div>
<div class="line"> <span class="comment">//----------------------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set the boundary conditions: Each end of the beam is fixed in space</span></div>
<div class="line"> <span class="comment">// Loop over the boundaries (ends of the beam)</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> b=0;b&lt;2;b++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Pin displacements in both x and y directions</span></div>
<div class="line">   wall_mesh_pt()-&gt;boundary_node_pt(b,0)-&gt;pin_position(0); </div>
<div class="line">   wall_mesh_pt()-&gt;boundary_node_pt(b,0)-&gt;pin_position(1);</div>
<div class="line">  }</div>
</div><!-- fragment --><p>We choose two fluid control nodes in the middle of the inflow and outflow cross-sections to document the velocities, and choose a central node in the wall mesh to document its displacement.</p>
<div class="fragment"><div class="line">  </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Choose control nodes</span></div>
<div class="line"> <span class="comment">//---------------------</span></div>
<div class="line">  </div>
<div class="line"> <span class="comment">// Left boundary</span></div>
<div class="line"> ibound=5; </div>
<div class="line"> num_nod= bulk_mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line"> <span class="keywordtype">unsigned</span> control_nod=num_nod/2;</div>
<div class="line"> Left_node_pt= bulk_mesh_pt()-&gt;boundary_node_pt(ibound, control_nod);</div>
<div class="line">  </div>
<div class="line"> <span class="comment">// Right boundary</span></div>
<div class="line"> ibound=1; </div>
<div class="line"> num_nod= bulk_mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line"> control_nod=num_nod/2;</div>
<div class="line"> Right_node_pt= bulk_mesh_pt()-&gt;boundary_node_pt(ibound, control_nod);</div>
<div class="line">  </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set the pointer to the control node on the wall</span></div>
<div class="line"> Wall_node_pt=wall_mesh_pt()-&gt;node_pt(Ncollapsible/2);</div>
</div><!-- fragment --><p> Finally, we set up the remaining fluid-structure interaction: The fluid nodes that are located on the moving wall remain attached to material particles on the wall. The no-slip condition (4) therefore implies that the fluid velocity at each of these nodes must be equal to the nodes' velocity. Hence the fluid velocity must be updated whenever a node update function changes the nodal position. This is done most easily by means of the auxiliary node update function &ndash; a function that is executed automatically whenever a node's <code>node_update()</code> function is called. To achieve this we pass a function pointer to the <code>FSI_functions::apply_no_slip_on_moving_wall()</code> function to the nodes on the fluid mesh's boundary 3:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Setup FSI</span></div>
<div class="line"> <span class="comment">//----------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// The velocity of the fluid nodes on the wall (fluid mesh boundary 3)</span></div>
<div class="line"> <span class="comment">// is set by the wall motion -- hence the no-slip condition must be</span></div>
<div class="line"> <span class="comment">// re-applied whenever a node update is performed for these nodes. </span></div>
<div class="line"> <span class="comment">// Such tasks may be performed automatically by the auxiliary node update </span></div>
<div class="line"> <span class="comment">// function specified by a function pointer:</span></div>
<div class="line"> ibound=3; </div>
<div class="line"> num_nod= bulk_mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">  {</div>
<div class="line">   bulk_mesh_pt()-&gt;boundary_node_pt(ibound, inod)-&gt;</div>
<div class="line">    set_auxiliary_node_update_fct_pt(</div>
<div class="line">     FSI_functions::apply_no_slip_on_moving_wall);</div>
<div class="line">  }</div>
</div><!-- fragment --><p> Next, the <code>FSIHermiteBeamElements</code> have to be "told" which fluid elements are located next to their Gauss points to allow them to work out the fluid traction. The required lookup tables are created by the function <code>FSI_functions::setup_fluid_load_info_for_solid_elements(...)</code>:</p>
<div class="fragment"><div class="line">  </div>
<div class="line">  </div>
<div class="line"> <span class="comment">// Work out which fluid dofs affect the residuals of the wall elements:</span></div>
<div class="line"> <span class="comment">// We pass the boundary between the fluid and solid meshes and </span></div>
<div class="line"> <span class="comment">// pointers to the meshes. The interaction boundary is boundary 3 of the </span></div>
<div class="line"> <span class="comment">// 2D fluid mesh.</span></div>
<div class="line"> FSI_functions::setup_fluid_load_info_for_solid_elements&lt;ELEMENT,2&gt;</div>
<div class="line">  (<span class="keyword">this</span>,3,Bulk_mesh_pt,Wall_mesh_pt);</div>
</div><!-- fragment --><p> Finally, we set up the equation numbering scheme.</p>
<div class="fragment"><div class="line">  </div>
<div class="line"> <span class="comment">// Setup equation numbering scheme</span></div>
<div class="line"> cout &lt;&lt;<span class="stringliteral">&quot;Number of equations: &quot;</span> &lt;&lt; assign_eqn_numbers() &lt;&lt; std::endl; </div>
<div class="line">  </div>
<div class="line"> </div>
<div class="line">}<span class="comment">//end of constructor</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<p> <br  />
</p>
<h1><a class="anchor" id="doc"></a>
Post processing</h1>
<p>The function <code>doc_solution(...)</code> outputs the velocity and wall displacement fields and records the time-trace of the axial velocity at the control nodes and the position of the wall's midpoint. The function <code>FSI_functions::doc_fsi(...)</code> is a helper function that can be used to document/validate the various FSI lookup schemes; see <a class="el" href="index.html#comments_and_ex">Comments and Exercises</a> for an illustration of their output.</p>
 <div class="fragment"><div class="line"><span class="comment">//====start_of_doc_solution===================================================</span></div>
<div class="line"><span class="comment">/// Doc the solution</span></div>
<div class="line"><span class="comment"></span><span class="comment">//============================================================================</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classFSICollapsibleChannelProblem.html#aff5cacbc8d81f6c1beda947085496462">FSICollapsibleChannelProblem&lt;ELEMENT&gt;:: doc_solution</a>(DocInfo&amp; doc_info, </div>
<div class="line">                                                       ofstream&amp; trace_file)</div>
<div class="line">{ </div>
<div class="ttc" id="aclassFSICollapsibleChannelProblem_html_aff5cacbc8d81f6c1beda947085496462"><div class="ttname"><a href="classFSICollapsibleChannelProblem.html#aff5cacbc8d81f6c1beda947085496462">FSICollapsibleChannelProblem::doc_solution</a></div><div class="ttdeci">void doc_solution(DocInfo &amp;doc_info, ofstream &amp;trace_file)</div><div class="ttdoc">Doc the solution.</div><div class="ttdef"><b>Definition:</b> <a href="fsi__collapsible__channel_8cc_source.html#l00668">fsi_collapsible_channel.cc:668</a></div></div>
<div class="line"> <span class="comment">// Doc fsi</span></div>
<div class="line">   FSI_functions::doc_fsi&lt;MacroElementNodeUpdateNode&gt;(Bulk_mesh_pt,Wall_mesh_pt,doc_info);</div>
<div class="line"> ofstream some_file;</div>
<div class="line"> <span class="keywordtype">char</span> filename[100];</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Number of plot points</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> npts;</div>
<div class="line"> npts=5; </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output fluid solution </span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/soln%i.dat&quot;</span>,doc_info.directory().c_str(),</div>
<div class="line">         doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> bulk_mesh_pt()-&gt;output(some_file,npts);</div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Document the wall shape</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/beam%i.dat&quot;</span>,doc_info.directory().c_str(),</div>
<div class="line">         doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> wall_mesh_pt()-&gt;output(some_file,npts);</div>
<div class="line"> some_file.close();</div>
<div class="line">   </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Write trace file </span></div>
<div class="line"> trace_file &lt;&lt; time_pt()-&gt;time() &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">            &lt;&lt; Wall_node_pt-&gt;x(1) &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">            &lt;&lt; Left_node_pt-&gt;value(0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">            &lt;&lt; Right_node_pt-&gt;value(0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">            &lt;&lt; <a class="code" href="namespaceGlobal__Physical__Variables.html#a0406c0cbd463d1df2458fe5de98a00eb">Global_Physical_Variables::P_ext</a>  &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div>
<div class="line">            &lt;&lt; std::endl; </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end_of_doc_solution</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="tractioncre"></a>
Creation of the traction elements</h1>
<p>This function is the same as the one used in <a href="../../../navier_stokes/collapsible_channel/html/index.html">the problem with prescribed wall motion</a>.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="IC"></a>
Applying the initial conditions</h1>
<p>This function is the same as the one used in <a href="../../../navier_stokes/collapsible_channel/html/index.html">the problem with prescribed wall motion</a>.</p>
<hr  />
 <hr  />
 <h1><a class="anchor" id="comments_and_ex"></a>
Comments and Exercises</h1>
<h2><a class="anchor" id="comments"></a>
Comments</h2>
<ul>
<li><b>Variables that affect the fluid traction are not just velocities and pressures!</b> <br  />
<br  />
 In the section <a class="el" href="index.html#fsi_wall_elements">Applying the fluid-traction to the wall elements: FSIWallElements</a> we briefly discussed how the function <code>FSI_functions::setup_fluid_load_info_for_solid_elements(...)</code> determines the variables that affect the fluid traction onto the <code>FSIWallElements</code>. For a Newtonian fluid, the components of the fluid traction vector (on the viscous scale) onto the wall is given by <p class="formulaDsp">
<img class="formulaDsp" alt="\[ t_i = -p N_i + \left(\frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right) N_j \mbox{ \ \ \ for $i=1,2[,3]$} \]" src="form_50.png" width="260" height="31"/>
</p>
 where <img class="formulaInl" alt="$ N_i \ (\mbox{for } i=1,2[,3]) $" src="form_51.png" width="104" height="14"/> are the components of the normal to the fluid domain, pointing into the fluid. This equation shows that the fluid traction is primarily affected by the velocity and pressure degrees of freedom in the fluid elements that are "adjacent" to a given <code>FSIWallElement</code>. <br  />
<br  />
 However, since the traction involves derivatives of the velocity, the traction is also affected by changes to the <br  />
 geometry of the fluid element. Therefore, the list of variables that affect the fluid traction must (and indeed does) include all those <code>Data</code> objects that are involved in the adjacent fluid elements' node update operations. <br  />
<br  />
 Here is an animation that illustrates these dependencies for a relatively coarse discretisation in which the collapsible section of the fluid mesh is discretised with 10 "vertical columns" of <code>QCrouzeixRaviartElement&lt;2&gt;</code> elements, while the wall is discretised with 22 <code>FSIHermiteBeamElements</code>, each of which contains 3 Gauss points. The animation shows the region of the fluid mesh close to the (strongly deformed) elastic wall. Each different frame illustrates the FSI lookup schemes for a different wall element.<ul>
<li>The position of the wall Gauss points are displayed by "gradient" markers while the corresponding points in the adjacent fluid elements (i.e. the points at which the fluid traction is computed) are displayed by "delta" markers. Since the fluid and solid discretisations are non-matching the points do not coincide exactly though they will continue to approach each other under further mesh refinement.</li>
<li>The coloured numbers indicate the number of values that affect the fluid traction on this <code>FSIWallElement:</code> <ul>
<li>The red numbers represent the number of nodal values at the nodes of the adjacent fluid element(s) that affect the traction: For a 2D Crouzeix-Raviart element, each fluid node stores two velocity degrees of freedom, both of which affect the traction. <br  />
</li>
<li>The blue numbers represent the number of internal <code>Data</code> values stored in an adjacent fluid element that affect the traction: In a 2D Crouzeix-Raviart element, each element stores three pressure values in its internal <code>Data</code> and all three pressure values affect the traction.</li>
<li>Finally, the green numbers indicate the number of <code>Data</code> values that are (potentially) involved in the node-update operation for the nodes in the adjacent fluid elements. Recall that during the <code>MacroElement</code> - based node-update we only refer to the wall via its representation as a <code>WallAsGeomObject</code>, i.e. as a "compound" <code>GeomObject</code>. The geometric <code>Data</code> of a compound <code>GeomObject</code> is given by the geometric <code>Data</code> of <em>all</em> its sub-objects. Therefore, the geometric <code>Data</code> of the <code>WallAsGeomObject</code> includes the positional <code>Data</code> of all <code>SolidNodes</code> stored in this mesh. In an <code>FSIHermiteBeamElement</code>, each <code>SolidNode</code> stores four values, representing the node's x- and y-positions and their derivatives with respect to the element's local coordinate.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="image">
<img src="crozier_raviart_fsi_macro.gif" alt=""/>
<div class="caption">
Animation of the Data values that affect the fluid traction that the adjacent fluid elements exert onto the various FSIHermiteBeamElements in the wall mesh. (The fluid elements are 2D Crouzeix-Raviart elements.) </div></div>
 <p>Here is the corresponding animation for a discretisation with 2D Taylor-Hood elements. These elements have no internal <code>Data</code> but the pressure degrees of freedom are stored at the fluid element's corner nodes: </p><div class="image">
<img src="taylor_hood_fsi_macro.gif" alt=""/>
<div class="caption">
Animation of the Data values that affect the fluid traction that the adjacent fluid elements exert onto the various FSIHermiteBeamElements in the wall mesh. (The fluid elements are 2D Taylor-Hood elements.) </div></div>
 <p>Finally, here is an animation that shows the (wall) degrees of freedom that affect the node-update of a given fluid node. The red square marker shows the fluid node; the green numbers show the number of the degrees of freedom at the <code>SolidNodes</code> that are involved that fluid node's node update. Again it is clear that the <code>MacroElement/Domain-based</code> node update procedure in which the wall mesh is represented by a compound <code>GeomObject</code> does not result in a sparse node-update procedure: Each <code>SolidNode</code> in the wall mesh is assumed to affect the position of all fluid nodes.</p>
<div class="image">
<img src="fsi_nodes.gif" alt=""/>
<div class="caption">
Animation of the Data values that affect the node update of the fluid nodes. </div></div>
 <hr  />
<ul>
<li><b>(In-)efficiency of the MacroElement-based node-update</b> <br  />
<br  />
 The animations shown above illustrate very graphically that the implementation of the fluid-structure interaction via <code>MacroElement/Domain</code> - based node updates does not lead to a particularly efficient algorithm. The current approach suffers from two main problems:<ol type="1">
<li>The fluid-node update is not sparse: Since we cannot distinguish between the various sub-objects in the "compound" <code>GeomObject</code>, we can do no better than assuming the worst-case scenario, namely that <em>all</em> positional degrees of freedom of <em>all</em> <code>SolidNodes</code> in the wall mesh potentially affect the nodal position in the fluid elements adjacent to the wall. Consequently, each <code>FSIHermiteBeamElement</code> in the wall mesh depends on all solid mechanics degrees of freedom in the wall mesh. As a result, the wall discretisation completely loses its sparsity!</li>
<li>When updating the position of the fluid nodes via the fluid element's <code>Domain/MacroElement</code> representation, we obtain the wall shape from the <code>GeomObject::position(...)</code> function of the "compound" <code>GeomObject</code>, using the wall's Lagrangian coordinate <img class="formulaInl" alt="$ \xi $" src="form_46.png" width="8" height="13"/> as the "compound" <code>GeomObject's</code> intrinsic coordinate. As discussed in the section <a class="el" href="index.html#wall_geom_object">Representing the wall mesh as a GeomObject</a>, this is a very costly operation, since we first have to determine which of the constituent <code>FSIHermiteBeamElements</code> "contains" the required Lagrangian coordinate, and then evaluate the Eulerian position of the relevant point in the element.</li>
</ol>
</li>
</ul>
<p>In <a href="../../../interaction/fsi_collapsible_channel_algebraic/html/index.html">the next example</a> we will demonstrate how the use of the algebraic node update procedure, described in <a href="../../../navier_stokes/algebraic_collapsible_channel/html/index.html">an earlier example</a>, allows us to avoid both problems, resulting in a much more efficient code.</p>
<hr  />
 <hr  />
<h2><a class="anchor" id="ex"></a>
Exercises</h2>
<ol type="1">
<li>Use the function <code>FSIHermiteBeamElement::get_normal(...)</code> to plot the unit normal vector to the wall and thus confirm that the value for <code>FSIHermiteBeamElement::normal_points_into_fluid()</code> is correct. [<b>Hint:</b> Another way to sanity-check that the correct value for this flag has been set is to change the velocity boundary conditions at the upstream end to a pure Dirichlet condition by prescribing the axial velocity profile. With Dirichlet conditions everywhere, one fluid pressure degree of freedom, <img class="formulaInl" alt="$ p_{fix} $" src="form_52.png" width="23" height="10"/> , say, can (indeed must!) then be assigned arbitrarily. Now set the inflow velocity to zero and increase the value of <img class="formulaInl" alt="$ p_{fix} $" src="form_52.png" width="23" height="10"/> from zero, say. If the wall collapses inwards as <img class="formulaInl" alt="$ p_{fix} $" src="form_52.png" width="23" height="10"/> is increased the direction of normal was chosen wrongly!]</li>
<li>In section <a class="el" href="index.html#fsi_wall_elements">Applying the fluid-traction to the wall elements: FSIWallElements</a> we mentioned that the function <code>FSI_functions::setup_fluid_load_info_for_solid_elements(...)</code> assumes that the fluid nodes on the FSI boundary store the boundary coordinate. Investigate what happens if this step is omitted, e.g. by commenting out the assignment of boundary coordinates with <code>Node::set_coordinates_on_boundary(...)</code> in <a href="../../../../src/meshes/collapsible_channel_mesh.template.cc">collapsible_channel_mesh.template.cc</a>.</li>
<li>In section <a class="el" href="index.html#undeformed">The undeformed wall</a> we mentioned that the function <code>GeomObject::d2position(...)</code> must be implemented for all <code>GeomObjects</code> that specify the undeformed shape of a beam element. Check what happens if this function is not implemented, e.g. by <br  />
 commenting out its definition in the <code><a class="el" href="classUndeformedWall.html" title="/////////////////////////////////////////////////////////////////////// /////////////////////////////...">UndeformedWall</a></code> class.</li>
<li>In section <a class="el" href="index.html#problemcontr">The problem constructor</a> we commented that <code>oomph-lib</code> does not require the discretisations of the fluid and solid meshes to match along the common boundary. Confirm this, e.g., by increasing the number of elements in the wall mesh. . <br  />
</li>
</ol>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory: <center> <a href="../../../../demo_drivers/interaction/fsi_collapsible_channel/">demo_drivers/interaction/fsi_collapsible_channel/ </a> </center></li>
<li>The driver code is: <center> <a href="../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc">demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc </a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:28:52
        </div>
      </div>
    </footer>
</body>
</html>
