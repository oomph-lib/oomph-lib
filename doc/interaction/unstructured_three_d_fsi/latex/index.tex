This tutorial demonstrates the use of unstructured meshes in 3D fluid-\/structure interaction problems. We combine two single-\/physics problems, namely
\begin{DoxyItemize}
\item \href{../../../solid/unstructured_three_d_solid/html/index.html}{\texttt{ Large deformations of an elastic 3D bifurcating tube, loaded by an internal pressure}} ~\newline
~\newline

\item \href{../../../navier_stokes/unstructured_three_d_fluid/html/index.html}{\texttt{ Flow through a rigid 3D bifurcating tube}}
\end{DoxyItemize}for which we have already created unstructured 3D meshes, using \href{http://www.wias-berlin.de/~si }{\texttt{ Hang Si\textquotesingle{}s}} open-\/source mesh generator \href{http://wias-berlin.de/software/tetgen//}{\texttt{ {\ttfamily tetgen} }}.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_the_problem}{}\doxysection{The problem}\label{index_the_problem}
The two figures below show a sketch of the problem. An applied pressure drop drives fluid through an elastic, bifurcating tube whose branches have approximately rectangular cross-\/sections. We solve this problem as a fully-\/coupled fluid-\/structure interaction problem in which the fluid provides the traction onto the solid whose deformation changes the fluid domain.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{problem_sketch_forward}
\doxyfigcaption{Sketch of the problem. }
\end{DoxyImage}


 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{problem_sketch_backward}
\doxyfigcaption{Sketch of the problem (reverse view). }
\end{DoxyImage}


As usual, we formulate the problem in non-\/dimensional form. For this purpose we non-\/dimensionalise all lengths on the half-\/width, $ W $, of the square inflow cross-\/section, and use the overall pressure drop, $ \Delta P^* = P_{in}^* - P_{out}^* $ to define the (viscous) velocity scale \[ {\cal U} = \frac{\Delta P^*\ W}{\mu}. \] With this choice the Reynolds number becomes \[ Re = \frac{\rho {\cal U} W }{\mu} = \frac{ \Delta P^* \rho W^2 }{\mu^2}, \] and we choose to drive the flow by a dimensionless pressure drop of $ \Delta P = 1. $ Using this non-\/dimensionalisation an increase in the Reynolds number may be interpreted as in increase in the applied (dimensional) pressure drop along the vessel. Note that all pressures are defined relative to an external pressure, which we set to zero.

We assume that the solid\textquotesingle{}s constitutive equation is given by {\ttfamily oomph-\/lib\textquotesingle{}s} generalised Hookean constitutive law and non-\/dimensionalise the solid-\/mechanics stresses and tractions with the Young\textquotesingle{}s modulus $ E $.

The FSI interaction parameter $ Q, $ which represents the ratio of the (viscous) fluid stress scale to the reference stress used to non-\/dimensionalise the solid stresses, is therefore given by \[ Q = \frac{\mu {\cal U}}{{\cal L} E} = \frac{\Delta P^*}{E} \ . \]

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_results}{}\doxysection{Results}\label{index_results}
The animation below illustrates the system\textquotesingle{}s behaviour in a parameter study in which we keep the Reynolds number fixed at $ Re=100 $ while increasing the FSI parameter $ Q $ in small increments. The increase in $ Q $ may be interpreted as a reduction in the tube\textquotesingle{}s stiffness and the animation shows clearly how this increases the flow-\/induced deformation\+: the upstream end bulges and the downstream end is compressed.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{unstructured_fluid}
\doxyfigcaption{Animation of the flow field (pressure contours and velocity vectors). }
\end{DoxyImage}


 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{unstructured_solid}
\doxyfigcaption{Animation of the wall deformation -\/-\/ the vectors indicate the fluid load. }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_overview_implementation}{}\doxysection{Overview of the implementation}\label{index_overview_implementation}
The general procedure described below is essentially the same as that discussed in the \href{../../unstructured_fsi/html/index.html}{\texttt{ two-\/dimensional unstructured FSI tutorial. }} The use of an unstructured mesh means that the most convenient node-\/update strategy for the fluid mesh is to treat it as a pseudo-\/elastic solid. Nonetheless, the majority of the steps described below are the same as for other fluid-\/structure-\/interaction problems.

We reiterate that an important prerequisite for the use of the automatic {\ttfamily FSI\+\_\+functions} is that each boundary between fluid and solid meshes must be parametrised by boundary coordinates. Moreover, the boundary-\/coordinate representations {\bfseries{ must }} be the same in both the fluid and solid meshes. This use of a continuous-\/coordinate representation of the boundaries means that the fluid and solid meshes do not need to match at the boundaries; see the section \mbox{\hyperlink{index_matching_fluid_and_solid}{Fluid and solid meshes do not have to be matching}}. Unfortunately, the construction of a global surface parametrisation of a general surface is a non-\/trivial problem. We side-\/step this problem by making use of the fact that any third-\/party tetrahedral mesh generator represents domain boundaries using a surface triangulation, or planar surface facets. As the mesh is imported into {\ttfamily oomph-\/lib}, each surface facet is treated as a separate boundary and given a unique boundary identifier. The surface parametrisation of each facet is then simply given by local coordinates of the plane; see \mbox{\hyperlink{index_boundary_coord}{How the boundary coordinates are generated}}. A consequence of this approach is that the physical boundaries will consist of several mesh \char`\"{}boundaries\char`\"{}, as already discussed in the single-\/physics problems.

Since the driver code, discussed in detail below, is somewhat lengthy (partly because of the large number of self-\/tests and diagnostics included), we provide a brief overview of the main steps required to solve this problem\+: ~\newline
~\newline

\begin{DoxyEnumerate}
\item Use the unstructured 3D mesh generator \href{http://wias-berlin.de/software/tetgen//}{\texttt{ {\ttfamily tetgen} }} to generate the solid mesh, using the procedure discussed in \href{../../../solid/unstructured_three_d_solid/html/index.html\#mesh}{\texttt{ another tutorial.}} ~\newline
~\newline

\item Use the same procedure to generate the fluid mesh, as discussed in \href{../../../navier_stokes/unstructured_three_d_fluid/html/index.html\#mesh}{\texttt{ the single-\/physics fluids tutorial.}} Make sure that the fluid mesh is derived from the {\ttfamily Solid\+Mesh} base class to allow the use of pseudo-\/elasticity to update the nodal positions in response to the deformation of the domain boundary. ~\newline
~\newline

\item Ensure that boundary coordinates are set up (consistently) on the FSI interface between the two meshes. For meshes derived from {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Tetgen\+Mesh} class, this may be done by calling the function {\ttfamily Tetgen\+Mesh\+::setup\+\_\+boundary\+\_\+coordinates()}; see the section \mbox{\hyperlink{index_boundary_coord}{How the boundary coordinates are generated}} for details. ~\newline
~\newline

\item Attach {\ttfamily FSISolid\+Traction\+Elements} to the faces of the \char`\"{}bulk\char`\"{} solid elements that are exposed to the fluid flow. These elements will apply the fluid traction to the solid. ~\newline
~\newline

\item Combine the {\ttfamily FSISolid\+Traction\+Elements} to a compound {\ttfamily Geom\+Object} that provides a continuous representation of the solid\textquotesingle{}s FSI boundary, required by the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} described below. ~\newline
~\newline

\item Attach {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} to the faces of the \char`\"{}bulk\char`\"{} fluid elements that are adjacent to the solid. These elements will employ Lagrange multipliers to deform the pseudo-\/solid fluid mesh so that its shape remains consistent with the motion of the solid\textquotesingle{}s FSI boundary (as described by the compound {\ttfamily Geom\+Object} created in the previous step). ~\newline
~\newline

\item Determine the \char`\"{}bulk\char`\"{} fluid elements that are adjacent to the integration points of the {\ttfamily FSISolid\+Traction\+Elements}, using the function {\ttfamily FSI\+\_\+functions\+::setup\+\_\+fluid\+\_\+load\+\_\+info\+\_\+for\+\_\+solid\+\_\+elements(...)}. ~\newline
~\newline

\end{DoxyEnumerate}In our experience, just as in two-\/dimensions, the most error-\/prone part of this procedure is the identification of the mesh boundaries. In particular, if the description of the FSI interface as viewed from the fluid and solid meshes is inconsistent, the automatic matching of the unstructured fluid and solid meshes will not work (see \mbox{\hyperlink{index_boundary_coord}{How the boundary coordinates are generated}} for details). For this reason, the driver code presented below generates a lot of output that can be used to identify and fix such problems. See also the section \mbox{\hyperlink{index_go_wrong}{What can go wrong?}} at the end of this tutorial.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_namespace}{}\doxysection{Problem Parameters}\label{index_namespace}
As usual we define the various problem parameters in a global namespace. We define the Reynolds number, $ Re $, and the FSI interaction parameter $ Q $.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=======start\_of\_namespace==========================================}}
\DoxyCodeLine{\textcolor{comment}{/// Global variables}}
\DoxyCodeLine{\textcolor{comment}{//================================================================}}
\DoxyCodeLine{\textcolor{keyword}{namespace }\mbox{\hyperlink{namespaceGlobal__Parameters}{Global\_Parameters}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Default Reynolds number}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobal__Parameters_a9d72e94a9305c6a310940a6a427ebe06}{Re}}=100.0; }
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Default FSI parameter}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Q}}=0.0;}

\end{DoxyCodeInclude}
 We provide a pointer to the constitutive equation for the solid. For simplicity, the same constitutive equation will also be used for the (pseudo-\/)solid elements that determine the deformation of the fluid mesh. In general, of course, a different constitutive equation can (and probably should) be used to control the mesh motion.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to constitutive law}}
\DoxyCodeLine{\textcolor{comment}{} ConstitutiveLaw* \mbox{\hyperlink{namespaceGlobal__Parameters_adbd1f040f375c96fe56b3f475f7dbec2}{Constitutive\_law\_pt}}=0;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Poisson's ratio for generalised Hookean constitutive equation}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobal__Parameters_a20fccdcfa2c15ad8b951b9ada3bb1661}{Nu}}=0.3;}

\end{DoxyCodeInclude}
 Finally, we define the tractions that act on the fluid at the in-\/ and outflow cross-\/sections. We enforce the non-\/dimensional pressure drop of $ \Delta P = 1$ (on the viscous scale) by setting $ P_{in} = -P_{out}=0.5 $, thus pressurising the tube\textquotesingle{}s upstream end while applying an equal and opposite \char`\"{}suction\char`\"{} downstream. (Note that in the ~\newline
 \href{../../../navier_stokes/unstructured_three_d_fluid/html/index.html}{\texttt{ corresponding single-\/physics fluids problem}} the actual pressure values were irrelevant because the vessel walls were rigid. In the FSI problem considered here it obviously makes a big difference if the fluid pressure is positive or negative because the external reference pressure is set to zero.)


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Fluid pressure on inflow boundary}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobal__Parameters_a05b26d00935600b5e0149872844f224c}{P\_in}}=0.5;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Applied traction on fluid at the inflow boundary}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespaceGlobal__Parameters_af7faf65214ed9ead637f7c208addb095}{prescribed\_inflow\_traction}}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}\& t,}
\DoxyCodeLine{                                 \textcolor{keyword}{const} Vector<double>\& x,}
\DoxyCodeLine{                                 \textcolor{keyword}{const} Vector<double>\& n,}
\DoxyCodeLine{                                 Vector<double>\& traction)}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  traction[0]=0.0;}
\DoxyCodeLine{  traction[1]=0.0;}
\DoxyCodeLine{  traction[2]=\mbox{\hyperlink{namespaceGlobal__Parameters_a05b26d00935600b5e0149872844f224c}{P\_in}};}
\DoxyCodeLine{ \} }
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Fluid pressure on outflow boundary}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobal__Parameters_ac680ed856897793d54c9c867da19169c}{P\_out}}=-\/0.5; }
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Applied traction on fluid at the inflow boundary}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespaceGlobal__Parameters_a83155358b144cff7e29ecb6b209a2d3e}{prescribed\_outflow\_traction}}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}\& t,}
\DoxyCodeLine{                                  \textcolor{keyword}{const} Vector<double>\& x,}
\DoxyCodeLine{                                  \textcolor{keyword}{const} Vector<double>\& n,}
\DoxyCodeLine{                                  Vector<double>\& traction)}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  traction[0]=0.0;}
\DoxyCodeLine{  traction[1]=0.0;}
\DoxyCodeLine{  traction[2]=-\/\mbox{\hyperlink{namespaceGlobal__Parameters_ac680ed856897793d54c9c867da19169c}{P\_out}};}
\DoxyCodeLine{ \} }
\DoxyCodeLine{}
\DoxyCodeLine{ }
\DoxyCodeLine{\} \textcolor{comment}{//end\_of\_namespace}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_mesh_code}{}\doxysection{Creating the meshes}\label{index_mesh_code}
\hypertarget{index_solid_mesh}{}\doxysubsection{The solid mesh}\label{index_solid_mesh}
Following the procedure discussed in the \href{../../../solid/unstructured_three_d_solid/html/index.html}{\texttt{ single-\/physics solid mechanics problem}} we create the mesh for the elastic tube using multiple inheritance from {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Tetgen\+Mesh} and the {\ttfamily Solid\+Mesh} base class.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==========start\_solid\_mesh===============================================}}
\DoxyCodeLine{\textcolor{comment}{/// Tetgen-\/based mesh upgraded to become a solid mesh}}
\DoxyCodeLine{\textcolor{comment}{//=========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{classMySolidTetgenMesh}{MySolidTetgenMesh}} : \textcolor{keyword}{public} \textcolor{keyword}{virtual} TetgenMesh<ELEMENT>, }
\DoxyCodeLine{                       \textcolor{keyword}{public} \textcolor{keyword}{virtual} SolidMesh }
\DoxyCodeLine{\{}

\end{DoxyCodeInclude}
 As before, we set the Lagrangian coordinates to the current nodal positions to make the initial configuration stress-\/free. Next, we identify the elements next to the various boundaries (\href{../../../solid/unstructured_three_d_solid/html/index.html}{\texttt{ recall }} that the domain boundaries are specified in the tetgen {\ttfamily $\ast$.poly} file), and set up the boundary coordinates. Adopting our usual state of continuous paranoia, we document these elements to facilitate debugging; see the section \mbox{\hyperlink{index_boundary_coord}{How the boundary coordinates are generated}} for details.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Constructor: }}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classMySolidTetgenMesh}{MySolidTetgenMesh}}(\textcolor{keyword}{const} std::string\& node\_file\_name,}
\DoxyCodeLine{                \textcolor{keyword}{const} std::string\& element\_file\_name,}
\DoxyCodeLine{                \textcolor{keyword}{const} std::string\& face\_file\_name,}
\DoxyCodeLine{                TimeStepper* time\_stepper\_pt=}
\DoxyCodeLine{                \&Mesh::Default\_TimeStepper) : }
\DoxyCodeLine{  TetgenMesh<ELEMENT>(node\_file\_name, element\_file\_name,}
\DoxyCodeLine{                      face\_file\_name, time\_stepper\_pt)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{//Assign the Lagrangian coordinates}}
\DoxyCodeLine{   set\_lagrangian\_nodal\_coordinates();}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Find elements next to boundaries}}
\DoxyCodeLine{   setup\_boundary\_element\_info();}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Setup boundary coordinates for all boundaries}}
\DoxyCodeLine{   \textcolor{keywordtype}{char} filename[100];}
\DoxyCodeLine{   ofstream some\_file;}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} nb=this-\/>nboundary();}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} b=0;b<nb;b++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     sprintf(filename,\textcolor{stringliteral}{"{}RESLT/solid\_boundary\_test\%i.dat"{}},b);}
\DoxyCodeLine{     some\_file.open(filename);}
\DoxyCodeLine{     this-\/>\textcolor{keyword}{template} setup\_boundary\_coordinates<ELEMENT>(b,some\_file);}
\DoxyCodeLine{     some\_file.close();}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Empty Destructor}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keyword}{virtual} \mbox{\hyperlink{classMySolidTetgenMesh}{\string~MySolidTetgenMesh}}() \{ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\};}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
\hypertarget{index_fluid_mesh}{}\doxysubsection{The fluid mesh}\label{index_fluid_mesh}
The creation of the fluid mesh follows the same process but uses the mesh created for the ~\newline
 \href{../../../navier_stokes/unstructured_three_d_fluid/html/index.html}{\texttt{ single-\/physics fluids problem.}} The use of multiple inheritance from the {\ttfamily Tetgen\+Mesh} and {\ttfamily Solid\+Mesh} base classes is required to use pseudo-\/solid node-\/update techniques to move the fluid nodes in response to changes in the domain boundary. We refer to the \href{../../../navier_stokes/unstructured_three_d_fluid/html/index.html}{\texttt{ fluids tutorial}} for a discussion of the {\ttfamily split\+\_\+corner\+\_\+elements} flag.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==============start\_fluid\_mesh===========================================}}
\DoxyCodeLine{\textcolor{comment}{/// Tetgen-\/based mesh upgraded to become a (pseudo-\/) solid mesh}}
\DoxyCodeLine{\textcolor{comment}{//=========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{classFluidTetMesh}{FluidTetMesh}} : \textcolor{keyword}{public} \textcolor{keyword}{virtual} TetgenMesh<ELEMENT>,}
\DoxyCodeLine{                     \textcolor{keyword}{public} \textcolor{keyword}{virtual} SolidMesh }
\DoxyCodeLine{\{}
\DoxyCodeLine{ }
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Constructor: }}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classFluidTetMesh_a5f8ea145d68623198abc97209a0491a6}{FluidTetMesh}}(\textcolor{keyword}{const} std::string\& node\_file\_name,}
\DoxyCodeLine{              \textcolor{keyword}{const} std::string\& element\_file\_name,}
\DoxyCodeLine{              \textcolor{keyword}{const} std::string\& face\_file\_name,}
\DoxyCodeLine{              \textcolor{keyword}{const} \textcolor{keywordtype}{bool}\& split\_corner\_elements,}
\DoxyCodeLine{              TimeStepper* time\_stepper\_pt=}
\DoxyCodeLine{              \&Mesh::Default\_TimeStepper) : }
\DoxyCodeLine{  TetgenMesh<ELEMENT>(node\_file\_name, element\_file\_name,}
\DoxyCodeLine{                      face\_file\_name, split\_corner\_elements, }
\DoxyCodeLine{                      time\_stepper\_pt)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{//Assign the Lagrangian coordinates}}
\DoxyCodeLine{   set\_lagrangian\_nodal\_coordinates();}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Find out elements next to boundary}}
\DoxyCodeLine{   setup\_boundary\_element\_info();}

\end{DoxyCodeInclude}
 We create boundary coordinates along all mesh boundaries. To ensure that fluid and solid boundary coordinates are aligned properly, we use the flag {\ttfamily switch\+\_\+normal} to change the direction of the normal vector for the fluid mesh; see \mbox{\hyperlink{index_boundary_coord}{How the boundary coordinates are generated}} for details.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Setup boundary coordinates for boundary.}}
\DoxyCodeLine{   \textcolor{comment}{// To be consistent with the boundary coordinates generated}}
\DoxyCodeLine{   \textcolor{comment}{// in the solid, we switch the direction of the normal.}}
\DoxyCodeLine{   \textcolor{comment}{// (Both meshes are generated from the same polygonal facets}}
\DoxyCodeLine{   \textcolor{comment}{// at the FSI interface).}}
\DoxyCodeLine{   \textcolor{keywordtype}{bool} switch\_normal=\textcolor{keyword}{true};}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Setup boundary coordinates for all boundaries}}
\DoxyCodeLine{   \textcolor{keywordtype}{char} filename[100];}
\DoxyCodeLine{   ofstream some\_file;}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} nb=this-\/>nboundary();}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} b=0;b<nb;b++) }
\DoxyCodeLine{    \{}
\DoxyCodeLine{     sprintf(filename,\textcolor{stringliteral}{"{}RESLT/fluid\_boundary\_test\%i.dat"{}},b);}
\DoxyCodeLine{     some\_file.open(filename);}
\DoxyCodeLine{     this-\/>\textcolor{keyword}{template} setup\_boundary\_coordinates<ELEMENT>(b,switch\_normal,some\_file);}
\DoxyCodeLine{     some\_file.close();}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Empty Destructor}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keyword}{virtual} \mbox{\hyperlink{classFluidTetMesh}{\string~FluidTetMesh}}() \{ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\};}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysection{The driver code}\label{index_main}
We specify an output directory and instantiate the constitutive equation ({\ttfamily oomph-\/lib\textquotesingle{}s} generalisation of Hooke\textquotesingle{}s law), specifying a Poisson ratio of 0.\+3. As discussed above, this constitutive equation will be used for the \char`\"{}proper\char`\"{} solid mechanics that determines the deformation of the elastic vessel walls, and for the pseudo-\/solid that determines the deformation of the fluid mesh.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//========================= start\_of\_main=================================}}
\DoxyCodeLine{\textcolor{comment}{/// Demonstrate how to solve an unstructured 3D FSI problem}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keywordtype}{int} \mbox{\hyperlink{unstructured__three__d__fsi_8cc_a3c04138a5bfe5d72780bb7e82a18e627}{main}}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)}
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{// Label for output}}
\DoxyCodeLine{ DocInfo doc\_info;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Output directory}}
\DoxyCodeLine{ doc\_info.set\_directory(\textcolor{stringliteral}{"{}RESLT"{}});}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Create generalised Hookean constitutive equations}}
\DoxyCodeLine{ \mbox{\hyperlink{namespaceGlobal__Parameters_adbd1f040f375c96fe56b3f475f7dbec2}{Global\_Parameters::Constitutive\_law\_pt}} = }
\DoxyCodeLine{  \textcolor{keyword}{new} GeneralisedHookean(\&\mbox{\hyperlink{namespaceGlobal__Parameters_a20fccdcfa2c15ad8b951b9ada3bb1661}{Global\_Parameters::Nu}});}

\end{DoxyCodeInclude}
 We create the {\ttfamily Problem} object and output the initial guess for the solution.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{//Set up the problem}}
\DoxyCodeLine{ \mbox{\hyperlink{classUnstructuredFSIProblem}{UnstructuredFSIProblem}}<}
\DoxyCodeLine{ PseudoSolidNodeUpdateElement<TTaylorHoodElement<3>, TPVDElement<3,3> >,}
\DoxyCodeLine{  TPVDElement<3,3> > problem;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{//Output initial configuration}}
\DoxyCodeLine{ problem.\mbox{\hyperlink{classUnstructuredFSIProblem_a15f581318b505de07f50bd570da8c8d0}{doc\_solution}}(doc\_info);}
\DoxyCodeLine{ doc\_info.number()++;   }

\end{DoxyCodeInclude}
 Finally, we perform a parameter study in which we compute the solution of the fully-\/coupled FSI problem for increasing values of the FSI parameter $ Q $ -- physically, an increase in $ Q $ can be interpreted as a reduction in the stiffness of the tube walls while keeping the fluid properties and the driving pressure drop constant.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Parameter study}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nstep=2;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Increment in FSI parameter}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} q\_increment=5.0e-\/2;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} istep=0;istep<nstep;istep++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Solve the problem}}
\DoxyCodeLine{   problem.newton\_solve();}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{//Output solution}}
\DoxyCodeLine{   problem.doc\_solution(doc\_info);}
\DoxyCodeLine{   doc\_info.number()++;}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Bump up FSI parameter}}
\DoxyCodeLine{   \mbox{\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q}}+=q\_increment;   }
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end\_of\_main}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_class}{}\doxysection{The Problem class}\label{index_class}
The {\ttfamily Problem} class has the usual members, with access functions to the fluid and solid meshes, and a post-\/processing routine.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===============start\_of\_problem\_class===============================}}
\DoxyCodeLine{\textcolor{comment}{/// Unstructured 3D FSI problem}}
\DoxyCodeLine{\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT, \textcolor{keyword}{class} SOLID\_ELEMENT>}
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{classUnstructuredFSIProblem}{UnstructuredFSIProblem}} : \textcolor{keyword}{public} Problem}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Constructor: }}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classUnstructuredFSIProblem_a6a31fd839e0215ef1312942cf7284bd2}{UnstructuredFSIProblem}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Destructor (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classUnstructuredFSIProblem_a976a81e0dee902f6713bd8ca4d79d000}{\string~UnstructuredFSIProblem}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Doc the solution}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classUnstructuredFSIProblem_a15f581318b505de07f50bd570da8c8d0}{doc\_solution}}(DocInfo\& doc\_info);}

\end{DoxyCodeInclude}
 We provide several helper functions to create the {\ttfamily Face\+Elements} that (i) apply the applied traction on the fluid at the in-\/ and outflow cross-\/sections; (ii) apply the fluid traction onto the solid, and (iii) create the Lagrange multipliers that apply the solid displacement onto the pseudo-\/solid fluid mesh.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Create fluid traction elements at inflow}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} create\_fluid\_traction\_elements();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Create FSI traction elements}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} create\_fsi\_traction\_elements();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Create elements that enforce prescribed boundary motion}}
\DoxyCodeLine{\textcolor{comment}{ /// for the pseudo-\/solid fluid mesh by Lagrange multipliers}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} create\_lagrange\_multiplier\_elements();}

\end{DoxyCodeInclude}


We also provide a helper function that documents the boundary coordinates on the solid mesh. ~\newline



\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Sanity check: Doc boundary coordinates on i-\/th solid FSI interface}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} doc\_solid\_boundary\_coordinates(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& i);}

\end{DoxyCodeInclude}
 Finally we provide a large number of additional helper functions that specify the various mesh boundaries (as defined in the tetgen {\ttfamily $\ast$.poly} file) that make up the physical boundaries of interest\+: the in-\/ and outflow boundaries in the fluid domain; the FSI boundaries of the fluid and solid domains and the boundaries along which the tube wall is held in a fixed position.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Return total number of mesh boundaries that make up the inflow }}
\DoxyCodeLine{\textcolor{comment}{ /// boundary}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{unsigned} nfluid\_inflow\_traction\_boundary()}
\DoxyCodeLine{  \{\textcolor{keywordflow}{return} Inflow\_boundary\_id.size();\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ ///  Return total number of mesh boundaries that make up the outflow }}
\DoxyCodeLine{\textcolor{comment}{ /// boundary}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{unsigned} nfluid\_outflow\_traction\_boundary()}
\DoxyCodeLine{  \{\textcolor{keywordflow}{return} Outflow\_boundary\_id.size();\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Return total number of mesh boundaries that make up the }}
\DoxyCodeLine{\textcolor{comment}{ /// in-\/ and outflow boundaries where a traction has to be applied}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{unsigned} nfluid\_traction\_boundary()}
\DoxyCodeLine{  \{\textcolor{keywordflow}{return} Inflow\_boundary\_id.size()+Outflow\_boundary\_id.size();\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Return total number of mesh boundaries in the solid mesh that}}
\DoxyCodeLine{\textcolor{comment}{ /// make up the FSI interface}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{unsigned} nsolid\_fsi\_boundary()}
\DoxyCodeLine{  \{\textcolor{keywordflow}{return} Solid\_fsi\_boundary\_id.size();\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Return total number of mesh boundaries in the fluid mesh that}}
\DoxyCodeLine{\textcolor{comment}{ /// make up the FSI interface}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{unsigned} nfluid\_fsi\_boundary()}
\DoxyCodeLine{  \{\textcolor{keywordflow}{return} Fluid\_fsi\_boundary\_id.size();\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Return total number of mesh boundaries in the solid mesh }}
\DoxyCodeLine{\textcolor{comment}{ /// where the position is pinned.}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{unsigned} npinned\_solid\_boundary()}
\DoxyCodeLine{  \{\textcolor{keywordflow}{return} Pinned\_solid\_boundary\_id.size();\} }
\DoxyCodeLine{  \textcolor{comment}{//end npinned\_solid\_boundary}}

\end{DoxyCodeInclude}
 The private member data includes pointers to the various meshes and the {\ttfamily Geom\+Object} representation of the FSI boundary (created from the {\ttfamily Face\+Elements} attached to the solid mesh).


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Bulk solid mesh}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classMySolidTetgenMesh}{MySolidTetgenMesh<SOLID\_ELEMENT>}}* Solid\_mesh\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Meshes of FSI traction elements}}
\DoxyCodeLine{\textcolor{comment}{} Vector<SolidMesh*> Solid\_fsi\_traction\_mesh\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Bulk fluid mesh}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classFluidTetMesh}{FluidTetMesh<FLUID\_ELEMENT>}}* Fluid\_mesh\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Meshes of fluid traction elements that apply pressure at in/outflow}}
\DoxyCodeLine{\textcolor{comment}{} Vector<Mesh*> Fluid\_traction\_mesh\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Meshes of Lagrange multiplier elements}}
\DoxyCodeLine{\textcolor{comment}{} Vector<SolidMesh*> Lagrange\_multiplier\_mesh\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// GeomObject incarnations of the FSI boundary in the solid mesh}}
\DoxyCodeLine{\textcolor{comment}{} Vector<MeshAsGeomObject*>}
\DoxyCodeLine{ Solid\_fsi\_boundary\_pt;}

\end{DoxyCodeInclude}
 Finally, here are the vectors that store the mesh boundary IDs associated with the various domain boundaries of interest.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// IDs of solid mesh boundaries where displacements are pinned}}
\DoxyCodeLine{\textcolor{comment}{} Vector<unsigned> Pinned\_solid\_boundary\_id;}
\DoxyCodeLine{  \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// IDs of solid mesh boundaries which make up the FSI interface}}
\DoxyCodeLine{\textcolor{comment}{} Vector<unsigned> Solid\_fsi\_boundary\_id;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// IDs of fluid mesh boundaries along which inflow boundary conditions}}
\DoxyCodeLine{\textcolor{comment}{ /// are applied}}
\DoxyCodeLine{\textcolor{comment}{} Vector<unsigned> Inflow\_boundary\_id;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// IDs of fluid mesh boundaries along which inflow boundary conditions}}
\DoxyCodeLine{\textcolor{comment}{ /// are applied}}
\DoxyCodeLine{\textcolor{comment}{} Vector<unsigned> Outflow\_boundary\_id;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// IDs of fluid mesh boundaries which make up the FSI interface}}
\DoxyCodeLine{\textcolor{comment}{} Vector<unsigned> Fluid\_fsi\_boundary\_id;}
\DoxyCodeLine{}
\DoxyCodeLine{\};}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_constructor}{}\doxysection{The Problem constructor}\label{index_constructor}
We start by building the fluid mesh, using the files created by \href{http://wias-berlin.de/software/tetgen//}{\texttt{ {\ttfamily tetgen} }}; see the discussion in the corresponding \href{../../../navier_stokes/unstructured_three_d_fluid/html/index.html\#mesh}{\texttt{ single-\/physics fluids problem.}}


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==========start\_of\_constructor==========================================}}
\DoxyCodeLine{\textcolor{comment}{/// Constructor for unstructured 3D FSI problem}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT, \textcolor{keyword}{class} SOLID\_ELEMENT>}
\DoxyCodeLine{\mbox{\hyperlink{classUnstructuredFSIProblem_a6a31fd839e0215ef1312942cf7284bd2}{UnstructuredFSIProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::UnstructuredFSIProblem}}()}
\DoxyCodeLine{\{ }
\DoxyCodeLine{ \textcolor{comment}{// Define fluid mesh and its distinguished boundaries}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ }
\DoxyCodeLine{   \textcolor{comment}{//Create fluid bulk mesh, sub-\/dividing "{}corner"{} elements}}
\DoxyCodeLine{ \textcolor{keywordtype}{string} node\_file\_name=\textcolor{stringliteral}{"{}fsi\_bifurcation\_fluid.1.node"{}};}
\DoxyCodeLine{ \textcolor{keywordtype}{string} element\_file\_name=\textcolor{stringliteral}{"{}fsi\_bifurcation\_fluid.1.ele"{}};}
\DoxyCodeLine{ \textcolor{keywordtype}{string} face\_file\_name=\textcolor{stringliteral}{"{}fsi\_bifurcation\_fluid.1.face"{}};}
\DoxyCodeLine{ \textcolor{keywordtype}{bool} split\_corner\_elements=\textcolor{keyword}{true};}
\DoxyCodeLine{ Fluid\_mesh\_pt =  \textcolor{keyword}{new} \mbox{\hyperlink{classFluidTetMesh}{FluidTetMesh<FLUID\_ELEMENT>}}(node\_file\_name,}
\DoxyCodeLine{                                                  element\_file\_name,}
\DoxyCodeLine{                                                  face\_file\_name,}
\DoxyCodeLine{                                                  split\_corner\_elements);}

\end{DoxyCodeInclude}


Next we associated the {\ttfamily tetgen} boundary IDs with the various boundaries of interest\+: The inflow boundary is represented by {\ttfamily tetgen} boundary 0, and the two outflow boundaries have IDs 1 and 2.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// The following corresponds to the boundaries as specified by}}
\DoxyCodeLine{ \textcolor{comment}{// facets in the tetgen input:}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Fluid mesh has one inflow boundary: Boundary 0}}
\DoxyCodeLine{ Inflow\_boundary\_id.resize(1);}
\DoxyCodeLine{ Inflow\_boundary\_id[0]=0;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Fluid mesh has two outflow boundaries: Boundaries 1 and 2}}
\DoxyCodeLine{ Outflow\_boundary\_id.resize(2);}
\DoxyCodeLine{ Outflow\_boundary\_id[0]=1;}
\DoxyCodeLine{ Outflow\_boundary\_id[1]=2;}

\end{DoxyCodeInclude}
 The FSI boundary (i.\+e. the boundary of the fluid mesh that is exposed to the elastic vessel wall) comprises 12 separate tetgen facets which were numbered 3 to 14 in the {\ttfamily $\ast$.poly} that describes the fluid mesh.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// The remaining fluid boundaries are FSI boundaries.}}
\DoxyCodeLine{ \textcolor{comment}{// Note that their order (as indexed in this vector, not}}
\DoxyCodeLine{ \textcolor{comment}{// their actual numbers) have to match those in the corresponding}}
\DoxyCodeLine{ \textcolor{comment}{// lookup scheme for the solid.}}
\DoxyCodeLine{ Fluid\_fsi\_boundary\_id.resize(12);}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<12;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   Fluid\_fsi\_boundary\_id[i]=i+3;}
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}


Next, we create the solid mesh, using the files created by \href{http://wias-berlin.de/software/tetgen//}{\texttt{ {\ttfamily tetgen} }}; see the discussion in the corresponding \href{../../../solid/unstructured_three_d_solid/html/index.html\#mesh}{\texttt{ single-\/physics solids problem.}}


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Define solid mesh and its distinguished boundaries}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{//Create solid bulk mesh}}
\DoxyCodeLine{ node\_file\_name=\textcolor{stringliteral}{"{}fsi\_bifurcation\_solid.1.node"{}};}
\DoxyCodeLine{ element\_file\_name=\textcolor{stringliteral}{"{}fsi\_bifurcation\_solid.1.ele"{}};}
\DoxyCodeLine{ face\_file\_name=\textcolor{stringliteral}{"{}fsi\_bifurcation\_solid.1.face"{}};}
\DoxyCodeLine{ Solid\_mesh\_pt =  \textcolor{keyword}{new} \mbox{\hyperlink{classMySolidTetgenMesh}{MySolidTetgenMesh<SOLID\_ELEMENT>}}(node\_file\_name,}
\DoxyCodeLine{                                                    element\_file\_name,}
\DoxyCodeLine{                                                    face\_file\_name);}

\end{DoxyCodeInclude}
 Following the procedure used for the fluid mesh, we identify the mesh boundaries that make up the (pinned) ends of the tube (boundaries 0, 1 and 2, as defined in the tetgen {\ttfamily $\ast$.poly} file) and the FSI boundary (boundaries 3 to 14 -- note that this enumeration matches that in the fluid mesh; see \mbox{\hyperlink{index_boundary_coord}{How the boundary coordinates are generated}} for further details of how the fluid and solid meshes are matched).


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// The following corresponds to the boundaries as specified by}}
\DoxyCodeLine{ \textcolor{comment}{// facets in the tetgen input:}}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// IDs of solid mesh boundaries where displacements are pinned}}
\DoxyCodeLine{\textcolor{comment}{} Pinned\_solid\_boundary\_id.resize(3);}
\DoxyCodeLine{ Pinned\_solid\_boundary\_id[0]=0;}
\DoxyCodeLine{ Pinned\_solid\_boundary\_id[1]=1;}
\DoxyCodeLine{ Pinned\_solid\_boundary\_id[2]=2;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// The solid and fluid fsi boundaries are numbered int he same way.}}
\DoxyCodeLine{ Solid\_fsi\_boundary\_id.resize(12);}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<12;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   Solid\_fsi\_boundary\_id[i]=i+3;}
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
 We create the fluid traction elements that impose the applied pressures in the in-\/ and outflow cross-\/sections.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Create (empty) meshes of fluid traction elements at inflow/outflow}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Create the meshes}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n=nfluid\_traction\_boundary();}
\DoxyCodeLine{ Fluid\_traction\_mesh\_pt.resize(n);}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   Fluid\_traction\_mesh\_pt[i]=\textcolor{keyword}{new} Mesh;}
\DoxyCodeLine{  \} }
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Populate them with elements}}
\DoxyCodeLine{ create\_fluid\_traction\_elements();}

\end{DoxyCodeInclude}


Next, we create the {\ttfamily Face\+Elements} that apply the fluid traction to the solid,


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create FSI Traction elements}}
\DoxyCodeLine{\textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ }
\DoxyCodeLine{\textcolor{comment}{// Create (empty) meshes of FSI traction elements}}
\DoxyCodeLine{ n=nsolid\_fsi\_boundary();}
\DoxyCodeLine{ Solid\_fsi\_traction\_mesh\_pt.resize(n);}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   Solid\_fsi\_traction\_mesh\_pt[i]=\textcolor{keyword}{new} SolidMesh;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Build the FSI traction elements}}
\DoxyCodeLine{ create\_fsi\_traction\_elements();}

\end{DoxyCodeInclude}
 and the {\ttfamily Face\+Elements} that use Lagrange multipliers to deform the fluid mesh to keep it aligned with the FSI boundary.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Create Lagrange multiplier mesh for boundary motion of fluid mesh}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{  }
\DoxyCodeLine{ \textcolor{comment}{// Construct the mesh of elements that enforce prescribed boundary motion}}
\DoxyCodeLine{ \textcolor{comment}{// of pseudo-\/solid fluid mesh by Lagrange multipliers}}
\DoxyCodeLine{ n=nfluid\_fsi\_boundary();}
\DoxyCodeLine{ Lagrange\_multiplier\_mesh\_pt.resize(n);}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   Lagrange\_multiplier\_mesh\_pt[i]=\textcolor{keyword}{new} SolidMesh;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Create elements}}
\DoxyCodeLine{ create\_lagrange\_multiplier\_elements();}

\end{DoxyCodeInclude}
 We combine the various sub-\/meshes to a global mesh.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Combine the lot}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Add sub meshes:}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// The solid bulk mesh}}
\DoxyCodeLine{ add\_sub\_mesh(Solid\_mesh\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Fluid bulk mesh}}
\DoxyCodeLine{ add\_sub\_mesh(Fluid\_mesh\_pt);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// The fluid traction meshes}}
\DoxyCodeLine{ n=nfluid\_traction\_boundary();}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)}
\DoxyCodeLine{  \{ }
\DoxyCodeLine{   add\_sub\_mesh(Fluid\_traction\_mesh\_pt[i]);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// The solid fsi traction meshes}}
\DoxyCodeLine{ n=nsolid\_fsi\_boundary();}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   add\_sub\_mesh(Solid\_fsi\_traction\_mesh\_pt[i]);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// The Lagrange multiplier meshes for the fluid}}
\DoxyCodeLine{ n=nfluid\_fsi\_boundary();}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)}
\DoxyCodeLine{  \{   }
\DoxyCodeLine{   add\_sub\_mesh(Lagrange\_multiplier\_mesh\_pt[i]);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Build global mesh}}
\DoxyCodeLine{ build\_global\_mesh();}

\end{DoxyCodeInclude}


Next, we apply the boundary conditions for the fluid mesh\+: We impose parallel in-\/ and outflow at the in-\/ and outflow boundaries and apply boundary conditions for the pseudo-\/elastic deformation of the fluid mesh. Since the in-\/ and outflow cross-\/sections of the elastic tube are held in place, we pin the position of the fluid nodes in these cross-\/sections too. To facilitate debugging we document the position of the fluid nodes whose (pseudo-\/solid) displacements we suppressed.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Apply BCs for fluid}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{  }
\DoxyCodeLine{ \textcolor{comment}{// Doc position of pinned pseudo solid nodes}}
\DoxyCodeLine{ std::ofstream pseudo\_solid\_bc\_file(\textcolor{stringliteral}{"{}RESLT/pinned\_pseudo\_solid\_nodes.dat"{}});}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Loop over inflow/outflow boundaries to impose parallel flow}}
\DoxyCodeLine{ \textcolor{comment}{// and pin pseudo-\/solid displacements}}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} in\_out=0;in\_out<2;in\_out++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Loop over in/outflow boundaries}}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} n=nfluid\_inflow\_traction\_boundary();}
\DoxyCodeLine{   \textcolor{keywordflow}{if} (in\_out==1) n=nfluid\_outflow\_traction\_boundary();}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Get boundary ID}}
\DoxyCodeLine{     \textcolor{keywordtype}{unsigned} b=0;}
\DoxyCodeLine{     \textcolor{keywordflow}{if} (in\_out==0)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       b=Inflow\_boundary\_id[i];}
\DoxyCodeLine{      \}}
\DoxyCodeLine{     \textcolor{keywordflow}{else}}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       b=Outflow\_boundary\_id[i];}
\DoxyCodeLine{      \}}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Number of nodes on that boundary}}
\DoxyCodeLine{     \textcolor{keywordtype}{unsigned} num\_nod=Fluid\_mesh\_pt-\/>nboundary\_node(b);}
\DoxyCodeLine{     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       \textcolor{comment}{// Get the node}}
\DoxyCodeLine{       SolidNode* nod\_pt=Fluid\_mesh\_pt-\/>boundary\_node\_pt(b,inod);}
\DoxyCodeLine{       }
\DoxyCodeLine{       \textcolor{comment}{// Pin transverse velocities}}
\DoxyCodeLine{       nod\_pt-\/>pin(0);}
\DoxyCodeLine{       nod\_pt-\/>pin(1);}
\DoxyCodeLine{       }
\DoxyCodeLine{       \textcolor{comment}{// Pin the nodal (pseudo-\/solid) displacements}}
\DoxyCodeLine{       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<3;i++)}
\DoxyCodeLine{        \{         }
\DoxyCodeLine{         nod\_pt-\/>pin\_position(i);         }
\DoxyCodeLine{         }
\DoxyCodeLine{         \textcolor{comment}{// Doc it as pinned}}
\DoxyCodeLine{         pseudo\_solid\_bc\_file << nod\_pt-\/>x(i) << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{        \}}
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Close}}
\DoxyCodeLine{ pseudo\_solid\_bc\_file.close();}

\end{DoxyCodeInclude}
 We apply the no-\/slip condition on the fluid nodes that are located on the FSI boundary. In addition, we apply boundary conditions for the Lagrange multipliers. We pin the Lagrange multipliers for nodes that are located on the in-\/ and outflow boundaries where the nodal positions are pinned. \href{../../../solid/prescribed_displ_lagr_mult/html/index.html}{\texttt{ Recall}} that the Lagrange multipliers are additional degrees of freedom that are added to the \char`\"{}bulk\char`\"{} degrees of freedom that were originally created by the \char`\"{}bulk\char`\"{} element. The storage for the Lagrange multipliers is added to the Nodes by the Face\+Elements and the values at which the Lagrange multipliers are stored are found using the function {\ttfamily Boundary\+Node\+Base\+::index\+\_\+of\+\_\+first\+\_\+value\+\_\+assigned\+\_\+by\+\_\+face\+\_\+element()}. The documentation of the position of the pinned Lagrange multiplier nodes in {\ttfamily RESLT/pinned\+\_\+lagrange\+\_\+multiplier\+\_\+nodes.\+dat} is here to facilitate the debugging of the code and is highly recommended.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Doc bcs for Lagrange multipliers}}
\DoxyCodeLine{ ofstream pinned\_file(\textcolor{stringliteral}{"{}RESLT/pinned\_lagrange\_multiplier\_nodes.dat"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Loop over all fluid mesh boundaries and pin velocities}}
\DoxyCodeLine{ \textcolor{comment}{// of nodes that haven't been dealt with yet}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nbound=nfluid\_fsi\_boundary();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<nbound;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{//Get the mesh boundary}}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} b = Fluid\_fsi\_boundary\_id[i];}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} num\_nod=Fluid\_mesh\_pt-\/>nboundary\_node(b);}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{comment}{// Get node}}
\DoxyCodeLine{     Node* nod\_pt= Fluid\_mesh\_pt-\/>boundary\_node\_pt(b,inod);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Pin all velocities}}
\DoxyCodeLine{     nod\_pt-\/>pin(0); }
\DoxyCodeLine{     nod\_pt-\/>pin(1); }
\DoxyCodeLine{     nod\_pt-\/>pin(2); }
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Find out whether node is also on in/outflow}}
\DoxyCodeLine{     \textcolor{keywordtype}{bool} is\_in\_or\_outflow\_node=\textcolor{keyword}{false};}
\DoxyCodeLine{     \textcolor{keywordtype}{unsigned} n=nfluid\_inflow\_traction\_boundary();}
\DoxyCodeLine{     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} k=0;k<n;k++)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       \textcolor{keywordflow}{if} (nod\_pt-\/>is\_on\_boundary(Inflow\_boundary\_id[k]))}
\DoxyCodeLine{        \{}
\DoxyCodeLine{         is\_in\_or\_outflow\_node=\textcolor{keyword}{true};}
\DoxyCodeLine{         \textcolor{keywordflow}{break};}
\DoxyCodeLine{        \}}
\DoxyCodeLine{      \}}
\DoxyCodeLine{     \textcolor{keywordflow}{if} (!is\_in\_or\_outflow\_node)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       \textcolor{keywordtype}{unsigned} n=nfluid\_outflow\_traction\_boundary();}
\DoxyCodeLine{       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} k=0;k<n;k++)}
\DoxyCodeLine{        \{}
\DoxyCodeLine{         \textcolor{keywordflow}{if} (nod\_pt-\/>is\_on\_boundary(Outflow\_boundary\_id[k]))}
\DoxyCodeLine{          \{}
\DoxyCodeLine{           is\_in\_or\_outflow\_node=\textcolor{keyword}{true};}
\DoxyCodeLine{           \textcolor{keywordflow}{break};}
\DoxyCodeLine{          \}}
\DoxyCodeLine{        \}}
\DoxyCodeLine{      \}}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Pin the Lagrange multipliers on the out/in-\/flow boundaries}}
\DoxyCodeLine{     \textcolor{keywordflow}{if} (is\_in\_or\_outflow\_node)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       \textcolor{comment}{//Cast to a boundary node}}
\DoxyCodeLine{       BoundaryNode<SolidNode> *bnod\_pt = }
\DoxyCodeLine{        \textcolor{keyword}{dynamic\_cast<}BoundaryNode<SolidNode>*\textcolor{keyword}{>}}
\DoxyCodeLine{        ( Fluid\_mesh\_pt-\/>boundary\_node\_pt(b,inod) );}
\DoxyCodeLine{              }
\DoxyCodeLine{       \textcolor{comment}{// Loop over the Lagrange multipliers}}
\DoxyCodeLine{       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} l=0;l<3;l++)}
\DoxyCodeLine{        \{}
\DoxyCodeLine{         \textcolor{comment}{// Pin the Lagrange multipliers that impose the displacement}}
\DoxyCodeLine{         \textcolor{comment}{// because the positon of the fluid nodes at the in/outflow}}
\DoxyCodeLine{         \textcolor{comment}{// is already determined. }}
\DoxyCodeLine{         nod\_pt-\/>pin}
\DoxyCodeLine{          (bnod\_pt-\/>index\_of\_first\_value\_assigned\_by\_face\_element()+l);}
\DoxyCodeLine{        \}}
\DoxyCodeLine{}
\DoxyCodeLine{       \textcolor{comment}{// Doc that we've pinned the Lagrange multipliers at this node}}
\DoxyCodeLine{       pinned\_file << nod\_pt-\/>x(0) << \textcolor{stringliteral}{"{} "{}}}
\DoxyCodeLine{                   << nod\_pt-\/>x(1) << \textcolor{stringliteral}{"{} "{}}}
\DoxyCodeLine{                   << nod\_pt-\/>x(2) << endl;}
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{   }
\DoxyCodeLine{  \} \textcolor{comment}{// done no slip on fsi boundary}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Done}}
\DoxyCodeLine{ pinned\_file.close();}

\end{DoxyCodeInclude}
 We complete the build of the fluid elements by specifying the Reynolds number and the constitutive equation for the pseudo-\/solid equations; recall that we use the same constitutive equation as used for the tube wall.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Complete the build of the fluid elements so they are fully functional}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_element = Fluid\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Upcast from GeneralisedElement to the present element}}
\DoxyCodeLine{   FLUID\_ELEMENT* el\_pt = }
\DoxyCodeLine{    \textcolor{keyword}{dynamic\_cast<}FLUID\_ELEMENT*\textcolor{keyword}{>}(Fluid\_mesh\_pt-\/>element\_pt(e));}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{//Set the Reynolds number}}
\DoxyCodeLine{   el\_pt-\/>re\_pt() = \&\mbox{\hyperlink{namespaceGlobal__Parameters_a9d72e94a9305c6a310940a6a427ebe06}{Global\_Parameters::Re}};}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Set the constitutive law for pseudo-\/elastic mesh deformation}}
\DoxyCodeLine{   el\_pt-\/>constitutive\_law\_pt() =}
\DoxyCodeLine{    \mbox{\hyperlink{namespaceGlobal__Parameters_adbd1f040f375c96fe56b3f475f7dbec2}{Global\_Parameters::Constitutive\_law\_pt}};}
\DoxyCodeLine{   }
\DoxyCodeLine{  \} \textcolor{comment}{// end loop over elements}}

\end{DoxyCodeInclude}


We apply the \char`\"{}solid\char`\"{} boundary conditions by pinning the positions of the nodes that are located at the ends of the elastic tube, and, just to be on the safe side, document their positions to allow for debugging and sanity-\/checking.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Apply BCs for solid}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Doc pinned solid nodes}}
\DoxyCodeLine{ std::ofstream bc\_file(\textcolor{stringliteral}{"{}RESLT/pinned\_solid\_nodes.dat"{}});}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Pin positions at inflow boundary (boundaries 0 and 1)}}
\DoxyCodeLine{ n=npinned\_solid\_boundary();}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Get boundary ID}}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} b=Pinned\_solid\_boundary\_id[i];}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} num\_nod= Solid\_mesh\_pt-\/>nboundary\_node(b);  }
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)}
\DoxyCodeLine{    \{    }
\DoxyCodeLine{     \textcolor{comment}{// Get node}}
\DoxyCodeLine{     SolidNode* nod\_pt=Solid\_mesh\_pt-\/>boundary\_node\_pt(b,inod);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Pin all directions}}
\DoxyCodeLine{     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<3;i++)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       nod\_pt-\/>pin\_position(i);}
\DoxyCodeLine{       }
\DoxyCodeLine{       \textcolor{comment}{// ...and doc it as pinned}}
\DoxyCodeLine{       bc\_file << nod\_pt-\/>x(i) << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{      \}}
\DoxyCodeLine{     }
\DoxyCodeLine{     bc\_file << std::endl;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ bc\_file.close();}

\end{DoxyCodeInclude}


We complete the build of the solid elements by passing the pointer to the constitutive equation.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ }
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Complete the build of Solid elements so they are fully functional}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ n\_element = Solid\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{//Cast to a solid element}}
\DoxyCodeLine{   SOLID\_ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}SOLID\_ELEMENT*\textcolor{keyword}{>}(}
\DoxyCodeLine{    Solid\_mesh\_pt-\/>element\_pt(i));}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Set the constitutive law   }}
\DoxyCodeLine{   el\_pt-\/>constitutive\_law\_pt() =}
\DoxyCodeLine{    \mbox{\hyperlink{namespaceGlobal__Parameters_adbd1f040f375c96fe56b3f475f7dbec2}{Global\_Parameters::Constitutive\_law\_pt}};}
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
 Finally, we set up the fluid-\/structure interaction by determining which \char`\"{}bulk\char`\"{} fluid elements are located next to the FSI traction elements that apply the fluid load to the solid. This must be done separately for each of the mesh boundaries that make up the physical FSI boundary. To facilitate debugging, we document the boundary coordinates along the FSI interface (as seen by the fluid) by opening the {\ttfamily Multi\+\_\+domain\+\_\+functions\+::\+Doc\+\_\+boundary\+\_\+coordinate\+\_\+file} stream before calling {\ttfamily FSI\+\_\+functions\+::setup\+\_\+fluid\+\_\+load\+\_\+info\+\_\+for\+\_\+solid\+\_\+elements(...)}. If this stream is open, the setup routine writes the Eulerian coordinates of the points on the FSI interface and their intrinsic surface coordinate $ [ x, y, z, \zeta_1, \zeta_2 ] $ to the specified file. This may be compared against the corresponding data for the solid\textquotesingle{}s view of the FSI interface, documented in {\ttfamily doc\+\_\+solid\+\_\+boundary\+\_\+coordinates()}.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup FSI}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{     }
\DoxyCodeLine{ \textcolor{comment}{// Work out which fluid dofs affect the residuals of the wall elements:}}
\DoxyCodeLine{ \textcolor{comment}{// We pass the boundary between the fluid and solid meshes and }}
\DoxyCodeLine{ \textcolor{comment}{// pointers to the meshes. }}
\DoxyCodeLine{ n=nsolid\_fsi\_boundary();}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Sanity check: Doc boundary coordinates from solid side}}
\DoxyCodeLine{   doc\_solid\_boundary\_coordinates(i);}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{//Doc boundary coordinates in fluid}}
\DoxyCodeLine{   \textcolor{keywordtype}{char} filename[100];}
\DoxyCodeLine{   sprintf(filename,\textcolor{stringliteral}{"{}RESLT/fluid\_boundary\_coordinates\%i.dat"{}},i);}
\DoxyCodeLine{   Multi\_domain\_functions::Doc\_boundary\_coordinate\_file.open(filename);}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Setup FSI: Pass ID of fluid FSI boundary and associated}}
\DoxyCodeLine{   \textcolor{comment}{// mesh of solid fsi traction elements.}}
\DoxyCodeLine{   FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,3>}
\DoxyCodeLine{    (\textcolor{keyword}{this},Fluid\_fsi\_boundary\_id[i],Fluid\_mesh\_pt,Solid\_fsi\_traction\_mesh\_pt[i]);}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Close the doc file}}
\DoxyCodeLine{   Multi\_domain\_functions::Doc\_boundary\_coordinate\_file.close();}
\DoxyCodeLine{  \} }

\end{DoxyCodeInclude}


All that\textquotesingle{}s now left to do is to set up the equation numbering scheme and the problem is ready to be solved.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Setup equation numbering scheme}}
\DoxyCodeLine{ std::cout <<\textcolor{stringliteral}{"{}Number of equations: "{}} << assign\_eqn\_numbers() << std::endl; }
\DoxyCodeLine{ }
\DoxyCodeLine{\}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_fsi_traction}{}\doxysection{Creating the FSI traction elements}\label{index_fsi_traction}
The creation of the FSI traction elements that apply the fluid traction to the solid elements that are adjacent to the FSI boundary follows the usual procedure\+: We loop over the relevant 3D \char`\"{}bulk\char`\"{} solid elements and attach the {\ttfamily FSISolid\+Traction\+Elements} to the appropriate faces.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//============start\_of\_create\_fsi\_traction\_elements======================}}
\DoxyCodeLine{\textcolor{comment}{/// Create FSI traction elements }}
\DoxyCodeLine{\textcolor{comment}{//=======================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT,\textcolor{keyword}{class} SOLID\_ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classUnstructuredFSIProblem_a934a587c99668fca969a72814b3142a7}{UnstructuredFSIProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classUnstructuredFSIProblem_a934a587c99668fca969a72814b3142a7}{create\_fsi\_traction\_elements}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Loop over FSI boundaries in solid}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n=nsolid\_fsi\_boundary();}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Get boundary ID}}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} b=Solid\_fsi\_boundary\_id[i];}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} n\_element = Solid\_mesh\_pt-\/>nboundary\_element(b);}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b}}
\DoxyCodeLine{   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}}
\DoxyCodeLine{     SOLID\_ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}SOLID\_ELEMENT*\textcolor{keyword}{>}(}
\DoxyCodeLine{      Solid\_mesh\_pt-\/>boundary\_element\_pt(b,e));}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{//What is the index of the face of the element e along boundary b}}
\DoxyCodeLine{     \textcolor{keywordtype}{int} face\_index = Solid\_mesh\_pt-\/>face\_index\_at\_boundary(b,e);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Create new element }}
\DoxyCodeLine{     FSISolidTractionElement<SOLID\_ELEMENT,3>* el\_pt=}
\DoxyCodeLine{      \textcolor{keyword}{new} FSISolidTractionElement<SOLID\_ELEMENT,3>(bulk\_elem\_pt,face\_index);}

\end{DoxyCodeInclude}
 Next we add the newly-\/created {\ttfamily Face\+Element} to the mesh of traction elements, specify which boundary of the bulk mesh it is attached to, and pass the FSI interaction parameter $ Q $ to the element.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Add it to the mesh}}
\DoxyCodeLine{     Solid\_fsi\_traction\_mesh\_pt[i]-\/>add\_element\_pt(el\_pt);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Specify boundary number}}
\DoxyCodeLine{     el\_pt-\/>set\_boundary\_number\_in\_bulk\_mesh(b);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Function that specifies the load ratios}}
\DoxyCodeLine{     el\_pt-\/>q\_pt() = \&\mbox{\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q}}; }
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ }
\DoxyCodeLine{\} \textcolor{comment}{// end of create\_fsi\_traction\_elements}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_create_lagr}{}\doxysection{Creating the Lagrange multiplier elements}\label{index_create_lagr}
The creation of the {\ttfamily Face\+Elements} that use Lagrange multipliers to impose the boundary displacement of the pseudo-\/solid fluid mesh is again fairly straightforward (the use of Lagrange multipliers for the imposition of boundary displacements is explained in \href{../../../solid/prescribed_displ_lagr_mult/html/index.html}{\texttt{ another tutorial}}). The only complication is that we must loop over the different parts of the FSI boundary. In each case we combine the {\ttfamily FSISolid\+Traction\+Elements} attached to the solid mesh into a compound {\ttfamily Geom\+Object}. Each {\ttfamily Geom\+Object} provides a continuous representation of the relevant part of the FSI boundary, parametrised by the boundary coordinate assigned earlier while its shape is determined by the deformation of the 3D solid elements that the {\ttfamily FSISolid\+Traction\+Elements} are attached to.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//============start\_of\_create\_lagrange\_multiplier\_elements===============}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{/// Create elements that impose the prescribed boundary displacement}}
\DoxyCodeLine{\textcolor{comment}{/// for the pseudo-\/solid fluid mesh}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//=======================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT, \textcolor{keyword}{class} SOLID\_ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classUnstructuredFSIProblem_a6f810c300f373cfc79e23d58f95944e3}{UnstructuredFSIProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classUnstructuredFSIProblem_a6f810c300f373cfc79e23d58f95944e3}{create\_lagrange\_multiplier\_elements}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{// Make space}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n=nfluid\_fsi\_boundary();}
\DoxyCodeLine{ Solid\_fsi\_boundary\_pt.resize(n);}
\DoxyCodeLine{    }
\DoxyCodeLine{ \textcolor{comment}{// Loop over FSI interfaces in fluid}}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)}
\DoxyCodeLine{  \{   }
\DoxyCodeLine{   \textcolor{comment}{// Get boundary ID}}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} b=Fluid\_fsi\_boundary\_id[i];}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Create  GeomObject incarnation of fsi boundary in solid mesh}}
\DoxyCodeLine{   Solid\_fsi\_boundary\_pt[i]=}
\DoxyCodeLine{    \textcolor{keyword}{new} MeshAsGeomObject}
\DoxyCodeLine{    (Solid\_fsi\_traction\_mesh\_pt[i]);}

\end{DoxyCodeInclude}
 Having represented the boundary by a (compound) {\ttfamily Geom\+Object}, we now attach {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} to the appropriate faces of the \char`\"{}bulk\char`\"{} fluid elements that are adjacent to the FSI interface and add them to their own mesh\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// How many bulk fluid elements are adjacent to boundary b?}}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} n\_element = Fluid\_mesh\_pt-\/>nboundary\_element(b);}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Loop over the bulk fluid elements adjacent to boundary b?}}
\DoxyCodeLine{   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{comment}{// Get pointer to the bulk fluid element that is adjacent to boundary b}}
\DoxyCodeLine{     FLUID\_ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}FLUID\_ELEMENT*\textcolor{keyword}{>}(}
\DoxyCodeLine{      Fluid\_mesh\_pt-\/>boundary\_element\_pt(b,e));}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{//Find the index of the face of element e along boundary b}}
\DoxyCodeLine{     \textcolor{keywordtype}{int} face\_index = Fluid\_mesh\_pt-\/>face\_index\_at\_boundary(b,e);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Create new element}}
\DoxyCodeLine{     ImposeDisplacementByLagrangeMultiplierElement<FLUID\_ELEMENT>* el\_pt =}
\DoxyCodeLine{      \textcolor{keyword}{new} ImposeDisplacementByLagrangeMultiplierElement<FLUID\_ELEMENT>(}
\DoxyCodeLine{       bulk\_elem\_pt,face\_index);   }
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Add it to the mesh}}
\DoxyCodeLine{     Lagrange\_multiplier\_mesh\_pt[i]-\/>add\_element\_pt(el\_pt);}

\end{DoxyCodeInclude}
 Finally, we pass a pointer to the compound {\ttfamily Geom\+Object} that defines the shape of the FSI interface and specify which boundary in the \char`\"{}bulk\char`\"{} fluid mesh the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Element} is attached to.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Set the GeomObject that defines the boundary shape and set}}
\DoxyCodeLine{     \textcolor{comment}{// which bulk boundary we are attached to (needed to extract}}
\DoxyCodeLine{     \textcolor{comment}{// the boundary coordinate from the bulk nodes)}}
\DoxyCodeLine{     el\_pt-\/>set\_boundary\_shape\_geom\_object\_pt(Solid\_fsi\_boundary\_pt[i],b);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of create\_lagrange\_multiplier\_elements}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_fluid_traction}{}\doxysection{Attaching the fluid traction elements}\label{index_fluid_traction}
The helper function {\ttfamily create\+\_\+fluid\+\_\+traction\+\_\+elements()} attaches {\ttfamily Navier\+Stokes\+Traction\+Elements} to the in-\/ and outflow cross-\/sections of the fluid mesh and thus imposes the prescribed pressure drop onto the fluid.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//============start\_of\_fluid\_traction\_elements==============================}}
\DoxyCodeLine{\textcolor{comment}{/// Create fluid traction elements }}
\DoxyCodeLine{\textcolor{comment}{//=======================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT,\textcolor{keyword}{class} SOLID\_ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classUnstructuredFSIProblem_af766e3bbc8963a286678cb1d277909f5}{UnstructuredFSIProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classUnstructuredFSIProblem_af766e3bbc8963a286678cb1d277909f5}{create\_fluid\_traction\_elements}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Counter for number of fluid traction meshes}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} count=0;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Loop over inflow/outflow boundaries}}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} in\_out=0;in\_out<2;in\_out++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Loop over boundaries with fluid traction elements}}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} n=nfluid\_inflow\_traction\_boundary();}
\DoxyCodeLine{   \textcolor{keywordflow}{if} (in\_out==1) n=nfluid\_outflow\_traction\_boundary();}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Get boundary ID}}
\DoxyCodeLine{     \textcolor{keywordtype}{unsigned} b=0;}
\DoxyCodeLine{     \textcolor{keywordflow}{if} (in\_out==0)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       b=Inflow\_boundary\_id[i];}
\DoxyCodeLine{      \}}
\DoxyCodeLine{     \textcolor{keywordflow}{else}}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       b=Outflow\_boundary\_id[i];}
\DoxyCodeLine{      \}}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}}
\DoxyCodeLine{     \textcolor{keywordtype}{unsigned} n\_element = Fluid\_mesh\_pt-\/>nboundary\_element(b);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b}}
\DoxyCodeLine{     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}}
\DoxyCodeLine{       FLUID\_ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}FLUID\_ELEMENT*\textcolor{keyword}{>}(}
\DoxyCodeLine{        Fluid\_mesh\_pt-\/>boundary\_element\_pt(b,e));}
\DoxyCodeLine{       }
\DoxyCodeLine{       \textcolor{comment}{//What is the index of the face of the element e along boundary b}}
\DoxyCodeLine{       \textcolor{keywordtype}{int} face\_index = Fluid\_mesh\_pt-\/>face\_index\_at\_boundary(b,e);}
\DoxyCodeLine{       }
\DoxyCodeLine{       \textcolor{comment}{// Create new element }}
\DoxyCodeLine{       NavierStokesTractionElement<FLUID\_ELEMENT>* el\_pt=}
\DoxyCodeLine{        \textcolor{keyword}{new} NavierStokesTractionElement<FLUID\_ELEMENT>(bulk\_elem\_pt,}
\DoxyCodeLine{                                                       face\_index);}
\DoxyCodeLine{       }
\DoxyCodeLine{       \textcolor{comment}{// Add it to the mesh}}
\DoxyCodeLine{       Fluid\_traction\_mesh\_pt[count]-\/>add\_element\_pt(el\_pt);}
\DoxyCodeLine{         }
\DoxyCodeLine{       \textcolor{comment}{// Set the pointer to the prescribed traction function}}
\DoxyCodeLine{       \textcolor{keywordflow}{if} (in\_out==0)}
\DoxyCodeLine{        \{}
\DoxyCodeLine{         el\_pt-\/>traction\_fct\_pt() = }
\DoxyCodeLine{          \&\mbox{\hyperlink{namespaceGlobal__Parameters_af7faf65214ed9ead637f7c208addb095}{Global\_Parameters::prescribed\_inflow\_traction}};}
\DoxyCodeLine{        \}}
\DoxyCodeLine{       \textcolor{keywordflow}{else}}
\DoxyCodeLine{        \{ }
\DoxyCodeLine{         el\_pt-\/>traction\_fct\_pt() = }
\DoxyCodeLine{          \&\mbox{\hyperlink{namespaceGlobal__Parameters_a83155358b144cff7e29ecb6b209a2d3e}{Global\_Parameters::prescribed\_outflow\_traction}};}
\DoxyCodeLine{        \}}
\DoxyCodeLine{      \}}
\DoxyCodeLine{     \textcolor{comment}{// Bump up counter}}
\DoxyCodeLine{     count++;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \} \textcolor{comment}{// end of create\_traction\_elements}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_doc_solution}{}\doxysection{Post-\/processing}\label{index_doc_solution}
The post-\/processing routine simply executes the output functions for the fluid and solid meshes and documents their mesh boundaries. We also document the FSI traction that the fluid exerts onto the solid.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//========start\_of\_doc\_solution===========================================}}
\DoxyCodeLine{\textcolor{comment}{/// Doc the solution}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT, \textcolor{keyword}{class} SOLID\_ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classUnstructuredFSIProblem_a15f581318b505de07f50bd570da8c8d0}{UnstructuredFSIProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classUnstructuredFSIProblem_a15f581318b505de07f50bd570da8c8d0}{doc\_solution}}(DocInfo\& doc\_info)}
\DoxyCodeLine{\{ }
\DoxyCodeLine{}
\DoxyCodeLine{ ofstream some\_file;}
\DoxyCodeLine{ \textcolor{keywordtype}{char} filename[100];}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Number of plot points}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} npts;}
\DoxyCodeLine{ npts=5;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Output solid boundaries}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/solid\_boundaries\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ Solid\_mesh\_pt-\/>output\_boundaries(some\_file);}
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{ }
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Output solid solution}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/solid\_soln\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ Solid\_mesh\_pt-\/>output(some\_file,npts);}
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Output fluid boundaries}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/fluid\_boundaries\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ Fluid\_mesh\_pt-\/>output\_boundaries(some\_file);}
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{ }
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Output fluid solution}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/fluid\_soln\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ Fluid\_mesh\_pt-\/>output(some\_file,npts);}
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{  }
\DoxyCodeLine{   }
\DoxyCodeLine{ \textcolor{comment}{// Output fsi traction}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/fsi\_traction\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n=nsolid\_fsi\_boundary();}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   Solid\_fsi\_traction\_mesh\_pt[i]-\/>output(some\_file,npts);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end\_of\_doc}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_doc_solid_zeta}{}\doxysection{Sanity check\+: Documenting the solid boundary coordinates}\label{index_doc_solid_zeta}
The function {\ttfamily doc\+\_\+solid\+\_\+boundary\+\_\+coordinates()} documents the parametrisation of the solid\textquotesingle{}s FSI boundary by writing into a file the solid\textquotesingle{}s counterpart of the $ [ x, y, z, \zeta_1, \zeta_2 ] $ data that we created for the fluid side of the FSI interface when setting up the fluid-\/structure interaction with {\ttfamily FSI\+\_\+functions\+::setup\+\_\+fluid\+\_\+load\+\_\+info\+\_\+for\+\_\+solid\+\_\+elements(...)}. The two parametrisations should be consistent; see \mbox{\hyperlink{index_go_wrong}{What can go wrong?}} for more details. The implementation is straightforward and is suppressed for brevity; see the \href{../../../../demo_drivers/interaction/unstructured_three_d_fsi/unstructured_three_d_fsi.cc}{\texttt{ source code }} if you want to know how it works.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comm_ex}{}\doxysection{Comments and Exercises}\label{index_comm_ex}
\hypertarget{index_boundary_coord}{}\doxysubsection{How the boundary coordinates are generated}\label{index_boundary_coord}
The use of pseudo-\/elasticity for the node update in the fluid mesh makes the solution of FSI problems extremely straightforward. They key feature that allows the \char`\"{}automatic\char`\"{} coupling of the unstructured fluid and solid meshes is the (consistent!) generation of the boundary coordinates $ (\zeta_1,\zeta_2) $ along the FSI interface. For reasons already mentioned, the procedure is more involved than in the equivalent two-\/dimensional problem. The implementation of this functionality in {\ttfamily Tetgen\+Mesh\+::setup\+\_\+boundary\+\_\+coordinates(...)} exploits the fact that
\begin{DoxyEnumerate}
\item Meshes generated by \href{http://wias-berlin.de/software/tetgen//}{\texttt{ {\ttfamily tetgen} }} are bounded by planar facets, and ~\newline
~\newline

\item We insist that all facets are given distinct boundary IDs ~\newline
 when defining the domain in the tetgen {\ttfamily $\ast$.poly} file.
\end{DoxyEnumerate}The figure below illustrates the generation of the boundary coordinates within a representative planar facet (shown in cyan) that defines a particular mesh boundary.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{boundary_coords_with_mesh}
\doxyfigcaption{Sketch illustrating the generation of boundary coordinates on a mesh boundary that is defined by a planar facet (shown in cyan). }
\end{DoxyImage}


Here is how we generate the boundary coordinates\+:


\begin{DoxyEnumerate}
\item We start by attaching {\ttfamily Face\+Elements} to the appropriate faces of the \char`\"{}bulk\char`\"{} elements that are adjacent to the mesh boundary defined by the facet. These {\ttfamily Face\+Elements} provide a surface triangulation of the boundary. In the sketch above, the surface triangulation is represented by the blue surface mesh. ~\newline
~\newline

\item We locate the \char`\"{}lower left\char`\"{} and \char`\"{}upper right\char`\"{} nodes within the surface mesh, based on a lexicographical ordering of the nodes\textquotesingle{} 3D coordinates. ~\newline
~\newline

\item The straight line from the \char`\"{}lower left\char`\"{} to the \char`\"{}upper right\char`\"{} node (shown by the dashed red line) defines a direction that is co-\/planar with the facet and therefore allows us to define an in-\/plane unit vector, $ {\bf T}_1$, shown in red. ~\newline
~\newline

\item A second in-\/plane unit vector, $ {\bf T}_2$ (shown in yellow), can then be constructed by taking the cross-\/product of $ {\bf T}_1$ and the outer unit normal $ {\bf N} $. (The outer unit normal can be obtained from any of the adjacent bulk elements.) ~\newline
~\newline

\item The orthonormal in-\/plane vectors $ {\bf T}_1$ and $ {\bf T}_2$ define a unique parametrisation of the boundary in terms of the boundary coordinates $ (\zeta_1,\zeta_2) $, if we insist that for every point on the boundary we have \[ {\bf R}(\zeta_1,\zeta_2) = {\bf R}_{\mbox{lower left}} + \zeta_1 {\bf T}_1 + \zeta_2 {\bf T}_2. \] This allows the assignment of boundary coordinates for each of the nodes on this boundary. ~\newline
~\newline

\item Once this is done we can delete the {\ttfamily Face\+Elements} that defined the surface triangulation. ~\newline
~\newline

\end{DoxyEnumerate}Since the generation of the boundary coordinates by the above procedure only relies on the position of the \char`\"{}lower left\char`\"{} and \char`\"{}upper right\char`\"{} vertices (which are properties of the facet rather than the {\ttfamily tetgen} mesh) the boundary coordinates are unique, regardless of the actual discretisation generated by {\ttfamily tetgen}. Furthermore, the boundary coordinates created from the fluid and solid meshes will be consistent {\itshape provided} we reverse the direction of the outer unit normal in one of the meshes. This is exactly what the {\ttfamily switch\+\_\+normal} flag in {\ttfamily Tetgen\+Mesh\+::setup\+\_\+boundary\+\_\+coordinates(...)} is for. When generating the boundary coordinates for our problem, we switched the direction of the normal in the fluid mesh; see the section \mbox{\hyperlink{index_fluid_mesh}{The fluid mesh}}, above.

Here is an animation of the automatically-\/generated boundary coordinates along the 12 mesh boundaries that constitute the FSI boundary, when viewed from the fluid and the solid, respectively. In each of the frames the contours indicate the value of ~\newline
 $ \zeta_1 $ within the respective boundary. Note that the boundary coordinates established in the two meshes match, even though the discretisations do not.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fluid_boundary_test}
\doxyfigcaption{Contour plot of the automatically-\/generated boundary coordinates on the FSI boundary, viewed from the fluid mesh. }
\end{DoxyImage}


 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{solid_boundary_test}
\doxyfigcaption{Contour plot of the automatically-\/generated boundary coordinates on the FSI boundary, viewed from the solid mesh. }
\end{DoxyImage}


You should explore this procedure yourself as an {\bfseries{exercise\+:}} For instance you may want to explore what happens if you don\textquotesingle{}t switch the direction of the normal in the fluid mesh when generating the boundary coordinates.

\DoxyHorRuler{0}
\hypertarget{index_matching_fluid_and_solid}{}\doxysubsection{Fluid and solid meshes do not have to be matching}\label{index_matching_fluid_and_solid}
The mesh shown in the problem sketch at the beginning of this tutorial already suggested that the fluid and solid meshes do not have to match across the FSI interface. To illustrate this point more clearly, here is the result of another computation for which we generated a much finer fluid mesh, using


\begin{DoxyCode}{0}
\DoxyCodeLine{tetgen -\/a0.05 fsi\_bifurcation\_fluid.poly}

\end{DoxyCode}


The resulting tetgen {\ttfamily $\ast$.ele}, {\ttfamily $\ast$.node} and {\ttfamily $\ast$.face} files can be used with same driver code.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{finer_fluid_mesh}
\doxyfigcaption{Solution computed with a finer fluid mesh. }
\end{DoxyImage}


As an {\bfseries{exercise}}, generate some finer fluid and solid meshes yourself and confirm that they may be used without having to change the driver code.

\DoxyHorRuler{0}
\hypertarget{index_go_wrong}{}\doxysubsection{What can go wrong?}\label{index_go_wrong}
Here are a few things that can (and often do) go wrong in unstructured, three-\/dimensional FSI problems.
\begin{DoxyItemize}
\item {\bfseries{The facets that define the FSI boundary don\textquotesingle{}t match\+:}} ~\newline
~\newline
 This tends to happen if the {\ttfamily $\ast$.poly} files describing the fluid and solid meshes do not use the same facets to describe the FSI interface. While we do not expect the fluid and solid meshes themselves to match, the representation of the FSI interface via facets {\ttfamily must} be consistent. A simple way to ensure consistency is to use the following procedure\+: ~\newline
~\newline

\begin{DoxyEnumerate}
\item Write the {\ttfamily $\ast$.poly} file for the fluid mesh. Make sure that each facet is given a separate boundary ID (at least for the facets describing the FSI interface). ~\newline
~\newline

\item Solve a single-\/physics fluids problem on this mesh to check the integrity of the mesh -- the solution of this problem will also give you some insight into the expected flow field. ~\newline
~\newline

\item Make a copy of the {\ttfamily $\ast$.poly} file for the fluid mesh and modify it to describe the solid mesh, leaving the facets that define the FSI interface unchanged. This automatically ensures that the representation of the FSI boundary from the fluid\textquotesingle{}s and the solid\textquotesingle{}s point of view is consistent. ~\newline
~\newline

\item Solve a single-\/physics solids problem on this mesh to check the integrity of the mesh, e.\+g. by applying some pressure loading on the future FSI boundary -- the solution of this problem will also give you some insight into the expected wall deformation. ~\newline
~\newline

\item Couple the two problems, as shown in this tutorial. ~\newline
~\newline

\end{DoxyEnumerate}As an {\bfseries{exercise}}, modify the tetgen {\ttfamily $\ast$.poly} files and the driver code so that it can handle the extended domain considered in the \href{../../../navier_stokes/unstructured_three_d_fluid/html/index.html\#finer_mesh}{\texttt{ single-\/physics fluids problem.}} ~\newline
~\newline

\item {\bfseries{ An FSI (sub-\/)boundary is not planar\+:}} ~\newline
~\newline
 In an unstructured mesh, the FSI boundary will usually be represented by a large number of distinct mesh boundaries. The automatic setup of the boundary coordinates on these mesh boundaries requires them to be (individually) planar -- at least in the problem\textquotesingle{}s initial configuration. Provided you have followed our advice and associated each of the facets that define the FSI boundary with a different boundary ID, you should not have any problems as {\ttfamily tetgen} does not allow non-\/planar facets. ~\newline
~\newline

\item {\bfseries{ The solver does not converge\+:}} ~\newline
~\newline
 A large-\/displacement FSI problem is a highly nonlinear problem and the provision of a good initial guess for the Newton iteration is essential. We tend to proceed as follows\+: ~\newline
~\newline

\begin{DoxyEnumerate}
\item Follow the steps outlined above, to study the constituent single-\/physics problems first. This will already give you some insight into the behaviour of the problem. For instance, the solution of the single-\/physics Navier-\/\+Stokes equations at the desired Reynolds number may have to be computed via a parameter incrementation, starting from Stokes flow. Similarly, the study of the single-\/physics solid problem will reveal what load increments can be accommodated without causing the Newton iteration to diverge. ~\newline
~\newline

\item Combine the two single-\/physics problems using the steps described in this tutorial. ~\newline
~\newline

\item Switch off the fluid-\/structure interaction by ~\newline
~\newline

\begin{DoxyEnumerate}
\item setting the FSI parameter to zero, $ Q = 0, $ ~\newline
~\newline

\item commenting out the call to {\ttfamily FSI\+\_\+functions\+::setup\+\_\+fluid\+\_\+load\+\_\+info\+\_\+for\+\_\+solid\+\_\+elements(...)}, ~\newline
~\newline

\item not creating the Lagrange-\/multiplier elements that enforce the solid displacements onto the fluid mesh.
\end{DoxyEnumerate}~\newline
~\newline
 This completely uncouples the two problems, although they will be solved simultaneously, allowing you to replicate the single-\/physics parameter studies already performed. ~\newline
~\newline

\item Now switch on the various interactions, one-\/by-\/one, while carefully validating the results at each stage. We tend to proceed as follows\+: ~\newline
~\newline

\begin{DoxyEnumerate}
\item Solve the uncoupled problem at zero Reynolds number. ~\newline
~\newline

\item Increase the Reynolds number in small increments to its target value. ~\newline
~\newline

\item Re-\/enable the call to {\ttfamily FSI\+\_\+functions\+::setup\+\_\+fluid\+\_\+load\+\_\+info\+\_\+for\+\_\+solid\+\_\+elements(...)} and attach the Lagrange multiplier elements but keep $ Q = 0. $ If the solid is not loaded by any forces/tractions other than those arising from the fluid, the solution should not change as the solid remains unloaded. ~\newline
~\newline

\item Gently increase the value of the FSI parameter, $ Q $, remembering that it represents the ratio of the typical viscous fluid stresses to the stiffness of the solid. Hence, even relatively small values of $ Q $ tend to lead to relatively large solid displacements. Be gentle!
\end{DoxyEnumerate}
\end{DoxyEnumerate}~\newline
~\newline

\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/interaction/unstructured_three_d_fsi}{\texttt{ demo\+\_\+drivers/interaction/unstructured\+\_\+three\+\_\+d\+\_\+fsi }} \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/interaction/unstructured_three_d_fsi/unstructured_three_d_fsi.cc}{\texttt{ demo\+\_\+drivers/interaction/unstructured\+\_\+three\+\_\+d\+\_\+fsi/unstructured\+\_\+three\+\_\+d\+\_\+fsi.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{PDF file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
