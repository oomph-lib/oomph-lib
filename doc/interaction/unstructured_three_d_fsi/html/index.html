<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Demo problem: 3D FSI on unstructured meshes</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Demo problem: 3D FSI on unstructured meshes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial demonstrates the use of unstructured meshes in 3D fluid-structure interaction problems. We combine two single-physics problems, namely</p><ul>
<li><a href="../../../solid/unstructured_three_d_solid/html/index.html">Large deformations of an elastic 3D bifurcating tube, loaded by an internal pressure</a> <br  />
<br  />
</li>
<li><a href="../../../navier_stokes/unstructured_three_d_fluid/html/index.html">Flow through a rigid 3D bifurcating tube</a></li>
</ul>
<p>for which we have already created unstructured 3D meshes, using <a href="http://www.wias-berlin.de/~si ">Hang Si's</a> open-source mesh generator <a href="http://wias-berlin.de/software/tetgen//"><code>tetgen</code> </a>.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="the_problem"></a>
The problem</h1>
<p>The two figures below show a sketch of the problem. An applied pressure drop drives fluid through an elastic, bifurcating tube whose branches have approximately rectangular cross-sections. We solve this problem as a fully-coupled fluid-structure interaction problem in which the fluid provides the traction onto the solid whose deformation changes the fluid domain.</p>
<div class="image">
<img src="problem_sketch_forward.gif" alt=""/>
<div class="caption">
Sketch of the problem. </div></div>
 <div class="image">
<img src="problem_sketch_backward.gif" alt=""/>
<div class="caption">
Sketch of the problem (reverse view). </div></div>
 <p>As usual, we formulate the problem in non-dimensional form. For this purpose we non-dimensionalise all lengths on the half-width, <img class="formulaInl" alt="$ W $" src="form_0.png" width="14" height="10"/>, of the square inflow cross-section, and use the overall pressure drop, <img class="formulaInl" alt="$ \Delta P^* = P_{in}^* - P_{out}^* $" src="form_1.png" width="99" height="14"/> to define the (viscous) velocity scale </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\cal U} = \frac{\Delta P^*\ W}{\mu}. \]" src="form_2.png" width="76" height="30"/>
</p>
<p> With this choice the Reynolds number becomes </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ Re = \frac{\rho {\cal U} W }{\mu} = \frac{ \Delta P^* \rho W^2 }{\mu^2}, \]" src="form_3.png" width="139" height="31"/>
</p>
<p> and we choose to drive the flow by a dimensionless pressure drop of <img class="formulaInl" alt="$ \Delta P = 1. $" src="form_4.png" width="46" height="10"/> Using this non-dimensionalisation an increase in the Reynolds number may be interpreted as in increase in the applied (dimensional) pressure drop along the vessel. Note that all pressures are defined relative to an external pressure, which we set to zero.</p>
<p>We assume that the solid's constitutive equation is given by <code>oomph-lib's</code> generalised Hookean constitutive law and non-dimensionalise the solid-mechanics stresses and tractions with the Young's modulus <img class="formulaInl" alt="$ E $" src="form_5.png" width="10" height="9"/>.</p>
<p>The FSI interaction parameter <img class="formulaInl" alt="$ Q, $" src="form_6.png" width="13" height="13"/> which represents the ratio of the (viscous) fluid stress scale to the reference stress used to non-dimensionalise the solid stresses, is therefore given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ Q = \frac{\mu {\cal U}}{{\cal L} E} = \frac{\Delta P^*}{E} \ . \]" src="form_7.png" width="101" height="28"/>
</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="results"></a>
Results</h1>
<p>The animation below illustrates the system's behaviour in a parameter study in which we keep the Reynolds number fixed at <img class="formulaInl" alt="$ Re=100 $" src="form_8.png" width="50" height="10"/> while increasing the FSI parameter <img class="formulaInl" alt="$ Q $" src="form_9.png" width="10" height="13"/> in small increments. The increase in <img class="formulaInl" alt="$ Q $" src="form_9.png" width="10" height="13"/> may be interpreted as a reduction in the tube's stiffness and the animation shows clearly how this increases the flow-induced deformation: the upstream end bulges and the downstream end is compressed.</p>
<div class="image">
<img src="unstructured_fluid.gif" alt=""/>
<div class="caption">
Animation of the flow field (pressure contours and velocity vectors). </div></div>
 <div class="image">
<img src="unstructured_solid.gif" alt=""/>
<div class="caption">
Animation of the wall deformation -- the vectors indicate the fluid load. </div></div>
 <hr  />
 <hr  />
<h1><a class="anchor" id="overview_implementation"></a>
Overview of the implementation</h1>
<p>The general procedure described below is essentially the same as that discussed in the <a href="../../unstructured_fsi/html/index.html">two-dimensional unstructured FSI tutorial. </a> The use of an unstructured mesh means that the most convenient node-update strategy for the fluid mesh is to treat it as a pseudo-elastic solid. Nonetheless, the majority of the steps described below are the same as for other fluid-structure-interaction problems.</p>
<p>We reiterate that an important prerequisite for the use of the automatic <code>FSI_functions</code> is that each boundary between fluid and solid meshes must be parametrised by boundary coordinates. Moreover, the boundary-coordinate representations <b> must </b> be the same in both the fluid and solid meshes. This use of a continuous-coordinate representation of the boundaries means that the fluid and solid meshes do not need to match at the boundaries; see the section <a class="el" href="index.html#matching_fluid_and_solid">Fluid and solid meshes do not have to be matching</a>. Unfortunately, the construction of a global surface parametrisation of a general surface is a non-trivial problem. We side-step this problem by making use of the fact that any third-party tetrahedral mesh generator represents domain boundaries using a surface triangulation, or planar surface facets. As the mesh is imported into <code>oomph-lib</code>, each surface facet is treated as a separate boundary and given a unique boundary identifier. The surface parametrisation of each facet is then simply given by local coordinates of the plane; see <a class="el" href="index.html#boundary_coord">How the boundary coordinates are generated</a>. A consequence of this approach is that the physical boundaries will consist of several mesh "boundaries", as already discussed in the single-physics problems.</p>
<p>Since the driver code, discussed in detail below, is somewhat lengthy (partly because of the large number of self-tests and diagnostics included), we provide a brief overview of the main steps required to solve this problem: <br  />
<br  />
</p><ol type="1">
<li>Use the unstructured 3D mesh generator <a href="http://wias-berlin.de/software/tetgen//"><code>tetgen</code> </a> to generate the solid mesh, using the procedure discussed in <a href="../../../solid/unstructured_three_d_solid/html/index.html#mesh">another tutorial.</a> <br  />
<br  />
</li>
<li>Use the same procedure to generate the fluid mesh, as discussed in <a href="../../../navier_stokes/unstructured_three_d_fluid/html/index.html#mesh">the single-physics fluids tutorial.</a> Make sure that the fluid mesh is derived from the <code>SolidMesh</code> base class to allow the use of pseudo-elasticity to update the nodal positions in response to the deformation of the domain boundary. <br  />
<br  />
</li>
<li>Ensure that boundary coordinates are set up (consistently) on the FSI interface between the two meshes. For meshes derived from <code>oomph-lib's</code> <code>TetgenMesh</code> class, this may be done by calling the function <code>TetgenMesh::setup_boundary_coordinates()</code>; see the section <a class="el" href="index.html#boundary_coord">How the boundary coordinates are generated</a> for details. <br  />
<br  />
</li>
<li>Attach <code>FSISolidTractionElements</code> to the faces of the "bulk" solid elements that are exposed to the fluid flow. These elements will apply the fluid traction to the solid. <br  />
<br  />
</li>
<li>Combine the <code>FSISolidTractionElements</code> to a compound <code>GeomObject</code> that provides a continuous representation of the solid's FSI boundary, required by the <code>ImposeDisplacementByLagrangeMultiplierElements</code> described below. <br  />
<br  />
</li>
<li>Attach <code>ImposeDisplacementByLagrangeMultiplierElements</code> to the faces of the "bulk" fluid elements that are adjacent to the solid. These elements will employ Lagrange multipliers to deform the pseudo-solid fluid mesh so that its shape remains consistent with the motion of the solid's FSI boundary (as described by the compound <code>GeomObject</code> created in the previous step). <br  />
<br  />
</li>
<li>Determine the "bulk" fluid elements that are adjacent to the integration points of the <code>FSISolidTractionElements</code>, using the function <code>FSI_functions::setup_fluid_load_info_for_solid_elements(...)</code>. <br  />
<br  />
</li>
</ol>
<p>In our experience, just as in two-dimensions, the most error-prone part of this procedure is the identification of the mesh boundaries. In particular, if the description of the FSI interface as viewed from the fluid and solid meshes is inconsistent, the automatic matching of the unstructured fluid and solid meshes will not work (see <a class="el" href="index.html#boundary_coord">How the boundary coordinates are generated</a> for details). For this reason, the driver code presented below generates a lot of output that can be used to identify and fix such problems. See also the section <a class="el" href="index.html#go_wrong">What can go wrong?</a> at the end of this tutorial.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="namespace"></a>
Problem Parameters</h1>
<p>As usual we define the various problem parameters in a global namespace. We define the Reynolds number, <img class="formulaInl" alt="$ Re $" src="form_10.png" width="15" height="10"/>, and the FSI interaction parameter <img class="formulaInl" alt="$ Q $" src="form_9.png" width="10" height="13"/>.</p>
 <div class="fragment"><div class="line"><span class="comment">//=======start_of_namespace==========================================</span></div>
<div class="line"><span class="comment">/// Global variables</span></div>
<div class="line"><span class="comment"></span><span class="comment">//================================================================</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceGlobal__Parameters.html">Global_Parameters</a></div>
<div class="line">{</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Default Reynolds number</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Parameters.html#a9d72e94a9305c6a310940a6a427ebe06">Re</a>=100.0; </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Default FSI parameter</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Parameters.html#a7814fddf663e56168174a42d2cd6b4c1">Q</a>=0.0;</div>
<div class="ttc" id="anamespaceGlobal__Parameters_html"><div class="ttname"><a href="namespaceGlobal__Parameters.html">Global_Parameters</a></div><div class="ttdoc">/////////////////////////////////////////////////////////////// /////////////////////////////////////...</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00156">unstructured_three_d_fsi.cc:157</a></div></div>
<div class="ttc" id="anamespaceGlobal__Parameters_html_a7814fddf663e56168174a42d2cd6b4c1"><div class="ttname"><a href="namespaceGlobal__Parameters.html#a7814fddf663e56168174a42d2cd6b4c1">Global_Parameters::Q</a></div><div class="ttdeci">double Q</div><div class="ttdoc">Default FSI parameter.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00163">unstructured_three_d_fsi.cc:163</a></div></div>
<div class="ttc" id="anamespaceGlobal__Parameters_html_a9d72e94a9305c6a310940a6a427ebe06"><div class="ttname"><a href="namespaceGlobal__Parameters.html#a9d72e94a9305c6a310940a6a427ebe06">Global_Parameters::Re</a></div><div class="ttdeci">double Re</div><div class="ttdoc">Default Reynolds number.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00160">unstructured_three_d_fsi.cc:160</a></div></div>
</div><!-- fragment --><p> We provide a pointer to the constitutive equation for the solid. For simplicity, the same constitutive equation will also be used for the (pseudo-)solid elements that determine the deformation of the fluid mesh. In general, of course, a different constitutive equation can (and probably should) be used to control the mesh motion.</p>
<div class="fragment"><div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to constitutive law</span></div>
<div class="line"><span class="comment"></span> ConstitutiveLaw* <a class="code" href="namespaceGlobal__Parameters.html#adbd1f040f375c96fe56b3f475f7dbec2">Constitutive_law_pt</a>=0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Poisson&#39;s ratio for generalised Hookean constitutive equation</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Parameters.html#a20fccdcfa2c15ad8b951b9ada3bb1661">Nu</a>=0.3;</div>
<div class="ttc" id="anamespaceGlobal__Parameters_html_a20fccdcfa2c15ad8b951b9ada3bb1661"><div class="ttname"><a href="namespaceGlobal__Parameters.html#a20fccdcfa2c15ad8b951b9ada3bb1661">Global_Parameters::Nu</a></div><div class="ttdeci">double Nu</div><div class="ttdoc">Poisson's ratio for generalised Hookean constitutive equation.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00169">unstructured_three_d_fsi.cc:169</a></div></div>
<div class="ttc" id="anamespaceGlobal__Parameters_html_adbd1f040f375c96fe56b3f475f7dbec2"><div class="ttname"><a href="namespaceGlobal__Parameters.html#adbd1f040f375c96fe56b3f475f7dbec2">Global_Parameters::Constitutive_law_pt</a></div><div class="ttdeci">ConstitutiveLaw * Constitutive_law_pt</div><div class="ttdoc">Pointer to constitutive law.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00166">unstructured_three_d_fsi.cc:166</a></div></div>
</div><!-- fragment --><p> Finally, we define the tractions that act on the fluid at the in- and outflow cross-sections. We enforce the non-dimensional pressure drop of <img class="formulaInl" alt="$ \Delta P = 1$" src="form_11.png" width="43" height="10"/> (on the viscous scale) by setting <img class="formulaInl" alt="$ P_{in} = -P_{out}=0.5 $" src="form_12.png" width="100" height="13"/>, thus pressurising the tube's upstream end while applying an equal and opposite "suction" downstream. (Note that in the <br  />
 <a href="../../../navier_stokes/unstructured_three_d_fluid/html/index.html">corresponding single-physics fluids problem</a> the actual pressure values were irrelevant because the vessel walls were rigid. In the FSI problem considered here it obviously makes a big difference if the fluid pressure is positive or negative because the external reference pressure is set to zero.)</p>
<div class="fragment"><div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Fluid pressure on inflow boundary</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Parameters.html#a05b26d00935600b5e0149872844f224c">P_in</a>=0.5;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Applied traction on fluid at the inflow boundary</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceGlobal__Parameters.html#af7faf65214ed9ead637f7c208addb095">prescribed_inflow_traction</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; t,</div>
<div class="line">                                 <span class="keyword">const</span> Vector&lt;double&gt;&amp; x,</div>
<div class="line">                                 <span class="keyword">const</span> Vector&lt;double&gt;&amp; n,</div>
<div class="line">                                 Vector&lt;double&gt;&amp; traction)</div>
<div class="line"> {</div>
<div class="line">  traction[0]=0.0;</div>
<div class="line">  traction[1]=0.0;</div>
<div class="line">  traction[2]=<a class="code" href="namespaceGlobal__Parameters.html#a05b26d00935600b5e0149872844f224c">P_in</a>;</div>
<div class="line"> } </div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Fluid pressure on outflow boundary</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Parameters.html#ac680ed856897793d54c9c867da19169c">P_out</a>=-0.5; </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Applied traction on fluid at the inflow boundary</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceGlobal__Parameters.html#a83155358b144cff7e29ecb6b209a2d3e">prescribed_outflow_traction</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; t,</div>
<div class="line">                                  <span class="keyword">const</span> Vector&lt;double&gt;&amp; x,</div>
<div class="line">                                  <span class="keyword">const</span> Vector&lt;double&gt;&amp; n,</div>
<div class="line">                                  Vector&lt;double&gt;&amp; traction)</div>
<div class="line"> {</div>
<div class="line">  traction[0]=0.0;</div>
<div class="line">  traction[1]=0.0;</div>
<div class="line">  traction[2]=-<a class="code" href="namespaceGlobal__Parameters.html#ac680ed856897793d54c9c867da19169c">P_out</a>;</div>
<div class="line"> } </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">} <span class="comment">//end_of_namespace</span></div>
<div class="ttc" id="anamespaceGlobal__Parameters_html_a05b26d00935600b5e0149872844f224c"><div class="ttname"><a href="namespaceGlobal__Parameters.html#a05b26d00935600b5e0149872844f224c">Global_Parameters::P_in</a></div><div class="ttdeci">double P_in</div><div class="ttdoc">Fluid pressure on inflow boundary.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00172">unstructured_three_d_fsi.cc:172</a></div></div>
<div class="ttc" id="anamespaceGlobal__Parameters_html_a83155358b144cff7e29ecb6b209a2d3e"><div class="ttname"><a href="namespaceGlobal__Parameters.html#a83155358b144cff7e29ecb6b209a2d3e">Global_Parameters::prescribed_outflow_traction</a></div><div class="ttdeci">void prescribed_outflow_traction(const double &amp;t, const Vector&lt; double &gt; &amp;x, const Vector&lt; double &gt; &amp;n, Vector&lt; double &gt; &amp;traction)</div><div class="ttdoc">Applied traction on fluid at the inflow boundary.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00190">unstructured_three_d_fsi.cc:190</a></div></div>
<div class="ttc" id="anamespaceGlobal__Parameters_html_ac680ed856897793d54c9c867da19169c"><div class="ttname"><a href="namespaceGlobal__Parameters.html#ac680ed856897793d54c9c867da19169c">Global_Parameters::P_out</a></div><div class="ttdeci">double P_out</div><div class="ttdoc">Fluid pressure on outflow boundary.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00187">unstructured_three_d_fsi.cc:187</a></div></div>
<div class="ttc" id="anamespaceGlobal__Parameters_html_af7faf65214ed9ead637f7c208addb095"><div class="ttname"><a href="namespaceGlobal__Parameters.html#af7faf65214ed9ead637f7c208addb095">Global_Parameters::prescribed_inflow_traction</a></div><div class="ttdeci">void prescribed_inflow_traction(const double &amp;t, const Vector&lt; double &gt; &amp;x, const Vector&lt; double &gt; &amp;n, Vector&lt; double &gt; &amp;traction)</div><div class="ttdoc">Applied traction on fluid at the inflow boundary.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00175">unstructured_three_d_fsi.cc:175</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="mesh_code"></a>
Creating the meshes</h1>
<h2><a class="anchor" id="solid_mesh"></a>
The solid mesh</h2>
<p>Following the procedure discussed in the <a href="../../../solid/unstructured_three_d_solid/html/index.html">single-physics solid mechanics problem</a> we create the mesh for the elastic tube using multiple inheritance from <code>oomph-lib's</code> <code>TetgenMesh</code> and the <code>SolidMesh</code> base class.</p>
 <div class="fragment"><div class="line"><span class="comment">//==========start_solid_mesh===============================================</span></div>
<div class="line"><span class="comment">/// Tetgen-based mesh upgraded to become a solid mesh</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classMySolidTetgenMesh.html">MySolidTetgenMesh</a> : <span class="keyword">public</span> <span class="keyword">virtual</span> TetgenMesh&lt;ELEMENT&gt;, </div>
<div class="line">                       <span class="keyword">public</span> <span class="keyword">virtual</span> SolidMesh </div>
<div class="line">{</div>
<div class="ttc" id="aclassMySolidTetgenMesh_html"><div class="ttname"><a href="classMySolidTetgenMesh.html">MySolidTetgenMesh</a></div><div class="ttdoc">Tetgen-based mesh upgraded to become a solid mesh.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00048">unstructured_three_d_fsi.cc:50</a></div></div>
</div><!-- fragment --><p> As before, we set the Lagrangian coordinates to the current nodal positions to make the initial configuration stress-free. Next, we identify the elements next to the various boundaries (<a href="../../../solid/unstructured_three_d_solid/html/index.html">recall </a> that the domain boundaries are specified in the tetgen <code>*.poly</code> file), and set up the boundary coordinates. Adopting our usual state of continuous paranoia, we document these elements to facilitate debugging; see the section <a class="el" href="index.html#boundary_coord">How the boundary coordinates are generated</a> for details.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Constructor: </span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classMySolidTetgenMesh.html">MySolidTetgenMesh</a>(<span class="keyword">const</span> std::string&amp; node_file_name,</div>
<div class="line">                <span class="keyword">const</span> std::string&amp; element_file_name,</div>
<div class="line">                <span class="keyword">const</span> std::string&amp; face_file_name,</div>
<div class="line">                TimeStepper* time_stepper_pt=</div>
<div class="line">                &amp;Mesh::Default_TimeStepper) : </div>
<div class="line">  TetgenMesh&lt;ELEMENT&gt;(node_file_name, element_file_name,</div>
<div class="line">                      face_file_name, time_stepper_pt)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Assign the Lagrangian coordinates</span></div>
<div class="line">   set_lagrangian_nodal_coordinates();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Find elements next to boundaries</span></div>
<div class="line">   setup_boundary_element_info();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Setup boundary coordinates for all boundaries</span></div>
<div class="line">   <span class="keywordtype">char</span> filename[100];</div>
<div class="line">   ofstream some_file;</div>
<div class="line">   <span class="keywordtype">unsigned</span> nb=this-&gt;nboundary();</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> b=0;b&lt;nb;b++)</div>
<div class="line">    {</div>
<div class="line">     sprintf(filename,<span class="stringliteral">&quot;RESLT/solid_boundary_test%i.dat&quot;</span>,b);</div>
<div class="line">     some_file.open(filename);</div>
<div class="line">     this-&gt;<span class="keyword">template</span> setup_boundary_coordinates&lt;ELEMENT&gt;(b,some_file);</div>
<div class="line">     some_file.close();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Empty Destructor</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">virtual</span> ~<a class="code" href="classMySolidTetgenMesh.html">MySolidTetgenMesh</a>() { }</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="fluid_mesh"></a>
The fluid mesh</h2>
<p>The creation of the fluid mesh follows the same process but uses the mesh created for the <br  />
 <a href="../../../navier_stokes/unstructured_three_d_fluid/html/index.html">single-physics fluids problem.</a> The use of multiple inheritance from the <code>TetgenMesh</code> and <code>SolidMesh</code> base classes is required to use pseudo-solid node-update techniques to move the fluid nodes in response to changes in the domain boundary. We refer to the <a href="../../../navier_stokes/unstructured_three_d_fluid/html/index.html">fluids tutorial</a> for a discussion of the <code>split_corner_elements</code> flag.</p>
<div class="fragment"><div class="line"><span class="comment">//==============start_fluid_mesh===========================================</span></div>
<div class="line"><span class="comment">/// Tetgen-based mesh upgraded to become a (pseudo-) solid mesh</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classFluidTetMesh.html">FluidTetMesh</a> : <span class="keyword">public</span> <span class="keyword">virtual</span> TetgenMesh&lt;ELEMENT&gt;,</div>
<div class="line">                     <span class="keyword">public</span> <span class="keyword">virtual</span> SolidMesh </div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Constructor: </span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classFluidTetMesh.html#a5f8ea145d68623198abc97209a0491a6">FluidTetMesh</a>(<span class="keyword">const</span> std::string&amp; node_file_name,</div>
<div class="line">              <span class="keyword">const</span> std::string&amp; element_file_name,</div>
<div class="line">              <span class="keyword">const</span> std::string&amp; face_file_name,</div>
<div class="line">              <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; split_corner_elements,</div>
<div class="line">              TimeStepper* time_stepper_pt=</div>
<div class="line">              &amp;Mesh::Default_TimeStepper) : </div>
<div class="line">  TetgenMesh&lt;ELEMENT&gt;(node_file_name, element_file_name,</div>
<div class="line">                      face_file_name, split_corner_elements, </div>
<div class="line">                      time_stepper_pt)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Assign the Lagrangian coordinates</span></div>
<div class="line">   set_lagrangian_nodal_coordinates();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Find out elements next to boundary</span></div>
<div class="line">   setup_boundary_element_info();</div>
<div class="ttc" id="aclassFluidTetMesh_html"><div class="ttname"><a href="classFluidTetMesh.html">FluidTetMesh</a></div><div class="ttdoc">//////////////////////////////////////////////////////////////////// ////////////////////////////////...</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00098">unstructured_three_d_fsi.cc:100</a></div></div>
<div class="ttc" id="aclassFluidTetMesh_html_a5f8ea145d68623198abc97209a0491a6"><div class="ttname"><a href="classFluidTetMesh.html#a5f8ea145d68623198abc97209a0491a6">FluidTetMesh::FluidTetMesh</a></div><div class="ttdeci">FluidTetMesh(const std::string &amp;node_file_name, const std::string &amp;element_file_name, const std::string &amp;face_file_name, const bool &amp;split_corner_elements, TimeStepper *time_stepper_pt=&amp;Mesh::Default_TimeStepper)</div><div class="ttdoc">Constructor:</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00105">unstructured_three_d_fsi.cc:105</a></div></div>
</div><!-- fragment --><p> We create boundary coordinates along all mesh boundaries. To ensure that fluid and solid boundary coordinates are aligned properly, we use the flag <code>switch_normal</code> to change the direction of the normal vector for the fluid mesh; see <a class="el" href="index.html#boundary_coord">How the boundary coordinates are generated</a> for details.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">   <span class="comment">// Setup boundary coordinates for boundary.</span></div>
<div class="line">   <span class="comment">// To be consistent with the boundary coordinates generated</span></div>
<div class="line">   <span class="comment">// in the solid, we switch the direction of the normal.</span></div>
<div class="line">   <span class="comment">// (Both meshes are generated from the same polygonal facets</span></div>
<div class="line">   <span class="comment">// at the FSI interface).</span></div>
<div class="line">   <span class="keywordtype">bool</span> switch_normal=<span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Setup boundary coordinates for all boundaries</span></div>
<div class="line">   <span class="keywordtype">char</span> filename[100];</div>
<div class="line">   ofstream some_file;</div>
<div class="line">   <span class="keywordtype">unsigned</span> nb=this-&gt;nboundary();</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> b=0;b&lt;nb;b++) </div>
<div class="line">    {</div>
<div class="line">     sprintf(filename,<span class="stringliteral">&quot;RESLT/fluid_boundary_test%i.dat&quot;</span>,b);</div>
<div class="line">     some_file.open(filename);</div>
<div class="line">     this-&gt;<span class="keyword">template</span> setup_boundary_coordinates&lt;ELEMENT&gt;(b,switch_normal,some_file);</div>
<div class="line">     some_file.close();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Empty Destructor</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">virtual</span> ~<a class="code" href="classFluidTetMesh.html">FluidTetMesh</a>() { }</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="main"></a>
The driver code</h1>
<p>We specify an output directory and instantiate the constitutive equation (<code>oomph-lib's</code> generalisation of Hooke's law), specifying a Poisson ratio of 0.3. As discussed above, this constitutive equation will be used for the "proper" solid mechanics that determines the deformation of the elastic vessel walls, and for the pseudo-solid that determines the deformation of the fluid mesh.</p>
 <div class="fragment"><div class="line"><span class="comment">//========================= start_of_main=================================</span></div>
<div class="line"><span class="comment">/// Demonstrate how to solve an unstructured 3D FSI problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="unstructured__three__d__fsi_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Label for output</span></div>
<div class="line"> DocInfo doc_info;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output directory</span></div>
<div class="line"> doc_info.set_directory(<span class="stringliteral">&quot;RESLT&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create generalised Hookean constitutive equations</span></div>
<div class="line"> <a class="code" href="namespaceGlobal__Parameters.html#adbd1f040f375c96fe56b3f475f7dbec2">Global_Parameters::Constitutive_law_pt</a> = </div>
<div class="line">  <span class="keyword">new</span> GeneralisedHookean(&amp;<a class="code" href="namespaceGlobal__Parameters.html#a20fccdcfa2c15ad8b951b9ada3bb1661">Global_Parameters::Nu</a>);</div>
<div class="ttc" id="aunstructured__three__d__fsi_8cc_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="unstructured__three__d__fsi_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdoc">Demonstrate how to solve an unstructured 3D FSI problem.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l01002">unstructured_three_d_fsi.cc:1002</a></div></div>
</div><!-- fragment --><p> We create the <code>Problem</code> object and output the initial guess for the solution.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">//Set up the problem</span></div>
<div class="line"> <a class="code" href="classUnstructuredFSIProblem.html">UnstructuredFSIProblem</a>&lt;</div>
<div class="line"> PseudoSolidNodeUpdateElement&lt;TTaylorHoodElement&lt;3&gt;, TPVDElement&lt;3,3&gt; &gt;,</div>
<div class="line">  TPVDElement&lt;3,3&gt; &gt; problem;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Output initial configuration</span></div>
<div class="line"> problem.<a class="code" href="classUnstructuredFSIProblem.html#a15f581318b505de07f50bd570da8c8d0">doc_solution</a>(doc_info);</div>
<div class="line"> doc_info.number()++;   </div>
<div class="ttc" id="aclassUnstructuredFSIProblem_html"><div class="ttname"><a href="classUnstructuredFSIProblem.html">UnstructuredFSIProblem</a></div><div class="ttdoc">Unstructured 3D FSI problem.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00212">unstructured_three_d_fsi.cc:213</a></div></div>
<div class="ttc" id="aclassUnstructuredFSIProblem_html_a15f581318b505de07f50bd570da8c8d0"><div class="ttname"><a href="classUnstructuredFSIProblem.html#a15f581318b505de07f50bd570da8c8d0">UnstructuredFSIProblem::doc_solution</a></div><div class="ttdeci">void doc_solution(DocInfo &amp;doc_info)</div><div class="ttdoc">Doc the solution.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00934">unstructured_three_d_fsi.cc:935</a></div></div>
</div><!-- fragment --><p> Finally, we perform a parameter study in which we compute the solution of the fully-coupled FSI problem for increasing values of the FSI parameter <img class="formulaInl" alt="$ Q $" src="form_9.png" width="10" height="13"/> &ndash; physically, an increase in <img class="formulaInl" alt="$ Q $" src="form_9.png" width="10" height="13"/> can be interpreted as a reduction in the stiffness of the tube walls while keeping the fluid properties and the driving pressure drop constant.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Parameter study</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nstep=2;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Increment in FSI parameter</span></div>
<div class="line"> <span class="keywordtype">double</span> q_increment=5.0e-2;</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> istep=0;istep&lt;nstep;istep++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Solve the problem</span></div>
<div class="line">   problem.newton_solve();</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Output solution</span></div>
<div class="line">   problem.doc_solution(doc_info);</div>
<div class="line">   doc_info.number()++;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Bump up FSI parameter</span></div>
<div class="line">   <a class="code" href="namespaceGlobal__Parameters.html#a7814fddf663e56168174a42d2cd6b4c1">Global_Parameters::Q</a>+=q_increment;   </div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end_of_main</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="class"></a>
The Problem class</h1>
<p>The <code>Problem</code> class has the usual members, with access functions to the fluid and solid meshes, and a post-processing routine.</p>
 <div class="fragment"><div class="line"><span class="comment">//===============start_of_problem_class===============================</span></div>
<div class="line"><span class="comment">/// Unstructured 3D FSI problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> FLUID_ELEMENT, <span class="keyword">class</span> SOLID_ELEMENT&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classUnstructuredFSIProblem.html">UnstructuredFSIProblem</a> : <span class="keyword">public</span> Problem</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Constructor: </span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classUnstructuredFSIProblem.html#a6a31fd839e0215ef1312942cf7284bd2">UnstructuredFSIProblem</a>();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Destructor (empty)</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classUnstructuredFSIProblem.html#a976a81e0dee902f6713bd8ca4d79d000">~UnstructuredFSIProblem</a>(){}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Doc the solution</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classUnstructuredFSIProblem.html#a15f581318b505de07f50bd570da8c8d0">doc_solution</a>(DocInfo&amp; doc_info);</div>
<div class="ttc" id="aclassUnstructuredFSIProblem_html_a6a31fd839e0215ef1312942cf7284bd2"><div class="ttname"><a href="classUnstructuredFSIProblem.html#a6a31fd839e0215ef1312942cf7284bd2">UnstructuredFSIProblem::UnstructuredFSIProblem</a></div><div class="ttdeci">UnstructuredFSIProblem()</div><div class="ttdoc">Constructor:</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00318">unstructured_three_d_fsi.cc:318</a></div></div>
<div class="ttc" id="aclassUnstructuredFSIProblem_html_a976a81e0dee902f6713bd8ca4d79d000"><div class="ttname"><a href="classUnstructuredFSIProblem.html#a976a81e0dee902f6713bd8ca4d79d000">UnstructuredFSIProblem::~UnstructuredFSIProblem</a></div><div class="ttdeci">~UnstructuredFSIProblem()</div><div class="ttdoc">Destructor (empty)</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00221">unstructured_three_d_fsi.cc:221</a></div></div>
</div><!-- fragment --><p> We provide several helper functions to create the <code>FaceElements</code> that (i) apply the applied traction on the fluid at the in- and outflow cross-sections; (ii) apply the fluid traction onto the solid, and (iii) create the Lagrange multipliers that apply the solid displacement onto the pseudo-solid fluid mesh.</p>
<div class="fragment"><div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Create fluid traction elements at inflow</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> create_fluid_traction_elements();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Create FSI traction elements</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> create_fsi_traction_elements();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Create elements that enforce prescribed boundary motion</span></div>
<div class="line"><span class="comment"> /// for the pseudo-solid fluid mesh by Lagrange multipliers</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> create_lagrange_multiplier_elements();</div>
</div><!-- fragment --><p>We also provide a helper function that documents the boundary coordinates on the solid mesh. <br  />
</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Sanity check: Doc boundary coordinates on i-th solid FSI interface</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> doc_solid_boundary_coordinates(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; i);</div>
</div><!-- fragment --><p> Finally we provide a large number of additional helper functions that specify the various mesh boundaries (as defined in the tetgen <code>*.poly</code> file) that make up the physical boundaries of interest: the in- and outflow boundaries in the fluid domain; the FSI boundaries of the fluid and solid domains and the boundaries along which the tube wall is held in a fixed position.</p>
<div class="fragment"><div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Return total number of mesh boundaries that make up the inflow </span></div>
<div class="line"><span class="comment"> /// boundary</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">unsigned</span> nfluid_inflow_traction_boundary()</div>
<div class="line">  {<span class="keywordflow">return</span> Inflow_boundary_id.size();}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> ///  Return total number of mesh boundaries that make up the outflow </span></div>
<div class="line"><span class="comment"> /// boundary</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">unsigned</span> nfluid_outflow_traction_boundary()</div>
<div class="line">  {<span class="keywordflow">return</span> Outflow_boundary_id.size();}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Return total number of mesh boundaries that make up the </span></div>
<div class="line"><span class="comment"> /// in- and outflow boundaries where a traction has to be applied</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">unsigned</span> nfluid_traction_boundary()</div>
<div class="line">  {<span class="keywordflow">return</span> Inflow_boundary_id.size()+Outflow_boundary_id.size();}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Return total number of mesh boundaries in the solid mesh that</span></div>
<div class="line"><span class="comment"> /// make up the FSI interface</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">unsigned</span> nsolid_fsi_boundary()</div>
<div class="line">  {<span class="keywordflow">return</span> Solid_fsi_boundary_id.size();}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Return total number of mesh boundaries in the fluid mesh that</span></div>
<div class="line"><span class="comment"> /// make up the FSI interface</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">unsigned</span> nfluid_fsi_boundary()</div>
<div class="line">  {<span class="keywordflow">return</span> Fluid_fsi_boundary_id.size();}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Return total number of mesh boundaries in the solid mesh </span></div>
<div class="line"><span class="comment"> /// where the position is pinned.</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">unsigned</span> npinned_solid_boundary()</div>
<div class="line">  {<span class="keywordflow">return</span> Pinned_solid_boundary_id.size();} </div>
<div class="line">  <span class="comment">//end npinned_solid_boundary</span></div>
</div><!-- fragment --><p> The private member data includes pointers to the various meshes and the <code>GeomObject</code> representation of the FSI boundary (created from the <code>FaceElements</code> attached to the solid mesh).</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Bulk solid mesh</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classMySolidTetgenMesh.html">MySolidTetgenMesh&lt;SOLID_ELEMENT&gt;</a>* Solid_mesh_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Meshes of FSI traction elements</span></div>
<div class="line"><span class="comment"></span> Vector&lt;SolidMesh*&gt; Solid_fsi_traction_mesh_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Bulk fluid mesh</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classFluidTetMesh.html">FluidTetMesh&lt;FLUID_ELEMENT&gt;</a>* Fluid_mesh_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Meshes of fluid traction elements that apply pressure at in/outflow</span></div>
<div class="line"><span class="comment"></span> Vector&lt;Mesh*&gt; Fluid_traction_mesh_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Meshes of Lagrange multiplier elements</span></div>
<div class="line"><span class="comment"></span> Vector&lt;SolidMesh*&gt; Lagrange_multiplier_mesh_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// GeomObject incarnations of the FSI boundary in the solid mesh</span></div>
<div class="line"><span class="comment"></span> Vector&lt;MeshAsGeomObject*&gt;</div>
<div class="line"> Solid_fsi_boundary_pt;</div>
</div><!-- fragment --><p> Finally, here are the vectors that store the mesh boundary IDs associated with the various domain boundaries of interest.</p>
<div class="fragment"><div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// IDs of solid mesh boundaries where displacements are pinned</span></div>
<div class="line"><span class="comment"></span> Vector&lt;unsigned&gt; Pinned_solid_boundary_id;</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment"> /// IDs of solid mesh boundaries which make up the FSI interface</span></div>
<div class="line"><span class="comment"></span> Vector&lt;unsigned&gt; Solid_fsi_boundary_id;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// IDs of fluid mesh boundaries along which inflow boundary conditions</span></div>
<div class="line"><span class="comment"> /// are applied</span></div>
<div class="line"><span class="comment"></span> Vector&lt;unsigned&gt; Inflow_boundary_id;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// IDs of fluid mesh boundaries along which inflow boundary conditions</span></div>
<div class="line"><span class="comment"> /// are applied</span></div>
<div class="line"><span class="comment"></span> Vector&lt;unsigned&gt; Outflow_boundary_id;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// IDs of fluid mesh boundaries which make up the FSI interface</span></div>
<div class="line"><span class="comment"></span> Vector&lt;unsigned&gt; Fluid_fsi_boundary_id;</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="constructor"></a>
The Problem constructor</h1>
<p>We start by building the fluid mesh, using the files created by <a href="http://wias-berlin.de/software/tetgen//"><code>tetgen</code> </a>; see the discussion in the corresponding <a href="../../../navier_stokes/unstructured_three_d_fluid/html/index.html#mesh">single-physics fluids problem.</a></p>
<div class="fragment"><div class="line"><span class="comment">//==========start_of_constructor==========================================</span></div>
<div class="line"><span class="comment">/// Constructor for unstructured 3D FSI problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> FLUID_ELEMENT, <span class="keyword">class</span> SOLID_ELEMENT&gt;</div>
<div class="line"><a class="code" href="classUnstructuredFSIProblem.html#a6a31fd839e0215ef1312942cf7284bd2">UnstructuredFSIProblem&lt;FLUID_ELEMENT,SOLID_ELEMENT&gt;::UnstructuredFSIProblem</a>()</div>
<div class="line">{ </div>
<div class="line"> <span class="comment">// Define fluid mesh and its distinguished boundaries</span></div>
<div class="line"> <span class="comment">//---------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Create fluid bulk mesh, sub-dividing &quot;corner&quot; elements</span></div>
<div class="line"> <span class="keywordtype">string</span> node_file_name=<span class="stringliteral">&quot;fsi_bifurcation_fluid.1.node&quot;</span>;</div>
<div class="line"> <span class="keywordtype">string</span> element_file_name=<span class="stringliteral">&quot;fsi_bifurcation_fluid.1.ele&quot;</span>;</div>
<div class="line"> <span class="keywordtype">string</span> face_file_name=<span class="stringliteral">&quot;fsi_bifurcation_fluid.1.face&quot;</span>;</div>
<div class="line"> <span class="keywordtype">bool</span> split_corner_elements=<span class="keyword">true</span>;</div>
<div class="line"> Fluid_mesh_pt =  <span class="keyword">new</span> <a class="code" href="classFluidTetMesh.html">FluidTetMesh&lt;FLUID_ELEMENT&gt;</a>(node_file_name,</div>
<div class="line">                                                  element_file_name,</div>
<div class="line">                                                  face_file_name,</div>
<div class="line">                                                  split_corner_elements);</div>
</div><!-- fragment --><p>Next we associated the <code>tetgen</code> boundary IDs with the various boundaries of interest: The inflow boundary is represented by <code>tetgen</code> boundary 0, and the two outflow boundaries have IDs 1 and 2.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// The following corresponds to the boundaries as specified by</span></div>
<div class="line"> <span class="comment">// facets in the tetgen input:</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Fluid mesh has one inflow boundary: Boundary 0</span></div>
<div class="line"> Inflow_boundary_id.resize(1);</div>
<div class="line"> Inflow_boundary_id[0]=0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Fluid mesh has two outflow boundaries: Boundaries 1 and 2</span></div>
<div class="line"> Outflow_boundary_id.resize(2);</div>
<div class="line"> Outflow_boundary_id[0]=1;</div>
<div class="line"> Outflow_boundary_id[1]=2;</div>
</div><!-- fragment --><p> The FSI boundary (i.e. the boundary of the fluid mesh that is exposed to the elastic vessel wall) comprises 12 separate tetgen facets which were numbered 3 to 14 in the <code>*.poly</code> that describes the fluid mesh.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// The remaining fluid boundaries are FSI boundaries.</span></div>
<div class="line"> <span class="comment">// Note that their order (as indexed in this vector, not</span></div>
<div class="line"> <span class="comment">// their actual numbers) have to match those in the corresponding</span></div>
<div class="line"> <span class="comment">// lookup scheme for the solid.</span></div>
<div class="line"> Fluid_fsi_boundary_id.resize(12);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;12;i++)</div>
<div class="line">  {</div>
<div class="line">   Fluid_fsi_boundary_id[i]=i+3;</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Next, we create the solid mesh, using the files created by <a href="http://wias-berlin.de/software/tetgen//"><code>tetgen</code> </a>; see the discussion in the corresponding <a href="../../../solid/unstructured_three_d_solid/html/index.html#mesh">single-physics solids problem.</a></p>
<div class="fragment"><div class="line"> <span class="comment">// Define solid mesh and its distinguished boundaries</span></div>
<div class="line"> <span class="comment">//---------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Create solid bulk mesh</span></div>
<div class="line"> node_file_name=<span class="stringliteral">&quot;fsi_bifurcation_solid.1.node&quot;</span>;</div>
<div class="line"> element_file_name=<span class="stringliteral">&quot;fsi_bifurcation_solid.1.ele&quot;</span>;</div>
<div class="line"> face_file_name=<span class="stringliteral">&quot;fsi_bifurcation_solid.1.face&quot;</span>;</div>
<div class="line"> Solid_mesh_pt =  <span class="keyword">new</span> <a class="code" href="classMySolidTetgenMesh.html">MySolidTetgenMesh&lt;SOLID_ELEMENT&gt;</a>(node_file_name,</div>
<div class="line">                                                    element_file_name,</div>
<div class="line">                                                    face_file_name);</div>
</div><!-- fragment --><p> Following the procedure used for the fluid mesh, we identify the mesh boundaries that make up the (pinned) ends of the tube (boundaries 0, 1 and 2, as defined in the tetgen <code>*.poly</code> file) and the FSI boundary (boundaries 3 to 14 &ndash; note that this enumeration matches that in the fluid mesh; see <a class="el" href="index.html#boundary_coord">How the boundary coordinates are generated</a> for further details of how the fluid and solid meshes are matched).</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// The following corresponds to the boundaries as specified by</span></div>
<div class="line"> <span class="comment">// facets in the tetgen input:</span></div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// IDs of solid mesh boundaries where displacements are pinned</span></div>
<div class="line"><span class="comment"></span> Pinned_solid_boundary_id.resize(3);</div>
<div class="line"> Pinned_solid_boundary_id[0]=0;</div>
<div class="line"> Pinned_solid_boundary_id[1]=1;</div>
<div class="line"> Pinned_solid_boundary_id[2]=2;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// The solid and fluid fsi boundaries are numbered int he same way.</span></div>
<div class="line"> Solid_fsi_boundary_id.resize(12);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;12;i++)</div>
<div class="line">  {</div>
<div class="line">   Solid_fsi_boundary_id[i]=i+3;</div>
<div class="line">  }</div>
</div><!-- fragment --><p> We create the fluid traction elements that impose the applied pressures in the in- and outflow cross-sections.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create (empty) meshes of fluid traction elements at inflow/outflow</span></div>
<div class="line"> <span class="comment">//-----------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create the meshes</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n=nfluid_traction_boundary();</div>
<div class="line"> Fluid_traction_mesh_pt.resize(n);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n;i++)</div>
<div class="line">  {</div>
<div class="line">   Fluid_traction_mesh_pt[i]=<span class="keyword">new</span> Mesh;</div>
<div class="line">  } </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Populate them with elements</span></div>
<div class="line"> create_fluid_traction_elements();</div>
</div><!-- fragment --><p>Next, we create the <code>FaceElements</code> that apply the fluid traction to the solid,</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create FSI Traction elements</span></div>
<div class="line"><span class="comment">//-----------------------------</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create (empty) meshes of FSI traction elements</span></div>
<div class="line"> n=nsolid_fsi_boundary();</div>
<div class="line"> Solid_fsi_traction_mesh_pt.resize(n);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n;i++)</div>
<div class="line">  {</div>
<div class="line">   Solid_fsi_traction_mesh_pt[i]=<span class="keyword">new</span> SolidMesh;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the FSI traction elements</span></div>
<div class="line"> create_fsi_traction_elements();</div>
</div><!-- fragment --><p> and the <code>FaceElements</code> that use Lagrange multipliers to deform the fluid mesh to keep it aligned with the FSI boundary.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create Lagrange multiplier mesh for boundary motion of fluid mesh</span></div>
<div class="line"> <span class="comment">//------------------------------------------------------------------</span></div>
<div class="line">  </div>
<div class="line"> <span class="comment">// Construct the mesh of elements that enforce prescribed boundary motion</span></div>
<div class="line"> <span class="comment">// of pseudo-solid fluid mesh by Lagrange multipliers</span></div>
<div class="line"> n=nfluid_fsi_boundary();</div>
<div class="line"> Lagrange_multiplier_mesh_pt.resize(n);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n;i++)</div>
<div class="line">  {</div>
<div class="line">   Lagrange_multiplier_mesh_pt[i]=<span class="keyword">new</span> SolidMesh;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create elements</span></div>
<div class="line"> create_lagrange_multiplier_elements();</div>
</div><!-- fragment --><p> We combine the various sub-meshes to a global mesh.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Combine the lot</span></div>
<div class="line"> <span class="comment">//----------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Add sub meshes:</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// The solid bulk mesh</span></div>
<div class="line"> add_sub_mesh(Solid_mesh_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Fluid bulk mesh</span></div>
<div class="line"> add_sub_mesh(Fluid_mesh_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// The fluid traction meshes</span></div>
<div class="line"> n=nfluid_traction_boundary();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n;i++)</div>
<div class="line">  { </div>
<div class="line">   add_sub_mesh(Fluid_traction_mesh_pt[i]);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// The solid fsi traction meshes</span></div>
<div class="line"> n=nsolid_fsi_boundary();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n;i++)</div>
<div class="line">  {</div>
<div class="line">   add_sub_mesh(Solid_fsi_traction_mesh_pt[i]);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// The Lagrange multiplier meshes for the fluid</span></div>
<div class="line"> n=nfluid_fsi_boundary();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n;i++)</div>
<div class="line">  {   </div>
<div class="line">   add_sub_mesh(Lagrange_multiplier_mesh_pt[i]);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build global mesh</span></div>
<div class="line"> build_global_mesh();</div>
</div><!-- fragment --><p>Next, we apply the boundary conditions for the fluid mesh: We impose parallel in- and outflow at the in- and outflow boundaries and apply boundary conditions for the pseudo-elastic deformation of the fluid mesh. Since the in- and outflow cross-sections of the elastic tube are held in place, we pin the position of the fluid nodes in these cross-sections too. To facilitate debugging we document the position of the fluid nodes whose (pseudo-solid) displacements we suppressed.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Apply BCs for fluid</span></div>
<div class="line"> <span class="comment">//--------------------</span></div>
<div class="line">  </div>
<div class="line"> <span class="comment">// Doc position of pinned pseudo solid nodes</span></div>
<div class="line"> std::ofstream pseudo_solid_bc_file(<span class="stringliteral">&quot;RESLT/pinned_pseudo_solid_nodes.dat&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over inflow/outflow boundaries to impose parallel flow</span></div>
<div class="line"> <span class="comment">// and pin pseudo-solid displacements</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> in_out=0;in_out&lt;2;in_out++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Loop over in/outflow boundaries</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n=nfluid_inflow_traction_boundary();</div>
<div class="line">   <span class="keywordflow">if</span> (in_out==1) n=nfluid_outflow_traction_boundary();</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n;i++)</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Get boundary ID</span></div>
<div class="line">     <span class="keywordtype">unsigned</span> b=0;</div>
<div class="line">     <span class="keywordflow">if</span> (in_out==0)</div>
<div class="line">      {</div>
<div class="line">       b=Inflow_boundary_id[i];</div>
<div class="line">      }</div>
<div class="line">     <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">       b=Outflow_boundary_id[i];</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Number of nodes on that boundary</span></div>
<div class="line">     <span class="keywordtype">unsigned</span> num_nod=Fluid_mesh_pt-&gt;nboundary_node(b);</div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">      {</div>
<div class="line">       <span class="comment">// Get the node</span></div>
<div class="line">       SolidNode* nod_pt=Fluid_mesh_pt-&gt;boundary_node_pt(b,inod);</div>
<div class="line">       </div>
<div class="line">       <span class="comment">// Pin transverse velocities</span></div>
<div class="line">       nod_pt-&gt;pin(0);</div>
<div class="line">       nod_pt-&gt;pin(1);</div>
<div class="line">       </div>
<div class="line">       <span class="comment">// Pin the nodal (pseudo-solid) displacements</span></div>
<div class="line">       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;3;i++)</div>
<div class="line">        {         </div>
<div class="line">         nod_pt-&gt;pin_position(i);         </div>
<div class="line">         </div>
<div class="line">         <span class="comment">// Doc it as pinned</span></div>
<div class="line">         pseudo_solid_bc_file &lt;&lt; nod_pt-&gt;x(i) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Close</span></div>
<div class="line"> pseudo_solid_bc_file.close();</div>
</div><!-- fragment --><p> We apply the no-slip condition on the fluid nodes that are located on the FSI boundary. In addition, we apply boundary conditions for the Lagrange multipliers. We pin the Lagrange multipliers for nodes that are located on the in- and outflow boundaries where the nodal positions are pinned. <a href="../../../solid/prescribed_displ_lagr_mult/html/index.html">Recall</a> that the Lagrange multipliers are additional degrees of freedom that are added to the "bulk" degrees of freedom that were originally created by the "bulk" element. The storage for the Lagrange multipliers is added to the Nodes by the FaceElements and the values at which the Lagrange multipliers are stored are found using the function <code>BoundaryNodeBase::index_of_first_value_assigned_by_face_element()</code>. The documentation of the position of the pinned Lagrange multiplier nodes in <code>RESLT/pinned_lagrange_multiplier_nodes.dat</code> is here to facilitate the debugging of the code and is highly recommended.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Doc bcs for Lagrange multipliers</span></div>
<div class="line"> ofstream pinned_file(<span class="stringliteral">&quot;RESLT/pinned_lagrange_multiplier_nodes.dat&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over all fluid mesh boundaries and pin velocities</span></div>
<div class="line"> <span class="comment">// of nodes that haven&#39;t been dealt with yet</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nbound=nfluid_fsi_boundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;nbound;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Get the mesh boundary</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> b = Fluid_fsi_boundary_id[i];</div>
<div class="line">   </div>
<div class="line">   <span class="keywordtype">unsigned</span> num_nod=Fluid_mesh_pt-&gt;nboundary_node(b);</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Get node</span></div>
<div class="line">     Node* nod_pt= Fluid_mesh_pt-&gt;boundary_node_pt(b,inod);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Pin all velocities</span></div>
<div class="line">     nod_pt-&gt;pin(0); </div>
<div class="line">     nod_pt-&gt;pin(1); </div>
<div class="line">     nod_pt-&gt;pin(2); </div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Find out whether node is also on in/outflow</span></div>
<div class="line">     <span class="keywordtype">bool</span> is_in_or_outflow_node=<span class="keyword">false</span>;</div>
<div class="line">     <span class="keywordtype">unsigned</span> n=nfluid_inflow_traction_boundary();</div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0;k&lt;n;k++)</div>
<div class="line">      {</div>
<div class="line">       <span class="keywordflow">if</span> (nod_pt-&gt;is_on_boundary(Inflow_boundary_id[k]))</div>
<div class="line">        {</div>
<div class="line">         is_in_or_outflow_node=<span class="keyword">true</span>;</div>
<div class="line">         <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">     <span class="keywordflow">if</span> (!is_in_or_outflow_node)</div>
<div class="line">      {</div>
<div class="line">       <span class="keywordtype">unsigned</span> n=nfluid_outflow_traction_boundary();</div>
<div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0;k&lt;n;k++)</div>
<div class="line">        {</div>
<div class="line">         <span class="keywordflow">if</span> (nod_pt-&gt;is_on_boundary(Outflow_boundary_id[k]))</div>
<div class="line">          {</div>
<div class="line">           is_in_or_outflow_node=<span class="keyword">true</span>;</div>
<div class="line">           <span class="keywordflow">break</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Pin the Lagrange multipliers on the out/in-flow boundaries</span></div>
<div class="line">     <span class="keywordflow">if</span> (is_in_or_outflow_node)</div>
<div class="line">      {</div>
<div class="line">       <span class="comment">//Cast to a boundary node</span></div>
<div class="line">       BoundaryNode&lt;SolidNode&gt; *bnod_pt = </div>
<div class="line">        <span class="keyword">dynamic_cast&lt;</span>BoundaryNode&lt;SolidNode&gt;*<span class="keyword">&gt;</span></div>
<div class="line">        ( Fluid_mesh_pt-&gt;boundary_node_pt(b,inod) );</div>
<div class="line">              </div>
<div class="line">       <span class="comment">// Loop over the Lagrange multipliers</span></div>
<div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l=0;l&lt;3;l++)</div>
<div class="line">        {</div>
<div class="line">         <span class="comment">// Pin the Lagrange multipliers that impose the displacement</span></div>
<div class="line">         <span class="comment">// because the positon of the fluid nodes at the in/outflow</span></div>
<div class="line">         <span class="comment">// is already determined. </span></div>
<div class="line">         nod_pt-&gt;pin</div>
<div class="line">          (bnod_pt-&gt;index_of_first_value_assigned_by_face_element()+l);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">       <span class="comment">// Doc that we&#39;ve pinned the Lagrange multipliers at this node</span></div>
<div class="line">       pinned_file &lt;&lt; nod_pt-&gt;x(0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">                   &lt;&lt; nod_pt-&gt;x(1) &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">                   &lt;&lt; nod_pt-&gt;x(2) &lt;&lt; endl;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">   </div>
<div class="line">  } <span class="comment">// done no slip on fsi boundary</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Done</span></div>
<div class="line"> pinned_file.close();</div>
</div><!-- fragment --><p> We complete the build of the fluid elements by specifying the Reynolds number and the constitutive equation for the pseudo-solid equations; recall that we use the same constitutive equation as used for the tube wall.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Complete the build of the fluid elements so they are fully functional</span></div>
<div class="line"> <span class="comment">//----------------------------------------------------------------------</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_element = Fluid_mesh_pt-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from GeneralisedElement to the present element</span></div>
<div class="line">   FLUID_ELEMENT* el_pt = </div>
<div class="line">    <span class="keyword">dynamic_cast&lt;</span>FLUID_ELEMENT*<span class="keyword">&gt;</span>(Fluid_mesh_pt-&gt;element_pt(e));</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Set the Reynolds number</span></div>
<div class="line">   el_pt-&gt;re_pt() = &amp;<a class="code" href="namespaceGlobal__Parameters.html#a9d72e94a9305c6a310940a6a427ebe06">Global_Parameters::Re</a>;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Set the constitutive law for pseudo-elastic mesh deformation</span></div>
<div class="line">   el_pt-&gt;constitutive_law_pt() =</div>
<div class="line">    <a class="code" href="namespaceGlobal__Parameters.html#adbd1f040f375c96fe56b3f475f7dbec2">Global_Parameters::Constitutive_law_pt</a>;</div>
<div class="line">   </div>
<div class="line">  } <span class="comment">// end loop over elements</span></div>
</div><!-- fragment --><p>We apply the "solid" boundary conditions by pinning the positions of the nodes that are located at the ends of the elastic tube, and, just to be on the safe side, document their positions to allow for debugging and sanity-checking.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Apply BCs for solid</span></div>
<div class="line"> <span class="comment">//--------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Doc pinned solid nodes</span></div>
<div class="line"> std::ofstream bc_file(<span class="stringliteral">&quot;RESLT/pinned_solid_nodes.dat&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Pin positions at inflow boundary (boundaries 0 and 1)</span></div>
<div class="line"> n=npinned_solid_boundary();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Get boundary ID</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> b=Pinned_solid_boundary_id[i];</div>
<div class="line">   <span class="keywordtype">unsigned</span> num_nod= Solid_mesh_pt-&gt;nboundary_node(b);  </div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">    {    </div>
<div class="line">     <span class="comment">// Get node</span></div>
<div class="line">     SolidNode* nod_pt=Solid_mesh_pt-&gt;boundary_node_pt(b,inod);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Pin all directions</span></div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;3;i++)</div>
<div class="line">      {</div>
<div class="line">       nod_pt-&gt;pin_position(i);</div>
<div class="line">       </div>
<div class="line">       <span class="comment">// ...and doc it as pinned</span></div>
<div class="line">       bc_file &lt;&lt; nod_pt-&gt;x(i) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">      }</div>
<div class="line">     </div>
<div class="line">     bc_file &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> bc_file.close();</div>
</div><!-- fragment --><p>We complete the build of the solid elements by passing the pointer to the constitutive equation.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Complete the build of Solid elements so they are fully functional</span></div>
<div class="line"> <span class="comment">//----------------------------------------------------------------</span></div>
<div class="line"> n_element = Solid_mesh_pt-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_element;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Cast to a solid element</span></div>
<div class="line">   SOLID_ELEMENT *el_pt = <span class="keyword">dynamic_cast&lt;</span>SOLID_ELEMENT*<span class="keyword">&gt;</span>(</div>
<div class="line">    Solid_mesh_pt-&gt;element_pt(i));</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Set the constitutive law   </span></div>
<div class="line">   el_pt-&gt;constitutive_law_pt() =</div>
<div class="line">    <a class="code" href="namespaceGlobal__Parameters.html#adbd1f040f375c96fe56b3f475f7dbec2">Global_Parameters::Constitutive_law_pt</a>;</div>
<div class="line">  }</div>
</div><!-- fragment --><p> Finally, we set up the fluid-structure interaction by determining which "bulk" fluid elements are located next to the FSI traction elements that apply the fluid load to the solid. This must be done separately for each of the mesh boundaries that make up the physical FSI boundary. To facilitate debugging, we document the boundary coordinates along the FSI interface (as seen by the fluid) by opening the <code>Multi_domain_functions::Doc_boundary_coordinate_file</code> stream before calling <code>FSI_functions::setup_fluid_load_info_for_solid_elements(...)</code>. If this stream is open, the setup routine writes the Eulerian coordinates of the points on the FSI interface and their intrinsic surface coordinate <img class="formulaInl" alt="$ [ x, y, z, \zeta_1, \zeta_2 ] $" src="form_13.png" width="70" height="14"/> to the specified file. This may be compared against the corresponding data for the solid's view of the FSI interface, documented in <code>doc_solid_boundary_coordinates()</code>.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Setup FSI</span></div>
<div class="line"> <span class="comment">//----------</span></div>
<div class="line">     </div>
<div class="line"> <span class="comment">// Work out which fluid dofs affect the residuals of the wall elements:</span></div>
<div class="line"> <span class="comment">// We pass the boundary between the fluid and solid meshes and </span></div>
<div class="line"> <span class="comment">// pointers to the meshes. </span></div>
<div class="line"> n=nsolid_fsi_boundary();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Sanity check: Doc boundary coordinates from solid side</span></div>
<div class="line">   doc_solid_boundary_coordinates(i);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Doc boundary coordinates in fluid</span></div>
<div class="line">   <span class="keywordtype">char</span> filename[100];</div>
<div class="line">   sprintf(filename,<span class="stringliteral">&quot;RESLT/fluid_boundary_coordinates%i.dat&quot;</span>,i);</div>
<div class="line">   Multi_domain_functions::Doc_boundary_coordinate_file.open(filename);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Setup FSI: Pass ID of fluid FSI boundary and associated</span></div>
<div class="line">   <span class="comment">// mesh of solid fsi traction elements.</span></div>
<div class="line">   FSI_functions::setup_fluid_load_info_for_solid_elements&lt;FLUID_ELEMENT,3&gt;</div>
<div class="line">    (<span class="keyword">this</span>,Fluid_fsi_boundary_id[i],Fluid_mesh_pt,Solid_fsi_traction_mesh_pt[i]);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Close the doc file</span></div>
<div class="line">   Multi_domain_functions::Doc_boundary_coordinate_file.close();</div>
<div class="line">  } </div>
</div><!-- fragment --><p>All that's now left to do is to set up the equation numbering scheme and the problem is ready to be solved.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Setup equation numbering scheme</span></div>
<div class="line"> std::cout &lt;&lt;<span class="stringliteral">&quot;Number of equations: &quot;</span> &lt;&lt; assign_eqn_numbers() &lt;&lt; std::endl; </div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="fsi_traction"></a>
Creating the FSI traction elements</h1>
<p>The creation of the FSI traction elements that apply the fluid traction to the solid elements that are adjacent to the FSI boundary follows the usual procedure: We loop over the relevant 3D "bulk" solid elements and attach the <code>FSISolidTractionElements</code> to the appropriate faces.</p>
<div class="fragment"><div class="line"><span class="comment">//============start_of_create_fsi_traction_elements======================</span></div>
<div class="line"><span class="comment">/// Create FSI traction elements </span></div>
<div class="line"><span class="comment"></span><span class="comment">//=======================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> FLUID_ELEMENT,<span class="keyword">class</span> SOLID_ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classUnstructuredFSIProblem.html#a934a587c99668fca969a72814b3142a7">UnstructuredFSIProblem&lt;FLUID_ELEMENT,SOLID_ELEMENT&gt;::</a></div>
<div class="line"><a class="code" href="classUnstructuredFSIProblem.html#a934a587c99668fca969a72814b3142a7">create_fsi_traction_elements</a>()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over FSI boundaries in solid</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n=nsolid_fsi_boundary();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Get boundary ID</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> b=Solid_fsi_boundary_id[i];</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// How many bulk elements are adjacent to boundary b?</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_element = Solid_mesh_pt-&gt;nboundary_element(b);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Loop over the bulk elements adjacent to boundary b</span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Get pointer to the bulk element that is adjacent to boundary b</span></div>
<div class="line">     SOLID_ELEMENT* bulk_elem_pt = <span class="keyword">dynamic_cast&lt;</span>SOLID_ELEMENT*<span class="keyword">&gt;</span>(</div>
<div class="line">      Solid_mesh_pt-&gt;boundary_element_pt(b,e));</div>
<div class="line">     </div>
<div class="line">     <span class="comment">//What is the index of the face of the element e along boundary b</span></div>
<div class="line">     <span class="keywordtype">int</span> face_index = Solid_mesh_pt-&gt;face_index_at_boundary(b,e);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Create new element </span></div>
<div class="line">     FSISolidTractionElement&lt;SOLID_ELEMENT,3&gt;* el_pt=</div>
<div class="line">      <span class="keyword">new</span> FSISolidTractionElement&lt;SOLID_ELEMENT,3&gt;(bulk_elem_pt,face_index);</div>
<div class="ttc" id="aclassUnstructuredFSIProblem_html_a934a587c99668fca969a72814b3142a7"><div class="ttname"><a href="classUnstructuredFSIProblem.html#a934a587c99668fca969a72814b3142a7">UnstructuredFSIProblem::create_fsi_traction_elements</a></div><div class="ttdeci">void create_fsi_traction_elements()</div><div class="ttdoc">Create FSI traction elements.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00704">unstructured_three_d_fsi.cc:705</a></div></div>
</div><!-- fragment --><p> Next we add the newly-created <code>FaceElement</code> to the mesh of traction elements, specify which boundary of the bulk mesh it is attached to, and pass the FSI interaction parameter <img class="formulaInl" alt="$ Q $" src="form_9.png" width="10" height="13"/> to the element.</p>
<div class="fragment"><div class="line">     </div>
<div class="line">     <span class="comment">// Add it to the mesh</span></div>
<div class="line">     Solid_fsi_traction_mesh_pt[i]-&gt;add_element_pt(el_pt);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Specify boundary number</span></div>
<div class="line">     el_pt-&gt;set_boundary_number_in_bulk_mesh(b);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Function that specifies the load ratios</span></div>
<div class="line">     el_pt-&gt;q_pt() = &amp;<a class="code" href="namespaceGlobal__Parameters.html#a7814fddf663e56168174a42d2cd6b4c1">Global_Parameters::Q</a>; </div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of create_fsi_traction_elements</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="create_lagr"></a>
Creating the Lagrange multiplier elements</h1>
<p>The creation of the <code>FaceElements</code> that use Lagrange multipliers to impose the boundary displacement of the pseudo-solid fluid mesh is again fairly straightforward (the use of Lagrange multipliers for the imposition of boundary displacements is explained in <a href="../../../solid/prescribed_displ_lagr_mult/html/index.html">another tutorial</a>). The only complication is that we must loop over the different parts of the FSI boundary. In each case we combine the <code>FSISolidTractionElements</code> attached to the solid mesh into a compound <code>GeomObject</code>. Each <code>GeomObject</code> provides a continuous representation of the relevant part of the FSI boundary, parametrised by the boundary coordinate assigned earlier while its shape is determined by the deformation of the 3D solid elements that the <code>FSISolidTractionElements</code> are attached to.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">//============start_of_create_lagrange_multiplier_elements===============</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// Create elements that impose the prescribed boundary displacement</span></div>
<div class="line"><span class="comment">/// for the pseudo-solid fluid mesh</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=======================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> FLUID_ELEMENT, <span class="keyword">class</span> SOLID_ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classUnstructuredFSIProblem.html#a6f810c300f373cfc79e23d58f95944e3">UnstructuredFSIProblem&lt;FLUID_ELEMENT,SOLID_ELEMENT&gt;::</a></div>
<div class="line"><a class="code" href="classUnstructuredFSIProblem.html#a6f810c300f373cfc79e23d58f95944e3">create_lagrange_multiplier_elements</a>()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Make space</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n=nfluid_fsi_boundary();</div>
<div class="line"> Solid_fsi_boundary_pt.resize(n);</div>
<div class="line">    </div>
<div class="line"> <span class="comment">// Loop over FSI interfaces in fluid</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n;i++)</div>
<div class="line">  {   </div>
<div class="line">   <span class="comment">// Get boundary ID</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> b=Fluid_fsi_boundary_id[i];</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Create  GeomObject incarnation of fsi boundary in solid mesh</span></div>
<div class="line">   Solid_fsi_boundary_pt[i]=</div>
<div class="line">    <span class="keyword">new</span> MeshAsGeomObject</div>
<div class="line">    (Solid_fsi_traction_mesh_pt[i]);</div>
<div class="ttc" id="aclassUnstructuredFSIProblem_html_a6f810c300f373cfc79e23d58f95944e3"><div class="ttname"><a href="classUnstructuredFSIProblem.html#a6f810c300f373cfc79e23d58f95944e3">UnstructuredFSIProblem::create_lagrange_multiplier_elements</a></div><div class="ttdeci">void create_lagrange_multiplier_elements()</div><div class="ttdoc">Create elements that enforce prescribed boundary motion for the pseudo-solid fluid mesh by Lagrange m...</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00751">unstructured_three_d_fsi.cc:752</a></div></div>
</div><!-- fragment --><p> Having represented the boundary by a (compound) <code>GeomObject</code>, we now attach <code>ImposeDisplacementByLagrangeMultiplierElements</code> to the appropriate faces of the "bulk" fluid elements that are adjacent to the FSI interface and add them to their own mesh:</p>
<div class="fragment"><div class="line">   </div>
<div class="line">   <span class="comment">// How many bulk fluid elements are adjacent to boundary b?</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_element = Fluid_mesh_pt-&gt;nboundary_element(b);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Loop over the bulk fluid elements adjacent to boundary b?</span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Get pointer to the bulk fluid element that is adjacent to boundary b</span></div>
<div class="line">     FLUID_ELEMENT* bulk_elem_pt = <span class="keyword">dynamic_cast&lt;</span>FLUID_ELEMENT*<span class="keyword">&gt;</span>(</div>
<div class="line">      Fluid_mesh_pt-&gt;boundary_element_pt(b,e));</div>
<div class="line">     </div>
<div class="line">     <span class="comment">//Find the index of the face of element e along boundary b</span></div>
<div class="line">     <span class="keywordtype">int</span> face_index = Fluid_mesh_pt-&gt;face_index_at_boundary(b,e);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Create new element</span></div>
<div class="line">     ImposeDisplacementByLagrangeMultiplierElement&lt;FLUID_ELEMENT&gt;* el_pt =</div>
<div class="line">      <span class="keyword">new</span> ImposeDisplacementByLagrangeMultiplierElement&lt;FLUID_ELEMENT&gt;(</div>
<div class="line">       bulk_elem_pt,face_index);   </div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Add it to the mesh</span></div>
<div class="line">     Lagrange_multiplier_mesh_pt[i]-&gt;add_element_pt(el_pt);</div>
</div><!-- fragment --><p> Finally, we pass a pointer to the compound <code>GeomObject</code> that defines the shape of the FSI interface and specify which boundary in the "bulk" fluid mesh the <code>ImposeDisplacementByLagrangeMultiplierElement</code> is attached to.</p>
<div class="fragment"><div class="line">     </div>
<div class="line">     <span class="comment">// Set the GeomObject that defines the boundary shape and set</span></div>
<div class="line">     <span class="comment">// which bulk boundary we are attached to (needed to extract</span></div>
<div class="line">     <span class="comment">// the boundary coordinate from the bulk nodes)</span></div>
<div class="line">     el_pt-&gt;set_boundary_shape_geom_object_pt(Solid_fsi_boundary_pt[i],b);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of create_lagrange_multiplier_elements</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="fluid_traction"></a>
Attaching the fluid traction elements</h1>
<p>The helper function <code>create_fluid_traction_elements()</code> attaches <code>NavierStokesTractionElements</code> to the in- and outflow cross-sections of the fluid mesh and thus imposes the prescribed pressure drop onto the fluid.</p>
<div class="fragment"><div class="line"><span class="comment">//============start_of_fluid_traction_elements==============================</span></div>
<div class="line"><span class="comment">/// Create fluid traction elements </span></div>
<div class="line"><span class="comment"></span><span class="comment">//=======================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> FLUID_ELEMENT,<span class="keyword">class</span> SOLID_ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classUnstructuredFSIProblem.html#af766e3bbc8963a286678cb1d277909f5">UnstructuredFSIProblem&lt;FLUID_ELEMENT,SOLID_ELEMENT&gt;::</a></div>
<div class="line"><a class="code" href="classUnstructuredFSIProblem.html#af766e3bbc8963a286678cb1d277909f5">create_fluid_traction_elements</a>()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Counter for number of fluid traction meshes</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> count=0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over inflow/outflow boundaries</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> in_out=0;in_out&lt;2;in_out++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Loop over boundaries with fluid traction elements</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n=nfluid_inflow_traction_boundary();</div>
<div class="line">   <span class="keywordflow">if</span> (in_out==1) n=nfluid_outflow_traction_boundary();</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n;i++)</div>
<div class="line">    {</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Get boundary ID</span></div>
<div class="line">     <span class="keywordtype">unsigned</span> b=0;</div>
<div class="line">     <span class="keywordflow">if</span> (in_out==0)</div>
<div class="line">      {</div>
<div class="line">       b=Inflow_boundary_id[i];</div>
<div class="line">      }</div>
<div class="line">     <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">       b=Outflow_boundary_id[i];</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// How many bulk elements are adjacent to boundary b?</span></div>
<div class="line">     <span class="keywordtype">unsigned</span> n_element = Fluid_mesh_pt-&gt;nboundary_element(b);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Loop over the bulk elements adjacent to boundary b</span></div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">      {</div>
<div class="line">       <span class="comment">// Get pointer to the bulk element that is adjacent to boundary b</span></div>
<div class="line">       FLUID_ELEMENT* bulk_elem_pt = <span class="keyword">dynamic_cast&lt;</span>FLUID_ELEMENT*<span class="keyword">&gt;</span>(</div>
<div class="line">        Fluid_mesh_pt-&gt;boundary_element_pt(b,e));</div>
<div class="line">       </div>
<div class="line">       <span class="comment">//What is the index of the face of the element e along boundary b</span></div>
<div class="line">       <span class="keywordtype">int</span> face_index = Fluid_mesh_pt-&gt;face_index_at_boundary(b,e);</div>
<div class="line">       </div>
<div class="line">       <span class="comment">// Create new element </span></div>
<div class="line">       NavierStokesTractionElement&lt;FLUID_ELEMENT&gt;* el_pt=</div>
<div class="line">        <span class="keyword">new</span> NavierStokesTractionElement&lt;FLUID_ELEMENT&gt;(bulk_elem_pt,</div>
<div class="line">                                                       face_index);</div>
<div class="line">       </div>
<div class="line">       <span class="comment">// Add it to the mesh</span></div>
<div class="line">       Fluid_traction_mesh_pt[count]-&gt;add_element_pt(el_pt);</div>
<div class="line">         </div>
<div class="line">       <span class="comment">// Set the pointer to the prescribed traction function</span></div>
<div class="line">       <span class="keywordflow">if</span> (in_out==0)</div>
<div class="line">        {</div>
<div class="line">         el_pt-&gt;traction_fct_pt() = </div>
<div class="line">          &amp;<a class="code" href="namespaceGlobal__Parameters.html#af7faf65214ed9ead637f7c208addb095">Global_Parameters::prescribed_inflow_traction</a>;</div>
<div class="line">        }</div>
<div class="line">       <span class="keywordflow">else</span></div>
<div class="line">        { </div>
<div class="line">         el_pt-&gt;traction_fct_pt() = </div>
<div class="line">          &amp;<a class="code" href="namespaceGlobal__Parameters.html#a83155358b144cff7e29ecb6b209a2d3e">Global_Parameters::prescribed_outflow_traction</a>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">     <span class="comment">// Bump up counter</span></div>
<div class="line">     count++;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> } <span class="comment">// end of create_traction_elements</span></div>
<div class="ttc" id="aclassUnstructuredFSIProblem_html_af766e3bbc8963a286678cb1d277909f5"><div class="ttname"><a href="classUnstructuredFSIProblem.html#af766e3bbc8963a286678cb1d277909f5">UnstructuredFSIProblem::create_fluid_traction_elements</a></div><div class="ttdeci">void create_fluid_traction_elements()</div><div class="ttdoc">Create fluid traction elements at inflow.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__three__d__fsi_8cc_source.html#l00805">unstructured_three_d_fsi.cc:806</a></div></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="doc_solution"></a>
Post-processing</h1>
<p>The post-processing routine simply executes the output functions for the fluid and solid meshes and documents their mesh boundaries. We also document the FSI traction that the fluid exerts onto the solid.</p>
<div class="fragment"><div class="line"><span class="comment">//========start_of_doc_solution===========================================</span></div>
<div class="line"><span class="comment">/// Doc the solution</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> FLUID_ELEMENT, <span class="keyword">class</span> SOLID_ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classUnstructuredFSIProblem.html#a15f581318b505de07f50bd570da8c8d0">UnstructuredFSIProblem&lt;FLUID_ELEMENT,SOLID_ELEMENT&gt;::</a></div>
<div class="line"><a class="code" href="classUnstructuredFSIProblem.html#a15f581318b505de07f50bd570da8c8d0">doc_solution</a>(DocInfo&amp; doc_info)</div>
<div class="line">{ </div>
<div class="line"> </div>
<div class="line"> ofstream some_file;</div>
<div class="line"> <span class="keywordtype">char</span> filename[100];</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Number of plot points</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> npts;</div>
<div class="line"> npts=5;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output solid boundaries</span></div>
<div class="line"> <span class="comment">//------------------------</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/solid_boundaries%i.dat&quot;</span>,doc_info.directory().c_str(),</div>
<div class="line">         doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> Solid_mesh_pt-&gt;output_boundaries(some_file);</div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output solid solution</span></div>
<div class="line"> <span class="comment">//-----------------------</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/solid_soln%i.dat&quot;</span>,doc_info.directory().c_str(),</div>
<div class="line">         doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> Solid_mesh_pt-&gt;output(some_file,npts);</div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output fluid boundaries</span></div>
<div class="line"> <span class="comment">//------------------------</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/fluid_boundaries%i.dat&quot;</span>,doc_info.directory().c_str(),</div>
<div class="line">         doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> Fluid_mesh_pt-&gt;output_boundaries(some_file);</div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output fluid solution</span></div>
<div class="line"> <span class="comment">//-----------------------</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/fluid_soln%i.dat&quot;</span>,doc_info.directory().c_str(),</div>
<div class="line">         doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> Fluid_mesh_pt-&gt;output(some_file,npts);</div>
<div class="line"> some_file.close();</div>
<div class="line">  </div>
<div class="line">   </div>
<div class="line"> <span class="comment">// Output fsi traction</span></div>
<div class="line"> <span class="comment">//--------------------</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/fsi_traction%i.dat&quot;</span>,doc_info.directory().c_str(),</div>
<div class="line">         doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> <span class="keywordtype">unsigned</span> n=nsolid_fsi_boundary();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;n;i++)</div>
<div class="line">  {</div>
<div class="line">   Solid_fsi_traction_mesh_pt[i]-&gt;output(some_file,npts);</div>
<div class="line">  }</div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end_of_doc</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="doc_solid_zeta"></a>
Sanity check: Documenting the solid boundary coordinates</h1>
<p>The function <code>doc_solid_boundary_coordinates()</code> documents the parametrisation of the solid's FSI boundary by writing into a file the solid's counterpart of the <img class="formulaInl" alt="$ [ x, y, z, \zeta_1, \zeta_2 ] $" src="form_13.png" width="70" height="14"/> data that we created for the fluid side of the FSI interface when setting up the fluid-structure interaction with <code>FSI_functions::setup_fluid_load_info_for_solid_elements(...)</code>. The two parametrisations should be consistent; see <a class="el" href="index.html#go_wrong">What can go wrong?</a> for more details. The implementation is straightforward and is suppressed for brevity; see the <a href="../../../../demo_drivers/interaction/unstructured_three_d_fsi/unstructured_three_d_fsi.cc">source code </a> if you want to know how it works.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="comm_ex"></a>
Comments and Exercises</h1>
<h2><a class="anchor" id="boundary_coord"></a>
How the boundary coordinates are generated</h2>
<p>The use of pseudo-elasticity for the node update in the fluid mesh makes the solution of FSI problems extremely straightforward. They key feature that allows the "automatic" coupling of the unstructured fluid and solid meshes is the (consistent!) generation of the boundary coordinates <img class="formulaInl" alt="$ (\zeta_1,\zeta_2) $" src="form_14.png" width="36" height="14"/> along the FSI interface. For reasons already mentioned, the procedure is more involved than in the equivalent two-dimensional problem. The implementation of this functionality in <code>TetgenMesh::setup_boundary_coordinates(...)</code> exploits the fact that</p><ol type="1">
<li>Meshes generated by <a href="http://wias-berlin.de/software/tetgen//"><code>tetgen</code> </a> are bounded by planar facets, and <br  />
<br  />
</li>
<li>We insist that all facets are given distinct boundary IDs <br  />
 when defining the domain in the tetgen <code>*.poly</code> file.</li>
</ol>
<p>The figure below illustrates the generation of the boundary coordinates within a representative planar facet (shown in cyan) that defines a particular mesh boundary.</p>
<div class="image">
<img src="boundary_coords_with_mesh.gif" alt=""/>
<div class="caption">
Sketch illustrating the generation of boundary coordinates on a mesh boundary that is defined by a planar facet (shown in cyan). </div></div>
 <p>Here is how we generate the boundary coordinates:</p>
<ol type="1">
<li>We start by attaching <code>FaceElements</code> to the appropriate faces of the "bulk" elements that are adjacent to the mesh boundary defined by the facet. These <code>FaceElements</code> provide a surface triangulation of the boundary. In the sketch above, the surface triangulation is represented by the blue surface mesh. <br  />
<br  />
</li>
<li>We locate the "lower left" and "upper right" nodes within the surface mesh, based on a lexicographical ordering of the nodes' 3D coordinates. <br  />
<br  />
</li>
<li>The straight line from the "lower left" to the "upper right" node (shown by the dashed red line) defines a direction that is co-planar with the facet and therefore allows us to define an in-plane unit vector, <img class="formulaInl" alt="$ {\bf T}_1$" src="form_15.png" width="15" height="11"/>, shown in red. <br  />
<br  />
</li>
<li>A second in-plane unit vector, <img class="formulaInl" alt="$ {\bf T}_2$" src="form_16.png" width="16" height="11"/> (shown in yellow), can then be constructed by taking the cross-product of <img class="formulaInl" alt="$ {\bf T}_1$" src="form_15.png" width="15" height="11"/> and the outer unit normal <img class="formulaInl" alt="$ {\bf N} $" src="form_17.png" width="13" height="10"/>. (The outer unit normal can be obtained from any of the adjacent bulk elements.) <br  />
<br  />
</li>
<li>The orthonormal in-plane vectors <img class="formulaInl" alt="$ {\bf T}_1$" src="form_15.png" width="15" height="11"/> and <img class="formulaInl" alt="$ {\bf T}_2$" src="form_16.png" width="16" height="11"/> define a unique parametrisation of the boundary in terms of the boundary coordinates <img class="formulaInl" alt="$ (\zeta_1,\zeta_2) $" src="form_14.png" width="36" height="14"/>, if we insist that for every point on the boundary we have <p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf R}(\zeta_1,\zeta_2) = {\bf R}_{\mbox{lower left}} + \zeta_1 {\bf T}_1 + \zeta_2 {\bf T}_2. \]" src="form_18.png" width="214" height="15"/>
</p>
 This allows the assignment of boundary coordinates for each of the nodes on this boundary. <br  />
<br  />
</li>
<li>Once this is done we can delete the <code>FaceElements</code> that defined the surface triangulation. <br  />
<br  />
</li>
</ol>
<p>Since the generation of the boundary coordinates by the above procedure only relies on the position of the "lower left" and "upper right" vertices (which are properties of the facet rather than the <code>tetgen</code> mesh) the boundary coordinates are unique, regardless of the actual discretisation generated by <code>tetgen</code>. Furthermore, the boundary coordinates created from the fluid and solid meshes will be consistent <em>provided</em> we reverse the direction of the outer unit normal in one of the meshes. This is exactly what the <code>switch_normal</code> flag in <code>TetgenMesh::setup_boundary_coordinates(...)</code> is for. When generating the boundary coordinates for our problem, we switched the direction of the normal in the fluid mesh; see the section <a class="el" href="index.html#fluid_mesh">The fluid mesh</a>, above.</p>
<p>Here is an animation of the automatically-generated boundary coordinates along the 12 mesh boundaries that constitute the FSI boundary, when viewed from the fluid and the solid, respectively. In each of the frames the contours indicate the value of <br  />
 <img class="formulaInl" alt="$ \zeta_1 $" src="form_19.png" width="10" height="13"/> within the respective boundary. Note that the boundary coordinates established in the two meshes match, even though the discretisations do not.</p>
<div class="image">
<img src="fluid_boundary_test.gif" alt=""/>
<div class="caption">
Contour plot of the automatically-generated boundary coordinates on the FSI boundary, viewed from the fluid mesh. </div></div>
 <div class="image">
<img src="solid_boundary_test.gif" alt=""/>
<div class="caption">
Contour plot of the automatically-generated boundary coordinates on the FSI boundary, viewed from the solid mesh. </div></div>
 <p>You should explore this procedure yourself as an <b>exercise:</b> For instance you may want to explore what happens if you don't switch the direction of the normal in the fluid mesh when generating the boundary coordinates.</p>
<hr  />
<h2><a class="anchor" id="matching_fluid_and_solid"></a>
Fluid and solid meshes do not have to be matching</h2>
<p>The mesh shown in the problem sketch at the beginning of this tutorial already suggested that the fluid and solid meshes do not have to match across the FSI interface. To illustrate this point more clearly, here is the result of another computation for which we generated a much finer fluid mesh, using</p>
<div class="fragment"><div class="line">tetgen -a0.05 fsi_bifurcation_fluid.poly</div>
</div><!-- fragment --><p>The resulting tetgen <code>*.ele</code>, <code>*.node</code> and <code>*.face</code> files can be used with same driver code.</p>
<div class="image">
<img src="finer_fluid_mesh.gif" alt=""/>
<div class="caption">
Solution computed with a finer fluid mesh. </div></div>
 <p>As an <b>exercise</b>, generate some finer fluid and solid meshes yourself and confirm that they may be used without having to change the driver code.</p>
<hr  />
<h2><a class="anchor" id="go_wrong"></a>
What can go wrong?</h2>
<p>Here are a few things that can (and often do) go wrong in unstructured, three-dimensional FSI problems.</p><ul>
<li><b>The facets that define the FSI boundary don't match:</b> <br  />
<br  />
 This tends to happen if the <code>*.poly</code> files describing the fluid and solid meshes do not use the same facets to describe the FSI interface. While we do not expect the fluid and solid meshes themselves to match, the representation of the FSI interface via facets <code>must</code> be consistent. A simple way to ensure consistency is to use the following procedure: <br  />
<br  />
<ol type="1">
<li>Write the <code>*.poly</code> file for the fluid mesh. Make sure that each facet is given a separate boundary ID (at least for the facets describing the FSI interface). <br  />
<br  />
</li>
<li>Solve a single-physics fluids problem on this mesh to check the integrity of the mesh &ndash; the solution of this problem will also give you some insight into the expected flow field. <br  />
<br  />
</li>
<li>Make a copy of the <code>*.poly</code> file for the fluid mesh and modify it to describe the solid mesh, leaving the facets that define the FSI interface unchanged. This automatically ensures that the representation of the FSI boundary from the fluid's and the solid's point of view is consistent. <br  />
<br  />
</li>
<li>Solve a single-physics solids problem on this mesh to check the integrity of the mesh, e.g. by applying some pressure loading on the future FSI boundary &ndash; the solution of this problem will also give you some insight into the expected wall deformation. <br  />
<br  />
</li>
<li>Couple the two problems, as shown in this tutorial. <br  />
<br  />
</li>
</ol>
As an <b>exercise</b>, modify the tetgen <code>*.poly</code> files and the driver code so that it can handle the extended domain considered in the <a href="../../../navier_stokes/unstructured_three_d_fluid/html/index.html#finer_mesh">single-physics fluids problem.</a> <br  />
<br  />
</li>
<li><b> An FSI (sub-)boundary is not planar:</b> <br  />
<br  />
 In an unstructured mesh, the FSI boundary will usually be represented by a large number of distinct mesh boundaries. The automatic setup of the boundary coordinates on these mesh boundaries requires them to be (individually) planar &ndash; at least in the problem's initial configuration. Provided you have followed our advice and associated each of the facets that define the FSI boundary with a different boundary ID, you should not have any problems as <code>tetgen</code> does not allow non-planar facets. <br  />
<br  />
</li>
<li><b> The solver does not converge:</b> <br  />
<br  />
 A large-displacement FSI problem is a highly nonlinear problem and the provision of a good initial guess for the Newton iteration is essential. We tend to proceed as follows: <br  />
<br  />
<ol type="1">
<li>Follow the steps outlined above, to study the constituent single-physics problems first. This will already give you some insight into the behaviour of the problem. For instance, the solution of the single-physics Navier-Stokes equations at the desired Reynolds number may have to be computed via a parameter incrementation, starting from Stokes flow. Similarly, the study of the single-physics solid problem will reveal what load increments can be accommodated without causing the Newton iteration to diverge. <br  />
<br  />
</li>
<li>Combine the two single-physics problems using the steps described in this tutorial. <br  />
<br  />
</li>
<li>Switch off the fluid-structure interaction by <br  />
<br  />
<ol type="a">
<li>setting the FSI parameter to zero, <img class="formulaInl" alt="$ Q = 0, $" src="form_20.png" width="35" height="13"/> <br  />
<br  />
</li>
<li>commenting out the call to <code>FSI_functions::setup_fluid_load_info_for_solid_elements(...)</code>, <br  />
<br  />
</li>
<li>not creating the Lagrange-multiplier elements that enforce the solid displacements onto the fluid mesh.</li>
</ol>
</li>
</ol>
</li>
</ul>
<p><br  />
<br  />
 This completely uncouples the two problems, although they will be solved simultaneously, allowing you to replicate the single-physics parameter studies already performed. <br  />
<br  />
</p><ol type="1">
<li>Now switch on the various interactions, one-by-one, while carefully validating the results at each stage. We tend to proceed as follows: <br  />
<br  />
<ol type="a">
<li>Solve the uncoupled problem at zero Reynolds number. <br  />
<br  />
</li>
<li>Increase the Reynolds number in small increments to its target value. <br  />
<br  />
</li>
<li>Re-enable the call to <code>FSI_functions::setup_fluid_load_info_for_solid_elements(...)</code> and attach the Lagrange multiplier elements but keep <img class="formulaInl" alt="$ Q = 0. $" src="form_21.png" width="35" height="13"/> If the solid is not loaded by any forces/tractions other than those arising from the fluid, the solution should not change as the solid remains unloaded. <br  />
<br  />
</li>
<li>Gently increase the value of the FSI parameter, <img class="formulaInl" alt="$ Q $" src="form_9.png" width="10" height="13"/>, remembering that it represents the ratio of the typical viscous fluid stresses to the stiffness of the solid. Hence, even relatively small values of <img class="formulaInl" alt="$ Q $" src="form_9.png" width="10" height="13"/> tend to lead to relatively large solid displacements. Be gentle!</li>
</ol>
</li>
</ol>
<p><br  />
<br  />
</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory:<br  />
<br  />
<center> <a href="../../../../demo_drivers/interaction/unstructured_three_d_fsi">demo_drivers/interaction/unstructured_three_d_fsi </a> </center><br  />
</li>
<li>The driver code is: <br  />
<br  />
<center> <a href="../../../../demo_drivers/interaction/unstructured_three_d_fsi/unstructured_three_d_fsi.cc">demo_drivers/interaction/unstructured_three_d_fsi/unstructured_three_d_fsi.cc </a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:31:38
        </div>
      </div>
    </footer>
</body>
</html>
