<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Flow in a 2D collapsible channel revisited &ndash; sparse algebraic node updates</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Flow in a 2D collapsible channel revisited &ndash; sparse algebraic node updates </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In an <a href="../../fsi_collapsible_channel/html/index.html">earlier example,</a> we demonstrated how the <code>MacroElement/Domain</code> - based node-update procedure that we originally developed for problems with moving, curvilinear domain boundaries may also be used in fluid-structure interaction problems in which the position of the domain boundary has to be determined as part of the solution. We demonstrated that the driver code for the coupled multi-physics problem was a straightforward combination of the driver codes for the two constituent single-physics problems. The two key steps required to couple the two single-physics codes were:</p><ol type="1">
<li>Recast the wall mesh to a <code>GeomObject</code>, using the <code>MeshAsGeomObject</code> class. This class turns an existing solid mechanics mesh into a "compound" <code>GeomObject</code> in which material points on the <br  />
 wall are identified by their Lagrangian coordinate, <img class="formulaInl" alt="$ \xi $" src="form_0.png" width="8" height="13"/> , which doubles as the <code>GeomObject's</code> intrinsic coordinate, <img class="formulaInl" alt="$ \zeta $" src="form_1.png" width="6" height="13"/> . <br  />
<br  />
</li>
<li>Use the "compound" <code>GeomObject</code> to represent the moving boundary of the fluid mesh. "Upgrade" the fluid elements (of type <code>FLUID_ELEMENT</code>, say) to the "wrapped" version <code>MacroElementNodeUpdateElement&lt;FLUID_ELEMENT&gt;</code> to allow the the node-update to be performed node-by-node, and to automatically evaluate the "shape derivatives" &ndash; the derivatives of the fluid equations with respect to the (solid mechanics) degrees of freedom that determine their nodal positions. <br  />
<br  />
</li>
</ol>
<p>While the implementation of these steps is very straightforward, we pointed out that the resulting code was not particularly efficient as the fluid-node update is not as sparse as it could (should!) be: Since it is impossible to distinguish between the various sub-objects in the "compound" <code>GeomObject</code>, we can do no better than to assume the worst-case scenario, namely that the positional degrees of freedom of all <code>SolidNodes</code> in the wall mesh potentially affect the nodal position in all fluid elements. This dramatically increases the size of the elemental Jacobian matrices, and creates many nonzero entries in the off-diagonal blocks in the global Jacobian matrix.</p>
<h1><a class="anchor" id="alg_sparse"></a>
Sparse algebraic node updates in FSI problems</h1>
<p>To avoid this problem we need a node-update strategy in which the position of each fluid node is determined by only a small number of solid mechanics degrees of freedom. The algebraic node-update strategy discussed in the <a href="../../../navier_stokes/algebraic_collapsible_channel/html/index.html">non-FSI version of the collapsible channel problem,</a> provides an ideal framework for this, as it allows each node to update its own position, using a node-specific update function. Recall that in the <code>AlgebraicMesh</code> - version of the <code>CollapsibleChannelMesh</code>, each <code>AlgebraicNode</code> stored a pointer to the (single) <code>GeomObject</code> that represented the moving curvilinear boundary, and the Lagrangian coordinate of a reference point on this <code>GeomObject</code>. The node's node-update function then placed the node at a fixed vertical fraction on the line connecting the reference point on the "elastic" wall to a second reference point on the fixed lower channel wall. Furthermore, the "wrapped" element, <code>AlgebraicElement&lt;FLUID_ELEMENT&gt;</code>, automatically computes the "shape derivatives" by finite-differencing the fluid residuals with respect to the degrees of freedom stored in the <code>GeomObject's</code> geometric <code>Data</code>, just as in the case of the <code>MacroElement</code> - based node-update procedure.</p>
<p>If used in the form discussed in the <a href="../../../navier_stokes/algebraic_collapsible_channel/html/index.html">earlier example,</a> this methodology does not (yet!) improve the sparsity of the node update: The geometric <code>Data</code> of the "compound" <code>GeomObject</code> that represents the wall still contains the positional degrees of freedom of <em>all</em> of the mesh's constituent <code>FSIHermiteBeamElements</code>. This is wasteful because the position of a material point on the (discretised) wall depends only on the positional degrees of freedom of the element that this point is located in. The (costly-to-compute) derivatives with respect to all other solid mechanics degree of freedom are zero. We will therefore modify the node-update procedure as follows: Each <code>AlgebraicNode</code> stores a pointer to the <code>FSIHermiteBeamElement</code> that its reference point is located in. This is possible because <code>FSIHermiteBeamElements</code> are derived from the <code>FiniteElement</code> class which, in turn, is derived from the <code>GeomObject</code> class. In other words, the sub-objects of the compound <code>MeshAsGeomObject</code> are <code>GeomObjects</code> themselves. Their shape is parametrised by the <code>FSIHermiteBeamElement's</code> local coordinate, <img class="formulaInl" alt="$ s $" src="form_2.png" width="5" height="6"/> , which acts as the (sub-)<code>GeomObject's</code> intrinsic coordinate, <img class="formulaInl" alt="$ \zeta $" src="form_1.png" width="6" height="13"/> .</p>
<p>Given a pointer to a compound <code>GeomObject</code>, <code>geom_obj_pt</code>, say, and the intrinsic coordinate <img class="formulaInl" alt="$ \zeta_{compound} $" src="form_3.png" width="51" height="14"/> = <code>zeta_compound</code> of a point in that <code>GeomObject</code>, the function <code>GeomObject::locate_zeta(...)</code> may be used to determine a pointer, <code>sub_obj_pt</code>, to the sub-object that this point is located in, and the vector of intrinsic coordinates <code>zeta_sub_obj</code> of the point in this sub-object. This procedure is illustrated in this code fragment:</p>
<div class="fragment"><div class="line"> [...] </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Vector containing the (1D) intrinsic coordinate in the </span></div>
<div class="line"><span class="comment">// compound GeomObject:</span></div>
<div class="line">Vector&lt;double&gt; zeta_compound(1);</div>
<div class="line">zeta_compound[0]=0.3;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pointer to the sub-GeomObject:</span></div>
<div class="line">GeomObject* sub_geom_obj_pt;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Vector containing the (1D) intrinsic coordinate in the </span></div>
<div class="line"><span class="comment">// sub-GeomObject:</span></div>
<div class="line">Vector&lt;double&gt; zeta_sub_obj(1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get it...</span></div>
<div class="line">geom_obj_pt-&gt;locate_zeta(zeta_compound, sub_geom_obj_pt, zeta_sub_obj);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check the result: </span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Position vector to the point when viewed from</span></div>
<div class="line"><span class="comment">// the compound GeomObject</span></div>
<div class="line">Vector&lt;double&gt; r_compound(2);</div>
<div class="line">geom_obj_pt-&gt;position(zeta_compound,r_compound);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Position vector to the point when viewed from</span></div>
<div class="line"><span class="comment">// the sub-GeomObject</span></div>
<div class="line">Vector&lt;double&gt; r_sub(2);</div>
<div class="line">sub_geom_obj_pt-&gt;position(zeta_sub,r_sub);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// With a bit of luck we should now have r_sub == r_compound...</span></div>
<div class="line"> </div>
<div class="line">[...]</div>
</div><!-- fragment --><p>Here is an illustration of the relation between the various coordinates and <code>GeomObjects:</code> </p>
<div class="image">
<img src="locate_zeta.gif" alt=""/>
<div class="caption">
Sketch of the various coordinates and GeomObjects. The (continuous) beam is parametrised by its Lagrangian coordinate xi which doubles as the intrinsic coordinate zeta for its role as a GeomObject. The (discretised) beam is a compound GeomObject, parametrised by the Lagrangian coordinate xi; its constituent FSI beam elements are sub-GeomObjects that are parametrised by their local coordinates, s. </div></div>
 <p>We note that the <code>GeomObject</code> base class provides a default implementation for the <code>GeomObject::locate_zeta(...)</code> function as a virtual member function which returns the <code>GeomObject's</code> <code>"this"</code> pointer and sets <img class="formulaInl" alt="$ \zeta_{compound} = \zeta_{sub} $" src="form_4.png" width="89" height="14"/> . Unless the function is overloaded in a specific derived class, the <code>GeomObject</code> therefore acts as its own sub-object. This is a sensible default as it ensures that (<code>geom_obj_pt</code>, <img class="formulaInl" alt="$ \zeta_{compound}$" src="form_5.png" width="51" height="14"/> ) and (<code>sub_geom_obj_pt</code>, <code><img class="formulaInl" alt="$ \zeta_{sub}$" src="form_6.png" width="20" height="13"/></code> ) always identify the same point, regardless of whether nor not the <code>GeomObject</code> pointed to by <code>geom_obj_pt</code> is a "compound" <code>GeomObject</code>.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="impl"></a>
The implementation</h1>
<p>The implementation of the sparse node-update strategy requires only a few minor modifications to the <code>AlgebraicCollapsibleChannelMesh</code>, first discussed in the <a href="../../../navier_stokes/algebraic_collapsible_channel/html/index.html">non-FSI example.</a></p>
<hr  />
<h2><a class="anchor" id="mesh"></a>
The AlgebraicCollapsibleChannelMesh</h2>
<p>We construct the mesh by multiple inheritance, combining the already existing <code>CollapsibleChannelMesh</code> with the <code>AlgebraicMesh</code> base class:</p>
 <div class="fragment"><div class="line">  <span class="comment">//========start_of_algebraic_collapsible_channel_mesh==============</span></div>
<div class="line"><span class="comment">  /// Collapsible channel mesh with algebraic node update</span></div>
<div class="line"><span class="comment"></span>  <span class="comment">//=================================================================</span></div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line">  <span class="keyword">class </span>AlgebraicCollapsibleChannelMesh</div>
<div class="line">    : <span class="keyword">public</span> <span class="keyword">virtual</span> CollapsibleChannelMesh&lt;ELEMENT&gt;,</div>
<div class="line">      <span class="keyword">public</span> AlgebraicMesh</div>
<div class="line">  {</div>
</div><!-- fragment --><p> The constructor calls the constructor of the underlying <code>CollapsibleChannelMesh</code> and then calls the private member function <code>setup_algebraic_node_update()</code> to initialise the data for the algebraic node update procedures. (The initialisation is implemented in a separate function so it can be called from additional mesh constructors that are not discussed here.) The destructor remains empty.</p>
<div class="fragment"><div class="line">  <span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">    /// Constructor: Pass number of elements in upstream/collapsible/</span></div>
<div class="line"><span class="comment">    /// downstream segment and across the channel; lengths of upstream/</span></div>
<div class="line"><span class="comment">    /// collapsible/downstream segments and width of channel, pointer to</span></div>
<div class="line"><span class="comment">    /// GeomObject that defines the collapsible segment and pointer to</span></div>
<div class="line"><span class="comment">    /// TimeStepper (defaults to the default timestepper, Steady).</span></div>
<div class="line"><span class="comment"></span>    AlgebraicCollapsibleChannelMesh(</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; nup,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ncollapsible,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ndown,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ny,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; lup,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; lcollapsible,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ldown,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ly,</div>
<div class="line">      GeomObject* wall_pt,</div>
<div class="line">      TimeStepper* time_stepper_pt = &amp;Mesh::Default_TimeStepper)</div>
<div class="line">      : CollapsibleChannelMesh&lt;ELEMENT&gt;(nup,</div>
<div class="line">                                        ncollapsible,</div>
<div class="line">                                        ndown,</div>
<div class="line">                                        ny,</div>
<div class="line">                                        lup,</div>
<div class="line">                                        lcollapsible,</div>
<div class="line">                                        ldown,</div>
<div class="line">                                        ly,</div>
<div class="line">                                        wall_pt,</div>
<div class="line">                                        time_stepper_pt)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Add the geometric object to the list associated with this AlgebraicMesh</span></div>
<div class="line">      AlgebraicMesh::add_geom_object_list_pt(wall_pt);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Setup algebraic node update operations</span></div>
<div class="line">      setup_algebraic_node_update();</div>
<div class="line">    }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /// Destructor: empty</span></div>
<div class="line"><span class="comment"></span>    <span class="keyword">virtual</span> ~AlgebraicCollapsibleChannelMesh() {}</div>
</div><!-- fragment --><p> The function <code>algebraic_node_update(...)</code> is defined as a pure virtual function in the <code>AlgebraicMesh</code> base class and therefore must be implemented, whereas the virtual function <code>update_node_update(...)</code> is only required for refineable meshes and can remain empty.</p>
<div class="fragment"><div class="line">    <span class="comment">/// Update nodal position at time level t (t=0: present;</span></div>
<div class="line"><span class="comment">    /// t&gt;0: previous)</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> algebraic_node_update(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; t, AlgebraicNode*&amp; node_pt);</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /// Update the node-udate data after mesh adaptation.</span></div>
<div class="line"><span class="comment">    /// Empty -- no update of node update required as this is</span></div>
<div class="line"><span class="comment">    /// non-refineable mesh.</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> update_node_update(AlgebraicNode*&amp; node_pt) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">protected</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">    /// Function to setup the algebraic node update</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> setup_algebraic_node_update();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /// Dummy function pointer</span></div>
<div class="line"><span class="comment"></span>    CollapsibleChannelDomain::BLSquashFctPt Dummy_fct_pt;</div>
<div class="line">  };</div>
</div><!-- fragment --><p>The setup of the algebraic node update is very similar to that used in the <a href="../../../navier_stokes/algebraic_collapsible_channel/html/index.html">non-FSI example discussed earlier.</a> The main difference between the two versions of the mesh is that we use the function <code>GeomObject::locate_zeta(...)</code> to determine the sub-<code>GeomObject</code> within which the reference point on the wall is located. As discussed above, the default implementation of this function in the <code>GeomObject</code> base class ensures that the mesh can be used with compound and non-compound <code>GeomObjects</code>.</p>
<p>We start by determining the x and y-coordinates of the nodes and decide if they are located in the collapsible part of the mesh. (The positions of nodes that are located in the rigid upstream and downstream channel segments do not have to be updated; for such nodes we skip the assignment of the node-update data. See the discussion in the <a href="../../../navier_stokes/algebraic_collapsible_channel/html/index.html">non-FSI example</a> for details.)</p>
 <div class="fragment"><div class="line">  <span class="comment">//=====start_setup=================================================</span></div>
<div class="line"><span class="comment">  /// Setup algebraic mesh update -- assumes that mesh has</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// initially been set up with a flush upper wall</span></div>
<div class="line"><span class="comment"></span>  <span class="comment">//=================================================================</span></div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line">  <span class="keywordtype">void</span> AlgebraicCollapsibleChannelMesh&lt;ELEMENT&gt;::setup_algebraic_node_update()</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Shorthand for some geometric data:</span></div>
<div class="line">    <span class="keywordtype">double</span> l_up = this-&gt;domain_pt()-&gt;l_up();</div>
<div class="line">    <span class="keywordtype">double</span> l_collapsible = this-&gt;domain_pt()-&gt;l_collapsible();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Loop over all nodes in mesh</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> nnod = this-&gt;nnode();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; nnod; j++)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Get pointer to node -- recall that that Mesh::node_pt(...) has been</span></div>
<div class="line">      <span class="comment">// overloaded in the AlgebraicMesh class to return a pointer to</span></div>
<div class="line">      <span class="comment">// an AlgebraicNode.</span></div>
<div class="line">      AlgebraicNode* nod_pt = node_pt(j);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Get coordinates</span></div>
<div class="line">      <span class="keywordtype">double</span> x = nod_pt-&gt;x(0);</div>
<div class="line">      <span class="keywordtype">double</span> y = nod_pt-&gt;x(1);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Check if it&#39;s in the collapsible part:</span></div>
<div class="line">      <span class="keywordflow">if</span> ((x &gt;= l_up) &amp;&amp; (x &lt;= (l_up + l_collapsible)))</div>
</div><!-- fragment --><p> Assuming that the wall is in its undeformed position (we'll check this in a second...), we determine the intrinsic coordinate of the reference point on the upper wall (taking the offset between <img class="formulaInl" alt="$ x$" src="form_7.png" width="8" height="6"/> and <img class="formulaInl" alt="$ \zeta$" src="form_8.png" width="6" height="13"/> into account: The left end of the elastic wall is located at <img class="formulaInl" alt="$ \zeta=0$" src="form_9.png" width="29" height="13"/> and at <img class="formulaInl" alt="$ x = L_{up} $" src="form_10.png" width="45" height="14"/> ), and identify the sub - <code>GeomObject</code> within which the reference point is located.</p>
<div class="fragment"><div class="line">      {</div>
<div class="line">        <span class="comment">// Get zeta coordinate on the undeformed wall</span></div>
<div class="line">        Vector&lt;double&gt; zeta(1);</div>
<div class="line">        zeta[0] = x - l_up;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Get pointer to geometric (sub-)object and Lagrangian coordinate</span></div>
<div class="line">        <span class="comment">// on that sub-object. For a wall that is represented by</span></div>
<div class="line">        <span class="comment">// a single geom object, this simply returns the input.</span></div>
<div class="line">        <span class="comment">// If the geom object consists of sub-objects (e.g.</span></div>
<div class="line">        <span class="comment">// if it is a finite element mesh representing a wall,</span></div>
<div class="line">        <span class="comment">// then we&#39;ll obtain the pointer to the finite element</span></div>
<div class="line">        <span class="comment">// (in its incarnation as a GeomObject) and the</span></div>
<div class="line">        <span class="comment">// local coordinate in that element.</span></div>
<div class="line">        GeomObject* geom_obj_pt;</div>
<div class="line">        Vector&lt;double&gt; s(1);</div>
<div class="line">        this-&gt;Wall_pt-&gt;locate_zeta(zeta, geom_obj_pt, s);</div>
</div><!-- fragment --><p> Just to be on the safe side, we double check that the wall is still in its undeformed position:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">        <span class="comment">// Get position vector to wall:</span></div>
<div class="line">        Vector&lt;double&gt; r_wall(2);</div>
<div class="line">        geom_obj_pt-&gt;position(s, r_wall);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Sanity check: Confirm that the wall is in its undeformed position</span></div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line">        <span class="keywordflow">if</span> ((std::fabs(r_wall[0] - x) &gt; 1.0e-15) &amp;&amp;</div>
<div class="line">            (std::fabs(r_wall[1] - y) &gt; 1.0e-15))</div>
<div class="line">        {</div>
<div class="line">          std::ostringstream error_stream;</div>
<div class="line">          error_stream &lt;&lt; <span class="stringliteral">&quot;Wall must be in its undeformed position when\n&quot;</span></div>
<div class="line">                       &lt;&lt; <span class="stringliteral">&quot;algebraic node update information is set up!\n &quot;</span></div>
<div class="line">                       &lt;&lt; <span class="stringliteral">&quot;x-discrepancy: &quot;</span> &lt;&lt; std::fabs(r_wall[0] - x)</div>
<div class="line">                       &lt;&lt; std::endl</div>
<div class="line">                       &lt;&lt; <span class="stringliteral">&quot;y-discrepancy: &quot;</span> &lt;&lt; std::fabs(r_wall[1] - y)</div>
<div class="line">                       &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">throw</span> OomphLibError(error_stream.str(),</div>
<div class="line">                              OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                              OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">        }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> Now we can create the node update data for the present <code>AlgebraicNode</code>. The node update function involves a single <code>GeomObject:</code> The (sub-)<code>GeomObject</code> within which the reference point on the upper wall is located.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line">        <span class="comment">// One geometric object is involved in update operation</span></div>
<div class="line">        Vector&lt;GeomObject*&gt; geom_object_pt(1);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The actual geometric object (If the wall is simple GeomObject</span></div>
<div class="line">        <span class="comment">// this is the same as Wall_pt; if it&#39;s a compound GeomObject</span></div>
<div class="line">        <span class="comment">// this points to the sub-object)</span></div>
<div class="line">        geom_object_pt[0] = geom_obj_pt;</div>
</div><!-- fragment --><p> As in the mesh used in the <a href="../../../navier_stokes/algebraic_collapsible_channel/html/index.html">non-FSI example</a> we store the x-coordinate of the reference point on the lower wall, the fractional height of the node, and its intrinsic coordinate in the (sub-)<code>GeomObject</code> on the upper wall. We also store the intrinsic coordinate of the reference point in the compound <code>GeomObject</code> (i.e. the Lagrangian coordinate of the reference point in the continuous beam). This will turn out to be useful in the refineable version of this mesh, to be discussed in <a href="../../fsi_collapsible_channel_adapt/html/index.html">the next example.</a></p>
<div class="fragment"><div class="line"> </div>
<div class="line">        <span class="comment">// The update function requires four  parameters:</span></div>
<div class="line">        Vector&lt;double&gt; ref_value(4);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// First reference value: Original x-position</span></div>
<div class="line">        ref_value[0] = r_wall[0];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Second  reference value: fractional position along</span></div>
<div class="line">        <span class="comment">// straight line from the bottom (at the original x position)</span></div>
<div class="line">        <span class="comment">// to the point on the wall)</span></div>
<div class="line">        ref_value[1] = y / r_wall[1];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Third reference value: Reference local coordinate</span></div>
<div class="line">        <span class="comment">// in wall element (local coordinate in FE if we&#39;re dealing</span></div>
<div class="line">        <span class="comment">// with a wall mesh)</span></div>
<div class="line">        ref_value[2] = s[0];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Fourth reference value: zeta coordinate on wall</span></div>
<div class="line">        <span class="comment">// If the wall is a simple GeomObject, zeta[0]=s[0]</span></div>
<div class="line">        <span class="comment">// but if it&#39;s a compound GeomObject (e.g. a finite element mesh)</span></div>
<div class="line">        <span class="comment">// zeta scales during mesh refinement, whereas s[0] and the</span></div>
<div class="line">        <span class="comment">// pointer to the geom object have to be re-computed.</span></div>
<div class="line">        ref_value[3] = zeta[0];</div>
</div><!-- fragment --><p> Finally, we create the node update information by passing the pointer to the mesh, the pointer to the <code>GeomObject</code> and the reference values to the <code>AlgebraicNode</code>.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">        <span class="comment">// Setup algebraic update for node: Pass update information</span></div>
<div class="line">        nod_pt-&gt;add_node_update_info(<span class="keyword">this</span>, <span class="comment">// mesh</span></div>
<div class="line">                                     geom_object_pt, <span class="comment">// vector of geom objects</span></div>
<div class="line">                                     ref_value); <span class="comment">// vector of  ref. values</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// end of setup_algebraic_node_update</span></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="driver"></a>
The driver code</h1>
<p>Since <code>oomph-lib's</code> various node update procedures use the same interfaces, changing the node update strategy from the <code>Domain/MacroElement</code> - based procedure, discussed in the <a href="../../fsi_collapsible_channel/html/index.html">previous example,</a> to the procedure implemented in the <code>AlgebraicCollapsibleChannelMesh</code>, only requires minimal changes to the driver code. In fact, the changes are so trivial, that both versions are implemented in the same driver code, <a href="../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc">fsi_collapsible_channel.cc</a>, using compiler flags to switch from one version to the other. If the code is compiled with the flag <code>-DMACRO_ELEMENT_NODE_UPDATE</code> the <code>Domain/MacroElement</code> - based node-update procedure, implemented in the <code>MacroElementNodeUpdateCollapsibleChannelMesh</code> is used, otherwise the code uses the <code>AlgebraicCollapsibleChannelMesh</code>, discussed above. Here is one of the few portions of the code where the distinction between the two versions is required: The access function to the "bulk" (fluid) mesh in the problem class.</p>
 <div class="fragment"><div class="line"><span class="preprocessor">#ifdef MACRO_ELEMENT_NODE_UPDATE</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Access function for the specific bulk (fluid) mesh</span></div>
<div class="line"><span class="comment"></span> MacroElementNodeUpdateCollapsibleChannelMesh&lt;ELEMENT&gt;* bulk_mesh_pt() </div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from pointer to the Mesh base class to the specific </span></div>
<div class="line">   <span class="comment">// element type that we&#39;re using here.</span></div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span></div>
<div class="line">    MacroElementNodeUpdateCollapsibleChannelMesh&lt;ELEMENT&gt;*<span class="keyword">&gt;</span></div>
<div class="line">    (Bulk_mesh_pt);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Access function for the specific bulk (fluid) mesh</span></div>
<div class="line"><span class="comment"></span> AlgebraicCollapsibleChannelMesh&lt;ELEMENT&gt;* bulk_mesh_pt() </div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from pointer to the Mesh base class to the specific </span></div>
<div class="line">   <span class="comment">// element type that we&#39;re using here.</span></div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span></div>
<div class="line">    AlgebraicCollapsibleChannelMesh&lt;ELEMENT&gt;*<span class="keyword">&gt;</span></div>
<div class="line">    (Bulk_mesh_pt);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> Incidentally, the driver code also uses compiler flags to switch between Crouzeix-Raviart and Taylor-Hood elements for the discretisation of the Navier-Stokes equations. By default, Crouzeix-Raviart elements are used; Taylor-Hood elements are used if the code is compiled with with the flag <code>-DTAYLOR_HOOD</code>.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="results"></a>
Results</h1>
<p>The animations shown below illustrate the interaction between fluid and solid mechanics degrees of freedom in the computations with the algebraic node update. Comparison with the corresponding animations for the <code>Domain/MacroElement</code> - based procedures, shown in the <a href="../../fsi_collapsible_channel/html/index.html#comments">earlier example</a> demonstrates the greatly improved sparsity of the node update. With the algebraic node-update procedures, the residuals of the <code>FSIHermiteBeamElements</code> now only depend on the fluid degrees of freedom in the adjacent fluid elements and on the solid mechanics degree of freedom in the <code>FSIHermiteBeamElements</code> that affect the nodal position in these fluid elements.</p>
<div class="image">
<img src="cr_alg.gif" alt=""/>
<div class="caption">
Animation of the Data values that affect the fluid traction that the adjacent fluid elements exert onto the various FSIHermiteBeamElements in the wall mesh. (The fluid elements are 2D Crouzeix-Raviart elements.) </div></div>
 <p>Here is the corresponding animation for a discretisation with 2D Taylor-Hood elements. These elements have no internal <code>Data</code> but the pressure degrees of freedom are stored at the fluid element's corner nodes:</p>
<div class="image">
<img src="th_alg.gif" alt=""/>
<div class="caption">
Animation of the Data values that affect the fluid traction that the adjacent fluid elements exert onto the various FSIHermiteBeamElements in the wall mesh. (The fluid elements are 2D Taylor-Hood elements.) </div></div>
 <p>Finally, here is an animation that shows the (solid mechanics) degrees of freedom that affect the node-update of a given fluid node. The red square marker shows the fluid node; the green numbers show the number of the degrees of freedom at the <code>SolidNodes</code> that are involved that fluid node's node update. With the algebraic node update, the position of each fluid node is only affected by the solid mechanics degree of freedom in the <code>FSIHermiteBeamElement</code> that contains its reference point.</p>
<div class="image">
<img src="fsi_fluid_nodes.gif" alt=""/>
<div class="caption">
Animation of the Data values that affect the node update of the fluid nodes. </div></div>
 <p>The improved sparsity leads to a very significant speedup compared to the <code>MacroElement/Domain</code> - based node update procedure.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="ex"></a>
Exercises</h1>
<ol type="1">
<li>Demonstrate that the dramatically improved execution speed achieved with the <code>AlgebraicCollapsibleChannelMesh</code> is mainly due to the improved sparsity of the node update, achieved by using the <code>GeomObject::locate_zeta(...)</code> function. <br  />
<br  />
 <b>Hint:</b> You can either copy the basic <code>MyAlgebraicCollapsibleChannelMesh</code> in the file <a href="../../../../demo_drivers/navier_stokes/collapsible_channel/my_alg_channel_mesh.h">my_algebraic_collapsible_channel_mesh.h</a>, developed for the <a href="../../../navier_stokes/algebraic_collapsible_channel/html/index.html">non-FSI version of the collapsible channel problem,</a> into the FSI driver code <a href="../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc">fsi_collapsible_channel.cc</a> and use that mesh instead of the <code>AlgebraicCollapsibleChannelMesh</code>, or replace the line <br  />
<br  />
<div class="fragment"><div class="line">this-&gt;Wall_pt-&gt;locate_zeta(zeta,geom_obj_pt,s);</div>
</div><!-- fragment --> <br  />
<br  />
 in the function <code>AlgebraicCollapsibleChannelMesh&lt;ELEMENT&gt;::setup_algebraic_node_update()</code> in <a href="../../../../src/meshes/collapsible_channel_mesh.template.cc">collapsible_channel_mesh.template.cc</a> by <br  />
<br  />
<div class="fragment"><div class="line">this-&gt;Wall_pt-&gt;GeomObject::locate_zeta(zeta,geom_obj_pt,s);</div>
</div><!-- fragment --> <br  />
<br  />
 thus bypassing the "sparsification". <br  />
<br  />
</li>
<li>Explore how the speedup achievable with the algebraic node update procedure depends on the mesh resolution. A speedup by a factor of ten is typical for computations on the coarse mesh used for the validation runs; much more dramatic speedups tend to be obtained on finer meshes. <br  />
<br  />
 <br  />
</li>
</ol>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory:<br  />
<br  />
<center> <a href="../../../../demo_drivers/interaction/fsi_collapsible_channel/">demo_drivers/interaction/fsi_collapsible_channel/ </a> </center><br  />
</li>
<li>The driver code is: <br  />
<br  />
<center> <a href="../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc">demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc </a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:29:26
        </div>
      </div>
    </footer>
</body>
</html>
