<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Demo problem: Adaptive solution of Poisson&#39;s equation in a fish-shaped domain.</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Demo problem: Adaptive solution of Poisson's equation in a fish-shaped domain. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this document, we discuss the solution of a 2D Poisson problem using <code>oomph-lib's</code> powerful mesh adaptation routines:</p>
<center> <table class="doxtable">
<tr>
<td><center> <b>Two-dimensional model Poisson problem in a non-trivial domain</b> </center> Solve <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{i=1}^2 \frac{\partial^2u}{\partial x_i^2} = -1, \ \ \ \ \ \ \ \ \ \ (1) \]" src="form_0.png" width="139" height="38"/>
</p>
 in the fish-shaped domain <img class="formulaInl" alt="$D_{fish} $" src="form_1.png" width="30" height="14"/>, with homogeneous Dirichlet boundary conditions <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left. u\right|_{\partial D_{fish}}=0. \ \ \ \ \ \ \ \ \ \ (2) \]" src="form_2.png" width="128" height="16"/>
</p>
   </td></tr>
</table>
<br  />
 </center><p> <br  />
</p>
<div class="image">
<img src="fish_poisson_soln.gif" alt=""/>
<div class="caption">
Plot of the solution </div></div>
 <p>The sharp corners in the domain create singularities in the solution (its derivatives are unbounded) and so accurate results can only be obtained if we use a sufficiently fine discretisation. Implementing this by uniform mesh refinement would create a huge number of elements in the interior of the domain where the fine discretisation is not required.</p>
<p>To avoid this problem, <code>oomph-lib</code> provides mesh adaptation routines that automatically adapt the mesh, based on <em>a</em> <em>posteriori</em> error estimates. Regions in which an error estimator indicates that the solution is not resolved to the required accuracy are refined; automatic unrefinement is performed in regions where the discretisation is unnecessarily fine.</p>
<p>We provide a detailed discussion of the driver code <a href="../../../../demo_drivers/poisson/fish_poisson/fish_poisson.cc">fish_poisson.cc</a> which illustrates a variety of mesh refinement procedures. [The alternative driver code <a href="../../../../demo_drivers/poisson/fish_poisson/fish_poisson_no_adapt.cc">fish_poisson_no_adapt.cc</a> solves the same problem without mesh adaptation. Its structure is very similar to that in the <a href="../../../poisson/two_d_poisson/html/index.html">2D Poisson problem considered earlier</a>. It is provided mainly to illustrate how easy to it is incorporate adaptivity into a <code>Problem</code>.]</p>
<p>In the current example we demonstrate how to <em>use</em> existing refineable meshes and elements. Two further examples will demonstrate how easy it is to <em>create</em> refineable meshes in <a href="../../../poisson/two_d_poisson_adapt/html/index.html">domains with polygonal boundaries</a> and in <a href="../../../poisson/fish_poisson2/html/index.html">domains with curvilinear boundaries.</a></p>
<hr  />
<p> <br  />
 </p><hr  />
<h1><a class="anchor" id="global"></a>
Global parameters and functions</h1>
<p>The namespace <code><a class="el" href="namespaceConstSourceForPoisson.html" title="Namespace for const source term in Poisson equation.">ConstSourceForPoisson</a></code> only contains the constant source function <img class="formulaInl" alt="$ f(x)=-1 $" src="form_3.png" width="56" height="14"/>.</p>
 <div class="fragment"><div class="line"><span class="comment">//============ start_of_namespace=====================================</span></div>
<div class="line"><span class="comment">/// Namespace for const source term in Poisson equation</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceConstSourceForPoisson.html">ConstSourceForPoisson</a></div>
<div class="line">{ </div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Strength of source function: default value -1.0</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceConstSourceForPoisson.html#add351c5acab2561d68d1fc9ec3d5fc5e">Strength</a>=-1.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/// Const source function</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceConstSourceForPoisson.html#aeaa1153817bde9598372b803342f3299">source_function</a>(<span class="keyword">const</span> Vector&lt;double&gt;&amp; x, <span class="keywordtype">double</span>&amp; source)</div>
<div class="line"> {</div>
<div class="line">  source = <a class="code" href="namespaceConstSourceForPoisson.html#add351c5acab2561d68d1fc9ec3d5fc5e">Strength</a>;</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of namespace</span></div>
<div class="ttc" id="anamespaceConstSourceForPoisson_html"><div class="ttname"><a href="namespaceConstSourceForPoisson.html">ConstSourceForPoisson</a></div><div class="ttdoc">Namespace for const source term in Poisson equation.</div><div class="ttdef"><b>Definition:</b> <a href="fish__poisson_8cc_source.html#l00047">fish_poisson.cc:48</a></div></div>
<div class="ttc" id="anamespaceConstSourceForPoisson_html_add351c5acab2561d68d1fc9ec3d5fc5e"><div class="ttname"><a href="namespaceConstSourceForPoisson.html#add351c5acab2561d68d1fc9ec3d5fc5e">ConstSourceForPoisson::Strength</a></div><div class="ttdeci">double Strength</div><div class="ttdoc">Strength of source function: default value -1.0.</div><div class="ttdef"><b>Definition:</b> <a href="fish__poisson_8cc_source.html#l00051">fish_poisson.cc:51</a></div></div>
<div class="ttc" id="anamespaceConstSourceForPoisson_html_aeaa1153817bde9598372b803342f3299"><div class="ttname"><a href="namespaceConstSourceForPoisson.html#aeaa1153817bde9598372b803342f3299">ConstSourceForPoisson::source_function</a></div><div class="ttdeci">void source_function(const Vector&lt; double &gt; &amp;x, double &amp;source)</div><div class="ttdoc">Const source function.</div><div class="ttdef"><b>Definition:</b> <a href="fish__poisson_8cc_source.html#l00054">fish_poisson.cc:54</a></div></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="main"></a>
The driver code</h1>
<p>The main code is very short and calls two functions that illustrate two different adaptation strategies:</p><ul>
<li>A black-box approach in which the adaptation cycle<ol type="1">
<li>solve the problem on the initial, coarse mesh</li>
<li>compute an error estimate</li>
<li>adapt the mesh</li>
<li>solve again</li>
</ol>
</li>
</ul>
<p>is performed automatically until the solution satisfies the required error bounds (or until the maximum permitted number of adaptation steps has been reached).</p><ul>
<li>In the second approach we start by performing a number of uniform mesh refinement steps, and then use incremental adaptations, allowing us to document how the refinement proceeds.</li>
</ul>
 <div class="fragment"><div class="line"><span class="comment">//=================start_of_main==========================================</span></div>
<div class="line"><span class="comment">/// Demonstrate how to solve 2D Poisson problem in </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// fish-shaped domain with mesh adaptation.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="fish__poisson_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Solve with adaptation, docing the intermediate steps</span></div>
<div class="line"> <a class="code" href="fish__poisson_8cc.html#a9f5ae2c03a7f02e61857d322177ce5d5">solve_with_incremental_adaptation</a>();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Solve directly, with fully automatic adaptation</span></div>
<div class="line"> <a class="code" href="fish__poisson_8cc.html#a79a1cfcdcd821bd277276d163b85acfb">solve_with_fully_automatic_adaptation</a>();</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of main</span></div>
<div class="ttc" id="afish__poisson_8cc_html_a79a1cfcdcd821bd277276d163b85acfb"><div class="ttname"><a href="fish__poisson_8cc.html#a79a1cfcdcd821bd277276d163b85acfb">solve_with_fully_automatic_adaptation</a></div><div class="ttdeci">void solve_with_fully_automatic_adaptation()</div><div class="ttdoc">Demonstrate how to solve 2D Poisson problem in fish-shaped domain with fully automatic mesh adaptatio...</div><div class="ttdef"><b>Definition:</b> <a href="fish__poisson_8cc_source.html#l00282">fish_poisson.cc:282</a></div></div>
<div class="ttc" id="afish__poisson_8cc_html_a9f5ae2c03a7f02e61857d322177ce5d5"><div class="ttname"><a href="fish__poisson_8cc.html#a9f5ae2c03a7f02e61857d322177ce5d5">solve_with_incremental_adaptation</a></div><div class="ttdeci">void solve_with_incremental_adaptation()</div><div class="ttdoc">Demonstrate how to solve 2D Poisson problem in fish-shaped domain with mesh adaptation....</div><div class="ttdef"><b>Definition:</b> <a href="fish__poisson_8cc_source.html#l00191">fish_poisson.cc:191</a></div></div>
<div class="ttc" id="afish__poisson_8cc_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="fish__poisson_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdoc">Demonstrate how to solve 2D Poisson problem in fish-shaped domain with mesh adaptation.</div><div class="ttdef"><b>Definition:</b> <a href="fish__poisson_8cc_source.html#l00325">fish_poisson.cc:325</a></div></div>
</div><!-- fragment --> <hr  />
<h2><a class="anchor" id="black_box"></a>
Black-box adaptation</h2>
<p>We start by creating the Problem object, using the refineable equivalent of the <code>QPoissonElement</code> &ndash; the <code>RefineableQPoissonElement</code>, which is templated by the dimension and the number of nodes along the element's edges; the <code>RefineableQPoissonElement&lt;2,3&gt;</code> is a nine-node (bi-quadratic) quad element.</p>
 <div class="fragment"><div class="line"><span class="comment">//================================start_black_box=========================</span></div>
<div class="line"><span class="comment">/// Demonstrate how to solve 2D Poisson problem in </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// fish-shaped domain with fully automatic mesh adaptation</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="fish__poisson_8cc.html#a79a1cfcdcd821bd277276d163b85acfb">solve_with_fully_automatic_adaptation</a>()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Set up the problem with nine-node refineable Poisson elements</span></div>
<div class="line">  <a class="code" href="classRefineableFishPoissonProblem.html">RefineableFishPoissonProblem&lt;RefineableQPoissonElement&lt;2,3&gt;</a> &gt; problem;</div>
<div class="ttc" id="aclassRefineableFishPoissonProblem_html"><div class="ttname"><a href="classRefineableFishPoissonProblem.html">RefineableFishPoissonProblem</a></div><div class="ttdoc">Refineable Poisson problem in fish-shaped domain. Template parameter identifies the element type.</div><div class="ttdef"><b>Definition:</b> <a href="fish__poisson_8cc_source.html#l00069">fish_poisson.cc:70</a></div></div>
</div><!-- fragment --><p>After creating the <code>DocInfo</code> object, we document the (default) adaptivity targets:</p>
<div class="fragment"><div class="line">  <span class="comment">// Setup labels for output</span></div>
<div class="line">  <span class="comment">//------------------------</span></div>
<div class="line">  DocInfo doc_info;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Set output directory</span></div>
<div class="line">  doc_info.set_directory(<span class="stringliteral">&quot;RESLT_fully_automatic&quot;</span>); </div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Step number</span></div>
<div class="line">  doc_info.number()=0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Doc (default) refinement targets</span></div>
<div class="line">  <span class="comment">//----------------------------------</span></div>
<div class="line">  problem.<a class="code" href="classRefineableFishPoissonProblem.html#a803c9050b07b35aba22f08a5a9e59f2c">mesh_pt</a>()-&gt;doc_adaptivity_targets(cout);</div>
<div class="ttc" id="aclassRefineableFishPoissonProblem_html_a803c9050b07b35aba22f08a5a9e59f2c"><div class="ttname"><a href="classRefineableFishPoissonProblem.html#a803c9050b07b35aba22f08a5a9e59f2c">RefineableFishPoissonProblem::mesh_pt</a></div><div class="ttdeci">RefineableFishMesh&lt; ELEMENT &gt; * mesh_pt()</div><div class="ttdoc">Overloaded version of the problem's access function to the mesh. Recasts the pointer to the base Mesh...</div><div class="ttdef"><b>Definition:</b> <a href="fish__poisson_8cc_source.html#l00089">fish_poisson.cc:89</a></div></div>
</div><!-- fragment --><p> These include</p><ul>
<li><b>The target for the maximum error:</b> Any elements whose error estimate exceed this value will be split into four "sons".</li>
<li><b>The target for the minimum error: </b> Any elements whose error estimate lies below this value are deemed to be unnecessarily small and are scheduled for (possible) unrefinement. [Elements can only be unrefined (i.e. merged with their "brothers") if their "brothers" are also scheduled for unrefinement.]</li>
<li><b>The minimum refinement level:</b> In problems with curvilinear domain boundaries it is often necessary to retain a reasonably accurate representation of the boundary (e.g. for postprocessing purposes), even if the error estimate suggests that the mesh could be unrefined further.</li>
<li><b>The maximum refinement level:</b> In problems where the solution has singularities, the refinement process would continue indefinitely, therefore an upper bound on the refinement level must be imposed.</li>
<li>Finally, because unrefinement is done purely to speed up the computation, it would not make sense to adapt the mesh if this process would only remove a few elements, while forcing the re-computation of the solution on an only slightly coarsened mesh. Therefore, no mesh adaptation is performed if<ul>
<li>the adaptation would only perform unrefinements</li>
<li><b>and</b> the number of elements scheduled for unrefinement is below a certain threshold.</li>
</ul>
</li>
</ul>
<p>These default parameters can be changed by the user; see <a class="el" href="index.html#comments">Comments and Exercises</a>.</p>
<p>The fully-adaptive solution of the problem is very simple. We simply pass the maximum number of adaptations to the Newton solver and document the results. Done!</p>
 <div class="fragment"><div class="line">  <span class="comment">// Solve/doc the problem with fully automatic adaptation</span></div>
<div class="line">  <span class="comment">//------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Maximum number of adaptations:</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> max_adapt=5;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Solve the problem; perform up to specified number of adaptations.</span></div>
<div class="line">  problem.newton_solve(max_adapt);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">//Output solution</span></div>
<div class="line">  problem.<a class="code" href="classRefineableFishPoissonProblem.html#aeee1bf23216971b50b8822c45e62c48b">doc_solution</a>(doc_info);   </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end black box</span></div>
<div class="ttc" id="aclassRefineableFishPoissonProblem_html_aeee1bf23216971b50b8822c45e62c48b"><div class="ttname"><a href="classRefineableFishPoissonProblem.html#aeee1bf23216971b50b8822c45e62c48b">RefineableFishPoissonProblem::doc_solution</a></div><div class="ttdeci">void doc_solution(DocInfo &amp;doc_info)</div><div class="ttdoc">Doc the solution. Output directory and labels are specified by DocInfo object.</div><div class="ttdef"><b>Definition:</b> <a href="fish__poisson_8cc_source.html#l00161">fish_poisson.cc:161</a></div></div>
</div><!-- fragment --> <hr  />
<h2><a class="anchor" id="incremental"></a>
Incremental adaptation</h2>
<p>To allow the user more control over the mesh adaptation process, <code>oomph-lib</code> provides a number of functions that perform individual adaptation steps without re-computing the solution immediately. This allows the user to</p><ul>
<li>perform uniform mesh refinement and unrefinement,</li>
<li>impose a specific refinement pattern,</li>
<li>monitor/document the progress of the automatic adaptation.</li>
</ul>
<p>The second driver function illustrates some of these functions. We start by setting up the problem, create the <code>DocInfo</code> object and document the adaptivity targets, exactly as before:</p>
 <div class="fragment"><div class="line"><span class="comment">//=====================start_of_incremental===============================</span></div>
<div class="line"><span class="comment">/// Demonstrate how to solve 2D Poisson problem in </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// fish-shaped domain with mesh adaptation. First we solve on the original</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// coarse mesh. Next we do a few uniform refinement steps and re-solve.</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// Finally, we enter into an automatic adapation loop.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="fish__poisson_8cc.html#a9f5ae2c03a7f02e61857d322177ce5d5">solve_with_incremental_adaptation</a>()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Set up the problem with nine-node refineable Poisson elements</span></div>
<div class="line"> <a class="code" href="classRefineableFishPoissonProblem.html">RefineableFishPoissonProblem&lt;RefineableQPoissonElement&lt;2,3&gt;</a> &gt; problem;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Setup labels for output</span></div>
<div class="line"> <span class="comment">//------------------------</span></div>
<div class="line"> DocInfo doc_info;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set output directory</span></div>
<div class="line"> doc_info.set_directory(<span class="stringliteral">&quot;RESLT_incremental&quot;</span>); </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Step number</span></div>
<div class="line"> doc_info.number()=0;</div>
<div class="line">  </div>
<div class="line">  </div>
<div class="line"> <span class="comment">// Doc (default) refinement targets</span></div>
<div class="line"> <span class="comment">//----------------------------------</span></div>
<div class="line"> problem.<a class="code" href="classRefineableFishPoissonProblem.html#a803c9050b07b35aba22f08a5a9e59f2c">mesh_pt</a>()-&gt;doc_adaptivity_targets(cout);</div>
</div><!-- fragment --><p> Next, we solve the problem on the original, very coarse mesh and document the result:</p>
 <div class="fragment"><div class="line"> <span class="comment">// Solve/doc the problem on the initial, very coarse mesh</span></div>
<div class="line"> <span class="comment">//-------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Solve the problem</span></div>
<div class="line"> problem.newton_solve();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Output solution</span></div>
<div class="line"> problem.<a class="code" href="classRefineableFishPoissonProblem.html#aeee1bf23216971b50b8822c45e62c48b">doc_solution</a>(doc_info);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Increment counter for solutions </span></div>
<div class="line"> doc_info.number()++;</div>
</div><!-- fragment --><p>We know that the result is unlikely to be very accurate, so we apply three levels of uniform refinement, increasing the number of elements from 4 to 256, and re-compute:</p>
 <div class="fragment"><div class="line"> <span class="comment">// Do three rounds of uniform mesh refinement and re-solve</span></div>
<div class="line"> <span class="comment">//--------------------------------------------------------</span></div>
<div class="line"> problem.refine_uniformly();</div>
<div class="line"> problem.refine_uniformly();</div>
<div class="line"> problem.refine_uniformly();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Solve the problem </span></div>
<div class="line"> problem.newton_solve();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Output solution</span></div>
<div class="line"> problem.<a class="code" href="classRefineableFishPoissonProblem.html#aeee1bf23216971b50b8822c45e62c48b">doc_solution</a>(doc_info);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Increment counter for solutions </span></div>
<div class="line"> doc_info.number()++;</div>
</div><!-- fragment --><p> The solution looks much smoother but we suspect that the corner regions are still under-resolved. Therefore, we call the <code>Problem::adapt()</code> function which computes an error estimate for all elements and automatically performs a single mesh adaptation (refinement/unrefinement) step. If this adaptation changes the mesh, we recompute the solution, using the "normal" Newton solver without automatic adaptation. We document the solution and continue the adaptation cycle until <code>Problem::adapt()</code> ceases to change the mesh:</p>
 <div class="fragment"><div class="line"> <span class="comment">// Now do (up to) four rounds of fully automatic adapation in response to </span></div>
<div class="line"> <span class="comment">//-----------------------------------------------------------------------</span></div>
<div class="line"> <span class="comment">// error estimate</span></div>
<div class="line"> <span class="comment">//---------------</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> max_solve=4;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> isolve=0;isolve&lt;max_solve;isolve++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Adapt problem/mesh</span></div>
<div class="line">   problem.adapt(); </div>
<div class="line">         </div>
<div class="line">   <span class="comment">// Re-solve the problem if the adaptation has changed anything</span></div>
<div class="line">   <span class="keywordflow">if</span> ((problem.<a class="code" href="classRefineableFishPoissonProblem.html#a803c9050b07b35aba22f08a5a9e59f2c">mesh_pt</a>()-&gt;nrefined()  !=0)||</div>
<div class="line">       (problem.<a class="code" href="classRefineableFishPoissonProblem.html#a803c9050b07b35aba22f08a5a9e59f2c">mesh_pt</a>()-&gt;nunrefined()!=0))</div>
<div class="line">    {</div>
<div class="line">     problem.newton_solve();</div>
<div class="line">    }</div>
<div class="line">   <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">     cout &lt;&lt; <span class="stringliteral">&quot;Mesh wasn&#39;t adapted --&gt; we&#39;ll stop here&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">     <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Output solution</span></div>
<div class="line">   problem.<a class="code" href="classRefineableFishPoissonProblem.html#aeee1bf23216971b50b8822c45e62c48b">doc_solution</a>(doc_info);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Increment counter for solutions </span></div>
<div class="line">   doc_info.number()++;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of incremental</span></div>
</div><!-- fragment --><p> The progress of the adaptation is illustrated in the animated gif at the beginning of this document. The first frame displays the solution on the original four-element mesh; the next frame shows the solution on the uniformly refined mesh; the final two frames show the progress of the subsequent, error-estimate-driven mesh adaptation.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="problem"></a>
The problem class</h1>
<p>The problem class is virtually identical to that used in the <a href="../../../poisson/two_d_poisson/html/index.html">2D Poisson problem without mesh refinement</a>. In the present problem, we leave the function <code>Problem::actions_before_newton_solve()</code> empty because the boundary conditions do not change. The function <code><a class="el" href="classRefineableFishPoissonProblem.html#a803c9050b07b35aba22f08a5a9e59f2c" title="Overloaded version of the problem&#39;s access function to the mesh. Recasts the pointer to the base Mesh...">RefineableFishPoissonProblem::mesh_pt()</a></code> overloads the (virtual) function <code>Problem::mesh_pt()</code> since it returns a pointer to a generic <code>Mesh</code> object, rather than a pointer to the specific mesh used in this problem. This avoids explicit re-casts in the rest of the code where member functions of the specific mesh need to be accessed.</p>
 <div class="fragment"><div class="line"><span class="comment">//======start_of_problem_class========================================</span></div>
<div class="line"><span class="comment">/// Refineable Poisson problem in fish-shaped domain.</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// Template parameter identifies the element type.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classRefineableFishPoissonProblem.html">RefineableFishPoissonProblem</a> : <span class="keyword">public</span> Problem</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Constructor</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classRefineableFishPoissonProblem.html#a7a9c8258a867de6b3c8b9d00a7c965f1">RefineableFishPoissonProblem</a>();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Destructor: Empty</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">virtual</span> <a class="code" href="classRefineableFishPoissonProblem.html#a4a5e7c5f264364211ad641353933c222">~RefineableFishPoissonProblem</a>(){}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Update the problem specs after solve (empty)</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classRefineableFishPoissonProblem.html#a7f6c356f7c8bd0130de957297e999f40">actions_after_newton_solve</a>() {}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Update the problem specs before solve (empty)</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classRefineableFishPoissonProblem.html#a58098181f3b88c2fc65f24fb15c1a529">actions_before_newton_solve</a>() {}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Overloaded version of the problem&#39;s access function to </span></div>
<div class="line"><span class="comment"> /// the mesh. Recasts the pointer to the base Mesh object to </span></div>
<div class="line"><span class="comment"> /// the actual mesh type.</span></div>
<div class="line"><span class="comment"></span> RefineableFishMesh&lt;ELEMENT&gt;* <a class="code" href="classRefineableFishPoissonProblem.html#a803c9050b07b35aba22f08a5a9e59f2c">mesh_pt</a>() </div>
<div class="line">  {</div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span>RefineableFishMesh&lt;ELEMENT&gt;*<span class="keyword">&gt;</span>(Problem::mesh_pt());</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Doc the solution. Output directory and labels are specified </span></div>
<div class="line"><span class="comment"> /// by DocInfo object</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classRefineableFishPoissonProblem.html#aeee1bf23216971b50b8822c45e62c48b">doc_solution</a>(DocInfo&amp; doc_info);</div>
<div class="line"> </div>
<div class="line">}; <span class="comment">// end of problem class</span></div>
<div class="ttc" id="aclassRefineableFishPoissonProblem_html_a4a5e7c5f264364211ad641353933c222"><div class="ttname"><a href="classRefineableFishPoissonProblem.html#a4a5e7c5f264364211ad641353933c222">RefineableFishPoissonProblem::~RefineableFishPoissonProblem</a></div><div class="ttdeci">virtual ~RefineableFishPoissonProblem()</div><div class="ttdoc">Destructor: Empty.</div><div class="ttdef"><b>Definition:</b> <a href="fish__poisson_8cc_source.html#l00078">fish_poisson.cc:78</a></div></div>
<div class="ttc" id="aclassRefineableFishPoissonProblem_html_a58098181f3b88c2fc65f24fb15c1a529"><div class="ttname"><a href="classRefineableFishPoissonProblem.html#a58098181f3b88c2fc65f24fb15c1a529">RefineableFishPoissonProblem::actions_before_newton_solve</a></div><div class="ttdeci">void actions_before_newton_solve()</div><div class="ttdoc">Update the problem specs before solve (empty)</div><div class="ttdef"><b>Definition:</b> <a href="fish__poisson_8cc_source.html#l00084">fish_poisson.cc:84</a></div></div>
<div class="ttc" id="aclassRefineableFishPoissonProblem_html_a7a9c8258a867de6b3c8b9d00a7c965f1"><div class="ttname"><a href="classRefineableFishPoissonProblem.html#a7a9c8258a867de6b3c8b9d00a7c965f1">RefineableFishPoissonProblem::RefineableFishPoissonProblem</a></div><div class="ttdeci">RefineableFishPoissonProblem()</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> <a href="fish__poisson_8cc_source.html#l00109">fish_poisson.cc:109</a></div></div>
<div class="ttc" id="aclassRefineableFishPoissonProblem_html_a7f6c356f7c8bd0130de957297e999f40"><div class="ttname"><a href="classRefineableFishPoissonProblem.html#a7f6c356f7c8bd0130de957297e999f40">RefineableFishPoissonProblem::actions_after_newton_solve</a></div><div class="ttdeci">void actions_after_newton_solve()</div><div class="ttdoc">Update the problem specs after solve (empty)</div><div class="ttdef"><b>Definition:</b> <a href="fish__poisson_8cc_source.html#l00081">fish_poisson.cc:81</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="constructor"></a>
The Problem constructor</h1>
<p>We start by creating the mesh, using <code>oomph-lib's</code> <code>RefineableFishMesh</code> object:</p>
<div class="fragment"><div class="line"><span class="comment">//===========start_of_constructor=========================================</span></div>
<div class="line"><span class="comment">/// Constructor for adaptive Poisson problem in fish-shaped</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// domain.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><a class="code" href="classRefineableFishPoissonProblem.html#a7a9c8258a867de6b3c8b9d00a7c965f1">RefineableFishPoissonProblem&lt;ELEMENT&gt;::RefineableFishPoissonProblem</a>()</div>
<div class="line">{ </div>
<div class="line">    </div>
<div class="line"> <span class="comment">// Build fish mesh -- this is a coarse base mesh consisting </span></div>
<div class="line"> <span class="comment">// of four elements. We&#39;ll refine/adapt the mesh later.</span></div>
<div class="line"> Problem::mesh_pt()=<span class="keyword">new</span> RefineableFishMesh&lt;ELEMENT&gt;;</div>
</div><!-- fragment --><p> Next, we create an error estimator for the problem. The <code>Z2ErrorEstimator</code> is based on Zhu and Zienkiewicz's flux recovery technique and can be used with all elements that are derived from the <code>ElementWithZ2ErrorEstimator</code> base class (or with functions that implement the pure virtual functions that are defined in this class) &ndash; the <code>RefineableQPoissonElement</code> is an element of this type.</p>
<div class="fragment"><div class="line"> <span class="comment">// Create/set error estimator</span></div>
<div class="line"> mesh_pt()-&gt;spatial_error_estimator_pt()=<span class="keyword">new</span> Z2ErrorEstimator;</div>
</div><!-- fragment --><p> Next we pin the nodal values on all boundaries, apply the homogeneous Dirichlet boundary conditions, pass the pointer to the source function to the elements, and set up the equation numbering scheme.</p>
<div class="fragment"><div class="line"> <span class="comment">// Set the boundary conditions for this problem: All nodes are</span></div>
<div class="line"> <span class="comment">// free by default -- just pin the ones that have Dirichlet conditions</span></div>
<div class="line"> <span class="comment">// here. Since the boundary values are never changed, we set</span></div>
<div class="line"> <span class="comment">// them here rather than in actions_before_newton_solve(). </span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_bound = mesh_pt()-&gt;nboundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_bound;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="keywordtype">unsigned</span> n_node = mesh_pt()-&gt;nboundary_node(i);</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> n=0;n&lt;n_node;n++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Pin the single scalar value at this node</span></div>
<div class="line">     mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;pin(0); </div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Assign the homogenous boundary condition for the one and only</span></div>
<div class="line">     <span class="comment">// nodal value</span></div>
<div class="line">     mesh_pt()-&gt;boundary_node_pt(i,n)-&gt;set_value(0,0.0); </div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over elements and set pointers to source function</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_element = mesh_pt()-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from FiniteElement to the present element</span></div>
<div class="line">   ELEMENT *el_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(mesh_pt()-&gt;element_pt(e));</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Set the source function pointer</span></div>
<div class="line">   el_pt-&gt;source_fct_pt() = &amp;<a class="code" href="namespaceConstSourceForPoisson.html#aeaa1153817bde9598372b803342f3299">ConstSourceForPoisson::source_function</a>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Setup the equation numbering scheme</span></div>
<div class="line"> cout &lt;&lt;<span class="stringliteral">&quot;Number of equations: &quot;</span> &lt;&lt; assign_eqn_numbers() &lt;&lt; std::endl; </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of constructor</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="doc"></a>
Post-processing</h1>
<p>The post-processing routine writes the computed result to an output file, labeled with the identifiers specified in the <code>DocInfo</code> object.</p>
<div class="fragment"><div class="line"><span class="comment">//=======start_of_doc=====================================================</span></div>
<div class="line"><span class="comment">/// Doc the solution in tecplot format.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classRefineableFishPoissonProblem.html#aeee1bf23216971b50b8822c45e62c48b">RefineableFishPoissonProblem&lt;ELEMENT&gt;::doc_solution</a>(DocInfo&amp; doc_info)</div>
<div class="line">{ </div>
<div class="line"> </div>
<div class="line"> ofstream some_file;</div>
<div class="line"> <span class="keywordtype">char</span> filename[100];</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Number of plot points in each coordinate direction.</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> npts;</div>
<div class="line"> npts=5; </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output solution </span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/soln%i.dat&quot;</span>,doc_info.directory().c_str(),</div>
<div class="line">         doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> mesh_pt()-&gt;output(some_file,npts);</div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of doc</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="comments"></a>
Comments and Exercises</h1>
<p>The purpose of this example was to provide a high-level overview of <code>oomph-lib's</code> mesh adaptation procedures. We demonstrated that the implementation of full adaptivity only required us to</p><ul>
<li>replace the <code>FishMesh</code> and the <code>QPoissonElement</code> objects by their refineable equivalents, <code>RefineableFishMesh</code> and <code>RefineableQPoissonElement</code>, respectively</li>
<li>specify the error estimator, and</li>
<li>specify the maximum number of adaptations for the black-box adaptive Newton solver.</li>
</ul>
<p>(Compare the Problem specification for the current problem to that of its non-refineable equivalent, contained in the alternative driver code <a href="../../../../demo_drivers/poisson/fish_poisson/fish_poisson_no_adapt.cc">fish_poisson_no_adapt.cc.</a>)</p>
<p>Since most of the "hard work" involved in the mesh adaptation is "hidden" from the user, we highlight some important aspects of the procedure:</p>
<h2><a class="anchor" id="adapt_bc"></a>
Automatic transfer of the solution/boundary conditions during the mesh adaptation</h2>
<p>The <code>Problem::adapt()</code> function automatically determines the correct boundary conditions for newly created nodes on the Mesh boundary; it automatically updates the equation numbering scheme, and interpolates the solution from the original mesh onto the adapted mesh. This is important in nonlinear problems where the provision of a good initial guess for the Newton iteration is vital; and in time-dependent problems where the solution at one timestep provides initial conditions for the next one. See the discussion of <a href="../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html">the adaptive solution of the unsteady heat equation</a> for more details. Furthermore, the source function pointers are automatically passed to an element's four "son" elements when the element is subdivided. This allows the adaptation to proceed completely automatically, without any intervention by the "user". On return from <code>Problem::adapt()</code> the problem can immediately be re-solved.</p>
<p>In some special cases, certain actions may need to be performed before or after the mesh adaptation (e.g. if flux boundary conditions are applied by <code>FaceElements</code>; this is explained in <a href="../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html">another example</a>). To ensure that these steps are performed when the adaptation is controlled by the "black-box" adaptive Newton solver, the <code>Problem</code> class provides the two empty virtual functions </p><div class="fragment"><div class="line">Problem::actions_before_adapt()</div>
</div><!-- fragment --><p> and </p><div class="fragment"><div class="line">Problem::actions_after_adapt()</div>
</div><!-- fragment --><p> which are called automatically before and after the adaptation. The "user" can overload these in his/her specific <code>Problem</code> class to implement such actions.</p>
<h2><a class="anchor" id="how_to"></a>
Automatic mesh adaptation in domains with curvilinear boundaries</h2>
<p>The mesh adaptation not only increases the number of elements but also produces a more accurate representation of the curvilinear domain boundary &ndash; new boundary nodes are placed exactly onto the analytically-defined, curvilinear boundary, rather than on the boundaries of the "father" element, which only provides an approximate representation of the exact domain boundary. This is achieved by employing a <code>MacroElement-based</code> representation of the <code>Domain</code> &ndash; we will discuss this in more detail in <a href="../../../poisson/fish_poisson2/html/index.html">another example.</a></p>
<h2><a class="anchor" id="problem_vs_mesh"></a>
Problem adaptation vs. Mesh adaptation</h2>
<p>Many adaptation routines in the <code>Problem</code> class have equivalents in the <code>RefineableMesh</code> class. It is important to appreciate the important differences between them: If adaptation is performed at the <code>Problem</code> level, the adapted <code>Problem</code> is fully functional, i.e. boundary conditions will have been assigned for newly created nodes on the mesh boundary, the equation numbering scheme will have been updated, etc. The adapted <code>Problem</code> can therefore be re-solved immediately. Conversely, if a mesh is refined directly, using the member functions of the <code>RefineableMesh</code> class, many of these additional tasks need to be performed "by hand" before the adapted <code>Problem</code> can be resolved.</p>
<hr  />
<h2><a class="anchor" id="exercises"></a>
Exercises</h2>
<p>To familiarise yourself with <code>oomph-lib's</code> mesh adaptation procedures we suggest the following exercises:</p><ol type="1">
<li>When the Poisson problem is solved with the default refinement targets, no elements are unrefined. Increase the minimum permitted error from its default value of <img class="formulaInl" alt="$ 10^{-5} $" src="form_4.png" width="25" height="11"/> to <img class="formulaInl" alt="$ 10^{-4} $" src="form_5.png" width="25" height="11"/> by adding the statement <div class="fragment"><div class="line">problem.mesh_pt()-&gt;min_permitted_error()=1.0e-4;</div>
</div><!-- fragment --> before <div class="fragment"><div class="line">problem.mesh_pt()-&gt;doc_adaptivity_targets(cout);</div>
</div><!-- fragment --> This value forces an unrefinement of several elements in the mesh: <div class="image">
<img src="fish_poisson_soln2.gif" alt=""/>
<div class="caption">
Plot of the solutions obtained with the modified adaptivity targets. </div></div>
 </li>
<li>Convince yourself that <code>Problem::adapt()</code> does indeed interpolate the solution from the coarse mesh to the fine mesh &ndash; call <code>Problem::doc_solution(...)</code> before and after its execution. <br  />
</li>
<li>The <code>Problem::refine_uniformly()</code> function has a counterpart <code>Problem::unrefine_uniformly()</code>. Why does this function not simply unrefine every single element in the mesh? Explore the action of <code>Problem::unrefine_uniformly()</code> by plotting the solution before and after a few executions of this function. <div class="image">
<img src="fish_poisson_soln3.gif" alt=""/>
<div class="caption">
Uniform unrefinement </div></div>
 </li>
<li>Impose a "user-defined" refinement pattern by calling the function <code>Problem::refine_selected_elements(...)</code>.</li>
</ol>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory: <center> <a href="../../../../demo_drivers/poisson/fish_poisson/">demo_drivers/poisson/fish_poisson/ </a> </center></li>
<li>The driver code is: <center> <a href="../../../../demo_drivers/poisson/fish_poisson/fish_poisson.cc">demo_drivers/poisson/fish_poisson/fish_poisson.cc </a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:14:21
        </div>
      </div>
    </footer>
</body>
</html>
