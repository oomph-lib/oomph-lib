In this document, we demonstrate how a solve the 1D Poisson problem using existing objects from the {\ttfamily oomph-\/lib} library\+:

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{One-\/dimensional model Poisson problem}} \end{center}  Solve \[ \frac{\mbox{d}^2u}{\mbox{d}x^2} = f(x), \ \ \ \ \ \ \ \ \ \ (1) \] in a one-\/dimensional domain $ x\in[0,1] $, with boundary conditions \[ u(0)=u_0 \ \mbox{\ \ \ and \ \ \ } \ \ u(1)=u_1, \ \ \ \ \ \ \ \ \ \ (2) \] where $ u_0 $ and $ u_1 $ are given.   \\\cline{1-1}
\end{longtabu}
\end{center} 

We provide a detailed discussion of the driver code \href{../../../../demo_drivers/poisson/one_d_poisson/one_d_poisson.cc}{\texttt{ one\+\_\+d\+\_\+poisson.\+cc}} which solves the problem for the specific source function \[ f(x) = \pm 30 \sin(\sqrt{30} x), \ \ \ \ (3) \] and boundary conditions \[ u_0= 0; \ \ \ u_1 = \mp 1. \] In this case, the problem has the (fish-\/shaped) exact solution \[ u(x) = \pm \left[ \left(\sin(\sqrt{30})-1\right) x - \sin(\sqrt{30} x)\right]. \ \ \ \ \ (4)\]

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{one_d_fish}
\doxyfigcaption{The fish-\/shaped solution u(x). }
\end{DoxyImage}


\DoxyHorRuler{0}
 ~\newline
 \DoxyHorRuler{0}
\hypertarget{index_global}{}\doxysection{Global parameters and functions}\label{index_global}
Source functions and problem parameters generally need to be accessible to a variety of {\ttfamily oomph-\/lib} objects and we tend to define such functions/quantities in C++ namespaces. Here we use the namespace {\ttfamily \mbox{\hyperlink{namespaceFishSolnOneDPoisson}{Fish\+Soln\+One\+DPoisson}}} to define the source function (3) and the exact solution (4). Both functions use the integer value \mbox{\hyperlink{namespaceFishSolnOneDPoisson_a108e814ef887ffcc8caa7c65a7d30f06}{Fish\+Soln\+One\+DPoisson\+::\+Sign}}, which can be set by the \char`\"{}user\char`\"{} in the driver code.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_namespace================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Namespace for fish-\/shaped solution of 1D Poisson equation}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{namespace }\mbox{\hyperlink{namespaceFishSolnOneDPoisson}{FishSolnOneDPoisson}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Sign of the source function }}
\DoxyCodeLine{\textcolor{comment}{ /// (-\/ gives the upper half of the fish, + the lower half)}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{int} \mbox{\hyperlink{namespaceFishSolnOneDPoisson_a108e814ef887ffcc8caa7c65a7d30f06}{Sign}}=-\/1;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Exact, fish-\/shaped solution as a 1D vector}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespaceFishSolnOneDPoisson_a52c9346f567cb68fe20268a592deb4bc}{get\_exact\_u}}(\textcolor{keyword}{const} Vector<double>\& x, Vector<double>\& u)}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  u[0] = double(\mbox{\hyperlink{namespaceFishSolnOneDPoisson_a108e814ef887ffcc8caa7c65a7d30f06}{Sign}})*((sin(sqrt(30.0))-\/1.0)*x[0]-\/sin(sqrt(30.0)*x[0]));}
\DoxyCodeLine{ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Source function required to make the fish shape an exact solution }}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespaceFishSolnOneDPoisson_afd2f5aef6b8868526dbf8e74d379697f}{source\_function}}(\textcolor{keyword}{const} Vector<double>\& x, \textcolor{keywordtype}{double}\& source)}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  source = double(\mbox{\hyperlink{namespaceFishSolnOneDPoisson_a108e814ef887ffcc8caa7c65a7d30f06}{Sign}})*30.0*sin(sqrt(30.0)*x[0]);}
\DoxyCodeLine{ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of namespace}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysection{The driver code}\label{index_main}
In order to solve the Poisson problem with {\ttfamily oomph-\/lib}, we represent the mathematical problem defined by equations (1) and (2) in a specific {\ttfamily Problem} object, {\ttfamily \mbox{\hyperlink{classOneDPoissonProblem}{One\+DPoisson\+Problem}}}. {\ttfamily oomph-\/lib} provides a variety of 1D Poisson elements (1D elements with linear, quadratic and cubic representations for the unknown function) and we pass the specific element type as a template parameter to the {\ttfamily Problem}. In the driver code, listed below, we use the {\ttfamily QPoisson\+Element$<$1,4$>$}, a four-\/node (cubic) 1D Poisson element. We pass the number of elements in the mesh as the first argument to the {\ttfamily Problem} constructor and the pointer to the source function, defined in the namespace {\ttfamily \mbox{\hyperlink{namespaceFishSolnOneDPoisson}{Fish\+Soln\+One\+DPoisson}}}, as the second.

Once the problem has been created, we execute {\ttfamily Problem\+::self\+\_\+test()}, which checks that the {\ttfamily Problem} has been properly set up. If this test is passed, we proceed to solve the problem\+: Initially, we set the sign of the source function (defined in the variable {\ttfamily \mbox{\hyperlink{namespaceFishSolnOneDPoisson_a108e814ef887ffcc8caa7c65a7d30f06}{Fish\+Soln\+One\+DPoisson\+::\+Sign}}}) to -\/1 and solve, using {\ttfamily oomph-\/lib\textquotesingle{}s} Newton solver. We write the solution to output files, using the {\ttfamily \mbox{\hyperlink{classOneDPoissonProblem}{One\+DPoisson\+Problem}}\textquotesingle{}s} member function {\ttfamily doc\+\_\+solution()}, discussed below. We then repeat the process, using a positive sign for the source function.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//======start\_of\_main==================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Driver for 1D Poisson problem}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//=====================================================================}}
\DoxyCodeLine{\textcolor{keywordtype}{int} \mbox{\hyperlink{one__d__poisson_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set up the problem: }}
\DoxyCodeLine{ \textcolor{comment}{// Solve a 1D Poisson problem using a source function that generates}}
\DoxyCodeLine{ \textcolor{comment}{// a fish shaped exact solution}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_element=40; \textcolor{comment}{//Number of elements}}
\DoxyCodeLine{ \mbox{\hyperlink{classOneDPoissonProblem}{OneDPoissonProblem<QPoissonElement<1,4>}} > \textcolor{comment}{//Element type as template parameter}}
\DoxyCodeLine{  problem(n\_element,\mbox{\hyperlink{namespaceFishSolnOneDPoisson_afd2f5aef6b8868526dbf8e74d379697f}{FishSolnOneDPoisson::source\_function}});}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Check whether the problem can be solved}}
\DoxyCodeLine{ cout << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n\(\backslash\)nProblem self-\/test "{}};}
\DoxyCodeLine{ \textcolor{keywordflow}{if} (problem.self\_test()==0)  }
\DoxyCodeLine{  \{}
\DoxyCodeLine{   cout << \textcolor{stringliteral}{"{}passed: Problem can be solved."{}} << std::endl;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ \textcolor{keywordflow}{else} }
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{keywordflow}{throw} OomphLibError(\textcolor{stringliteral}{"{}failed!"{}},}
\DoxyCodeLine{                       OOMPH\_CURRENT\_FUNCTION,OOMPH\_EXCEPTION\_LOCATION);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set the sign of the source function:}}
\DoxyCodeLine{ cout << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n\(\backslash\)nSolving with negative sign:\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{ \mbox{\hyperlink{namespaceFishSolnOneDPoisson_a108e814ef887ffcc8caa7c65a7d30f06}{FishSolnOneDPoisson::Sign}}=-\/1;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Solve the problem with this Sign}}
\DoxyCodeLine{ problem.newton\_solve();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{//Output solution for this case (label output files with "{}0"{})}}
\DoxyCodeLine{ problem.doc\_solution(0);}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Change the sign of the source function:}}
\DoxyCodeLine{ cout << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n\(\backslash\)nSolving with positive sign:\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{ \mbox{\hyperlink{namespaceFishSolnOneDPoisson_a108e814ef887ffcc8caa7c65a7d30f06}{FishSolnOneDPoisson::Sign}}=1;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Re-\/solve the problem with this Sign (boundary conditions get}}
\DoxyCodeLine{ \textcolor{comment}{// updated automatically when Problem::actions\_before\_newton\_solve() is}}
\DoxyCodeLine{ \textcolor{comment}{// called.}}
\DoxyCodeLine{ problem.newton\_solve();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{//Output solution for this case (label output files with "{}1"{})}}
\DoxyCodeLine{ problem.doc\_solution(1);}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of main}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_problem}{}\doxysection{The problem class}\label{index_problem}
{\ttfamily oomph-\/lib} driver codes tend to be very compact and \char`\"{}high-\/level\char`\"{} because all the \char`\"{}hard work\char`\"{} is done in the {\ttfamily Problem} specification. For our simple Poisson problem, this step is completely straightforward\+:

The {\ttfamily \mbox{\hyperlink{classOneDPoissonProblem}{One\+DPoisson\+Problem}}} is derived from {\ttfamily oomph-\/lib\textquotesingle{}s} generic {\ttfamily Problem} class and, as discussed above, the specific element type is specified as a template parameter to make it easy for the \char`\"{}user\char`\"{} to change the element type in the driver code.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_problem\_class============================================}}
\DoxyCodeLine{\textcolor{comment}{/// 1D Poisson problem in unit interval.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT> }
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{classOneDPoissonProblem}{OneDPoissonProblem}} : \textcolor{keyword}{public} Problem}

\end{DoxyCodeInclude}
 The {\ttfamily One\+DPoisson\+Problemclass} has five member functions, only three of which are non-\/trivial\+:
\begin{DoxyItemize}
\item the constructor {\ttfamily \mbox{\hyperlink{classOneDPoissonProblem}{One\+DPoisson\+Problem(...)}}} 
\item the function {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+solve()} 
\item the function {\ttfamily doc\+\_\+solution(...)} 
\end{DoxyItemize}The function {\ttfamily Problem\+::actions\+\_\+after\+\_\+newton\+\_\+solve()} is a pure virtual member function of the {\ttfamily Problem} base class and must be provided. However, it is not required in the present problem so we leave it empty. Similarly, the problem destructor can remain empty as all memory de-\/allocation is handled in the destructor of the {\ttfamily Problem} base class. The Problem only stores one private data member, the pointer to the source function.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Constructor: Pass number of elements and pointer to source function}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classOneDPoissonProblem_ab814af5dfd3b7ae665cd20e27da5d9ae}{OneDPoissonProblem}}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& n\_element, }
\DoxyCodeLine{                    PoissonEquations<1>::PoissonSourceFctPt source\_fct\_pt);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Destructor (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classOneDPoissonProblem_a940fa32d7939788e27b708818fb046ec}{\string~OneDPoissonProblem}}()}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{keyword}{delete} mesh\_pt();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem specs before solve: (Re)set boundary conditions}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classOneDPoissonProblem_a6e42423869771fbd216326cba516a76b}{actions\_before\_newton\_solve}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem specs after solve (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classOneDPoissonProblem_ab023d367cc68b77a7828536333c924ed}{actions\_after\_newton\_solve}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Doc the solution, pass the number of the case considered,}}
\DoxyCodeLine{\textcolor{comment}{ /// so that output files can be distinguished.}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classOneDPoissonProblem_aaf42d034e42e7615acfa262a9c56b638}{doc\_solution}}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& label);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to source function}}
\DoxyCodeLine{\textcolor{comment}{} PoissonEquations<1>::PoissonSourceFctPt \mbox{\hyperlink{classOneDPoissonProblem_a5fdff4b9218f56dec7fbc282f2428eef}{Source\_fct\_pt}};}
\DoxyCodeLine{}
\DoxyCodeLine{\}; \textcolor{comment}{// end of problem class}}

\end{DoxyCodeInclude}


\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center}{\bfseries{\label{index_gen_conv}%
\Hypertarget{index_gen_conv}%
A general convention}}\end{center}  The type {\ttfamily Poisson\+Equations$<$1$>$\+::\+Poisson\+Source\+Fct\+Pt}, used to define the type of the source function pointer, is a public typedef, defined in {\ttfamily oomph-\/lib\textquotesingle{}s} Poisson equation class, as follows\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[...]}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// \(\backslash\)short Function pointer to source function has the form fct(x,f(x)). }}
\DoxyCodeLine{\textcolor{comment}{ /// Note that x is a Vector! }}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keyword}{typedef} void (*PoissonSourceFctPt)(\textcolor{keyword}{const} Vector<double>\& x, \textcolor{keywordtype}{double}\& f);}
\DoxyCodeLine{}
\DoxyCodeLine{[...]}

\end{DoxyCode}


This reflects a {\bfseries{general}} {\bfseries{convention}} in {\ttfamily oomph-\/lib}\+: The function types of source functions etc. that are required by specific elements, are always declared as public types in the element classes. The logic behind this is that only the element writer/maintainer knows what type of function (i.\+e. the type of its arguments and its return value) a specific element requires. For instance, the source function for the Poisson equation requires the spatial coordinate {\ttfamily x} as input and computes the (scalar) value of the source function. Since the syntax for C++ function pointers is somewhat \char`\"{}non-\/obvious\char`\"{} (that\textquotesingle{}s according to Bjarne Stroustrup, the designer of C++, himself!), we use typedefs to give the function pointers more intuitive names. Since the typedefs are public, they can be used anywhere in the \char`\"{}user\textquotesingle{}s\char`\"{} code.

While we\textquotesingle{}re at it, here\textquotesingle{}s {\bfseries{another}} {\bfseries{convention\+:}} If an {\ttfamily oomph-\/lib} function has input and output arguments in its argument list, the input arguments appear first (and are usually passed as constant references), while the output arguments appear last (and are passed as references).   \\\cline{1-1}
\end{longtabu}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_constructor}{}\doxysection{The Problem constructor}\label{index_constructor}
In the {\ttfamily Problem} constructor, we define the domain length and build a {\ttfamily Mesh}, using {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily One\+DMesh} object which is templated by the element type. The required number of elements and the domain length are passed as arguments to the {\ttfamily One\+DMesh} constructors. The subsequent lines of code pin the nodal values at the two boundary nodes. Next we pass the source function pointer to the elements. Finally, we call the generic {\ttfamily Problem\+::assign\+\_\+eqn\+\_\+numbers()} routine which does precisely what it says...


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====start\_of\_constructor===============================================}}
\DoxyCodeLine{\textcolor{comment}{/// Constructor for 1D Poisson problem in unit interval.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// Discretise the 1D domain with n\_element elements of type ELEMENT.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// Specify function pointer to source function. }}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\mbox{\hyperlink{classOneDPoissonProblem_ab814af5dfd3b7ae665cd20e27da5d9ae}{OneDPoissonProblem<ELEMENT>::OneDPoissonProblem}}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& n\_element,}
\DoxyCodeLine{ PoissonEquations<1>::PoissonSourceFctPt source\_fct\_pt) : }
\DoxyCodeLine{ \mbox{\hyperlink{classOneDPoissonProblem_a5fdff4b9218f56dec7fbc282f2428eef}{Source\_fct\_pt}}(source\_fct\_pt)}
\DoxyCodeLine{\{ }
\DoxyCodeLine{ Problem::Sparse\_assembly\_method = Perform\_assembly\_using\_two\_arrays;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Problem::Problem\_is\_nonlinear = false;}}
\DoxyCodeLine{ \textcolor{comment}{// Set domain length }}
\DoxyCodeLine{ \textcolor{keywordtype}{double} L=1.0;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Build mesh and store pointer in Problem}}
\DoxyCodeLine{ Problem::mesh\_pt() = \textcolor{keyword}{new} OneDMesh<ELEMENT>(n\_element,L);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set the boundary conditions for this problem: By default, all nodal}}
\DoxyCodeLine{ \textcolor{comment}{// values are free -\/-\/ we only need to pin the ones that have }}
\DoxyCodeLine{ \textcolor{comment}{// Dirichlet conditions. }}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Pin the single nodal value at the single node on mesh }}
\DoxyCodeLine{ \textcolor{comment}{// boundary 0 (= the left domain boundary at x=0)}}
\DoxyCodeLine{ mesh\_pt()-\/>boundary\_node\_pt(0,0)-\/>pin(0);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Pin the single nodal value at the single node on mesh }}
\DoxyCodeLine{ \textcolor{comment}{// boundary 1 (= the right domain boundary at x=1)}}
\DoxyCodeLine{ mesh\_pt()-\/>boundary\_node\_pt(1,0)-\/>pin(0);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Complete the setup of the 1D Poisson problem:}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Loop over elements and set pointers to source function}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Upcast from GeneralisedElement to the present element}}
\DoxyCodeLine{   ELEMENT *elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()-\/>element\_pt(i));}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{//Set the source function pointer}}
\DoxyCodeLine{   elem\_pt-\/>source\_fct\_pt() = \mbox{\hyperlink{classOneDPoissonProblem_a5fdff4b9218f56dec7fbc282f2428eef}{Source\_fct\_pt}};}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup equation numbering scheme}}
\DoxyCodeLine{ assign\_eqn\_numbers();}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of constructor}}

\end{DoxyCodeInclude}
 The cast in the loop over the elements is required because {\ttfamily Mesh\+::element\+\_\+pt(...)} returns a pointer to the element base class {\ttfamily Generalised\+Element}, which does not have an access function to the Poisson element\textquotesingle{}s source function pointer.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center}{\bfseries{\label{index_const_conv}%
\Hypertarget{index_const_conv}%
A general convention}}\end{center}  It might seem more natural to pass essential parameters (such as the Poisson element\textquotesingle{}s source function pointer) to an element when the element is created. If we made the source function pointer an argument of the element constructor, we would not have to execute this loop in the constructor.

However, {\ttfamily oomph-\/lib} employs a general {\bfseries{convention}} that element constructors should not have any arguments. This is because elements are usually created by the {\ttfamily Mesh} constructor. To allow {\ttfamily Meshes} that were originally developed for one particular element type (e.\+g. a quadrilateral Poisson element) to be used with other elements of same geometry (e.\+g. a quadrilateral Navier-\/\+Stokes element), {\ttfamily Mesh} objects are usually templated by the element type. The {\ttfamily Mesh} constructor creates elements by calling the element\textquotesingle{}s default (argument-\/free!) constructor. If we were to set any element-\/specific arguments via arguments to the element constructor it would be impossible to re-\/use the {\ttfamily Mesh} with other element types -- Navier-\/\+Stokes elements, for instance, do not have a source function pointer. The actions performed in this loop are therefore fairly typical as most non-\/trivial elements need to be passed some additional information to become fully functional.

\\\cline{1-1}
\end{longtabu}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_actions_before}{}\doxysection{\char`\"{}\+Actions before solve\char`\"{}}\label{index_actions_before}
The pure virtual function {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve()} must be implemented for all specific {\ttfamily Problems} and, as the name suggests, should perform any actions that need to be performed before the system of equations is solved. In the current problem, we use {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve()} to update the boundary conditions in response to possible changes in the sign of the source function. We use the exact solution (specified in the namespace {\ttfamily \mbox{\hyperlink{namespaceFishSolnOneDPoisson}{Fish\+Soln\+One\+DPoisson}}}) to determine the boundary values that are appropriate for the sign specified in {\ttfamily \mbox{\hyperlink{namespaceFishSolnOneDPoisson_a108e814ef887ffcc8caa7c65a7d30f06}{Fish\+Soln\+One\+DPoisson\+::\+Sign}}}.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===start\_of\_actions\_before\_newton\_solve========================================}}
\DoxyCodeLine{\textcolor{comment}{/// Update the problem specs before solve: (Re)set boundary values}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// from the exact solution. }}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classOneDPoissonProblem_a6e42423869771fbd216326cba516a76b}{OneDPoissonProblem<ELEMENT>::actions\_before\_newton\_solve}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Assign boundary values for this problem by reading them out}}
\DoxyCodeLine{ \textcolor{comment}{// from the exact solution.}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Left boundary is node 0 in the mesh:}}
\DoxyCodeLine{ Node* left\_node\_pt=mesh\_pt()-\/>node\_pt(0);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Determine the position of the boundary node (the exact solution}}
\DoxyCodeLine{ \textcolor{comment}{// requires the coordinate in a 1D vector!)}}
\DoxyCodeLine{ Vector<double> x(1);}
\DoxyCodeLine{ x[0]=left\_node\_pt-\/>x(0);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Boundary value (read in from exact solution which returns}}
\DoxyCodeLine{ \textcolor{comment}{// the solution in a 1D vector)}}
\DoxyCodeLine{ Vector<double> u(1);}
\DoxyCodeLine{ \mbox{\hyperlink{namespaceFishSolnOneDPoisson_a52c9346f567cb68fe20268a592deb4bc}{FishSolnOneDPoisson::get\_exact\_u}}(x,u);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Assign the boundary condition to one (and only) nodal value}}
\DoxyCodeLine{ left\_node\_pt-\/>set\_value(0,u[0]);}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Right boundary is last node in the mesh:}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} last\_node=mesh\_pt()-\/>nnode()-\/1;}
\DoxyCodeLine{ Node* right\_node\_pt=mesh\_pt()-\/>node\_pt(last\_node);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Determine the position of the boundary node}}
\DoxyCodeLine{ x[0]=right\_node\_pt-\/>x(0);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Boundary value (read in from exact solution which returns}}
\DoxyCodeLine{ \textcolor{comment}{// the solution in a 1D vector)}}
\DoxyCodeLine{ \mbox{\hyperlink{namespaceFishSolnOneDPoisson_a52c9346f567cb68fe20268a592deb4bc}{FishSolnOneDPoisson::get\_exact\_u}}(x,u);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Assign the boundary condition to one (and only) nodal value}}
\DoxyCodeLine{ right\_node\_pt-\/>set\_value(0,u[0]);}
\DoxyCodeLine{}
\DoxyCodeLine{ }
\DoxyCodeLine{\} \textcolor{comment}{// end of actions before solve}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_doc}{}\doxysection{Post-\/processing}\label{index_doc}
The function {\ttfamily doc\+\_\+solution(...)} writes the FE solution and the corresponding exact solution, defined in {\ttfamily Fish\+Soln\+One\+DPoisson\+::get\+\_\+exact\+\_\+u(...)} to disk. The argument {\ttfamily label} is used to add identifiers to the output file names. Note that all output functions are implemented in the generic {\ttfamily Mesh} class\+:
\begin{DoxyItemize}
\item The function {\ttfamily Mesh\+::output(...)} executes the {\ttfamily Finite\+Element\+::output(...)} function for each element in a mesh. For 1D Poisson elements, this function writes the values of $ x $ and $ u(x) $ at {\ttfamily npts} uniformly spaced points in the element to the specified file.
\item The function {\ttfamily Mesh\+::output\+\_\+fct(...)} plots the function specified by the function pointer in its last argument at the specified number of points in each of the constituent elements. This allows point-\/by-\/point comparisons between exact and FE solutions. Here we plot the exact solution at a larger number of points to ensure that the exact solution looks smooth even if only a small number of elements are used for the discretisation of the ODE.
\end{DoxyItemize}Finally, we call the function {\ttfamily Mesh\+::compute\+\_\+error(...)} which determines the square of the L2 error, based on the difference between the exact solution (specified by a function pointer) and the FE solution. We also plot the pointwise error in the specified output file.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===start\_of\_doc=========================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Doc the solution in tecplot format. Label files with label.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classOneDPoissonProblem_aaf42d034e42e7615acfa262a9c56b638}{OneDPoissonProblem<ELEMENT>::doc\_solution}}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& label)}
\DoxyCodeLine{\{ }
\DoxyCodeLine{ \textcolor{keyword}{using namespace }StringConversion;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Number of plot points}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} npts;}
\DoxyCodeLine{ npts=5; }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Output solution with specified number of plot points per element}}
\DoxyCodeLine{ ofstream solution\_file((\textcolor{stringliteral}{"{}soln"{}} + to\_string(label) + \textcolor{stringliteral}{"{}.dat"{}}).c\_str());}
\DoxyCodeLine{ mesh\_pt()-\/>output(solution\_file,npts);}
\DoxyCodeLine{ solution\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Output exact solution at much higher resolution (so we can}}
\DoxyCodeLine{ \textcolor{comment}{// see how well the solutions agree between nodal points)}}
\DoxyCodeLine{ ofstream exact\_file((\textcolor{stringliteral}{"{}exact\_soln"{}} + to\_string(label) + \textcolor{stringliteral}{"{}.dat"{}}).c\_str());}
\DoxyCodeLine{ mesh\_pt()-\/>output\_fct(exact\_file,20*npts,\mbox{\hyperlink{namespaceFishSolnOneDPoisson_a52c9346f567cb68fe20268a592deb4bc}{FishSolnOneDPoisson::get\_exact\_u}}); }
\DoxyCodeLine{ exact\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Doc pointwise error and compute norm of error and of the solution}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} error,norm;}
\DoxyCodeLine{ ofstream error\_file((\textcolor{stringliteral}{"{}error"{}} + to\_string(label) + \textcolor{stringliteral}{"{}.dat"{}}).c\_str());}
\DoxyCodeLine{ mesh\_pt()-\/>compute\_error(error\_file,\mbox{\hyperlink{namespaceFishSolnOneDPoisson_a52c9346f567cb68fe20268a592deb4bc}{FishSolnOneDPoisson::get\_exact\_u}},}
\DoxyCodeLine{                          error,norm); }
\DoxyCodeLine{ error\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Doc error norm:}}
\DoxyCodeLine{ cout << \textcolor{stringliteral}{"{}\(\backslash\)nNorm of error    : "{}} << sqrt(error) << std::endl; }
\DoxyCodeLine{ cout << \textcolor{stringliteral}{"{}Norm of solution : "{}} << sqrt(norm) << std::endl << std::endl;}
\DoxyCodeLine{ cout << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of doc}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_exercises}{}\doxysection{Exercises}\label{index_exercises}

\begin{DoxyEnumerate}
\item Run the code with different numbers of elements. How does the error between the exact and the analytical solution change?
\item Compare the error obtained with different element types -- replace the four-\/node Poisson element, {\ttfamily QPoisson\+Element$<$1,4$>$}, by its lower-\/order counterparts {\ttfamily QPoisson\+Element$<$1,3$>$} and {\ttfamily QPoisson\+Element$<$1,2$>$}.
\item The fish-\/shaped exact solution (4) is fairly smooth. Postulate a more rapidly varying \char`\"{}exact\char`\"{} solution, such as \[ u(x) = \tanh\left[\alpha \left(x-\frac{1}{2}\right)\right] \] which produces a \char`\"{}step\char`\"{} at $ x=1/2 $ when $ \alpha $ becomes sufficiently large. Calculate the source function required for this function to be an exact solution and implement both functions in another namespace, {\ttfamily Tanh\+Soln\+One\+DPoisson}, say. Replace the reference to {\ttfamily \mbox{\hyperlink{namespaceFishSolnOneDPoisson}{Fish\+Soln\+One\+DPoisson}}} by {\ttfamily Tanh\+Soln\+One\+DPoisson} and repeat the above exercises.
\item Remove the Dirichlet boundary condition at the left end of the domain. What do you observe? \mbox{[}We shall return to this question in \href{../../../poisson/two_d_poisson_flux_bc/html/index.html}{\texttt{ another example}} where we discuss the \href{../../../poisson/two_d_poisson_flux_bc/html/index.html}{\texttt{ application of Neumann-\/type boundary conditions}}.\mbox{]}
\end{DoxyEnumerate}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/poisson/one_d_poisson/}{\texttt{ demo\+\_\+drivers/poisson/one\+\_\+d\+\_\+poisson/ }} \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/poisson/one_d_poisson/one_d_poisson.cc}{\texttt{ demo\+\_\+drivers/poisson/one\+\_\+d\+\_\+poisson/one\+\_\+d\+\_\+poisson.\+cc }} \end{center} 
\end{DoxyItemize}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{PDF file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
