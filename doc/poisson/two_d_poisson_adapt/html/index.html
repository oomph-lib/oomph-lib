<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Demo problem: How to create simple refineable meshes</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Demo problem: How to create simple refineable meshes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In a <a href="../../../poisson/fish_poisson/html/index.html">previous example</a> we gave an overview of <code>oomph-lib's</code> powerful mesh adaptation capabilities and demonstrated the use of the functions</p><ul>
<li><code>Problem::refine_uniformly()</code> which performs automatic, uniform refinement of a given (refineable) mesh.</li>
<li><code>Problem::adapt()</code> which performs automatic mesh adaptation (local refinement or unrefinement), based on error estimates that are computed (automatically) by a chosen error estimator.</li>
<li><code>Problem::newton_solve(...)</code> &ndash; a black-box adaptive Newton solver that automatically adapts the mesh and recomputes the solution until it satisfies the prescribed error bounds.</li>
</ul>
<p>Provided the problem has been discretised with suitable "refineable mesh" and "refineable element" objects from <code>oomph-lib's</code> mesh and finite element libraries, none of these functions require any intervention by the user. Most of <code>oomph-lib</code> finite elements are already available in "refineable" and "non-refineable" forms. For instance, the <code>RefineableQPoissonElement</code> that we used in the <a href="../../../poisson/fish_poisson/html/index.html">previous example</a> is the refineable equivalent of the 2D <code>QPoissonElement</code>. <a href="../../../to_be_written/html/index.html">Another document</a> describes how to create new refineable elements. Here we shall discuss how to "upgrade" existing meshes to <code>RefineableMeshes</code>, i.e. meshes that can be used with <code>oomph-lib's</code> mesh adaptation routines.</p>
<p>The minimum functionality that must be provided by such meshes is specified by the pure virtual functions in the abstract base class <code>RefineableMesh</code> and all refineable Meshes should be derived from this class. Here is a graphical representation of the typical inheritance structure for refineable meshes, illustrated for 2D quad meshes:</p>
<div class="image">
<img src="refineable_mesh_inheritance.gif" alt=""/>
<div class="caption">
Typical inheritance structure for refineable meshes, illustrated for 2D quad meshes. </div></div>
 <p>The diagram contains two fully-functional meshes:</p><ul>
<li>The <code>SomeMesh</code> is some basic, non-refineable mesh that is derived directly from the generic <code>Mesh</code> base class. Typically, it provides a coarse discretisation of a 2D domain with 2D elements from the <code>QElement</code> family. Its constructor creates the mesh's nodes and elements and initialises the various boundary lookup schemes. (Consult the <a href="../../../quick_guide/html/index.html#mesh">"How to build a mesh"</a> section of the <a href="../../../quick_guide/html/index.html">Quick Guide</a> for details of the generic mesh generation process.)</li>
<li>The <code>RefineableSomeMesh</code> is the refineable equivalent of the basic <code>SomeMesh</code>. It inherits the original mesh layout from the <code>SomeMesh</code> class. Refineability is added by inheriting from the <code>RefineableQuadMesh</code> class; this class implements the mesh adaptation procedures, specified as pure virtual functions in the <code>RefineableMesh</code> class, for 2D quad meshes, employing <code>QuadTree</code> - based refinement techniques.</li>
</ul>
<p>Equivalent inheritance structures can be/are implemented for meshes with different element topologies: For instance, the <code>RefineableBrickMesh</code> class is the 3D equivalent of the <code>RefineableQuadMesh</code> class: It performs the mesh adaptation for 3D brick meshes by <code>OcTree</code> - based refinement techniques.</p>
<p>Typically, most of the "hard work" involved in the mesh adaptation process is implemented in the intermediate classes (such as <code>RefineableQuadMesh</code> or <code>RefineableBrickMesh</code>). Upgrading an existing mesh to a refineable version therefore usually requires very little effort. We demonstrate this by re-visiting the 2D Poisson problem that we analysed in an <a href="../../../poisson/two_d_poisson/html/index.html">earlier example: </a></p>
<center> <table class="doxtable">
<tr>
<td><center> <b>Two-dimensional model Poisson problem</b> </center> Solve <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{i=1}^2 \frac{\partial^2u}{\partial x_i^2} = f(x_1,x_2), \ \ \ \ \ \ \ \ \ \ (1) \]" src="form_0.png" width="170" height="38"/>
</p>
 in the rectangular domain <img class="formulaInl" alt="$D =\left\{ (x_1,x_2) \in [0,1] \times [0,2]\right\}$" src="form_1.png" width="160" height="14"/>, with Dirichlet boundary conditions <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left. u\right|_{\partial D}=u_0 \ \ \ \ \ \ \ \ \ \ (2) \]" src="form_2.png" width="113" height="14"/>
</p>
 where <p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_0(x_1,x_2) = \tanh(1-\alpha(x_1 \tan\Phi - x_2)) \ \ \ \ \ \ \ \ \ (3) \]" src="form_3.png" width="269" height="14"/>
</p>
 and <p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(x_1,x_2) = \sum_{i=1}^2 \frac{\partial^2 u_0}{\partial x_i^2} \ \ \ \ \ \ \ \ \ (4) \]" src="form_4.png" width="166" height="38"/>
</p>
 so that <img class="formulaInl" alt="$u_0(x_1,x_2) $" src="form_5.png" width="54" height="14"/> represents the exact solution of the problem.   </td></tr>
</table>
<br  />
 </center><p>Recall that for large values of <img class="formulaInl" alt="$ \alpha $" src="form_6.png" width="8" height="6"/> the solution approaches a step function </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_{step}(x_1,x_2) = \left\{ \begin{array}{rl} -1 &amp; \mbox {for $x_2 &lt; x_1 \ \tan\Phi$} \\ 1 &amp; \mbox {for $x_2 &gt; x_1 \ \tan\Phi$} \end{array} \right. \]" src="form_7.png" width="224" height="31"/>
</p>
<p> Accurate numerical solution can therefore only be obtained if the mesh is refined &ndash; ideally only in the vicinity of the "step":</p>
<div class="image">
<img src="TanhPoissonAdaptive.gif" alt=""/>
<div class="caption">
Plot of the solution with adaptive mesh refinement </div></div>
 <p>We shall discuss the driver code <br  />
 <a href="../../../../demo_drivers/poisson/two_d_poisson_adapt/two_d_poisson_adapt.cc">two_d_poisson_adapt.cc</a> which solves the above problem with adaptive mesh refinement. Its key feature is the creation of the refineable mesh <code><a class="el" href="classSimpleRefineableRectangularQuadMesh.html" title="Refineable equivalent of the SimpleRectangularQuadMesh. Refinement is performed by the QuadTree-based...">SimpleRefineableRectangularQuadMesh</a></code> &ndash; the refineable equivalent of the <code>SimpleRectangularQuadMesh</code> used in the <br  />
 <a href="../../../poisson/two_d_poisson/html/index.html">earlier example.</a> </p><hr  />
<p> <br  />
 </p><hr  />
<h1><a class="anchor" id="refineable"></a>
Creating the refineable mesh</h1>
<p><code>QuadTree-based</code> mesh refinement, as implemented in the <code>RefineableQuadMesh</code> class, requires the coarse initial mesh to be represented by a <code>QuadTreeForest:</code> Each element in the mesh must be associated with a <code>QuadTree</code>, and the relative orientation of the various <code>QuadTrees</code> relative to each other must be established. This can be done automatically by calling the function <code>RefineableQuadMesh::setup_quadtree_forest()</code>. The <code><a class="el" href="classSimpleRefineableRectangularQuadMesh.html" title="Refineable equivalent of the SimpleRectangularQuadMesh. Refinement is performed by the QuadTree-based...">SimpleRefineableRectangularQuadMesh</a></code> class is therefore very compact. The mesh is derived from the <code>SimpleRectangularQuadMesh</code> and the <code>Refineable1QuadMesh</code> classes, both of which are templated by the element type:</p>
 <div class="fragment"><div class="line"><span class="comment">//==============================start_of_mesh======================</span></div>
<div class="line"><span class="comment">/// Refineable equivalent of the SimpleRectangularQuadMesh.</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// Refinement is performed by the QuadTree-based procedures</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// implemented in the RefineableQuadMesh base class.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classSimpleRefineableRectangularQuadMesh.html">SimpleRefineableRectangularQuadMesh</a> : </div>
<div class="line"> <span class="keyword">public</span> <span class="keyword">virtual</span> SimpleRectangularQuadMesh&lt;ELEMENT&gt;,  </div>
<div class="line"> <span class="keyword">public</span> RefineableQuadMesh&lt;ELEMENT&gt;</div>
<div class="ttc" id="aclassSimpleRefineableRectangularQuadMesh_html"><div class="ttname"><a href="classSimpleRefineableRectangularQuadMesh.html">SimpleRefineableRectangularQuadMesh</a></div><div class="ttdoc">Refineable equivalent of the SimpleRectangularQuadMesh. Refinement is performed by the QuadTree-based...</div><div class="ttdef"><b>Definition:</b> <a href="two__d__poisson__adapt_8cc_source.html#l00052">two_d_poisson_adapt.cc:55</a></div></div>
</div><!-- fragment --><p> The mesh constructor first calls the constructor of the underlying <code>SimpleRectangularQuadMesh</code> to create the nodes and elements, and to set up the various boundary lookup schemes. The call to <code>RefineableQuadMesh::setup_quadtree_forest()</code> creates the <code>QuadTreeForest</code> representation of the mesh. That's all!</p>
<div class="fragment"><div class="line"><span class="keyword">public</span>: </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> ///  Pass number of elements in the horizontal </span></div>
<div class="line"><span class="comment"> /// and vertical directions, and the corresponding dimensions.</span></div>
<div class="line"><span class="comment"> /// Timestepper defaults to Static.</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classSimpleRefineableRectangularQuadMesh.html#ae0eab85a2c97fce00d7c82a613378e79">SimpleRefineableRectangularQuadMesh</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;Nx,</div>
<div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;Ny, </div>
<div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;Lx, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;Ly,</div>
<div class="line">                                     TimeStepper* time_stepper_pt=</div>
<div class="line">                                     &amp;Mesh::Default_TimeStepper) :</div>
<div class="line">  SimpleRectangularQuadMesh&lt;ELEMENT&gt;(Nx,Ny,Lx,Ly,time_stepper_pt)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Nodal positions etc. were created in constructor for</span></div>
<div class="line">   <span class="comment">// SimpleRectangularQuadMesh&lt;...&gt; --&gt; We only need to set up </span></div>
<div class="line">   <span class="comment">// adaptivity information: Associate finite elements with their </span></div>
<div class="line">   <span class="comment">// QuadTrees and plant them in a QuadTreeForest:</span></div>
<div class="line">   this-&gt;setup_quadtree_forest();</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// end of constructor</span></div>
<div class="ttc" id="aclassSimpleRefineableRectangularQuadMesh_html_ae0eab85a2c97fce00d7c82a613378e79"><div class="ttname"><a href="classSimpleRefineableRectangularQuadMesh.html#ae0eab85a2c97fce00d7c82a613378e79">SimpleRefineableRectangularQuadMesh::SimpleRefineableRectangularQuadMesh</a></div><div class="ttdeci">SimpleRefineableRectangularQuadMesh(const unsigned &amp;Nx, const unsigned &amp;Ny, const double &amp;Lx, const double &amp;Ly, TimeStepper *time_stepper_pt=&amp;Mesh::Default_TimeStepper)</div><div class="ttdoc">Pass number of elements in the horizontal and vertical directions, and the corresponding dimensions....</div><div class="ttdef"><b>Definition:</b> <a href="two__d__poisson__adapt_8cc_source.html#l00062">two_d_poisson_adapt.cc:62</a></div></div>
</div><!-- fragment --><p> The destructor can remain empty, as all memory de-allocation is handled in the mesh base classes.</p>
<div class="fragment"><div class="line"> <span class="comment">/// Destructor: Empty</span></div>
<div class="line"> <span class="keyword">virtual</span> <a class="code" href="classSimpleRefineableRectangularQuadMesh.html#a8f258e0b5178ccb33f0596ae5a33c3c5">~SimpleRefineableRectangularQuadMesh</a>() {}</div>
<div class="ttc" id="aclassSimpleRefineableRectangularQuadMesh_html_a8f258e0b5178ccb33f0596ae5a33c3c5"><div class="ttname"><a href="classSimpleRefineableRectangularQuadMesh.html#a8f258e0b5178ccb33f0596ae5a33c3c5">SimpleRefineableRectangularQuadMesh::~SimpleRefineableRectangularQuadMesh</a></div><div class="ttdeci">virtual ~SimpleRefineableRectangularQuadMesh()</div><div class="ttdoc">Destructor: Empty.</div><div class="ttdef"><b>Definition:</b> <a href="two__d__poisson__adapt_8cc_source.html#l00079">two_d_poisson_adapt.cc:79</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="global"></a>
Global parameters and functions</h1>
<p>The specification of the source function and the exact solution in the namespace <code><a class="el" href="namespaceTanhSolnForPoisson.html" title="Namespace for exact solution for Poisson equation with &quot;sharp step&quot;.">TanhSolnForPoisson</a></code> is identical to that in the non-refineable version discussed in the <a href="../../../poisson/two_d_poisson/html/index.html">previous example</a>.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="main"></a>
The driver code</h1>
<p>The driver code is very similar to that in the <a href="../../../poisson/two_d_poisson/html/index.html">non-refineable version</a>. We simply change the mesh from the <code>SimpleRectangularQuadMesh</code> to its refineable equivalent, and discretise the problem with nine-node <code>RefineableQPoissonElements</code> instead of nine-node 2D <code>QPoissonElements</code>. We choose a large value of <img class="formulaInl" alt="$ \alpha = 50$" src="form_8.png" width="36" height="9"/> for the "steepness" parameter and solve the problem with the "black-box" Newton solver, allowing for up to four adaptive refinements:</p>
 <div class="fragment"><div class="line"><span class="comment">//===== start_of_main=====================================================</span></div>
<div class="line"><span class="comment">/// Driver code for 2D Poisson problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="two__d__poisson__adapt_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Set up the problem</span></div>
<div class="line"> <span class="comment">//------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create the problem with 2D nine-node refineable elements from the</span></div>
<div class="line"> <span class="comment">// RefineableQuadPoissonElement family. Pass pointer to source function. </span></div>
<div class="line"> <a class="code" href="classRefineablePoissonProblem.html">RefineablePoissonProblem&lt;RefineableQPoissonElement&lt;2,3&gt;</a> &gt; </div>
<div class="line">  problem(&amp;<a class="code" href="namespaceTanhSolnForPoisson.html#ae1b9d6789ff301e3d63a4e292213036c">TanhSolnForPoisson::get_source</a>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create label for output</span></div>
<div class="line"> <span class="comment">//------------------------</span></div>
<div class="line"> DocInfo doc_info;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set output directory</span></div>
<div class="line"> doc_info.set_directory(<span class="stringliteral">&quot;RESLT&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Step number</span></div>
<div class="line"> doc_info.number()=0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Check if we&#39;re ready to go:</span></div>
<div class="line"> <span class="comment">//----------------------------</span></div>
<div class="line"> cout &lt;&lt; <span class="stringliteral">&quot;\n\n\nProblem self-test &quot;</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (problem.self_test()==0) </div>
<div class="line">  {</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;passed: Problem can be solved.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> <span class="keywordflow">else</span> </div>
<div class="line">  {</div>
<div class="line">   <span class="keywordflow">throw</span> OomphLibError(<span class="stringliteral">&quot;Self test failed&quot;</span>,</div>
<div class="line">                       OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                       OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set the orientation of the &quot;step&quot; to 45 degrees</span></div>
<div class="line"> <a class="code" href="namespaceTanhSolnForPoisson.html#a785ccd00a727125a5138fbbcac173294">TanhSolnForPoisson::TanPhi</a>=1.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Choose a large value for the steepness of the &quot;step&quot;</span></div>
<div class="line"> <a class="code" href="namespaceTanhSolnForPoisson.html#ae676ccd186d5df119cce811596d949c1">TanhSolnForPoisson::Alpha</a>=50.0; </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Solve the problem, performing up to 4 adaptive refinements</span></div>
<div class="line"> problem.newton_solve(4);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Output the solution</span></div>
<div class="line"> problem.doc_solution(doc_info);</div>
<div class="line"> </div>
<div class="line">} <span class="comment">//end of main</span></div>
<div class="ttc" id="aclassRefineablePoissonProblem_html"><div class="ttname"><a href="classRefineablePoissonProblem.html">RefineablePoissonProblem</a></div><div class="ttdoc">2D Poisson problem on rectangular domain, discretised with refineable 2D QPoisson elements....</div><div class="ttdef"><b>Definition:</b> <a href="two__d__poisson__adapt_8cc_source.html#l00127">two_d_poisson_adapt.cc:128</a></div></div>
<div class="ttc" id="anamespaceTanhSolnForPoisson_html_a785ccd00a727125a5138fbbcac173294"><div class="ttname"><a href="namespaceTanhSolnForPoisson.html#a785ccd00a727125a5138fbbcac173294">TanhSolnForPoisson::TanPhi</a></div><div class="ttdeci">double TanPhi</div><div class="ttdoc">Parameter for angle Phi of &quot;step&quot;.</div><div class="ttdef"><b>Definition:</b> <a href="two__d__poisson__adapt_8cc_source.html#l00095">two_d_poisson_adapt.cc:95</a></div></div>
<div class="ttc" id="anamespaceTanhSolnForPoisson_html_ae1b9d6789ff301e3d63a4e292213036c"><div class="ttname"><a href="namespaceTanhSolnForPoisson.html#ae1b9d6789ff301e3d63a4e292213036c">TanhSolnForPoisson::get_source</a></div><div class="ttdeci">void get_source(const Vector&lt; double &gt; &amp;x, double &amp;source)</div><div class="ttdoc">Source function required to make the solution above an exact solution.</div><div class="ttdef"><b>Definition:</b> <a href="two__d__poisson__adapt_8cc_source.html#l00104">two_d_poisson_adapt.cc:104</a></div></div>
<div class="ttc" id="anamespaceTanhSolnForPoisson_html_ae676ccd186d5df119cce811596d949c1"><div class="ttname"><a href="namespaceTanhSolnForPoisson.html#ae676ccd186d5df119cce811596d949c1">TanhSolnForPoisson::Alpha</a></div><div class="ttdeci">double Alpha</div><div class="ttdoc">Parameter for steepness of &quot;step&quot;.</div><div class="ttdef"><b>Definition:</b> <a href="two__d__poisson__adapt_8cc_source.html#l00092">two_d_poisson_adapt.cc:92</a></div></div>
<div class="ttc" id="atwo__d__poisson__adapt_8cc_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="two__d__poisson__adapt_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdoc">Driver code for 2D Poisson problem.</div><div class="ttdef"><b>Definition:</b> <a href="two__d__poisson__adapt_8cc_source.html#l00329">two_d_poisson_adapt.cc:329</a></div></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="problem"></a>
The problem class</h1>
<p>The problem class definition is virtually identical to that in the <a href="../../../poisson/two_d_poisson/html/index.html">non-refineable version</a>. The only new function is an overloaded version of the <code>Problem::mesh_pt()</code> function which returns a pointer to the generic <code>Mesh</code> object. Our version returns a pointer to the specific mesh, to avoid the use of explicit casts in the rest of the code.</p>
 <div class="fragment"><div class="line"><span class="comment">//====== start_of_problem_class=======================================</span></div>
<div class="line"><span class="comment">/// 2D Poisson problem on rectangular domain, discretised with</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// refineable 2D QPoisson elements. The specific type of element is</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// specified via the template parameter.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt; </div>
<div class="line"><span class="keyword">class </span><a class="code" href="classRefineablePoissonProblem.html">RefineablePoissonProblem</a> : <span class="keyword">public</span> Problem</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Constructor: Pass pointer to source function</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classRefineablePoissonProblem.html#a019ec586c38163e04e177de92503c02f">RefineablePoissonProblem</a>(PoissonEquations&lt;2&gt;::PoissonSourceFctPt </div>
<div class="line">                          source_fct_pt);</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Destructor (empty)</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classRefineablePoissonProblem.html#a84980680d8a6576e14af42a8639d391a">~RefineablePoissonProblem</a>(){}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Update the problem specs before solve: Reset boundary conditions</span></div>
<div class="line"><span class="comment"> /// to the values from the exact solution.</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classRefineablePoissonProblem.html#a883906ab6c06ffa10ed55dc4fc02ce96">actions_before_newton_solve</a>();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Update the problem after solve (empty)</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classRefineablePoissonProblem.html#ac4d433dad09bce5bd9be21e86d347e38">actions_after_newton_solve</a>(){}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Doc the solution. DocInfo object stores flags/labels for where the</span></div>
<div class="line"><span class="comment"> /// output gets written to</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classRefineablePoissonProblem.html#aaf9482084473a6ca2bd0de24acae08e9">doc_solution</a>(DocInfo&amp; doc_info);</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Overloaded version of the Problem&#39;s access function to </span></div>
<div class="line"><span class="comment"> /// the mesh. Recasts the pointer to the base Mesh object to </span></div>
<div class="line"><span class="comment"> /// the actual mesh type.</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classSimpleRefineableRectangularQuadMesh.html">SimpleRefineableRectangularQuadMesh&lt;ELEMENT&gt;</a>* <a class="code" href="classRefineablePoissonProblem.html#ad8148aada59e279cbd9eb34272b65fa5">mesh_pt</a>() </div>
<div class="line">  {</div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classSimpleRefineableRectangularQuadMesh.html">SimpleRefineableRectangularQuadMesh&lt;ELEMENT&gt;</a>*<span class="keyword">&gt;</span>(</div>
<div class="line">    Problem::mesh_pt());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to source function</span></div>
<div class="line"><span class="comment"></span> PoissonEquations&lt;2&gt;::PoissonSourceFctPt <a class="code" href="classRefineablePoissonProblem.html#abaf852221a8673550f96bbb507d6b05a">Source_fct_pt</a>;</div>
<div class="line"> </div>
<div class="line">}; <span class="comment">// end of problem class</span></div>
<div class="ttc" id="aclassRefineablePoissonProblem_html_a019ec586c38163e04e177de92503c02f"><div class="ttname"><a href="classRefineablePoissonProblem.html#a019ec586c38163e04e177de92503c02f">RefineablePoissonProblem::RefineablePoissonProblem</a></div><div class="ttdeci">RefineablePoissonProblem(PoissonEquations&lt; 2 &gt;::PoissonSourceFctPt source_fct_pt)</div><div class="ttdoc">Constructor: Pass pointer to source function.</div><div class="ttdef"><b>Definition:</b> <a href="two__d__poisson__adapt_8cc_source.html#l00173">two_d_poisson_adapt.cc:174</a></div></div>
<div class="ttc" id="aclassRefineablePoissonProblem_html_a84980680d8a6576e14af42a8639d391a"><div class="ttname"><a href="classRefineablePoissonProblem.html#a84980680d8a6576e14af42a8639d391a">RefineablePoissonProblem::~RefineablePoissonProblem</a></div><div class="ttdeci">~RefineablePoissonProblem()</div><div class="ttdoc">Destructor (empty)</div><div class="ttdef"><b>Definition:</b> <a href="two__d__poisson__adapt_8cc_source.html#l00137">two_d_poisson_adapt.cc:137</a></div></div>
<div class="ttc" id="aclassRefineablePoissonProblem_html_a883906ab6c06ffa10ed55dc4fc02ce96"><div class="ttname"><a href="classRefineablePoissonProblem.html#a883906ab6c06ffa10ed55dc4fc02ce96">RefineablePoissonProblem::actions_before_newton_solve</a></div><div class="ttdeci">void actions_before_newton_solve()</div><div class="ttdoc">Update the problem specs before solve: Reset boundary conditions to the values from the exact solutio...</div><div class="ttdef"><b>Definition:</b> <a href="two__d__poisson__adapt_8cc_source.html#l00241">two_d_poisson_adapt.cc:241</a></div></div>
<div class="ttc" id="aclassRefineablePoissonProblem_html_aaf9482084473a6ca2bd0de24acae08e9"><div class="ttname"><a href="classRefineablePoissonProblem.html#aaf9482084473a6ca2bd0de24acae08e9">RefineablePoissonProblem::doc_solution</a></div><div class="ttdeci">void doc_solution(DocInfo &amp;doc_info)</div><div class="ttdoc">Doc the solution. DocInfo object stores flags/labels for where the output gets written to.</div><div class="ttdef"><b>Definition:</b> <a href="two__d__poisson__adapt_8cc_source.html#l00279">two_d_poisson_adapt.cc:279</a></div></div>
<div class="ttc" id="aclassRefineablePoissonProblem_html_abaf852221a8673550f96bbb507d6b05a"><div class="ttname"><a href="classRefineablePoissonProblem.html#abaf852221a8673550f96bbb507d6b05a">RefineablePoissonProblem::Source_fct_pt</a></div><div class="ttdeci">PoissonEquations&lt; 2 &gt;::PoissonSourceFctPt Source_fct_pt</div><div class="ttdoc">Pointer to source function.</div><div class="ttdef"><b>Definition:</b> <a href="two__d__poisson__adapt_8cc_source.html#l00162">two_d_poisson_adapt.cc:162</a></div></div>
<div class="ttc" id="aclassRefineablePoissonProblem_html_ac4d433dad09bce5bd9be21e86d347e38"><div class="ttname"><a href="classRefineablePoissonProblem.html#ac4d433dad09bce5bd9be21e86d347e38">RefineablePoissonProblem::actions_after_newton_solve</a></div><div class="ttdeci">void actions_after_newton_solve()</div><div class="ttdoc">Update the problem after solve (empty)</div><div class="ttdef"><b>Definition:</b> <a href="two__d__poisson__adapt_8cc_source.html#l00144">two_d_poisson_adapt.cc:144</a></div></div>
<div class="ttc" id="aclassRefineablePoissonProblem_html_ad8148aada59e279cbd9eb34272b65fa5"><div class="ttname"><a href="classRefineablePoissonProblem.html#ad8148aada59e279cbd9eb34272b65fa5">RefineablePoissonProblem::mesh_pt</a></div><div class="ttdeci">SimpleRefineableRectangularQuadMesh&lt; ELEMENT &gt; * mesh_pt()</div><div class="ttdoc">Overloaded version of the Problem's access function to the mesh. Recasts the pointer to the base Mesh...</div><div class="ttdef"><b>Definition:</b> <a href="two__d__poisson__adapt_8cc_source.html#l00153">two_d_poisson_adapt.cc:153</a></div></div>
</div><!-- fragment --><p> [See the discussion of the <a href="../../one_d_poisson/html/index.html">1D Poisson problem</a> for a more detailed discussion of the function type PoissonEquations&lt;2&gt;::PoissonSourceFctPt.]</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="constructor"></a>
The Problem constructor</h1>
<p>The problem constructor is virtually identical to that in the <a href="../../../poisson/two_d_poisson/html/index.html">non-refineable version</a>. The only change required is the specification of an error estimator for the mesh adaptations: We create an instance of the <code>Z2ErrorEstimator</code> and pass a pointer to it to the mesh.</p>
<div class="fragment"><div class="line"><span class="comment">//=====start_of_constructor===============================================</span></div>
<div class="line"><span class="comment">/// Constructor for Poisson problem: Pass pointer to source function.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><a class="code" href="classRefineablePoissonProblem.html#a019ec586c38163e04e177de92503c02f">RefineablePoissonProblem&lt;ELEMENT&gt;::</a></div>
<div class="line"><a class="code" href="classRefineablePoissonProblem.html#a019ec586c38163e04e177de92503c02f">      RefineablePoissonProblem</a>(PoissonEquations&lt;2&gt;::PoissonSourceFctPt </div>
<div class="line">                               source_fct_pt)</div>
<div class="line">       :  Source_fct_pt(source_fct_pt)</div>
<div class="line">{ </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Setup mesh</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// # of elements in x-direction</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_x=4;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// # of elements in y-direction</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_y=4;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Domain length in x-direction</span></div>
<div class="line"> <span class="keywordtype">double</span> l_x=1.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Domain length in y-direction</span></div>
<div class="line"> <span class="keywordtype">double</span> l_y=2.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build and assign mesh</span></div>
<div class="line"> Problem::mesh_pt() = </div>
<div class="line">  <span class="keyword">new</span> <a class="code" href="classSimpleRefineableRectangularQuadMesh.html">SimpleRefineableRectangularQuadMesh&lt;ELEMENT&gt;</a>(n_x,n_y,l_x,l_y);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create/set error estimator</span></div>
<div class="line"> mesh_pt()-&gt;spatial_error_estimator_pt()=<span class="keyword">new</span> Z2ErrorEstimator;</div>
<div class="line">  </div>
<div class="line"> <span class="comment">// Set the boundary conditions for this problem: All nodes are</span></div>
<div class="line"> <span class="comment">// free by default -- only need to pin the ones that have Dirichlet conditions</span></div>
<div class="line"> <span class="comment">// here. </span></div>
<div class="line"> <span class="keywordtype">unsigned</span> num_bound = mesh_pt()-&gt;nboundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibound=0;ibound&lt;num_bound;ibound++)</div>
<div class="line">  {</div>
<div class="line">   <span class="keywordtype">unsigned</span> num_nod= mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">    {</div>
<div class="line">     mesh_pt()-&gt;boundary_node_pt(ibound,inod)-&gt;pin(0); </div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Complete the build of all elements so they are fully functional</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over the elements to set up element-specific </span></div>
<div class="line"> <span class="comment">// things that cannot be handled by the (argument-free!) ELEMENT </span></div>
<div class="line"> <span class="comment">// constructor: Pass pointer to source function</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_element = mesh_pt()-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_element;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from GeneralsedElement to the present element</span></div>
<div class="line">   ELEMENT *el_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(mesh_pt()-&gt;element_pt(i));</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Set the source function pointer</span></div>
<div class="line">   el_pt-&gt;source_fct_pt() = Source_fct_pt;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Setup equation numbering scheme</span></div>
<div class="line"> cout &lt;&lt;<span class="stringliteral">&quot;Number of equations: &quot;</span> &lt;&lt; assign_eqn_numbers() &lt;&lt; std::endl; </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of constructor</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="actions_before"></a>
"Actions before solve"</h1>
<p>This function is identical to that in the <a href="../../../poisson/two_d_poisson/html/index.html">non-refineable version</a>.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="doc"></a>
Post-processing</h1>
<p>The function <code>doc_solution(...)</code> is identical to that in the <a href="../../../poisson/two_d_poisson/html/index.html">non-refineable version</a>.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="exercises"></a>
Comments</h1>
<p>Since most of the "hard work" involved in the mesh adaptation is hidden from "user" we briefly comment on various steps involved in the mesh adaptation process and highlight certain important implications.</p>
<h2><a class="anchor" id="splitting"></a>
The refinement pattern</h2>
<p>The <code>QuadTree</code> - based mesh adaption routines, implemented in the <code>RefineableQuadMesh</code> class, split elements into four "son elements" if the error estimate exceeds the acceptable maximum. By default, the position of any newly created nodes is determined from the geometric mapping of the "father" element. For instance, when a four-node quad "father" element is split into four "sons", five new nodes are created and they are located at <img class="formulaInl" alt="$ (s_0,s_1) = (0,-1), \ (1,0), \ (0,1), \ (-1,0) $" src="form_9.png" width="213" height="14"/> and <img class="formulaInl" alt="$ (0,0)$" src="form_10.png" width="26" height="14"/> in the father element's local coordinate system. This procedure is adequate for problems in which the coarse initial mesh provides a perfect representation of the domain (e.g. polygonal domains). If the domain has curvilinear boundaries, successive mesh refinements must generate a more and more accurate representation of these boundaries. This requires slight changes to the mesh adaptation procedures. We will discuss these in <a href="../../../poisson/fish_poisson2/html/index.html">another example</a>.</p>
<p>The splitting of "father" elements into four equal-sized "sons" maintains the aspect ratio of the elements during the mesh adaptation. The good news is that mesh adaption will not cause a deterioration in the element quality. The bad news is that poorly designed coarse meshes cannot be improved by mesh adaptation. It is therefore worthwhile to invest some time into the initial mesh design. For complicated domains, it may be sensible to perform the initial mesh generation with a dedicated, third-party mesh generator. (We provide <a href="../../../meshes/third_party_meshes/html/index.html">another example</a> to illustrate how to build <code>oomph-lib</code> meshes based on the output from a third-party mesh generator.)</p>
<h2><a class="anchor" id="hang"></a>
Hanging nodes</h2>
<p>The local splitting of elements can create so-called "hanging
nodes" &ndash; nodes on element edges that are not shared by any adjacent elements. The nodal values and coordinates at such nodes must be constrained to ensure the inter-element continuity of the solution. Specifically, the nodal values and coordinates at hanging nodes must be suitable linear combinations of the values at a number of "master nodes". (In the first instance, the master nodes are the nodes on the adjacent element's edge that <em>are</em> shared by adjacent elements. If there are multiple levels of refinement, such nodes can themselves be hanging; the ultimate set of master nodes is therefore be determined recursively.)</p>
<p>The setup of the hanging node constraints is handled automatically by the mesh adaptation routines and the technical details are therefore of little relevance to the general user. (The <a href="../../../the_data_structure/html/index.html">"bottom up" discussion of the data structure</a> provides details if you are interested.) One aspect of the way in which hanging nodes are handled in <code>oomph-lib</code> is important, however. Up to now we have accessed nodal values either via the function</p>
<div class="fragment"><div class="line">Node::set_value(...)</div>
</div><!-- fragment --><p>which sets the values stored at a <code>Node</code>, or the pointer-based access function</p>
<div class="fragment"><div class="line">Node::value_pt(...)</div>
</div><!-- fragment --><p>which returns a pointer to these values.</p>
<p>What happens when a node is hanging, i.e. if <code>Node::is_hanging()</code> returns <code>true</code>?</p>
<table class="doxtable">
<tr>
<td bgcolor="cornsilk"><center><b>A convention</b></center><p> The functions</p>
<div class="fragment"><div class="line">Node::set_value(...)</div>
</div><!-- fragment --><p class="intertd">and</p>
<div class="fragment"><div class="line">Node::value_pt(...)</div>
</div><!-- fragment --><p class="intertd">always refer to the nodal values stored at the <code>Node</code> itself.</p>
<p class="intertd"><b>Important:</b> If a node is hanging, the value pointed to by <code>Node::value_pt(...)</code> is <b>not</b> kept up to date!</p>
<p class="intertd">The correctly constrained nodal value must be computed "on the fly", using the list of master nodes and their respective weights, stored in the node's <code>HangingInfo</code> object. This is done automatically by the function</p>
<div class="fragment"><div class="line">Node::value(...)</div>
</div><!-- fragment --><p class="intertd">which returns the appropriate value for hanging <em>and</em> non-hanging nodes: For non-hanging nodes it returns the value pointed to by <code>Node::value_pt(...)</code>; for hanging nodes, it computes the correctly constrained values. When developing new elements or writing new post-processing routines, the user should therefore always refer to nodal values with the <code>Node::value(...)</code> function to ensure that the code works correctly in the presence of hanging nodes.</p>
<p class="intertd">We provide equivalent functions to access the nodal positions: The function</p>
<div class="fragment"><div class="line">Node::x(...)</div>
</div><!-- fragment --><p class="intertd">returns the values of (Eulerian) coordinates stored at the node. These values can be out of date if the node is hanging. The function</p>
<div class="fragment"><div class="line">Node::position(...)</div>
</div><!-- fragment --><p class="intertd">should be used to determine a node's Eulerian position &ndash; this function is the equivalent of <code>Node::value(...)</code> and determines the nodal coordinates of hanging nodes "on the fly", using the node's list of master nodes and weights.</p>
<p class="intertd">Finally, we note that while the nodal values and coordinates stored at a node might be out of date <em>while</em> a node is hanging, the values are automatically assigned up-to-date values when subsequent mesh adaptations change a node's status from hanging to non-hanging.</p>
<p class="endtd"></p>
</td></tr>
</table>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory: <center> <a href="../../../../demo_drivers/poisson/two_d_poisson_adapt/">demo_drivers/poisson/two_d_poisson_adapt/ </a> </center></li>
<li>The driver code is: <center> <a href="../../../../demo_drivers/poisson/two_d_poisson_adapt/two_d_poisson_adapt.cc">demo_drivers/poisson/two_d_poisson_adapt/two_d_poisson_adapt.cc </a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Fri Dec 29 2023 07:57:48
        </div>
      </div>
    </footer>
</body>
</html>
