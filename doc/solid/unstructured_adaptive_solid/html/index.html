<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Demo problem: Solid Mechanics using unstructured meshes with adaptivity</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Demo problem: Solid Mechanics using unstructured meshes with adaptivity </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The purpose of this tutorial is to demonstrate the adaptive solution of solid mechanics problems using unstructured meshes generated by <code>oomph-lib's</code> <a href="../../../../doc/meshes/mesh_from_inline_triangle/html/index.html">inline unstructured mesh generation </a> procedures. The use of these methods for solid mechanics problems required no additional effort on the part of the user and the setup is essentially the same as that described for <a href="../../unstructured_solid/html/index.html">unstructured solid mechanics without mesh adaptation. </a> Lagrangian coordinates are projected between meshes in the same way as all other field variables, Eulerian coordinates and history values, see the description in <a href="../../../meshes/mesh_from_inline_triangle/html/index.html">another tutorial. </a></p>
<p>The solid mechanics problem described here can be regarded as a sub-problem for the <br  />
 <a href="../../../../doc/interaction/unstructured_adaptive_fsi/html/index.html">unstructured adaptive fluid&ndash;structure interaction tutorial.</a> In addition, we can use the problem to assess the errors incurred when projecting the solution between different meshes.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="problem"></a>
The problem</h1>
<p>An elastic bar is fixed at the base and loaded by a constant pressure on its left-hand side. The pressure load is increased and then decreased so that at the end of the simulation the bar should return to its undeformed position. The strain energy in the final configuration is a measure of the projection error because if there were no projection at all it would be exactly zero (or certainly zero to less than machine precision).</p>
<div class="image">
<img src="solid_sketch.gif" alt=""/>
<div class="caption">
Sketch of the problem. </div></div>
 <hr  />
 <hr  />
<h1><a class="anchor" id="results"></a>
Results</h1>
<p>The animation shown below illustrates the solid's deformation and illustrates the adaptation of the mesh as the load changes.</p>
<div class="image">
<img src="solid_res.gif" alt=""/>
<div class="caption">
Plot of the deformation. </div></div>
 <p>The initial strain energy is <img class="formulaInl" alt="$ O(10^{-28}) $" src="form_0.png" width="49" height="15"/>, and the strain energy in the final configuration after the external pressure has been reset to zero, but the mesh has been adapted, is <img class="formulaInl" alt="$ O(10^{-8}) $" src="form_1.png" width="44" height="15"/>. The strain energy at the maximum deflection is <img class="formulaInl" alt="$ O(10^{-3}) $" src="form_2.png" width="44" height="15"/>.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="namespace"></a>
Global Physical Variables</h1>
<p>We define the various physical variables in a global namespace. We define Poisson's ratio and prepare a pointer to a constitutive equation.</p>
 <div class="fragment"><div class="line"><span class="comment">//=======start_namespace==========================================</span></div>
<div class="line"><span class="comment">/// Global variables</span></div>
<div class="line"><span class="comment"></span><span class="comment">//================================================================</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceGlobal__Physical__Variables.html">Global_Physical_Variables</a></div>
<div class="line">{<span class="comment"></span></div>
<div class="line"><span class="comment"> /// Poisson&#39;s ratio</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#a3962c36313826b19f216f6bbbdd6a477">Nu</a>=0.3;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to constitutive law</span></div>
<div class="line"><span class="comment"></span> ConstitutiveLaw* <a class="code" href="namespaceGlobal__Physical__Variables.html#a2a37fb040c832ee7a086bb13bb02a100">Constitutive_law_pt</a>=0;</div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html">Global_Physical_Variables</a></div><div class="ttdoc">//////////////////////////////////////////////////////////////////// ////////////////////////////////...</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00051">unstructured_adaptive_solid.cc:52</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a2a37fb040c832ee7a086bb13bb02a100"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a2a37fb040c832ee7a086bb13bb02a100">Global_Physical_Variables::Constitutive_law_pt</a></div><div class="ttdeci">ConstitutiveLaw * Constitutive_law_pt</div><div class="ttdoc">Pointer to constitutive law.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00057">unstructured_adaptive_solid.cc:57</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a3962c36313826b19f216f6bbbdd6a477"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a3962c36313826b19f216f6bbbdd6a477">Global_Physical_Variables::Nu</a></div><div class="ttdeci">double Nu</div><div class="ttdoc">Poisson's ratio.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00054">unstructured_adaptive_solid.cc:54</a></div></div>
</div><!-- fragment --><p> Next we define the pressure load to be applied at the left-hand boundary,</p>
<div class="fragment"><div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Uniform pressure</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#a23c2ade6398f54040b869f7f3a2bcc4b">P</a> = 0.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Constant pressure load. The arguments to this function are imposed</span></div>
<div class="line"><span class="comment"> /// on us by the SolidTractionElements which allow the traction to </span></div>
<div class="line"><span class="comment"> /// depend on the Lagrangian and Eulerian coordinates x and xi, and on the </span></div>
<div class="line"><span class="comment"> /// outer unit normal to the surface. Here we only need the outer unit</span></div>
<div class="line"><span class="comment"> /// normal.</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#a19f4e20a92e7d216b4d2b00308f96917">constant_pressure</a>(<span class="keyword">const</span> Vector&lt;double&gt; &amp;xi, <span class="keyword">const</span> Vector&lt;double&gt; &amp;x,</div>
<div class="line">                        <span class="keyword">const</span> Vector&lt;double&gt; &amp;n, Vector&lt;double&gt; &amp;traction)</div>
<div class="line"> {</div>
<div class="line">  <span class="keywordtype">unsigned</span> dim = traction.size();</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;dim;i++)</div>
<div class="line">   {</div>
<div class="line">    traction[i] = -<a class="code" href="namespaceGlobal__Physical__Variables.html#a23c2ade6398f54040b869f7f3a2bcc4b">P</a>*n[i];</div>
<div class="line">   }</div>
<div class="line"> } </div>
<div class="line"> </div>
<div class="line">} <span class="comment">//end namespace</span></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a19f4e20a92e7d216b4d2b00308f96917"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a19f4e20a92e7d216b4d2b00308f96917">Global_Physical_Variables::constant_pressure</a></div><div class="ttdeci">void constant_pressure(const Vector&lt; double &gt; &amp;xi, const Vector&lt; double &gt; &amp;x, const Vector&lt; double &gt; &amp;n, Vector&lt; double &gt; &amp;traction)</div><div class="ttdoc">Constant pressure load. The arguments to this function are imposed on us by the SolidTractionElements...</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00067">unstructured_adaptive_solid.cc:67</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a23c2ade6398f54040b869f7f3a2bcc4b"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a23c2ade6398f54040b869f7f3a2bcc4b">Global_Physical_Variables::P</a></div><div class="ttdeci">double P</div><div class="ttdoc">Uniform pressure.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00060">unstructured_adaptive_solid.cc:60</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="main"></a>
The driver code</h1>
<p>The driver code consists of essentially the same code repeated for three different formulations of solid mechanics: (i) (compressible) displacement only; (ii) (compressible) displacement-pressure; and (iii) incompressible displacement-pressure. We shall describe the code only for the first formulation.</p>
<p>Initially, we specify an output directory and instantiate a constitutive equation. (Recall that the single-argument constructor to the <code>GeneralisedHookean</code> constitutive law implies that all stresses are non-dimensionalised on Young's modulus <img class="formulaInl" alt="$ E $" src="form_3.png" width="10" height="9"/>).</p>
 <div class="fragment"><div class="line"><span class="comment">//===========start_main===================================================</span></div>
<div class="line"><span class="comment">/// Demonstrate how to solve an unstructured solid problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="unstructured__adaptive__solid_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Doc info object</span></div>
<div class="line"> DocInfo doc_info;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output directory</span></div>
<div class="line"> doc_info.set_directory(<span class="stringliteral">&quot;RESLT&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create generalised Hookean constitutive equations</span></div>
<div class="line"> <a class="code" href="namespaceGlobal__Physical__Variables.html#a2a37fb040c832ee7a086bb13bb02a100">Global_Physical_Variables::Constitutive_law_pt</a> = </div>
<div class="line">  <span class="keyword">new</span> GeneralisedHookean(&amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a3962c36313826b19f216f6bbbdd6a477">Global_Physical_Variables::Nu</a>);</div>
<div class="ttc" id="aunstructured__adaptive__solid_8cc_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="unstructured__adaptive__solid_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdoc">Demonstrate how to solve an unstructured solid problem.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00419">unstructured_adaptive_solid.cc:419</a></div></div>
</div><!-- fragment --><p> We then open an output file for the strain energy, create the <code>Problem</code> object using a displacement formulation of the equations and output the initial configuration.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> {</div>
<div class="line">  std::ofstream strain(<span class="stringliteral">&quot;RESLT/s_energy.dat&quot;</span>);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Running with pure displacement formulation\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Set up the problem</span></div>
<div class="line">  <a class="code" href="classUnstructuredSolidProblem.html">UnstructuredSolidProblem&lt;ProjectablePVDElement&lt;TPVDElement&lt;2,3&gt;</a> &gt; &gt; problem;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">//Output initial configuration</span></div>
<div class="line">  problem.<a class="code" href="classUnstructuredSolidProblem.html#ab3d66fd61b69d12b4f159d763fc44f15">doc_solution</a>(doc_info);</div>
<div class="line">  doc_info.number()++;</div>
<div class="ttc" id="aclassUnstructuredSolidProblem_html"><div class="ttname"><a href="classUnstructuredSolidProblem.html">UnstructuredSolidProblem</a></div><div class="ttdoc">Unstructured solid problem.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00085">unstructured_adaptive_solid.cc:86</a></div></div>
<div class="ttc" id="aclassUnstructuredSolidProblem_html_ab3d66fd61b69d12b4f159d763fc44f15"><div class="ttname"><a href="classUnstructuredSolidProblem.html#ab3d66fd61b69d12b4f159d763fc44f15">UnstructuredSolidProblem::doc_solution</a></div><div class="ttdeci">void doc_solution(DocInfo &amp;doc_info)</div><div class="ttdoc">Doc the solution.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00270">unstructured_adaptive_solid.cc:270</a></div></div>
</div><!-- fragment --><p> Finally, we perform the parameter study by slowly increasing and then reducing the pressure on the left-hand boundary. Note that one round of mesh adaptation is specified for every Newton solve.</p>
<div class="fragment"><div class="line">  </div>
<div class="line">  <span class="comment">// Parameter study</span></div>
<div class="line">  <a class="code" href="namespaceGlobal__Physical__Variables.html#a23c2ade6398f54040b869f7f3a2bcc4b">Global_Physical_Variables::P</a>=0.0;</div>
<div class="line">  <span class="keywordtype">double</span> pressure_increment=0.1e-2;</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">unsigned</span> nstep=5;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> istep=0;istep&lt;nstep;istep++)</div>
<div class="line">   {</div>
<div class="line">    <span class="comment">// Solve the problem with one round of adaptivity</span></div>
<div class="line">    problem.newton_solve(1);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> strain_energy = problem.<a class="code" href="classUnstructuredSolidProblem.html#a4da918a1f0cf94ebccc5112b58c28ece">get_strain_energy</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Strain energy is &quot;</span> &lt;&lt; strain_energy &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    <span class="comment">//Output strain energy to file</span></div>
<div class="line">    strain &lt;&lt; <a class="code" href="namespaceGlobal__Physical__Variables.html#a23c2ade6398f54040b869f7f3a2bcc4b">Global_Physical_Variables::P</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; strain_energy &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Output solution</span></div>
<div class="line">    problem.<a class="code" href="classUnstructuredSolidProblem.html#ab3d66fd61b69d12b4f159d763fc44f15">doc_solution</a>(doc_info);</div>
<div class="line">    doc_info.number()++;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">//Reverse direction of increment </span></div>
<div class="line">    <span class="keywordflow">if</span>(istep==2) {pressure_increment *= -1.0;}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Increase (or decrease) load</span></div>
<div class="line">    <a class="code" href="namespaceGlobal__Physical__Variables.html#a23c2ade6398f54040b869f7f3a2bcc4b">Global_Physical_Variables::P</a>+=pressure_increment;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">  strain.close();</div>
<div class="line"> } <span class="comment">//end_displacement_formulation</span></div>
<div class="ttc" id="aclassUnstructuredSolidProblem_html_a4da918a1f0cf94ebccc5112b58c28ece"><div class="ttname"><a href="classUnstructuredSolidProblem.html#a4da918a1f0cf94ebccc5112b58c28ece">UnstructuredSolidProblem::get_strain_energy</a></div><div class="ttdeci">double get_strain_energy()</div><div class="ttdoc">Calculate the strain energy.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00309">unstructured_adaptive_solid.cc:309</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="class"></a>
The Problem class</h1>
<p>The <code>Problem</code> class has the obvious member functions as well as a function to set whether the material is incompressible and a function to compute the strain energy of the elastic body. The class provides storage for the two sub-meshes: the bulk mesh of 2D solid elements and the mesh of 1D traction elements that will be attached to the left-hand boundary. In addition, storage is provided for the polygon that represents the initial outer boundary of the solid body and a boolean flag that is used to specify whether the material is incompressible or not.</p>
 <div class="fragment"><div class="line"><span class="comment">//==============start_problem=========================================</span></div>
<div class="line"><span class="comment">/// Unstructured solid problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt; </div>
<div class="line"><span class="keyword">class </span><a class="code" href="classUnstructuredSolidProblem.html">UnstructuredSolidProblem</a> : <span class="keyword">public</span> Problem</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Constructor: </span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classUnstructuredSolidProblem.html#a18ce02b6e4bbc86403c9e1b32c095772">UnstructuredSolidProblem</a>();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Destructor (empty)</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classUnstructuredSolidProblem.html#a25fe105d949498bf8f7c15aff96a7d00">~UnstructuredSolidProblem</a>(){}</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Set the problem to be incompressible</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classUnstructuredSolidProblem.html#a9b725d83bc051b594d080a40d6d317d3">set_incompressible</a>() {<a class="code" href="classUnstructuredSolidProblem.html#a956386972054504cdc23fd970b126934">Incompressible</a>=<span class="keyword">true</span>;}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Doc the solution</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classUnstructuredSolidProblem.html#ab3d66fd61b69d12b4f159d763fc44f15">doc_solution</a>(DocInfo&amp; doc_info);</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Calculate the strain energy</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="classUnstructuredSolidProblem.html#a4da918a1f0cf94ebccc5112b58c28ece">get_strain_energy</a>();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Remove Traction Mesh</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classUnstructuredSolidProblem.html#a463b4b976fdd12129ac2bd23bece1b8b">actions_before_adapt</a>();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Add on the traction elements after adaptation</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classUnstructuredSolidProblem.html#acf0bbf57534a1516a633d702d9fd21ab">actions_after_adapt</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Bulk mesh</span></div>
<div class="line"><span class="comment"></span> RefineableSolidTriangleMesh&lt;ELEMENT&gt;* <a class="code" href="classUnstructuredSolidProblem.html#af121067bd532a78b4360373b60aaddd0">Solid_mesh_pt</a>;</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Pointer to mesh of traction elements</span></div>
<div class="line"><span class="comment"></span> SolidMesh* <a class="code" href="classUnstructuredSolidProblem.html#a42018e62ce6bf48968f389880669c8f4">Traction_mesh_pt</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Triangle mesh polygon for outer boundary </span></div>
<div class="line"><span class="comment"></span> TriangleMeshPolygon* <a class="code" href="classUnstructuredSolidProblem.html#a2e7ef7b4984d6d2a063c0c2374931d0c">Outer_boundary_polyline_pt</a>; </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Boolean flag used in an incompressible problem</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">bool</span> <a class="code" href="classUnstructuredSolidProblem.html#a956386972054504cdc23fd970b126934">Incompressible</a>;</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="ttc" id="aclassUnstructuredSolidProblem_html_a18ce02b6e4bbc86403c9e1b32c095772"><div class="ttname"><a href="classUnstructuredSolidProblem.html#a18ce02b6e4bbc86403c9e1b32c095772">UnstructuredSolidProblem::UnstructuredSolidProblem</a></div><div class="ttdeci">UnstructuredSolidProblem()</div><div class="ttdoc">Constructor:</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00133">unstructured_adaptive_solid.cc:133</a></div></div>
<div class="ttc" id="aclassUnstructuredSolidProblem_html_a25fe105d949498bf8f7c15aff96a7d00"><div class="ttname"><a href="classUnstructuredSolidProblem.html#a25fe105d949498bf8f7c15aff96a7d00">UnstructuredSolidProblem::~UnstructuredSolidProblem</a></div><div class="ttdeci">~UnstructuredSolidProblem()</div><div class="ttdoc">Destructor (empty)</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00094">unstructured_adaptive_solid.cc:94</a></div></div>
<div class="ttc" id="aclassUnstructuredSolidProblem_html_a2e7ef7b4984d6d2a063c0c2374931d0c"><div class="ttname"><a href="classUnstructuredSolidProblem.html#a2e7ef7b4984d6d2a063c0c2374931d0c">UnstructuredSolidProblem::Outer_boundary_polyline_pt</a></div><div class="ttdeci">TriangleMeshPolygon * Outer_boundary_polyline_pt</div><div class="ttdoc">Triangle mesh polygon for outer boundary.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00120">unstructured_adaptive_solid.cc:120</a></div></div>
<div class="ttc" id="aclassUnstructuredSolidProblem_html_a42018e62ce6bf48968f389880669c8f4"><div class="ttname"><a href="classUnstructuredSolidProblem.html#a42018e62ce6bf48968f389880669c8f4">UnstructuredSolidProblem::Traction_mesh_pt</a></div><div class="ttdeci">SolidMesh * Traction_mesh_pt</div><div class="ttdoc">Pointer to mesh of traction elements.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00117">unstructured_adaptive_solid.cc:117</a></div></div>
<div class="ttc" id="aclassUnstructuredSolidProblem_html_a463b4b976fdd12129ac2bd23bece1b8b"><div class="ttname"><a href="classUnstructuredSolidProblem.html#a463b4b976fdd12129ac2bd23bece1b8b">UnstructuredSolidProblem::actions_before_adapt</a></div><div class="ttdeci">void actions_before_adapt()</div><div class="ttdoc">Remove Traction Mesh.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00331">unstructured_adaptive_solid.cc:331</a></div></div>
<div class="ttc" id="aclassUnstructuredSolidProblem_html_a956386972054504cdc23fd970b126934"><div class="ttname"><a href="classUnstructuredSolidProblem.html#a956386972054504cdc23fd970b126934">UnstructuredSolidProblem::Incompressible</a></div><div class="ttdeci">bool Incompressible</div><div class="ttdoc">Boolean flag used in an incompressible problem.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00123">unstructured_adaptive_solid.cc:123</a></div></div>
<div class="ttc" id="aclassUnstructuredSolidProblem_html_a9b725d83bc051b594d080a40d6d317d3"><div class="ttname"><a href="classUnstructuredSolidProblem.html#a9b725d83bc051b594d080a40d6d317d3">UnstructuredSolidProblem::set_incompressible</a></div><div class="ttdeci">void set_incompressible()</div><div class="ttdoc">Set the problem to be incompressible.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00097">unstructured_adaptive_solid.cc:97</a></div></div>
<div class="ttc" id="aclassUnstructuredSolidProblem_html_acf0bbf57534a1516a633d702d9fd21ab"><div class="ttname"><a href="classUnstructuredSolidProblem.html#acf0bbf57534a1516a633d702d9fd21ab">UnstructuredSolidProblem::actions_after_adapt</a></div><div class="ttdeci">void actions_after_adapt()</div><div class="ttdoc">Add on the traction elements after adaptation.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00348">unstructured_adaptive_solid.cc:348</a></div></div>
<div class="ttc" id="aclassUnstructuredSolidProblem_html_af121067bd532a78b4360373b60aaddd0"><div class="ttname"><a href="classUnstructuredSolidProblem.html#af121067bd532a78b4360373b60aaddd0">UnstructuredSolidProblem::Solid_mesh_pt</a></div><div class="ttdeci">RefineableSolidTriangleMesh&lt; ELEMENT &gt; * Solid_mesh_pt</div><div class="ttdoc">Bulk mesh.</div><div class="ttdef"><b>Definition:</b> <a href="unstructured__adaptive__solid_8cc_source.html#l00114">unstructured_adaptive_solid.cc:114</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="constructor"></a>
The Problem constructor</h1>
<p>We begin by building the closed, piecewise linear boundary of the undeformed solid body <img class="formulaInl" alt="$ x_{1} \in [0,1] $" src="form_4.png" width="53" height="14"/>, <img class="formulaInl" alt="$ x_{2} \in [0,5]. $" src="form_5.png" width="56" height="14"/> The boundaries are labelled anticlockwise with boundary with the left-hand boundary being boundary 0, see the sketch above. This process is a simplified version of the construction used in <a href="../../../../doc/meshes/mesh_from_inline_triangle/html/index.html">another tutorial. </a></p>
 <div class="fragment"><div class="line"><span class="comment">//===============start_constructor========================================</span></div>
<div class="line"><span class="comment">/// Constructor for unstructured solid problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><a class="code" href="classUnstructuredSolidProblem.html#a18ce02b6e4bbc86403c9e1b32c095772">UnstructuredSolidProblem&lt;ELEMENT&gt;::UnstructuredSolidProblem</a>() :</div>
<div class="line"> Incompressible(false)</div>
<div class="line">{  </div>
<div class="line"> <span class="comment">// Build the boundary segments for outer boundary, consisting of</span></div>
<div class="line"> <span class="comment">//--------------------------------------------------------------</span></div>
<div class="line"> <span class="comment">// four separeate polyline segments</span></div>
<div class="line"> <span class="comment">//---------------------------------</span></div>
<div class="line"> Vector&lt;TriangleMeshCurveSection*&gt; boundary_segment_pt(4);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Initialize boundary segment</span></div>
<div class="line"> Vector&lt;Vector&lt;double&gt; &gt; bound_seg(2);</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;2;i++) {bound_seg[i].resize(2);}</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// First boundary segment</span></div>
<div class="line"> bound_seg[0][0]=0.0;</div>
<div class="line"> bound_seg[0][1]=0.0;</div>
<div class="line"> bound_seg[1][0]=0.0;</div>
<div class="line"> bound_seg[1][1]=5.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Specify 1st boundary id</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> bound_id = 0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the 1st boundary segment</span></div>
<div class="line"> boundary_segment_pt[0] = <span class="keyword">new</span> TriangleMeshPolyLine(bound_seg,bound_id);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Second boundary segment</span></div>
<div class="line"> bound_seg[0][0]=0.0;</div>
<div class="line"> bound_seg[0][1]=5.0;</div>
<div class="line"> bound_seg[1][0]=1.0;</div>
<div class="line"> bound_seg[1][1]=5.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Specify 2nd boundary id</span></div>
<div class="line"> bound_id = 1;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the 2nd boundary segment</span></div>
<div class="line"> boundary_segment_pt[1] = <span class="keyword">new</span> TriangleMeshPolyLine(bound_seg,bound_id);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Third boundary segment</span></div>
<div class="line"> bound_seg[0][0]=1.0;</div>
<div class="line"> bound_seg[0][1]=5.0;</div>
<div class="line"> bound_seg[1][0]=1.0;</div>
<div class="line"> bound_seg[1][1]=0.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Specify 3rd boundary id</span></div>
<div class="line"> bound_id = 2;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the 3rd boundary segment</span></div>
<div class="line"> boundary_segment_pt[2] = <span class="keyword">new</span> TriangleMeshPolyLine(bound_seg,bound_id);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Fourth boundary segment</span></div>
<div class="line"> bound_seg[0][0]=1.0;</div>
<div class="line"> bound_seg[0][1]=0.0;</div>
<div class="line"> bound_seg[1][0]=0.0;</div>
<div class="line"> bound_seg[1][1]=0.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Specify 4th boundary id</span></div>
<div class="line"> bound_id = 3;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the 4th boundary segment</span></div>
<div class="line"> boundary_segment_pt[3] = <span class="keyword">new</span> TriangleMeshPolyLine(bound_seg,bound_id);</div>
<div class="line">  </div>
<div class="line"> <span class="comment">// Create the triangle mesh polygon for outer boundary using boundary segment</span></div>
<div class="line"> Outer_boundary_polyline_pt = <span class="keyword">new</span> TriangleMeshPolygon(boundary_segment_pt);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// There are no holes</span></div>
<div class="line"> <span class="comment">//-------------------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Now build the mesh, based on the boundaries specified by</span></div>
<div class="line"> <span class="comment">//---------------------------------------------------------</span></div>
<div class="line"> <span class="comment">// polygons just created</span></div>
<div class="line"> <span class="comment">//----------------------</span></div>
<div class="line"> <span class="keywordtype">double</span> uniform_element_area=0.2;</div>
<div class="line"> </div>
<div class="line"> TriangleMeshClosedCurve* closed_curve_pt=Outer_boundary_polyline_pt;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Use the TriangleMeshParameters object for gathering all</span></div>
<div class="line"> <span class="comment">// the necessary arguments for the TriangleMesh object</span></div>
<div class="line"> TriangleMeshParameters triangle_mesh_parameters(</div>
<div class="line">   closed_curve_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Define the maximum element area</span></div>
<div class="line"> triangle_mesh_parameters.element_area() =</div>
<div class="line">   uniform_element_area;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create the mesh</span></div>
<div class="line"> Solid_mesh_pt =</div>
<div class="line">   <span class="keyword">new</span> RefineableSolidTriangleMesh&lt;ELEMENT&gt;(</div>
<div class="line">     triangle_mesh_parameters);</div>
</div><!-- fragment --><p> We next construct an error estimator and specify the target errors and element sizes.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">//hierher</span></div>
<div class="line"> <span class="comment">// Disable the use of an iterative solver for the projection</span></div>
<div class="line"> <span class="comment">// stage during mesh adaptation</span></div>
<div class="line"> Solid_mesh_pt-&gt;disable_iterative_solver_for_projection();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set error estimator for bulk mesh</span></div>
<div class="line"> Z2ErrorEstimator* error_estimator_pt=<span class="keyword">new</span> Z2ErrorEstimator;</div>
<div class="line"> Solid_mesh_pt-&gt;spatial_error_estimator_pt()=error_estimator_pt;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set targets for spatial adaptivity</span></div>
<div class="line"> Solid_mesh_pt-&gt;max_permitted_error()=0.0001;</div>
<div class="line"> Solid_mesh_pt-&gt;min_permitted_error()=0.001; </div>
<div class="line"> Solid_mesh_pt-&gt;max_element_size()=0.2;</div>
<div class="line"> Solid_mesh_pt-&gt;min_element_size()=0.001; </div>
</div><!-- fragment --><p> We output the boundaries, construct an empty traction mesh and combine the bulk and traction meshes into a global mesh.</p>
<div class="fragment"><div class="line">   </div>
<div class="line"> <span class="comment">// Output mesh boundaries</span></div>
<div class="line"> this-&gt;Solid_mesh_pt-&gt;output_boundaries(<span class="stringliteral">&quot;boundaries.dat&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Make the traction mesh</span></div>
<div class="line"> Traction_mesh_pt=<span class="keyword">new</span> SolidMesh;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Add sub meshes</span></div>
<div class="line"> add_sub_mesh(Solid_mesh_pt);</div>
<div class="line"> add_sub_mesh(Traction_mesh_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the global mesh</span></div>
<div class="line"> build_global_mesh();</div>
</div><!-- fragment --><p> Finally we call <code>actions_after_adapt()</code>, which constructs the traction elements, sets the boundary conditions and completes the build of the elements, and then we assign the equation numbers</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">//Call actions after adapt:</span></div>
<div class="line"> <span class="comment">// 1) to build the traction elements</span></div>
<div class="line"> <span class="comment">// 2) to pin the nodes on the lower boundary (boundary 3)</span></div>
<div class="line"> <span class="comment">// 3) to complete the build of the elements</span></div>
<div class="line"> <span class="comment">// Note there is slight duplication here because we rebuild the global mesh</span></div>
<div class="line"> <span class="comment">// twice.</span></div>
<div class="line"> this-&gt;actions_after_adapt();</div>
<div class="line">   </div>
<div class="line"> <span class="comment">// Setup equation numbering scheme</span></div>
<div class="line"> cout &lt;&lt;<span class="stringliteral">&quot;Number of equations: &quot;</span> &lt;&lt; assign_eqn_numbers() &lt;&lt; std::endl; </div>
<div class="line"> </div>
<div class="line">} <span class="comment">//end constructor</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="adapt_after"></a>
Actions before adaptation</h1>
<p>The <code>actions_before_adapt()</code> function simply deletes the traction elements and clears the storage in the face mesh.</p>
 <div class="fragment"><div class="line"><span class="comment">//==============start_actions_before_adapt================================</span></div>
<div class="line"><span class="comment">/// Actions before adapt: remove the traction elements in the surface mesh</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classUnstructuredSolidProblem.html#a463b4b976fdd12129ac2bd23bece1b8b">UnstructuredSolidProblem&lt;ELEMENT&gt;::actions_before_adapt</a>()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// How many surface elements are in the surface mesh</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_element = Traction_mesh_pt-&gt;nelement();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over the surface elements and kill them</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++) {<span class="keyword">delete</span> Traction_mesh_pt-&gt;element_pt(e);}</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Wipe the mesh</span></div>
<div class="line"> Traction_mesh_pt-&gt;flush_element_and_node_storage();</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end_actions_before_adapt</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="adapt_after"></a>
Actions before adaptation</h1>
<p>The function <code>actions_after_adapt()</code> first builds the traction elements adjacent to the left-hand boundary (boundary 0) and rebuilds the global mesh. The <code><a class="el" href="namespaceGlobal__Physical__Variables.html#a19f4e20a92e7d216b4d2b00308f96917" title="Constant pressure load. The arguments to this function are imposed on us by the SolidTractionElements...">constant_pressure()</a></code> load function is passed to each of the traction elements.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment">//=================start_actions_after_adapt=============================</span><span class="comment"></span></div>
<div class="line"><span class="comment"> /// Need to add on the traction elements after adaptation</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=======================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classUnstructuredSolidProblem.html#acf0bbf57534a1516a633d702d9fd21ab">UnstructuredSolidProblem&lt;ELEMENT&gt;::actions_after_adapt</a>()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">//The boundary in question is boundary 0</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> b=0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// How many bulk elements are adjacent to boundary b?</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_element = Solid_mesh_pt-&gt;nboundary_element(b);</div>
<div class="line"> <span class="comment">// Loop over the bulk elements adjacent to boundary b</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Get pointer to the bulk element that is adjacent to boundary b</span></div>
<div class="line">   ELEMENT* bulk_elem_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(</div>
<div class="line">    Solid_mesh_pt-&gt;boundary_element_pt(b,e));</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Find the index of the face of element e along boundary b</span></div>
<div class="line">   <span class="keywordtype">int</span> face_index = Solid_mesh_pt-&gt;face_index_at_boundary(b,e);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Create solid traction element</span></div>
<div class="line">   SolidTractionElement&lt;ELEMENT&gt; *el_pt = </div>
<div class="line">    <span class="keyword">new</span> SolidTractionElement&lt;ELEMENT&gt;(bulk_elem_pt,face_index);   </div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Add to mesh</span></div>
<div class="line">   Traction_mesh_pt-&gt;add_element_pt(el_pt);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Set the traction function</span></div>
<div class="line">   el_pt-&gt;traction_fct_pt() = <a class="code" href="namespaceGlobal__Physical__Variables.html#a19f4e20a92e7d216b4d2b00308f96917">Global_Physical_Variables::constant_pressure</a>;</div>
<div class="line">  }  </div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Now rebuild the global mesh</span></div>
<div class="line"> this-&gt;rebuild_global_mesh();</div>
</div><!-- fragment --><p> Next, the boundary conditions of a fixed base (boundary 3) are set. These must be reset every time after an adaptation because completely new nodes are generated.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">//(Re)set the boundary conditions</span></div>
<div class="line"> <span class="comment">//Pin both positions at lower boundary (boundary 3)</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> ibound=3;</div>
<div class="line"> <span class="keywordtype">unsigned</span> num_nod= mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">  {  </div>
<div class="line">   <span class="comment">// Get node</span></div>
<div class="line">   SolidNode* nod_pt=Solid_mesh_pt-&gt;boundary_node_pt(ibound,inod);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Pin both directions</span></div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;2;i++) {nod_pt-&gt;pin_position(i);}</div>
<div class="line">  }</div>
<div class="line"> <span class="comment">//End of set boundary conditions </span></div>
</div><!-- fragment --><p> Finally, the constitutive law and, if required, incompressibility flag are passed to the bulk (solid) elements. Again, this must be performed after every adaptation because a completely new mesh is generated.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Complete the build of all elements so they are fully functional</span></div>
<div class="line"> n_element = Solid_mesh_pt-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Cast to a solid element</span></div>
<div class="line">   ELEMENT *el_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(Solid_mesh_pt-&gt;element_pt(e));</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Set the constitutive law</span></div>
<div class="line">   el_pt-&gt;constitutive_law_pt() =</div>
<div class="line">    <a class="code" href="namespaceGlobal__Physical__Variables.html#a2a37fb040c832ee7a086bb13bb02a100">Global_Physical_Variables::Constitutive_law_pt</a>;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Set the incompressibility flag if required</span></div>
<div class="line">   <span class="keywordflow">if</span>(Incompressible) </div>
<div class="line">    {</div>
<div class="line">     <span class="comment">//Need another dynamic cast</span></div>
<div class="line">     <span class="keyword">dynamic_cast&lt;</span>TPVDElementWithContinuousPressure&lt;2&gt;*<span class="keyword">&gt;</span>(el_pt)</div>
<div class="line">      -&gt;set_incompressible();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end_actions_after_adapt</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="strain"></a>
Computation of the strain energy</h1>
<p>The strain energy is computed by looping over all elements in the bulk mesh and adding their contributions to the potential (strain) energy.</p>
 <div class="fragment"><div class="line"><span class="comment">//================start_get_strain_energy================================</span></div>
<div class="line"><span class="comment">/// Calculate the strain energy in the entire elastic solid</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=======================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="classUnstructuredSolidProblem.html#a4da918a1f0cf94ebccc5112b58c28ece">UnstructuredSolidProblem&lt;ELEMENT&gt;::get_strain_energy</a>()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">double</span> strain_energy=0.0;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_element = Solid_mesh_pt-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Cast to a solid element</span></div>
<div class="line">   ELEMENT *el_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(Solid_mesh_pt-&gt;element_pt(e));</div>
<div class="line">   </div>
<div class="line">   <span class="keywordtype">double</span> pot_en, kin_en;</div>
<div class="line">   el_pt-&gt;get_energy(pot_en,kin_en);</div>
<div class="line">   strain_energy += pot_en;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">return</span> strain_energy;</div>
<div class="line">} <span class="comment">// end_get_strain_energy</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="doc"></a>
Post-processing</h1>
<p>The post-processing routine outputs the deformed domain shape and the applied traction. In the spirit of continuing paranoia we also document the domain boundaries. It is exactly the same as in the related <a href="../../unstructured_solid/html/index.html">non-adaptive unstructured solid tutorial. </a></p>
<hr  />
 <hr  />
<h1><a class="anchor" id="comm_ex"></a>
Comments and Exercises</h1>
<h2><a class="anchor" id="ex"></a>
Exercises</h2>
<ol type="1">
<li>Examine the changes in strain energy under variations in mesh refinement tolerances and number of intermediate steps between the undeformed and maximally deformed states.</li>
<li>What happens if the Lagrangian coordinates are reset after every adaptation? Why?</li>
<li>Modify the problem so that compression is from the upper surface, rather than the left-hand side. What happens when the material is incompressible?</li>
</ol>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory:<br  />
<br  />
<center> <a href="../../../../demo_drivers/solid/unstructured_adaptive_solid/">demo_drivers/solid/unstructured_adaptive_solid/ </a> </center><br  />
</li>
<li>The driver codes are: <br  />
<br  />
<center> <a href="../../../../demo_drivers/solid/unstructured_adaptive_solid/unstructured_adaptive_solid.cc">demo_drivers/solid/unstructured_solid/unstructured_adaptive_solid.cc </a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:27:38
        </div>
      </div>
    </footer>
</body>
</html>
