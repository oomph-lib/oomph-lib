\mainpage Demo problem: Solid Mechanics using unstructured meshes

The purpose of this tutorial is to demonstrate the solution of
solid mechanics problems using unstructured meshes. We focus primarily
on two-dimensional meshes, 
generated using  <A HREF="http://www.cs.berkeley.edu/~jrs/">
Jonathan Shewchuk's</A> open-source mesh generator 
<A HREF="http://www.cs.cmu.edu/~quake/triangle.html">\c Triangle,</A> 
based on the output from the open-source 
drawing program <A HREF="http://www.xfig.org/">xfig.</A> 
An example three-dimensional problem is described 
<a href="../../unstructured_three_d_solid/html/index.html"> here; </a> 
see also \ref three_d later in this document.

The solid mechanics problem studied here also serves as a
"warm-up problem" for the
<a href="../../../interaction/unstructured_fsi/html/index.html">corresponding 
fluid-structure interaction problem </a> in which the solid object 
is immersed in (and loaded by) a viscous fluid. 
 

<HR>
<HR>

\section problem The problem 
Here is a sketch of the problem: A slightly strange-looking elastic
solid is loaded by gravity and by a pressure load, acting on its
upper face. 

@I w 0.75\textwidth  solid_sketch "Sketch of the problem. "


<HR>
<HR> 

\section mesh Mesh generation
We employ the combination of <A HREF="http://www.xfig.org/">xfig</A>,
\c oomph-lib's conversion code 
<a href="../../../meshes/mesh_from_xfig/html/index.html">
\c fig2poly </a>, and the unstructured
mesh generator 
<A HREF="http://www.cs.cmu.edu/~quake/triangle.html">\c Triangle
</A> to generate the mesh, using the procedure discussed in 
<a href="../../../meshes/mesh_from_xfig/html/index.html">
another tutorial.</a>

We start by drawing the outline of the solid as a polyline in
<A HREF="http://www.xfig.org/">xfig</A>:

@I w 0.75\textwidth xfig_screenshot  "xfig drawing of the solid body. "

(Note that we draw the solid upside-down because of the way 
<A HREF="http://www.xfig.org/">xfig</A> orients its coordinate axes.)

We save the figure as a *.fig file and convert it to a *.poly file
using \c oomph-lib's conversion code 
<a href="../../../meshes/mesh_from_xfig/html/index.html">
\c fig2poly </a>
 (a copy of which is
located in \c oomph-lib's \c bin directory):

\code
fig3poly solid.fig 
\endcode

This creates a file called \c solid.fig.poly that can be processed
using Triangle. For instance, to create a quality mesh with a maximum
element size of 0.025 we use
\code
triangle -q -a0.025 solid.fig.poly
\endcode

Here is a plot of the mesh, generated by \c showme 
distributed with 
<A HREF="http://www.cs.cmu.edu/~quake/triangle.html">\c Triangle
</A>:

@I w 0.75\textwidth showme_screenshot "Visualisation of the mesh with showme. "

The <CODE> *.poly, *.ele </CODE> and <CODE> *.node </CODE>
files generated by 
<A HREF="http://www.cs.cmu.edu/~quake/triangle.html">\c Triangle
</A> can now be used as input to \c oomph-lib's 
\c TriangleMesh class.
 
<HR>
<HR>

\section results Results
The animation shown below illustrates the solid's deformation. 
The first frame shows the undeformed, stress-free reference
configuration; the second frame shows the deformation induced
by gravity. Subsequent frames illustrate the deformation in response
to the (additional) increasing "suction" applied at the upper face.

@I w 0.75\textwidth two_d "Plot of the deformation. "

The blue markers show the position of pinned nodes.

<HR>
<HR>

\section mesh_code Creating the mesh

We create the mesh by multiple inheritance from \c oomph-lib's 
\c TriangleMesh and the \c SolidMesh base class:

\dontinclude unstructured_two_d_solid.cc
\skipline start_mesh
\until {

The constructor calls the constructor of the underlying 
\c TriangleMesh, and, as usual, sets the Lagrangian coordinates
to the current nodal positions, making the current configuration
stress-free.

\until set_lagrangian_nodal_coordinates()

The \c TriangleMesh constructor associates each polyline in the
\c xfig drawing with a distinct \c oomph-lib mesh boundary. Hence
the boundary nodes are initially located on the same, single boundary. 
To facilitate the application of boundary conditions, we divide the single
boundary into three:

\until set_nboundary

We loop over all nodes in the mesh and identify nodes on the lower
(pinned) boundary by their y-coordinate. We remove the node
from the boundary 0 and re-allocate it to the new boundary 1:

\until }

Similarly, we identify all nodes on the upper boundary and
re-assign them to boundary 2, before re-generating the various boundary
lookup schemes that identify which elements are located next
to the various mesh boundaries:

\until };

<HR>
<HR>

\section namespace Problem Parameters
As usual we define the various problem parameters in a 
global namespace. We define Poisson's ratio and 
prepare a pointer to a constitutive equation.

\skipline start_namespace
\until Constitutive_law_pt

Next we define the gravitational body force

\until }

and the pressure load to be applied at the upper boundary

\until end namespace

<HR>
<HR>

\section main The driver code

The driver code is straightforward. We specify an output directory
and instantiate a constitutive equation. (Recall that the
single-argument constructor to the \c GeneralisedHookean
constitutive law implies that all stresses are non-dimensionalised
on Young's modulus \f$ E \f$).

\dontinclude unstructured_two_d_solid.cc
\skipline start_main
\until ::Nu);

We create the \c Problem object using a displacement formulation of
the equations and output the initial
configuration

\until ()++

Finally, we perform a straightforward parameter study, applying
a constant gravitational load and slowly increasing the
suction (negative pressure) on the upper boundary. 

\until end_displacement_formulation

The parameter study is then repeated for a pressure-displacement
formulation with and without an incompressibility constraint, see the 
<A HREF="../../../../demo_drivers/solid/unstructured_solid/unstructured_two_d_solid.cc">
source code </A> for details.

<HR>
<HR>

\section class The Problem class
The \c Problem class has the usual member functions and provides
storage for the two sub-meshes: the bulk mesh of 2D solid elements
and the mesh of 1D traction elements that will be attached to the 
upper boundary.

\dontinclude unstructured_two_d_solid.cc
\skipline start_problem
\until };



<HR>
<HR>

\section constructor The Problem constructor

We start by building the bulk mesh, using the files created
by <A HREF="http://www.cs.cmu.edu/~quake/triangle.html">\c Triangle
</A>.

\skipline start_constructor
\until poly_file_name);

Next we create traction elements, attaching them to the "bulk"
solid elements that are adjacent to boundary 2. We also specify 
the load function.

\until }

We add both meshes as sub-meshes to the \c Problem and build
the global mesh

\until build_global

Next we apply the boundary conditions at the lower boundary
where we suppress the displacements in both directions. 
We document the position of the pinned nodes to allow us
to check that the boundary IDs were identified correctly -- see
\ref comm_ex for a further discussion of this issue.

\until bc_file.close();

Finally, we complete the build of the solid elements by specifying
their constitutive equation and the body force before assigning
the equation numbers.

\until end constructor


<HR>
<HR>

\section doc Post-processing

The post-processing routine outputs the deformed domain shape
and the applied traction. In the spirit of continuing paranoia
we also document the domain boundaries; see \ref comm_ex.

\until }


<HR>
<HR>

\section comm_ex Comments and Exercises

\subsection bound Identification/assignment of mesh boundaries
This tutorial demonstrates that the use of unstructured meshes
for solid mechanics problems is extremely straightforward. 
The only aspect that requires some care (and not just for solid
mechanics applications) is the correct identification/assigment of
domain boundaries when the mesh is generated with 
<A HREF="http://www.xfig.org/">xfig.</A> The fact that
we documented the mesh boundaries and the positions of the pinned 
nodes in the driver code suggests (correctly!) that we managed to 
get both assignments (slightly) wrong when we first wrote the
driver code. The manual identification of nodes on domain
boundaries is tedious and therefore error prone and, as usual, 
it pays to <B>be  as a paranoid as possible</B>! Ignore this 
advice at your own risk...

We also welcome any improvements to our conversion code
<A HREF="../../../../demo_drivers/meshing/mesh_from_xfig_triangle/fig2poly.cc">
fig2poly.cc
</A>
that would allow the specification of domain boundaries from
within <A HREF="http://www.xfig.org/">xfig.</A> It's probably
not possible but if you have any ideas how to go about this
(either by hijacking information that can be generated by
<A HREF="http://www.xfig.org/">xfig</A> or via some other
GUI interface),
<a href="../../../contact/html/index.html">let us know.</a>


<HR>

\subsection three_d 3D Problems

Unstructured meshes may also be used for the 3D solid mechanics problems. 
The overall procedure is very similar to that documented
above, we will not provide a detailed discussion of the corresponding 
3D driver code

<CENTER>
<A HREF="../../../../demo_drivers/solid/unstructured_solid/unstructured_three_d_solid.cc">
demo_drivers/solid/unstructured_solid/unstructured_three_d_solid.cc
</A>
</CENTER>

which computes the deformation of the hollow cube used in the
<a href="../../../meshes/mesh_from_tetgen/html/index.html">
Mesh Generation with Tetgen Tutorial</a>.

Here is an animation of the cube's deformation when it is subjected 
to gravity, acting in the negative \f$ z \f$-direction, and 
a "suction" force applied on the upper face, while its right face 
is held in a fixed position.

@I w 0.75\textwidth three_d "Plot of the deformation of a hollow 3D cube. "

An alternative three-dimensional problem: the deformation of a bifurcating
tube is described <a href="../../unstructured_three_d_solid/html/index.html">
here. </a>

<HR>
<HR>

\section sources Source files for this tutorial
- The source files for this tutorial are located in the directory:\n\n
<CENTER>
<A HREF="../../../../demo_drivers/solid/unstructured_solid/">
demo_drivers/solid/unstructured_solid/
</A>
</CENTER>\n
- The driver codes are: \n\n
<CENTER>
<A HREF="../../../../demo_drivers/solid/unstructured_solid/unstructured_two_d_solid.cc">
demo_drivers/solid/unstructured_solid/unstructured_two_d_solid.cc
</A>
</CENTER>
and 
<CENTER>
<A HREF="../../../../demo_drivers/solid/unstructured_solid/unstructured_three_d_solid.cc">
demo_drivers/solid/unstructured_solid/unstructured_three_d_solid.cc
</A>
</CENTER>
.










