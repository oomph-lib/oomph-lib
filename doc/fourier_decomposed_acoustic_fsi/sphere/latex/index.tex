\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{Acknowledgement\+:}} This tutorial and the associated driver codes were developed jointly with David Nigro and Robert Harter (Thales Underwater Systems Ltd) with financial support from a KTA Secondment grant from University of Manchester\textquotesingle{}s EPSRC-\/funded Knowledge Transfer Account. \end{center}    \\\cline{1-1}
\end{longtabu}
\end{center} 

In this document we discuss the solution of time-\/harmonic acoustic fluid-\/structure interaction problems in cylindrical polar coordinates, using a Fourier decomposition of the solution in the azimuthal direction. These equations are useful to solve problems involving axisymmetric elastic bodies.

We start by reviewing the relevant theory and then present the solution of a simple model problem -- the sound radiation from an oscillating sphere that is coated with a compressible elastic layer.

This problem combines the problems discussed in the tutorials illustrating
\begin{DoxyItemize}
\item \href{../../../time_harmonic_fourier_decomposed_linear_elasticity/cylinder/html/index.html}{\texttt{ the solution of the time-\/harmonic equations of linear elasticity in cylindrical polar coordinates}}
\end{DoxyItemize}and
\begin{DoxyItemize}
\item \href{../../../fourier_decomposed_helmholtz/sphere_scattering/html/index.html}{\texttt{ the Helmholtz equation in cylindrical polar coordinates}}
\end{DoxyItemize}\mbox{[}Note that this tutorial is (obviously) very similar to its \href{../../../acoustic_fsi/acoustic_fsi_annulus/html/index.html}{\texttt{ cartesian counterpart}}. The considerable overlap of material is deliberate to make both tutorials reasonably self-\/contained and explicit.\mbox{]}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 ~\newline
\hypertarget{index_theory}{}\doxysection{Theory\+: Time-\/harmonic acoustic fluid-\/structure interaction problems in cylindrical polar coordinates}\label{index_theory}
The figure below shows a sketch of a representative model problem\+: a sphere is immersed in an inviscid compressible fluid and performs a prescribed harmonic oscillation of radian frequency $\omega$. The sphere is coated with a compressible elastic layer. We wish to compute the displacement field in the elastic coating (assumed to be described by the \href{../../../time_harmonic_fourier_decomposed_linear_elasticity/cylinder/html/index.html}{\texttt{ equations of time-\/harmonic linear elasticity}}) and the pressure distribution in the fluid (governed by \href{../../../fourier_decomposed_helmholtz/sphere_scattering/html/index.html}{\texttt{ the Helmholtz equation}}). The two sets of equations interact at the interface between fluid and solid\+: the fluid pressure exerts a traction onto the elastic layer, while the motion of the elastic layer drives the fluid motion via the non-\/penetration condition.

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{coated_sphere}
\doxyfigcaption{Sketch of the model problem\+: Forced oscillations of a sphere (black) deform an elastic coating layer (pink) which is surrounded by a compressible fluid. }
\end{DoxyImage}
\hypertarget{index_fluid}{}\doxysubsection{The fluid model\+: the Helmholtz equation}\label{index_fluid}
We describe the behaviour of the fluid in terms of the displacement field, $ {\bf d}^*(r^*,z^*,\varphi,t^*)$, of the fluid particles, where $r^*, z^* $ and $ \varphi $ are cylindrical polar coordinates. As usual, we use asterisks to distinguish dimensional quantities from their non-\/dimensional equivalents. The fluid is inviscid and compressible, with a bulk modulus $ B $, such that the acoustic pressure is given by $ P^* = - B \ \nabla^{*} \cdot {\bf d}^* $ We assume that the fluid motion is irrotational and can be described by a displacement potential $\Phi^*$, such that $ {\bf d}^*= \nabla^* \Phi^*. $ We consider steady-\/state time-\/harmonic oscillations and write the displacement potential and the pressure as $\Phi^*(r^*,z^*,\varphi,t^*) = \mbox{Re} \{\phi^*(r^*,z^*,\varphi) \exp(-{\rm i} \omega t^*)\} $ and $P^*(r^*,z^*,\varphi,t^*) = \mbox{Re}\{p^*(r^*,z^*,\varphi) \exp(-{\rm i} \omega t^*)\}$, respectively, where $\mbox{Re}\{\ldots \}$ denotes the real part. For small disturbances, the linearised Euler equation reveals that the time-\/harmonic pressure is related to the displacement potential via $ p^* = \rho_{\rm f} \omega^2 \phi^*$ where $ \rho_{\rm f}$ is the ambient fluid density. We non-\/dimensionalise all lengths on a problem-\/specific lengthscale $ {\cal L}$ (e.\+g. the outer radius of the coating layer) such that $ [r^*, z^*] = {\cal L} [r,z], \ {\bf d}^* = {\cal L} {\bf d} $ and $\phi^* = {\cal L}^2 \phi$.

We then decompose $ \phi $ into its Fourier components by writing \[ {\phi}(r,\varphi,z) = \sum_{N=-\infty}^{\infty} \phi_N(r,z) \exp({\rm i} N \varphi). \] Since the governing equations are linear we can compute each Fourier component $ \phi_N(r,z) $ individually by solving \[ \nabla^2 {\phi_{N}}(r,z) + \left(k^2-\frac{N^2}{r^2}\right) \phi_N(r,z) = 0, \ \ \ \ \ \ \ \ \ \ \ \ (1) \] where the square of the non-\/dimensional wavenumber, \[ k^2 = \frac{\rho_{\rm f} (\omega {\cal L})^2}{B}, \] represents the ratio of the typical inertial fluid pressure induced by the wall oscillation to the `stiffness' of the fluid.\hypertarget{index_elastic}{}\doxysubsection{The solid model\+: the time harmonic equations of linear elasticity}\label{index_elastic}
We model the coating layer as a linearly elastic solid, described in terms of a displacement field $ {\bf U}^*(r^*,z^*,\varphi,t^*)$, with stress tensor \[ \mbox{\boldmath$ \tau^*$}=\frac{E}{1+\nu}\left( \frac{\nu}{1-2\nu}(\mbox{\boldmath$\nabla^*\cdot U^*$})\textbf{I}+ \frac{1}{2}(\mbox{\boldmath$ \nabla^* U^*$}+ \mbox{\boldmath$ \nabla^* U^*$}^{{\rm T}})\right), \] where $E$ and $\nu$ are the material\textquotesingle{}s Young\textquotesingle{}s modulus and Poisson\textquotesingle{}s ratio, respectively.

As before, we assume a time-\/harmonic solution with frequency $ \omega$ so that $ {\bf U}^*(r^*,z^*,\varphi,t^*) = {\rm Re} \{ {\bf u}^*(r^*,z^*,\varphi) \exp(-{\rm i}\omega t^*)\}$. We non-\/dimensionalise the displacements on ${\cal L}$ and the stress on Young\textquotesingle{}s modulus, $E$, so that ${\bf u}^* = {\cal L} {\bf u} $ and $ \mbox{\boldmath$ \tau^*$} = E \mbox{\boldmath$ \tau$}$. The deformation of the elastic coating is then governed by the time-\/harmonic Navier-\/\+Lame equations \begin{center} \[ \mbox{\boldmath$ \nabla\cdot\tau$}+\Omega^2\mbox{\boldmath$ u$} = {\bf 0} \ \ \ \ \ \ \ \ \ \ (2) \] \end{center}  where \begin{center} \[ \mbox{\boldmath$ \tau $}=\frac{1}{1+\nu}\left( \frac{\nu}{1-2\nu}(\mbox{\boldmath$\nabla\cdot u$})\textbf{I}+ \frac{1}{2}(\mbox{\boldmath$ \nabla u$}+\mbox{\boldmath$ \nabla u$}^{{\rm T}})\right) \ \ \ \ \ \ \ \ \ \ (3) \] \end{center}  is the non-\/dimensional stress tensor. The (square of the) non-\/dimensional wavenumber \[ \Omega^2 = \frac{\rho_{\rm s} (\omega {\cal L})^2}{E}, \] where $ \rho_{\rm s}$ is the solid density, represents the ratio of the typical inertial solid pressure induced by the wall oscillation to the stiffness of the elastic coating. We note that for a `light' coating we have $\Omega \ll 1$.

We then decompose $ {\bf u} $ into its Fourier components by writing \[ {\bf u}(r,\varphi,z) = \sum_{N=-\infty}^{\infty} {\bf u}_N(r,z) \exp({\rm i} N \varphi). \] This decomposition allows us to remove the $ \theta $-\/dependence from the equations by writing $ \partial (.)/\partial\theta={\rm i} N (.) $. Since the governing equations are linear, we can solve for each Fourier component separately and specify the Fourier wavenumber $ N $ as a parameter.\hypertarget{index_bc}{}\doxysubsection{Boundary conditions}\label{index_bc}
The inner surface of the elastic coating, $ \partial D_{\rm s} $, is subject to the prescribed displacement imposed by the oscillating cylinder. For instance, if the inner cylinder performs spherically symmetric oscillations of non-\/dimensional amplitude $ \epsilon$, we have \[ \mbox{\bf u}_0 = \epsilon \, \mbox{\bf e}_{r_{\rm sphere}} \mbox{\ \ \ \ \ on $\partial D_{\rm s}$}, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (4) \] where \[ \mbox{\bf e}_{r_{\rm sphere}} = \frac{r}{\sqrt{r^2+z^2}} {\bf e}_r + \frac{z}{\sqrt{r^2+z^2}} {\bf e}_z \] is the unit vector in the (spherically!) radial direction, while the other Fourier components remain zero, $ \mbox{\bf u}_j = {\bf 0} $ for $ j=\pm 1, \pm 2, ...$ The fluid-\/loaded surface of the elastic coating, $ \partial D_{\rm f} $, is subject to the fluid pressure. The non-\/dimensional traction exerted by the fluid onto the solid (on the solid stress scale) is therefore given by \[ {\bf t}^{\rm [solid]} = \mbox{\boldmath$ \tau $}^{\rm [solid]} \cdot {\bf n} = - \phi \ Q \ {\bf n} \mbox{\ \ \ \ \ on $\partial D_{\rm f}$}, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (5) \] where the $ {\bf n} = n_r {\bf e}_r + n_z {\bf e}_z $ is the outer unit normal on the solid boundary $\partial D_{\rm f}$ and \[ Q=\frac{\rho_{\rm f}({\cal L}\omega)^2}{E} \] is the final non-\/dimensional parameter in the problem. It represents the ratio of the typical inertial fluid pressure induced by the wall oscillation to the stiffness of the elastic coating. The parameter $Q$ therefore provides a measure of the strength of the fluid-\/structure interaction (FSI) in the sense that for $Q \to 0$ the elastic coating does not `feel' the presence of the fluid.

The fluid is forced by the normal displacement of the solid. Imposing the non-\/penetration condition $({\bf d} - {\bf u}) \cdot {\bf n} = 0$ on $\partial D_{\rm f}$ yields a Neumann condition for the displacement potential, \[ \frac{\partial \phi}{\partial n} = {\bf u} \cdot {\bf n} \mbox{\ \ \ \ \ on $\partial D_{\rm f}$}. \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (6) \] Finally, the displacement potential for the fluid must satisfy the Sommerfeld radiation condition \[ \lim_{r_{\rm sphere} \to \infty} r_{\rm sphere} \left( \frac{\partial \phi}{\partial r_{\rm sphere} } - {\rm i} k \phi \right) = 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (7) \] where $ r_{\rm sphere} = \sqrt{(r^2+z^2)} $ is the (spherical) radius. The Sommerfeld radiation condition ensures that the oscillating sphere does not generate any incoming waves.

Equations (5), (6) and (7) apply for each Fourier component of the solution.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_impl}{}\doxysection{Implementation}\label{index_impl}
The implementation of the coupled problem follows the usual procedure for multi-\/domain problems in {\ttfamily oomph-\/lib}. We discretise the constituent single-\/physics problems using the existing single-\/physics elements, here {\ttfamily oomph-\/lib\textquotesingle{}s} 
\begin{DoxyItemize}
\item \href{../../../fourier_decomposed_helmholtz/sphere_scattering/html/index.html}{\texttt{ Helmholtz elements}}
\end{DoxyItemize}and
\begin{DoxyItemize}
\item \href{../../../time_harmonic_fourier_decomposed_linear_elasticity/cylinder/html/index.html}{\texttt{ time-\/harmonic linear elasticity elements}}
\end{DoxyItemize}for the discretisation of the PDEs (1) and (2), respectively. The displacement boundary condition (4) on the inner surface of the elastic coating is imposed as usual by pinning the relevant degrees of freedom, exactly as in a \href{../../../time_harmonic_fourier_decomposed_linear_elasticity/cylinder/html/index.html}{\texttt{ single-\/physics solid mechanics problem}}. Similarly, the Sommerfeld radiation condition (7) on the outer boundary of the fluid domain can be imposed by any of the methods available for the solution of the single-\/physics Helmholtz equation, such as a \href{../../../fourier_decomposed_helmholtz/sphere_scattering/html/index.html\#DtN}{\texttt{ Dirichlet-\/to-\/\+Neumann mapping.}}

The boundary conditions (5) and (6) at the fluid-\/solid interface are traction boundary conditions for the solid, and Neumann boundary conditions for the Helmholtz equation, respectively. In a single-\/physics problem we would impose such boundary conditions by attaching suitable {\ttfamily Face\+Elements} to the appropriate boundaries of the \char`\"{}bulk\char`\"{} elements, as shown in the sketch below\+: {\ttfamily Time\+Harmonic\+Fourier\+Decomposed\+Linear\+Elasticity\+Traction\+Element} could be used to impose a (given) traction, $ {\bf t}_0$, onto the solid; {\ttfamily Fourier\+Decomposed\+Helmholtz\+Flux\+Elements} could be used to impose a (given) normal derivative, $ f_0$, on the displacement potential. Both $ {\bf t}_0$ and $ f_0 $ would usually be specified in a user-\/defined namespace and accessed via function pointers as indicated in the right half of the sketch.

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{single_physics}
\doxyfigcaption{Sketch illustrating the imposition of flux and traction boundary conditions in single-\/physics problems. The continuous problems are shown on the left; the discretised ones on the right. }
\end{DoxyImage}


In the coupled problem, illustrated in the left half of the next sketch, the traction acting on the solid becomes a function of the displacement potential via the boundary condition (5), while the normal derivative of the displacement potential is given in terms of the solid displacement via equation (6). Note that corresponding points on the FSI boundary $ \partial D_{\rm f}$ are identified by matching values of the boundary coordinate $ \zeta $ which is assumed to be consistent between the two domains.

The implementation of this interaction in the discretised problem is illustrated in the right half of the sketch\+: We replace the single-\/physics {\ttfamily Fourier\+Decomposed\+Helmholtz\+Flux\+Elements} by {\ttfamily Fourier\+Decomposed\+Helmholtz\+Flux\+From\+Normal\+Displacement\+BCElements}, and the {\ttfamily Time\+Harmonic\+Fourier\+Decomposed\+Linear\+Elasticity\+Traction\+Elements} by {\ttfamily Fourier\+Decomposed\+Time\+Harmonic\+Lin\+Elast\+Loaded\+By\+Helmholtz\+Pressure\+BCElements}. (Yes, we like to be verbose...). Both of these {\ttfamily Face\+Elements} are derived from the {\ttfamily Element\+With\+External\+Element} base class and can therefore store a pointer to an \char`\"{}external\char`\"{} element that provides the information required to impose the appropriate boundary condition. Thus, the {\ttfamily Fourier\+Decomposed\+Helmholtz\+Flux\+From\+Normal\+Displacement\+BCElements} store pointers to the \char`\"{}adjacent\char`\"{} time-\/harmonic linear elasticity elements (from which they obtain the boundary displacement required for the imposition of (6)), while the {\ttfamily Fourier\+Decomposed\+Time\+Harmonic\+Lin\+Elast\+Loaded\+By\+Helmholtz\+Pressure\+BCElements} store pointers to the \char`\"{}adjacent\char`\"{} Helmholtz elements that provide the value of the displacement potential required for the evaluation of (5).

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{multi_physics}
\doxyfigcaption{Sketch illustrating the imposition of flux and traction boundary conditions in the coupled multi-\/physics problem. The continuous problems are shown on the left; the discretised ones on the right. }
\end{DoxyImage}


The identification of the \char`\"{}adjacent\char`\"{} bulk elements can be performed using the {\ttfamily Multi\+\_\+domain\+\_\+functions\+::setup\+\_\+bulk\+\_\+elements\+\_\+adjacent\+\_\+to\+\_\+face\+\_\+mesh(...)} helper function. We note that, as suggested by the sketch above, this function does not require to the two adjacent meshes to have a consistent discretisation -- the identification of adjacent elements is based entirely on the (assumed to be consistent) boundary coordinate $ \zeta $ in the two meshes. We refer to \href{../../../poisson/fish_poisson2/html/index.html\#boundary_coords}{\texttt{ another tutorial}} for a discussion of how to set up (or change) the parametrisation of mesh boundaries by boundary coordinates.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_results}{}\doxysection{Results}\label{index_results}
The animation below shows the deformation of the elastic coating if a non-\/spherically symmetric displacement \[ \mbox{\bf u} = \epsilon \, \mbox{\bf e}_{r_{\rm sphere}} \cos (M\theta) \mbox{\ \ \ \ \ on $\partial D_{\rm s}$}, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (8) \] (for $ M=4 $) where $ \theta $ is the zenith angle, is imposed on the inner boundary of the coating $\partial D_{\rm s}$.

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{anim}
\doxyfigcaption{Animation showing the time-\/harmonic oscillation of the elastic coating. (The pink region in the background shows the undeformed configuration.) }
\end{DoxyImage}


Here is a plot of the corresponding pressure field\+:

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{potential}
\doxyfigcaption{Plot of the displacement potential (a measure of the fluid pressure). The elevation in the carpet plot indicates the real part; the colour contours represent the imaginary part. }
\end{DoxyImage}


Finally, we provide some validation of the computational results by comparing the non-\/dimensional time-\/average radiated power \[ \overline{\cal P }_N = \frac{\overline{\cal P }^*_N}{\rho_{\rm f} \omega^3 {\cal L}^5} \] (see \mbox{\hyperlink{index_appendix}{Appendix\+: The time-\/averaged radiated power}} for details) against the analytical solution for spherically symmetric forcing ( $ N=0, M=0 $) for the parameter values $ k^2 = 10 $, $ \rho_{\rm solid}/\rho_{\rm fluid} =1.0 $, $ \nu =0.3 $ and a non-\/dimensional coating thickness of $ h = 0.2. $

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{trace}
\doxyfigcaption{Radiated power as function of the FSI parameter Q for a spherically-\/symmetrically oscillating coating. Markers\+: computed results; continuous line\+: analytical result. }
\end{DoxyImage}


 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{comp_phi_re}
\doxyfigcaption{Real part of the fluid displacement potential (a measure of the fluid pressure) for Q=10. Shaded\+: computed; spheres\+: exact. }
\end{DoxyImage}


 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{comp_phi_im}
\doxyfigcaption{Imaginary part of the fluid displacement potential (a measure of the fluid pressure) for Q=10. Shaded\+: computed; spheres\+: exact. }
\end{DoxyImage}


 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{comp_ur_re}
\doxyfigcaption{Real part of the radial solid displacement for Q=10. Shaded\+: computed; spheres\+: exact. }
\end{DoxyImage}


 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{comp_ur_im}
\doxyfigcaption{Imaginary part of the radial solid displacement for Q=10. Shaded\+: computed; spheres\+: exact. }
\end{DoxyImage}


 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{comp_uz_re}
\doxyfigcaption{Real part of the axial solid displacement for Q=10. Shaded\+: computed; spheres\+: exact. }
\end{DoxyImage}


 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{comp_uz_im}
\doxyfigcaption{Imaginary part of the axial solid displacement for Q=10. Shaded\+: computed; spheres\+: exact. }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_num_soln}{}\doxysection{The numerical solution}\label{index_num_soln}
\hypertarget{index_namespace}{}\doxysubsection{The global namespace}\label{index_namespace}
As usual we define the problem parameters in a namespace. (\href{../../../time_harmonic_fourier_decomposed_linear_elasticity/cylinder/html/index.html\#comments}{\texttt{ Recall}} that we allow the constitutive parameters to be complex-\/valued.)  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=======start\_of\_namespace==========================================}}
\DoxyCodeLine{\textcolor{comment}{/// Global variables}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//===================================================================}}
\DoxyCodeLine{\textcolor{keyword}{namespace }\mbox{\hyperlink{namespaceGlobal__Parameters}{Global\_Parameters}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Square of wavenumber for the Helmholtz equation}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobal__Parameters_a91a3fa265abaf9e724c668ee800ffb29}{K\_squared}}=10.0;}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Radius of outer boundary of Helmholtz domain}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobal__Parameters_a88ded445ecd7bd89701409e68fd0b900}{Outer\_radius}}=2.0; }
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// FSI parameter}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Q}}=10.0;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Non-\/dim thickness of elastic coating}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobal__Parameters_ae3cf8878ede839bffda01f79bbe3e819}{H\_coating}}=0.2; }
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Define azimuthal Fourier wavenumber}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{int} \mbox{\hyperlink{namespaceGlobal__Parameters_ae1198385d90f52c4ed921520ae43a9e7}{Fourier\_wavenumber}}=0;}
\DoxyCodeLine{   \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Poisson's ratio Nu}}
\DoxyCodeLine{\textcolor{comment}{} std::complex<double> \mbox{\hyperlink{namespaceGlobal__Parameters_a373950a959cd784c8f8028099807c2fb}{Nu}}(std::complex<double>(0.3,0.0));}

\end{DoxyCodeInclude}
 We wish to perform parameter studies in which we vary the FSI parameter $ Q $. To make this physically meaningful, we interpret $ Q =(\rho_{\rm f}({\cal L}\omega)^2)/E $ as a measure of the stiffness of the elastic coating (so that an increase in $ Q $ corresponds to a reduction in the layer\textquotesingle{}s elastic modulus $ E $). In that case, the frequency parameter $ \Omega^2 = (\rho_{\rm s} (\omega {\cal L})^2)/E $ in the time-\/harmonic linear elasticity equations becomes a dependent parameter and is given in terms of the density ratio $ \rho_{\rm solid}/\rho_{\rm fluid} $ and $ Q $ by $ \Omega^2 = (\rho_{\rm solid}/\rho_{\rm fluid}) Q$. We therefore provide a helper function to update the dependent parameter following any change in the independent parameters.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Non-\/dim square of frequency for solid -\/-\/ dependent variable!}}
\DoxyCodeLine{\textcolor{comment}{} std::complex<double>  \mbox{\hyperlink{namespaceGlobal__Parameters_a91314f7f1cc80c43543948568f50f405}{Omega\_sq}}(std::complex<double>(100.0,0.0));}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Density ratio: solid to fluid}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Density\_ratio}}=1.0; }
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Function to update dependent parameter values}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespaceGlobal__Parameters_ae0f9a80fb7510dbfbbef22582da231b7}{update\_parameter\_values}}()}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \mbox{\hyperlink{namespaceGlobal__Parameters_a91314f7f1cc80c43543948568f50f405}{Omega\_sq}}=\mbox{\hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Density\_ratio}}*\mbox{\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Q}};}
\DoxyCodeLine{ \}}

\end{DoxyCodeInclude}
 We force the system by imposing a prescribed displacement on the inner surface of the elastic coating and allow this to vary in the \char`\"{}zenith\char`\"{}-\/direction with wavenumber $ M $\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Wavenumber "{}zenith"{}-\/variation of imposed displacement of coating}}
\DoxyCodeLine{\textcolor{comment}{ /// on inner boundary }}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{unsigned} \mbox{\hyperlink{namespaceGlobal__Parameters_abc67bb72ab99af013e3c7f6ffe453798}{M}}=4; }
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Displacement field on inner boundary of solid}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespaceGlobal__Parameters_ab51fa55d06d9963d363bcf966cfcc62b}{solid\_boundary\_displacement}}(\textcolor{keyword}{const} Vector<double>\& x,}
\DoxyCodeLine{                                  Vector<std::complex<double> >\& u)}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  Vector<double> normal(2);}
\DoxyCodeLine{  \textcolor{keywordtype}{double} norm=sqrt(x[0]*x[0]+x[1]*x[1]);}
\DoxyCodeLine{  \textcolor{keywordtype}{double} theta=atan2(x[1],x[0]);}
\DoxyCodeLine{  normal[0]=x[0]/norm;}
\DoxyCodeLine{  normal[1]=x[1]/norm;}
\DoxyCodeLine{}
\DoxyCodeLine{  u[0]=complex<double>(normal[0]*cos(\textcolor{keywordtype}{double}(\mbox{\hyperlink{namespaceGlobal__Parameters_abc67bb72ab99af013e3c7f6ffe453798}{M}})*theta),0.0);}
\DoxyCodeLine{  u[1]=complex<double>(normal[1]*cos(\textcolor{keywordtype}{double}(\mbox{\hyperlink{namespaceGlobal__Parameters_abc67bb72ab99af013e3c7f6ffe453798}{M}})*theta),0.0);}
\DoxyCodeLine{ \}}

\end{DoxyCodeInclude}
 Finally, we specify the output directory and a multiplier for the number of elements in the meshes to aid mesh convergence studies.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Output directory}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{string} \mbox{\hyperlink{namespaceGlobal__Parameters_a301ab922df72030c660b21328d6caf76}{Directory}}=\textcolor{stringliteral}{"{}RESLT"{}};}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Multiplier for number of elements}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{unsigned} \mbox{\hyperlink{namespaceGlobal__Parameters_a35d5d2ecfff0cec6150a5dc79e5c1ad1}{El\_multiplier}}=1;}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{//end\_of\_namespace}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysubsection{The driver code}\label{index_main}
The driver code is very straightforward. We parse the command line to determine the parameters for the parameter study and build the problem object, using nine-\/noded quadrilateral elements for the solution of the time-\/harmonic elasticity and Helmholtz equations.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=======start\_of\_main==================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Driver for coated sphere loaded by lineared fluid loading}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//======================================================================}}
\DoxyCodeLine{\textcolor{keywordtype}{int} \mbox{\hyperlink{fourier__decomposed__acoustic__fsi_8cc_a3c04138a5bfe5d72780bb7e82a18e627}{main}}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Store command line arguments}}
\DoxyCodeLine{ CommandLineArgs::setup(argc,argv);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Define possible command line arguments and parse the ones that}}
\DoxyCodeLine{ \textcolor{comment}{// were actually specified}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Output directory}}
\DoxyCodeLine{ CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"{}-\/-\/dir"{}},}
\DoxyCodeLine{                                            \&\mbox{\hyperlink{namespaceGlobal__Parameters_a301ab922df72030c660b21328d6caf76}{Global\_Parameters::Directory}});}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Parameter for the Helmholtz equation}}
\DoxyCodeLine{ CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"{}-\/-\/k\_squared"{}},}
\DoxyCodeLine{                                            \&\mbox{\hyperlink{namespaceGlobal__Parameters_a91a3fa265abaf9e724c668ee800ffb29}{Global\_Parameters::K\_squared}});}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Initial value of Q }}
\DoxyCodeLine{ CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"{}-\/-\/q\_initial"{}}, }
\DoxyCodeLine{                                            \&\mbox{\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q}});}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Number of steps in parameter study}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nstep=2;}
\DoxyCodeLine{ CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"{}-\/-\/nstep"{}},\&nstep);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Increment in FSI parameter in parameter study}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} q\_increment=5.0;}
\DoxyCodeLine{ CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"{}-\/-\/q\_increment"{}},\&q\_increment);}
\DoxyCodeLine{ }
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Wavenumber "{}zenith"{}-\/variation of imposed displacement of coating}}
\DoxyCodeLine{ \textcolor{comment}{// on inner boundary }}
\DoxyCodeLine{ CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"{}-\/-\/M"{}},}
\DoxyCodeLine{                                            \&\mbox{\hyperlink{namespaceGlobal__Parameters_abc67bb72ab99af013e3c7f6ffe453798}{Global\_Parameters::M}});}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Multiplier for number of elements}}
\DoxyCodeLine{ CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"{}-\/-\/el\_multiplier"{}},}
\DoxyCodeLine{                                            \&\mbox{\hyperlink{namespaceGlobal__Parameters_a35d5d2ecfff0cec6150a5dc79e5c1ad1}{Global\_Parameters::El\_multiplier}});}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Parse command line}}
\DoxyCodeLine{ CommandLineArgs::parse\_and\_assign(); }
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Doc what has actually been specified on the command line}}
\DoxyCodeLine{ CommandLineArgs::doc\_specified\_flags();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Update dependent parameters values}}
\DoxyCodeLine{ \mbox{\hyperlink{namespaceGlobal__Parameters_ae0f9a80fb7510dbfbbef22582da231b7}{Global\_Parameters::update\_parameter\_values}}();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set up doc info}}
\DoxyCodeLine{ DocInfo doc\_info;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Set output directory}}
\DoxyCodeLine{ doc\_info.set\_directory(\mbox{\hyperlink{namespaceGlobal__Parameters_a301ab922df72030c660b21328d6caf76}{Global\_Parameters::Directory}});}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Set up the problem}}
\DoxyCodeLine{ \mbox{\hyperlink{classCoatedSphereProblem}{CoatedSphereProblem<QTimeHarmonicFourierDecomposedLinearElasticityElement<3>}},}
\DoxyCodeLine{                     QFourierDecomposedHelmholtzElement<3> > problem;}

\end{DoxyCodeInclude}
 We then solve the problem for various values of $ Q $, updating the dependent variables after every increment.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{//Parameter incrementation}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<nstep;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Solve the problem with Newton's method}}
\DoxyCodeLine{   problem.newton\_solve();}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Doc solution}}
\DoxyCodeLine{   problem.\mbox{\hyperlink{classCoatedSphereProblem_aaeade2a110160c002b2b45954a5a0edc}{doc\_solution}}(doc\_info);}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Increment FSI parameter}}
\DoxyCodeLine{   \mbox{\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q}}+=q\_increment;}
\DoxyCodeLine{   \mbox{\hyperlink{namespaceGlobal__Parameters_ae0f9a80fb7510dbfbbef22582da231b7}{Global\_Parameters::update\_parameter\_values}}();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{//end\_of\_main}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_class}{}\doxysubsection{The problem class}\label{index_class}
The {\ttfamily Problem} class is templated by the types of the \char`\"{}bulk\char`\"{} elements used to discretise the Fourier-\/decomposed time-\/harmonic linear elasticity and Helmholtz equations, respectively. It contains the usual member functions to attach {\ttfamily Face\+Elements} to the bulk meshes in order to apply the various Neumann boundary conditions. We note that the costly recomputation of the $ \gamma- $ integral in the Dirichlet-\/to-\/\+Neumann mapping before the Newton convergence check (implemented in {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()}) can be avoided by declaring the problem to be linear; see the discussion in the \href{../../../fourier_decomposed_helmholtz/sphere_scattering/html/index.html\#DtN}{\texttt{ Helmholtz tutorial}} and \mbox{\hyperlink{index_comm}{Comments}}.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=============start\_of\_problem\_class===================================}}
\DoxyCodeLine{\textcolor{comment}{/// Coated sphere FSI}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//====================================================================== }}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>}
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{classCoatedSphereProblem}{CoatedSphereProblem}} : \textcolor{keyword}{public} Problem}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Constructor:}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classCoatedSphereProblem_ab9c983e7f0bed66f13d59bd65d6d151b}{CoatedSphereProblem}}();}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update function (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classCoatedSphereProblem_aa268009485d4d2bb6b4856bfa318aaa9}{actions\_before\_newton\_solve}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update function (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classCoatedSphereProblem_ae5287efab54b16ec1bd5cced98971c9c}{actions\_after\_newton\_solve}}() \{\}}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Recompute gamma integral before checking Newton residuals}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classCoatedSphereProblem_a2f55bc904971ca96eb9af3451ef5b4c4}{actions\_before\_newton\_convergence\_check}}()}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \mbox{\hyperlink{classCoatedSphereProblem_abb33720ab0a096c5e1d6be33310bff21}{Helmholtz\_DtN\_mesh\_pt}}-\/>setup\_gamma();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Doc the solution}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classCoatedSphereProblem_aaeade2a110160c002b2b45954a5a0edc}{doc\_solution}}(DocInfo\& doc\_info);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Create FSI traction elements}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classCoatedSphereProblem_a2d342158b3058cd5392e2de3fd7595da}{create\_fsi\_traction\_elements}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Create Helmholtz FSI flux elements}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classCoatedSphereProblem_a9a301689052eefd53552aadc23ff893b}{create\_helmholtz\_fsi\_flux\_elements}}(); }
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Setup interaction}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classCoatedSphereProblem_aeea43c892871a6c65df992aedc3b3547}{setup\_interaction}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Create DtN elements on outer boundary}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classCoatedSphereProblem_a867f4ed706f00a73c87c2c862dcf19c3}{create\_helmholtz\_DtN\_elements}}();}

\end{DoxyCodeInclude}
 The private member data includes storage for the various meshes and objects that are used for outputting the results.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to solid mesh}}
\DoxyCodeLine{\textcolor{comment}{} TwoDAnnularMesh<ELASTICITY\_ELEMENT>* Solid\_mesh\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to mesh of FSI traction elements}}
\DoxyCodeLine{\textcolor{comment}{} Mesh* FSI\_traction\_mesh\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to Helmholtz mesh}}
\DoxyCodeLine{\textcolor{comment}{} TwoDAnnularMesh<HELMHOLTZ\_ELEMENT>* Helmholtz\_mesh\_pt;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to mesh of Helmholtz FSI flux elements}}
\DoxyCodeLine{\textcolor{comment}{} Mesh* Helmholtz\_fsi\_flux\_mesh\_pt;}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to mesh containing the DtN elements}}
\DoxyCodeLine{\textcolor{comment}{} FourierDecomposedHelmholtzDtNMesh<HELMHOLTZ\_ELEMENT>* Helmholtz\_DtN\_mesh\_pt;}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Trace file}}
\DoxyCodeLine{\textcolor{comment}{} ofstream Trace\_file;}
\DoxyCodeLine{}
\DoxyCodeLine{\};\textcolor{comment}{// end\_of\_problem\_class}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_constr}{}\doxysubsection{The problem constructor}\label{index_constr}
We start by building the meshes for the elasticity and Helmholtz equations. Both domains are half annular regions, so the annular mesh (which is built from a rectangular {\ttfamily Quad\+Mesh}) is not periodic but only occupies 180 degrees. The mesh also needs to be rotated by 90 degrees to align its ends with the $ z- $ axis\+:

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===========start\_of\_constructor======================================= }}
\DoxyCodeLine{\textcolor{comment}{/// Constructor: }}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//====================================================================== }}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>}
\DoxyCodeLine{\mbox{\hyperlink{classCoatedSphereProblem_ab9c983e7f0bed66f13d59bd65d6d151b}{CoatedSphereProblem<ELASTICITY\_ELEMENT, HELMHOLTZ\_ELEMENT>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classCoatedSphereProblem_ab9c983e7f0bed66f13d59bd65d6d151b}{CoatedSphereProblem}}() }
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Parameters for meshes}}
\DoxyCodeLine{ \textcolor{keywordtype}{bool} periodic=\textcolor{keyword}{false};}
\DoxyCodeLine{ \textcolor{keywordtype}{double} azimuthal\_fraction\_of\_coating=0.5;}
\DoxyCodeLine{ \textcolor{keywordtype}{double} phi=0.5*MathematicalConstants::Pi;}

\end{DoxyCodeInclude}
 The solid mesh occupies the region between $ r = 1-h $ and $ r=1 $ where $ h $ is the thickness of the elastic coating\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Solid mesh}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ \textcolor{comment}{// Number of elements in azimuthal direction}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} ntheta\_solid=10*\mbox{\hyperlink{namespaceGlobal__Parameters_a35d5d2ecfff0cec6150a5dc79e5c1ad1}{Global\_Parameters::El\_multiplier}};}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Number of elements in radial direction }}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nr\_solid=3*\mbox{\hyperlink{namespaceGlobal__Parameters_a35d5d2ecfff0cec6150a5dc79e5c1ad1}{Global\_Parameters::El\_multiplier}};}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Innermost radius for solid mesh}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} a=1.0-\/\mbox{\hyperlink{namespaceGlobal__Parameters_ae3cf8878ede839bffda01f79bbe3e819}{Global\_Parameters::H\_coating}};}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Build solid mesh}}
\DoxyCodeLine{ Solid\_mesh\_pt = \textcolor{keyword}{new} }
\DoxyCodeLine{  TwoDAnnularMesh<ELASTICITY\_ELEMENT>(periodic,azimuthal\_fraction\_of\_coating,}
\DoxyCodeLine{                                      ntheta\_solid,nr\_solid,a,}
\DoxyCodeLine{                                      \mbox{\hyperlink{namespaceGlobal__Parameters_ae3cf8878ede839bffda01f79bbe3e819}{Global\_Parameters::H\_coating}},phi);}

\end{DoxyCodeInclude}


The Helmholtz mesh occupies the region between $ r = 1 $ and $ r=R_{\rm outer} $ where $ R_{\rm outer}$ is the outer radius of the computational domain where we will apply the Sommerfeld radiation condition. Note that the two meshes are not matching -- both meshes have 3 element layers in the radial direction but 10 and 11 in the azimuthal direction, respectively. This is done mainly to illustrate our claim that the multi-\/domain setup functions can operate with non-\/matching meshes.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Helmholtz mesh}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Number of elements in azimuthal direction in Helmholtz mesh}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} ntheta\_helmholtz=11*\mbox{\hyperlink{namespaceGlobal__Parameters_a35d5d2ecfff0cec6150a5dc79e5c1ad1}{Global\_Parameters::El\_multiplier}};}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Number of elements in radial direction in Helmholtz mesh}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nr\_helmholtz=3*\mbox{\hyperlink{namespaceGlobal__Parameters_a35d5d2ecfff0cec6150a5dc79e5c1ad1}{Global\_Parameters::El\_multiplier}};}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Innermost radius of Helmholtz mesh}}
\DoxyCodeLine{ a=1.0;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Thickness of Helmholtz mesh}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} h\_thick\_helmholtz=\mbox{\hyperlink{namespaceGlobal__Parameters_a88ded445ecd7bd89701409e68fd0b900}{Global\_Parameters::Outer\_radius}}-\/a;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Build mesh}}
\DoxyCodeLine{ Helmholtz\_mesh\_pt = \textcolor{keyword}{new} TwoDAnnularMesh<HELMHOLTZ\_ELEMENT>}
\DoxyCodeLine{  (periodic,azimuthal\_fraction\_of\_coating,}
\DoxyCodeLine{   ntheta\_helmholtz,nr\_helmholtz,a,h\_thick\_helmholtz,phi);}

\end{DoxyCodeInclude}
 Next we create the mesh that will store the {\ttfamily Face\+Elements} that will apply the Sommerfeld radiation condition, using the specified number of Fourier terms in the Dirichlet-\/to-\/\+Neumann mapping; see the \href{../../../fourier_decomposed_helmholtz/sphere_scattering/html/index.html\#DtN}{\texttt{ Helmholtz tutorial}} for details.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Create mesh for DtN elements on outer boundary}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nfourier=20;}
\DoxyCodeLine{ Helmholtz\_DtN\_mesh\_pt=}
\DoxyCodeLine{  \textcolor{keyword}{new} FourierDecomposedHelmholtzDtNMesh<HELMHOLTZ\_ELEMENT>(}
\DoxyCodeLine{   \mbox{\hyperlink{namespaceGlobal__Parameters_a88ded445ecd7bd89701409e68fd0b900}{Global\_Parameters::Outer\_radius}},nfourier);}

\end{DoxyCodeInclude}
 Next we pass the problem parameters to the bulk elements. The elasticity elements require a pointer to Poisson\textquotesingle{}s ratio, $ \nu $, the azimuthal (Fourier) wavenumber $ N $, and the frequency parameter $ \Omega^2 $\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Complete the solid problem setup to make the elements fully functional}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nel=Solid\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<nel;e++)}
\DoxyCodeLine{  \{     }
\DoxyCodeLine{   \textcolor{comment}{// Cast to a bulk element}}
\DoxyCodeLine{   ELASTICITY\_ELEMENT* el\_pt=\textcolor{keyword}{dynamic\_cast<}ELASTICITY\_ELEMENT*\textcolor{keyword}{>}(}
\DoxyCodeLine{    Solid\_mesh\_pt-\/>element\_pt(e));}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Set the pointer to Fourier wavenumber}}
\DoxyCodeLine{   el\_pt-\/>fourier\_wavenumber\_pt() = \&\mbox{\hyperlink{namespaceGlobal__Parameters_ae1198385d90f52c4ed921520ae43a9e7}{Global\_Parameters::Fourier\_wavenumber}};}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Set the pointer to Poisson's ratio}}
\DoxyCodeLine{   el\_pt-\/>nu\_pt() = \&\mbox{\hyperlink{namespaceGlobal__Parameters_a373950a959cd784c8f8028099807c2fb}{Global\_Parameters::Nu}};}
\DoxyCodeLine{      }
\DoxyCodeLine{   \textcolor{comment}{// Set the pointer to square of the angular frequency}}
\DoxyCodeLine{   el\_pt-\/>omega\_sq\_pt() = \&\mbox{\hyperlink{namespaceGlobal__Parameters_a91314f7f1cc80c43543948568f50f405}{Global\_Parameters::Omega\_sq}};}
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
 The Helmholtz elements need a pointer to the (square of the) wavenumber, $ k^2 $ and the azimuthal (Fourier) wavenumber $ N $\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Complete the build of all Helmholtz elements so they are fully functional}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_element = Helmholtz\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Upcast from GeneralsedElement to the present element}}
\DoxyCodeLine{   HELMHOLTZ\_ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}HELMHOLTZ\_ELEMENT*\textcolor{keyword}{>}(}
\DoxyCodeLine{    Helmholtz\_mesh\_pt-\/>element\_pt(i));}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{//Set the k\_squared pointer}}
\DoxyCodeLine{   el\_pt-\/>k\_squared\_pt()=\&\mbox{\hyperlink{namespaceGlobal__Parameters_a91a3fa265abaf9e724c668ee800ffb29}{Global\_Parameters::K\_squared}};}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Set pointer to Fourier wave number}}
\DoxyCodeLine{   el\_pt-\/>fourier\_wavenumber\_pt()=\&\mbox{\hyperlink{namespaceGlobal__Parameters_ae1198385d90f52c4ed921520ae43a9e7}{Global\_Parameters::Fourier\_wavenumber}};}
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
 It is always a good idea to check the enumeration of the mesh boundaries to facilitate the application of boundary conditions\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Output meshes and their boundaries so far so we can double }}
\DoxyCodeLine{ \textcolor{comment}{// check the boundary enumeration}}
\DoxyCodeLine{ Solid\_mesh\_pt-\/>output(\textcolor{stringliteral}{"{}solid\_mesh.dat"{}});}
\DoxyCodeLine{ Helmholtz\_mesh\_pt-\/>output(\textcolor{stringliteral}{"{}helmholtz\_mesh.dat"{}});}
\DoxyCodeLine{ Solid\_mesh\_pt-\/>output\_boundaries(\textcolor{stringliteral}{"{}solid\_mesh\_boundary.dat"{}});}
\DoxyCodeLine{ Helmholtz\_mesh\_pt-\/>output\_boundaries(\textcolor{stringliteral}{"{}helmholtz\_mesh\_boundary.dat"{}});}

\end{DoxyCodeInclude}
 Next we create the meshes containing the various {\ttfamily Face\+Elements} used to apply to the FSI traction boundary condition (5), the FSI flux boundary condition (6) for the Helmholtz equation, and the Sommerfeld radiation condition (7), respectively, using helper functions discussed below.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Create FaceElement meshes for boundary conditions}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Construct the fsi traction element mesh}}
\DoxyCodeLine{ FSI\_traction\_mesh\_pt=\textcolor{keyword}{new} Mesh;}
\DoxyCodeLine{ create\_fsi\_traction\_elements();}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Construct the Helmholtz fsi flux element mesh}}
\DoxyCodeLine{ Helmholtz\_fsi\_flux\_mesh\_pt=\textcolor{keyword}{new} Mesh;}
\DoxyCodeLine{ create\_helmholtz\_fsi\_flux\_elements();}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Create DtN elements}}
\DoxyCodeLine{ create\_helmholtz\_DtN\_elements();}

\end{DoxyCodeInclude}


We add the various sub-\/meshes to the problem and build the global mesh


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Combine sub meshes}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ add\_sub\_mesh(Solid\_mesh\_pt);}
\DoxyCodeLine{ add\_sub\_mesh(FSI\_traction\_mesh\_pt);}
\DoxyCodeLine{ add\_sub\_mesh(Helmholtz\_mesh\_pt);}
\DoxyCodeLine{ add\_sub\_mesh(Helmholtz\_fsi\_flux\_mesh\_pt);}
\DoxyCodeLine{ add\_sub\_mesh(Helmholtz\_DtN\_mesh\_pt); }
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Build the Problem's global mesh from its various sub-\/meshes}}
\DoxyCodeLine{ build\_global\_mesh();}

\end{DoxyCodeInclude}
 The solid displacements are prescribed on the inner boundary (boundary 0) of the solid mesh so we pin all six values (representing the real and imaginary parts of the displacements in the $ r-, z- $ and $ \varphi- $ directions, respectively) and assign the boundary values using the function {\ttfamily Global\+\_\+\+Parameters\+::solid\+\_\+boundary\+\_\+displacement(...)}. (The enumeration of the unknowns in the Fourier-\/decomposed equations time-\/harmonic linear elasticity is discussed in \href{../../../time_harmonic_fourier_decomposed_linear_elasticity/cylinder/html/index.html\#element_types}{\texttt{ another tutorial}}.)


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Solid boundary conditions:}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Pin the solid inner boundary (boundary 0) in all directions}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} b=0;}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_node = Solid\_mesh\_pt-\/>nboundary\_node(b);}
\DoxyCodeLine{ }
\DoxyCodeLine{ Vector<std::complex<double> > u(2);}
\DoxyCodeLine{ Vector<double> x(2);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{//Loop over the nodes to pin and assign boundary displacements on }}
\DoxyCodeLine{ \textcolor{comment}{//solid boundary}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_node;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   Node* nod\_pt=Solid\_mesh\_pt-\/>boundary\_node\_pt(b,i);}
\DoxyCodeLine{   nod\_pt-\/>pin(0);}
\DoxyCodeLine{   nod\_pt-\/>pin(1);}
\DoxyCodeLine{   nod\_pt-\/>pin(2);}
\DoxyCodeLine{   nod\_pt-\/>pin(3);}
\DoxyCodeLine{   nod\_pt-\/>pin(4);}
\DoxyCodeLine{   nod\_pt-\/>pin(5);}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Assign prescribed displacements}}
\DoxyCodeLine{   x[0]=nod\_pt-\/>x(0);}
\DoxyCodeLine{   x[1]=nod\_pt-\/>x(1);}
\DoxyCodeLine{   \mbox{\hyperlink{namespaceGlobal__Parameters_ab51fa55d06d9963d363bcf966cfcc62b}{Global\_Parameters::solid\_boundary\_displacement}}(x,u);}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Real part of radial displacement}}
\DoxyCodeLine{   nod\_pt-\/>set\_value(0,u[0].real());}
\DoxyCodeLine{   \textcolor{comment}{// Real part of axial displacement}}
\DoxyCodeLine{   nod\_pt-\/>set\_value(1,u[1].real());}
\DoxyCodeLine{   \textcolor{comment}{// Real part of azimuthal displacement}}
\DoxyCodeLine{   nod\_pt-\/>set\_value(2,0.0);}
\DoxyCodeLine{   \textcolor{comment}{// Imag part of radial displacement}}
\DoxyCodeLine{   nod\_pt-\/>set\_value(3,u[0].imag());}
\DoxyCodeLine{   \textcolor{comment}{// Imag part of axial displacement}}
\DoxyCodeLine{   nod\_pt-\/>set\_value(4,u[1].imag());}
\DoxyCodeLine{   \textcolor{comment}{// Imag part of azimuthal displacement}}
\DoxyCodeLine{   nod\_pt-\/>set\_value(5,0.0);}
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
 The radial and azimuthal displacements have to vanish on the symmetry boundary (boundaries 1 and 3)\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Vertical Symmetry boundary (r=0 and z<0)}}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{keywordtype}{unsigned} ibound=1;}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} num\_nod= Solid\_mesh\_pt-\/>nboundary\_node(ibound);}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{comment}{// Get pointer to node}}
\DoxyCodeLine{     Node* nod\_pt=Solid\_mesh\_pt-\/>boundary\_node\_pt(ibound,inod);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Pin radial displacement (u\_0 (real) and u\_3 (imag))}}
\DoxyCodeLine{     nod\_pt-\/>pin(0);}
\DoxyCodeLine{     nod\_pt-\/>set\_value(0,0.0);}
\DoxyCodeLine{     nod\_pt-\/>pin(3);}
\DoxyCodeLine{     nod\_pt-\/>set\_value(3,0.0);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Pin azimuthal displacement (u\_2 (real) and u\_5 (imag))}}
\DoxyCodeLine{     nod\_pt-\/>pin(2);}
\DoxyCodeLine{     nod\_pt-\/>set\_value(2,0.0);}
\DoxyCodeLine{     nod\_pt-\/>pin(5);}
\DoxyCodeLine{     nod\_pt-\/>set\_value(5,0.0);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ \}}
\DoxyCodeLine{ }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Vertical Symmetry boundary (r=0 and z>0)}}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  \textcolor{keywordtype}{unsigned} ibound=3;}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} num\_nod= Solid\_mesh\_pt-\/>nboundary\_node(ibound);}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{comment}{// Get pointer to node}}
\DoxyCodeLine{     Node* nod\_pt=Solid\_mesh\_pt-\/>boundary\_node\_pt(ibound,inod);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Pin radial displacement (u\_0 (real) and u\_3 (imag))}}
\DoxyCodeLine{     nod\_pt-\/>pin(0);}
\DoxyCodeLine{     nod\_pt-\/>set\_value(0,0.0);}
\DoxyCodeLine{     nod\_pt-\/>pin(3);}
\DoxyCodeLine{     nod\_pt-\/>set\_value(3,0.0);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Pin azimuthal displacement (u\_2 (real) and u\_5 (imag))}}
\DoxyCodeLine{     nod\_pt-\/>pin(2);}
\DoxyCodeLine{     nod\_pt-\/>set\_value(2,0.0);}
\DoxyCodeLine{     nod\_pt-\/>pin(5);}
\DoxyCodeLine{     nod\_pt-\/>set\_value(5,0.0);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ \} \textcolor{comment}{// done sym bc}}

\end{DoxyCodeInclude}
 Finally, we set up the fluid-\/structure interaction, assign the equation numbers and open a trace file to record the radiated power as a function of the FSI parameter $ Q $.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup fluid-\/structure interaction}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ setup\_interaction();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Open trace file}}
\DoxyCodeLine{ \textcolor{keywordtype}{char} filename[100];}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/trace.dat"{}},\mbox{\hyperlink{namespaceGlobal__Parameters_a301ab922df72030c660b21328d6caf76}{Global\_Parameters::Directory}}.c\_str());}
\DoxyCodeLine{ Trace\_file.open(filename);}
\DoxyCodeLine{  }
\DoxyCodeLine{ \textcolor{comment}{// Setup equation numbering scheme}}
\DoxyCodeLine{ cout <<\textcolor{stringliteral}{"{}Number of equations: "{}} << assign\_eqn\_numbers() << std::endl; }
\DoxyCodeLine{}
\DoxyCodeLine{\}\textcolor{comment}{//end\_of\_constructor}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_create_flux}{}\doxysubsection{Creating the FSI traction elements (and the FSI flux and Dt\+N elements)}\label{index_create_flux}
The function {\ttfamily create\+\_\+fsi\+\_\+traction\+\_\+elements()} creates the {\ttfamily Face\+Elements} required to apply the FSI traction boundary condition (5) on the outer boundary (boundary 2) of the solid mesh\+:

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//============start\_of\_create\_fsi\_traction\_elements======================}}
\DoxyCodeLine{\textcolor{comment}{/// Create fsi traction elements }}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//=======================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classCoatedSphereProblem_a2d342158b3058cd5392e2de3fd7595da}{CoatedSphereProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classCoatedSphereProblem_a2d342158b3058cd5392e2de3fd7595da}{create\_fsi\_traction\_elements}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{// We're on boundary 2 of the solid mesh}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} b=2;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_element = Solid\_mesh\_pt-\/>nboundary\_element(b);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}}
\DoxyCodeLine{   ELASTICITY\_ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELASTICITY\_ELEMENT*\textcolor{keyword}{>}(}
\DoxyCodeLine{    Solid\_mesh\_pt-\/>boundary\_element\_pt(b,e));}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{//Find the index of the face of element e along boundary b}}
\DoxyCodeLine{   \textcolor{keywordtype}{int} face\_index = Solid\_mesh\_pt-\/>face\_index\_at\_boundary(b,e);}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Create element}}
\DoxyCodeLine{   FourierDecomposedTimeHarmonicLinElastLoadedByHelmholtzPressureBCElement}
\DoxyCodeLine{    <ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>* el\_pt=}
\DoxyCodeLine{    \textcolor{keyword}{new} FourierDecomposedTimeHarmonicLinElastLoadedByHelmholtzPressureBCElement}
\DoxyCodeLine{    <ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>(bulk\_elem\_pt,}
\DoxyCodeLine{                                           face\_index);   }
\DoxyCodeLine{   \textcolor{comment}{// Add to mesh}}
\DoxyCodeLine{   FSI\_traction\_mesh\_pt-\/>add\_element\_pt(el\_pt);}

\end{DoxyCodeInclude}
 To function properly, the elements need to know the number of the bulk mesh boundary they are attached to (this allows them to determine the boundary coordinate $ \zeta $ required to set up the fluid-\/structure interaction; see \mbox{\hyperlink{index_impl}{Implementation}} ), and the FSI parameter $ Q $.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Associate element with bulk boundary (to allow it to access}}
\DoxyCodeLine{   \textcolor{comment}{// the boundary coordinates in the bulk mesh)}}
\DoxyCodeLine{   el\_pt-\/>set\_boundary\_number\_in\_bulk\_mesh(b); }
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Set FSI parameter}}
\DoxyCodeLine{   el\_pt-\/>q\_pt()=\&\mbox{\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q}};}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ }
\DoxyCodeLine{\} \textcolor{comment}{// end\_of\_create\_fsi\_traction\_elements}}

\end{DoxyCodeInclude}


\mbox{[}{\bfseries{Note\+:}} We omit the listings of the functions {\ttfamily create\+\_\+helmholtz\+\_\+fsi\+\_\+flux\+\_\+elements()} and {\ttfamily create\+\_\+helmholtz\+\_\+\+Dt\+N\+\_\+elements()} which create the {\ttfamily Face\+Elements} required to apply the FSI flux boundary condition (6) on the inner boundary (boundary 0), and the Sommerfeld radiation condition (7) on the outer boundary (boundary 2) of the Helmholtz mesh because they are very similar. Feel free to inspect the ~\newline
 \href{../../../../demo_drivers/interaction/fourier_decomposed_acoustic_fsi/fourier_decomposed_acoustic_fsi.cc}{\texttt{ source code.}}\mbox{]}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_fsi}{}\doxysubsection{Setting up the fluid-\/structure interaction}\label{index_fsi}
The setup of the fluid-\/structure interaction requires the identification of the \char`\"{}bulk\char`\"{} Helmholtz elements that are adjacent to (the Gauss points of) the {\ttfamily Face\+Elements} that impose the FSI traction boundary condition (5), in terms of the displacement potential $ \phi $ computed by these \char`\"{}bulk\char`\"{} elements. This can be done using the helper function {\ttfamily Multi\+\_\+domain\+\_\+functions\+::setup\+\_\+bulk\+\_\+elements\+\_\+adjacent\+\_\+to\+\_\+face\+\_\+mesh(...)} which is templated by the type of the \char`\"{}bulk\char`\"{} element and its spatial dimension, and takes as arguments\+:
\begin{DoxyItemize}
\item a pointer to the {\ttfamily Problem},
\item the boundary ID of the FSI boundary in the \char`\"{}bulk\char`\"{} mesh,
\item a pointer to that mesh,
\item a pointer to the mesh of {\ttfamily Face\+Elements}.
\end{DoxyItemize}Nearly a one-\/liner (if you ignore the optional output of the boundary coordinate which allows us to check that the FSI boundaries of the fluid and solid domains have been parametrised consistently).

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====================start\_of\_setup\_interaction======================}}
\DoxyCodeLine{\textcolor{comment}{/// Setup interaction between two fields}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classCoatedSphereProblem_aeea43c892871a6c65df992aedc3b3547}{CoatedSphereProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classCoatedSphereProblem_aeea43c892871a6c65df992aedc3b3547}{setup\_interaction}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup Helmholtz "{}pressure"{} load on traction elements}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} boundary\_in\_helmholtz\_mesh=0;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Doc boundary coordinate for Helmholtz}}
\DoxyCodeLine{ ofstream the\_file;}
\DoxyCodeLine{ the\_file.open(\textcolor{stringliteral}{"{}boundary\_coordinate\_hh.dat"{}});}
\DoxyCodeLine{ Helmholtz\_mesh\_pt-\/>Mesh::template doc\_boundary\_coordinates<HELMHOLTZ\_ELEMENT>}
\DoxyCodeLine{  (boundary\_in\_helmholtz\_mesh, the\_file);}
\DoxyCodeLine{ the\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup interaction}}
\DoxyCodeLine{  Multi\_domain\_functions::setup\_bulk\_elements\_adjacent\_to\_face\_mesh}
\DoxyCodeLine{  <HELMHOLTZ\_ELEMENT,2>}
\DoxyCodeLine{  (\textcolor{keyword}{this},boundary\_in\_helmholtz\_mesh,Helmholtz\_mesh\_pt,FSI\_traction\_mesh\_pt);}

\end{DoxyCodeInclude}
 Exactly the same method can be used for the identification of the \char`\"{}bulk\char`\"{} elasticity elements that are adjacent to (the Gauss points of) the {\ttfamily Face\+Elements} that impose the FSI flux boundary condition (6), using the displacement $ {\bf u} $ computed by these \char`\"{}bulk\char`\"{} elements\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup Helmholtz flux from normal displacement interaction}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} boundary\_in\_solid\_mesh=2;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Doc boundary coordinate for solid mesh}}
\DoxyCodeLine{ the\_file.open(\textcolor{stringliteral}{"{}boundary\_coordinate\_solid.dat"{}});}
\DoxyCodeLine{ Solid\_mesh\_pt-\/>Mesh::template doc\_boundary\_coordinates<ELASTICITY\_ELEMENT>}
\DoxyCodeLine{  (boundary\_in\_solid\_mesh, the\_file);}
\DoxyCodeLine{ the\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup interaction}}
\DoxyCodeLine{ Multi\_domain\_functions::setup\_bulk\_elements\_adjacent\_to\_face\_mesh}
\DoxyCodeLine{  <ELASTICITY\_ELEMENT,2>(}
\DoxyCodeLine{   \textcolor{keyword}{this},boundary\_in\_solid\_mesh,Solid\_mesh\_pt,Helmholtz\_fsi\_flux\_mesh\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{\}\textcolor{comment}{// end\_of\_setup\_interaction}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_doc}{}\doxysubsection{Post-\/processing}\label{index_doc}
The post-\/processing function {\ttfamily doc\+\_\+solution(...)} computes and outputs the total radiated power, and plots the computed solutions (real and imaginary parts) for all fields.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==============start\_of\_doc\_solution===============================}}
\DoxyCodeLine{\textcolor{comment}{/// Doc the solution}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//==================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classCoatedSphereProblem_aaeade2a110160c002b2b45954a5a0edc}{CoatedSphereProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classCoatedSphereProblem_aaeade2a110160c002b2b45954a5a0edc}{doc\_solution}}(DocInfo\& doc\_info)}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Doc parameters}}
\DoxyCodeLine{ oomph\_info << \textcolor{stringliteral}{"{}Writing result for step "{}} << doc\_info.number() }
\DoxyCodeLine{            << \textcolor{stringliteral}{"{}. Parameters: "{}}<< std::endl;}
\DoxyCodeLine{ oomph\_info << \textcolor{stringliteral}{"{}Fourier mode number : N = "{}}}
\DoxyCodeLine{            << \mbox{\hyperlink{namespaceGlobal__Parameters_ae1198385d90f52c4ed921520ae43a9e7}{Global\_Parameters::Fourier\_wavenumber}} << std::endl;}
\DoxyCodeLine{ oomph\_info << \textcolor{stringliteral}{"{}FSI parameter : Q = "{}} << \mbox{\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q}} << std::endl;}
\DoxyCodeLine{ oomph\_info << \textcolor{stringliteral}{"{}Fluid outer radius : R = "{}} << \mbox{\hyperlink{namespaceGlobal__Parameters_a88ded445ecd7bd89701409e68fd0b900}{Global\_Parameters::Outer\_radius}}}
\DoxyCodeLine{            << std::endl;}
\DoxyCodeLine{ oomph\_info << \textcolor{stringliteral}{"{}Fluid wavenumber : k\string^2 = "{}} << \mbox{\hyperlink{namespaceGlobal__Parameters_a91a3fa265abaf9e724c668ee800ffb29}{Global\_Parameters::K\_squared}}}
\DoxyCodeLine{            << std::endl;}
\DoxyCodeLine{ oomph\_info << \textcolor{stringliteral}{"{}Solid wavenumber : Omega\_sq = "{}} << \mbox{\hyperlink{namespaceGlobal__Parameters_a91314f7f1cc80c43543948568f50f405}{Global\_Parameters::Omega\_sq}} }
\DoxyCodeLine{            << std::endl << std::endl; }
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ ofstream some\_file,some\_file2;}
\DoxyCodeLine{ \textcolor{keywordtype}{char} filename[100];}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Number of plot points}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_plot=5; }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Compute/output the radiated power}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/power\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Accumulate contribution from elements}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} power=0.0;}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nn\_element=Helmholtz\_DtN\_mesh\_pt-\/>nelement(); }
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<nn\_element;e++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   FourierDecomposedHelmholtzBCElementBase<HELMHOLTZ\_ELEMENT> *el\_pt = }
\DoxyCodeLine{    \textcolor{keyword}{dynamic\_cast<}FourierDecomposedHelmholtzBCElementBase<HELMHOLTZ\_ELEMENT>*\textcolor{keyword}{>}(}
\DoxyCodeLine{     Helmholtz\_DtN\_mesh\_pt-\/>element\_pt(e)); }
\DoxyCodeLine{   power += el\_pt-\/>global\_power\_contribution(some\_file);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{ oomph\_info << \textcolor{stringliteral}{"{}Radiated power: "{}} << power << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Output displacement field}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/elast\_soln\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ Solid\_mesh\_pt-\/>output(some\_file,n\_plot);}
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Output Helmholtz}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/helmholtz\_soln\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ Helmholtz\_mesh\_pt-\/>output(some\_file,n\_plot);}
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Output fsi traction elements}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ }}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/fsi\_traction\_soln\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ FSI\_traction\_mesh\_pt-\/>output(some\_file,n\_plot);}
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Output Helmholtz fsi flux elements}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ }}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/fsi\_flux\_bc\_soln\%i.dat"{}},doc\_info.directory().c\_str(),}
\DoxyCodeLine{         doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ Helmholtz\_fsi\_flux\_mesh\_pt-\/>output(some\_file,n\_plot);}
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Write trace file}}
\DoxyCodeLine{ Trace\_file << \mbox{\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q}} << \textcolor{stringliteral}{"{} "{}} }
\DoxyCodeLine{            << \mbox{\hyperlink{namespaceGlobal__Parameters_a91a3fa265abaf9e724c668ee800ffb29}{Global\_Parameters::K\_squared}} << \textcolor{stringliteral}{"{} "{}}}
\DoxyCodeLine{            << \mbox{\hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}} << \textcolor{stringliteral}{"{} "{}}}
\DoxyCodeLine{            << \mbox{\hyperlink{namespaceGlobal__Parameters_a91314f7f1cc80c43543948568f50f405}{Global\_Parameters::Omega\_sq}}.real() << \textcolor{stringliteral}{"{} "{}}}
\DoxyCodeLine{            << power << \textcolor{stringliteral}{"{} "{}} }
\DoxyCodeLine{            << std::endl;}
\DoxyCodeLine{   }
\DoxyCodeLine{ \textcolor{comment}{// Bump up counter}}
\DoxyCodeLine{ doc\_info.number()++;}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{//end\_of\_doc\_solution}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comm_ex}{}\doxysection{Comments and Exercises}\label{index_comm_ex}
\hypertarget{index_comm}{}\doxysubsection{Comments}\label{index_comm}

\begin{DoxyItemize}
\item The application of the Sommerfeld radiation condition via a Dirichlet-\/to-\/\+Neumann mapping is discussed in detail in \href{../../../fourier_decomposed_helmholtz/sphere_scattering/html/index.html\#DtN}{\texttt{ another tutorial.}} We explain there that, because the $ \gamma $ integral depends on the solution, it must be recomputed whenever the unknowns are updated during the Newton iteration. This is best done by adding a call to {\ttfamily Fourier\+Decomposed\+Helmholtz\+Dt\+NMesh\+::setup\+\_\+gamma()} to {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()} as done in the driver code listed above. However, if Helmholtz\textquotesingle{}s equation is solved in isolation (or within a coupled, but linear problem as in the present case ), the Newton method is guaranteed to converge in one iteration. In such cases the unnecessary recomputation of $ \gamma $ after the one-\/and-\/only Newton iteration can be suppressed by setting {\ttfamily Problem\+::\+Problem\+\_\+is\+\_\+nonlinear} to {\ttfamily false} -- in that case, {\ttfamily oomph-\/lib\textquotesingle{}s} Newton solver skips the convergence check in the Newton iteration and simply accepts the solution obtained after one linear solve.
\item You may have noticed that, unlike the tutorial for the \href{../../../acoustic_fsi/acoustic_fsi_annulus/html/index.html}{\texttt{ cartesian counterpart}} of the model problem considered here, we neither demonstrate how to apply the Sommerfeld radiation condition by approximate/absorbing boundary conditions (ABCs), nor do we demonstrate the use of spatial adaptivity. This is because the relevant elements have not (yet!) been written (Any volunteers?). If you wish to enable spatial adaptivity we suggest using an unstructured adaptive mesh, using the methodology demonstrated in \href{../../../fourier_decomposed_acoustic_fsi/unstructured_sphere/html/index.html\#DtN}{\texttt{ another tutorial.}}
\end{DoxyItemize}

\DoxyHorRuler{0}
\hypertarget{index_ex}{}\doxysubsection{Exercises}\label{index_ex}

\begin{DoxyItemize}
\item As shown in the \mbox{\hyperlink{index_appendix}{Appendix\+: The time-\/averaged radiated power}}, the time-\/averaged radiated power $ \overline{\cal P}$ depends on the derivatives of the displacement potential $ \phi $. This implies that the value for $ \overline{\cal P}$ computed from the finite-\/element solution for $ \phi $ is not as accurate as the displacement potential itself. Computing $ \overline{\cal P}$ to a certain tolerance (e.\+g. to \char`\"{}graphical accuracy\char`\"{} as in the plot shown above) therefore tends to require meshes that are much finer than would be required if we were only interested in $ \phi $ itself. ~\newline
~\newline
 Investigate the accuracy of the computational predictions for $ \overline{\cal P}$ by\+:
\begin{DoxyItemize}
\item increasing the spatial resolution e.\+g. by using the command line flag {\ttfamily --el\+\_\+multiplier} which controls the number of elements in the mesh.
\item reducing the outer radius of the computational domain, using the command line flag {\ttfamily --outer\+\_\+radius}, say.
\item varying the element type, from the bi-\/linear {\ttfamily QFourier\+Decomposed\+Helmholtz\+Element$<$2$>$} to the bi-\/cubic {\ttfamily QFourier\+Decomposed\+Helmholtz\+Element$<$4$>$}, say.
\end{DoxyItemize}
\end{DoxyItemize}Which of these approaches gives you the \char`\"{}most accuracy\char`\"{} for a given number of degrees of freedom? \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_appendix}{}\doxysection{Appendix\+: The time-\/averaged radiated power}\label{index_appendix}
This appendix provides a brief summary of the computation (and non-\/dimensionalisation) of the time-\/averaged power $ \overline{\cal P }^* $ radiated across the closed surface $ \partial V $ (with outer unit normal $ {\bf n} $) of a fluid volume $ V $. In dimensional terms, $ \overline{\cal P }^* $ is given by \[ \overline{\cal P }^* = \oint_{\partial V} I^* dA^*, \ \ \ \ \ \ \ \ \ \ \ (9) \] where the intensity \[ I^* = \frac{1}{{\cal T}} \int_0^{\cal T} {\bf U}^* \cdot P^* {\bf n} \ dt^* \] depends on the fluid velocity $ {\bf U}^* = \partial {\bf d}^*/\partial t^* = \partial/\partial t^* (\nabla^* \Phi^*) $ and the pressure $ P^* = \rho_{\rm f} \omega^2 \Phi^* $. The time average is taken over the period of the oscillation, $ {\cal T} = 2\pi/\omega. $ Using our time-\/periodic ansatz for the fluid displacement potential, $ \Phi^* = Re\{ \phi^* \exp(-{\rm i}\omega t^*) \} $, the intensity can be re-\/written as \[ I^* = \frac{1}{2} \rho_{\rm f} \omega^3 \bigg( Im \{\frac{\partial \phi^*}{\partial n^*} \} Re\{\phi^* \} - Re \{\frac{\partial \phi^*}{\partial n^*} \} Im\{\phi^* \} \bigg). \] Next we express the surface integral in (9) in cylindrical polar coordinates. Assuming the (axisymmetric) boundary of the fluid domain is parametrised (in the $ (r^*,z^*)$ plane) as $ r^* = R^*(s^*)$ and $ z^* = Z^*(s^*)$, where $ s^* $ is some curve parameter (e.\+g. the arclength), we have \[ \overline{\cal P }^* = \int \int_0^{2\pi} I^*(s^*,\varphi) \sqrt{ \left(\frac{\partial R^*}{\partial s^*}\right)^2 + \left(\frac{\partial Z^*}{\partial s^*}\right)^2 } R^*(s^*) \ d\varphi \ ds^* \] The power associated with the $ N-$th azimuthal Fourier mode, $ \phi^*_N(r^*,z^*) \exp({\rm i}N \varphi) $, is then given by \[ \overline{\cal P }^*_N = \pi \rho_{\rm f} \omega^3 \int \bigg( Im \{\frac{\partial \phi_N^*}{\partial n^*} \} Re\{\phi_N^* \} - Re \{\frac{\partial \phi_N^*}{\partial n^*} \} Im\{\phi_N^* \} \bigg) \sqrt{ \left(\frac{\partial R^*}{\partial s^*}\right)^2 + \left(\frac{\partial Z^*}{\partial s^*}\right)^2 } R^*(s^*) \ ds^*. \] Non-\/dimensionalising all lengths on $ {\cal L}$ and the displacement potential on $ {\cal L}^2 $ then yields the following expression for the non-\/dimensional time-\/averaged radiated power \[ \overline{\cal P }_N = \frac{\overline{\cal P }^*_N}{\rho_{\rm f} \omega^3 {\cal L}^5} = \pi \int \bigg( Im \{\frac{\partial \phi_N}{\partial n} \} Re\{\phi_N \} - Re \{\frac{\partial \phi_N}{\partial n} \} Im\{\phi_N \} \bigg) \sqrt{ \left(\frac{\partial R}{\partial s}\right)^2 + \left(\frac{\partial Z}{\partial s}\right)^2 } R(s) \ ds. \] This quantity is computed by {\ttfamily oomph-\/lib} on an element-\/by-\/element basis, using the function {\ttfamily Fourier\+Decomposed\+Helmholtz\+BCElement\+Base\+::global\+\_\+power\+\_\+contribution(...)}.

The computation is most easily validated by comparing against analytical results in which the displacement potential is expressed in spherical polar coordinates $ (r_{\rm sphere}^*, \theta, \varphi) $ where $ r_{\rm sphere}^* = \sqrt{r^{*2} + z^{*2}} $ and $ \theta $ is the zenith angle which varies from $ \theta=0$ at the \char`\"{}\+North pole\char`\"{} to $ \theta=\pi $ at the \char`\"{}\+South pole\char`\"{}. If we evaluate the surface integral in (9) on a spherical surface of dimensional radius $ a^* $, the dimensional time-\/averaged radiated power is \[ \overline{\cal P }^* = \int_0^\pi \int_0^{2\pi} I^*(r_{\rm sphere}^*=a^*, \theta,\varphi)\ a^{*2} \sin(\theta) \ d\varphi \ d\theta. \] The power associated with $ N-$th azimuthal Fourier mode, $ \phi^*_N(r^*,z^*) \exp({\rm i}N \varphi) $, is then given by \[ \overline{\cal P }^*_N = \pi a^{*2} \rho_{\rm f} \omega^3 \int_0^\pi \left.\bigg( Im \{\frac{\partial \phi_N^*}{\partial n^*} \} Re\{\phi_N^* \} - Re \{\frac{\partial \phi_N^*}{\partial n^*} \} Im\{\phi_N^* \} \bigg)\right|_{r_{\rm sphere}^*=a^*} \sin(\theta) \ d\theta, \] where $ \partial / \partial n^* = \partial / \partial r_{\rm sphere}^* $. The non-\/dimensional time-\/averaged power, evaluated on a sphere of non-\/dimensional radius $ a = a^*/{\cal L}$ is then given by \[ \overline{\cal P }_N = \frac{\overline{\cal P }^*_N}{\rho_{\rm f} \omega^3 {\cal L}^5} = \pi a^2 \int_0^\pi \left. \bigg( Im \{\frac{\partial \phi_N}{\partial n} \} Re\{\phi_N \} - Re \{\frac{\partial \phi_N}{\partial n} \} Im\{\phi_N \} \bigg)\right|_{r_{\rm sphere}=a} \sin(\theta) \ d\theta, \] where $ \partial / \partial n = \partial / \partial r_{\rm sphere} $.

The derivation of the analytical expression for $ \overline{\cal P }_N $ against which we validated our computational results were performed with maple, using the script \href{../../../../demo_drivers/interaction/fourier_decomposed_acoustic_fsi/exact.map}{\texttt{ demo\+\_\+drivers/interaction/fourier\+\_\+decomposed\+\_\+acoustic\+\_\+fsi/exact.\+map }}. \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/interaction/fourier_decomposed_acoustic_fsi}{\texttt{ demo\+\_\+drivers/interaction/fourier\+\_\+decomposed\+\_\+acoustic\+\_\+fsi/ }} \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/interaction/fourier_decomposed_acoustic_fsi/fourier_decomposed_acoustic_fsi.cc}{\texttt{ demo\+\_\+drivers/interaction/fourier\+\_\+decomposed\+\_\+acoustic\+\_\+fsi/fourier\+\_\+decomposed\+\_\+acoustic\+\_\+fsi.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{PDF file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
