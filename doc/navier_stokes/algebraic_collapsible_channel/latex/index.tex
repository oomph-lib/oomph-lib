In many previous examples we illustrated how {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Domain} and {\ttfamily Macro\+Element} objects facilitate the generation of refineable (and non-\/refineable) meshes in domains with moving, curvilinear boundaries. Consult, for instance\+:


\begin{DoxyItemize}
\item The tutorial \href{../../../poisson/fish_poisson2/html/index.html}{\texttt{ \char`\"{}\+How to create refineable meshes in domains with curvilinear and/or   moving boundaries\char`\"{}}} for a general discussion of the methodology. ~\newline
~\newline

\item The tutorial \href{../../../unsteady_heat/two_d_unsteady_heat_ALE/html/index.html}{\texttt{ \char`\"{}\+Spatially adaptive solution of the 2\+D unsteady heat equation with    flux boundary conditions in a moving domain\+: ALE methods\char`\"{}}} for an example involving the unsteady heat equation. ~\newline
~\newline

\item The tutorials ~\newline
~\newline

\begin{DoxyItemize}
\item \href{../../../navier_stokes/osc_ellipse/html/index.html}{\texttt{ \char`\"{}\+Finite-\/\+Reynolds-\/number flow inside an oscillating ellipse\char`\"{}}} ~\newline
~\newline

\end{DoxyItemize}or
\begin{DoxyItemize}
\item \href{../../../navier_stokes/collapsible_channel/html/index.html}{\texttt{ \char`\"{}\+Flow in a 2\+D channel with an oscillating wall\char`\"{}}} ~\newline
~\newline

\end{DoxyItemize}for examples involving the Navier-\/\+Stokes equations.
\end{DoxyItemize}The two main features of the {\ttfamily Macro\+Element/\+Domain} -\/ based node-\/update are that, once the curvilinear domain is represented by a {\ttfamily Domain} object
\begin{DoxyEnumerate}
\item Any subsequent mesh refinement will respect the curvilinear domain boundaries. ~\newline
~\newline

\item The udate of the nodal positions in response to a change in the position of the domain\textquotesingle{}s curvilinear boundaries may be performed by the \char`\"{}black-\/box\char`\"{} function {\ttfamily Mesh\+::node\+\_\+update()}.
\end{DoxyEnumerate}

The availability of a \char`\"{}black-\/box\char`\"{} node-\/update procedure is very convenient but in some applications it may be desirable (or even necessary) to provide a customised node-\/update function, either because the mesh deformation generated by the \char`\"{}black-\/box\char`\"{} procedure is not appropriate or because it is not efficient. The latter problem arises particularly in fluid-\/structure interaction problems.

In this tutorial we shall demonstrate an alternative node-\/update technique, based on {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Algebraic\+Node}, {\ttfamily Algebraic\+Element}, and {\ttfamily Algebraic\+Mesh} classes. The key feature of this approach is that it allows \char`\"{}each node to update its own position\char`\"{}. This is in contrast to the {\ttfamily Domain/\+Macro\+Element-\/based} approach in which we can only update the nodal positions of {\itshape all} nodes in the mesh simultaneously -- not a particularly sparse operation! \mbox{[}We note that the {\ttfamily Node} and {\ttfamily Finite\+Element} base classes provide the virtual functions {\ttfamily Node\+::node\+\_\+update()} and {\ttfamily Finite\+Element\+::node\+\_\+update()}. These functions are intended to be used for node-\/by-\/node or element-\/by-\/element node-\/updates but in their default implementations they are empty. Hence no node-\/update is performed unless these functions are overloaded in derived classes such as {\ttfamily Algebraic\+Node} and {\ttfamily Algebraic\+Element}.\mbox{]}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_overview}{}\doxysection{Overview}\label{index_overview}
The idea behind the algebraic node-\/updates is simple\+: The {\ttfamily Algebraic\+Mesh} class (the base class for meshes containing {\ttfamily Algebraic\+Elements} and {\ttfamily Algebraic\+Nodes}) contains the pure virtual function


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} AlgebraicMesh::algebraic\_node\_update(..., AlgebraicNode* node\_pt)=0;}

\end{DoxyCode}


which must be implemented in every specific {\ttfamily Algebraic\+Mesh}. Its task is to update the position of the node specified by the pointer-\/valued argument. ~\newline
~\newline
 The specific implementation of the node-\/update operation is obviously problem-\/dependent but it is easy to illustrate the general procedure by considering the collapsible channel mesh sketched below\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{alg_node_update_sketch}
\doxyfigcaption{Sketch of the algebraic node-\/update procedure for the collapsible channel mesh. }
\end{DoxyImage}


The upper figure shows the mesh in the undeformed domain in which wall shape is parametrised by the intrinsic (Lagrangian) coordinate $ \zeta $ as $ {\bf R}(\zeta,t=0) = (L_{up} + \zeta, 1) ^T. $ In this configuration each node is located at a certain fraction along the vertical lines across the channel. For instance, the $ j$-\/th node (drawn in blue) is located at a fraction of $ \omega_j = 1/3 $ along the straight line that connects reference point $ {\bf A}_j $ on the bottom wall to reference point $ {\bf B}_j $ on the flexible upper wall. We note that reference point $ {\bf B}_j $ may be identified by its Lagrangian coordinate $ \zeta_j $ on the wall.

The lower figure shows a sketch of the deformed domain and illustrates a possible algebraic node-\/update strategy\+: Given the new wall shape, described by $ {\bf R}(\zeta,t) $, we position each node on the straight line that connects its reference point $ {\bf A}\textnormal{\textquotesingle}_j = {\bf A}_j $ on the lower wall to the reference point $ {\bf B}\textnormal{\textquotesingle}_j = {\bf R}(\zeta_j,t) $ on the deformable upper wall.

To perform this node-\/update procedure for a specific node, we generally have to store
\begin{DoxyItemize}
\item A pointer to one (or more) {\ttfamily Geom\+Object(s)} that define the curvilinear domain boundaries. ~\newline
~\newline

\item A number of node-\/specific reference values (such as $ \omega_j, \ \zeta_j $, and the $ x_1 $ -\/coordinate of point $ {\bf A}_j $, $ X^{(A)}_j $, say) that establish the node\textquotesingle{}s position relative to these {\ttfamily Geom\+Objects}. ~\newline
~\newline

\item A pointer to the {\ttfamily Algebraic\+Mesh} that implements the node-\/update procedure.
\end{DoxyItemize}Since the node-\/update data is node-\/specific, we provide storage for it in the {\ttfamily Algebraic\+Node} class -- a class that is derived from the {\ttfamily Node} class. The node-\/update function itself is shared by many nodes in the mesh and is implemented in {\ttfamily Algebraic\+Mesh\+::algebraic\+\_\+node\+\_\+update(...)}. This function extracts the node-\/update parameters, $ \omega_j, \ \zeta_j $, and $ X^{(A)}_j $ and the pointer to the {\ttfamily Geom\+Object} that parametrises the wall, {\ttfamily wall\+\_\+pt}, say, from the {\ttfamily Algebraic\+Node} passed to it. With these parameters, the position of reference point ${\bf A}\textnormal{\textquotesingle}_j $ is given by $ {\bf A}\textnormal{\textquotesingle}_j = (X_j^{(A)},0)^T $ while the coordinates of reference point $ {\bf B}\textnormal{\textquotesingle}_j = {\bf R}(\zeta_j,t)$ may be obtained from a call to {\ttfamily wall\+\_\+pt-\/$>$position(...)}. The nodal position $ {\bf r}_j $ may then be updated via \[ {\bf r}_j = {\bf A}_j\textnormal{\textquotesingle} + \omega_j \left( {\bf B}_j\textnormal{\textquotesingle}-{\bf A}_j\textnormal{\textquotesingle} \right) \]

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_how_to_use}{}\doxysection{How to use existing Algebraic\+Meshes}\label{index_how_to_use}
To use the algebraic node-\/update capabilities of an existing {\ttfamily Algebraic\+Mesh}, all {\ttfamily Nodes} must be replaced by {\ttfamily Algebraic\+Nodes} to allow the storage of the node-\/specific node-\/update parameters. Recall that within {\ttfamily oomph-\/lib} {\ttfamily Nodes} are usually created by the elements, using the function {\ttfamily Finite\+Element\+::construct\+\_\+node(...)} whose argument specifies the local node number of the newly created {\ttfamily Node} within the element that creates it. (The specification of the local node number is required to allow the {\ttfamily Finite\+Element\+::construct\+\_\+node(...)} function to create a {\ttfamily Node} with the appropriate number of values and history values. For instance, in 2D Taylor-\/\+Hood Navier-\/\+Stokes elements, the elements\textquotesingle{} vertex nodes have to store three values, representing the two velocity components and the pressure, whereas all other nodes only require storage for the two velocity components.)

To ensure that the {\ttfamily Finite\+Element\+::construct\+\_\+node(...)} function creates {\ttfamily Algebraic\+Nodes} rather than \char`\"{}ordinary\char`\"{} {\ttfamily Nodes}, we provide the templated wrapper class


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<ELEMENT>}
\DoxyCodeLine{\textcolor{keyword}{class }AlgebraicElement<ELEMENT> : \textcolor{keyword}{public} ELEMENT}

\end{DoxyCode}


which overloads the {\ttfamily Finite\+Element\+::construct\+\_\+node(...)} function so that it creates {\ttfamily Algebraic\+Nodes} instead. In most other respects, the \char`\"{}wrapped\char`\"{} element behaves exactly as the underlying {\ttfamily ELEMENT} itself. To use an existing {\ttfamily Algebraic\+Mesh} with a certain element type, {\ttfamily QTaylor\+Hood\+Element$<$2$>$}, say, we simply \char`\"{}upgrade\char`\"{} the element to an {\ttfamily Algebraic\+Element} by specifying the element type as {\ttfamily Algebraic\+Element$<$QTaylor\+Hood\+Element$<$2$>$} $>$. ~\newline


The changes to an existing driver code that performs the node update by the default {\ttfamily Domain/\+Macro\+Element} methodology are therefore completely trivial. You may wish to compare the driver code \href{../../../../demo_drivers/navier_stokes/collapsible_channel/collapsible_channel.cc}{\texttt{ collapsible\+\_\+channel.\+cc}}, discussed in \href{../../collapsible_channel/html/index.html}{\texttt{ an earlier example}}, to the driver code \href{../../../../demo_drivers/navier_stokes/collapsible_channel/collapsible_channel_algebraic.cc}{\texttt{ collapsible\+\_\+channel\+\_\+algebraic.\+cc}} in which the fluid domain is discretised by the {\ttfamily My\+Algebraic\+Collapsible\+Channel\+Mesh}, discussed below.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_how_to_write}{}\doxysection{How to create a new Algebraic\+Mesh â€“ a basic example}\label{index_how_to_write}
To illustrate how to create a new {\ttfamily Algebraic\+Mesh}, we will now discuss the implementation of the {\ttfamily My\+Algebraic\+Collapsible\+Channel\+Mesh} -- an {\ttfamily Algebraic\+Mesh} -\/ version of the {\ttfamily Collapsible\+Channel\+Mesh}, used in \href{../../collapsible_channel/html/index.html}{\texttt{ the earlier example}}.

\DoxyHorRuler{0}
\hypertarget{index_class}{}\doxysubsection{The class definition}\label{index_class}
We construct the mesh by multiple inheritance from the {\ttfamily Algebraic\+Mesh} base class, and the already-\/existing {\ttfamily Collapsible\+Channel\+Mesh}. The constructor first calls the constructor of the underlying {\ttfamily Collapsible\+Channel\+Mesh} (thus \char`\"{}recycling\char`\"{} the basic mesh generation process, i.\+e. the generation of nodes and elements etc.) and then adds the algebraic node-\/update information by calling the function {\ttfamily setup\+\_\+algebraic\+\_\+node\+\_\+update()}.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===========start\_algebraic\_mesh==================================}}
\DoxyCodeLine{\textcolor{comment}{/// Collapsible channel mesh with algebraic node update}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//=================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keyword}{class }MyAlgebraicCollapsibleChannelMesh : }
\DoxyCodeLine{  \textcolor{keyword}{public} AlgebraicMesh,}
\DoxyCodeLine{  \textcolor{keyword}{public} \textcolor{keyword}{virtual} CollapsibleChannelMesh<ELEMENT>}
\DoxyCodeLine{\{ }
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}: }
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Constructor: Pass number of elements in upstream/collapsible/}}
\DoxyCodeLine{\textcolor{comment}{ /// downstream segment and across the channel; lengths of upstream/}}
\DoxyCodeLine{\textcolor{comment}{ /// collapsible/downstream segments and width of channel, pointer to }}
\DoxyCodeLine{\textcolor{comment}{ /// GeomObject that defines the collapsible segment, and pointer to }}
\DoxyCodeLine{\textcolor{comment}{ /// TimeStepper (defaults to the default timestepper, Steady). }}
\DoxyCodeLine{\textcolor{comment}{} MyAlgebraicCollapsibleChannelMesh(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& nup, }
\DoxyCodeLine{                                   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& ncollapsible, }
\DoxyCodeLine{                                   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& ndown, }
\DoxyCodeLine{                                   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& ny, }
\DoxyCodeLine{                                   \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& lup, }
\DoxyCodeLine{                                   \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& lcollapsible, }
\DoxyCodeLine{                                   \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& ldown, }
\DoxyCodeLine{                                   \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& ly,}
\DoxyCodeLine{                                   GeomObject* wall\_pt,}
\DoxyCodeLine{                                   TimeStepper* time\_stepper\_pt=}
\DoxyCodeLine{                                   \&Mesh::Default\_TimeStepper) :}
\DoxyCodeLine{  CollapsibleChannelMesh<ELEMENT>(nup, ncollapsible, ndown, ny,}
\DoxyCodeLine{                                  lup, lcollapsible, ldown, ly,}
\DoxyCodeLine{                                  wall\_pt,}
\DoxyCodeLine{                                  time\_stepper\_pt)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Setup algebraic node update operations}}
\DoxyCodeLine{   setup\_algebraic\_node\_update();}
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
 We declare the interface for the pure virtual function {\ttfamily algebraic\+\_\+node\+\_\+update(...)}, to be discussed below, and implement a second pure virtual function, {\ttfamily Algebraic\+Mesh\+::update\+\_\+node\+\_\+update()}, that may be used to update reference values following a mesh adaptation. Since the current mesh is not refineable, we leave this function empty and refer to \href{../../../interaction/fsi_collapsible_channel_adapt/html/index.html}{\texttt{ another example}} for a more detailed discussion of its role.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{/// Update nodal position at time level t (t=0: present; }}
\DoxyCodeLine{\textcolor{comment}{ /// t>0: previous)}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} algebraic\_node\_update(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& t, AlgebraicNode*\& node\_pt);}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the geometric references that are used }}
\DoxyCodeLine{\textcolor{comment}{ /// to update node after mesh adaptation.}}
\DoxyCodeLine{\textcolor{comment}{ /// Empty -\/-\/ no update of node update required}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} update\_node\_update(AlgebraicNode*\& node\_pt) \{\}}

\end{DoxyCodeInclude}
 The protected member function {\ttfamily setup\+\_\+algebraic\+\_\+node\+\_\+update()} will be discussed below.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{keyword}{protected}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Function to setup the algebraic node update}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} setup\_algebraic\_node\_update();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Dummy function pointer }}
\DoxyCodeLine{\textcolor{comment}{} CollapsibleChannelDomain::BLSquashFctPt Dummy\_fct\_pt;}
\DoxyCodeLine{}
\DoxyCodeLine{\};}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
\hypertarget{index_setting_up}{}\doxysubsection{Setting up the algebraic node update}\label{index_setting_up}
When the function {\ttfamily setup\+\_\+algebraic\+\_\+node\+\_\+update()} is called, the constructor of the underlying {\ttfamily Collapsible\+Channel\+Mesh} will already have created the mesh\textquotesingle{}s elements and nodes, and the nodes will be located at their initial positions in the undeformed domain.

To set up the algebraic node-\/update data, we start by extracting the lengths of the upstream rigid section, $ L_{up} $, and the length of the collapsible segment, $ L_{collapsible} $, from the {\ttfamily Collapsible\+Channel\+Domain\+:} 


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//============start\_setup\_algebraic\_node\_update====================}}
\DoxyCodeLine{\textcolor{comment}{/// Setup algebraic mesh update -\/-\/ assumes that mesh has}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// initially been set up with the wall in its undeformed position.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//=================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} MyAlgebraicCollapsibleChannelMesh<ELEMENT>::setup\_algebraic\_node\_update()}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Extract some reference lengths from the CollapsibleChannelDomain. }}
\DoxyCodeLine{ \textcolor{keywordtype}{double} l\_up=this-\/>domain\_pt()-\/>l\_up();}
\DoxyCodeLine{ \textcolor{keywordtype}{double} l\_collapsible=this-\/>domain\_pt()-\/>l\_collapsible();}

\end{DoxyCodeInclude}
 Next, we loop over all {\ttfamily Algebraic\+Nodes} in the mesh and determine their current positions\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Loop over all nodes in mesh}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nnod=this-\/>nnode();}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<nnod;j++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Get pointer to node}}
\DoxyCodeLine{   AlgebraicNode* nod\_pt=node\_pt(j);}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Get coordinates}}
\DoxyCodeLine{   \textcolor{keywordtype}{double} x=nod\_pt-\/>x(0);}
\DoxyCodeLine{   \textcolor{keywordtype}{double} y=nod\_pt-\/>x(1);}

\end{DoxyCodeInclude}


If the {\ttfamily j} -\/th node is located in the \char`\"{}collapsible\char`\"{} section of the mesh we determine its reference coordinate, $ \zeta_j $, on the wall and determine the coordinates of its reference point $ {\bf B}_j $ from the {\ttfamily Geom\+Object} that represents the moving wall.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{   \textcolor{comment}{// Check if the node is in the collapsible part:}}
\DoxyCodeLine{   \textcolor{keywordflow}{if} ( (x>=l\_up) \&\& (x<=(l\_up+l\_collapsible)) )}
\DoxyCodeLine{    \{}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Get zeta coordinate on the undeformed wall}}
\DoxyCodeLine{     Vector<double> zeta(1);}
\DoxyCodeLine{     zeta[0]=x-\/l\_up;}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Get position vector to wall:}}
\DoxyCodeLine{     Vector<double> r\_wall(2);}
\DoxyCodeLine{     this-\/>Wall\_pt-\/>position(zeta,r\_wall);}

\end{DoxyCodeInclude}
 Just to be on the safe side, we check that the wall is actually in its undeformed configuration, as assumed.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{     \textcolor{comment}{// Sanity check: Confirm that the wall is in its undeformed position}}
\DoxyCodeLine{\textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{     \textcolor{keywordflow}{if} ((std::abs(r\_wall[0]-\/x)>1.0e-\/15)\&\&(std::abs(r\_wall[1]-\/y)>1.0e-\/15))}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       std::ostringstream error\_stream;}
\DoxyCodeLine{       error\_stream }
\DoxyCodeLine{        << \textcolor{stringliteral}{"{}Wall must be in its undeformed position when\(\backslash\)n"{}}}
\DoxyCodeLine{        << \textcolor{stringliteral}{"{}algebraic node update information is set up!\(\backslash\)n "{}}}
\DoxyCodeLine{        << \textcolor{stringliteral}{"{}x-\/discrepancy: "{}} << std::abs(r\_wall[0]-\/x) << std::endl}
\DoxyCodeLine{        << \textcolor{stringliteral}{"{}y-\/discrepancy: "{}} << std::abs(r\_wall[1]-\/y) << std::endl;}
\DoxyCodeLine{       }
\DoxyCodeLine{       \textcolor{keywordflow}{throw} OomphLibError(}
\DoxyCodeLine{        error\_stream.str(),}
\DoxyCodeLine{        OOMPH\_CURRENT\_FUNCTION,}
\DoxyCodeLine{        OOMPH\_EXCEPTION\_LOCATION);}
\DoxyCodeLine{      \}}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif       }}

\end{DoxyCodeInclude}
 Next, we package the data required for the node-\/update operations (the pointers to {\ttfamily Geom\+Object(s)} and the reference values) into vectors. In the present example, the node-\/update operation only involves a single {\ttfamily Geom\+Object\+:} 


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{     \textcolor{comment}{// Only a single geometric object is involved in the node update operation}}
\DoxyCodeLine{     Vector<GeomObject*> geom\_object\_pt(1);}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// The wall geometric object}}
\DoxyCodeLine{     geom\_object\_pt[0]=this-\/>Wall\_pt;}

\end{DoxyCodeInclude}
 We have three reference values\+: The $ x_1 $ -\/ coordinate of point $ {\bf A}_j $,


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{     \textcolor{comment}{// The update function requires three parameters:}}
\DoxyCodeLine{     Vector<double> ref\_value(3);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// First reference value: Original x-\/position on the lower wall }}
\DoxyCodeLine{     ref\_value[0]=r\_wall[0];}

\end{DoxyCodeInclude}
 as well as the fractional height, $ \omega_j $,


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{     \textcolor{comment}{// Second reference value: Fractional position along }}
\DoxyCodeLine{     \textcolor{comment}{// straight line from the bottom (at the original x-\/position)}}
\DoxyCodeLine{     \textcolor{comment}{// to the point on the wall}}
\DoxyCodeLine{     ref\_value[1]=y/r\_wall[1];}

\end{DoxyCodeInclude}
 and the reference coordinate, $ \zeta_j $, along the wall\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{     \textcolor{comment}{// Third reference value: Zeta coordinate on wall}}
\DoxyCodeLine{     ref\_value[2]=zeta[0];   }

\end{DoxyCodeInclude}
 The vectors of reference values and geometric objects are then passed to the node, together with the pointer to the mesh ({\ttfamily this}) that implements the node-\/update function.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Setup algebraic update for node: Pass update information}}
\DoxyCodeLine{     \textcolor{comment}{// to AlgebraicNode:}}
\DoxyCodeLine{     nod\_pt-\/>add\_node\_update\_info(}
\DoxyCodeLine{      \textcolor{keyword}{this},               \textcolor{comment}{// mesh}}
\DoxyCodeLine{      geom\_object\_pt,     \textcolor{comment}{// vector of geom objects}}
\DoxyCodeLine{      ref\_value);         \textcolor{comment}{// vector of ref. values}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{   }
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{//end of setup\_algebraic\_node\_update}}

\end{DoxyCodeInclude}
\DoxyHorRuler{0}
\hypertarget{index_node_update}{}\doxysubsection{The node-\/update function}\label{index_node_update}
The function {\ttfamily algebraic\+\_\+node\+\_\+update(...)} reverses the setup process\+: It extracts the node-\/update data from the {\ttfamily Algebraic\+Node} and updates its position at the {\ttfamily t} -\/th previous time-\/level\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=============start\_of\_algebraic\_node\_update======================}}
\DoxyCodeLine{\textcolor{comment}{/// Perform algebraic mesh update at time level t (t=0: present; }}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// t>0: previous)}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//=================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} MyAlgebraicCollapsibleChannelMesh<ELEMENT>::algebraic\_node\_update(}
\DoxyCodeLine{ \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& t, AlgebraicNode*\& node\_pt)}
\DoxyCodeLine{\{}

\end{DoxyCodeInclude}
 We start by extracting the vectors of reference values and {\ttfamily Geom\+Objects} involved in this node\textquotesingle{}s node-\/update, using the functions {\ttfamily Algebraic\+Node\+::vector\+\_\+ref\+\_\+value()} which returns a Vector of reference values, and the function ~\newline
 {\ttfamily Algebraic\+Node\+::vector\+\_\+geom\+\_\+object\+\_\+pt()} which returns a Vector of pointers to {\ttfamily Geom\+Objects}.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Extract reference values for update by copy construction}}
\DoxyCodeLine{ Vector<double> ref\_value(node\_pt-\/>vector\_ref\_value());}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Extract geometric objects for update by copy construction}}
\DoxyCodeLine{ Vector<GeomObject*> geom\_object\_pt(node\_pt-\/>vector\_geom\_object\_pt());}

\end{DoxyCodeInclude}
 Next, we translate these into local variables,


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// First reference value: Original x-\/position }}
\DoxyCodeLine{ \textcolor{keywordtype}{double} x\_bottom=ref\_value[0];}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Second reference value: Fractional position along }}
\DoxyCodeLine{ \textcolor{comment}{// straight line from the bottom (at the original x-\/position)}}
\DoxyCodeLine{ \textcolor{comment}{// to the point on the wall}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} fract=ref\_value[1];}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Third reference value: Zeta coordinate on wall}}
\DoxyCodeLine{ Vector<double> zeta(1);}
\DoxyCodeLine{ zeta[0]=ref\_value[2];}
\DoxyCodeLine{     }
\DoxyCodeLine{ \textcolor{comment}{// Pointer to wall geom object}}
\DoxyCodeLine{ GeomObject* wall\_pt=geom\_object\_pt[0];}

\end{DoxyCodeInclude}


and obtain the current wall position from the wall {\ttfamily Geom\+Object}.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Get position vector to wall at previous timestep t}}
\DoxyCodeLine{ Vector<double> r\_wall(2);}
\DoxyCodeLine{ wall\_pt-\/>position(t,zeta,r\_wall);}

\end{DoxyCodeInclude}
 Finally, we update the nodal position\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Assign new nodal coordinates}}
\DoxyCodeLine{ node\_pt-\/>x(t,0)=x\_bottom+fract*(r\_wall[0]-\/x\_bottom);}
\DoxyCodeLine{ node\_pt-\/>x(t,1)=         fract* r\_wall[1];}
\DoxyCodeLine{}
\DoxyCodeLine{\}}

\end{DoxyCodeInclude}
 Done!

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comments}{}\doxysection{Comments and Exercises}\label{index_comments}
\hypertarget{index_comm}{}\doxysubsection{Comments}\label{index_comm}

\begin{DoxyItemize}
\item {\bfseries{Element-\/by-\/element and global node updates\+:}} ~\newline
 ~\newline
 As explained above, the re-\/implementation of the (empty) {\ttfamily Node\+::node\+\_\+update()} function by {\ttfamily Algebraic\+Node\+::node\+\_\+update()} allows each node to \char`\"{}update its    own position\char`\"{}. The {\ttfamily Algebraic\+Mesh} and {\ttfamily Algebraic\+Element} classes provide their own re-\/implementation of the {\ttfamily node\+\_\+update()} functions in the {\ttfamily Mesh} and {\ttfamily Finite\+Element} classes, and perform the node-\/updates by executing the {\ttfamily Algebraic\+Node\+::node\+\_\+update()} function of their constituent nodes. ~\newline
~\newline

\item {\bfseries{Default node-\/update function\+:}} ~\newline
 ~\newline
 We stress that, in the above example, it was only necessary to set up the node-\/update data for the nodes in the central \char`\"{}collapsible\char`\"{} part of the mesh as they are the only modes whose position is affected by the motion of the curvilinear boundary. This is possible because the {\ttfamily Algebraic\+Node} constructor provides default assignments for the node-\/update data. In particular, the pointer to the Mesh that performs the node update is initialised by a pointer to the (static instantiation of a) {\ttfamily Dummy\+Mesh} whose {\ttfamily Algebraic\+Mesh\+::algebraic\+\_\+node\+\_\+update(...)} and {\ttfamily Algebraic\+Mesh\+::update\+\_\+node\+\_\+update(...)} functions are empty. This ensures that nodes for which these default assignments are not overwritten stay at their original position when the node udate is performed. This implementation provides a sensible default behaviour for the node update. ~\newline
~\newline

\item {\bfseries{Multiple node-\/update functions\+:}} ~\newline
 ~\newline
 In the simple example considered here, a single node-\/update function was sufficient to update the positions of all moving nodes in the mesh. In more complicated meshes, it may be be necessary to provide different node-\/update functions for nodes that are located in different parts of the mesh. To facilitate the implementation of such cases, it is possible to specify an identifier for the node-\/update function when calling the {\ttfamily Algebraic\+Node\+::add\+\_\+node\+\_\+update\+\_\+info(...)} function, using its alternative interface 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} AlgebraicNode::add\_node\_update\_info(}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int}\& \textcolor{keywordtype}{id},                              \textcolor{comment}{// ID of the node-\/update fct}}
\DoxyCodeLine{    AlgebraicMesh* mesh\_pt,                     \textcolor{comment}{// pointer to mesh}}
\DoxyCodeLine{    \textcolor{keyword}{const} Vector<GeomObject*>\& geom\_object\_pt,  \textcolor{comment}{// vector of geom objects}}
\DoxyCodeLine{    \textcolor{keyword}{const} Vector<double>\& ref\_value);           \textcolor{comment}{// vector of ref. values}}

\end{DoxyCode}
 When implementing the {\ttfamily Algebraic\+Mesh\+::algebraic\+\_\+node\+\_\+update(...)} function for a mesh that contains multiple node-\/update functions, the ID of the node-\/update function associated with a particular node can be obtained from {\ttfamily Algebraic\+Node\+::node\+\_\+update\+\_\+fct\+\_\+id()}, allowing the node-\/update function to take the appropriate action. (As an example, consider the implementation of the algebraic node-\/update function for the {\ttfamily Refineable\+Algebraic\+Fish\+Mesh} in which different node-\/update functions are used to update the position of nodes in the fish\textquotesingle{}s \char`\"{}body\char`\"{} and in its \char`\"{}tail\char`\"{}.) If the {\ttfamily Algebraic\+Node\+::add\+\_\+node\+\_\+update\+\_\+info(...)} function is called without specifying an ID, a default ID of 0 is assigned. ~\newline
~\newline

\item {\bfseries{Consistency between multiple node-\/update functions\+:}} ~\newline
 ~\newline
 If a mesh contains multiple node-\/update functions, it is likely that some nodes are located at the interface between regions that are updated by different node-\/update functions. As indicated by the {\ttfamily \char`\"{}add\+\_\+...\char`\"{}} in the {\ttfamily Algebraic\+Node\+::add\+\_\+node\+\_\+update\+\_\+info(...)} function, {\ttfamily Algebraic\+Nodes} may be associated with multiple node-\/update functions, though the different node-\/update functions associated with a node must, of course, give the same result. This may be verified by calling the {\ttfamily Algebraic\+Node\+::self\+\_\+test()} function for all nodes in an {\ttfamily Algebraic\+Mesh}. ~\newline
 ~\newline
 {\bfseries{Note\+:}} In refineable {\ttfamily Algebraic\+Meshes} (discussed in more detail below), {\ttfamily Algebraic\+Nodes} {\bfseries{must}} be associated with all possible node-\/update functions to ensure that the reference values for newly created nodes are determined correctly during the adaptive mesh refinement. ~\newline
~\newline

\item {\bfseries{Adaptivity\+:}} ~\newline
 ~\newline
 Refineable {\ttfamily Algebraic\+Meshes} may be created by multiple inheritance from a suitable {\ttfamily Refineable\+Mesh} base class (e.\+g. the {\ttfamily Refineable\+Quad\+Mesh} class), and setting up the required tree representation of the coarse initial mesh, exactly as for \char`\"{}ordinary\char`\"{} meshes (see the tutorial \href{../../../poisson/two_d_poisson_adapt/html/index.html}{\texttt{ \char`\"{}\+How to create simple refineable meshes\char`\"{}}} for details). As an example, here is the class definition for a refineable version of the {\ttfamily My\+Algebraic\+Collapsible\+Channel\+Mesh} discussed above\+: ~\newline
 ~\newline
  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===========start\_refineable\_algebraic\_collapsible\_channel\_mesh======}}
\DoxyCodeLine{\textcolor{comment}{/// Refineable version of the CollapsibleChannel mesh with}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// algebraic node update.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keyword}{class }MyRefineableAlgebraicCollapsibleChannelMesh : }
\DoxyCodeLine{  \textcolor{keyword}{public} RefineableQuadMesh<ELEMENT>,}
\DoxyCodeLine{  \textcolor{keyword}{public} \textcolor{keyword}{virtual} MyAlgebraicCollapsibleChannelMesh<ELEMENT>}
\DoxyCodeLine{\{ }
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}: }
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Constructor: Pass number of elements in upstream/collapsible/}}
\DoxyCodeLine{\textcolor{comment}{ /// downstream segment and across the channel; lengths of upstream/}}
\DoxyCodeLine{\textcolor{comment}{ /// collapsible/downstream segments and width of channel, pointer to }}
\DoxyCodeLine{\textcolor{comment}{ /// GeomObject that defines the collapsible segment, function pointer}}
\DoxyCodeLine{\textcolor{comment}{ /// to "{}boundary layer squash function"{}, and pointer to }}
\DoxyCodeLine{\textcolor{comment}{ /// TimeStepper (defaults to the default timestepper, Steady). }}
\DoxyCodeLine{\textcolor{comment}{} MyRefineableAlgebraicCollapsibleChannelMesh(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& nup, }
\DoxyCodeLine{                                             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& ncollapsible, }
\DoxyCodeLine{                                             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& ndown, }
\DoxyCodeLine{                                             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& ny, }
\DoxyCodeLine{                                             \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& lup, }
\DoxyCodeLine{                                             \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& lcollapsible, }
\DoxyCodeLine{                                             \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& ldown, }
\DoxyCodeLine{                                             \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& ly,}
\DoxyCodeLine{                                             GeomObject* wall\_pt,}
\DoxyCodeLine{                                             TimeStepper* time\_stepper\_pt=}
\DoxyCodeLine{                                             \&Mesh::Default\_TimeStepper) :}
\DoxyCodeLine{  CollapsibleChannelMesh<ELEMENT>(nup, ncollapsible, ndown, ny,}
\DoxyCodeLine{                                  lup, lcollapsible, ldown, ly,}
\DoxyCodeLine{                                  wall\_pt,}
\DoxyCodeLine{                                  time\_stepper\_pt),}
\DoxyCodeLine{  MyAlgebraicCollapsibleChannelMesh<ELEMENT>(nup, ncollapsible, ndown, ny,}
\DoxyCodeLine{                                             lup, lcollapsible, ldown, ly,}
\DoxyCodeLine{                                             wall\_pt,}
\DoxyCodeLine{                                             time\_stepper\_pt)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Build quadtree forest}}
\DoxyCodeLine{   this-\/>setup\_quadtree\_forest();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}

\end{DoxyCodeInclude}
 ~\newline
 Note that none of the functions defined in the non-\/refineable version of this mesh have to be re-\/implemented. This raises the question of how the node-\/update data for any newly created nodes are determined when the mesh is refined. By default, the reference values for any newly created {\ttfamily Algebraic\+Nodes} are determined by interpolation from the node\textquotesingle{}s \char`\"{}father element\char`\"{}. Furthermore, it is assumed ~\newline
 that the same {\ttfamily Geom\+Objects} are involved in the node-\/update function for the newly created node. ~\newline
 This default behaviour is appropriate for the mesh considered here. In other cases, (e.\+g. in the corresponding \href{../../../interaction/fsi_collapsible_channel_algebraic/html/index.html}{\texttt{ fluid-\/structure interaction problem}}), some or all of the node-\/update data may have to be recomputed when the mesh is adapted. Such updates may be performed by the {\ttfamily Algebraic\+Mesh\+::update\+\_\+node\+\_\+update(...)} function which is executed automatically whenever a refineable {\ttfamily Algebraic\+Mesh} is adapted. ~\newline
~\newline

\item {\bfseries{Node updates for hanging nodes\+:}} ~\newline
 ~\newline
 Recall that refineable meshes may contain hanging nodes whose position is constrained by its \char`\"{}master nodes\char`\"{}. When the {\ttfamily Algebraic\+Node\+::node\+\_\+update(...)} function is called for a hanging node, it first updates the position of its master nodes (using their own node-\/update functions) and then updates its own constrained position accordingly. ~\newline
~\newline

\item {\bfseries{Automatic finite-\/differencing with respect to geometric Data\+:}} ~\newline
~\newline
 Algebraic node updates are particularly useful in fluid-\/structure interaction problems since they allow the development of \char`\"{}sparse\char`\"{} node update procedures in which each (solid mechanics) degree of freedom only affects the position of a small number of nodes in the fluid mesh. We will discuss fluid-\/structure interaction problems in more detail \href{../../../interaction/fsi_collapsible_channel_algebraic/html/index.html}{\texttt{ elsewhere}} but stress already that one of the major complications in such problems (and, in fact, in any free-\/boundary problem) is the need to evaluate the so-\/called shape derivatives -- the derivatives of the \char`\"{}bulk\char`\"{} (here the Navier-\/\+Stokes) equations with respect to the degrees of freedom (here the nodal positions in the wall mesh) that affect the position of the nodes in the \char`\"{}bulk\char`\"{} mesh. ~\newline
~\newline
 The algebraic node update procedures discussed above are sufficiently general to handle such interactions. The shape/position of the {\ttfamily Geom\+Objects} that are involved in an {\ttfamily Algebraic\+Node\textquotesingle{}s} node update, may depend on unknowns in the overall problem. Such unknowns constitute a {\ttfamily Geom\+Object\textquotesingle{}s} geometric {\ttfamily Data} which may be obtained from its member function {\ttfamily Geom\+Object\+::geom\+\_\+data\+\_\+pt(...)}. {\ttfamily Algebraic\+Elements} use finite differencing to include the shape derivatives (i.\+e. the derivatives of the residuals of the underlying (wrapped) element with respect to the geometric {\ttfamily Data} involved in the element\textquotesingle{}s node update) into the element\textquotesingle{}s Jacobian matrix. ~\newline
~\newline

\item {\bfseries{Additional sanity checks and other generalisations\+:}} ~\newline
 ~\newline
 The {\ttfamily My\+Algebraic\+Collapsible\+Channel\+Mesh} and its refineable equivalent are slightly simplified versions of the meshes in {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily src/meshes} directory. These meshes contain a number of additional sanity checks that we omitted here for the sake of brevity. Furthermore, these meshes can be used with {\ttfamily Geom\+Objects} that comprise \char`\"{}sub-\/\char`\"{}{\ttfamily Geom\+Objects}, a feature that is essential in problems with proper fluid-\/structure interaction. We will discuss this in \href{../../../interaction/fsi_collapsible_channel_algebraic/html/index.html}{\texttt{ another example.}}
\end{DoxyItemize}\hypertarget{index_exx}{}\doxysubsection{Exercises}\label{index_exx}

\begin{DoxyEnumerate}
\item If you inspect the ~\newline
 \href{../../../../demo_drivers/navier_stokes/collapsible_channel/my_alg_channel_mesh.h}{\texttt{ source code}} for the {\ttfamily My\+Algebraic\+Collapsible\+Channel\+Mesh}, you will notice that the mesh has an additional constructor that allows the specification of the \char`\"{}boundary layer squash function\char`\"{} first introduced in the original {\ttfamily Collapsible\+Channel\+Mesh}. Explain why in the {\ttfamily Algebraic\+Mesh} version of this mesh, the function pointer to the \char`\"{}boundary layer    squash function\char`\"{} can only be specified via the constructor -- the access function is deliberately broken.
\end{DoxyEnumerate}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/navier_stokes/collapsible_channel/}{\texttt{ demo\+\_\+drivers/navier\+\_\+stokes/collapsible\+\_\+channel/ }} \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/navier_stokes/collapsible_channel/collapsible_channel_algebraic.cc}{\texttt{ demo\+\_\+drivers/navier\+\_\+stokes/collapsible\+\_\+channel/collapsible\+\_\+channel\+\_\+algebraic.\+cc }} \end{center} 
\end{DoxyItemize}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{PDF file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
