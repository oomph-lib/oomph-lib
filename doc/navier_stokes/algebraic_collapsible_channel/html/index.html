<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Demo problem: Flow in a 2D channel with an oscillating wall revisited &ndash; AlgebraicElements: How to customise the mesh update</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.2 -->
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Demo problem: Flow in a 2D channel with an oscillating wall revisited &ndash; AlgebraicElements: How to customise the mesh update </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >In many previous examples we illustrated how <code>oomph-lib's</code> <code>Domain</code> and <code>MacroElement</code> objects facilitate the generation of refineable (and non-refineable) meshes in domains with moving, curvilinear boundaries. Consult, for instance:</p>
<ul>
<li>The tutorial <a href="../../../poisson/fish_poisson2/html/index.html">"How to create refineable meshes in domains with curvilinear and/or
  moving boundaries"</a> for a general discussion of the methodology. <br  />
<br  />
</li>
<li>The tutorial <a href="../../../unsteady_heat/two_d_unsteady_heat_ALE/html/index.html">"Spatially adaptive solution of the 2D unsteady heat equation with 
  flux boundary conditions in a moving domain: ALE methods"</a> for an example involving the unsteady heat equation. <br  />
<br  />
</li>
<li>The tutorials <br  />
<br  />
<ul>
<li><a href="../../../navier_stokes/osc_ellipse/html/index.html">"Finite-Reynolds-number flow inside an oscillating ellipse"</a> <br  />
<br  />
</li>
</ul>
or<ul>
<li><a href="../../../navier_stokes/collapsible_channel/html/index.html">"Flow in a 2D channel with an oscillating wall"</a> <br  />
<br  />
</li>
</ul>
for examples involving the Navier-Stokes equations.</li>
</ul>
<p>The two main features of the <code>MacroElement/Domain</code> - based node-update are that, once the curvilinear domain is represented by a <code>Domain</code> object</p><ol type="1">
<li>Any subsequent mesh refinement will respect the curvilinear domain boundaries. <br  />
<br  />
</li>
<li>The udate of the nodal positions in response to a change in the position of the domain's curvilinear boundaries may be performed by the "black-box" function <code>Mesh::node_update()</code>.</li>
</ol>
<p >The availability of a "black-box" node-update procedure is very convenient but in some applications it may be desirable (or even necessary) to provide a customised node-update function, either because the mesh deformation generated by the "black-box" procedure is not appropriate or because it is not efficient. The latter problem arises particularly in fluid-structure interaction problems.</p>
<p >In this tutorial we shall demonstrate an alternative node-update technique, based on <code>oomph-lib's</code> <code>AlgebraicNode</code>, <code>AlgebraicElement</code>, and <code>AlgebraicMesh</code> classes. The key feature of this approach is that it allows "each node to update its own
position". This is in contrast to the <code>Domain/MacroElement-based</code> approach in which we can only update the nodal positions of <em>all</em> nodes in the mesh simultaneously &ndash; not a particularly sparse operation! [We note that the <code>Node</code> and <code>FiniteElement</code> base classes provide the virtual functions <code>Node::node_update()</code> and <code>FiniteElement::node_update()</code>. These functions are intended to be used for node-by-node or element-by-element node-updates but in their default implementations they are empty. Hence no node-update is performed unless these functions are overloaded in derived classes such as <code>AlgebraicNode</code> and <code>AlgebraicElement</code>.]</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="overview"></a>
Overview</h1>
<p >The idea behind the algebraic node-updates is simple: The <code>AlgebraicMesh</code> class (the base class for meshes containing <code>AlgebraicElements</code> and <code>AlgebraicNodes</code>) contains the pure virtual function</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> AlgebraicMesh::algebraic_node_update(..., AlgebraicNode* node_pt)=0;</div>
</div><!-- fragment --><p >which must be implemented in every specific <code>AlgebraicMesh</code>. Its task is to update the position of the node specified by the pointer-valued argument. <br  />
<br  />
 The specific implementation of the node-update operation is obviously problem-dependent but it is easy to illustrate the general procedure by considering the collapsible channel mesh sketched below:</p>
<div class="image">
<img src="alg_node_update_sketch.gif" alt=""/>
<div class="caption">
Sketch of the algebraic node-update procedure for the collapsible channel mesh. </div></div>
 <p >The upper figure shows the mesh in the undeformed domain in which wall shape is parametrised by the intrinsic (Lagrangian) coordinate <img class="formulaInl" alt="$ \zeta $" src="form_4.png" width="6" height="13"/> as <img class="formulaInl" alt="$ {\bf R}(\zeta,t=0) = (L_{up} + \zeta, 1) ^T. $" src="form_5.png" width="151" height="15"/> In this configuration each node is located at a certain fraction along the vertical lines across the channel. For instance, the <img class="formulaInl" alt="$ j$" src="form_6.png" width="6" height="11"/>-th node (drawn in blue) is located at a fraction of <img class="formulaInl" alt="$ \omega_j = 1/3 $" src="form_7.png" width="50" height="14"/> along the straight line that connects reference point <img class="formulaInl" alt="$ {\bf A}_j $" src="form_8.png" width="16" height="14"/> on the bottom wall to reference point <img class="formulaInl" alt="$ {\bf B}_j $" src="form_9.png" width="15" height="14"/> on the flexible upper wall. We note that reference point <img class="formulaInl" alt="$ {\bf B}_j $" src="form_9.png" width="15" height="14"/> may be identified by its Lagrangian coordinate <img class="formulaInl" alt="$ \zeta_j $" src="form_10.png" width="10" height="14"/> on the wall.</p>
<p >The lower figure shows a sketch of the deformed domain and illustrates a possible algebraic node-update strategy: Given the new wall shape, described by <img class="formulaInl" alt="$ {\bf R}(\zeta,t) $" src="form_11.png" width="38" height="14"/>, we position each node on the straight line that connects its reference point <img class="formulaInl" alt="$ {\bf A}'_j = {\bf A}_j $" src="form_12.png" width="49" height="15"/> on the lower wall to the reference point <img class="formulaInl" alt="$ {\bf B}'_j = {\bf R}(\zeta_j,t) $" src="form_13.png" width="74" height="15"/> on the deformable upper wall.</p>
<p >To perform this node-update procedure for a specific node, we generally have to store</p><ul>
<li>A pointer to one (or more) <code>GeomObject(s)</code> that define the curvilinear domain boundaries. <br  />
<br  />
</li>
<li>A number of node-specific reference values (such as <img class="formulaInl" alt="$ \omega_j, \ \zeta_j $" src="form_14.png" width="34" height="14"/>, and the <img class="formulaInl" alt="$ x_1 $" src="form_15.png" width="13" height="9"/> -coordinate of point <img class="formulaInl" alt="$ {\bf A}_j $" src="form_8.png" width="16" height="14"/>, <img class="formulaInl" alt="$ X^{(A)}_j $" src="form_16.png" width="28" height="20"/>, say) that establish the node's position relative to these <code>GeomObjects</code>. <br  />
<br  />
</li>
<li>A pointer to the <code>AlgebraicMesh</code> that implements the node-update procedure.</li>
</ul>
<p>Since the node-update data is node-specific, we provide storage for it in the <code>AlgebraicNode</code> class &ndash; a class that is derived from the <code>Node</code> class. The node-update function itself is shared by many nodes in the mesh and is implemented in <code>AlgebraicMesh::algebraic_node_update(...)</code>. This function extracts the node-update parameters, <img class="formulaInl" alt="$ \omega_j, \ \zeta_j $" src="form_14.png" width="34" height="14"/>, and <img class="formulaInl" alt="$ X^{(A)}_j $" src="form_16.png" width="28" height="20"/> and the pointer to the <code>GeomObject</code> that parametrises the wall, <code>wall_pt</code>, say, from the <code>AlgebraicNode</code> passed to it. With these parameters, the position of reference point <img class="formulaInl" alt="${\bf A}'_j $" src="form_17.png" width="16" height="15"/> is given by <img class="formulaInl" alt="$ {\bf A}'_j = (X_j^{(A)},0)^T $" src="form_18.png" width="90" height="20"/> while the coordinates of reference point <img class="formulaInl" alt="$ {\bf B}'_j = {\bf R}(\zeta_j,t)$" src="form_19.png" width="74" height="15"/> may be obtained from a call to <code>wall_pt-&gt;position(...)</code>. The nodal position <img class="formulaInl" alt="$ {\bf r}_j $" src="form_20.png" width="11" height="10"/> may then be updated via </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf r}_j = {\bf A}_j' + \omega_j \left( {\bf B}_j'-{\bf A}_j' \right) \]" src="form_21.png" width="131" height="16"/>
</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="how_to_use"></a>
How to use existing AlgebraicMeshes</h1>
<p >To use the algebraic node-update capabilities of an existing <code>AlgebraicMesh</code>, all <code>Nodes</code> must be replaced by <code>AlgebraicNodes</code> to allow the storage of the node-specific node-update parameters. Recall that within <code>oomph-lib</code> <code>Nodes</code> are usually created by the elements, using the function <code>FiniteElement::construct_node(...)</code> whose argument specifies the local node number of the newly created <code>Node</code> within the element that creates it. (The specification of the local node number is required to allow the <code>FiniteElement::construct_node(...)</code> function to create a <code>Node</code> with the appropriate number of values and history values. For instance, in 2D Taylor-Hood Navier-Stokes elements, the elements' vertex nodes have to store three values, representing the two velocity components and the pressure, whereas all other nodes only require storage for the two velocity components.)</p>
<p >To ensure that the <code>FiniteElement::construct_node(...)</code> function creates <code>AlgebraicNodes</code> rather than "ordinary" <code>Nodes</code>, we provide the templated wrapper class</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;ELEMENT&gt;</div>
<div class="line"><span class="keyword">class </span>AlgebraicElement&lt;ELEMENT&gt; : <span class="keyword">public</span> ELEMENT</div>
</div><!-- fragment --><p >which overloads the <code>FiniteElement::construct_node(...)</code> function so that it creates <code>AlgebraicNodes</code> instead. In most other respects, the "wrapped" element behaves exactly as the underlying <code>ELEMENT</code> itself. To use an existing <code>AlgebraicMesh</code> with a certain element type, <code>QTaylorHoodElement&lt;2&gt;</code>, say, we simply "upgrade" the element to an <code>AlgebraicElement</code> by specifying the element type as <code>AlgebraicElement&lt;QTaylorHoodElement&lt;2&gt;</code> &gt;. <br  />
</p>
<p >The changes to an existing driver code that performs the node update by the default <code>Domain/MacroElement</code> methodology are therefore completely trivial. You may wish to compare the driver code <a href="../../../../demo_drivers/navier_stokes/collapsible_channel/collapsible_channel.cc">collapsible_channel.cc</a>, discussed in <a href="../../collapsible_channel/html/index.html">an earlier example</a>, to the driver code <a href="../../../../demo_drivers/navier_stokes/collapsible_channel/collapsible_channel_algebraic.cc">collapsible_channel_algebraic.cc</a> in which the fluid domain is discretised by the <code>MyAlgebraicCollapsibleChannelMesh</code>, discussed below.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="how_to_write"></a>
How to create a new AlgebraicMesh â€“ a basic example</h1>
<p >To illustrate how to create a new <code>AlgebraicMesh</code>, we will now discuss the implementation of the <code>MyAlgebraicCollapsibleChannelMesh</code> &ndash; an <code>AlgebraicMesh</code> - version of the <code>CollapsibleChannelMesh</code>, used in <a href="../../collapsible_channel/html/index.html">the earlier example</a>.</p>
<hr  />
<h2><a class="anchor" id="class"></a>
The class definition</h2>
<p >We construct the mesh by multiple inheritance from the <code>AlgebraicMesh</code> base class, and the already-existing <code>CollapsibleChannelMesh</code>. The constructor first calls the constructor of the underlying <code>CollapsibleChannelMesh</code> (thus "recycling" the basic mesh generation process, i.e. the generation of nodes and elements etc.) and then adds the algebraic node-update information by calling the function <code>setup_algebraic_node_update()</code>.</p>
 <div class="fragment"><div class="line"><span class="comment">//===========start_algebraic_mesh==================================</span></div>
<div class="line"><span class="comment">/// Collapsible channel mesh with algebraic node update</span></div>
<div class="line"><span class="comment">//=================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keyword">class </span>MyAlgebraicCollapsibleChannelMesh : </div>
<div class="line">  <span class="keyword">public</span> AlgebraicMesh,</div>
<div class="line">  <span class="keyword">public</span> <span class="keyword">virtual</span> CollapsibleChannelMesh&lt;ELEMENT&gt;</div>
<div class="line">{ </div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>: </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Constructor: Pass number of elements in upstream/collapsible/</span></div>
<div class="line"><span class="comment"> /// downstream segment and across the channel; lengths of upstream/</span></div>
<div class="line"><span class="comment"> /// collapsible/downstream segments and width of channel, pointer to </span></div>
<div class="line"><span class="comment"> /// GeomObject that defines the collapsible segment, and pointer to </span></div>
<div class="line"><span class="comment"> /// TimeStepper (defaults to the default timestepper, Steady). </span></div>
<div class="line"><span class="comment"></span> MyAlgebraicCollapsibleChannelMesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; nup, </div>
<div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ncollapsible, </div>
<div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ndown, </div>
<div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ny, </div>
<div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; lup, </div>
<div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; lcollapsible, </div>
<div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ldown, </div>
<div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ly,</div>
<div class="line">                                   GeomObject* wall_pt,</div>
<div class="line">                                   TimeStepper* time_stepper_pt=</div>
<div class="line">                                   &amp;Mesh::Default_TimeStepper) :</div>
<div class="line">  CollapsibleChannelMesh&lt;ELEMENT&gt;(nup, ncollapsible, ndown, ny,</div>
<div class="line">                                  lup, lcollapsible, ldown, ly,</div>
<div class="line">                                  wall_pt,</div>
<div class="line">                                  time_stepper_pt)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Setup algebraic node update operations</span></div>
<div class="line">   setup_algebraic_node_update();</div>
<div class="line">  }</div>
</div><!-- fragment --><p> We declare the interface for the pure virtual function <code>algebraic_node_update(...)</code>, to be discussed below, and implement a second pure virtual function, <code>AlgebraicMesh::update_node_update()</code>, that may be used to update reference values following a mesh adaptation. Since the current mesh is not refineable, we leave this function empty and refer to <a href="../../../interaction/fsi_collapsible_channel_adapt/html/index.html">another example</a> for a more detailed discussion of its role.</p>
<div class="fragment"><div class="line"><span class="comment"> /// Update nodal position at time level t (t=0: present; </span></div>
<div class="line"><span class="comment"> /// t&gt;0: previous)</span></div>
<div class="line"> <span class="keywordtype">void</span> algebraic_node_update(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; t, AlgebraicNode*&amp; node_pt);</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Update the geometric references that are used </span></div>
<div class="line"><span class="comment"> /// to update node after mesh adaptation.</span></div>
<div class="line"><span class="comment"> /// Empty -- no update of node update required</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> update_node_update(AlgebraicNode*&amp; node_pt) {}</div>
</div><!-- fragment --><p> The protected member function <code>setup_algebraic_node_update()</code> will be discussed below.</p>
<div class="fragment"><div class="line"><span class="keyword">protected</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Function to setup the algebraic node update</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> setup_algebraic_node_update();</div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Dummy function pointer </span></div>
<div class="line"><span class="comment"></span> CollapsibleChannelDomain::BLSquashFctPt Dummy_fct_pt;</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --> <hr  />
<h2><a class="anchor" id="setting_up"></a>
Setting up the algebraic node update</h2>
<p >When the function <code>setup_algebraic_node_update()</code> is called, the constructor of the underlying <code>CollapsibleChannelMesh</code> will already have created the mesh's elements and nodes, and the nodes will be located at their initial positions in the undeformed domain.</p>
<p >To set up the algebraic node-update data, we start by extracting the lengths of the upstream rigid section, <img class="formulaInl" alt="$ L_{up} $" src="form_22.png" width="20" height="14"/>, and the length of the collapsible segment, <img class="formulaInl" alt="$ L_{collapsible} $" src="form_23.png" width="55" height="14"/>, from the <code>CollapsibleChannelDomain:</code> </p>
<div class="fragment"><div class="line"><span class="comment">//============start_setup_algebraic_node_update====================</span></div>
<div class="line"><span class="comment">/// Setup algebraic mesh update -- assumes that mesh has</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// initially been set up with the wall in its undeformed position.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> MyAlgebraicCollapsibleChannelMesh&lt;ELEMENT&gt;::setup_algebraic_node_update()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Extract some reference lengths from the CollapsibleChannelDomain. </span></div>
<div class="line"> <span class="keywordtype">double</span> l_up=this-&gt;domain_pt()-&gt;l_up();</div>
<div class="line"> <span class="keywordtype">double</span> l_collapsible=this-&gt;domain_pt()-&gt;l_collapsible();</div>
</div><!-- fragment --><p> Next, we loop over all <code>AlgebraicNodes</code> in the mesh and determine their current positions:</p>
<div class="fragment"><div class="line"> <span class="comment">// Loop over all nodes in mesh</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nnod=this-&gt;nnode();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0;j&lt;nnod;j++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Get pointer to node</span></div>
<div class="line">   AlgebraicNode* nod_pt=node_pt(j);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Get coordinates</span></div>
<div class="line">   <span class="keywordtype">double</span> x=nod_pt-&gt;x(0);</div>
<div class="line">   <span class="keywordtype">double</span> y=nod_pt-&gt;x(1);</div>
</div><!-- fragment --><p >If the <code>j</code> -th node is located in the "collapsible" section of the mesh we determine its reference coordinate, <img class="formulaInl" alt="$ \zeta_j $" src="form_10.png" width="10" height="14"/>, on the wall and determine the coordinates of its reference point <img class="formulaInl" alt="$ {\bf B}_j $" src="form_9.png" width="15" height="14"/> from the <code>GeomObject</code> that represents the moving wall.</p>
<div class="fragment"><div class="line">   <span class="comment">// Check if the node is in the collapsible part:</span></div>
<div class="line">   <span class="keywordflow">if</span> ( (x&gt;=l_up) &amp;&amp; (x&lt;=(l_up+l_collapsible)) )</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Get zeta coordinate on the undeformed wall</span></div>
<div class="line">     Vector&lt;double&gt; zeta(1);</div>
<div class="line">     zeta[0]=x-l_up;</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Get position vector to wall:</span></div>
<div class="line">     Vector&lt;double&gt; r_wall(2);</div>
<div class="line">     this-&gt;Wall_pt-&gt;position(zeta,r_wall);</div>
</div><!-- fragment --><p> Just to be on the safe side, we check that the wall is actually in its undeformed configuration, as assumed.</p>
<div class="fragment"><div class="line">     <span class="comment">// Sanity check: Confirm that the wall is in its undeformed position</span></div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line">     <span class="keywordflow">if</span> ((std::abs(r_wall[0]-x)&gt;1.0e-15)&amp;&amp;(std::abs(r_wall[1]-y)&gt;1.0e-15))</div>
<div class="line">      {</div>
<div class="line">       std::ostringstream error_stream;</div>
<div class="line">       error_stream </div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;Wall must be in its undeformed position when\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;algebraic node update information is set up!\n &quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;x-discrepancy: &quot;</span> &lt;&lt; std::abs(r_wall[0]-x) &lt;&lt; std::endl</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;y-discrepancy: &quot;</span> &lt;&lt; std::abs(r_wall[1]-y) &lt;&lt; std::endl;</div>
<div class="line">       </div>
<div class="line">       <span class="keywordflow">throw</span> OomphLibError(</div>
<div class="line">        error_stream.str(),</div>
<div class="line">        OOMPH_CURRENT_FUNCTION,</div>
<div class="line">        OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">      }</div>
<div class="line"><span class="preprocessor">#endif       </span></div>
</div><!-- fragment --><p> Next, we package the data required for the node-update operations (the pointers to <code>GeomObject(s)</code> and the reference values) into vectors. In the present example, the node-update operation only involves a single <code>GeomObject:</code> </p>
<div class="fragment"><div class="line">     <span class="comment">// Only a single geometric object is involved in the node update operation</span></div>
<div class="line">     Vector&lt;GeomObject*&gt; geom_object_pt(1);</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// The wall geometric object</span></div>
<div class="line">     geom_object_pt[0]=this-&gt;Wall_pt;</div>
</div><!-- fragment --><p> We have three reference values: The <img class="formulaInl" alt="$ x_1 $" src="form_15.png" width="13" height="9"/> - coordinate of point <img class="formulaInl" alt="$ {\bf A}_j $" src="form_8.png" width="16" height="14"/>,</p>
<div class="fragment"><div class="line">     <span class="comment">// The update function requires three parameters:</span></div>
<div class="line">     Vector&lt;double&gt; ref_value(3);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// First reference value: Original x-position on the lower wall </span></div>
<div class="line">     ref_value[0]=r_wall[0];</div>
</div><!-- fragment --><p> as well as the fractional height, <img class="formulaInl" alt="$ \omega_j $" src="form_24.png" width="13" height="10"/>,</p>
<div class="fragment"><div class="line">     <span class="comment">// Second reference value: Fractional position along </span></div>
<div class="line">     <span class="comment">// straight line from the bottom (at the original x-position)</span></div>
<div class="line">     <span class="comment">// to the point on the wall</span></div>
<div class="line">     ref_value[1]=y/r_wall[1];</div>
</div><!-- fragment --><p> and the reference coordinate, <img class="formulaInl" alt="$ \zeta_j $" src="form_10.png" width="10" height="14"/>, along the wall:</p>
<div class="fragment"><div class="line">     <span class="comment">// Third reference value: Zeta coordinate on wall</span></div>
<div class="line">     ref_value[2]=zeta[0];   </div>
</div><!-- fragment --><p> The vectors of reference values and geometric objects are then passed to the node, together with the pointer to the mesh (<code>this</code>) that implements the node-update function.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">     <span class="comment">// Setup algebraic update for node: Pass update information</span></div>
<div class="line">     <span class="comment">// to AlgebraicNode:</span></div>
<div class="line">     nod_pt-&gt;add_node_update_info(</div>
<div class="line">      <span class="keyword">this</span>,               <span class="comment">// mesh</span></div>
<div class="line">      geom_object_pt,     <span class="comment">// vector of geom objects</span></div>
<div class="line">      ref_value);         <span class="comment">// vector of ref. values</span></div>
<div class="line">    }</div>
<div class="line">   </div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">//end of setup_algebraic_node_update</span></div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="node_update"></a>
The node-update function</h2>
<p >The function <code>algebraic_node_update(...)</code> reverses the setup process: It extracts the node-update data from the <code>AlgebraicNode</code> and updates its position at the <code>t</code> -th previous time-level:</p>
<div class="fragment"><div class="line"><span class="comment">//=============start_of_algebraic_node_update======================</span></div>
<div class="line"><span class="comment">/// Perform algebraic mesh update at time level t (t=0: present; </span><span class="comment"></span></div>
<div class="line"><span class="comment">/// t&gt;0: previous)</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> MyAlgebraicCollapsibleChannelMesh&lt;ELEMENT&gt;::algebraic_node_update(</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; t, AlgebraicNode*&amp; node_pt)</div>
<div class="line">{</div>
</div><!-- fragment --><p> We start by extracting the vectors of reference values and <code>GeomObjects</code> involved in this node's node-update, using the functions <code>AlgebraicNode::vector_ref_value()</code> which returns a Vector of reference values, and the function <br  />
 <code>AlgebraicNode::vector_geom_object_pt()</code> which returns a Vector of pointers to <code>GeomObjects</code>.</p>
<div class="fragment"><div class="line"> <span class="comment">// Extract reference values for update by copy construction</span></div>
<div class="line"> Vector&lt;double&gt; ref_value(node_pt-&gt;vector_ref_value());</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Extract geometric objects for update by copy construction</span></div>
<div class="line"> Vector&lt;GeomObject*&gt; geom_object_pt(node_pt-&gt;vector_geom_object_pt());</div>
</div><!-- fragment --><p> Next, we translate these into local variables,</p>
<div class="fragment"><div class="line"> <span class="comment">// First reference value: Original x-position </span></div>
<div class="line"> <span class="keywordtype">double</span> x_bottom=ref_value[0];</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Second reference value: Fractional position along </span></div>
<div class="line"> <span class="comment">// straight line from the bottom (at the original x-position)</span></div>
<div class="line"> <span class="comment">// to the point on the wall</span></div>
<div class="line"> <span class="keywordtype">double</span> fract=ref_value[1];</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Third reference value: Zeta coordinate on wall</span></div>
<div class="line"> Vector&lt;double&gt; zeta(1);</div>
<div class="line"> zeta[0]=ref_value[2];</div>
<div class="line">     </div>
<div class="line"> <span class="comment">// Pointer to wall geom object</span></div>
<div class="line"> GeomObject* wall_pt=geom_object_pt[0];</div>
</div><!-- fragment --><p >and obtain the current wall position from the wall <code>GeomObject</code>.</p>
<div class="fragment"><div class="line"> <span class="comment">// Get position vector to wall at previous timestep t</span></div>
<div class="line"> Vector&lt;double&gt; r_wall(2);</div>
<div class="line"> wall_pt-&gt;position(t,zeta,r_wall);</div>
</div><!-- fragment --><p> Finally, we update the nodal position:</p>
<div class="fragment"><div class="line"> <span class="comment">// Assign new nodal coordinates</span></div>
<div class="line"> node_pt-&gt;x(t,0)=x_bottom+fract*(r_wall[0]-x_bottom);</div>
<div class="line"> node_pt-&gt;x(t,1)=         fract* r_wall[1];</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p> Done!</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="comments"></a>
Comments and Exercises</h1>
<h2><a class="anchor" id="comm"></a>
Comments</h2>
<ul>
<li><b>Element-by-element and global node updates:</b> <br  />
 <br  />
 As explained above, the re-implementation of the (empty) <code>Node::node_update()</code> function by <code>AlgebraicNode::node_update()</code> allows each node to "update its 
  own position". The <code>AlgebraicMesh</code> and <code>AlgebraicElement</code> classes provide their own re-implementation of the <code>node_update()</code> functions in the <code>Mesh</code> and <code>FiniteElement</code> classes, and perform the node-updates by executing the <code>AlgebraicNode::node_update()</code> function of their constituent nodes. <br  />
<br  />
</li>
<li><b>Default node-update function:</b> <br  />
 <br  />
 We stress that, in the above example, it was only necessary to set up the node-update data for the nodes in the central "collapsible" part of the mesh as they are the only modes whose position is affected by the motion of the curvilinear boundary. This is possible because the <code>AlgebraicNode</code> constructor provides default assignments for the node-update data. In particular, the pointer to the Mesh that performs the node update is initialised by a pointer to the (static instantiation of a) <code>DummyMesh</code> whose <code>AlgebraicMesh::algebraic_node_update(...)</code> and <code>AlgebraicMesh::update_node_update(...)</code> functions are empty. This ensures that nodes for which these default assignments are not overwritten stay at their original position when the node udate is performed. This implementation provides a sensible default behaviour for the node update. <br  />
<br  />
</li>
<li><b>Multiple node-update functions:</b> <br  />
 <br  />
 In the simple example considered here, a single node-update function was sufficient to update the positions of all moving nodes in the mesh. In more complicated meshes, it may be be necessary to provide different node-update functions for nodes that are located in different parts of the mesh. To facilitate the implementation of such cases, it is possible to specify an identifier for the node-update function when calling the <code>AlgebraicNode::add_node_update_info(...)</code> function, using its alternative interface <div class="fragment"><div class="line"><span class="keywordtype">void</span> AlgebraicNode::add_node_update_info(</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; <span class="keywordtype">id</span>,                              <span class="comment">// ID of the node-update fct</span></div>
<div class="line">    AlgebraicMesh* mesh_pt,                     <span class="comment">// pointer to mesh</span></div>
<div class="line">    <span class="keyword">const</span> Vector&lt;GeomObject*&gt;&amp; geom_object_pt,  <span class="comment">// vector of geom objects</span></div>
<div class="line">    <span class="keyword">const</span> Vector&lt;double&gt;&amp; ref_value);           <span class="comment">// vector of ref. values</span></div>
</div><!-- fragment --> When implementing the <code>AlgebraicMesh::algebraic_node_update(...)</code> function for a mesh that contains multiple node-update functions, the ID of the node-update function associated with a particular node can be obtained from <code>AlgebraicNode::node_update_fct_id()</code>, allowing the node-update function to take the appropriate action. (As an example, consider the implementation of the algebraic node-update function for the <code>RefineableAlgebraicFishMesh</code> in which different node-update functions are used to update the position of nodes in the fish's "body" and in its "tail".) If the <code>AlgebraicNode::add_node_update_info(...)</code> function is called without specifying an ID, a default ID of 0 is assigned. <br  />
<br  />
</li>
<li><b>Consistency between multiple node-update functions:</b> <br  />
 <br  />
 If a mesh contains multiple node-update functions, it is likely that some nodes are located at the interface between regions that are updated by different node-update functions. As indicated by the <code>"add_..."</code> in the <code>AlgebraicNode::add_node_update_info(...)</code> function, <code>AlgebraicNodes</code> may be associated with multiple node-update functions, though the different node-update functions associated with a node must, of course, give the same result. This may be verified by calling the <code>AlgebraicNode::self_test()</code> function for all nodes in an <code>AlgebraicMesh</code>. <br  />
 <br  />
 <b>Note:</b> In refineable <code>AlgebraicMeshes</code> (discussed in more detail below), <code>AlgebraicNodes</code> <b>must</b> be associated with all possible node-update functions to ensure that the reference values for newly created nodes are determined correctly during the adaptive mesh refinement. <br  />
<br  />
</li>
<li><b>Adaptivity:</b> <br  />
 <br  />
 Refineable <code>AlgebraicMeshes</code> may be created by multiple inheritance from a suitable <code>RefineableMesh</code> base class (e.g. the <code>RefineableQuadMesh</code> class), and setting up the required tree representation of the coarse initial mesh, exactly as for "ordinary" meshes (see the tutorial <a href="../../../poisson/two_d_poisson_adapt/html/index.html">"How to create simple refineable meshes"</a> for details). As an example, here is the class definition for a refineable version of the <code>MyAlgebraicCollapsibleChannelMesh</code> discussed above: <br  />
 <br  />
  <div class="fragment"><div class="line"><span class="comment">//===========start_refineable_algebraic_collapsible_channel_mesh======</span></div>
<div class="line"><span class="comment">/// Refineable version of the CollapsibleChannel mesh with</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// algebraic node update.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keyword">class </span>MyRefineableAlgebraicCollapsibleChannelMesh : </div>
<div class="line">  <span class="keyword">public</span> RefineableQuadMesh&lt;ELEMENT&gt;,</div>
<div class="line">  <span class="keyword">public</span> <span class="keyword">virtual</span> MyAlgebraicCollapsibleChannelMesh&lt;ELEMENT&gt;</div>
<div class="line">{ </div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>: </div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Constructor: Pass number of elements in upstream/collapsible/</span></div>
<div class="line"><span class="comment"> /// downstream segment and across the channel; lengths of upstream/</span></div>
<div class="line"><span class="comment"> /// collapsible/downstream segments and width of channel, pointer to </span></div>
<div class="line"><span class="comment"> /// GeomObject that defines the collapsible segment, function pointer</span></div>
<div class="line"><span class="comment"> /// to &quot;boundary layer squash function&quot;, and pointer to </span></div>
<div class="line"><span class="comment"> /// TimeStepper (defaults to the default timestepper, Steady). </span></div>
<div class="line"><span class="comment"></span> MyRefineableAlgebraicCollapsibleChannelMesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; nup, </div>
<div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ncollapsible, </div>
<div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ndown, </div>
<div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ny, </div>
<div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; lup, </div>
<div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; lcollapsible, </div>
<div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ldown, </div>
<div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ly,</div>
<div class="line">                                             GeomObject* wall_pt,</div>
<div class="line">                                             TimeStepper* time_stepper_pt=</div>
<div class="line">                                             &amp;Mesh::Default_TimeStepper) :</div>
<div class="line">  CollapsibleChannelMesh&lt;ELEMENT&gt;(nup, ncollapsible, ndown, ny,</div>
<div class="line">                                  lup, lcollapsible, ldown, ly,</div>
<div class="line">                                  wall_pt,</div>
<div class="line">                                  time_stepper_pt),</div>
<div class="line">  MyAlgebraicCollapsibleChannelMesh&lt;ELEMENT&gt;(nup, ncollapsible, ndown, ny,</div>
<div class="line">                                             lup, lcollapsible, ldown, ly,</div>
<div class="line">                                             wall_pt,</div>
<div class="line">                                             time_stepper_pt)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Build quadtree forest</span></div>
<div class="line">   this-&gt;setup_quadtree_forest();</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --> <br  />
 Note that none of the functions defined in the non-refineable version of this mesh have to be re-implemented. This raises the question of how the node-update data for any newly created nodes are determined when the mesh is refined. By default, the reference values for any newly created <code>AlgebraicNodes</code> are determined by interpolation from the node's "father element". Furthermore, it is assumed <br  />
 that the same <code>GeomObjects</code> are involved in the node-update function for the newly created node. <br  />
 This default behaviour is appropriate for the mesh considered here. In other cases, (e.g. in the corresponding <a href="../../../interaction/fsi_collapsible_channel_algebraic/html/index.html">fluid-structure interaction problem</a>), some or all of the node-update data may have to be recomputed when the mesh is adapted. Such updates may be performed by the <code>AlgebraicMesh::update_node_update(...)</code> function which is executed automatically whenever a refineable <code>AlgebraicMesh</code> is adapted. <br  />
<br  />
</li>
<li><b>Node updates for hanging nodes:</b> <br  />
 <br  />
 Recall that refineable meshes may contain hanging nodes whose position is constrained by its "master nodes". When the <code>AlgebraicNode::node_update(...)</code> function is called for a hanging node, it first updates the position of its master nodes (using their own node-update functions) and then updates its own constrained position accordingly. <br  />
<br  />
</li>
<li><b>Automatic finite-differencing with respect to geometric Data:</b> <br  />
<br  />
 Algebraic node updates are particularly useful in fluid-structure interaction problems since they allow the development of "sparse" node update procedures in which each (solid mechanics) degree of freedom only affects the position of a small number of nodes in the fluid mesh. We will discuss fluid-structure interaction problems in more detail <a href="../../../interaction/fsi_collapsible_channel_algebraic/html/index.html">elsewhere</a> but stress already that one of the major complications in such problems (and, in fact, in any free-boundary problem) is the need to evaluate the so-called shape derivatives &ndash; the derivatives of the "bulk" (here the Navier-Stokes) equations with respect to the degrees of freedom (here the nodal positions in the wall mesh) that affect the position of the nodes in the "bulk" mesh. <br  />
<br  />
 The algebraic node update procedures discussed above are sufficiently general to handle such interactions. The shape/position of the <code>GeomObjects</code> that are involved in an <code>AlgebraicNode's</code> node update, may depend on unknowns in the overall problem. Such unknowns constitute a <code>GeomObject's</code> geometric <code>Data</code> which may be obtained from its member function <code>GeomObject::geom_data_pt(...)</code>. <code>AlgebraicElements</code> use finite differencing to include the shape derivatives (i.e. the derivatives of the residuals of the underlying (wrapped) element with respect to the geometric <code>Data</code> involved in the element's node update) into the element's Jacobian matrix. <br  />
<br  />
</li>
<li><b>Additional sanity checks and other generalisations:</b> <br  />
 <br  />
 The <code>MyAlgebraicCollapsibleChannelMesh</code> and its refineable equivalent are slightly simplified versions of the meshes in <code>oomph-lib's</code> <code>src/meshes</code> directory. These meshes contain a number of additional sanity checks that we omitted here for the sake of brevity. Furthermore, these meshes can be used with <code>GeomObjects</code> that comprise "sub-"<code>GeomObjects</code>, a feature that is essential in problems with proper fluid-structure interaction. We will discuss this in <a href="../../../interaction/fsi_collapsible_channel_algebraic/html/index.html">another example.</a></li>
</ul>
<h2><a class="anchor" id="exx"></a>
Exercises</h2>
<ol type="1">
<li>If you inspect the <br  />
 <a href="../../../../demo_drivers/navier_stokes/collapsible_channel/my_alg_channel_mesh.h">source code</a> for the <code>MyAlgebraicCollapsibleChannelMesh</code>, you will notice that the mesh has an additional constructor that allows the specification of the "boundary layer squash function" first introduced in the original <code>CollapsibleChannelMesh</code>. Explain why in the <code>AlgebraicMesh</code> version of this mesh, the function pointer to the "boundary layer
   squash function" can only be specified via the constructor &ndash; the access function is deliberately broken.</li>
</ol>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory:<br  />
<br  />
<center> <a href="../../../../demo_drivers/navier_stokes/collapsible_channel/">demo_drivers/navier_stokes/collapsible_channel/ </a> </center><br  />
</li>
<li>The driver code is: <br  />
<br  />
<center> <a href="../../../../demo_drivers/navier_stokes/collapsible_channel/collapsible_channel_algebraic.cc">demo_drivers/navier_stokes/collapsible_channel/collapsible_channel_algebraic.cc </a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p >A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Wed Oct 27 2021 15:41:33
        </div>
      </div>
    </footer>
</body>
</html>
