<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Demo problem: Flow of a fluid film down an inclined plane</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Demo problem: Flow of a fluid film down an inclined plane </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The two-dimensional flow of a free surface down an inclined plane is a simple exact solution of the Navier&ndash;Stokes equations. We describe two different ways of solving the problem using either spines or a pseudo-elastic method to define the bulk mesh motion. Reassuringly, the results are the same irrespective of the method chosen.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="form"></a>
Problem formulation</h1>
<div class="image">
<img src="sketch.gif" alt=""/>
<div class="caption">
A film of incompressible viscous fluid of a given thickness flows down a plane inclined at a prescribed angle to the gravitational field. </div></div>
 <p>Formulating the problem in coordinates tangential ( <img class="formulaInl" alt="$x^{*}$" src="form_0.png" width="13" height="10"/>) and normal ( <img class="formulaInl" alt="$y^{*}$" src="form_1.png" width="13" height="13"/>) to the plane and assuming that the flow is steady and only in the tangential direction, but independent of the tangential coordinate, reduces the momentum equations to</p>
<center> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial p^*}{\partial x^*} = \rho \,g \sin\alpha + \mu\,\frac{\partial^{2} u^*}{\partial y^{*2}}, \]" src="form_2.png" width="138" height="31"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial p^*}{\partial y^*} = -\rho \,g \cos\alpha, \]" src="form_3.png" width="95" height="30"/>
</p>
 </center><p> where <img class="formulaInl" alt="$u^*$" src="form_4.png" width="13" height="10"/> is the velocity component tangential to the plane and <img class="formulaInl" alt="$p^*$" src="form_5.png" width="13" height="13"/> is the fluid pressure. Note that the continuity equation is automatically satisfied.</p>
<p>We non-dimensionalise using the only length-scale in the problem <img class="formulaInl" alt="$H$" src="form_6.png" width="11" height="10"/>, choosing the viscous scale for the pressure and choosing a reference velocity scale <img class="formulaInl" alt="$U$" src="form_7.png" width="10" height="10"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x^{*} = H x,\qquad y^{*} = H y,\qquad u^* = U u,\qquad p^* = \mu U/H,\]" src="form_8.png" width="299" height="14"/>
</p>
<p> and the governing equations become </p><center> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial p}{\partial x} = \frac{\rho \,g H^{2}}{\mu U} \sin\alpha + \frac{\partial^{2} u}{\partial y^{2}} = \frac{Re}{Fr} \sin \alpha + \frac{\partial^{2} u}{\partial y^{2}}, \]" src="form_9.png" width="238" height="31"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial p}{\partial y} = -\frac{\rho \,g H^{2}}{\mu U} \cos\alpha = - \frac{Re}{Fr} \cos\alpha. \]" src="form_10.png" width="183" height="31"/>
</p>
 </center><p> The dimensionless grouping <img class="formulaInl" alt="$ \rho g H^{2} / (\mu U) $" src="form_11.png" width="64" height="15"/> represents the ratio of gravitational forces to viscous forces and we choose to identify it as a Reynolds number <img class="formulaInl" alt="$ Re = \rho U H / \mu$" src="form_12.png" width="73" height="14"/> divided by a Froude number <img class="formulaInl" alt="$ Fr = U^{2} / (g H)$" src="form_13.png" width="80" height="15"/>.</p>
<p>We proceed by assuming that the flow is driven entirely by the gravitational body force and that there is no additional tangential pressure gradient. Then, integrating the tangential momentum balance twice and using the boundary conditions of no-slip at the plane ( <img class="formulaInl" alt="$y=0$" src="form_14.png" width="30" height="11"/>)and that the free surface ( <img class="formulaInl" alt="$y=1$" src="form_15.png" width="30" height="11"/>) is tangentially stress-free gives </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u = \frac{1}{2}\frac{Re}{Fr}\sin\alpha \left(2 y - y^{2}\right). \]" src="form_16.png" width="139" height="28"/>
</p>
<p> Integrating the normal momentum balance and setting the reference external pressure to be zero at the free surface gives </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ p = \frac{Re}{Fr}\cos\alpha (1 - y).\]" src="form_17.png" width="113" height="28"/>
</p>
<p>Finally, we specify a "natural" velocity scale by setting <img class="formulaInl" alt="$Re/Fr = 2$" src="form_18.png" width="60" height="14"/>, corresponding to the velocity of the free-surface for a vertical film ( <img class="formulaInl" alt="$\alpha = \pi/2$" src="form_19.png" width="44" height="14"/>).</p>
<p>We shall assess the stability of the flat-film solution by applying a small, short-duration perturbation to the wall velocity and evolving the system in time. If the interface is stable, the perturbation should decay, if not it should grow. A linear stability analysis for this problem was performed by Benjamin (1957) and Yih (1963), who both found that for long waves in the absence of surface tension, the interface was unstable when </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ Re &gt; \frac{5}{4} \sin\alpha. \]" src="form_20.png" width="71" height="26"/>
</p>
<p> (If you read the papers you will see that the Reynolds number was defined such that the average fluid downslope velocity was one; to convert to our Reynolds number, we must multiply by 3/2.)</p>
<p>The figure below shows the time evolution of the interface on a slope of <img class="formulaInl" alt="$ \pi/4 $" src="form_21.png" width="21" height="14"/> for Reynolds numbers of zero (red line) and <img class="formulaInl" alt="$ 4 \sin\alpha $" src="form_22.png" width="35" height="9"/> (green line). The perturbation wavenumber is <img class="formulaInl" alt="$ K = 0.1 $" src="form_23.png" width="44" height="10"/> and the interface rapidly develops waves that grow as they are convected downslope for the higher Reynolds number, but decay when <img class="formulaInl" alt="$ Re = 0 $" src="form_24.png" width="38" height="10"/>.</p>
<div class="image">
<img src="animated_surface.gif" alt=""/>
<div class="caption">
Time evolution (or static snapshot at t = 7.5) of the interface shape for Re = 0 (Red) and 4 sin(alpha) (Green). </div></div>
 <p>The decay rate of the interfacial perturbation at <img class="formulaInl" alt="$ Re = 0 $" src="form_24.png" width="38" height="10"/> is slow, but can be seen in the next figure, which shows the height of the interface at the downstream end of the domain plotted against time. The domain is chosen so that it will contain three waves and the decay or growth of successive crests and troughs can be seen.</p>
<div class="image">
<img src="time_trace.gif" alt=""/>
<div class="caption">
Time history of the interface position at the downstream end of the computational domain. </div></div>
 <h2><a class="anchor" id="bound"></a>
A note on the boundary conditions</h2>
<p>Resolving the above analytic solution in a finite computational domain requires some thought about boundary conditions. We are only ever free to set one pressure value and setting the external pressure to zero fixes the pressure within the fluid. The boundary conditions at the plane are those of no-slip and at the free-surface the usual dynamic and kinematic conditions apply. Nonetheless, we have a number of possibilities for the boundary conditions at the "artificial" upstream and downstream computational boundaries.</p><ul>
<li>Prescribe periodic boundary conditions.</li>
<li>Prescribe the velocity profile as a Dirichlet condition at both ends.</li>
<li>Prescribe the appropriate hydrostatic pressure gradient and zero normal velocity.</li>
</ul>
<p>We have chosen the last option, in which case the hydrostatic pressure gradient must be consistent with the external pressure. In other words, the pressure must be zero at the free surface ( <img class="formulaInl" alt="$y=0$" src="form_14.png" width="30" height="11"/>). Changing the external pressure would correspond to changing the film thickness, so the external pressure is directly responsible for enforcing a specific volume constraint, unless <img class="formulaInl" alt="$\alpha = \pi/2$" src="form_19.png" width="44" height="14"/>. When <img class="formulaInl" alt="$\alpha = \pi/2$" src="form_19.png" width="44" height="14"/> there is no variation in hydrostatic pressure through the film and its thickness is not specified by the external pressure.</p>
<p>We must also worry about the boundary conditions on the free surface itself and we choose to impose a contact angle condition of <img class="formulaInl" alt="$ \pi/2 $" src="form_25.png" width="21" height="14"/> at the upstream end, which ensures that the film remains flat. At the downstream end, we add a line tension term that arises from use of the surface divergence theorem to integrate the contribution of the dynamic boundary condition. This term can be used to enforce contact angle conditions in a weak formulation, but here we simply add the term using the angle calculated from the current position of the free surface.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="global"></a>
Global parameters and functions</h1>
<p>The global parameters are the Reynolds number, the dimensionless grouping <img class="formulaInl" alt="$Re/Fr$" src="form_26.png" width="38" height="14"/>, the angle of inclination of the slope <img class="formulaInl" alt="$\alpha$" src="form_27.png" width="8" height="6"/>, the direction of the gravity vector <img class="formulaInl" alt="$G$" src="form_28.png" width="10" height="10"/> and the capillary number <img class="formulaInl" alt="$Ca$" src="form_29.png" width="16" height="10"/>, which only influences the dynamics.</p>
 <div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceGlobal__Physical__Variables.html">Global_Physical_Variables</a></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html">Global_Physical_Variables</a></div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00051">inclined_plane.cc:52</a></div></div>
<div class="line">{<span class="comment"></span></div>
<div class="line"><span class="comment"> /// Reynolds number, based on the average velocity within the fluid film</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#ab814e627d2eb5bc50318879d19ab16b9">Re</a>=0.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// The product of Reynolds number and inverse Froude number </span></div>
<div class="line"><span class="comment"> /// is set to two in this problem, which gives the free surface velocity</span></div>
<div class="line"><span class="comment"> /// to be sin(alpha). [Set to three in order to get the same scale as </span></div>
<div class="line"><span class="comment"> /// used by Yih, Benjamin, etc]</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#aa6286f02b476912dd7550eced538331a">ReInvFr</a>=2.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Angle of incline of the slope (45 degrees)</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#aa2e802ee7cc8e1ac900ba94c3ce86eb7">Alpha</a> = 1.0*atan(1.0);</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// The Vector direction of gravity, set in main()</span></div>
<div class="line"><span class="comment"></span> Vector&lt;double&gt; <a class="code" href="namespaceGlobal__Physical__Variables.html#aa868968dead376240a69f9152bd599b9">G</a>(2,0.0);</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// The Capillary number</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#a8b32b93d2e546f9375ec418474107838">Ca</a>= 1.0;</div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a8b32b93d2e546f9375ec418474107838"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a8b32b93d2e546f9375ec418474107838">Global_Physical_Variables::Ca</a></div><div class="ttdeci">double Ca</div><div class="ttdoc">The Capillary number.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00069">inclined_plane.cc:69</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_aa2e802ee7cc8e1ac900ba94c3ce86eb7"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#aa2e802ee7cc8e1ac900ba94c3ce86eb7">Global_Physical_Variables::Alpha</a></div><div class="ttdeci">double Alpha</div><div class="ttdoc">Angle of incline of the slope (45 degrees)</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00063">inclined_plane.cc:63</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_aa6286f02b476912dd7550eced538331a"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#aa6286f02b476912dd7550eced538331a">Global_Physical_Variables::ReInvFr</a></div><div class="ttdeci">double ReInvFr</div><div class="ttdoc">The product of Reynolds number and inverse Froude number is set to two in this problem,...</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00060">inclined_plane.cc:60</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_aa868968dead376240a69f9152bd599b9"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#aa868968dead376240a69f9152bd599b9">Global_Physical_Variables::G</a></div><div class="ttdeci">Vector&lt; double &gt; G(2, 0.0)</div><div class="ttdoc">The Vector direction of gravity, set in main()</div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_ab814e627d2eb5bc50318879d19ab16b9"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#ab814e627d2eb5bc50318879d19ab16b9">Global_Physical_Variables::Re</a></div><div class="ttdeci">double Re</div><div class="ttdoc">Reynolds number, based on the average velocity within the fluid film.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00054">inclined_plane.cc:54</a></div></div>
</div><!-- fragment --><p> The hydrostatic pressure field is specified as an applied traction. At the outlet (inlet), the outer unit normal is in the positive (negative) <img class="formulaInl" alt="$x$" src="form_30.png" width="8" height="6"/> direction and so the required traction is given by <img class="formulaInl" alt="$-p$" src="form_31.png" width="16" height="9"/> ( <img class="formulaInl" alt="$p$" src="form_32.png" width="8" height="9"/>), </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{\boldmath$t$}|_{\mbox{outlet}} = (- (Re/Fr)\cos\alpha (1 - y), 0), \qquad \mbox{\boldmath$t$}|_{\mbox{inlet}} = ((Re/Fr)\cos\alpha (1 - y), 0).\]" src="form_33.png" width="421" height="15"/>
</p>
<p> These tractions are specified by the two different functions </p><div class="fragment"><div class="line"> <span class="comment">/// Function that prescribes the hydrostatic pressure field at the outlet</span></div>
<div class="line"> <span class="keywordtype">void</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#ab577639e7c51979d3db7565c08c69c70">hydrostatic_pressure_outlet</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; time, <span class="keyword">const</span> Vector&lt;double&gt; &amp;x, </div>
<div class="line">                                  <span class="keyword">const</span> Vector&lt;double&gt; &amp;n, </div>
<div class="line">                                  Vector&lt;double&gt; &amp;traction)</div>
<div class="line"> {</div>
<div class="line">  traction[0] = <a class="code" href="namespaceGlobal__Physical__Variables.html#aa6286f02b476912dd7550eced538331a">ReInvFr</a>*<a class="code" href="namespaceGlobal__Physical__Variables.html#aa868968dead376240a69f9152bd599b9">G</a>[1]*(1.0 - x[1]);</div>
<div class="line">  traction[1] = 0.0;</div>
<div class="line"> }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Function that prescribes hydrostatic pressure field at the inlet</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#af1f48eb04a3c7f97b1efacea533acdbc">hydrostatic_pressure_inlet</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; time, <span class="keyword">const</span> Vector&lt;double&gt; &amp;x, </div>
<div class="line">                                 <span class="keyword">const</span> Vector&lt;double&gt; &amp;n,</div>
<div class="line">                                 Vector&lt;double&gt; &amp;traction)</div>
<div class="line"> {</div>
<div class="line">  traction[0] = -<a class="code" href="namespaceGlobal__Physical__Variables.html#aa6286f02b476912dd7550eced538331a">ReInvFr</a>*<a class="code" href="namespaceGlobal__Physical__Variables.html#aa868968dead376240a69f9152bd599b9">G</a>[1]*(1.0 - x[1]);</div>
<div class="line">  traction[1] = 0.0;</div>
<div class="line"> }</div>
<div class="line"> <span class="comment">//end of traction functions</span></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_ab577639e7c51979d3db7565c08c69c70"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#ab577639e7c51979d3db7565c08c69c70">Global_Physical_Variables::hydrostatic_pressure_outlet</a></div><div class="ttdeci">void hydrostatic_pressure_outlet(const double &amp;time, const Vector&lt; double &gt; &amp;x, const Vector&lt; double &gt; &amp;n, Vector&lt; double &gt; &amp;traction)</div><div class="ttdoc">Function that prescribes the hydrostatic pressure field at the outlet.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00106">inclined_plane.cc:106</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_af1f48eb04a3c7f97b1efacea533acdbc"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#af1f48eb04a3c7f97b1efacea533acdbc">Global_Physical_Variables::hydrostatic_pressure_inlet</a></div><div class="ttdeci">void hydrostatic_pressure_inlet(const double &amp;time, const Vector&lt; double &gt; &amp;x, const Vector&lt; double &gt; &amp;n, Vector&lt; double &gt; &amp;traction)</div><div class="ttdoc">Function that prescribes hydrostatic pressure field at the inlet.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00115">inclined_plane.cc:115</a></div></div>
</div><!-- fragment --><p> Note that <code>G</code> [ <code>1</code> ] is the component of the gravitational body force in the vertical direction, so <img class="formulaInl" alt="$ G[1] = - \cos\alpha$" src="form_34.png" width="78" height="14"/>. <br  />
</p>
<p>We must also specify the direction of the normals (directed out of the fluid) to the notional walls that form the inlet and outlet and a contact angle of <img class="formulaInl" alt="$ \pi /2 $" src="form_35.png" width="21" height="14"/> that will be used as a boundary condition on the free surface at the upstream end of the domain. In this case the normal to the inlet is in the negative x-direction and the normal to the outlet is in the positive x-direction. The actual value of the <code>Wall_normal</code> vector is set in <code><a class="el" href="inclined__plane_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a></code> </p>
 <div class="fragment"><div class="line"> <span class="comment">/// Direction of the wall normal vector (at the inlet)</span></div>
<div class="line"> Vector&lt;double&gt; <a class="code" href="namespaceGlobal__Physical__Variables.html#a5feb3df21fc4a0adefadecb8a8ed98d7">Wall_normal</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Function that specifies the wall unit normal at the inlet</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#aa26e74c1f9f93f8212e45380f55fb562">wall_unit_normal_inlet_fct</a>(<span class="keyword">const</span> Vector&lt;double&gt; &amp;x, </div>
<div class="line">                                 Vector&lt;double&gt; &amp;normal)</div>
<div class="line"> {</div>
<div class="line">  normal=<a class="code" href="namespaceGlobal__Physical__Variables.html#a5feb3df21fc4a0adefadecb8a8ed98d7">Wall_normal</a>;</div>
<div class="line"> }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Function that specified the wall unit normal at the outlet</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#a8ab8f6e823e4cd204ed7264121a42bfb">wall_unit_normal_outlet_fct</a>(<span class="keyword">const</span> Vector&lt;double&gt; &amp;x, </div>
<div class="line">                                 Vector&lt;double&gt; &amp;normal)</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">//Set the normal</span></div>
<div class="line">  normal = <a class="code" href="namespaceGlobal__Physical__Variables.html#a5feb3df21fc4a0adefadecb8a8ed98d7">Wall_normal</a>;</div>
<div class="line">  <span class="comment">//and flip the sign</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> n_dim = normal.size();</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_dim;++i) {normal[i] *= -1.0;}</div>
<div class="line"> }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// The contact angle that is imposed at the inlet (pi)</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#a1c3587461447262715bd444ac91a29c9">Inlet_Angle</a> = 2.0*atan(1.0);</div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a1c3587461447262715bd444ac91a29c9"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a1c3587461447262715bd444ac91a29c9">Global_Physical_Variables::Inlet_Angle</a></div><div class="ttdeci">double Inlet_Angle</div><div class="ttdoc">The contact angle that is imposed at the inlet (pi)</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00102">inclined_plane.cc:102</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a5feb3df21fc4a0adefadecb8a8ed98d7"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a5feb3df21fc4a0adefadecb8a8ed98d7">Global_Physical_Variables::Wall_normal</a></div><div class="ttdeci">Vector&lt; double &gt; Wall_normal</div><div class="ttdoc">Direction of the wall normal vector (at the inlet)</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00081">inclined_plane.cc:81</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a8ab8f6e823e4cd204ed7264121a42bfb"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a8ab8f6e823e4cd204ed7264121a42bfb">Global_Physical_Variables::wall_unit_normal_outlet_fct</a></div><div class="ttdeci">void wall_unit_normal_outlet_fct(const Vector&lt; double &gt; &amp;x, Vector&lt; double &gt; &amp;normal)</div><div class="ttdoc">Function that specified the wall unit normal at the outlet.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00091">inclined_plane.cc:91</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_aa26e74c1f9f93f8212e45380f55fb562"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#aa26e74c1f9f93f8212e45380f55fb562">Global_Physical_Variables::wall_unit_normal_inlet_fct</a></div><div class="ttdeci">void wall_unit_normal_inlet_fct(const Vector&lt; double &gt; &amp;x, Vector&lt; double &gt; &amp;normal)</div><div class="ttdoc">Function that specifies the wall unit normal at the inlet.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00084">inclined_plane.cc:84</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
 <h1><a class="anchor" id="main"></a>
The driver code</h1>
<p>We start by specifying the constitutive law used to define the mesh motion when pseudo-elastic deformation is used. </p><div class="fragment"><div class="line"><span class="comment">//start of main</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="inclined__plane_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">using namespace </span><a class="code" href="namespaceGlobal__Physical__Variables.html">Global_Physical_Variables</a>;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Set the constitutive law for the mesh deformation</span></div>
<div class="line"> <a class="code" href="namespaceGlobal__Physical__Variables.html#a2a37fb040c832ee7a086bb13bb02a100">Constitutive_law_pt</a>  = <span class="keyword">new</span> GeneralisedHookean(&amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a3962c36313826b19f216f6bbbdd6a477">Global_Physical_Variables::Nu</a>);</div>
<div class="ttc" id="ainclined__plane_8cc_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="inclined__plane_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00756">inclined_plane.cc:756</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a2a37fb040c832ee7a086bb13bb02a100"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a2a37fb040c832ee7a086bb13bb02a100">Global_Physical_Variables::Constitutive_law_pt</a></div><div class="ttdeci">ConstitutiveLaw * Constitutive_law_pt</div><div class="ttdoc">Constitutive law used to determine the mesh deformation.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00125">inclined_plane.cc:125</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a3962c36313826b19f216f6bbbdd6a477"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a3962c36313826b19f216f6bbbdd6a477">Global_Physical_Variables::Nu</a></div><div class="ttdeci">double Nu</div><div class="ttdoc">Pseudo-solid Poisson ratio.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00128">inclined_plane.cc:128</a></div></div>
</div><!-- fragment --><p> Next, the type of fluid element is chosen according to specified compiler flags </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef CR_ELEMENT</span></div>
<div class="line"><span class="preprocessor">#define FLUID_ELEMENT QCrouzeixRaviartElement&lt;2&gt;</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#define FLUID_ELEMENT QTaylorHoodElement&lt;2&gt;</span></div>
<div class="line"><span class="preprocessor">#endif </span></div>
</div><!-- fragment --><p> We then initialise the physical parameters, the Reynolds number and the direction of the gravitational body force, both based on the angle of inclination <img class="formulaInl" alt="$\alpha$" src="form_27.png" width="8" height="6"/>. </p><div class="fragment"><div class="line"> <span class="comment">//Initialise physical parameters</span></div>
<div class="line"> <span class="comment">//Scale Reynolds number to be independent of alpha.</span></div>
<div class="line"> <a class="code" href="namespaceGlobal__Physical__Variables.html#ab814e627d2eb5bc50318879d19ab16b9">Re</a> = 4.0/sin(<a class="code" href="namespaceGlobal__Physical__Variables.html#aa2e802ee7cc8e1ac900ba94c3ce86eb7">Alpha</a>); </div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Set the direction of gravity</span></div>
<div class="line"> <a class="code" href="namespaceGlobal__Physical__Variables.html#aa868968dead376240a69f9152bd599b9">G</a>[0] = sin(<a class="code" href="namespaceGlobal__Physical__Variables.html#aa2e802ee7cc8e1ac900ba94c3ce86eb7">Alpha</a>);</div>
<div class="line"> <a class="code" href="namespaceGlobal__Physical__Variables.html#aa868968dead376240a69f9152bd599b9">G</a>[1] = -cos(<a class="code" href="namespaceGlobal__Physical__Variables.html#aa2e802ee7cc8e1ac900ba94c3ce86eb7">Alpha</a>);</div>
</div><!-- fragment --><p> We also set the direction of the notional wall normal vector. </p><div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">//The wall normal to the inlet is in the negative x direction</span></div>
<div class="line"> <a class="code" href="namespaceGlobal__Physical__Variables.html#a5feb3df21fc4a0adefadecb8a8ed98d7">Wall_normal</a>.resize(2);</div>
<div class="line"> <a class="code" href="namespaceGlobal__Physical__Variables.html#a5feb3df21fc4a0adefadecb8a8ed98d7">Wall_normal</a>[0] = -1.0;</div>
<div class="line"> <a class="code" href="namespaceGlobal__Physical__Variables.html#a5feb3df21fc4a0adefadecb8a8ed98d7">Wall_normal</a>[1] = 0.0;</div>
</div><!-- fragment --><p> We now create the spine version of the problem, solve the steady problem, assign initial conditions by assuming that the problem has been at the steady state for all previous times, and then evolve the system in time. </p><div class="fragment"><div class="line"> <span class="comment">//Spine problem</span></div>
<div class="line"> {</div>
<div class="line">  <span class="comment">//Create the problem</span></div>
<div class="line">  <a class="code" href="classSpineInclinedPlaneProblem.html">SpineInclinedPlaneProblem&lt;SpineElement&lt;FLUID_ELEMENT &gt;</a>, BDF&lt;2&gt; &gt; </div>
<div class="line">   problem(30,4,<a class="code" href="namespaceGlobal__Physical__Variables.html#a987847160c3cfad8977836291fb9d0e0">Global_Physical_Variables::Length</a>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">//Solve the steady problem</span></div>
<div class="line">  problem.solve_steady();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">//Prepare the problem for timestepping </span></div>
<div class="line">  <span class="comment">//(assume that it&#39;s been at the flat-film solution for all previous time)</span></div>
<div class="line">  <span class="keywordtype">double</span> dt = 0.1;</div>
<div class="line">  problem.assign_initial_values_impulsive(dt);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">//Timestep it </span></div>
<div class="line">  problem.timestep(dt,2);</div>
<div class="line"> } <span class="comment">//End of spine problem</span></div>
<div class="ttc" id="aclassSpineInclinedPlaneProblem_html"><div class="ttname"><a href="classSpineInclinedPlaneProblem.html">SpineInclinedPlaneProblem</a></div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00607">inclined_plane.cc:609</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a987847160c3cfad8977836291fb9d0e0"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a987847160c3cfad8977836291fb9d0e0">Global_Physical_Variables::Length</a></div><div class="ttdeci">double Length</div><div class="ttdoc">The length of the domain to fit the desired number of waves.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00078">inclined_plane.cc:78</a></div></div>
</div><!-- fragment --><p> Finally, exactly the same procedure is performed for the elastic problem </p><div class="fragment"><div class="line"> <span class="comment">//Elastic problem</span></div>
<div class="line"> {</div>
<div class="line">  <span class="comment">//Create the problem</span></div>
<div class="line">  <a class="code" href="classElasticInclinedPlaneProblem.html">ElasticInclinedPlaneProblem</a>&lt;</div>
<div class="line">   PseudoSolidNodeUpdateElement&lt;FLUID_ELEMENT,QPVDElement&lt;2,3&gt; &gt;, BDF&lt;2&gt; &gt; </div>
<div class="line">     problem(30,4,<a class="code" href="namespaceGlobal__Physical__Variables.html#a987847160c3cfad8977836291fb9d0e0">Global_Physical_Variables::Length</a>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">//Solve the steady problem</span></div>
<div class="line">  problem.solve_steady();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">//Prepare the problem for timestepping </span></div>
<div class="line">  <span class="comment">//(assume that it&#39;s been at the flat-film solution for all previous time)</span></div>
<div class="line">  <span class="keywordtype">double</span> dt = 0.1;</div>
<div class="line">  problem.assign_initial_values_impulsive(dt);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Timestep it</span></div>
<div class="line">  problem.timestep(dt,2);</div>
<div class="line"> } <span class="comment">//End of elastic problem</span></div>
<div class="ttc" id="aclassElasticInclinedPlaneProblem_html"><div class="ttname"><a href="classElasticInclinedPlaneProblem.html">ElasticInclinedPlaneProblem</a></div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00687">inclined_plane.cc:689</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
 <h1><a class="anchor" id="mesh"></a>
The mesh classes</h1>
<p>The base mesh class is the <code>SimpleRectangularQuadMesh:</code> boundary 0 will be the wall; boundary 2 will be the free surface; and the remaining boundaries will be the inlet (3) and outlet (1). Below we shall demonstrate how to convert an existing mesh into a <code>SpineMesh</code> and <code>ElasticMesh</code> suitable for free-surface problems.</p>
<h2><a class="anchor" id="spine_mesh"></a>
Creating the spine mesh</h2>
<p>The <code><a class="el" href="classSpineInclinedPlaneMesh.html" title="Create a spine mesh for the problem.">SpineInclinedPlaneMesh</a></code> inherits from the generic <code>SimpleRectangularQuadMesh</code> and adds vertical spines to the Nodes within the mesh in the constructor. Note that the resulting mesh is essentially the same as the <code>SingleLayerSpineMesh</code>, but has a somewhat simpler interface.</p>
 <div class="fragment"><div class="line"><span class="comment">/// Create a spine mesh for the problem</span></div>
<div class="line"><span class="comment">//======================================================================</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classSpineInclinedPlaneMesh.html">SpineInclinedPlaneMesh</a> : </div>
<div class="line"> <span class="keyword">public</span> SimpleRectangularQuadMesh&lt;ELEMENT&gt;,</div>
<div class="line"> <span class="keyword">public</span> SpineMesh</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <a class="code" href="classSpineInclinedPlaneMesh.html#a97e770220d4cd41e11c86c5cfa289133">SpineInclinedPlaneMesh</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;nx, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;ny,</div>
<div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;lx, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;ly,</div>
<div class="line">                        TimeStepper* time_stepper_pt) :</div>
<div class="line">  SimpleRectangularQuadMesh&lt;ELEMENT&gt;</div>
<div class="line"> (nx,ny,lx,ly,time_stepper_pt), SpineMesh()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Find the number of linear points in the element</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_p =  <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(finite_element_pt(0))-&gt;nnode_1d();</div>
<div class="line">   <span class="comment">//Reserve storage for the number of spines</span></div>
<div class="line">   Spine_pt.reserve((n_p-1)*nx + 1);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Create single pointer to a spine</span></div>
<div class="line">   Spine* new_spine_pt=0;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Now loop over the elements horizontally</span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> j=0;j&lt;nx;j++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">//In most elements, we don&#39;t assign a spine to the last column,</span></div>
<div class="line">     <span class="comment">//beacuse that will be done by the next element</span></div>
<div class="line">     <span class="keywordtype">unsigned</span> n_pmax = n_p-1;</div>
<div class="line">     <span class="comment">//In the last element, however, we must assign the final spine</span></div>
<div class="line">     <span class="keywordflow">if</span>(j==nx-1) {n_pmax = n_p;}</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//Loop over all nodes horizontally</span></div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> l2=0;l2&lt;n_pmax;l2++)</div>
<div class="line">      {</div>
<div class="line">       <span class="comment">//Create a new spine with unit height and add to the mesh</span></div>
<div class="line">       new_spine_pt=<span class="keyword">new</span> Spine(1.0);</div>
<div class="line">       Spine_pt.push_back(new_spine_pt);</div>
<div class="line">       </div>
<div class="line">       <span class="comment">// Get the node</span></div>
<div class="line">       SpineNode* nod_pt=element_node_pt(j,l2);</div>
<div class="line">       <span class="comment">//Set the pointer to spine</span></div>
<div class="line">       nod_pt-&gt;spine_pt() = new_spine_pt;</div>
<div class="line">       <span class="comment">//Set the fraction</span></div>
<div class="line">       nod_pt-&gt;fraction() = 0.0;</div>
<div class="line">       <span class="comment">// Pointer to the mesh that implements the update fct</span></div>
<div class="line">       nod_pt-&gt;spine_mesh_pt() = <span class="keyword">this</span>; </div>
<div class="line">       </div>
<div class="line">       <span class="comment">//Loop vertically along the spine</span></div>
<div class="line">       <span class="comment">//Loop over the elements </span></div>
<div class="line">       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i=0;i&lt;ny;i++)</div>
<div class="line">        {</div>
<div class="line">         <span class="comment">//Loop over the vertical nodes, apart from the first</span></div>
<div class="line">         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> l1=1;l1&lt;n_p;l1++)</div>
<div class="line">          {</div>
<div class="line">           <span class="comment">// Get the node</span></div>
<div class="line">           SpineNode* nod_pt=element_node_pt(i*nx+j,l1*n_p+l2);</div>
<div class="line">           <span class="comment">//Set the pointer to the spine</span></div>
<div class="line">           nod_pt-&gt;spine_pt() = new_spine_pt;</div>
<div class="line">           <span class="comment">//Set the fraction</span></div>
<div class="line">           nod_pt-&gt;fraction()=(double(i)+double(l1)/double(n_p-1))/<span class="keywordtype">double</span>(ny);</div>
<div class="line">           <span class="comment">// Pointer to the mesh that implements the update fct</span></div>
<div class="line">           nod_pt-&gt;spine_mesh_pt() = <span class="keyword">this</span>; </div>
<div class="line">          }  </div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    } <span class="comment">//End of horizontal loop over elements  </span></div>
<div class="line">  } <span class="comment">//end of constructor</span></div>
<div class="ttc" id="aclassSpineInclinedPlaneMesh_html"><div class="ttname"><a href="classSpineInclinedPlaneMesh.html">SpineInclinedPlaneMesh</a></div><div class="ttdoc">Create a spine mesh for the problem.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00522">inclined_plane.cc:525</a></div></div>
<div class="ttc" id="aclassSpineInclinedPlaneMesh_html_a97e770220d4cd41e11c86c5cfa289133"><div class="ttname"><a href="classSpineInclinedPlaneMesh.html#a97e770220d4cd41e11c86c5cfa289133">SpineInclinedPlaneMesh::SpineInclinedPlaneMesh</a></div><div class="ttdeci">SpineInclinedPlaneMesh(const unsigned &amp;nx, const unsigned &amp;ny, const double &amp;lx, const double &amp;ly, TimeStepper *time_stepper_pt)</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00527">inclined_plane.cc:527</a></div></div>
</div><!-- fragment --><p>In addition, a <code>spine_node_update()</code> function must be provided that determines how the <code>Nodes</code> move as functions of the <code>Spines</code>. </p><div class="fragment"><div class="line"> <span class="comment">/// General node update function implements pure virtual function </span></div>
<div class="line"><span class="comment"> /// defined in SpineMesh base class and performs specific node update</span></div>
<div class="line"><span class="comment"></span><span class="comment"> /// actions:  along vertical spines</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> spine_node_update(SpineNode* spine_node_pt)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Get fraction along the spine</span></div>
<div class="line">   <span class="keywordtype">double</span> W = spine_node_pt-&gt;fraction();</div>
<div class="line">   <span class="comment">//Get spine height</span></div>
<div class="line">   <span class="keywordtype">double</span> H = spine_node_pt-&gt;h();</div>
<div class="line">   <span class="comment">//Set the value of y</span></div>
<div class="line">   spine_node_pt-&gt;x(1) = W*H;</div>
<div class="line">  }</div>
</div><!-- fragment --> <h2><a class="anchor" id="elastic_mesh"></a>
Creating the ElasticMesh</h2>
<p>The <code><a class="el" href="classElasticInclinedPlaneMesh.html" title="Create an Elastic mesh for the problem.">ElasticInclinedPlaneMesh</a></code> inherits from the <code>SimpleRectangularQuadMesh</code> and the undeformed (reference) configuration is set to be the current position of the <code>Nodes</code>. </p><div class="fragment"><div class="line"><span class="comment">/// Create an Elastic mesh for the problem</span></div>
<div class="line"><span class="comment">//======================================================================</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classElasticInclinedPlaneMesh.html">ElasticInclinedPlaneMesh</a> : </div>
<div class="line"> <span class="keyword">public</span> SimpleRectangularQuadMesh&lt;ELEMENT&gt;,</div>
<div class="line"> <span class="keyword">public</span> SolidMesh</div>
<div class="line">{</div>
<div class="line"> <span class="comment">//Public functions</span></div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line"> <a class="code" href="classElasticInclinedPlaneMesh.html#a61ba6d852505dd1353e791223fdfce04">ElasticInclinedPlaneMesh</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;nx, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;ny,</div>
<div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;lx, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;ly,</div>
<div class="line">                          TimeStepper* time_stepper_pt) :</div>
<div class="line">  SimpleRectangularQuadMesh&lt;ELEMENT&gt;(nx,ny,lx,ly,time_stepper_pt), SolidMesh()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Make the current configuration the undeformed one</span></div>
<div class="line">   set_lagrangian_nodal_coordinates();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="aclassElasticInclinedPlaneMesh_html"><div class="ttname"><a href="classElasticInclinedPlaneMesh.html">ElasticInclinedPlaneMesh</a></div><div class="ttdoc">Create an Elastic mesh for the problem.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00664">inclined_plane.cc:667</a></div></div>
<div class="ttc" id="aclassElasticInclinedPlaneMesh_html_a61ba6d852505dd1353e791223fdfce04"><div class="ttname"><a href="classElasticInclinedPlaneMesh.html#a61ba6d852505dd1353e791223fdfce04">ElasticInclinedPlaneMesh::ElasticInclinedPlaneMesh</a></div><div class="ttdeci">ElasticInclinedPlaneMesh(const unsigned &amp;nx, const unsigned &amp;ny, const double &amp;lx, const double &amp;ly, TimeStepper *time_stepper_pt)</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00670">inclined_plane.cc:670</a></div></div>
</div><!-- fragment --><p>Note that the specification of the ElasticMesh is much simpler than that of a SpineMesh because no decision needs to be taken about how to describe the motion using Spines.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="problem"></a>
The problem classes</h1>
<h2><a class="anchor" id="generic_prob"></a>
The generic problem</h2>
<p>For ease of exposition, all generic functionality is included in the <code><a class="el" href="classInclinedPlaneProblem.html" title="Generic problem class that will form the base class for both spine and elastic mesh-updates of the pr...">InclinedPlaneProblem</a></code> class, which is templated by the bulk <code>ELEMENT</code> and the <code>INTERFACE_ELEMENT</code>. The class includes storage for the different sub-meshes: Bulk, the Traction elements associated with the inlet and outlet, the (free) Surface elements and the point elements associated with the ends of the interface. In addition, a string <code>Output_prefix</code> is used to distinguish between the output files from different formulations.  </p><div class="fragment"><div class="line"><span class="comment">/// Generic problem class that will form the base class for both </span></div>
<div class="line"><span class="comment">/// spine and elastic mesh-updates of the problem.</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// Templated by the bulk element and interface element types</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT, <span class="keyword">class</span> INTERFACE_ELEMENT&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classInclinedPlaneProblem.html">InclinedPlaneProblem</a> : <span class="keyword">public</span> Problem</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Bulk fluid mesh</span></div>
<div class="line"><span class="comment"></span> Mesh* <a class="code" href="classInclinedPlaneProblem.html#a20c506fe684dc146424b8ec019239783">Bulk_mesh_pt</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Mesh for the traction elements that are added at inlet and outlet</span></div>
<div class="line"><span class="comment"></span> Mesh* <a class="code" href="classInclinedPlaneProblem.html#a85bcc36a8ad4ad7aa3595585e73a3197">Traction_mesh_pt</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Mesh for the free surface elements</span></div>
<div class="line"><span class="comment"></span> Mesh* <a class="code" href="classInclinedPlaneProblem.html#aba36d367278218bf00356c3bee0733a0">Surface_mesh_pt</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Mesh for the point elements at each end of the free surface</span></div>
<div class="line"><span class="comment"></span> Mesh* <a class="code" href="classInclinedPlaneProblem.html#adefbac5880323d7de622e2ba0c526746">Point_mesh_pt</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Prefix for output files</span></div>
<div class="line"><span class="comment"></span> std::string <a class="code" href="classInclinedPlaneProblem.html#a6ad45c76bd24f63c0162313042ce2e7d">Output_prefix</a>;</div>
<div class="ttc" id="aclassInclinedPlaneProblem_html"><div class="ttname"><a href="classInclinedPlaneProblem.html">InclinedPlaneProblem</a></div><div class="ttdoc">Generic problem class that will form the base class for both spine and elastic mesh-updates of the pr...</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00138">inclined_plane.cc:139</a></div></div>
<div class="ttc" id="aclassInclinedPlaneProblem_html_a20c506fe684dc146424b8ec019239783"><div class="ttname"><a href="classInclinedPlaneProblem.html#a20c506fe684dc146424b8ec019239783">InclinedPlaneProblem::Bulk_mesh_pt</a></div><div class="ttdeci">Mesh * Bulk_mesh_pt</div><div class="ttdoc">Bulk fluid mesh.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00144">inclined_plane.cc:144</a></div></div>
<div class="ttc" id="aclassInclinedPlaneProblem_html_a6ad45c76bd24f63c0162313042ce2e7d"><div class="ttname"><a href="classInclinedPlaneProblem.html#a6ad45c76bd24f63c0162313042ce2e7d">InclinedPlaneProblem::Output_prefix</a></div><div class="ttdeci">std::string Output_prefix</div><div class="ttdoc">Prefix for output files.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00156">inclined_plane.cc:156</a></div></div>
<div class="ttc" id="aclassInclinedPlaneProblem_html_a85bcc36a8ad4ad7aa3595585e73a3197"><div class="ttname"><a href="classInclinedPlaneProblem.html#a85bcc36a8ad4ad7aa3595585e73a3197">InclinedPlaneProblem::Traction_mesh_pt</a></div><div class="ttdeci">Mesh * Traction_mesh_pt</div><div class="ttdoc">Mesh for the traction elements that are added at inlet and outlet.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00147">inclined_plane.cc:147</a></div></div>
<div class="ttc" id="aclassInclinedPlaneProblem_html_aba36d367278218bf00356c3bee0733a0"><div class="ttname"><a href="classInclinedPlaneProblem.html#aba36d367278218bf00356c3bee0733a0">InclinedPlaneProblem::Surface_mesh_pt</a></div><div class="ttdeci">Mesh * Surface_mesh_pt</div><div class="ttdoc">Mesh for the free surface elements.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00150">inclined_plane.cc:150</a></div></div>
<div class="ttc" id="aclassInclinedPlaneProblem_html_adefbac5880323d7de622e2ba0c526746"><div class="ttname"><a href="classInclinedPlaneProblem.html#adefbac5880323d7de622e2ba0c526746">InclinedPlaneProblem::Point_mesh_pt</a></div><div class="ttdeci">Mesh * Point_mesh_pt</div><div class="ttdoc">Mesh for the point elements at each end of the free surface.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00153">inclined_plane.cc:153</a></div></div>
</div><!-- fragment --><p> The time-dependent perturbation is introduced in the function <code>actions_before_implicit_timestep()</code>, which sets the vertical velocity on the wall (boundary 0) </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ v = \epsilon \sin(K x) t \mbox{e}^{-t} \]" src="form_36.png" width="96" height="15"/>
</p>
 <div class="fragment"><div class="line"> <span class="keywordtype">void</span> actions_before_implicit_timestep()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Read out the current time</span></div>
<div class="line">   <span class="keywordtype">double</span> time = this-&gt;time_pt()-&gt;time();</div>
<div class="line">   <span class="comment">//Now add a temporary sinusoidal suction and blowing to the base</span></div>
<div class="line">   <span class="comment">//Amplitude of the perturbation</span></div>
<div class="line">   <span class="keywordtype">double</span> epsilon = 0.01;</div>
<div class="line">   <span class="comment">//Loop over the nodes on the base</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_node = this-&gt;Bulk_mesh_pt-&gt;nboundary_node(0);</div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> n=0;n&lt;n_node;n++)</div>
<div class="line">    {</div>
<div class="line">     Node* nod_pt = this-&gt;Bulk_mesh_pt-&gt;boundary_node_pt(0,n);</div>
<div class="line">     <span class="keywordtype">double</span> arg = <a class="code" href="namespaceGlobal__Physical__Variables.html#a9da8be10d9e20eb0329af7fd8d6e0e98">Global_Physical_Variables::K</a>*nod_pt-&gt;x(0);</div>
<div class="line">     <span class="keywordtype">double</span> value = sin(arg)*epsilon*time*exp(-time);</div>
<div class="line">     nod_pt-&gt;set_value(1,value);</div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">//end_of_actions_before_implicit_timestep</span></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a9da8be10d9e20eb0329af7fd8d6e0e98"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a9da8be10d9e20eb0329af7fd8d6e0e98">Global_Physical_Variables::K</a></div><div class="ttdeci">double K</div><div class="ttdoc">Set the wavenumber.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00072">inclined_plane.cc:72</a></div></div>
</div><!-- fragment --><p> The function <code>make_traction_elements()</code> creates <code>NavierStokesTractionElement</code> s adjacent to the mesh boundaries 3 (the inlet) and 1 (the inlet). These elements are added to the <code>Mesh</code> <code>Traction_mesh_pt</code>, which is itself constructed in the function and pointers to the appropriate traction functions are assigned. </p><div class="fragment"><div class="line"> <span class="comment">/// Function to add the traction boundary elements to boundaries</span></div>
<div class="line"><span class="comment"> /// 3(inlet) and 1(outlet) of the mesh</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> make_traction_elements()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Create a new (empty mesh)</span></div>
<div class="line">   Traction_mesh_pt = <span class="keyword">new</span> Mesh;</div>
<div class="line">   <span class="comment">//Inlet boundary conditions (boundary 3)</span></div>
<div class="line">   {</div>
<div class="line">    <span class="keywordtype">unsigned</span> b = 3;</div>
<div class="line">    <span class="comment">//Find the number of elements adjacent to mesh boundary</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> n_boundary_element = Bulk_mesh_pt-&gt;nboundary_element(b);</div>
<div class="line">    <span class="comment">//Loop over these elements and create the traction elements</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_boundary_element;e++)</div>
<div class="line">     {</div>
<div class="line">      NavierStokesTractionElement&lt;ELEMENT&gt; *surface_element_pt =</div>
<div class="line">       <span class="keyword">new</span> NavierStokesTractionElement&lt;ELEMENT&gt;</div>
<div class="line">       (Bulk_mesh_pt-&gt;boundary_element_pt(b,e),</div>
<div class="line">        Bulk_mesh_pt-&gt;face_index_at_boundary(b,e));</div>
<div class="line">      <span class="comment">//Add the elements to the mesh</span></div>
<div class="line">      Traction_mesh_pt-&gt;add_element_pt(surface_element_pt);</div>
<div class="line">      <span class="comment">//Set the traction function</span></div>
<div class="line">      surface_element_pt-&gt;traction_fct_pt() = </div>
<div class="line">       &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#af1f48eb04a3c7f97b1efacea533acdbc">Global_Physical_Variables::hydrostatic_pressure_inlet</a>;</div>
<div class="line">     }</div>
<div class="line">   }</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Outlet boundary conditions (boundary 1)</span></div>
<div class="line">   {</div>
<div class="line">    <span class="keywordtype">unsigned</span> b=1;</div>
<div class="line">    <span class="comment">//Find the number of elements adjacent to mesh boundary</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> n_boundary_element = Bulk_mesh_pt-&gt;nboundary_element(b);</div>
<div class="line">    <span class="comment">//Loop over these elements and create the traction elements</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_boundary_element;e++)</div>
<div class="line">     {</div>
<div class="line">      NavierStokesTractionElement&lt;ELEMENT&gt; *surface_element_pt =</div>
<div class="line">       <span class="keyword">new</span> NavierStokesTractionElement&lt;ELEMENT&gt;</div>
<div class="line">       (Bulk_mesh_pt-&gt;boundary_element_pt(b,e),</div>
<div class="line">        Bulk_mesh_pt-&gt;face_index_at_boundary(b,e));</div>
<div class="line">      <span class="comment">//Add the elements to the mesh</span></div>
<div class="line">      Traction_mesh_pt-&gt;add_element_pt(surface_element_pt);</div>
<div class="line">      <span class="comment">//Set the traction function</span></div>
<div class="line">      surface_element_pt-&gt;traction_fct_pt() = </div>
<div class="line">       &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#ab577639e7c51979d3db7565c08c69c70">Global_Physical_Variables::hydrostatic_pressure_outlet</a>;</div>
<div class="line">     }</div>
<div class="line">   }</div>
<div class="line">  } <span class="comment">//end of make_traction_elements</span></div>
</div><!-- fragment --><p> The function <code>make_free_surface_elements()</code> creates the appropriate <code>INTERFACE_ELEMENTs</code> adjacent to the free surface (boundary 2), sets the capillary number and also creates free-surface boundary elements at the left- and right-hand ends of the interface. If these "point" elements are not included then the surface tension is not applied correctly at the edges of the domain. The contact angle is set to be the value <code>Inlet_Angle</code> at the left-hand edge of the domain. </p><div class="fragment"><div class="line"> <span class="comment">//Make the free surface elements on the top surface</span></div>
<div class="line"> <span class="keywordtype">void</span> make_free_surface_elements()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Create the (empty) meshes</span></div>
<div class="line">   Surface_mesh_pt = <span class="keyword">new</span> Mesh;</div>
<div class="line">   Point_mesh_pt = <span class="keyword">new</span> Mesh;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//The free surface is on the boundary 2</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> b = 2;</div>
<div class="line">   <span class="keywordtype">unsigned</span> n_boundary_element = Bulk_mesh_pt-&gt;nboundary_element(b);</div>
<div class="line">   <span class="comment">//Loop over the elements and create the appropriate interface elements</span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_boundary_element;e++)</div>
<div class="line">    {</div>
<div class="line">     INTERFACE_ELEMENT *surface_element_pt =</div>
<div class="line">      <span class="keyword">new</span> INTERFACE_ELEMENT</div>
<div class="line">      (Bulk_mesh_pt-&gt;boundary_element_pt(b,e),</div>
<div class="line">       Bulk_mesh_pt-&gt;face_index_at_boundary(b,e));</div>
<div class="line">     <span class="comment">//Add elements to the mesh</span></div>
<div class="line">     Surface_mesh_pt-&gt;add_element_pt(surface_element_pt);</div>
<div class="line">     <span class="comment">//Assign the capillary number to the free surface</span></div>
<div class="line">     surface_element_pt-&gt;ca_pt() = </div>
<div class="line">      &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a8b32b93d2e546f9375ec418474107838">Global_Physical_Variables::Ca</a>;</div>
<div class="line">     </div>
<div class="line">     <span class="comment">//Make a point element from left-hand side of the </span></div>
<div class="line">     <span class="comment">//first surface element (note that this relies on knowledge of </span></div>
<div class="line">     <span class="comment">//the element order within the mesh)</span></div>
<div class="line">     <span class="keywordflow">if</span>(e==0)</div>
<div class="line">      {</div>
<div class="line">       FluidInterfaceBoundingElement* point_element_pt =</div>
<div class="line">        surface_element_pt-&gt;make_bounding_element(-1);</div>
<div class="line">       <span class="comment">//Add element to the point mesh</span></div>
<div class="line">       Point_mesh_pt-&gt;add_element_pt(point_element_pt);</div>
<div class="line">       <span class="comment">//Set the capillary number</span></div>
<div class="line">       point_element_pt-&gt;ca_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a8b32b93d2e546f9375ec418474107838">Global_Physical_Variables::Ca</a>;</div>
<div class="line">       <span class="comment">//Set the wall normal</span></div>
<div class="line">       point_element_pt-&gt;wall_unit_normal_fct_pt() = </div>
<div class="line">        &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#aa26e74c1f9f93f8212e45380f55fb562">Global_Physical_Variables::wall_unit_normal_inlet_fct</a>;</div>
<div class="line">       <span class="comment">//Set the contact angle (using the strong version of the constraint)</span></div>
<div class="line">       point_element_pt-&gt;set_contact_angle(</div>
<div class="line">        &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a1c3587461447262715bd444ac91a29c9">Global_Physical_Variables::Inlet_Angle</a>);</div>
<div class="line">      }</div>
<div class="line">     </div>
<div class="line">     <span class="comment">//Make another point element from the right-hand side of the </span></div>
<div class="line">     <span class="comment">//last surface element (note that this relies on knowledge of </span></div>
<div class="line">     <span class="comment">//the element order within the mesh)</span></div>
<div class="line">     <span class="keywordflow">if</span>(e==n_boundary_element-1)</div>
<div class="line">      {</div>
<div class="line">       FluidInterfaceBoundingElement* point_element_pt =</div>
<div class="line">        surface_element_pt-&gt;make_bounding_element(1);</div>
<div class="line">       <span class="comment">//Add element to the mesh</span></div>
<div class="line">       Point_mesh_pt-&gt;add_element_pt(point_element_pt);</div>
<div class="line">       <span class="comment">//Set the capillary number</span></div>
<div class="line">       point_element_pt-&gt;ca_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a8b32b93d2e546f9375ec418474107838">Global_Physical_Variables::Ca</a>;</div>
<div class="line">       <span class="comment">// Set the function that specifies the wall normal</span></div>
<div class="line">       point_element_pt-&gt;wall_unit_normal_fct_pt() = </div>
<div class="line">        &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a8ab8f6e823e4cd204ed7264121a42bfb">Global_Physical_Variables::wall_unit_normal_outlet_fct</a>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">//end of make_free_surface_elements</span></div>
</div><!-- fragment --><p>The function <code>complete_build()</code> assigns physical parameters to the fluid elements, sets the boundary conditions and assigns equation numbers.  </p><div class="fragment"><div class="line"> <span class="keywordtype">void</span> complete_build()</div>
<div class="line">  {</div>
<div class="line">   <span class="keyword">using namespace </span><a class="code" href="namespaceGlobal__Physical__Variables.html">Global_Physical_Variables</a>;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Complete the build of the fluid elements by passing physical parameters</span></div>
<div class="line">   <span class="comment">//Find the number of bulk elements</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_element = Bulk_mesh_pt-&gt;nelement();</div>
<div class="line">   <span class="comment">//Loop over all the fluid elements </span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">//Cast to a fluid element</span></div>
<div class="line">     ELEMENT *temp_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(Bulk_mesh_pt-&gt;element_pt(e));</div>
<div class="line">     </div>
<div class="line">     <span class="comment">//Set the Reynolds number</span></div>
<div class="line">     temp_pt-&gt;re_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#ab814e627d2eb5bc50318879d19ab16b9">Re</a>;</div>
<div class="line">     <span class="comment">//The Strouhal number is 1, so ReSt = Re</span></div>
<div class="line">     temp_pt-&gt;re_st_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#ab814e627d2eb5bc50318879d19ab16b9">Re</a>;</div>
<div class="line">     <span class="comment">//Set the Reynolds number / Froude number</span></div>
<div class="line">     temp_pt-&gt;re_invfr_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#aa6286f02b476912dd7550eced538331a">ReInvFr</a>;</div>
<div class="line">     <span class="comment">//Set the direction of gravity</span></div>
<div class="line">     temp_pt-&gt;g_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#aa868968dead376240a69f9152bd599b9">G</a>;</div>
<div class="line">    }</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//------------Set the boundary conditions for this problem----------</span></div>
<div class="line"> </div>
<div class="line">   {</div>
<div class="line">    <span class="comment">//Determine whether we are solving an elastic problem or not</span></div>
<div class="line">    <span class="keywordtype">bool</span> elastic = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span>(<span class="keyword">dynamic_cast&lt;</span>SolidNode*<span class="keyword">&gt;</span>(Bulk_mesh_pt-&gt;node_pt(0))) {elastic=<span class="keyword">true</span>;}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Loop over the bottom of the mesh (the wall of the channel)</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> n_node = Bulk_mesh_pt-&gt;nboundary_node(0);</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;n_node;j++)</div>
<div class="line">     {</div>
<div class="line">      <span class="comment">//Pin the u- and v- velocities</span></div>
<div class="line">      Bulk_mesh_pt-&gt;boundary_node_pt(0,j)-&gt;pin(0);</div>
<div class="line">      Bulk_mesh_pt-&gt;boundary_node_pt(0,j)-&gt;pin(1);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">//If we are formulating the elastic problem pin both positions</span></div>
<div class="line">      <span class="comment">//of nodes</span></div>
<div class="line">      <span class="keywordflow">if</span>(elastic)</div>
<div class="line">       {</div>
<div class="line">        <span class="keyword">static_cast&lt;</span>SolidNode*<span class="keyword">&gt;</span>(Bulk_mesh_pt-&gt;boundary_node_pt(0,j))</div>
<div class="line">         -&gt;pin_position(0);</div>
<div class="line">        <span class="keyword">static_cast&lt;</span>SolidNode*<span class="keyword">&gt;</span>(Bulk_mesh_pt-&gt;boundary_node_pt(0,j))</div>
<div class="line">         -&gt;pin_position(1);</div>
<div class="line">       }</div>
<div class="line">     }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">//Loop over the inlet and set the Dirichlet condition</span></div>
<div class="line">    <span class="comment">//of no vertical velocity</span></div>
<div class="line">    n_node = Bulk_mesh_pt-&gt;nboundary_node(3);</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;n_node;j++)</div>
<div class="line">     {</div>
<div class="line">      Bulk_mesh_pt-&gt;boundary_node_pt(3,j)-&gt;pin(1);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">//If elastic pin horizontal position of nodes</span></div>
<div class="line">      <span class="keywordflow">if</span>(elastic)</div>
<div class="line">       { </div>
<div class="line">        <span class="keyword">static_cast&lt;</span>SolidNode*<span class="keyword">&gt;</span>(Bulk_mesh_pt-&gt;boundary_node_pt(3,j))</div>
<div class="line">         -&gt;pin_position(0);</div>
<div class="line">       }</div>
<div class="line">     }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">//Loop over the outlet and set the Dirichlet condition</span></div>
<div class="line">    <span class="comment">//of no vertical velocity</span></div>
<div class="line">    n_node = Bulk_mesh_pt-&gt;nboundary_node(1);</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;n_node;j++)</div>
<div class="line">     {</div>
<div class="line">      Bulk_mesh_pt-&gt;boundary_node_pt(1,j)-&gt;pin(1);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">//If elastic pin horizontal position</span></div>
<div class="line">      <span class="keywordflow">if</span>(elastic)</div>
<div class="line">       { </div>
<div class="line">        <span class="keyword">static_cast&lt;</span>SolidNode*<span class="keyword">&gt;</span>(Bulk_mesh_pt-&gt;boundary_node_pt(1,j))</div>
<div class="line">         -&gt;pin_position(0);</div>
<div class="line">       }</div>
<div class="line">     }</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Attach the boundary conditions to the mesh</span></div>
<div class="line">   std::cout &lt;&lt; assign_eqn_numbers() &lt;&lt; <span class="stringliteral">&quot; in the main problem&quot;</span> &lt;&lt; std::endl; </div>
<div class="line">  } <span class="comment">//end of complete_build</span></div>
</div><!-- fragment --><p> Note that boundary conditions for the nodal positions in the pseudo-elastic formulation are specified by testing whether the <code>Nodes</code> are <code>SolidNodes</code>. In this case, the <code>Nodes</code> on the inlet and outlet boundaries are constrained to remain at the same horizontal position and the <code>Nodes</code> on the plane wall are fixed.</p>
<p>The function <code>solve_steady()</code> initialises the velocity of at all <code>Nodes</code> to the flat-film solution, solves the steady equations and writes the solution to a file. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classInclinedPlaneProblem.html#a0e2fcfdb8230df82729ba7d728e58040">InclinedPlaneProblem&lt;ELEMENT,INTERFACE_ELEMENT&gt;::solve_steady</a>()</div>
<div class="ttc" id="aclassInclinedPlaneProblem_html_a0e2fcfdb8230df82729ba7d728e58040"><div class="ttname"><a href="classInclinedPlaneProblem.html#a0e2fcfdb8230df82729ba7d728e58040">InclinedPlaneProblem::solve_steady</a></div><div class="ttdeci">void solve_steady()</div><div class="ttdoc">Solve the steady problem.</div><div class="ttdef"><b>Definition:</b> <a href="inclined__plane_8cc_source.html#l00411">inclined_plane.cc:411</a></div></div>
<div class="line">{</div>
<div class="line"> <span class="comment">//Load the namespace</span></div>
<div class="line"> <span class="keyword">using namespace </span><a class="code" href="namespaceGlobal__Physical__Variables.html">Global_Physical_Variables</a>;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Initially set all nodes to the Nusselt flat-film solution</span></div>
<div class="line"> {</div>
<div class="line">  <span class="keywordtype">unsigned</span> n_node = Bulk_mesh_pt-&gt;nnode();</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span>  n=0;n&lt;n_node;n++)</div>
<div class="line">   {</div>
<div class="line">    <span class="keywordtype">double</span> y = Bulk_mesh_pt-&gt;node_pt(n)-&gt;x(1);</div>
<div class="line">    <span class="comment">//Top row</span></div>
<div class="line">    Bulk_mesh_pt-&gt;node_pt(n)-&gt;set_value(0,0.5*<a class="code" href="namespaceGlobal__Physical__Variables.html#aa6286f02b476912dd7550eced538331a">ReInvFr</a>*sin(<a class="code" href="namespaceGlobal__Physical__Variables.html#aa2e802ee7cc8e1ac900ba94c3ce86eb7">Alpha</a>)*(2.0*y - y*y));</div>
<div class="line">   }</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Do one steady solve</span></div>
<div class="line"> steady_newton_solve();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Output the full flow field</span></div>
<div class="line"> std::string filename = Output_prefix;;</div>
<div class="line"> filename.append(<span class="stringliteral">&quot;_output.dat&quot;</span>);</div>
<div class="line"> ofstream file(filename.c_str());</div>
<div class="line"> Bulk_mesh_pt-&gt;output(file,5);</div>
<div class="line"> file.close();</div>
<div class="line">} <span class="comment">//end of solve_steady</span></div>
</div><!-- fragment --><p> Finally, the function <code>timestep()</code> takes a number of fixed timesteps writing vertical positions and the time to a trace file and writing the complete flow field to disk after a given number of timesteps. </p><div class="fragment"><div class="line">timestep(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;dt, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;n_tsteps)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">//Need to use the Global variables here</span></div>
<div class="line"> <span class="keyword">using namespace </span><a class="code" href="namespaceGlobal__Physical__Variables.html">Global_Physical_Variables</a>;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Open an output file</span></div>
<div class="line"> std::string filename = Output_prefix;</div>
<div class="line"> filename.append(<span class="stringliteral">&quot;_time_trace.dat&quot;</span>);</div>
<div class="line"> ofstream trace(filename.c_str()); </div>
<div class="line"> <span class="comment">//Counter that will be used to output the full flowfield</span></div>
<div class="line"> <span class="comment">//at certain timesteps</span></div>
<div class="line"> <span class="keywordtype">int</span> counter=0; </div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Initial output of the time and the value of the vertical position at the</span></div>
<div class="line"> <span class="comment">//left and right-hand end of the free surface</span></div>
<div class="line"> trace &lt;&lt; time_pt()-&gt;time() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div>
<div class="line">       &lt;&lt; Bulk_mesh_pt-&gt;boundary_node_pt(2,0)-&gt;value(1) </div>
<div class="line">       &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">       &lt;&lt;  Bulk_mesh_pt-&gt;</div>
<div class="line">  boundary_node_pt(2, Bulk_mesh_pt-&gt;nboundary_node(2)-1)-&gt;x(1) </div>
<div class="line">       &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">       &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Loop over the desired number of timesteps</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> t=1;t&lt;=n_tsteps;t++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Increase the counter</span></div>
<div class="line">   counter++;</div>
<div class="line">   cout &lt;&lt; std::endl;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;--------------TIMESTEP &quot;</span> &lt;&lt; t&lt;&lt; <span class="stringliteral">&quot; ------------------&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Take a timestep of size dt</span></div>
<div class="line">   unsteady_newton_solve(dt);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Uncomment to get full solution output</span></div>
<div class="line">   <span class="keywordflow">if</span>(counter==2) <span class="comment">//Change this number to get output every n steps</span></div>
<div class="line">    {</div>
<div class="line">     std::ofstream file;</div>
<div class="line">     std::ostringstream filename;</div>
<div class="line">     filename &lt;&lt; Output_prefix &lt;&lt; <span class="stringliteral">&quot;_step&quot;</span> &lt;&lt; <a class="code" href="namespaceGlobal__Physical__Variables.html#ab814e627d2eb5bc50318879d19ab16b9">Re</a> &lt;&lt; <span class="stringliteral">&quot;_&quot;</span> &lt;&lt; t &lt;&lt; <span class="stringliteral">&quot;.dat&quot;</span>;</div>
<div class="line">     file.open(filename.str().c_str());</div>
<div class="line">     Bulk_mesh_pt-&gt;output(file,5);</div>
<div class="line">     file.close();</div>
<div class="line">     </div>
<div class="line">     counter=0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Always output the interface</span></div>
<div class="line">   {</div>
<div class="line">    std::ofstream file;</div>
<div class="line">     std::ostringstream filename;</div>
<div class="line">     filename &lt;&lt; Output_prefix &lt;&lt; <span class="stringliteral">&quot;_interface_&quot;</span> &lt;&lt; <a class="code" href="namespaceGlobal__Physical__Variables.html#ab814e627d2eb5bc50318879d19ab16b9">Re</a> &lt;&lt; <span class="stringliteral">&quot;_&quot;</span> &lt;&lt; t &lt;&lt; <span class="stringliteral">&quot;.dat&quot;</span>;</div>
<div class="line">     file.open(filename.str().c_str());</div>
<div class="line">     Surface_mesh_pt-&gt;output(file,5);</div>
<div class="line">     file.close();</div>
<div class="line">   }</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Output the time and value of the vertical position of the free surface</span></div>
<div class="line">   <span class="comment">//at the left- and right-hand ends</span></div>
<div class="line">   trace &lt;&lt; time_pt()-&gt;time() &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">         &lt;&lt; Bulk_mesh_pt-&gt;boundary_node_pt(2,0)-&gt;x(1) &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">         &lt;&lt; </div>
<div class="line">    Bulk_mesh_pt-&gt;</div>
<div class="line">    boundary_node_pt(2,Bulk_mesh_pt-&gt;nboundary_node(2)-1)-&gt;x(1) &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">         &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">//end of timestep</span></div>
</div><!-- fragment --> <h2><a class="anchor" id="spine_prob"></a>
The spine-based formulation</h2>
<p>The class <code><a class="el" href="classSpineInclinedPlaneProblem.html">SpineInclinedPlaneProblem</a></code> inherits from the generic <code><a class="el" href="classInclinedPlaneProblem.html" title="Generic problem class that will form the base class for both spine and elastic mesh-updates of the pr...">InclinedPlaneProblem</a></code> class and requires only minor modification. The constructor sets the string <code>Output_prefix</code>, builds a timestepper, builds the specific <code>SpineMesh</code>, creates the appropriate <code>FaceElements</code>, adds all sub-meshes to the <code>Problem</code>, builds the global mesh and then calls <code><a class="el" href="classInclinedPlaneProblem.html#ae44e360be4a46e1343c3960c3a43380f" title="Complete the build of the problem setting all standard parameters and boundary conditions.">InclinedPlaneProblem::complete_build()</a></code>. </p><div class="fragment"><div class="line"> <a class="code" href="classSpineInclinedPlaneProblem.html">SpineInclinedPlaneProblem</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;nx, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;ny,</div>
<div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;length): </div>
<div class="line">  <a class="code" href="classInclinedPlaneProblem.html">InclinedPlaneProblem</a>&lt;ELEMENT,SpineLineFluidInterfaceElement&lt;ELEMENT&gt; &gt;</div>
<div class="line">  (nx,ny,length) </div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Set the name</span></div>
<div class="line">   this-&gt;Output_prefix = <span class="stringliteral">&quot;spine&quot;</span>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Create our one and only timestepper, with adaptive timestepping</span></div>
<div class="line">   this-&gt;add_time_stepper_pt(<span class="keyword">new</span> TIMESTEPPER);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Create the bulk mesh</span></div>
<div class="line">   this-&gt;Bulk_mesh_pt = <span class="keyword">new</span>  <a class="code" href="classSpineInclinedPlaneMesh.html">SpineInclinedPlaneMesh&lt;ELEMENT&gt;</a>(</div>
<div class="line">    nx,ny,length,1.0,this-&gt;time_stepper_pt());</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Create the traction elements</span></div>
<div class="line">   this-&gt;make_traction_elements();</div>
<div class="line">   <span class="comment">//Create the free surface elements</span></div>
<div class="line">   this-&gt;make_free_surface_elements();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Add all sub meshes to the problem</span></div>
<div class="line">   this-&gt;add_sub_mesh(this-&gt;Bulk_mesh_pt);</div>
<div class="line">   this-&gt;add_sub_mesh(this-&gt;Traction_mesh_pt);</div>
<div class="line">   this-&gt;add_sub_mesh(this-&gt;Surface_mesh_pt);</div>
<div class="line">   this-&gt;add_sub_mesh(this-&gt;Point_mesh_pt);</div>
<div class="line">   <span class="comment">//Create the global mesh</span></div>
<div class="line">   this-&gt;build_global_mesh();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Complete the build of the problem</span></div>
<div class="line">   this-&gt;complete_build();</div>
<div class="line">  }</div>
</div><!-- fragment --><p> In a spine-based formulation, the nodal positions must be updated after every Newton step, which is achieved by overloading the function <code>Problem::actions_before_newton_convergence_check()</code> </p><div class="fragment"><div class="line"> <span class="comment">/// Spine heights/lengths are unknowns in the problem so their</span></div>
<div class="line"><span class="comment"> /// values get corrected during each Newton step. However,</span></div>
<div class="line"><span class="comment"></span><span class="comment"> /// changing their value does not automatically change the</span></div>
<div class="line"><span class="comment"></span><span class="comment"> /// nodal positions, so we need to update all of them</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> actions_before_newton_convergence_check()</div>
<div class="line">  {this-&gt;Bulk_mesh_pt-&gt;node_update();}</div>
</div><!-- fragment --><p> We also specify a destructor to clean up memory allocated by the class.</p>
<h2><a class="anchor" id="elastic_probe"></a>
The pseudo-solid-based formulation</h2>
<p>The class <code><a class="el" href="classElasticInclinedPlaneProblem.html">ElasticInclinedPlaneProblem</a></code> inherits from the generic <code><a class="el" href="classInclinedPlaneProblem.html" title="Generic problem class that will form the base class for both spine and elastic mesh-updates of the pr...">InclinedPlaneProblem</a></code> class and also requires only minor modification. The constructor sets the string <code>Output_prefix</code>, builds a timestepper, builds the specific <code>SolidMesh</code>, sets the constitutive law for the bulk elements, creates the appropriate <code>FaceElements</code>, adds all sub-meshes to the <code>Problem</code>, builds the global mesh and then calls <code><a class="el" href="classInclinedPlaneProblem.html#ae44e360be4a46e1343c3960c3a43380f" title="Complete the build of the problem setting all standard parameters and boundary conditions.">InclinedPlaneProblem::complete_build()</a></code> </p><div class="fragment"><div class="line"> <a class="code" href="classElasticInclinedPlaneProblem.html">ElasticInclinedPlaneProblem</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;nx, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;ny,</div>
<div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;length) :</div>
<div class="line">  <a class="code" href="classInclinedPlaneProblem.html">InclinedPlaneProblem</a>&lt;ELEMENT,ElasticLineFluidInterfaceElement&lt;ELEMENT&gt; &gt;</div>
<div class="line">  (nx,ny,length) </div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Set the name</span></div>
<div class="line">   this-&gt;Output_prefix = <span class="stringliteral">&quot;elastic&quot;</span>;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Create our one and only timestepper, with adaptive timestepping</span></div>
<div class="line">   this-&gt;add_time_stepper_pt(<span class="keyword">new</span> TIMESTEPPER);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Create the bulk mesh</span></div>
<div class="line">   this-&gt;Bulk_mesh_pt = <span class="keyword">new</span>  <a class="code" href="classElasticInclinedPlaneMesh.html">ElasticInclinedPlaneMesh&lt;ELEMENT&gt;</a>(</div>
<div class="line">    nx,ny,length,1.0,this-&gt;time_stepper_pt());</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Set the consititutive law for the elements</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_element = this-&gt;Bulk_mesh_pt-&gt;nelement();</div>
<div class="line">   <span class="comment">//Loop over all the fluid elements </span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">//Cast to a fluid element</span></div>
<div class="line">     ELEMENT *temp_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(</div>
<div class="line">      this-&gt;Bulk_mesh_pt-&gt;element_pt(e));</div>
<div class="line">     <span class="comment">//Set the constitutive law </span></div>
<div class="line">     temp_pt-&gt;constitutive_law_pt() = </div>
<div class="line">      <a class="code" href="namespaceGlobal__Physical__Variables.html#a2a37fb040c832ee7a086bb13bb02a100">Global_Physical_Variables::Constitutive_law_pt</a>;</div>
<div class="line">    }</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Create the traction elements</span></div>
<div class="line">   this-&gt;make_traction_elements();</div>
<div class="line">   <span class="comment">//Create the free surface element</span></div>
<div class="line">   this-&gt;make_free_surface_elements();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Add all sub meshes to the problem</span></div>
<div class="line">   this-&gt;add_sub_mesh(this-&gt;Bulk_mesh_pt);</div>
<div class="line">   this-&gt;add_sub_mesh(this-&gt;Traction_mesh_pt);</div>
<div class="line">   this-&gt;add_sub_mesh(this-&gt;Surface_mesh_pt);</div>
<div class="line">   this-&gt;add_sub_mesh(this-&gt;Point_mesh_pt);</div>
<div class="line">   <span class="comment">//Create the global mesh</span></div>
<div class="line">   this-&gt;build_global_mesh();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Complete the rest of the build</span></div>
<div class="line">   this-&gt;complete_build();</div>
<div class="line">  } <span class="comment">//end of constructor</span></div>
</div><!-- fragment --><p> In a pseudo-solid formulation, it is advantageous to reset the undeformed configuration after every timestep (an updated Lagrangian formulation). Hence, the <code>Problem::actions_after_implicit_timestep()</code> function is overloaded </p><div class="fragment"><div class="line"> <span class="keywordtype">void</span> actions_after_implicit_timestep()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Now loop over all the nodes and reset their Lagrangian coordinates</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_node = this-&gt;Bulk_mesh_pt-&gt;nnode();</div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> n=0;n&lt;n_node;n++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">//Cast node to an elastic node</span></div>
<div class="line">     SolidNode* temp_pt = </div>
<div class="line">      <span class="keyword">static_cast&lt;</span>SolidNode*<span class="keyword">&gt;</span>(this-&gt;Bulk_mesh_pt-&gt;node_pt(n));</div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;2;j++) {temp_pt-&gt;xi(j) = temp_pt-&gt;x(j);}</div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">//end of actions_after_implicit_timestep</span></div>
</div><!-- fragment --><p> We also specify a destructor to clean up memory allocated by the class.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="exercises"></a>
Exercises</h1>
<ol type="1">
<li>Confirm that the steady solution agrees with the exact solution.</li>
<li>Investigate what happens when the angle is varied. What happens when the angle is set to zero? What happens when the angle is set to <img class="formulaInl" alt="$\pi/2$" src="form_37.png" width="21" height="14"/>?</li>
<li>What happens if the hydrostatic pressure boundary conditions are not applied?</li>
<li>How does the stability of the system to the perturbation change with angle, <img class="formulaInl" alt="$ Ca $" src="form_38.png" width="16" height="10"/> and <img class="formulaInl" alt="$ K $" src="form_39.png" width="11" height="10"/>? Are the results in agreement with the theoretical predictions?</li>
<li>Are the results independent of the length of the domain?</li>
<li>Compare the spine-based and pseudo-elastic-based formulations? What is the same and what is different? Which method do you prefer? <hr  />
 <hr  />
</li>
</ol>
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory:<br  />
<br  />
<center> <a href="../../../../demo_drivers/navier_stokes/inclined_plane/">demo_drivers/navier_stokes/inclined_plane/ </a> </center><br  />
</li>
<li>The driver code is: <br  />
<br  />
<center> <a href="../../../../demo_drivers/navier_stokes/inclined_plane/inclined_plane.cc">demo_drivers/navier_stokes/inclined_plane/inclined_plane.cc </a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:19:24
        </div>
      </div>
    </footer>
</body>
</html>
