<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Interfaces, Free Surfaces and Surface Transport: Theory and implementation</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Interfaces, Free Surfaces and Surface Transport: Theory and implementation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document provides the theoretical background underlying <code>oomph-lib's</code> free surface, interface and surface transport capabilities. We begin with a review of the relevant theory to establish the overall framework and notation, and then discuss the implementation of the methodology in <code>oomph-lib</code>.</p>
<p>Here is an overview of the structure of this document:</p><ul>
<li><a class="el" href="index.html#theory">Theory</a><ul>
<li><a class="el" href="index.html#surface_representation">Geometry of Surfaces</a></li>
<li><a class="el" href="index.html#surface_gradient">Differential Operators On A Surface</a></li>
<li><a class="el" href="index.html#boundary_conditions">Free Surface and Interface Boundary Conditions</a></li>
<li><a class="el" href="index.html#surface_transport">Surface Transport Equations</a></li>
</ul>
</li>
</ul>
<ul>
<li><a class="el" href="index.html#fs_implementation">Implementation</a><ul>
<li><a class="el" href="index.html#fluid_interface">The FluidInterfaceElement class</a></li>
<li><a class="el" href="index.html#line">The LineDerivatives class</a></li>
<li><a class="el" href="index.html#axi">The AxisymmetricDerivatives class</a></li>
<li><a class="el" href="index.html#spine_formulation">The SpineLine/Axi/SurfaceFluidInterfaceElement classes</a></li>
<li><a class="el" href="index.html#elastic_formulation">The ElasticLine/Axi/SurfaceFluidInterfaceElement classes</a></li>
</ul>
</li>
</ul>
<p>If you don't need all the gory details, you may prefer to start by exploring the free-surface flow tutorials in <code>oomph-lib's</code> <a href="../../../example_code_list/html/index.html#free_surface_nst">list of example driver codes.</a></p>
<hr  />
 <hr  />
<h1><a class="anchor" id="theory"></a>
Theory</h1>
<p>A complete theoretical treatment of moving surfaces in space requires the use of differential geometry, described in detail by Aris (1962) <em> Vectors, Tensors and the Basic Equations of Fluid Mechanics </em>, Wetherburn (1955) <em> Differential Geometry of Three Dimensions, Volume I </em> and Green &amp; Zerna (1968) <em> Theoretical Elasticity </em> among others. Here, we shall present only the essential information and the reader is referred to these texts to fill in additional background.</p>
<hr  />
<h2><a class="anchor" id="surface_representation"></a>
Geometry of Surfaces</h2>
<p>For our purposes, a surface is a object of dimension <img class="formulaInl" alt="$n-1$" src="form_0.png" width="30" height="9"/> embedded in an <img class="formulaInl" alt="$n\!$" src="form_1.png" width="9" height="6"/>-dimensional Euclidean space, where <img class="formulaInl" alt="$n$" src="form_2.png" width="9" height="6"/> is two or three. We can always represent such a surface by a position vector from our chosen origin <img class="formulaInl" alt="$ \mathbf{R}^{*}(\zeta^{\alpha},t) $" src="form_3.png" width="50" height="14"/>, parametrised by time <img class="formulaInl" alt="$t$" src="form_4.png" width="5" height="9"/> and intrinsic (surface) coordinates <img class="formulaInl" alt="$\zeta^{\alpha}$" src="form_5.png" width="13" height="13"/>, where the Greek index <img class="formulaInl" alt="$\alpha = 1,..,n-1$" src="form_6.png" width="78" height="11"/>.</p>
<p>Throughout this document we will use the summation convention that repeated Roman indices are to be summed over the range from 1 to <img class="formulaInl" alt="$n$" src="form_2.png" width="9" height="6"/> and repeated Greek indices are to be summed over the range from 1 to <img class="formulaInl" alt="$n-1$" src="form_0.png" width="30" height="9"/>. We will retain the summation signs for all other sums, such as sums over the nodes etc.</p>
<p>The covariant base vectors of the surface are defined to be the partial derivatives of the position vector with respect to the surface coordinates. For a two-dimensional surface, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{\boldmath$g$}_{1} = \frac{\partial\mbox{\boldmath$R$}}{\partial \zeta^{1}}, \quad \quad \quad \mbox{\boldmath$g$}_{2} = \frac{\partial\mbox{\boldmath$R$}}{\partial \zeta^{2}}. \]" src="form_7.png" width="150" height="30"/>
</p>
<p> The covariant metric tensor of the surface is formed by taking the dot product of the covariant base vectors </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ g_{\alpha\beta} = \mbox{\boldmath$g$}_{\alpha}\mbox{\boldmath$\cdot$} \mbox{\boldmath$g$}_{\beta}, \]" src="form_8.png" width="71" height="11"/>
</p>
<p> and the determinant of the covariant metric tensor is denoted by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ g = g_{11}g_{22} - g_{12}g_{21}. \]" src="form_9.png" width="108" height="9"/>
</p>
<p> The contravariant metric tensor is the inverse of the covariant metric tensor and is denoted by <img class="formulaInl" alt="$ g^{\alpha\beta} $" src="form_10.png" width="20" height="14"/>. Thus, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ g^{11} = g_{22}/g, \quad g^{12} = -g_{12}/g, \quad g^{21} = - g_{21}/g, \quad g^{22} = g_{11}/g. \]" src="form_11.png" width="328" height="16"/>
</p>
<p>For a one-dimensional surface, there is a single covariant base vector that coincides with the tangent vector </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{\boldmath$g$}_{1} = \frac{\partial \mbox{\boldmath$R$}}{\partial \zeta^1}.\]" src="form_12.png" width="55" height="30"/>
</p>
<p> Here, the covariant metric tensor is simply the inner product of the tangent vector with itself <img class="formulaInl" alt="$ g_{11} = \mbox{\boldmath$g$}_{1} \mbox{\boldmath$\cdot g$}_{1} $" src="form_13.png" width="63" height="10"/> with determinant <img class="formulaInl" alt="$ g = g_{11} $" src="form_14.png" width="40" height="9"/> and the contravariant metric tensor is <img class="formulaInl" alt="$ g^{11} = 1/g_{11} $" src="form_15.png" width="63" height="15"/>.</p>
<p>We will need to integrate quantities over the surface, which uses the result that an infinitesimal unit of area is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{ d}S = \sqrt{g} \mbox{ d}\zeta^{\alpha}, \]" src="form_16.png" width="78" height="14"/>
</p>
<p> in terms of the intrinsic coordinates.</p>
<div class="image">
<img src="surface_sketch.gif" alt=""/>
<div class="caption">
Sketch of section of a two-dimensional surface, S , in a three-dimensional space. The covariant base vectors are tangent to the surface and in the direction of the intrinsic surface coordinates. The intrinsic coordinates parametrise the position vector to material points in the surface. The surface is bounded by the curve B and the vector m is perpendicular to the outer unit normal of the surface and tangent to the bounding curve. </div></div>
 <hr  />
<h2><a class="anchor" id="surface_gradient"></a>
Differential Operators On A Surface</h2>
<p>The formulation of transport equations within the surface requires the rates of change of surface quantities. The appropriate derivative is the surface gradient, often written as <img class="formulaInl" alt="$ \mbox{\boldmath$\nabla$}_{\!\!_S} $" src="form_17.png" width="14" height="14"/> and defined unhelpfully in many papers and textbooks as the gradient operator restricted to the surface or </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{\boldmath$\nabla$}_{\!\!S} \phi = \mbox{\boldmath$\nabla$} \phi - (\mbox{\boldmath$\nabla$}\phi \mbox{\boldmath$\cdot n$}) \mbox{\boldmath$n$}.\]" src="form_18.png" width="129" height="14"/>
</p>
<p> The problem with the above definition is that if a quantity is defined only on the surface it is impossible to take its gradient <img class="formulaInl" alt="$\mbox{\boldmath$\nabla$}$" src="form_19.png" width="11" height="11"/>.</p>
<p>A more helpful definition in terms of the intrinsic coordinates is that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{\boldmath$\nabla$}_{\!\!_S} \phi = g^{\alpha\beta} \mbox{\boldmath$g$}_{\alpha} \frac{\partial \phi}{\partial \zeta^{\beta}}. \]" src="form_20.png" width="100" height="30"/>
</p>
<p> For a one dimensional surface parametrised by the arc-length, <img class="formulaInl" alt="$ s$" src="form_21.png" width="5" height="6"/>, this reduces to <img class="formulaInl" alt="$ \mbox{\boldmath$\nabla$}_{\!\!_S} \phi = \mbox{\boldmath$t$} \partial \phi / \partial s,$" src="form_22.png" width="81" height="14"/> where <img class="formulaInl" alt="$ t$" src="form_23.png" width="5" height="9"/> is a unit tangent vector to the surface. By definition the surface gradient is tangent to the surface and has no normal component.</p>
<p>The surface divergence of an <img class="formulaInl" alt="$ n\!$" src="form_24.png" width="9" height="6"/>-dimensional vector quantity defined on the surface is given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{\boldmath$\nabla$}_{\!\!_S} \mbox{\boldmath$\cdot v$} = g^{\alpha\beta} \mbox{\boldmath$g$}_{\alpha} \mbox{\boldmath$\cdot$} \frac{\partial \mbox{\boldmath$v$}}{\partial \zeta^{\beta}}. \]" src="form_25.png" width="109" height="30"/>
</p>
<p> The divergence theorem applied over the surface (Aris, 1955) is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int\!\!\!\int_{S} \mbox{\boldmath$\nabla$}_{\!\!_S} \mbox{\boldmath$\cdot v$}_{t}\,\mbox{ d}S = \int_{B} \mbox{\boldmath$v$}_{t} \mbox{\boldmath$\cdot m$}\,\mbox{d} l, \]" src="form_26.png" width="156" height="30"/>
</p>
<p> where <img class="formulaInl" alt="$ \mbox{\boldmath$v$}_{t}$" src="form_27.png" width="13" height="9"/> is a vector tangential to the surface; and <img class="formulaInl" alt="$ \mbox{\boldmath$m$}$" src="form_28.png" width="14" height="6"/> is the unit vector tangent to the surface, but perpendicular to the tangent of the bounding curve <img class="formulaInl" alt="$ B$" src="form_29.png" width="10" height="10"/>, see the Figure above.</p>
<p>If a general vector is decomposed into normal and tangential components, <img class="formulaInl" alt="$ \mbox{\boldmath$v$} = \mbox{\boldmath$v$}_{t} + v_{n} \mbox{\boldmath$n$} $" src="form_30.png" width="74" height="11"/>, we can write </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int\!\!\!\int_{S} \mbox{\boldmath$\nabla$}_{\!\!_S} \mbox{\boldmath$\cdot v$}\,\mbox{ d}S = \int\!\!\!\int_{S} \mbox{\boldmath$\nabla$}_{\!\!_S} \mbox{\boldmath$\cdot$} \left(\mbox{\boldmath$v$}_{t} + v_{n} \mbox{\boldmath$n$}\right)\,\mbox{ d}S = \int\!\!\!\int_{S} \mbox{\boldmath$\nabla$}_{\!\!_S} \mbox{\boldmath$\cdot v$}_{t}\,\mbox{ d}S + \int\!\!\!\int_{S} \mbox{\boldmath$\nabla$}_{\!\!_S} \mbox{\boldmath$\cdot$} (v_{n} \mbox{\boldmath$n$})\,\mbox{ d}S \]" src="form_31.png" width="424" height="30"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ = \int\!\!\!\int_{S} \mbox{\boldmath$\nabla$}_{\!\!_S} \mbox{\boldmath$\cdot v$}_{t}\,\mbox{ d}S\ + \int\!\!\!\int_{S} v_{n} \mbox{\boldmath$\nabla$}_{\!\!_S} \mbox{\boldmath$\cdot$} \mbox{\boldmath$n$} + \mbox{\boldmath$n\cdot\nabla$}_{\!\!_S} v_{n}\,\mbox{ d}S = \int\!\!\!\int_{S} \mbox{\boldmath$\nabla$}_{\!\!_S} \mbox{\boldmath$\cdot v$}_{t}\,\mbox{ d}S\ - \int\!\!\!\int_{S} v_{n} \kappa\,\mbox{ d}S, \]" src="form_32.png" width="429" height="30"/>
</p>
<p> where <img class="formulaInl" alt="$\kappa$" src="form_33.png" width="8" height="6"/> is twice the mean curvature of the surface and equal to minus the surface divergence of the normal. The term <img class="formulaInl" alt="$ \mbox{\boldmath$n\cdot\nabla$}_{\!\!_S} v_{n} = 0 $" src="form_34.png" width="71" height="14"/> because the normal and surface divergence of any scalar quantity are orthogonal.</p>
<p>Hence using the divergence theorem on the first term on the right-hand side, we obtain </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int\!\!\!\int_{S} \mbox{\boldmath$\nabla$}_{\!\!_S} \mbox{\boldmath$\cdot v$}\,\mbox{ d}S = - \int\!\!\!\int_{S} v_{n} \kappa\,\mbox{ d}S + \int_{B} \mbox{\boldmath$v$}_{t} \mbox{\boldmath$\cdot m$}\,\mbox{d} l = - \int\!\!\!\int_{S} v_{n} \kappa\,\mbox{ d}S + \int_{B} \mbox{\boldmath$v\cdot m$}\,\mbox{d} l, \quad (1) \]" src="form_35.png" width="435" height="30"/>
</p>
<p> because the normal component of <img class="formulaInl" alt="$ \mbox{\boldmath$v$}$" src="form_36.png" width="9" height="6"/> is perpendicular to <img class="formulaInl" alt="$ \mbox{\boldmath$m$}$" src="form_28.png" width="14" height="6"/> and therefore contributes nothing to the line integral.</p>
<p>If we now choose <img class="formulaInl" alt="$ \mbox{\boldmath$v$} = \phi\, \mbox{\boldmath$e$}_{i}$" src="form_37.png" width="45" height="13"/>, where <img class="formulaInl" alt="$ \mbox{\boldmath$e$}_{i}$" src="form_38.png" width="10" height="9"/> is the unit base vector in the <img class="formulaInl" alt="$ i\!$" src="form_39.png" width="5" height="9"/>-th Cartesian coordinate direction, then we obtain </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\int\!\!\!\int_{S} \mbox{\boldmath$\nabla$}_{\!\!_S} \phi\, \mbox{\boldmath$\cdot e$}_{i}\,\mbox{ d}S\ = - \int\!\!\!\int_{S} \phi (\mbox{\boldmath$e$}_{i} \mbox{\boldmath$\cdot n$}) \kappa\,\mbox{ d}S + \int_{B} \phi\, \mbox{\boldmath$e$}_{i} \mbox{\boldmath$\cdot m$}\,\mbox{d} l, \]" src="form_40.png" width="299" height="30"/>
</p>
<p> which is equivalent to the surface divergence theorem for a scalar field described by Wetherburn (1955; p 240, Eqn 26) </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int\!\!\!\int_{S} \kappa \phi \mbox{\boldmath$n$}\mbox{ d}S = \int_{B} \phi \mbox{\boldmath$m$} \mbox{ d} l - \int\!\!\!\int_{S}\mbox{\boldmath$\nabla$}_{\!\!_{S}}\, \phi\mbox{ d}S. \quad \quad (2) \]" src="form_41.png" width="264" height="30"/>
</p>
<hr  />
<h2><a class="anchor" id="boundary_conditions"></a>
Free Surface and Interface Boundary Conditions</h2>
<h3><a class="anchor" id="dyn_con"></a>
Dynamic condition</h3>
<div class="image">
<img src="free_surface_sketch.gif" alt=""/>
<div class="caption">
Sketch of the interface between two fluids. </div></div>
 <p>The presence of an interface with non-constant surface tension <img class="formulaInl" alt="$ \sigma^{*} $" src="form_42.png" width="13" height="10"/> contributes to the overall force balance, as also described in <a href="../../single_layer_free_surface/html/index.html">another tutorial </a>. The surface tension acts a line force bounding the interface and acting in the direction <img class="formulaInl" alt="$ \mbox{\boldmath$m$}$" src="form_28.png" width="14" height="6"/>. Thus using the surface divergence theorem in the form (2), </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{B} \sigma^{*} \mbox{\boldmath$m$} \mbox{ d} l = \int\!\!\!\int_{S} \sigma^{*} \kappa + \mbox{\boldmath$\nabla$}_{\!\!_{S}}\, \sigma^{*} \mbox{ d}S, \]" src="form_43.png" width="189" height="30"/>
</p>
<p> which gives the terms to be included in the force balance.</p>
<p>If we define the lower fluid in the sketch above to be fluid 1 and the upper fluid to be fluid 2. The traction exerted by fluid 1 onto fluid 2, <img class="formulaInl" alt="$ \mathbf{t}^{[1]*} $" src="form_44.png" width="23" height="13"/> and that exerted by fluid 2 onto fluid 1, <img class="formulaInl" alt="$ \mathbf{t}^{[2]*} $" src="form_45.png" width="23" height="13"/>. Then, balance of forces requires that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{t}^{[1]*} - \mathbf{t}^{[2]*} \equiv \left[\left[ \mbox{\boldmath$\tau$}^{*} \mbox{\boldmath$\cdot n$}^{[1]} \right]\right] = \sigma^{*} \, \kappa^{*} \, \mbox{\boldmath$n$}^{[1]} + \mbox{\boldmath$\nabla$}_{\!\!_{S}}\, \sigma^{*} \]" src="form_46.png" width="250" height="24"/>
</p>
<p> where we have been explicit about the fact that the curvature is dimensional and <img class="formulaInl" alt="$ \kappa^{*} &gt; 0 $" src="form_47.png" width="35" height="11"/> if the centre of curvature lies inside fluid 1.</p>
<p>After using the non-dimensionalisation described in <a href="../../single_layer_free_surface/html/index.html">another tutorial, </a> the boundary condition becomes </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\left[\left[ \mbox{\boldmath$\tau$} \mbox{\boldmath$\cdot n$}^{[1]} \right]\right] = \frac{1}{Ca} \left[\sigma \, \kappa \, \mbox{\boldmath$n$} + \mbox{\boldmath$\nabla$}_{\!\!_{S}}\, \sigma \right] \]" src="form_48.png" width="165" height="26"/>
</p>
<p> where <img class="formulaInl" alt="$ \sigma = \sigma^{*} / \sigma_{ref} $" src="form_49.png" width="66" height="14"/> and <img class="formulaInl" alt="$ Ca = \mu_{ref}\, \mathcal{U} / \sigma_{ref},$" src="form_50.png" width="100" height="14"/> is the capillary number based on a reference viscosity and surface tension. This condition can be incorporated directly into the weak form of the momentum equations because the surface integral term in these equations, as described in <a href="../../rayleigh_traction_channel/html/index.html#traction_theory">another tutorial </a>, is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int\!\!\!\int_{S} \mbox{\boldmath$n\cdot \tau\cdot \psi$}^{(F)}\,\mbox{ d}S, \]" src="form_51.png" width="111" height="30"/>
</p>
<p> where <img class="formulaInl" alt="$ \mbox{\boldmath$\psi$}^{(F)}$" src="form_52.png" width="26" height="15"/> are the vector test functions associated with the momentum equations. Note that it is more compact to work with vector test functions rather than the Cartesian components of a vector test function in this case. The terms in the integral are exactly those on the left-hand side of the boundary condition multiplied by the test function. Hence, they become </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int\!\!\!\int_{S} \frac{1}{Ca} \left[\sigma \, \kappa \, \mbox{\boldmath$n$} + \mbox{\boldmath$\nabla$}_{\!\!_{S}}\, \sigma \right]\mbox{\boldmath$\cdot\psi$}^{(F)}\, \mbox{ d}S. \]" src="form_53.png" width="176" height="30"/>
</p>
<p>Early contributors computed these terms directly, but an undesirable feature is that computation of the curvature requires taking second derivatives of the position vector, which requires a higher degree of smoothness than previously demanded. We can use the surface divergence theorem again to weaken this requirement. Firstly we must use the product rule to bring the test function into the surface divergence </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int\!\!\!\int_{S} \frac{1}{Ca} \left[\sigma \mbox{\boldmath$\psi$}^{(F)} \mbox{\boldmath$\cdot$}\, \kappa \, \mbox{\boldmath$n$} + \mbox{\boldmath$\nabla$}_{\!\!_{S}}\, \mbox{\boldmath$\cdot$}\left(\sigma \mbox{\boldmath$\psi$}^{(F)} \right) - \sigma\, \mbox{\boldmath$\nabla$}_{\!\!_{S}}\,\mbox{\boldmath$\cdot\psi$}^{(F)} \right]\, \mbox{ d}S; \]" src="form_54.png" width="301" height="30"/>
</p>
<p> and then we can use the surface divergence theorem (1) on the first two terms to obtain </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{B} \frac{1}{Ca} \sigma \mbox{\boldmath$\psi$}^{(F)} \mbox{\boldmath$\cdot m$}\,\mbox{ d}l - \int\!\!\!\int_{S} \frac{1}{Ca} \sigma \mbox{\boldmath$\nabla$}_{\!\!_{S}}\, \mbox{\boldmath$\cdot\psi$}^{(F)} \, \mbox{ d}S. \]" src="form_55.png" width="241" height="30"/>
</p>
<p>In index notation these terms become </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{B} \frac{1}{Ca} \sigma \psi_{i}^{(F)} m_{i}\,\mbox{ d}l - \int\!\!\!\int_{S} \frac{1}{Ca} \sigma g^{\alpha\beta} \Big[\mbox{\boldmath$g$}_{\alpha}\Big]_{i} \left[\mbox{\boldmath$\psi$}^{(F)}_{,\beta}\right]_{i} \, \mbox{ d}S, \]" src="form_56.png" width="289" height="30"/>
</p>
<p> where <img class="formulaInl" alt="$ [\mbox{\boldmath$g$}_{\alpha}]_{i} $" src="form_57.png" width="25" height="14"/> denotes the <img class="formulaInl" alt="$ i\!$" src="form_39.png" width="5" height="9"/>-th component of the covariant base vector <img class="formulaInl" alt="$ \mbox{\boldmath$g$}_{\alpha} $" src="form_58.png" width="15" height="10"/> and <img class="formulaInl" alt="$ \sigma_{,\beta}$" src="form_59.png" width="16" height="10"/> represents the derivative <img class="formulaInl" alt="$ \partial \sigma / \partial \zeta^{\beta} \quad (3) $" src="form_60.png" width="69" height="15"/>. These are the terms that are implemented in <code>oomph-lib's</code> free surface elements. Note that variations in surface tension are taken into account in this formulation without the explicit need to take its surface derivative. An important observation is that the intrinsic surface coordinates can be chosen to be the local coordinates of each element so that we do not need to introduce another set of coordinates.</p>
<h3><a class="anchor" id="kin_con"></a>
Kinematic condition</h3>
<p>The kinematic condition is that "particles on the surface must
 remain on the surface". In other words the normal velocity of the surface must equal the normal rate of change of its position with time. The condition is compactly expressed in non-dimensional form as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left(\mbox{\boldmath$U$} - St \frac{\partial \mathbf{R}}{\partial t}\right) \mbox{\boldmath$\cdot n$} = 0, \]" src="form_61.png" width="118" height="31"/>
</p>
<p> where <img class="formulaInl" alt="$ St$" src="form_62.png" width="13" height="10"/> is the Strouhal number, see <a href="../../single_layer_free_surface/html/index.html">another tutorial </a> for details. Note that, in general <img class="formulaInl" alt="$ \mbox{\boldmath$U$}$" src="form_63.png" width="11" height="10"/> the velocity of the surface need <em> not </em> coincide with the velocity of the fluid.</p>
<p>Although this equation must be satisfied the details of how exactly it is implemented depend crucially on the mesh-update strategy chosen and we make use of the C++ features of inheritance and templating to avoid code duplication, see below for details.</p>
<hr  />
<h2><a class="anchor" id="surface_transport"></a>
Surface Transport Equations</h2>
<p>Consider a chemical species with surface concentration <img class="formulaInl" alt="$ \Gamma$" src="form_64.png" width="9" height="9"/> that is only present on the surface. It can be transported within the moving surface by the standard mechanisms of advection and diffusion, but changes in the surface area can also induce changes in its concentration. The formulation of surface transport equations has been discussed many times in the literature and the main confusion surrounds how material derivatives are taken. Unlike the conventional bulk equations the surface does not occupy every point in the domain, so one cannot simply use the standard form of the material derivative.</p>
<p>Rather than covering the literature, here we shall simply state, <em> ab initio </em>, the governing equations formulated by Huang, Lai &amp; Tseng as well as Cermelli et al (2005), who claim it was established by Slattery (1972). We shall demonstrate that it is equivalent to the form stated by Wong &amp; Rumshitski and used by Campana et al (2004), but that it leads to a simpler formulation which avoids explicit calculation of the curvature (and hence second derivatives).</p>
<p>The dimensionless governing equations in weak form governing the transport of a scalar quantity <img class="formulaInl" alt="$ \Gamma $" src="form_65.png" width="9" height="9"/> are </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int\!\!\!\int_{S} \left[ St \left(\frac{\partial \Gamma}{\partial t} - \dot{\mbox{\boldmath$R$}} \mbox{\boldmath$\cdot$} \mbox{\boldmath$\nabla$}_{\!\!_{S}} \Gamma \right) + \mbox{\boldmath$\nabla$}_{\!\!_{S}} \mbox{\boldmath$\cdot$} \left(\Gamma \mbox{\boldmath$U$}\right) - \frac{1}{Pe_{s}} \mbox{\boldmath$\nabla$}_{\!\!_{S}}\mbox{\boldmath$\cdot$} \mbox{\boldmath$\nabla$}_{\!\!_{S}} \Gamma \right]\, \phi\, \mbox{d}S = 0. \]" src="form_66.png" width="344" height="31"/>
</p>
<p> In the above equation the time derivative is taken at fixed `&lsquo;nodes&rsquo;' in the finite element formulation and the ALE-like term compensates for tangential movement of these nodes along the surface. The normal movement is enforced to be exactly the same as the surface velocity by the kinematic condition. Note that the velocity in the third term of the governing equation is the full (bulk) fluid velocity. The dimensionless quantity <img class="formulaInl" alt="$ Pe_s = \mathcal{U}\mathcal{L} / D_{s} $" src="form_67.png" width="76" height="14"/> is the surface Peclet number.</p>
<p>The formulation of Campana et al is found by decomposing the velocity in this term into normal and tangential components. </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{\boldmath$\nabla$}_{S} \mbox{\boldmath$\cdot$} \left(\Gamma \mbox{\boldmath$U$}\right) = \mbox{\boldmath$\nabla$}_{\!\!_{S}} \mbox{\boldmath$\cdot$} \left(\Gamma \mbox{\boldmath$U$}_{t} + \Gamma U_{n} \mbox{\boldmath$n$} \right). \]" src="form_68.png" width="178" height="14"/>
</p>
<p> The surface gradient yields a vector that is tangential to the surface so that its inner product with the unit normal, <img class="formulaInl" alt="$ \mbox{\boldmath$n$}$" src="form_69.png" width="10" height="6"/> is zero. Thus, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{\boldmath$\nabla$}_{\!\!_{S}} \mbox{\boldmath$\cdot$} \left(\Gamma \mbox{\boldmath$U$}\right) = \mbox{\boldmath$\nabla$}_{\!\!_{S}} \mbox{\boldmath$\cdot$} \left(\Gamma \mbox{\boldmath$U$}_{t}\right) + \Gamma U_{n} \mbox{\boldmath$\nabla$}_{\!\!_{S}} \mbox{\boldmath$\cdot n$}, \]" src="form_70.png" width="191" height="14"/>
</p>
<p> which is the starting point for Campana <em> et al</em>'s derivation because the surface divergence of the normal may be replaced by the curvature, as described above.</p>
<p>Returning to our formulation we use the surface divergence theorem (1) to integrate the diffusion term and the product rule to handle the third term: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int\!\!\!\int_{S} \left[ St \left(\frac{\partial \Gamma}{\partial t} - \dot{\mbox{\boldmath$R$}} \mbox{\boldmath$\cdot$} \mbox{\boldmath$\nabla$}_{\!\!_{S}} \Gamma \right) + \Gamma \mbox{\boldmath$\nabla$}_{\!\!_{S}} \mbox{\boldmath$\cdot$} \mbox{\boldmath$U$} + \mbox{\boldmath$U$} \mbox{\boldmath$\cdot$} \mbox{\boldmath$\nabla$}_{\!\!_{S}} \Gamma \right] \phi + \frac{1}{Pe_{s}} \mbox{\boldmath$\nabla$}_{\!\!_{S}} \Gamma \mbox{\boldmath$\cdot$} \mbox{\boldmath$\nabla$}_{\!\!_{S}} \phi\, \mbox{d}S - \int_{B} \frac{1}{Pe_{s}} \mbox{\boldmath$\nabla$}_{\!\!_{S}} \Gamma \mbox{\boldmath$\cdot m$}\, \phi \,\mbox{ d} l = 0,\]" src="form_71.png" width="504" height="31"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Rightarrow \quad \int\!\!\!\int_{S} \left[ St\, \frac{\partial \Gamma}{\partial t} + (\mbox{\boldmath$U$} - St\, \dot{\mbox{\boldmath$R$}}) \mbox{\boldmath$\cdot$} \mbox{\boldmath$\nabla$}_{\!\!_{S}} \Gamma + \Gamma \mbox{\boldmath$\nabla$}_{\!\!_{S}} \mbox{\boldmath$\cdot$} \mbox{\boldmath$U$} \right] \phi + \frac{1}{Pe_{s}} \mbox{\boldmath$\nabla$}_{\!\!_{S}} \Gamma \mbox{\boldmath$\cdot$} \mbox{\boldmath$\nabla$}_{\!\!_{S}} \phi\, \mbox{d}S - \int_{B} \frac{1}{Pe_{s}} \mbox{\boldmath$\nabla$}_{\!\!_{S}} \Gamma \mbox{\boldmath$\cdot m$}\, \phi \,\mbox{ d} l = 0,\]" src="form_72.png" width="511" height="31"/>
</p>
<p> The line term represents no-diffusive flux out of the system. In index notation the equations are </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int\!\!\!\int_{S} \left[ St\, \frac{\partial \Gamma}{\partial t} + g^{\alpha\beta} [\mbox{\boldmath$g$}_{\alpha}]_{i}\left\{ (U_{i} - St\, \dot{R}_{i}) \Gamma_{,\beta} + \Gamma \left[\mbox{\boldmath$U$}_{,\beta}\right]_{i}\right\} \right] \phi + \frac{1}{Pe_{s}} g^{\alpha\beta} \Gamma_{,\alpha} \phi_{,\beta}\, \mbox{d}S - \int_{B} \frac{1}{Pe_{s}} g^{\alpha\beta} [\mbox{\boldmath$g$}_{\alpha}]_{i} m_{i} \Gamma_{,\beta}\, \phi \,\mbox{ d} l = 0,\]" src="form_73.png" width="586" height="31"/>
</p>
<p>These are the equations implemented in <code>oomph-lib</code> using the definitions of surface derivatives given in <a class="el" href="index.html#surface_gradient">Differential Operators On A Surface</a>.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="fs_implementation"></a>
Implementation</h1>
<p>We will now discuss how the discrete versions of the equations derived above are actually implemented in <code>oomph-lib</code>. The basic idea is that the equations should be implemented independently of the specific element type and mesh-update strategy and a base class <a class="el" href="classoomph_1_1FluidInterfaceElement.html" title="Base class establishing common interfaces and functions for all Navier-Stokes-like fluid interface el...">oomph::FluidInterfaceElement</a> defines the generic functionality for all fluid interface elements. The only difference between the different surface geometries are in the definitions of the surface derivative operators and these are defined in specific classes <a class="el" href="classoomph_1_1LineDerivatives.html" title="Class that establishes the surface derivative functions for LineElements. These are defined in a sepa...">oomph::LineDerivatives</a> (1D surface), <a class="el" href="classoomph_1_1AxisymmetricDerivatives.html" title="Class that establishes the surface derivative functions for AxisymmetricInterfaceElements....">oomph::AxisymmetricDerivatives</a> and <a class="el" href="classoomph_1_1SurfaceDerivatives.html" title="Class that establishes the surface derivative functions for SurfaceInterfaceElements (2D surfaces in ...">oomph::SurfaceDerivatives</a> (2D surface). The final specific element is created by using a special templated class that determines the node-update strategy and takes the base class, derivative class and bulk element as template arguments.</p>
<hr  />
<h2><a class="anchor" id="fluid_interface"></a>
The FluidInterfaceElement class</h2>
<p>The template-free <a class="el" href="classoomph_1_1FluidInterfaceElement.html" title="Base class establishing common interfaces and functions for all Navier-Stokes-like fluid interface el...">oomph::FluidInterfaceElement</a> class provides storage and member functions that are common to all free-surface and interface elements. The most important functions to be aware of are:</p><ul>
<li>Storage and access functions for (pointers to) the capillary and Strouhal numbers.</li>
<li>Storage for a (pointer to) an external pressure degree of freedom if the boundary is a free surface, rather than an interface.</li>
<li>The virtual function <div class="fragment"><div class="line"><span class="keywordtype">double</span> FluidInterfaceElement::compute_surface_derivatives(...)</div>
</div><!-- fragment --> specifies how the surface gradient operators are computed.</li>
<li>The function <div class="fragment"><div class="line"><span class="keywordtype">double</span> FluidInterfaceElement::sigma(<span class="keyword">const</span> Vector&lt;double&gt; &amp;s_local) </div>
</div><!-- fragment --> that returns the surface tension at the given local coordinate; default implementation returns 1.0.</li>
<li>The function <div class="fragment"><div class="line">FluidInterfaceElement::fill_in_generic_residual_contribution_interface(..)</div>
</div><!-- fragment --> that is responsible for assembling the residual and jacobian contributions corresponding to the dynamic and kinematic boundary conditions.</li>
<li>The function <div class="fragment"><div class="line">FluidInterfaceElement::add_additional_residual_contributions_interface(...)</div>
</div><!-- fragment --> which is called from <em> within </em> the integration loop and is used to assemble any additional surface transport equations or equations arising from different node update strategies. This function is virtual so that it can be overloaded in derived classes.</li>
<li>The function <div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">int</span> FluidInterfaceElement::kinematic_local_eqn(...)</div>
</div><!-- fragment --> that is used to specify the local equation number used for the kinematic condition, which depends on the mesh-update strategy chosen.</li>
</ul>
<h2><a class="anchor" id="line"></a>
The LineDerivatives class</h2>
<p>The class <a class="el" href="classoomph_1_1LineDerivatives.html" title="Class that establishes the surface derivative functions for LineElements. These are defined in a sepa...">oomph::LineDerivatives</a> implements the specific surface derivatives associated with a one-dimensional surface in a two-dimensional domain.The global coordinate system is Cartesian so its base vectors do not vary with the surface coordinates and <img class="formulaInl" alt="$ [\mbox{\boldmath$\psi$}_{,\beta}^{(F)}]_{i} = \psi^{(F)}_{i,\beta}$" src="form_74.png" width="78" height="20"/>; and the contribution to each component of the momentum equation is found by setting the appropriate component <img class="formulaInl" alt="$ \psi^{(F)}_{i} = 0$" src="form_75.png" width="49" height="19"/> for <img class="formulaInl" alt="$ i = 1,2 $" src="form_76.png" width="40" height="11"/>.</p>
<h2><a class="anchor" id="axi"></a>
The AxisymmetricDerivatives class</h2>
<p>The class <a class="el" href="classoomph_1_1AxisymmetricDerivatives.html" title="Class that establishes the surface derivative functions for AxisymmetricInterfaceElements....">oomph::AxisymmetricDerivatives</a> implements the specific residuals associated with a two-dimensional surface in a three-dimensional domain, under the assumption of axisymmetry. Thus, the coordinate system is cylindrical polar <img class="formulaInl" alt="$(r,z,\theta)$" src="form_77.png" width="38" height="14"/>, but it is assumed that there are no variations in the <img class="formulaInl" alt="$ \theta $" src="form_78.png" width="6" height="10"/> direction.</p>
<p>It is worthwhile including the required mathematics here because the terms are not the same as in the <code>LineDerivatives</code> class. Specifically, if the surface coordinates are <img class="formulaInl" alt="$ (\zeta^{1}, \zeta^{2}) = (s,\theta)$" src="form_79.png" width="83" height="15"/>, the position vector to the surface is given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{\boldmath$R$} = \left(\begin{array}{c} r(s)\cos\theta \\ r(s)\sin\theta \\ z(s) \end{array}\right) \quad\Rightarrow\quad \mbox{\boldmath$g$}_{1} = \left(\begin{array}{c} r'(s)\cos\theta \\ r'(s)\sin\theta \\ z'(s) \end{array}\right), \quad \mbox{\boldmath$g$}_{2} = \left(\begin{array}{c} -r(s)\sin\theta \\ r(s)\cos\theta \\ 0 \end{array}\right), \]" src="form_80.png" width="416" height="46"/>
</p>
<p> where <img class="formulaInl" alt="$ r'(s) = \partial r / \partial s$" src="form_81.png" width="75" height="14"/> and <img class="formulaInl" alt="$ z'(s) = \partial z / \partial s$" src="form_82.png" width="75" height="14"/>. Hence, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ g_{11} = (r')^{2} + (z')^{2}, \quad g_{12} = g_{21} = 0, \quad g_{22} = r^{2}, \quad\mbox{and}\quad g = r^{2} \left[(r')^{2} + (z')^{2}\right].\]" src="form_83.png" width="420" height="18"/>
</p>
<p> In our standard formulation, the vector test function is given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{\boldmath$\psi$}^{(F)} = \left(\begin{array}{c} \psi_{r}^{(F)}(s) \cos\theta \\ \psi_{r}^{(F)}(s) \sin\theta \\ \psi_{z}^{(F)}(s) \end{array} \right) \quad\Rightarrow\quad \mbox{\boldmath$\psi$}^{(F)}_{,1} = \left(\begin{array}{c} (\psi')_{r}^{(F)}(s) \cos\theta \\ (\psi')_{r}^{(F)}(s) \sin\theta \\ (\psi')_{z}^{(F)}(s) \end{array} \right) \quad\mbox{and}\quad \mbox{\boldmath$\psi$}^{(F)}_{,2} = \left(\begin{array}{c} -\psi_{r}^{(F)}(s) \sin\theta \\ \psi_{r}^{(F)}(s) \cos\theta \\ 0 \end{array} \right).\]" src="form_84.png" width="550" height="54"/>
</p>
<p>Thus the contribution to the momentum equation (3) are </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{B} \frac{1}{Ca} \sigma \psi_{i}^{(F)} m_{i}\,\mbox{ d}l - \int\!\!\!\int_{S} \frac{1}{Ca} \sigma \left[\frac{r' (\psi')_{r}^{(F)} + z' (\psi')_{z}^{(F)}}{(r')^{2} + (z')^2} + \frac{1}{r} \psi_{r}^{(F)}\right]\, \mbox{ d}S, \]" src="form_85.png" width="374" height="39"/>
</p>
<p> Two separate contributions are then derived from the cases <img class="formulaInl" alt="$ \psi_{r}^{(F)} = 0 $" src="form_86.png" width="49" height="18"/> and <img class="formulaInl" alt="$ \psi_{z}^{(F)} = 0$" src="form_87.png" width="49" height="18"/>. The difference from the <code>LineDerivatives</code> is the final term that accounts for the azimuthal curvature. In addition, we must also multiply all terms by the additional factor of <img class="formulaInl" alt="$ r$" src="form_88.png" width="8" height="6"/> in the square-root of the determinant of the surface metric tensor.</p>
<h2><a class="anchor" id="surface"></a>
The SurfaceDerivatives class</h2>
<p>The class <a class="el" href="classoomph_1_1SurfaceDerivatives.html" title="Class that establishes the surface derivative functions for SurfaceInterfaceElements (2D surfaces in ...">oomph::SurfaceDerivatives</a> implements the specific residuals associated with a general two-dimensional surface in a three-dimensional domain. Once again, the global coordinate is Cartesian, so the contribution to each momentum equation is found by setting the two other components of the test function to be zero.</p>
<hr  />
<h1><a class="anchor" id="spine_formulation"></a>
The SpineLine/Axi/SurfaceFluidInterfaceElement classes</h1>
<p>We shall discuss the "line" version of the elements, but the others are essentially the same.</p>
<p>The class <a class="el" href="classoomph_1_1SpineLineFluidInterfaceElement.html">oomph::SpineLineFluidInterfaceElement</a> is templated by the bulk element type, <code>ELEMENT</code>, and inherits from <code>FluidInterfaceElement</code>, LineDerivatives and <code>Hijacked&lt;SpineElement&lt;FaceGeometry&lt;ELEMENT&gt;</code> &gt; &gt;. The hijacking is only required for imposition of contact angle boundary conditions, see <a href="../../static_single_layer/html/index.html">another tutorial </a> for more details.</p>
<p>Note that the use of templates to make the code generic makes it hard to read. A simplified constructor is given below and simply builds the element based on the <code>FaceGeometry</code> of the bulk element and sets the indices associated with the bulk fluid velocity components from the bulk element.</p>
 <div class="fragment"><div class="line">    SpineLineFluidInterfaceElement(FiniteElement* <span class="keyword">const</span>&amp; element_pt,</div>
</div><!-- fragment --><p>If a spine method is used to update the nodal positions then the spine height is the unknown associated with the kinematic condition. Thus, the function <code>kinematic_local_eqn(...)</code> is overloaded accordingly  </p><div class="fragment"><div class="line">    <span class="keywordtype">int</span> kinematic_local_eqn(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; n)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">return</span> this-&gt;spine_local_eqn(n);</div>
</div><!-- fragment --><p> Finally, the element calculates the geometric contributions to the jacobian using the generic functionality in <code>ElementWithMovingNodes</code> </p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> fill_in_contribution_to_jacobian(Vector&lt;double&gt;&amp; residuals,</div>
</div><!-- fragment --><p> There are no additional contributions to the residuals or jacobian.</p>
<hr  />
<h1><a class="anchor" id="elastic_formulation"></a>
The ElasticLine/Axi/SurfaceFluidInterfaceElement classes</h1>
<p>We shall discuss the "line" version of the elements, but the others are essentially the same.</p>
<p>The class <a class="el" href="classoomph_1_1ElasticLineFluidInterfaceElement.html" title="Specialise the elastic update template class to concrete 1D case.">oomph::ElasticLineFluidInterfaceElement</a> is templated by the bulk element type, <code>ELEMENT</code>, and inherits from <code>LineDerivatives</code>, FluidInterfaceElement and <code>Hijacked&lt;FaceGeometry&lt;ELEMENT&gt;</code> &gt;. The hijacking is again only required for imposition of contact angle boundary conditions.</p>
<p>The "elastic" versions of the elements are more complicated than the "spine" versions because the kinematic condition is imposed using Lagrange multipliers, following the method described by Cairncross et al A finite element method for free surface flows of incompressible fluids in three dimensions. Part I. Boundary fitted mesh motion' (2000). These Lagrange multipliers must be added to the <code>Nodes</code> on the free surface and their introduction adds additional terms to the equations governing the bulk mesh motion.</p>
<p>The constructor is given below and in addition to building the element based on the <code>FaceGeometry</code> of the bulk element and setting the indices associated with the bulk fluid velocity components from the bulk element, it also adds the additional storage required for the Lagrange multipliers</p>
 <div class="fragment"><div class="line">    ElasticLineFluidInterfaceElement(FiniteElement* <span class="keyword">const</span>&amp; element_pt,</div>
</div><!-- fragment --><p> The kinematic boundary condition is associated with the Lagrange multiplier and <code>kinematic_local_eqn(...)</code> is overloaded accordingly  </p><div class="fragment"><div class="line">    <span class="comment">/// (This is the equation for the Lagrange multiplier)</span></div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">int</span> kinematic_local_eqn(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; n)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Get the index of the nodal value associated with Lagrange multiplier</span></div>
<div class="line">      <span class="keywordflow">return</span> this-&gt;nodal_local_eqn(n, this-&gt;lagrange_index(n));</div>
<div class="line">    }</div>
</div><!-- fragment --><p> The element calculates the geometric contributions to the jacobian using the generic functionality in <code>SolidElements</code> </p><div class="fragment"><div class="line">    <span class="keywordtype">void</span> fill_in_contribution_to_jacobian(Vector&lt;double&gt;&amp; residuals,</div>
<div class="line">                                          DenseMatrix&lt;double&gt;&amp; jacobian)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Call the generic routine with the flag set to 1</span></div>
<div class="line">      EQUATION_CLASS::fill_in_generic_residual_contribution_interface(</div>
<div class="line">        residuals, jacobian, 1);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Call the generic finite difference routine for the solid variables</span></div>
<div class="line">      this-&gt;fill_in_jacobian_from_solid_position_by_fd(jacobian);</div>
<div class="line">    }</div>
</div><!-- fragment --><p> The additional contributions to the residuals and jacobian arise from the Lagrange multiplier contributions to the equations that determine the position of the nodes. The essential loop is the contribution below which adds the normal traction to the governing equations of solid mechanics: </p><div class="fragment"><div class="line">      <span class="comment">// Loop over the shape functions to assemble contributions</span></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l = 0; l &lt; n_node; l++)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Loop over the directions</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; nodal_dimension; i++)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// Now using the same shape functions for the elastic equations,</span></div>
<div class="line">          <span class="comment">// so we can stay in the loop</span></div>
<div class="line">          local_eqn = this-&gt;position_local_eqn(l, 0, i);</div>
<div class="line">          <span class="keywordflow">if</span> (local_eqn &gt;= 0)</div>
<div class="line">          {</div>
<div class="line">            <span class="comment">// Add in the Lagrange multiplier contribution</span></div>
<div class="line">            residuals[local_eqn] -=</div>
<div class="line">              interpolated_lagrange * interpolated_n[i] * psif(l) * J * W;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Do the Jacobian calculation</span></div>
<div class="line">            <span class="keywordflow">if</span> (flag)</div>
<div class="line">            {</div>
<div class="line">              <span class="comment">// Loop over the nodes</span></div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> l2 = 0; l2 &lt; n_node; l2++)</div>
<div class="line">              {</div>
<div class="line">                <span class="comment">// Dependence on solid positions will be handled by FDs</span></div>
<div class="line">                <span class="comment">// That leaves the Lagrange multiplier contribution</span></div>
<div class="line">                local_unknown = this-&gt;kinematic_local_eqn(l2);</div>
<div class="line">                <span class="keywordflow">if</span> (local_unknown &gt;= 0)</div>
<div class="line">                {</div>
<div class="line">                  jacobian(local_eqn, local_unknown) -=</div>
<div class="line">                    psif(l2) * interpolated_n[i] * psif(l) * J * W;</div>
<div class="line">                }</div>
<div class="line">              }</div>
<div class="line">            } <span class="comment">// End of Jacobian calculation</span></div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      } <span class="comment">// End of loop over shape functions</span></div>
</div><!-- fragment --> <h1><a class="anchor" id="surface"></a>
The SurfaceDerivatives class</h1>
<p>The recommended strategy for implementing surface transport equations is to inherit from the appropriate <code>FluidInterfaceElement</code>, and include the equations independently of the mesh-update strategy by overloading the function </p><div class="fragment"><div class="line">FluidInterfaceElement::add_additional_residual_contributions_interface(...)</div>
</div><!-- fragment --><p> The mesh-update specialisations can be added by further specialisation as required. Alternatively, one could simply inherit directly from the specialised element. This is the approach taken in this <a href="../../../multi_physics/rayleigh_instability_surfactant/html/index.html">example code. </a></p>
<p>An important point is that the axisymmetric formulation of the surface divergence of a vector is not entirely trivial, as discussed in <a class="el" href="index.html#axi">The AxisymmetricDerivatives class</a>. In the context of surface transport the term that is always present is <img class="formulaInl" alt="$ \mbox{\boldmath$\nabla$}_{\!\!_{S}}\mbox{\boldmath$\cdot$} \mbox{\boldmath$U$} $" src="form_89.png" width="30" height="14"/>. Using the same surface coordinates as above, <img class="formulaInl" alt="$ (\zeta^{1}, \zeta^{2}) = (s,\theta)$" src="form_79.png" width="83" height="15"/>, the velocity vector is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{\boldmath$U$} = \left(\begin{array}{c} U_r(s)\cos\theta \\ U_r(s)\sin\theta \\ U_z(s) \end{array}\right) \quad\Rightarrow\quad \mbox{\boldmath$U$}_{,1} = \left(\begin{array}{c} \frac{\partial U_{r}}{\partial s}\cos\theta \\ \frac{\partial U_{r}}{\partial s} \sin\theta \\ \frac{\partial U_z}{\partial s} \end{array}\right), \quad \mbox{\boldmath$U$}_{,2} = \left(\begin{array}{c} -U_r \sin\theta \\ U_r\cos\theta \\ 0 \end{array}\right). \]" src="form_90.png" width="426" height="49"/>
</p>
<p> Thus, the surface divergence term is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{\boldmath$\nabla$}_{\!\!_{S}} \mbox{\boldmath$\cdot$} \mbox{\boldmath$U$} = \frac{\left(\frac{\partial U_{r}}{\partial s} \frac{\partial r}{\partial s} + \frac{\partial U_{z}}{\partial s} \frac{\partial z}{\partial s}\right)}{(r')^{2} + (z')^{2}} + \frac{U_{r}}{r},\]" src="form_91.png" width="181" height="34"/>
</p>
<p> which is exactly the same form as the surface divergence of the vector test function derived in the section <a class="el" href="index.html#axi">The AxisymmetricDerivatives class</a>, as expected.</p>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:23:07
        </div>
      </div>
    </footer>
</body>
</html>
