<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Propagation of a bubble in a channel - mesh generation and adaptation for free surface problems</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Propagation of a bubble in a channel - mesh generation and adaptation for free surface problems </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this tutorial we demonstrate the adaptive solution of free surface problems on unstructured meshes, using the example of a bubble propagating along a straight channel. We also demonstrate how to impose volume constraints on enclosed regions within the fluid.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="example"></a>
The example problem</h1>
<p>We illustrate the solution of the unsteady 2D Navier-Stokes equations by considering the propagation of a single bubble along a straight channel as shown in the sketch below. We non-dimensionalise all lengths on the channel width, <img class="formulaInl" alt="$ \mathcal{L}=H $" src="form_0.png" width="38" height="10"/>, velocities on the maximum (prescribed) inflow velocity, <img class="formulaInl" alt="$ \mathcal{U} $" src="form_1.png" width="10" height="11"/>, and time on the intrinsic timescale, <img class="formulaInl" alt="$ \mathcal{T}=\mathcal{L}/\mathcal{U} $" src="form_2.png" width="51" height="14"/> , which corresponds to a Strouhal number <img class="formulaInl" alt="$ St=1.0 $" src="form_3.png" width="45" height="10"/> .</p>
<div class="image">
<img src="problem.gif" alt=""/>
<div class="caption">
The problem setup. </div></div>
 <p>The problem is then governed by the following equations.</p>
<p>Solve</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Re\Big(St\frac{\partial u_i}{\partial t}+u_j\frac{\partial u_i}{\partial x_j} \Big) = - \frac{\partial p}{\partial x_i} + \frac{\partial }{\partial x_j} \left( \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right), \ \ \ \ \ \ \ \ \ \ (1) \]" src="form_4.png" width="346" height="31"/>
</p>
<p>and</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial u_i}{\partial x_i} = 0, \]" src="form_5.png" width="48" height="29"/>
</p>
<p>in the rectangular domain <img class="formulaInl" alt="$ D = \left\{x_1 \in [0,1]; x_2 \in [0,L] \right\} $" src="form_6.png" width="153" height="14"/> , subject to the Dirichlet boundary conditions</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_1=0, \ \ \ \ \ \ \ \ \ \ (2) \]" src="form_7.png" width="99" height="14"/>
</p>
<p>on the top and bottom boundaries and</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_2=0, \ \ \ \ \ \ \ \ \ \ (3) \]" src="form_8.png" width="99" height="14"/>
</p>
<p>on all boundaries. The inflow on the left boundary is described by a Poiseuille flow profile</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_1(x_2)=4 x_2 (1-x_2). \ \ \ \ \ \ \ \ \ \ (4) \]" src="form_9.png" width="175" height="14"/>
</p>
<p>The free surface is defined by the position vector <img class="formulaInl" alt="$ \mathbf{R} $" src="form_10.png" width="13" height="10"/>, which is subject to the kinematic condition</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Big(u_i-St \frac{\partial R_i}{\partial t} \Big) n_i =0, \ \ \ \ \ \ \ \ \ \ (5) \]" src="form_11.png" width="173" height="28"/>
</p>
<p>and the dynamic condition</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tau_{ij} n_j=- \Big( \frac{1}{Ca} \kappa+p_{bubble} \Big) n_i, \ \ \ \ \ \ \ \ \ \ (6) \]" src="form_12.png" width="218" height="26"/>
</p>
<p>where the stress tensor is defined as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tau_{ij}=-p \delta_{ij}+\Big( \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \Big). \ \ \ \ \ \ \ \ \ \ (7) \]" src="form_13.png" width="213" height="31"/>
</p>
<p>The initial position of the interface, for a bubble initially located in the centre of the channel, is given by</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{R}(\zeta)=\Big( \frac{L}{2}+ a \frac{1-\zeta^2}{1+\zeta^2}, \frac{1}{2} + a \frac{2\zeta}{1+\zeta^2} \Big), \ \ \ \ \ \ \ \ \ \ (8) \]" src="form_14.png" width="264" height="31"/>
</p>
<p>where <img class="formulaInl" alt="$ a $" src="form_15.png" width="6" height="6"/> is the initial non-dimensional bubble radius and <img class="formulaInl" alt="$ \zeta=[0,2\pi] $" src="form_16.png" width="54" height="14"/>.</p>
<hr  />
<p>The problem is subject to the constraint that the bubble volume, <img class="formulaInl" alt="$ V_{bubble} $" src="form_17.png" width="34" height="13"/>, remains constant which is achieved by adjusting, the bubble pressure, <img class="formulaInl" alt="$ p_{bubble} $" src="form_18.png" width="34" height="9"/> . We formulate the volume constraint by making use of Gauss` theorem, which states that for any vector <img class="formulaInl" alt="$ \mathbf{b} $" src="form_19.png" width="9" height="10"/></p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int \nabla . \mathbf{b} dV = \oint \mathbf{b}. \mathbf{n} dS. \ \ \ \ \ \ \ \ \ \ (9) \]" src="form_20.png" width="178" height="29"/>
</p>
<p>Choosing <img class="formulaInl" alt="$ \mathbf{b}=\mathbf{x} $" src="form_21.png" width="34" height="10"/> we note that the divergence of <img class="formulaInl" alt="$\mathbf{x}$" src="form_22.png" width="9" height="6"/> gives the spatial dimension <img class="formulaInl" alt="$ D $" src="form_23.png" width="10" height="10"/> and the integral <img class="formulaInl" alt="$\int dV$" src="form_24.png" width="26" height="15"/> is the enclosed volume <img class="formulaInl" alt="$V_{bubble}$" src="form_25.png" width="34" height="13"/>. Hence, the volume constraint can be written as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ V_{bubble}-\frac{1}{D} \oint \mathbf{R}.\mathbf{n} dS=0. \ \ \ \ \ \ \ \ \ \ (10) \]" src="form_26.png" width="206" height="29"/>
</p>
<p>This is the equation that determines the unknown bubble pressure <img class="formulaInl" alt="$ p_{bubble} $" src="form_18.png" width="34" height="9"/> .</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="implementation"></a>
Implementation</h1>
<p>We solve the governing equations using an ALE-based finite-element method, discretising the fluid domain with triangular Taylor-Hood elements, and updating the mesh with <a href="../../single_layer_free_surface/html/index.html#kinematic_condition_implementation">a pseudo-elastic node-update procedure</a>. <br  />
 As usual, we impose the kinematic and dynamic boundary conditions with <code>FaceElements</code>. The volume constraint is imposed in a similar way: We attach <code>LineVolumeConstraintBoundingSolidElements</code> to the bubble surface to compute the line integrals in equation (10), and create an additional <code>VolumeConstraintElement</code> which adds <img class="formulaInl" alt="$ V_{bubble} $" src="form_17.png" width="34" height="13"/> to this equation and is also "in
charge" of the unknown bubble pressure.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="results"></a>
Results</h1>
<p>We perform the simulation in a two-stage procedure. We start by performing a steady solve with the inflow switched off. This deforms the bubble into its steady state (approximately) circular configuration with the required volume. The actual time-dependent simulation is then performed with an impulsive start from this configuration.</p>
<p>The figure below shows a contour plot of the pressure distribution with overlaid streamlines. This is a snapshot of <a href="../figures/bubble.avi">an animation of the flow field</a>, for the parameters <img class="formulaInl" alt="$ Re=ReSt=0.0 $" src="form_27.png" width="93" height="10"/> and <img class="formulaInl" alt="$ Ca=0.05 $" src="form_28.png" width="55" height="10"/> .</p>
<div class="image">
<img src="tutorial.gif" alt=""/>
<div class="caption">
Snapshot of the flow field (streamlines and pressure contours) for a propagating bubble. </div></div>
 <hr  />
 <hr  />
<h1><a class="anchor" id="parameters"></a>
Global parameters</h1>
<p>As usual, we create a namespace where we define the dimensionless parameters <img class="formulaInl" alt="$ Re $" src="form_29.png" width="15" height="10"/>, <img class="formulaInl" alt="$ Ca $" src="form_30.png" width="16" height="10"/> and the non-dimensional channel length <img class="formulaInl" alt="$ L $" src="form_31.png" width="9" height="10"/>. As discussed in <a href="../../driven_cavity/html/index.html#params">another tutorial</a>, the Strouhal number defaults to one, so that we do not have to set it in this case. We also store the initial bubble radius and the bubble volume, as well as a scaling factor for the inflow velocity (this allows us to "switch off" the inflow when computing the initial steady solution). Finally we define the Poisson ratio for the generalised Hookean constitutive law that is used by pseudo-elastic mesh update.</p>
 <div class="fragment"><div class="line"><span class="comment">//==start_of_namespace==============================</span></div>
<div class="line"><span class="comment">/// Namespace for Problem Parameter</span></div>
<div class="line"><span class="comment"></span><span class="comment">//==================================================</span></div>
<div class="line"> <span class="keyword">namespace </span><a class="code" href="namespaceProblem__Parameter.html">Problem_Parameter</a></div>
<div class="line"> {    <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Doc info object</span></div>
<div class="line"><span class="comment"></span>  DocInfo <a class="code" href="namespaceProblem__Parameter.html#a1dd3c6bcf97360c8fe0d288ca7610351">Doc_info</a>;</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Reynolds number</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">double</span> <a class="code" href="namespaceProblem__Parameter.html#acc656299287d4d9a8374c2c501750b4f">Re</a>=0.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Capillary number</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">double</span> <a class="code" href="namespaceProblem__Parameter.html#af6194d2571881779c678fbabc1503d47">Ca</a> = 10.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Pseudo-solid Poisson ratio</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">double</span> <a class="code" href="namespaceProblem__Parameter.html#abec2e733c8f2d3c18ebc702b3f80cc17">Nu</a>=0.3;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Initial radius of bubble</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">double</span> <a class="code" href="namespaceProblem__Parameter.html#a903237528f0e9bb92debcc8842576cca">Radius</a> = 0.25;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Volume of the bubble (negative because it&#39;s outside the</span></div>
<div class="line"><span class="comment">  /// fluid!)</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">double</span> <a class="code" href="namespaceProblem__Parameter.html#aad8e0a2d1ec39a8dd7357a43bcc5f20e">Volume</a> = -MathematicalConstants::Pi*<a class="code" href="namespaceProblem__Parameter.html#a903237528f0e9bb92debcc8842576cca">Radius</a>*<a class="code" href="namespaceProblem__Parameter.html#a903237528f0e9bb92debcc8842576cca">Radius</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Scaling factor for inflow velocity (allows it to be switched off</span></div>
<div class="line"><span class="comment">  /// to do hydrostatics)</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">double</span> <a class="code" href="namespaceProblem__Parameter.html#a7792613e563a733ad88b8e15d126fc3a">Inflow_veloc_magnitude</a> = 0.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Length of the channel</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">double</span> <a class="code" href="namespaceProblem__Parameter.html#a7b67840fea463f29b53d12f7bd7cb34b">Length</a> = 3.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Constitutive law used to determine the mesh deformation</span></div>
<div class="line"><span class="comment"></span>  ConstitutiveLaw *<a class="code" href="namespaceProblem__Parameter.html#a810f05c8d3e3331aed75643557d1057c">Constitutive_law_pt</a>=0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Trace file</span></div>
<div class="line"><span class="comment"></span>  ofstream <a class="code" href="namespaceProblem__Parameter.html#a55310be5f2dfcb5fcfe35d71f9c16e06">Trace_file</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// File to document the norm of the solution (for validation </span></div>
<div class="line"><span class="comment">  /// purposes -- triangle doesn&#39;t give fully reproducible results so</span></div>
<div class="line"><span class="comment">  /// mesh generation/adaptation may generate slightly different numbers</span></div>
<div class="line"><span class="comment">  /// of elements on different machines!)</span></div>
<div class="line"><span class="comment"></span>  ofstream <a class="code" href="namespaceProblem__Parameter.html#a388e06a5e637b21378ab1832e5564bec">Norm_file</a>;</div>
<div class="line">  </div>
<div class="line"> } <span class="comment">// end_of_namespace</span></div>
<div class="ttc" id="anamespaceProblem__Parameter_html"><div class="ttname"><a href="namespaceProblem__Parameter.html">Problem_Parameter</a></div><div class="ttdoc">////////////////////////////////////////////////////////////// //////////////////////////////////////...</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00369">adaptive_bubble_in_channel.cc:370</a></div></div>
<div class="ttc" id="anamespaceProblem__Parameter_html_a1dd3c6bcf97360c8fe0d288ca7610351"><div class="ttname"><a href="namespaceProblem__Parameter.html#a1dd3c6bcf97360c8fe0d288ca7610351">Problem_Parameter::Doc_info</a></div><div class="ttdeci">DocInfo Doc_info</div><div class="ttdoc">Doc info object.</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00372">adaptive_bubble_in_channel.cc:372</a></div></div>
<div class="ttc" id="anamespaceProblem__Parameter_html_a388e06a5e637b21378ab1832e5564bec"><div class="ttname"><a href="namespaceProblem__Parameter.html#a388e06a5e637b21378ab1832e5564bec">Problem_Parameter::Norm_file</a></div><div class="ttdeci">ofstream Norm_file</div><div class="ttdoc">File to document the norm of the solution (for validation purposes – triangle doesn't give fully repr...</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00407">adaptive_bubble_in_channel.cc:407</a></div></div>
<div class="ttc" id="anamespaceProblem__Parameter_html_a55310be5f2dfcb5fcfe35d71f9c16e06"><div class="ttname"><a href="namespaceProblem__Parameter.html#a55310be5f2dfcb5fcfe35d71f9c16e06">Problem_Parameter::Trace_file</a></div><div class="ttdeci">ofstream Trace_file</div><div class="ttdoc">Trace file.</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00401">adaptive_bubble_in_channel.cc:401</a></div></div>
<div class="ttc" id="anamespaceProblem__Parameter_html_a7792613e563a733ad88b8e15d126fc3a"><div class="ttname"><a href="namespaceProblem__Parameter.html#a7792613e563a733ad88b8e15d126fc3a">Problem_Parameter::Inflow_veloc_magnitude</a></div><div class="ttdeci">double Inflow_veloc_magnitude</div><div class="ttdoc">Scaling factor for inflow velocity (allows it to be switched off to do hydrostatics)</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00392">adaptive_bubble_in_channel.cc:392</a></div></div>
<div class="ttc" id="anamespaceProblem__Parameter_html_a7b67840fea463f29b53d12f7bd7cb34b"><div class="ttname"><a href="namespaceProblem__Parameter.html#a7b67840fea463f29b53d12f7bd7cb34b">Problem_Parameter::Length</a></div><div class="ttdeci">double Length</div><div class="ttdoc">Length of the channel.</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00395">adaptive_bubble_in_channel.cc:395</a></div></div>
<div class="ttc" id="anamespaceProblem__Parameter_html_a810f05c8d3e3331aed75643557d1057c"><div class="ttname"><a href="namespaceProblem__Parameter.html#a810f05c8d3e3331aed75643557d1057c">Problem_Parameter::Constitutive_law_pt</a></div><div class="ttdeci">ConstitutiveLaw * Constitutive_law_pt</div><div class="ttdoc">Constitutive law used to determine the mesh deformation.</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00398">adaptive_bubble_in_channel.cc:398</a></div></div>
<div class="ttc" id="anamespaceProblem__Parameter_html_a903237528f0e9bb92debcc8842576cca"><div class="ttname"><a href="namespaceProblem__Parameter.html#a903237528f0e9bb92debcc8842576cca">Problem_Parameter::Radius</a></div><div class="ttdeci">double Radius</div><div class="ttdoc">Initial radius of bubble.</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00384">adaptive_bubble_in_channel.cc:384</a></div></div>
<div class="ttc" id="anamespaceProblem__Parameter_html_aad8e0a2d1ec39a8dd7357a43bcc5f20e"><div class="ttname"><a href="namespaceProblem__Parameter.html#aad8e0a2d1ec39a8dd7357a43bcc5f20e">Problem_Parameter::Volume</a></div><div class="ttdeci">double Volume</div><div class="ttdoc">Volume of the bubble (negative because it's outside the fluid!)</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00388">adaptive_bubble_in_channel.cc:388</a></div></div>
<div class="ttc" id="anamespaceProblem__Parameter_html_abec2e733c8f2d3c18ebc702b3f80cc17"><div class="ttname"><a href="namespaceProblem__Parameter.html#abec2e733c8f2d3c18ebc702b3f80cc17">Problem_Parameter::Nu</a></div><div class="ttdeci">double Nu</div><div class="ttdoc">Pseudo-solid Poisson ratio.</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00381">adaptive_bubble_in_channel.cc:381</a></div></div>
<div class="ttc" id="anamespaceProblem__Parameter_html_acc656299287d4d9a8374c2c501750b4f"><div class="ttname"><a href="namespaceProblem__Parameter.html#acc656299287d4d9a8374c2c501750b4f">Problem_Parameter::Re</a></div><div class="ttdeci">double Re</div><div class="ttdoc">Reynolds number.</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00375">adaptive_bubble_in_channel.cc:375</a></div></div>
<div class="ttc" id="anamespaceProblem__Parameter_html_af6194d2571881779c678fbabc1503d47"><div class="ttname"><a href="namespaceProblem__Parameter.html#af6194d2571881779c678fbabc1503d47">Problem_Parameter::Ca</a></div><div class="ttdeci">double Ca</div><div class="ttdoc">Capillary number.</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00378">adaptive_bubble_in_channel.cc:378</a></div></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="main"></a>
The driver code</h1>
<p>We start by processing the command line arguments and create the generalised Hookean constitutive equations for the pseudo-elastic node-update. We then open various output files and build the problem.</p>
<div class="fragment"><div class="line"><span class="comment">//==========start_of_main=====================================</span></div>
<div class="line"><span class="comment">/// Driver code for moving bubble problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//============================================================</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="adaptive__bubble__in__channel_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">  </div>
<div class="line"> <span class="comment">// Store command line arguments</span></div>
<div class="line"> CommandLineArgs::setup(argc,argv);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Define possible command line arguments and parse the ones that</span></div>
<div class="line"> <span class="comment">// were actually specified</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Validation?</span></div>
<div class="line"> CommandLineArgs::specify_command_line_flag(<span class="stringliteral">&quot;--validation&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Parse command line</span></div>
<div class="line"> CommandLineArgs::parse_and_assign(); </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Doc what has actually been specified on the command line</span></div>
<div class="line"> CommandLineArgs::doc_specified_flags();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create generalised Hookean constitutive equations</span></div>
<div class="line"> <a class="code" href="namespaceProblem__Parameter.html#a810f05c8d3e3331aed75643557d1057c">Problem_Parameter::Constitutive_law_pt</a> = </div>
<div class="line">  <span class="keyword">new</span> GeneralisedHookean(&amp;<a class="code" href="namespaceProblem__Parameter.html#abec2e733c8f2d3c18ebc702b3f80cc17">Problem_Parameter::Nu</a>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Open trace file</span></div>
<div class="line"> <a class="code" href="namespaceProblem__Parameter.html#a55310be5f2dfcb5fcfe35d71f9c16e06">Problem_Parameter::Trace_file</a>.open(<span class="stringliteral">&quot;RESLT/trace.dat&quot;</span>); </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Increase precision of output</span></div>
<div class="line"> <a class="code" href="namespaceProblem__Parameter.html#a55310be5f2dfcb5fcfe35d71f9c16e06">Problem_Parameter::Trace_file</a>.precision(20);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Open norm file</span></div>
<div class="line"> <a class="code" href="namespaceProblem__Parameter.html#a388e06a5e637b21378ab1832e5564bec">Problem_Parameter::Norm_file</a>.open(<span class="stringliteral">&quot;RESLT/norm.dat&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create problem in initial configuration</span></div>
<div class="line"> <a class="code" href="classBubbleInChannelProblem.html">BubbleInChannelProblem&lt;ProjectableTaylorHoodElement&lt;MyTaylorHoodElement&gt;</a> &gt; </div>
<div class="ttc" id="aadaptive__bubble__in__channel_8cc_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="adaptive__bubble__in__channel_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdoc">Driver code for moving bubble problem.</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l01272">adaptive_bubble_in_channel.cc:1272</a></div></div>
<div class="ttc" id="aclassBubbleInChannelProblem_html"><div class="ttname"><a href="classBubbleInChannelProblem.html">BubbleInChannelProblem</a></div><div class="ttdoc">//////////////////////////////////////////////////////// ////////////////////////////////////////////...</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00424">adaptive_bubble_in_channel.cc:425</a></div></div>
</div><!-- fragment --><p> We start by performing a steady solve (with the inflow switched off) to compute the initial configuration, a circular bubble in stationary fluid.</p>
<div class="fragment"><div class="line"> <span class="comment">// Before starting the time-integration we want to &quot;inflate&quot; it to form </span></div>
<div class="line"> <span class="comment">// a proper circular bubble. We do this by setting the inflow to zero</span></div>
<div class="line"> <span class="comment">// and doing a steady solve (with one adaptation)</span></div>
<div class="line"> <a class="code" href="namespaceProblem__Parameter.html#a7792613e563a733ad88b8e15d126fc3a">Problem_Parameter::Inflow_veloc_magnitude</a>=0.0;</div>
<div class="line"> </div>
<div class="line"> problem.steady_newton_solve(1);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// If all went well, this should show us a nice circular bubble</span></div>
<div class="line"> <span class="comment">// in a stationary fluid</span></div>
<div class="line"> problem.doc_solution();</div>
</div><!-- fragment --><p> Next, the timestepper is initialised and an impulsive start performed. The inflow is switched on and the first few unsteady Newton solves are performed without adaptation.</p>
<div class="fragment"><div class="line"> <span class="comment">// Initialise timestepper</span></div>
<div class="line"> <span class="keywordtype">double</span> dt=0.025;</div>
<div class="line"> problem.initialise_dt(dt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Perform impulsive start from current state</span></div>
<div class="line"> problem.assign_initial_values_impulsive();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Now switch on the inflow and re-assign the boundary conditions</span></div>
<div class="line"> <span class="comment">// (Call to complete_problem_setup() is a bit expensive given that we</span></div>
<div class="line"> <span class="comment">// we only want to set the inflow velocity but who cares -- it&#39;s just</span></div>
<div class="line"> <span class="comment">// a one off.</span></div>
<div class="line"> <a class="code" href="namespaceProblem__Parameter.html#a7792613e563a733ad88b8e15d126fc3a">Problem_Parameter::Inflow_veloc_magnitude</a>=1.0;</div>
<div class="line"> problem.complete_problem_setup();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Solve problem on fixed mesh</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nstep=6;</div>
<div class="line"> <span class="keywordflow">if</span> (CommandLineArgs::command_line_flag_has_been_set(<span class="stringliteral">&quot;--validation&quot;</span>))</div>
<div class="line">  {</div>
<div class="line">   nstep=2;</div>
<div class="line">   oomph_info &lt;&lt; <span class="stringliteral">&quot;Remeshing after every second step during validation\n&quot;</span>;</div>
<div class="line">  }</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;nstep;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Solve the problem</span></div>
<div class="line">   problem.unsteady_newton_solve(dt);    </div>
<div class="line">   problem.doc_solution();</div>
<div class="line">  } <span class="comment">// done solution on fixed mesh</span></div>
</div><!-- fragment --><p>To limit the distortion of the elements we allow then mesh adaptation (which involves the re-generation of the entire mesh) every few timesteps.</p>
<div class="fragment"><div class="line"> <span class="comment">// Now do a proper loop, doing nstep timesteps before adapting/remeshing</span></div>
<div class="line"> <span class="comment">// and repeating the lot ncycle times</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> ncycle=1000;</div>
<div class="line"> <span class="keywordflow">if</span> (CommandLineArgs::command_line_flag_has_been_set(<span class="stringliteral">&quot;--validation&quot;</span>))</div>
<div class="line">  {</div>
<div class="line">   ncycle=1;</div>
<div class="line">   oomph_info &lt;&lt; <span class="stringliteral">&quot;Only doing one cycle during validation\n&quot;</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Do the cycles</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;ncycle;j++)</div>
<div class="line">  {       </div>
<div class="line">   <span class="comment">// Allow up to one level of refinement for next solve</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> max_adapt=1;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Solve problem a few times</span></div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;nstep;i++)</div>
<div class="line">    {     </div>
<div class="line">     <span class="comment">// Solve the problem</span></div>
<div class="line">     problem.unsteady_newton_solve(dt,max_adapt,<span class="keyword">false</span>); </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Build the label for doc and output solution</span></div>
<div class="line">     std::stringstream label;</div>
<div class="line">     label &lt;&lt; <span class="stringliteral">&quot;Adaptation &quot;</span> &lt;&lt;j &lt;&lt; <span class="stringliteral">&quot; Step &quot;</span>&lt;&lt; i;</div>
<div class="line">     problem.doc_solution(label.str());</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// No more refinement for the next nstep steps</span></div>
<div class="line">     max_adapt=0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">} <span class="comment">//End of main</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="problem"></a>
The problem class</h1>
<p>As usual, we template the Problem class by the element type</p>
 <div class="fragment"><div class="line"><span class="comment">//==start_of_problem_class============================================</span></div>
<div class="line"><span class="comment">/// Problem class to simulate inviscid bubble propagating along 2D channel</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classBubbleInChannelProblem.html">BubbleInChannelProblem</a> : <span class="keyword">public</span> Problem</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Constructor</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classBubbleInChannelProblem.html#a04bf2f20c65e85228fac381d786bedad">BubbleInChannelProblem</a>();</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Destructor</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classBubbleInChannelProblem.html#a7a048a26898571d0f109df2a11f08eb7">~BubbleInChannelProblem</a>()</div>
<div class="ttc" id="aclassBubbleInChannelProblem_html_a04bf2f20c65e85228fac381d786bedad"><div class="ttname"><a href="classBubbleInChannelProblem.html#a04bf2f20c65e85228fac381d786bedad">BubbleInChannelProblem::BubbleInChannelProblem</a></div><div class="ttdeci">BubbleInChannelProblem()</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00619">adaptive_bubble_in_channel.cc:619</a></div></div>
<div class="ttc" id="aclassBubbleInChannelProblem_html_a7a048a26898571d0f109df2a11f08eb7"><div class="ttname"><a href="classBubbleInChannelProblem.html#a7a048a26898571d0f109df2a11f08eb7">BubbleInChannelProblem::~BubbleInChannelProblem</a></div><div class="ttdeci">~BubbleInChannelProblem()</div><div class="ttdoc">Destructor.</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00433">adaptive_bubble_in_channel.cc:433</a></div></div>
</div><!-- fragment --><p> The <code>FaceElements</code> are deleted and re-attached before and after each adaptation. Also, as discussed in <a href="../../../meshes/mesh_from_inline_triangle/html/index.html#overview">another tutorial</a>, we re-apply the boundary conditions and complete the build of all elements after each adaptation, using the helper function <code>complete_problem_setup()</code> (discussed below).</p>
<div class="fragment"><div class="line"> <span class="comment">/// Actions before adapt: Wipe the mesh of free surface elements</span></div>
<div class="line"> <span class="keywordtype">void</span> actions_before_adapt()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Kill the  elements and wipe surface mesh</span></div>
<div class="line">   delete_free_surface_elements();</div>
<div class="line">   delete_volume_constraint_elements();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Rebuild the Problem&#39;s global mesh from its various sub-meshes</span></div>
<div class="line">   this-&gt;rebuild_global_mesh();</div>
<div class="line">  </div>
<div class="line">  }<span class="comment">// end of actions_before_adapt</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Actions after adapt: Rebuild the mesh of free surface elements</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> actions_after_adapt()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Create the elements that impose the displacement constraint </span></div>
<div class="line">   create_free_surface_elements();</div>
<div class="line">   create_volume_constraint_elements();</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Rebuild the Problem&#39;s global mesh from its various sub-meshes</span></div>
<div class="line">   this-&gt;rebuild_global_mesh();</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Setup the problem again -- remember that fluid mesh has been</span></div>
<div class="line">   <span class="comment">// completely rebuilt and its element&#39;s don&#39;t have any</span></div>
<div class="line">   <span class="comment">// pointers to Re etc. yet</span></div>
<div class="line">   complete_problem_setup();</div>
<div class="line"> </div>
<div class="line">  }<span class="comment">// end of actions_after_adapt</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Update the after solve (empty)</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> actions_after_newton_solve(){}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Update the problem specs before solve</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> actions_before_newton_solve()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Reset the Lagrangian coordinates of the nodes to be the current</span></div>
<div class="line">   <span class="comment">//Eulerian coordinates -- this makes the current configuration</span></div>
<div class="line">   <span class="comment">//stress free</span></div>
<div class="line">   Fluid_mesh_pt-&gt;set_lagrangian_nodal_coordinates();</div>
<div class="line">  }</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Set boundary conditions and complete the build of all elements</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> complete_problem_setup();</div>
</div><!-- fragment --><p> We define the post-processing functions to document the solution and to compute the error estimates.</p>
<div class="fragment"><div class="line"> <span class="comment">/// Doc the solution</span></div>
<div class="line"> <span class="keywordtype">void</span> doc_solution(<span class="keyword">const</span> std::string&amp; comment=<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Compute the error estimates and assign to elements for plotting</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> compute_error_estimate(<span class="keywordtype">double</span>&amp; max_err,</div>
</div><!-- fragment --><p> We also provide helper functions to delete and create face elements adjacent to the bubble boundary.</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Create free surface elements</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> create_free_surface_elements();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Delete free surface elements </span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> delete_free_surface_elements()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// How many surface elements are in the surface mesh</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_element = Free_surface_mesh_pt-&gt;nelement();</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Loop over the surface elements</span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Kill surface element</span></div>
<div class="line">     <span class="keyword">delete</span> Free_surface_mesh_pt-&gt;element_pt(e);</div>
<div class="line">    }</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Wipe the mesh</span></div>
<div class="line">   Free_surface_mesh_pt-&gt;flush_element_and_node_storage();</div>
<div class="line">   </div>
<div class="line">  } <span class="comment">// end of delete_free_surface_elements</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/// Create elements that impose volume constraint on the bubble</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> create_volume_constraint_elements();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Delete volume constraint elements</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> delete_volume_constraint_elements()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// How many surface elements are in the surface mesh</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_element = Volume_constraint_mesh_pt-&gt;nelement();</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Loop over the surface elements (but don&#39;t kill the volume constraint</span></div>
<div class="line">   <span class="comment">// element (element 0))</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> first_el_to_be_killed=1;</div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=first_el_to_be_killed;e&lt;n_element;e++) </div>
<div class="line">    {</div>
<div class="line">     <span class="keyword">delete</span> Volume_constraint_mesh_pt-&gt;element_pt(e);</div>
<div class="line">    }</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Wipe the mesh</span></div>
<div class="line">   Volume_constraint_mesh_pt-&gt;flush_element_and_node_storage();</div>
<div class="line">   </div>
<div class="line">  } <span class="comment">// end of delete_volume_constraint_elements</span></div>
</div><!-- fragment --><p> The private data includes pointers to the fluid mesh, and the two face meshes which impose the kinematic and dynamic boundary conditions, and the volume constraint, respectively. We also store pointers to the Data that stores the unknown bubble pressure and to the <code>VolumeConstraintElement</code> that imposes the volume constraint and is "in charge of" the bubble pressure.</p>
<div class="fragment"><div class="line"> <span class="comment">/// Pointers to mesh of free surface elements</span></div>
<div class="line"> Mesh* Free_surface_mesh_pt;</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Pointer to mesh containing elements that impose volume constraint</span></div>
<div class="line"><span class="comment"></span> Mesh* Volume_constraint_mesh_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to Fluid_mesh</span></div>
<div class="line"><span class="comment"></span> RefineableSolidTriangleMesh&lt;ELEMENT&gt;* Fluid_mesh_pt;</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Vector storing pointer to the bubble polygons</span></div>
<div class="line"><span class="comment"></span> Vector&lt;TriangleMeshPolygon*&gt; Bubble_polygon_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Triangle mesh polygon for outer boundary </span></div>
<div class="line"><span class="comment"></span> TriangleMeshPolygon* Outer_boundary_polyline_pt; </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to a global bubble pressure datum</span></div>
<div class="line"><span class="comment"></span> Data* Bubble_pressure_data_pt;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to element that imposes volume constraint for bubble</span></div>
<div class="line"><span class="comment"></span> VolumeConstraintElement* Vol_constraint_el_pt;</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Enumeration of mesh boundaries</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">enum</span> </div>
<div class="line"> {</div>
<div class="line">  Inflow_boundary_id=0,</div>
<div class="line">  Upper_wall_boundary_id=1,</div>
<div class="line">  Outflow_boundary_id=2,</div>
<div class="line">  Bottom_wall_boundary_id=3,</div>
<div class="line">  First_bubble_boundary_id=4,</div>
<div class="line">  Second_bubble_boundary_id=5</div>
<div class="line"> };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">}; <span class="comment">// end_of_problem_class</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="constructor"></a>
The problem constructor</h1>
<p>We allocate the timestepper and build the <code>VolumeConstraintElement</code> that imposes the volume constraint. The element stores the volume that is to be conserved as well as the bubble pressure, which is determined from the volume constraint. The initial guess for the bubble pressure, <img class="formulaInl" alt="$ p_{bubble}=Ca/a $" src="form_32.png" width="81" height="14"/>, is appropriate for a static bubble in stationary fluid.</p>
<div class="fragment"><div class="line"><span class="comment">//==start_constructor=====================================================</span></div>
<div class="line"><span class="comment">/// Constructor</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><a class="code" href="classBubbleInChannelProblem.html#a04bf2f20c65e85228fac381d786bedad">BubbleInChannelProblem&lt;ELEMENT&gt;::BubbleInChannelProblem</a>()</div>
<div class="line">{ </div>
<div class="line"> <span class="comment">// Output directory</span></div>
<div class="line"> <a class="code" href="namespaceProblem__Parameter.html#a1dd3c6bcf97360c8fe0d288ca7610351">Problem_Parameter::Doc_info</a>.set_directory(<span class="stringliteral">&quot;RESLT&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Allocate the timestepper -- this constructs the Problem&#39;s </span></div>
<div class="line"> <span class="comment">// time object with a sufficient amount of storage to store the</span></div>
<div class="line"> <span class="comment">// previous timsteps. </span></div>
<div class="line"> this-&gt;add_time_stepper_pt(<span class="keyword">new</span> BDF&lt;2&gt;);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build volume constraint element: Pass pointer to double that</span></div>
<div class="line"> <span class="comment">// specifies target volume, data that contains the &quot;traded&quot; pressure</span></div>
<div class="line"> <span class="comment">// and the index of the traded pressure value within this Data item</span></div>
<div class="line"> <span class="comment">// Build element and create pressure internally</span></div>
<div class="line"> Vol_constraint_el_pt= </div>
<div class="line">  <span class="keyword">new</span> VolumeConstraintElement(&amp;<a class="code" href="namespaceProblem__Parameter.html#aad8e0a2d1ec39a8dd7357a43bcc5f20e">Problem_Parameter::Volume</a>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Which value stores the pressure?</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> index=Vol_constraint_el_pt-&gt;index_of_traded_pressure();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Pressure data</span></div>
<div class="line"> Bubble_pressure_data_pt=Vol_constraint_el_pt-&gt;p_traded_data_pt();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Assign initial value</span></div>
<div class="line"> Vol_constraint_el_pt-&gt;p_traded_data_pt()-&gt;</div>
<div class="line">  set_value(index,<a class="code" href="namespaceProblem__Parameter.html#af6194d2571881779c678fbabc1503d47">Problem_Parameter::Ca</a>/<a class="code" href="namespaceProblem__Parameter.html#a903237528f0e9bb92debcc8842576cca">Problem_Parameter::Radius</a>);</div>
</div><!-- fragment --><p> Next the outer boundary, consisting of four separate polylines, is built. Each polyline is defined by a start and an end point and is stored in a vector. This vector is then used to create the closed polygon required by <code>Triangle</code>.</p>
<div class="fragment"><div class="line"> <span class="comment">// Build the boundary segments for outer boundary, consisting of</span></div>
<div class="line"> <span class="comment">//--------------------------------------------------------------</span></div>
<div class="line"> <span class="comment">// four separate polylines</span></div>
<div class="line"> <span class="comment">//------------------------</span></div>
<div class="line"> Vector&lt;TriangleMeshCurveSection*&gt; boundary_polyline_pt(4);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Each polyline only has two vertices -- provide storage for their</span></div>
<div class="line"> <span class="comment">// coordinates</span></div>
<div class="line"> Vector&lt;Vector&lt;double&gt; &gt; vertex_coord(2);</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;2;i++)</div>
<div class="line">  {</div>
<div class="line">   vertex_coord[i].resize(2);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// First polyline: Inflow</span></div>
<div class="line"> vertex_coord[0][0]=0.0;</div>
<div class="line"> vertex_coord[0][1]=0.0;</div>
<div class="line"> vertex_coord[1][0]=0.0;</div>
<div class="line"> vertex_coord[1][1]=1.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the 1st boundary polyline</span></div>
<div class="line"> boundary_polyline_pt[0] = <span class="keyword">new</span> TriangleMeshPolyLine(vertex_coord,</div>
<div class="line">                                                   Inflow_boundary_id);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Second boundary polyline: Upper wall</span></div>
<div class="line"> vertex_coord[0][0]=0.0;</div>
<div class="line"> vertex_coord[0][1]=1.0;</div>
<div class="line"> vertex_coord[1][0]=<a class="code" href="namespaceProblem__Parameter.html#a7b67840fea463f29b53d12f7bd7cb34b">Problem_Parameter::Length</a>;</div>
<div class="line"> vertex_coord[1][1]=1.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the 2nd boundary polyline</span></div>
<div class="line"> boundary_polyline_pt[1] = <span class="keyword">new</span> TriangleMeshPolyLine(vertex_coord,</div>
<div class="line">                                                   Upper_wall_boundary_id);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Third boundary polyline: Outflow</span></div>
<div class="line"> vertex_coord[0][0]=<a class="code" href="namespaceProblem__Parameter.html#a7b67840fea463f29b53d12f7bd7cb34b">Problem_Parameter::Length</a>;</div>
<div class="line"> vertex_coord[0][1]=1.0;</div>
<div class="line"> vertex_coord[1][0]=<a class="code" href="namespaceProblem__Parameter.html#a7b67840fea463f29b53d12f7bd7cb34b">Problem_Parameter::Length</a>;</div>
<div class="line"> vertex_coord[1][1]=0.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the 3rd boundary polyline</span></div>
<div class="line"> boundary_polyline_pt[2] = <span class="keyword">new</span> TriangleMeshPolyLine(vertex_coord,</div>
<div class="line">                                                   Outflow_boundary_id);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Fourth boundary polyline: Bottom wall</span></div>
<div class="line"> vertex_coord[0][0]=<a class="code" href="namespaceProblem__Parameter.html#a7b67840fea463f29b53d12f7bd7cb34b">Problem_Parameter::Length</a>;</div>
<div class="line"> vertex_coord[0][1]=0.0;</div>
<div class="line"> vertex_coord[1][0]=0.0;</div>
<div class="line"> vertex_coord[1][1]=0.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the 4th boundary polyline</span></div>
<div class="line"> boundary_polyline_pt[3] = <span class="keyword">new</span> TriangleMeshPolyLine(vertex_coord,</div>
<div class="line">                                                    Bottom_wall_boundary_id);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create the triangle mesh polygon for outer boundary</span></div>
<div class="line"> Outer_boundary_polyline_pt = <span class="keyword">new</span> TriangleMeshPolygon(boundary_polyline_pt);</div>
</div><!-- fragment --><p> Next the polygon representing the bubble in the initial setup is generated. (<a href="../../../meshes/mesh_from_inline_triangle/html/index.html#polygonal">Recall</a> that closed polygons must be subdivided into at least two distinct polylines.)</p>
<div class="fragment"><div class="line"> <span class="comment">// Now define initial shape of bubble(s) with polygon</span></div>
<div class="line"> <span class="comment">//---------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// We have one bubble</span></div>
<div class="line"> Bubble_polygon_pt.resize(1);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Place it smack in the middle of the channel</span></div>
<div class="line"> <span class="keywordtype">double</span> x_center = 0.5*<a class="code" href="namespaceProblem__Parameter.html#a7b67840fea463f29b53d12f7bd7cb34b">Problem_Parameter::Length</a>;</div>
<div class="line"> <span class="keywordtype">double</span> y_center = 0.5;</div>
<div class="line"> Ellipse * bubble_pt = <span class="keyword">new</span> Ellipse(<a class="code" href="namespaceProblem__Parameter.html#a903237528f0e9bb92debcc8842576cca">Problem_Parameter::Radius</a>,</div>
<div class="line">                                       <a class="code" href="namespaceProblem__Parameter.html#a903237528f0e9bb92debcc8842576cca">Problem_Parameter::Radius</a>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Intrinsic coordinate along GeomObject defining the bubble</span></div>
<div class="line"> Vector&lt;double&gt; zeta(1);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Position vector to GeomObject defining the bubble</span></div>
<div class="line"> Vector&lt;double&gt; coord(2);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Number of points defining bubble</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> npoints = 16; </div>
<div class="line"> <span class="keywordtype">double</span> unit_zeta = MathematicalConstants::Pi/double(npoints-1);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// This bubble is bounded by two distinct boundaries, each</span></div>
<div class="line"> <span class="comment">// represented by its own polyline</span></div>
<div class="line"> Vector&lt;TriangleMeshCurveSection*&gt; bubble_polyline_pt(2);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Vertex coordinates</span></div>
<div class="line"> Vector&lt;Vector&lt;double&gt; &gt; bubble_vertex(npoints);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create points on boundary</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ipoint=0; ipoint&lt;npoints;ipoint++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Resize the vector </span></div>
<div class="line">   bubble_vertex[ipoint].resize(2);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Get the coordinates</span></div>
<div class="line">   zeta[0]=unit_zeta*double(ipoint);</div>
<div class="line">   bubble_pt-&gt;position(zeta,coord);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Shift</span></div>
<div class="line">   bubble_vertex[ipoint][0]=coord[0]+x_center;</div>
<div class="line">   bubble_vertex[ipoint][1]=coord[1]+y_center;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the 1st bubble polyline</span></div>
<div class="line"> bubble_polyline_pt[0] = <span class="keyword">new</span> TriangleMeshPolyLine(bubble_vertex,</div>
<div class="line">                                                  First_bubble_boundary_id);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Second boundary of bubble</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ipoint=0; ipoint&lt;npoints;ipoint++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Resize the vector </span></div>
<div class="line">   bubble_vertex[ipoint].resize(2);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Get the coordinates</span></div>
<div class="line">   zeta[0]=(unit_zeta*double(ipoint))+MathematicalConstants::Pi;</div>
<div class="line">   bubble_pt-&gt;position(zeta,coord);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Shift</span></div>
<div class="line">   bubble_vertex[ipoint][0]=coord[0]+x_center;</div>
<div class="line">   bubble_vertex[ipoint][1]=coord[1]+y_center;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the 2nd bubble polyline</span></div>
<div class="line"> bubble_polyline_pt[1] = <span class="keyword">new</span> TriangleMeshPolyLine(bubble_vertex,</div>
<div class="line">                                                  Second_bubble_boundary_id);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Define coordinates of a point inside the bubble</span></div>
<div class="line"> Vector&lt;double&gt; bubble_center(2);</div>
<div class="line"> bubble_center[0]=x_center;</div>
<div class="line"> bubble_center[1]=y_center;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create closed polygon from two polylines</span></div>
<div class="line"> Bubble_polygon_pt[0] = <span class="keyword">new</span> TriangleMeshPolygon(</div>
<div class="line">                 bubble_polyline_pt,</div>
<div class="line">                 bubble_center);</div>
</div><!-- fragment --><p> Once the boundary representation in form of polygons is completed the mesh is generated using <code>Triangle</code>. We specify the error estimator and set targets for the spatial adaptivity, and output the initial mesh.</p>
<div class="fragment"><div class="line"> <span class="comment">// Now build the mesh, based on the boundaries specified by</span></div>
<div class="line"> <span class="comment">//---------------------------------------------------------</span></div>
<div class="line"> <span class="comment">// polygons just created</span></div>
<div class="line"> <span class="comment">//----------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Convert to &quot;closed curve&quot; objects</span></div>
<div class="line"> TriangleMeshClosedCurve* outer_closed_curve_pt=Outer_boundary_polyline_pt;</div>
<div class="line"> <span class="keywordtype">unsigned</span> nb=Bubble_polygon_pt.size();</div>
<div class="line"> Vector&lt;TriangleMeshClosedCurve*&gt; bubble_closed_curve_pt(nb);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;nb;i++)</div>
<div class="line">  {</div>
<div class="line">   bubble_closed_curve_pt[i]=Bubble_polygon_pt[i];</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Target area for initial mesh</span></div>
<div class="line"> <span class="keywordtype">double</span> uniform_element_area=0.2;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Use the TriangleMeshParameters object for gathering all</span></div>
<div class="line"> <span class="comment">// the necessary arguments for the TriangleMesh object</span></div>
<div class="line"> TriangleMeshParameters triangle_mesh_parameters(</div>
<div class="line">   outer_closed_curve_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Define the holes on the boundary</span></div>
<div class="line"> triangle_mesh_parameters.internal_closed_curve_pt() =</div>
<div class="line">   bubble_closed_curve_pt;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Define the maximum element areas</span></div>
<div class="line"> triangle_mesh_parameters.element_area() =</div>
<div class="line">   uniform_element_area;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create the mesh</span></div>
<div class="line"> Fluid_mesh_pt =</div>
<div class="line">   <span class="keyword">new</span> RefineableSolidTriangleMesh&lt;ELEMENT&gt;(</div>
<div class="line">     triangle_mesh_parameters, this-&gt;time_stepper_pt());</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set error estimator for bulk mesh</span></div>
<div class="line"> Z2ErrorEstimator* error_estimator_pt=<span class="keyword">new</span> Z2ErrorEstimator;</div>
<div class="line"> Fluid_mesh_pt-&gt;spatial_error_estimator_pt()=error_estimator_pt;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set targets for spatial adaptivity</span></div>
<div class="line"> Fluid_mesh_pt-&gt;max_permitted_error()=0.005;</div>
<div class="line"> Fluid_mesh_pt-&gt;min_permitted_error()=0.001;</div>
<div class="line"> Fluid_mesh_pt-&gt;max_element_size()=0.2;</div>
<div class="line"> Fluid_mesh_pt-&gt;min_element_size()=0.001; </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Use coarser mesh during validation</span></div>
<div class="line"> <span class="keywordflow">if</span> (CommandLineArgs::command_line_flag_has_been_set(<span class="stringliteral">&quot;--validation&quot;</span>))</div>
<div class="line">  {</div>
<div class="line">   Fluid_mesh_pt-&gt;min_element_size()=0.01; </div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output boundary and mesh initial mesh for information</span></div>
<div class="line"> this-&gt;Fluid_mesh_pt-&gt;output_boundaries(<span class="stringliteral">&quot;boundaries.dat&quot;</span>);</div>
<div class="line"> this-&gt;Fluid_mesh_pt-&gt;output(<span class="stringliteral">&quot;mesh.dat&quot;</span>);</div>
</div><!-- fragment --><p> We complete the problem setup, create the various surface meshes that impose the dynamic and kinematic boundary conditions and the volume constraint. We then combine the submeshes into a global mesh.</p>
<div class="fragment"><div class="line"> <span class="comment">// Set boundary condition and complete the build of all elements</span></div>
<div class="line"> complete_problem_setup();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Construct the mesh of free surface elements</span></div>
<div class="line"> Free_surface_mesh_pt=<span class="keyword">new</span> Mesh;</div>
<div class="line"> create_free_surface_elements();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Construct the mesh of elements that impose the volume constraint</span></div>
<div class="line"> Volume_constraint_mesh_pt = <span class="keyword">new</span> Mesh;</div>
<div class="line"> create_volume_constraint_elements();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Combine meshes</span></div>
<div class="line"> <span class="comment">//---------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Add volume constraint sub mesh</span></div>
<div class="line"> this-&gt;add_sub_mesh(this-&gt;Volume_constraint_mesh_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Add Fluid_mesh_pt sub meshes</span></div>
<div class="line"> this-&gt;add_sub_mesh(Fluid_mesh_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Add Free_surface sub meshes</span></div>
<div class="line"> this-&gt;add_sub_mesh(this-&gt;Free_surface_mesh_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build global mesh</span></div>
<div class="line"> this-&gt;build_global_mesh();</div>
<div class="line">  </div>
<div class="line"> <span class="comment">// Setup equation numbering scheme</span></div>
<div class="line"> cout &lt;&lt;<span class="stringliteral">&quot;Number of equations: &quot;</span> &lt;&lt; this-&gt;assign_eqn_numbers() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end_of_constructor</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="problem_setup"></a>
Problem setup</h1>
<p>During the problem setup the position of all boundary nodes in the pseudo-elastic fluid mesh, apart from those on the bubble boundary, are pinned.</p>
 <div class="fragment"><div class="line"><span class="comment">//==start_of_complete_problem_setup=======================================</span></div>
<div class="line"><span class="comment">/// Set boundary conditions and complete the build of all elements</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classBubbleInChannelProblem.html#a7b3c042477f4ee4e62dd1e00e1a480f8">BubbleInChannelProblem&lt;ELEMENT&gt;::complete_problem_setup</a>()</div>
<div class="line">{      </div>
<div class="line"> <span class="comment">// Map to record if a given boundary is on a bubble or not</span></div>
<div class="line"> map&lt;unsigned,bool&gt; is_on_bubble_bound;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over the bubbles </span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nbubble=Bubble_polygon_pt.size();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibubble=0;ibubble&lt;nbubble;ibubble++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Get the vector all boundary IDs associated with the polylines that</span></div>
<div class="line">   <span class="comment">// make up the closed polygon</span></div>
<div class="line">   Vector&lt;unsigned&gt; bubble_bound_id=this-&gt;Bubble_polygon_pt[ibubble]-&gt;</div>
<div class="line">    polygon_boundary_id();</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Get the number of boundary</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> nbound=bubble_bound_id.size();</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Fill in the map</span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibound=0;ibound&lt;nbound;ibound++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// This boundary...</span></div>
<div class="line">     <span class="keywordtype">unsigned</span> bound_id=bubble_bound_id[ibound];</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// ...is on the bubble</span></div>
<div class="line">     is_on_bubble_bound[bound_id]=<span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">// points on bubble boundary located</span></div>
<div class="ttc" id="aclassBubbleInChannelProblem_html_a7b3c042477f4ee4e62dd1e00e1a480f8"><div class="ttname"><a href="classBubbleInChannelProblem.html#a7b3c042477f4ee4e62dd1e00e1a480f8">BubbleInChannelProblem::complete_problem_setup</a></div><div class="ttdeci">void complete_problem_setup()</div><div class="ttdoc">Set boundary conditions and complete the build of all elements.</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l01003">adaptive_bubble_in_channel.cc:1003</a></div></div>
</div><!-- fragment --><p> We pin both velocity components on the inflow, top and bottom boundaries and the vertical velocity component at the outflow.</p>
<div class="fragment"><div class="line"> <span class="comment">// Re-set the boundary conditions for fluid problem: All nodes are</span></div>
<div class="line"> <span class="comment">// free by default -- just pin the ones that have Dirichlet conditions</span></div>
<div class="line"> <span class="comment">// here. </span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nbound=Fluid_mesh_pt-&gt;nboundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibound=0;ibound&lt;nbound;ibound++)</div>
<div class="line">  {</div>
<div class="line">   <span class="keywordtype">unsigned</span> num_nod=Fluid_mesh_pt-&gt;nboundary_node(ibound);</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Get node</span></div>
<div class="line">     Node* nod_pt=Fluid_mesh_pt-&gt;boundary_node_pt(ibound,inod);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">//Pin both velocities on inflow (0) and side boundaries (1 and 3)</span></div>
<div class="line">     <span class="keywordflow">if</span>((ibound==0) || (ibound==1) || (ibound==3))</div>
<div class="line">      {</div>
<div class="line">       nod_pt-&gt;pin(0);</div>
<div class="line">       nod_pt-&gt;pin(1);</div>
<div class="line">      }</div>
<div class="line">     </div>
<div class="line">     <span class="comment">//If it&#39;s the outflow pin only the vertical velocity</span></div>
<div class="line">     <span class="keywordflow">if</span>(ibound==2) {nod_pt-&gt;pin(1);}</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Pin pseudo-solid positions apart from bubble boundary which</span></div>
<div class="line">     <span class="comment">// we allow to move</span></div>
<div class="line">     SolidNode* solid_node_pt = <span class="keyword">dynamic_cast&lt;</span>SolidNode*<span class="keyword">&gt;</span>(nod_pt);</div>
<div class="line">     <span class="keywordflow">if</span>(is_on_bubble_bound[ibound])</div>
<div class="line">      {</div>
<div class="line">       solid_node_pt-&gt;unpin_position(0);</div>
<div class="line">       solid_node_pt-&gt;unpin_position(1);</div>
<div class="line">      }</div>
<div class="line">     <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">       solid_node_pt-&gt;pin_position(0);</div>
<div class="line">       solid_node_pt-&gt;pin_position(1);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">// end loop over boundaries</span></div>
</div><!-- fragment --><p> Next, the bulk elements are made fully functional. For every element the pointers to the time, Reynolds number, Womersley number and the constitutive law for the mesh deformation are set.</p>
<div class="fragment"><div class="line"> <span class="comment">// Complete the build of all elements so they are fully functional</span></div>
<div class="line"> <span class="comment">// Remember that adaptation for triangle meshes involves a complete</span></div>
<div class="line"> <span class="comment">// regneration of the mesh (rather than splitting as in tree-based</span></div>
<div class="line"> <span class="comment">// meshes where such parameters can be passed down from the father</span></div>
<div class="line"> <span class="comment">// element!)</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_element = Fluid_mesh_pt-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from GeneralisedElement to the present element</span></div>
<div class="line">   ELEMENT* el_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(Fluid_mesh_pt-&gt;element_pt(e));</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Set the Reynolds number</span></div>
<div class="line">   el_pt-&gt;re_pt() = &amp;<a class="code" href="namespaceProblem__Parameter.html#acc656299287d4d9a8374c2c501750b4f">Problem_Parameter::Re</a>;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Set the Womersley number (same as Re since St=1)</span></div>
<div class="line">   el_pt-&gt;re_st_pt() = &amp;<a class="code" href="namespaceProblem__Parameter.html#acc656299287d4d9a8374c2c501750b4f">Problem_Parameter::Re</a>;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Set the constitutive law for pseudo-elastic mesh deformation</span></div>
<div class="line">   el_pt-&gt;constitutive_law_pt()=<a class="code" href="namespaceProblem__Parameter.html#a810f05c8d3e3331aed75643557d1057c">Problem_Parameter::Constitutive_law_pt</a>;</div>
<div class="line">  }</div>
</div><!-- fragment --><p> Finally, we (re-)assign the velocity boundary values by imposing no slip on the channel walls, parallel outflow, and a Poiseuille profile at the inlet.</p>
<div class="fragment"><div class="line"> <span class="comment">// Re-apply boundary values on Dirichlet boundary conditions </span></div>
<div class="line"> <span class="comment">// (Boundary conditions are ignored when the solution is transferred</span></div>
<div class="line"> <span class="comment">// from the old to the new mesh by projection; this leads to a slight</span></div>
<div class="line"> <span class="comment">// change in the boundary values (which are, of course, never changed,</span></div>
<div class="line"> <span class="comment">// unlike the actual unknowns for which the projected values only</span></div>
<div class="line"> <span class="comment">// serve as an initial guess)</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set velocity and history values of velocity on walls</span></div>
<div class="line"> nbound=this-&gt;Fluid_mesh_pt-&gt;nboundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibound=0;ibound&lt;nbound;++ibound)</div>
<div class="line">  {</div>
<div class="line">   <span class="keywordflow">if</span> ((ibound==Upper_wall_boundary_id)||</div>
<div class="line">       (ibound==Bottom_wall_boundary_id)||</div>
<div class="line">       (ibound==Outflow_boundary_id)||</div>
<div class="line">       (ibound==Inflow_boundary_id))</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Loop over nodes on this boundary</span></div>
<div class="line">     <span class="keywordtype">unsigned</span> num_nod=this-&gt;Fluid_mesh_pt-&gt;nboundary_node(ibound);</div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">      {</div>
<div class="line">       <span class="comment">// Get node</span></div>
<div class="line">       Node* nod_pt=this-&gt;Fluid_mesh_pt-&gt;boundary_node_pt(ibound,inod);</div>
<div class="line">       </div>
<div class="line">       <span class="comment">// Get number of previous (history) values</span></div>
<div class="line">       <span class="keywordtype">unsigned</span> n_prev=nod_pt-&gt;time_stepper_pt()-&gt;nprev_values();</div>
<div class="line">       </div>
<div class="line">       <span class="comment">// Velocity is and was zero at all previous times</span></div>
<div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> t=0;t&lt;=n_prev;t++)</div>
<div class="line">        {</div>
<div class="line">         <span class="keywordflow">if</span> (ibound!=Inflow_boundary_id)</div>
<div class="line">          {</div>
<div class="line">           <span class="comment">// Parallel outflow</span></div>
<div class="line">           <span class="keywordflow">if</span> (ibound!=Outflow_boundary_id)</div>
<div class="line">            {</div>
<div class="line">             nod_pt-&gt;set_value(t,0,0.0); </div>
<div class="line">            }</div>
<div class="line">           nod_pt-&gt;set_value(t,1,0.0);</div>
<div class="line">          }</div>
<div class="line">         </div>
<div class="line">         <span class="comment">// Nodes have always been there...</span></div>
<div class="line">         nod_pt-&gt;x(t,0)=nod_pt-&gt;x(0,0);</div>
<div class="line">         nod_pt-&gt;x(t,1)=nod_pt-&gt;x(0,1);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Re-assign prescribed inflow velocity at inlet</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> num_nod=this-&gt;Fluid_mesh_pt-&gt;nboundary_node(Inflow_boundary_id);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Get node</span></div>
<div class="line">   Node* nod_pt=this-&gt;Fluid_mesh_pt-&gt;boundary_node_pt(Inflow_boundary_id,</div>
<div class="line">                                                      inod);</div>
<div class="line">   <span class="comment">//Now set the boundary velocity</span></div>
<div class="line">   <span class="keywordtype">double</span> y = nod_pt-&gt;x(1); </div>
<div class="line">   nod_pt-&gt;set_value(0,<a class="code" href="namespaceProblem__Parameter.html#a7792613e563a733ad88b8e15d126fc3a">Problem_Parameter::Inflow_veloc_magnitude</a>*y*(1-y));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of complete_problem_setup</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="face_elements"></a>
Generation of face elements</h1>
<p>As usual we impose the kinematic and dynamic boundary condition at the free surface by attaching <code>FaceElements</code> to the relevant boundaries of the bulk elements. We specify pointers to the Capillary number <img class="formulaInl" alt="$ Ca $" src="form_30.png" width="16" height="10"/> and the bubble pressure <img class="formulaInl" alt="$ p_{bubble} $" src="form_18.png" width="34" height="9"/>. The pointer to the Strouhal number <img class="formulaInl" alt="$ St $" src="form_33.png" width="13" height="10"/> does not need to be set, since it already defaults to a value of 1.0.</p>
 <div class="fragment"><div class="line"><span class="comment">//============start_of_create_free_surface_elements======================</span></div>
<div class="line"><span class="comment">/// Create elements that impose the kinematic and dynamic bcs</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// for the pseudo-solid fluid mesh</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=======================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classBubbleInChannelProblem.html#a9a5a34516352db3153baa52ccb204b62">BubbleInChannelProblem&lt;ELEMENT&gt;::create_free_surface_elements</a>()</div>
<div class="line">{ </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Volume constraint element stores the Data item that stores</span></div>
<div class="line"> <span class="comment">// the bubble pressure that is adjusted/traded to allow for</span></div>
<div class="line"> <span class="comment">// volume conservation. Which value is the pressure stored in?</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> p_traded_index=Vol_constraint_el_pt-&gt;index_of_traded_pressure();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Loop over the free surface boundaries</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nb=Fluid_mesh_pt-&gt;nboundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> b=First_bubble_boundary_id;b&lt;nb;b++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// How many bulk fluid elements are adjacent to boundary b?</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_element = Fluid_mesh_pt-&gt;nboundary_element(b);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Loop over the bulk fluid elements adjacent to boundary b?</span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Get pointer to the bulk fluid element that is </span></div>
<div class="line">     <span class="comment">// adjacent to boundary b</span></div>
<div class="line">     ELEMENT* bulk_elem_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(</div>
<div class="line">      Fluid_mesh_pt-&gt;boundary_element_pt(b,e));</div>
<div class="line">     </div>
<div class="line">     <span class="comment">//Find the index of the face of element e along boundary b</span></div>
<div class="line">     <span class="keywordtype">int</span> face_index = Fluid_mesh_pt-&gt;face_index_at_boundary(b,e);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Create new element</span></div>
<div class="line">     ElasticLineFluidInterfaceElement&lt;ELEMENT&gt;* el_pt =</div>
<div class="line">      <span class="keyword">new</span> ElasticLineFluidInterfaceElement&lt;ELEMENT&gt;(</div>
<div class="line">       bulk_elem_pt,face_index);   </div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Add it to the mesh</span></div>
<div class="line">     Free_surface_mesh_pt-&gt;add_element_pt(el_pt);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">//Add the appropriate boundary number</span></div>
<div class="line">     el_pt-&gt;set_boundary_number_in_bulk_mesh(b);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">//Specify the capillary number</span></div>
<div class="line">     el_pt-&gt;ca_pt() = &amp;<a class="code" href="namespaceProblem__Parameter.html#af6194d2571881779c678fbabc1503d47">Problem_Parameter::Ca</a>;</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Specify the bubble pressure (pointer to Data object and </span></div>
<div class="line">     <span class="comment">// index of value within that Data object that corresponds</span></div>
<div class="line">     <span class="comment">// to the traded pressure</span></div>
<div class="line">     el_pt-&gt;set_external_pressure_data(</div>
<div class="line">      Vol_constraint_el_pt-&gt;p_traded_data_pt(),p_traded_index); </div>
<div class="line">    } </div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="comment">// end of create_free_surface_elements</span></div>
<div class="ttc" id="aclassBubbleInChannelProblem_html_a9a5a34516352db3153baa52ccb204b62"><div class="ttname"><a href="classBubbleInChannelProblem.html#a9a5a34516352db3153baa52ccb204b62">BubbleInChannelProblem::create_free_surface_elements</a></div><div class="ttdeci">void create_free_surface_elements()</div><div class="ttdoc">Create free surface elements.</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00900">adaptive_bubble_in_channel.cc:900</a></div></div>
</div><!-- fragment --><p> The volume constraint elements are created in a similar way. Recall that the <code>LineVolumeConstraintBoundingSolidElements</code> compute the line integrals in equation (10) while the <code>VolumeConstraintElement</code> adds <img class="formulaInl" alt="$ V_{bubble} $" src="form_17.png" width="34" height="13"/> to this equation.</p>
<div class="fragment"><div class="line"><span class="comment">//============start_of_create_volume_constraint_elements=================</span></div>
<div class="line"><span class="comment">/// Create elements that impose volume constraint on the bubble</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=======================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classBubbleInChannelProblem.html#ae1ab79ef810211e337127878876c0fa6">BubbleInChannelProblem&lt;ELEMENT&gt;::create_volume_constraint_elements</a>()</div>
<div class="line">{ </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Add volume constraint element to the mesh</span></div>
<div class="line"> Volume_constraint_mesh_pt-&gt;add_element_pt(Vol_constraint_el_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Loop over the free surface boundaries</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nb=Fluid_mesh_pt-&gt;nboundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> b=First_bubble_boundary_id;b&lt;nb;b++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// How many bulk fluid elements are adjacent to boundary b?</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_element = Fluid_mesh_pt-&gt;nboundary_element(b);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Loop over the bulk fluid elements adjacent to boundary b?</span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Get pointer to the bulk fluid element that is </span></div>
<div class="line">     <span class="comment">// adjacent to boundary b</span></div>
<div class="line">     ELEMENT* bulk_elem_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(</div>
<div class="line">      Fluid_mesh_pt-&gt;boundary_element_pt(b,e));</div>
<div class="line">     </div>
<div class="line">     <span class="comment">//Find the index of the face of element e along boundary b</span></div>
<div class="line">     <span class="keywordtype">int</span> face_index = Fluid_mesh_pt-&gt;face_index_at_boundary(b,e);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Create new element</span></div>
<div class="line">     ElasticLineVolumeConstraintBoundingElement&lt;ELEMENT&gt;* el_pt =</div>
<div class="line">      <span class="keyword">new</span> ElasticLineVolumeConstraintBoundingElement&lt;ELEMENT&gt;(</div>
<div class="line">       bulk_elem_pt,face_index);   </div>
<div class="line">     </div>
<div class="line">     <span class="comment">//Set the &quot;master&quot; volume constraint element</span></div>
<div class="line">     el_pt-&gt;set_volume_constraint_element(Vol_constraint_el_pt);</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Add it to the mesh</span></div>
<div class="line">     Volume_constraint_mesh_pt-&gt;add_element_pt(el_pt);     </div>
<div class="line">    } </div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="comment">// end of create_volume_constraint_elements</span></div>
<div class="ttc" id="aclassBubbleInChannelProblem_html_ae1ab79ef810211e337127878876c0fa6"><div class="ttname"><a href="classBubbleInChannelProblem.html#ae1ab79ef810211e337127878876c0fa6">BubbleInChannelProblem::create_volume_constraint_elements</a></div><div class="ttdeci">void create_volume_constraint_elements()</div><div class="ttdoc">Create elements that impose volume constraint on the bubble.</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l00958">adaptive_bubble_in_channel.cc:958</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="doc"></a>
Post-processing</h1>
<p>This member function documents the computed solution after every Newton solve.</p>
<div class="fragment"><div class="line"><span class="comment">//==start_of_doc_solution=================================================</span></div>
<div class="line"><span class="comment">/// Doc the solution</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classBubbleInChannelProblem.html#a6a68ee06024107d7b3f92059365a06d1">BubbleInChannelProblem&lt;ELEMENT&gt;::doc_solution</a>(<span class="keyword">const</span> std::string&amp; comment)</div>
<div class="line">{ </div>
<div class="line"> oomph_info &lt;&lt; <span class="stringliteral">&quot;Docing step: &quot;</span> &lt;&lt; <a class="code" href="namespaceProblem__Parameter.html#a1dd3c6bcf97360c8fe0d288ca7610351">Problem_Parameter::Doc_info</a>.number()</div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> ofstream some_file;</div>
<div class="line"> <span class="keywordtype">char</span> filename[100];</div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/soln%i.dat&quot;</span>,</div>
<div class="line">         <a class="code" href="namespaceProblem__Parameter.html#a1dd3c6bcf97360c8fe0d288ca7610351">Problem_Parameter::Doc_info</a>.directory().c_str(),</div>
<div class="line">         <a class="code" href="namespaceProblem__Parameter.html#a1dd3c6bcf97360c8fe0d288ca7610351">Problem_Parameter::Doc_info</a>.number());</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Number of plot points</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> npts;</div>
<div class="line"> npts=5; </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Compute errors and assign to each element for plotting</span></div>
<div class="line"> <span class="keywordtype">double</span> max_err;</div>
<div class="line"> <span class="keywordtype">double</span> min_err;</div>
<div class="line"> compute_error_estimate(max_err,min_err);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Assemble square of L2 norm </span></div>
<div class="line"> <span class="keywordtype">double</span> square_of_l2_norm=0.0;</div>
<div class="line"> <span class="keywordtype">unsigned</span> nel=Fluid_mesh_pt-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> e=0;e&lt;nel;e++)</div>
<div class="line">  {</div>
<div class="line">   square_of_l2_norm+=</div>
<div class="line">    <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(this-&gt;Fluid_mesh_pt-&gt;element_pt(e))-&gt;</div>
<div class="line">    square_of_l2_norm();</div>
<div class="line">  }</div>
<div class="line"> <a class="code" href="namespaceProblem__Parameter.html#a388e06a5e637b21378ab1832e5564bec">Problem_Parameter::Norm_file</a> &lt;&lt; sqrt(square_of_l2_norm) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> some_file &lt;&lt; dynamic_cast&lt;ELEMENT*&gt;(this-&gt;Fluid_mesh_pt-&gt;element_pt(0))</div>
<div class="line">  -&gt;variable_identifier();</div>
<div class="line"> this-&gt;Fluid_mesh_pt-&gt;output(some_file,npts);   </div>
<div class="line"> some_file &lt;&lt; <span class="stringliteral">&quot;TEXT X = 25, Y = 78, CS=FRAME T = \&quot;Global Step &quot;</span> </div>
<div class="line">           &lt;&lt; <a class="code" href="namespaceProblem__Parameter.html#a1dd3c6bcf97360c8fe0d288ca7610351">Problem_Parameter::Doc_info</a>.number() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> </div>
<div class="line">           &lt;&lt; comment &lt;&lt; <span class="stringliteral">&quot;\&quot;\n&quot;</span>;</div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output boundaries</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/boundaries%i.dat&quot;</span>,</div>
<div class="line">         <a class="code" href="namespaceProblem__Parameter.html#a1dd3c6bcf97360c8fe0d288ca7610351">Problem_Parameter::Doc_info</a>.directory().c_str(),</div>
<div class="line">         <a class="code" href="namespaceProblem__Parameter.html#a1dd3c6bcf97360c8fe0d288ca7610351">Problem_Parameter::Doc_info</a>.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> this-&gt;Fluid_mesh_pt-&gt;output_boundaries(some_file);</div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Get max/min area</span></div>
<div class="line"> <span class="keywordtype">double</span> max_area;</div>
<div class="line"> <span class="keywordtype">double</span> min_area;</div>
<div class="line"> Fluid_mesh_pt-&gt;max_and_min_element_size(max_area, min_area);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Get total volume enclosed by face elements (ignore first one)</span></div>
<div class="line"> <span class="keywordtype">double</span> vol=0.0;</div>
<div class="line"> vol=<a class="code" href="namespaceProblem__Parameter.html#aad8e0a2d1ec39a8dd7357a43bcc5f20e">Problem_Parameter::Volume</a>;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Write trace file</span></div>
<div class="line"> <a class="code" href="namespaceProblem__Parameter.html#a55310be5f2dfcb5fcfe35d71f9c16e06">Problem_Parameter::Trace_file</a> </div>
<div class="line">  &lt;&lt; this-&gt;time_pt()-&gt;time() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div>
<div class="line">  &lt;&lt; Fluid_mesh_pt-&gt;nelement() &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">  &lt;&lt; max_area &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">  &lt;&lt; min_area &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">  &lt;&lt; max_err &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">  &lt;&lt; min_err &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">  &lt;&lt; sqrt(square_of_l2_norm) &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">  &lt;&lt; vol &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">  &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Increment the doc_info number</span></div>
<div class="line"> <a class="code" href="namespaceProblem__Parameter.html#a1dd3c6bcf97360c8fe0d288ca7610351">Problem_Parameter::Doc_info</a>.number()++;</div>
<div class="line"> </div>
<div class="line">} <span class="comment">//end_of_doc_solution</span></div>
<div class="ttc" id="aclassBubbleInChannelProblem_html_a6a68ee06024107d7b3f92059365a06d1"><div class="ttname"><a href="classBubbleInChannelProblem.html#a6a68ee06024107d7b3f92059365a06d1">BubbleInChannelProblem::doc_solution</a></div><div class="ttdeci">void doc_solution(const std::string &amp;comment=&quot;&quot;)</div><div class="ttdoc">Doc the solution.</div><div class="ttdef"><b>Definition:</b> <a href="adaptive__bubble__in__channel_8cc_source.html#l01156">adaptive_bubble_in_channel.cc:1156</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="comments"></a>
Comments and Exercises</h1>
<h2><a class="anchor" id="adapt"></a>
Mesh adaptation for problems with 'closed' free boundaries</h2>
<p>We described <a href="../../../meshes/mesh_from_inline_triangle/html/index.html">in another tutorial</a> how <code>oomph-lib</code> employs a two-stage process for the (re-)generation of unstructured meshes in domains whose curvilinear boundaries are represented by <code>GeomObjects:</code> we initially sample the <code>GeomObject</code> at a user-specified number of points (equally spaced along the relevant section of the <code>GeomObject</code>) to create the vertices for an initial polygonal representation of the curvilinear boundary. This polygonal boundary representation is used to generate a new mesh with <code>Triangle</code>. The nodes on the domain boundaries are then "snapped" onto the curvilinear boundaries where required.</p>
<p>In principle, the same methodology can be (and is) employed for the mesh regeneration in free-surface problems. However, in a free-surface problem the curvilinear boundary evolves freely as part of the solution and is therefore not described by a user-specified <code>GeomObject</code>. When re-generating the mesh we therefore create a temporary <code>GeomObject</code> by attaching <code>FaceElements</code> to the relevant mesh boundaries of the existing mesh. We then use the vertices of the face elements to create a polyline representation of the boundary. This is illustrated in the figure below which shows part of the original mesh (the nodes and triangular elements adjacent to the boundary) in black. The blue lines represent the <code>FaceElements</code> that are erected on the current curvilinear domain boundary (as defined by the boundaries of the "bulk" elements). The vertices of these <code>FaceElements</code> (red hollow circles) provide the vertices for the polyline representation of the boundary (red line).</p>
<div class="image">
<img src="remesh_1.gif" alt=""/>
<div class="caption">
Sketch illustrating the generation of a polyline along the curvilinear domain boundary. </div></div>
 <p>Using this polyline representation of the boundary, a new mesh is built using <code>Triangle</code>. Depending on the target areas specified by the spatial error estimator, <code>Triangle</code> may erect multiple elements along each polyline segment. For instance in the figure below three elements have been created along the polyline segment created from <code>FaceElement</code> 3 in the original mesh.</p>
<div class="image">
<img src="remesh_2.gif" alt=""/>
<div class="caption">
Sketch showing the new mesh generated by Triangle, using (i) the polygonal representation of the boundary and (ii) the area targets provided by the spatial error estimator. </div></div>
 <p>Next, the boundary coordinates are set up and the nodes are snapped onto the curvilinear boundary that is still defined by the <code>FaceElements</code> that were attached to the original mesh, as shown below.</p>
<div class="image">
<img src="remesh_3.gif" alt=""/>
<div class="caption">
Sketch showing the mesh following the snapping of nodes to the curvilinear boundary. </div></div>
 <p><br  />
 <br  />
 <br  />
 </p><center> <table border="1," width="500px">
<tr>
<td bgcolor="cornsilk"><center> <b>IMPORTANT:</b> <br  />
Note that the initial shape of moving free boundaries <b>must</b> <b>not</b> be described by <code>TriangleMeshCurviLines</code>. While the use of <code>TriangleMeshCurviLines</code> would ensure that the nodes are initially located exactly on the curvilinear boundary described by the associated <code>GeomObject</code> without having to "snap" them to their desired position, a problem arises when the mesh is adapted. When this happens, nodes on curvilinear boundaries that are described by <code>TriangleMeshCurviLines</code> are placed on the (presumably unchanged) geometry defined by the associated <code>GeomObject</code> rather than being placed on the deformed boundary as described above &ndash; the free surface therefore keeps jumping back to its initial position whenever the mesh is adapted which is unlikely to be desired! </center>   </td></tr>
</table>
</center><h2><a class="anchor" id="issues"></a>
Modifications to the basic mesh re-generation procedure</h2>
<p>The procedure described above is very robust and works satisfactorily in the example problem discussed in this tutorial. Below we discuss a a few optional modifications to the mesh regeneration procedure that are helpful to deal with complications that can arise in certain circumstances:</p>
<h3><a class="anchor" id="unrefinement"></a>
Unrefinement of polylines</h3>
<p>As discussed above, <code>Triangle</code> generates a new mesh, based on (i) the polygonal representation of the boundary and (ii) the area targets provided by the spatial error estimator for the bulk elements. The polygonal boundary representation defines the minimum number of bulk elements that are generated next to the boundary &ndash; we showed above how multiple elements can be erected on a given boundary segment. However, since <code>Triangle</code> never merges any boundary segments this procedure can result in unnecessarily fine meshes near the boundary: once the bulk mesh has been refined to a certain level, the polygonal boundary representation cannot be coarsened, even if the spatial error estimator would allow much larger elements to be created at a later stage of the simulation.</p>
<p>We therefore provide the option to coarsen the polygonal boundary representation following its creation from the <code>FaceElements</code> that are attached to the current mesh. This is done by assessing if the (geometrical) boundary representation is unnecessarily fine, judged by how close any three adjacent vertices are to a straight line. This is illustrated in the sketch below: To assess if the middle vertex can be deleted, we determine the height of a circular segment connecting the three vertices. If the ratio of this height, <img class="formulaInl" alt="$ d $" src="form_34.png" width="6" height="10"/> , to the distance <img class="formulaInl" alt="$ l $" src="form_35.png" width="4" height="10"/> between the two outer vertices is less than a user-defined tolerance (i.e. if the local curvature is so small that the middle vertex is not required to represent the boundary sufficiently accurately), the middle vertex is deleted.</p>
<div class="image">
<img src="unrefinement.gif" alt=""/>
<div class="caption">
Sketch illustrating the criterion for the unrefinement of polylines. </div></div>
 <p>The tolerance for the unrefinement of polygons is set by the function</p>
<div class="fragment"><div class="line">TriangleMesh::set_polyline_unrefinement_tolerance(...)</div>
</div><!-- fragment --><p>By default we allow polyline unrefinement (with a default tolerance of 0.04). Polyline unrefinement can be disabled by calling</p>
<div class="fragment"><div class="line">TriangleMesh::disable_polyline_unrefinement()</div>
</div><!-- fragment --><p>where <code>TriangleMesh</code> is a base for the <code>TriangleMeshClosedCurve</code> class.</p>
<h3><a class="anchor" id="refinement"></a>
Refinement of polylines</h3>
<p>It is also possible that the free surface deforms in such a way that the polyline representation of the domain boundary becomes too inaccurate, e.g. because the representation of the solution only requires fairly large elements. Even though large elements may be sufficient to represent the solution, the mesh-regeneration tends to fail when "snapping" the nodes onto the highly-curved curvilinear boundary (typically because elements near the boundary become highly distorted or even inverted).</p>
<p>We therefore provide the option to refine the polygonal representation of the boundary employing a criterion similar to the one used for unrefinement discussed above. To assess the need for a boundary refinement we consider each boundary segment and compute the distance from segment's mid-point to its counterpart on the curvilinear boundary. If the ratio of the distance between these points, <img class="formulaInl" alt="$ d $" src="form_34.png" width="6" height="10"/>, to the length of the segment connecting the vertices, <img class="formulaInl" alt="$ l $" src="form_35.png" width="4" height="10"/>, is larger than a user-specifiable tolerance, the point on the curvilinear boundary becomes an additional vertex of the polyline and the original segment is split into two as illustrated in the figure below:</p>
<div class="image">
<img src="refinement.gif" alt=""/>
<div class="caption">
Sketch illustrating the criterion for the refinement of polylines. </div></div>
 <p>The tolerance for the refinement of polygons is set by the function</p>
<div class="fragment"><div class="line">TriangleMesh::set_polyline_refinement_tolerance(...)</div>
</div><!-- fragment --><p>By default we allow polyline refinement (with a default tolerance of 0.08). Polyline refinement can be disabled by calling</p>
<div class="fragment"><div class="line">TriangleMesh::disable_polyline_refinement()</div>
</div><!-- fragment --><h3><a class="anchor" id="redistribution"></a>
Redistribution of segments between polylines</h3>
<p>The kinematic boundary condition (5) determines only the normal displacement of the boundary, hence the tangential displacement of nodes on the boundary is not controlled directly. It is therefore possible that nodes move along the perimeter of the curvilinear boundary and, as a result, one polyline may become much shorter than the others, as illustrated in the transition from a) to b) in the figure below. This is clearly undesirable and can be avoided by redistributing the vertices/segment between the polygon's constituent polylines such that each polyline spans an approximately equal fraction of the polygon's overall perimeter. This process is illustrated in b) and c) in the figure below. Note that the redistribution of segments does not change the shape of the polygonal boundary but merely the way in which it is represented in terms of polylines.</p>
<div class="image">
<img src="redistribution.gif" alt=""/>
<div class="caption">
Sketch illustrating the optional redistribution of polyline segments. </div></div>
 <p>We provide the option to perform this step immediately after the generation of the updated polyline representation for the curvilinear boundary (and before the boundary refinement/unrefinement discussed above). Given that each polyline represents a distinct mesh boundary, the redistribution of segments between different polylines moves nodes from one boundary to another and, in general, this is clearly undesirable. Therefore, the redistribution of segments is is deactivated by default and must be activated by calling the function</p>
<div class="fragment"><div class="line">TriangleMeshPolygon::enable_redistribution_of_segments_between_polylines()</div>
</div><!-- fragment --><p>Note that the redistribution of segments is not possible/sensible for <code>TriangleMeshClosedCurve</code> formed by <code>TriangleMeshCurviLines</code> since such boundaries are associated with a specific, continuous <code>GeomObject</code> with specific start/end coordinates.</p>
<hr  />
<h2><a class="anchor" id="exercises"></a>
Exercises</h2>
<ol type="1">
<li>As discussed above, we start the simulation by performing an initial steady Newton solve during which we deform the polygonal boundary that represents the air-liquid interface into its static equilibrium shape &ndash; a circle enclosing the required volume. This may seem like a rather costly way of creating a circular interface. Why not simply move the nodes on that boundary manually to their "correct" positions by adjusting their radial positions after returning from the mesh constructor? To explore this question, snap the required nodes manually onto the circular boundary and call the steady Newton solver. Why is the initial residual not equal to zero, even though we have manually assigned the correct solution as an initial guess? <br  />
</li>
<li>Comment out <code>create_volume_constraint_elements()</code> and <code>delete_volume_constraint_elements()</code> throughout the code and explain what happens.</li>
<li>Experiment with the refinement/unrefinement of polylines and explore the option to re-distribute segments between the polylines that define the boundaries of the bubble. Specifically, change the initial polygonal representation the bubble surface such that the first <code>TriangleMeshPolyLine</code> only represents 1/4 of the perimeter while the second one represents the remaining 3/4. Confirm that, following the mesh adaptation, the bubble boundaries are adjusted such that each boundary occupies approximately 1/2 of the bubble surface when the redistribution of polylines is enabled.</li>
</ol>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory: <center> <a href="../../../../demo_drivers/navier_stokes/unstructured_adaptive_fs/">demo_drivers/navier_stokes/unstructured_adaptive_fs/ </a> </center></li>
<li>The driver code is: <center> <a href="../../../../demo_drivers/navier_stokes/unstructured_adaptive_fs/adaptive_bubble_in_channel.cc">demo_drivers/navier_stokes/unstructured_adaptive_fs/adaptive_bubble_in_channel.cc</a> </center> .</li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:17:03
        </div>
      </div>
    </footer>
</body>
</html>
