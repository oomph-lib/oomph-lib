<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Inline mesh generation and adaptation based on Triangle</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Inline mesh generation and adaptation based on Triangle </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this document we demonstrate how to generate unstructured 2D meshes for <code>oomph-lib</code>, using <a href="http://www.cs.berkeley.edu/~jrs/">Jonathan Shewchuk's</a> <a href="http://www.cs.cmu.edu/~quake/triangle.html">Triangle</a> library from within an <code>oomph-lib</code> driver code. This complements the discussion in <a href="../../../../doc/meshes/mesh_from_triangle/html/index.html">another tutorial</a> where we illustrated how to build <code>oomph-lib</code> meshes using the output generated when <a href="http://www.cs.cmu.edu/~quake/triangle.html"><code>Triangle</code> </a> is used to create the mesh externally.</p>
<p>In addition, we demonstrate</p><ul>
<li>how to create meshes with polygonal or curvilinear boundaries</li>
</ul>
<p>and</p><ul>
<li>how to adapt (re-generate) these meshes based on spatial error estimates.</li>
</ul>
<p>Here we restrict ourselves to the solution of problems in fixed domains. Other tutorials discuss more advanced applications involving moving meshes, e.g.</p><ul>
<li><a href="../../../../doc/navier_stokes/jeffery_orbit/html/index.html">The motion of an ellipse in a shear flow</a> <br  />
<br  />
</li>
<li><a href="../../../../doc/navier_stokes/adaptive_bubble_in_channel/html/index.html">The propagation of a bubble in a channel &ndash; mesh generation and adaptation for free-surface flows.</a> <br  />
<br  />
</li>
</ul>
<hr  />
 <hr  />
<h1><a class="anchor" id="overview"></a>
Overview of mesh generation procedures</h1>
<h2><a class="anchor" id="polygonal"></a>
Meshes with polygonal boundaries</h2>
<p>If the domain has polygonal outer (and possibly internal) boundaries, the mesh generation process follows a similar pattern to that required in the external use of <a href="http://www.cs.cmu.edu/~quake/triangle.html"><code>Triangle</code> </a>, but using <code>oomph-lib</code> classes to represent the required data. We define the polygonal boundaries using <code>TriangleMeshPolyLines</code>, which represent distinct mesh boundaries and are defined by a series of vertex coordinates. Multiple <code>TriangleMeshPolyLines</code> can be combined to define (closed) <code>TriangleMeshPolygons</code>. These are then used to create an unstructured mesh with a pre-determined target area for all elements, via an interface to <a href="http://www.cs.cmu.edu/~quake/triangle.html"><code>Triangle</code> </a>.</p>
<p>One particular feature of <code>oomph-lib's</code> interface to <a href="http://www.cs.cmu.edu/~quake/triangle.html"><code>Triangle</code> </a> is that each closed <code>TriangleMeshPolygon</code> must contain at least two distinct <code>TriangleMeshPolyLines</code>, each with its own boundary ID. This is because every <code>Node</code> can only have a single-valued boundary coordinate but if the boundary is closed there would be a discontinuity in the coordinate value. (For example, a standard representation would have <img class="formulaInl" alt="$ \zeta = [0,2\pi] $" src="form_0.png" width="54" height="14"/> , but the node at <img class="formulaInl" alt="$\zeta=0$" src="form_1.png" width="29" height="13"/> should also have <img class="formulaInl" alt="$ \zeta=2\pi $" src="form_2.png" width="36" height="13"/> and this is not possible.) The sketch below shows a representative domain as well as two legal and one illegal representations of the domain boundaries. Note that the boundaries can be enumerated in an arbitrary fashion.</p>
<div class="image">
<img src="polygonal_mesh.gif" alt=""/>
<div class="caption">
Sketch of a polygonal domain (top) and two legal (bottom left and middle) and one illegal (bottom right) representations of the boundaries in terms of TriangleMeshPolyLines. </div></div>
 <hr  />
<h2><a class="anchor" id="curvilinear"></a>
Meshes with curvilinear boundaries</h2>
<p>It is also possible to discretise domains with curvilinear boundaries as shown in the sketch below. Assuming that each curvilinear boundary is represented by a <code>GeomObject</code> that specifies the position vector <img class="formulaInl" alt="$ {\bf R}(\zeta) $" src="form_3.png" width="28" height="14"/> to a point on the curvilinear boundary as a function of some surface coordinate <img class="formulaInl" alt="$ \zeta $" src="form_4.png" width="6" height="13"/>, we split each closed boundary into (at least) two distinct <code>TriangleMeshCurviLines</code> &ndash; the curvilinear equivalents of <code>TriangleMeshPolyLines</code>. Each <code>TriangleMeshCurviLine</code> is constructed from a pointer to the <code>GeomObject</code> and the start and end values of the boundary coordinate <img class="formulaInl" alt="$ \zeta $" src="form_4.png" width="6" height="13"/> along the relevant part of the curvilinear boundary. The <code>TriangleMeshCurviLines</code> are then combined to a <code>TriangleMeshClosedCurve</code> &ndash; the general closed curve.</p>
<div class="image">
<img src="curvilinear_mesh.gif" alt=""/>
<div class="caption">
Sketch of a domain bounded by a curvilinear boundary, containing two holes with curvilinear (hole 1) and polygonal (hole 2) boundaries, respectively. </div></div>
 <p>The mesh is then created in a two-stage process: All <code>TriangleMeshCurviLines</code> are sampled at a certain number of points (specified by the user in the constructor) to create the vertices for a polyline representation of the boundary. This polygonal representation of the boundaries is used by <code>Triangle</code> to generate the mesh. Finally, nodes on curvilinear boundaries are "snapped" onto the actual curvilinear boundary.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="adapt"></a>
Overview of mesh adaptation methodology</h1>
<p>The methodology employed to adapt <code>oomph-lib's</code> unstructured meshes differs from that used for structured meshes. Specifically, rather than sub-dividing elements in which the error estimate exceeds a threshold and merging elements in which the solution is "too accurate", we completely re-generate the mesh and project the solution from the old to the new mesh. This is because we originally developed the underlying methodology to solve free-boundary problems in which the domain undergoes such large deformations that re-meshing is required. The ability to adjust the element sizes guided by spatial error estimates when re-meshing the domain is a simple fringe benefit.</p>
<p>A number of issues are important:</p><ul>
<li>To facilitate mesh adaptation in free-boundary problems, we re-generate the polygonal representation of the boundary, using the vertex nodes of the elements on the boundary to re-define the polygon. The number of vertices in the polygons that define the mesh boundaries will therefore generally change during the mesh adaptation process. This is discussed in more detail in <a href="../../../../doc/navier_stokes/adaptive_bubble_in_channel/html/index.html#adapt">another tutorial.</a><br  />
<br  />
</li>
<li>The mesh (and thus its constituent elements) are completely re-generated when the mesh is adapted, and so it is necessary to "complete
  the build" of all elements after each mesh adaptation. For instance, pointers to problem parameters (Reynolds numbers, source functions, etc) must be re-set after the adaptation since they cannot (easily) be passed from the old to the new mesh. <br  />
<br  />
</li>
<li>When projecting the solution from the old to the new mesh, we project <br  />
<br  />
<ul>
<li>all unknowns and their associated history values (if any) <br  />
<br  />
</li>
<li>the history values of the nodal positions. This is important for moving mesh problems where the mesh velocity is required to evaluate the ALE time-derivatives.</li>
</ul>
</li>
</ul>
<p><br  />
<br  />
</p><ul>
<li>The ability to automatically project the solution from the old to the new mesh requires the elements, of type <code>ELEMENT</code>, say, to be wrapped in the templated <code>ProjectableElement&lt;ELEMENT&gt;</code> class. This class requires the specification of various element characteristics (such as the number of fields to be projected, the number of history values, etc) in the form of virtual functions. This is much more straightforward than upgrading an existing element to become a refineable element for use in an adaptive computation on a structured mesh because the "mesh adaptation by mesh re-generation" avoids the creation of hanging nodes. See the section <a class="el" href="index.html#wrapper">Upgrading elements to become "projectable"</a> for a slightly more detailed discussion of this aspect. <br  />
 <br  />
<br  />
</li>
<li>Note that we do <b>not</b> apply any boundary conditions during the projection of these fields. This decision was not taken out of laziness but because the interfaces required to specify which boundary conditions to enforce and which ones to relax during the projection were too unwieldy. It is therefore <b>important</b> to re-apply boundary conditions and boundary values after each adaptation. <br  />
<br  />
</li>
</ul>
<p>We recommend using the <code>Problem::actions_after_adapt()</code> function to re-assign boundary conditions and to complete the build of all elements after the adaptation.</p>
<p>Apart from these issues, the user interfaces to the mesh adaptation functions are exactly the same as for structured meshes. Specifically, it is possible to specify maximum and minimum element sizes and target values for the error such that the mesh is refined in regions where the error estimate is <code>too large'' and unrefined where it is </code>too small''.</p>
<p>Typically, the most computationally expensive stage of the mesh regeneration procedure is the multi-domain setup procedure which identifies corresponding points in the old and new meshes. In "cheap" problems, such as the Poisson problem discussed below, the cost of the mesh regeneration can exceed the cost of the subsequent solve, but in most "hard" problems (such as the ones listed at the beginning of this tutorial) the cost of the mesh regeneration is modest (and, in the case of large-displacement free-boundary problems, unavoidable anyway).</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="example"></a>
An example: The adaptive solution of Poisson's equations on an unstructured mesh</h1>
<p>As an example we consider the adaptive solution of Poisson's equation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial^2 u}{\partial x_i^2} = f(x_1,x_2) \]" src="form_5.png" width="86" height="33"/>
</p>
<p> in a circular domain that contains an elliptical and a polygonal hole. As in many previous examples, we apply Dirichlet boundary conditions on all domain boundaries and choose the boundary values and the source function <img class="formulaInl" alt="$ f(x_1,x_2) $" src="form_6.png" width="48" height="14"/> such that the exact solution of the problem is given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u(x_1,x_2) = \tanh(1-\alpha(x_1 \tan\Phi - x_2)), \]" src="form_7.png" width="214" height="14"/>
</p>
<p> which approaches a step function, oriented at an angle <img class="formulaInl" alt="$ \Phi $" src="form_8.png" width="9" height="10"/> within the <img class="formulaInl" alt="$ (x_1,x_2) $" src="form_9.png" width="40" height="14"/> plane, as <img class="formulaInl" alt="$ \alpha $" src="form_10.png" width="8" height="6"/> becomes large. The figure below shows contour plots of the solution for <img class="formulaInl" alt="$ \alpha = 5 $" src="form_11.png" width="30" height="9"/> for various angles <img class="formulaInl" alt="$ \Phi $" src="form_8.png" width="9" height="10"/>. It illustrates how the mesh adaptation adjusts the mesh such the smallest elements are located in the region where the solution undergoes rapid change.</p>
<div class="image">
<img src="solution.gif" alt=""/>
<div class="caption">
Contour plot of the solution. </div></div>
 <hr  />
 <hr  />
<h1><a class="anchor" id="global"></a>
Global parameters and functions</h1>
<p>Following our usual practice, we use a namespace to define the source function and the exact solution.  </p><div class="fragment"><div class="line"><span class="comment">//===== start_of_namespace=============================================</span></div>
<div class="line"><span class="comment">/// Namespace for exact solution for Poisson equation with &quot;sharp step&quot; </span></div>
<div class="line"><span class="comment"></span><span class="comment">//=====================================================================</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceTanhSolnForPoisson.html">TanhSolnForPoisson</a></div>
<div class="line">{</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Parameter for steepness of &quot;step&quot;</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceTanhSolnForPoisson.html#ae676ccd186d5df119cce811596d949c1">Alpha</a>=5.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Parameter for angle Phi of &quot;step&quot;</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceTanhSolnForPoisson.html#a785ccd00a727125a5138fbbcac173294">TanPhi</a>=0.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Exact solution as a Vector</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceTanhSolnForPoisson.html#af7896e9c18ce6438c73ae2a875e8b7de">get_exact_u</a>(<span class="keyword">const</span> Vector&lt;double&gt;&amp; x, Vector&lt;double&gt;&amp; u)</div>
<div class="line"> {</div>
<div class="line">  u[0]=tanh(1.0-<a class="code" href="namespaceTanhSolnForPoisson.html#ae676ccd186d5df119cce811596d949c1">Alpha</a>*(<a class="code" href="namespaceTanhSolnForPoisson.html#a785ccd00a727125a5138fbbcac173294">TanPhi</a>*x[0]-x[1]));</div>
<div class="line"> }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Source function required to make the solution above an exact solution </span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceTanhSolnForPoisson.html#ae1b9d6789ff301e3d63a4e292213036c">get_source</a>(<span class="keyword">const</span> Vector&lt;double&gt;&amp; x, <span class="keywordtype">double</span>&amp; source)</div>
<div class="line"> {</div>
<div class="line">  source = 2.0*tanh(-1.0+<a class="code" href="namespaceTanhSolnForPoisson.html#ae676ccd186d5df119cce811596d949c1">Alpha</a>*(<a class="code" href="namespaceTanhSolnForPoisson.html#a785ccd00a727125a5138fbbcac173294">TanPhi</a>*x[0]-x[1]))*</div>
<div class="line">   (1.0-pow(tanh(-1.0+<a class="code" href="namespaceTanhSolnForPoisson.html#ae676ccd186d5df119cce811596d949c1">Alpha</a>*(<a class="code" href="namespaceTanhSolnForPoisson.html#a785ccd00a727125a5138fbbcac173294">TanPhi</a>*x[0]-x[1])),2.0))*</div>
<div class="line">   <a class="code" href="namespaceTanhSolnForPoisson.html#ae676ccd186d5df119cce811596d949c1">Alpha</a>*<a class="code" href="namespaceTanhSolnForPoisson.html#ae676ccd186d5df119cce811596d949c1">Alpha</a>*<a class="code" href="namespaceTanhSolnForPoisson.html#a785ccd00a727125a5138fbbcac173294">TanPhi</a>*<a class="code" href="namespaceTanhSolnForPoisson.html#a785ccd00a727125a5138fbbcac173294">TanPhi</a>+2.0*tanh(-1.0+<a class="code" href="namespaceTanhSolnForPoisson.html#ae676ccd186d5df119cce811596d949c1">Alpha</a>*(<a class="code" href="namespaceTanhSolnForPoisson.html#a785ccd00a727125a5138fbbcac173294">TanPhi</a>*x[0]-x[1]))*</div>
<div class="line">   (1.0-pow(tanh(-1.0+<a class="code" href="namespaceTanhSolnForPoisson.html#ae676ccd186d5df119cce811596d949c1">Alpha</a>*(<a class="code" href="namespaceTanhSolnForPoisson.html#a785ccd00a727125a5138fbbcac173294">TanPhi</a>*x[0]-x[1])),2.0))*<a class="code" href="namespaceTanhSolnForPoisson.html#ae676ccd186d5df119cce811596d949c1">Alpha</a>*<a class="code" href="namespaceTanhSolnForPoisson.html#ae676ccd186d5df119cce811596d949c1">Alpha</a>;</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Zero function -- used to compute norm of the computed solution by </span></div>
<div class="line"><span class="comment"> /// computing the norm of the error when compared against this.</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceTanhSolnForPoisson.html#a5cd8441c6e87d4bc153697eff13513dd">zero</a>(<span class="keyword">const</span> Vector&lt;double&gt;&amp; x, Vector&lt;double&gt;&amp; u)</div>
<div class="line"> {</div>
<div class="line">  u[0]=0.0;</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of namespace</span></div>
<div class="ttc" id="anamespaceTanhSolnForPoisson_html"><div class="ttname"><a href="namespaceTanhSolnForPoisson.html">TanhSolnForPoisson</a></div><div class="ttdoc">Namespace for exact solution for Poisson equation with &quot;sharp step&quot;.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00045">mesh_from_inline_triangle.cc:46</a></div></div>
<div class="ttc" id="anamespaceTanhSolnForPoisson_html_a5cd8441c6e87d4bc153697eff13513dd"><div class="ttname"><a href="namespaceTanhSolnForPoisson.html#a5cd8441c6e87d4bc153697eff13513dd">TanhSolnForPoisson::zero</a></div><div class="ttdeci">void zero(const Vector&lt; double &gt; &amp;x, Vector&lt; double &gt; &amp;u)</div><div class="ttdoc">Zero function – used to compute norm of the computed solution by computing the norm of the error when...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00072">mesh_from_inline_triangle.cc:72</a></div></div>
<div class="ttc" id="anamespaceTanhSolnForPoisson_html_a785ccd00a727125a5138fbbcac173294"><div class="ttname"><a href="namespaceTanhSolnForPoisson.html#a785ccd00a727125a5138fbbcac173294">TanhSolnForPoisson::TanPhi</a></div><div class="ttdeci">double TanPhi</div><div class="ttdoc">Parameter for angle Phi of &quot;step&quot;.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00052">mesh_from_inline_triangle.cc:52</a></div></div>
<div class="ttc" id="anamespaceTanhSolnForPoisson_html_ae1b9d6789ff301e3d63a4e292213036c"><div class="ttname"><a href="namespaceTanhSolnForPoisson.html#ae1b9d6789ff301e3d63a4e292213036c">TanhSolnForPoisson::get_source</a></div><div class="ttdeci">void get_source(const Vector&lt; double &gt; &amp;x, double &amp;source)</div><div class="ttdoc">Source function required to make the solution above an exact solution.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00061">mesh_from_inline_triangle.cc:61</a></div></div>
<div class="ttc" id="anamespaceTanhSolnForPoisson_html_ae676ccd186d5df119cce811596d949c1"><div class="ttname"><a href="namespaceTanhSolnForPoisson.html#ae676ccd186d5df119cce811596d949c1">TanhSolnForPoisson::Alpha</a></div><div class="ttdeci">double Alpha</div><div class="ttdoc">Parameter for steepness of &quot;step&quot;.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00049">mesh_from_inline_triangle.cc:49</a></div></div>
<div class="ttc" id="anamespaceTanhSolnForPoisson_html_af7896e9c18ce6438c73ae2a875e8b7de"><div class="ttname"><a href="namespaceTanhSolnForPoisson.html#af7896e9c18ce6438c73ae2a875e8b7de">TanhSolnForPoisson::get_exact_u</a></div><div class="ttdeci">void get_exact_u(const Vector&lt; double &gt; &amp;x, Vector&lt; double &gt; &amp;u)</div><div class="ttdoc">Exact solution as a Vector.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00055">mesh_from_inline_triangle.cc:55</a></div></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="main"></a>
The driver code</h1>
<p>We start by processing command line arguments which allow us to run the code in self-test mode and build the problem with "projectable" six-noded triangular Poisson elements.</p>
 <div class="fragment"><div class="line"><span class="comment">//=======start_of_main========================================</span></div>
<div class="line"><span class="comment">/// Driver code for demo of inline triangle mesh generation</span></div>
<div class="line"><span class="comment"></span><span class="comment">//============================================================</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="mesh__from__inline__triangle_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Store command line arguments</span></div>
<div class="line"> CommandLineArgs::setup(argc,argv);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Define possible command line arguments and parse the ones that</span></div>
<div class="line"> <span class="comment">// were actually specified</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Validation?</span></div>
<div class="line"> CommandLineArgs::specify_command_line_flag(<span class="stringliteral">&quot;--validation&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Parse command line</span></div>
<div class="line"> CommandLineArgs::parse_and_assign(); </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Doc what has actually been specified on the command line</span></div>
<div class="line"> CommandLineArgs::doc_specified_flags();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create problem</span></div>
<div class="line"> <a class="code" href="classUnstructuredPoissonProblem.html">UnstructuredPoissonProblem&lt;ProjectablePoissonElement&lt;TPoissonElement&lt;2,3&gt;</a> &gt; &gt;</div>
<div class="line">  problem;</div>
<div class="ttc" id="aclassUnstructuredPoissonProblem_html"><div class="ttname"><a href="classUnstructuredPoissonProblem.html">UnstructuredPoissonProblem</a></div><div class="ttdoc">//////////////////////////////////////////////////////// ////////////////////////////////////////////...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00090">mesh_from_inline_triangle.cc:91</a></div></div>
<div class="ttc" id="amesh__from__inline__triangle_8cc_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="mesh__from__inline__triangle_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdoc">Driver code for demo of inline triangle mesh generation.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00595">mesh_from_inline_triangle.cc:595</a></div></div>
</div><!-- fragment --><p>We then perform a parameter study, solving the problem for various orientations of the "step" and allowing a certain number of spatial adaptations per solve. (If the code is run in self-test mode, we perform fewer steps and allow for less adaptation to speed up the computation.)</p>
<div class="fragment"><div class="line"> <span class="comment">// Loop over orientation of step</span></div>
<div class="line"> <span class="comment">//==============================</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nstep=5;</div>
<div class="line"> <span class="keywordflow">if</span> (CommandLineArgs::command_line_flag_has_been_set(<span class="stringliteral">&quot;--validation&quot;</span>))</div>
<div class="line">  {</div>
<div class="line">   nstep=2;</div>
<div class="line">  }</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;nstep;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Solve with spatial adaptation</span></div>
<div class="line">   <span class="comment">//==============================</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> max_adapt=3;</div>
<div class="line">   <span class="keywordflow">if</span> (CommandLineArgs::command_line_flag_has_been_set(<span class="stringliteral">&quot;--validation&quot;</span>))</div>
<div class="line">    {</div>
<div class="line">     max_adapt=1;</div>
<div class="line">    }</div>
<div class="line">   problem.newton_solve(max_adapt);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Doc the solution</span></div>
<div class="line">   <span class="comment">//=================</span></div>
<div class="line">   std::stringstream comment_stream;</div>
<div class="line">   comment_stream &lt;&lt; <span class="stringliteral">&quot;Solution for tan(phi) = &quot;</span> &lt;&lt; <a class="code" href="namespaceTanhSolnForPoisson.html#a785ccd00a727125a5138fbbcac173294">TanhSolnForPoisson::TanPhi</a>; </div>
<div class="line">   problem.<a class="code" href="classUnstructuredPoissonProblem.html#a9b21a3c3f574da71411f852006fe2a0c">doc_solution</a>(comment_stream.str());</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Rotate orientation of solution</span></div>
<div class="line">   <a class="code" href="namespaceTanhSolnForPoisson.html#a785ccd00a727125a5138fbbcac173294">TanhSolnForPoisson::TanPhi</a>+=0.5;</div>
<div class="line">  }   </div>
<div class="line"> </div>
<div class="line">} <span class="comment">//End of main</span></div>
<div class="ttc" id="aclassUnstructuredPoissonProblem_html_a9b21a3c3f574da71411f852006fe2a0c"><div class="ttname"><a href="classUnstructuredPoissonProblem.html#a9b21a3c3f574da71411f852006fe2a0c">UnstructuredPoissonProblem::doc_solution</a></div><div class="ttdeci">void doc_solution(const std::string &amp;comment=&quot;&quot;)</div><div class="ttdoc">Doc the solution.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00536">mesh_from_inline_triangle.cc:536</a></div></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="problem"></a>
The problem class</h1>
<p>The problem class contains the usual member functions. As discussed above, the boundary conditions and the source function have to be re-specified after every mesh adaptation since the adapted mesh contains completely new elements. This is done in the function <code>complete_problem_setup()</code>, discussed below, which is called from the Problem constructor and from <code>actions_after_adapt()</code>. We re-assign the Dirichlet boundary conditions in <code>actions_before_newton_solve()</code>, using a second helper function <code>apply_boundary_conditions()</code>:</p>
 <div class="fragment"><div class="line"><span class="comment">//==start_of_problem_class============================================</span></div>
<div class="line"><span class="comment">/// Class definition</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classUnstructuredPoissonProblem.html">UnstructuredPoissonProblem</a> : <span class="keyword">public</span> <span class="keyword">virtual</span> Problem</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Constructor</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classUnstructuredPoissonProblem.html#a26e7610a714aea17c9278beec4842371">UnstructuredPoissonProblem</a>();</div>
<div class="line">    <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Destructor</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classUnstructuredPoissonProblem.html#aeae85592e36ba7be6b4891fb49d2197b">~UnstructuredPoissonProblem</a>(){};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Actions before adapt. Empty</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classUnstructuredPoissonProblem.html#ac9627efd3c311156e5347ed37d4ea4b0">actions_before_adapt</a>() {}</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Actions after adapt: </span></div>
<div class="line"><span class="comment"> /// Setup the problem again -- remember that the mesh has been</span></div>
<div class="line"><span class="comment"> /// completely rebuilt and its element&#39;s don&#39;t have any</span></div>
<div class="line"><span class="comment"> /// pointers to source fcts etc. yet</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classUnstructuredPoissonProblem.html#a6f3e089824cfbb4f458efd8c8ffd376d">actions_after_adapt</a>()</div>
<div class="line">  {</div>
<div class="line">   <a class="code" href="classUnstructuredPoissonProblem.html#a5cbf00790e8469b43c64c6aaadfe7b41">complete_problem_setup</a>();</div>
<div class="line">  }</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Update after solve (empty)</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classUnstructuredPoissonProblem.html#a822bd18e50ebeefd6d1c196fad7c0bf1">actions_after_newton_solve</a>(){}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Update the problem specs before solve: Re-apply boundary conditons</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classUnstructuredPoissonProblem.html#a2ab9d23c0e6e6631ffe1a761f6bdf026">actions_before_newton_solve</a>()</div>
<div class="line">  {</div>
<div class="line">   <a class="code" href="classUnstructuredPoissonProblem.html#ace8b8b3097ae2024a0589b2bf9b4ee7b">apply_boundary_conditions</a>();</div>
<div class="line">  }</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Doc the solution</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classUnstructuredPoissonProblem.html#a9b21a3c3f574da71411f852006fe2a0c">doc_solution</a>(<span class="keyword">const</span> std::string&amp; comment=<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Doc info object for labeling output</span></div>
<div class="line"><span class="comment"></span> DocInfo <a class="code" href="classUnstructuredPoissonProblem.html#a5c4c29b1c95cd63055e5aced124ca708">Doc_info</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Helper function to apply boundary conditions</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classUnstructuredPoissonProblem.html#ace8b8b3097ae2024a0589b2bf9b4ee7b">apply_boundary_conditions</a>();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Helper function to (re-)set boundary condition</span></div>
<div class="line"><span class="comment"> /// and complete the build of  all elements</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classUnstructuredPoissonProblem.html#a5cbf00790e8469b43c64c6aaadfe7b41">complete_problem_setup</a>();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointers to specific mesh</span></div>
<div class="line"><span class="comment"></span> RefineableTriangleMesh&lt;ELEMENT&gt;* <a class="code" href="classUnstructuredPoissonProblem.html#af95c713f5db16c288e307768b6bf9bb8">My_mesh_pt</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Trace file to document norm of solution</span></div>
<div class="line"><span class="comment"></span> ofstream <a class="code" href="classUnstructuredPoissonProblem.html#ac7fdb8fb9a886ced0ee7244890406d90">Trace_file</a>;</div>
<div class="line"> </div>
<div class="line">}; <span class="comment">// end_of_problem_class</span></div>
<div class="ttc" id="aclassUnstructuredPoissonProblem_html_a26e7610a714aea17c9278beec4842371"><div class="ttname"><a href="classUnstructuredPoissonProblem.html#a26e7610a714aea17c9278beec4842371">UnstructuredPoissonProblem::UnstructuredPoissonProblem</a></div><div class="ttdeci">UnstructuredPoissonProblem()</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00154">mesh_from_inline_triangle.cc:154</a></div></div>
<div class="ttc" id="aclassUnstructuredPoissonProblem_html_a2ab9d23c0e6e6631ffe1a761f6bdf026"><div class="ttname"><a href="classUnstructuredPoissonProblem.html#a2ab9d23c0e6e6631ffe1a761f6bdf026">UnstructuredPoissonProblem::actions_before_newton_solve</a></div><div class="ttdeci">void actions_before_newton_solve()</div><div class="ttdoc">Update the problem specs before solve: Re-apply boundary conditons.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00117">mesh_from_inline_triangle.cc:117</a></div></div>
<div class="ttc" id="aclassUnstructuredPoissonProblem_html_a5c4c29b1c95cd63055e5aced124ca708"><div class="ttname"><a href="classUnstructuredPoissonProblem.html#a5c4c29b1c95cd63055e5aced124ca708">UnstructuredPoissonProblem::Doc_info</a></div><div class="ttdeci">DocInfo Doc_info</div><div class="ttdoc">Doc info object for labeling output.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00129">mesh_from_inline_triangle.cc:129</a></div></div>
<div class="ttc" id="aclassUnstructuredPoissonProblem_html_a5cbf00790e8469b43c64c6aaadfe7b41"><div class="ttname"><a href="classUnstructuredPoissonProblem.html#a5cbf00790e8469b43c64c6aaadfe7b41">UnstructuredPoissonProblem::complete_problem_setup</a></div><div class="ttdeci">void complete_problem_setup()</div><div class="ttdoc">Helper function to (re-)set boundary condition and complete the build of all elements.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00458">mesh_from_inline_triangle.cc:458</a></div></div>
<div class="ttc" id="aclassUnstructuredPoissonProblem_html_a6f3e089824cfbb4f458efd8c8ffd376d"><div class="ttname"><a href="classUnstructuredPoissonProblem.html#a6f3e089824cfbb4f458efd8c8ffd376d">UnstructuredPoissonProblem::actions_after_adapt</a></div><div class="ttdeci">void actions_after_adapt()</div><div class="ttdoc">Actions after adapt: Setup the problem again – remember that the mesh has been completely rebuilt and...</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00108">mesh_from_inline_triangle.cc:108</a></div></div>
<div class="ttc" id="aclassUnstructuredPoissonProblem_html_a822bd18e50ebeefd6d1c196fad7c0bf1"><div class="ttname"><a href="classUnstructuredPoissonProblem.html#a822bd18e50ebeefd6d1c196fad7c0bf1">UnstructuredPoissonProblem::actions_after_newton_solve</a></div><div class="ttdeci">void actions_after_newton_solve()</div><div class="ttdoc">Update after solve (empty)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00114">mesh_from_inline_triangle.cc:114</a></div></div>
<div class="ttc" id="aclassUnstructuredPoissonProblem_html_ac7fdb8fb9a886ced0ee7244890406d90"><div class="ttname"><a href="classUnstructuredPoissonProblem.html#ac7fdb8fb9a886ced0ee7244890406d90">UnstructuredPoissonProblem::Trace_file</a></div><div class="ttdeci">ofstream Trace_file</div><div class="ttdoc">Trace file to document norm of solution.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00142">mesh_from_inline_triangle.cc:142</a></div></div>
<div class="ttc" id="aclassUnstructuredPoissonProblem_html_ac9627efd3c311156e5347ed37d4ea4b0"><div class="ttname"><a href="classUnstructuredPoissonProblem.html#ac9627efd3c311156e5347ed37d4ea4b0">UnstructuredPoissonProblem::actions_before_adapt</a></div><div class="ttdeci">void actions_before_adapt()</div><div class="ttdoc">Actions before adapt. Empty.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00102">mesh_from_inline_triangle.cc:102</a></div></div>
<div class="ttc" id="aclassUnstructuredPoissonProblem_html_ace8b8b3097ae2024a0589b2bf9b4ee7b"><div class="ttname"><a href="classUnstructuredPoissonProblem.html#ace8b8b3097ae2024a0589b2bf9b4ee7b">UnstructuredPoissonProblem::apply_boundary_conditions</a></div><div class="ttdeci">void apply_boundary_conditions()</div><div class="ttdoc">Helper function to apply boundary conditions.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00502">mesh_from_inline_triangle.cc:502</a></div></div>
<div class="ttc" id="aclassUnstructuredPoissonProblem_html_aeae85592e36ba7be6b4891fb49d2197b"><div class="ttname"><a href="classUnstructuredPoissonProblem.html#aeae85592e36ba7be6b4891fb49d2197b">UnstructuredPoissonProblem::~UnstructuredPoissonProblem</a></div><div class="ttdeci">~UnstructuredPoissonProblem()</div><div class="ttdoc">Destructor.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00099">mesh_from_inline_triangle.cc:99</a></div></div>
<div class="ttc" id="aclassUnstructuredPoissonProblem_html_af95c713f5db16c288e307768b6bf9bb8"><div class="ttname"><a href="classUnstructuredPoissonProblem.html#af95c713f5db16c288e307768b6bf9bb8">UnstructuredPoissonProblem::My_mesh_pt</a></div><div class="ttdeci">RefineableTriangleMesh&lt; ELEMENT &gt; * My_mesh_pt</div><div class="ttdoc">Pointers to specific mesh.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__from__inline__triangle_8cc_source.html#l00139">mesh_from_inline_triangle.cc:139</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="constructor"></a>
The Problem constructor</h1>
<p>Most of the problem constructor is concerned with the specification of the mesh boundaries. We start by generating a <code>GeomObject</code> that describes the circular outer boundary of the domain.</p>
<div class="fragment"><div class="line"><span class="comment">//==start_constructor=====================================================</span></div>
<div class="line"><span class="comment">/// Constructor</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><a class="code" href="classUnstructuredPoissonProblem.html#a26e7610a714aea17c9278beec4842371">UnstructuredPoissonProblem&lt;ELEMENT&gt;::UnstructuredPoissonProblem</a>()</div>
<div class="line">{          </div>
<div class="line"> <span class="comment">// Intrinsic coordinate along GeomObject</span></div>
<div class="line"> Vector&lt;double&gt; zeta(1);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Position vector on GeomObject</span></div>
<div class="line"> Vector&lt;double&gt; posn(2);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Ellipse defining the outer boundary</span></div>
<div class="line"> <span class="keywordtype">double</span> x_center = 0.0;</div>
<div class="line"> <span class="keywordtype">double</span> y_center = 0.0;</div>
<div class="line"> <span class="keywordtype">double</span> A = 1.0;</div>
<div class="line"> <span class="keywordtype">double</span> B = 1.0;</div>
<div class="line"> Ellipse * outer_boundary_ellipse_pt = <span class="keyword">new</span> Ellipse(A,B);</div>
</div><!-- fragment --><p> This <code>GeomObject</code> is now used to describe the outer boundary in terms of a <code>TriangleMeshClosedCurve</code> object, a base class which can represent polygonal and curvilinear boundaries. We start by providing a pointer to this (yet-to-be-built) object.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Pointer to the closed curve that defines the outer boundary</span></div>
<div class="line"> TriangleMeshClosedCurve* closed_curve_pt=0;</div>
</div><!-- fragment --><p>As discussed above, the closed outer boundary must be broken up into (at least) two distinct sub-boundaries to allow <code>oomph-lib</code> to automatically refine and setup boundary coordinates. We therefore create two <code>TriangleMeshCurviLines</code>, specifying</p><ul>
<li>the <code>GeomObject</code> that provides the exact curvilinear representation of the boundary, <br  />
<br  />
</li>
<li>the start and end coordinates of the boundary on that <code>GeomObject</code>, <br  />
<br  />
</li>
<li>the number of straight-line segments used to represent this boundary during the initial phase of the mesh generation process. Recall that nodes on this boundary are "snapped" onto the exact curvilinear boundary after the initial mesh is generated &ndash; the number of segments should therefore be sufficiently large to ensure that the "snapping" does not distort the elements next to the boundary too much. See <a class="el" href="index.html#how_many_segments">How many vertices should I use to sample my curvilinear boundary?</a> for a more detailed discussion of this issue.</li>
</ul>
<div class="fragment"><div class="line">   <span class="comment">// Provide storage for pointers to the two parts of the curvilinear boundary</span></div>
<div class="line">   Vector&lt;TriangleMeshCurveSection*&gt; outer_curvilinear_boundary_pt(2);</div>
</div><!-- fragment --><p> We choose five boundary segments for the first <code>TriangleMeshCurviLine</code> which represents the upper half of the boundary which we label as boundary 0,</p>
<div class="fragment"><div class="line">   </div>
<div class="line">   <span class="comment">// First bit</span></div>
<div class="line">   <span class="comment">//----------</span></div>
<div class="line">   <span class="keywordtype">double</span> zeta_start=0.0;</div>
<div class="line">   <span class="keywordtype">double</span> zeta_end=MathematicalConstants::Pi;</div>
<div class="line">   <span class="keywordtype">unsigned</span> nsegment=5;</div>
<div class="line">   <span class="keywordtype">unsigned</span> boundary_id=0;</div>
<div class="line">   outer_curvilinear_boundary_pt[0]=<span class="keyword">new</span> TriangleMeshCurviLine(</div>
<div class="line">    outer_boundary_ellipse_pt,zeta_start,zeta_end,nsegment,boundary_id);</div>
</div><!-- fragment --><p> and eight segments for the lower half which we label as boundary 1:</p>
<div class="fragment"><div class="line">   </div>
<div class="line">   <span class="comment">// Second bit</span></div>
<div class="line">   <span class="comment">//-----------</span></div>
<div class="line">   zeta_start=MathematicalConstants::Pi;</div>
<div class="line">   zeta_end=2.0*MathematicalConstants::Pi;</div>
<div class="line">   nsegment=8;</div>
<div class="line">   boundary_id=1;</div>
<div class="line">   outer_curvilinear_boundary_pt[1]=<span class="keyword">new</span> TriangleMeshCurviLine(</div>
<div class="line">    outer_boundary_ellipse_pt,zeta_start,zeta_end,nsegment,boundary_id);</div>
</div><!-- fragment --><p> We then combine the two <code>TriangleMeshCurviLines</code> to a <code>TriangleMeshClosedCurve</code> which describes the outer boundary.</p>
<div class="fragment"><div class="line">   <span class="comment">// Combine to curvilinear boundary and define the</span></div>
<div class="line">   <span class="comment">//--------------------------------</span></div>
<div class="line">   <span class="comment">// outer boundary</span></div>
<div class="line">   <span class="comment">//--------------------------------</span></div>
<div class="line">   closed_curve_pt=</div>
<div class="line">     <span class="keyword">new</span> TriangleMeshClosedCurve(outer_curvilinear_boundary_pt);</div>
</div><!-- fragment --><p> Next we deal with the two inner (hole) boundaries</p>
<div class="fragment"><div class="line"> <span class="comment">// Now build the holes</span></div>
<div class="line"> <span class="comment">//====================</span></div>
<div class="line"> Vector&lt;TriangleMeshClosedCurve*&gt; hole_pt(2);</div>
</div><!-- fragment --><p> The first hole is a polygon whose 12 vertices we distribute along a circle of radius <img class="formulaInl" alt="$ 0.1 $" src="form_12.png" width="16" height="9"/> , centred at <img class="formulaInl" alt="$ (x_1,x_2)=(0,0.5). $" src="form_13.png" width="98" height="14"/> As above, we break the closed boundary into two distinct sub-boundaries &ndash; this time represented by <code>TriangleMeshPolyLines:</code> </p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Build polygonal hole</span></div>
<div class="line"> <span class="comment">//=====================</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build first hole: A circle</span></div>
<div class="line"> x_center = 0.0;</div>
<div class="line"> y_center = 0.5;</div>
<div class="line"> A = 0.1;</div>
<div class="line"> B = 0.1;</div>
<div class="line"> Ellipse* polygon_ellipse_pt=<span class="keyword">new</span> Ellipse(A,B);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Number of segments defining upper and lower half of the hole</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_seg = 6; </div>
<div class="line"> <span class="keywordtype">double</span> unit_zeta = MathematicalConstants::Pi/double(n_seg);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// This hole is bounded by two distinct boundaries, each</span></div>
<div class="line"> <span class="comment">// represented by its own polyline</span></div>
<div class="line"> Vector&lt;TriangleMeshCurveSection*&gt; hole_polyline_pt(2);</div>
</div><!-- fragment --><p> We create the vertex coordinates for the upper half of the polygonal hole,</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// First boundary of polygonal hole</span></div>
<div class="line"> <span class="comment">//---------------------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Vertex coordinates</span></div>
<div class="line"> Vector&lt;Vector&lt;double&gt; &gt; bound_hole(n_seg+1);</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ipoint=0; ipoint&lt;n_seg+1;ipoint++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Resize the vector </span></div>
<div class="line">   bound_hole[ipoint].resize(2);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Get the coordinates</span></div>
<div class="line">   zeta[0]=unit_zeta*double(ipoint);</div>
<div class="line">   polygon_ellipse_pt-&gt;position(zeta,posn);</div>
<div class="line">   bound_hole[ipoint][0]=posn[0]+x_center;</div>
<div class="line">   bound_hole[ipoint][1]=posn[1]+y_center;</div>
<div class="line">  }</div>
</div><!-- fragment --><p> and build the <code>TriangleMeshPolyLine</code>, specifying a boundary ID:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Specify the hole boundary id</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> boundary_id=2;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the 1st hole polyline</span></div>
<div class="line"> hole_polyline_pt[0] = <span class="keyword">new</span> TriangleMeshPolyLine(bound_hole,boundary_id);</div>
</div><!-- fragment --><p> We repeat the exercise for the lower half which we turn into boundary 4:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Second boundary of polygonal hole</span></div>
<div class="line"> <span class="comment">//----------------------------------</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ipoint=0; ipoint&lt;n_seg+1;ipoint++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Resize the vector </span></div>
<div class="line">   bound_hole[ipoint].resize(2);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Get the coordinates</span></div>
<div class="line">   zeta[0]=(unit_zeta*double(ipoint))+MathematicalConstants::Pi;</div>
<div class="line">   polygon_ellipse_pt-&gt;position(zeta,posn);</div>
<div class="line">   bound_hole[ipoint][0]=posn[0]+x_center;</div>
<div class="line">   bound_hole[ipoint][1]=posn[1]+y_center;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Specify the hole boundary id</span></div>
<div class="line"> boundary_id=3;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the 2nd hole polyline</span></div>
<div class="line"> hole_polyline_pt[1] = <span class="keyword">new</span> TriangleMeshPolyLine(bound_hole,boundary_id);</div>
</div><!-- fragment --><p> Finally, we build the polygonal hole itself, specifying its constituent <code>TriangleMeshPolyLines</code> and the coordinate of a point inside the hole, which is required by <code>Triangle:</code> </p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the polygonal hole </span></div>
<div class="line"> <span class="comment">//-------------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Inner hole center coordinates</span></div>
<div class="line"> Vector&lt;double&gt; hole_center(2);</div>
<div class="line"> hole_center[0]=x_center;</div>
<div class="line"> hole_center[1]=y_center;</div>
<div class="line"> </div>
<div class="line"> hole_pt[0] = <span class="keyword">new</span> TriangleMeshPolygon(hole_polyline_pt, hole_center);</div>
</div><!-- fragment --><p> The construction of the second, curvilinear internal boundary (an ellipse centred at the origin) is virtually identical to the steps taken for the construction of the outer boundary, apart from the fact that, as an internal boundary, it again requires the specification of a point inside the hole.</p>
<div class="fragment"><div class="line"> <span class="comment">// Build curvilinear hole</span></div>
<div class="line"> <span class="comment">//======================</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build second hole: Another ellipse</span></div>
<div class="line"> A = 0.2;</div>
<div class="line"> B = 0.1;</div>
<div class="line"> Ellipse* ellipse_pt=<span class="keyword">new</span> Ellipse(A,B);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the two parts of the curvilinear boundary</span></div>
<div class="line"> Vector&lt;TriangleMeshCurveSection*&gt; curvilinear_boundary_pt(2);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// First part of curvilinear boundary</span></div>
<div class="line"> <span class="comment">//-----------------------------------</span></div>
<div class="line"> <span class="keywordtype">double</span> zeta_start=0.0;</div>
<div class="line"> <span class="keywordtype">double</span> zeta_end=MathematicalConstants::Pi;</div>
<div class="line"> <span class="keywordtype">unsigned</span> nsegment=10;</div>
<div class="line"> boundary_id=4;</div>
<div class="line"> curvilinear_boundary_pt[0]=<span class="keyword">new</span> TriangleMeshCurviLine(</div>
<div class="line">  ellipse_pt,zeta_start,zeta_end, </div>
<div class="line">  nsegment,boundary_id);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Second part of curvilinear boundary</span></div>
<div class="line"> <span class="comment">//-------------------------------------</span></div>
<div class="line"> zeta_start=MathematicalConstants::Pi;</div>
<div class="line"> zeta_end=2.0*MathematicalConstants::Pi;</div>
<div class="line"> nsegment=15;</div>
<div class="line"> boundary_id=5;</div>
<div class="line"> curvilinear_boundary_pt[1]=<span class="keyword">new</span> TriangleMeshCurviLine(</div>
<div class="line">  ellipse_pt,zeta_start,zeta_end, </div>
<div class="line">  nsegment,boundary_id);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Combine to hole</span></div>
<div class="line"> <span class="comment">//----------------</span></div>
<div class="line"> Vector&lt;double&gt; hole_coords(2);</div>
<div class="line"> hole_coords[0]=0.0;</div>
<div class="line"> hole_coords[1]=0.0;</div>
<div class="line"> Vector&lt;TriangleMeshClosedCurve*&gt; curvilinear_hole_pt(1);</div>
<div class="line"> hole_pt[1]=</div>
<div class="line">  <span class="keyword">new</span> TriangleMeshClosedCurve(curvilinear_boundary_pt,</div>
<div class="line">                                                 hole_coords);</div>
</div><!-- fragment --> <h2><a class="anchor" id="build_mesh"></a>
Construct the mesh</h2>
<p>To facilitate the construction of the mesh <code>TriangleMesh</code> object we use the object <code>TriangleMeshParameters</code>. The only necessary argument for creating this object is the outer boundary. The definition of holes, internal boundaries and regions is explained in <a href="../../../../doc/meshes/mesh_from_inline_triangle_internal_boundaries/html/index.html">another tutorial</a>. The object can also be used to control whether additional refinement may be performed on the mesh boundaries. The default behaviour is that such refinement will occur so that the highest quality mesh is obtained. In some cases, e.g. periodic boundary conditions, you may wish to ensure that each input boundary segment corresponds to a single element edge in the final mesh. This can be achieved for the outer boundary by calling <code>TriangleMeshParameters::disable_boundary_refinement()</code>. However, Triangle will still add additional points to any internal boundaries unless the additional function <code>TriangleMeshParameters::disable_internal_boundary_refinement()</code> is also called. The functions <code>TriangleMeshParameters::enable_boundary_refinement()</code> and <code>TriangleMeshParameters::enable_internal_boundary_refinement()</code> can be used to return to the default behaviour. Note that it is not currently possible to suppress refinement on the internal boundaries, but refine the outer boundary.</p>
<p>We can specify a target for the element sizes and pass it to the <code>TriangleMeshParameters</code> object as showed next:</p>
<div class="fragment"><div class="line"> <span class="comment">// Now build the mesh</span></div>
<div class="line"> <span class="comment">//===================</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Use the TriangleMeshParameters object for helping on the manage of the</span></div>
<div class="line"> <span class="comment">// TriangleMesh parameters</span></div>
<div class="line"> TriangleMeshParameters triangle_mesh_parameters(closed_curve_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Specify the closed curve using the TriangleMeshParameters object</span></div>
<div class="line"> triangle_mesh_parameters.internal_closed_curve_pt() = hole_pt;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Specify the maximum area element</span></div>
<div class="line"> <span class="keywordtype">double</span> uniform_element_area=0.2;</div>
<div class="line"> triangle_mesh_parameters.element_area() = uniform_element_area;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create the mesh</span></div>
<div class="line"> My_mesh_pt=<span class="keyword">new</span> </div>
<div class="line">  RefineableTriangleMesh&lt;ELEMENT&gt;(triangle_mesh_parameters);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Store as the problem&#39;s one and only mesh</span></div>
<div class="line"> Problem::mesh_pt()=My_mesh_pt;</div>
</div><!-- fragment --><p> We specify a spatial error estimator and limit the maximum and minimum element sizes,</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Set error estimator for bulk mesh</span></div>
<div class="line"> Z2ErrorEstimator* error_estimator_pt=<span class="keyword">new</span> Z2ErrorEstimator;</div>
<div class="line"> My_mesh_pt-&gt;spatial_error_estimator_pt()=error_estimator_pt;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set element size limits</span></div>
<div class="line"> My_mesh_pt-&gt;max_element_size()=0.2;</div>
<div class="line"> My_mesh_pt-&gt;min_element_size()=0.002; </div>
</div><!-- fragment --><p> before completing the problem setup (see below) and assigning the equation numbers.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Set boundary condition and complete the build of all elements</span></div>
<div class="line"> complete_problem_setup();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Open trace file</span></div>
<div class="line"> <span class="keywordtype">char</span> filename[100];</div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;RESLT/trace.dat&quot;</span>);</div>
<div class="line"> Trace_file.open(filename);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Setup equation numbering scheme</span></div>
<div class="line"> oomph_info &lt;&lt;<span class="stringliteral">&quot;Number of equations: &quot;</span> </div>
<div class="line">            &lt;&lt; this-&gt;assign_eqn_numbers() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end_of_constructor</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="complete"></a>
Completing the problem setup</h1>
<p>As discussed above, the helper function <code>complete_problem_setup()</code> starts by (re-)applying the boundary conditions by pinning the nodal values on all mesh boundaries,</p>
<div class="fragment"><div class="line"><span class="comment">//==start_of_complete======================================================</span></div>
<div class="line"><span class="comment"> /// Set boundary condition exactly, and complete the build of </span></div>
<div class="line"><span class="comment"></span><span class="comment"> /// all elements</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classUnstructuredPoissonProblem.html#a5cbf00790e8469b43c64c6aaadfe7b41">UnstructuredPoissonProblem&lt;ELEMENT&gt;::complete_problem_setup</a>()</div>
<div class="line">{   </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set the boundary conditions for problem: All nodes are</span></div>
<div class="line"> <span class="comment">// free by default -- just pin the ones that have Dirichlet conditions</span></div>
<div class="line"> <span class="comment">// here. </span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nbound=My_mesh_pt-&gt;nboundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibound=0;ibound&lt;nbound;ibound++)</div>
<div class="line">  {</div>
<div class="line">   <span class="keywordtype">unsigned</span> num_nod=My_mesh_pt-&gt;nboundary_node(ibound);</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Get node</span></div>
<div class="line">     Node* nod_pt=My_mesh_pt-&gt;boundary_node_pt(ibound,inod);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Pin one-and-only unknown value</span></div>
<div class="line">     nod_pt-&gt;pin(0);</div>
<div class="line">    }   </div>
<div class="line">  } <span class="comment">// end loop over boundaries</span></div>
</div><!-- fragment --><p> specifies the source function pointer for all elements,</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Complete the build of all elements so they are fully functional</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_element = My_mesh_pt-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from GeneralisedElement to the present element</span></div>
<div class="line">   ELEMENT* el_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(My_mesh_pt-&gt;element_pt(e));</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Set the source function pointer</span></div>
<div class="line">   el_pt-&gt;source_fct_pt() = &amp;<a class="code" href="namespaceTanhSolnForPoisson.html#ae1b9d6789ff301e3d63a4e292213036c">TanhSolnForPoisson::get_source</a>;</div>
<div class="line">  }</div>
</div><!-- fragment --><p> and then re-sets the boundary values:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Re-apply Dirichlet boundary conditions (projection ignores</span></div>
<div class="line"> <span class="comment">// boundary conditions!)</span></div>
<div class="line"> apply_boundary_conditions();</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="bc"></a>
Assigning the boundary values</h1>
<p>The function <code>apply_boundary_conditions()</code> does exactly what is says: It loops over all boundary nodes and assigns the value according the exact solution specified in the namespace <code><a class="el" href="namespaceTanhSolnForPoisson.html" title="Namespace for exact solution for Poisson equation with &quot;sharp step&quot;.">TanhSolnForPoisson</a></code>.</p>
<div class="fragment"><div class="line"><span class="comment">//==start_of_apply_bc=====================================================</span></div>
<div class="line"><span class="comment"> /// Helper function to apply boundary conditions</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classUnstructuredPoissonProblem.html#ace8b8b3097ae2024a0589b2bf9b4ee7b">UnstructuredPoissonProblem&lt;ELEMENT&gt;::apply_boundary_conditions</a>()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over all boundary nodes</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nbound=this-&gt;My_mesh_pt-&gt;nboundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibound=0;ibound&lt;nbound;ibound++)</div>
<div class="line">  {</div>
<div class="line">   <span class="keywordtype">unsigned</span> num_nod=this-&gt;My_mesh_pt-&gt;nboundary_node(ibound);</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Get node</span></div>
<div class="line">     Node* nod_pt=this-&gt;My_mesh_pt-&gt;boundary_node_pt(ibound,inod);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Extract nodal coordinates from node:</span></div>
<div class="line">     Vector&lt;double&gt; x(2);</div>
<div class="line">     x[0]=nod_pt-&gt;x(0);</div>
<div class="line">     x[1]=nod_pt-&gt;x(1);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Compute the value of the exact solution at the nodal point</span></div>
<div class="line">     Vector&lt;double&gt; u(1);</div>
<div class="line">     <a class="code" href="namespaceTanhSolnForPoisson.html#af7896e9c18ce6438c73ae2a875e8b7de">TanhSolnForPoisson::get_exact_u</a>(x,u);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Assign the value to the one (and only) nodal value at this node</span></div>
<div class="line">     nod_pt-&gt;set_value(0,u[0]);</div>
<div class="line">    }</div>
<div class="line">  } </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end set bc</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="doc"></a>
Post-processing</h1>
<p>We compare the computed solution against the exact solution:</p>
<div class="fragment"><div class="line"><span class="comment">//==start_of_doc_solution=================================================</span></div>
<div class="line"><span class="comment">/// Doc the solution</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classUnstructuredPoissonProblem.html#a9b21a3c3f574da71411f852006fe2a0c">UnstructuredPoissonProblem&lt;ELEMENT&gt;::doc_solution</a>(<span class="keyword">const</span> </div>
<div class="line">                                                       std::string&amp; comment)</div>
<div class="line">{ </div>
<div class="line"> ofstream some_file;</div>
<div class="line"> <span class="keywordtype">char</span> filename[100];</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Number of plot points</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> npts;</div>
<div class="line"> npts=5; </div>
<div class="line"> </div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;RESLT/soln%i.dat&quot;</span>,Doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> this-&gt;My_mesh_pt-&gt;output(some_file,npts); </div>
<div class="line"> some_file &lt;&lt; <span class="stringliteral">&quot;TEXT X = 22, Y = 92, CS=FRAME T = \&quot;&quot;</span> </div>
<div class="line">           &lt;&lt; comment &lt;&lt; <span class="stringliteral">&quot;\&quot;\n&quot;</span>;</div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output exact solution </span></div>
<div class="line"> <span class="comment">//----------------------</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;RESLT/exact_soln%i.dat&quot;</span>,Doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> My_mesh_pt-&gt;output_fct(some_file,npts,<a class="code" href="namespaceTanhSolnForPoisson.html#af7896e9c18ce6438c73ae2a875e8b7de">TanhSolnForPoisson::get_exact_u</a>); </div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output boundaries</span></div>
<div class="line"> <span class="comment">//------------------</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;RESLT/boundaries%i.dat&quot;</span>,Doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> My_mesh_pt-&gt;output_boundaries(some_file);</div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Doc error and return of the square of the L2 error</span></div>
<div class="line"> <span class="comment">//---------------------------------------------------</span></div>
<div class="line"> <span class="keywordtype">double</span> error,norm,dummy_error,zero_norm;</div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;RESLT/error%i.dat&quot;</span>,Doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> My_mesh_pt-&gt;compute_error(some_file,<a class="code" href="namespaceTanhSolnForPoisson.html#af7896e9c18ce6438c73ae2a875e8b7de">TanhSolnForPoisson::get_exact_u</a>,</div>
<div class="line">                           error,norm); </div>
<div class="line"> </div>
<div class="line"> My_mesh_pt-&gt;compute_error(some_file,<a class="code" href="namespaceTanhSolnForPoisson.html#a5cd8441c6e87d4bc153697eff13513dd">TanhSolnForPoisson::zero</a>,</div>
<div class="line">                           dummy_error,zero_norm); </div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Doc L2 error and norm of solution</span></div>
<div class="line"> oomph_info &lt;&lt; <span class="stringliteral">&quot;\nNorm of error   : &quot;</span> &lt;&lt; sqrt(error) &lt;&lt; std::endl; </div>
<div class="line"> oomph_info &lt;&lt; <span class="stringliteral">&quot;Norm of exact solution: &quot;</span> &lt;&lt; sqrt(norm) &lt;&lt; std::endl;</div>
<div class="line"> oomph_info &lt;&lt; <span class="stringliteral">&quot;Norm of computed solution: &quot;</span> &lt;&lt; sqrt(dummy_error) &lt;&lt; std::endl;</div>
<div class="line"> Trace_file &lt;&lt; sqrt(norm) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; sqrt(dummy_error) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Increment the doc_info number</span></div>
<div class="line"> Doc_info.number()++;</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of doc</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="comments"></a>
Comments and Exercises</h1>
<h2><a class="anchor" id="wrapper"></a>
Upgrading elements to become "projectable"</h2>
<p>As discussed above, a key step in the "mesh-adaptation-by-mesh-regeneration" procedure is the projection of the solution from the old to the new mesh. The ability to perform this projection fully-automatically during the mesh adaptation requires the elements to be "wrapped" in the templated <code>ProjectableElement&lt;ELEMENT&gt;</code> class. This class is derived from the <code>ProjectableElementBase</code> base class which specifies a number of pure virtual functions that must be specified for each specific element type. For the Poisson problem considered here these functions are already provided in the <code>ProjectablePoissonElement&lt;ELEMENT&gt;</code> class. Similar wrappers exist for many other equations. If you want to "upgrade" your own elements to become projectable, inspect the prototypes for the relevant pure virtual functions which are defined in</p>
<center> <a href="../../../../src/generic/projection.h">src/generic/projection.h </a> </center><p>while the specific implementation for the projectable Poisson elements is provided in</p>
<center> <a href="../../../../src/poisson/poisson_elements.h">src/poisson/poisson_elements.h </a> </center><p>Of course, you can avoid the additional work by dispensing with adaptivity and simply generating a sufficiently fine (uniform) mesh. This is illustrated in the alternative driver code </p><center> <a href="../../../../demo_drivers/meshing/mesh_from_inline_triangle/mesh_from_inline_triangle_no_adapt.cc">demo_drivers/meshing/mesh_from_inline_triangle/mesh_from_inline_triangle_no_adapt.cc </a> </center><hr  />
<h2><a class="anchor" id="how_many_segments"></a>
How many vertices should I use to sample my curvilinear boundary?</h2>
<p>As discussed above, meshes with curvilinear boundaries are created in a two-stage process. Initially, Triangle generates a mesh with polygonal boundaries using a user-specified number of vertices that are evenly distributed along the relevant <code>GeomObject</code>. The nodes on that boundary are then "snapped" onto the actual curvilinear boundary in a post-processing step. The decision of how many vertices to choose involves a compromise between two conflicting demands:</p><ul>
<li>The number of boundary nodes created by Triangle will be at least as big as the number of vertices specified. Triangle may add additional boundary nodes to generate a mesh of sufficient quality but it will not remove any vertices. Using a very large number of vertices can therefore lead to unnecessarily fine meshes. <br  />
<br  />
</li>
<li>If the number of vertices is too small, the polygonal representation of the domain boundary may be a poor approximation to the actual curvilinear boundary. Elements near such boundaries may become (too) strongly distorted when nodes are "snapped" onto the curvilinear boundary. This often manifests itself in inverted elements. (An element is considered inverted if the Jacobian of the mapping between local and global coordinates becomes non-positive anywhere. Note that negative Jacobians may occur in the interior of elements (e.g. at their Gauss points) even if a plot of the element, based on its nodal positions, still looks "OK").</li>
</ul>
<hr  />
<h2><a class="anchor" id="ex"></a>
Exercises</h2>
<ol type="1">
<li>Change the outer curvilinear boundary to a polygonal boundary (you can cheat &ndash; the relevant code is already contained in the driver code but it's "hidden" with <code>ifdefs</code>; this code also documents the re-distribution of straight-line segments between different polylines, a capability that is important in certain free-boundary problems). <br  />
<br  />
</li>
<li>Vary the number of vertices used for the initial polygonal representation of the curvilinear hole to establish what number is required to avoid the inversion of elements during the "snap-nodes-to-the-curvilinear-boundary" phase. <br  />
<br  />
</li>
<li>Create "projectable" advection diffusion elements to solve the the advection diffusion problem discussed in <a href="../../../../doc/advection_diffusion/two_d_adv_diff_adapt/html/index.html">another tutorial,</a> using spatial adaptation on an unstructured mesh. <br  />
<br  />
</li>
</ol>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory:<br  />
<br  />
<center> <a href="../../../../demo_drivers/meshing/mesh_from_triangle/">demo_drivers/meshing/mesh_from_inline_triangle/ </a> </center><br  />
</li>
<li>The driver code is: <br  />
<br  />
<center> <a href="../../../../demo_drivers/meshing/mesh_from_inline_triangle/mesh_from_inline_triangle.cc">demo_drivers/meshing/mesh_from_inline_triangle/mesh_from_inline_triangle.cc </a> </center> <br  />
<br  />
</li>
<li>The additional driver code <br  />
<br  />
<center> <a href="../../../../demo_drivers/meshing/mesh_from_inline_triangle/mesh_from_inline_triangle_no_adapt.cc">demo_drivers/meshing/mesh_from_inline_triangle/mesh_from_inline_triangle_no_adapt.cc </a> </center> <br  />
shows how to generate non-refineable triangle meshes inline. This code does not require any modifications to existing triangular elements.</li>
</ul>
<h1><a class="anchor" id="curve_sections"></a>
Appendix A: Generalization for polylines and curvilines</h1>
<p>The objects, <code>TriangleMeshPolyLine</code> and <code>TriangleMeshCurviLine</code> inherit the properties of a more general representation called <code>TriangleMeshCurveSection</code>. This allows one to define more general boundaries as a combination of <code>TriangleMeshPolyLines</code> and <code>TriangleMeshCurviLines</code>. Therefore, if we want to define a more general closed curve use the <code>TriangleMeshClosedCurve</code> object. You may notice the use of this object through the example code when defining the outer boundary.</p>
<p>For the interested reader, the class diagram showing the hierarchy of the mentioned objects is showed on the next figure.</p>
<div class="image">
<img src="class_diagram.gif" alt=""/>
<div class="caption">
The hierarchy of the <code>TriangleMesh</code> objects. </div></div>
 <p>Note the <code>TriangleMeshOpenCurve</code> object, which allows to define internal boundaries on the domain, explained on <a href="../../../../doc/meshes/mesh_from_inline_triangle_internal_boundaries/html/index.html">another tutorial</a></p>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:05:52
        </div>
      </div>
    </footer>
</body>
</html>
