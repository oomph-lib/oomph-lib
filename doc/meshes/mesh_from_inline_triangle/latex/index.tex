In this document we demonstrate how to generate unstructured 2D meshes for {\ttfamily oomph-\/lib}, using \href{http://www.cs.berkeley.edu/~jrs/}{\texttt{ Jonathan Shewchuk\textquotesingle{}s}} \href{http://www.cs.cmu.edu/~quake/triangle.html}{\texttt{ Triangle}} library from within an {\ttfamily oomph-\/lib} driver code. This complements the discussion in \href{../../../../doc/meshes/mesh_from_triangle/html/index.html}{\texttt{ another tutorial}} where we illustrated how to build {\ttfamily oomph-\/lib} meshes using the output generated when \href{http://www.cs.cmu.edu/~quake/triangle.html}{\texttt{ {\ttfamily Triangle} }} is used to create the mesh externally.

In addition, we demonstrate
\begin{DoxyItemize}
\item how to create meshes with polygonal or curvilinear boundaries
\end{DoxyItemize}and
\begin{DoxyItemize}
\item how to adapt (re-\/generate) these meshes based on spatial error estimates.
\end{DoxyItemize}Here we restrict ourselves to the solution of problems in fixed domains. Other tutorials discuss more advanced applications involving moving meshes, e.\+g.
\begin{DoxyItemize}
\item \href{../../../../doc/navier_stokes/jeffery_orbit/html/index.html}{\texttt{ The motion of an ellipse in a shear flow}} ~\newline
~\newline

\item \href{../../../../doc/navier_stokes/adaptive_bubble_in_channel/html/index.html}{\texttt{ The propagation of a bubble in a channel -- mesh generation and adaptation for free-\/surface flows.}} ~\newline
~\newline

\end{DoxyItemize}\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_overview}{}\doxysection{Overview of mesh generation procedures}\label{index_overview}
\hypertarget{index_polygonal}{}\doxysubsection{Meshes with polygonal boundaries}\label{index_polygonal}
If the domain has polygonal outer (and possibly internal) boundaries, the mesh generation process follows a similar pattern to that required in the external use of \href{http://www.cs.cmu.edu/~quake/triangle.html}{\texttt{ {\ttfamily Triangle} }}, but using {\ttfamily oomph-\/lib} classes to represent the required data. We define the polygonal boundaries using {\ttfamily Triangle\+Mesh\+Poly\+Lines}, which represent distinct mesh boundaries and are defined by a series of vertex coordinates. Multiple {\ttfamily Triangle\+Mesh\+Poly\+Lines} can be combined to define (closed) {\ttfamily Triangle\+Mesh\+Polygons}. These are then used to create an unstructured mesh with a pre-\/determined target area for all elements, via an interface to \href{http://www.cs.cmu.edu/~quake/triangle.html}{\texttt{ {\ttfamily Triangle} }}.

One particular feature of {\ttfamily oomph-\/lib\textquotesingle{}s} interface to \href{http://www.cs.cmu.edu/~quake/triangle.html}{\texttt{ {\ttfamily Triangle} }} is that each closed {\ttfamily Triangle\+Mesh\+Polygon} must contain at least two distinct {\ttfamily Triangle\+Mesh\+Poly\+Lines}, each with its own boundary ID. This is because every {\ttfamily Node} can only have a single-\/valued boundary coordinate but if the boundary is closed there would be a discontinuity in the coordinate value. (For example, a standard representation would have $ \zeta = [0,2\pi] $ , but the node at $\zeta=0$ should also have $ \zeta=2\pi $ and this is not possible.) The sketch below shows a representative domain as well as two legal and one illegal representations of the domain boundaries. Note that the boundaries can be enumerated in an arbitrary fashion.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{polygonal_mesh}
\doxyfigcaption{Sketch of a polygonal domain (top) and two legal (bottom left and middle) and one illegal (bottom right) representations of the boundaries in terms of Triangle\+Mesh\+Poly\+Lines. }
\end{DoxyImage}


\DoxyHorRuler{0}
\hypertarget{index_curvilinear}{}\doxysubsection{Meshes with curvilinear boundaries}\label{index_curvilinear}
It is also possible to discretise domains with curvilinear boundaries as shown in the sketch below. Assuming that each curvilinear boundary is represented by a {\ttfamily Geom\+Object} that specifies the position vector $ {\bf R}(\zeta) $ to a point on the curvilinear boundary as a function of some surface coordinate $ \zeta $, we split each closed boundary into (at least) two distinct {\ttfamily Triangle\+Mesh\+Curvi\+Lines} -- the curvilinear equivalents of {\ttfamily Triangle\+Mesh\+Poly\+Lines}. Each {\ttfamily Triangle\+Mesh\+Curvi\+Line} is constructed from a pointer to the {\ttfamily Geom\+Object} and the start and end values of the boundary coordinate $ \zeta $ along the relevant part of the curvilinear boundary. The {\ttfamily Triangle\+Mesh\+Curvi\+Lines} are then combined to a {\ttfamily Triangle\+Mesh\+Closed\+Curve} -- the general closed curve.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{curvilinear_mesh}
\doxyfigcaption{Sketch of a domain bounded by a curvilinear boundary, containing two holes with curvilinear (hole 1) and polygonal (hole 2) boundaries, respectively. }
\end{DoxyImage}


The mesh is then created in a two-\/stage process\+: All {\ttfamily Triangle\+Mesh\+Curvi\+Lines} are sampled at a certain number of points (specified by the user in the constructor) to create the vertices for a polyline representation of the boundary. This polygonal representation of the boundaries is used by {\ttfamily Triangle} to generate the mesh. Finally, nodes on curvilinear boundaries are \char`\"{}snapped\char`\"{} onto the actual curvilinear boundary.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_adapt}{}\doxysection{Overview of mesh adaptation methodology}\label{index_adapt}
The methodology employed to adapt {\ttfamily oomph-\/lib\textquotesingle{}s} unstructured meshes differs from that used for structured meshes. Specifically, rather than sub-\/dividing elements in which the error estimate exceeds a threshold and merging elements in which the solution is \char`\"{}too accurate\char`\"{}, we completely re-\/generate the mesh and project the solution from the old to the new mesh. This is because we originally developed the underlying methodology to solve free-\/boundary problems in which the domain undergoes such large deformations that re-\/meshing is required. The ability to adjust the element sizes guided by spatial error estimates when re-\/meshing the domain is a simple fringe benefit.

A number of issues are important\+:
\begin{DoxyItemize}
\item To facilitate mesh adaptation in free-\/boundary problems, we re-\/generate the polygonal representation of the boundary, using the vertex nodes of the elements on the boundary to re-\/define the polygon. The number of vertices in the polygons that define the mesh boundaries will therefore generally change during the mesh adaptation process. This is discussed in more detail in \href{../../../../doc/navier_stokes/adaptive_bubble_in_channel/html/index.html\#adapt}{\texttt{ another tutorial.}}~\newline
~\newline

\item The mesh (and thus its constituent elements) are completely re-\/generated when the mesh is adapted, and so it is necessary to \char`\"{}complete   the build\char`\"{} of all elements after each mesh adaptation. For instance, pointers to problem parameters (Reynolds numbers, source functions, etc) must be re-\/set after the adaptation since they cannot (easily) be passed from the old to the new mesh. ~\newline
~\newline

\item When projecting the solution from the old to the new mesh, we project ~\newline
~\newline

\begin{DoxyItemize}
\item all unknowns and their associated history values (if any) ~\newline
~\newline

\item the history values of the nodal positions. This is important for moving mesh problems where the mesh velocity is required to evaluate the ALE time-\/derivatives.
\end{DoxyItemize}~\newline
~\newline

\item The ability to automatically project the solution from the old to the new mesh requires the elements, of type {\ttfamily ELEMENT}, say, to be wrapped in the templated {\ttfamily Projectable\+Element$<$\+ELEMENT$>$} class. This class requires the specification of various element characteristics (such as the number of fields to be projected, the number of history values, etc) in the form of virtual functions. This is much more straightforward than upgrading an existing element to become a refineable element for use in an adaptive computation on a structured mesh because the \char`\"{}mesh adaptation by mesh re-\/generation\char`\"{} avoids the creation of hanging nodes. See the section \mbox{\hyperlink{index_wrapper}{Upgrading elements to become \char`\"{}projectable\char`\"{}}} for a slightly more detailed discussion of this aspect. ~\newline
 ~\newline
~\newline

\item Note that we do {\bfseries{not}} apply any boundary conditions during the projection of these fields. This decision was not taken out of laziness but because the interfaces required to specify which boundary conditions to enforce and which ones to relax during the projection were too unwieldy. It is therefore {\bfseries{important}} to re-\/apply boundary conditions and boundary values after each adaptation. ~\newline
~\newline

\end{DoxyItemize}We recommend using the {\ttfamily Problem\+::actions\+\_\+after\+\_\+adapt()} function to re-\/assign boundary conditions and to complete the build of all elements after the adaptation.

Apart from these issues, the user interfaces to the mesh adaptation functions are exactly the same as for structured meshes. Specifically, it is possible to specify maximum and minimum element sizes and target values for the error such that the mesh is refined in regions where the error estimate is {\ttfamily too large\textquotesingle{}\textquotesingle{} and unrefined where it is }too small\textquotesingle{}\textquotesingle{}.

Typically, the most computationally expensive stage of the mesh regeneration procedure is the multi-\/domain setup procedure which identifies corresponding points in the old and new meshes. In \char`\"{}cheap\char`\"{} problems, such as the Poisson problem discussed below, the cost of the mesh regeneration can exceed the cost of the subsequent solve, but in most \char`\"{}hard\char`\"{} problems (such as the ones listed at the beginning of this tutorial) the cost of the mesh regeneration is modest (and, in the case of large-\/displacement free-\/boundary problems, unavoidable anyway).

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_example}{}\doxysection{An example\+: The adaptive solution of Poisson\textquotesingle{}s equations on an unstructured mesh}\label{index_example}
As an example we consider the adaptive solution of Poisson\textquotesingle{}s equation \[ \frac{\partial^2 u}{\partial x_i^2} = f(x_1,x_2) \] in a circular domain that contains an elliptical and a polygonal hole. As in many previous examples, we apply Dirichlet boundary conditions on all domain boundaries and choose the boundary values and the source function $ f(x_1,x_2) $ such that the exact solution of the problem is given by \[ u(x_1,x_2) = \tanh(1-\alpha(x_1 \tan\Phi - x_2)), \] which approaches a step function, oriented at an angle $ \Phi $ within the $ (x_1,x_2) $ plane, as $ \alpha $ becomes large. The figure below shows contour plots of the solution for $ \alpha = 5 $ for various angles $ \Phi $. It illustrates how the mesh adaptation adjusts the mesh such the smallest elements are located in the region where the solution undergoes rapid change.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{solution}
\doxyfigcaption{Contour plot of the solution. }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_global}{}\doxysection{Global parameters and functions}\label{index_global}
Following our usual practice, we use a namespace to define the source function and the exact solution.  
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//===== start\_of\_namespace=============================================}}
\DoxyCodeLine{\textcolor{comment}{/// Namespace for exact solution for Poisson equation with "{}sharp step"{} }}
\DoxyCodeLine{\textcolor{comment}{//=====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{namespace }\mbox{\hyperlink{namespaceTanhSolnForPoisson}{TanhSolnForPoisson}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Parameter for steepness of "{}step"{}}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{Alpha}}=5.0;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Parameter for angle Phi of "{}step"{}}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} \mbox{\hyperlink{namespaceTanhSolnForPoisson_a785ccd00a727125a5138fbbcac173294}{TanPhi}}=0.0;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Exact solution as a Vector}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{get\_exact\_u}}(\textcolor{keyword}{const} Vector<double>\& x, Vector<double>\& u)}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  u[0]=tanh(1.0-\/\mbox{\hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{Alpha}}*(\mbox{\hyperlink{namespaceTanhSolnForPoisson_a785ccd00a727125a5138fbbcac173294}{TanPhi}}*x[0]-\/x[1]));}
\DoxyCodeLine{ \}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Source function required to make the solution above an exact solution }}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespaceTanhSolnForPoisson_ae1b9d6789ff301e3d63a4e292213036c}{get\_source}}(\textcolor{keyword}{const} Vector<double>\& x, \textcolor{keywordtype}{double}\& source)}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  source = 2.0*tanh(-\/1.0+\mbox{\hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{Alpha}}*(\mbox{\hyperlink{namespaceTanhSolnForPoisson_a785ccd00a727125a5138fbbcac173294}{TanPhi}}*x[0]-\/x[1]))*}
\DoxyCodeLine{   (1.0-\/pow(tanh(-\/1.0+\mbox{\hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{Alpha}}*(\mbox{\hyperlink{namespaceTanhSolnForPoisson_a785ccd00a727125a5138fbbcac173294}{TanPhi}}*x[0]-\/x[1])),2.0))*}
\DoxyCodeLine{   \mbox{\hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{Alpha}}*\mbox{\hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{Alpha}}*\mbox{\hyperlink{namespaceTanhSolnForPoisson_a785ccd00a727125a5138fbbcac173294}{TanPhi}}*\mbox{\hyperlink{namespaceTanhSolnForPoisson_a785ccd00a727125a5138fbbcac173294}{TanPhi}}+2.0*tanh(-\/1.0+\mbox{\hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{Alpha}}*(\mbox{\hyperlink{namespaceTanhSolnForPoisson_a785ccd00a727125a5138fbbcac173294}{TanPhi}}*x[0]-\/x[1]))*}
\DoxyCodeLine{   (1.0-\/pow(tanh(-\/1.0+\mbox{\hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{Alpha}}*(\mbox{\hyperlink{namespaceTanhSolnForPoisson_a785ccd00a727125a5138fbbcac173294}{TanPhi}}*x[0]-\/x[1])),2.0))*\mbox{\hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{Alpha}}*\mbox{\hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{Alpha}};}
\DoxyCodeLine{ \}}
\DoxyCodeLine{ }
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Zero function -\/-\/ used to compute norm of the computed solution by }}
\DoxyCodeLine{\textcolor{comment}{ /// computing the norm of the error when compared against this.}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespaceTanhSolnForPoisson_a5cd8441c6e87d4bc153697eff13513dd}{zero}}(\textcolor{keyword}{const} Vector<double>\& x, Vector<double>\& u)}
\DoxyCodeLine{ \{}
\DoxyCodeLine{  u[0]=0.0;}
\DoxyCodeLine{ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of namespace}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysection{The driver code}\label{index_main}
We start by processing command line arguments which allow us to run the code in self-\/test mode and build the problem with \char`\"{}projectable\char`\"{} six-\/noded triangular Poisson elements.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=======start\_of\_main========================================}}
\DoxyCodeLine{\textcolor{comment}{/// Driver code for demo of inline triangle mesh generation}}
\DoxyCodeLine{\textcolor{comment}{//============================================================}}
\DoxyCodeLine{\textcolor{keywordtype}{int} \mbox{\hyperlink{mesh__from__inline__triangle_8cc_a3c04138a5bfe5d72780bb7e82a18e627}{main}}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)}
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{// Store command line arguments}}
\DoxyCodeLine{ CommandLineArgs::setup(argc,argv);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Define possible command line arguments and parse the ones that}}
\DoxyCodeLine{ \textcolor{comment}{// were actually specified}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Validation?}}
\DoxyCodeLine{ CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"{}-\/-\/validation"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Parse command line}}
\DoxyCodeLine{ CommandLineArgs::parse\_and\_assign(); }
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Doc what has actually been specified on the command line}}
\DoxyCodeLine{ CommandLineArgs::doc\_specified\_flags();}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Create problem}}
\DoxyCodeLine{ \mbox{\hyperlink{classUnstructuredPoissonProblem}{UnstructuredPoissonProblem<ProjectablePoissonElement<TPoissonElement<2,3>}} > >}
\DoxyCodeLine{  problem;}

\end{DoxyCodeInclude}


We then perform a parameter study, solving the problem for various orientations of the \char`\"{}step\char`\"{} and allowing a certain number of spatial adaptations per solve. (If the code is run in self-\/test mode, we perform fewer steps and allow for less adaptation to speed up the computation.)


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Loop over orientation of step}}
\DoxyCodeLine{ \textcolor{comment}{//==============================}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nstep=5;}
\DoxyCodeLine{ \textcolor{keywordflow}{if} (CommandLineArgs::command\_line\_flag\_has\_been\_set(\textcolor{stringliteral}{"{}-\/-\/validation"{}}))}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   nstep=2;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<nstep;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Solve with spatial adaptation}}
\DoxyCodeLine{   \textcolor{comment}{//==============================}}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} max\_adapt=3;}
\DoxyCodeLine{   \textcolor{keywordflow}{if} (CommandLineArgs::command\_line\_flag\_has\_been\_set(\textcolor{stringliteral}{"{}-\/-\/validation"{}}))}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     max\_adapt=1;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{   problem.newton\_solve(max\_adapt);}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Doc the solution}}
\DoxyCodeLine{   \textcolor{comment}{//=================}}
\DoxyCodeLine{   std::stringstream comment\_stream;}
\DoxyCodeLine{   comment\_stream << \textcolor{stringliteral}{"{}Solution for tan(phi) = "{}} << \mbox{\hyperlink{namespaceTanhSolnForPoisson_a785ccd00a727125a5138fbbcac173294}{TanhSolnForPoisson::TanPhi}}; }
\DoxyCodeLine{   problem.\mbox{\hyperlink{classUnstructuredPoissonProblem_a9b21a3c3f574da71411f852006fe2a0c}{doc\_solution}}(comment\_stream.str());}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Rotate orientation of solution}}
\DoxyCodeLine{   \mbox{\hyperlink{namespaceTanhSolnForPoisson_a785ccd00a727125a5138fbbcac173294}{TanhSolnForPoisson::TanPhi}}+=0.5;}
\DoxyCodeLine{  \}   }
\DoxyCodeLine{ }
\DoxyCodeLine{\} \textcolor{comment}{//End of main}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_problem}{}\doxysection{The problem class}\label{index_problem}
The problem class contains the usual member functions. As discussed above, the boundary conditions and the source function have to be re-\/specified after every mesh adaptation since the adapted mesh contains completely new elements. This is done in the function {\ttfamily complete\+\_\+problem\+\_\+setup()}, discussed below, which is called from the Problem constructor and from {\ttfamily actions\+\_\+after\+\_\+adapt()}. We re-\/assign the Dirichlet boundary conditions in {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+solve()}, using a second helper function {\ttfamily apply\+\_\+boundary\+\_\+conditions()}\+:

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_problem\_class============================================}}
\DoxyCodeLine{\textcolor{comment}{/// Class definition}}
\DoxyCodeLine{\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{classUnstructuredPoissonProblem}{UnstructuredPoissonProblem}} : \textcolor{keyword}{public} \textcolor{keyword}{virtual} Problem}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Constructor}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classUnstructuredPoissonProblem_a26e7610a714aea17c9278beec4842371}{UnstructuredPoissonProblem}}();}
\DoxyCodeLine{    \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Destructor}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classUnstructuredPoissonProblem_aeae85592e36ba7be6b4891fb49d2197b}{\string~UnstructuredPoissonProblem}}()\{\};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Actions before adapt. Empty}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classUnstructuredPoissonProblem_ac9627efd3c311156e5347ed37d4ea4b0}{actions\_before\_adapt}}() \{\}}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Actions after adapt: }}
\DoxyCodeLine{\textcolor{comment}{ /// Setup the problem again -\/-\/ remember that the mesh has been}}
\DoxyCodeLine{\textcolor{comment}{ /// completely rebuilt and its element's don't have any}}
\DoxyCodeLine{\textcolor{comment}{ /// pointers to source fcts etc. yet}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classUnstructuredPoissonProblem_a6f3e089824cfbb4f458efd8c8ffd376d}{actions\_after\_adapt}}()}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \mbox{\hyperlink{classUnstructuredPoissonProblem_a5cbf00790e8469b43c64c6aaadfe7b41}{complete\_problem\_setup}}();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update after solve (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classUnstructuredPoissonProblem_a822bd18e50ebeefd6d1c196fad7c0bf1}{actions\_after\_newton\_solve}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem specs before solve: Re-\/apply boundary conditons}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classUnstructuredPoissonProblem_a2ab9d23c0e6e6631ffe1a761f6bdf026}{actions\_before\_newton\_solve}}()}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \mbox{\hyperlink{classUnstructuredPoissonProblem_ace8b8b3097ae2024a0589b2bf9b4ee7b}{apply\_boundary\_conditions}}();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Doc the solution}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classUnstructuredPoissonProblem_a9b21a3c3f574da71411f852006fe2a0c}{doc\_solution}}(\textcolor{keyword}{const} std::string\& comment=\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{ }
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Doc info object for labeling output}}
\DoxyCodeLine{\textcolor{comment}{} DocInfo \mbox{\hyperlink{classUnstructuredPoissonProblem_a5c4c29b1c95cd63055e5aced124ca708}{Doc\_info}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Helper function to apply boundary conditions}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classUnstructuredPoissonProblem_ace8b8b3097ae2024a0589b2bf9b4ee7b}{apply\_boundary\_conditions}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Helper function to (re-\/)set boundary condition}}
\DoxyCodeLine{\textcolor{comment}{ /// and complete the build of  all elements}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classUnstructuredPoissonProblem_a5cbf00790e8469b43c64c6aaadfe7b41}{complete\_problem\_setup}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointers to specific mesh}}
\DoxyCodeLine{\textcolor{comment}{} RefineableTriangleMesh<ELEMENT>* \mbox{\hyperlink{classUnstructuredPoissonProblem_af95c713f5db16c288e307768b6bf9bb8}{My\_mesh\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Trace file to document norm of solution}}
\DoxyCodeLine{\textcolor{comment}{} ofstream \mbox{\hyperlink{classUnstructuredPoissonProblem_ac7fdb8fb9a886ced0ee7244890406d90}{Trace\_file}};}
\DoxyCodeLine{}
\DoxyCodeLine{\}; \textcolor{comment}{// end\_of\_problem\_class}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_constructor}{}\doxysection{The Problem constructor}\label{index_constructor}
Most of the problem constructor is concerned with the specification of the mesh boundaries. We start by generating a {\ttfamily Geom\+Object} that describes the circular outer boundary of the domain.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_constructor=====================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Constructor}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\mbox{\hyperlink{classUnstructuredPoissonProblem_a26e7610a714aea17c9278beec4842371}{UnstructuredPoissonProblem<ELEMENT>::UnstructuredPoissonProblem}}()}
\DoxyCodeLine{\{          }
\DoxyCodeLine{ \textcolor{comment}{// Intrinsic coordinate along GeomObject}}
\DoxyCodeLine{ Vector<double> zeta(1);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Position vector on GeomObject}}
\DoxyCodeLine{ Vector<double> posn(2);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Ellipse defining the outer boundary}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} x\_center = 0.0;}
\DoxyCodeLine{ \textcolor{keywordtype}{double} y\_center = 0.0;}
\DoxyCodeLine{ \textcolor{keywordtype}{double} A = 1.0;}
\DoxyCodeLine{ \textcolor{keywordtype}{double} B = 1.0;}
\DoxyCodeLine{ Ellipse * outer\_boundary\_ellipse\_pt = \textcolor{keyword}{new} Ellipse(A,B);}

\end{DoxyCodeInclude}
 This {\ttfamily Geom\+Object} is now used to describe the outer boundary in terms of a {\ttfamily Triangle\+Mesh\+Closed\+Curve} object, a base class which can represent polygonal and curvilinear boundaries. We start by providing a pointer to this (yet-\/to-\/be-\/built) object.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Pointer to the closed curve that defines the outer boundary}}
\DoxyCodeLine{ TriangleMeshClosedCurve* closed\_curve\_pt=0;}

\end{DoxyCodeInclude}


As discussed above, the closed outer boundary must be broken up into (at least) two distinct sub-\/boundaries to allow {\ttfamily oomph-\/lib} to automatically refine and setup boundary coordinates. We therefore create two {\ttfamily Triangle\+Mesh\+Curvi\+Lines}, specifying
\begin{DoxyItemize}
\item the {\ttfamily Geom\+Object} that provides the exact curvilinear representation of the boundary, ~\newline
~\newline

\item the start and end coordinates of the boundary on that {\ttfamily Geom\+Object}, ~\newline
~\newline

\item the number of straight-\/line segments used to represent this boundary during the initial phase of the mesh generation process. Recall that nodes on this boundary are \char`\"{}snapped\char`\"{} onto the exact curvilinear boundary after the initial mesh is generated -- the number of segments should therefore be sufficiently large to ensure that the \char`\"{}snapping\char`\"{} does not distort the elements next to the boundary too much. See \mbox{\hyperlink{index_how_many_segments}{How many vertices should I use to sample my curvilinear boundary?}} for a more detailed discussion of this issue.
\end{DoxyItemize}
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{   \textcolor{comment}{// Provide storage for pointers to the two parts of the curvilinear boundary}}
\DoxyCodeLine{   Vector<TriangleMeshCurveSection*> outer\_curvilinear\_boundary\_pt(2);}

\end{DoxyCodeInclude}
 We choose five boundary segments for the first {\ttfamily Triangle\+Mesh\+Curvi\+Line} which represents the upper half of the boundary which we label as boundary 0,


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// First bit}}
\DoxyCodeLine{   \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{   \textcolor{keywordtype}{double} zeta\_start=0.0;}
\DoxyCodeLine{   \textcolor{keywordtype}{double} zeta\_end=MathematicalConstants::Pi;}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} nsegment=5;}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} boundary\_id=0;}
\DoxyCodeLine{   outer\_curvilinear\_boundary\_pt[0]=\textcolor{keyword}{new} TriangleMeshCurviLine(}
\DoxyCodeLine{    outer\_boundary\_ellipse\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id);}

\end{DoxyCodeInclude}
 and eight segments for the lower half which we label as boundary 1\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Second bit}}
\DoxyCodeLine{   \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{   zeta\_start=MathematicalConstants::Pi;}
\DoxyCodeLine{   zeta\_end=2.0*MathematicalConstants::Pi;}
\DoxyCodeLine{   nsegment=8;}
\DoxyCodeLine{   boundary\_id=1;}
\DoxyCodeLine{   outer\_curvilinear\_boundary\_pt[1]=\textcolor{keyword}{new} TriangleMeshCurviLine(}
\DoxyCodeLine{    outer\_boundary\_ellipse\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id);}

\end{DoxyCodeInclude}
 We then combine the two {\ttfamily Triangle\+Mesh\+Curvi\+Lines} to a {\ttfamily Triangle\+Mesh\+Closed\+Curve} which describes the outer boundary.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{   \textcolor{comment}{// Combine to curvilinear boundary and define the}}
\DoxyCodeLine{   \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{   \textcolor{comment}{// outer boundary}}
\DoxyCodeLine{   \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{   closed\_curve\_pt=}
\DoxyCodeLine{     \textcolor{keyword}{new} TriangleMeshClosedCurve(outer\_curvilinear\_boundary\_pt);}

\end{DoxyCodeInclude}
 Next we deal with the two inner (hole) boundaries


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Now build the holes}}
\DoxyCodeLine{ \textcolor{comment}{//====================}}
\DoxyCodeLine{ Vector<TriangleMeshClosedCurve*> hole\_pt(2);}

\end{DoxyCodeInclude}
 The first hole is a polygon whose 12 vertices we distribute along a circle of radius $ 0.1 $ , centred at $ (x_1,x_2)=(0,0.5). $ As above, we break the closed boundary into two distinct sub-\/boundaries -- this time represented by {\ttfamily Triangle\+Mesh\+Poly\+Lines\+:} 


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Build polygonal hole}}
\DoxyCodeLine{ \textcolor{comment}{//=====================}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Build first hole: A circle}}
\DoxyCodeLine{ x\_center = 0.0;}
\DoxyCodeLine{ y\_center = 0.5;}
\DoxyCodeLine{ A = 0.1;}
\DoxyCodeLine{ B = 0.1;}
\DoxyCodeLine{ Ellipse* polygon\_ellipse\_pt=\textcolor{keyword}{new} Ellipse(A,B);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Number of segments defining upper and lower half of the hole}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_seg = 6; }
\DoxyCodeLine{ \textcolor{keywordtype}{double} unit\_zeta = MathematicalConstants::Pi/double(n\_seg);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// This hole is bounded by two distinct boundaries, each}}
\DoxyCodeLine{ \textcolor{comment}{// represented by its own polyline}}
\DoxyCodeLine{ Vector<TriangleMeshCurveSection*> hole\_polyline\_pt(2);}

\end{DoxyCodeInclude}
 We create the vertex coordinates for the upper half of the polygonal hole,


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// First boundary of polygonal hole}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Vertex coordinates}}
\DoxyCodeLine{ Vector<Vector<double> > bound\_hole(n\_seg+1);}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ipoint=0; ipoint<n\_seg+1;ipoint++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Resize the vector }}
\DoxyCodeLine{   bound\_hole[ipoint].resize(2);}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Get the coordinates}}
\DoxyCodeLine{   zeta[0]=unit\_zeta*double(ipoint);}
\DoxyCodeLine{   polygon\_ellipse\_pt-\/>position(zeta,posn);}
\DoxyCodeLine{   bound\_hole[ipoint][0]=posn[0]+x\_center;}
\DoxyCodeLine{   bound\_hole[ipoint][1]=posn[1]+y\_center;}
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
 and build the {\ttfamily Triangle\+Mesh\+Poly\+Line}, specifying a boundary ID\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Specify the hole boundary id}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} boundary\_id=2;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Build the 1st hole polyline}}
\DoxyCodeLine{ hole\_polyline\_pt[0] = \textcolor{keyword}{new} TriangleMeshPolyLine(bound\_hole,boundary\_id);}

\end{DoxyCodeInclude}
 We repeat the exercise for the lower half which we turn into boundary 4\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Second boundary of polygonal hole}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ipoint=0; ipoint<n\_seg+1;ipoint++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Resize the vector }}
\DoxyCodeLine{   bound\_hole[ipoint].resize(2);}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Get the coordinates}}
\DoxyCodeLine{   zeta[0]=(unit\_zeta*double(ipoint))+MathematicalConstants::Pi;}
\DoxyCodeLine{   polygon\_ellipse\_pt-\/>position(zeta,posn);}
\DoxyCodeLine{   bound\_hole[ipoint][0]=posn[0]+x\_center;}
\DoxyCodeLine{   bound\_hole[ipoint][1]=posn[1]+y\_center;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Specify the hole boundary id}}
\DoxyCodeLine{ boundary\_id=3;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Build the 2nd hole polyline}}
\DoxyCodeLine{ hole\_polyline\_pt[1] = \textcolor{keyword}{new} TriangleMeshPolyLine(bound\_hole,boundary\_id);}

\end{DoxyCodeInclude}
 Finally, we build the polygonal hole itself, specifying its constituent {\ttfamily Triangle\+Mesh\+Poly\+Lines} and the coordinate of a point inside the hole, which is required by {\ttfamily Triangle\+:} 


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Build the polygonal hole }}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Inner hole center coordinates}}
\DoxyCodeLine{ Vector<double> hole\_center(2);}
\DoxyCodeLine{ hole\_center[0]=x\_center;}
\DoxyCodeLine{ hole\_center[1]=y\_center;}
\DoxyCodeLine{}
\DoxyCodeLine{ hole\_pt[0] = \textcolor{keyword}{new} TriangleMeshPolygon(hole\_polyline\_pt, hole\_center);}

\end{DoxyCodeInclude}
 The construction of the second, curvilinear internal boundary (an ellipse centred at the origin) is virtually identical to the steps taken for the construction of the outer boundary, apart from the fact that, as an internal boundary, it again requires the specification of a point inside the hole.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Build curvilinear hole}}
\DoxyCodeLine{ \textcolor{comment}{//======================}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Build second hole: Another ellipse}}
\DoxyCodeLine{ A = 0.2;}
\DoxyCodeLine{ B = 0.1;}
\DoxyCodeLine{ Ellipse* ellipse\_pt=\textcolor{keyword}{new} Ellipse(A,B);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Build the two parts of the curvilinear boundary}}
\DoxyCodeLine{ Vector<TriangleMeshCurveSection*> curvilinear\_boundary\_pt(2);}
\DoxyCodeLine{ }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// First part of curvilinear boundary}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} zeta\_start=0.0;}
\DoxyCodeLine{ \textcolor{keywordtype}{double} zeta\_end=MathematicalConstants::Pi;}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nsegment=10;}
\DoxyCodeLine{ boundary\_id=4;}
\DoxyCodeLine{ curvilinear\_boundary\_pt[0]=\textcolor{keyword}{new} TriangleMeshCurviLine(}
\DoxyCodeLine{  ellipse\_pt,zeta\_start,zeta\_end, }
\DoxyCodeLine{  nsegment,boundary\_id);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Second part of curvilinear boundary}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ zeta\_start=MathematicalConstants::Pi;}
\DoxyCodeLine{ zeta\_end=2.0*MathematicalConstants::Pi;}
\DoxyCodeLine{ nsegment=15;}
\DoxyCodeLine{ boundary\_id=5;}
\DoxyCodeLine{ curvilinear\_boundary\_pt[1]=\textcolor{keyword}{new} TriangleMeshCurviLine(}
\DoxyCodeLine{  ellipse\_pt,zeta\_start,zeta\_end, }
\DoxyCodeLine{  nsegment,boundary\_id);}
\DoxyCodeLine{ }
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Combine to hole}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ Vector<double> hole\_coords(2);}
\DoxyCodeLine{ hole\_coords[0]=0.0;}
\DoxyCodeLine{ hole\_coords[1]=0.0;}
\DoxyCodeLine{ Vector<TriangleMeshClosedCurve*> curvilinear\_hole\_pt(1);}
\DoxyCodeLine{ hole\_pt[1]=}
\DoxyCodeLine{  \textcolor{keyword}{new} TriangleMeshClosedCurve(curvilinear\_boundary\_pt,}
\DoxyCodeLine{                                                 hole\_coords);}

\end{DoxyCodeInclude}
 \hypertarget{index_build_mesh}{}\doxysubsection{Construct the mesh}\label{index_build_mesh}
To facilitate the construction of the mesh {\ttfamily Triangle\+Mesh} object we use the object {\ttfamily Triangle\+Mesh\+Parameters}. The only necessary argument for creating this object is the outer boundary. The definition of holes, internal boundaries and regions is explained in \href{../../../../doc/meshes/mesh_from_inline_triangle_internal_boundaries/html/index.html}{\texttt{ another tutorial}}. The object can also be used to control whether additional refinement may be performed on the mesh boundaries. The default behaviour is that such refinement will occur so that the highest quality mesh is obtained. In some cases, e.\+g. periodic boundary conditions, you may wish to ensure that each input boundary segment corresponds to a single element edge in the final mesh. This can be achieved for the outer boundary by calling {\ttfamily Triangle\+Mesh\+Parameters\+::disable\+\_\+boundary\+\_\+refinement()}. However, Triangle will still add additional points to any internal boundaries unless the additional function {\ttfamily Triangle\+Mesh\+Parameters\+::disable\+\_\+internal\+\_\+boundary\+\_\+refinement()} is also called. The functions {\ttfamily Triangle\+Mesh\+Parameters\+::enable\+\_\+boundary\+\_\+refinement()} and {\ttfamily Triangle\+Mesh\+Parameters\+::enable\+\_\+internal\+\_\+boundary\+\_\+refinement()} can be used to return to the default behaviour. Note that it is not currently possible to suppress refinement on the internal boundaries, but refine the outer boundary.

We can specify a target for the element sizes and pass it to the {\ttfamily Triangle\+Mesh\+Parameters} object as showed next\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Now build the mesh}}
\DoxyCodeLine{ \textcolor{comment}{//===================}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Use the TriangleMeshParameters object for helping on the manage of the}}
\DoxyCodeLine{ \textcolor{comment}{// TriangleMesh parameters}}
\DoxyCodeLine{ TriangleMeshParameters triangle\_mesh\_parameters(closed\_curve\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Specify the closed curve using the TriangleMeshParameters object}}
\DoxyCodeLine{ triangle\_mesh\_parameters.internal\_closed\_curve\_pt() = hole\_pt;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Specify the maximum area element}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} uniform\_element\_area=0.2;}
\DoxyCodeLine{ triangle\_mesh\_parameters.element\_area() = uniform\_element\_area;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Create the mesh}}
\DoxyCodeLine{ My\_mesh\_pt=\textcolor{keyword}{new} }
\DoxyCodeLine{  RefineableTriangleMesh<ELEMENT>(triangle\_mesh\_parameters);}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Store as the problem's one and only mesh}}
\DoxyCodeLine{ Problem::mesh\_pt()=My\_mesh\_pt;}

\end{DoxyCodeInclude}
 We specify a spatial error estimator and limit the maximum and minimum element sizes,


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set error estimator for bulk mesh}}
\DoxyCodeLine{ Z2ErrorEstimator* error\_estimator\_pt=\textcolor{keyword}{new} Z2ErrorEstimator;}
\DoxyCodeLine{ My\_mesh\_pt-\/>spatial\_error\_estimator\_pt()=error\_estimator\_pt;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set element size limits}}
\DoxyCodeLine{ My\_mesh\_pt-\/>max\_element\_size()=0.2;}
\DoxyCodeLine{ My\_mesh\_pt-\/>min\_element\_size()=0.002; }

\end{DoxyCodeInclude}
 before completing the problem setup (see below) and assigning the equation numbers.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Set boundary condition and complete the build of all elements}}
\DoxyCodeLine{ complete\_problem\_setup();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Open trace file}}
\DoxyCodeLine{ \textcolor{keywordtype}{char} filename[100];}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}RESLT/trace.dat"{}});}
\DoxyCodeLine{ Trace\_file.open(filename);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup equation numbering scheme}}
\DoxyCodeLine{ oomph\_info <<\textcolor{stringliteral}{"{}Number of equations: "{}} }
\DoxyCodeLine{            << this-\/>assign\_eqn\_numbers() << std::endl;}
\DoxyCodeLine{ }
\DoxyCodeLine{\} \textcolor{comment}{// end\_of\_constructor}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_complete}{}\doxysection{Completing the problem setup}\label{index_complete}
As discussed above, the helper function {\ttfamily complete\+\_\+problem\+\_\+setup()} starts by (re-\/)applying the boundary conditions by pinning the nodal values on all mesh boundaries,


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_complete======================================================}}
\DoxyCodeLine{\textcolor{comment}{ /// Set boundary condition exactly, and complete the build of }\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// all elements}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classUnstructuredPoissonProblem_a5cbf00790e8469b43c64c6aaadfe7b41}{UnstructuredPoissonProblem<ELEMENT>::complete\_problem\_setup}}()}
\DoxyCodeLine{\{   }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set the boundary conditions for problem: All nodes are}}
\DoxyCodeLine{ \textcolor{comment}{// free by default -\/-\/ just pin the ones that have Dirichlet conditions}}
\DoxyCodeLine{ \textcolor{comment}{// here. }}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nbound=My\_mesh\_pt-\/>nboundary();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<nbound;ibound++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} num\_nod=My\_mesh\_pt-\/>nboundary\_node(ibound);}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{comment}{// Get node}}
\DoxyCodeLine{     Node* nod\_pt=My\_mesh\_pt-\/>boundary\_node\_pt(ibound,inod);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Pin one-\/and-\/only unknown value}}
\DoxyCodeLine{     nod\_pt-\/>pin(0);}
\DoxyCodeLine{    \}   }
\DoxyCodeLine{  \} \textcolor{comment}{// end loop over boundaries}}

\end{DoxyCodeInclude}
 specifies the source function pointer for all elements,


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Complete the build of all elements so they are fully functional}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_element = My\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Upcast from GeneralisedElement to the present element}}
\DoxyCodeLine{   ELEMENT* el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(My\_mesh\_pt-\/>element\_pt(e));}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{//Set the source function pointer}}
\DoxyCodeLine{   el\_pt-\/>source\_fct\_pt() = \&\mbox{\hyperlink{namespaceTanhSolnForPoisson_ae1b9d6789ff301e3d63a4e292213036c}{TanhSolnForPoisson::get\_source}};}
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
 and then re-\/sets the boundary values\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Re-\/apply Dirichlet boundary conditions (projection ignores}}
\DoxyCodeLine{ \textcolor{comment}{// boundary conditions!)}}
\DoxyCodeLine{ apply\_boundary\_conditions();}
\DoxyCodeLine{\}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_bc}{}\doxysection{Assigning the boundary values}\label{index_bc}
The function {\ttfamily apply\+\_\+boundary\+\_\+conditions()} does exactly what is says\+: It loops over all boundary nodes and assigns the value according the exact solution specified in the namespace {\ttfamily \mbox{\hyperlink{namespaceTanhSolnForPoisson}{Tanh\+Soln\+For\+Poisson}}}.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_apply\_bc=====================================================}}
\DoxyCodeLine{\textcolor{comment}{ /// Helper function to apply boundary conditions}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classUnstructuredPoissonProblem_ace8b8b3097ae2024a0589b2bf9b4ee7b}{UnstructuredPoissonProblem<ELEMENT>::apply\_boundary\_conditions}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Loop over all boundary nodes}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nbound=this-\/>My\_mesh\_pt-\/>nboundary();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<nbound;ibound++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{keywordtype}{unsigned} num\_nod=this-\/>My\_mesh\_pt-\/>nboundary\_node(ibound);}
\DoxyCodeLine{   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{comment}{// Get node}}
\DoxyCodeLine{     Node* nod\_pt=this-\/>My\_mesh\_pt-\/>boundary\_node\_pt(ibound,inod);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Extract nodal coordinates from node:}}
\DoxyCodeLine{     Vector<double> x(2);}
\DoxyCodeLine{     x[0]=nod\_pt-\/>x(0);}
\DoxyCodeLine{     x[1]=nod\_pt-\/>x(1);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Compute the value of the exact solution at the nodal point}}
\DoxyCodeLine{     Vector<double> u(1);}
\DoxyCodeLine{     \mbox{\hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{TanhSolnForPoisson::get\_exact\_u}}(x,u);}
\DoxyCodeLine{     }
\DoxyCodeLine{     \textcolor{comment}{// Assign the value to the one (and only) nodal value at this node}}
\DoxyCodeLine{     nod\_pt-\/>set\_value(0,u[0]);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \} }
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end set bc}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_doc}{}\doxysection{Post-\/processing}\label{index_doc}
We compare the computed solution against the exact solution\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_doc\_solution=================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Doc the solution}}
\DoxyCodeLine{\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classUnstructuredPoissonProblem_a9b21a3c3f574da71411f852006fe2a0c}{UnstructuredPoissonProblem<ELEMENT>::doc\_solution}}(\textcolor{keyword}{const} }
\DoxyCodeLine{                                                       std::string\& comment)}
\DoxyCodeLine{\{ }
\DoxyCodeLine{ ofstream some\_file;}
\DoxyCodeLine{ \textcolor{keywordtype}{char} filename[100];}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Number of plot points}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} npts;}
\DoxyCodeLine{ npts=5; }
\DoxyCodeLine{ }
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}RESLT/soln\%i.dat"{}},Doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ this-\/>My\_mesh\_pt-\/>output(some\_file,npts); }
\DoxyCodeLine{ some\_file << \textcolor{stringliteral}{"{}TEXT X = 22, Y = 92, CS=FRAME T = \(\backslash\)"{}"{}} }
\DoxyCodeLine{           << comment << \textcolor{stringliteral}{"{}\(\backslash\)"{}\(\backslash\)n"{}};}
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Output exact solution }}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}RESLT/exact\_soln\%i.dat"{}},Doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ My\_mesh\_pt-\/>output\_fct(some\_file,npts,\mbox{\hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{TanhSolnForPoisson::get\_exact\_u}}); }
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Output boundaries}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}RESLT/boundaries\%i.dat"{}},Doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ My\_mesh\_pt-\/>output\_boundaries(some\_file);}
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Doc error and return of the square of the L2 error}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} error,norm,dummy\_error,zero\_norm;}
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}RESLT/error\%i.dat"{}},Doc\_info.number());}
\DoxyCodeLine{ some\_file.open(filename);}
\DoxyCodeLine{ My\_mesh\_pt-\/>compute\_error(some\_file,\mbox{\hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{TanhSolnForPoisson::get\_exact\_u}},}
\DoxyCodeLine{                           error,norm); }
\DoxyCodeLine{ }
\DoxyCodeLine{ My\_mesh\_pt-\/>compute\_error(some\_file,\mbox{\hyperlink{namespaceTanhSolnForPoisson_a5cd8441c6e87d4bc153697eff13513dd}{TanhSolnForPoisson::zero}},}
\DoxyCodeLine{                           dummy\_error,zero\_norm); }
\DoxyCodeLine{ some\_file.close();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Doc L2 error and norm of solution}}
\DoxyCodeLine{ oomph\_info << \textcolor{stringliteral}{"{}\(\backslash\)nNorm of error   : "{}} << sqrt(error) << std::endl; }
\DoxyCodeLine{ oomph\_info << \textcolor{stringliteral}{"{}Norm of exact solution: "{}} << sqrt(norm) << std::endl;}
\DoxyCodeLine{ oomph\_info << \textcolor{stringliteral}{"{}Norm of computed solution: "{}} << sqrt(dummy\_error) << std::endl;}
\DoxyCodeLine{ Trace\_file << sqrt(norm) << \textcolor{stringliteral}{"{} "{}} << sqrt(dummy\_error) << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Increment the doc\_info number}}
\DoxyCodeLine{ Doc\_info.number()++;}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of doc}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comments}{}\doxysection{Comments and Exercises}\label{index_comments}
\hypertarget{index_wrapper}{}\doxysubsection{Upgrading elements to become \char`\"{}projectable\char`\"{}}\label{index_wrapper}
As discussed above, a key step in the \char`\"{}mesh-\/adaptation-\/by-\/mesh-\/regeneration\char`\"{} procedure is the projection of the solution from the old to the new mesh. The ability to perform this projection fully-\/automatically during the mesh adaptation requires the elements to be \char`\"{}wrapped\char`\"{} in the templated {\ttfamily Projectable\+Element$<$\+ELEMENT$>$} class. This class is derived from the {\ttfamily Projectable\+Element\+Base} base class which specifies a number of pure virtual functions that must be specified for each specific element type. For the Poisson problem considered here these functions are already provided in the {\ttfamily Projectable\+Poisson\+Element$<$\+ELEMENT$>$} class. Similar wrappers exist for many other equations. If you want to \char`\"{}upgrade\char`\"{} your own elements to become projectable, inspect the prototypes for the relevant pure virtual functions which are defined in

\begin{center} \href{../../../../src/generic/projection.h}{\texttt{ src/generic/projection.\+h }} \end{center} 

while the specific implementation for the projectable Poisson elements is provided in

\begin{center} \href{../../../../src/poisson/poisson_elements.h}{\texttt{ src/poisson/poisson\+\_\+elements.\+h }} \end{center} 

Of course, you can avoid the additional work by dispensing with adaptivity and simply generating a sufficiently fine (uniform) mesh. This is illustrated in the alternative driver code \begin{center} \href{../../../../demo_drivers/meshing/mesh_from_inline_triangle/mesh_from_inline_triangle_no_adapt.cc}{\texttt{ demo\+\_\+drivers/meshing/mesh\+\_\+from\+\_\+inline\+\_\+triangle/mesh\+\_\+from\+\_\+inline\+\_\+triangle\+\_\+no\+\_\+adapt.\+cc }} \end{center} 

\DoxyHorRuler{0}
\hypertarget{index_how_many_segments}{}\doxysubsection{How many vertices should I use to sample my curvilinear boundary?}\label{index_how_many_segments}
As discussed above, meshes with curvilinear boundaries are created in a two-\/stage process. Initially, Triangle generates a mesh with polygonal boundaries using a user-\/specified number of vertices that are evenly distributed along the relevant {\ttfamily Geom\+Object}. The nodes on that boundary are then \char`\"{}snapped\char`\"{} onto the actual curvilinear boundary in a post-\/processing step. The decision of how many vertices to choose involves a compromise between two conflicting demands\+:
\begin{DoxyItemize}
\item The number of boundary nodes created by Triangle will be at least as big as the number of vertices specified. Triangle may add additional boundary nodes to generate a mesh of sufficient quality but it will not remove any vertices. Using a very large number of vertices can therefore lead to unnecessarily fine meshes. ~\newline
~\newline

\item If the number of vertices is too small, the polygonal representation of the domain boundary may be a poor approximation to the actual curvilinear boundary. Elements near such boundaries may become (too) strongly distorted when nodes are \char`\"{}snapped\char`\"{} onto the curvilinear boundary. This often manifests itself in inverted elements. (An element is considered inverted if the Jacobian of the mapping between local and global coordinates becomes non-\/positive anywhere. Note that negative Jacobians may occur in the interior of elements (e.\+g. at their Gauss points) even if a plot of the element, based on its nodal positions, still looks \char`\"{}\+OK\char`\"{}).
\end{DoxyItemize}\DoxyHorRuler{0}
\hypertarget{index_ex}{}\doxysubsection{Exercises}\label{index_ex}

\begin{DoxyEnumerate}
\item Change the outer curvilinear boundary to a polygonal boundary (you can cheat -- the relevant code is already contained in the driver code but it\textquotesingle{}s \char`\"{}hidden\char`\"{} with {\ttfamily ifdefs}; this code also documents the re-\/distribution of straight-\/line segments between different polylines, a capability that is important in certain free-\/boundary problems). ~\newline
~\newline

\item Vary the number of vertices used for the initial polygonal representation of the curvilinear hole to establish what number is required to avoid the inversion of elements during the \char`\"{}snap-\/nodes-\/to-\/the-\/curvilinear-\/boundary\char`\"{} phase. ~\newline
~\newline

\item Create \char`\"{}projectable\char`\"{} advection diffusion elements to solve the the advection diffusion problem discussed in \href{../../../../doc/advection_diffusion/two_d_adv_diff_adapt/html/index.html}{\texttt{ another tutorial,}} using spatial adaptation on an unstructured mesh. ~\newline
~\newline

\end{DoxyEnumerate}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/meshing/mesh_from_triangle/}{\texttt{ demo\+\_\+drivers/meshing/mesh\+\_\+from\+\_\+inline\+\_\+triangle/ }} \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/meshing/mesh_from_inline_triangle/mesh_from_inline_triangle.cc}{\texttt{ demo\+\_\+drivers/meshing/mesh\+\_\+from\+\_\+inline\+\_\+triangle/mesh\+\_\+from\+\_\+inline\+\_\+triangle.\+cc }} \end{center}  ~\newline
~\newline

\item The additional driver code ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/meshing/mesh_from_inline_triangle/mesh_from_inline_triangle_no_adapt.cc}{\texttt{ demo\+\_\+drivers/meshing/mesh\+\_\+from\+\_\+inline\+\_\+triangle/mesh\+\_\+from\+\_\+inline\+\_\+triangle\+\_\+no\+\_\+adapt.\+cc }} \end{center}  ~\newline
shows how to generate non-\/refineable triangle meshes inline. This code does not require any modifications to existing triangular elements.
\end{DoxyItemize}\hypertarget{index_curve_sections}{}\doxysection{Appendix A\+: Generalization for polylines and curvilines}\label{index_curve_sections}
The objects, {\ttfamily Triangle\+Mesh\+Poly\+Line} and {\ttfamily Triangle\+Mesh\+Curvi\+Line} inherit the properties of a more general representation called {\ttfamily Triangle\+Mesh\+Curve\+Section}. This allows one to define more general boundaries as a combination of {\ttfamily Triangle\+Mesh\+Poly\+Lines} and {\ttfamily Triangle\+Mesh\+Curvi\+Lines}. Therefore, if we want to define a more general closed curve use the {\ttfamily Triangle\+Mesh\+Closed\+Curve} object. You may notice the use of this object through the example code when defining the outer boundary.

For the interested reader, the class diagram showing the hierarchy of the mentioned objects is showed on the next figure.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{class_diagram}
\doxyfigcaption{The hierarchy of the {\ttfamily Triangle\+Mesh} objects. }
\end{DoxyImage}


Note the {\ttfamily Triangle\+Mesh\+Open\+Curve} object, which allows to define internal boundaries on the domain, explained on \href{../../../../doc/meshes/mesh_from_inline_triangle_internal_boundaries/html/index.html}{\texttt{ another tutorial}}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{PDF file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
