<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Demo problem: A one-dimensional eigenproblem</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Demo problem: A one-dimensional eigenproblem </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this document, we demonstrate how to solve a 1D eigenproblem (eigenvalues of the 1D Laplace operator in a bounded domain) by creating custom elements. The tutorial is similar in spirit to the <a href="../../../quick_guide/html/index.html">quick guide </a> but far less detailed. </p><center> <table class="doxtable">
<tr>
<td><center> <b>One-dimensional model eigenvalue problem</b> </center> Solve <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial^2u}{\partial x_1^2} + \lambda u = 0, \ \ \ \ \ \ \ \ \ \ (1) \]" src="form_0.png" width="136" height="33"/>
</p>
 in the domain <img class="formulaInl" alt="$D =\left\{ x_1 \in [0,1] \right\}$" src="form_1.png" width="93" height="14"/>, with homogeneous Dirichlet boundary conditions <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left. u\right|_{\partial D}=0. \ \ \ \ \ \ \ \ \ \ (2) \]" src="form_2.png" width="109" height="14"/>
</p>
   </td></tr>
</table>
<br  />
 </center><p>An eigenfunction must be non-zero by definition and so the exact solutions are given by the countably infinite set: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_{n} = \sin (\sqrt{\lambda}_{n} x_{1}), \ \ \ \ \ \ \ \lambda_{n} = n^{2}\pi^{2}. \]" src="form_3.png" width="188" height="16"/>
</p>
<p>We provide a detailed discussion of the driver code <a href="../../../../demo_drivers/eigenproblems/harmonic/harmonic.cc">harmonic.cc</a> which solves the problem for the first four eigenvalues.</p>
<p>In <code>oomph-lib</code> all eigenproblems are solved by using interfaces to third-party libraries. The default is LAPACK's (direct) QZ solver which is included with the library. An interface is also provided to the ANASAZI solver, part of The Trilinos Project, a suite of iterative solvers. Thus, if you want to solve small problems, use the default QZ solver; for larger problems, we recommend using ANASAZI.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="theory"></a>
Overview of the theory</h1>
<p>A discrete (linear) eigenproblem takes the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ J_{ij} V_{j} = \lambda M_{ij} V_{j}, \ \ \ \ \ \ \ \ (3) \]" src="form_4.png" width="139" height="14"/>
</p>
<p> where <img class="formulaInl" alt="$ V_{j} $" src="form_5.png" width="11" height="14"/> is the vector of discrete unknowns, <img class="formulaInl" alt="$ \lambda $" src="form_6.png" width="8" height="10"/> is the eigenvalue, and <img class="formulaInl" alt="$ J_{ij} $" src="form_7.png" width="15" height="14"/> and <img class="formulaInl" alt="$ M_{ij} $" src="form_8.png" width="20" height="14"/> are two matrices: <img class="formulaInl" alt="$ J_{ij} $" src="form_7.png" width="15" height="14"/> (often denoted <img class="formulaInl" alt="$ K_{ij} $" src="form_9.png" width="19" height="14"/> in the literature) is known as the stiffness matrix and <img class="formulaInl" alt="$ M_{ij} $" src="form_8.png" width="20" height="14"/> is termed the mass matrix. The third-party libraries mentioned above all solve systems of the form (3), and within <code>oomph-lib</code> we must simply provide the required mass and stiffness matrices.</p>
<h2><a class="anchor" id="linear_stab"></a>
Linear Stability Theory</h2>
<p>In many cases, eigenproblems arise from linear stability analyses of steady solutions to our set of nonlinear residuals. For example, if we have a time-dependent system of equations </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial u}{\partial t} = \mathcal{F}(u), \]" src="form_10.png" width="63" height="28"/>
</p>
<p> then the residual formulation is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathcal{R}(u) = \mathcal{F}(u) - \frac{\partial u}{\partial t} = 0; \ \ \ \ \ \ \ (4) \]" src="form_11.png" width="178" height="28"/>
</p>
<p> and steady solutions, <img class="formulaInl" alt="$ u_{s} $" src="form_12.png" width="13" height="9"/> are found by setting <img class="formulaInl" alt="$ \partial u / \partial t = 0 $" src="form_13.png" width="55" height="14"/>. Note that in a nonlinear system there may be many possible steady solutions for the same set of parameter values.</p>
<p>A linear stability analysis proceeds by assuming that the steady solution is perturbed by a small amount, so that <img class="formulaInl" alt="$ u = u_{s} + \epsilon \hat{u} $" src="form_14.png" width="65" height="13"/>, where <img class="formulaInl" alt="$ |\epsilon| \ll 1$" src="form_15.png" width="36" height="14"/>. If we substitute this expression into the governing equation (4) and neglect terms that involve <img class="formulaInl" alt="$ \epsilon^{2} $" src="form_16.png" width="10" height="11"/> (on the assumption that they are really small) then we obtain the equation: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathcal{F}(u_{s}) + \epsilon \left[\frac{\partial \mathcal{F}(u_{s})}{\partial u} \hat{u} - \frac{\partial \hat{u}}{\partial t} \right] \approx 0. \]" src="form_17.png" width="176" height="31"/>
</p>
<p> Note that we have used a Taylor expansion of <img class="formulaInl" alt="$ \mathcal{F} $" src="form_18.png" width="11" height="11"/>, so we are assuming that such an operation "makes sense". The solution <img class="formulaInl" alt="$ u_{s} $" src="form_12.png" width="13" height="9"/> is a steady state, so by definition <img class="formulaInl" alt="$\mathcal{F}(u_{s}) = 0$" src="form_19.png" width="56" height="14"/> and then we are left with the <b>linear</b> equation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \mathcal{F} (u_{s})}{\partial u} \hat{u} = \mathcal{J}(u_{s}) \hat{u} = \frac{\partial \hat{u}}{\partial t}. \ \ \ \ \ \ \ \ \ (5) \]" src="form_20.png" width="196" height="29"/>
</p>
<p> The Jacobian <img class="formulaInl" alt="$ \mathcal{J} $" src="form_21.png" width="11" height="11"/> is exactly the same as that required by the Newton method when solving the steady set of equations, <img class="formulaInl" alt="$ \mathcal{F}(u) = 0.$" src="form_22.png" width="54" height="14"/></p>
<p>The general solution of equation (5) takes the form <img class="formulaInl" alt="$ \hat{u} = \mbox{e}^{\lambda t} v$" src="form_23.png" width="48" height="11"/> because the only function that is proportional to its derivative is the exponential. The necessary functional form of the solution means that equation (5) becomes </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathcal{J}(u_{s}) v = \lambda v, \]" src="form_24.png" width="74" height="14"/>
</p>
<p> which is an eigenproblem in which the mass "matrix" is the identity. Thus, in order to assess the stability of a solution to our nonlinear system we must solve an eigenproblem using the Jacobian matrix, which is why we used the notation <img class="formulaInl" alt="$ J_{ij} $" src="form_7.png" width="15" height="14"/> rather than <img class="formulaInl" alt="$ K_{ij} $" src="form_9.png" width="19" height="14"/> in equation (3). The solution is said to be linearly stable if the real part of all eigenvalues is negative because then the perturbation decays as <img class="formulaInl" alt="$ t \to \infty$" src="form_25.png" width="38" height="9"/>, but it is linearly unstable if even a single eigenvalue has positive real part. Note that in even more general equations the mass "matrix" is not necessarily the identity.</p>
<h2><a class="anchor" id="weak"></a>
Weak formulation of the problem</h2>
<p>If we wish to solve the problem (1) using finite elements, we must first derive the weak form, which follows from the standard procedure of multiplication by a test function and integration by parts </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{D} \frac{\partial u}{\partial x_{1}} \frac{\partial \phi^{(test)}}{\partial x_{1}}\,\mbox{d} x_{1} = \lambda \int_{D} u\, \phi^{(test)}\,\mbox{d} x_{1}. \]" src="form_26.png" width="216" height="33"/>
</p>
<p> Note that the boundary terms are neglected as a consequence of the Dirichlet boundary conditions.</p>
<p>If we expand the <img class="formulaInl" alt="$ u(x_{1}) = V_{j} \psi_{j}(x_{1}) $" src="form_27.png" width="95" height="14"/> in terms of known basis functions <img class="formulaInl" alt="$ \psi_{j} $" src="form_28.png" width="14" height="14"/> and use the same basis functions as our test functions (Galerkin method), then the weak form becomes </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{D} \frac{\partial \psi_{j}}{\partial x_{1}} \frac{\partial \psi_{i}}{\partial x_{1}}\,\mbox{d} x_{1} V_{j} = \lambda \int_{D} \psi_{i} \psi_{j}\,\mbox{d} x_{1} V_{j}. \]" src="form_29.png" width="206" height="30"/>
</p>
<p> On comparison with equation (3), we identify the Jacobian and mass matrices </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ J_{ij} = \int_{D} \frac{\partial \psi_{j}}{\partial x_{1}} \frac{\partial \psi_{i}}{\partial x_{1}}\,\mbox{d} x_{1}, \ \ \ \ \ M_{ij} = \int_{D} \psi_{i} \psi_{j}\,\mbox{d} x_{1}. \ \ \ \ \ (6) \]" src="form_30.png" width="286" height="30"/>
</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="impl"></a>
Implementation</h1>
<p>In <code>oomph-lib</code>, eigenproblems are formulated on an element-by-element basis in a similar way to standard problems. Eigenproblems make use of the function </p><div class="fragment"><div class="line">GeneralisedElement::get_jacobian_and_mass_matrix(</div>
<div class="line">  Vector&lt;double&gt; &amp;residuals, </div>
<div class="line">  DenseMatrix&lt;double&gt; &amp;jacobian,</div>
<div class="line">  DenseMatrix&lt;double&gt; &amp;mass_matrix);</div>
</div><!-- fragment --><p> where the Jacobian is the matrix <img class="formulaInl" alt="$J_{ij}$" src="form_31.png" width="15" height="14"/> and the mass matrix is <img class="formulaInl" alt="$M_{ij}$" src="form_32.png" width="20" height="14"/> in equation (3). The residuals need not be returned when solving an eigenproblem, but the interface is chosen so that linear stability of solutions to the nonlinear system can easily be calculated without reformulating the problem.</p>
<p>Once again, to avoid reinitialisation in multi-physics problems, the helper function </p><div class="fragment"><div class="line">GeneralisedElement::fill_in_contribution_to_jacobian_and_mass_matrix(</div>
<div class="line">  Vector&lt;double&gt; &amp;residuals, </div>
<div class="line">  DenseMatrix&lt;double&gt; &amp;jacobian,</div>
<div class="line">  DenseMatrix&lt;double&gt; &amp;mass_matrix);</div>
</div><!-- fragment --><p> is used and this will be overloaded in our custom elements below.</p>
<h2><a class="anchor" id="equations"></a>
Creating the elements</h2>
<p>For generality, we implement the mathematics to assemble contributions to the Jacobian and mass matrices defined in equations (6) in the class <code>HarmonicEquations</code> that inherits from <code>FiniteElement</code>. This construction mirrors that in our standard equation classes and allows a clean separation between the equations and the choice of basis function.</p>
 <div class="fragment"><div class="line"><span class="comment">/// A class for all elements that solve the simple one-dimensional</span></div>
<div class="line"><span class="comment">/// eigenvalue problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// \f[ </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// \frac{\partial^2 u}{\partial x_i^2}  + \lambda u = 0</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// \f] </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// These elements are very closely related to the Poisson</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// elements and could inherit from them. They are here developed</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// from scratch for pedagogical purposes.</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// This class  contains the generic maths. Shape functions, geometric</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// mapping etc. must get implemented in derived class.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//================================================================</span></div>
<div class="line"><span class="keyword">class </span>HarmonicEquations : <span class="keyword">public</span> <span class="keyword">virtual</span> FiniteElement</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><span class="comment"> /// Empty Constructor</span></div>
<div class="line"><span class="comment"></span> HarmonicEquations() {}</div>
</div><!-- fragment --><p> The unknowns that represent the discretised eigenfunction are assumed to be stored at the nodes.</p>
<div class="fragment"><div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Access function: Eigenfunction value at local node n</span></div>
<div class="line"><span class="comment"> /// Note that solving the eigenproblem does not assign values</span></div>
<div class="line"><span class="comment"> /// to this storage space. It is used for output purposes only.</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">double</span> u(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; n)<span class="keyword"> const </span></div>
<div class="line"><span class="keyword">  </span>{<span class="keywordflow">return</span> nodal_value(n,0);}</div>
</div><!-- fragment --><p> The class contains functions to output the eigenfunction; interpolate the nodal unknown; and provides interfaces for the shape functions and their derivatives. The key function is <code>fill_in_contribution_to_jacobian_and_mass_matrix</code> which implements the calculation of the equations (6). The residuals vector is not filled in and does not need to be unless we also wish to solve an associated (non-eigen) problem.</p>
<div class="fragment"><div class="line"> <span class="keywordtype">void</span> fill_in_contribution_to_jacobian_and_mass_matrix(</div>
<div class="line">  Vector&lt;double&gt; &amp;residuals,</div>
<div class="line">  DenseMatrix&lt;double&gt; &amp;jacobian, DenseMatrix&lt;double&gt; &amp;mass_matrix)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Find out how many nodes there are</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_node = nnode();</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Set up memory for the shape functions and their derivatives</span></div>
<div class="line">   Shape psi(n_node);</div>
<div class="line">   DShape dpsidx(n_node,1);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Set the number of integration points</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> n_intpt = integral_pt()-&gt;nweight();</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Integers to store the local equation and unknown numbers</span></div>
<div class="line">   <span class="keywordtype">int</span> local_eqn=0, local_unknown=0;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Loop over the integration points</span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ipt=0;ipt&lt;n_intpt;ipt++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">//Get the integral weight</span></div>
<div class="line">     <span class="keywordtype">double</span> w = integral_pt()-&gt;weight(ipt);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">//Call the derivatives of the shape and test functions</span></div>
<div class="line">     <span class="keywordtype">double</span> J = dshape_eulerian_at_knot(ipt,psi,dpsidx);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">//Premultiply the weights and the Jacobian</span></div>
<div class="line">     <span class="keywordtype">double</span> W = w*J;</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//Assemble the contributions to the mass matrix</span></div>
<div class="line">     <span class="comment">//Loop over the test functions</span></div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> l=0;l&lt;n_node;l++)</div>
<div class="line">      {</div>
<div class="line">       <span class="comment">//Get the local equation number</span></div>
<div class="line">       local_eqn = u_local_eqn(l);</div>
<div class="line">       <span class="comment">/*IF it&#39;s not a boundary condition*/</span></div>
<div class="line">       <span class="keywordflow">if</span>(local_eqn &gt;= 0)</div>
<div class="line">        {</div>
<div class="line">         <span class="comment">//Loop over the shape functions</span></div>
<div class="line">         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> l2=0;l2&lt;n_node;l2++)</div>
<div class="line">          { </div>
<div class="line">           local_unknown = u_local_eqn(l2);</div>
<div class="line">           <span class="comment">//If at a non-zero degree of freedom add in the entry</span></div>
<div class="line">           <span class="keywordflow">if</span>(local_unknown &gt;= 0)</div>
<div class="line">            {</div>
<div class="line">             jacobian(local_eqn,local_unknown) += dpsidx(l,0)*dpsidx(l2,0)*W;</div>
<div class="line">             mass_matrix(local_eqn, local_unknown) += psi(l)*psi(l2)*W;</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">//end_of_fill_in_contribution_to_jacobian_and_mass_matrix</span></div>
</div><!-- fragment --><p>The shape functions are specified in the <code><a class="el" href="classQHarmonicElement.html" title="QHarmonicElement&lt;NNODE_1D&gt; elements are 1D Elements with NNODE_1D nodal points that are used to solve...">QHarmonicElement</a></code> class that inherits from our standard one-dimensional Lagrange elements <code>QElement&lt;1,NNODE_1D&gt;</code> as well as <code>HarmonicEquations</code>. The number of unknowns (one) is specified and the output functions and shape functions are overloaded as required: the output functions are specified in the <code>HarmonicEquations</code> class, whereas the shape functions are provided by the <code>QElement&lt;1,NNODE_1D&gt;</code> class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> NNODE_1D&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classQHarmonicElement.html">QHarmonicElement</a> : <span class="keyword">public</span> <span class="keyword">virtual</span> QElement&lt;1,NNODE_1D&gt;, </div>
<div class="line">                         <span class="keyword">public</span> HarmonicEquations</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Constructor: Call constructors for QElement and </span></div>
<div class="line"><span class="comment"> /// Poisson equations</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classQHarmonicElement.html#a0e7480a0064b51e87ba197551bb10373">QHarmonicElement</a>() : QElement&lt;1,NNODE_1D&gt;(), HarmonicEquations() {}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> ///  Required  # of `values&#39; (pinned or dofs) </span></div>
<div class="line"><span class="comment"> /// at node n</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <a class="code" href="classQHarmonicElement.html#a8574a452983b15fb2b4d40ec4ef3e890">required_nvalue</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;n)<span class="keyword"> const </span>{<span class="keywordflow">return</span> 1;}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Output function overloaded from HarmonicEquations</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classQHarmonicElement.html#a8b38012f3d62ef419c359f5e545e5f85">output</a>(ostream &amp;outfile) </div>
<div class="line">  {HarmonicEquations::output(outfile);}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> ///  Output function overloaded from HarmonicEquations</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classQHarmonicElement.html#a8b38012f3d62ef419c359f5e545e5f85">output</a>(ostream &amp;outfile, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;Nplot) </div>
<div class="line">  {HarmonicEquations::output(outfile,Nplot);}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/// Shape, test functions &amp; derivs. w.r.t. to global coords. Return Jacobian.</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="classQHarmonicElement.html#a206b7334e82cb563d7d575deb9f755b1">dshape_eulerian</a>(<span class="keyword">const</span> Vector&lt;double&gt; &amp;s, </div>
<div class="line">                               Shape &amp;psi, </div>
<div class="line">                               DShape &amp;dpsidx)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{<span class="keywordflow">return</span> QElement&lt;1,NNODE_1D&gt;::dshape_eulerian(s,psi,dpsidx);}</div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Shape, test functions &amp; derivs. w.r.t. to global coords. at</span></div>
<div class="line"><span class="comment"> /// integration point ipt. Return Jacobian.</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="classQHarmonicElement.html#a6b11b5a42bd20c4e1d1e9840ba22a80a">dshape_eulerian_at_knot</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ipt,</div>
<div class="line">                                       Shape &amp;psi, </div>
<div class="line">                                       DShape &amp;dpsidx)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{<span class="keywordflow">return</span> QElement&lt;1,NNODE_1D&gt;::dshape_eulerian_at_knot(ipt,psi,dpsidx);}</div>
<div class="line"> </div>
<div class="line">}; <span class="comment">//end_of_QHarmonic_class_definition</span></div>
<div class="ttc" id="aclassQHarmonicElement_html"><div class="ttname"><a href="classQHarmonicElement.html">QHarmonicElement</a></div><div class="ttdoc">QHarmonicElement&lt;NNODE_1D&gt; elements are 1D Elements with NNODE_1D nodal points that are used to solve...</div><div class="ttdef"><b>Definition:</b> <a href="harmonic_8cc_source.html#l00222">harmonic.cc:224</a></div></div>
<div class="ttc" id="aclassQHarmonicElement_html_a0e7480a0064b51e87ba197551bb10373"><div class="ttname"><a href="classQHarmonicElement.html#a0e7480a0064b51e87ba197551bb10373">QHarmonicElement::QHarmonicElement</a></div><div class="ttdeci">QHarmonicElement()</div><div class="ttdoc">Constructor: Call constructors for QElement and Poisson equations.</div><div class="ttdef"><b>Definition:</b> <a href="harmonic_8cc_source.html#l00230">harmonic.cc:230</a></div></div>
<div class="ttc" id="aclassQHarmonicElement_html_a206b7334e82cb563d7d575deb9f755b1"><div class="ttname"><a href="classQHarmonicElement.html#a206b7334e82cb563d7d575deb9f755b1">QHarmonicElement::dshape_eulerian</a></div><div class="ttdeci">double dshape_eulerian(const Vector&lt; double &gt; &amp;s, Shape &amp;psi, DShape &amp;dpsidx) const</div><div class="ttdoc">Shape, test functions &amp; derivs. w.r.t. to global coords. Return Jacobian.</div><div class="ttdef"><b>Definition:</b> <a href="harmonic_8cc_source.html#l00248">harmonic.cc:248</a></div></div>
<div class="ttc" id="aclassQHarmonicElement_html_a6b11b5a42bd20c4e1d1e9840ba22a80a"><div class="ttname"><a href="classQHarmonicElement.html#a6b11b5a42bd20c4e1d1e9840ba22a80a">QHarmonicElement::dshape_eulerian_at_knot</a></div><div class="ttdeci">double dshape_eulerian_at_knot(const unsigned &amp;ipt, Shape &amp;psi, DShape &amp;dpsidx) const</div><div class="ttdoc">Shape, test functions &amp; derivs. w.r.t. to global coords. at integration point ipt....</div><div class="ttdef"><b>Definition:</b> <a href="harmonic_8cc_source.html#l00256">harmonic.cc:256</a></div></div>
<div class="ttc" id="aclassQHarmonicElement_html_a8574a452983b15fb2b4d40ec4ef3e890"><div class="ttname"><a href="classQHarmonicElement.html#a8574a452983b15fb2b4d40ec4ef3e890">QHarmonicElement::required_nvalue</a></div><div class="ttdeci">unsigned required_nvalue(const unsigned &amp;n) const</div><div class="ttdoc">Required # of ‘values’ (pinned or dofs) at node n.</div><div class="ttdef"><b>Definition:</b> <a href="harmonic_8cc_source.html#l00234">harmonic.cc:234</a></div></div>
<div class="ttc" id="aclassQHarmonicElement_html_a8b38012f3d62ef419c359f5e545e5f85"><div class="ttname"><a href="classQHarmonicElement.html#a8b38012f3d62ef419c359f5e545e5f85">QHarmonicElement::output</a></div><div class="ttdeci">void output(ostream &amp;outfile)</div><div class="ttdoc">Output function overloaded from HarmonicEquations.</div><div class="ttdef"><b>Definition:</b> <a href="harmonic_8cc_source.html#l00237">harmonic.cc:237</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="main"></a>
The driver code</h1>
<p>In order to solve the 1D eigenproblem using <code>oomph-lib</code>, we represent the mathematical problem defined by equations (1) and (2) in a specific <code>Problem</code> object, <code><a class="el" href="classHarmonicProblem.html" title="1D Harmonic problem in unit interval.">HarmonicProblem</a></code>, which is templated by the element type and the eigensolver. We use <code>QHarmonicElement&lt;3&gt;</code>, a quadratic element and our three different eigensolvers, including timing statements to compare the three approaches. Note that if you do not have Trilinos installed then only the LAPACK_QZ solver will do anything.</p>
<p>The problem class takes a single argument corresponding to the number of elements used to discretise the domain and contains a member function <code>solve</code> that takes an integer used for documentation purposes.</p>
<div class="fragment"><div class="line"> <span class="keywordtype">unsigned</span> n_element=100; <span class="comment">//Number of elements</span></div>
<div class="line"> </div>
<div class="line"> clock_t t_start1 = clock();</div>
<div class="line"> <span class="comment">//Solve with LAPACK_QZ</span></div>
<div class="line"> {</div>
<div class="line">  <a class="code" href="classHarmonicProblem.html">HarmonicProblem&lt;QHarmonicElement&lt;3&gt;</a>,LAPACK_QZ&gt; </div>
<div class="line">   problem(n_element);</div>
<div class="line">  </div>
<div class="line">  problem.solve(1);</div>
<div class="line"> }</div>
<div class="line"> clock_t t_end1 = clock();</div>
<div class="ttc" id="aclassHarmonicProblem_html"><div class="ttname"><a href="classHarmonicProblem.html">HarmonicProblem</a></div><div class="ttdoc">1D Harmonic problem in unit interval.</div><div class="ttdef"><b>Definition:</b> <a href="harmonic_8cc_source.html#l00268">harmonic.cc:269</a></div></div>
</div><!-- fragment --><p> The same problem is then solved with a different solver</p>
<div class="fragment"><div class="line"> clock_t t_start2 = clock();</div>
<div class="line"><span class="comment">//Solve with Anasazi</span></div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// hierher Andrew: This doesn&#39;t seem to be included in the self tests</span></div>
<div class="line">  <a class="code" href="classHarmonicProblem.html">HarmonicProblem&lt;QHarmonicElement&lt;3&gt;</a>,ANASAZI&gt; problem(n_element);</div>
<div class="line">  problem.solve(2);</div>
<div class="line"> }</div>
<div class="line"> clock_t t_end2 = clock();</div>
</div><!-- fragment --><p> and again with the Trilinos ANASAZI solver if it is installed.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="problem"></a>
The problem class</h1>
<p>The <code><a class="el" href="classHarmonicProblem.html" title="1D Harmonic problem in unit interval.">HarmonicProblem</a></code> is derived from <code>oomph-lib's</code> generic <code>Problem</code> class and the specific element type and eigensolver are specified as template parameters to make it easy for the "user" to change either of these from the driver code.</p>
 <div class="fragment"><div class="line"><span class="comment">//==start_of_problem_class============================================</span></div>
<div class="line"><span class="comment">/// 1D Harmonic problem in unit interval.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT,<span class="keyword">class</span> EIGEN_SOLVER&gt; </div>
<div class="line"><span class="keyword">class </span><a class="code" href="classHarmonicProblem.html">HarmonicProblem</a> : <span class="keyword">public</span> Problem</div>
</div><!-- fragment --><p> The problem class has four member functions:</p><ul>
<li>the constructor <code><a class="el" href="classHarmonicProblem.html" title="1D Harmonic problem in unit interval.">HarmonicProblem(...)</a></code> </li>
<li>the destructor <code>~HarmonicProblem()</code> </li>
<li>the function <code>solve(...)</code> </li>
<li>the function <code>doc_solution(...)</code> </li>
</ul>
<p>The destructor merely cleans up the memory by deleting the objects that are allocated in the constructor, so we shall not discuss it further here. The <code>doc_solution</code> function is also simple and writes the eigenfunction to a file.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="constructor"></a>
The Problem constructor</h1>
<p>In the <code>Problem</code> constructor, we start by creating the eigensolver specified by the second template parameter. We then discretise the domain using <code>oomph-lib's</code> <code>1DMesh</code> object. The arguments of this object's constructor are the number of elements (whose type is specified by the template parameter), and the domain length. Next, we pin the nodal values on the domain boundaries, which corresponds to applying the Dirichlet boundary conditions. Finally we call the generic <code>Problem::assign_eqn_numbers()</code> routine to set up the equation numbers.</p>
 <div class="fragment"><div class="line"><span class="comment">//=====start_of_constructor===============================================</span></div>
<div class="line"><span class="comment">/// Constructor for 1D Harmonic problem in unit interval.</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// Discretise the 1D domain with n_element elements of type ELEMENT.</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// Specify function pointer to source function. </span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT,<span class="keyword">class</span> EIGEN_SOLVER&gt;</div>
<div class="line"><a class="code" href="classHarmonicProblem.html#a77a25847f00ae50c83218530149e3e57">HarmonicProblem&lt;ELEMENT,EIGEN_SOLVER&gt;::HarmonicProblem</a>(</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; n_element)</div>
<div class="line">{ </div>
<div class="line"> <span class="comment">//Create the eigen solver</span></div>
<div class="line"> this-&gt;eigen_solver_pt() = <span class="keyword">new</span> EIGEN_SOLVER;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Set domain length </span></div>
<div class="line"> <span class="keywordtype">double</span> L=1.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build mesh and store pointer in Problem</span></div>
<div class="line"> Problem::mesh_pt() = <span class="keyword">new</span> OneDMesh&lt;ELEMENT&gt;(n_element,L);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set the boundary conditions for this problem: By default, all nodal</span></div>
<div class="line"> <span class="comment">// values are free -- we only need to pin the ones that have </span></div>
<div class="line"> <span class="comment">// Dirichlet conditions. </span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Pin the single nodal value at the single node on mesh </span></div>
<div class="line"> <span class="comment">// boundary 0 (= the left domain boundary at x=0)</span></div>
<div class="line"> mesh_pt()-&gt;boundary_node_pt(0,0)-&gt;pin(0);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Pin the single nodal value at the single node on mesh </span></div>
<div class="line"> <span class="comment">// boundary 1 (= the right domain boundary at x=1)</span></div>
<div class="line"> mesh_pt()-&gt;boundary_node_pt(1,0)-&gt;pin(0);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Setup equation numbering scheme</span></div>
<div class="line"> assign_eqn_numbers();</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of constructor</span></div>
<div class="ttc" id="aclassHarmonicProblem_html_a77a25847f00ae50c83218530149e3e57"><div class="ttname"><a href="classHarmonicProblem.html#a77a25847f00ae50c83218530149e3e57">HarmonicProblem::HarmonicProblem</a></div><div class="ttdeci">HarmonicProblem(const unsigned &amp;n_element)</div><div class="ttdoc">Constructor: Pass number of elements and pointer to source function.</div><div class="ttdef"><b>Definition:</b> <a href="harmonic_8cc_source.html#l00295">harmonic.cc:295</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="solve"></a>
Solving the problem</h1>
<p>The <code>solve(...)</code> function is where all the action happens and takes a single unsigned integer argument which is used as a label to distinguish the output from different eigensolvers.</p>
<p>The function <code>Problem::solve_eigenproblem(...)</code> plays an equivalent role to <code>Problem::newton_solve(...)</code> in eigenproblems. Here, additional storage must be allocated for the eigenvalues (a vector of complex numbers) and eigenvectors (a vector of double vectors). The vectors will be resized internally depending on the number of eigenvalues returned. The number is not always the same as the number of eigenvalues requested because both parts of a complex conjugate pair of eigenvalues are always returned. In the <code>solve</code>(..) function we first allocate the required storage, specify the desired number of eigenvalues and then solve the eigenproblem:</p>
<div class="fragment"><div class="line"><span class="comment">//=======================start_of_solve==============================</span></div>
<div class="line"><span class="comment">/// Solve the eigenproblem </span></div>
<div class="line"><span class="comment"></span><span class="comment">//===================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT,<span class="keyword">class</span> EIGEN_SOLVER&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classHarmonicProblem.html#aba2b3fd58a67f03ca0481e426d385c5d">HarmonicProblem&lt;ELEMENT,EIGEN_SOLVER&gt;::</a></div>
<div class="line"><a class="code" href="classHarmonicProblem.html#aba2b3fd58a67f03ca0481e426d385c5d">solve</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; label)</div>
<div class="line">{ </div>
<div class="line"> <span class="comment">//Set external storage for the eigenvalues</span></div>
<div class="line"> Vector&lt;complex&lt;double&gt; &gt; eigenvalue;</div>
<div class="line"> <span class="comment">//Set external storage for the eigenvectors</span></div>
<div class="line"> Vector&lt;DoubleVector&gt; eigenvector_real;</div>
<div class="line"> Vector&lt;DoubleVector&gt; eigenvector_imag;</div>
<div class="line"> <span class="comment">//Desired number eigenvalues</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_eval=4;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Solve the eigenproblem</span></div>
<div class="line"> this-&gt;solve_eigenproblem(n_eval,eigenvalue,eigenvector_real,eigenvector_imag);</div>
<div class="ttc" id="aclassHarmonicProblem_html_aba2b3fd58a67f03ca0481e426d385c5d"><div class="ttname"><a href="classHarmonicProblem.html#aba2b3fd58a67f03ca0481e426d385c5d">HarmonicProblem::solve</a></div><div class="ttdeci">void solve(const unsigned &amp;label)</div><div class="ttdoc">Solve the problem.</div><div class="ttdef"><b>Definition:</b> <a href="harmonic_8cc_source.html#l00352">harmonic.cc:353</a></div></div>
</div><!-- fragment --><p> The rest of the function post-processes the output from the eigensolver. In order to ensure repeatability of the output for our self-tests the eigenvalues are sorted on the size of their real part. The eigenfunction associated with the second smallest eigenvalue is normalised to have unit length and then output to a file.</p>
<p>In order to output the eigenfunction the values must be transferred to the nodal values so that it can be interpolated. This is performed by the function <code>Problem::assign_eigenvector_to_dofs(...)</code>. Note that this function overwrites the existing nodal data, so a backup must be taken if it is important. This can be done using the function <code>Problem::store_current_dof_values()</code> and the stored values can be recovered via <code>Problem::restore_dof_values()</code>.</p>
<p>Finally, the sorted eigenvalues are reported and also saved to a file.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">//We now need to sort the output based on the size of the real part</span></div>
<div class="line"> <span class="comment">//of the eigenvalues.</span></div>
<div class="line"> <span class="comment">//This is because the solver does not necessarily sort the eigenvalues</span></div>
<div class="line"> Vector&lt;complex&lt;double&gt; &gt; sorted_eigenvalue = eigenvalue;</div>
<div class="line"> sort(sorted_eigenvalue.begin(),sorted_eigenvalue.end(),</div>
<div class="line">      <a class="code" href="classComplexLess.html">ComplexLess&lt;double&gt;</a>());</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Read out the second smallest eigenvalue</span></div>
<div class="line"> complex&lt;double&gt; temp_evalue = sorted_eigenvalue[1];</div>
<div class="line"> <span class="keywordtype">unsigned</span> second_smallest_index=0;</div>
<div class="line"> <span class="comment">//Loop over the unsorted eigenvalues and find the entry that corresponds</span></div>
<div class="line"> <span class="comment">//to our second smallest eigenvalue.</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;eigenvalue.size();i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Note that equality tests for doubles are bad, but it was just</span></div>
<div class="line">   <span class="comment">//sorted data, so should be fine</span></div>
<div class="line">   <span class="keywordflow">if</span>(eigenvalue[i] == temp_evalue) {second_smallest_index=i; <span class="keywordflow">break</span>;}</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Normalise the eigenvector </span></div>
<div class="line"> {</div>
<div class="line">  <span class="comment">//Get the dimension of the eigenvector</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> dim = eigenvector_real[second_smallest_index].nrow();</div>
<div class="line">  <span class="keywordtype">double</span> length=0.0;</div>
<div class="line">  <span class="comment">//Loop over all the entries</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;dim;i++)</div>
<div class="line">   {</div>
<div class="line">    <span class="comment">//Add the contribution to the length</span></div>
<div class="line">    length += std::pow(eigenvector_real[second_smallest_index][i],2.0);</div>
<div class="line">   }</div>
<div class="line">  <span class="comment">//Now take the magnitude</span></div>
<div class="line">  length = sqrt(length);</div>
<div class="line">  <span class="comment">//Fix the sign</span></div>
<div class="line">  <span class="keywordflow">if</span>(eigenvector_real[second_smallest_index][0] &lt; 0) {length *= -1.0;}</div>
<div class="line">  <span class="comment">//Finally normalise</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;dim;i++)</div>
<div class="line">   {</div>
<div class="line">    eigenvector_real[second_smallest_index][i] /= length;</div>
<div class="line">   }</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Now assign the second eigenvector to the dofs of the problem</span></div>
<div class="line"> this-&gt;assign_eigenvector_to_dofs(eigenvector_real[second_smallest_index]);</div>
<div class="line"> <span class="comment">//Output solution for this case (label output files with &quot;1&quot;)</span></div>
<div class="line"> this-&gt;<a class="code" href="classHarmonicProblem.html#a95e94f87cf4f63e332c09bd9f1bbae7c">doc_solution</a>(label);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">char</span> filename[100];</div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;eigenvalues%i.dat&quot;</span>,label);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Open an output file for the sorted eigenvalues</span></div>
<div class="line"> ofstream evalues(filename);</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_eval;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Print to screen</span></div>
<div class="line">   cout &lt;&lt; sorted_eigenvalue[i].real() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div>
<div class="line">        &lt;&lt; sorted_eigenvalue[i].imag() &lt;&lt; std::endl;</div>
<div class="line">   <span class="comment">//Send to file</span></div>
<div class="line">   evalues &lt;&lt; sorted_eigenvalue[i].real() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div>
<div class="line">           &lt;&lt; sorted_eigenvalue[i].imag() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> evalues.close();</div>
<div class="line">} <span class="comment">//end_of_solve</span></div>
<div class="ttc" id="aclassComplexLess_html"><div class="ttname"><a href="classComplexLess.html">ComplexLess</a></div><div class="ttdoc">Function-type-object to perform comparison of complex data types Needed to sort the complex eigenvalu...</div><div class="ttdef"><b>Definition:</b> <a href="complex__harmonic_8cc_source.html#l00056">complex_harmonic.cc:57</a></div></div>
<div class="ttc" id="aclassHarmonicProblem_html_a95e94f87cf4f63e332c09bd9f1bbae7c"><div class="ttname"><a href="classHarmonicProblem.html#a95e94f87cf4f63e332c09bd9f1bbae7c">HarmonicProblem::doc_solution</a></div><div class="ttdeci">void doc_solution(const unsigned &amp;label)</div><div class="ttdoc">Doc the solution, pass the number of the case considered, so that output files can be distinguished.</div><div class="ttdef"><b>Definition:</b> <a href="harmonic_8cc_source.html#l00330">harmonic.cc:330</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="exercises"></a>
Comments and exercises</h1>
<ol type="1">
<li>Modify the code to compute a different number of eigenvalues. What is the maximum number of eigenvalues that could be computed?</li>
<li>Write a function to calculate the error between the numerical and exact solutions to the eigenproblem. How does the error vary with changes in the number of elements?</li>
<li>Compare the errors for each different eigenfunction. What happens to the error as the eigenvalue increase? Can you explain why?</li>
<li>Repeat the above experiments with <code>QHarmonicElement&lt;2&gt;</code>. What happens?</li>
<li>Modify the problem to include a convective-like term <img class="formulaInl" alt="$ \mu \frac{\partial u}{\partial x_{1}} $" src="form_33.png" width="28" height="19"/>. Compare the computed results to the analytic solution. What happens to the eigenvalues and eigenfunctions?</li>
</ol>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory: <center> <a href="../../../../demo_drivers/eigenproblems/harmonic/">demo_drivers/eigenproblems/harmonic/ </a> </center></li>
<li>The driver code is: <center> <a href="../../../../demo_drivers/eigenproblems/harmonic/harmonic.cc">demo_drivers/eigenproblems/harmonic/harmonic.cc </a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:33:09
        </div>
      </div>
    </footer>
</body>
</html>
