This is a slightly more advanced example in which we demonstrate the use of spatial adaptivity in time-\/dependent problems. We discuss the implementation of the spatially adaptive version of {\ttfamily oomph-\/lib\textquotesingle{}s} unsteady Newton solver, {\ttfamily Problem\+::unsteady\+\_\+newton\+\_\+solve(...)}, and explain why the assignment of initial conditions should be performed by overloading the {\ttfamily Problem\+::set\+\_\+initial\+\_\+condition()} function. We also discuss briefly how {\ttfamily oomph-\/lib\textquotesingle{}s} generic dump and restart functions deal with adaptive meshes.

For this purpose consider the following problem\+:

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{The two-\/dimensional unsteady heat equation with flux boundary conditions in a quarter circle domain}} \end{center}  Solve \[ \sum_{i=1}^2\frac{\partial^2 u}{\partial x_i^2} = \frac{\partial u}{\partial t} + f\left(x_1,x_2,t\right), \ \ \ \ \ \ \ \ \ \ (1) \] in the quarter-\/circle domain $ D $, bounded by the coordinate axes and the unit circle, subject to Neumann boundary conditions, \[ \left. \frac{\partial u}{\partial n}\right|_{\partial D_{Neumann}}= - \left. \frac{\partial u}{\partial x_2}\right|_{\partial D_{Neumann}}= g_0, \ \ \ \ \ \ \ \ \ \ (2) \] along the horizontal domain boundary $ \partial D_{Neumann} = \{ (x_1,x_2) | x_1 \in [0,1], x_2=0 \} $, and to Dirichlet boundary conditions, \[ \left. u\right|_{\partial D_{Dirichlet}}=h_0, \ \ \ \ \ \ \ \ \ \ (3) \] elsewhere.  
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{domain}
\doxyfigcaption{Sketch of the domain and the boundary conditions. }
\end{DoxyImage}
 The initial conditions are given by \[ u(x_1,x_2,t=0)=k_0(x_1,x_2), \ \ \ \ \ \ \ \ \ \ (4) \] where the functions $ f, g_0, \ h_0$ and $ k_0$ are given.   \\\cline{1-1}
\end{longtabu}
~\newline
 \end{center} 

We choose the functions $ f, g_0, \ h_0$ and $ k_0$ so that \[ u_0(x_1,x_2,t) = \tanh\bigg[1-\alpha\bigg(\tan\Phi \big(x_1-\beta\tanh[ \gamma\cos\left(2\pi t\right)]\big)- x_2\bigg)\bigg] \ \ \ \ \ \ \ \ \ \ (5) \] is the exact solution.

The solution represents the \char`\"{}usual\char`\"{} tanh profile, whose steepness is controlled by the parameter $ \alpha $ so that for $ \alpha \gg 1 $ the solution approaches a step. The step is oriented at an angle $ \Phi $ against the $ x_1-$ axis and its position varies periodically. The parameter $ \beta $ controls the amplitude of the step\textquotesingle{}s lateral displacement, while $ \gamma $ determines the rate at which its position changes. For $ \gamma \gg 1 $ , the step remains stationary for most of the period and then translates rapidly parallel to the $ x_1- $ axis, making this a very challenging problem.

The figure below shows a snapshot of the \href{../figures/step_soln.avi}{\texttt{ animated solution}}, obtained from the spatially adaptive simulation discussed below, for the parameter values $ \alpha=10, \ \Phi=45^o, \ \beta=0.3, \ \gamma=5. $

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{step_soln}
\doxyfigcaption{Snapshot of the solution. }
\end{DoxyImage}


The mesh adaptation in response to the translation of the step can be seen more clearly in this contour plot, taken from \href{../figures/unsteady_heat_contour.avi}{\texttt{ another animation of the solution}}.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{unsteady_heat_contour}
\doxyfigcaption{Contour plot of the solution. }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_spatial_adapt}{}\doxysection{Background\+: Spatial adaptivity in time-\/dependent problems}\label{index_spatial_adapt}
Enabling spatial adaptivity in time-\/dependent problems involves essentially the same steps as for steady problems\+:
\begin{DoxyItemize}
\item The domain must be discretised with a mesh that is derived from the {\ttfamily Refineable\+Mesh} base class.
\item An {\ttfamily Error\+Estimator} object must be created and passed to the mesh.
\item The empty virtual functions {\ttfamily Problem\+::actions\+\_\+before\+\_\+adapt()} and {\ttfamily Problem\+::actions\+\_\+after\+\_\+adapt()} may be overloaded to perform any actions that are required before or after the mesh adaptation, such as the deletion or recreation of any {\ttfamily Face\+Elements} that apply flux boundary conditions.
\end{DoxyItemize}Once these steps have been performed, a spatially adaptive solution can be computed with a three-\/argument version of {\ttfamily oomph-\/lib\textquotesingle{}s} unsteady Newton solver {\ttfamily Problem\+::unsteady\+\_\+newton\+\_\+solve(...)}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::unsteady\_newton\_solve(dt,max\_adapt,first)}

\end{DoxyCode}


The arguments to this function are as follows\+:
\begin{DoxyItemize}
\item The {\ttfamily double} {\ttfamily dt} specifies the (fixed) timestep.
\item The {\ttfamily unsigned} {\ttfamily max\+\_\+adapt} specifies the maximum number of spatial adaptations allowed.
\item The {\ttfamily bool} {\ttfamily first} indicates if the first timestep is performed. This argument is required to allow the automatic re-\/assignment of the initial conditions following any mesh adaptations during the computation of the first timestep.
\end{DoxyItemize}Given these arguments, the unsteady Newton solver solves the non-\/linear system of spatially and temporally discretised equations to advance the solution from time $ t $ to $ t + dt $ . Once the solution at time $ t + dt $ has been obtained, error estimates are computed for all elements. If any elemental error estimates are outside the target range, the solution is rejected and the mesh is adapted. In the course of mesh adaptation the existing solution (the nodal values {\itshape and} the history values) at time $ t $ are interpolated onto the new mesh before recomputing the solution. This process is repeated until the error estimates are within the target range, or until the maximum number of adaptations, specified by the parameter {\ttfamily max\+\_\+adapt}, is exceeded, just as in the steady case.

Here is an illustration of the procedure for a 1D problem\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{adapted}
\doxyfigcaption{Sketch of the mesh adaptation for time-\/dependent problems. }
\end{DoxyImage}


This procedure is the obvious generalisation of the procedure for steady problems. However, in time-\/dependent problems two additional issues arise\+:
\begin{DoxyEnumerate}
\item In a steady problem the interpolation of the solution onto the adapted mesh (step 4 in the above sketch) merely serves to provide an initial guess for the solution on the refined mesh. It is irrelevant if the interpolation from the coarse mesh provides a poor approximation of the actual solution as the solution is completely recomputed anyway. ~\newline
~\newline
 In an unsteady problem, we also have to interpolate the history values (the solution at previous timesteps in a BDF scheme) onto the adapted mesh. Their values are {\itshape not} changed when the solution is advanced from time $ t $ to $ t+ dt. $ In time-\/dependent problems, the benefit of repeated mesh adaptations (i.\+e. {\ttfamily max\+\_\+adapt} $>$ 1) is therefore limited by the fact that mesh refinement cannot improve their accuracy -- the history values are always given by the (possibly poor) approximations obtained by interpolation from the coarser mesh employed at the previous timestep. We therefore recommend limiting the number of spatial adaptations to {\ttfamily max\+\_\+adapt} = 1. We stress that, in practice, this is not a serious restriction because the time-\/integration procedure will only provide (temporally) accurate results if the timestep {\ttfamily dt} is so small that the solution at time $ t $ only differs slightly from that at time $ t + dt $ . One level of mesh adaptation per timestep should therefore be sufficient to adapt the mesh in response to these changes.
\item The only exception to this recommendation arises during the computation of the first timestep, illustrated in the following sketch\+:  
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{adapted_ic1}
\doxyfigcaption{Sketch of the mesh adaptation during the computation of the first timestep. }
\end{DoxyImage}
 When computing the first timestep, the solution on the initial mesh will have been created by assigning the nodal values according to the analytical initial condition (4). If the initial mesh is very coarse (as it should be), the finite-\/element representation of the initial condition is likely to be very poor, as shown in the above sketch. Clearly, the interpolation from the coarse onto the fine mesh cannot recover any small-\/scale features in the initial condition that were missed by its representation on the coarse mesh. It is therefore better to re-\/assign the initial condition (the values {\itshape and} the history values!) on the adapted mesh, as shown in this sketch\+:  
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{adapted_ic2}
\doxyfigcaption{Sketch of the modified mesh adaptation during the computation of the first timestep. }
\end{DoxyImage}
 With this procedure, repeated mesh adaptations will improve the accuracy of the solution, therefore much larger values of {\ttfamily max\+\_\+adapt} can (and should!) be specified when the first timestep is computed. The unsteady Newton solver {\ttfamily Problem\+::unsteady\+\_\+newton\+\_\+solve(...)} performs the revised procedure if the boolean argument {\ttfamily first} is set {\ttfamily true}. In that case, the values and history values on the adapted mesh are (re-\/)assigned by calling the function 
\begin{DoxyCode}{0}
\DoxyCodeLine{Problem::set\_initial\_condition()}

\end{DoxyCode}
 which is defined as an empty virtual function in the {\ttfamily Problem} base class. You should overload it in your derived {\ttfamily Problem} to ensure that your specific initial conditions are assigned by the mesh adaptation procedures. \mbox{[}In fact, the function {\ttfamily Problem\+::set\+\_\+initial\+\_\+condition()} is not quite empty -- not re-\/setting the initial condition when performing mesh adaptations during the first timestep of a time-\/dependent simulation seems \char`\"{}so     wrong\char`\"{} that the function issues a warning message. Although the overloading of this function is not strictly necessary if the initial conditions can be represented exactly by the interpolation from the coarse mesh onto the fine mesh, we consider it good practice to do so, for reasons discussed in \href{../../../axisym_navier_stokes/spin_up/html/index.html\#good_practice_ics}{\texttt{ another tutorial}}.\mbox{]}
\end{DoxyEnumerate}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_overview}{}\doxysection{Overview of the driver code}\label{index_overview}
Equipped with this background information, the driver code for our example problem is easy to understand, if somewhat lengthy. \mbox{[}Using an example with Dirichlet boundary conditions along the entire domain boundary would have shortened the code significantly but we deliberately chose an example with Neumann boundary conditions to demonstrate that the functions {\ttfamily Problem\+::actions\+\_\+before\+\_\+adapt()} and {\ttfamily Problem\+::actions\+\_\+after\+\_\+adapt()} may be used exactly as in the steady computations.\mbox{]} We will not discuss the methodology for applying flux-\/type boundary conditions in problems with spatial adaptivity in detail, but refer to the discussion provided in the \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\texttt{ earlier steady example.}}

Overall, the code is a straightforward combination of the driver code for the \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\texttt{ steady Poisson problem with flux boundary conditions and spatial adaptivity}} and the driver code for the \href{../../two_d_unsteady_heat/html/index.html}{\texttt{ unsteady heat equation without spatial adaptivity. }}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_namespace}{}\doxysection{Global parameters and functions}\label{index_namespace}
As usual, we store the problem parameters in a namespace, {\ttfamily \mbox{\hyperlink{namespaceTanhSolnForUnsteadyHeat}{Tanh\+Soln\+For\+Unsteady\+Heat}}}, in which we also specify the source function, the prescribed flux along the Neumann boundary and the exact solution.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_ellipse}{}\doxysection{Representing the curvilinear domain boundary by a  Geom\+Object}\label{index_ellipse}
As discussed \href{../../../poisson/fish_poisson2/html/index.html}{\texttt{ elsewhere,}} {\ttfamily oomph-\/lib\textquotesingle{}s} mesh adaptation procedures require curvilinear domain boundaries to be represented by {\ttfamily Geom\+Objects} which describe the object\textquotesingle{}s shape via their member function {\ttfamily Geom\+Object\+::position(...)}. This function exists in two versions\+:
\begin{DoxyItemize}
\item The two-\/argument version, {\ttfamily Geom\+Object\+::position(xi,r)} computes the position vector, {\ttfamily r}, to the point on/in the {\ttfamily Geom\+Object}, parametrised by the vector of intrinsic coordinates, {\ttfamily xi}.
\item The three-\/argument version {\ttfamily Geom\+Object\+::position(t,xi,r)}, where {\ttfamily t} is an {\ttfamily unsigned}, computes the position vector at the {\ttfamily t} -\/ th previous timestep.
\end{DoxyItemize}In the current problem, the domain boundary is stationary, therefore the steady and unsteady versions of the function are identical. Here is the complete source code for the {\ttfamily \mbox{\hyperlink{classMyUnitCircle}{My\+Unit\+Circle}}} object which we will use to represent the curvilinear domain boundary\+:

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//============start\_of\_MyUnitCircle====================================}}
\DoxyCodeLine{\textcolor{comment}{/// Unit circle as GeomObject}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[ x = \(\backslash\)cos(\(\backslash\)xi)  \(\backslash\)f]}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[ y = \(\backslash\)sin(\(\backslash\)xi)  \(\backslash\)f]}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//=====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{classMyUnitCircle}{MyUnitCircle}} : \textcolor{keyword}{public} GeomObject}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Constructor: The circle is a 1D object}}
\DoxyCodeLine{\textcolor{comment}{ /// (i.e. it's parametrised by one intrinsic coordinate) in 2D space.}}
\DoxyCodeLine{\textcolor{comment}{ /// Pass these arguments to the constructor of the GeomObject base class.}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classMyUnitCircle_a056add64776e52a8ea2ba2e9d6d0e32d}{MyUnitCircle}}() : GeomObject(1,2) \{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Destructor: Empty}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keyword}{virtual} \mbox{\hyperlink{classMyUnitCircle_ae6b321a25ef6f6b12d7c9a225f91140d}{\string~MyUnitCircle}}() \{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Current position vector to material point at }}
\DoxyCodeLine{\textcolor{comment}{ /// Lagrangian coordinate xi }}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classMyUnitCircle_ab60b73d1c28b013c40dd2aaa98072261}{position}}(\textcolor{keyword}{const} Vector<double>\& xi, Vector<double>\& r)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{  }\{}
\DoxyCodeLine{   \textcolor{comment}{// Position vector}}
\DoxyCodeLine{   r[0] = cos(xi[0]);}
\DoxyCodeLine{   r[1] = sin(xi[0]);}
\DoxyCodeLine{  \} \textcolor{comment}{// end of position(...)}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Parametrised position on object: r(xi). Evaluated at}}
\DoxyCodeLine{\textcolor{comment}{ /// previous time level. t=0: current time; t>0: previous}}
\DoxyCodeLine{\textcolor{comment}{ /// time level. Circle is fixed -\/-\/ simply call the steady version.}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classMyUnitCircle_ab60b73d1c28b013c40dd2aaa98072261}{position}}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}\& t, \textcolor{keyword}{const} Vector<double>\& xi,}
\DoxyCodeLine{               Vector<double>\& r)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{  }\{}
\DoxyCodeLine{   \textcolor{comment}{// Call steady version }}
\DoxyCodeLine{   \mbox{\hyperlink{classMyUnitCircle_ab60b73d1c28b013c40dd2aaa98072261}{position}}(xi,r);}
\DoxyCodeLine{  \} \textcolor{comment}{// end of position(...)}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\}; \textcolor{comment}{// end of MyUnitCircle}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysection{The main function}\label{index_main}
As before, we use command line arguments to (optionally) specify a restart file. We store the command line arguments in the namespace {\ttfamily Command\+Line\+Args} and build the {\ttfamily Problem} object, passing the pointer to the source function. Next we specify the time-\/interval for the simulation and set the error targets for the spatial adaptation.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//======start\_of\_main=====================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Demonstrate how to solve an unsteady heat problem}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// with mesh adaptation. Command line arguments specify }}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// the name of the restart file. }}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keywordtype}{int} \mbox{\hyperlink{two__d__unsteady__heat__adapt_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[])}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Store command line arguments}}
\DoxyCodeLine{ CommandLineArgs::setup(argc,argv);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Build problem}}
\DoxyCodeLine{ \mbox{\hyperlink{classRefineableUnsteadyHeatProblem}{RefineableUnsteadyHeatProblem<RefineableQUnsteadyHeatElement<2,3>}} >}
\DoxyCodeLine{  problem(\&\mbox{\hyperlink{namespaceTanhSolnForUnsteadyHeat_aea922a29dfeeb80ef4768def0d6fbde4}{TanhSolnForUnsteadyHeat::get\_source}});}
\DoxyCodeLine{   }
\DoxyCodeLine{ \textcolor{comment}{// Specify duration of the simulation}}
\DoxyCodeLine{ \textcolor{comment}{//double t\_max=3.0;}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set targets for spatial adaptivity}}
\DoxyCodeLine{ problem.bulk\_mesh\_pt()-\/>max\_permitted\_error()=0.001;}
\DoxyCodeLine{ problem.bulk\_mesh\_pt()-\/>min\_permitted\_error()=0.0001;}

\end{DoxyCodeInclude}
 We create and initialise the boolean flag that indicates if the first timestep is computed, and choose a large initial value for the number of permitted mesh adaptations. We then assign the initial conditions on the coarse initial mesh and retrieve the timestep (chosen when the initial conditions are assigned in {\ttfamily set\+\_\+initial\+\_\+condition()} ) from the problem\textquotesingle{}s {\ttfamily Time} object.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Set IC}}
\DoxyCodeLine{ problem.set\_initial\_condition();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Initial timestep: Use the one used when setting up the initial}}
\DoxyCodeLine{ \textcolor{comment}{// condition}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} dt=problem.time\_pt()-\/>dt();}

\end{DoxyCodeInclude}
 If the simulation has been restarted, the first timestep is not the step at which the initial condition has to be assigned, therefore we reset the {\ttfamily first} and {\ttfamily max\+\_\+adapt} parameters to their appropriate values. If the run is not restarted, the problem will have been built with a very coarse initial mesh (comprising just three elements). We don\textquotesingle{}t need an error estimator to tell us that this is too coarse to represent the solution accurately and apply two levels of uniform refinement before solving the problem. Note that we refine the entire problem, not just the mesh to ensure that {\ttfamily Problem\+::actions\+\_\+before\+\_\+adapt()} and {\ttfamily Problem\+::actions\+\_\+after\+\_\+adapt()} are executed and the equation numbering scheme is re-\/generated. {\ttfamily Problem\+::refine\+\_\+uniformly()} also interpolates the solution from the coarse initial mesh onto the refined mesh but, as discussed above, this will lead to a very poor representation of the initial condition. Therefore we re-\/assign the initial condition on the refined mesh and document the finite-\/element representation of the initial condition.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// If restart: The first step isn't really the first step,}}
\DoxyCodeLine{ \textcolor{comment}{// i.e. initial condition should not be re-\/set when }}
\DoxyCodeLine{ \textcolor{comment}{// adaptive refinement has been performed. Also, limit}}
\DoxyCodeLine{ \textcolor{comment}{// the max. number of refinements per timestep to the}}
\DoxyCodeLine{ \textcolor{comment}{// normal value straightaway.}}
\DoxyCodeLine{ \textcolor{keywordflow}{if} (CommandLineArgs::Argc==2)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   first=\textcolor{keyword}{false};}
\DoxyCodeLine{   max\_adapt=1;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ \textcolor{comment}{// If no restart, refine mesh uniformly before we get started}}
\DoxyCodeLine{ \textcolor{keywordflow}{else}}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   problem.refine\_uniformly();}
\DoxyCodeLine{   problem.refine\_uniformly();}
\DoxyCodeLine{   \textcolor{comment}{// Solution is automatically interpolated from the coarse initial mesh}}
\DoxyCodeLine{   \textcolor{comment}{// onto the refined mesh but this provides a very poor representation}}
\DoxyCodeLine{   \textcolor{comment}{// of the intial condition: Re-\/assign the initial conditions}}
\DoxyCodeLine{   problem.set\_initial\_condition();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{//Output FE representation of the initial condition}}
\DoxyCodeLine{ problem.doc\_solution();}

\end{DoxyCodeInclude}
 The time-\/stepping loop itself is very similar to that used in the \href{../../two_d_unsteady_heat/html/index.html}{\texttt{ example without spatial adaptivity}}. Here we call the three-\/argument version of the unsteady Newton solver {\ttfamily Problem\+::unsteady\+\_\+newton\+\_\+solve(...)} and re-\/set the parameters {\ttfamily max\+\_\+adapt} and {\ttfamily first} to their appropriate values once the first step has been performed.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Find number of steps}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nstep = 6; \textcolor{comment}{// unsigned(t\_max/dt);}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Timestepping loop}}
\DoxyCodeLine{ \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} istep=0;istep<nstep;istep++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Take timestep }}
\DoxyCodeLine{   problem.unsteady\_newton\_solve(dt,max\_adapt,first);}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Now we've done the first timestep -\/-\/ don't re-\/set the IC}}
\DoxyCodeLine{   \textcolor{comment}{// in subsequent steps}}
\DoxyCodeLine{   first=\textcolor{keyword}{false};}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Reduce the number of spatial adaptations to one per }}
\DoxyCodeLine{   \textcolor{comment}{// timestep}}
\DoxyCodeLine{   max\_adapt=1;}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{//Output solution}}
\DoxyCodeLine{   problem.doc\_solution();}
\DoxyCodeLine{}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ }
\DoxyCodeLine{}
\DoxyCodeLine{\}; \textcolor{comment}{// end of main}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_problem}{}\doxysection{The problem class}\label{index_problem}
As discussed above, the problem class mainly contains verbatim copies of the member functions in the corresponding \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\texttt{ steady }} and \href{../../two_d_unsteady_heat/html/index.html}{\texttt{ unsteady}} problems\+:

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=====start\_of\_problem\_class=========================================}}
\DoxyCodeLine{\textcolor{comment}{/// Unsteady heat problem in quarter circle domain.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//====================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{classRefineableUnsteadyHeatProblem}{RefineableUnsteadyHeatProblem}} : \textcolor{keyword}{public} Problem}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Constructor: Pass pointer to source function}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a894f3bd6c1c23c307a736de6898e4e98}{RefineableUnsteadyHeatProblem}}(UnsteadyHeatEquations<2>::}
\DoxyCodeLine{                             UnsteadyHeatSourceFctPt source\_fct\_pt);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Destructor: Close trace file}}
\DoxyCodeLine{\textcolor{comment}{} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a975e00f5e87d77b4e1bf4d50482dea2b}{\string~RefineableUnsteadyHeatProblem}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem specs after solve (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_ada522772b79e92a75edf3724d0a273da}{actions\_after\_newton\_solve}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem specs before solve (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_aac1935e15c67b196e6db97dd058511b5}{actions\_before\_newton\_solve}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem specs after timestep (empty)}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_aa740f2eb1b3909100a04709b401c0b41}{actions\_after\_implicit\_timestep}}()\{\}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Update the problem specs before next timestep: }}
\DoxyCodeLine{\textcolor{comment}{ /// Set Dirchlet boundary conditions from exact solution.}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_ac754f1313cd6d684c149443beb5bcf9e}{actions\_before\_implicit\_timestep}}();}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Actions before adapt: Wipe the mesh of prescribed flux elements}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a4419fcea0ccbf0509f1d5dd37d8301de}{actions\_before\_adapt}}();}
\DoxyCodeLine{ \textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Actions after adapt: Rebuild the mesh of prescribed flux elements}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a1f8a9e91269440c799a2075f989d62b1}{actions\_after\_adapt}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Set initial condition (incl previous timesteps) according}}
\DoxyCodeLine{\textcolor{comment}{ /// to specified function. Note that his overloads the virtual}}
\DoxyCodeLine{\textcolor{comment}{ /// function in the Problem base class and is therefore executed }}
\DoxyCodeLine{\textcolor{comment}{ /// automatically to re-\/assign the initial conditions during the }}
\DoxyCodeLine{\textcolor{comment}{ /// spatially adaptive solution at the first timestep.}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a30e2e1d62b059982f7014b74f4fe2be9}{set\_initial\_condition}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Create UnsteadyHeat flux elements on boundary b of the Mesh pointed}}
\DoxyCodeLine{\textcolor{comment}{ /// to by bulk\_mesh\_pt and add them to the Mesh object pointed to by }}
\DoxyCodeLine{\textcolor{comment}{ /// surface\_mesh\_pt}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a65601ec64c73ac578b43f4af04c46569}{create\_flux\_elements}}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \&b, Mesh* \textcolor{keyword}{const} \&\mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a4d8eec1505a3c53960a3182ec462b4e7}{bulk\_mesh\_pt}},}
\DoxyCodeLine{                           Mesh* \textcolor{keyword}{const} \&surface\_mesh\_pt);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Delete UnsteadyHeat flux elements and wipe the surface mesh}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_ad2e53af5c385e44e33e400b430b610e8}{delete\_flux\_elements}}(Mesh* \textcolor{keyword}{const} \&surface\_mesh\_pt);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Doc the solution}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a77d590171785b6b5f4070af9401c0e37}{doc\_solution}}();}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Dump problem data to allow for later restart}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a1fb939c3f9c258fd49328bb1516ced98}{dump\_it}}(ofstream\& dump\_file);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Read problem data for restart}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_af36fa71e72852367411e21b50b179625}{restart}}(ifstream\& restart\_file);}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to bulk mesh}}
\DoxyCodeLine{\textcolor{comment}{} RefineableQuarterCircleSectorMesh<ELEMENT>* \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a4d8eec1505a3c53960a3182ec462b4e7}{bulk\_mesh\_pt}}()}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{keywordflow}{return} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_afade341e03a4c97e62444c80adc9552f}{Bulk\_mesh\_pt}};}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to GeomObject that specifies the domain bondary}}
\DoxyCodeLine{\textcolor{comment}{} GeomObject* \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a368512778fbfd59e918104340466b1df}{Boundary\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to source function}}
\DoxyCodeLine{\textcolor{comment}{} UnsteadyHeatEquations<2>::UnsteadyHeatSourceFctPt \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a99eb5a2cd4b680b4f83e739bd4e16639}{Source\_fct\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to the "{}bulk"{} mesh}}
\DoxyCodeLine{\textcolor{comment}{} RefineableQuarterCircleSectorMesh<ELEMENT>* \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_afade341e03a4c97e62444c80adc9552f}{Bulk\_mesh\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to the "{}surface"{} mesh}}
\DoxyCodeLine{\textcolor{comment}{} Mesh* \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a2febbb317a74e427bf6304235d779fe6}{Surface\_mesh\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Pointer to central node (exists at all refinement levels) for doc}}
\DoxyCodeLine{\textcolor{comment}{} Node* \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a7ff1982af5819bab492c693178be0c24}{Doc\_node\_pt}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Doc info object}}
\DoxyCodeLine{\textcolor{comment}{} DocInfo \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a9ea9d79a57cb16a6292a637965767f7e}{Doc\_info}};}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Trace file}}
\DoxyCodeLine{\textcolor{comment}{} ofstream \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a8f62ba78fb856d2e07b00254ca7a0e6a}{Trace\_file}};}
\DoxyCodeLine{}
\DoxyCodeLine{\}; \textcolor{comment}{// end of problem\_class}}

\end{DoxyCodeInclude}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_constructor}{}\doxysection{The problem constructor}\label{index_constructor}
The problem constructor combines the constructors of the \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\texttt{ steady }} and \href{../../two_d_unsteady_heat/html/index.html}{\texttt{ unsteady}} problems. We start by creating a {\ttfamily Doc\+Info} object to control the output, set the parameters for the exact solution and create the {\ttfamily Time\+Stepper\+:} 


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//========start\_of\_constructor============================================}}
\DoxyCodeLine{\textcolor{comment}{/// Constructor for UnsteadyHeat problem in quarter circle domain.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// Pass pointer to source function.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a894f3bd6c1c23c307a736de6898e4e98}{RefineableUnsteadyHeatProblem<ELEMENT>::RefineableUnsteadyHeatProblem}}(}
\DoxyCodeLine{   UnsteadyHeatEquations<2>::UnsteadyHeatSourceFctPt source\_fct\_pt) : }
\DoxyCodeLine{         Source\_fct\_pt(source\_fct\_pt)}
\DoxyCodeLine{\{ }
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup labels for output}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Output directory}}
\DoxyCodeLine{ Doc\_info.set\_directory(\textcolor{stringliteral}{"{}RESLT"{}});}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Output number}}
\DoxyCodeLine{ Doc\_info.number()=0; }
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Open trace file}}
\DoxyCodeLine{ \textcolor{keywordtype}{char} filename[100];   }
\DoxyCodeLine{ sprintf(filename,\textcolor{stringliteral}{"{}\%s/trace.dat"{}},Doc\_info.directory().c\_str());}
\DoxyCodeLine{ Trace\_file.open(filename);}
\DoxyCodeLine{ }
\DoxyCodeLine{ Trace\_file << \textcolor{stringliteral}{"{}VARIABLES=\(\backslash\)"{}time t\(\backslash\)"{},\(\backslash\)"{}u<SUB>FE</SUB>\(\backslash\)"{},\(\backslash\)"{}u<SUB>exact</SUB>\(\backslash\)"{},"{}}}
\DoxyCodeLine{            << \textcolor{stringliteral}{"{}\(\backslash\)"{}A\(\backslash\)"{},"{}}}
\DoxyCodeLine{            << \textcolor{stringliteral}{"{}\(\backslash\)"{}X<SUB>step</SUB>\(\backslash\)"{},"{}}}
\DoxyCodeLine{            << \textcolor{stringliteral}{"{}\(\backslash\)"{}N<SUB>element</SUB>\(\backslash\)"{},"{}}}
\DoxyCodeLine{            << \textcolor{stringliteral}{"{}\(\backslash\)"{}N<SUB>refined</SUB>\(\backslash\)"{},"{}}}
\DoxyCodeLine{            << \textcolor{stringliteral}{"{}\(\backslash\)"{}N<SUB>unrefined</SUB>\(\backslash\)"{},"{}}}
\DoxyCodeLine{            << \textcolor{stringliteral}{"{}\(\backslash\)"{}norm of error\(\backslash\)"{},"{}}}
\DoxyCodeLine{            << \textcolor{stringliteral}{"{}\(\backslash\)"{}norm of solution\(\backslash\)"{}"{}}}
\DoxyCodeLine{            << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup parameters for tanh solution}}
\DoxyCodeLine{ \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Steepness of step}}
\DoxyCodeLine{ \mbox{\hyperlink{namespaceTanhSolnForUnsteadyHeat_a4c75d9887d6f25405bbead696a94db63}{TanhSolnForUnsteadyHeat::Alpha}}=10.0;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Orientation of step}}
\DoxyCodeLine{ \mbox{\hyperlink{namespaceTanhSolnForUnsteadyHeat_af8d2e06630e8a3f71d1f8dbeecf8a964}{TanhSolnForUnsteadyHeat::TanPhi}}=1.0;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Amplitude for movement of step}}
\DoxyCodeLine{ \mbox{\hyperlink{namespaceTanhSolnForUnsteadyHeat_a66f6116310a5f9f96c2d3bf28250a92b}{TanhSolnForUnsteadyHeat::Beta}}=0.3; }
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Parameter for time-\/dependence of step movement}}
\DoxyCodeLine{ \mbox{\hyperlink{namespaceTanhSolnForUnsteadyHeat_a5bb742b074ab5f3f65286b1cff1f1512}{TanhSolnForUnsteadyHeat::Gamma}}=5.0;}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{//Allocate the timestepper -\/-\/ This constructs the time object as well}}
\DoxyCodeLine{ add\_time\_stepper\_pt(\textcolor{keyword}{new} BDF<2>());}

\end{DoxyCodeInclude}


We create the {\ttfamily Geom\+Object} that describes the curvilinear domain boundary and pass it to the mesh constructor\+:


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Setup mesh}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Build geometric object that forms the curvilinear domain boundary:}}
\DoxyCodeLine{ \textcolor{comment}{// a unit circle }}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Create GeomObject}}
\DoxyCodeLine{ Boundary\_pt=\textcolor{keyword}{new} \mbox{\hyperlink{classMyUnitCircle}{MyUnitCircle}};}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Start and end coordinates of curvilinear domain boundary on circle}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} xi\_lo=0.0;}
\DoxyCodeLine{ \textcolor{keywordtype}{double} xi\_hi=MathematicalConstants::Pi/2.0;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Now create the bulk mesh. Separating line between the two }}
\DoxyCodeLine{ \textcolor{comment}{// elements next to the curvilinear boundary is located half-\/way}}
\DoxyCodeLine{ \textcolor{comment}{// along the boundary.}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} fract\_mid=0.5;}
\DoxyCodeLine{ Bulk\_mesh\_pt = \textcolor{keyword}{new} RefineableQuarterCircleSectorMesh<ELEMENT>(}
\DoxyCodeLine{  Boundary\_pt,xi\_lo,fract\_mid,xi\_hi,time\_stepper\_pt());}

\end{DoxyCodeInclude}
 Next, we create the surface mesh that contains the prescribed flux elements and combine the two submeshes to the {\ttfamily Problem\textquotesingle{}s} global mesh. We create an instance of the {\ttfamily Z2\+Error\+Estimator} and pass it to the bulk mesh.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Create the surface mesh as an empty mesh}}
\DoxyCodeLine{ Surface\_mesh\_pt=\textcolor{keyword}{new} Mesh;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Create prescribed-\/flux elements from all elements that are }}
\DoxyCodeLine{ \textcolor{comment}{// adjacent to boundary 0 (the horizontal lower boundary), and add them }}
\DoxyCodeLine{ \textcolor{comment}{// to the (so far empty) surface mesh.}}
\DoxyCodeLine{ create\_flux\_elements(0,Bulk\_mesh\_pt,Surface\_mesh\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Add the two sub meshes to the problem}}
\DoxyCodeLine{ add\_sub\_mesh(Bulk\_mesh\_pt);}
\DoxyCodeLine{ add\_sub\_mesh(Surface\_mesh\_pt);}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Combine all submeshes into a single global Mesh}}
\DoxyCodeLine{ build\_global\_mesh();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Set error estimator for bulk mesh}}
\DoxyCodeLine{ Z2ErrorEstimator* error\_estimator\_pt=\textcolor{keyword}{new} Z2ErrorEstimator;}
\DoxyCodeLine{ Bulk\_mesh\_pt-\/>spatial\_error\_estimator\_pt()=error\_estimator\_pt;}

\end{DoxyCodeInclude}
 We pin the nodal values on the Dirichlet boundaries and select the central node in the unrefined three-\/element mesh as the control node at which the solution is documented in the trace file.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}}
\DoxyCodeLine{ \textcolor{comment}{// free by default -\/-\/ just pin the ones that have Dirichlet conditions}}
\DoxyCodeLine{ \textcolor{comment}{// here. }}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_bound = Bulk\_mesh\_pt-\/>nboundary();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} b=0;b<n\_bound;b++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Leave nodes on boundary 0 free -\/-\/ this is where we apply the flux}}
\DoxyCodeLine{   \textcolor{comment}{// boundary condition}}
\DoxyCodeLine{   \textcolor{keywordflow}{if} (b!=0)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt-\/>nboundary\_node(b);}
\DoxyCodeLine{     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       Bulk\_mesh\_pt-\/>boundary\_node\_pt(b,n)-\/>pin(0); }
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Extract pointer to the central node (this exists at all refinement levels)}}
\DoxyCodeLine{ \textcolor{comment}{// for doc of solution}}
\DoxyCodeLine{ FiniteElement* el0\_pt=Bulk\_mesh\_pt-\/>finite\_element\_pt(0);}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} nnod=el0\_pt-\/>nnode();}
\DoxyCodeLine{ Doc\_node\_pt=el0\_pt-\/>node\_pt(nnod-\/1);}

\end{DoxyCodeInclude}
 Finally, we complete the build of all elements by passing the relevant function pointers to the elements, and assign the equation numbers.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Complete the build of all elements so they are fully functional}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Find number of elements in mesh}}
\DoxyCodeLine{ \textcolor{keywordtype}{unsigned} n\_element = Bulk\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Loop over the elements to set up element-\/specific }}
\DoxyCodeLine{ \textcolor{comment}{// things that cannot be handled by constructor}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Upcast from FiniteElement to the present element}}
\DoxyCodeLine{   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt-\/>element\_pt(i));}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{//Set the source function pointer}}
\DoxyCodeLine{   el\_pt-\/>source\_fct\_pt() = Source\_fct\_pt;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Loop over the flux elements to pass pointer to prescribed flux function}}
\DoxyCodeLine{ n\_element=Surface\_mesh\_pt-\/>nelement();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Upcast from GeneralisedElement to UnsteadyHeat flux element}}
\DoxyCodeLine{   UnsteadyHeatFluxElement<ELEMENT> *el\_pt = }
\DoxyCodeLine{    \textcolor{keyword}{dynamic\_cast<}UnsteadyHeatFluxElement<ELEMENT>*\textcolor{keyword}{>}(}
\DoxyCodeLine{     Surface\_mesh\_pt-\/>element\_pt(e));}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Set the pointer to the prescribed flux function}}
\DoxyCodeLine{   el\_pt-\/>flux\_fct\_pt() = }
\DoxyCodeLine{    \&\mbox{\hyperlink{namespaceTanhSolnForUnsteadyHeat_af4d78d73bd9981a5a9ecacecfd0e9cb8}{TanhSolnForUnsteadyHeat::prescribed\_flux\_on\_fixed\_y\_boundary}};}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Do equation numbering}}
\DoxyCodeLine{ cout <<\textcolor{stringliteral}{"{}Number of equations: "{}} << assign\_eqn\_numbers() << std::endl; }
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of constructor}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_old_functions}{}\doxysection{Other member functions}\label{index_old_functions}
The remaining member functions
\begin{DoxyItemize}
\item {\ttfamily actions\+\_\+after\+\_\+newton\+\_\+solve()} 
\item {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+solve()} 
\item {\ttfamily actions\+\_\+after\+\_\+implicit\+\_\+timestep()} 
\item {\ttfamily actions\+\_\+before\+\_\+implicit\+\_\+timestep()} 
\item {\ttfamily actions\+\_\+before\+\_\+adapt()} 
\item {\ttfamily actions\+\_\+after\+\_\+adapt()} 
\item {\ttfamily set\+\_\+initial\+\_\+condition()} 
\item {\ttfamily create\+\_\+flux\+\_\+elements(...)} 
\item {\ttfamily delete\+\_\+flux\+\_\+elements(...)} 
\item {\ttfamily doc\+\_\+solution()} 
\item {\ttfamily dump\+\_\+it(...)} 
\item {\ttfamily restart(...)} 
\end{DoxyItemize}are identical (or at least extremely similar) to those in previous examples, so we do not list them here. You can examine the functions in detail in the source code \href{../../../../demo_drivers/unsteady_heat/two_d_unsteady_heat_adapt/two_d_unsteady_heat_adapt.cc}{\texttt{ two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+adapt.\+cc}}.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_restart}{}\doxysection{Dump/restart with spatial adaptivity}\label{index_restart}
It is worth examining the dump and restart functions, however, as they demonstrate that the generic versions defined in the {\ttfamily Problem} base class can also deal with adaptive problems -- a non-\/trivial task!


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=======start\_of\_dump\_it=================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Dump the solution to disk}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a1fb939c3f9c258fd49328bb1516ced98}{RefineableUnsteadyHeatProblem<ELEMENT>::dump\_it}}(ofstream\& dump\_file)}
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{// Dump the refinement pattern and the generic problem data}}
\DoxyCodeLine{ Problem::dump(dump\_file);}
\DoxyCodeLine{  }
\DoxyCodeLine{\} \textcolor{comment}{// end of dump\_it}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//=========start\_of\_restart===============================================}\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{/// Read solution from disk}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_af36fa71e72852367411e21b50b179625}{RefineableUnsteadyHeatProblem<ELEMENT>::restart}}(ifstream\& restart\_file)}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Refine the mesh and read in the generic problem data}}
\DoxyCodeLine{ Problem::read(restart\_file);}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of restart}}

\end{DoxyCodeInclude}
 Since details of their implementation are hidden from the user, we briefly comment on the various tasks performed by these functions. The main task of the {\ttfamily Problem\+::read(...)} function is to read values (and history values) of all {\ttfamily Data} objects from a file and to assign these values to the appropriate {\ttfamily Data} (and {\ttfamily Node}) objects in the {\ttfamily Problem}. This assumes that the {\ttfamily Problem\textquotesingle{}s} constituent {\ttfamily Meshes}, elements, {\ttfamily Nodes} and {\ttfamily Data} objects have been created, and that the {\ttfamily Problem\textquotesingle{}s} various pointer-\/based lookup schemes access them in the order they were in when the {\ttfamily Problem} was dumped to the restart file. In a non-\/adaptive computation, the number of elements and the number of {\ttfamily Data} objects remain constant throughout the simulation and the {\ttfamily Problem\+::read(...)} function can be called as soon as the {\ttfamily Problem} has been built -- usually by its constructor. (The {\ttfamily Problem} constructor always builds and enumerates its constituent objects in the same order.)

In a simulation with spatial adaptivity the number of elements, {\ttfamily Nodes} and {\ttfamily Data} objects varies throughout the computation. It is therefore necessary to re-\/generate the {\ttfamily Problem\textquotesingle{}s} refinement pattern before the {\ttfamily Data} values can be read from the restart file. This is achieved (internally) by calling the function {\ttfamily Refineable\+Mesh\+::dump\+\_\+refinement(...)} for all refineable meshes before the {\ttfamily Data} is dumped. This function writes the {\ttfamily Mesh\textquotesingle{}s} refinement pattern to the restart file, using a format that can be read by the corresponding member function {\ttfamily Refineable\+Mesh\+::refine(...)} which adapts an unrefined mesh so that its topology and the order of its {\ttfamily Nodes} and elements is recreated.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comments}{}\doxysection{Comments and exercises}\label{index_comments}
The plots below show the time history of various parameters.
\begin{DoxyItemize}
\item The upper graph compares the solution at the control node (red line) against the exact solution (green line).
\item The middle graph shows the position of the step by plotting its intercept with the $ x_1- $ axis as a function of time, and the error of the solution.
\item The lower graph illustrates the evolution of the adaptive spatial refinement process\+: The green line illustrates the total number of elements; the blue and red lines show the number of elements that are refined and unrefined at each timestep.
\end{DoxyItemize}

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{trace}
\doxyfigcaption{Time history of the solution. }
\end{DoxyImage}


The plots illustrate clearly how the mesh is adapted as the step moves through the domain -- the peaks in the number of refined/unrefined elements per timestep coincide with the periods during which the step moves very rapidly. The increase in the error during these phases is mainly due to the temporal error -- the \href{../figures/step_soln.avi}{\texttt{ animation}} shows that the computed solution lags behind the exact one. We will address this by adding adaptive time-\/stepping in \href{../../two_d_unsteady_heat_2adapt/html/index.html}{\texttt{ another example.}}\hypertarget{index_ex}{}\doxysubsection{Exercises}\label{index_ex}

\begin{DoxyEnumerate}
\item Confirm that the error during the periods of rapid change in the solution is due to the temporal error by repeating the simulation with a smaller/larger timestep and/or a time-\/stepping scheme with higher/lower order (e.\+g. BDF$<$1$>$ or BDF$<$4$>$).
\item Assess the importance of re-\/assigning the initial conditions when spatial adaptations are performed during the computation of the first timestep.
\begin{DoxyEnumerate}
\item Compare the finite-\/element representation of the initial condition(contained in the file {\ttfamily RESLT/soln0.\+dat}) against that obtained when the re-\/assignment of the initial conditions after the two calls to {\ttfamily problem.\+refine\+\_\+uniformly()} in the {\ttfamily main} function is suppressed.
\item Comment out the calls to {\ttfamily problem.\+refine\+\_\+uniformly()} and set {\ttfamily first=false} throughout the {\ttfamily main} function and compare the computed results against those obtained with ~\newline
 the correct procedure.
\end{DoxyEnumerate}
\end{DoxyEnumerate}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{
../../../../
demo_drivers/unsteady_heat/two_d_unsteady_heat_adapt/
}{\texttt{ demo\+\_\+drivers/unsteady\+\_\+heat/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+adapt/ }} \end{center} 
\item The driver code is\+: \begin{center} \href{
../../../../
demo_drivers/unsteady_heat/two_d_unsteady_heat_adapt/two_d_unsteady_heat_adapt.cc
}{\texttt{ demo\+\_\+drivers/unsteady\+\_\+heat/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+adapt/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+adapt.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{PDF file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
