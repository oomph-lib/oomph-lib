This is the final and most complex problem in our series of demo codes for the unsteady heat equation. We re-\/visit the moving domain problem considered in the \href{../../two_d_unsteady_heat_ALE/html/index.html}{\texttt{ previous example }} and solve it with a {\itshape combination} of spatial and temporal adaptivity.

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{The two-\/dimensional unsteady heat equation with flux boundary conditions in a moving domain.}} \end{center}  Solve \[ \sum_{i=1}^2\frac{\partial^2 u}{\partial x_i^2} = \frac{\partial u}{\partial t} + f\left(x_1,x_2,t\right), \ \ \ \ \ \ \ \ \ \ (1) \] in the domain $ D $, bounded by the coordinate axes and the time-\/dependent ellipse \[ \mathbf{r}_{ellipse}(\xi,t) = \left( \begin{array}{c} \big(a+\hat{a}\sin(2\pi t/\hat{T})\big) \cos(\xi) \\ \big(b+\hat{b}\sin(2\pi t/\hat{T})\big) \sin(\xi) \end{array} \right), \ \ \ \ \ \ \ \ \ \ (2) \] subject to Neumann boundary conditions, \[ \left. \frac{\partial u}{\partial n}\right|_{\partial D_{Neumann}}= - \left. \frac{\partial u}{\partial x_2}\right|_{\partial D_{Neumann}}= g_0, \ \ \ \ \ \ \ \ \ \ (3) \] along the horizontal domain boundary $ \partial D_{Neumann} = \{ (x_1,x_2) | x_1 \in [0,1], x_2=0 \} $, and to Dirichlet boundary conditions, \[ \left. u\right|_{\partial D_{Dirichlet}}=h_0, \ \ \ \ \ \ \ \ \ \ (4) \] elsewhere.  
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{domain}
\doxyfigcaption{Sketch of the time-\/dependent domain and the boundary conditions. }
\end{DoxyImage}
 The initial conditions are given by \[ u(x_1,x_2,t=0)=k_0(x_1,x_2), \ \ \ \ \ \ \ \ \ \ (5) \] where the functions $ f, g_0, \ h_0$ and $ k_0$ are given.   \\\cline{1-1}
\end{longtabu}
~\newline
 \end{center} 

We choose the functions $ f, g_0, \ h_0$ and $ k_0$ so that \[ u_0(x_1,x_2,t) = \tanh\bigg[1-\alpha\bigg(\tan\Phi \big(x_1-\beta\tanh[ \gamma\cos\left(2\pi t\right)]\big)- x_2\bigg)\bigg] \ \ \ \ \ \ \ \ \ \ (6) \] is the exact solution.

The solution represents the \char`\"{}usual\char`\"{} tanh profile, whose steepness is controlled by the parameter $ \alpha $ so that for $ \alpha \gg 1 $ the solution approaches a step. The step is oriented at an angle $ \Phi $ against the $ x_1-$-\/axis and its position varies periodically. The parameter $ \beta $ controls the amplitude of the step\textquotesingle{}s lateral displacement, while $ \gamma $ determines the rate at which its position changes. For $ \gamma \gg 1$, the step remains stationary for most of the period and then translates rapidly parallel to the $ x_1-$-\/axis, making this a very challenging problem.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comb}{}\doxysection{Background\+: Combined spatial and temporal adaptivity}\label{index_comb}
When \href{../../two_d_unsteady_heat_ALE/html/index.html}{\texttt{ solving the above problem with pure spatial adaptivity,}} we observed that the error of the computed solution increased noticeably during phases when the \char`\"{}step\char`\"{} moved rapidly through the domain, suggesting that the error is due to the temporal rather than the spatial discretisation. If you attempted the exercises suggested at the end of that demo problem, you will have confirmed this by observing that the error is reduced when the time-\/integration is performed with a smaller timestep. Since the solution only undergoes rapid changes during short periods of time, the use of temporal adaptivity is highly desirable. Before demonstrating that the combined use of temporal and spatial adaptivity only requires trivial changes to the driver code with purely spatial adaptivity, we briefly comment on the strategy employed by {\ttfamily oomph-\/lib\textquotesingle{}s} doubly-\/adaptive unsteady Newton solver


\begin{DoxyCode}{0}
\DoxyCodeLine{doubly\_adaptive\_unsteady\_newton\_solve(dt,epsilon\_t,max\_adapt,first)}

\end{DoxyCode}


This Newton solver performs the spatial and temporal adaptations sequentially, as follows\+:
\begin{DoxyEnumerate}
\item Given a mesh and the solution on that mesh at time $ t $, we first advance the solution to time $ t + dt$, adjusting the timestep $ dt $ until the global temporal error norm computed by {\ttfamily Problem\+::global\+\_\+temporal\+\_\+error\+\_\+norm()} falls below the target error specified by the ({\ttfamily double}) argument {\ttfamily epsilon\+\_\+t}. The ({\ttfamily double}) argument {\ttfamily dt}, specifies the suggestion for the timestep.
\item Once a temporally accurate solution has been computed on that mesh, we perform up to {\ttfamily max\+\_\+adapt} spatial adaptations to reduce the spatial error. We re-\/compute the solution on the adapted meshes, using the (fixed) timestep selected previously by the temporal adaptation. Once the spatial adaptations are complete, we could, in principle, re-\/evaluate the temporal error and, if required, re-\/compute the timestep yet again -- at a significant additional cost. We omit this further adjustment and accept the solution \char`\"{}as is\char`\"{}.
\end{DoxyEnumerate}As before, the boolean argument {\ttfamily first} indicates if the first timestep is being computed (see the ~\newline
 \href{../../two_d_unsteady_heat_adapt/html/index.html}{\texttt{ example without temporal adaptivity}} for more information on this important issue). As in the \href{../../two_d_unsteady_heat_t_adapt/html/index.html}{\texttt{ case of pure temporal adaptivity}}, the adaptive unsteady Newton solver returns a suggestion for the size of the next timestep.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_impl}{}\doxysection{The implementation}\label{index_impl}
Since the spatial and temporal adaptations are performed independently, adding \char`\"{}double adaptivity\char`\"{} to the existing \href{../../two_d_unsteady_heat_ALE/html/index.html}{\texttt{ driver code with pure spatial adaptivity}} only requires the implementation of the additional member function {\ttfamily Problem\+::global\+\_\+temporal\+\_\+error\+\_\+norm()}. In the current problem we can use the one that we created for the \href{../../two_d_unsteady_heat_t_adapt/html/index.html}{\texttt{ example with pure temporal adaptivity}}. Furthermore, we pass a true boolean flag to the constructor of the {\ttfamily BDF$<$2$>$} timestepper, to make it adaptive. That\textquotesingle{}s all! Apart from a few (optional) improvements to the dump/restart functions (discussed below), \href{../../../../demo_drivers/unsteady_heat/two_d_unsteady_heat_2adapt/two_d_unsteady_heat_2adapt.cc}{\texttt{ the code}} does not require any other changes.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_reslt}{}\doxysection{Some results}\label{index_reslt}
The figure below shows a snapshot of the \href{../figures/step_soln.avi}{\texttt{ animated solution}}, obtained from the doubly adaptive simulation.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{step_soln}
\doxyfigcaption{Snapshot of the solution. }
\end{DoxyImage}


When viewing the \href{../figures/step_soln.avi}{\texttt{ animation of the solution}}, note how the time-\/bar grows much more rapidly during phases when the solution only changes slowly, reflecting the larger timestep used during these phases.

The time-\/traces shown below compare the exact and computed solutions, and document the variations in timestep and the norm of the error throughout the simulation, for a temporal error target of {\ttfamily epsilon\+\_\+t} = $ 10^{-2}. $ The plots show clearly how the adaptive timestepper selects a much larger timestep during the phases when the solution only changes slowly. However, the error during phases of rapid change is still relatively large -- the comparison between the exact and computed solution shows that the two are not graphically indistinguishable. We ought to do better!

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{trace}
\doxyfigcaption{Time trace of the solution, the error and the timestep chosen by the adaptive timestepper for a temporal error target of 1\+E-\/2. }
\end{DoxyImage}


The time-\/traces below show the results from a second simulation with a smaller target error of {\ttfamily epsilon\+\_\+t} = $ 10^{-3} $. The exact and computed solutions are now graphically indistinguishable and the error has been reduced significantly -- at the cost of having to take much smaller timesteps throughout the simulation. Without adaptive time-\/stepping, this simulation would become {\itshape very} expensive as timesteps as small as $ dt = 2 \times 10^{-4}$ are required to properly resolve the solution during the phases of rapid change.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{trace_target1e-3}
\doxyfigcaption{Time trace of the solution, the error and the timestep chosen by the adaptive timestepper for a temporal error target of 1\+E-\/3. }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_comments}{}\doxysection{Comments and Exercises}\label{index_comments}
\hypertarget{index_cust}{}\doxysubsection{Customising the dump/restart procedure}\label{index_cust}
In two earlier examples, we commented on two undesirable features of the default dump/restart procedures\+:
\begin{DoxyItemize}
\item The restart files do not record the counter (stored in a {\ttfamily Doc\+Info} object) that we typically use to label the output files. Therefore the output files produced in the restarted run start with label \char`\"{}0\char`\"{}, making it difficult to merge the data files from the original and restarted simulations.
\item In an adaptive simulation, the restart files do not record the adaptive timestepper\textquotesingle{}s suggestion for the next timestep, therefore the first timestep in the restarted simulation is performed with the timestep that was used when the solution was dumped to disk, leading to slight differences in the history of the timesteps chosen; see the plot shown at the end of the discussion of the \href{../../two_d_unsteady_heat_t_adapt/html/index.html}{\texttt{ example with purely temporal adaptivity. }}
\end{DoxyItemize}To address these problems, we modified the {\ttfamily Problem} class for the present example slightly\+: We added the {\ttfamily Doc\+Info} object which stores the label for the output file to the {\ttfamily Problem\textquotesingle{}s} private member data, and provide storage for the size of the next timestep suggested by the adaptive timestepper.

 ~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Doc info object}}
\DoxyCodeLine{\textcolor{comment}{} DocInfo Doc\_info;}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{ /// Suggestion for next timestep (stored to allow it to be written}}
\DoxyCodeLine{\textcolor{comment}{ /// to (or read from) restart file)}}
\DoxyCodeLine{\textcolor{comment}{} \textcolor{keywordtype}{double} Next\_dt;}

\end{DoxyCodeInclude}
 \mbox{[}We also provide a public access function, {\ttfamily double} {\ttfamily next\+\_\+dt()}, to the suggested next timestep; see \mbox{\hyperlink{index_no_pub}{Do NOT use public member data in any classes}} .\mbox{]}

We initialise the output label in the {\ttfamily Problem} constructor,

 ~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//========start\_of\_constructor============================================}}
\DoxyCodeLine{\textcolor{comment}{/// Constructor for UnsteadyHeat problem on deformable ellipse domain.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// Pass pointer to source function.}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a894f3bd6c1c23c307a736de6898e4e98}{RefineableUnsteadyHeatProblem<ELEMENT>::RefineableUnsteadyHeatProblem}}(}
\DoxyCodeLine{ UnsteadyHeatEquations<2>::UnsteadyHeatSourceFctPt source\_fct\_pt)}
\DoxyCodeLine{ : Source\_fct\_pt(source\_fct\_pt)}
\DoxyCodeLine{\{}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Setup labels for output}}
\DoxyCodeLine{ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Output directory}}
\DoxyCodeLine{ Doc\_info.set\_directory(\textcolor{stringliteral}{"{}RESLT"{}});}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Output number}}
\DoxyCodeLine{ Doc\_info.number()=0; }

\end{DoxyCodeInclude}
 and set {\ttfamily Next\+\_\+dt} to the initial timestep when the initial condition is assigned in {\ttfamily set\+\_\+initial\+\_\+condition()}\+:

 ~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{   \textcolor{comment}{// Choose initial timestep}}
\DoxyCodeLine{   \textcolor{keywordtype}{double} dt0=0.005;}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Initialise timestep -\/-\/ also sets the weights for all timesteppers}}
\DoxyCodeLine{   \textcolor{comment}{// in the problem.}}
\DoxyCodeLine{   initialise\_dt(dt0);}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Use this as the first "{}suggested"{} timestep}}
\DoxyCodeLine{   Next\_dt=dt0;}

\end{DoxyCodeInclude}


We modify the timestepping loop so that the adaptive timestepper\textquotesingle{}s suggestion for the next timestep is stored in the {\ttfamily Problem\textquotesingle{}s} private data member {\ttfamily Next\+\_\+dt}, which is accessible via the public member function {\ttfamily next\+\_\+dt()}\+:

 ~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Timestepping loop}}
\DoxyCodeLine{ \textcolor{keywordflow}{while} (problem.time\_pt()-\/>time()<t\_max)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Take timestep with temporal and spatial adaptivity}}
\DoxyCodeLine{   \textcolor{keywordtype}{double} dt\_new=}
\DoxyCodeLine{   problem.doubly\_adaptive\_unsteady\_newton\_solve(dt,problem.epsilon\_t(),}
\DoxyCodeLine{                                                 max\_adapt,first);}
\DoxyCodeLine{   cout << \textcolor{stringliteral}{"{}Suggested new dt: "{}} << dt\_new << std::endl;}
\DoxyCodeLine{   dt=dt\_new;}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Store for restart}}
\DoxyCodeLine{   problem.next\_dt()=dt\_new;}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Now we've done the first timestep -\/-\/ don't re-\/set the IC}}
\DoxyCodeLine{   \textcolor{comment}{// in subsequent steps}}
\DoxyCodeLine{   first=\textcolor{keyword}{false};}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Reduce the number of spatial adaptations to one per }}
\DoxyCodeLine{   \textcolor{comment}{// timestep -\/-\/ too scared that the interpolation error will }}
\DoxyCodeLine{   \textcolor{comment}{// wipe out any further gains...}}
\DoxyCodeLine{   max\_adapt=1;}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{//Output solution}}
\DoxyCodeLine{   problem.doc\_solution();}
\DoxyCodeLine{}
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
 Since the {\ttfamily Problem} now has access to the {\ttfamily Doc\+Info} object (and therefore to the label that we use to identify the output files), and to the suggested next timestep, we write both to the restart file, adding brief comments behind the \char`\"{}raw\char`\"{} data.

 ~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=======start\_of\_dump\_it=================================================}}
\DoxyCodeLine{\textcolor{comment}{/// Dump the solution to disk}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_a1fb939c3f9c258fd49328bb1516ced98}{RefineableUnsteadyHeatProblem<ELEMENT>::dump\_it}}(ofstream\& dump\_file)}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Write step number}}
\DoxyCodeLine{ dump\_file << Doc\_info.number() << \textcolor{stringliteral}{"{} \# step number"{}} << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Write suggested next timestep}}
\DoxyCodeLine{ dump\_file << Next\_dt << \textcolor{stringliteral}{"{} \# suggested next timestep"{}} << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Dump the refinement pattern and the generic problem data}}
\DoxyCodeLine{ Problem::dump(dump\_file);}
\DoxyCodeLine{  }
\DoxyCodeLine{\} \textcolor{comment}{// end of dump\_it}}

\end{DoxyCodeInclude}


These values are then read during the restart\+:

 ~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//=========start\_of\_restart===============================================}}
\DoxyCodeLine{\textcolor{comment}{/// Read solution from disk}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classRefineableUnsteadyHeatProblem_af36fa71e72852367411e21b50b179625}{RefineableUnsteadyHeatProblem<ELEMENT>::restart}}(ifstream\& restart\_file)}
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{// Read line up to termination sign}}
\DoxyCodeLine{ \textcolor{keywordtype}{string} input\_string;}
\DoxyCodeLine{ getline(restart\_file,input\_string,\textcolor{charliteral}{'\#'});}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Ignore rest of line}}
\DoxyCodeLine{ restart\_file.ignore(80,\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Read in step number}}
\DoxyCodeLine{ Doc\_info.number()=unsigned(atof(input\_string.c\_str()));}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Increment number for next solution}}
\DoxyCodeLine{ Doc\_info.number()++;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Read line up to termination sign}}
\DoxyCodeLine{ getline(restart\_file,input\_string,\textcolor{charliteral}{'\#'});}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Ignore rest of line}}
\DoxyCodeLine{ restart\_file.ignore(80,\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Read suggested next timestep}}
\DoxyCodeLine{ Next\_dt=double(atof(input\_string.c\_str()));}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Refine the mesh and read in the generic problem data}}
\DoxyCodeLine{ Problem::read(restart\_file);}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// end of restart}}

\end{DoxyCodeInclude}
 \mbox{[}The slightly clumsy read procedure is required to ensure that the comments that follow the \char`\"{}raw\char`\"{} data are ignored.\mbox{]}

Following the assignment of the initial conditions, the first timestep for the timestepping loop in the {\ttfamily main} function can now be obtained from {\ttfamily next\+\_\+dt()} since {\ttfamily Next\+\_\+dt} will either have been set to the actual first timestep used when setting up the initial conditions at time $ t=0$, or to the next timestep that had been suggested by the adaptive timestepper when the restart file was created.

Here are the time-\/traces for the solution and the timesteps from the original and the restarted simulations -- apart from the (very small) roundoff errors due to the finite precision in which all data is recorded in the restart files, they are now in perfect agreement.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{restart_trace}
\doxyfigcaption{Time-\/traces of the solution and the timestep for the original (green) and restarted (red) simulations with the customised dump/restart procedure. }
\end{DoxyImage}


\DoxyHorRuler{0}
\hypertarget{index_no_pub}{}\doxysubsection{Do NOT use public member data in any classes}\label{index_no_pub}
A little aside\+: Yes, we really do recommend storing the suggestion for the size of the next timestep as private member data and providing an access function to it. This must seem like (and indeed is) slight overkill in the present context\+: Why can\textquotesingle{}t we just store it as public member data and avoid having to write the access function? The answer is\+: Because public data is bad and it\textquotesingle{}s a good habit to avoid it as a matter of principle -- even in trivial examples.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/unsteady_heat/two_d_unsteady_heat_2adapt/}{\texttt{ demo\+\_\+drivers/unsteady\+\_\+heat/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+2adapt/ }} \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/unsteady_heat/two_d_unsteady_heat_2adapt/two_d_unsteady_heat_2adapt.cc}{\texttt{ demo\+\_\+drivers/unsteady\+\_\+heat/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+2adapt/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+2adapt.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{PDF file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
