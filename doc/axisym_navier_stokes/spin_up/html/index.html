<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Example problem: Spin-up of a viscous fluid</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Example problem: Spin-up of a viscous fluid </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is our first axisymmetric Navier&ndash;Stokes example problem. We discuss the non-dimensionalisation of the equations and their implementation in <code>oomph-lib</code>, and demonstrate the solution of a spin-up problem.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="equations"></a>
The axisymmetric Navierâ€“Stokes equations</h1>
<p>In dimensional form the axisymmetric Navier&ndash;Stokes equations are given by the momentum equations (for the <img class="formulaInl" alt="$ r^* $" src="form_0.png" width="11" height="10"/> , <img class="formulaInl" alt="$ z^* $" src="form_1.png" width="11" height="10"/> and <img class="formulaInl" alt="$ \theta $" src="form_2.png" width="6" height="10"/> directions, respectively) </p><center> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \rho \left[ \frac{\partial u_r^*}{\partial t^*} + {u_r^*}\frac{\partial u_r^*}{\partial r^*} - \frac{{u_{\theta}^*}^2}{r^*} + {u_z^*}\frac{\partial u_r^*}{\partial z^*} \right] = B_r^*\left(r^*,z^*,t^*\right) + \rho G_r^* + \frac{\partial \tau_{rr}^*}{\partial r^*} + \frac{\tau_{rr}^*}{r^*} - \frac{\tau_{\theta\theta}^*}{r^*} + \frac{\partial\tau_{rz}^*}{\partial z^*}, \]" src="form_3.png" width="436" height="33"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \rho \left[ \frac{\partial u_z^*}{\partial t^*} + {u_r^*}\frac{\partial u_z^*}{\partial r^*} + {u_z^*}\frac{\partial u_z^*}{\partial z^*} \right] = B_z^*\left(r^*,z^*,t^*\right) + \rho G_z^* + \frac{\partial \tau_{zr}^*}{\partial r^*} + \frac{\tau_{zr}^*}{r^*} + \frac{\partial\tau_{zz}^*}{\partial z^*}, \]" src="form_4.png" width="395" height="31"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \rho \left[ \frac{\partial u_{\theta}^*}{\partial t^*} + {u_r^*}\frac{\partial u_{\theta}^*}{\partial r^*} + \frac{u_r^* u_{\theta}^*}{r^*} + u_z^* \frac{\partial u_{\theta}^*}{\partial z^*} \right] = B_\theta^*\left(r^*,z^*,t^*\right) + \rho G_\theta^* + \frac{\partial \tau_{\theta r}^*}{\partial r^*} + \frac{\tau_{\theta r}^*}{r^*} + \frac{\tau_{r\theta}^*}{r^*} + \frac{\partial\tau_{\theta z}^*}{\partial z^*}, \]" src="form_5.png" width="444" height="31"/>
</p>
 </center><p>and the continuity equation</p>
<center> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial u_r^*}{\partial r^*} + \frac{u_r^*}{r^*} + \frac{\partial u_z^*}{\partial z^*} = Q^*, \]" src="form_6.png" width="128" height="28"/>
</p>
 </center><p>where <img class="formulaInl" alt="$ u_r^* $" src="form_7.png" width="14" height="14"/> , <img class="formulaInl" alt="$ u_z^* $" src="form_8.png" width="14" height="14"/> and <img class="formulaInl" alt="$ u_{\theta}^* $" src="form_9.png" width="13" height="14"/> are the radial, axial and azimuthal velocity components respectively, <img class="formulaInl" alt="$ p^* $" src="form_10.png" width="13" height="13"/> is the pressure and <img class="formulaInl" alt="$ t^* $" src="form_11.png" width="10" height="10"/> is time. We have split the body force into two components: A constant vector <img class="formulaInl" alt="$ \rho \ G_i^* $" src="form_12.png" width="26" height="14"/> (where <img class="formulaInl" alt="$ i = r, z, \theta $" src="form_13.png" width="51" height="13"/>) which typically represents gravitational forces; and a variable body force, <img class="formulaInl" alt="$ B_i^*(r^*,z^*,t^*) $" src="form_14.png" width="70" height="14"/> . <img class="formulaInl" alt="$ Q^*(r^*,z^*,t^*) $" src="form_15.png" width="69" height="14"/> is a volumetric source term for the continuity equation and is typically equal to zero.</p>
<p>The components of the dimensional stress tensor <img class="formulaInl" alt="$ \tau_{ij}^* $" src="form_16.png" width="14" height="15"/> are defined as:</p>
<center> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tau_{rr}^* = -p^* + \mu (1+\Gamma) \frac{\partial u_r^*}{\partial r^*}, \qquad \tau_{\theta\theta}^* = -p^* + \mu (1+\Gamma) \frac{u_r^*}{r^*}, \qquad \tau_{zz}^* = -p^* + \mu (1+\Gamma) \frac{\partial u_z^*}{\partial z^*}, \]" src="form_17.png" width="441" height="28"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tau_{rz}^* = \mu \left( \frac{\partial u_r^*}{\partial z^*} + \Gamma \frac{\partial u_z^*}{\partial r^*} \right), \qquad \tau_{zr}^* = \mu \left( \frac{\partial u_z^*}{\partial r^*} + \Gamma \frac{\partial u_r^*}{\partial z^*} \right), \]" src="form_18.png" width="299" height="31"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tau_{r \theta}^* = \mu \left( \Gamma \frac{\partial u_{\theta}^*}{\partial r^*} - \frac{u_{\theta}^*}{r^*} \right), \qquad \tau_{\theta r}^* = \mu \left( \frac{\partial u_{\theta}^*}{\partial r^*} - \Gamma \frac{u_{\theta}^*}{r^*} \right), \]" src="form_19.png" width="284" height="31"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tau_{\theta z}^* = \mu \frac{\partial u_{\theta}^*}{\partial z^*}, \qquad \tau_{z \theta}^* = \mu \Gamma \frac{\partial u_{\theta}^*}{\partial z^*}. \]" src="form_20.png" width="169" height="28"/>
</p>
 </center><p>We note that taking <img class="formulaInl" alt="$ \Gamma=1 $" src="form_21.png" width="31" height="9"/> corresponds to using the stress-divergence form of the viscous term in the Navier&ndash;Stokes equations, which is the form that <code>oomph-lib</code> uses by default. We can, however, recover the &lsquo;standard&rsquo; form by setting <img class="formulaInl" alt="$ \Gamma=0 $" src="form_22.png" width="31" height="9"/>.</p>
<p>We non-dimensionalise the equations, using problem-specific reference quantities for the velocity, <img class="formulaInl" alt="$ {\cal U},$" src="form_23.png" width="13" height="13"/> length, <img class="formulaInl" alt="$ {\cal L}, $" src="form_24.png" width="13" height="13"/> and time, <img class="formulaInl" alt="${\cal T},$" src="form_25.png" width="14" height="13"/> and scale the constant body force vector on the gravitational acceleration, <img class="formulaInl" alt="$ g, $" src="form_26.png" width="10" height="9"/> so that </p><center> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_r^* = {\cal U} \, u_r, \qquad u_z^* = {\cal U} \, u_z, \qquad u_\theta^* = {\cal U} \, u_\theta, \]" src="form_27.png" width="224" height="14"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ r^* = {\cal L} \, r, \qquad z^* = {\cal L} \, z, \qquad t^* = {\cal T} \, t, \qquad G_i^* = g \, G_i, \]" src="form_28.png" width="283" height="14"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ p^* = \frac{\mu_{ref} {\cal U}}{{\cal L}} \, p, \qquad B_i^* = \frac{{\cal U}\mu_{ref}}{{\cal L}^2} \, B_i, \qquad Q^* = \frac{{\cal U}}{{\cal L}}\, Q, \]" src="form_29.png" width="278" height="28"/>
</p>
 </center><p> where we note that the pressure and the variable body force have been non-dimensionalised on the viscous scale. <img class="formulaInl" alt="$ \mu_{ref} $" src="form_30.png" width="24" height="10"/> and <img class="formulaInl" alt="$ \rho_{ref} $" src="form_31.png" width="23" height="10"/> are reference values for the fluid viscosity and density, respectively. In single-fluid problems, they are identical to the viscosity <img class="formulaInl" alt="$ \mu $" src="form_32.png" width="9" height="9"/> and density <img class="formulaInl" alt="$ \rho $" src="form_33.png" width="8" height="9"/> of the (one and only) fluid in the problem.</p>
<p>The non-dimensional form of the axisymmetric Navier&ndash;Stokes equations is then given by </p><center> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ R_{\rho} Re \left[ St \frac{\partial u_r}{\partial t} + u_r \frac{\partial u_r}{\partial r} - \frac{u_\theta^2}{r} + u_z \frac{\partial u_r}{\partial z} \right] = B_r\left(r,z,t\right) + R_\rho \frac{Re}{Fr} G_r + \frac{\partial \tau_{rr}}{\partial r} + \frac{\tau_{rr}}{r} - \frac{\tau_{\theta\theta}}{r} + \frac{\partial \tau_{rz}}{\partial z}, \]" src="form_34.png" width="476" height="31"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ R_{\rho} Re \left[ St \frac{\partial u_z}{\partial t} + u_r \frac{\partial u_z}{\partial r} + u_z \frac{\partial u_z}{\partial z} \right] = B_z\left(r,z,t\right) + R_\rho \frac{Re}{Fr} G_z + \frac{\partial \tau_{zr}}{\partial r} + \frac{\tau_{zr}}{r} + \frac{\partial \tau_{zz}}{\partial z}, \]" src="form_35.png" width="429" height="31"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ R_{\rho} Re \left[ St \frac{\partial u_\theta}{\partial t} + u_r \frac{\partial u_\theta}{\partial r} + \frac{u_r u_\theta}{r} + u_z \frac{\partial u_\theta}{\partial z} \right] = B_\theta\left(r,z,t\right) + R_\rho \frac{Re}{Fr} G_\theta + \frac{\partial \tau_{\theta r}}{\partial r} + \frac{\tau_{\theta r}}{r} + \frac{\tau_{r \theta}}{r} + \frac{\partial \tau_{\theta z}}{\partial z}, \]" src="form_36.png" width="489" height="31"/>
</p>
 </center><p>and</p>
<center> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial u_r}{\partial r} + \frac{u_r}{r} + \frac{\partial u_z}{\partial z} = Q. \]" src="form_37.png" width="121" height="28"/>
</p>
 </center><p>Here the components of the non-dimensional stress tensor <img class="formulaInl" alt="$ \tau_{ij} $" src="form_38.png" width="14" height="10"/> are defined as:</p>
<center> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tau_{rr} = -p + R_\mu (1+\Gamma) \frac{\partial u_r}{\partial r}, \qquad \tau_{\theta\theta} = -p + R_\mu (1+\Gamma) \frac{u_r}{r}, \qquad \tau_{zz} = -p + R_\mu (1+\Gamma) \frac{\partial u_z}{\partial z}, \]" src="form_39.png" width="449" height="28"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tau_{rz} = R_\mu \left( \frac{\partial u_r}{\partial z} + \Gamma \frac{\partial u_z}{\partial r} \right), \qquad \tau_{zr} = R_\mu \left( \frac{\partial u_z}{\partial r} + \Gamma \frac{\partial u_r}{\partial z} \right), \]" src="form_40.png" width="315" height="31"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tau_{r \theta} = R_\mu \left( \Gamma \frac{\partial u_\theta}{\partial r} - \frac{u_\theta}{r} \right), \qquad \tau_{\theta r} = R_\mu \left( \frac{\partial u_\theta}{\partial r} - \Gamma \frac{u_\theta}{r} \right), \]" src="form_41.png" width="300" height="31"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tau_{\theta z} = R_\mu \frac{\partial u_\theta}{\partial z} \qquad \tau_{z \theta} = R_\mu \Gamma \frac{\partial u_\theta}{\partial z}. \]" src="form_42.png" width="180" height="28"/>
</p>
 </center><p>The dimensionless parameters </p><center> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ Re = \frac{{\cal U}{\cal L}\rho_{ref}}{\mu_{ref}}, \qquad St = \frac{{\cal L}}{{\cal U}{\cal T}}, \qquad Fr = \frac{{\cal U}^2}{g{\cal L}}, \]" src="form_43.png" width="241" height="33"/>
</p>
 </center><p> are the Reynolds number, Strouhal number and Froude number respectively. <img class="formulaInl" alt="$ R_\rho=\rho/\rho_{ref} $" src="form_44.png" width="66" height="14"/> and <img class="formulaInl" alt="$ R_\mu =\mu/\mu_{ref}$" src="form_45.png" width="69" height="14"/> represent the ratios of the fluid's density and its dynamic viscosity, relative to the density and viscosity values used to form the non-dimensional parameters (By default, <img class="formulaInl" alt="$ R_\rho = R_\mu = 1 $" src="form_46.png" width="70" height="14"/> ; other values tend to be used in problems involving multiple fluids). We refer to <a href="../../../navier_stokes/driven_cavity/html/index.html#params">another tutorial</a> for a more detailed discussion of these non-dimensional parameters and their default values.</p>
<p>The above equations are typically augmented by Dirichlet boundary conditions for (some of) the velocity components. On boundaries where no velocity boundary conditions are applied, the flow satisfies the "traction free" natural boundary condition <img class="formulaInl" alt="$ t_i = 0 $" src="form_47.png" width="33" height="11"/>. For example, in the spin-up problem to be considered below, no condition is applied to the <img class="formulaInl" alt="$ z $" src="form_48.png" width="6" height="6"/>-component of the velocity on the symmetry boundary, which means that the traction in this direction, <img class="formulaInl" alt="$ t_z $" src="form_49.png" width="10" height="11"/>, is equal to zero.</p>
<p>If the velocity is prescribed along the entire domain boundary, the fluid pressure <img class="formulaInl" alt="$ p $" src="form_50.png" width="8" height="9"/> is only determined up to an arbitrary constant. This indeterminacy may be overcome by prescribing the value of the pressure at a single point in the domain. See the exercises at the end of the (non-axisymmetric) <a href="../../../navier_stokes/driven_cavity/html/index.html#exercises">driven cavity example</a> for further discussion of this issue.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="implementation"></a>
Implementation</h1>
<p><code>oomph-lib</code> provides two LBB-stable isoparametric axisymmetric Navier&ndash;Stokes elements that are based on the <code>QElement&lt;2,3&gt;</code> family of geometric finite elements. They are nine-node quadrilateral elements which only differ in the way in which the pressure is represented. In <code>AxisymmetricQCrouzeixRaviartElements</code> the pressure is represented by a discontinuous, piecewise bi-linear function. <code>AxisymmetricQTaylorHoodElements</code> represent the pressure by a globally-continuous, piecewise bi-linear interpolation between the pressure values that are stored at the elements' four corner nodes.</p>
<p>The implementation of these axisymmetric Navier&ndash;Stokes elements is very similar to their non-axisymmetric counterparts, discussed in detail in <a href="../../../navier_stokes/driven_cavity/html/index.html#element_types">another tutorial</a>. The radial and axial nodal positions are stored at the first and second nodal coordinates respectively, and can therefore be accessed by the member functions</p><ul>
<li>Radial coordinate ( <img class="formulaInl" alt="$ r $" src="form_51.png" width="8" height="6"/>): <code>Node::x(0)</code> </li>
<li>Axial coordinate ( <img class="formulaInl" alt="$ z $" src="form_48.png" width="6" height="6"/>): <code>Node::x(1)</code> </li>
</ul>
<p>By default the radial, axial and azimuthal components are stored as the first, second and third nodal values respectively, and can therefore be accessed by the member functions</p><ul>
<li>Radial component ( <img class="formulaInl" alt="$ u_r $" src="form_52.png" width="14" height="9"/>): <code>Node::value(0)</code> </li>
<li>Axial component ( <img class="formulaInl" alt="$ u_z $" src="form_53.png" width="14" height="9"/>): <code>Node::value(1)</code> </li>
<li>Azimuthal component ( <img class="formulaInl" alt="$ u_\theta $" src="form_54.png" width="13" height="9"/>): <code>Node::value(2)</code> </li>
</ul>
<hr  />
 <hr  />
<h1><a class="anchor" id="example"></a>
The example problem</h1>
<p>The solution of the axisymmetric Navier&ndash;Stokes equations will be illustrated using the example of a spin-up problem. We consider a sealed cylindrical container of radius <img class="formulaInl" alt="$ R $" src="form_55.png" width="10" height="10"/> and height <img class="formulaInl" alt="$ H $" src="form_56.png" width="11" height="10"/>, filled with a fluid of density <img class="formulaInl" alt="$ \rho $" src="form_33.png" width="8" height="9"/> and dynamic viscosity <img class="formulaInl" alt="$ \mu $" src="form_32.png" width="9" height="9"/>. Both the fluid and the cylinder are initially at rest, and at time <img class="formulaInl" alt="$ t=0 $" src="form_57.png" width="29" height="9"/> the cylinder immediately begins to rotate about its vertical axis of symmetry with a constant angular velocity <img class="formulaInl" alt="$ \Omega $" src="form_58.png" width="9" height="10"/>. Initially, the bulk of the fluid remains stationary, with the exception of the regions next to the solid boundaries. The fluid near the top and bottom &lsquo;lids&rsquo; is moving faster than that along the bulk of the cylinder, and gets driven radially outward. It is replaced by fluid from the interior, setting up secondary flows in the <img class="formulaInl" alt="$ r $" src="form_51.png" width="8" height="6"/>- <img class="formulaInl" alt="$ z $" src="form_48.png" width="6" height="6"/> plane, until eventually the entire fluid is moving in solid body rotation with the cylinder.</p>
<div class="image">
<img src="spin_up_diagram.gif" alt=""/>
<div class="caption">
Sketch of the problem. The red `slice' represents the domain in which the axisymmetric Navier--Stokes equations will be solved. </div></div>
 <p>We model this problem by solving the axisymmetric Navier&ndash;Stokes equations in a rectangular domain of width <img class="formulaInl" alt="$ R $" src="form_55.png" width="10" height="10"/> and height <img class="formulaInl" alt="$ H $" src="form_56.png" width="11" height="10"/>. For our non-dimensionalisation we choose the length scale <img class="formulaInl" alt="$ {\cal L} $" src="form_59.png" width="10" height="10"/> to be the radius of the cylinder <img class="formulaInl" alt="$ R $" src="form_55.png" width="10" height="10"/> and the velocity scale <img class="formulaInl" alt="$ {\cal U} $" src="form_60.png" width="10" height="11"/> to be the speed of the outer wall <img class="formulaInl" alt="$ R \, \Omega $" src="form_61.png" width="20" height="10"/>. The time scale <img class="formulaInl" alt="$ {\cal T} $" src="form_62.png" width="11" height="11"/> is chosen to be <img class="formulaInl" alt="$ {\cal L}/{\cal U} $" src="form_63.png" width="25" height="14"/> so that the Strouhal number is equal to one. We choose an aspect ratio of <img class="formulaInl" alt="$ H = 1.4 R $" src="form_64.png" width="54" height="10"/> and therefore our domain <img class="formulaInl" alt="$ D $" src="form_65.png" width="10" height="10"/> is defined to be </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ D = \{ r \in [0.0,1.0], \; z \in [0.0,1.4] \}. \]" src="form_66.png" width="184" height="14"/>
</p>
<p> The governing equations are subject to the Dirichlet boundary conditions </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_r = 0, \qquad u_z = 0, \qquad u_\theta = r \]" src="form_67.png" width="169" height="11"/>
</p>
<p> on the bottom, right and top boundaries and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_r = 0, \qquad u_\theta = 0 \]" src="form_68.png" width="101" height="11"/>
</p>
<p> on the left boundary, <img class="formulaInl" alt="$ r=0 $" src="form_69.png" width="30" height="9"/>. The <img class="formulaInl" alt="$ z $" src="form_48.png" width="6" height="6"/>-component of the velocity on this boundary is traction-free, which corresponds to the symmetry condition <img class="formulaInl" alt="$ \partial u_z /\partial r = 0 $" src="form_70.png" width="63" height="14"/>.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="results"></a>
Results</h1>
<p>The figure below shows contour plots of the azimuthal velocity component and the pressure distribution with superimposed streamlines, taken from <a href="../figures/spin_up_stream.avi">an animation of the flow field</a>, computed with axisymmetric Taylor-Hood elements for the parameters <img class="formulaInl" alt="$ Re = Re \, St = 5.0 $" src="form_71.png" width="95" height="10"/></p>
<div class="image">
<img src="spin_up_stream.gif" alt=""/>
<div class="caption">
Plot of the azimuthal velocity and pressure fields. </div></div>
 <p>The figure below shows carpet plots of all three velocity components and the pressure, taken from <a href="../figures/spin_up_carpet.avi">another animation of the flow field</a>, computed with axisymmetric Taylor-Hood elements for the parameters <img class="formulaInl" alt="$ Re = Re \, St = 5.0 $" src="form_71.png" width="95" height="10"/></p>
<div class="image">
<img src="spin_up_carpet.gif" alt=""/>
<div class="caption">
Plot of the velocity and pressure fields. </div></div>
 <hr  />
 <hr  />
<h1><a class="anchor" id="namespace"></a>
Global parameters and functions</h1>
<p>The Reynolds number and the Womersley number (the product of the Reynolds and Strouhal numbers) are needed in this problem. As usual, we define them in a namespace:</p>
 <div class="fragment"><div class="line"><span class="comment">//==start_of_namespace====================================================</span></div>
<div class="line"><span class="comment">/// Namespace for physical parameters</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceGlobal__Physical__Variables.html">Global_Physical_Variables</a></div>
<div class="line">{</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Reynolds number</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#ab814e627d2eb5bc50318879d19ab16b9">Re</a> = 5.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Womersley number</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#a085ee4bf968ffdd01a41b8c41864f907">ReSt</a> = 5.0;</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// End of namespace</span></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html">Global_Physical_Variables</a></div><div class="ttdoc">Namespace for physical parameters.</div><div class="ttdef"><b>Definition:</b> <a href="spin__up_8cc_source.html#l00049">spin_up.cc:50</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a085ee4bf968ffdd01a41b8c41864f907"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a085ee4bf968ffdd01a41b8c41864f907">Global_Physical_Variables::ReSt</a></div><div class="ttdeci">double ReSt</div><div class="ttdoc">Womersley number.</div><div class="ttdef"><b>Definition:</b> <a href="spin__up_8cc_source.html#l00056">spin_up.cc:56</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_ab814e627d2eb5bc50318879d19ab16b9"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#ab814e627d2eb5bc50318879d19ab16b9">Global_Physical_Variables::Re</a></div><div class="ttdeci">double Re</div><div class="ttdoc">Reynolds number.</div><div class="ttdef"><b>Definition:</b> <a href="spin__up_8cc_source.html#l00053">spin_up.cc:53</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="main"></a>
The driver code</h1>
<p>We start by specifying the (non-dimensional) length of time we want to run the simulation for and the size of the timestep. Because all driver codes are run as part of <code>oomph-lib's</code> self-testing routines we allow the user to pass a command line argument to the executable which sets the maximum time to some lower value.</p>
<div class="fragment"><div class="line"><span class="comment">//==start_of_main=========================================================</span></div>
<div class="line"><span class="comment">/// Driver code for axisymmetric spin-up problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="spin__up_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Store command line arguments</span></div>
<div class="line"> CommandLineArgs::setup(argc,argv);</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Maximum time</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> t_max = 1.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Duration of timestep</span></div>
<div class="line"><span class="comment"></span> <span class="keyword">const</span> <span class="keywordtype">double</span> dt = 0.01;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// If we are doing validation run, use smaller number of timesteps</span></div>
<div class="line"> <span class="keywordflow">if</span>(CommandLineArgs::Argc&gt;1) { t_max = 0.02; }</div>
<div class="ttc" id="aspin__up_8cc_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="spin__up_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdoc">/////////////////////////////////////////////////////////////////////// /////////////////////////////...</div><div class="ttdef"><b>Definition:</b> <a href="spin__up_8cc_source.html#l00427">spin_up.cc:427</a></div></div>
</div><!-- fragment --><p> Next we specify the dimensions of the mesh and the number of elements in the radial and azimuthal directions.</p>
<div class="fragment"><div class="line"> <span class="comment">// Number of elements in radial (r) direction</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_r = 2;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Number of elements in axial (z) direction</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_z = 2;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Length in radial (r) direction</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span> l_r = 1.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Length in axial (z) direction</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span> l_z = 1.4;</div>
</div><!-- fragment --><p> We build the problem using <code>RefineableAxisymmetricQTaylorHoodElements</code> and the <code>BDF&lt;2&gt;</code> timestepper, before calling <code>unsteady_run(...)</code>. This function solves the system at each timestep using the <code>Problem::unsteady_newton_solve(...)</code> function before documenting the result.</p>
<div class="fragment"><div class="line"> <span class="comment">// RefineableAxisymmetricQTaylorHoodElements</span></div>
<div class="line"> <span class="comment">// -----------------------------------------</span></div>
<div class="line"> {</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Doing RefineableAxisymmetricQTaylorHoodElement&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Build the problem with RefineableAxisymmetricQTaylorHoodElements</span></div>
<div class="line">  <a class="code" href="classRotatingCylinderProblem.html">RotatingCylinderProblem</a></div>
<div class="line">   &lt;RefineableAxisymmetricQTaylorHoodElement, BDF&lt;2&gt; &gt; </div>
<div class="line">   problem(n_r,n_z,l_r,l_z);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Solve the problem and output the solution</span></div>
<div class="line">  problem.unsteady_run(t_max,dt,<span class="stringliteral">&quot;RESLT_TH&quot;</span>);</div>
<div class="line"> }</div>
<div class="ttc" id="aclassRotatingCylinderProblem_html"><div class="ttname"><a href="classRotatingCylinderProblem.html">RotatingCylinderProblem</a></div><div class="ttdoc">/////////////////////////////////////////////////////////////////////// /////////////////////////////...</div><div class="ttdef"><b>Definition:</b> <a href="spin__up_8cc_source.html#l00071">spin_up.cc:72</a></div></div>
</div><!-- fragment --><p> We then repeat the process with <code>RefineableAxisymmetricQCrouzeixRaviartElements</code>.</p>
<div class="fragment"><div class="line"> <span class="comment">// RefineableAxisymmetricQCrouzeixRaviartElements</span></div>
<div class="line"> <span class="comment">// ----------------------------------------------</span></div>
<div class="line"> {</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Doing RefineableAxisymmetricQCrouzeixRaviartElement&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Build the problem with RefineableAxisymmetricQCrouzeixRaviartElements</span></div>
<div class="line">  <a class="code" href="classRotatingCylinderProblem.html">RotatingCylinderProblem</a></div>
<div class="line">   &lt;RefineableAxisymmetricQCrouzeixRaviartElement, BDF&lt;2&gt; &gt;</div>
<div class="line">   problem(n_r,n_z,l_r,l_z);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Solve the problem and output the solution</span></div>
<div class="line">  problem.unsteady_run(t_max,dt,<span class="stringliteral">&quot;RESLT_CR&quot;</span>);</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// End of main</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="problem"></a>
The problem class</h1>
<p>The <code>Problem</code> class for our unsteady axisymmetric Navier&ndash;Stokes problem is very similar to that used in the <a href="../../../navier_stokes/rayleigh_channel/html/index.html">Rayleigh channel example</a>. We specify the type of the element and the type of the timestepper (assumed to be a member of the <code>BDF</code> family) as template parameters, and pass the number of elements and domain length in both coordinate directions to the problem constructor. We define an empty destructor, functions to set the initial and boundary conditions and a post-processing function <code>doc_solution(...)</code>, which will be used by the timestepping function <code>unsteady_run(...)</code>.</p>
 <div class="fragment"><div class="line"><span class="comment">//==start_of_problem_class================================================</span></div>
<div class="line"><span class="comment">/// Refineable rotating cylinder problem in a rectangular</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// axisymmetric domain</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ELEMENT, <span class="keyword">class</span> TIMESTEPPER&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classRotatingCylinderProblem.html">RotatingCylinderProblem</a> : <span class="keyword">public</span> Problem</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Constructor: Pass the number of elements and the lengths of the</span></div>
<div class="line"><span class="comment"> /// domain in the radial (r) and axial (z) directions</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classRotatingCylinderProblem.html#a436b0ff8c4ac33acfe10492c587ad80d">RotatingCylinderProblem</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; n_r, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; n_z,</div>
<div class="line">                         <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; l_r, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; l_z);</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Destructor (empty)</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classRotatingCylinderProblem.html#a586e71f48ee21cfc3bc93d17e91bbc11">~RotatingCylinderProblem</a>() {}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Set initial conditions</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classRotatingCylinderProblem.html#a5e4316cce2306c4aab4a20b88cdfe6e3">set_initial_condition</a>();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Set boundary conditions</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classRotatingCylinderProblem.html#a37efdb2d7059535a48b12f69869996ee">set_boundary_conditions</a>();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Document the solution</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classRotatingCylinderProblem.html#a22f82fba41d68b9748642f9a29a12592">doc_solution</a>(DocInfo &amp;doc_info);</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Do unsteady run up to maximum time t_max with given timestep dt</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classRotatingCylinderProblem.html#abfb7f77b97e9ac061edbaa97a018cd24">unsteady_run</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; t_max, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; dt,</div>
<div class="line">                   <span class="keyword">const</span> <span class="keywordtype">string</span> dir_name);</div>
<div class="ttc" id="aclassRotatingCylinderProblem_html_a22f82fba41d68b9748642f9a29a12592"><div class="ttname"><a href="classRotatingCylinderProblem.html#a22f82fba41d68b9748642f9a29a12592">RotatingCylinderProblem::doc_solution</a></div><div class="ttdeci">void doc_solution(DocInfo &amp;doc_info)</div><div class="ttdoc">Document the solution.</div><div class="ttdef"><b>Definition:</b> <a href="spin__up_8cc_source.html#l00319">spin_up.cc:320</a></div></div>
<div class="ttc" id="aclassRotatingCylinderProblem_html_a37efdb2d7059535a48b12f69869996ee"><div class="ttname"><a href="classRotatingCylinderProblem.html#a37efdb2d7059535a48b12f69869996ee">RotatingCylinderProblem::set_boundary_conditions</a></div><div class="ttdeci">void set_boundary_conditions()</div><div class="ttdoc">Set boundary conditions.</div><div class="ttdef"><b>Definition:</b> <a href="spin__up_8cc_source.html#l00274">spin_up.cc:274</a></div></div>
<div class="ttc" id="aclassRotatingCylinderProblem_html_a436b0ff8c4ac33acfe10492c587ad80d"><div class="ttname"><a href="classRotatingCylinderProblem.html#a436b0ff8c4ac33acfe10492c587ad80d">RotatingCylinderProblem::RotatingCylinderProblem</a></div><div class="ttdeci">RotatingCylinderProblem(const unsigned &amp;n_r, const unsigned &amp;n_z, const double &amp;l_r, const double &amp;l_z)</div><div class="ttdoc">Constructor: Pass the number of elements and the lengths of the domain in the radial (r) and axial (z...</div><div class="ttdef"><b>Definition:</b> <a href="spin__up_8cc_source.html#l00148">spin_up.cc:149</a></div></div>
<div class="ttc" id="aclassRotatingCylinderProblem_html_a586e71f48ee21cfc3bc93d17e91bbc11"><div class="ttname"><a href="classRotatingCylinderProblem.html#a586e71f48ee21cfc3bc93d17e91bbc11">RotatingCylinderProblem::~RotatingCylinderProblem</a></div><div class="ttdeci">~RotatingCylinderProblem()</div><div class="ttdoc">Destructor (empty)</div><div class="ttdef"><b>Definition:</b> <a href="spin__up_8cc_source.html#l00082">spin_up.cc:82</a></div></div>
<div class="ttc" id="aclassRotatingCylinderProblem_html_a5e4316cce2306c4aab4a20b88cdfe6e3"><div class="ttname"><a href="classRotatingCylinderProblem.html#a5e4316cce2306c4aab4a20b88cdfe6e3">RotatingCylinderProblem::set_initial_condition</a></div><div class="ttdeci">void set_initial_condition()</div><div class="ttdoc">Set initial conditions.</div><div class="ttdef"><b>Definition:</b> <a href="spin__up_8cc_source.html#l00244">spin_up.cc:244</a></div></div>
<div class="ttc" id="aclassRotatingCylinderProblem_html_abfb7f77b97e9ac061edbaa97a018cd24"><div class="ttname"><a href="classRotatingCylinderProblem.html#abfb7f77b97e9ac061edbaa97a018cd24">RotatingCylinderProblem::unsteady_run</a></div><div class="ttdeci">void unsteady_run(const double &amp;t_max, const double &amp;dt, const string dir_name)</div><div class="ttdoc">Do unsteady run up to maximum time t_max with given timestep dt.</div><div class="ttdef"><b>Definition:</b> <a href="spin__up_8cc_source.html#l00351">spin_up.cc:352</a></div></div>
</div><!-- fragment --><p> Next we define an access function to the specific <code>Mesh:</code> </p>
<div class="fragment"><div class="line"> <span class="comment">/// Access function for the specific mesh</span></div>
<div class="line"> RefineableRectangularQuadMesh&lt;ELEMENT&gt;* mesh_pt() </div>
<div class="line">  {</div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span>RefineableRectangularQuadMesh&lt;ELEMENT&gt;*<span class="keyword">&gt;</span></div>
<div class="line">    (Problem::mesh_pt());</div>
<div class="line">  }</div>
</div><!-- fragment --><p> We reset the boundary conditions before each solve by overloading <code>Problem::actions_before_newton_solve()</code>. This is to ensure that all newly-created nodes are given the correct boundary conditions.</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Update the problem specs before solve. </span></div>
<div class="line"><span class="comment"> /// Reset velocity boundary conditions just to be on the safe side...</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> actions_before_newton_solve() { set_boundary_conditions(); }</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// No actions required after solve step</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> actions_after_newton_solve() {}</div>
</div><!-- fragment --><p> In Navier&ndash;Stokes problems in which the velocity is prescribed along the entire domain boundary, the pressure is only determined up an arbitrary constant, making it necessary to "pin" one pressure value. If the pinned pressure degree of freedom is associated with an element that is unrefined during the mesh adaptation, the pinned degree of freedom may no longer exist in the adapted problem. We therefore use the function <code>Problem::actions_after_adapt()</code> to ensure that precisely one pressure degree of freedom is pinned when re-solving the adapted problem. Additionally, the possible presence of hanging nodes in an adapted mesh requires special treatment for elements (e.g. Taylor-Hood elements) in which the pressure is represented by a low-order interpolation between a subset of the element's nodal values. The function <code>AxisymmetricNavierStokesEquations::pin_redundant_nodal_pressures(...)</code> performs the required tasks. The technical details of these functions are discussed in detail in an <a href="../../../navier_stokes/adaptive_driven_cavity/html/index.html">earlier tutorial</a>.</p>
<div class="fragment"><div class="line"> <span class="comment">/// After adaptation: Pin pressure again (the previously pinned</span></div>
<div class="line"><span class="comment"> /// value might have disappeared) and pin redudant pressure dofs</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> actions_after_adapt()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Unpin all pressure dofs</span></div>
<div class="line">   RefineableAxisymmetricNavierStokesEquations::</div>
<div class="line">    unpin_all_pressure_dofs(mesh_pt()-&gt;element_pt());</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Pin redudant pressure dofs</span></div>
<div class="line">   RefineableAxisymmetricNavierStokesEquations::</div>
<div class="line">    pin_redundant_nodal_pressures(mesh_pt()-&gt;element_pt());</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Now set the pressure in first element at &#39;node&#39; 0 to 0.0</span></div>
<div class="line">   fix_pressure(0,0,0.0);</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// End of actions_after_adapt</span></div>
</div><!-- fragment --><p> Finally, we provide a helper function <code>fix_pressure(...)</code> which pins a pressure value in a specified element and assigns a specific value.</p>
<div class="fragment"><div class="line"> <span class="comment">/// Fix pressure in element e at pressure dof pdof and set to pvalue</span></div>
<div class="line"> <span class="keywordtype">void</span> fix_pressure(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; e,</div>
<div class="line">                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; pdof, </div>
<div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; pvalue)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Cast to actual element and fix pressure</span></div>
<div class="line">   <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(mesh_pt()-&gt;element_pt(e))-&gt;</div>
<div class="line">    fix_pressure(pdof,pvalue);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">}; <span class="comment">// End of problem class</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="constructor"></a>
The problem constructor</h1>
<p>We start by building the timestepper, determining its type from the class's second template argument, and pass a pointer to it to the problem, using the function <code>Problem::add_time_stepper_pt(...)</code>.</p>
<div class="fragment"><div class="line"><span class="comment">//==start_of_constructor==================================================</span></div>
<div class="line"><span class="comment">/// Constructor for refineable rotating cylinder problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ELEMENT, <span class="keyword">class</span> TIMESTEPPER&gt;</div>
<div class="line"><a class="code" href="classRotatingCylinderProblem.html#a436b0ff8c4ac33acfe10492c587ad80d">RotatingCylinderProblem&lt;ELEMENT,TIMESTEPPER&gt;::</a></div>
<div class="line"><a class="code" href="classRotatingCylinderProblem.html#a436b0ff8c4ac33acfe10492c587ad80d">RotatingCylinderProblem</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; n_r, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; n_z,</div>
<div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; l_r, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; l_z)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Allocate the timestepper (this constructs the time object as well)</span></div>
<div class="line"> add_time_stepper_pt(<span class="keyword">new</span> TIMESTEPPER);</div>
</div><!-- fragment --><p> Next we build the adaptive mesh and specify an error estimator, which will be used to guide the automatic mesh adaptation. We pass this to the mesh, set the maximum refinement level and override the maximum and minimum permitted errors, which are used to determine whether or not an element should be refined/unrefined during mesh adaptation.</p>
<div class="fragment"><div class="line"> <span class="comment">// Build and assign mesh</span></div>
<div class="line"> Problem::mesh_pt() = <span class="keyword">new</span> RefineableRectangularQuadMesh&lt;ELEMENT&gt;</div>
<div class="line">  (n_r,n_z,l_r,l_z,time_stepper_pt());</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create and set the error estimator for spatial adaptivity</span></div>
<div class="line"> mesh_pt()-&gt;spatial_error_estimator_pt() = <span class="keyword">new</span> Z2ErrorEstimator;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set the maximum refinement level for the mesh to 4</span></div>
<div class="line"> mesh_pt()-&gt;max_refinement_level() = 4;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Override the maximum and minimum permitted errors</span></div>
<div class="line"> mesh_pt()-&gt;max_permitted_error() = 1.0e-2;</div>
<div class="line"> mesh_pt()-&gt;min_permitted_error() = 1.0e-3;</div>
</div><!-- fragment --><p> We pin the radial and azimuthal velocity components on all boundaries, and the axial component on the three solid boundaries.</p>
<div class="fragment"><div class="line"> <span class="comment">// Set the boundary conditions for this problem</span></div>
<div class="line"> <span class="comment">// --------------------------------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// All nodes are free by default -- just pin the ones that have</span></div>
<div class="line"> <span class="comment">// Dirichlet conditions here</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Determine number of mesh boundaries</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_boundary = mesh_pt()-&gt;nboundary();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over mesh boundaries</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> b=0;b&lt;n_boundary;b++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Determine number of nodes on boundary b</span></div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_node = mesh_pt()-&gt;nboundary_node(b);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Loop over nodes on boundary b</span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> n=0;n&lt;n_node;n++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Pin values for radial velocity on all boundaries</span></div>
<div class="line">     mesh_pt()-&gt;boundary_node_pt(b,n)-&gt;pin(0);</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Pin values for axial velocity on all SOLID boundaries (b = 0,1,2)</span></div>
<div class="line">     <span class="keywordflow">if</span>(b!=3) { mesh_pt()-&gt;boundary_node_pt(b,n)-&gt;pin(1); }</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Pin values for azimuthal velocity on all boundaries</span></div>
<div class="line">     mesh_pt()-&gt;boundary_node_pt(b,n)-&gt;pin(2);</div>
<div class="line"> </div>
<div class="line">    } <span class="comment">// End of loop over nodes on boundary b</span></div>
<div class="line">  } <span class="comment">// End of loop over mesh boundaries</span></div>
</div><!-- fragment --><p> We pass the pointers to the Reynolds and Womersley numbers, <img class="formulaInl" alt="$ Re $" src="form_72.png" width="15" height="10"/> and <img class="formulaInl" alt="$ Re\, St $" src="form_73.png" width="30" height="10"/> , and the pointer to the global time object (created when we called <code>Problem::add_time_stepper_pt(...)</code> above) to the elements. Because we know that the mesh will remain stationary we can disable the ALE formulation of the unsteady equations by calling <code>AxisymmetricNavierStokesEquations::disable_ALE()</code>. This suppresses the additional computation required to calculate the correction to the Eulerian time-derivative <img class="formulaInl" alt="$ \partial u /\partial t $" src="form_74.png" width="33" height="14"/> which is required if the mesh is moving, as discussed in detail in <a href="../../../optimisation/html/index.html#ale">another tutorial</a>.</p>
<div class="fragment"><div class="line"> <span class="comment">// Complete the problem setup to make the elements fully functional</span></div>
<div class="line"> <span class="comment">// ----------------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Determine number of elements in mesh</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_element = mesh_pt()-&gt;nelement();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over the elements</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from GeneralisedElement to the present element</span></div>
<div class="line">   ELEMENT* el_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(mesh_pt()-&gt;element_pt(e));</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set the Reynolds number</span></div>
<div class="line">   el_pt-&gt;re_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#ab814e627d2eb5bc50318879d19ab16b9">Global_Physical_Variables::Re</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set the Womersley number</span></div>
<div class="line">   el_pt-&gt;re_st_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a085ee4bf968ffdd01a41b8c41864f907">Global_Physical_Variables::ReSt</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The mesh remains fixed</span></div>
<div class="line">   el_pt-&gt;disable_ALE();</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// End of loop over elements</span></div>
</div><!-- fragment --><p> Since no traction boundary conditions are applied anywhere, the pressure is only determined up to an arbitrary constant. For the reasons discussed above we pin any redundant pressure degrees of freedom caused by hanging nodes and then ensure a unique solution by pinning a single pressure value. Finally, we set up the equation numbering scheme using the function <code>Problem::assign_eqn_numbers()</code>.</p>
<div class="fragment"><div class="line"> <span class="comment">// Pin redundant pressure dofs</span></div>
<div class="line"> RefineableAxisymmetricNavierStokesEquations::</div>
<div class="line">  pin_redundant_nodal_pressures(mesh_pt()-&gt;element_pt());</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Now set the pressure in first element at &#39;node&#39; 0 to 0.0</span></div>
<div class="line"> fix_pressure(0,0,0.0);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set up equation numbering scheme</span></div>
<div class="line"> cout &lt;&lt; <span class="stringliteral">&quot;Number of equations: &quot;</span> &lt;&lt; assign_eqn_numbers() &lt;&lt; std::endl; </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// End of constructor</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="set_initial_condition"></a>
Initial conditions</h1>
<p>The function <code>set_initial_condition()</code> sets the initial conditions for the problem by looping over all the nodes in the mesh and setting all velocity components to zero. No initial conditions are required for the pressure. We then call the function <code>Problem::assign_initial_values_impulsive()</code> which copies the current values at each of the nodes into the required number of history values for the timestepper in question. This corresponds to an impulsive start, as for all time <img class="formulaInl" alt="$ t \leq 0 $" src="form_75.png" width="29" height="11"/> the fluid is at rest. At the first timestep, the solid domain boundaries are immediately moving with a speed corresponding to their radial distance from the symmetry boundary. <code>Problem::set_initial_condition()</code> is called after each mesh adaptation on the first timestep only. This means that any newly-created nodes obtain their values from the actual (analytical) initial conditions rather than from interpolation of the values of previously-existing nodes.</p>
<div class="fragment"><div class="line"><span class="comment">//==start_of_set_initial_condition========================================</span></div>
<div class="line"><span class="comment">/// Set initial conditions: Set all nodal velocities to zero and</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// initialise the previous velocities to correspond to an impulsive start</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ELEMENT, <span class="keyword">class</span> TIMESTEPPER&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classRotatingCylinderProblem.html#a5e4316cce2306c4aab4a20b88cdfe6e3">RotatingCylinderProblem&lt;ELEMENT,TIMESTEPPER&gt;::set_initial_condition</a>()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Determine number of nodes in mesh</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_node = mesh_pt()-&gt;nnode();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over all nodes in mesh</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> n=0;n&lt;n_node;n++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Loop over the three velocity components</span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;3;i++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Set velocity component i of node n to zero</span></div>
<div class="line">     mesh_pt()-&gt;node_pt(n)-&gt;set_value(i,0.0);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Initialise the previous velocity values for timestepping</span></div>
<div class="line"> <span class="comment">// corresponding to an impulsive start</span></div>
<div class="line"> assign_initial_values_impulsive();</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// End of set_initial_condition</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="set_boundary_conditions"></a>
Boundary conditions</h1>
<p>The function <code>set_boundary_conditions()</code> sets the boundary conditions for the problem. On the three solid boundaries ( <img class="formulaInl" alt="$ r = 1.0 $" src="form_76.png" width="40" height="9"/>, <img class="formulaInl" alt="$ z = 0.0 $" src="form_77.png" width="39" height="9"/> and <img class="formulaInl" alt="$ z = 1.4 $" src="form_78.png" width="39" height="9"/>) we set the radial and axial velocities to zero so that there is no penetration of the wall by the fluid or flow along it. To simulate the domain rotating around the axis <img class="formulaInl" alt="$ r = 0 $" src="form_79.png" width="30" height="9"/> we set the azimuthal velocity at each node along these boundaries to be equal to the radial position of the node. On the symmetry boundary ( <img class="formulaInl" alt="$ r = 0 $" src="form_79.png" width="30" height="9"/>) we set the radial and azimuthal velocities to zero but leave the axial component unconstrained. As discussed <a href="#equations">above</a>, not applying a velocity boundary condition causes the flow to satisfy the "traction
free" natural boundary condition; in this case, <img class="formulaInl" alt="$ t_z = 0 $" src="form_80.png" width="34" height="11"/>. This corresponds to the symmetry condition <img class="formulaInl" alt="$ \partial u_z /\partial r = 0 $" src="form_70.png" width="63" height="14"/>.</p>
<div class="fragment"><div class="line"><span class="comment">//==start_of_set_boundary_conditions======================================</span></div>
<div class="line"><span class="comment">/// Set boundary conditions: Set both velocity components to zero</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// on the bottom (solid) wall and the horizontal component only to zero</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// on the side (periodic) boundaries</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ELEMENT, <span class="keyword">class</span> TIMESTEPPER&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classRotatingCylinderProblem.html#a37efdb2d7059535a48b12f69869996ee">RotatingCylinderProblem&lt;ELEMENT,TIMESTEPPER&gt;::set_boundary_conditions</a>()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Determine number of mesh boundaries</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_boundary = mesh_pt()-&gt;nboundary();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over mesh boundaries</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> b=0;b&lt;n_boundary;b++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Determine number of nodes on boundary b</span></div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_node = mesh_pt()-&gt;nboundary_node(b);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Loop over nodes on boundary b</span></div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> n=0;n&lt;n_node;n++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// For the solid boundaries (boundaries 0,1,2)</span></div>
<div class="line">     <span class="keywordflow">if</span>(b&lt;3)</div>
<div class="line">      {</div>
<div class="line">       <span class="comment">// Get the radial component of position</span></div>
<div class="line">       <span class="keyword">const</span> <span class="keywordtype">double</span> r_pos = mesh_pt()-&gt;boundary_node_pt(b,n)-&gt;x(0);</div>
<div class="line">           </div>
<div class="line">       <span class="comment">// Set all velocity components to no flow along boundary</span></div>
<div class="line">       mesh_pt()-&gt;boundary_node_pt(b,n)-&gt;set_value(0,0,0.0); <span class="comment">// Radial</span></div>
<div class="line">       mesh_pt()-&gt;boundary_node_pt(b,n)-&gt;set_value(0,1,0.0); <span class="comment">// Axial</span></div>
<div class="line">       mesh_pt()-&gt;boundary_node_pt(b,n)-&gt;set_value(0,2,r_pos); <span class="comment">// Azimuthal</span></div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// For the symmetry boundary (boundary 3)</span></div>
<div class="line">     <span class="keywordflow">if</span>(b==3)</div>
<div class="line">      {</div>
<div class="line">       <span class="comment">// Set only the radial (i=0) and azimuthal (i=2) velocity components</span></div>
<div class="line">       <span class="comment">// to no flow along boundary (axial component is unconstrained)</span></div>
<div class="line">       mesh_pt()-&gt;boundary_node_pt(b,n)-&gt;set_value(0,0,0.0);</div>
<div class="line">       mesh_pt()-&gt;boundary_node_pt(b,n)-&gt;set_value(0,2,0.0);</div>
<div class="line">      }</div>
<div class="line">    } <span class="comment">// End of loop over nodes on boundary b</span></div>
<div class="line">  } <span class="comment">// End of loop over mesh boundaries</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// End of set_boundary_conditions</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="doc"></a>
Post-processing</h1>
<p>As expected, this member function documents the computed solution. We first print the value of the current time to the screen, before outputting the computed solution.</p>
<div class="fragment"><div class="line"><span class="comment">//==start_of_doc_solution=================================================</span></div>
<div class="line"><span class="comment">/// Document the solution</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ELEMENT, <span class="keyword">class</span> TIMESTEPPER&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classRotatingCylinderProblem.html#a22f82fba41d68b9748642f9a29a12592">RotatingCylinderProblem&lt;ELEMENT,TIMESTEPPER&gt;::</a></div>
<div class="line"><a class="code" href="classRotatingCylinderProblem.html#a22f82fba41d68b9748642f9a29a12592">doc_solution</a>(DocInfo&amp; doc_info)</div>
<div class="line">{ </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output the time</span></div>
<div class="line"> cout &lt;&lt; <span class="stringliteral">&quot;Time is now &quot;</span> &lt;&lt; time_pt()-&gt;time() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> ofstream some_file;</div>
<div class="line"> <span class="keywordtype">char</span> filename[100];</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set number of plot points (in each coordinate direction)</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> npts = 5;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Open solution output file</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/soln%i.dat&quot;</span>,</div>
<div class="line">         doc_info.directory().c_str(),doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output solution to file</span></div>
<div class="line"> mesh_pt()-&gt;output(some_file,npts);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Close solution output file</span></div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// End of doc_solution</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="timestepping"></a>
The timestepping loop</h1>
<p>The function <code>unsteady_run(...)</code> is used to perform the timestepping procedure. We start by creating a <code>DocInfo</code> object to store the output directory and the label for the output files.</p>
<p>Before using any of <code>oomph-lib's</code> timestepping functions, the timestep <img class="formulaInl" alt="$ dt $" src="form_81.png" width="11" height="10"/> must be passed to the problem's timestepping routines by calling the function <code>Problem::initialise_dt(...)</code> which sets the weights for all timesteppers in the problem. Next we assign the initial conditions by calling <code>Problem::set_initial_condition()</code>, which was discussed <a href="#set_initial_condition">above</a>.</p>
<div class="fragment"><div class="line"> <span class="comment">// Initialise timestep</span></div>
<div class="line"> initialise_dt(dt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set initial condition</span></div>
<div class="line"> set_initial_condition();</div>
</div><!-- fragment --><p> We define the maximum number of spatial adaptations which are permitted per timestep, and refine the mesh uniformly twice.</p>
<div class="fragment"><div class="line"> <span class="comment">// Maximum number of spatial adaptations per timestep</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> max_adapt = 4;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Call refine_uniformly twice</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;2;i++) { refine_uniformly(); }</div>
</div><!-- fragment --><p> We determine the number of timesteps to be performed and document the initial conditions. A flag, <code>first_timestep</code>, is initialised and set to true. This flag will be passed to <code>Problem::unsteady_newton_solve(...)</code>, and when set to true instructs the code to re-assign the initial conditions after every mesh adaptation.</p>
<div class="fragment"><div class="line"> <span class="comment">// Determine number of timesteps</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_timestep = unsigned(t_max/dt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Doc initial solution</span></div>
<div class="line"> doc_solution(doc_info);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Increment counter for solutions </span></div>
<div class="line"> doc_info.number()++;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Are we on the first timestep? At this point, yes!</span></div>
<div class="line"> <span class="keywordtype">bool</span> first_timestep = <span class="keyword">true</span>;</div>
</div><!-- fragment --><p> A key feature of this problem is the fact that the flow field approaches a "trivial" solution (rigid body rotation) which can be fully-resolved by the discretisation. In that case, equidistribution of the error (normalised by the norm of the global error which tends to zero!) leads to strong uniform mesh refinement despite the fact that the solution is fully converged. To avoid this, we prescribe a constant reference flux to normalise the error. For more details, see the discussion in the <a href="../../../the_data_structure/html/classoomph_1_1Z2ErrorEstimator.html"><code>Z2ErrorEstimator</code> class reference</a>.</p>
<div class="fragment"><div class="line"> <span class="comment">// Specify normalising factor explicitly</span></div>
<div class="line"> Z2ErrorEstimator* error_pt = <span class="keyword">dynamic_cast&lt;</span>Z2ErrorEstimator*<span class="keyword">&gt;</span></div>
<div class="line">  (mesh_pt()-&gt;spatial_error_estimator_pt());</div>
<div class="line"> error_pt-&gt;reference_flux_norm() = 0.01;</div>
</div><!-- fragment --><p> Finally, we perform the actual timestepping loop. For each timestep the function <code>unsteady_newton_solve(dt)</code> is called and the solution documented.</p>
<div class="fragment"><div class="line"> <span class="comment">// Timestepping loop</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> t=1;t&lt;=n_timestep;t++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Output current timestep to screen</span></div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;\nTimestep &quot;</span> &lt;&lt; t &lt;&lt; <span class="stringliteral">&quot; of &quot;</span> &lt;&lt; n_timestep &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Take fixed timestep with spatial adaptivity</span></div>
<div class="line">   unsteady_newton_solve(dt,max_adapt,first_timestep);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// No longer on first timestep, so set first_timestep flag to false</span></div>
<div class="line">   first_timestep = <span class="keyword">false</span>; </div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Reset maximum number of adaptations for all future timesteps</span></div>
<div class="line">   max_adapt = 1;</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Doc solution</span></div>
<div class="line">   doc_solution(doc_info);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Increment counter for solutions </span></div>
<div class="line">   doc_info.number()++;</div>
<div class="line">   </div>
<div class="line">  } <span class="comment">// End of timestepping loop</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// End of unsteady_run</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="comments"></a>
Comments and Exercises</h1>
<h2><a class="anchor" id="good_practice_bcs"></a>
Good practice: Assigning boundary conditions</h2>
<p>In our driver code we reset the boundary conditions for the problem before each Newton solve. This is done to ensure that any new boundary nodes created during mesh refinement are explicitly given the correct boundary conditions. However, the function that actually creates the new nodes, <code>RefineableQElement&lt;2&gt;::build(...)</code>, automatically assigns new nodes with values by interpolating within the father element. Since in our case the boundary conditions are linear, there is in fact no need to reset them at any point during the simulation, as the new boundary nodes were already given precisely the correct values by interpolation. Resetting the boundary conditions is only strictly necessary, therefore, in cases where:</p>
<ol type="1">
<li>The boundary conditions are given by a function which is of higher order than the shape functions used by the finite element, or</li>
<li>The boundary conditions are time-dependent.</li>
</ol>
<h2><a class="anchor" id="good_practice_ics"></a>
Good practice: Assigning initial conditions</h2>
<p>Similarly, we repeatedly call the <code>set_initial_condition()</code> function after each mesh adaptation during the first timestep. This is done to ensure that the exact initial conditions are given to newly created nodes during mesh refinement. Again, this is not strictly necessary in our case since <code>RefineableQElement&lt;2&gt;::build(...)</code> provides newly-created nodes with history values which are computed by interpolation of the history values stored at the nodes of the father element. Our initial conditions are constant and can therefore be represented exactly by this procedure. Should the initial conditions be given by an analytical function of higher order than the shape functions used by the finite elements, however, it would indeed be necessary to explicitly provide newly-created nodes with the exact initial conditions during the first timestep. For a more in-depth discussion, see <a href="../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html#spatial_adapt">another tutorial</a>.</p>
<center> <b>A slight subtlety</b> </center><p>Omitting the re-assignment of the initial conditions on the adapted mesh when performing the first timestep does have a subtle effect that we encourage you to explore in the exercises below. You will observe that the solution obtained when re-assigning the initial conditions differs <b>very</b> slightly from that obtained when this step is suppressed. This obviously seems to contradict the statements made above and requires some explanation.</p>
<p>To understand why the behaviour is not unexpected (and perfectly acceptable!) let us analyse in more detail what really happens when we compute the first timestep in a spatially adaptive computation. When we perform the first Newton solve on the original mesh, the history values (which, for a BDF timestepper, represent the solution at previous timesteps) are identically equal to zero. The current values are also zero but this has no particular significance &ndash; they simply provide the initial guess for the solution at the advanced time level and their values are subsequently updated by the Newton solver.</p>
<p>Following the convergence of the Newton solver, the history values will therefore have retained their original values (zero) while the current values will have been updated to represent the "correct" solution of the nonlinear problem at the next timestep (on the current mesh). The accuracy of this solution is now assessed by the spatial error estimator. If the estimated error is deemed too large, the mesh is adapted and all quantities (history values <b>and</b> current values) are automatically transferred onto the new mesh by interpolation &ndash; exactly as discussed above. Interpolation of the (identically equal to zero) history values onto the new mesh assigns zero history values for all newly-created nodes &ndash; exactly what we (needlessly) do in our own implementation of <code>Problem::set_initial_conditions()</code>. The interpolation of the current values transfers what is our current "best guess" for the solution at the advanced time onto the new mesh. In principle, this provides a "better" initial guess for the solution at the advanced time level than the zero initial guess that we re-assign when we call <code>Problem::set_initial_conditions()</code> but (as long as the Newton iteration converges) this assignment is irrelevant. However, starting the Newton iteration from a different initial guess will almost certainly lead to a slightly different solution &ndash; a solution being defined as a(ny) set of current values for which the maximum residual in the <code>Problem's</code> residual vector is less than the required tolerance. Hence, even though omitting or performing the re-assignment of the initial conditions leads to two <b>slightly</b> different solutions, both solutions are equally acceptable (within the threshold that is implicit in our convergence criterion for the Newton iteration).</p>
<h2><a class="anchor" id="exercises"></a>
Exercises</h2>
<ol type="1">
<li>Remove the function <code>set_initial_condition()</code> entirely from the driver code (do not just leave it empty!), so that the initial conditions are not constantly reset during the first timestep. Confirm that the code still produces approximately (but not precisely) the same results, as discussed in the <a href="#good_practice_ics">previous section</a>.</li>
<li>Restore <code>set_initial_condition()</code> to its original state, but remove the call to <code>assign_initial_values_impulsive()</code>. Confirm that the code still produces precisely the same results. Why are exactly the same results produced this time?</li>
</ol>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory:<br  />
<br  />
<center> <a href="../../../../demo_drivers/axisym_navier_stokes/spin_up/">demo_drivers/axisym_navier_stokes/spin_up/ </a> </center><br  />
</li>
<li>The driver code is: <br  />
<br  />
<center> <a href="../../../../demo_drivers/axisym_navier_stokes/spin_up/spin_up.cc">demo_drivers/axisym_navier_stokes/spin_up/spin_up.cc </a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:23:29
        </div>
      </div>
    </footer>
</body>
</html>
