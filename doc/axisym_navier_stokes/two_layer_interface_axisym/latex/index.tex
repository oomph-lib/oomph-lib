In an \href{../../../navier_stokes/two_layer_interface/html/index.html}{\texttt{ earlier example}} we considered a free surface Navier--Stokes problem in which the interface between two viscous fluids was deformed to a prescribed shape and then allowed to relax. This example considers a similar problem in which the two fluids occupy a cylindrical domain which is orientated such that its axis of symmetry is normal to the equilibrium position of the interface. The problem is assumed to be axisymmetric and so the computational domain is rectangular as before, with the difference here that the governing equations are the axisymmetric Navier--Stokes equations as opposed to the two-\/dimensional Cartesian Navier--Stokes equations employed by the \href{../../../navier_stokes/two_layer_interface/html/index.html}{\texttt{ other example}}. These equations are discussed in detail in \href{../../../axisym_navier_stokes/spin_up/html/index.html}{\texttt{ another tutorial}}. Otherwise, the same overall strategy is employed. Since the implementation of the Navier--Stokes elements in {\ttfamily oomph-\/lib} is based on the Arbitrary Lagrangian Eulerian form of the equations, we can discretise the computational domain using a boundary-\/fitted mesh which deforms in response to the change in position of the interface. The positions of the nodes in the `bulk' of the mesh are determined by treating the interior of the mesh as a fictitious elastic solid and solving a solid mechanics problem, a technique which we refer to as a `pseudo-\/solid node update strategy'. The deformation of the free surface boundary itself is imposed by solving the kinematic boundary condition for a field of Lagrange multipliers at the interface, and this condition is discretised by attaching {\ttfamily Face\+Elements} to those `bulk' elements in the `lower' of the two fluids which have boundaries adjacent to the interface.\hypertarget{index_interface_def}{}\doxysection{Choosing an appropriate interface deformation}\label{index_interface_def}
The \href{../../../navier_stokes/two_layer_interface/html/index.html}{\texttt{ two-\/dimensional problem}} was started impulsively from a set of initial conditions such that the fluid was at rest and the interface was prescribed to be a cosine curve. Since this was an eigenmode of the system, the shape of the interface remained `in mode' throughout the simulation. Choosing a single eigenmode as an initial condition allowed the results of the simulation to be compared with an analytical solution, and as we wish to do the same thing here we choose a zeroth-\/order Bessel function of the first kind, $ J_0(kr) $, where $ k $ is a wavenumber and $ r $ is the radial spatial coordinate. This function has the property that its derivative with respect to $ r $ evaluated at $ r=0 $ is zero, which must be the case if the interface is to be smooth at the symmetry boundary (the central axis of the cylinder).

A further consideration is that we want the equilibrium state of the system to be such that the interface is a flat line at $ z=0 $, where $ z $ is the axial coordinate. This state can only be reached if we choose an initial deformation $ z=h(r) $ which is volume conserving, and we therefore require \[ \int_{r=0}^{r=a} h(r) r dr = 0 \] to be satisfied, where $ a $ is the radius of the cylindrical container (or the width of the computational domain). Since in our case $ h(r) = J_0(kr) $, and we will choose a computational domain of width $ a=1 $, our initial condition must therefore satisfy \[ \int_0^1 r \, J_0(kr) \, dr = 0. \] Using the properties of Bessel functions we find that this condition is met if $ J_1(k) = 0 $, and hence the values of $ k $ are constrained to be zeroes of $ J_1(k) $.

Furthermore, the properties of Bessel functions are such that the derivative of $ J_0(kr) $ with respect to $ r $, evaluated at any point along the $ r $-\/axis which corresponds to a zero of $ J_1(kr) $, is itself zero. The velocity boundary condition in the axial direction is therefore the traction-\/free condition $ \partial u_z / \partial r = 0 $. This could be physically realised by having a `slippery' outer wall where the contact line can move but the contact angle is fixed at $ 90^o $, and is in fact an identical condition to the symmetry boundary condition prescribed at the axis of symmetry ( $ r=0 $).

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_example_problem}{}\doxysection{The example problem}\label{index_example_problem}
We will illustrate the solution of the unsteady axisymmetric Navier--Stokes equations using the example of a distorted interface between two viscous fluids which is allowed to relax. The domain is symmetric about the line $ r=0 $, which corresponds to the axis of the cylindrical container.

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries{ The unsteady axisymmetric Navier--Stokes equations either side of a distorted interface.}} \end{center}  Solve \[ Re \left[ St \frac{\partial u_r}{\partial t} + u_r \frac{\partial u_r}{\partial r} - \frac{u_\theta^2}{r} + u_z \frac{\partial u_r}{\partial z} \right] = -\frac{\partial p}{\partial r} + \frac{Re}{Fr} G_r + \left[ \frac{\partial^2 u_r}{\partial r^2} + \frac{1}{r}\frac{\partial u_r}{\partial r} - \frac{u_r}{r^2} + \frac{\partial^2 u_r}{\partial z^2} \right], \] \[ Re \left[ St \frac{\partial u_\theta}{\partial t} + u_r \frac{\partial u_\theta}{\partial r} + \frac{u_r u_\theta}{r} + u_z \frac{\partial u_\theta}{\partial z} \right] = \frac{Re}{Fr} G_\theta + \left[ \frac{\partial^2 u_\theta}{\partial r^2} + \frac{1}{r}\frac{\partial u_\theta}{\partial r} - \frac{u_\theta}{r^2} + \frac{\partial^2 u_\theta}{\partial z^2} \right], \] \[ Re \left[ St \frac{\partial u_z}{\partial t} + u_r \frac{\partial u_z}{\partial r} + u_z \frac{\partial u_z}{\partial z} \right] = -\frac{\partial p}{\partial z} + \frac{Re}{Fr} G_z + \left[ \frac{\partial^2 u_z}{\partial r^2} + \frac{1}{r}\frac{\partial u_z}{\partial r} + \frac{\partial^2 u_z}{\partial z^2} \right], \] and \[ \frac{\partial u_r}{\partial r} + \frac{u_r}{r} + \frac{\partial u_z}{\partial z} = 0 \ \ \ \ \ \ \ \ \ \ (1) \] in the `lower' fluid, and \[ R_\rho Re \left[ St \frac{\partial u_r}{\partial t} + u_r \frac{\partial u_r}{\partial r} - \frac{u_\theta^2}{r} + u_z \frac{\partial u_r}{\partial z} \right] = -\frac{\partial p}{\partial r} + R_\rho \frac{Re}{Fr} G_r + R_\mu \left[ \frac{\partial^2 u_r}{\partial r^2} + \frac{1}{r}\frac{\partial u_r}{\partial r} - \frac{u_r}{r^2} + \frac{\partial^2 u_r}{\partial z^2} \right], \] \[ R_\rho Re \left[ St \frac{\partial u_\theta}{\partial t} + u_r \frac{\partial u_\theta}{\partial r} + \frac{u_r u_\theta}{r} + u_z \frac{\partial u_\theta}{\partial z} \right] = R_\rho \frac{Re}{Fr} G_\theta + R_\mu \left[ \frac{\partial^2 u_\theta}{\partial r^2} + \frac{1}{r}\frac{\partial u_\theta}{\partial r} - \frac{u_\theta}{r^2} + \frac{\partial^2 u_\theta}{\partial z^2} \right], \] \[ R_\rho Re \left[ St \frac{\partial u_z}{\partial t} + u_r \frac{\partial u_z}{\partial r} + u_z \frac{\partial u_z}{\partial z} \right] = -\frac{\partial p}{\partial z} + R_\rho \frac{Re}{Fr} G_z + R_\mu \left[ \frac{\partial^2 u_z}{\partial r^2} + \frac{1}{r}\frac{\partial u_z}{\partial r} + \frac{\partial^2 u_z}{\partial z^2} \right], \] and \[ \frac{\partial u_r}{\partial r} + \frac{u_r}{r} + \frac{\partial u_z}{\partial z} = 0 \ \ \ \ \ \ \ \ \ \ (2) \] in the `upper' fluid. Gravity acts in the negative $ z $ direction and so $ G_r = G_\theta = 0 $ and $ G_z = 1 $. The governing equations are subject to the no slip boundary conditions \[ u_r = u_\theta = u_z = 0 \ \ \ \ \ \ \ \ \ \ (3) \] on the top ( $ z = 2.0 $) and bottom ( $ z = 0.0 $) solid boundaries and the symmetry boundary conditions \[ u_r = u_\theta = 0 \ \ \ \ \ \ \ \ \ \ (4) \] on the left ( $ r = 0.0 $) and right ( $ r = 1.0 $) boundaries.

We denote the position vector to the interface between the two fluids by $ \mathbf{R} $, which is subject to the kinematic condition \[ \left(u_i - St\, \frac{\partial R_i}{\partial t}\right) n_i = 0, \ \ \ \ \ \ \ \ \ \ (5) \] and the dynamic condition \[ \tau_{ij}^{[2]}n_j = \tau_{ij}^{[1]}n_j+\frac{1}{Ca}\kappa n_i. \ \ \ \ \ \ \ \ \ \ (6) \]   \\\cline{1-1}
\end{longtabu}
~\newline
 \end{center} 

\begin{center} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{1}{|X[-1]}|}
\hline
The non-\/dimensional, symmetric stress tensor in the `lower' fluid is defined as \[ \tau_{rr} = -p + 2\frac{\partial u_r}{\partial r}, \qquad \tau_{\theta\theta} = -p + 2\frac{u_r}{r}, \ \ \ \ \ \ \ \ \ \ \] \[ \tau_{zz} = -p + 2\frac{\partial u_z}{\partial z}, \qquad \tau_{rz} = \frac{\partial u_r}{\partial z} + \frac{\partial u_z}{\partial r}, \ \ \ \ \ \ \ \ \ \ (7) \] \[ \tau_{\theta r} = r \frac{\partial}{\partial r}\left(\frac{u_{\theta}}{r}\right), \qquad \tau_{\theta z} = \frac{\partial u_{\theta}}{\partial z}, \ \ \ \ \ \ \ \ \ \ \] and that in the `upper' fluid is defined as \[ \tau_{rr} = -p + 2R_\mu \frac{\partial u_r}{\partial r}, \qquad \tau_{\theta\theta} = -p + 2R_\mu \frac{u_r}{r}, \ \ \ \ \ \ \ \ \ \ \] \[ \tau_{zz} = -p + 2R_\mu \frac{\partial u_z}{\partial z}, \qquad \tau_{rz} = R_\mu \left(\frac{\partial u_r}{\partial z} + \frac{\partial u_z}{\partial r}\right), \ \ \ \ \ \ \ \ \ \ (8) \] \[ \tau_{\theta r} = R_\mu r \frac{\partial}{\partial r}\left(\frac{u_{\theta}}{r}\right), \qquad \tau_{\theta z} = R_\mu \frac{\partial u_{\theta}}{\partial z}. \ \ \ \ \ \ \ \ \ \ \]

The initial shape of the interface is defined by \[ \mathbf{R} = r \, \mathbf{e}_r + \left[ 1.0 + \epsilon J_0(kr) \right] \, \mathbf{e}_z, \ \ \ \ \ \ \ \ \ \ (9) \] where $ \epsilon $ is the amplitude of the initial deflection, $ k $ is a wavenumber and $ J_0(kr) $ is a zeroth-\/order Bessel function of the first kind.   \\\cline{1-1}
\end{longtabu}
~\newline
 \end{center} 

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_results}{}\doxysection{Results}\label{index_results}
The figure below shows a contour plot of the pressure distribution taken from \href{../figures/two_layer_interface_axisym.avi}{\texttt{ an animation of the flow field}}, for the parameters $ Re = Re \, St = Re/Fr = 5.0 $, $ R_\rho = 0.5 $, $ R_\mu = 0.1 $ and $ Ca = 0.01 $.

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{two_layer_interface_axisym}
\doxyfigcaption{Pressure contour plot for the axisymmetric relaxing interface problem. }
\end{DoxyImage}


The restoring forces of surface tension and gravitational acceleration act to revert the interface to its undeformed flat state. The interface oscillates up and down, but the motion is damped as the energy in the system is dissipated through viscous forces. Eventually the interface settles down to its equilibrium position, as can be seen in the following time-\/trace of the height of the interface at the left-\/hand edge of the domain ( $ r=0 $).

 
\begin{DoxyImage}
\includegraphics[width=0.95\textwidth]{two_layer_interface_axisym_trace}
\doxyfigcaption{Time-\/trace of the height of the interface at the symmetry axis (r=0). }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_validation}{}\doxysection{Validation}\label{index_validation}
The free surface boundary conditions for the axisymmetric Navier--Stokes equations have been validated against an analytical test case, and we present the results in the figure below. For sufficiently small amplitudes, $ \epsilon \ll 1 $, we can linearise the governing equations and obtain a dispersion relation $ \lambda(k) $. In the \href{../../../navier_stokes/single_layer_free_surface/html/index.html\#validation}{\texttt{ two-\/dimensional single-\/layer example}} we discussed the derivation of such a dispersion relation, and the technique used for this problem is very similar. The major difference is that the proposed separable solution for the linearised equations is of the form \[ \hat{h}(r,t) = H e^{\lambda t} J_0(kr), \] \[ \hat{u}_r(r,z,t) = U_r(z) e^{\lambda t} J_1(kr), \] \[ \hat{u}_z(r,z,t) = U_z(z) e^{\lambda t} J_0(kr), \] and \[ \hat{p}(r,z,t) = P(z) e^{\lambda t} J_0(kr). \] As in the \href{../../../navier_stokes/two_layer_interface/html/index.html\#validation}{\texttt{ two-\/dimensional two-\/layer example}}, we will have a linear system containing nine unknowns, rather than the five unknowns that arise from a single-\/fluid problem. The real and imaginary parts of $ \lambda $ correspond to the growth rate and the frequency of the oscillating interface respectively, and can be compared to numerical results computed for given values of the wavenumber $ k $. We choose an initial deflection amplitude of $ \epsilon = 0.01 $ and determine the growth rate and frequency of the oscillation from a time-\/trace of the left-\/hand edge of the interface.

 
\begin{DoxyImage}
\includegraphics[width=0.95\textwidth]{two_layer_interface_axisym_code_validation}
\doxyfigcaption{Validation of the code (points) by comparison with an analytical dispersion relation (lines). }
\end{DoxyImage}


\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_namespace}{}\doxysection{Global parameters and functions}\label{index_namespace}
As in the \href{../../../navier_stokes/two_layer_interface/html/index.html\#namespace}{\texttt{ earlier example}}, we use a namespace to define the dimensionless parameters $ Re $, $ St $, $ Re/Fr $ and $ Ca $. Since we are solving for the unknown bulk nodal positions by treating the interior of the mesh as a fictitious elastic solid, we also need to define the Poisson ratio for this `pseudo-\/solid\textquotesingle{}s' generalised Hookean constitutive law, $ \nu $. As before, we define the density and viscosity ratios of the top fluid to the bottom fluid and a unit vector $ G $ which points in the direction of gravity. The only difference from \href{../../../navier_stokes/two_layer_interface/html/index.html\#namespace}{\texttt{ before}} is that in this case $ G $ must have three dimensions since this is an axisymmetric problem.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{/// Direction of gravity}}
\DoxyCodeLine{ Vector<double> \mbox{\hyperlink{namespaceGlobal__Physical__Variables_af5ae275cf339105b9a54821c034df470}{G}}(3);}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_main}{}\doxysection{The driver code}\label{index_main}
The first section of the driver code is identical to that of the \href{../../../navier_stokes/two_layer_interface/html/index.html\#main}{\texttt{ earlier example}}. We define a command line flag which allows us to run a `validation' version of the code (for {\ttfamily oomph-\/lib\textquotesingle{}s} self-\/testing routines) and check that the non-\/dimensional quantities provided in the {\ttfamily \mbox{\hyperlink{namespaceGlobal__Physical__Variables}{Global\+\_\+\+Physical\+\_\+\+Variables}}} namespace are self-\/consistent. Next we specify the duration of the simulation and the size of the timestep. If we are running the code as a validation, we set the length of the simulation such that only two timesteps are taken. The direction in which gravity acts is defined to be vertically downwards.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Set direction of gravity (vertically downwards)}}
\DoxyCodeLine{ \mbox{\hyperlink{namespaceGlobal__Physical__Variables_af5ae275cf339105b9a54821c034df470}{Global\_Physical\_Variables::G}}[0] = 0.0;}
\DoxyCodeLine{ \mbox{\hyperlink{namespaceGlobal__Physical__Variables_af5ae275cf339105b9a54821c034df470}{Global\_Physical\_Variables::G}}[1] = -\/1.0;}
\DoxyCodeLine{ \mbox{\hyperlink{namespaceGlobal__Physical__Variables_af5ae275cf339105b9a54821c034df470}{Global\_Physical\_Variables::G}}[2] = 0.0;}

\end{DoxyCodeInclude}
 Finally, we build the problem using the `pseudo-\/solid' version of {\ttfamily Refineable\+Axisymmetric\+QCrouzeix\+Raviart\+Elements} and the {\ttfamily BDF$<$2$>$} timestepper, before calling {\ttfamily unsteady\+\_\+run(...)}. This function solves the system at each timestep using the {\ttfamily Problem\+::unsteady\+\_\+newton\+\_\+solve(...)} function before documenting the result.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Set up the elastic test problem with AxisymmetricQCrouzeixRaviartElements,}}
\DoxyCodeLine{ \textcolor{comment}{// using the BDF<2> timestepper}}
\DoxyCodeLine{ \mbox{\hyperlink{classInterfaceProblem}{InterfaceProblem}}<RefineablePseudoSolidNodeUpdateElement<}
\DoxyCodeLine{ RefineableAxisymmetricQCrouzeixRaviartElement,}
\DoxyCodeLine{  RefineableQPVDElement<2,3> >,BDF<2> > problem;}
\DoxyCodeLine{   }
\DoxyCodeLine{ \textcolor{comment}{// Run the unsteady simulation}}
\DoxyCodeLine{ problem.\mbox{\hyperlink{classInterfaceProblem_adf1f4e43d10939e4323e0e315b711085}{unsteady\_run}}(t\_max,dt);}
\DoxyCodeLine{}
\DoxyCodeLine{\} \textcolor{comment}{// End of main}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_mesh}{}\doxysection{The mesh class}\label{index_mesh}
The mesh class is almost identical to that in the \href{../../../navier_stokes/two_layer_interface/html/index.html\#mesh}{\texttt{ two-\/dimensional problem}}. The only difference is that, given that this (specific) mesh is to be used in an axisymmetric problem, it does not make sense to allow the mesh to be periodic in the horizontal direction.\hypertarget{index_problem_class}{}\doxysection{The problem class}\label{index_problem_class}
The problem class is almost identical to the \href{../../../navier_stokes/two_layer_interface/html/index.html\#problem_class}{\texttt{ two-\/dimensional problem}}. The only modification arises in the arguments of {\ttfamily deform\+\_\+free\+\_\+surface(...)}, as the initial shape of the interface is a Bessel function $ J_0(kr) $ as opposed to a cosine curve.

 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{/// Deform the mesh/free surface to a prescribed function}}
\DoxyCodeLine{ \textcolor{keywordtype}{void} deform\_free\_surface(\textcolor{keyword}{const} \textcolor{keywordtype}{double} \&epsilon, \textcolor{keyword}{const} \textcolor{keywordtype}{double} \&k);}

\end{DoxyCodeInclude}
 \hypertarget{index_constructor}{}\doxysection{The problem constructor}\label{index_constructor}
The constructor starts by building the timestepper and setting the dimensions of the mesh. The number of elements in the $ r $ and $ z $ directions in both fluid layers are specified. The next section of the constructor is exactly as \href{../../../navier_stokes/two_layer_interface/html/index.html\#constructor}{\texttt{ before}}. We build the bulk mesh, create an error estimator and set the maximum refinement level. An empty surface mesh is created and populated with a call to {\ttfamily create\+\_\+interface\+\_\+elements}, before the two meshes are combined to form the global mesh. Next we define the boundary conditions. On the top and bottom boundaries ( $ z = 2.0 $ and $ z = 0.0 $) we apply the no-\/slip condition by pinning all three velocity components. On the outer (solid) wall ( $ r = 1.0 $) we pin the radial (no penetration) and azimuthal (no slip) components but not the axial component. This simulates the \char`\"{}slippery\char`\"{} outer wall. These conditions are also applied at the symmetry boundary ( $ r = 0.0 $). The vertical position of the nodes on the top and bottom boundaries are also pinned.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Set the boundary conditions for this problem}}
\DoxyCodeLine{ \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// All nodes are free by default -\/-\/ just pin the ones that have}}
\DoxyCodeLine{ \textcolor{comment}{// Dirichlet conditions here}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Determine number of mesh boundaries}}
\DoxyCodeLine{ \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_boundary = Bulk\_mesh\_pt-\/>nboundary();}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Loop over mesh boundaries}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} b=0;b<n\_boundary;b++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Determine number of nodes on boundary b}}
\DoxyCodeLine{   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt-\/>nboundary\_node(b);}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Loop over nodes on boundary b}}
\DoxyCodeLine{   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{comment}{// Fluid boundary conditions:}}
\DoxyCodeLine{     \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Pin radial and azimuthal velocities (no slip/penetration)}}
\DoxyCodeLine{     \textcolor{comment}{// on all boundaries other than the interface (b=4)}}
\DoxyCodeLine{     \textcolor{keywordflow}{if}(b!=4)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       Bulk\_mesh\_pt-\/>boundary\_node\_pt(b,n)-\/>pin(0);}
\DoxyCodeLine{       Bulk\_mesh\_pt-\/>boundary\_node\_pt(b,n)-\/>pin(2);}
\DoxyCodeLine{      \}}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Pin axial velocity on top (b=2) and bottom (b=0) boundaries}}
\DoxyCodeLine{     \textcolor{comment}{// (no penetration). Because we have a slippery outer wall we do}}
\DoxyCodeLine{     \textcolor{comment}{// NOT pin the axial velocity on this boundary (b=1); similarly,}}
\DoxyCodeLine{     \textcolor{comment}{// we do not pin the axial velocity on the symmetry boundary (b=3).}}
\DoxyCodeLine{     \textcolor{keywordflow}{if}(b==0 || b==2) \{ Bulk\_mesh\_pt-\/>boundary\_node\_pt(b,n)-\/>pin(1); \}}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Solid boundary conditions:}}
\DoxyCodeLine{     \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Pin vertical displacement on solid boundaries}}
\DoxyCodeLine{     \textcolor{keywordflow}{if}(b==0 || b==2) \{ Bulk\_mesh\_pt-\/>boundary\_node\_pt(b,n)-\/>pin\_position(1); \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \} \textcolor{comment}{// End of loop over nodes on boundary b}}
\DoxyCodeLine{  \} \textcolor{comment}{// End of loop over mesh boundaries}}

\end{DoxyCodeInclude}
 We pin the horizontal position of all nodes in the mesh as well as the azimuthal velocity components throughout the bulk of the domain (since in an axisymmetric problem these should remain zero always).


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Loop over all nodes in mesh}}
\DoxyCodeLine{ \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt-\/>nnode();}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Pin horizontal displacement of all nodes}}
\DoxyCodeLine{   Bulk\_mesh\_pt-\/>node\_pt(n)-\/>pin\_position(0);}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{comment}{// Pin all azimuthal velocities throughout the bulk of the domain}}
\DoxyCodeLine{   Bulk\_mesh\_pt-\/>node\_pt(n)-\/>pin(2);}
\DoxyCodeLine{  \}}

\end{DoxyCodeInclude}
 The remainder of the problem constructor is identical to that of the \href{../../../navier_stokes/two_layer_interface/html/index.html\#constructor}{\texttt{ two-\/dimensional problem}}. We create a generalised Hookean constitutive equation for the pseudo-\/solid mesh before looping over all elements in the bulk mesh and assigning pointers to the Reynolds and Womersley numbers, $ Re $ and $ Re\, St $, the product of the Reynolds number and the inverse of the Froude number, $ Re/Fr $, the direction of gravity, $ G $, the constitutive law and the global time object. For those elements which correspond to the upper fluid layer, we also assign pointers for the viscosity and density ratios, $ R_\mu $ and $ R_\rho $. We pin one degree of freedom and call the function which assigns the boundary conditions, before finally setting up the equation numbering scheme.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_set_initial_condition}{}\doxysection{Initial conditions}\label{index_set_initial_condition}
The {\ttfamily set\+\_\+initial\+\_\+conditions()} function is very similar to that in the \href{../../../navier_stokes/two_layer_interface/html/index.html\#set_initial_condition}{\texttt{ two-\/dimensional problem}}. We loop over all nodes in the mesh and set all three velocity components to zero, before calling {\ttfamily Problem\+::assign\+\_\+initial\+\_\+values\+\_\+impulsive()}. This function copies the current nodal values and positions into the required number of history values for the timestepper in question, simulating an impulsive start.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_set\_initial\_condition========================================}}
\DoxyCodeLine{\textcolor{comment}{/// Set initial conditions: Set all nodal velocities to zero and}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// initialise the previous velocities and nodal positions to correspond}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// to an impulsive start}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classInterfaceProblem_a0d3af8378c4f0a6e38636be958c300d5}{InterfaceProblem<ELEMENT,TIMESTEPPER>::set\_initial\_condition}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{// Determine number of nodes in mesh}}
\DoxyCodeLine{ \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt-\/>nnode();}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Loop over all nodes in mesh}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Loop over the three velocity components}}
\DoxyCodeLine{   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<3;i++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{comment}{// Set velocity component i of node n to zero}}
\DoxyCodeLine{     Bulk\_mesh\_pt-\/>node\_pt(n)-\/>set\_value(i,0.0);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Initialise the previous velocity values and nodal positions}}
\DoxyCodeLine{ \textcolor{comment}{// for timestepping corresponding to an impulsive start}}
\DoxyCodeLine{ assign\_initial\_values\_impulsive();}
\DoxyCodeLine{ }
\DoxyCodeLine{\} \textcolor{comment}{// End of set\_initial\_condition}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_set_boundary_conditions}{}\doxysection{Boundary conditions}\label{index_set_boundary_conditions}
The {\ttfamily set\+\_\+boundary\+\_\+conditions()} function is very similar to that in the \href{../../../navier_stokes/two_layer_interface/html/index.html\#set_boundary_conditions}{\texttt{ two-\/dimensional problem}}.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_set\_boundary\_conditions======================================}}
\DoxyCodeLine{\textcolor{comment}{/// Set boundary conditions: Set all velocity components to zero}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// on the top and bottom (solid) walls and the radial and azimuthal}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{/// components only to zero on the side boundaries}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classInterfaceProblem_a844445832ad7a32aa9f5d03ffdb40ebb}{InterfaceProblem<ELEMENT,TIMESTEPPER>::set\_boundary\_conditions}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{// Determine number of mesh boundaries}}
\DoxyCodeLine{ \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_boundary = Bulk\_mesh\_pt-\/>nboundary();}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Loop over mesh boundaries}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} b=0;b<n\_boundary;b++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Determine number of nodes on boundary b}}
\DoxyCodeLine{   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt-\/>nboundary\_node(b);}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Loop over nodes on boundary b}}
\DoxyCodeLine{   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{     \textcolor{comment}{// Set radial component of the velocity to zero on all boundaries}}
\DoxyCodeLine{     \textcolor{comment}{// other than the interface (b=4)}}
\DoxyCodeLine{     \textcolor{keywordflow}{if}(b!=4) \{ Bulk\_mesh\_pt-\/>boundary\_node\_pt(b,n)-\/>set\_value(0,0.0); \}}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Set azimuthal component of the velocity to zero on all boundaries}}
\DoxyCodeLine{     \textcolor{comment}{// other than the interface (b=4)}}
\DoxyCodeLine{     \textcolor{keywordflow}{if}(b!=4) \{ Bulk\_mesh\_pt-\/>boundary\_node\_pt(b,n)-\/>set\_value(2,0.0); \}}
\DoxyCodeLine{}
\DoxyCodeLine{     \textcolor{comment}{// Set axial component of the velocity to zero on solid boundaries}}
\DoxyCodeLine{     \textcolor{keywordflow}{if}(b==0 || b==2)}
\DoxyCodeLine{      \{}
\DoxyCodeLine{       Bulk\_mesh\_pt-\/>boundary\_node\_pt(b,n)-\/>set\_value(1,0.0);}
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\} \textcolor{comment}{// End of set\_boundary\_conditions}}

\end{DoxyCodeInclude}
 \hypertarget{index_before_after_adapt}{}\doxysection{Actions before and after adaptation}\label{index_before_after_adapt}
These functions follow exactly the same structure as those in the \href{../../../navier_stokes/two_layer_interface/html/index.html\#before_adapt}{\texttt{ two-\/dimensional problem}}.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_create_interface_elements}{}\doxysection{Create interface elements}\label{index_create_interface_elements}
This function is identical to that in the \href{../../../navier_stokes/two_layer_interface/html/index.html\#create_interface_elements}{\texttt{ two-\/dimensional problem}}, with the exception that instead of creating interface elements of the type


\begin{DoxyCode}{0}
\DoxyCodeLine{ElasticLineFluidInterfaceElement<ELEMENT>,}

\end{DoxyCode}


we are creating interface elements of the type


\begin{DoxyCode}{0}
\DoxyCodeLine{ElasticAxisymFluidInterfaceElement<ELEMENT>,}

\end{DoxyCode}


where {\ttfamily ELEMENT} is the templated bulk element type.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_delete_interface_elements}{}\doxysection{Delete interface elements}\label{index_delete_interface_elements}
This function is identical to that in the \href{../../../navier_stokes/two_layer_interface/html/index.html\#delete_interface_elements}{\texttt{ two-\/dimensional problem}}.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_deform_free_surface}{}\doxysection{Prescribing the initial free surface position}\label{index_deform_free_surface}
At the beginning of the simulation the interface is deformed by a prescribed function (9), implemented in the function {\ttfamily deform\+\_\+free\+\_\+surface(...)}, which cycles through the bulk mesh\textquotesingle{}s {\ttfamily Nodes} and modifies their positions such that the nodes on the free surface follow the prescribed interface shape and the bulk nodes retain their fractional position between the solid boundaries and the (now deformed) interface.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{//==start\_of\_deform\_free\_surface==========================================}}
\DoxyCodeLine{\textcolor{comment}{/// Deform the mesh/free surface to a prescribed function}}
\DoxyCodeLine{\textcolor{comment}{}\textcolor{comment}{//========================================================================}}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{classInterfaceProblem_aa93d492461ac53f0d9f88516bce322dc}{InterfaceProblem<ELEMENT,TIMESTEPPER>::}}}
\DoxyCodeLine{\mbox{\hyperlink{classInterfaceProblem_aa93d492461ac53f0d9f88516bce322dc}{deform\_free\_surface}}(\textcolor{keyword}{const} \textcolor{keywordtype}{double} \&epsilon,\textcolor{keyword}{const} \textcolor{keywordtype}{double} \&k)}
\DoxyCodeLine{\{}
\DoxyCodeLine{ \textcolor{comment}{// Initialise Bessel functions (only need the first!)}}
\DoxyCodeLine{ \textcolor{keywordtype}{double} j0, j1, y0, y1, j0p, j1p, y0p, y1p;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Determine number of nodes in the "{}bulk"{} mesh}}
\DoxyCodeLine{ \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt-\/>nnode();}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Loop over all nodes in mesh}}
\DoxyCodeLine{ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{   \textcolor{comment}{// Determine eulerian position of node}}
\DoxyCodeLine{   \textcolor{keyword}{const} \textcolor{keywordtype}{double} current\_r\_pos = Bulk\_mesh\_pt-\/>node\_pt(n)-\/>x(0);}
\DoxyCodeLine{   \textcolor{keyword}{const} \textcolor{keywordtype}{double} current\_z\_pos = Bulk\_mesh\_pt-\/>node\_pt(n)-\/>x(1);}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Compute Bessel functions}}
\DoxyCodeLine{   CRBond\_Bessel::bessjy01a(k*current\_r\_pos,j0,j1,y0,y1,j0p,j1p,y0p,y1p);}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Determine new vertical position of node}}
\DoxyCodeLine{   \textcolor{keyword}{const} \textcolor{keywordtype}{double} new\_z\_pos = current\_z\_pos}
\DoxyCodeLine{    + (1.0-\/fabs(1.0-\/current\_z\_pos))*epsilon*j0;}
\DoxyCodeLine{   }
\DoxyCodeLine{   \textcolor{comment}{// Set new position}}
\DoxyCodeLine{   Bulk\_mesh\_pt-\/>node\_pt(n)-\/>x(1) = new\_z\_pos;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\} \textcolor{comment}{// End of deform\_free\_surface}}

\end{DoxyCodeInclude}
 \DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_doc}{}\doxysection{Post-\/processing}\label{index_doc}
This function follows an identical structure to that in the \href{../../../navier_stokes/two_layer_interface/html/index.html\#doc}{\texttt{ two-\/dimensional problem}}.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_unsteady_run}{}\doxysection{The timestepping loop}\label{index_unsteady_run}
The function {\ttfamily unsteady\+\_\+run(...)} is used to perform the timestepping procedure, and is very similar to that in the \href{../../../navier_stokes/two_layer_interface/html/index.html\#unsteady_run}{\texttt{ two-\/dimensional problem}}. The only difference arises from the fact that the initial interface deformation is a Bessel function rather than a cosine curve.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{ \textcolor{comment}{// Set value of epsilon}}
\DoxyCodeLine{ \textcolor{keyword}{const} \textcolor{keywordtype}{double} epsilon = 0.1;}
\DoxyCodeLine{ }
\DoxyCodeLine{ \textcolor{comment}{// Set value of k in Bessel function J\_0(kr)}}
\DoxyCodeLine{ \textcolor{keyword}{const} \textcolor{keywordtype}{double} k\_bessel = 3.8317;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Deform the mesh/free surface}}
\DoxyCodeLine{ deform\_free\_surface(epsilon,k\_bessel);}

\end{DoxyCodeInclude}
 The rest of the function is identical to \href{../../../navier_stokes/two_layer_interface/html/index.html\#unsteady_run}{\texttt{ before}}.

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
\hypertarget{index_sources}{}\doxysection{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/axisym_navier_stokes/two_layer_interface_axisym/}{\texttt{ demo\+\_\+drivers/axisym\+\_\+navier\+\_\+stokes/two\+\_\+layer\+\_\+interface\+\_\+axisym/ }} \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/axisym_navier_stokes/two_layer_interface_axisym/elastic_two_layer_interface_axisym.cc}{\texttt{ demo\+\_\+drivers/axisym\+\_\+navier\+\_\+stokes/two\+\_\+layer\+\_\+interface\+\_\+axisym/elastic\+\_\+two\+\_\+layer\+\_\+interface\+\_\+axisym.\+cc }} \end{center} 
\end{DoxyItemize}

\DoxyHorRuler{0}
 \DoxyHorRuler{0}
 \hypertarget{index_pdf}{}\doxysection{PDF file}\label{index_pdf}
A \href{../latex/refman.pdf}{\texttt{ pdf version}} of this document is available. \end{document}
