<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Refineable Boussinesq Convection using a multi-domain approach: Combining (Refineable) Navier&ndash;Stokes and Advection-Diffusion domains</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Refineable Boussinesq Convection using a multi-domain approach: Combining (Refineable) Navier&ndash;Stokes and Advection-Diffusion domains </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this tutorial we present an alternative approach to the solution of multi-physics problems, using what we call a "multi-domain" approach. We illustrate the methodology by re-considering the <a href="../../b_convection/html/index.html">previously-described, </a> two-dimensional Boussinesq convection problem in which an incompressible, Newtonian fluid is heated from below.</p>
<p>The tutorial is quite long but comprises four relatively self-contained parts. Feel free to skip the theory if you want to jump straight in... <br  />
<br  />
</p><ul>
<li><a href="#setting_up"><b>Part I</b></a> provides an overview of <code>oomph-lib's</code> overall framework for setting up multi-domain interactions. <br  />
<br  />
</li>
<li><a href="#implement_boussinesq"><b>Part II</b></a> illustrates the general procedure for the specific example of a Boussinesq convection problem. We demonstrate how to implement a two-way, multi-domain interaction between the Navier-Stokes equations in which the body force is affected by thermal buoyancy effects, and the advection-diffusion equations for the temperature, in which the "wind" is given by fluid velocity. <br  />
 <br  />
<br  />
</li>
<li><a href="#multi_domain_boussinesq"><b>Part III</b></a> discusses the driver code to solve the Boussinesq problem, using the elements developed in Part II. <br  />
<br  />
</li>
<li><a href="#optimise"><b>Part IV</b></a> discusses how to optimise multi-domain interactions.</li>
</ul>
<hr  />
<h1><a class="anchor" id="setting_up"></a>
Part I: The overall framework for handling multi-domain interactions</h1>
<p>When two or more physical processes interact within the same spatial domain there are three different approaches to setting up the interaction within <code>oomph-lib</code>. One approach is to write a completely new element that discretises all the PDEs involved in the problem. The second approach, described in the tutorials discussing the <a href="../../b_convection/html/index.html">the non-refineable </a> and <a href="../../refine_b_convect/html/index.html">refineable </a> solution of the Boussinesq convection problem, is to create a combined multi-physics element using inheritance from two, or more, existing elements. In both these cases, the physical processes and their associated fields interact within a single element and we refer to this methodology as a <b>multi-field</b> approach.</p>
<p>In this tutorial we describe a third approach to multi-physics problems, in which we solve the problem using two different types of elements on two different meshes (domains), each occupying the same physical space. Rather than interacting locally within elements, the different physical processes interact directly between the two domains, so that, in the Boussinesq convection problem considered here, each advection-diffusion element obtains the "wind" from the (separate) Navier-Stokes element that occupies the same position, while the Navier-Stokes elements obtain the temperature required for the computation of the buoyancy force from the corresponding advection-diffusion element.</p>
<p>One benefit of this <b>multi-domain</b> approach, compared to a <b>multi-field</b> approach, is that different error estimators can be used on each domain and there is no longer a need to construct a combined multi-physics error estimator; see the <a href="../../refine_b_convect/html/index.html">tutorial for the adaptive solution of the Boussinesq convection problem</a> for more details on this issue. Moreover, the meshes do not have to have the same refinement pattern, which can be advantageous if the different physical processes act over different spatial scales. The figure below shows that in the Boussinesq convection problem the Navier&ndash;Stokes mesh (panel (a)) requires much more refinement than the advection-diffusion mesh (panel (b)).</p>
<div class="image">
<img src="two_domains.gif" alt=""/>
<div class="caption">
Steady Convection Rolls: (a) contours of x-velocity and corresponding element boundaries in Navier--Stokes mesh, (b) contours of temperature and corresponding element boundaries in advection-diffusion mesh. </div></div>
 <hr  />
<h2><a class="anchor" id="external_elements"></a>
The ElementWithExternalElement class</h2>
<p>Interaction between different elements in different domains is a fundamental feature of many multi-physics problems and the generic functionality to deal with such interactions is provided by the <code>ElementWithExternalElement</code> class. Any element that requires information from an "external element" should therefore inherit from the base class <code>ElementWithExternalElement</code>. <br  />
</p>
<p>"External elements" typically provide source-like terms for the <code>ElementWithExternalElement</code>. For instance, in the Boussinesq convection problem studied here, the advection-diffusion element is the "external element" for the Navier-Stokes element because it affects the body force in the Navier-Stokes equations; in a fluid-structure interaction problem, the Navier-Stokes elements that are adjacent to the fluid-loaded elastic wall act as the "external elements" for the <code>FSIWallElement</code> because they determine the traction that the fluid exerts onto the wall; etc.</p>
<p>Within a finite-element context, the effect of the "external element" onto the <code>ElementWithExternalElement</code> typically has to be evaluated at the integration points of the <code>ElementWithExternalElement</code>. Therefore, the <code>ElementWithExternalElement</code> base class provides storage for a pointer to an "external element" (and the local coordinate within it) for each integration point. Access to this information is provided via the member functions</p>
<div class="fragment"><div class="line">FiniteElement*&amp; ElementWithExternalElement::external_element_pt(</div>
<div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; interaction, </div>
<div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ipt);</div>
</div><!-- fragment --><p>and</p>
<div class="fragment"><div class="line">Vector&lt;double&gt;&amp; ElementWithExternalElement::external_element_local_coord(</div>
<div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; interaction, </div>
<div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ipt);</div>
</div><!-- fragment --><p>For a given integration point, <code>ipt</code>, within the <code>ElementWithExternalElement</code>, these functions identify the corresponding point in the "external element" by returning a pointer to the "external element" and the local coordinate within it, respectively. The unsigned parameter <code>interaction</code> denotes the interaction index, required to allow for cases where an element interacts with more than one "external element". This occurs, for instance, in double-diffusive convection problems (discussed in <a href="../../../../demo_drivers/multi_physics/double_diffusive_convection/multimesh_dd_convection.cc">a separate demo driver code </a>), in which the body force in the Navier-Stokes equations is affected by two physical properties, <em> e.g.</em> temperature and salinity, both of which are transported by separate advection-diffusion processes; or in FSI problems where a beam or shell element is affected by a fluid load on both its "front" and "back" (see, e.g., the <a href="../../../interaction/fsi_channel_with_leaflet/html/index.html">FSI channel with leaflet problem</a>).</p>
<p><code>Data</code> that affects the fields in the "external elements" must be specified so that the off-diagonal blocks in the <code>ElementWithExternalElement's</code> Jacobian matrix (representing the derivatives of the <code>ElementWithExternalElement's</code> residual vector with respect to the <code>Data</code> in the "external elements") can be calculated. We divide such data into two categories:</p><ul>
<li><em> External field data: </em> all <code>Data</code> that affects the fields through which the "external element" interacts with the <code>ElementWithExternalElement</code>.</li>
</ul>
<ul>
<li><em> External geometric data: </em> all geometric <code>Data</code> that affects the shape and position of the "external element" and, therefore, spatial derivatives of its fields.</li>
</ul>
<p>The rationale for this division is that in many cases the field data's contribution to the interaction blocks in the Jacobian matrix can be found analytically, whereas the geometric data is more easily handled by finite differencing.</p>
<p>Both types of external data are determined (automatically) by two member functions of the <code>ElementWithExternalElement</code>. The first one,</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span>  ElementWithExternalElement::identify_all_field_data_for_external_interaction(</div>
<div class="line">    Vector&lt;std::set&lt;FiniteElement*&gt; &gt; <span class="keyword">const</span> &amp;external_elements_pt,</div>
<div class="line">    std::set&lt;std::pair&lt;Data*,unsigned&gt; &gt; &amp;paired_interaction_data); </div>
</div><!-- fragment --><p>determines the external field data that affect the (possibly multiple) interactions in the <code>ElementWithExternalElement</code>. Given the vector <code>external_elements_pt</code> (within which <code> external_elements_pt[i] </code> contains the set of pointers to the "external elements" involved in the <code>ElementWithExternalElement's</code> <code>i</code> -th interaction), the function returns a set of pairs, each of which comprises a pointer to a <code>Data</code> object and an unsigned that identifies a value within it. The default implementation of this function includes <b>all</b> field data of <b>all</b> "external elements", using calls to</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> FiniteElement::identify_field_data_for_interactions(...)</div>
</div><!-- fragment --><p>for each "external element". Similarly, the function</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span>  ElementWithExternalElement::identify_all_geometric_data_for_external_interaction(</div>
<div class="line">    Vector&lt;std::set&lt;FiniteElement*&gt; &gt;  <span class="keyword">const</span> &amp;external_elements_pt,</div>
<div class="line">    std::set&lt;Data*&gt; &amp;external_geometric_data_pt);</div>
</div><!-- fragment --><p>returns the set of <b>all</b> <code>Data</code> that affect the shape or position of any of the "external elements" specified by the vector <code>external_elements_pt</code>. Again, this function has a default implementation that determines <b>all</b> geometric Data associated with "external elements" by calling</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> FiniteElement::identify_geometric_data(..)</div>
</div><!-- fragment --><p>for each "external element".</p>
<p>We note that the default implementation of these functions can (and, where possible, should) be overloaded to exclude data values that do not actually contribute to the interaction. For instance, in the Boussinesq convection problem considered here, the advection-diffusion elements are only affected by the velocity degrees of freedom in the Navier-Stokes elements but not by the pressures. Our re-implementation of <code>ElementWithExternalElement::identify_all_field_data_for_external_interaction(...)</code> in the multi-domain advection-diffusion element for the Boussinesq problem therefore excludes the pressure degrees of freedom, see <a href="#optimise"><b>Part IV</b></a>.</p>
<hr  />
<h2><a class="anchor" id="off_diag_jac"></a>
Computation of the Jacobian matrix</h2>
<p>Most single-physics elements already provide functions to compute their own Jacobians analytically. These functions compute the derivatives of the element's residual vector with respect to the element's "own" degrees of freedom (e.g. the fluid velocity and pressure in a Navier-Stokes element). The interaction with the "external element" introduces additional dependencies because the element's residual vector now also depends on the unknowns associated with the "external
elements". The derivatives of the element's residual vector with respect to these unknowns must therefore be included into the computation of the element's Jacobian matrix.</p>
<p>To maximise code re-use, we follow the approach discussed in the <a href="../../b_convection/html/index.html#comments">comments </a> section of the single-domain version of the problem and re-use the underlying element's <code>fill_in_contribution_to_jacobian(...)</code> function, while employing finite-differencing to evaluate the derivatives of the element's residual vector with respect to the unknowns associated with the "external elements". This is done most easily by using the function</p>
<div class="fragment"><div class="line">ElementWithExternalElement::fill_in_jacobian_from_external_interaction_by_fd(..)</div>
</div><!-- fragment --><p>which computes the derivatives of the element's residual vector with respect to external field and external geometric data by calls to the two functions</p>
<div class="fragment"><div class="line">ElementWithExternalElement::fill_in_jacobian_from_external_interaction_field_by_fd(..)</div>
</div><!-- fragment --><p>and</p>
<div class="fragment"><div class="line">ElementWithExternalElement::fill_in_jacobian_from_external_interaction_geometric_by_fd(..)</div>
</div><!-- fragment --><p>If, in a particular problem, it is known that the interaction is not affected by the position or shape of the "external elements" (<em> i.e. </em> if the interaction terms do not involve spatial derivatives of the "external element's" field variables) the unnecessary computation of the derivatives with respect to the "external element's" geometric data may be suppressed using a call to</p>
<div class="fragment"><div class="line">ElementWithExternalElement::ignore_external_geometric_data();</div>
</div><!-- fragment --><p>Depending on the complexity of the interaction terms, it may be worthwhile to provide a function that computes the off-diagonal blocks analytically. This is discussed in more detail in <a href="#optimise"><b>Part IV</b></a>.</p>
<hr  />
<h2><a class="anchor" id="setting_up_interaction"></a>
Setting up the interaction</h2>
<p>The namespace <code>Multi_domain_functions</code> provides numerous helper functions that facilitate the setup of multi-domain interactions. Specifically, the function <code>Multi_domain_functions::setup_multi_domain_interactions(...)</code> can be used to identify the "external elements" in a two-way interaction between two meshes. The function has the following interface:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT_0,<span class="keyword">class</span> ELEMENT_1&gt;     </div>
<div class="line"><span class="keywordtype">void</span> setup_multi_domain_interactions(Problem* problem_pt, </div>
<div class="line">                                     Mesh* <span class="keyword">const</span> &amp;first_mesh_pt,</div>
<div class="line">                                     Mesh* <span class="keyword">const</span> &amp;second_mesh_pt,</div>
<div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; first_interaction=0,</div>
<div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; second_interaction=0);</div>
</div><!-- fragment --><p>Here <code>first_mesh_pt</code> and <code>second_mesh_pt</code> point to the two interacting meshes whose elements (of type <code>ELEMENT_0</code> and <code>ELEMENT_1</code>, respectively), must be derived from the <code>ElementWithExternalElement</code> class. The optional interaction parameters may be used to specify which interaction is set up in each mesh. If the parameter is not specified it defaults to zero, appropriate if there is only a single interaction.</p>
<p>The function must be called prior to the assignment of the equation numbers, and then again whenever either of the two meshes has changed, <em> e.g.</em> after a mesh adaptation.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="implement_boussinesq"></a>
Part II: Implementing multi-domain interaction elements for the Boussinesq convection problem</h1>
<p>We illustrate the general procedures discussed above by demonstrating how to upgrade existing single-physics Navier-Stokes and advection-diffusion elements to <code>ElementWithExternalElements</code> that can be used for the multi-domain-based solution of the Boussinesq convection problem.</p>
<hr  />
<h2><a class="anchor" id="nst"></a>
Upgrading the Navier-Stokes element to an ElementWithExternalElement</h2>
<p>We use multiple inheritance to upgrade an existing refineable Navier-Stokes element to a <code>RefineableNavierStokesBoussinesqElement</code> in which the temperature that affects the body force is given by an "external" advection-diffusion element. To facilitate code reuse we employ templating to specify the types of the Navier-Stokes and advection diffusion elements.</p>
 <div class="fragment"><div class="line">  <span class="comment">//======================nst_bous_class=================================</span></div>
<div class="line"><span class="comment">  /// Build a refineable Navier Stokes element that inherits from</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// ElementWithExternalElement so that it can &quot;communicate&quot; with</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// an advection diffusion element that provides the temperature</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// in the body force term.</span></div>
<div class="line"><span class="comment"></span>  <span class="comment">//=====================================================================</span></div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> NST_ELEMENT, <span class="keyword">class</span> AD_ELEMENT&gt;</div>
<div class="line">  <span class="keyword">class </span>RefineableNavierStokesBoussinesqElement</div>
<div class="line">    : <span class="keyword">public</span> <span class="keyword">virtual</span> NST_ELEMENT,</div>
<div class="line">      <span class="keyword">public</span> <span class="keyword">virtual</span> ElementWithExternalElement</div>
<div class="line">  {</div>
</div><!-- fragment --><p>The constructor calls the constructors of the underlying elements, initialises the pointer to the Rayleigh number (stored as private member data in the class) and sets the number of interactions to one, indicating that the residuals of the Navier-Stokes element are only affected by a single type of "external element" &ndash; the advection-diffusion element that determines the temperature distribution.</p>
<div class="fragment"><div class="line">  <span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">    /// Constructor: call the underlying constructors and</span></div>
<div class="line"><span class="comment">    /// initialise the pointer to the Rayleigh number to point</span></div>
<div class="line"><span class="comment">    /// to the default value of 0.0.</span></div>
<div class="line"><span class="comment"></span>    RefineableNavierStokesBoussinesqElement()</div>
<div class="line">      : NST_ELEMENT(), ElementWithExternalElement()</div>
<div class="line">    {</div>
<div class="line">      Ra_pt = &amp;<a class="code" href="namespaceoomph_1_1MultiDomainBoussinesqHelper.html#ae77c07b69cffe295ac07e2c25c31a8aa">MultiDomainBoussinesqHelper::Default_Physical_Constant_Value</a>;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// There is one interaction: The effect of the advection-diffusion</span></div>
<div class="line">      <span class="comment">// element onto the buoyancy term</span></div>
<div class="line">      this-&gt;set_ninteraction(1);</div>
<div class="line">    }</div>
<div class="ttc" id="anamespaceoomph_1_1MultiDomainBoussinesqHelper_html_ae77c07b69cffe295ac07e2c25c31a8aa"><div class="ttname"><a href="namespaceoomph_1_1MultiDomainBoussinesqHelper.html#ae77c07b69cffe295ac07e2c25c31a8aa">oomph::MultiDomainBoussinesqHelper::Default_Physical_Constant_Value</a></div><div class="ttdeci">double Default_Physical_Constant_Value</div><div class="ttdoc">Default value for physical constants.</div><div class="ttdef"><b>Definition:</b> <a href="multi__domain__boussinesq__elements_8h_source.html#l00048">multi_domain_boussinesq_elements.h:48</a></div></div>
</div><!-- fragment --><p> We provide access functions to the Rayleigh number</p>
<div class="fragment"><div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /// Access function for the Rayleigh number (const version)</span></div>
<div class="line"><span class="comment"></span>    <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ra()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> *Ra_pt;</div>
<div class="line">    }</div>
</div><!-- fragment --><p>and, given that we are dealing with a refineable element, make sure that the pointer to the Rayleigh number is passed to the "son" elements when the element is refined. Furthermore, if the external geometric data could safely be ignored in the "father" elements we assume that the same is true for the "sons":</p>
<div class="fragment"><div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /// Access function for the pointer to the Rayleigh number</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">double</span>*&amp; ra_pt()</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">return</span> Ra_pt;</div>
<div class="line">    }</div>
</div><!-- fragment --><p> The most important step is to overload the function that computes the body force in the Navier-Stokes equations so that it depends on the temperature at the <code>ipt</code> -th integration point, as computed by the "external element":</p>
 <div class="fragment"><div class="line">    <span class="comment">/// Overload get_body_force_nst() to return the temperature-dependent</span></div>
<div class="line"><span class="comment">    /// buoyancy force, using the temperature computed by the</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// &quot;external&quot; advection diffusion element associated with</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// integration point \c ipt.</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> get_body_force_nst(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; time,</div>
<div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ipt,</div>
<div class="line">                            <span class="keyword">const</span> Vector&lt;double&gt;&amp; s,</div>
<div class="line">                            <span class="keyword">const</span> Vector&lt;double&gt;&amp; x,</div>
<div class="line">                            Vector&lt;double&gt;&amp; body_force)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Set interaction index -- there&#39;s only one interaction...</span></div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> interaction = 0;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Get a pointer to the external element that computes the</span></div>
<div class="line">      <span class="comment">// the temperature -- we know it&#39;s an advection diffusion element.</span></div>
<div class="line">      <span class="keyword">const</span> AD_ELEMENT* adv_diff_el_pt =</div>
<div class="line">        <span class="keyword">dynamic_cast&lt;</span>AD_ELEMENT*<span class="keyword">&gt;</span>(external_element_pt(interaction, ipt));</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Get the temperature interpolated from the external element</span></div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> interpolated_t = adv_diff_el_pt-&gt;interpolated_u_adv_diff(</div>
<div class="line">        external_element_local_coord(interaction, ipt));</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Get vector that indicates the direction of gravity from</span></div>
<div class="line">      <span class="comment">// the Navier-Stokes equations</span></div>
<div class="line">      Vector&lt;double&gt; gravity(NST_ELEMENT::g());</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Set the temperature-dependent body force:</span></div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_dim = this-&gt;dim();</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n_dim; i++)</div>
<div class="line">      {</div>
<div class="line">        body_force[i] = -gravity[i] * interpolated_t * ra();</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    } <span class="comment">// end overloaded body force</span></div>
</div><!-- fragment --><p> There is only one external interaction so the interaction index is set to zero and the value of the temperature at the integration point is obtained by casting the external element to an advection diffusion element and finding its interpolated field at the appropriate stored local coordinate. Once the temperature has been obtained, the code is identical to that discussed in the <a href="../../b_convection/html/index.html">tutorial for the corresponding multi-field implementation</a>; in that implementation the temperature could be found from a member function because the interaction is internal to the element.</p>
<p>Finally, we have to compute the element's Jacobian matrix. The easiest (although potentially inefficient) way to do this is to recycle the analytical computation of the derivatives of the Navier-Stokes residuals with respect to the fluid degrees of freedom, as implemented in <br  />
 <code>NST_ELEMENT::fill_in_contribution_to_jacobian(...)</code>,</p>
 <div class="fragment"><div class="line">    <span class="comment">/// Compute the element&#39;s residual vector and the Jacobian matrix.</span></div>
<div class="line">    <span class="keywordtype">void</span> fill_in_contribution_to_jacobian(Vector&lt;double&gt;&amp; residuals,</div>
<div class="line">                                          DenseMatrix&lt;double&gt;&amp; jacobian)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Get the analytical contribution from the basic Navier-Stokes element</span></div>
<div class="line">      NST_ELEMENT::fill_in_contribution_to_jacobian(residuals, jacobian);</div>
</div><!-- fragment --><p> and then fill in the derivatives with respect to the degrees of freedom associated with the "external
elements" by finite differencing:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef USE_FD_FOR_DERIVATIVES_WRT_EXTERNAL_DATA_IN_MULTI_DOMAIN_BOUSSINESQ</span></div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Get the off-diagonal terms by finite differencing</span></div>
<div class="line">      this-&gt;fill_in_jacobian_from_external_interaction_by_fd(residuals,</div>
<div class="line">                                                             jacobian);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
</div><!-- fragment --><p> If this is deemed to be too inefficient, we can provide a function that computes the required entries in the Jacobian analytically:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">      <span class="comment">// Get the off-diagonal terms analytically</span></div>
<div class="line">      this-&gt;fill_in_off_diagonal_block_analytic(residuals, jacobian);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
</div><!-- fragment --><p>(The code illustrates both approaches and employs the macro <code>USE_FD_FOR_DERIVATIVES_WRT_EXTERNAL_DATA_IN_MULTI_DOMAIN_BOUSSINESQ</code> to choose which one to use.)</p>
<p>We refer to <a href="#optimise"><b>Part IV</b></a> for a discussion of how to implement the fully-analytic computation of the Jacobian matrix in the function <code>fill_in_off_diagonal_block_analytic(...)</code>.</p>
<hr  />
<hr  />
<h2><a class="anchor" id="ad"></a>
Upgrading the advection-diffusion element to an ElementWithExternalElement</h2>
<p>Upgrading the advection-diffusion element to an <code>ElementWithExternalElement</code> in which the wind is given by the "external" Navier Stokes element follows the same procedure. We use multiple inheritance to construct the element and set the number of interactions to one:</p>
 <div class="fragment"><div class="line">  <span class="comment">//======================ad_bous_class==================================</span></div>
<div class="line"><span class="comment">  /// Build an AdvectionDiffusionElement that inherits from</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// ElementWithExternalElement so that it can &quot;communicate&quot; with the</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// a NavierStokesElement that provides its wind.</span></div>
<div class="line"><span class="comment"></span>  <span class="comment">//=====================================================================</span></div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> AD_ELEMENT, <span class="keyword">class</span> NST_ELEMENT&gt;</div>
<div class="line">  <span class="keyword">class </span>RefineableAdvectionDiffusionBoussinesqElement</div>
<div class="line">    : <span class="keyword">public</span> <span class="keyword">virtual</span> AD_ELEMENT,</div>
<div class="line">      <span class="keyword">public</span> <span class="keyword">virtual</span> ElementWithExternalElement</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">    /// Constructor: call the underlying constructors</span></div>
<div class="line"><span class="comment"></span>    RefineableAdvectionDiffusionBoussinesqElement()</div>
<div class="line">      : AD_ELEMENT(), ElementWithExternalElement()</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// There is one interaction</span></div>
<div class="line">      this-&gt;set_ninteraction(1);</div>
<div class="line">    }</div>
</div><!-- fragment --><p>We overload the function that computes the "wind" for the advection diffusion equations so that it is given by the fluid velocity at the <code>ipt</code> -th integration point, as computed by the "external element":</p>
 <div class="fragment"><div class="line">    <span class="comment">/// Overload the wind function in the advection-diffusion equations.</span></div>
<div class="line"><span class="comment">    /// This provides the coupling from the Navier--Stokes equations to the</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// advection-diffusion equations because the wind is the fluid velocity,</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// obtained from the &quot;external&quot; element</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> get_wind_adv_diff(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ipt,</div>
<div class="line">                           <span class="keyword">const</span> Vector&lt;double&gt;&amp; s,</div>
<div class="line">                           <span class="keyword">const</span> Vector&lt;double&gt;&amp; x,</div>
<div class="line">                           Vector&lt;double&gt;&amp; wind)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="comment">// There is only one interaction</span></div>
<div class="line">      <span class="keywordtype">unsigned</span> interaction = 0;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Dynamic cast &quot;external&quot; element to Navier Stokes element</span></div>
<div class="line">      NST_ELEMENT* nst_el_pt =</div>
<div class="line">        <span class="keyword">dynamic_cast&lt;</span>NST_ELEMENT*<span class="keyword">&gt;</span>(external_element_pt(interaction, ipt));</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Wind is given by the velocity in the Navier Stokes element</span></div>
<div class="line">      nst_el_pt-&gt;interpolated_u_nst(</div>
<div class="line">        external_element_local_coord(interaction, ipt), wind);</div>
<div class="line"> </div>
<div class="line">    } <span class="comment">// end of get_wind_adv_diff</span></div>
</div><!-- fragment --><p> Again, there is only one external interaction so the interaction index is set to zero and the external element must be cast to a Navier-Stokes element so that the interpolated velocity field can be found. The code is similar to that used in the <a href="../../b_convection/html/index.html">multi-field implementation</a>, which uses internal, rather than external, interaction.</p>
<p>The element's Jacobian matrix can be computed by the same methods discussed for the Navier-Stokes elements:</p>
<div class="fragment"><div class="line">    <span class="comment">/// Compute the element&#39;s residual vector and the Jacobian matrix.</span></div>
<div class="line">    <span class="keywordtype">void</span> fill_in_contribution_to_jacobian(Vector&lt;double&gt;&amp; residuals,</div>
<div class="line">                                          DenseMatrix&lt;double&gt;&amp; jacobian)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Get the contribution from the basic advection diffusion element</span></div>
<div class="line">      AD_ELEMENT::fill_in_contribution_to_jacobian(residuals, jacobian);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef USE_FD_FOR_DERIVATIVES_WRT_EXTERNAL_DATA_IN_MULTI_DOMAIN_BOUSSINESQ</span></div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Get the off-diagonal terms by finite differencing</span></div>
<div class="line">      this-&gt;fill_in_jacobian_from_external_interaction_by_fd(residuals,</div>
<div class="line">                                                             jacobian);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Get the off-diagonal terms analytically</span></div>
<div class="line">      this-&gt;fill_in_off_diagonal_block_analytic(residuals, jacobian);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="multi_domain_boussinesq"></a>
Part III: The driver code for the multi-domain Boussinesq problem</h1>
<p>Using the upgraded elements discussed above, <a href="../../../../demo_drivers/multi_physics/boussinesq_convection/multi_domain_ref_b_convection.cc">the driver code </a> for the multi-domain-based solution of the Boussinesq convection problem is very similar to that of the <a href="../../refine_b_convect/html/index.html">single-domain example.</a> Indeed, the <code><a class="el" href="boussinesq__convection_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627" title="Driver code for 2D Boussinesq convection problem.">main()</a></code> functions are virtually identical. The only difference is that the <code><a class="el" href="classRefineableConvectionProblem.html" title="/////////////////////////////////////////////////////////////////// /////////////////////////////////...">RefineableConvectionProblem</a></code> takes two template arguments (specifying the two different element types) instead of one (specifying the type of the single, combined element).</p>
<hr  />
<h2><a class="anchor" id="problem_class"></a>
The problem class</h2>
<p>The problem class is similar to that of the <a href="../../refine_b_convect/html/index.html">single-domain example </a> and many of the functions are the same. There are now two meshes, however, one for the fluid elements and one for the advection-diffusion elements:</p>
 <div class="fragment"><div class="line"> <span class="comment">/// Access function to the NST mesh. </span></div>
<div class="line"><span class="comment"> /// Casts the pointer to the base Mesh object to </span></div>
<div class="line"><span class="comment"></span><span class="comment"> /// the actual mesh type.</span></div>
<div class="line"><span class="comment"></span> RefineableRectangularQuadMesh&lt;NST_ELEMENT&gt;* nst_mesh_pt() </div>
<div class="line">  {</div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span>RefineableRectangularQuadMesh&lt;NST_ELEMENT&gt;*<span class="keyword">&gt;</span></div>
<div class="line">    (Nst_mesh_pt);</div>
<div class="line">  } <span class="comment">// end_of_nst_mesh</span></div>
<div class="line"> <span class="comment">/// Access function to the AD mesh. </span></div>
<div class="line"><span class="comment"> /// Casts the pointer to the base Mesh object to </span></div>
<div class="line"><span class="comment"></span><span class="comment"> /// the actual mesh type.</span></div>
<div class="line"><span class="comment"></span> RefineableRectangularQuadMesh&lt;AD_ELEMENT&gt;* adv_diff_mesh_pt() </div>
<div class="line">  {</div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span>RefineableRectangularQuadMesh&lt;AD_ELEMENT&gt;*<span class="keyword">&gt;</span></div>
<div class="line">    (Adv_diff_mesh_pt);</div>
<div class="line">  } <span class="comment">// end_of_ad_mesh</span></div>
</div><!-- fragment --><p> and after any mesh adaptation, the interaction between the two meshes must be set up again.</p>
<div class="fragment"><div class="line"> <span class="comment">/// Actions after adaptation, reset all sources, then</span></div>
<div class="line"><span class="comment"> /// re-pin a single pressure degree of freedom</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> actions_after_adapt()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Unpin all the pressures in NST mesh to avoid pinning two pressures</span></div>
<div class="line">   RefineableNavierStokesEquations&lt;2&gt;::</div>
<div class="line">    unpin_all_pressure_dofs(nst_mesh_pt()-&gt;element_pt());</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Pin the zero-th pressure dof in the zero-th element and set</span></div>
<div class="line">   <span class="comment">// its value to zero</span></div>
<div class="line">   fix_pressure(0,0,0.0);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set external elements for the multi-domain solution.</span></div>
<div class="line">   Multi_domain_functions::</div>
<div class="line">    setup_multi_domain_interactions&lt;NST_ELEMENT,AD_ELEMENT&gt;</div>
<div class="line">    (<span class="keyword">this</span>,nst_mesh_pt(),adv_diff_mesh_pt());</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">//end_of_actions_after_adapt</span></div>
</div><!-- fragment --> <hr  />
<h2><a class="anchor" id="constructor"></a>
The Problem constructor</h2>
<p>The problem constructor is slightly different from the equivalent single-domain version, mainly because there are two meshes instead of one. Firstly, we build two coarse meshes with the same number of elements ( <img class="formulaInl" alt="$ 9 \times 8 $" src="form_0.png" width="29" height="9"/>, as in the original single-domain problem) and dimensions for each mesh. Error estimators and error targets are set separately for each mesh.</p>
 <div class="fragment"><div class="line"><span class="comment">//=======start_of_constructor=============================================</span></div>
<div class="line"><span class="comment">/// Constructor for adaptive thermal convection problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> NST_ELEMENT,<span class="keyword">class</span> AD_ELEMENT&gt;</div>
<div class="line"><a class="code" href="classRefineableConvectionProblem.html#a97e661986093402bf55fb6c32b782ddc">RefineableConvectionProblem&lt;NST_ELEMENT,AD_ELEMENT&gt;::</a></div>
<div class="line"><a class="code" href="classRefineableConvectionProblem.html#a97e661986093402bf55fb6c32b782ddc">RefineableConvectionProblem</a>()</div>
<div class="line">{ </div>
<div class="line"> <span class="comment">// Set output directory</span></div>
<div class="line"> Doc_info.set_directory(<span class="stringliteral">&quot;RESLT&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// # of elements in x-direction</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_x=9;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// # of elements in y-direction</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_y=8;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Domain length in x-direction</span></div>
<div class="line"> <span class="keywordtype">double</span> l_x=3.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Domain length in y-direction</span></div>
<div class="line"> <span class="keywordtype">double</span> l_y=1.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the meshes</span></div>
<div class="line"> Nst_mesh_pt =</div>
<div class="line">  <span class="keyword">new</span> RefineableRectangularQuadMesh&lt;NST_ELEMENT&gt;(n_x,n_y,l_x,l_y);</div>
<div class="line"> Adv_diff_mesh_pt =</div>
<div class="line">  <span class="keyword">new</span> RefineableRectangularQuadMesh&lt;AD_ELEMENT&gt;(n_x,n_y,l_x,l_y);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create/set error estimator</span></div>
<div class="line"> Nst_mesh_pt-&gt;spatial_error_estimator_pt()=<span class="keyword">new</span> Z2ErrorEstimator;</div>
<div class="line"> Adv_diff_mesh_pt-&gt;spatial_error_estimator_pt()=<span class="keyword">new</span> Z2ErrorEstimator;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set error targets for adaptive refinement</span></div>
<div class="line"> Nst_mesh_pt-&gt;max_permitted_error()=0.5e-3; </div>
<div class="line"> Nst_mesh_pt-&gt;min_permitted_error()=0.5e-4; </div>
<div class="line"> Adv_diff_mesh_pt-&gt;max_permitted_error()=0.5e-3; </div>
<div class="line"> Adv_diff_mesh_pt-&gt;min_permitted_error()=0.5e-4; </div>
<div class="ttc" id="aclassRefineableConvectionProblem_html_a97e661986093402bf55fb6c32b782ddc"><div class="ttname"><a href="classRefineableConvectionProblem.html#a97e661986093402bf55fb6c32b782ddc">RefineableConvectionProblem::RefineableConvectionProblem</a></div><div class="ttdeci">RefineableConvectionProblem()</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> <a href="multi__domain__ref__b__convection_8cc_source.html#l00186">multi_domain_ref_b_convection.cc:187</a></div></div>
</div><!-- fragment --><p> The boundary constraints are applied to each mesh in turn; firstly on the Navier&ndash;Stokes mesh, where we must also pin a single pressure:</p>
<div class="fragment"><div class="line"> <span class="comment">// Set the boundary conditions for this problem: All nodes are</span></div>
<div class="line"> <span class="comment">// free by default -- only need to pin the ones that have Dirichlet </span></div>
<div class="line"> <span class="comment">// conditions here</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Loop over the boundaries of the NST mesh</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> num_bound = nst_mesh_pt()-&gt;nboundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibound=0;ibound&lt;num_bound;ibound++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Set the maximum index to be pinned (all values by default)</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> val_max;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Loop over the number of nodes on the boundry</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> num_nod= nst_mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//If we are on the side-walls, the v-velocity and temperature</span></div>
<div class="line">     <span class="comment">//satisfy natural boundary conditions, so we only pin the</span></div>
<div class="line">     <span class="comment">//first value</span></div>
<div class="line">     <span class="keywordflow">if</span>((ibound==1) || (ibound==3)) </div>
<div class="line">      {</div>
<div class="line">       val_max=1;</div>
<div class="line">      }</div>
<div class="line">     <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">       val_max=nst_mesh_pt()-&gt;boundary_node_pt(ibound,inod)-&gt;nvalue();</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//Loop over the desired values stored at the nodes and pin</span></div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;val_max;j++)</div>
<div class="line">      {</div>
<div class="line">       nst_mesh_pt()-&gt;boundary_node_pt(ibound,inod)-&gt;pin(j);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Pin the zero-th pressure value in the zero-th element and</span></div>
<div class="line"> <span class="comment">// set its value to zero.</span></div>
<div class="line"> fix_pressure(0,0,0.0);</div>
</div><!-- fragment --><p> We then apply boundary constraints to the advection-diffusion mesh:</p>
<div class="fragment"><div class="line"> <span class="comment">//Loop over the boundaries of the AD mesh</span></div>
<div class="line"> num_bound = adv_diff_mesh_pt()-&gt;nboundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibound=0;ibound&lt;num_bound;ibound++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Set the maximum index to be pinned (all values by default)</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> val_max;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Loop over the number of nodes on the boundry</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> num_nod= adv_diff_mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">//If we are on the side-walls, the v-velocity and temperature</span></div>
<div class="line">     <span class="comment">//satisfy natural boundary conditions, so we don&#39;t pin anything</span></div>
<div class="line">     <span class="comment">// in this mesh</span></div>
<div class="line">     <span class="keywordflow">if</span> ((ibound==1) || (ibound==3)) </div>
<div class="line">      {</div>
<div class="line">       val_max=0;</div>
<div class="line">      }</div>
<div class="line">     <span class="keywordflow">else</span> <span class="comment">// pin all values</span></div>
<div class="line">      {</div>
<div class="line">       val_max=adv_diff_mesh_pt()-&gt;boundary_node_pt(ibound,inod)-&gt;nvalue();</div>
<div class="line">       <span class="comment">//Loop over the desired values stored at the nodes and pin</span></div>
<div class="line">       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;val_max;j++)</div>
<div class="line">        {</div>
<div class="line">         adv_diff_mesh_pt()-&gt;boundary_node_pt(ibound,inod)-&gt;pin(j);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">// end of loop over AD mesh boundaries</span></div>
</div><!-- fragment --><p> and complete the build of all elements in each mesh by setting the pointers to the required physical parameters in each domain. Since neither of the interaction terms involves spatial derivatives of the field variables in the "external elements", we can ignore the derivatives with respect to the external geometric data when computing the element's Jacobian matrix. This is done by the calls to <code>ElementWithExternalElement::ignore_external_geometric_data()</code>;</p>
<div class="fragment"><div class="line"> <span class="comment">// Complete the build of all elements so they are fully functional </span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over the elements to set up element-specific </span></div>
<div class="line"> <span class="comment">// things that cannot be handled by the (argument-free!) ELEMENT </span></div>
<div class="line"> <span class="comment">// constructor.</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_nst_element = nst_mesh_pt()-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_nst_element;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from GeneralsedElement to the present element</span></div>
<div class="line">   NST_ELEMENT *el_pt = <span class="keyword">dynamic_cast&lt;</span>NST_ELEMENT*<span class="keyword">&gt;</span></div>
<div class="line">    (nst_mesh_pt()-&gt;element_pt(i));</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set the Reynolds number (1/Pr in our non-dimensionalisation)</span></div>
<div class="line">   el_pt-&gt;re_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a87796c9f402e6f90c07cf5ba0db4367e">Global_Physical_Variables::Inverse_Prandtl</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set ReSt (also 1/Pr in our non-dimensionalisation)</span></div>
<div class="line">   el_pt-&gt;re_st_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a87796c9f402e6f90c07cf5ba0db4367e">Global_Physical_Variables::Inverse_Prandtl</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set the Rayleigh number</span></div>
<div class="line">   el_pt-&gt;ra_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a637fd2a6a7c5b34ed3288300d8bf84b7">Global_Physical_Variables::Rayleigh</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Set Gravity vector</span></div>
<div class="line">   el_pt-&gt;g_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a42f4a0aee37dbb36186267931c614053">Global_Physical_Variables::Direction_of_gravity</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// We can ignore the external geometric data in the &quot;external&quot;</span></div>
<div class="line">   <span class="comment">// advection diffusion element when computing the Jacobian matrix</span></div>
<div class="line">   <span class="comment">// because the interaction does not involve spatial gradients of </span></div>
<div class="line">   <span class="comment">// the temperature (and also because the mesh isn&#39;t moving!)</span></div>
<div class="line">   el_pt-&gt;ignore_external_geometric_data();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">unsigned</span> n_ad_element = adv_diff_mesh_pt()-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_ad_element;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from GeneralsedElement to the present element</span></div>
<div class="line">   AD_ELEMENT *el_pt = <span class="keyword">dynamic_cast&lt;</span>AD_ELEMENT*<span class="keyword">&gt;</span></div>
<div class="line">    (adv_diff_mesh_pt()-&gt;element_pt(i));</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set the Peclet number</span></div>
<div class="line">   el_pt-&gt;pe_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#ad4cdf142ba50635d62ac4c614f445af7">Global_Physical_Variables::Peclet</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set the Peclet number multiplied by the Strouhal number</span></div>
<div class="line">   el_pt-&gt;pe_st_pt() =&amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#ad4cdf142ba50635d62ac4c614f445af7">Global_Physical_Variables::Peclet</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// We can ignore the external geometric data in the &quot;external&quot;</span></div>
<div class="line">   <span class="comment">// Navier Stokes element when computing the Jacobian matrix</span></div>
<div class="line">   <span class="comment">// because the interaction does not involve spatial gradients of </span></div>
<div class="line">   <span class="comment">// the velocities (and also because the mesh isn&#39;t moving!)</span></div>
<div class="line">   el_pt-&gt;ignore_external_geometric_data();</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// end of setup for all AD elements</span></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a42f4a0aee37dbb36186267931c614053"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a42f4a0aee37dbb36186267931c614053">Global_Physical_Variables::Direction_of_gravity</a></div><div class="ttdeci">Vector&lt; double &gt; Direction_of_gravity(2)</div><div class="ttdoc">Gravity vector.</div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a637fd2a6a7c5b34ed3288300d8bf84b7"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a637fd2a6a7c5b34ed3288300d8bf84b7">Global_Physical_Variables::Rayleigh</a></div><div class="ttdeci">double Rayleigh</div><div class="ttdoc">Rayleigh number, set to be greater than the threshold for linear instability.</div><div class="ttdef"><b>Definition:</b> <a href="boussinesq__convection_8cc_source.html#l00058">boussinesq_convection.cc:58</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a87796c9f402e6f90c07cf5ba0db4367e"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a87796c9f402e6f90c07cf5ba0db4367e">Global_Physical_Variables::Inverse_Prandtl</a></div><div class="ttdeci">double Inverse_Prandtl</div><div class="ttdoc">1/Prandtl number</div><div class="ttdef"><b>Definition:</b> <a href="boussinesq__convection_8cc_source.html#l00054">boussinesq_convection.cc:54</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_ad4cdf142ba50635d62ac4c614f445af7"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#ad4cdf142ba50635d62ac4c614f445af7">Global_Physical_Variables::Peclet</a></div><div class="ttdeci">double Peclet</div><div class="ttdoc">Peclet number (identically one from our non-dimensionalisation)</div><div class="ttdef"><b>Definition:</b> <a href="boussinesq__convection_8cc_source.html#l00051">boussinesq_convection.cc:51</a></div></div>
</div><!-- fragment --><p> Finally we combine the submeshes, set up the interaction between the two meshes, and assign the equation numbers.</p>
<div class="fragment"><div class="line"> <span class="comment">// combine the submeshes</span></div>
<div class="line"> add_sub_mesh(Nst_mesh_pt);</div>
<div class="line"> add_sub_mesh(Adv_diff_mesh_pt);</div>
<div class="line"> build_global_mesh();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set external elements for the multi-domain solution.</span></div>
<div class="line"> Multi_domain_functions::</div>
<div class="line">  setup_multi_domain_interactions&lt;NST_ELEMENT,AD_ELEMENT&gt;</div>
<div class="line">  (<span class="keyword">this</span>,nst_mesh_pt(),adv_diff_mesh_pt());</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Setup equation numbering scheme</span></div>
<div class="line"> cout &lt;&lt; <span class="stringliteral">&quot;Number of equations: &quot;</span> &lt;&lt; assign_eqn_numbers() &lt;&lt; endl; </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of constructor</span></div>
</div><!-- fragment --> <hr  />
<h2><a class="anchor" id="actions_before_newton_solve"></a>
The function actions_before_newton_solve(...)</h2>
<p>In this function we update the problem specifications before a solution by re-applying the specific values of the Dirichlet boundary conditions for each mesh, and ensuring that the mass-conserving imperfection is applied to the velocity boundary conditions on the Navier&ndash;Stokes mesh if required. The boundary conditions are exactly the same as for the <a href="../../b_convection/html/index.html">single-domain version of the problem</a>, but they must be applied differently because there are now two meshes instead of one.</p>
 <div class="fragment"><div class="line"><span class="comment">//===================start_actions_before_newton_solve====================</span></div>
<div class="line"><span class="comment">/// Update the problem specs before solve: (Re-)set boundary conditions</span></div>
<div class="line"><span class="comment"></span><span class="comment">/// to include an imperfection (or not) depending on the control flag.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> NST_ELEMENT,<span class="keyword">class</span> AD_ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classRefineableConvectionProblem.html#a694f0be87fe09a30d94e92acfce85eee">RefineableConvectionProblem&lt;NST_ELEMENT,AD_ELEMENT&gt;::actions_before_newton_solve</a>()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Loop over the boundaries on the NST mesh</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> num_bound = nst_mesh_pt()-&gt;nboundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibound=0;ibound&lt;num_bound;ibound++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Loop over the nodes on boundary </span></div>
<div class="line">   <span class="keywordtype">unsigned</span> num_nod=nst_mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Get pointer to node</span></div>
<div class="line">     Node* nod_pt=nst_mesh_pt()-&gt;boundary_node_pt(ibound,inod);</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//Set the number of velocity components</span></div>
<div class="line">     <span class="keywordtype">unsigned</span> vel_max=2;</div>
<div class="line">     <span class="comment">//If we are on the side walls we only pin the x-velocity.</span></div>
<div class="line">     <span class="keywordflow">if</span>((ibound==1) || (ibound==3)) {vel_max = 1;}</div>
<div class="line">     <span class="comment">//Set the pinned velocities to zero</span></div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;vel_max;j++) {nod_pt-&gt;set_value(j,0.0);}</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//If we are on the top boundary</span></div>
<div class="line">     <span class="keywordflow">if</span>(ibound==2) </div>
<div class="line">      {</div>
<div class="line">       <span class="comment">//Add small velocity imperfection if desired</span></div>
<div class="line">       <span class="keywordflow">if</span>(Imperfect)</div>
<div class="line">        {</div>
<div class="line">         <span class="comment">//Read out the x position</span></div>
<div class="line">         <span class="keywordtype">double</span> x = nod_pt-&gt;x(0);</div>
<div class="line">         <span class="comment">//Set a sinusoidal perturbation in the vertical velocity</span></div>
<div class="line">         <span class="comment">//This perturbation is mass conserving</span></div>
<div class="line">         <span class="keywordtype">double</span> value = sin(2.0*3.141592654*x/3.0);</div>
<div class="line">         nod_pt-&gt;set_value(1,value);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over all the boundaries on the AD mesh</span></div>
<div class="line"> num_bound=adv_diff_mesh_pt()-&gt;nboundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibound=0;ibound&lt;num_bound;ibound++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Loop over the nodes on boundary </span></div>
<div class="line">   <span class="keywordtype">unsigned</span> num_nod=adv_diff_mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Get pointer to node</span></div>
<div class="line">     Node* nod_pt=adv_diff_mesh_pt()-&gt;boundary_node_pt(ibound,inod);</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//If we are on the top boundary, set the temperature </span></div>
<div class="line">     <span class="comment">//to -0.5 (cooled)</span></div>
<div class="line">     <span class="keywordflow">if</span>(ibound==2) {nod_pt-&gt;set_value(0,-0.5);}</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//If we are on the bottom boundary, set the temperature</span></div>
<div class="line">     <span class="comment">//to 0.5 (heated)</span></div>
<div class="line">     <span class="keywordflow">if</span>(ibound==0) {nod_pt-&gt;set_value(0,0.5);}</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// end of actions before solve</span></div>
<div class="ttc" id="aclassRefineableConvectionProblem_html_a694f0be87fe09a30d94e92acfce85eee"><div class="ttname"><a href="classRefineableConvectionProblem.html#a694f0be87fe09a30d94e92acfce85eee">RefineableConvectionProblem::actions_before_newton_solve</a></div><div class="ttdeci">void actions_before_newton_solve()</div><div class="ttdoc">Update the problem specs before solve:</div><div class="ttdef"><b>Definition:</b> <a href="multi__domain__ref__b__convection_8cc_source.html#l00364">multi_domain_ref_b_convection.cc:364</a></div></div>
</div><!-- fragment --> <hr  />
<h2><a class="anchor" id="doc_solution"></a>
The function doc_solution(...)</h2>
<p>This function outputs all fields to the specified solution file in the directory pointed to by the <code>DocInfo</code> object.</p>
 <div class="fragment"><div class="line"><span class="comment">//====================start_of_doc_solution===============================</span></div>
<div class="line"><span class="comment">/// Doc the solution</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> NST_ELEMENT,<span class="keyword">class</span> AD_ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classRefineableConvectionProblem.html#a47efcb3467931e13e12687303135e38b">RefineableConvectionProblem&lt;NST_ELEMENT,AD_ELEMENT&gt;::doc_solution</a>()</div>
<div class="line">{ </div>
<div class="line"> <span class="comment">//Declare an output stream and filename</span></div>
<div class="line"> ofstream some_file;</div>
<div class="line"> <span class="keywordtype">char</span> filename[100];</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Number of plot points: npts x npts</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> npts=5;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output Navier-Stokes solution</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/fluid_soln%i.dat&quot;</span>,Doc_info.directory().c_str(),</div>
<div class="line">         Doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> nst_mesh_pt()-&gt;output(some_file,npts);</div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output advection diffusion solution</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/temperature_soln%i.dat&quot;</span>,Doc_info.directory().c_str(),</div>
<div class="line">         Doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> adv_diff_mesh_pt()-&gt;output(some_file,npts);</div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> Doc_info.number()++;</div>
<div class="line">} <span class="comment">// end of doc</span></div>
<div class="ttc" id="aclassRefineableConvectionProblem_html_a47efcb3467931e13e12687303135e38b"><div class="ttname"><a href="classRefineableConvectionProblem.html#a47efcb3467931e13e12687303135e38b">RefineableConvectionProblem::doc_solution</a></div><div class="ttdeci">void doc_solution()</div><div class="ttdoc">Doc the solution.</div><div class="ttdef"><b>Definition:</b> <a href="multi__domain__ref__b__convection_8cc_source.html#l00432">multi_domain_ref_b_convection.cc:432</a></div></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="optimise"></a>
Part IV: Optimising multi-domain interactions</h1>
<p>We showed in <a href="#implement_boussinesq"><b>Part II</b></a> that only a small number of functions <b> must </b> be implemented to upgrade an existing single-physics element to an <code>ElementWithExternalElement</code> that can interact with another element in a different domain. This is because much of the required functionality is already implemented in the <code>ElementWithExternalElement</code> base class, which makes the implementation of multi-physics interactions very easy. The use of general-purpose functions may incur unnecessary computational cost, however. Hence, a better efficiency can be achieved by overloading certain functions when implementing a specific <code>ElementWithExternalElement</code>.</p>
<hr  />
<h2><a class="anchor" id="restricting_field_data"></a>
Ignoring field data that does not participate in the interaction</h2>
<p>The function <code>ElementWithExternalElement::identify_all_field_data_for_external_interaction(...)</code> assumes that <b>all</b> data values in the external elements affect the interaction with the <code>ElementWithExternalElement</code>. In many cases this assumption is overly pessimistic (and costly). For instance in the Boussinesq convection problem only the velocity degrees of freedom in the (external) Navier-Stokes element affect the the advection-diffusion equations via the "wind". It is therefore sensible to exclude the pressure degrees of freedom from the interaction by re-implementing <code>identify_all_field_data_for_external_interaction(...)</code> as follows</p>
 <div class="fragment"><div class="line">  <span class="comment">//================optimised_identification_of_field_data==================</span></div>
<div class="line"><span class="comment">  /// Overload the function that must return all field data involved</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// in the interaction with the external (Navier Stokes) element.</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// Only the velocity dofs in the Navier Stokes element affect the</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// interaction with the current element.</span></div>
<div class="line"><span class="comment"></span>  <span class="comment">//=======================================================================</span></div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> AD_ELEMENT, <span class="keyword">class</span> NST_ELEMENT&gt;</div>
<div class="line">  <span class="keywordtype">void</span> RefineableAdvectionDiffusionBoussinesqElement&lt;AD_ELEMENT, NST_ELEMENT&gt;::</div>
<div class="line">    identify_all_field_data_for_external_interaction(</div>
<div class="line">      Vector&lt;std::set&lt;FiniteElement*&gt;&gt; <span class="keyword">const</span>&amp; external_elements_pt,</div>
<div class="line">      std::set&lt;std::pair&lt;Data*, unsigned&gt;&gt;&amp; paired_interaction_data)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// There&#39;s only one interaction</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> interaction = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Loop over each Navier Stokes element in the set of external elements that</span></div>
<div class="line">    <span class="comment">// affect the current element</span></div>
<div class="line">    <span class="keywordflow">for</span> (std::set&lt;FiniteElement*&gt;::iterator it =</div>
<div class="line">           external_elements_pt[interaction].begin();</div>
<div class="line">         it != external_elements_pt[interaction].end();</div>
<div class="line">         it++)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Cast the external element to a fluid element</span></div>
<div class="line">      NST_ELEMENT* external_fluid_el_pt = <span class="keyword">dynamic_cast&lt;</span>NST_ELEMENT*<span class="keyword">&gt;</span>(*it);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Loop over the nodes</span></div>
<div class="line">      <span class="keywordtype">unsigned</span> nnod = external_fluid_el_pt-&gt;nnode();</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; nnod; j++)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Pointer to node (in its incarnation as Data)</span></div>
<div class="line">        Data* veloc_data_pt = external_fluid_el_pt-&gt;node_pt(j);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Get all velocity dofs</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_dim = this-&gt;dim();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n_dim; i++)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// Which value corresponds to the i-th velocity?</span></div>
<div class="line">          <span class="keywordtype">unsigned</span> val = external_fluid_el_pt-&gt;u_index_nst(i);</div>
<div class="line"> </div>
<div class="line">          <span class="comment">// Turn pointer to Data and index of value into pair</span></div>
<div class="line">          <span class="comment">// and add to the set</span></div>
<div class="line">          paired_interaction_data.insert(std::make_pair(veloc_data_pt, val));</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">// done</span></div>
</div><!-- fragment --><p> Similar approaches can be used to ignore selected (weak) interactions when computing the element's Jacobian matrix. For instance, the <code>FSIWallElement</code> is an <code>ElementWithExternalElement</code> for which the adjacent fluid elements that apply the fluid traction to the FSI boundary act as "external elements". In high-Reynolds-number flows, the fluid traction is dominated by the pressure while shear stresses tend to be small. The <code>FSIWallElement</code> therefore uses the same mechanism as illustrated above to (optionally) neglect the derivatives of its residuals with respect to the fluid velocity degrees of freedom. We stress that this does not exclude the shear stress from the computation &ndash; it simply replaces the exact Jacobian by an approximate version in which the effect of the velocity degrees of freedom on the residuals of the <code>FSIWallElement</code> are neglected. This may lead to a slight degradation in the convergence rate of the Newton iteration but this may be more than compensated for by the reduction in the CPU times required to compute the Jacobian matrix.</p>
<hr  />
<h2><a class="anchor" id="restricting_geom_data"></a>
Ignoring geometric data</h2>
<p>If the interaction with the "external element" does not involve spatial derivatives of the fields represented by the "external element" or if the mesh containing the "external elements" is fixed, the external geometric data associated with the "external elements" can be ignored when computing the <code>ElementWithExternalElement's</code> Jacobian. This may be achieved by calling</p>
<div class="fragment"><div class="line">ElementWithExternalElement::ignore_external_geometric_data();</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="analytical_jacobian"></a>
Computing the off-diagonal blocks in the Jacobian analytically</h2>
<p>The setup of the Jacobian matrix can be made much more efficient by computing the derivatives of the <code>ElementWithExternalElements'</code> residual vector with respect to the field data in the associated "external elements" analytically. The multi-domain driver codes in</p>
<center> <a href="../../../../demo_drivers/multi_physics/boussinesq_convection">demo_drivers/multi_physics/boussinesq_convection </a> </center><p>demonstrate a possible implementation. The key challenge for the implementation is that the <code>ElementWithExternalElement</code> must label the entries in its elemental Jacobian matrix by its local equation numbers, whereas the "external element" can only compute the derivative of its fields with respect to its own (differently numbered) local degrees of freedom (d.o.f.s). To establish which local d.o.f. in the "external element" corresponds to a given local d.o.f. in the <code>ElementWithExternalElement</code> we exchange the (unique) global equation numbers associated with each d.o.f. Using this trick, the computation of the derivatives becomes relatively straightforward. Mathematically, it involves repeated applications of the chain rule. In the cases we considered, the fully-analytic computation of the elemental Jacobian matrix was about 3 to 4 times faster than finite-difference-based computation implemented in the <code>ElementWithExternalElement</code> base class. Whether the speedup is worth the additional (human) time required to implement the analytic computation of the off-diagonal entries depends on the application (and you!). If nothing else, the availability of a finite-difference based routine helps in the validation of any newly-developed analytic re-implementation.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="comm_and_ex"></a>
Comments and Exercises</h1>
<h2><a class="anchor" id="comments"></a>
Comments</h2>
<ul>
<li>The use of two separate meshes with different error estimators means that, in principle, a more accurate solution can be obtained with fewer degrees of freedom than using a combined error estimator on a single mesh. The combined error estimator implemented in the <a href="../../refine_b_convect/html/index.html">single-domain version of the problem </a> will cause refinement if either the fluid error or the advection-diffusion error is above the specified tolerance. Thus, a fully-converged solution in the single-domain problem is one in which the estimated error in all field variables is below the tolerance, but this may be at the cost of some over-refinement in one or more of the field variables. In the present multi-domain approach, if the solution is converged on both meshes then the estimated error in all field variables is again below the tolerance. Hence, it is fair, in some sense, to compare the results between fully-converged solutions for the single- and multi-domain problems. As suggested by the figure above, for the Boussinesq convection problem considered here we do obtain fully-converged solutions with fewer degrees of freedom using the multi-domain approach because the temperature field is over-refined in the single-domain case. Of course, the multi-domain solution includes the extra overhead of setting up the interaction, but, in general, this cost is negligible compared to the solution of the linear systems. <br  />
<br  />
</li>
<li>The general procedures described in this tutorial can be used to set up any interaction between different types of elements using multiple meshes. <br  />
<br  />
</li>
<li>Before any refinements take place the combined Jacobian is exactly the same as that in the single-domain problem and so the residuals at each Newton step will be exactly the same. You can verify this by comparing the appropriate output files in the <code>Validation</code> directory.</li>
</ul>
<hr  />
<h2><a class="anchor" id="exercises"></a>
Exercises</h2>
<ol type="1">
<li>Investigate the difference between the solutions for the multi-domain and single-domain problems by continuing to refine until the solutions are fully-converged to a given error tolerance. What is the difference in total number of degrees of freedom? What is the difference in solution time? What is the difference between the two solutions? <br  />
 <br  />
<br  />
</li>
<li>Investigate double-diffusive convection by adding another advection-diffusion mesh to the problem that interpolates a concentration field. Examples may be found in the <a href="../../../../demo_drivers/multi_physics/double_diffusive_convection">double_diffusive_convection </a> directory.</li>
</ol>
<hr  />
 <hr  />
 <h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory:<br  />
<br  />
<center> <a href="../../../../demo_drivers/multi_physics/boussinesq_convection">demo_drivers/multi_physics/boussinesq_convection </a> </center> <br  />
<br  />
 which contains refineable and non-refineable multi-domain versions of the Boussinesq convection problem. <br  />
<br  />
</li>
<li>The full driver code for the problem described in this tutorial is:<br  />
<br  />
<center> <a href="
../../../../
demo_drivers/multi_physics/boussinesq_convection/multi_domain_ref_b_convection.cc
">demo_drivers/multi_physics/boussinesq_convection/multi_domain_ref_b_convection.cc </a> </center> <br  />
<br  />
</li>
<li>The corresponding driver code for the non-refineable version of the problem is:<br  />
<br  />
<center> <a href="
../../../../
demo_drivers/multi_physics/boussinesq_convection/multi_domain_boussinesq_convection.cc
">demo_drivers/multi_physics/boussinesq_convection/multi_domain_boussinesq_convection.cc </a> </center><br  />
</li>
<li>The source code for the elements is in: <br  />
<br  />
<center> <a href="../../../../src/multi_physics/multi_domain_boussinesq_elements.h">src/multi_physics/multi_domain_boussinesq_elements.h</a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:32:34
        </div>
      </div>
    </footer>
</body>
</html>
