<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Refineable Boussinesq Convection: Combining Refineable Navier&ndash;Stokes and Advection&ndash;Diffusion equations</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.8 -->
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Refineable Boussinesq Convection: Combining Refineable Navier&ndash;Stokes and Advection&ndash;Diffusion equations </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="cells.gif" alt=""/>
<div class="caption">
Steady Convection Rolls: contours of temperature and element boundaries for a two-dimensional domain heated from below at Ra = 1800 </div></div>
 <p>We study convection of an incompressible Newtonian fluid heated from below in a two-dimensional domain of height <img class="formulaInl" alt="$ H $" src="form_0.png" width="11" height="10"/> : the B&eacute;nard problem. The lower wall is maintained at a temperature <img class="formulaInl" alt="$ \theta_{bottom} $" src="form_1.png" width="36" height="13"/> and the upper wall is maintained at a temperature <img class="formulaInl" alt="$ \theta_{top} $" src="form_2.png" width="20" height="14"/>, where <img class="formulaInl" alt="$ \theta_{bottom} &gt;
 \theta_{top} $" src="form_3.png" width="74" height="14"/>. The theory is described <a href="../../b_convection/html/index.html">the non-refineable version of the problem. </a></p>
<p>In this example, we solve the same physical problem, but using refineable elements. As an alternative to the time-stepping procedure adopted previously, we perturb the trivial steady-state solution and re-solve the steady equations to obtain the steady symmetry-broken solution. In what follows, we shall only describe those parts of the code that differ from the non-refineable version.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="main"></a>
The driver code</h1>
<p>We start by setting the direction of gravity, and constructing the problem using the new <a class="el" href="index.html#element">RefineableBuoyantQCrouzeixRaviartElements</a>, described <a href="#element">below.</a></p>
 <div class="fragment"><div class="line"><span class="comment">//===============start_of_main========================================</span></div>
<div class="line"><span class="comment">/// Driver code for 2D Boussinesq convection problem with </span><span class="comment"></span></div>
<div class="line"><span class="comment">/// adaptivity.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="multi__domain__ref__b__convection_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set the direction of gravity</span></div>
<div class="line"> <a class="code hl_function" href="namespaceGlobal__Physical__Variables.html#a42f4a0aee37dbb36186267931c614053">Global_Physical_Variables::Direction_of_gravity</a>[0] = 0.0;</div>
<div class="line"> <a class="code hl_function" href="namespaceGlobal__Physical__Variables.html#a42f4a0aee37dbb36186267931c614053">Global_Physical_Variables::Direction_of_gravity</a>[1] = -1.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create the problem with 2D nine-node refineable elements.</span></div>
<div class="line"> <a class="code hl_class" href="classRefineableConvectionProblem.html">RefineableConvectionProblem</a>&lt;</div>
<div class="line">  RefineableBuoyantQCrouzeixRaviartElement&lt;2&gt; &gt; problem;</div>
<div class="ttc" id="aclassRefineableConvectionProblem_html"><div class="ttname"><a href="classRefineableConvectionProblem.html">RefineableConvectionProblem</a></div><div class="ttdoc">2D Convection problem on two rectangular domains, discretised with refineable Navier-Stokes and Advec...</div><div class="ttdef"><b>Definition</b> <a href="multi__domain__ref__b__convection_8cc_source.html#l00080">multi_domain_ref_b_convection.cc:81</a></div></div>
<div class="ttc" id="amulti__domain__ref__b__convection_8cc_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="multi__domain__ref__b__convection_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdoc">Driver code for 2D Boussinesq convection problem with adaptivity.</div><div class="ttdef"><b>Definition</b> <a href="multi__domain__ref__b__convection_8cc_source.html#l00464">multi_domain_ref_b_convection.cc:464</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a42f4a0aee37dbb36186267931c614053"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a42f4a0aee37dbb36186267931c614053">Global_Physical_Variables::Direction_of_gravity</a></div><div class="ttdeci">Vector&lt; double &gt; Direction_of_gravity(2)</div><div class="ttdoc">Gravity vector.</div></div>
</div><!-- fragment --><p> As discussed in the <a href="../../b_convection/html/index.html">previous example,</a> a small perturbation is required to force the solution from the trivial steady state of zero velocity and linear temperature variation. Therefore, we add a small perturbation to the vertical velocity on the upper wall before solving the steady problem, allowing for up to two levels of adaptive mesh refinement.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Apply a perturbation to the upper boundary condition to</span></div>
<div class="line"> <span class="comment">// force the solution into the symmetry-broken state.</span></div>
<div class="line"> problem.enable_imperfection();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Solve the problem with (up to) two levels of adaptation</span></div>
<div class="line"> problem.newton_solve(2);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Document the solution</span></div>
<div class="line"> problem.doc_solution();</div>
</div><!-- fragment --><p> Having forced the solution into a non-trivial symmetry-broken state, we switch off the perturbation and re-solve the problem, allowing for another two levels of adaptive refinement. The Newton solver now converges to the unperturbed but symmetry-broken solution shown above.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> <span class="comment">// Make the boundary conditions perfect and solve again. </span></div>
<div class="line"> <span class="comment">// Now the slightly perturbed symmetry broken state computed</span></div>
<div class="line"> <span class="comment">// above is used as the initial condition and the Newton solver</span></div>
<div class="line"> <span class="comment">// converges to the symmetry broken solution, even without</span></div>
<div class="line"> <span class="comment">// the perturbation</span></div>
<div class="line"> problem.disable_imperfection();</div>
<div class="line"> problem.newton_solve(2);</div>
<div class="line"> problem.doc_solution();</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of main</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="problem"></a>
The problem class</h1>
<p>The problem class contains the constructor and (empty) destructor, the usual action functions, and an access function to the specific mesh used in this problem.</p>
 <div class="fragment"><div class="line"><span class="comment">//=======start_of_problem_class=======================================</span></div>
<div class="line"><span class="comment">/// 2D Convection  problem on rectangular domain, discretised </span><span class="comment"></span></div>
<div class="line"><span class="comment">/// with refineable elements. The specific type</span></div>
<div class="line"><span class="comment">/// of element is specified via the template parameter.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt; </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classRefineableConvectionProblem.html">RefineableConvectionProblem</a> : <span class="keyword">public</span> Problem</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Constructor</span></div>
<div class="line"><span class="comment"></span> <a class="code hl_function" href="classRefineableConvectionProblem.html#a97e661986093402bf55fb6c32b782ddc">RefineableConvectionProblem</a>();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Destructor. Empty</span></div>
<div class="line"><span class="comment"></span> <a class="code hl_function" href="classRefineableConvectionProblem.html#a43fc2693230601928578d5b0c6380943">~RefineableConvectionProblem</a>() {}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Update the problem specs before solve:</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code hl_function" href="classRefineableConvectionProblem.html#a694f0be87fe09a30d94e92acfce85eee">actions_before_newton_solve</a>();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Update the problem after solve (empty)</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code hl_function" href="classRefineableConvectionProblem.html#a13bda5e5e75928efa88433902ccab7ee">actions_after_newton_solve</a>(){}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Overloaded version of the problem&#39;s access function to </span></div>
<div class="line"><span class="comment"> /// the mesh. Recasts the pointer to the base Mesh object to </span></div>
<div class="line"><span class="comment"> /// the actual mesh type.</span></div>
<div class="line"><span class="comment"></span> RectangularQuadMesh&lt;ELEMENT&gt;* <a class="code hl_function" href="classRefineableConvectionProblem.html#ab39a08708e152e4f119832dc5e1bc96c">mesh_pt</a>() </div>
<div class="line">  {</div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span>RectangularQuadMesh&lt;ELEMENT&gt;*<span class="keyword">&gt;</span>(</div>
<div class="line">    Problem::mesh_pt());</div>
<div class="line">  } <span class="comment">//end of access function to specic mesh</span></div>
<div class="ttc" id="aclassRefineableConvectionProblem_html_a13bda5e5e75928efa88433902ccab7ee"><div class="ttname"><a href="classRefineableConvectionProblem.html#a13bda5e5e75928efa88433902ccab7ee">RefineableConvectionProblem::actions_after_newton_solve</a></div><div class="ttdeci">void actions_after_newton_solve()</div><div class="ttdoc">Update the problem after solve (empty)</div><div class="ttdef"><b>Definition</b> <a href="multi__domain__ref__b__convection_8cc_source.html#l00095">multi_domain_ref_b_convection.cc:95</a></div></div>
<div class="ttc" id="aclassRefineableConvectionProblem_html_a43fc2693230601928578d5b0c6380943"><div class="ttname"><a href="classRefineableConvectionProblem.html#a43fc2693230601928578d5b0c6380943">RefineableConvectionProblem::~RefineableConvectionProblem</a></div><div class="ttdeci">~RefineableConvectionProblem()</div><div class="ttdoc">Destructor. Empty.</div><div class="ttdef"><b>Definition</b> <a href="multi__domain__ref__b__convection_8cc_source.html#l00089">multi_domain_ref_b_convection.cc:89</a></div></div>
<div class="ttc" id="aclassRefineableConvectionProblem_html_a694f0be87fe09a30d94e92acfce85eee"><div class="ttname"><a href="classRefineableConvectionProblem.html#a694f0be87fe09a30d94e92acfce85eee">RefineableConvectionProblem::actions_before_newton_solve</a></div><div class="ttdeci">void actions_before_newton_solve()</div><div class="ttdoc">Update the problem specs before solve:</div><div class="ttdef"><b>Definition</b> <a href="multi__domain__ref__b__convection_8cc_source.html#l00364">multi_domain_ref_b_convection.cc:364</a></div></div>
<div class="ttc" id="aclassRefineableConvectionProblem_html_a97e661986093402bf55fb6c32b782ddc"><div class="ttname"><a href="classRefineableConvectionProblem.html#a97e661986093402bf55fb6c32b782ddc">RefineableConvectionProblem::RefineableConvectionProblem</a></div><div class="ttdeci">RefineableConvectionProblem()</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition</b> <a href="multi__domain__ref__b__convection_8cc_source.html#l00186">multi_domain_ref_b_convection.cc:187</a></div></div>
<div class="ttc" id="aclassRefineableConvectionProblem_html_ab39a08708e152e4f119832dc5e1bc96c"><div class="ttname"><a href="classRefineableConvectionProblem.html#ab39a08708e152e4f119832dc5e1bc96c">RefineableConvectionProblem::mesh_pt</a></div><div class="ttdeci">RectangularQuadMesh&lt; ELEMENT &gt; * mesh_pt()</div><div class="ttdoc">Overloaded version of the problem's access function to the mesh. Recasts the pointer to the base Mesh...</div><div class="ttdef"><b>Definition</b> <a href="refineable__b__convection_8cc_source.html#l00104">refineable_b_convection.cc:104</a></div></div>
</div><!-- fragment --><p> No specific action is required before the adaptation but following the mesh adaptation exactly one pressure degree of freedom must be pinned in the problem. (Since the domain is enclosed the pressure is only determined up to an arbitrary constant.) The pressure degree of freedom that was pinned before the adaptation may have disappeared during the adaptation, therefore the constraint must be re-applied. However, we unpin all pressure degrees of freedom first to ensure that we do not accidentally pin two pressure degrees of freedom.</p>
<div class="fragment"><div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Actions before adapt:(empty)</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> actions_before_adapt() {}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Actions after adaptation,</span></div>
<div class="line"><span class="comment"> /// Re-pin a single pressure degree of freedom</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> actions_after_adapt()</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Unpin all the pressures to avoid pinning two pressures</span></div>
<div class="line">   RefineableNavierStokesEquations&lt;2&gt;::</div>
<div class="line">    unpin_all_pressure_dofs(mesh_pt()-&gt;element_pt());</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Pin the zero-th pressure dof in the zero-th element and set</span></div>
<div class="line">   <span class="comment">// its value to zero</span></div>
<div class="line">   fix_pressure(0,0,0.0);</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Fix pressure in element e at pressure dof pdof and set to pvalue</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> fix_pressure(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;e, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;pdof, </div>
<div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;pvalue)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Cast to specific element and fix pressure</span></div>
<div class="line">   <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(mesh_pt()-&gt;element_pt(e))-&gt;</div>
<div class="line">    fix_pressure(pdof,pvalue);</div>
<div class="line">  } <span class="comment">// end_of_fix_pressure</span></div>
</div><!-- fragment --><p> The remaining member functions provide access to the boolean flag that controls the application of the imperfection, and document the solution:</p>
<div class="fragment"><div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Set the</span></div>
<div class="line"><span class="comment"> /// boundary condition on the upper wall to be perturbed slightly</span></div>
<div class="line"><span class="comment"> /// to force the solution into the symmetry broken state.</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> enable_imperfection() {Imperfect = <span class="keyword">true</span>;}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Set the</span></div>
<div class="line"><span class="comment"> /// boundary condition on the upper wall to be unperturbed.</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> disable_imperfection() {Imperfect = <span class="keyword">false</span>;}</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Doc the solution.</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> doc_solution();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// DocInfo object</span></div>
<div class="line"><span class="comment"></span> DocInfo Doc_info;</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Is the boundary condition imperfect or not</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">bool</span> Imperfect;</div>
<div class="line"> </div>
<div class="line">}; <span class="comment">// end of problem class</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="const"></a>
The constructor</h1>
<p>We pass the element type as a template parameter to the problem constructor, which has no arguments. The constructor builds a coarse initial <code>RefineableRectangularQuadMesh</code>, using <img class="formulaInl" alt="$ 9 \times 8 $" src="form_4.png" width="29" height="9"/> elements and allocates a spatial error estimator that is attached to the mesh.</p>
 <div class="fragment"><div class="line"><span class="comment">//=======start_of_constructor=============================================</span></div>
<div class="line"><span class="comment">/// Constructor for adaptive thermal convection problem</span></div>
<div class="line"><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><a class="code hl_function" href="classRefineableConvectionProblem.html#a97e661986093402bf55fb6c32b782ddc">RefineableConvectionProblem&lt;ELEMENT&gt;::</a></div>
<div class="line"><a class="code hl_function" href="classRefineableConvectionProblem.html#a97e661986093402bf55fb6c32b782ddc">RefineableConvectionProblem</a>() : Imperfect(false)</div>
<div class="line">{ </div>
<div class="line"> <span class="comment">// Set output directory</span></div>
<div class="line"> Doc_info.set_directory(<span class="stringliteral">&quot;RESLT&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// # of elements in x-direction</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_x=9;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// # of elements in y-direction</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_y=8;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Domain length in x-direction</span></div>
<div class="line"> <span class="keywordtype">double</span> l_x=3.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Domain length in y-direction</span></div>
<div class="line"> <span class="keywordtype">double</span> l_y=1.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build the mesh</span></div>
<div class="line"> RefineableRectangularQuadMesh&lt;ELEMENT&gt;* cast_mesh_pt =</div>
<div class="line">  <span class="keyword">new</span> RefineableRectangularQuadMesh&lt;ELEMENT&gt;(n_x,n_y,l_x,l_y);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Set the problem&#39;s mesh pointer</span></div>
<div class="line"> Problem::mesh_pt() = cast_mesh_pt;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create/set error estimator</span></div>
<div class="line"> cast_mesh_pt-&gt;spatial_error_estimator_pt()=<span class="keyword">new</span> Z2ErrorEstimator;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set error targets for adaptive refinement</span></div>
<div class="line"> cast_mesh_pt-&gt;max_permitted_error()=0.5e-3; </div>
<div class="line"> cast_mesh_pt-&gt;min_permitted_error()=0.5e-4; </div>
</div><!-- fragment --><p> Next, the boundary constraints are imposed. We pin all velocities and the temperature on the top and bottom walls and pin only the horizontal velocity on the sidewalls. As discussed above, a single pressure value must be pinned to ensure a unique solution.</p>
<div class="fragment"><div class="line"> <span class="comment">// Set the boundary conditions for this problem: All nodes are</span></div>
<div class="line"> <span class="comment">// free by default -- only need to pin the ones that have Dirichlet </span></div>
<div class="line"> <span class="comment">// conditions here</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Loop over the boundaries</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> num_bound = mesh_pt()-&gt;nboundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibound=0;ibound&lt;num_bound;ibound++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Set the maximum index to be pinned (all values by default)</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> val_max=3;</div>
<div class="line">   <span class="comment">//If we are on the side-walls, the v-velocity and temperature</span></div>
<div class="line">   <span class="comment">//satisfy natural boundary conditions, so we only pin the</span></div>
<div class="line">   <span class="comment">//first value</span></div>
<div class="line">   <span class="keywordflow">if</span>((ibound==1) || (ibound==3)) {val_max=1;}</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Loop over the number of nodes on the boundry</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> num_nod= mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">//Loop over the desired values stored at the nodes and pin</span></div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;val_max;j++)</div>
<div class="line">      {</div>
<div class="line">       mesh_pt()-&gt;boundary_node_pt(ibound,inod)-&gt;pin(j);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Pin the zero-th pressure value in the zero-th element and</span></div>
<div class="line"> <span class="comment">// set its value to zero.</span></div>
<div class="line"> fix_pressure(0,0,0.0);</div>
</div><!-- fragment --><p> We complete the build of the elements by setting the pointers to the physical parameters and finally assign the equation numbers</p>
<div class="fragment"><div class="line"> <span class="keywordtype">unsigned</span> n_element = mesh_pt()-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_element;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from GeneralsedElement to the present element</span></div>
<div class="line">   ELEMENT *el_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(mesh_pt()-&gt;element_pt(i));</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set the Peclet number</span></div>
<div class="line">   el_pt-&gt;pe_pt() = &amp;<a class="code hl_variable" href="namespaceGlobal__Physical__Variables.html#ad4cdf142ba50635d62ac4c614f445af7">Global_Physical_Variables::Peclet</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set the Peclet Strouhal number</span></div>
<div class="line">   el_pt-&gt;pe_st_pt() = &amp;<a class="code hl_variable" href="namespaceGlobal__Physical__Variables.html#ad4cdf142ba50635d62ac4c614f445af7">Global_Physical_Variables::Peclet</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set the Reynolds number (1/Pr in our non-dimensionalisation)</span></div>
<div class="line">   el_pt-&gt;re_pt() = &amp;<a class="code hl_variable" href="namespaceGlobal__Physical__Variables.html#a87796c9f402e6f90c07cf5ba0db4367e">Global_Physical_Variables::Inverse_Prandtl</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set ReSt (also 1/Pr in our non-dimensionalisation)</span></div>
<div class="line">   el_pt-&gt;re_st_pt() = &amp;<a class="code hl_variable" href="namespaceGlobal__Physical__Variables.html#a87796c9f402e6f90c07cf5ba0db4367e">Global_Physical_Variables::Inverse_Prandtl</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set the Rayleigh number</span></div>
<div class="line">   el_pt-&gt;ra_pt() = &amp;<a class="code hl_variable" href="namespaceGlobal__Physical__Variables.html#a637fd2a6a7c5b34ed3288300d8bf84b7">Global_Physical_Variables::Rayleigh</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Set Gravity vector</span></div>
<div class="line">   el_pt-&gt;g_pt() = &amp;<a class="code hl_function" href="namespaceGlobal__Physical__Variables.html#a42f4a0aee37dbb36186267931c614053">Global_Physical_Variables::Direction_of_gravity</a>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Setup equation numbering scheme</span></div>
<div class="line"> cout &lt;&lt;<span class="stringliteral">&quot;Number of equations: &quot;</span> &lt;&lt; assign_eqn_numbers() &lt;&lt; endl; </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of constructor</span></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a637fd2a6a7c5b34ed3288300d8bf84b7"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a637fd2a6a7c5b34ed3288300d8bf84b7">Global_Physical_Variables::Rayleigh</a></div><div class="ttdeci">double Rayleigh</div><div class="ttdoc">Rayleigh number, set to be greater than the threshold for linear instability.</div><div class="ttdef"><b>Definition</b> <a href="boussinesq__convection_8cc_source.html#l00058">boussinesq_convection.cc:58</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a87796c9f402e6f90c07cf5ba0db4367e"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a87796c9f402e6f90c07cf5ba0db4367e">Global_Physical_Variables::Inverse_Prandtl</a></div><div class="ttdeci">double Inverse_Prandtl</div><div class="ttdoc">1/Prandtl number</div><div class="ttdef"><b>Definition</b> <a href="boussinesq__convection_8cc_source.html#l00054">boussinesq_convection.cc:54</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_ad4cdf142ba50635d62ac4c614f445af7"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#ad4cdf142ba50635d62ac4c614f445af7">Global_Physical_Variables::Peclet</a></div><div class="ttdeci">double Peclet</div><div class="ttdoc">Peclet number (identically one from our non-dimensionalisation)</div><div class="ttdef"><b>Definition</b> <a href="boussinesq__convection_8cc_source.html#l00051">boussinesq_convection.cc:51</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h2><a class="anchor" id="fix_p"></a>
The function fix_pressure(...)</h2>
<p>This function is a simple wrapper to the element's <code>fix_pressure(...)</code> function.  </p><div class="fragment"><div class="line"><span class="comment"> /// Fix pressure in element e at pressure dof pdof and set to pvalue</span></div>
<div class="line"> <span class="keywordtype">void</span> fix_pressure(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;e, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;pdof, </div>
<div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;pvalue)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Cast to specific element and fix pressure</span></div>
<div class="line">   <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(mesh_pt()-&gt;element_pt(e))-&gt;</div>
<div class="line">    fix_pressure(pdof,pvalue);</div>
<div class="line">  } <span class="comment">// end_of_fix_pressure</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h2><a class="anchor" id="actions_before"></a>
The function actions_before_newton_solve(...)</h2>
<p>The function is used to set the specific values of the Dirichlet boundary conditions. If the boolean flag <code>Imperfect</code> is true then a small mass-conserving imperfection is added to the velocity boundary condition on the top wall.</p>
 <div class="fragment"><div class="line"><span class="comment">//===================start_actions_before_newton_solve===========================</span></div>
<div class="line"><span class="comment">/// Update the problem specs before solve: (Re-)set boundary conditions</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// to include an imperfection (or not) depending on the control flag.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="classRefineableConvectionProblem.html#a694f0be87fe09a30d94e92acfce85eee">RefineableConvectionProblem&lt;ELEMENT&gt;::actions_before_newton_solve</a>()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Loop over the boundaries</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> num_bound = mesh_pt()-&gt;nboundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibound=0;ibound&lt;num_bound;ibound++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Loop over the nodes on boundary </span></div>
<div class="line">   <span class="keywordtype">unsigned</span> num_nod=mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Get pointer to node</span></div>
<div class="line">     Node* nod_pt=mesh_pt()-&gt;boundary_node_pt(ibound,inod);</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//Set the number of velocity components</span></div>
<div class="line">     <span class="keywordtype">unsigned</span> vel_max=2;</div>
<div class="line">     <span class="comment">//If we are on the side walls we only pin the x-velocity.</span></div>
<div class="line">     <span class="keywordflow">if</span>((ibound==1) || (ibound==3)) {vel_max = 1;}</div>
<div class="line">     <span class="comment">//Set the pinned velocities to zero</span></div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;vel_max;j++) {nod_pt-&gt;set_value(j,0.0);}</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//If we are on the top boundary</span></div>
<div class="line">     <span class="keywordflow">if</span>(ibound==2) </div>
<div class="line">      {</div>
<div class="line">       <span class="comment">//Set the temperature to -0.5 (cooled)</span></div>
<div class="line">       nod_pt-&gt;set_value(2,-0.5);</div>
<div class="line">       <span class="comment">//Add small velocity imperfection if desired</span></div>
<div class="line">       <span class="keywordflow">if</span>(Imperfect)</div>
<div class="line">        {</div>
<div class="line">         <span class="comment">//Read out the x position</span></div>
<div class="line">         <span class="keywordtype">double</span> x = nod_pt-&gt;x(0);</div>
<div class="line">         <span class="comment">//Set a sinusoidal perturbation in the vertical velocity</span></div>
<div class="line">         <span class="comment">//This perturbation is mass conserving</span></div>
<div class="line">         <span class="keywordtype">double</span> value = sin(2.0*3.141592654*x/3.0);</div>
<div class="line">         nod_pt-&gt;set_value(1,value);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//If we are on the bottom boundary, set the temperature</span></div>
<div class="line">     <span class="comment">//to 0.5 (heated)</span></div>
<div class="line">     <span class="keywordflow">if</span>(ibound==0) {nod_pt-&gt;set_value(2,0.5);}</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// end of actions before solve</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h2><a class="anchor" id="doc"></a>
The function doc_solution(...)</h2>
<p>This function writes the complete velocity, pressure and temperature fields to a file in the output directory specified in the <code>DocInfo</code> object.</p>
 <div class="fragment"><div class="line"><span class="comment">//====================start_of_doc_solution===============================</span></div>
<div class="line"><span class="comment">/// Doc the solution</span></div>
<div class="line"><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="classRefineableConvectionProblem.html#a47efcb3467931e13e12687303135e38b">RefineableConvectionProblem&lt;ELEMENT&gt;::doc_solution</a>()</div>
<div class="line">{ </div>
<div class="line"> <span class="comment">//Declare an output stream and filename</span></div>
<div class="line"> ofstream some_file;</div>
<div class="line"> <span class="keywordtype">char</span> filename[100];</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Number of plot points: npts x npts</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> npts=5;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output solution </span></div>
<div class="line"> <span class="comment">//-----------------</span></div>
<div class="line"> snprintf(filename, <span class="keyword">sizeof</span>(filename), <span class="stringliteral">&quot;%s/soln%i.dat&quot;</span>,Doc_info.directory().c_str(),</div>
<div class="line">         Doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> mesh_pt()-&gt;output(some_file,npts);</div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> Doc_info.number()++;</div>
<div class="line">} <span class="comment">// end of doc</span></div>
<div class="ttc" id="aclassRefineableConvectionProblem_html_a47efcb3467931e13e12687303135e38b"><div class="ttname"><a href="classRefineableConvectionProblem.html#a47efcb3467931e13e12687303135e38b">RefineableConvectionProblem::doc_solution</a></div><div class="ttdeci">void doc_solution()</div><div class="ttdoc">Doc the solution.</div><div class="ttdef"><b>Definition</b> <a href="multi__domain__ref__b__convection_8cc_source.html#l00432">multi_domain_ref_b_convection.cc:432</a></div></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="element"></a>
Creating the new RefineableBouyantQCrouzeixRaviartElement class</h1>
<p>As in the <a href="../../b_convection/html/index.html">non-refineable version of the problem</a> we create the refineable element <code>RefineableBuoyantQCrouzeixRaviartElement</code> by multiple inheritance from the <code>RefineableQCrouzeixRaviartElement</code> and <code>RefineableQAdvectionDiffusionElement:</code> </p>
 <div class="fragment"><div class="line">  <span class="comment">//============start_element_class============================================</span></div>
<div class="line"><span class="comment">  /// A RefineableElement class that solves the</span><span class="comment"></span></div>
<div class="line"><span class="comment">  /// Boussinesq approximation of the Navier--Stokes</span></div>
<div class="line"><span class="comment">  /// and energy equations by coupling two pre-existing classes.</span></div>
<div class="line"><span class="comment">  /// The RefineableQAdvectionDiffusionElement</span></div>
<div class="line"><span class="comment">  /// with bi-quadratic interpolation for the</span></div>
<div class="line"><span class="comment">  /// scalar variable (temperature) and</span></div>
<div class="line"><span class="comment">  /// RefineableQCrouzeixRaviartElement which solves the Navier--Stokes</span></div>
<div class="line"><span class="comment">  /// equations using bi-quadratic interpolation for the velocities and a</span></div>
<div class="line"><span class="comment">  /// discontinuous bi-linear interpolation for the pressure. Note that we are</span></div>
<div class="line"><span class="comment">  /// free to choose the order in which we store the variables at the nodes. In</span></div>
<div class="line"><span class="comment">  /// this case we choose to store the variables in the order fluid velocities</span></div>
<div class="line"><span class="comment">  /// followed by temperature. We must, therefore, overload the function</span></div>
<div class="line"><span class="comment">  /// AdvectionDiffusionEquations&lt;DIM&gt;::u_index_adv_diff() to indicate that</span></div>
<div class="line"><span class="comment">  /// the temperature is stored at the DIM-th position not the 0-th. We do not</span></div>
<div class="line"><span class="comment">  /// need to overload the corresponding function in the</span></div>
<div class="line"><span class="comment">  /// NavierStokesEquations&lt;DIM&gt; class because the velocities are stored</span></div>
<div class="line"><span class="comment">  /// first. Finally, we choose to use the flux-recovery calculation from the</span></div>
<div class="line"><span class="comment">  /// fluid velocities to provide the error used in the mesh adaptation.</span></div>
<div class="line"><span class="comment"></span>  <span class="comment">//==========================================================================</span></div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> DIM&gt;</div>
<div class="line">  <span class="keyword">class </span>RefineableBuoyantQCrouzeixRaviartElement</div>
<div class="line">    : <span class="keyword">public</span> <span class="keyword">virtual</span> RefineableQAdvectionDiffusionElement&lt;DIM, 3&gt;,</div>
<div class="line">      <span class="keyword">public</span> <span class="keyword">virtual</span> RefineableQCrouzeixRaviartElement&lt;DIM&gt;</div>
<div class="line">  {</div>
</div><!-- fragment --><p>Many of the additional member functions required in the combined multi-physics element are identical to those in the non-refineable version:</p><ul>
<li>the access function to (the pointer to the) Rayleigh number, <code>ra_pt()</code>,</li>
<li>the output functions, <code>output(...)</code>,</li>
<li>the function <code>required_n_value(...)</code> which specifies the number of values required at each node,</li>
<li>the function <code>u_index_adv_diff(...)</code> which specifies the index at which the temperature is stored within the elements' <code>Nodes</code>,</li>
<li>the function <code>get_wind_adv_diff(...)</code> which specifies the "wind" in the advection diffusion equations in terms of the Navier-Stokes velocities,</li>
<li>the function <code>get_body_force_nst(...)</code> which specifies the body force in the Navier-Stokes equations in terms of the temperature.</li>
<li>the two "fill in" function are implemented as in the non-refineable element. The function <code>fill_in_contribution_to_residuals(...)</code> concatenates the contributions from the two underlying elements; the function <code>fill_in_contribution_to_jacobian(...)</code> computes the coupled elemental Jacobian matrix by finite-differencing.</li>
</ul>
<p>We shall only discuss those additional functions that are required in the refineable version of the combined multi-physics element.</p>
<p>Both constituent elements are derived from the <code>ElementWithZ2ErrorEstimator</code> base class and each element provides its own definition of the "Z2-flux" that is used by the Z2 error estimator to compute elemental error estimates. We must decide on a single error estimator for the combined element. We could base the error estimation entirely on the fluid flow, or the temperature field, but instead we shall choose our single error estimate to be the maximum of the fluid and temperature error estimates. The functions required by the <code>Z2ErrorEstimator</code> are overloaded to return all the flux terms associated with both the velocity and temperature fields, with the velocity field terms stored first.</p>
 <div class="fragment"><div class="line"><span class="comment">    /// The recovery order is that of the NavierStokes elements.</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> nrecovery_order()</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">return</span> RefineableQCrouzeixRaviartElement&lt;DIM&gt;::nrecovery_order();</div>
<div class="line">    }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /// The number of Z2 flux terms is the same as that in</span></div>
<div class="line"><span class="comment">    /// the fluid element plus that in the advection-diffusion element</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">unsigned</span> num_Z2_flux_terms()</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">return</span> (</div>
<div class="line">        RefineableQCrouzeixRaviartElement&lt;DIM&gt;::num_Z2_flux_terms() +</div>
<div class="line">        RefineableQAdvectionDiffusionElement&lt;DIM, 3&gt;::num_Z2_flux_terms());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /// Get the Z2 flux by concatenating the fluxes from the fluid and</span></div>
<div class="line"><span class="comment">    /// the advection diffusion elements.</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> get_Z2_flux(<span class="keyword">const</span> Vector&lt;double&gt;&amp; s, Vector&lt;double&gt;&amp; flux)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Find the number of fluid fluxes</span></div>
<div class="line">      <span class="keywordtype">unsigned</span> n_fluid_flux =</div>
<div class="line">        RefineableQCrouzeixRaviartElement&lt;DIM&gt;::num_Z2_flux_terms();</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Fill in the first flux entries as the velocity entries</span></div>
<div class="line">      RefineableQCrouzeixRaviartElement&lt;DIM&gt;::get_Z2_flux(s, flux);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Find the number of temperature fluxes</span></div>
<div class="line">      <span class="keywordtype">unsigned</span> n_temp_flux =</div>
<div class="line">        RefineableQAdvectionDiffusionElement&lt;DIM, 3&gt;::num_Z2_flux_terms();</div>
<div class="line">      Vector&lt;double&gt; temp_flux(n_temp_flux);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Get the temperature flux</span></div>
<div class="line">      RefineableQAdvectionDiffusionElement&lt;DIM, 3&gt;::get_Z2_flux(s, temp_flux);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Add the temperature flux to the end of the flux vector</span></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n_temp_flux; i++)</div>
<div class="line">      {</div>
<div class="line">        flux[n_fluid_flux + i] = temp_flux[i];</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    } <span class="comment">// end of get_Z2_flux</span></div>
</div><!-- fragment --><p> The default behaviour of the Z2 error estimator is to combine all components of the flux vector into a single compound flux. In the present multi-physics element, we instead define two compound fluxes: one corresponding to the combined temperature fluxes and the other to the combined velocity field fluxes. The flux components associated with each compound flux must specified by overloading the function <code>get_Z2_compound_flux_indices</code> which returns a vector of the same length as the number of flux components, containing the index of the compound flux to which the flux component contributes.</p>
 <div class="fragment"><div class="line"><span class="comment">    /// The number of compound fluxes is two (one for the fluid and</span></div>
<div class="line"><span class="comment">    /// one for the temperature)</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> ncompound_fluxes()</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">return</span> 2;</div>
<div class="line">    }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /// Fill in which flux components are associated with the fluid</span></div>
<div class="line"><span class="comment">    /// measure and which are associated with the temperature measure</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> get_Z2_compound_flux_indices(Vector&lt;unsigned&gt;&amp; flux_index)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Find the number of fluid fluxes</span></div>
<div class="line">      <span class="keywordtype">unsigned</span> n_fluid_flux =</div>
<div class="line">        RefineableQCrouzeixRaviartElement&lt;DIM&gt;::num_Z2_flux_terms();</div>
<div class="line">      <span class="comment">// Find the number of temperature fluxes</span></div>
<div class="line">      <span class="keywordtype">unsigned</span> n_temp_flux =</div>
<div class="line">        RefineableQAdvectionDiffusionElement&lt;DIM, 3&gt;::num_Z2_flux_terms();</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// The fluid fluxes are first</span></div>
<div class="line">      <span class="comment">// The values of the flux_index vector are zero on entry, so we</span></div>
<div class="line">      <span class="comment">// could omit this line</span></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n_fluid_flux; i++)</div>
<div class="line">      {</div>
<div class="line">        flux_index[i] = 0;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Set the temperature fluxes (the last set of fluxes</span></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n_temp_flux; i++)</div>
<div class="line">      {</div>
<div class="line">        flux_index[n_fluid_flux + i] = 1;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    } <span class="comment">// end of get_Z2_compound_flux_indices</span></div>
</div><!-- fragment --><p> The <code>Z2ErrorEstimator</code> calculates the error estimates for each compound flux. The individual error estimates are then combined to a single error estimate by the function <code>Z2ErrorEstimator::get_combined_error_estimate()</code>. By default the single error estimate is chosen to be the maximum of all calculated error estimates. Alternative user-defined functions can be specified via the function pointer <code>Z2ErrorEstimator::CombinedErrorEstimateFctPt&amp;</code> <code>combined_error_fct_pt()</code>, see <a class="el" href="index.html#comments">Comments</a> for a more detailed discussion of this aspect. <br  />
</p>
<p>The vertex nodes are defined by the underlying geometric element, but require a final overload to prevent ambiguities:</p>
 <div class="fragment"><div class="line"><span class="comment">    /// Number of vertex nodes in the element is obtained from the</span></div>
<div class="line"><span class="comment">    /// geometric element.</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> nvertex_node()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> QElement&lt;DIM, 3&gt;::nvertex_node();</div>
<div class="line">    }</div>
</div><!-- fragment -->  <div class="fragment"><div class="line"><span class="comment">    /// Pointer to the j-th vertex node in the element,</span></div>
<div class="line"><span class="comment">    /// Call the geometric element&#39;s function.</span></div>
<div class="line">    Node* vertex_node_pt(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; j)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> QElement&lt;DIM, 3&gt;::vertex_node_pt(j);</div>
<div class="line">    }</div>
</div><!-- fragment --><p> The number of continuously interpolated values is <code>DIM</code> <code>+</code> <code>1</code>: <code>DIM</code> velocity components and one temperature.  </p><div class="fragment"><div class="line">    <span class="keywordtype">unsigned</span> ncont_interpolated_values() const</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">return</span> DIM + 1;</div>
<div class="line">    }</div>
</div><!-- fragment --><p> The two versions of the <code>get_interpolated_values(...)</code> function must return the continuously interpolated variables at a specified position within the element:</p>
 <div class="fragment"><div class="line"><span class="comment">    /// Get the continuously interpolated values at the local coordinate</span></div>
<div class="line"><span class="comment">    /// s. We choose to put the fluid velocities first, followed by the</span><span class="comment"></span></div>
<div class="line"><span class="comment">    /// temperature.</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> get_interpolated_values(<span class="keyword">const</span> Vector&lt;double&gt;&amp; s,</div>
<div class="line">                                 Vector&lt;double&gt;&amp; values)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Storage for the fluid velocities</span></div>
<div class="line">      Vector&lt;double&gt; nst_values;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Get the fluid velocities from the fluid element</span></div>
<div class="line">      RefineableQCrouzeixRaviartElement&lt;DIM&gt;::get_interpolated_values(</div>
<div class="line">        s, nst_values);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Storage for the temperature</span></div>
<div class="line">      Vector&lt;double&gt; advection_values;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Get the temperature from the advection-diffusion element</span></div>
<div class="line">      RefineableQAdvectionDiffusionElement&lt;DIM, 3&gt;::get_interpolated_values(</div>
<div class="line">        s, advection_values);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Add the fluid velocities to the values vector</span></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; DIM; i++)</div>
<div class="line">      {</div>
<div class="line">        values.push_back(nst_values[i]);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Add the concentration to the end</span></div>
<div class="line">      values.push_back(advection_values[0]);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /// Get all continuously interpolated values at the local</span></div>
<div class="line"><span class="comment">    /// coordinate s at time level t (t=0: present; t&gt;0: previous).</span></div>
<div class="line"><span class="comment">    /// We choose to put the fluid velocities first, followed by the</span></div>
<div class="line"><span class="comment">    /// temperature</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> get_interpolated_values(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; t,</div>
<div class="line">                                 <span class="keyword">const</span> Vector&lt;double&gt;&amp; s,</div>
<div class="line">                                 Vector&lt;double&gt;&amp; values)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Storage for the fluid velocities</span></div>
<div class="line">      Vector&lt;double&gt; nst_values;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Get the fluid velocities from the fluid element</span></div>
<div class="line">      RefineableQCrouzeixRaviartElement&lt;DIM&gt;::get_interpolated_values(</div>
<div class="line">        t, s, nst_values);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Storage for the temperature</span></div>
<div class="line">      Vector&lt;double&gt; advection_values;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Get the temperature from the advection-diffusion element</span></div>
<div class="line">      RefineableQAdvectionDiffusionElement&lt;DIM, 3&gt;::get_interpolated_values(</div>
<div class="line">        s, advection_values);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Add the fluid velocities to the values vector</span></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; DIM; i++)</div>
<div class="line">      {</div>
<div class="line">        values.push_back(nst_values[i]);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Add the concentration to the end</span></div>
<div class="line">      values.push_back(advection_values[0]);</div>
<div class="line"> </div>
<div class="line">    } <span class="comment">// end of get_interpolated_values</span></div>
</div><!-- fragment --><p> Finally, the setup and build functions must call the build functions of the two constituent elements. In addition, the pointer to the Rayleigh number must be passed to the sons after refinement.</p>
 <div class="fragment"><div class="line"><span class="comment">    /// The additional hanging node information must be set up</span></div>
<div class="line"><span class="comment">    /// for both single-physics elements.</span></div>
<div class="line">    <span class="keywordtype">void</span> further_setup_hanging_nodes()</div>
<div class="line">    {</div>
<div class="line">      RefineableQCrouzeixRaviartElement&lt;DIM&gt;::further_setup_hanging_nodes();</div>
<div class="line">      RefineableQAdvectionDiffusionElement&lt;DIM,</div>
<div class="line">                                           3&gt;::further_setup_hanging_nodes();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /// Call the rebuild_from_sons functions for each of the</span></div>
<div class="line"><span class="comment">    /// constituent multi-physics elements.</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> rebuild_from_sons(Mesh*&amp; mesh_pt)</div>
<div class="line">    {</div>
<div class="line">      RefineableQAdvectionDiffusionElement&lt;DIM, 3&gt;::rebuild_from_sons(mesh_pt);</div>
<div class="line">      RefineableQCrouzeixRaviartElement&lt;DIM&gt;::rebuild_from_sons(mesh_pt);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /// Call the underlying single-physics element&#39;s further_build()</span></div>
<div class="line"><span class="comment">    /// functions and make sure that the pointer to the Rayleigh number</span></div>
<div class="line"><span class="comment">    /// is passed to the sons</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> further_build()</div>
<div class="line">    {</div>
<div class="line">      RefineableQCrouzeixRaviartElement&lt;DIM&gt;::further_build();</div>
<div class="line">      RefineableQAdvectionDiffusionElement&lt;DIM, 3&gt;::further_build();</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Cast the pointer to the father element to the specific</span></div>
<div class="line">      <span class="comment">// element type</span></div>
<div class="line">      RefineableBuoyantQCrouzeixRaviartElement&lt;DIM&gt;* cast_father_element_pt =</div>
<div class="line">        <span class="keyword">dynamic_cast&lt;</span>RefineableBuoyantQCrouzeixRaviartElement&lt;DIM&gt;*<span class="keyword">&gt;</span>(</div>
<div class="line">          this-&gt;father_element_pt());</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Set the pointer to the Rayleigh number to be the same as that in</span></div>
<div class="line">      <span class="comment">// the father</span></div>
<div class="line">      this-&gt;Ra_pt = cast_father_element_pt-&gt;ra_pt();</div>
<div class="line">    } <span class="comment">// end of further build</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="comm_and_exercises"></a>
Comments and Exercises</h1>
<h2><a class="anchor" id="comments"></a>
Comments</h2>
<ul>
<li><b>Error estimation for multi-physics elements</b><br  />
<br  />
 The error estimation for the combined multi-physics element is performed with the <code>Z2ErrorEstimator</code> which computes an error estimate based Zienkiewicz and Zhu's flux recovery technique, using the elemental "Z2 flux" defined in the pure virtual function <code>get_Z2_flux(...)</code>. The two constituent elements already provide their own implementation of this function: <br  />
<br  />
<ul>
<li>In the <code>RefineableQAdvectionDiffusionElement</code> the temperature gradient is used as the flux.<br  />
<br  />
</li>
<li>In the <code>RefineableQCrouzeixRaviartElement</code> the flux is defined by the components of the fluid's rate of strain tensor. <br  />
<br  />
</li>
</ul>
It is not obvious what combination of these flux terms should be used to compute the error estimates for the combined multi-physics element. The most general option would be to combine the two flux vectors, possibly using a weighting factor to control the relative importance of the various components. <br  />
<br  />
 In the example above, we chose an error estimate that was the maximum value of the individual error estimates for the Navier-Stokes flux and the temperature flux. Refinement will be performed if either of the single-physics error estimates are above the chosen thresholds. It is also possible to base the error estimation entirely on the Navier-Stokes fluxes; an appropriate choice for problems in which the variations in the velocity field are expected to be much more rapid than those in the temperature field. Alternatively, <br  />
 the error estimation could be based exclusively on the temperature field; a choice that would be appropriate for problems with thin thermal boundary layers. The different error estimates can all be specified by user-defined functions that combine the vector of compound-flux error estimates into a single number. For example, the function <div class="fragment"><div class="line"><span class="keywordtype">double</span> navier_stokes_flux_error(<span class="keyword">const</span> Vector&lt;double&gt; &amp;errors)</div>
<div class="line"> {<span class="keywordflow">return</span> errors[0];}</div>
</div><!-- fragment --> specifies that the combined error estimate is the first of the compound error estimates &mdash; the error estimate for the Navier&ndash;Stokes equations. <br  />
<br  />
 In the current example both fields vary very smoothly, and as a result spatial adaptivity is not really required in this problem. This is why we set a very narrow range of target errors &ndash; if the default targets are used, <code>oomph-lib</code> refines the mesh uniformly.</li>
</ul>
<h2><a class="anchor" id="exercises"></a>
Exercises</h2>
<ol type="1">
<li>Confirm that for a Rayleigh number of <img class="formulaInl" alt="$ Ra = 1700 $" src="form_5.png" width="58" height="10"/> the system is stable, i.e. it returns to the trivial state, when the perturbation to the vertical velocity on the upper wall is switched off.<br  />
<br  />
</li>
<li>Re-write the multi-physics elements so that the temperature is stored <b>before</b> the fluid velocities. Confirm that the solution is unchanged in this case.<br  />
<br  />
</li>
<li>Try using <code>RefineableQTaylorHoodElements</code> as the "fluid" element part of the multi-physics elements.</li>
<li>Change the error estimate to be based entirely on the error in the Navier&ndash;Stokes fluxes by using a user-defined function. Is there any difference in the refinement pattern?</li>
</ol>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory:<br  />
<br  />
<center> <a href="../../../../demo_drivers/multi_physics/boussinesq_convection/">demo_drivers/multi_physics/boussinesq_convection/ </a> </center><br  />
</li>
<li>The driver code is: <br  />
<br  />
<center> <a href="../../../../demo_drivers/multi_physics/boussinesq_convection/boussinesq_convection.cc">demo_drivers/multi_physics/boussinesq_convection/boussinesq_convection.cc </a> </center> <br  />
</li>
<li>The source code for the elements is in: <br  />
<br  />
<center> <a href="../../../../src/multi_physics/boussinesq_elements.h">src/multi_physics/boussinesq_elements.h</a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. \ </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Tue Jan 13 2026 16:28:59
        </div>
      </div>
    </footer>
</body>
</html>
