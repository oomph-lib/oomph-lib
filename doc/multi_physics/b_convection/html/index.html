<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Boussinesq Convection: Combining the Navier&ndash;Stokes and Advection&ndash;Diffusion equations</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Boussinesq Convection: Combining the Navier&ndash;Stokes and Advection&ndash;Diffusion equations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="symm_broken.gif" alt=""/>
<div class="caption">
Steady Convection Rolls: contours of temperature and the vector velocity field for a two-dimensional domain heated from below at Ra = 1800 </div></div>
 <p>We study convection of an incompressible Newtonian fluid heated from below in a two-dimensional domain of height <img class="formulaInl" alt="$ H $" src="form_0.png" width="11" height="10"/>: the B&eacute;nard problem. The lower wall is maintained at a temperature <img class="formulaInl" alt="$ \theta_{bottom} $" src="form_1.png" width="36" height="13"/> and the upper wall is maintained at a temperature <img class="formulaInl" alt="$ \theta_{top} $" src="form_2.png" width="20" height="14"/>, where <img class="formulaInl" alt="$ \theta_{bottom} &gt; \theta_{top} $" src="form_3.png" width="74" height="14"/> . The governing equations are the (2D) Navier&ndash;Stokes equations under the Boussinesq approximation, in which all variations in physical properties with temperature are neglected, apart from that of the density in the gravitational-body-force term in the momentum equations. This "buoyancy" term is given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Delta\rho G^{*}_{i}, \]" src="form_4.png" width="36" height="14"/>
</p>
<p> where <img class="formulaInl" alt="$ \Delta\rho $" src="form_5.png" width="16" height="13"/> is the variation in density and <img class="formulaInl" alt="$ G^{*}_{i} $" src="form_6.png" width="14" height="14"/> is the <img class="formulaInl" alt="$ i $" src="form_7.png" width="5" height="9"/> -th component of the gravitational body force. Under the additional assumption that variations in temperature are small, we can use the linear relationship </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Delta\rho = -\alpha\rho_{0}(\theta^{*} - \theta_{0}), \]" src="form_8.png" width="114" height="14"/>
</p>
<p> where <img class="formulaInl" alt="$ \alpha $" src="form_9.png" width="8" height="6"/> is the coefficient of thermal expansion of the fluid, <img class="formulaInl" alt="$ \theta^{*} $" src="form_10.png" width="11" height="10"/> is the (dimensional) temperature and <img class="formulaInl" alt="$ \rho_{0} $" src="form_11.png" width="13" height="9"/> is the density at the reference temperature <img class="formulaInl" alt="$ \theta_{0} $" src="form_12.png" width="10" height="13"/> .</p>
<p>The equations governing the fluid motion are thus the Navier&ndash;Stokes equations with the inclusion of the additional buoyancy term. In Cartesian coordinates, we have </p><center> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \rho_{0} \left (\frac{\partial u^{*}_i}{\partial t^{*}} + u^{*}_j \frac{\partial u^{*}_i}{\partial x^{*}_j} \right) = - \frac{\partial p^{*}}{\partial x^{*}_i} + \left[\rho_{0} - \alpha\rho_{0}(\theta^{*} - \theta_{0})\right] G^{*}_i + \mu_{0} \frac{\partial }{\partial x^{*}_j} \left[ \frac{\partial u^{*}_i}{\partial x^{*}_j} + \frac{\partial u^{*}_j}{\partial x^{*}_i} \right], \]" src="form_13.png" width="429" height="39"/>
</p>
 </center><p> and </p><center> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial u^{*}_i}{\partial x^{*}_i} = 0. \]" src="form_14.png" width="48" height="31"/>
</p>
 </center><p> Here, <img class="formulaInl" alt="$ u^{*}_{i} $" src="form_15.png" width="13" height="14"/> is the <img class="formulaInl" alt="$ i $" src="form_7.png" width="5" height="9"/> -th (dimensional) velocity component and <img class="formulaInl" alt="$ x^{*}_{i} $" src="form_16.png" width="13" height="14"/> is the position in the <img class="formulaInl" alt="$i$" src="form_17.png" width="5" height="9"/>-th coordinate direction; <img class="formulaInl" alt="$ \mu_{0} $" src="form_18.png" width="14" height="9"/> is the dynamic viscosity of the fluid at the reference temperature and <img class="formulaInl" alt="$ t^{*} $" src="form_19.png" width="10" height="10"/> is the dimensional time.</p>
<p>The equation that governs the evolution of the temperature field is the advection-diffusion equation where the "wind" is the fluid velocity. Thus, </p><center> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \theta^{*}}{\partial t^{*}} + u^{*}_{j}\frac{\partial \theta^{*}}{\partial x^{*}_{j}} = \kappa\frac{\partial}{\partial x^{*}_{j}}\left(\frac{\partial \theta^{*}}{\partial x^{*}_{j}}\right),\]" src="form_20.png" width="170" height="39"/>
</p>
 </center><p> where <img class="formulaInl" alt="$ \kappa $" src="form_21.png" width="8" height="6"/> is the (constant) thermal diffusivity of the fluid.</p>
<p>We choose the height of the domain, <img class="formulaInl" alt="$ H $" src="form_0.png" width="11" height="10"/>, as the length scale and let the characteristic thermal diffusion speed over that length, <img class="formulaInl" alt="$ \kappa/H $" src="form_22.png" width="25" height="14"/>, be the velocity scale, so that the P&eacute;clet number, <img class="formulaInl" alt="$ Pe = UH/\kappa = 1 $" src="form_23.png" width="88" height="14"/> . The fluid pressure is non-dimensionalised on the viscous scale, <img class="formulaInl" alt="$ \mu_{0} \kappa/H^{2} $" src="form_24.png" width="44" height="15"/> , and the hydrostatic pressure gradient is included explicitly, so that we work with the dimensionless excess pressure. The temperature is non-dimensionalised so that it is -0.5 at the upper (cooled) wall and 0.5 at the bottom (heated) wall and the reference temperature is then <img class="formulaInl" alt="$ \theta_{0} = (\theta_{top} + \theta_{bottom})/2 $" src="form_25.png" width="123" height="14"/>. Finally, the timescale is chosen to be the thermal diffusion timescale, <img class="formulaInl" alt="$ \kappa/H^{2} $" src="form_26.png" width="30" height="15"/> . Hence </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x^{*}_{i} = x_{i} H, \quad u^{*}_{i} = u_{i} \kappa/H, \quad p^{*} = -\rho_{0} g H x_{2} + \frac{\mu_{0}\kappa}{H^{2}}p,\quad \theta^{*} = \theta_{0} + \theta(\theta_{bottom} - \theta_{top}), \quad t^{*} = \frac{\kappa}{H^{2}}t. \]" src="form_27.png" width="495" height="24"/>
</p>
<p>The governing equations become </p><center> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ Pr^{-1}\left(\frac{\partial u_i}{\partial t} + u_j \frac{\partial u_i}{\partial x_j} \right) = - \frac{\partial p}{\partial x_i} - Ra \theta G_i + \frac{\partial }{\partial x_j} \left[ \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right], \]" src="form_28.png" width="339" height="31"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial u_i}{\partial x_i} = 0, \]" src="form_29.png" width="48" height="29"/>
</p>
 and <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \theta}{\partial t} + u_{j}\frac{\partial \theta}{\partial x_{j}} = \frac{\partial}{\partial x_{j}}\left(\frac{\partial \theta}{\partial x_{j}}\right),\]" src="form_30.png" width="154" height="31"/>
</p>
. </center><p> The appropriate dimensionless numbers are the Prandtl number <img class="formulaInl" alt="$ Pr = \frac{\nu}{\kappa} $" src="form_31.png" width="40" height="15"/>, and the Rayleigh number, <img class="formulaInl" alt="$ Ra = \frac{\alpha (\theta_{bottom} - \theta_{top})g H^{3}}{\nu\kappa} $" src="form_32.png" width="126" height="20"/> ; <img class="formulaInl" alt="$ g $" src="form_33.png" width="8" height="9"/> is the acceleration due to gravity and <img class="formulaInl" alt="$ \nu = \mu_{0}/\rho_{0} $" src="form_34.png" width="54" height="14"/> is the kinematic viscosity of the fluid.</p>
<p>We consider the solution of this coupled set of equations in a two-dimensional domain <img class="formulaInl" alt="$ 0 \leq x_{1} \leq 3 $" src="form_35.png" width="59" height="11"/> , <img class="formulaInl" alt="$ 0 \leq x_{2} \leq 1 $" src="form_36.png" width="59" height="11"/> . The boundary conditions are no-slip at the top and bottom walls </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_{1} = u_{2} = 0 \quad\mbox{on } x_{2} = 0, 1; \]" src="form_37.png" width="146" height="11"/>
</p>
<p> constant temperature at the top and bottom walls (heated from below) </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \theta = 0.5 \quad\mbox{on } x_{2}=0 \quad\mbox{and}\quad \theta = -0.5 \quad\mbox{on } x_{2} = 1; \]" src="form_38.png" width="266" height="13"/>
</p>
<p> and symmetry boundary conditions at the sides: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_{1} = 0,\quad \frac{\partial u_{2}}{\partial x_{1}} = 0, \quad \mbox{ and } \frac{\partial \theta}{\partial x_{1}} = 0 \quad\mbox{on } x_{1} = 0,3. \]" src="form_39.png" width="271" height="29"/>
</p>
<p> We assume that gravity acts vertically downward so that <img class="formulaInl" alt="$ G_{1} = 0 $" src="form_40.png" width="38" height="13"/> and <img class="formulaInl" alt="$ G_{2} = -1 $" src="form_41.png" width="48" height="13"/> .</p>
<p>There is a trivial steady-state solution that consists of a linearly-varying temperature field balanced by a quadratic pressure field: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_{1} = u_{2} = 0, \quad \theta = 0.5 - x_2, \quad p = P_{0} + 0.5 \ Ra \ x_{2} \left(1 - x_{2}\right). \]" src="form_42.png" width="324" height="14"/>
</p>
<div class="image">
<img src="base_flow.gif" alt=""/>
<div class="caption">
The base flow: no flow and a linear temperature distribution </div></div>
 <p>A linear stability analysis shows that this solution becomes unstable via an up-down, symmetry-breaking, pitchfork bifurcation at a critical Rayleigh number of <img class="formulaInl" alt="$ Ra_{crit} \approx 1708 $" src="form_43.png" width="75" height="13"/> with a critical wavenumber of <img class="formulaInl" alt="$ k \approx 3.11, $" src="form_44.png" width="49" height="13"/> see for example Hydrodynamic and Hydromagnetic Stability by S. Chandrasekhar OUP (1961). Thus, for <img class="formulaInl" alt="$ Ra &gt; 1708 $" src="form_45.png" width="58" height="11"/> there are three possible steady solutions, the (unstable) trivial steady state and two (stable) symmetry-broken states. In principle, all three states can be computed directly by solving the steady equations. However, we typically find that if the steady computation is started with a zero initial guess for the velocity and temperature, the Newton method converges to the trivial state. In order to demonstrate that this state is indeed unstable we therefore apply a time-dependent, mass-conserving perturbation to the vertical velocity at the upper wall and time-march the system while rapidly reducing the size of the perturbation. The system then evolves towards the nontrivial steady state as shown in the <a href="../figures/convect.avi">animation</a> from which the plots shown above were extracted. (In the <a href="../../refine_b_convect/html/index.html">next tutorial where we discuss the adaptive solution of this problem</a> we shall demonstrate an alternative technique for obtaining this solutions).</p>
<p>Note that by choosing our domain of a particular size and applying symmetry conditions at the sidewalls we are only able to realise a discrete set of wavelengths (those that exactly fit into the box). At the chosen Rayleigh number, 1800, only one of these modes is unstable; that of wavelength 2.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="namespace"></a>
Global parameters and functions</h1>
<p>The problem contains three global parameters, the P&eacute;clet number, the Prandtl number and the Rayleigh number which we define in a namespace, as usual. In fact, <img class="formulaInl" alt="$ 1/Pr $" src="form_46.png" width="28" height="14"/> is the natural dimensionless grouping, and so we use the inverse Prandtl number as our variable.  </p><div class="fragment"><div class="line"><span class="comment">//======start_of_namespace============================================</span></div>
<div class="line"><span class="comment">/// Namespace for the physical parameters in the problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceGlobal__Physical__Variables.html">Global_Physical_Variables</a></div>
<div class="line">{<span class="comment"></span></div>
<div class="line"><span class="comment"> /// Peclet number (identically one from our non-dimensionalisation)</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#ad4cdf142ba50635d62ac4c614f445af7">Peclet</a>=1.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// 1/Prandtl number</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#a87796c9f402e6f90c07cf5ba0db4367e">Inverse_Prandtl</a>=1.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Rayleigh number, set to be greater than </span></div>
<div class="line"><span class="comment"> /// the threshold for linear instability</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">double</span> <a class="code" href="namespaceGlobal__Physical__Variables.html#a637fd2a6a7c5b34ed3288300d8bf84b7">Rayleigh</a> = 1800.0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Gravity vector</span></div>
<div class="line"><span class="comment"></span> Vector&lt;double&gt; <a class="code" href="namespaceGlobal__Physical__Variables.html#a42f4a0aee37dbb36186267931c614053">Direction_of_gravity</a>(2);</div>
<div class="line">  </div>
<div class="line">} <span class="comment">// end_of_namespace</span></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html">Global_Physical_Variables</a></div><div class="ttdoc">Namespace for the physical parameters in the problem.</div><div class="ttdef"><b>Definition:</b> <a href="boussinesq__convection_8cc_source.html#l00048">boussinesq_convection.cc:49</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a42f4a0aee37dbb36186267931c614053"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a42f4a0aee37dbb36186267931c614053">Global_Physical_Variables::Direction_of_gravity</a></div><div class="ttdeci">Vector&lt; double &gt; Direction_of_gravity(2)</div><div class="ttdoc">Gravity vector.</div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a637fd2a6a7c5b34ed3288300d8bf84b7"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a637fd2a6a7c5b34ed3288300d8bf84b7">Global_Physical_Variables::Rayleigh</a></div><div class="ttdeci">double Rayleigh</div><div class="ttdoc">Rayleigh number, set to be greater than the threshold for linear instability.</div><div class="ttdef"><b>Definition:</b> <a href="boussinesq__convection_8cc_source.html#l00058">boussinesq_convection.cc:58</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_a87796c9f402e6f90c07cf5ba0db4367e"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#a87796c9f402e6f90c07cf5ba0db4367e">Global_Physical_Variables::Inverse_Prandtl</a></div><div class="ttdeci">double Inverse_Prandtl</div><div class="ttdoc">1/Prandtl number</div><div class="ttdef"><b>Definition:</b> <a href="boussinesq__convection_8cc_source.html#l00054">boussinesq_convection.cc:54</a></div></div>
<div class="ttc" id="anamespaceGlobal__Physical__Variables_html_ad4cdf142ba50635d62ac4c614f445af7"><div class="ttname"><a href="namespaceGlobal__Physical__Variables.html#ad4cdf142ba50635d62ac4c614f445af7">Global_Physical_Variables::Peclet</a></div><div class="ttdeci">double Peclet</div><div class="ttdoc">Peclet number (identically one from our non-dimensionalisation)</div><div class="ttdef"><b>Definition:</b> <a href="boussinesq__convection_8cc_source.html#l00051">boussinesq_convection.cc:51</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="main"></a>
The driver code</h1>
<p>In the driver code we set the direction of gravity and construct our problem, using the new <a class="el" href="index.html#element">BuoyantQCrouzeixRaviartElement</a>, a multi-physics element, created by combining the <code>QCrouzeixRaviart</code> Navier-Stokes elements with the <code>QAdvectionDiffusion</code> elements via multiple inheritance. (Details of the element's implementation are discussed in the section <a class="el" href="index.html#element">Creating the new BuoyantQCrouzeixRaviartElement class</a> below.)</p>
 <div class="fragment"><div class="line"><span class="comment">//=======start_of_main================================================</span></div>
<div class="line"><span class="comment">/// Driver code for 2D Boussinesq convection problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//====================================================================</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="boussinesq__convection_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set the direction of gravity</span></div>
<div class="line"> <a class="code" href="namespaceGlobal__Physical__Variables.html#a42f4a0aee37dbb36186267931c614053">Global_Physical_Variables::Direction_of_gravity</a>[0] = 0.0;</div>
<div class="line"> <a class="code" href="namespaceGlobal__Physical__Variables.html#a42f4a0aee37dbb36186267931c614053">Global_Physical_Variables::Direction_of_gravity</a>[1] = -1.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Construct our problem</span></div>
<div class="line"> <a class="code" href="classConvectionProblem.html">ConvectionProblem&lt;BuoyantQCrouzeixRaviartElement&lt;2&gt;</a> &gt; problem;</div>
<div class="ttc" id="aboussinesq__convection_8cc_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="boussinesq__convection_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdoc">Driver code for 2D Boussinesq convection problem.</div><div class="ttdef"><b>Definition:</b> <a href="boussinesq__convection_8cc_source.html#l00314">boussinesq_convection.cc:314</a></div></div>
<div class="ttc" id="aclassConvectionProblem_html"><div class="ttname"><a href="classConvectionProblem.html">ConvectionProblem</a></div><div class="ttdoc">/////////////////////////////////////////////////////////////////// /////////////////////////////////...</div><div class="ttdef"><b>Definition:</b> <a href="boussinesq__convection_8cc_source.html#l00075">boussinesq_convection.cc:76</a></div></div>
</div><!-- fragment --><p> We assign the boundary conditions at the time <img class="formulaInl" alt="$ t=0 $" src="form_47.png" width="29" height="9"/> and initially perform a single steady solve to obtain the trivial (and temporally unstable) trivial solution; see the section <a class="el" href="index.html#comments">Comments</a> for a more detailed discussion of the <code>Problem::steady_newton_solve()</code> function.</p>
<div class="fragment"><div class="line"> <span class="comment">// Apply the boundary condition at time zero</span></div>
<div class="line"> problem.<a class="code" href="classConvectionProblem.html#a605543718d51f7a77f75a46b48b543d7">set_boundary_conditions</a>(0.0);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Perform a single steady Newton solve</span></div>
<div class="line"> problem.steady_newton_solve();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Document the solution</span></div>
<div class="line"> problem.<a class="code" href="classConvectionProblem.html#ab7d9e5ac641ca08dd8b04c5eec179593">doc_solution</a>();</div>
<div class="ttc" id="aclassConvectionProblem_html_a605543718d51f7a77f75a46b48b543d7"><div class="ttname"><a href="classConvectionProblem.html#a605543718d51f7a77f75a46b48b543d7">ConvectionProblem::set_boundary_conditions</a></div><div class="ttdeci">void set_boundary_conditions(const double &amp;time)</div><div class="ttdoc">Set the boundary conditions.</div><div class="ttdef"><b>Definition:</b> <a href="boussinesq__convection_8cc_source.html#l00237">boussinesq_convection.cc:237</a></div></div>
<div class="ttc" id="aclassConvectionProblem_html_ab7d9e5ac641ca08dd8b04c5eec179593"><div class="ttname"><a href="classConvectionProblem.html#ab7d9e5ac641ca08dd8b04c5eec179593">ConvectionProblem::doc_solution</a></div><div class="ttdeci">void doc_solution()</div><div class="ttdoc">Doc the solution.</div><div class="ttdef"><b>Definition:</b> <a href="boussinesq__convection_8cc_source.html#l00290">boussinesq_convection.cc:290</a></div></div>
</div><!-- fragment --><p> The result of this calculation is the trivial symmetric base flow. We next timestep the system using the (unstable) steady solution as the initial condition. As time increases, the flow evolves to one of the stable asymmetric solutions, as shown in the <a href="../figures/convect.avi">animation of the results.</a> As usual, we only perform a few timesteps when the code is used as a self-test, i.e. if any command-line parameters are passed to the driver code.</p>
<div class="fragment"><div class="line"> <span class="comment">//Set the timestep</span></div>
<div class="line"> <span class="keywordtype">double</span> dt = 0.1;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Initialise the value of the timestep and set an impulsive start</span></div>
<div class="line"> problem.assign_initial_values_impulsive(dt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Set the number of timesteps to our default value</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_steps = 200;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//If we have a command line argument, perform fewer steps </span></div>
<div class="line"> <span class="comment">//(used for self-test runs)</span></div>
<div class="line"> <span class="keywordflow">if</span>(argc &gt; 1) {n_steps = 5;}</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Perform n_steps timesteps</span></div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_steps;++i)</div>
<div class="line">  {</div>
<div class="line">   problem.unsteady_newton_solve(dt);</div>
<div class="line">   problem.<a class="code" href="classConvectionProblem.html#ab7d9e5ac641ca08dd8b04c5eec179593">doc_solution</a>();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of main</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="problem"></a>
The problem class</h1>
<p>The problem class contains five non-trivial functions: the constructor, the <code>fix_pressure(...)</code> function, as well as the functions <code>set_boundary_conditions(...)</code>, <code>actions_before_implicit_timestep(...)</code> and <code>doc_solution(...)</code>, all discussed below.</p>
<hr  />
 <hr  />
<h2><a class="anchor" id="const"></a>
The constructor</h2>
<p>We pass the element type as a template parameter to the problem constructor, which has no arguments. The constructor creates a <code>BFD&lt;2&gt;</code> timestepper and builds a <code>RectangularQuadMesh</code> of <img class="formulaInl" alt="$ 8\times 8 $" src="form_48.png" width="29" height="9"/> elements.</p>
 <div class="fragment"><div class="line"><span class="comment">//===========start_of_constructor=========================================</span></div>
<div class="line"><span class="comment">/// Constructor for convection problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><a class="code" href="classConvectionProblem.html#a0c68c4c4b67d9fc8c9900fc895eed973">ConvectionProblem&lt;ELEMENT&gt;::ConvectionProblem</a>()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">//Allocate a timestepper</span></div>
<div class="line"> add_time_stepper_pt(<span class="keyword">new</span> BDF&lt;2&gt;);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set output directory</span></div>
<div class="line"> Doc_info.set_directory(<span class="stringliteral">&quot;RESLT&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// # of elements in x-direction</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_x=8;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// # of elements in y-direction</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_y=8;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Domain length in x-direction</span></div>
<div class="line"> <span class="keywordtype">double</span> l_x=3.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Domain length in y-direction</span></div>
<div class="line"> <span class="keywordtype">double</span> l_y=1.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build a standard rectangular quadmesh</span></div>
<div class="line"> Problem::mesh_pt() = </div>
<div class="line">  <span class="keyword">new</span> RectangularQuadMesh&lt;ELEMENT&gt;(n_x,n_y,l_x,l_y,time_stepper_pt());</div>
<div class="ttc" id="aclassConvectionProblem_html_a0c68c4c4b67d9fc8c9900fc895eed973"><div class="ttname"><a href="classConvectionProblem.html#a0c68c4c4b67d9fc8c9900fc895eed973">ConvectionProblem::ConvectionProblem</a></div><div class="ttdeci">ConvectionProblem()</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> <a href="boussinesq__convection_8cc_source.html#l00137">boussinesq_convection.cc:137</a></div></div>
</div><!-- fragment --><p> Next, the boundary constraints are imposed. We pin all velocities and the temperature on the top and bottom walls and pin only the horizontal velocity on the sidewalls. Since the domain is enclosed, the pressure is only determined up the an arbitrary constant. We resolve this ambiguity by pinning a single pressure value, using the <code>fix_pressure(...)</code> function.</p>
<div class="fragment"><div class="line"> <span class="comment">// Set the boundary conditions for this problem: All nodes are</span></div>
<div class="line"> <span class="comment">// free by default -- only need to pin the ones that have Dirichlet </span></div>
<div class="line"> <span class="comment">// conditions here</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Loop over the boundaries</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> num_bound = mesh_pt()-&gt;nboundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibound=0;ibound&lt;num_bound;ibound++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Set the maximum index to be pinned (all values by default)</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> val_max=3;</div>
<div class="line">   <span class="comment">//If we are on the side-walls, the v-velocity and temperature</span></div>
<div class="line">   <span class="comment">//satisfy natural boundary conditions, so we only pin the</span></div>
<div class="line">   <span class="comment">//first value</span></div>
<div class="line">   <span class="keywordflow">if</span>((ibound==1) || (ibound==3)) {val_max=1;}</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Loop over the number of nodes on the boundry</span></div>
<div class="line">   <span class="keywordtype">unsigned</span> num_nod= mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">//Loop over the desired values stored at the nodes and pin</span></div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;val_max;j++)</div>
<div class="line">      {</div>
<div class="line">       mesh_pt()-&gt;boundary_node_pt(ibound,inod)-&gt;pin(j);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Pin the zero-th pressure dof in element 0 and set its value to</span></div>
<div class="line"> <span class="comment">//zero:</span></div>
<div class="line"> fix_pressure(0,0,0.0);</div>
</div><!-- fragment --><p> We complete the build of the elements by setting the pointers to the physical parameters and finally assign the equation numbers</p>
<div class="fragment"><div class="line"> <span class="keywordtype">unsigned</span> n_element = mesh_pt()-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;n_element;i++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from GeneralsedElement to the present element</span></div>
<div class="line">   ELEMENT *el_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(mesh_pt()-&gt;element_pt(i));</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set the Peclet number</span></div>
<div class="line">   el_pt-&gt;pe_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#ad4cdf142ba50635d62ac4c614f445af7">Global_Physical_Variables::Peclet</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set the Peclet number multiplied by the Strouhal number</span></div>
<div class="line">   el_pt-&gt;pe_st_pt() =&amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#ad4cdf142ba50635d62ac4c614f445af7">Global_Physical_Variables::Peclet</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set the Reynolds number (1/Pr in our non-dimensionalisation)</span></div>
<div class="line">   el_pt-&gt;re_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a87796c9f402e6f90c07cf5ba0db4367e">Global_Physical_Variables::Inverse_Prandtl</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set ReSt (also 1/Pr in our non-dimensionalisation)</span></div>
<div class="line">   el_pt-&gt;re_st_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a87796c9f402e6f90c07cf5ba0db4367e">Global_Physical_Variables::Inverse_Prandtl</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Set the Rayleigh number</span></div>
<div class="line">   el_pt-&gt;ra_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a637fd2a6a7c5b34ed3288300d8bf84b7">Global_Physical_Variables::Rayleigh</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Set Gravity vector</span></div>
<div class="line">   el_pt-&gt;g_pt() = &amp;<a class="code" href="namespaceGlobal__Physical__Variables.html#a42f4a0aee37dbb36186267931c614053">Global_Physical_Variables::Direction_of_gravity</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//The mesh is fixed, so we can disable ALE</span></div>
<div class="line">   el_pt-&gt;disable_ALE();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Setup equation numbering scheme</span></div>
<div class="line"> cout &lt;&lt;<span class="stringliteral">&quot;Number of equations: &quot;</span> &lt;&lt; assign_eqn_numbers() &lt;&lt; endl; </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of constructor</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h2><a class="anchor" id="set_bound"></a>
The function set_boundary_conditions(...)</h2>
<p>In order to examine the stability of the symmetric state, we impose a time-dependent boundary condition that transiently perturbs the vertical velocity field at the upper boundary. Our boundary condition is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_{2}\big|_{x_2=1} = \epsilon \ t \ \mbox{e}^{-t} \sin(2\pi x_{1}/3), \]" src="form_49.png" width="163" height="19"/>
</p>
<p> where <img class="formulaInl" alt="$ \epsilon \ll 1 $" src="form_50.png" width="30" height="10"/> . The perturbation is zero at <img class="formulaInl" alt="$ t=0 $" src="form_47.png" width="29" height="9"/> , tends to zero as <img class="formulaInl" alt="$ t\to\infty $" src="form_51.png" width="38" height="9"/> , and is mass conserving. This is implemented in the function below</p>
 <div class="fragment"><div class="line"><span class="comment">//===========start_of_set_boundary_conditions================</span></div>
<div class="line"><span class="comment">/// Set the boundary conditions as a function of continuous </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// time</span></div>
<div class="line"><span class="comment"></span><span class="comment">//===========================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classConvectionProblem.html#a605543718d51f7a77f75a46b48b543d7">ConvectionProblem&lt;ELEMENT&gt;::set_boundary_conditions</a>(</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;time)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Loop over the boundaries</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> num_bound = mesh_pt()-&gt;nboundary();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> ibound=0;ibound&lt;num_bound;ibound++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Loop over the nodes on boundary </span></div>
<div class="line">   <span class="keywordtype">unsigned</span> num_nod=mesh_pt()-&gt;nboundary_node(ibound);</div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> inod=0;inod&lt;num_nod;inod++)</div>
<div class="line">    {</div>
<div class="line">     <span class="comment">// Get pointer to node</span></div>
<div class="line">     Node* nod_pt=mesh_pt()-&gt;boundary_node_pt(ibound,inod);</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//Set the number of velocity components</span></div>
<div class="line">     <span class="keywordtype">unsigned</span> vel_max=2;</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//If we are on the side walls we only set the x-velocity.</span></div>
<div class="line">     <span class="keywordflow">if</span>((ibound==1) || (ibound==3)) {vel_max = 1;}</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//Set the pinned velocities to zero</span></div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;vel_max;j++) {nod_pt-&gt;set_value(j,0.0);}</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//If we are on the top boundary</span></div>
<div class="line">     <span class="keywordflow">if</span>(ibound==2) </div>
<div class="line">      {</div>
<div class="line">       <span class="comment">//Set the temperature to -0.5 (cooled)</span></div>
<div class="line">       nod_pt-&gt;set_value(2,-0.5);</div>
<div class="line"> </div>
<div class="line">       <span class="comment">//Add small velocity imperfection if desired</span></div>
<div class="line">       <span class="keywordtype">double</span> epsilon = 0.01;</div>
<div class="line"> </div>
<div class="line">       <span class="comment">//Read out the x position</span></div>
<div class="line">       <span class="keywordtype">double</span> x = nod_pt-&gt;x(0);</div>
<div class="line"> </div>
<div class="line">       <span class="comment">//Set a sinusoidal perturbation in the vertical velocity</span></div>
<div class="line">       <span class="comment">//This perturbation is mass conserving</span></div>
<div class="line">       <span class="keywordtype">double</span> value = sin(2.0*MathematicalConstants::Pi*x/3.0)*</div>
<div class="line">        epsilon*time*exp(-time);</div>
<div class="line">       nod_pt-&gt;set_value(1,value);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//If we are on the bottom boundary, set the temperature</span></div>
<div class="line">     <span class="comment">//to 0.5 (heated)</span></div>
<div class="line">     <span class="keywordflow">if</span>(ibound==0) {nod_pt-&gt;set_value(2,0.5);}</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// end_of_set_boundary_conditions</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h2><a class="anchor" id="fix_p"></a>
The function fix_pressure(...)</h2>
<p>This function is a simple wrapper to the element's <code>fix_pressure(...)</code> function.</p>
 <div class="fragment"><div class="line"> <span class="comment">/// Fix pressure in element e at pressure dof pdof and set to pvalue</span></div>
<div class="line"> <span class="keywordtype">void</span> fix_pressure(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;e, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;pdof, </div>
<div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;pvalue)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Cast to specific element and fix pressure</span></div>
<div class="line">   <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(mesh_pt()-&gt;element_pt(e))-&gt;</div>
<div class="line">    fix_pressure(pdof,pvalue);</div>
<div class="line">  } <span class="comment">// end_of_fix_pressure</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h2><a class="anchor" id="actions_bef"></a>
The function actions_before_implicit_timestep()</h2>
<p>This function is used to ensure that the time-dependent boundary conditions are set to the correct value before solving the problem at the next time level.  </p><div class="fragment"><div class="line"> <span class="comment">/// Actions before the timestep (update the the time-dependent </span></div>
<div class="line"><span class="comment"> /// boundary conditions)</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> actions_before_implicit_timestep() </div>
<div class="line">  {</div>
<div class="line">   set_boundary_conditions(time_pt()-&gt;time());</div>
<div class="line">  }</div>
</div><!-- fragment --> <hr  />
 <hr  />
<h2><a class="anchor" id="doc"></a>
The function doc_solution(...)</h2>
<p>This function writes the complete velocity, pressure and temperature fields to a file in the output directory.</p>
 <div class="fragment"><div class="line"><span class="comment">//===============start_doc_solution=======================================</span></div>
<div class="line"><span class="comment">/// Doc the solution</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classConvectionProblem.html#ab7d9e5ac641ca08dd8b04c5eec179593">ConvectionProblem&lt;ELEMENT&gt;::doc_solution</a>()</div>
<div class="line">{ </div>
<div class="line"> <span class="comment">//Declare an output stream and filename</span></div>
<div class="line"> ofstream some_file;</div>
<div class="line"> <span class="keywordtype">char</span> filename[100];</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Number of plot points: npts x npts</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> npts=5;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output solution </span></div>
<div class="line"> <span class="comment">//-----------------</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/soln%i.dat&quot;</span>,Doc_info.directory().c_str(),</div>
<div class="line">         Doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> mesh_pt()-&gt;output(some_file,npts);</div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> Doc_info.number()++;</div>
<div class="line">} <span class="comment">// end of doc</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h1><a class="anchor" id="element"></a>
Creating the new BuoyantQCrouzeixRaviartElement class</h1>
<p>The sketch below illustrates how the new multi-physics <code>BuoyantQCrouzeixRaviartElement</code> is constructed by multiple inheritance from the two existing single-physics elements:</p>
<div class="image">
<img src="multi_physics.gif" alt=""/>
<div class="caption">
Sketch illustrating the construction of the BuoyantQCrouzeixRaviartElement by multiple inheritance. </div></div>
 <ul>
<li>The nine-noded two-dimensional <code>QCrouzeixRaviartElement</code> is based on a nine-node quadrilateral geometric <code>FiniteElement</code> from the <code>QElement</code> family. All of its <code>Nodes</code> store two values, the horizontal and vertical velocity, respectively. The element also stores internal <code>Data</code> which represents the (discontinuous) pressure degrees of freedom; in the sketch this <code>Data</code> is represented by the dashed box. <br  />
<br  />
</li>
<li>The two-dimensional <code>QAdvectionDiffusionElement</code> is based on the same geometric <code>FiniteElement</code> and stores one value (the temperature, <img class="formulaInl" alt="$ \theta $" src="form_52.png" width="6" height="10"/> ) at each <code>Node</code>.</li>
</ul>
<p>Both elements are fully-functional and provide their contributions to the global system of nonlinear algebraic equations that is solved by Newton's method via the two member functions <code>fill_in_contribution_to_residuals(...)</code> and <br  />
 <code>fill_in_contribution_to_jacobian(...)</code>.</p><ul>
<li>The <code>QAdvectionDiffusionElement's</code> member function <code>fill_in_contribution_to_residuals(...)</code> computes the element's contribution to the global residual vector for a given "wind". The "wind" is specified by its virtual member function <code>get_wind_adv_diff(...)</code> and in the <a href="../../../advection_diffusion/two_d_adv_diff_adapt/html/index.html">single-physics advection diffusion problems studied so far</a>, the "wind" tended to specified <em>a</em> <em>priori</em> by the user. The element's <br  />
 member function <code>fill_in_contribution_to_jacobian(...)</code> computes the elemental Jacobian matrix, i.e. the derivatives of the elemental residual vector with respect to its unknown nodal values (the temperatures). <br  />
<br  />
</li>
<li>Similarly, the <code>QCrouzeixRaviartElement's</code> member function <code>fill_in_contribution_to_residuals(...)</code> computes the element's contribution to the global residual vector for a given body force. The body force is specified by its virtual member function <code>get_body_force_nst(...)</code> and in the <a href="../../../navier_stokes/circular_driven_cavity/html/index.html">single-physics Navier-Stokes problems studied so far</a>, the body force tended to specified <em>a</em> <em>priori</em> by the user. The element's member function <code>fill_in_contribution_to_jacobian(...)</code> computes the elemental Jacobian matrix, i.e. the derivatives of the elemental residual vector with respect to its unknown nodal and internal values (the velocities and the pressure).</li>
</ul>
<p>When combining the two single-physics elements to a multi-physics element, we have to take the interaction between the constituent equations into account: In the coupled problem the "wind" in the advection-diffusion equations is given by the Navier-Stokes velocities, while the body force in the Navier-Stokes equations is a function of the temperature. When implementing these interactions we wish to recycle as much of the elements' existing functionality as possible. This may be achieved by the following straightforward steps:</p><ol type="1">
<li>Construct the combined multi-physics element by multiple inheritance. <br  />
<br  />
</li>
<li>Overload the <code>FiniteElement::required_nvalue(...)</code> function to ensure that each <code>Node</code> provides a sufficient amount of storage for the (larger) number of nodal values required in the multi-physics problem. <br  />
<br  />
</li>
<li>Overload the constituent element's member functions that indicate which nodal value corresponds to which type of degree of freedom. For instance, in the single-physics advection-diffusion problem, the temperature is stored at the zero-th nodal value whereas in the combined multi-physics element, the temperature is stored as the second value, as shown in the above sketch. <br  />
<br  />
</li>
<li>Provide a final overload for the element's <code>fill_in_contribution_to_residuals(...)</code> and <code>fill_in_contribution_to_jacobian(...)</code> functions. <br  />
 The former simply concatenates the residual vectors computed by the constituent single-physics elements. The latter function is easiest to implement by finite differencing the combined element's residual vector. [A more efficient approach (in terms of cpu time, not necessarily terms of development time!) is to recycle the diagonal blocks computed by the constituent elements's <code>fill_in_contribution_to_jacobian(...)</code> functions and to use finite-differencing only for the off-diagonal (interaction) blocks; see the section <a class="el" href="index.html#comments">Comments</a> a more detailed discussion of this technique.] <br  />
<br  />
</li>
</ol>
<p>That's all! Here is the implementation:</p>
 <div class="fragment"><div class="line">  <span class="comment">//======================class definition==============================</span></div>
<div class="line"><span class="comment">  /// A class that solves the Boussinesq approximation of the Navier--Stokes</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// and energy equations by coupling two pre-existing classes.</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// The QAdvectionDiffusionElement with bi-quadratic interpolation for the</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// scalar variable (temperature) and</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// QCrouzeixRaviartElement which solves the Navier--Stokes equations</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// using bi-quadratic interpolation for the velocities and a discontinuous</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// bi-linear interpolation for the pressure. Note that we are free to</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// choose the order in which we store the variables at the nodes. In this</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// case we choose to store the variables in the order fluid velocities</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// followed by temperature. We must, therefore, overload the function</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// AdvectionDiffusionEquations&lt;DIM&gt;::u_index_adv_diff() to indicate that</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// the temperature is stored at the DIM-th position not the 0-th. We do not</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// need to overload the corresponding function in the</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// NavierStokesEquations&lt;DIM&gt; class because the velocities are stored</span></div>
<div class="line"><span class="comment"></span><span class="comment">  /// first.</span></div>
<div class="line"><span class="comment"></span>  <span class="comment">//=========================================================================</span></div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> DIM&gt;</div>
<div class="line">  <span class="keyword">class </span>BuoyantQCrouzeixRaviartElement</div>
<div class="line">    : <span class="keyword">public</span> <span class="keyword">virtual</span> QAdvectionDiffusionElement&lt;DIM, 3&gt;,</div>
<div class="line">      <span class="keyword">public</span> <span class="keyword">virtual</span> QCrouzeixRaviartElement&lt;DIM&gt;</div>
</div><!-- fragment --><p> The class contains a single new physical parameter, the Rayleigh number, as usual referenced by a pointer to a double precision datum,</p>
 <div class="fragment"><div class="line">    <span class="comment">/// Pointer to a private data member, the Rayleigh number</span></div>
<div class="line">    <span class="keywordtype">double</span>* Ra_pt;</div>
</div><!-- fragment --><p> with suitable access functions.</p>
 <div class="fragment"><div class="line">    <span class="comment">/// Access function for the Rayleigh number (const version)</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ra()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> *Ra_pt;</div>
<div class="line">    }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /// Access function for the pointer to the Rayleigh number</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">double</span>*&amp; ra_pt()</div>
</div><!-- fragment --><p> The constructor calls the constructors of the component classes (<code>QCrouzeixRaviartElement</code> and <code>QAdvectionDiffusionElement</code>) and initialises the value of the Rayleigh number to zero, via a static default parameter value.</p>
 <div class="fragment"><div class="line">    <span class="comment">/// Constructor: call the underlying constructors and</span></div>
<div class="line"><span class="comment">    /// initialise the pointer to the Rayleigh number to point</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// to the default value of 0.0.</span></div>
<div class="line"><span class="comment"></span>    BuoyantQCrouzeixRaviartElement()</div>
<div class="line">      : QAdvectionDiffusionElement&lt;DIM, 3&gt;(), QCrouzeixRaviartElement&lt;DIM&gt;()</div>
<div class="line">    {</div>
<div class="line">      Ra_pt = &amp;<a class="code" href="namespaceoomph_1_1MultiDomainBoussinesqHelper.html#ae77c07b69cffe295ac07e2c25c31a8aa">Default_Physical_Constant_Value</a>;</div>
<div class="line">    }</div>
<div class="ttc" id="anamespaceoomph_1_1MultiDomainBoussinesqHelper_html_ae77c07b69cffe295ac07e2c25c31a8aa"><div class="ttname"><a href="namespaceoomph_1_1MultiDomainBoussinesqHelper.html#ae77c07b69cffe295ac07e2c25c31a8aa">oomph::MultiDomainBoussinesqHelper::Default_Physical_Constant_Value</a></div><div class="ttdeci">double Default_Physical_Constant_Value</div><div class="ttdoc">Default value for physical constants.</div><div class="ttdef"><b>Definition:</b> <a href="multi__domain__boussinesq__elements_8h_source.html#l00048">multi_domain_boussinesq_elements.h:48</a></div></div>
</div><!-- fragment --><p> We must overload the function <code>FiniteElement::required_nvalue()</code> because the new element will store <code>DIM+1</code> unknowns at each node: <code>DIM</code> fluid velocity components and the value of the temperature, as shown in the sketch above.</p>
 <div class="fragment"><div class="line">    <span class="comment">/// The required number of values stored at the nodes is the sum of</span></div>
<div class="line"><span class="comment">    /// the required values of the two single-physics  elements. Note that this</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// step is generic for any multi-physics element of this type.</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">unsigned</span> required_nvalue(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; n)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> (QAdvectionDiffusionElement&lt;DIM, 3&gt;::required_nvalue(n) +</div>
<div class="line">              QCrouzeixRaviartElement&lt;DIM&gt;::required_nvalue(n));</div>
</div><!-- fragment --><p> In the standard single-physics advection-diffusion elements the temperature is the only value stored at the nodes and is stored as <code>value(0)</code>. Similarly, in the single-physics Navier&ndash;Stokes elements, the fluid velocities are stored in the first <code>DIM</code> nodal values. In our new multi-physics element, we must decide where to store the different variables and then inform the single-physics elements of our choice. As indicated in the above sketch, we choose to store the temperature <b>after</b> the fluid velocities, so that it is <code>value(DIM)</code>. The recommended mechanism for communicating the location of the variables to the single-physics elements is to use an index function. Hence, single-physics elements that are to be the components of multi-physics elements must have an index function for their variables. For instance, the function <code>u_index_adv_diff(...)</code> is used in the <code>AdvectionDiffusionEquations</code> class to read out the position (index) at which the advected variable (the temperature) is stored. That function is now overloaded in our multi-physics element:</p>
 <div class="fragment"><div class="line">    <span class="comment">/// Overload the index at which the temperature</span></div>
<div class="line"><span class="comment">    /// variable is stored. We choose to store it after the fluid velocities.</span></div>
<div class="line"><span class="comment"></span>    <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> u_index_adv_diff()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> DIM;</div>
<div class="line">    }</div>
</div><!-- fragment --><p> We need not overload the index function for the fluid velocities because they remain stored in the first <code>DIM</code> positions at the node.</p>
<p>The coupling between the two sets of single-physics equations is achieved by overloading the two functions <code>get_wind_adv_diff()</code>, used in the advection-diffusion equations and <code>get_body_force_nst()</code>, used in the Navier&ndash;Stokes equations</p>
 <div class="fragment"><div class="line">    <span class="comment">/// Overload the wind function in the advection-diffusion equations.</span></div>
<div class="line"><span class="comment">    /// This provides the coupling from the Navier--Stokes equations to the</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// advection-diffusion equations because the wind is the fluid velocity.</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> get_wind_adv_diff(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ipt,</div>
<div class="line">                           <span class="keyword">const</span> Vector&lt;double&gt;&amp; s,</div>
<div class="line">                           <span class="keyword">const</span> Vector&lt;double&gt;&amp; x,</div>
<div class="line">                           Vector&lt;double&gt;&amp; wind)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="comment">// The wind function is simply the velocity at the points</span></div>
<div class="line">      this-&gt;interpolated_u_nst(s, wind);</div>
<div class="line">    }</div>
</div><!-- fragment -->  <div class="fragment"><div class="line">    <span class="comment">/// Overload the body force in the Navier-Stokes equations</span></div>
<div class="line"><span class="comment">    /// This provides the coupling from the advection-diffusion equations</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// to the Navier--Stokes equations, the body force is the</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// temperature multiplied by the Rayleigh number acting in the</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// direction opposite to gravity.</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> get_body_force_nst(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; time,</div>
<div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; ipt,</div>
<div class="line">                            <span class="keyword">const</span> Vector&lt;double&gt;&amp; s,</div>
<div class="line">                            <span class="keyword">const</span> Vector&lt;double&gt;&amp; x,</div>
<div class="line">                            Vector&lt;double&gt;&amp; result)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Get the temperature</span></div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> interpolated_t = this-&gt;interpolated_u_adv_diff(s);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Get vector that indicates the direction of gravity from</span></div>
<div class="line">      <span class="comment">// the Navier-Stokes equations</span></div>
<div class="line">      Vector&lt;double&gt; gravity(NavierStokesEquations&lt;DIM&gt;::g());</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Temperature-dependent body force:</span></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; DIM; i++)</div>
<div class="line">      {</div>
<div class="line">        result[i] = -gravity[i] * interpolated_t * ra();</div>
<div class="line">      }</div>
</div><!-- fragment --><p> The elemental residual vector is composed of the residuals from the two single-physics elements and we simply call the underlying functions for each element in turn.</p>
 <div class="fragment"><div class="line">    <span class="comment">/// Calculate the element&#39;s contribution to the residual vector.</span></div>
<div class="line"><span class="comment">    /// Recall that fill_in_* functions MUST NOT initialise the entries</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// in the vector to zero. This allows us to call the</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// fill_in_* functions of the constituent single-physics elements</span></div>
<div class="line"><span class="comment"></span><span class="comment">    /// sequentially, without wiping out any previously computed entries.</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> fill_in_contribution_to_residuals(Vector&lt;double&gt;&amp; residuals)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Fill in the residuals of the Navier-Stokes equations</span></div>
<div class="line">      NavierStokesEquations&lt;DIM&gt;::fill_in_contribution_to_residuals(residuals);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Fill in the residuals of the advection-diffusion eqautions</span></div>
<div class="line">      AdvectionDiffusionEquations&lt;DIM&gt;::fill_in_contribution_to_residuals(</div>
<div class="line">        residuals);</div>
<div class="line">    }</div>
</div><!-- fragment --><p> Finally, we compute the Jacobian matrix by finite-differencing the element's combined residual vector, using the default implementation of the <code>fill_in_contribution_to_jacobian(...)</code> function in the <code>FiniteElement</code> base class:</p>
 <div class="fragment"><div class="line">    <span class="comment">/// Compute the element&#39;s residual vector and the Jacobian matrix.</span></div>
<div class="line"><span class="comment">    /// Jacobian is computed by finite-differencing.</span></div>
<div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> fill_in_contribution_to_jacobian(Vector&lt;double&gt;&amp; residuals,</div>
<div class="line">                                          DenseMatrix&lt;double&gt;&amp; jacobian)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// This function computes the Jacobian by finite-differencing</span></div>
<div class="line">      FiniteElement::fill_in_contribution_to_jacobian(residuals, jacobian);</div>
<div class="line">    }</div>
</div><!-- fragment --><p> Finally, we overload the output function to print the fluid velocities, the fluid pressure and the temperature.</p>
 <div class="fragment"><div class="line">    <span class="comment">// Start of output function</span></div>
<div class="line">    <span class="keywordtype">void</span> output(std::ostream&amp; outfile, <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; nplot)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// vector of local coordinates</span></div>
<div class="line">      Vector&lt;double&gt; s(DIM);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Tecplot header info</span></div>
<div class="line">      outfile &lt;&lt; this-&gt;tecplot_zone_string(nplot);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Loop over plot points</span></div>
<div class="line">      <span class="keywordtype">unsigned</span> num_plot_points = this-&gt;nplot_points(nplot);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> iplot = 0; iplot &lt; num_plot_points; iplot++)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Get local coordinates of plot point</span></div>
<div class="line">        this-&gt;get_s_plot(iplot, nplot, s);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Output the position of the plot point</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; DIM; i++)</div>
<div class="line">        {</div>
<div class="line">          outfile &lt;&lt; this-&gt;interpolated_x(s, i) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Output the fluid velocities at the plot point</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; DIM; i++)</div>
<div class="line">        {</div>
<div class="line">          outfile &lt;&lt; this-&gt;interpolated_u_nst(s, i) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Output the fluid pressure at the plot point</span></div>
<div class="line">        outfile &lt;&lt; this-&gt;interpolated_p_nst(s) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Output the temperature (the advected variable) at the plot point</span></div>
<div class="line">        outfile &lt;&lt; this-&gt;interpolated_u_adv_diff(s) &lt;&lt; std::endl;</div>
<div class="line">      }</div>
<div class="line">      outfile &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Write tecplot footer (e.g. FE connectivity lists)</span></div>
<div class="line">      this-&gt;write_tecplot_zone_footer(outfile, nplot);</div>
<div class="line">    } <span class="comment">// End of output function</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
 <h1><a class="anchor" id="comm_and_ex"></a>
Comments and Exercises</h1>
<h2><a class="anchor" id="comments"></a>
Comments</h2>
<ul>
<li><b>The <code>steady_newton_solve()</code>function:</b> <br  />
<br  />
 In most previous examples we have encountered two main interfaces to <code>oomph-lib's</code> Newton solver: <br  />
<br  />
<ul>
<li>The function <code>Problem::newton_solve()</code> employs Newton's method to solve the system of nonlinear algebraic equations arising from the <code>Problem's</code> discretisation. The current <code>Data</code> values are used as the initial guess for the Newton iteration. On return from this function, all unknown <code>Data</code> values will have been assigned their correct values so that the solution of the problem may be plotted by calls to the elements' <code>output</code> functions. We tended to use this function to solve steady problems. <br  />
<br  />
</li>
<li>Given the solution at time <img class="formulaInl" alt="$ t = t_{\mbox{orig}} $" src="form_53.png" width="48" height="16"/> , the unsteady Newton solver <code> Problem::unsteady_newton_solve(dt,...) </code> increments time by <code>dt</code>, shifts the "history" values and then computes the solution at the advanced time, <img class="formulaInl" alt="$ t = t_{\mbox{orig}} $" src="form_53.png" width="48" height="16"/> + <code>dt</code>. On return from this function, all unknown <code>Data</code> values (and the corresponding "history" values) will have been assigned their correct values so that the solution at time <img class="formulaInl" alt="$ t = t_{\mbox{orig}} $" src="form_53.png" width="48" height="16"/> + <code>dt</code> may be plotted by calls to the elements' <code>output</code> functions. We tended to use this function for unsteady problems. <br  />
<br  />
</li>
</ul>
Inspection of the <code>Problem::unsteady_newton_solve(...)</code> function shows that this function is, in fact, a wrapper around <code>Problem::newton_solve()</code>, and that the latter function solves the discretised equations <em>including any terms that arise from an implicit time-discretisation</em>. The only purpose of the wrapper function is to shift the history values before taking the next timestep. This raises the question how to compute steady solutions (i.e. solutions obtained by setting the time-derivatives in the governing equation to zero) of a <code>Problem</code> that was discretised in a form that allows for timestepping, as in the problem studied here. This is the role of the function <code>Problem::steady_newton_solve()</code>: The function performs the following steps: <br  />
<br  />
<ol type="1">
<li>Disable all <code>TimeSteppers</code> in the <code>Problem</code> by calling their <code>TimeStepper::make_steady()</code> member function. <br  />
<br  />
</li>
<li>Call the <code>Problem::newton_solve()</code> function to compute the solution of the discretised problem with all time-derivatives set to zero. <br  />
<br  />
</li>
<li>Re-activate all <code>TimeSteppers</code> (unless they were already in "steady" mode when the function was called). <br  />
<br  />
</li>
<li>Call the function <code>Problem::assign_initial_values_impulsive()</code> to ensure that the "history" values used by the (now re-activated) <code>TimeSteppers</code> are consistent with an impulsive start from the steady solution just computed. <br  />
<br  />
</li>
</ol>
On return from this function, all unknown <code>Data</code> values (and the corresponding "history" values) will have been assigned their correct values so that the solution just computed is a steady solution to the full unsteady equations. <br  />
<br  />
</li>
<li><b><a class="anchor" id="opt"></a>Optimising the implementation of multi-physics interactions:</b> <br  />
<br  />
 The combined multi-physics element discussed above was implemented with just a few straightforward lines of code. The ease of implementation comes at a price, however, and more efficient implementations (in terms of CPU time) are possible: <br  />
<br  />
<ol type="1">
<li><b>Using finite-differencing only for the off-diagonal terms in the Jacobian matrix:</b> <br  />
<br  />
 While the use of finite-differencing in the setup of the Jacobian matrix is convenient, it does not exploit the fact that the constituent single-physics elements already provide analytical (and hence cheaper-to-compute) expressions for the two diagonal blocks in the coupled Jacobian matrix (i.e. the derivatives of the fluid residuals with respect to the fluid variables, and the derivatives of the advection diffusion residuals with respect to the temperature degrees of freedom). It is possible to recycle these entries and to use finite-differencing only to compute the off-diagonal interaction blocks (i.e. the derivatives of the Navier-Stokes residuals with respect to the temperature degrees of freedom, and the derivatives of the advection-diffusion residuals with respect to the velocities). In fact, the source code for the <code>BuoyantQCrouzeixRaviartElement</code> includes such an implementation. The full finite-difference-based computation discussed above is used if the code is compiled with the compiler flag <code>USE_FD_JACOBIAN_FOR_BUOYANT_Q_ELEMENT</code>. Finite-differences are used for the off-diagonal blocks only when the compiler flag <code>USE_OFF_DIAGONAL_FD_JACOBIAN_FOR_BUOYANT_Q_ELEMENT</code> is passed. When comparing the two versions of the code, we found the run times for the full finite-difference-based version to be approximately 3-7% higher, depending on the spatial resolution used. The implementation of the more efficient version is still straightforward and can be found in the source code <a href="../../../../demo_drivers/multi_physics/boussinesq_convection/boussinesq_convection.cc">boussinesq_convection.cc. </a> <br  />
<br  />
</li>
<li><b>Using an analytic Jacobian matrix:</b> <br  />
<br  />
 As discussed above, the re-use of the analytic expressions for the diagonal blocks of the coupled Jacobian matrix is straightforward. For a yet more efficient computation we can assemble analytic expressions for the off-diagonal interaction blocks; although this does require knowledge of precisely how the governing equations were implemented in the single-physics elements. Once again, the source code for the <code>BuoyantQCrouzeixRaviartElement</code> includes such an implementation and, moreover, it is the default behaviour. We found the assembly time for the analytic coupled Jacobian to be approximately 15% of the finite-difference based versions. The implementation is reasonably straightforward and can be found in the source code <a href="../../../../demo_drivers/multi_physics/boussinesq_convection/boussinesq_convection.cc">boussinesq_convection.cc. </a> <br  />
<br  />
</li>
<li><b>Complete re-implementation of the coupled element:</b> <br  />
<br  />
 Although recycling the analytically computed diagonal blocks in the Jacobian matrix leads to a modest speedup, and the use of analytic off-diagonal blocks to a further speedup, the computation of the coupled residual vector and Jacobian matrix are still somewhat inefficient. This is because the contributions from the Navier-Stokes and advection-diffusion equations are computed in two separate integration loops; and, if computed, the assembly of the analytic off-diagonal terms requires a third integration loop. The only solution to this problem would be to fully merge the source codes for two elements to create a customised element. In the present problem this would not be too difficult, particularly since the derivatives of the Navier-Stokes residuals with respect to the temperature, and the derivatives of the advection-diffusion residuals with respect to the velocities are easy to calculate. However, a reimplementation in this form would break the modularity of the library as any subsequent changes/improvements to the Navier-Stokes elements, say, would have to be added manually to the coupled element. If maximum speed is absolutely essential in your application, you may still wish to choose this option. The existing Navier-Stokes and advection diffusion elements provide the required building blocks for your custom-written coupled element. <br  />
<br  />
</li>
</ol>
</li>
</ul>
<hr  />
<h2><a class="anchor" id="exercises"></a>
Exercises</h2>
<ol type="1">
<li>Confirm that the system is stable, i.e. returns to the trivial state, when <img class="formulaInl" alt="$ Ra = 1700 $" src="form_54.png" width="58" height="10"/> .</li>
<li>How does the time-evolution of the system change when no-slip boundary conditions for the fluid velocity are applied on the side boundaries (a rigid box model)?</li>
<li>Re-write the multi-physics elements so that the temperature is stored <b>before</b> the fluid velocities. Confirm that the solution is unchanged in this case.</li>
<li>Assess the computational cost of the finite-difference based setup of the elements' Jacobian matrices by comparing the run times of the two versions of the code.</li>
<li>Try using <code>QTaylorHoodElements</code> as the "fluid" element part of the multi-physics elements. N.B. in this case, the temperature <b>must</b> be stored as the first variable at the nodes because we assume that it is always stored at the same location in every node.</li>
</ol>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory:<br  />
<br  />
<center> <a href="
../../../../
demo_drivers/multi_physics/boussinesq_convection/
">demo_drivers/multi_physics/boussinesq_convection/ </a> </center><br  />
</li>
<li>The driver code is: <br  />
<br  />
<center> <a href="
../../../../
demo_drivers/multi_physics/boussinesq_convection/boussinesq_convection.cc
">demo_drivers/multi_physics/boussinesq_convection/boussinesq_convection.cc </a> </center> <br  />
</li>
<li>The source code for the elements is in: <br  />
<br  />
<center> <a href="../../../../src/multi_physics/boussinesq_elements.h">src/multi_physics/boussinesq_elements.h</a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:32:16
        </div>
      </div>
    </footer>
</body>
</html>
