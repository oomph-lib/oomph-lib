<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: The data structure</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../figures/manifest.json">
<link rel="mask-icon" href="../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../html/index.html"><img alt="oomph-lib" src="../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../doc/copyright/html/index.html">Copyright</a></li>
            <li><a href="../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">The data structure </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p><code>oomph-lib</code> is big! This document gives a "bottom up" overview of the library's data structure and discusses how the various objects interact. In addition to the detailed discussion provided below, the following doxygen-generated lists/indices provide quick access to the documentation of <code>oomph-lib's</code> classes: clicking on the hyperlinks associated with a class takes you directly to a detailed description of its inheritance structure and its members.</p>
<ul>
<li>
<p class="startli"><a href="../../the_data_structure/html/classes.html">Class index </a></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a href="../../the_data_structure/html/functions.html">Class member index </a></p>
<p class="endli"></p>
</li>
</ul>
<p>This rest of this document provides a "bottom up" overview of the data structure in <code>oomph-lib</code> and discusses how the various objects interact. For brevity, we usually replace the list of arguments to functions by &lsquo;(...)&rsquo; and explain the main input and output parameters in words. The full specifications of the interfaces may be found in the individual class documentation, accessible via the links at the top of this page.</p>
<h2><a class="anchor" id="technical_terms"></a>
Technical terms</h2>
<p>Throughout this document, certain commonly used terms have a specific technical meaning:</p><ul>
<li><b>Value:</b> A <em>value</em> is a (double precision) number (e.g. a "nodal 
   value"). A value can either be an <em>unknown</em> in the problem or be determined by a boundary condition.</li>
<li><b>Unknown:</b> An <em>unknown</em> is a <em>value</em> that is not determined by a boundary condition.</li>
<li><b>Degree</b> <b>of</b> <b>freedom:</b> Synonym for <em>unknown</em>; often abbreviated as "dof".</li>
<li><b>History</b> <b>value:</b> <em>History</em> <em>values</em> are (double precision) numbers that are used by <code>TimeSteppers</code> to calculate time-derivatives of values. For instance, history values are often, but <b>not</b> <b>always</b>, the values at previous timesteps.</li>
<li><b>Pinned/free</b>: <em>Values</em> that are (are not) determined by boundary conditions are known as pinned (free) values.</li>
<li><b>Adapt:</b> <em>Mesh</em> <em>adaptation</em> refines/un-refines meshes by adding or deleting selected nodes and elements.</li>
</ul>
<h1><a class="anchor" id="general_data_structure"></a>
Overview of the basic data structure</h1>
<p>The main components of <code>oomph-lib</code> are <code>Data</code>, <code>Node</code>, <code>GeneralisedElement</code>, <code>Mesh</code> and <code>Problem</code>.</p>
<h2><a class="anchor" id="data"></a>
Data</h2>
<p>The most elementary data structure in <code>oomph-lib</code> is <code>Data</code> (ha!).</p>
<p>Consider the solution of a scalar PDE (e.g. a Poisson equation) with certain boundary conditions. The numerical solution of this problem requires the computation of the function values (double precision numbers) at a finite number of spatial positions (the <code>Nodes</code>). Typically, these values fall into two categories: those that are known <em>a</em> <em>priori</em> (i.e. are enforced by boundary conditions), and those that must be determined as part of the solution.</p>
<p><code>Data</code> stores a value &mdash; a double precision number. Typically, the values of the unknowns are determined by the solution of a system of algebraic equations. The solution of this system usually requires a (linear) numbering of the unknowns and associated equations. Hence, <code>Data</code> also stores a (long) integer that represents the number of the unknown in the global numbering scheme. <b>Convention:</b> If the <code>Data</code> value is pinned, we set the equation number to the static member data <code>Data::Is_pinned</code>, a negative number.</p>
<p>The number of an unknown is related to the number of the equation that &lsquo;determines its value&rsquo;, so we use the terms &lsquo;equation number&rsquo; and &lsquo;number of the unknown&rsquo; interchangeably. In fact, because the term &lsquo;number of the unknown&rsquo; is rather tedious, we <em>only</em> use the term &lsquo;equation number&rsquo;.</p>
<p>Two observations motivate a straightforward extension of this basic data structure:</p>
<ul>
<li>In time-dependent problems, the approximation of time-derivatives requires the storage of a certain number of auxiliary values (e.g. the values of the unknowns at a number of previous timesteps).</li>
<li>In many problems, we are not dealing with scalars (i.e. individual doubles) but with vector-valued unknowns; for instance, in a 3D fluids problem, we need to store three velocity components at every node.</li>
</ul>
<p>Therefore, <code>Data</code> allows the storage of multiple values (all of which can either be pinned or free, and all of which have their own global equation number); <code>Data</code> can also store a certain number of auxiliary (history) values used for timestepping. Finally, <code>Data</code> stores a pointer to a <code>TimeStepper</code> whose member functions relate the history values to the values' time-derivatives.</p>
<p>Direct, pointer-based read/write access to the <code>Data</code> values is provided by the functions </p><div class="fragment"><div class="line">Data::value_pt(<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>) </div>
<div class="ttc" id="acfortran_8h_html_adb50e893b86b3e55e751a42eab3cba82"><div class="ttname"><a href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a></div><div class="ttdeci">cstr elem_len * i</div><div class="ttdef"><b>Definition</b> <a href="cfortran_8h_source.html#l00603">cfortran.h:603</a></div></div>
</div><!-- fragment --><p> which returns a pointer to the i-th value at the present time, and by </p><div class="fragment"><div class="line">Data::value_pt(<a class="code hl_variable" href="cfortran_8h.html#af6f0bd3dc13317f895c91323c25c2b8f">t</a>,<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>) </div>
<div class="ttc" id="acfortran_8h_html_af6f0bd3dc13317f895c91323c25c2b8f"><div class="ttname"><a href="cfortran_8h.html#af6f0bd3dc13317f895c91323c25c2b8f">t</a></div><div class="ttdeci">char t</div><div class="ttdef"><b>Definition</b> <a href="cfortran_8h_source.html#l00568">cfortran.h:568</a></div></div>
</div><!-- fragment --><p> which returns a pointer to the <code>t</code> -th history value associated with value <code>i</code>. Read-only access is also provided by the functions </p><div class="fragment"><div class="line">Data::value(<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>)</div>
</div><!-- fragment --><p> and its time-dependent counterpart </p><div class="fragment"><div class="line">Data::value(<a class="code hl_variable" href="cfortran_8h.html#af6f0bd3dc13317f895c91323c25c2b8f">t</a>,<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>)</div>
</div><!-- fragment --><p> We recommend using these functions instead of the pointer-based access functions for read access because the two <code>Data::value(...)</code> functions are overloaded in the <code>Node</code> class (discussed below) so that they return suitably constrained nodal values if a <code>Node</code> is hanging. The <code>Data::value(...)</code> functions cannot be used to set <code>Data</code> values. For this purpose we provide the functions </p><div class="fragment"><div class="line">Data::set_value(<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>,val)</div>
</div><!-- fragment --><p> which sets the <code>i</code> -th <code>Data</code> value to the double precision number <code>val</code>; and its time-dependent counterpart </p><div class="fragment"><div class="line">Data::set_value(<a class="code hl_variable" href="cfortran_8h.html#af6f0bd3dc13317f895c91323c25c2b8f">t</a>,<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>,val)</div>
</div><!-- fragment --><p> which sets the <code>t</code> -th history value associated with the <code>i</code> -th <code>Data</code> value to the double precision number <code>val</code>.</p>
<p>The general convention for all time-dependent data is that the index t=0 refers to values at the present time, whereas the values associated with t&gt;0 correspond to history values. In many cases (e.g. BDF schemes) these history values are simply the values at previous timesteps, but this is not guaranteed. See the section <a class="el" href="index.html#timestepping">Time-stepping</a> for further details.</p>
<h2><a class="anchor" id="nodes"></a>
Nodes</h2>
<p>In FE computations, most (but not all; see below) <code>Data</code> are associated with nodal points. Conversely, all <code>Nodes</code> in a finite element mesh have <code>Data</code> associated with them. <code>Nodes</code> are therefore derived from <code>Data</code>, but also store a spatial position, specified by a certain number of spatial (Eulerian) coordinates.</p>
<p>The nodal positions are accessed by the member function </p><div class="fragment"><div class="line">Node::x(<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>) </div>
</div><!-- fragment --><p> which returns the current value of i-th nodal coordinate or </p><div class="fragment"><div class="line">Node::x(<a class="code hl_variable" href="cfortran_8h.html#af6f0bd3dc13317f895c91323c25c2b8f">t</a>,<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>) </div>
</div><!-- fragment --><p> which returns the value of i-th nodal coordinate at the present (t=0) timestep or a history value, if (t&gt;0); again, note that the history values are not necessarily positions at previous timesteps.</p>
<h3><a class="anchor" id="advanced_features_of_nodes"></a>
Advanced features:</h3>
<p><code>Nodes</code> have the following additional features:</p>
<ul>
<li>In moving-mesh problems, we must evaluate mesh velocities, which requires the storage of the nodal position at a number of previous timesteps. Storage for the positional history values is allocated by the <code>Node</code> constructor. A different <code>TimeStepper</code> may be used to represent time-derivatives of nodal position, so <code>Nodes</code> store a separate pointer to a positional <code>TimeStepper</code>. [Note: By default, we allocate the same amount of storage for the history of the nodal positions as we do for the history of the nodal values; e.g. if a <code>BDF&lt;2&gt;</code> scheme is used to evaluate the time-derivatives of the fluid velocities, we assume that the same timestepping scheme is used (and the same amount of storage required) to determine the mesh velocities from the nodal positions.]</li>
<li>For finite elements in which the global position of a point in an element is determined by interpolation from the position of the element's <code>Nodes</code> (Lagrange-type elements), we need only store the spatial position of the <code>Nodes</code>. In many other elements (e.g. Hermite-type elements), the interpolation of the geometry requires additional quantities, representing, e.g. the derivative of the mapping between local and global coordinates. Therefore, we allow the storage of additional positional variables at each <code>Node</code>, so that, in general, every <code>Node</code> has a number of <em>generalised</em> coordinates for each spatial coordinate direction. For instance, for nodes in 1D Hermite elements, the nodal coordinate of type '0' stores the global position at the node; the nodal coordinate of type '1' stores the derivative of the global position w.r.t. to the element's local coordinate. The member function <div class="fragment"><div class="line">Node::x_gen(k,<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>) </div>
</div><!-- fragment --> returns the <code>i</code> -th coordinate of the <code>k</code> -th coordinate type.</li>
<li>In the context of mesh refinement, nodes can become hanging nodes (i.e. nodes on an element's edge/face that are not shared by the adjacent element). The "hanging" status of a <code>Node</code> is indicated by the pointer to its <code>HangInfo</code> object. For ordinary (non-hanging) <code>Nodes</code> this pointer is NULL, the default setting; see the section <a class="el" href="index.html#Hanging_Nodes">Hanging Nodes</a> for a more detailed discussion of hanging nodes; in particular, the role of the member functions <code>Node::position()</code> and <code>Node::value()</code> </li>
<li>Mesh unrefinement can render nodes obsolete and we use a boolean flag to indicate this status. By default, <code>Nodes</code> are not obsolete.</li>
<li><b>BoundaryNodes:</b> <code>Nodes</code> "know" the domain/mesh boundaries on which they are located. A <code>Node</code> can be located on none, one or multiple boundaries; the latter case arises if the <code>Node</code> is located on edges and corners of the mesh. <br  />
 Storage of this information facilitates the automatic determination of boundary conditions for new <code>Nodes</code> that are created during mesh refinement.<br  />
 The majority of the <code>Nodes</code> will <b>not</b> be located on boundaries, however, and providing storage for the boundary information in every <code>Node</code> object is rather wasteful. The derived class <code>BoundaryNode</code> adds the required additional storage to the <code>Node</code> class and it follows that <br  />
 all <code>Nodes</code> that could lie on boundaries must be <code>BoundaryNodes</code>; see <a class="el" href="index.html#meshes">Meshes</a> for further details.</li>
<li><b>SolidNodes:</b> Many solid mechanics problems are formulated in Lagrangian coordinates. In this case, the governing equations are discretised in a fixed Lagrangian domain; the nodal coordinates represent the <code>Nodes'</code> fixed positions in this domain. When the elastic body deforms, material points (and hence the <code>Nodes</code>) are displaced to new Eulerian positions. The <code>SolidNode</code> class is derived from <code>Node</code> and contains storage for the <code>Nodes'</code> <b>fixed</b> positions (i.e. the Lagrangian coordinates) AND their <b>variable</b> positions (i.e. the Eulerian coordinates), which can be unknowns in the problem. To avoid confusion between the two, the access function for the nodal position, <div class="fragment"><div class="line">Node::x(...) </div>
</div><!-- fragment --> <b>always</b> refers to a <code>Node's</code> Eulerian position/coordinate. In <code>SolidNodes</code>, we provide a wrapper <div class="fragment"><div class="line">SolidNode::xi(..) </div>
</div><!-- fragment --> that provides access to the Lagrangian coordinates. Similarly, in the case of generalised coordinates <div class="fragment"><div class="line">Node::x_gen(...) </div>
</div><!-- fragment --> always refers to the generalised Eulerian position and <div class="fragment"><div class="line">SolidNode::xi_gen(...)</div>
</div><!-- fragment --> refers to the generalised Lagrangian position.</li>
</ul>
<h2><a class="anchor" id="elements"></a>
Elements</h2>
<h3><a class="anchor" id="Overview"></a>
Overview</h3>
<p>Most (finite-)elements in <code>oomph-lib</code> have a four-level inheritance structure which separates:</p><ol type="1">
<li>the basic functionality that is shared by all (generalised) elements.</li>
<li>the functionality that is shared by all finite elements.</li>
<li>the implementation of the finite element geometry (i.e. the shape-function-based mapping between local and global coordinates).</li>
<li>the representation of the mathematics that describes a specific problem.</li>
</ol>
<p>The distinction between geometry and &lsquo;maths&rsquo; greatly facilitates code-reuse as a (geometric) quad-element, say, can form the basis for elements that solve a variety of equations (e.g. Poisson, Advection&ndash;Diffusion, Navier&ndash;Stokes, ...). We shall now discuss the four levels of the element hierarchy in more detail.</p>
<h3><a class="anchor" id="Generalised_Element"></a>
Level 0: GeneralisedElement</h3>
<p>The class <code>GeneralisedElement</code> forms the base class for all elements in <code>oomph-lib</code>. It incorporates the basic functionality that all <b>elements</b> must have. The interfaces at this level are so general that a <code>GeneralisedElement</code> can represent discrete algebraic constraints (or even finite-difference stencils).</p>
<p>The main role of elements is to provide contributions to a global residual vector and to the global Jacobian matrix. The two virtual functions </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> GeneralisedElement::get_residuals(...) </div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> GeneralisedElement::get_jacobian(...) </div>
</div><!-- fragment --><p> specify the appropriate interfaces.</p>
<p>In multi-physics problems, the elemental residuals and Jacobian will be a combination of the residuals vectors and Jacobian matrices of the constituent single-physics elements. An obvious implementation is to use multiple inheritance and function overloading </p><div class="fragment"><div class="line"><span class="keyword">class </span>MultiPhysicsElement : <span class="keyword">public</span> <span class="keyword">virtual</span> SinglePhysicsOneElement,</div>
<div class="line">                            <span class="keyword">public</span> <span class="keyword">virtual</span> SinglePhysicsTwoElement</div>
<div class="line"> {   </div>
<div class="line"> </div>
<div class="line">  [...]</div>
<div class="line">                     </div>
<div class="line">  <span class="keywordtype">void</span> get_residuals(...) </div>
<div class="line">   {</div>
<div class="line">    SinglePhysicsOneElement::get_residuals(...);</div>
<div class="line">    SinglePhysicsTwoElement::get_residuals(...);</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">  [...]</div>
<div class="line"> </div>
<div class="line"> };</div>
</div><!-- fragment --><p> where the <code>MultiPhysicsElement</code> inherits from <code>SinglePhysicsOneElement</code> and <code>SinglePhysicsTwoElement</code>.</p>
<p>A problem with this implementation arises when we consider where to initialise the residuals vector. If the second single-physics <code>get_residuals(...)</code> function initialises the residuals vector, then the contribution of the first single-physics element will be negated. When writing a single-physics element, however, we cannot know whether it will ever be used as part of a multi-physics element and, if so, in which order the <code>get_residuals(...)</code> functions will be called. The solution adopted in <code>oomph-lib</code> is to provide the two additional virtual functions </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> GeneralisedElement::fill_in_contribution_to_residuals(...)</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> GeneralisedElement::fill_in_contribution_to_jacobian(...)</div>
</div><!-- fragment --><p> which <b>must</b> <b>not</b> initialise the residuals or Jacobian, but merely add the contribution of the element to the vector or matrix.</p>
<p>We then use the default implementation </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> GeneralisedElement::get_residuals(Vector&lt;double&gt; &amp;residuals) </div>
<div class="line"> {</div>
<div class="line">  <span class="comment">//Zero the residuals vector</span></div>
<div class="line">  residuals.initialise(0.0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Add the elemental contribution to the residuals vector</span></div>
<div class="line">  fill_in_contribution_to_residuals(residuals);</div>
<div class="line">  }</div>
</div><!-- fragment --><p> which permits a simple multi-physics re-implementation </p><div class="fragment"><div class="line"><span class="keyword">class </span>MultiPhysicsElement : <span class="keyword">public</span> <span class="keyword">virtual</span> SinglePhysicsOneElement,</div>
<div class="line">                            <span class="keyword">public</span> <span class="keyword">virtual</span> SinglePhysicsTwoElement</div>
<div class="line"> {   </div>
<div class="line"> </div>
<div class="line">  [...]</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">void</span> get_residuals(Vector&lt;double&gt; &amp;residuals) </div>
<div class="line">  {</div>
<div class="line">   <span class="comment">//Zero the residuals vector</span></div>
<div class="line">   residuals.initialise(0.0);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Add the first elemental contribution to the residuals vector</span></div>
<div class="line">   SinglePhysicsOneElement::fill_in_contribution_to_residuals(residuals);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Add the second elemental contribution to the residuals vector   </span></div>
<div class="line">   SinglePhysicsTwoElement::fill_in_contribution_to_residuals(residuals); </div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  [...]</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><p>The default implementation of <code>fill_in_contribution_to_jacobian(...)</code> uses finite differences to calculate the Jacobian matrix. Hence, the simplest possible implementation of a new element requires only the specification of <code>fill_in_contribution_to_residuals(...)</code>.</p>
<ul>
<li>When computing element residuals and Jacobian matrices, we need to know which <code>Data</code> affects the residuals (and hence the Jacobian matrix). For a <code>GeneralisedElement</code> such <code>Data</code> exists in two forms, accessed via pointers:<ul>
<li><code>Data</code> that is internal to each element is accessed via pointers to &lsquo;Internal <code>Data&rsquo;</code>. For instance, in fluid (finite) elements with discontinuous pressure interpolations, the pressure degrees of freedom are local to each element and are stored in the element's 'Internal <code>Data'</code>.</li>
<li><code>Data</code> that is external to the element. An example is a load parameter such as the external pressure that acts on a shell structure. Such <code>Data</code> is accessed via pointers to &lsquo;External <code>Data&rsquo;</code>. <br  />
</li>
<li>As discussed above, all <code>Data</code> contains values that are either free (i.e. unknown) or pinned (i.e. prescribed by boundary conditions). Free/unknown values have a non-negative global (equation) number. When assembling an element's local contribution to the global residual vector and the Jacobian matrix, we refer to the unknowns by their local (equation) numbers. In order to add the elemental contribution to the appropriate global degree of freedom, every element has a lookup table that establishes the relation between local and global equation numbers. This lookup table is automatically generated by the element's member function <div class="fragment"><div class="line">GeneralisedElement::assign_local_eqn_numbers() </div>
</div><!-- fragment --> Access to the lookup scheme is provided by the member function <code>eqn_number(...)</code> so that <div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> i_local;</div>
<div class="line">GeneralisedElement el;</div>
<div class="line"> </div>
<div class="line">[...]</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">unsigned</span> i_global=el.eqn_number(i_local); </div>
</div><!-- fragment --> returns the global equation number <code>i_global</code> corresponding to the local equation number <code>i_local</code>. The local equation numbers of the internal and external <code>Data</code> are stored in the private arrays <code>Internal_local_eqn</code> and <code>External_local_eqn</code>, accessed by the functions <code>GeneralisedElement::internal_local_eqn(...)</code> and <code>GeneralisedElement::external_local_eqn(...)</code>, respectively. Thus, <code>GeneralisedElement::internal_local_eqn(i_internal,i_value)</code> returns the local equation number of the <code>i_value</code> -th value stored in the <code>i_internal</code> -th internal <code>Data</code> object.</li>
<li>All elements have a pointer to a global <code>Time</code> object which allows the evaluation of time-dependent coefficients.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="Finite_Element"></a>
Level 1: FiniteElement</h3>
<p>The class <code>FiniteElement</code> is derived from <code>GeneralisedElement</code> and incorporates the basic functionality that all <b>finite</b> elements must have.</p>
<ul>
<li>All <code>FiniteElements</code> have a certain number of <code>Nodes</code>. We access the <code>Nodes</code> (and their associated values) via pointers and identify them via their (local) node numbers so that <div class="fragment"><div class="line">FiniteElement::Node_pt[n] </div>
</div><!-- fragment --> or the access function <div class="fragment"><div class="line">FiniteElement::node_pt(n) </div>
</div><!-- fragment --> returns a pointer to the element's <code>n</code> -th local <code>Node</code>.<ul>
<li>The <code>FiniteElement</code> class provides wrapper functions that give direct access to an element's (possibly generalised) nodal positions at the present timestep or, where appropriate, its positional history values, so that rather than <div class="fragment"><div class="line">FiniteElement::Node_pt[n]-&gt;x(<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>) </div>
</div><!-- fragment --> we can write <div class="fragment"><div class="line">FiniteElement::nodal_position(n,<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>) </div>
</div><!-- fragment --> Not only does this make the code more readable but also allows us to formulate the "mathematics" in general terms.<br  />
 [Furthermore, the function <code>FiniteElement::nodal_position(n,i)</code> accesses the nodal positions indirectly via <code>Node::position(...)</code> which ensures that the nodal position is consistent with any constraints associated with the <code>Node's</code> hanging status; see section <a class="el" href="index.html#Hanging_Nodes">Hanging Nodes</a> for further details.]</li>
<li><p class="startli">When <code>Nodes</code> are created in a (templated) finite element mesh, it is important that <code>Nodes</code> of the correct type with the appropriate amount of storage are created. For instance, Poisson elements require <code>Nodes</code> that provide storage for a single value at each <code>Node</code>, whereas 2D Taylor-Hood, Navier-Stokes elements require storage for three values (two velocities and one pressure) at the corner <code>Nodes</code>, but only two values (the two velocities) at all others. The member function </p><div class="fragment"><div class="line">FiniteElement::construct_node(...) </div>
</div><!-- fragment --><p> creates a <code>Node</code>, stores a pointer to the <code>Node</code> in the <code>FiniteElement::Node_pt</code> vector and returns a pointer to the newly created <code>Node</code>. The function is overloaded in elements that require a different type of <code>Node</code>, for example <code>SolidElement::construct_node(...)</code> creates a <code>SolidNode</code> rather than a <code>Node</code>. <br  />
 The function <code>FiniteElement::construct_node(...)</code> determines the necessary parameters for the node construction from virtual functions or internal data that must have been set during construction of the particular element. <a class="anchor" id="set_commands"></a> The spatial dimension of the <code>Node</code> and the number of generalised coordinates must be set in the constructor of a geometric <code>FiniteElement</code> (level 2 in the element hierarchy) by using the appropriate protected member functions. The only function that <b>must</b> be called is </p><div class="fragment"><div class="line">FiniteElement::set_dimension(dim), </div>
</div><!-- fragment --><p> which sets the spatial dimension of the element; by default the spatial dimension of the <code>FiniteElement's</code> <code>Nodes</code> is assumed to be the same. For example, </p><div class="fragment"><div class="line">FiniteElement::set_dimension(2) </div>
</div><!-- fragment --><p> sets both the spatial dimension of the element and the spatial dimension of its <code>Nodes</code> to be two. If the nodal dimension is not the same as the dimension of the element the member function </p><div class="fragment"><div class="line">FiniteElement::set_nodal_dimension(dim_node) </div>
</div><!-- fragment --><p> should be used to change the value of the nodal dimension. By default, <code>FiniteElements</code> interpolate a single position type, the position itself. If generalised coordinates are used, the number of generalised coordinates should be set using the function </p><div class="fragment"><div class="line">FiniteElement::set_n_nodal_position_type(n_pos_type). </div>
</div><!-- fragment --><p> The number of values stored at each <code>Node</code> is determined from the virtual member function </p><div class="fragment"><div class="line">FiniteElement::required_nvalue(...)  </div>
</div><!-- fragment --><p> In its default implementation this function returns zero so the function must be overloaded in specific derived <code>FiniteElements</code> that require storage for some values at its <code>Nodes</code>.</p>
<p class="startli">See section <a class="el" href="index.html#meshes">Meshes</a> for a full explanation of how and when <code>Nodes</code> are created.</p>
</li>
<li>The <code>FiniteElement</code> class also defines standard interfaces for member functions that compute the shape functions and their derivatives with respect to the local and global (Eulerian) coordinates, <div class="fragment"><div class="line">FiniteElement::shape(...) </div>
</div><!-- fragment --> <div class="fragment"><div class="line">FiniteElement::dshape_local(...) </div>
</div><!-- fragment --> The mappings from local to global Eulerian coordinates are implemented in complete generality in the class. The function <div class="fragment"><div class="line">FiniteElement::interpolated_x(...) </div>
</div><!-- fragment --> returns the interpolated Eulerian position within the element; <div class="fragment"><div class="line">FiniteElement::dshape_eulerian(...), </div>
</div><!-- fragment --> returns the derivative of the shape functions with respect to the Eulerian coordinates; and <div class="fragment"><div class="line">FiniteElement::J_eulerian(...) </div>
</div><!-- fragment --> returns the Jacobian of the mapping from Eulerian coordinates to local coordinates.</li>
<li>The function <code>GeneralisedElement::assign_local_eqn_numbers()</code> is overloaded in the <code>FiniteElement</code> class to ensure that local equation numbers are also assigned to the nodal <code>Data</code> (which does not necessarily exist in all <code>GeneralisedElements</code>). These local equation numbers are stored in the private array <code>FiniteElement::Nodal_local_eqn</code>, accessed by the function <code><code>FiniteElement::nodal_local_eqn(...)</code>.</code> </li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="Geometric_Element"></a>
Level 2: Geometric Elements</h3>
<p>At this level, we specify the element geometry and the mapping between local and global coordinates. Wherever possible, templating has been (and, for any newly developed elements, should be) used to formulate the elements in a dimension-independent way. For instance, Lagrange-type 1D line, 2D quad and 3D brick elements are implemented in the doubly-templated <code>QElement&lt;DIM,NNODE_1D&gt;</code> class. The template parameters indicate the spatial dimension of the element and the number of nodes along the element's one-dimensional edges. Hence, <code><a class="el" href="classoomph_1_1QElement.html">QElement&lt;1,3&gt;</a></code> is a three-node line element with a quadratic mapping between local and global coordinates; <code><a class="el" href="classoomph_1_1QElement.html">QElement&lt;3,2&gt;</a></code> is an 8 node brick element with a trilinear mapping between local and global coordinates. The dimension and the number of <code>Nodes</code> must be set by calling the appropriate <code>set_</code> functions in the constructor, see <a class="el" href="index.html#set_commands">above</a>.</p>
<p>The most important member functions implemented at this level include</p><ul>
<li>Functions that evaluate the shape functions (and their derivatives) at given values of the local coordinates.</li>
<li>Functions that specify the position of each <code>Node</code> inside its <code>FiniteElement</code>, in terms of the <code>FiniteElement's</code> local coordinates and, conversely, functions that determine whether a <code>Node</code> is located at a particular local coordinate.</li>
<li>Output functions that allow the element shapes to be plotted.</li>
</ul>
<p>Finally, we specify a pointer to a spatial integration scheme (usually a Gauss rule). The order of the integration scheme is based on the order of the interpolation in the isoparametric mapping. If this is inappropriate for an element that is derived from a given geometric element, the default assignment can be over-written at a higher level. This is discussed in more detail in a <a href="../../optimisation/html/index.html">separate document.</a></p>
<h3><a class="anchor" id="Maths_Element"></a>
Level 3: ‘The Maths’</h3>
<p>At this level, we implement the equations that are represented by the specific element. We implement the interpolation(s) for the unknown function(s), employing either the geometric shape functions that already exist on level 2, or employing additional shape functions defined at this level. This allows us to write further member functions such as <code>interpolated_u(...)</code>, say, which compute the i-th velocity component at the local coordinate <code>s</code> like this </p><div class="fragment"><div class="line"><span class="comment">// Create fluid element</span></div>
<div class="line">SomeFluidElement fluid_element;</div>
<div class="line"> </div>
<div class="line">[...]</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Vector of local coordinates</span></div>
<div class="line">Vector&lt;double&gt; <a class="code hl_variable" href="cfortran_8h.html#ab7123126e4885ef647dd9c6e3807a21c">s</a>(3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Vector of velocity components</span></div>
<div class="line">Vector&lt;double&gt; u(3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Compute the velocity at local coordinate s</span></div>
<div class="line">fluid_element.interpolated_u(<a class="code hl_variable" href="cfortran_8h.html#ab7123126e4885ef647dd9c6e3807a21c">s</a>,u);</div>
<div class="ttc" id="acfortran_8h_html_ab7123126e4885ef647dd9c6e3807a21c"><div class="ttname"><a href="cfortran_8h.html#ab7123126e4885ef647dd9c6e3807a21c">s</a></div><div class="ttdeci">static char t char * s</div><div class="ttdef"><b>Definition</b> <a href="cfortran_8h_source.html#l00568">cfortran.h:568</a></div></div>
</div><!-- fragment --><p> We introduce wrapper functions to access function values, so that we can formulate "The Maths" in generic terms. Rather than referring to the pressure at node <code>n</code>, via </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> n;</div>
<div class="line"><span class="keywordtype">double</span> press = Node_pt[n]-&gt;value(3);</div>
</div><!-- fragment --><p> (which forces us to remember that in this particular 3D fluid element, the pressure is stored as the fourth value at all nodes...), say, we provide an access function <code>p_fluid(...)</code> which allows us to write </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> n;</div>
<div class="line"><span class="keywordtype">double</span> press = fluid_element.p_fluid(n);</div>
</div><!-- fragment --><p> When writing these wrapper functions, direct access to the nodal values should be avoided to ensure that the element remains functional in the presence of hanging nodes. Hence, the wrapper functions should make use of the <code>Node::value(...)</code> functions as in this example </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> SomeFluidElement::p_fluid(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; n)</div>
<div class="line"> { <span class="keywordflow">return</span> Node_pt[n]-&gt;value(3);}</div>
</div><!-- fragment --><p> [See section <a class="el" href="index.html#Hanging_Nodes">Hanging Nodes</a> for a full description of hanging nodes.]</p>
<p>The functions </p><div class="fragment"><div class="line">FiniteElement::assign_additional_local_eqn_numbers()  </div>
</div><!-- fragment --> <div class="fragment"><div class="line">FiniteElement::get_residuals(...) </div>
</div><!-- fragment --> <div class="fragment"><div class="line">FiniteElement::get_jacobian(...) </div>
</div><!-- fragment --><p>that were defined (as virtual functions) in <code>FiniteElement</code> can now be implemented for the specific system of equations that are represented by this element. The function <code>assign_additional_local_eqn_numbers()</code> is called by <code>FiniteElement::assign_local_eqn_numbers()</code> and may be used to assign local equation numbers that correspond to particular physical variables. For example, in QCrouzeixRaviart "fluid" elements, the pressure is stored as 'internal <code>Data'</code>, so an internal array <code>P_local_eqn</code> could be defined by </p><div class="fragment"><div class="line">P_local_eqn[<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>] = internal_local_eqn(0,<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>) </div>
</div><!-- fragment --><p> but in QTaylorHood "fluid" elements, the pressure is stored as nodal <code>Data</code>, so that </p><div class="fragment"><div class="line">P_local_eqn[<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>] = nodal_local_eqn(Pconv[<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>],DIM+1) </div>
</div><!-- fragment --><p> In the above, <code>Pconv</code>[i] is an array that returns the local node number at which the <code>i</code> -th pressure freedom is stored and <code>DIM</code> is the dimension of the element. The use of such an array introduces a memory overhead, however, because each element must permanently store these additional integers. In general, we prefer to use member functions for this purpose. In QCrouzeixRaviart elements, for example, </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> p_local_eqn(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;n) </div>
<div class="line"> {</div>
<div class="line">  <span class="keywordflow">return</span> internal_local_eqn(0,n);</div>
<div class="line"> }</div>
</div><!-- fragment --><p> Thus, in our standard equations the function <code>assign_additional_local_eqn_numbers()</code> is not used.</p>
<p>Finally, the virtual function </p><div class="fragment"><div class="line">FiniteElement::required_nvalue(...)  </div>
</div><!-- fragment --><p> should be implemented to specify the number of values that are stored at each of the element's local <code>Nodes</code>. The default number of values stored at a <code>Node</code> is zero.</p>
<h3><a class="anchor" id="advanced_features_of_elements"></a>
‘Advanced’ features for the ‘Maths’ level:</h3>
<p>It often makes sense to subdivide the &lsquo;Maths&rsquo; level further into</p><ol type="1">
<li>A class that contains the abstract FE formulation of the mathematical problem.</li>
<li>A class that combines the mathematical formulation with a specific geometrical element.</li>
</ol>
<p>An example is given by the <code>QPoissonElements</code> which inherit their maths from <code>PoissonEquations</code> (templated by the spatial dimension) and their geometry from <code>QElement</code> (templated by the spatial dimension and the number of nodes). <code>PoissonEquations</code> specifies the weak form of the Poisson equation in terms of (virtual) shape and test functions. The <code>QPoissonElements</code> turn this abstract formulation into a specific (isoparametric) element, by specifying both test and shape functions as the geometric shape functions defined in <code>QElement</code>.</p>
<h3><a class="anchor" id="no_args_for_element_constructors"></a>
Important convention regarding element constructors</h3>
<p>To facilitate mesh generation and adaptation it is important that element constructors should <b>not</b> have <b>any</b> arguments! If arguments must be passed to an element (e.g. function pointers to source functions, etc.), this should be done <b>after</b> the mesh generation, usually in the <code>Problem</code> constructor. In adaptive mesh refinement procedures any function/data pointers in newly created elements are set to be the same as those of the father element. If this is not the desired behaviour, arguments should be passed to the elements in the function <code>Problem::actions_after_adapt()</code>.</p>
<h2><a class="anchor" id="meshes"></a>
Meshes</h2>
<p>At its most basic level, a <code>Mesh</code> is simply a collection of elements and <code>Nodes</code>, accessed by the vectors of pointers, <code>Mesh::Element_pt</code> and <code>Mesh::Node_pt</code>, respectively. To facilitate the application of boundary conditions, we also store vectors of pointers to the (<code>Boundary</code>)<code>Nodes</code> that lie on the boundaries of the mesh. They are accessible via the member function </p><div class="fragment"><div class="line">Mesh::boundary_node_pt(<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>,j) </div>
</div><!-- fragment --><p> which returns a pointer to the <code>j</code> -th node on the <code>i</code> -th boundary of the mesh.</p>
<h3><a class="anchor" id="Mesh_generation"></a>
Mesh generation</h3>
<p>The <code>oomph-lib</code> data structure is designed to make the mesh generation process generic so that meshes developed for one particular problem can easily be re-used in others. For this reason, it is generally assumed that a <code>Mesh</code> contains only elements of a single type and that this element type is passed to the <code>Mesh</code> constructor as a template parameter. Problems that require multiple element types should use multiple meshes, which are discussed in more detail below. It is possible to mix types of elements within a single <code>Mesh</code>, if desired; this can be advantageous when the element types are very closely related, for example "free surface" elements in a mesh of "Fluid" elements.</p>
<p>Mesh generation (usually performed in the <code>Mesh</code> 's constructor) then works as follows:</p><ol type="1">
<li>Create the first element and add the pointer to it to the <code>Mesh::Element_pt</code> vector. (We know which element to build because we have passed its type as a template parameter.) Since element constructors do not take any arguments, this step is completely generic and ensures that a <code>Mesh</code> that was originally created to solve a Poisson equation, say, can also be used to solve Navier-Stokes equations (provided the element topology is the same, i.e. provided the elements are derived from the same type of geometric element (e.g. quad or triangle). The element now exists but does not know anything about its <code>Nodes</code> etc.</li>
<li>Loop over the element's <code>Nodes</code> and for each Node:<ol type="a">
<li>Create the <code>Node</code> using the element's <div class="fragment"><div class="line">FiniteElement::construct_node(...) </div>
</div><!-- fragment --> member function. As discussed above, this function creates <code>Nodes</code> of exactly the right type and fills in the element's own <code>Node_pt</code> vector.</li>
<li><code>FiniteElement::construct_node(...)</code> returns a pointer to the newly created <code>Node</code>; add this to the <code>Mesh::Node_pt</code> vector.</li>
<li>Assign the nodal coordinates.</li>
</ol>
The <code>Node</code> is now fully functional and (by default) all values that are stored with it are free (i.e. not pinned).</li>
<li>If the <code>Node</code> is located on a mesh boundary then it must be a <code>BoundaryNode</code>. <code>BoundaryNodes</code> can be created using the function <div class="fragment"><div class="line">FiniteElement::construct_boundary_node(...) </div>
</div><!-- fragment --> in place of <code>FiniteElement::construct_node(...)</code>. Alternatively, if the <code>Node</code> has already been created, it can be upgraded to a <code>BoundaryNode</code> by using the function <div class="fragment"><div class="line">Mesh::convert_to_boundary_node(...) </div>
</div><!-- fragment --> The function <div class="fragment"><div class="line">Mesh::add_boundary_node(<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>,&amp;node) </div>
</div><!-- fragment --> should then be used to add (a pointer to) the <code>BoundaryNode</code> to the <code>Mesh's</code> boundary-storage scheme. In addition, the function <code>Mesh::add_boundary_node()</code> passes boundary information to the <code>Node</code> itself.</li>
<li>Create the next element and loop over its <code>Nodes</code>. Some <code>Nodes</code> will already exist (because they have been created by the first element). For such <code>Nodes</code>, we merely add the pointer to the existing <code>Nodes</code> to the element's <code>Node_pt</code> vector. If a <code>Node</code> does not exist yet, we create it, as discussed above.</li>
<li>Keep going until all the elements and <code>Nodes</code> have been built.</li>
</ol>
<h3><a class="anchor" id="Node_DOF_numbering"></a>
Equation/DOF numbering at the mesh level</h3>
<p>Now that the <code>Mesh</code> is assembled, we can set up the numbering scheme for the unknowns that are associated with the <code>Nodes</code> and with the elements' &lsquo;internal <code>Data</code> &rsquo;. (For problems that involve &lsquo;external <code>Data</code> &rsquo;, i.e. <code>Data</code> that is not associated with <code>Nodes</code> and elements, a further step is required; see section <a class="el" href="index.html#problems">Problems</a> below). As discussed above, whenever a <code>Data</code> object is created (either as part of a <code>Node</code> in the mesh or as &lsquo;internal <code>Data</code> &rsquo; inside an element), its values are assumed to be free (i.e. not pinned). Before we can set up the equation numbering scheme, we must pin all those <code>Data</code> values that are prescribed by boundary conditions. This is generally done at the <code>Problem</code> level (see below) and for the subsequent discussion, we assume that this step has already taken place.</p>
<p>The equation numbering scheme must achieve two things:</p><ul>
<li>Every unknown value needs to be associated with a unique, non-negative global equation number.</li>
<li>All elements need to set up the lookup tables that establish the relation between local and global equation numbers.</li>
</ul>
<p>These tasks are performed in two steps. The function </p><div class="fragment"><div class="line">Mesh::assign_global_eqn_numbers(...) </div>
</div><!-- fragment --><p> whose argument is a vector of pointers to doubles, <code>dof_pt</code>, assigns the (global) equation numbers for the element's internal <code>Data</code> and for all <code>Data</code> associated with the <code>Mesh's</code> <code>Nodes</code>. On return from this function, <code>dof_pt</code>[i] points to the value of the i-th global degree of freedom. <br  />
 The setup scheme (which is fully implemented in <code>oomph-lib</code>) works as follows:</p><ol type="1">
<li>Loop over all <code>Nodes</code> in the <code>Mesh</code>.<ul>
<li>Loop over all values that are stored at that <code>Node</code>.<ul>
<li>If the value is free (i.e. not pinned), add the pointer to the value to the <code>dof_pt</code> vector.</li>
</ul>
</li>
</ul>
</li>
<li>Loop over all elements.<ul>
<li>In every element, loop over the &lsquo;internal <code>Data</code> &rsquo;<ul>
<li>For every instance of &lsquo;internal <code>Data</code> &rsquo;, loop over its values.<ul>
<li>If the value is free (i.e. not pinned), add pointer to the value to the <code>dof_pt</code> vector.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>Once this has been done (for all <code>Meshes</code>, if there are multiple ones), the function </p><div class="fragment"><div class="line">Mesh::assign_local_eqn_numbers(...) </div>
</div><!-- fragment --><p> loops over all elements and executes their </p><div class="fragment"><div class="line">FiniteElement::assign_local_eqn_numbers(); </div>
</div><!-- fragment --><p> member function to set up the elements' lookup table that translates between local and global equation numbers.</p>
<h2><a class="anchor" id="problems"></a>
Problems</h2>
<p>Finally, we reach the highest level of the <code>oomph-lib</code> hierarchy, the <code>Problem</code> itself. The generic components of <code>Problem</code>, provided in the base class of that name, are:</p><ul>
<li>A pointer to the global <code>Mesh</code> (which can represent a number of submeshes, see below).</li>
<li>A pointer to the (discrete) <code>Time</code> (see section on <a class="el" href="index.html#timestepping">Time-stepping</a>).</li>
<li>A vector of pointers to (possibly multiple) <code>TimeSteppers</code>.</li>
<li>A vector that holds pointers to any &lsquo;global <code>Data</code> &rsquo;, i.e. <code>Data</code> that is not associated with elements or <code>Nodes</code>.</li>
<li>A vector <code>Dof_pt</code> that stores the pointers to all the unknown values (the degrees of freedom) in the problem.</li>
</ul>
<p><b>Multiple</b> <b>Meshes</b> </p>
<p>The mesh generation process previously described was for meshes that contain only elements of a single type. The process could easily be generalised to meshes that contain multiple element types by providing multiple template parameters. <br  />
 When solving a fluid-structure interaction (FSI) problem we could, therefore, create a single mesh that discretises both the fluid and the solid domains with appropriate elements. However, to facilitate code re-use it is desirable to keep meshes as simple as possible so that a mesh that was originally developed for a pure fluids problem can also be used in an FSI context. For this reason, the <code>Problem</code> class allows a problem to have multiple (sub-)meshes. Pointers to each sub-mesh must be stored in Problem's <code>Sub_mesh_pt</code> vector by using the function </p><div class="fragment"><div class="line">Problem::add_sub_mesh(Mesh* <span class="keyword">const</span> &amp;mesh_pt) </div>
</div><!-- fragment --><p> However, many of the generic operations within <code>oomph-lib</code> (equation numbering, solving, output of solutions,...) involve looping over <b>all</b> elements and <code>Nodes</code> in the problem. Therefore, if a <code>Problem</code> contains multiple (sub-)meshes, the sub-meshes must be combined into a single global <code>Mesh</code> whose <code>Element_pt</code> and <code>Node_pt</code> vectors provide ordered access to the elements and <code>Nodes</code> in <b>all</b> submeshes. The function </p><div class="fragment"><div class="line">Problem::build_global_mesh() </div>
</div><!-- fragment --><p> combines the sub-meshes into the global <code>Mesh</code> and must be called once all the sub-meshes have been constructed and "added" to the <code>Problem</code>.</p>
<p><b>Important:</b> Many operations (such as the shifting of history values in time-stepping) must be performed exactly once for each <code>Node</code> (or <code>Data</code>). Therefore, the vector of (pointers to) nodes in the global <code>Mesh</code> must not contain any duplicate entries. When copying (pointer to) <code>Nodes</code> from the submeshes into the global <code>Mesh</code>, the function <code>Problem::build_global_mesh()</code> ignores any <code>Nodes</code> that have already been copied from a previous submesh. [The <code>Mesh::self_test()</code> function checks for duplicates in the <code>Mesh::Node_pt</code> vector.]</p>
<p><b>Convention:</b> Recall that (<code>Boundary</code>)Nodes are &lsquo;told&rsquo; about the number of the boundary they live on when the (sub-)meshes are constructed. In the context of multiple meshes, this raises the question if this number should continue to refer to the boundary number within the submesh or be updated to a boundary number within the global <code>Mesh</code>. We adopt the convention that boundary numbers remain those that were originally assigned when the submeshes were constructed.</p>
<p><b>Multiple</b> <b>meshes</b> <b>and</b> <b>adaptivity:</b> Mesh adaptation is performed separately for each submesh. Following the adaptation of one or more submeshes (in the process of which various <code>Nodes/elements</code> will have been created/deleted), we must also update the global <code>Mesh</code>. This is done by calling </p><div class="fragment"><div class="line">Problem::rebuild_global_mesh(); </div>
</div><!-- fragment --><p> and this function is executed automatically if the mesh adaptation/refinement is performed by </p><div class="fragment"><div class="line">Problem::refine_uniformly(); </div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line">Problem::adapt(); </div>
</div><!-- fragment --><h3><a class="anchor" id="prob_setup"></a>
Problem Construction</h3>
<p>Here's an overview of how <code>Problems</code> are set up and solved in <code>oomph-lib</code>. For simplicity, we illustrate the process for a problem with a single <code>Mesh</code> that contains elements of a single type.</p><ol type="1">
<li>Define the element type and the <code>TimeStepper</code> (if the problem is time-dependent).</li>
<li>Build the <code>Mesh</code>, passing the element type as a template parameter and the <code>TimeStepper</code> as an argument to the Mesh constructor. (Typically <code>Mesh</code> constructors take a pointer to a <code>TimeStepper</code> as an argument since the <code>TimeStepper</code> needs to be passed to the element's <code>FiniteElement::construct_node(...)</code> function. If the <code>Problem</code> has no time-dependence, we can pass a pointer to the static <code>Mesh::Steady</code> timestepper; many <code>Mesh</code> constructors use a pointer to this <code>TimeStepper</code> as the default argument).</li>
<li>Create the <code>Problem</code> 's global <code>Data</code> (if it has any).</li>
<li>Apply the essential boundary conditions by pinning the appropriate values; all other values remain free.</li>
<li>We now have a fully assembled <code>Mesh</code> and all elements know their constituent <code>Nodes</code>. However, because element constructors are not allowed to have any arguments, all but the simplest of elements will now have to be provided with additional information. For instance, we might need to set pointers to source functions, etc.</li>
<li>Assign the equation numbers to all unknowns in the problem. This is accomplished in a two-stage process by <div class="fragment"><div class="line">Problem::assign_eqn_numbers(...) </div>
</div><!-- fragment --> which<ol type="a">
<li>Assigns the equation numbers for all global <code>Data</code> (if any)</li>
<li>Loops over the submeshes to perform the global equation numbering for all values associated with the <code>Meshes</code> (i.e. <code>Nodes</code> and elements), using <br  />
 <div class="fragment"><div class="line">Mesh::assign_global_eqn_numbers(...) </div>
</div><!-- fragment --></li>
<li>Loops over the submeshes again to perform the local equation numbering for all elements associated with the meshes using <br  />
 <div class="fragment"><div class="line">Mesh::assign_local_eqn_numbers(...) </div>
</div><!-- fragment --></li>
</ol>
[Note that we have to assign the global equation numbers for all meshes before we assign any local equation numbers. This is because the external <code>Data</code> of elements in one mesh might be nodal <code>Data</code> in another mesh &ndash; think of fluid-structure interaction problems]. At the end of this step, we will have filled in the <code>Problem's</code> <code>Dof_pt</code> vector which holds the pointers to the unknowns. [Note: The equation numbering scheme that is generated by the above procedure is unlikely to be optimal; it can (and in the interest of efficiency probably should) be changed afterwards by a problem-specific renumbering function.]</li>
<li>Before we can solve the <code>Problem</code> we will usually have to perform a few additional (problem-dependent) initialisation steps. For instance, we might want to assign initial and/or boundary conditions and provide initial guesses for the unknowns. For time-dependent problems, the <code>Problem</code> class provides a member function <div class="fragment"><div class="line">Problem::assign_initial_values_impulsive() </div>
</div><!-- fragment --> which creates a past history for all time-dependent unknowns, assuming an impulsive start. If you want a &lsquo;smooth&rsquo; start from a given previous time-history, you will have to implement this yourself; in this case, consult the section <a class="el" href="index.html#timestepping">Time-stepping</a> which outlines the time-stepping procedures in <code>oomph-lib</code>.</li>
<li>Now we can solve the <code>Problem</code> by calling <div class="fragment"><div class="line">Problem::newton_solve() </div>
</div><!-- fragment --> which employs the Newton-Raphson method to solve the nonlinear system of equations that is specified (formally) by the global Jacobian matrix and the global residual vectors. The function <code>Problem::newton_solve()</code> employs a linear solver which may be specified by <code>Problem::linear_solver_pt()</code>. The default linear solver is <a href="http://crd.lbl.gov/~xiaoye/SuperLU/">SuperLU </a>. The Newton iteration proceeds until the maximum residual falls below <code>Problem::Newton_solver_tolerance</code>. [If the number of iterations exceeds <code>Problem::Max_newton_iterations</code> or if the the maximum residual exceeds <code>Problem::Max_residuals</code>, the Newton solver throws an error]. When a solution has been found, all unknowns in the problem (which are accessible to the <code>Problem</code> via its <code>Dof_pt</code> vector) are up-to-date. The <code>Problem</code> class also provides the function <div class="fragment"><div class="line">Problem::unsteady_newton_solve(...) </div>
</div><!-- fragment --> for time-dependent problems. Given the current values of the unknowns (at time <code>t</code> = <code>Problem::Time_pt-&gt;time()</code> ) and their past histories, this function determines the solution at the advanced time <code>t+dt</code>. See section <a class="el" href="index.html#timestepping">Time-stepping</a> for more details on the conventions used in timestepping.</li>
</ol>
<p>The <code>Problem</code> class also has member functions which assemble the global residual vector and the global Jacobian matrix.</p>
<p><b>Important:</b> <br  />
 <br  />
 Since the unknowns in the <code>Problem</code> are accessed directly via pointers, their values are automatically updated during the Newton iteration. If the <code>Problem</code> has any auxiliary parameters that depend on the unknowns, their values need to be updated whenever an unknown might have changed (i.e. after every step of the Newton iteration). For such cases, the <code>Problem</code> class provides the four (empty) virtual functions </p><div class="fragment"><div class="line">Problem::actions_before_newton_step() </div>
</div><!-- fragment --> <div class="fragment"><div class="line">Problem::actions_after_newton_step() </div>
</div><!-- fragment --> <div class="fragment"><div class="line">Problem::actions_before_newton_solve() </div>
</div><!-- fragment --><p> and </p><div class="fragment"><div class="line">Problem::actions_after_newton_solve() </div>
</div><!-- fragment --><p> which are executed before/after every step of the Newton iteration and before/after the nonlinear solve itself, respectively. In addition, the virtual function </p><div class="fragment"><div class="line">Problem::actions_before_newton_convergence_check() </div>
</div><!-- fragment --><p> is executed before the residuals are calculated in the Newton solver.</p>
<p>When you formulate your own <code>Problem</code>, you will have to decide what (if anything) should live in these functions. Typical examples of actions that should be taken before a solve are the update of any boundary conditions. If the boundary conditions depend upon variables in the problem, they must be updated before every Newton step and should therefore be placed in <code>Problem::actions_before_newton_step()</code>. Actions that take place after a Newton step or solve would include things like updating the nodal positions, writing output or any other post-processing/solution monitoring. For example, if the solution after each Newton step were to be documented this could be accomplished by calling a suitable output function in the <code>Problem::actions_after_newton_step()</code> function.</p>
<p>In many cases, only the <code>Problem::actions_before_newton_convergence_check()</code> function is required. On entry to the Newton solver, the initial residuals are computed and checked, so the function is executed <b>before</b> any Newton steps are taken. After each Newton step, the residuals vector is recomputed and checked, so the function is also called after every Newton step (or before the next Newton step). Nonetheless, we provide all five functions for the greatest possible flexibility.</p>
<h1><a class="anchor" id="timestepping"></a>
Time-stepping</h1>
<h2><a class="anchor" id="time"></a>
Time</h2>
<p>Time-derivatives are generally evaluated by finite difference expressions, e.g. by BDF schemes. Hence, within the code, functions are only ever evaluated at discrete time levels. The class <code>Time</code> contains (a pointer to) the &lsquo;current&rsquo; value of the continuous time and a vector of current and previous timesteps so that the value of the continuous time at any previous timestep can easily be reconstructed. This is useful/necessary if there are any explicitly time-dependent parameters in the problem. The general convention within all timestepping procedures is to associate the values at the &lsquo;present&rsquo; time (i.e. the time for which a solution is sought) with time level &lsquo;0&rsquo;, those at the previous time level (where the solution is already known) with time levels &lsquo;1&rsquo;, &lsquo;2&rsquo; etc. The function </p><div class="fragment"><div class="line">Time::time(<a class="code hl_variable" href="cfortran_8h.html#af6f0bd3dc13317f895c91323c25c2b8f">t</a>) </div>
</div><!-- fragment --><p> therefore returns the &lsquo;current&rsquo; value of the continuous time if t=0, the continuous time before the previous timestep if t=1, etc.</p>
<h2><a class="anchor" id="basic_timestepping"></a>
Basic Time-stepping</h2>
<p>The base class <code>TimeStepper</code> provides the basic functionality required to evaluate time derivatives, and to keep track of the time histories of the unknowns. Primarily, a <code>TimeStepper</code> stores the coefficients (weights) that allow the evaluation of time-derivatives (up to a certain order) in terms of the history values stored in <code>Data</code>. Synchronisation of multiple <code>TimeStepper</code> s is ensured by providing them with pointers to the <code>Problem's</code> (single) <code>Time</code> object.</p>
<p>Here's an illustration of the time-stepping procedure for an implicit scheme.</p><ul>
<li><b>Stage</b> <b>1</b>: <b>Initialise</b> <ol type="1">
<li>Add a <code>TimeStepper</code> to the <code>Problem</code>. If a <code>Time</code> object has not yet been created, the <code>Problem::add_time_stepper_pt(...)</code> function creates one with the necessary storage. If the <code>Time</code> object already exists and the new <code>TimeStepper</code> requires more storage than presently exists, the storage in the <code>Time</code> object is resized. The function also passes a pointer to the global <code>Time</code> object to each <code>TimeStepper</code>.</li>
<li>Set up the <code>Problem</code> as discussed in section <a class="el" href="index.html#problems">Problems</a></li>
<li>Initialise the history of the previous timesteps by calling <code>Problem::initialise_dt(...)</code>.</li>
<li>Provide initial values for all unknowns. <b>Note:</b> In many cases, the initial values may be the result of a steady calculation. The function <code>Problem::steady_newton_solve()</code> should be used to calculate these values. The function sets the weights of the time-stepping scheme such that the time derivatives are zero and a steady problem is solved, even when the <code>Problem's</code> <code>TimeStepper</code> is not the dummy timestepper, <code>Steady</code>.</li>
<li>Provide time histories for the values (pinned <em>and</em> free!), either by imposing an impulsive start or by setting history values according to some given time-dependence: When generating the initial time history for the values from a given (&lsquo;exact&rsquo;) solution, assign the current values and the history values so that the solution is represented correctly at the initial time, <code>Time::time()</code>. At the end of this stage, <code>Data::value(...)</code> must return the current values and <br  />
 <code>TimeStepper::time_derivative(...)</code> must return their time-derivatives at the initial time.</li>
</ol>
</li>
<li><b>Stage</b> <b>2</b>: <b>Perform</b> <b>one</b> <b>timestep:</b> <br  />
 A timestep is performed by using the <div class="fragment"><div class="line">Problem::unsteady_newton_solve(...) </div>
</div><!-- fragment --> function, which implements the following steps:<ol type="1">
<li>Shift the time values back using <div class="fragment"><div class="line">Problem::shift_time_values() </div>
</div><!-- fragment --> (For BDF timesteppers, this simply moves the history values back by one level; see below for a detailed discussion of how the shifting of the history values is performed).</li>
<li>Solve the <code>Problem</code> at the advanced time by performing the following steps<ol type="a">
<li>Choose a timestep <code>dt</code>.</li>
<li>Advance the <code>Problem's</code> global time and (re-)calculate the weights for the <code>TimeStepper(s)</code>.</li>
<li>Update any time-dependent boundary conditions etc., usually via <div class="fragment"><div class="line">Problem::actions_before_newton_solve() </div>
</div><!-- fragment --> or <div class="fragment"><div class="line">Problem::actions_before_implicit_timestep()</div>
</div><!-- fragment --></li>
<li>Call the nonlinear solver to find the unknowns at the current (advanced) time.</li>
</ol>
</li>
</ol>
</li>
<li><b>Stage:</b> <b>3</b> <b>Document</b> <b>the</b> <b>solution</b> <br  />
 We now have a completely consistent representation of the current and history values of the system's unknowns for the current value of <code>Time::time()</code>. This is an excellent moment to dump the solutions to disk or do any other post-processing. These steps may be included in <div class="fragment"><div class="line">Problem::actions_after_newton_solve() </div>
</div><!-- fragment --> or <div class="fragment"><div class="line">Problem::actions_after_implicit_timestep() </div>
</div><!-- fragment --></li>
<li>Now return to <b>Stage</b> <b>2</b> for the next timestep.</li>
</ul>
<p>It is important to understand how the shifting of the timesteps (in preparation for the next timestep) is performed because certain default operations will not be appropriate for all <code>Elements/</code> <code>Problems</code>. Recall that in time-dependent problems, <code>Data::value_pt(i)</code> points to the current (and, as yet, unknown) <code>Data</code> values, while <code>Data::value_pt(t,i)</code> for t&gt;0 points to the history values that the <code>TimeStepper</code> uses to work out time-derivatives. When we move to the next timestep, the history values need to be adjusted in the manner that is appropriate for the timestepping scheme. For instance, for BDF schemes, all values need to be pushed back by one time level. This operation is performed by the function </p><div class="fragment"><div class="line">TimeStepper::shift_time_values(...) </div>
</div><!-- fragment --><p> In the case of <code>Nodes</code>, the shifting of values associated with the nodal positions is performed by the function </p><div class="fragment"><div class="line">TimeStepper::shift_time_positions(...) </div>
</div><!-- fragment --><p> To ensure that all <code>Data</code> in the <code>Problem</code> is shifted once (and only once!) <code>Problem::shift_time_values()</code> performs the following operations:</p><ol type="1">
<li>Shift the values of the time history stored in the <code>Time</code> object.</li>
<li>Shift the time values in the global <code>Mesh</code>. This involves the following steps:<ol type="a">
<li>Loop over all elements and call <code>TimeStepper::shift_time_values(...)</code> for the <code>TimeStepper</code> corresponding to each internal <code>Data</code> value. This leads to the slightly ugly construction <div class="fragment"><div class="line">internal_pt(<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>)-&gt;time_stepper_pt()-&gt;shift_time_values(internal_pt(<a class="code hl_variable" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>))</div>
</div><!-- fragment --> but there appears to be no way to avoid this.</li>
<li>Loop over all <code>Nodes</code> in the mesh and<ol type="i">
<li>call <code>TimeStepper::shift_time_values(...)</code> for each <code>Node</code> 's <code>TimeStepper</code>.</li>
<li>call <code>TimeStepper::shift_time_positions(...)</code> for each <code>Node's</code> positional <code>TimeStepper</code>.</li>
</ol>
</li>
</ol>
</li>
<li>Shift the time values for all global <code>Data</code>.</li>
</ol>
<h2><a class="anchor" id="adaptive_time_stepping"></a>
Adaptive time-stepping</h2>
<p>In adaptive time-stepping, the size of the timestep is adjusted automatically, so that the global (temporal) error estimate, computed by the Problem member function </p><div class="fragment"><div class="line">Problem::global_error_norm() </div>
</div><!-- fragment --><p> remains below a preset threshold. However, the function <code>Problem::global_error_norm()</code> must be implemented for each specific problem. The error norm is usually constructed from the (estimated) errors of individual <code>Data</code> values. Estimates for these quantities are given by the differences between the actual value and a predicted value, as determined by </p><div class="fragment"><div class="line">TimeStepper::error_in_value(...) </div>
</div><!-- fragment --><p> and the errors in positional <code>Data</code> values, found by </p><div class="fragment"><div class="line">TimeStepper::error_in_position(...) </div>
</div><!-- fragment --><p>In moving mesh problems, a suitable norm is the root-mean-square of the errors in all positional coordinates at every <code>Node</code>. In fluid problems, the error is usually based on the velocity components, etc.</p>
<p>Once a suitable norm has been chosen, a single adaptive timestep is taken by the function </p><div class="fragment"><div class="line">Problem::adaptive_unsteady_newton_solve(...) </div>
</div><!-- fragment --><p> This function returns a double precision number that is the value of <code>dt</code> that should be taken at the next timestep. A typical calling loop is thus </p><div class="fragment"><div class="line"><span class="comment">// Initial suggestion for timestep</span></div>
<div class="line"><span class="keywordtype">double</span> dt=0.001;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <a class="code hl_variable" href="cfortran_8h.html#af6f0bd3dc13317f895c91323c25c2b8f">t</a>=0;<a class="code hl_variable" href="cfortran_8h.html#af6f0bd3dc13317f895c91323c25c2b8f">t</a>&lt;100;<a class="code hl_variable" href="cfortran_8h.html#af6f0bd3dc13317f895c91323c25c2b8f">t</a>++)</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// Try to take a timestep dt forward; if the computed</span></div>
<div class="line">  <span class="comment">// solution is not sufficiently accurate, reduce the</span></div>
<div class="line">  <span class="comment">// the timestep and repeat... Return the suggestion for</span></div>
<div class="line">  <span class="comment">// next timestep</span></div>
<div class="line">  <span class="keywordtype">double</span> dt_next = adaptive_unsteady_newton_solve(dt,...);</div>
<div class="line">  dt = dt_next;</div>
<div class="line"> }</div>
</div><!-- fragment --><p>Within the <code>Problem::adaptive_unsteady_newton_solve</code>(..) function, if the global error norm is too large, the step is rejected, the timestep reduced and the step repeated. If the timestep falls below a preset tolerance <code>Problem::Minimum_dt</code> (which has the default value <code>1.0e-12</code>), the program will terminate. It is also possible to set a maximum timestep by over-writing the (large) default for <code>Problem::Maximum_dt</code> (initialised to <code>1.0e12</code>) with a smaller value.</p>
<h2><a class="anchor" id="restarts"></a>
Restarts</h2>
<p>Time-dependent simulations can consume a lot of computer time, and it is essential to be able to restart simulations rather than having to re-do them from scratch if a computer crashes during the code execution. For this purpose the <code>Problem</code> class provides the two member functions </p><div class="fragment"><div class="line">Problem::dump(...) </div>
</div><!-- fragment --><p> and </p><div class="fragment"><div class="line">Problem::read(...) </div>
</div><!-- fragment --><p> which write/read the generic <code>Problem</code> components (i.e. the <code>Data</code> values and history values, the history of previous timestep increments, etc) to/from disk. These generic functions are typically called from within a specific <code>Problem's</code> own dump/read functions which also deal with any additional, problem-specific data that has to be recorded/reset to allow a proper restart.</p>
<h1><a class="anchor" id="mesh_refinement"></a>
Problem/Mesh adaptation</h1>
<h2><a class="anchor" id="RefineableProblems"></a>
Adaptation at the Problem level</h2>
<p>The ability to adaptively refine/unrefine the <code>Problem's</code> mesh(es) in regions in which the solution undergoes rapid/slow variations is of crucial importance for the overall efficiency of the solution process. Mesh-adaptation involves the following steps:</p><ol type="1">
<li>Compute an estimate of the error in the computed solution for all elements in the mesh.</li>
<li>Label the elements whose error estimate is the above the maximum (or below the minimum) permissible error.</li>
<li>Perform the actual mesh adaptation: elements whose error is too large are subdivided into &lsquo;son&rsquo; elements; elements whose error is too small are merged with their &lsquo;siblings&rsquo;, provided the &lsquo;siblings&rsquo; are also scheduled for de-refinement. Usually, certain bounds are imposed on the maximum and minimum refinement levels to prevent excessive mesh refinement (e.g. near singularities) or de-refinement. (While the use of very large elements might be permissible in regions in which the solution varies little, such elements will provide a poor representation of the domain shape and thus lead to unsatisfactory post-processing.)</li>
<li>Represent the previously computed solution on the newly created <code>Nodes</code> / elements.</li>
<li>Once all the <code>Problem's</code> submeshes have been adapted, update the <code>Problem</code> itself by updating the global <code>Mesh</code>, re-generating the equation numbering scheme, etc.</li>
<li>Solve the adapted <code>Problem</code>.</li>
</ol>
<p>The <code>Problem</code> class provides several functions that perform these tasks completely automatically. For instance, the function </p><div class="fragment"><div class="line">Problem::refine_uniformly() </div>
</div><!-- fragment --><p> performs one uniform mesh refinement step for all (refineable) submeshes in the <code>Problem</code>. Similarly, the function </p><div class="fragment"><div class="line">Problem::adapt(...) </div>
</div><!-- fragment --><p> performs one mesh adaptation step. In both functions, mesh adaptation is followed by the update of the global <code>Mesh</code> and the re-assignment of the equation numbers so that, on return from these functions, the <code>Problem</code> can immediately be solved again.</p>
<p>The <code>Problem</code> class also provides overloaded versions of the steady and unsteady Newton solvers </p><div class="fragment"><div class="line">Problem::newton_solve(...) </div>
</div><!-- fragment --><p> and </p><div class="fragment"><div class="line">Problem::unsteady_newton_solve(...) </div>
</div><!-- fragment --><p> that automatically perform mesh adaptations until the computed solution satisfies the specified error bounds on all submeshes (or until a max. number of adaptations has been performed). The (empty) virtual member function </p><div class="fragment"><div class="line">Problem::set_initial_condition() </div>
</div><!-- fragment --><p> establishes the interface to the function that sets all <code>Data</code> to their initial conditions. This function must be overloaded if nontrivial initial conditions are to be applied. (If mesh adaptations are performed while the first timestep is computed, the initial conditions on the adapted mesh can usually be represented more accurately by re-assigning them, rather than by interpolation from the coarse initial mesh).</p>
<h2><a class="anchor" id="RefineableMeshes"></a>
Adaptation at the Mesh level</h2>
<p>The ability to perform the adaptation at the <code>Problem</code> level relies on the availability of standardised interfaces to functions that handle the adaptation on the <code>Mesh</code> level. These interfaces are provided in the class <code>RefineableMeshBase</code>. <code>RefineableMeshBase</code> is derived from <code>Mesh</code> and stores a pointer to a spatial error estimator, as well as double precision numbers representing the target error levels for the adaptation. The member function </p><div class="fragment"><div class="line">RefineableMeshBase::refine_uniformly(...) </div>
</div><!-- fragment --><p> performs one uniform mesh refinement step. Similarly, </p><div class="fragment"><div class="line">RefineableMeshBase::adapt(...) </div>
</div><!-- fragment --><p> adapts the mesh according to the specified error bounds, using the mesh's spatial error estimator to compute the elemental errors.</p>
<p>The details of the mesh adaptation process depend on the mesh topology; currently the virtual functions in <code>RefineableMeshBase</code> are implemented in a general form for quad and brick elements. We shall discuss the mesh adaptation process in detail for meshes of a particular type: The <code>RefineableQuadMesh</code> class implements the mesh adaptation procedures for two-dimensional, block-structured meshes which consist of the refineable variant of 2D <code>QElements</code>. The description provides a template for the development of mesh refinement procedures for meshes with different element topologies (e.g. triangular elements, or 3D <code>QElements</code>).</p>
<h2><a class="anchor" id="RefineableQuadMesh_section"></a>
Mesh adaptation for 2D quadrilateral meshes</h2>
<h3><a class="anchor" id="RefineableQElementsInmeshes"></a>
Refineable QElements</h3>
<p>The abstract base class <code>RefineableQElement&lt;2&gt;</code> &lsquo;upgrades&rsquo; existing elements of (geometric) type <code>QElement&lt;2,NNODE_1D&gt;</code> to versions that are suitable for use in adaptive computations. 'Upgrading' is achieved via inheritance so that, e.g., refineable Poisson elements are defined as: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> DIM, <span class="keywordtype">unsigned</span> NNODE_1D&gt;</div>
<div class="line"><span class="keyword">class </span>RefineableQPoissonElement : <span class="keyword">public</span> QPoissonElement&lt;DIM,NNODE_1D&gt;,</div>
<div class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> RefineablePoissonEquations&lt;DIM&gt;,</div>
<div class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> RefineableQElement&lt;DIM&gt;</div>
<div class="line">{</div>
<div class="line"> [...]</div>
<div class="line">}</div>
</div><!-- fragment --><p> The abstract base class <code>RefineableQElement&lt;2&gt;</code> defines virtual interfaces for those <code>FiniteElement</code> member functions that might have to be overloaded in the refineable version. In most cases, these member functions must be re-implemented to deal with the possible presence of hanging nodes, see below.</p>
<h3><a class="anchor" id="QuadTreeInMeshes"></a>
QuadTree procedures for mesh refinement</h3>
<p>Many of the mesh adaptation procedures for meshes of type <code>RefineableQuadMesh</code> use quadtree representations of the mesh. The quadtree navigation and search algorithms are based on those described in H. Samet's "The 
 design and analysis of spatial data structures" (Addison-Wesley, 1990). [Note: Unfortunately, in the usual tree terminology, quadtrees are made of <em>"nodes"</em> which are, of course, completely unrelated to the <code>Nodes</code> in the finite element mesh! The context and &ndash; within this document &ndash; the different typefaces should make it clear which is which...] It is important to understand that each <code>RefineableQElement&lt;2&gt;</code> has an associated <code>QuadTree</code> and each <code>QuadTree</code> has an associated <code>RefineableQElement&lt;2&gt;</code>. This two-way "has a" relationship permits a "clean" implementation of the (generic) <code>QuadTree</code> algorithms, although it does incur the cost of two additional pointers.</p>
<p>To illustrate the way in which <code>RefineableQuadMeshes</code> are represented by <code>QuadTrees</code>, the figure below shows a simple finite element mesh together with its quadtree-representation. There are two different types of quadtree classes: <code>QuadTrees</code> and <code>QuadTreeRoots</code>, which inherit from <code>QuadTrees</code>. The overall structure of the quadtree is defined by pointers between its <em>"nodes"</em>. Each <em>"node"</em> (an object of type <code>QuadTree</code>, shown in pink) in the quadtree has a pointer to its <em>"father"</em> (if this pointer is NULL, the <em>"node"</em> is the <em>"root node"</em>) and a vector of pointers to its four <em>"sons"</em> (if the vector is empty, the "node" is a <em>"leaf 
 \e node"</em>). This data structure is sufficient to navigate the quadtree (e.g. identify the quadtree's <em>"leaf nodes"</em>, determine a <em>"node"'s</em> neighbours, etc.) Each <code>QuadTree</code> also stores a pointer to an associated <em>"object"</em> of type <code>RefineableElement</code> (shown in light blue). The finite element mesh that is used in the computations only comprises those <code>RefineableElements</code> that are associated with <em>"leaf nodes"</em>. We refer to these elements as "active elements". In the diagram below, the active elements are identified by thick blue boundaries and the blue element numbers correspond to those in the mesh.</p>
<div class="image">
<img src="QuadTree.gif" alt=""/>
<div class="caption">
Illustration of a QuadTree and the associated RefineableQuadMesh</div></div>
<h3><a class="anchor" id="RefineableQuadMesh_setup_section"></a>
Mesh generation</h3>
<p>Any <code>Mesh</code> that is designed to contain 2D <code>QElement</code> s forms a suitable basis for a <code>RefineableQuadMesh</code> mesh and the initial stages of the mesh generation process can be performed exactly as described in section <a class="el" href="index.html#meshes">Meshes</a> above. Typically, the constructor for a <code>RefineableQuadMesh</code> will produce a relatively coarse background mesh (sometimes referred to as a "root mesh") which can subsequently be refined as required. As discussed before, the type of element will typically be passed as a template parameter and it is assumed that in any concrete instantiation of the <code>RefineableQuadMesh</code> class, the element is derived from the class <code>RefineableQElement&lt;2&gt;</code>.</p>
<p>Following the generic setup of the mesh (creating elements, <code>Nodes</code>, etc), the constructor of the <code>RefineableQuadMesh</code> must associate each <code>RefineableQElement&lt;2&gt;</code> in the mesh with a <code>QuadTreeRoot</code> and vice versa. The association between <code>RefineableQElement&lt;2&gt;s</code> and <code>QuadTreeRoots</code> is established by the <code>QuadTreeRoot</code> constructor which takes the pointer to the <code>RefineableQElement&lt;2&gt;</code> as its argument. The different <code>QuadTrees</code> must then be combined into a <code>QuadTreeForest</code>, whose constructor establishes each <code>QuadTree</code> 's N/S/W/E neighbours and their relative orientation. Here is an illustration:</p>
<div class="image">
<img src="QuarterCircleMesh.gif" alt=""/>
<div class="caption">
Mesh consisting of three RefineableQElement&lt;2&gt;s/ QuadTrees. Element/QuadTree numbers are blue, and the QuadTree's `northern' direction is indicated by the red arrows. The QuadTrees are combined to a QuadTreeForest which establishes their adjacency (QuadTree 2 is QuadTree 0's northern neighbour etc.) and their relative orientation (QuadTree 1's North coincides with QuadTree 2's West, etc.) Note that the RefineableQElement&lt;2&gt;'s local coordinates s_0 and s_1 are aligned with the QuadTree 's W--&gt;E and S--&gt;N directions, respectively.</div></div>
<p></p>
<p>The virtual member function </p><div class="fragment"><div class="line">RefineableQuadMesh::setup_quadtree_forest() </div>
</div><!-- fragment --><p> creates the <code>QuadTreeForest</code> automatically and should be called at the end of the <code>RefineableQuadMesh's</code> constructor. Finally, the mesh must be given a pointer to a spatial error estimator.</p>
<h3><a class="anchor" id="Hanging_Nodes"></a>
Hanging Nodes</h3>
<p>Before explaining the details of the mesh adaptation process we discuss how hanging nodes are treated in <code>oomph-lib</code>. The figure below shows a <code>RefineableQuadMesh</code> that originally consisted of four 4-node <code>RefineableQElements</code> and nine nodes (nodes 0 to 8). The mesh was adapted twice: During the first adaptation, the top right element was subdivided into four son elements and five new <code>Nodes</code> (nodes 9 to 13) were created. Then one of the newly created elements was subdivided again and in the process <code>Nodes</code> 14 to 18 were created. <br  />
 On this mesh, inter-element continuity is not ensured unless the hanging <code>Nodes</code> (=internal <code>Nodes</code> not shared by an adjacent element &ndash; here <code>Nodes</code> 9, 10, 14, 15, 17 and 18) are suitably constrained. For instance, the nodal values at <code>Node</code> 10 must be linear combinations of the values at nodes 4 and 7 if the solution is to remain continuous across the eastern edge of element 2. We refer to nodes 4 and 7 as the "master nodes" of <code>Node</code> </p><ol type="1">
<li><br  />
 The hanging node status of the <code>Nodes</code> can be determined by the following procedure:</li>
</ol>
<ul>
<li>Loop over all elements in the mesh. For each element <b>E</b> do:<ul>
<li>Loop over the edges of element. For each edge <b>e_E</b> do:<ul>
<li>Identify the neighbouring element, <b>N</b>, that faces edge <b>e_E</b>.</li>
<li>If the neighbouring element, <b>N</b>, has the same size as element <b>E</b> then the hanging node status of the <code>Nodes</code> that are located on edge <b>e_E</b> does not need to be changed.</li>
<li>If the neighbouring element, <b>N</b>, is larger than <b>E</b>, determine the edge <b>e_N</b> of element <b>N</b> that faces the edge <b>e_E</b>. Make all <code>Nodes</code> on edge <b>e_N</b> master nodes for all hanging <code>Nodes</code> on edge <b>e_E</b>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>If the difference in the refinement levels of two adjacent elements is greater than one, some of the master nodes determined by the above procedure will themselves be hanging nodes and these now need to be eliminated recursively. For instance, <code>Nodes</code> 9 and 11 are initially classified as master nodes for <code>Node</code> 17. However, <code>Node</code> 9 is a hanging node which depends on <code>Nodes</code> 4 and 5. Hence, the ultimate master nodes for <code>Node</code> 17 are <code>Nodes</code> 4, 5 and 11.</p>
<div class="image">
<img src="HangingNodes.gif" alt=""/>
<div class="caption">
Illustration of hanging nodes</div></div>
<p></p>
<p>The presence of hanging nodes must not affect the node-based representations for the unknown function(s) and for the geometric mapping within the elements. Hence, within any element <img class="formulaInl" alt="$ E $" src="form_0.png" width="10" height="10"/>, a scalar function <img class="formulaInl" alt="$ u $" src="form_1.png" width="9" height="6"/> should continue to be representable as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u = \sum_{j} U_{J(j,E)} \psi_j(s) \mbox{\hspace{5cm} (1)} \]" src="form_2.png" width="308" height="29"/>
</p>
<p> while the mapping between local and global coordinates should retain the form  </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[   {\bf x} = \sum_{j} {\bf X}_{J(j,E)} \psi_j(s),
        \mbox{\hspace{5cm} (2)} \]" src="form_3.png" width="316" height="29"/>
</p>
<p> where the sums are taken over the nodes <img class="formulaInl" alt="$ j $" src="form_4.png" width="6" height="11"/> of the element. <img class="formulaInl" alt="$ J(j,E) $" src="form_5.png" width="38" height="14"/> represents the global node number of local node <img class="formulaInl" alt="$ j $" src="form_4.png" width="6" height="11"/> in element <img class="formulaInl" alt="$ E $" src="form_0.png" width="10" height="10"/> and <img class="formulaInl" alt="$ U_J $" src="form_6.png" width="15" height="13"/> and <img class="formulaInl" alt="$ {\bf X}_J $" src="form_7.png" width="19" height="13"/> represent the function value at and the position vector to global node <img class="formulaInl" alt="$ J $" src="form_8.png" width="8" height="10"/>, respectively. To ensure inter-element continuity of <img class="formulaInl" alt="$ u $" src="form_1.png" width="9" height="6"/> and <img class="formulaInl" alt="$ {\bf x} $" src="form_9.png" width="9" height="6"/>, we constrain the nodal values and positions of the hanging nodes so that for every hanging node <img class="formulaInl" alt="$ J $" src="form_8.png" width="8" height="10"/> we have </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ U_J = \sum_{K} U_{K} \omega_{JK}  \]" src="form_10.png" width="94" height="28"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf X}_J = \sum_{K} {\bf X}_{K} \omega_{JK} \]" src="form_11.png" width="99" height="28"/>
</p>
<p> where the sum is taken over the hanging node's master nodes <img class="formulaInl" alt="$ K $" src="form_12.png" width="11" height="10"/> and the <img class="formulaInl" alt="$ \omega_{JK} $" src="form_13.png" width="24" height="9"/> are suitable weights. It is precisely this representation of the nodal positions and values that is implemented in <code>Node::value(...)</code> and <code>Node::position()</code>. [Note that different nodal values can have different hanging node constraints; e.g. in Taylor-Hood elements where the pressure and velocities are interpolated by linear and quadratic basis functions.]</p>
<p>For simply hanging nodes (e.g. <code>Nodes</code> 9, 10, 14 and 15 in the above sketch) the weights <img class="formulaInl" alt="$ \omega_{JK} $" src="form_13.png" width="24" height="9"/> are determined as follows:</p><ul>
<li>Find the neighbour element <b>N</b> that faces the hanging node <img class="formulaInl" alt="$ J $" src="form_8.png" width="8" height="10"/>.</li>
<li>Let <img class="formulaInl" alt="$ s_J $" src="form_14.png" width="13" height="9"/> be the local coordinate of hanging node <img class="formulaInl" alt="$ J $" src="form_8.png" width="8" height="10"/> in the neighbour element <b>N</b>.</li>
<li>For each master node <img class="formulaInl" alt="$ K $" src="form_12.png" width="11" height="10"/> in <b>N</b>, the weight <img class="formulaInl" alt="$  \omega_{JK} $" src="form_15.png" width="24" height="9"/> is then given by the shape function associated with master node <img class="formulaInl" alt="$ K $" src="form_12.png" width="11" height="10"/>, evaluated at <img class="formulaInl" alt="$ s_J $" src="form_14.png" width="13" height="9"/>, evaluated in element <b>N</b>. <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \omega_{JK} = \psi_K(s_J) \]" src="form_16.png" width="80" height="14"/>
</p>
</li>
</ul>
<p>For multiply hanging nodes (<code>Nodes</code> 17 and 18 in the above sketch), the weights of the ultimate master nodes are determined recursively, e.g. <img class="formulaInl" alt="$ \omega_{17\ 4} = \omega_{17\ 9}  
 \times \omega_{9 \ 4}. $" src="form_17.png" width="113" height="10"/><br  />
</p>
<p>For <code>RefineableQuadMesh</code> meshes, the above procedures are fully implemented. Executing the function </p><div class="fragment"><div class="line">RefineableQElement&lt;2&gt;::setup_hanging_nodes() </div>
</div><!-- fragment --><p> for each element in the mesh establishes which of the elements' <code>Nodes</code> are hanging and determines their primary master nodes and weights. Furthermore, it pins the values at the hanging nodes &ndash; because the values are constrained, they cannot be unknowns in the problem. When this function has been executed for all elements in the mesh, the recursive elimination of hanging master nodes is performed by calling </p><div class="fragment"><div class="line">RefineableMesh::complete_hanging_nodes(); </div>
</div><!-- fragment --><p>As mentioned above, the possible occurrence of hanging nodes needs to be reflected in the element's equation numbering scheme and in the functions that compute the elemental Jacobian matrix because the element residuals now potentially depend on <code>Nodes</code> outside the element. Therefore, <code>RefineableQElement&lt;2&gt;s</code> must re-implement various <code>FiniteElement</code> member functions, e.g., by re-implementing the virtual functions </p><div class="fragment"><div class="line">RefineableQElement&lt;2&gt;::get_residuals() </div>
</div><!-- fragment --><p> and </p><div class="fragment"><div class="line">RefineableQElement&lt;2&gt;::get_jacobian(...) </div>
</div><!-- fragment --><p> and various others, as specified in the <code>RefineableQElement&lt;2&gt;</code> class.</p>
<p>In practice, we again distinguish between the "geometry" and the "maths" by writing a general <code>RefineablePoissonEquations&lt;DIM&gt;</code> class that inherits from <code>PoissonEquations&lt;DIM&gt;</code> and re-implements the appropriate member functions.</p>
<h3><a class="anchor" id="RefineableQuadMesh_adaption_section"></a>
Mesh adaptation</h3>
<p>We can now discuss the details of the mesh adaptation process for <code>RefineableQuadMesh</code> meshes, although the general procedure is, in fact, generic: Once a solution has been computed, <code>Problem::adapt()</code> loops over all refineable submeshes, and uses their error estimator functions to compute the vector of elemental errors. The vector of errors is then passed to the submeshes' </p><div class="fragment"><div class="line">RefineableMesh::adapt(...) </div>
</div><!-- fragment --><p> function which performs the actual mesh adaptation and entails the following steps:</p><ul>
<li>Select all elements whose error exceeds the target maximum error for refinement, provided the elements have not already been refined to the maximum refinement level.</li>
<li>Select all elements whose error is smaller than the target minimum error for unrefinement, provided<ul>
<li>their siblings (which can be identified via (Quad)Tree procedures) can also be unrefined</li>
</ul>
and<ul>
<li>the unrefinement would not coarsen the mesh beyond the minimum refinement level.</li>
</ul>
</li>
<li>Now loop over all elements in the mesh (traversing through the leaves of the <code>QuadTreeForest</code>) and split those elements that are targeted for refinement. This involves the following steps:<ul>
<li>Create new <code>RefineableElements</code> of the same type as the father element.</li>
<li>Create new <code>QuadTrees</code> &mdash; as in the original setup, we pass the pointers to the newly created <code>RefineableElements</code> to the <code>QuadTree</code> constructors to establish the association between each <code>QuadTree</code> and its <code>RefineableElement</code>.</li>
<li>Declare the newly created <code>QuadTrees</code> to be the sons of the current <code>QuadTree</code>. This transforms the current <code>QuadTree</code> into a <em>"non-leaf node"</em> in the <code>QuadTreeForest</code>. Note that the <code>RefineableElement</code> is not deleted when it is split &ndash; it retains its full functionality (e.g. its pointers to its <code>Nodes</code>, etc). This ensures that the element is fully functional should its sons become scheduled for unrefinement at a later stage. Note that in cases when the <code>Nodes</code> are not uniformly-spaced, certain <code>Nodes</code> in the father will not be used by the sons. These <code>Nodes</code> will be marked as obsolete and deleted from the <code>Mesh</code>. The pointers to these <code>Nodes</code> must be set to NULL in the father element, but this cannot be done until after the hanging node procedures have been completed, see below.</li>
</ul>
</li>
<li>The newly-created elements now exist (and are accessible via the leaves of the <code>QuadTreeForest</code>) but they have not been &lsquo;built&rsquo; i.e. they do not have pointers to <code>Nodes</code> etc. We now loop over the <em>"leaf nodes"</em> in the <code>QuadTreeForest</code> and execute the virtual function <div class="fragment"><div class="line">RefineableElement::build() </div>
</div><!-- fragment --> for all newly created elements. In the specific case of a 2D <code>QuadMesh</code>, the <code>RefineableQElement&lt;2&gt;::build()</code> function will be called. [<b>Note:</b> Elements that have not been built yet are identified by the fact that the entries in their <code>Node_pt</code> vector point to NULL. All other elements are ignored by the <code>RefineableElement::build()</code> function.] <br  />
 The <code>RefineableElement::build()</code> function establishes the element's pointers to its <code>Nodes</code> and creates new <code>Nodes</code> as and when required: some <code>Nodes</code> will already have existed in the old mesh; some new <code>Nodes</code> might already have been created by a neighbouring element, etc. If a new <code>Node</code> needs to be created, it is allocated with the element's <code>FiniteElement::construct_node(...)</code> or <code>FiniteElement::construct_boundary_node(...)</code> functions. By default, the current and previous positions of the new <code>Nodes</code> are determined via the father element's geometric mapping. However, rather than referring directly to <code>QElement::interpolated_x(...)</code>, we determine the position with <div class="fragment"><div class="line">FiniteElement::get_x(...) </div>
</div><!-- fragment --> which determines the nodal positions based on the father element's macro-element representation if it exists; see section <a class="el" href="index.html#MacroElements">Domains and Macro Elements</a> for a discussion of macro elements for mesh refinement in domains with curvilinear boundaries. <br  />
 By default, all values at a newly created <code>Node</code> are free (not pinned). If a new <code>Node</code> is located on the edge of the father element, we apply the same boundary conditions (if any) that apply along the father element's edge. <br  />
 If a <code>Node</code> lies on a <code>Mesh</code> boundary, we add it to the <code>Mesh</code> 's storage scheme for <code>BoundaryNodes</code>. <br  />
 Finally, the values (and the history values) at the newly created <code>Nodes</code> must be assigned. This is done by using the interpolated values from the father element. Since the way in which values are interpolated inside an element is element-specific (e.g. in Taylor-Hood Navier-Stokes elements, different interpolations are used for the pressure and for the velocities), interpolated values are obtained from a call to the father element's <div class="fragment"><div class="line">RefineableQElement&lt;2&gt;::get_interpolated_values(...) </div>
</div><!-- fragment --> function which returns the vector of interpolated values (or history values) at a given local coordinate. This pure virtual function must be implemented for every specific <code>RefineableElement</code>. <br  />
 At this point, the generic steps in the build process are completed, but many particular <code>RefineableElements</code> now require further build operations. For instance, in Crouzeix-Raviart Navier-Stokes elements, the pressure interpolation is not based on nodal values but on internal <code>Data</code> which must be suitably initialised. For this purpose, we provide the interface <div class="fragment"><div class="line">RefineableElement::further_build(...) </div>
</div><!-- fragment --> which is executed at the end of <code>RefineableElement::build(...)</code> and can be used to perform any element-specific further build operations.</li>
<li>All new <code>Nodes</code> and elements have now been created. In the course of the mesh refinement, some of the previously existing <code>Nodes</code> that are (still) marked as hanging might have become non-hanging. Therefore, we now update the hanging nodes' values and coordinates so that their entries are consistent with their current hanging-node constraints and then reset their hanging-node status to non-hanging. Finally, we free (unpin) their nodal values. The hanging-node status of all <code>Nodes</code> will be re-assessed later, when the de-refinement phase is completed.</li>
<li>Now we loop over <b>all</b> <em>"nodes"</em> in the <code>QuadTreeForest</code>. If the sons of any <em>"non-leaf node"</em> in the <code>QuadTreeForest</code> are scheduled for de-refinement, we merge them into their father element. This entails the following steps:<ul>
<li>First we execute the father element's <div class="fragment"><div class="line">RefineableElement::rebuild_from_sons() </div>
</div><!-- fragment --> member function, which can be used, e.g., to determine suitable values for the father element's internal <code>Data</code> from the values of its sons. In addition, if any of the father's <code>Nodes</code> have been deleted during refinement, they must be re-created during the merge procedure.</li>
<li>Next, we 'unbuild' the son elements by marking those of its <code>Nodes</code> that do not exist in their father element as obsolete (this classification can later be over-ruled by other elements that need to retain the <code>Node</code>).</li>
<li>Now we delete the son <code>RefineableElements</code> and the associated <code>QuadTrees</code> and empty the father element's vector of pointers to its sons. This (re)turns the father element into a fully functional element.</li>
</ul>
</li>
<li>Next, we empty the <code>Mesh::Element_pt</code> vector and refill it with the currently active elements which are accessible via the <code>QuadTreeForest</code> 's <em>"leaf nodes"</em>.</li>
<li>Now we loop over all elements in the <code>Mesh::Element_pt</code> vector and mark their <code>Nodes</code> as non-obsolete.</li>
<li>We then update the <code>Nodes</code> hanging node status and adjust the nodal positions and values of the hanging nodes to make them consistent with the current hanging-node constraints.</li>
<li>We loop over all non-leaf elements in the <code>QuadTreeForest</code> and call their <code>deactivate_object()</code> function, which sets <code>FiniteElement::Node_pt</code>[n] to zero for any obsolete <code>Nodes</code>. Any <code>Nodes</code> in the <code>Mesh::Node_pt</code> vector that are still labelled as obsolete are truly obsolete and are deleted by calling <div class="fragment"><div class="line">Mesh::prune_dead_nodes() </div>
</div><!-- fragment --></li>
<li>Finally, in order to facilitate dump and restart operations we sort the <code>Nodes</code> into a standard order using <div class="fragment"><div class="line">Mesh::reorder_nodes() </div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="Macro_element_meshes"></a>
Mesh adaptation in domains with curved boundaries</h1>
<p>The mesh refinement procedures outlined above are perfectly adequate for meshes in polygonal domains. In such meshes the generation of the new nodal positions and the transfer of the solution from the old to the new mesh can be performed by simple interpolation, using the &lsquo;father&rsquo; element's geometric mapping and shape functions. However, in problems with curvilinear mesh boundaries we must ensure that the refined meshes provide a progressively more accurate representation of the curvilinear domain boundary.</p>
<p>To facilitate these steps, we now introduce the concept of <code>GeomObjects</code>, <code>Domains</code> and <code>MacroElements</code>, which allow a convenient and generic representation of domains that are bounded by time-dependent and/or curvilinear boundaries.</p>
<h2><a class="anchor" id="GeomObjects"></a>
Geometric Objects</h2>
<p>Here are two examples of curvilinear boundaries that are frequently encountered in computations on moving domains:</p><ul>
<li>In many problems the boundary <img class="formulaInl" alt="$\partial D$" src="form_18.png" width="18" height="10"/> of the moving domain <img class="formulaInl" alt="$D$" src="form_19.png" width="10" height="10"/> is given explicitly in terms of a position vector <p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf r}_{_{\partial D}}(\boldmath{\xi},t), \]" src="form_20.png" width="49" height="14"/>
</p>
 where <img class="formulaInl" alt="$ t $" src="form_21.png" width="5" height="9"/> is the (continuous) time and the components of the vector <img class="formulaInl" alt="$ \boldmath{\xi} $" src="form_22.png" width="8" height="13"/> parametrise the boundary. We have <img class="formulaInl" alt="$DIM({\bf r}_{_{\partial D}}) = DIM(\boldmath{\xi}) + 1$" src="form_23.png" width="144" height="14"/>. For instance, the surface of a cylinder <img class="formulaInl" alt="$C$" src="form_24.png" width="10" height="10"/> with time-dependent radius <img class="formulaInl" alt="$R(t)$" src="form_25.png" width="23" height="14"/> can be represented as  <p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf r}_{_{\partial C}} = \left( \begin{array}{c} 
                         R(t) \cos(\xi_2) \\
                         R(t) \sin(\xi_2) \\ 
                         \xi_1 \\ 
                         \end{array} \right). \]" src="form_26.png" width="139" height="46"/>
</p>
</li>
<li>In fluid problems with free surfaces or in fluid-structure interaction (FSI) problems, the domain boundary might have to be determined as part of the solution. In such cases, the boundary will have some computational representation. For instance, in an FSI computation in which a shell structure bounds the fluid domain, each shell finite element defines a small part of the fluid domain boundary and the shell element's local coordinates provide a parametrisation of some part of the boundary in a form similar to the one shown above.</li>
</ul>
<p>The common feature of these two examples is that, in both cases, the boundary is represented by a parametrised position vector. The <code>GeomObject</code> base class provides an abstract interface for such situations. In its most basic form, a &lsquo;geometric object&rsquo; simply provides a parametrisation of its shape by implementing the <code>GeomObject's</code> pure virtual member function </p><div class="fragment"><div class="line">GeomObject::position(xi,r)</div>
</div><!-- fragment --><p> which computes the position vector <code>r</code> at the coordinates specified by the vector <code>xi</code>. <code>GeomObject</code> also provides a large number of additional interfaces in the form of (broken) virtual functions. The most important of these is the time-dependent version of the above function </p><div class="fragment"><div class="line">GeomObject::position(xi,<a class="code hl_variable" href="cfortran_8h.html#af6f0bd3dc13317f895c91323c25c2b8f">t</a>,r)</div>
</div><!-- fragment --><p> which computes the position vector <code>r</code> at the coordinates specified by the vector <code>xi</code> at the <b>previous</b> <b>discrete</b> time level <code>t</code>. We follow the usual convention that</p><ul>
<li>for <code>t=0</code> the vector <code>r</code> is the position vector at the current time, <code> time = Time::time() = Time::time(0) </code></li>
<li>for <code>t=1</code> it represents the position at the previous (discrete) time level <code>t</code>, i.e. at the continuous time <code> time = Time::time() - Time::dt() = Time::time(1) </code></li>
<li>etc.</li>
</ul>
<p>By default, the virtual member function <code>GeomObject::position(xi,t,r)</code> calls the steady version <code>GeomObject::position(xi,r)</code>, so it only needs to be overloaded for genuinely time-dependent geometric objects (by default, the code execution terminates if the time-dependent version is called for <img class="formulaInl" alt="$ {\tt t} \ne 0; $" src="form_27.png" width="34" height="13"/> the function needs to be overloaded if this is not appropriate).</p>
<p>Further virtual member functions provide interfaces for the determination of the first and second spatial and temporal derivatives of the position vector, allowing the computation of boundary velocities, accelerations and curvatures, etc. These interfaces are provided as broken virtual functions, so they only need to be overloaded if/when the functionality is actually required in a particular application.</p>
<p>Typically, the shape of a <code>GeomObject</code> depends on a certain number of parameters (in the above examples, the radius <img class="formulaInl" alt="$ R(t) $" src="form_28.png" width="23" height="14"/> of the cylinder and the displacements of the shell element, respectively) which can be unknowns in the problem. We therefore store these parameters as (geometric) <code>Data</code>, whose values can be pinned or free.</p>
<h2><a class="anchor" id="MacroElements"></a>
Domains and Macro Elements</h2>
<p>For the purposes of mesh generation, we represent curvilinear domains by objects that are derived from the base class <code>Domain</code> and use <code>GeomObjects</code> to represent the curvilinear boundaries. For instance, the <code>QuarterCircleSectorDomain</code> sketched in the figure below is bounded by the geometric object <code>Ellipse</code> that parametrises the domain's curved boundary, shown in red.</p>
<p>Consider the coarse discretisation of the domain shown in the Fig. (a) and assume that element 2 (a four-node quad element from the <code>QElement</code> family) is scheduled for refinement into four son elements. As discussed above, by default the <code>Nodes</code> of the son elements are established/created as follows:</p><ul>
<li>If a <code>Node</code> already exists in the father element we store the pointer to the existing <code>Node</code> in the son element's <code>Node_pt</code> vector.</li>
<li>If a <code>Node</code> needs to be created, we determine its position from the geometric mapping of the father element. Thus the five new <code>Nodes</code> that need to be created when element 2 is refined, are placed at their father element's (i.e. element 2's) local coordinates (0,0), (0,1), (0,-1), (1,0) and (-1,0). The father element's <div class="fragment"><div class="line">RefineableQElement&lt;2&gt;::get_x(...) </div>
</div><!-- fragment --> determines the nodal position via a call to <code>QElement::interpolated_x(...)</code>. Similarly, the nodal values of the new <code>Nodes</code> are determined by using the interpolated values in the father element.</li>
</ul>
<div class="image">
<img src="MacroElementSketch.gif" alt=""/>
<div class="caption">
Illustration of mesh refinement with and without macro elements</div></div>
<p>For the element 0, this procedure would be perfectly adequate, as the domain boundary after refinement would (still) be captured exactly. However, when refining element 2 by this procedure, the new <code>Node</code> on the boundary is positioned on the straight line between the two boundary <code>Nodes</code> in the father element and not on the curved boundary itself, as shown in Fig. (b). Hence repeated mesh refinement will not lead to a better representation of the domain geometry and preclude convergence to the exact solution.</p>
<p>To overcome this problem, objects of type <code>Domain</code> provide a decomposition of the domain into a number of so-called <code>MacroElements</code>, as sketched in Fig. (c). Boundaries of the <code>MacroElements</code> are either given by (parts of) the (exact) curvilinear boundaries (as specified by the <code>Domain's</code> <code>GeomObjects</code>) or by (arbitrary and usually straight) internal edges (or, in 3D, faces). In 2D, <code>MacroElements</code> provide a mapping <img class="formulaInl" alt="$ {\bf r}(S_0,S_1) $" src="form_29.png" width="48" height="14"/> from a local coordinate system <img class="formulaInl" alt="$ (S_0, S_1) $" src="form_30.png" width="41" height="14"/>, with <img class="formulaInl" alt="$ S_i \in [-1..1]^2 $" src="form_31.png" width="68" height="15"/>, to the points inside the <code>MacroElement</code> via their member function </p><div class="fragment"><div class="line">MacroElement::macro_map(S,r) </div>
</div><!-- fragment --><p> The mapping needs to be chosen such that for <img class="formulaInl" alt="$ S_1\in [-1..1]$" src="form_32.png" width="64" height="14"/> the position vector <img class="formulaInl" alt="$ {\bf r}(S_0=-1,S_1) $" src="form_33.png" width="80" height="14"/> sweeps along the &lsquo;southern&rsquo; edge of the <code>MacroElement</code>, etc.; see Fig. (e). The form of the macro-element mapping is obviously not unique and it depends on the <code>MacroElement's</code> topology. The class <code>QMacroElement&lt;2&gt;</code> provides a mapping that is suitable for 2D quadrilateral elements and can therefore be used with <code>RefineableQElement&lt;2&gt;</code> s.</p>
<p>The constructors for objects of type <code>Domain</code> typically require a vector of pointers to the <code>GeomObjects</code> that define its boundaries. The <code>Domain</code> constructor then usually employs function pointers to the <code>GeomObject::position(...)</code> function to define the <code>MacroElement</code> boundaries. Once built, the <code>MacroElements</code> are accessible via the member function </p><div class="fragment"><div class="line">Domain::macro_element_pt(...). </div>
</div><!-- fragment --><p>We illustrate the macro-element based mesh generation and adaptation process for the case of <code>RefineableQuadMesh</code> meshes. Assume that the domain is represented by an object of type <code>Domain</code>. We build a coarse initial mesh which contains as many <code>RefineableQElement&lt;2&gt;s</code> as there are <code>QMacroElements</code> in the <code>Domain</code>. We associate each <code>RefineableQElement&lt;2&gt;</code> with one of the <code>QMacroElements</code> by storing a pointer to the <code>QMacroElement</code> in <code>FiniteElement::Macro_elem_pt</code>. Next, we use the <code>QMacroElements'</code> macro map to determine the <code>RefineableQElement&lt;2&gt;'s</code> nodal positions such that, e.g., the <code>RefineableQElement&lt;2&gt;'s</code> SW node is placed at the <code>QMacroElement</code> 's local coordinates <img class="formulaInl" alt="$(S_0,S_1)=(-1,-1)$" src="form_34.png" width="105" height="14"/>, etc. The fraction of the <code>QMacroElement</code> that is spanned by each <code>RefineableQElement&lt;2&gt;</code> is represented by the maximum and minimum values of the <code>QMacroElement's</code> local coordinates; the <code>RefineableQElement&lt;2&gt;</code> constructor initially sets these values to the defaults of +1.0 and -1.0, respectively, indicating that the <code>RefineableQElement&lt;2&gt;</code> spans the entire area of the corresponding <code>QMacroElement</code>.</p>
<p>With this additional information, we modify the <br  />
 <code>RefineableQElement&lt;2&gt;::build()</code> process as follows:</p><ul>
<li>After creating the son elements, we set their <code>FiniteElement::Macro_elem_pt</code> to that of their father.</li>
<li>We adjust the son's maximum and minimum <code>MacroElement</code> coordinates so that they span the appropriate fraction of the <code>MacroElement</code>. For instance, for the SW son element of element 2 in the above sketch, we set <img class="formulaInl" alt="$ S_0^{min}=-1, \  S_0^{max}=0, \ S_1^{min}=-1, \  S_1^{max}=0 $" src="form_35.png" width="253" height="15"/>. Should this element get refined again, we set its NW son element's coordinates to <img class="formulaInl" alt="$ S_0^{min}=-1, \  S_0^{max}=-0.5,
   \ S_1^{min}=-0.5, \  S_1^{max}=0 $" src="form_36.png" width="281" height="15"/>, etc.</li>
<li>The nodal positions of newly created <code>Nodes</code> are determined via calls to the father element's <code>RefineableQElement&lt;2&gt;::get_x(...)</code> function. If the father element is associated with a <code>MacroElement</code> (indicated by a non-NULL <code>RefineableQElement&lt;2&gt;::Macro_elem_pt</code> pointer), this function does not refer to <code>QElement::interpolated_x(...)</code> (i.e. the FE mapping) but places the new <code>Node</code> at the appropriate point inside the father's <code>MacroElement</code>. This ensures that <code>Nodes</code> that are created on the <code>Mesh</code> boundaries get placed on the <code>Domain</code> boundary, as shown in Fig. (d).</li>
<li>In time-dependent, moving mesh problems, the history of the new <code>Nodes'</code> position is established by calls to the time-dependent version of the <code>MacroElement::macro_map(...)</code> function, which in turn refers to the time-dependent <code>GeomObject::position(...)</code> function of the <code>GeomObjects</code> that define the <code>Domain</code> boundaries. Hence for all new <code>Nodes</code>, <code>Node::x(t,i)</code> for <code>t&gt;0</code>, returns the position the <code>Node</code> would have had if it had already existed at the previous time level t.</li>
<li>We retain the original procedure for initialising the current and previous values at the new <code>Nodes</code> and continue to determine them by interpolation from the father element, based on the father element's local coordinates. (We cannot determine the function values at the exact new nodal positions because new <code>Nodes</code> can be located outside their father elements.)</li>
</ul>
<h2><a class="anchor" id="moving_mesh"></a>
Macro-element-based node updates in moving mesh problems</h2>
<p>Once a <code>Mesh</code> is associated with a <code>Domain</code>, the function <code>Mesh::node_update()</code> updates the nodal positions in response to a change in the shape of the <code>GeomObjects</code> that define the <code>Domain</code> boundaries. [Note: This function updates all nodal positions first and then updates the positions of the hanging nodes to subject them to the hanging node constraints.] Alternative procedures for the update of the nodal positions in response to changes in the domain boundary are implemented in the <code>AlgebraicMesh</code>, <code>SpineMesh</code> and <code>SolidMesh</code> classes.</p>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. \ </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Tue Jan 13 2026 16:23:14
        </div>
      </div>
    </footer>
</body>
</html>
