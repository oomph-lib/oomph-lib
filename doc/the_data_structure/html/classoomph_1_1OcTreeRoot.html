<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: oomph::OcTreeRoot Class Reference</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../figures/manifest.json">
<link rel="mask-icon" href="../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../html/index.html"><img alt="oomph-lib" src="../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceoomph.html">oomph</a></li><li class="navelem"><a class="el" href="classoomph_1_1OcTreeRoot.html">OcTreeRoot</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classoomph_1_1OcTreeRoot-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">oomph::OcTreeRoot Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classoomph_1_1OcTreeRoot.html" title="OcTreeRoot is a OcTree that forms the root of a (recursive) octree. The &quot;root node&quot; is special as it ...">OcTreeRoot</a> is a <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> that forms the root of a (recursive) octree. The "root node" is special as it holds additional information about its neighbours and their relative rotation (inside a <a class="el" href="classoomph_1_1OcTreeForest.html" title="/////////////////////////////////////////////////////////////////////// /////////////////////////////...">OcTreeForest</a>).  
 <a href="classoomph_1_1OcTreeRoot.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="octree_8h_source.html">octree.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for oomph::OcTreeRoot:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classoomph_1_1OcTreeRoot.png" usemap="#oomph::OcTreeRoot_map" alt=""/>
  <map id="oomph::OcTreeRoot_map" name="oomph::OcTreeRoot_map">
<area href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree." alt="oomph::OcTree" shape="rect" coords="0,56,123,80"/>
<area href="classoomph_1_1TreeRoot.html" title="TreeRoot is a Tree that forms the root of a (recursive) tree. The &quot;root node&quot; is special as it holds ..." alt="oomph::TreeRoot" shape="rect" coords="133,56,256,80"/>
<area href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u..." alt="oomph::Tree" shape="rect" coords="0,0,123,24"/>
<area href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u..." alt="oomph::Tree" shape="rect" coords="133,0,256,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a594278fd254e72415e1523b1b8e7273d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTreeRoot.html#a594278fd254e72415e1523b1b8e7273d">OcTreeRoot</a> (<a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c">object_pt</a>)</td></tr>
<tr class="memdesc:a594278fd254e72415e1523b1b8e7273d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the root octree: Pass pointer to the <a class="el" href="classoomph_1_1RefineableQElement_3_013_01_4.html" title="Refineable version of QElement&lt;3,NNODE_1D&gt;.">RefineableQElement&lt;3&gt;</a> that is represented by the <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a>.  <a href="classoomph_1_1OcTreeRoot.html#a594278fd254e72415e1523b1b8e7273d">More...</a><br /></td></tr>
<tr class="separator:a594278fd254e72415e1523b1b8e7273d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da527433d221179d7e5eed13d547336"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTreeRoot.html#a3da527433d221179d7e5eed13d547336">OcTreeRoot</a> (const <a class="el" href="classoomph_1_1OcTreeRoot.html">OcTreeRoot</a> &amp;dummy)=delete</td></tr>
<tr class="memdesc:a3da527433d221179d7e5eed13d547336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broken copy constructor.  <a href="classoomph_1_1OcTreeRoot.html#a3da527433d221179d7e5eed13d547336">More...</a><br /></td></tr>
<tr class="separator:a3da527433d221179d7e5eed13d547336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6941e4a38b81116bec7f6b6c2e8e88de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTreeRoot.html#a6941e4a38b81116bec7f6b6c2e8e88de">operator=</a> (const <a class="el" href="classoomph_1_1OcTreeRoot.html">OcTreeRoot</a> &amp;)=delete</td></tr>
<tr class="memdesc:a6941e4a38b81116bec7f6b6c2e8e88de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broken assignment operator.  <a href="classoomph_1_1OcTreeRoot.html#a6941e4a38b81116bec7f6b6c2e8e88de">More...</a><br /></td></tr>
<tr class="separator:a6941e4a38b81116bec7f6b6c2e8e88de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef513b8401e5fd32d1311bdebe86f45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTreeRoot.html#acef513b8401e5fd32d1311bdebe86f45">edge_neighbour_pt</a> (const unsigned &amp;edge_direction)</td></tr>
<tr class="memdesc:acef513b8401e5fd32d1311bdebe86f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return vector of pointers to the edge-neighbouring TreeRoots in the (enumerated) (edge) direction.  <a href="classoomph_1_1OcTreeRoot.html#acef513b8401e5fd32d1311bdebe86f45">More...</a><br /></td></tr>
<tr class="separator:acef513b8401e5fd32d1311bdebe86f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3c1de4903d2db75d19274719912ea3"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTreeRoot.html#add3c1de4903d2db75d19274719912ea3">nedge_neighbour</a> (const unsigned &amp;edge_direction)</td></tr>
<tr class="memdesc:add3c1de4903d2db75d19274719912ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of edge-neighbouring <a class="el" href="classoomph_1_1OcTreeRoot.html" title="OcTreeRoot is a OcTree that forms the root of a (recursive) octree. The &quot;root node&quot; is special as it ...">OcTreeRoot</a> in the (enumerated) (edge) direction.  <a href="classoomph_1_1OcTreeRoot.html#add3c1de4903d2db75d19274719912ea3">More...</a><br /></td></tr>
<tr class="separator:add3c1de4903d2db75d19274719912ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ccf3b396de331440c5dcba2e024317"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTreeRoot.html#a92ccf3b396de331440c5dcba2e024317">add_edge_neighbour_pt</a> (<a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *oc_tree_root_pt, const unsigned &amp;edge_direction)</td></tr>
<tr class="memdesc:a92ccf3b396de331440c5dcba2e024317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add pointer to the edge-neighbouring [Oc]<a class="el" href="classoomph_1_1TreeRoot.html" title="TreeRoot is a Tree that forms the root of a (recursive) tree. The &quot;root node&quot; is special as it holds ...">TreeRoot</a> in the (enumerated) (edge) direction &ndash; maintains uniqueness.  <a href="classoomph_1_1OcTreeRoot.html#a92ccf3b396de331440c5dcba2e024317">More...</a><br /></td></tr>
<tr class="separator:a92ccf3b396de331440c5dcba2e024317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961a28583236f1b92bc35de064d2dba6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTreeRoot.html#a961a28583236f1b92bc35de064d2dba6">up_equivalent</a> (<a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *tree_root_pt)</td></tr>
<tr class="memdesc:a961a28583236f1b92bc35de064d2dba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return up equivalent of the neighbours specified by pointer: When viewed from the current octree's neighbour, our up direction is the neighbour's Up_equivalent[neighbour_pt] direction. If there's no rotation, this map contains the identify so that, e.g. <code>Up_equivalent</code>[neighbour_pt]=U (read as: "in my
neighbour, my Up is its Up"). If the neighbour is rotated by 180 degrees relative to the current octree (around the back-front axis) say, we have <code>Up_equivalent</code>[neighbour_pt]=D (read as: "in my
neighbour, my Up is its Down"); etc. Returns OMEGA if the Octree specified by the pointer argument is not a neighbour.  <a href="classoomph_1_1OcTreeRoot.html#a961a28583236f1b92bc35de064d2dba6">More...</a><br /></td></tr>
<tr class="separator:a961a28583236f1b92bc35de064d2dba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91210b8fab8bb9f092518303551e0c33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTreeRoot.html#a91210b8fab8bb9f092518303551e0c33">set_up_equivalent</a> (<a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *tree_root_pt, const int &amp;dir)</td></tr>
<tr class="memdesc:a91210b8fab8bb9f092518303551e0c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up equivalent of the neighbours specified by pointer: When viewed from the current octree's neighbour, our up direction is the neighbour's Up_equivalent[neighbour_pt] direction. If there's no rotation, this map contains the identify so that, e.g. <code>Up_equivalent</code>[neighbour_pt]=U (read as: "in my
neighbour, my Up is its Up"). If the neighbour is rotated by 180 degrees relative to the current octree (around the back-front axis) say, we have <code>Up_equivalent</code>[neighbour_pt]=D (read as: "in my
neighbour, my Up is its Down"); etc.  <a href="classoomph_1_1OcTreeRoot.html#a91210b8fab8bb9f092518303551e0c33">More...</a><br /></td></tr>
<tr class="separator:a91210b8fab8bb9f092518303551e0c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497950cb0812be6a95be8af658a03fb6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTreeRoot.html#a497950cb0812be6a95be8af658a03fb6">right_equivalent</a> (<a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *tree_root_pt)</td></tr>
<tr class="memdesc:a497950cb0812be6a95be8af658a03fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same thing as up_equivalent, but for the right direction: When viewed from the current octree neighbour, our right direction is the neighbour's Right_equivalent[neighbour_pt] direction. Returns OMEGA if the Octree specified by the pointer argument is not a neighbour.  <a href="classoomph_1_1OcTreeRoot.html#a497950cb0812be6a95be8af658a03fb6">More...</a><br /></td></tr>
<tr class="separator:a497950cb0812be6a95be8af658a03fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa462fe159838307aee0870ad089836f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTreeRoot.html#aa462fe159838307aee0870ad089836f5">set_right_equivalent</a> (<a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *tree_root_pt, const int &amp;dir)</td></tr>
<tr class="memdesc:aa462fe159838307aee0870ad089836f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same thing as up_equivalent, but for the right direction: When viewed from the current octree neighbour, our right direction is the neighbour's Right_equivalent[neighbour_pt] direction.  <a href="classoomph_1_1OcTreeRoot.html#aa462fe159838307aee0870ad089836f5">More...</a><br /></td></tr>
<tr class="separator:aa462fe159838307aee0870ad089836f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6730957601b05b991ffc9972d31f8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTreeRoot.html#a6b6730957601b05b991ffc9972d31f8b">direction_of_neighbour</a> (<a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *octree_root_pt)</td></tr>
<tr class="memdesc:a6b6730957601b05b991ffc9972d31f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If octree_root_pt is a neighbour, return the direction [faces L/R/F/B/U/D or edges DB/UP/...] in which it is found, otherwise return OMEGA.  <a href="classoomph_1_1OcTreeRoot.html#a6b6730957601b05b991ffc9972d31f8b">More...</a><br /></td></tr>
<tr class="separator:a6b6730957601b05b991ffc9972d31f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classoomph_1_1OcTree"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classoomph_1_1OcTree')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classoomph_1_1OcTree.html">oomph::OcTree</a></td></tr>
<tr class="memitem:a5c7bf77c8700898c428dacbdff6b334c inherit pub_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a5c7bf77c8700898c428dacbdff6b334c">~OcTree</a> ()</td></tr>
<tr class="memdesc:a5c7bf77c8700898c428dacbdff6b334c inherit pub_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Note: Deleting a octree also deletes the objects associated with all non-leaf nodes!  <a href="classoomph_1_1OcTree.html#a5c7bf77c8700898c428dacbdff6b334c">More...</a><br /></td></tr>
<tr class="separator:a5c7bf77c8700898c428dacbdff6b334c inherit pub_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d729ac4b94328c7168bbcf423421edd inherit pub_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a2d729ac4b94328c7168bbcf423421edd">OcTree</a> (const <a class="el" href="classoomph_1_1OcTree.html">OcTree</a> &amp;dummy)=delete</td></tr>
<tr class="memdesc:a2d729ac4b94328c7168bbcf423421edd inherit pub_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broken copy constructor.  <a href="classoomph_1_1OcTree.html#a2d729ac4b94328c7168bbcf423421edd">More...</a><br /></td></tr>
<tr class="separator:a2d729ac4b94328c7168bbcf423421edd inherit pub_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14dba08782264f0d6008a8c1578b41e1 inherit pub_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a14dba08782264f0d6008a8c1578b41e1">operator=</a> (const <a class="el" href="classoomph_1_1OcTree.html">OcTree</a> &amp;)=delete</td></tr>
<tr class="memdesc:a14dba08782264f0d6008a8c1578b41e1 inherit pub_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broken assignment operator.  <a href="classoomph_1_1OcTree.html#a14dba08782264f0d6008a8c1578b41e1">More...</a><br /></td></tr>
<tr class="separator:a14dba08782264f0d6008a8c1578b41e1 inherit pub_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f894bab3cbde60d810de0ee43a9f023 inherit pub_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Tree.html">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a2f894bab3cbde60d810de0ee43a9f023">construct_son</a> (<a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c">object_pt</a>, <a class="el" href="classoomph_1_1Tree.html">Tree</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a5f8444ddeda272b70669b8bbe929708a">father_pt</a>, const int &amp;<a class="el" href="classoomph_1_1Tree.html#a7537f8fe7c896d2220eb2da03567b34d">son_type</a>)</td></tr>
<tr class="memdesc:a2f894bab3cbde60d810de0ee43a9f023 inherit pub_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload the function construct_son to ensure that the son is a specific <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> and not a general <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a>.  <a href="classoomph_1_1OcTree.html#a2f894bab3cbde60d810de0ee43a9f023">More...</a><br /></td></tr>
<tr class="separator:a2f894bab3cbde60d810de0ee43a9f023 inherit pub_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690c4fbbca73bd48c0bc3b2913a9b39c inherit pub_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1OcTree.html">OcTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a690c4fbbca73bd48c0bc3b2913a9b39c">gteq_face_neighbour</a> (const int &amp;direction, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;translate_s, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;s_sw, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;s_ne, int &amp;face, int &amp;diff_level, bool &amp;in_neighbouring_tree) const</td></tr>
<tr class="memdesc:a690c4fbbca73bd48c0bc3b2913a9b39c inherit pub_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find (pointer to) &lsquo;greater-or-equal-sized face neighbour&rsquo; in given direction (L/R/U/D/F/B). Another way of interpreting this is that we're looking for the neighbour across the present element's face 'direction'. The various arguments return additional information about the size and relative orientation of the neighbouring octree. To interpret these we use the following <b>General convention:</b>  <a href="classoomph_1_1OcTree.html#a690c4fbbca73bd48c0bc3b2913a9b39c">More...</a><br /></td></tr>
<tr class="separator:a690c4fbbca73bd48c0bc3b2913a9b39c inherit pub_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a26409cd49a430095915c76060f476 inherit pub_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1OcTree.html">OcTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#ab5a26409cd49a430095915c76060f476">gteq_true_edge_neighbour</a> (const int &amp;direction, const unsigned &amp;i_root_edge_neighbour, unsigned &amp;nroot_edge_neighbour, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;translate_s, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;s_lo, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;s_hi, int &amp;edge, int &amp;diff_level) const</td></tr>
<tr class="memdesc:ab5a26409cd49a430095915c76060f476 inherit pub_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find (pointer to) &lsquo;greater-or-equal-sized true edge neighbour&rsquo; in the given direction (LB,RB,DB,UB [the back edges], LD,RD,LU,RU [the side edges], LF,RF,DF,UF [the front edges]).  <a href="classoomph_1_1OcTree.html#ab5a26409cd49a430095915c76060f476">More...</a><br /></td></tr>
<tr class="separator:ab5a26409cd49a430095915c76060f476 inherit pub_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68218b6e02594bef23cb141af8a19ffb inherit pub_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a68218b6e02594bef23cb141af8a19ffb">self_test</a> ()</td></tr>
<tr class="memdesc:a68218b6e02594bef23cb141af8a19ffb inherit pub_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-test: Check all neighbours. Return success (0) if the max. distance between corresponding points in the neighbours is less than the tolerance specified in the static value <a class="el" href="classoomph_1_1Tree.html#aef9abebc166fa3bf81ecb59ec0d5d6b2" title="Max. allowed discrepancy in neighbour finding routine (distance between points when identified from t...">Tree::Max_neighbour_finding_tolerance</a>.  <a href="classoomph_1_1OcTree.html#a68218b6e02594bef23cb141af8a19ffb">More...</a><br /></td></tr>
<tr class="separator:a68218b6e02594bef23cb141af8a19ffb inherit pub_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classoomph_1_1Tree"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classoomph_1_1Tree')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classoomph_1_1Tree.html">oomph::Tree</a></td></tr>
<tr class="memitem:ace0b4169cf94a040c280af8e14f6a283 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#ace0b4169cf94a040c280af8e14f6a283">~Tree</a> ()</td></tr>
<tr class="memdesc:ace0b4169cf94a040c280af8e14f6a283 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Note: Deleting a tree also deletes the objects associated with its non-leave nodes.  <a href="classoomph_1_1Tree.html#ace0b4169cf94a040c280af8e14f6a283">More...</a><br /></td></tr>
<tr class="separator:ace0b4169cf94a040c280af8e14f6a283 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dce113a40c6ac422353ab149b2d4eb inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a50dce113a40c6ac422353ab149b2d4eb">Tree</a> (const <a class="el" href="classoomph_1_1Tree.html">Tree</a> &amp;dummy)=delete</td></tr>
<tr class="memdesc:a50dce113a40c6ac422353ab149b2d4eb inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broken copy constructor.  <a href="classoomph_1_1Tree.html#a50dce113a40c6ac422353ab149b2d4eb">More...</a><br /></td></tr>
<tr class="separator:a50dce113a40c6ac422353ab149b2d4eb inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bce57d784f256d8d7b8d14432a7d77a inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a6bce57d784f256d8d7b8d14432a7d77a">operator=</a> (const <a class="el" href="classoomph_1_1Tree.html">Tree</a> &amp;)=delete</td></tr>
<tr class="memdesc:a6bce57d784f256d8d7b8d14432a7d77a inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broken assignment operator.  <a href="classoomph_1_1Tree.html#a6bce57d784f256d8d7b8d14432a7d77a">More...</a><br /></td></tr>
<tr class="separator:a6bce57d784f256d8d7b8d14432a7d77a inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2eeb0f1dd161f696cccc652974ff4c inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c">object_pt</a> () const</td></tr>
<tr class="memdesc:a2f2eeb0f1dd161f696cccc652974ff4c inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pointer to the object (<a class="el" href="classoomph_1_1RefineableElement.html" title="RefineableElements are FiniteElements that may be subdivided into children to provide a better local ...">RefineableElement</a>) represented by the tree.  <a href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c">More...</a><br /></td></tr>
<tr class="separator:a2f2eeb0f1dd161f696cccc652974ff4c inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a95bd9942e906fde87194845a1868c inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a96a95bd9942e906fde87194845a1868c">flush_object</a> ()</td></tr>
<tr class="memdesc:a96a95bd9942e906fde87194845a1868c inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the object represented by the tree.  <a href="classoomph_1_1Tree.html#a96a95bd9942e906fde87194845a1868c">More...</a><br /></td></tr>
<tr class="separator:a96a95bd9942e906fde87194845a1868c inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ca6416d7a368e29da6a6a998f460c7 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Tree.html">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#ab2ca6416d7a368e29da6a6a998f460c7">son_pt</a> (const int &amp;son_index) const</td></tr>
<tr class="memdesc:ab2ca6416d7a368e29da6a6a998f460c7 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to the son for a given index. Note that to aid code readability specific enums have been defined for specific trees. However, these are simply aliases for ints and the general interface can be implemented once, here.  <a href="classoomph_1_1Tree.html#ab2ca6416d7a368e29da6a6a998f460c7">More...</a><br /></td></tr>
<tr class="separator:ab2ca6416d7a368e29da6a6a998f460c7 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7026d14ead1a8d91ce417dfd0cd9478 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#ab7026d14ead1a8d91ce417dfd0cd9478">set_son_pt</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Tree.html">Tree</a> * &gt; &amp;<a class="el" href="classoomph_1_1Tree.html#ab2ca6416d7a368e29da6a6a998f460c7">son_pt</a>)</td></tr>
<tr class="memdesc:ab7026d14ead1a8d91ce417dfd0cd9478 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set vector of pointers to sons, indexed by the appropriate enum that identies son types. (To aid code readability specific enums have been defined for specific trees. However, these are simply aliases for ints and the general interface can be implemented once, here).  <a href="classoomph_1_1Tree.html#ab7026d14ead1a8d91ce417dfd0cd9478">More...</a><br /></td></tr>
<tr class="separator:ab7026d14ead1a8d91ce417dfd0cd9478 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e4123b40f6fb52d180a154c9123e85 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a31e4123b40f6fb52d180a154c9123e85">nsons</a> () const</td></tr>
<tr class="memdesc:a31e4123b40f6fb52d180a154c9123e85 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of sons (zero if it's a leaf node)  <a href="classoomph_1_1Tree.html#a31e4123b40f6fb52d180a154c9123e85">More...</a><br /></td></tr>
<tr class="separator:a31e4123b40f6fb52d180a154c9123e85 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34df656d2f298dbbdf60e7890a3dff2f inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a34df656d2f298dbbdf60e7890a3dff2f">flush_sons</a> ()</td></tr>
<tr class="memdesc:a34df656d2f298dbbdf60e7890a3dff2f inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the sons.  <a href="classoomph_1_1Tree.html#a34df656d2f298dbbdf60e7890a3dff2f">More...</a><br /></td></tr>
<tr class="separator:a34df656d2f298dbbdf60e7890a3dff2f inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48479dc463d2a8f10400b4b00643a27 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#ae48479dc463d2a8f10400b4b00643a27">root_pt</a> ()</td></tr>
<tr class="memdesc:ae48479dc463d2a8f10400b4b00643a27 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to root of the tree.  <a href="classoomph_1_1Tree.html#ae48479dc463d2a8f10400b4b00643a27">More...</a><br /></td></tr>
<tr class="separator:ae48479dc463d2a8f10400b4b00643a27 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4dee01da0a463c4a3a5be574943632 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a3e4dee01da0a463c4a3a5be574943632">root_pt</a> () const</td></tr>
<tr class="memdesc:a3e4dee01da0a463c4a3a5be574943632 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to root of the tree (const version)  <a href="classoomph_1_1Tree.html#a3e4dee01da0a463c4a3a5be574943632">More...</a><br /></td></tr>
<tr class="separator:a3e4dee01da0a463c4a3a5be574943632 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975ccfd63ffa14a04f14a37b3d2ff931 inherit pub_methods_classoomph_1_1Tree"><td class="memTemplParams" colspan="2">template&lt;class ELEMENT &gt; </td></tr>
<tr class="memitem:a975ccfd63ffa14a04f14a37b3d2ff931 inherit pub_methods_classoomph_1_1Tree"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a975ccfd63ffa14a04f14a37b3d2ff931">split_if_required</a> ()</td></tr>
<tr class="memdesc:a975ccfd63ffa14a04f14a37b3d2ff931 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">If required, split the leaf and create its sons &ndash; criterion: bool <a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c" title="Return the pointer to the object (RefineableElement) represented by the tree.">object_pt()</a>-&gt; to_be_refined() = true.  <a href="classoomph_1_1Tree.html#a975ccfd63ffa14a04f14a37b3d2ff931">More...</a><br /></td></tr>
<tr class="separator:a975ccfd63ffa14a04f14a37b3d2ff931 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6502324233a86eeeadba7f46505656af inherit pub_methods_classoomph_1_1Tree"><td class="memTemplParams" colspan="2">template&lt;class ELEMENT &gt; </td></tr>
<tr class="memitem:a6502324233a86eeeadba7f46505656af inherit pub_methods_classoomph_1_1Tree"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a6502324233a86eeeadba7f46505656af">p_refine_if_required</a> (<a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *&amp;mesh_pt)</td></tr>
<tr class="memdesc:a6502324233a86eeeadba7f46505656af inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">If required, p-refine the leaf &ndash; criterion: bool <a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c" title="Return the pointer to the object (RefineableElement) represented by the tree.">object_pt()</a>-&gt; to_be_p_refined() = true or bool <a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c" title="Return the pointer to the object (RefineableElement) represented by the tree.">object_pt()</a>-&gt; to_be_p_unrefined() = true.  <a href="classoomph_1_1Tree.html#a6502324233a86eeeadba7f46505656af">More...</a><br /></td></tr>
<tr class="separator:a6502324233a86eeeadba7f46505656af inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f977931ece6b719a9e616037bb2481 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#af4f977931ece6b719a9e616037bb2481">merge_sons_if_required</a> (<a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *&amp;mesh_pt)</td></tr>
<tr class="memdesc:af4f977931ece6b719a9e616037bb2481 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">If required, merge the four sons for unrefinement &ndash; criterion: bool <a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c" title="Return the pointer to the object (RefineableElement) represented by the tree.">object_pt()</a>-&gt; sons_to_be_unrefined() = true.  <a href="classoomph_1_1Tree.html#af4f977931ece6b719a9e616037bb2481">More...</a><br /></td></tr>
<tr class="separator:af4f977931ece6b719a9e616037bb2481 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea17489589a1872db51f2b142da4c1fb inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#aea17489589a1872db51f2b142da4c1fb">deactivate_object</a> ()</td></tr>
<tr class="memdesc:aea17489589a1872db51f2b142da4c1fb inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the <a class="el" href="classoomph_1_1RefineableElement.html" title="RefineableElements are FiniteElements that may be subdivided into children to provide a better local ...">RefineableElement</a>'s deactivate_element() function.  <a href="classoomph_1_1Tree.html#aea17489589a1872db51f2b142da4c1fb">More...</a><br /></td></tr>
<tr class="separator:aea17489589a1872db51f2b142da4c1fb inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caab39c8bee6fb65bbafed523aa6d3d inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a3caab39c8bee6fb65bbafed523aa6d3d">traverse_all</a> (<a class="el" href="classoomph_1_1Tree.html#a6b8ef236d41f52c92973682ca83679d5">Tree::VoidMemberFctPt</a> member_function)</td></tr>
<tr class="memdesc:a3caab39c8bee6fb65bbafed523aa6d3d inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree and execute void <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> member function member_function() at all its "nodes".  <a href="classoomph_1_1Tree.html#a3caab39c8bee6fb65bbafed523aa6d3d">More...</a><br /></td></tr>
<tr class="separator:a3caab39c8bee6fb65bbafed523aa6d3d inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c67186ca9c87eef9ce7eaa0af41057 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#af5c67186ca9c87eef9ce7eaa0af41057">traverse_all</a> (<a class="el" href="classoomph_1_1Tree.html#a498ffc10556f4335e831a06fc885a27a">Tree::VoidMeshPtArgumentMemberFctPt</a> member_function, <a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *&amp;mesh_pt)</td></tr>
<tr class="memdesc:af5c67186ca9c87eef9ce7eaa0af41057 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree and excute void <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> member function that takes a pointer to a mesh as an argument.  <a href="classoomph_1_1Tree.html#af5c67186ca9c87eef9ce7eaa0af41057">More...</a><br /></td></tr>
<tr class="separator:af5c67186ca9c87eef9ce7eaa0af41057 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef175445b09edb47624c4b88c6d548bc inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#aef175445b09edb47624c4b88c6d548bc">traverse_all_but_leaves</a> (<a class="el" href="classoomph_1_1Tree.html#a6b8ef236d41f52c92973682ca83679d5">Tree::VoidMemberFctPt</a> member_function)</td></tr>
<tr class="memdesc:aef175445b09edb47624c4b88c6d548bc inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree and execute void <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> member function member_function() at all its "nodes" aparat from the leaves.  <a href="classoomph_1_1Tree.html#aef175445b09edb47624c4b88c6d548bc">More...</a><br /></td></tr>
<tr class="separator:aef175445b09edb47624c4b88c6d548bc inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e0e3695dd8986e439927b7657ff741 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a22e0e3695dd8986e439927b7657ff741">traverse_leaves</a> (<a class="el" href="classoomph_1_1Tree.html#a6b8ef236d41f52c92973682ca83679d5">Tree::VoidMemberFctPt</a> member_function)</td></tr>
<tr class="memdesc:a22e0e3695dd8986e439927b7657ff741 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree and execute void <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> member function member_function() only at its leaves.  <a href="classoomph_1_1Tree.html#a22e0e3695dd8986e439927b7657ff741">More...</a><br /></td></tr>
<tr class="separator:a22e0e3695dd8986e439927b7657ff741 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914e74ef473b7e82299ea9337d37830d inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a914e74ef473b7e82299ea9337d37830d">traverse_leaves</a> (<a class="el" href="classoomph_1_1Tree.html#a498ffc10556f4335e831a06fc885a27a">Tree::VoidMeshPtArgumentMemberFctPt</a> member_function, <a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *&amp;mesh_pt)</td></tr>
<tr class="memdesc:a914e74ef473b7e82299ea9337d37830d inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree and execute void <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> member function that takes a pointer to a mesh as an argument only at its leaves.  <a href="classoomph_1_1Tree.html#a914e74ef473b7e82299ea9337d37830d">More...</a><br /></td></tr>
<tr class="separator:a914e74ef473b7e82299ea9337d37830d inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfbeb9178ce92a8a51e3a15293a86d1 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#accfbeb9178ce92a8a51e3a15293a86d1">stick_leaves_into_vector</a> (<a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Tree.html">Tree</a> * &gt; &amp;)</td></tr>
<tr class="memdesc:accfbeb9178ce92a8a51e3a15293a86d1 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse tree and stick pointers to leaf "nodes" (only) into <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a>.  <a href="classoomph_1_1Tree.html#accfbeb9178ce92a8a51e3a15293a86d1">More...</a><br /></td></tr>
<tr class="separator:accfbeb9178ce92a8a51e3a15293a86d1 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c84b4e4700a825ef0a6ca533b9ae895 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a2c84b4e4700a825ef0a6ca533b9ae895">stick_all_tree_nodes_into_vector</a> (<a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Tree.html">Tree</a> * &gt; &amp;)</td></tr>
<tr class="memdesc:a2c84b4e4700a825ef0a6ca533b9ae895 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse and stick pointers to all "nodes" into <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a>.  <a href="classoomph_1_1Tree.html#a2c84b4e4700a825ef0a6ca533b9ae895">More...</a><br /></td></tr>
<tr class="separator:a2c84b4e4700a825ef0a6ca533b9ae895 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7537f8fe7c896d2220eb2da03567b34d inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a7537f8fe7c896d2220eb2da03567b34d">son_type</a> () const</td></tr>
<tr class="memdesc:a7537f8fe7c896d2220eb2da03567b34d inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return son type.  <a href="classoomph_1_1Tree.html#a7537f8fe7c896d2220eb2da03567b34d">More...</a><br /></td></tr>
<tr class="separator:a7537f8fe7c896d2220eb2da03567b34d inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72000456c76880e3f78f8f8fb43d49d8 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a72000456c76880e3f78f8f8fb43d49d8">is_leaf</a> ()</td></tr>
<tr class="memdesc:a72000456c76880e3f78f8f8fb43d49d8 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the tree is a leaf node.  <a href="classoomph_1_1Tree.html#a72000456c76880e3f78f8f8fb43d49d8">More...</a><br /></td></tr>
<tr class="separator:a72000456c76880e3f78f8f8fb43d49d8 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8444ddeda272b70669b8bbe929708a inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Tree.html">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a5f8444ddeda272b70669b8bbe929708a">father_pt</a> () const</td></tr>
<tr class="memdesc:a5f8444ddeda272b70669b8bbe929708a inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to father: NULL if it's a root node.  <a href="classoomph_1_1Tree.html#a5f8444ddeda272b70669b8bbe929708a">More...</a><br /></td></tr>
<tr class="separator:a5f8444ddeda272b70669b8bbe929708a inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cf27d3116db0f8d2f18b3faf09ec15 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#ac0cf27d3116db0f8d2f18b3faf09ec15">set_father_pt</a> (<a class="el" href="classoomph_1_1Tree.html">Tree</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a5f8444ddeda272b70669b8bbe929708a">father_pt</a>)</td></tr>
<tr class="memdesc:ac0cf27d3116db0f8d2f18b3faf09ec15 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the father.  <a href="classoomph_1_1Tree.html#ac0cf27d3116db0f8d2f18b3faf09ec15">More...</a><br /></td></tr>
<tr class="separator:ac0cf27d3116db0f8d2f18b3faf09ec15 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3eba84432fcc595684ac7eb8331b8ee inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#ab3eba84432fcc595684ac7eb8331b8ee">level</a> () const</td></tr>
<tr class="memdesc:ab3eba84432fcc595684ac7eb8331b8ee inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the level of the <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> (root=0)  <a href="classoomph_1_1Tree.html#ab3eba84432fcc595684ac7eb8331b8ee">More...</a><br /></td></tr>
<tr class="separator:ab3eba84432fcc595684ac7eb8331b8ee inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classoomph_1_1TreeRoot"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classoomph_1_1TreeRoot')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classoomph_1_1TreeRoot.html">oomph::TreeRoot</a></td></tr>
<tr class="memitem:a9220f966655424676f4a5710b016c23d inherit pub_methods_classoomph_1_1TreeRoot"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1TreeRoot.html#a9220f966655424676f4a5710b016c23d">TreeRoot</a> (<a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c">object_pt</a>)</td></tr>
<tr class="memdesc:a9220f966655424676f4a5710b016c23d inherit pub_methods_classoomph_1_1TreeRoot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the (empty) root tree.  <a href="classoomph_1_1TreeRoot.html#a9220f966655424676f4a5710b016c23d">More...</a><br /></td></tr>
<tr class="separator:a9220f966655424676f4a5710b016c23d inherit pub_methods_classoomph_1_1TreeRoot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db9e51a9aa23d8894ad0fc573853d05 inherit pub_methods_classoomph_1_1TreeRoot"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1TreeRoot.html#a7db9e51a9aa23d8894ad0fc573853d05">TreeRoot</a> (const <a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> &amp;dummy)=delete</td></tr>
<tr class="memdesc:a7db9e51a9aa23d8894ad0fc573853d05 inherit pub_methods_classoomph_1_1TreeRoot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broken copy constructor.  <a href="classoomph_1_1TreeRoot.html#a7db9e51a9aa23d8894ad0fc573853d05">More...</a><br /></td></tr>
<tr class="separator:a7db9e51a9aa23d8894ad0fc573853d05 inherit pub_methods_classoomph_1_1TreeRoot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c486b91b11d6524a23f4ab8298f696b inherit pub_methods_classoomph_1_1TreeRoot"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1TreeRoot.html#a1c486b91b11d6524a23f4ab8298f696b">operator=</a> (const <a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> &amp;)=delete</td></tr>
<tr class="memdesc:a1c486b91b11d6524a23f4ab8298f696b inherit pub_methods_classoomph_1_1TreeRoot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broken assignment operator.  <a href="classoomph_1_1TreeRoot.html#a1c486b91b11d6524a23f4ab8298f696b">More...</a><br /></td></tr>
<tr class="separator:a1c486b91b11d6524a23f4ab8298f696b inherit pub_methods_classoomph_1_1TreeRoot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae793a707b05815957d5910d5216dddc1 inherit pub_methods_classoomph_1_1TreeRoot"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1TreeRoot.html#ae793a707b05815957d5910d5216dddc1">neighbour_pt</a> (const int &amp;direction)</td></tr>
<tr class="memdesc:ae793a707b05815957d5910d5216dddc1 inherit pub_methods_classoomph_1_1TreeRoot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pointer to the neighbouring TreeRoots in specified direction. Returns NULL if there's no neighbour in this direction.  <a href="classoomph_1_1TreeRoot.html#ae793a707b05815957d5910d5216dddc1">More...</a><br /></td></tr>
<tr class="separator:ae793a707b05815957d5910d5216dddc1 inherit pub_methods_classoomph_1_1TreeRoot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be347e54e34f924c008c302f5146064 inherit pub_methods_classoomph_1_1TreeRoot"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1TreeRoot.html#a7be347e54e34f924c008c302f5146064">is_neighbour_periodic</a> (const int &amp;direction)</td></tr>
<tr class="memdesc:a7be347e54e34f924c008c302f5146064 inherit pub_methods_classoomph_1_1TreeRoot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the neighbour in the particular direction is periodic.  <a href="classoomph_1_1TreeRoot.html#a7be347e54e34f924c008c302f5146064">More...</a><br /></td></tr>
<tr class="separator:a7be347e54e34f924c008c302f5146064 inherit pub_methods_classoomph_1_1TreeRoot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a2c51b2b42261bd8dde67ca32c594c inherit pub_methods_classoomph_1_1TreeRoot"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1TreeRoot.html#ad4a2c51b2b42261bd8dde67ca32c594c">set_neighbour_periodic</a> (const int &amp;direction)</td></tr>
<tr class="memdesc:ad4a2c51b2b42261bd8dde67ca32c594c inherit pub_methods_classoomph_1_1TreeRoot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the neighbour in particular direction to be periodic.  <a href="classoomph_1_1TreeRoot.html#ad4a2c51b2b42261bd8dde67ca32c594c">More...</a><br /></td></tr>
<tr class="separator:ad4a2c51b2b42261bd8dde67ca32c594c inherit pub_methods_classoomph_1_1TreeRoot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e20f4787d7b34d5f4462dea63fd0204 inherit pub_methods_classoomph_1_1TreeRoot"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1TreeRoot.html#a9e20f4787d7b34d5f4462dea63fd0204">set_neighbour_nonperiodic</a> (const int &amp;direction)</td></tr>
<tr class="memdesc:a9e20f4787d7b34d5f4462dea63fd0204 inherit pub_methods_classoomph_1_1TreeRoot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the neighbour in particular direction to be nonperiodic.  <a href="classoomph_1_1TreeRoot.html#a9e20f4787d7b34d5f4462dea63fd0204">More...</a><br /></td></tr>
<tr class="separator:a9e20f4787d7b34d5f4462dea63fd0204 inherit pub_methods_classoomph_1_1TreeRoot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81be1a835829a48f7f443dcc85f369b9 inherit pub_methods_classoomph_1_1TreeRoot"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1TreeRoot.html#a81be1a835829a48f7f443dcc85f369b9">nneighbour</a> ()</td></tr>
<tr class="memdesc:a81be1a835829a48f7f443dcc85f369b9 inherit pub_methods_classoomph_1_1TreeRoot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of neighbours.  <a href="classoomph_1_1TreeRoot.html#a81be1a835829a48f7f443dcc85f369b9">More...</a><br /></td></tr>
<tr class="separator:a81be1a835829a48f7f443dcc85f369b9 inherit pub_methods_classoomph_1_1TreeRoot"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae3c71331aaf452591ba6a3ab0cdbcdbc"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTreeRoot.html#ae3c71331aaf452591ba6a3ab0cdbcdbc">Edge_neighbour_pt</a></td></tr>
<tr class="memdesc:ae3c71331aaf452591ba6a3ab0cdbcdbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of pointers to the edge-neighbouring [Oc]TreeRoots: Edge_neighbour_pt[direction] is <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> to the pointers to the [Oc]<a class="el" href="classoomph_1_1TreeRoot.html" title="TreeRoot is a Tree that forms the root of a (recursive) tree. The &quot;root node&quot; is special as it holds ...">TreeRoot</a>'s edge neighbours in the (enumerated) (edge) direction.  <a href="classoomph_1_1OcTreeRoot.html#ae3c71331aaf452591ba6a3ab0cdbcdbc">More...</a><br /></td></tr>
<tr class="separator:ae3c71331aaf452591ba6a3ab0cdbcdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247955b8a3eb01e227ec2ee1f3bb96ce"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTreeRoot.html#a247955b8a3eb01e227ec2ee1f3bb96ce">Up_equivalent</a></td></tr>
<tr class="memdesc:a247955b8a3eb01e227ec2ee1f3bb96ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map giving the Up equivalent of the neighbour specified by pointer: When viewed from the current octree's neighbour, our up direction is the neighbour's Up_equivalent[neighbour_pt] direction. If there's no rotation, this map contains the identify so that, e.g. <code>Up_equivalent</code>[neighbour_pt]=U (read as: "in my
neighbour, my Up is its Up"). If the neighbour is rotated by 180 degrees relative to the current octree(around the back-front axis), say, we have <code>Up_equivalent</code>[neighbour_pt]=D (read as: "in my
neighbour, my Up is its Down"); etc.  <a href="classoomph_1_1OcTreeRoot.html#a247955b8a3eb01e227ec2ee1f3bb96ce">More...</a><br /></td></tr>
<tr class="separator:a247955b8a3eb01e227ec2ee1f3bb96ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739d09d26896cfb6924f4d023f5d791f"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTreeRoot.html#a739d09d26896cfb6924f4d023f5d791f">Right_equivalent</a></td></tr>
<tr class="memdesc:a739d09d26896cfb6924f4d023f5d791f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map giving the Right equivalent of the neighbour specified by pointer: When viewed from the current octree's neighbour, our right direction is the neighbour's right_equivalent[neighbour_pt] direction. If there's no rotation, this map contains the identify so that, e.g. <code>Right_equivalent</code>[neighbour_pt]=R (read as: "in my
neighbour, my Right is its Right").  <a href="classoomph_1_1OcTreeRoot.html#a739d09d26896cfb6924f4d023f5d791f">More...</a><br /></td></tr>
<tr class="separator:a739d09d26896cfb6924f4d023f5d791f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classoomph_1_1Tree"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classoomph_1_1Tree')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classoomph_1_1Tree.html">oomph::Tree</a></td></tr>
<tr class="memitem:a6b8ef236d41f52c92973682ca83679d5 inherit pub_types_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">typedef void(Tree::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a6b8ef236d41f52c92973682ca83679d5">VoidMemberFctPt</a>) ()</td></tr>
<tr class="memdesc:a6b8ef236d41f52c92973682ca83679d5 inherit pub_types_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to argument-free void <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> member function.  <a href="classoomph_1_1Tree.html#a6b8ef236d41f52c92973682ca83679d5">More...</a><br /></td></tr>
<tr class="separator:a6b8ef236d41f52c92973682ca83679d5 inherit pub_types_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498ffc10556f4335e831a06fc885a27a inherit pub_types_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">typedef void(Tree::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a498ffc10556f4335e831a06fc885a27a">VoidMeshPtArgumentMemberFctPt</a>) (<a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *&amp;mesh_pt)</td></tr>
<tr class="memdesc:a498ffc10556f4335e831a06fc885a27a inherit pub_types_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to a void <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> member function that takes a pointer to a mesh as its argument.  <a href="classoomph_1_1Tree.html#a498ffc10556f4335e831a06fc885a27a">More...</a><br /></td></tr>
<tr class="separator:a498ffc10556f4335e831a06fc885a27a inherit pub_types_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classoomph_1_1OcTree"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classoomph_1_1OcTree')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classoomph_1_1OcTree.html">oomph::OcTree</a></td></tr>
<tr class="memitem:a29d019becbc07f9ea2811a0ff0881d9a inherit pub_static_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a29d019becbc07f9ea2811a0ff0881d9a">faces_of_common_edge</a> (const int &amp;edge)</td></tr>
<tr class="memdesc:a29d019becbc07f9ea2811a0ff0881d9a inherit pub_static_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that, given an edge, returns the two faces on which it.  <a href="classoomph_1_1OcTree.html#a29d019becbc07f9ea2811a0ff0881d9a">More...</a><br /></td></tr>
<tr class="separator:a29d019becbc07f9ea2811a0ff0881d9a inherit pub_static_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7b0830cd9c913786e23259c69c71a0 inherit pub_static_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a5d7b0830cd9c913786e23259c69c71a0">setup_static_data</a> ()</td></tr>
<tr class="memdesc:a5d7b0830cd9c913786e23259c69c71a0 inherit pub_static_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the static data, rotation and reflection schemes, etc.  <a href="classoomph_1_1OcTree.html#a5d7b0830cd9c913786e23259c69c71a0">More...</a><br /></td></tr>
<tr class="separator:a5d7b0830cd9c913786e23259c69c71a0 inherit pub_static_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd54b3cd1f4196d618e73d19bb4ba157 inherit pub_static_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#afd54b3cd1f4196d618e73d19bb4ba157">doc_face_neighbours</a> (<a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Tree.html">Tree</a> * &gt; forest_nodes_pt, std::ofstream &amp;neighbours_file, std::ofstream &amp;neighbours_txt_file, double &amp;max_error)</td></tr>
<tr class="memdesc:afd54b3cd1f4196d618e73d19bb4ba157 inherit pub_static_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Doc/check all face neighbours of octree (nodes) contained in the <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> forest_node_pt. Output into neighbours_file which can be viewed from tecplot with OcTreeNeighbours.mcr Neighbour info and errors are displayed on neighbours_txt_file. Finally, compute the max. error between vertices when viewed from neighhbouring element. If the two filestreams are closed, output is suppressed.  <a href="classoomph_1_1OcTree.html#afd54b3cd1f4196d618e73d19bb4ba157">More...</a><br /></td></tr>
<tr class="separator:afd54b3cd1f4196d618e73d19bb4ba157 inherit pub_static_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728b0580f568f9d5fb814458b6c75fe4 inherit pub_static_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a728b0580f568f9d5fb814458b6c75fe4">doc_true_edge_neighbours</a> (<a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Tree.html">Tree</a> * &gt; forest_nodes_pt, std::ofstream &amp;neighbours_file, std::ofstream &amp;no_true_edge_file, std::ofstream &amp;neighbours_txt_file, double &amp;max_error)</td></tr>
<tr class="memdesc:a728b0580f568f9d5fb814458b6c75fe4 inherit pub_static_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Doc/check all true edge neighbours of octree (nodes) contained in the <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> forest_node_pt. Output into neighbours_file which can be viewed from tecplot with OcTreeNeighbours.mcr Neighbour info and errors are displayed on neighbours_txt_file. Finally, compute the max. error between vertices when viewed from neighhbouring element. If the two filestreams are closed, output is suppressed.  <a href="classoomph_1_1OcTree.html#a728b0580f568f9d5fb814458b6c75fe4">More...</a><br /></td></tr>
<tr class="separator:a728b0580f568f9d5fb814458b6c75fe4 inherit pub_static_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03edae455d5bd788acf426ca3f87b9d inherit pub_static_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#ab03edae455d5bd788acf426ca3f87b9d">get_the_other_face</a> (const unsigned &amp;n1, const unsigned &amp;n2, const unsigned &amp;nnode1d, const int &amp;face)</td></tr>
<tr class="memdesc:ab03edae455d5bd788acf426ca3f87b9d inherit pub_static_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an edge is bordered by the nodes whose local numbers are n1 and n2 in an element with nnode1d nodes along each coordinate direction, then this edge is shared by two faces. This function takes one of these faces as the argument <code>face</code> and returns the other one. (<code>face</code> is a direction in the set U,D,F,B,L,R).  <a href="classoomph_1_1OcTree.html#ab03edae455d5bd788acf426ca3f87b9d">More...</a><br /></td></tr>
<tr class="separator:ab03edae455d5bd788acf426ca3f87b9d inherit pub_static_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a129b95ad303ed340bb8bd86e05384 inherit pub_static_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#af2a129b95ad303ed340bb8bd86e05384">vertex_to_node_number</a> (const int &amp;vertex, const unsigned &amp;nnode1d)</td></tr>
<tr class="memdesc:af2a129b95ad303ed340bb8bd86e05384 inherit pub_static_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the local node number of given vertex [LDB,RDB,...] in an element with nnode1d nodes in each coordinate direction.  <a href="classoomph_1_1OcTree.html#af2a129b95ad303ed340bb8bd86e05384">More...</a><br /></td></tr>
<tr class="separator:af2a129b95ad303ed340bb8bd86e05384 inherit pub_static_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cbe5258a41168fe2d891e52ae64e6b inherit pub_static_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a43cbe5258a41168fe2d891e52ae64e6b">node_number_to_vertex</a> (const unsigned &amp;n, const unsigned &amp;nnode1d)</td></tr>
<tr class="memdesc:a43cbe5258a41168fe2d891e52ae64e6b inherit pub_static_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vertex [LDB,RDB,...] of local (vertex) node n in an element with nnode1d nodes in each coordinate direction.  <a href="classoomph_1_1OcTree.html#a43cbe5258a41168fe2d891e52ae64e6b">More...</a><br /></td></tr>
<tr class="separator:a43cbe5258a41168fe2d891e52ae64e6b inherit pub_static_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e5185f0395a19883e216fd80103cf7 inherit pub_static_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a25e5185f0395a19883e216fd80103cf7">rotate</a> (const int &amp;new_up, const int &amp;new_right, const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; &amp;dir)</td></tr>
<tr class="memdesc:a25e5185f0395a19883e216fd80103cf7 inherit pub_static_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">If U[p] becomes new_up and R[ight] becomes new_right then the direction vector <code>dir</code> becomes rotate(new_up, new_right, dir)  <a href="classoomph_1_1OcTree.html#a25e5185f0395a19883e216fd80103cf7">More...</a><br /></td></tr>
<tr class="separator:a25e5185f0395a19883e216fd80103cf7 inherit pub_static_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65a00f8f47eb8b6da56ffa9d6ba8f36 inherit pub_static_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#ab65a00f8f47eb8b6da56ffa9d6ba8f36">rotate</a> (const int &amp;new_up, const int &amp;new_right, const int &amp;dir)</td></tr>
<tr class="memdesc:ab65a00f8f47eb8b6da56ffa9d6ba8f36 inherit pub_static_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">If U[p] becomes new_up and R[ight] becomes new_right then the direction <code>dir</code> becomes <code>rotate(new_up, new_right, dir)</code>  <a href="classoomph_1_1OcTree.html#ab65a00f8f47eb8b6da56ffa9d6ba8f36">More...</a><br /></td></tr>
<tr class="separator:ab65a00f8f47eb8b6da56ffa9d6ba8f36 inherit pub_static_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classoomph_1_1Tree"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classoomph_1_1Tree')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classoomph_1_1Tree.html">oomph::Tree</a></td></tr>
<tr class="memitem:affbae3271da943dfc23645ade966aef9 inherit pub_static_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">static double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#affbae3271da943dfc23645ade966aef9">max_neighbour_finding_tolerance</a> ()</td></tr>
<tr class="memdesc:affbae3271da943dfc23645ade966aef9 inherit pub_static_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max. allowed discrepancy in neighbour finding routine (distance between points when identified from two neighbouring elements)  <a href="classoomph_1_1Tree.html#affbae3271da943dfc23645ade966aef9">More...</a><br /></td></tr>
<tr class="separator:affbae3271da943dfc23645ade966aef9 inherit pub_static_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classoomph_1_1OcTree"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classoomph_1_1OcTree')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classoomph_1_1OcTree.html">oomph::OcTree</a></td></tr>
<tr class="memitem:a2e9487b716f4d583aada06a850b8eae9 inherit pub_static_attribs_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a2e9487b716f4d583aada06a850b8eae9">Direct_string</a></td></tr>
<tr class="memdesc:a2e9487b716f4d583aada06a850b8eae9 inherit pub_static_attribs_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate (enumerated) directions into strings.  <a href="classoomph_1_1OcTree.html#a2e9487b716f4d583aada06a850b8eae9">More...</a><br /></td></tr>
<tr class="separator:a2e9487b716f4d583aada06a850b8eae9 inherit pub_static_attribs_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b5b6208e34976cb3fd50e84b5c2d05 inherit pub_static_attribs_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a50b5b6208e34976cb3fd50e84b5c2d05">Reflect_face</a></td></tr>
<tr class="memdesc:a50b5b6208e34976cb3fd50e84b5c2d05 inherit pub_static_attribs_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get opposite face, e.g. Reflect_face[L]=R.  <a href="classoomph_1_1OcTree.html#a50b5b6208e34976cb3fd50e84b5c2d05">More...</a><br /></td></tr>
<tr class="separator:a50b5b6208e34976cb3fd50e84b5c2d05 inherit pub_static_attribs_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb757b41fc1c4b7ea697de40c19b6c36 inherit pub_static_attribs_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#aeb757b41fc1c4b7ea697de40c19b6c36">Reflect_edge</a></td></tr>
<tr class="memdesc:aeb757b41fc1c4b7ea697de40c19b6c36 inherit pub_static_attribs_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get opposite edge, e.g. Reflect_edge[DB]=UF.  <a href="classoomph_1_1OcTree.html#aeb757b41fc1c4b7ea697de40c19b6c36">More...</a><br /></td></tr>
<tr class="separator:aeb757b41fc1c4b7ea697de40c19b6c36 inherit pub_static_attribs_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee0e40be5a1aa25e7356e23ec327636 inherit pub_static_attribs_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#acee0e40be5a1aa25e7356e23ec327636">Reflect_vertex</a></td></tr>
<tr class="memdesc:acee0e40be5a1aa25e7356e23ec327636 inherit pub_static_attribs_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get opposite vertex, e.g. Reflect_vertex[LDB]=RUF.  <a href="classoomph_1_1OcTree.html#acee0e40be5a1aa25e7356e23ec327636">More...</a><br /></td></tr>
<tr class="separator:acee0e40be5a1aa25e7356e23ec327636 inherit pub_static_attribs_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf182a71db90c350c3f1d334d73d103f inherit pub_static_attribs_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#acf182a71db90c350c3f1d334d73d103f">Vertex_at_end_of_edge</a></td></tr>
<tr class="memdesc:acf182a71db90c350c3f1d334d73d103f inherit pub_static_attribs_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a></code> of vectors containing the two vertices for each edge, e.g. <code>Vertex_at_end_of_edge</code>[LU][0]=LUB and <code>Vertex_at_end_of_edge</code>[LU][1]=LUF.  <a href="classoomph_1_1OcTree.html#acf182a71db90c350c3f1d334d73d103f">More...</a><br /></td></tr>
<tr class="separator:acf182a71db90c350c3f1d334d73d103f inherit pub_static_attribs_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec83bade91057d89aa3896274cb96b7e inherit pub_static_attribs_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt;, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#aec83bade91057d89aa3896274cb96b7e">Vector_to_direction</a></td></tr>
<tr class="memdesc:aec83bade91057d89aa3896274cb96b7e inherit pub_static_attribs_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each vector representing a direction can be translated into a direction, either a son type (vertex), a face or an edge. E.g. : Vector_to_direction[(1,-1,1)]=RDF, Vector_to_direction[(0,1,0)]=U.  <a href="classoomph_1_1OcTree.html#aec83bade91057d89aa3896274cb96b7e">More...</a><br /></td></tr>
<tr class="separator:aec83bade91057d89aa3896274cb96b7e inherit pub_static_attribs_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf813fbb9cffe89fb51f3c8ccd3083ca inherit pub_static_attribs_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#adf813fbb9cffe89fb51f3c8ccd3083ca">Direction_to_vector</a></td></tr>
<tr class="memdesc:adf813fbb9cffe89fb51f3c8ccd3083ca inherit pub_static_attribs_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each direction, i.e. a son_type (vertex), a face or an edge, this defines a vector that indicates this direction. E.g : Direction_to_vector[RDB]=(1,-1,-1), Direction_to_vector[U]=(0,1,0)  <a href="classoomph_1_1OcTree.html#adf813fbb9cffe89fb51f3c8ccd3083ca">More...</a><br /></td></tr>
<tr class="separator:adf813fbb9cffe89fb51f3c8ccd3083ca inherit pub_static_attribs_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cff579697781e1ec50c86517feec77 inherit pub_static_attribs_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static std::map&lt; std::pair&lt; std::pair&lt; int, int &gt;, std::pair&lt; int, int &gt; &gt;, std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a88cff579697781e1ec50c86517feec77">Up_and_right_equivalent_for_pairs_of_vertices</a></td></tr>
<tr class="memdesc:a88cff579697781e1ec50c86517feec77 inherit pub_static_attribs_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the up/right-equivalents corresponding to two pairs of vertices along an element edge:  <a href="classoomph_1_1OcTree.html#a88cff579697781e1ec50c86517feec77">More...</a><br /></td></tr>
<tr class="separator:a88cff579697781e1ec50c86517feec77 inherit pub_static_attribs_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classoomph_1_1Tree"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classoomph_1_1Tree')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classoomph_1_1Tree.html">oomph::Tree</a></td></tr>
<tr class="memitem:a9e532196340dcd859ff8207eea2ddbbc inherit pub_static_attribs_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a9e532196340dcd859ff8207eea2ddbbc">OMEGA</a> = 26</td></tr>
<tr class="memdesc:a9e532196340dcd859ff8207eea2ddbbc inherit pub_static_attribs_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value for an unassigned neighbour.  <a href="classoomph_1_1Tree.html#a9e532196340dcd859ff8207eea2ddbbc">More...</a><br /></td></tr>
<tr class="separator:a9e532196340dcd859ff8207eea2ddbbc inherit pub_static_attribs_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classoomph_1_1OcTree"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classoomph_1_1OcTree')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classoomph_1_1OcTree.html">oomph::OcTree</a></td></tr>
<tr class="memitem:abb830075e2f08aa68bf65a07089039ca inherit pro_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#abb830075e2f08aa68bf65a07089039ca">OcTree</a> ()</td></tr>
<tr class="memdesc:abb830075e2f08aa68bf65a07089039ca inherit pro_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor (empty and broken)  <a href="classoomph_1_1OcTree.html#abb830075e2f08aa68bf65a07089039ca">More...</a><br /></td></tr>
<tr class="separator:abb830075e2f08aa68bf65a07089039ca inherit pro_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0f7987566846a0451bdc1ed522a2d4 inherit pro_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a2c0f7987566846a0451bdc1ed522a2d4">OcTree</a> (<a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c">object_pt</a>)</td></tr>
<tr class="memdesc:a2c0f7987566846a0451bdc1ed522a2d4 inherit pro_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for empty (root) tree: no father, no sons; just pass a pointer to its object (a <a class="el" href="classoomph_1_1RefineableQElement_3_013_01_4.html" title="Refineable version of QElement&lt;3,NNODE_1D&gt;.">RefineableQElement&lt;3&gt;</a>). This is protected because OcTrees can only be created internally, during the split operation. Only OcTreeRoots can be created externally.  <a href="classoomph_1_1OcTree.html#a2c0f7987566846a0451bdc1ed522a2d4">More...</a><br /></td></tr>
<tr class="separator:a2c0f7987566846a0451bdc1ed522a2d4 inherit pro_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79e3cbf9d0c65f9e4a01207d65d4967 inherit pro_methods_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#af79e3cbf9d0c65f9e4a01207d65d4967">OcTree</a> (<a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c">object_pt</a>, <a class="el" href="classoomph_1_1Tree.html">Tree</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a5f8444ddeda272b70669b8bbe929708a">father_pt</a>, const int &amp;<a class="el" href="classoomph_1_1Tree.html#a7537f8fe7c896d2220eb2da03567b34d">son_type</a>)</td></tr>
<tr class="memdesc:af79e3cbf9d0c65f9e4a01207d65d4967 inherit pro_methods_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for tree that has a father: Pass it the pointer to its object, the pointer to its father and tell it what type of son (LDB,RDB,...) it is. Protected because OcTrees can only be created internally, during the split operation. Only OcTreeRoots can be created externally.  <a href="classoomph_1_1OcTree.html#af79e3cbf9d0c65f9e4a01207d65d4967">More...</a><br /></td></tr>
<tr class="separator:af79e3cbf9d0c65f9e4a01207d65d4967 inherit pro_methods_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classoomph_1_1Tree"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classoomph_1_1Tree')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classoomph_1_1Tree.html">oomph::Tree</a></td></tr>
<tr class="memitem:ada92f1aa44ee6ef5b52ec5ad0af00359 inherit pro_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#ada92f1aa44ee6ef5b52ec5ad0af00359">Tree</a> ()</td></tr>
<tr class="memdesc:ada92f1aa44ee6ef5b52ec5ad0af00359 inherit pro_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor (empty and broken)  <a href="classoomph_1_1Tree.html#ada92f1aa44ee6ef5b52ec5ad0af00359">More...</a><br /></td></tr>
<tr class="separator:ada92f1aa44ee6ef5b52ec5ad0af00359 inherit pro_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e78c3a130add917de182ab5f1674531 inherit pro_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a6e78c3a130add917de182ab5f1674531">Tree</a> (<a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c">object_pt</a>)</td></tr>
<tr class="memdesc:a6e78c3a130add917de182ab5f1674531 inherit pro_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for empty (root) tree: no father, no sons; just pass a pointer to its object Protected because Trees can only be created internally, during the split operation. Only TreeRoots can be created externally.  <a href="classoomph_1_1Tree.html#a6e78c3a130add917de182ab5f1674531">More...</a><br /></td></tr>
<tr class="separator:a6e78c3a130add917de182ab5f1674531 inherit pro_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d611dde1f429500330f28e56ee71883 inherit pro_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a9d611dde1f429500330f28e56ee71883">Tree</a> (<a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c">object_pt</a>, <a class="el" href="classoomph_1_1Tree.html">Tree</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a5f8444ddeda272b70669b8bbe929708a">father_pt</a>, const int &amp;<a class="el" href="classoomph_1_1Tree.html#a7537f8fe7c896d2220eb2da03567b34d">son_type</a>)</td></tr>
<tr class="memdesc:a9d611dde1f429500330f28e56ee71883 inherit pro_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for tree that has a father: Pass it the pointer to its object, the pointer to its father and tell it what type of son it is. Protected because Trees can only be created internally, during the split operation. Only TreeRoots can be created externally.  <a href="classoomph_1_1Tree.html#a9d611dde1f429500330f28e56ee71883">More...</a><br /></td></tr>
<tr class="separator:a9d611dde1f429500330f28e56ee71883 inherit pro_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classoomph_1_1Tree"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classoomph_1_1Tree')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classoomph_1_1Tree.html">oomph::Tree</a></td></tr>
<tr class="memitem:a61782afd668561ad7ab324f658ffeb6a inherit pro_attribs_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a61782afd668561ad7ab324f658ffeb6a">Root_pt</a></td></tr>
<tr class="memdesc:a61782afd668561ad7ab324f658ffeb6a inherit pro_attribs_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the root of the tree.  <a href="classoomph_1_1Tree.html#a61782afd668561ad7ab324f658ffeb6a">More...</a><br /></td></tr>
<tr class="separator:a61782afd668561ad7ab324f658ffeb6a inherit pro_attribs_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001ce5515a3d76cdad248695e149504b inherit pro_attribs_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Tree.html">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a001ce5515a3d76cdad248695e149504b">Father_pt</a></td></tr>
<tr class="memdesc:a001ce5515a3d76cdad248695e149504b inherit pro_attribs_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the Father of the <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a>.  <a href="classoomph_1_1Tree.html#a001ce5515a3d76cdad248695e149504b">More...</a><br /></td></tr>
<tr class="separator:a001ce5515a3d76cdad248695e149504b inherit pro_attribs_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b9069f345b296654421604c5569af6 inherit pro_attribs_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Tree.html">Tree</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#ac6b9069f345b296654421604c5569af6">Son_pt</a></td></tr>
<tr class="memdesc:ac6b9069f345b296654421604c5569af6 inherit pro_attribs_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> of pointers to the sons of the <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a>.  <a href="classoomph_1_1Tree.html#ac6b9069f345b296654421604c5569af6">More...</a><br /></td></tr>
<tr class="separator:ac6b9069f345b296654421604c5569af6 inherit pro_attribs_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac30decb7a63027906880620f8b98ee inherit pro_attribs_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a9ac30decb7a63027906880620f8b98ee">Level</a></td></tr>
<tr class="memdesc:a9ac30decb7a63027906880620f8b98ee inherit pro_attribs_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level of the <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> (level 0 = root)  <a href="classoomph_1_1Tree.html#a9ac30decb7a63027906880620f8b98ee">More...</a><br /></td></tr>
<tr class="separator:a9ac30decb7a63027906880620f8b98ee inherit pro_attribs_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fe7895af25c9f60062c081fc51967c inherit pro_attribs_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a83fe7895af25c9f60062c081fc51967c">Son_type</a></td></tr>
<tr class="memdesc:a83fe7895af25c9f60062c081fc51967c inherit pro_attribs_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Son type (e.g. SW/SE/NW/NE in a quadtree)  <a href="classoomph_1_1Tree.html#a83fe7895af25c9f60062c081fc51967c">More...</a><br /></td></tr>
<tr class="separator:a83fe7895af25c9f60062c081fc51967c inherit pro_attribs_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ee20b575da510512d0e108cf7b06c6 inherit pro_attribs_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a61ee20b575da510512d0e108cf7b06c6">Object_pt</a></td></tr>
<tr class="memdesc:a61ee20b575da510512d0e108cf7b06c6 inherit pro_attribs_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the object represented by the tree.  <a href="classoomph_1_1Tree.html#a61ee20b575da510512d0e108cf7b06c6">More...</a><br /></td></tr>
<tr class="separator:a61ee20b575da510512d0e108cf7b06c6 inherit pro_attribs_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classoomph_1_1TreeRoot"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classoomph_1_1TreeRoot')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classoomph_1_1TreeRoot.html">oomph::TreeRoot</a></td></tr>
<tr class="memitem:a8923854080ee44a2d1be477000309b13 inherit pro_attribs_classoomph_1_1TreeRoot"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1TreeRoot.html#a8923854080ee44a2d1be477000309b13">Neighbour_pt</a></td></tr>
<tr class="memdesc:a8923854080ee44a2d1be477000309b13 inherit pro_attribs_classoomph_1_1TreeRoot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of pointers to the neighbouring TreeRoots: Neighbour_pt[direction] returns the pointer to the <a class="el" href="classoomph_1_1TreeRoot.html" title="TreeRoot is a Tree that forms the root of a (recursive) tree. The &quot;root node&quot; is special as it holds ...">TreeRoot</a>'s neighbour in the (enumerated) direction. Returns NULL if there's no neighbour in this direction.  <a href="classoomph_1_1TreeRoot.html#a8923854080ee44a2d1be477000309b13">More...</a><br /></td></tr>
<tr class="separator:a8923854080ee44a2d1be477000309b13 inherit pro_attribs_classoomph_1_1TreeRoot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067533f9b739e6c185ce776ea0c98e88 inherit pro_attribs_classoomph_1_1TreeRoot"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1TreeRoot.html#a067533f9b739e6c185ce776ea0c98e88">Neighbour_periodic</a></td></tr>
<tr class="memdesc:a067533f9b739e6c185ce776ea0c98e88 inherit pro_attribs_classoomph_1_1TreeRoot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of booleans used for periodic boundaries: Neighbour_periodic_direction[directon] returns true if the neighbour in that direction is actually a periodic neighbour &mdash; shared data values, but independent position. The default return of the map is false.  <a href="classoomph_1_1TreeRoot.html#a067533f9b739e6c185ce776ea0c98e88">More...</a><br /></td></tr>
<tr class="separator:a067533f9b739e6c185ce776ea0c98e88 inherit pro_attribs_classoomph_1_1TreeRoot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classoomph_1_1OcTree"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classoomph_1_1OcTree')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classoomph_1_1OcTree.html">oomph::OcTree</a></td></tr>
<tr class="memitem:addaa397d11580ec949531c8ae9b082a5 inherit pro_static_attribs_classoomph_1_1OcTree"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#addaa397d11580ec949531c8ae9b082a5">Static_data_has_been_setup</a> = false</td></tr>
<tr class="memdesc:addaa397d11580ec949531c8ae9b082a5 inherit pro_static_attribs_classoomph_1_1OcTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bool indicating that static member data has been setup.  <a href="classoomph_1_1OcTree.html#addaa397d11580ec949531c8ae9b082a5">More...</a><br /></td></tr>
<tr class="separator:addaa397d11580ec949531c8ae9b082a5 inherit pro_static_attribs_classoomph_1_1OcTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classoomph_1_1Tree"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classoomph_1_1Tree')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classoomph_1_1Tree.html">oomph::Tree</a></td></tr>
<tr class="memitem:aef9abebc166fa3bf81ecb59ec0d5d6b2 inherit pro_static_attribs_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#aef9abebc166fa3bf81ecb59ec0d5d6b2">Max_neighbour_finding_tolerance</a> = 1.0e-14</td></tr>
<tr class="memdesc:aef9abebc166fa3bf81ecb59ec0d5d6b2 inherit pro_static_attribs_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max. allowed discrepancy in neighbour finding routine (distance between points when identified from two neighbouring elements)  <a href="classoomph_1_1Tree.html#aef9abebc166fa3bf81ecb59ec0d5d6b2">More...</a><br /></td></tr>
<tr class="separator:aef9abebc166fa3bf81ecb59ec0d5d6b2 inherit pro_static_attribs_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classoomph_1_1OcTreeRoot.html" title="OcTreeRoot is a OcTree that forms the root of a (recursive) octree. The &quot;root node&quot; is special as it ...">OcTreeRoot</a> is a <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> that forms the root of a (recursive) octree. The "root node" is special as it holds additional information about its neighbours and their relative rotation (inside a <a class="el" href="classoomph_1_1OcTreeForest.html" title="/////////////////////////////////////////////////////////////////////// /////////////////////////////...">OcTreeForest</a>). </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00610">610</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a594278fd254e72415e1523b1b8e7273d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594278fd254e72415e1523b1b8e7273d">&#9670;&nbsp;</a></span>OcTreeRoot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">oomph::OcTreeRoot::OcTreeRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *const &amp;&#160;</td>
          <td class="paramname"><em>object_pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for the root octree: Pass pointer to the <a class="el" href="classoomph_1_1RefineableQElement_3_013_01_4.html" title="Refineable version of QElement&lt;3,NNODE_1D&gt;.">RefineableQElement&lt;3&gt;</a> that is represented by the <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a>. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00641">641</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00412">oomph::OcTree::Static_data_has_been_setup</a>, and <a class="el" href="oomph__definitions_8cc_source.html#l00286">oomph::Global_string_for_annotation::string()</a>.</p>

</div>
</div>
<a id="a3da527433d221179d7e5eed13d547336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da527433d221179d7e5eed13d547336">&#9670;&nbsp;</a></span>OcTreeRoot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">oomph::OcTreeRoot::OcTreeRoot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoomph_1_1OcTreeRoot.html">OcTreeRoot</a> &amp;&#160;</td>
          <td class="paramname"><em>dummy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broken copy constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a92ccf3b396de331440c5dcba2e024317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ccf3b396de331440c5dcba2e024317">&#9670;&nbsp;</a></span>add_edge_neighbour_pt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oomph::OcTreeRoot::add_edge_neighbour_pt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *&#160;</td>
          <td class="paramname"><em>oc_tree_root_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>edge_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add pointer to the edge-neighbouring [Oc]<a class="el" href="classoomph_1_1TreeRoot.html" title="TreeRoot is a Tree that forms the root of a (recursive) tree. The &quot;root node&quot; is special as it holds ...">TreeRoot</a> in the (enumerated) (edge) direction &ndash; maintains uniqueness. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00716">716</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00059">oomph::OcTreeNames::DB</a>, <a class="el" href="octree_8h_source.html#l00067">oomph::OcTreeNames::DF</a>, <a class="el" href="octree_8h_source.html#l00329">oomph::OcTree::Direct_string</a>, <a class="el" href="octree_8h_source.html#l00616">Edge_neighbour_pt</a>, <a class="el" href="octree_8h_source.html#l00057">oomph::OcTreeNames::LB</a>, <a class="el" href="octree_8h_source.html#l00061">oomph::OcTreeNames::LD</a>, <a class="el" href="octree_8h_source.html#l00065">oomph::OcTreeNames::LF</a>, <a class="el" href="octree_8h_source.html#l00063">oomph::OcTreeNames::LU</a>, <a class="el" href="octree_8h_source.html#l00058">oomph::OcTreeNames::RB</a>, <a class="el" href="octree_8h_source.html#l00062">oomph::OcTreeNames::RD</a>, <a class="el" href="octree_8h_source.html#l00066">oomph::OcTreeNames::RF</a>, <a class="el" href="octree_8h_source.html#l00064">oomph::OcTreeNames::RU</a>, <a class="el" href="octree_8h_source.html#l00060">oomph::OcTreeNames::UB</a>, and <a class="el" href="octree_8h_source.html#l00068">oomph::OcTreeNames::UF</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l04913">oomph::OcTreeForest::find_neighbours()</a>.</p>

</div>
</div>
<a id="a6b6730957601b05b991ffc9972d31f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6730957601b05b991ffc9972d31f8b">&#9670;&nbsp;</a></span>direction_of_neighbour()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int oomph::OcTreeRoot::direction_of_neighbour </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *&#160;</td>
          <td class="paramname"><em>octree_root_pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If octree_root_pt is a neighbour, return the direction [faces L/R/F/B/U/D or edges DB/UP/...] in which it is found, otherwise return OMEGA. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00814">814</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00073">oomph::OcTreeNames::B</a>, <a class="el" href="octree_8h_source.html#l00071">oomph::OcTreeNames::D</a>, <a class="el" href="octree_8h_source.html#l00059">oomph::OcTreeNames::DB</a>, <a class="el" href="octree_8h_source.html#l00067">oomph::OcTreeNames::DF</a>, <a class="el" href="cfortran_8h_source.html#l00571">e</a>, <a class="el" href="octree_8h_source.html#l00668">edge_neighbour_pt()</a>, <a class="el" href="octree_8h_source.html#l00074">oomph::OcTreeNames::F</a>, <a class="el" href="octree_8h_source.html#l00069">oomph::OcTreeNames::L</a>, <a class="el" href="octree_8h_source.html#l00057">oomph::OcTreeNames::LB</a>, <a class="el" href="octree_8h_source.html#l00061">oomph::OcTreeNames::LD</a>, <a class="el" href="octree_8h_source.html#l00065">oomph::OcTreeNames::LF</a>, <a class="el" href="octree_8h_source.html#l00063">oomph::OcTreeNames::LU</a>, <a class="el" href="tree_8h_source.html#l00330">oomph::TreeRoot::Neighbour_pt</a>, <a class="el" href="tree_8h_source.html#l00262">oomph::Tree::OMEGA</a>, <a class="el" href="octree_8h_source.html#l00070">oomph::OcTreeNames::R</a>, <a class="el" href="octree_8h_source.html#l00058">oomph::OcTreeNames::RB</a>, <a class="el" href="octree_8h_source.html#l00062">oomph::OcTreeNames::RD</a>, <a class="el" href="octree_8h_source.html#l00066">oomph::OcTreeNames::RF</a>, <a class="el" href="octree_8h_source.html#l00064">oomph::OcTreeNames::RU</a>, <a class="el" href="octree_8h_source.html#l00072">oomph::OcTreeNames::U</a>, <a class="el" href="octree_8h_source.html#l00060">oomph::OcTreeNames::UB</a>, and <a class="el" href="octree_8h_source.html#l00068">oomph::OcTreeNames::UF</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l05255">oomph::OcTreeForest::construct_up_right_equivalents()</a>, <a class="el" href="octree_8h_source.html#l00790">right_equivalent()</a>, and <a class="el" href="octree_8h_source.html#l00757">up_equivalent()</a>.</p>

</div>
</div>
<a id="acef513b8401e5fd32d1311bdebe86f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef513b8401e5fd32d1311bdebe86f45">&#9670;&nbsp;</a></span>edge_neighbour_pt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt;<a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a>*&gt; oomph::OcTreeRoot::edge_neighbour_pt </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>edge_direction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return vector of pointers to the edge-neighbouring TreeRoots in the (enumerated) (edge) direction. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00668">668</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00059">oomph::OcTreeNames::DB</a>, <a class="el" href="octree_8h_source.html#l00067">oomph::OcTreeNames::DF</a>, <a class="el" href="octree_8h_source.html#l00329">oomph::OcTree::Direct_string</a>, <a class="el" href="octree_8h_source.html#l00616">Edge_neighbour_pt</a>, <a class="el" href="octree_8h_source.html#l00057">oomph::OcTreeNames::LB</a>, <a class="el" href="octree_8h_source.html#l00061">oomph::OcTreeNames::LD</a>, <a class="el" href="octree_8h_source.html#l00065">oomph::OcTreeNames::LF</a>, <a class="el" href="octree_8h_source.html#l00063">oomph::OcTreeNames::LU</a>, <a class="el" href="octree_8h_source.html#l00058">oomph::OcTreeNames::RB</a>, <a class="el" href="octree_8h_source.html#l00062">oomph::OcTreeNames::RD</a>, <a class="el" href="octree_8h_source.html#l00066">oomph::OcTreeNames::RF</a>, <a class="el" href="octree_8h_source.html#l00064">oomph::OcTreeNames::RU</a>, <a class="el" href="octree_8h_source.html#l00060">oomph::OcTreeNames::UB</a>, and <a class="el" href="octree_8h_source.html#l00068">oomph::OcTreeNames::UF</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8h_source.html#l00814">direction_of_neighbour()</a>, and <a class="el" href="octree_8h_source.html#l01002">oomph::OcTreeForest::oc_edge_neigh_pt()</a>.</p>

</div>
</div>
<a id="add3c1de4903d2db75d19274719912ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3c1de4903d2db75d19274719912ea3">&#9670;&nbsp;</a></span>nedge_neighbour()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned oomph::OcTreeRoot::nedge_neighbour </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>edge_direction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of edge-neighbouring <a class="el" href="classoomph_1_1OcTreeRoot.html" title="OcTreeRoot is a OcTree that forms the root of a (recursive) octree. The &quot;root node&quot; is special as it ...">OcTreeRoot</a> in the (enumerated) (edge) direction. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00693">693</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00059">oomph::OcTreeNames::DB</a>, <a class="el" href="octree_8h_source.html#l00067">oomph::OcTreeNames::DF</a>, <a class="el" href="octree_8h_source.html#l00329">oomph::OcTree::Direct_string</a>, <a class="el" href="octree_8h_source.html#l00616">Edge_neighbour_pt</a>, <a class="el" href="octree_8h_source.html#l00057">oomph::OcTreeNames::LB</a>, <a class="el" href="octree_8h_source.html#l00061">oomph::OcTreeNames::LD</a>, <a class="el" href="octree_8h_source.html#l00065">oomph::OcTreeNames::LF</a>, <a class="el" href="octree_8h_source.html#l00063">oomph::OcTreeNames::LU</a>, <a class="el" href="octree_8h_source.html#l00058">oomph::OcTreeNames::RB</a>, <a class="el" href="octree_8h_source.html#l00062">oomph::OcTreeNames::RD</a>, <a class="el" href="octree_8h_source.html#l00066">oomph::OcTreeNames::RF</a>, <a class="el" href="octree_8h_source.html#l00064">oomph::OcTreeNames::RU</a>, <a class="el" href="octree_8h_source.html#l00060">oomph::OcTreeNames::UB</a>, and <a class="el" href="octree_8h_source.html#l00068">oomph::OcTreeNames::UF</a>.</p>

</div>
</div>
<a id="a6941e4a38b81116bec7f6b6c2e8e88de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6941e4a38b81116bec7f6b6c2e8e88de">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oomph::OcTreeRoot::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoomph_1_1OcTreeRoot.html">OcTreeRoot</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broken assignment operator. </p>

</div>
</div>
<a id="a497950cb0812be6a95be8af658a03fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497950cb0812be6a95be8af658a03fb6">&#9670;&nbsp;</a></span>right_equivalent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int oomph::OcTreeRoot::right_equivalent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *&#160;</td>
          <td class="paramname"><em>tree_root_pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same thing as up_equivalent, but for the right direction: When viewed from the current octree neighbour, our right direction is the neighbour's Right_equivalent[neighbour_pt] direction. Returns OMEGA if the Octree specified by the pointer argument is not a neighbour. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00790">790</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00814">direction_of_neighbour()</a>, <a class="el" href="tree_8h_source.html#l00262">oomph::Tree::OMEGA</a>, and <a class="el" href="octree_8h_source.html#l00635">Right_equivalent</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l03373">oomph::OcTree::gteq_face_neighbour()</a>, and <a class="el" href="octree_8cc_source.html#l03618">oomph::OcTree::gteq_true_edge_neighbour()</a>.</p>

</div>
</div>
<a id="aa462fe159838307aee0870ad089836f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa462fe159838307aee0870ad089836f5">&#9670;&nbsp;</a></span>set_right_equivalent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oomph::OcTreeRoot::set_right_equivalent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *&#160;</td>
          <td class="paramname"><em>tree_root_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same thing as up_equivalent, but for the right direction: When viewed from the current octree neighbour, our right direction is the neighbour's Right_equivalent[neighbour_pt] direction. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00806">806</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00635">Right_equivalent</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l05255">oomph::OcTreeForest::construct_up_right_equivalents()</a>.</p>

</div>
</div>
<a id="a91210b8fab8bb9f092518303551e0c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91210b8fab8bb9f092518303551e0c33">&#9670;&nbsp;</a></span>set_up_equivalent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oomph::OcTreeRoot::set_up_equivalent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *&#160;</td>
          <td class="paramname"><em>tree_root_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up equivalent of the neighbours specified by pointer: When viewed from the current octree's neighbour, our up direction is the neighbour's Up_equivalent[neighbour_pt] direction. If there's no rotation, this map contains the identify so that, e.g. <code>Up_equivalent</code>[neighbour_pt]=U (read as: "in my
neighbour, my Up is its Up"). If the neighbour is rotated by 180 degrees relative to the current octree (around the back-front axis) say, we have <code>Up_equivalent</code>[neighbour_pt]=D (read as: "in my
neighbour, my Up is its Down"); etc. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00779">779</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00627">Up_equivalent</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l05255">oomph::OcTreeForest::construct_up_right_equivalents()</a>.</p>

</div>
</div>
<a id="a961a28583236f1b92bc35de064d2dba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961a28583236f1b92bc35de064d2dba6">&#9670;&nbsp;</a></span>up_equivalent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int oomph::OcTreeRoot::up_equivalent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *&#160;</td>
          <td class="paramname"><em>tree_root_pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return up equivalent of the neighbours specified by pointer: When viewed from the current octree's neighbour, our up direction is the neighbour's Up_equivalent[neighbour_pt] direction. If there's no rotation, this map contains the identify so that, e.g. <code>Up_equivalent</code>[neighbour_pt]=U (read as: "in my
neighbour, my Up is its Up"). If the neighbour is rotated by 180 degrees relative to the current octree (around the back-front axis) say, we have <code>Up_equivalent</code>[neighbour_pt]=D (read as: "in my
neighbour, my Up is its Down"); etc. Returns OMEGA if the Octree specified by the pointer argument is not a neighbour. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00757">757</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00814">direction_of_neighbour()</a>, <a class="el" href="tree_8h_source.html#l00262">oomph::Tree::OMEGA</a>, and <a class="el" href="octree_8h_source.html#l00627">Up_equivalent</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l03373">oomph::OcTree::gteq_face_neighbour()</a>, and <a class="el" href="octree_8cc_source.html#l03618">oomph::OcTree::gteq_true_edge_neighbour()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae3c71331aaf452591ba6a3ab0cdbcdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c71331aaf452591ba6a3ab0cdbcdbc">&#9670;&nbsp;</a></span>Edge_neighbour_pt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt;<a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a>*&gt; &gt; oomph::OcTreeRoot::Edge_neighbour_pt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map of pointers to the edge-neighbouring [Oc]TreeRoots: Edge_neighbour_pt[direction] is <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> to the pointers to the [Oc]<a class="el" href="classoomph_1_1TreeRoot.html" title="TreeRoot is a Tree that forms the root of a (recursive) tree. The &quot;root node&quot; is special as it holds ...">TreeRoot</a>'s edge neighbours in the (enumerated) (edge) direction. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00616">616</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8h_source.html#l00716">add_edge_neighbour_pt()</a>, <a class="el" href="octree_8h_source.html#l00668">edge_neighbour_pt()</a>, and <a class="el" href="octree_8h_source.html#l00693">nedge_neighbour()</a>.</p>

</div>
</div>
<a id="a739d09d26896cfb6924f4d023f5d791f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739d09d26896cfb6924f4d023f5d791f">&#9670;&nbsp;</a></span>Right_equivalent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a>*, int&gt; oomph::OcTreeRoot::Right_equivalent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map giving the Right equivalent of the neighbour specified by pointer: When viewed from the current octree's neighbour, our right direction is the neighbour's right_equivalent[neighbour_pt] direction. If there's no rotation, this map contains the identify so that, e.g. <code>Right_equivalent</code>[neighbour_pt]=R (read as: "in my
neighbour, my Right is its Right"). </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00635">635</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8h_source.html#l00790">right_equivalent()</a>, and <a class="el" href="octree_8h_source.html#l00806">set_right_equivalent()</a>.</p>

</div>
</div>
<a id="a247955b8a3eb01e227ec2ee1f3bb96ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247955b8a3eb01e227ec2ee1f3bb96ce">&#9670;&nbsp;</a></span>Up_equivalent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a>*, int&gt; oomph::OcTreeRoot::Up_equivalent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map giving the Up equivalent of the neighbour specified by pointer: When viewed from the current octree's neighbour, our up direction is the neighbour's Up_equivalent[neighbour_pt] direction. If there's no rotation, this map contains the identify so that, e.g. <code>Up_equivalent</code>[neighbour_pt]=U (read as: "in my
neighbour, my Up is its Up"). If the neighbour is rotated by 180 degrees relative to the current octree(around the back-front axis), say, we have <code>Up_equivalent</code>[neighbour_pt]=D (read as: "in my
neighbour, my Up is its Down"); etc. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00627">627</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8h_source.html#l00779">set_up_equivalent()</a>, and <a class="el" href="octree_8h_source.html#l00757">up_equivalent()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="octree_8h_source.html">octree.h</a></li>
</ul>
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:11:29
        </div>
      </div>
    </footer>
</body>
</html>
