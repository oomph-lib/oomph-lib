<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: oomph::BiharmonicFluidProblem&lt; DIM &gt; Class Template Reference</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../figures/manifest.json">
<link rel="mask-icon" href="../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../html/index.html"><img alt="oomph-lib" src="../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceoomph.html">oomph</a></li><li class="navelem"><a class="el" href="classoomph_1_1BiharmonicFluidProblem.html">BiharmonicFluidProblem</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classoomph_1_1BiharmonicFluidProblem-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">oomph::BiharmonicFluidProblem&lt; DIM &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Biharmonic Fluid <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> Class - describes stokes flow in 2D. Developed for the topologically rectangular Hermite Element <a class="el" href="classoomph_1_1Mesh.html" title="A general mesh class.">Mesh</a>. Contains functions allowing the following boundary conditions to be applied (on a given edge):  
 <a href="classoomph_1_1BiharmonicFluidProblem.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="biharmonic__problem_8h_source.html">biharmonic_problem.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for oomph::BiharmonicFluidProblem&lt; DIM &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classoomph_1_1BiharmonicFluidProblem.png" usemap="#oomph::BiharmonicFluidProblem_3C_20DIM_20_3E_map" alt=""/>
  <map id="oomph::BiharmonicFluidProblem_3C_20DIM_20_3E_map" name="oomph::BiharmonicFluidProblem_3C_20DIM_20_3E_map">
<area href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////..." alt="oomph::Problem" shape="rect" coords="0,56,239,80"/>
<area href="classoomph_1_1ExplicitTimeSteppableObject.html" title="Class for objects than can be advanced in time by an Explicit Timestepper. WARNING: For explicit time..." alt="oomph::ExplicitTimeSteppableObject" shape="rect" coords="0,0,239,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a93661d3b0c52bd82fd58496f9f853079"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1BiharmonicFluidProblem.html#a93661d3b0c52bd82fd58496f9f853079">FluidBCFctPt</a>) (const double &amp;<a class="el" href="cfortran_8h.html#ab7123126e4885ef647dd9c6e3807a21c">s</a>, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;u)</td></tr>
<tr class="memdesc:a93661d3b0c52bd82fd58496f9f853079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a dirichlet boundary condition function pointer. Takes the position along a boundary (s) in the macro element coordinate scheme and returns the fluid velocity normal (dpsi/dt) to the boundary (u[0]) and the fluid velocity tangential (dpsidn) to the boundary (u[1]).  <a href="classoomph_1_1BiharmonicFluidProblem.html#a93661d3b0c52bd82fd58496f9f853079">More...</a><br /></td></tr>
<tr class="separator:a93661d3b0c52bd82fd58496f9f853079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classoomph_1_1Problem"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classoomph_1_1Problem')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classoomph_1_1Problem.html">oomph::Problem</a></td></tr>
<tr class="memitem:a8fc1f40f2a9309e9ff02772fa2258402 inherit pub_types_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a8fc1f40f2a9309e9ff02772fa2258402">Distributed_problem_matrix_distribution</a> { <a class="el" href="classoomph_1_1Problem.html#a8fc1f40f2a9309e9ff02772fa2258402ad7503f3fef4bc3556497018171c820e6">Default_matrix_distribution</a>
, <a class="el" href="classoomph_1_1Problem.html#a8fc1f40f2a9309e9ff02772fa2258402aed8521359adcaf514039424b29893796">Problem_matrix_distribution</a>
, <a class="el" href="classoomph_1_1Problem.html#a8fc1f40f2a9309e9ff02772fa2258402a741cb51275fde6a02373b2ffacf1273f">Uniform_matrix_distribution</a>
 }</td></tr>
<tr class="memdesc:a8fc1f40f2a9309e9ff02772fa2258402"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum for distribution of distributed jacobians. 1 - Automatic - the <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> distribution is employed, unless any processor has number of rows equal to 110% of N/P, in which case uniform distribution is employed. 2 - <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> - the jacobian on processor p only contains rows that correspond to equations that are on this processor. (minimises communication) 3 - Uniform - each processor holds as close to N/P matrix rows as possible. (very well load balanced)  <a href="classoomph_1_1Problem.html#a8fc1f40f2a9309e9ff02772fa2258402">More...</a><br /></td></tr>
<tr class="separator:a8fc1f40f2a9309e9ff02772fa2258402 inherit pub_types_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638b525d7cae45e56160e3c282c8ad09 inherit pub_types_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a638b525d7cae45e56160e3c282c8ad09">SpatialErrorEstimatorFctPt</a>) (<a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *&amp;<a class="el" href="classoomph_1_1Problem.html#aad122d70a22dc5302cfd5853d3cf3057">mesh_pt</a>, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;elemental_error)</td></tr>
<tr class="memdesc:a638b525d7cae45e56160e3c282c8ad09 inherit pub_types_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer for spatial error estimator.  <a href="classoomph_1_1Problem.html#a638b525d7cae45e56160e3c282c8ad09">More...</a><br /></td></tr>
<tr class="separator:a638b525d7cae45e56160e3c282c8ad09 inherit pub_types_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220abfde16b8b1b544b4127e0e4cc9e4 inherit pub_types_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a220abfde16b8b1b544b4127e0e4cc9e4">SpatialErrorEstimatorWithDocFctPt</a>) (<a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *&amp;<a class="el" href="classoomph_1_1Problem.html#aad122d70a22dc5302cfd5853d3cf3057">mesh_pt</a>, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;elemental_error, <a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info)</td></tr>
<tr class="memdesc:a220abfde16b8b1b544b4127e0e4cc9e4 inherit pub_types_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer for spatial error estimator with doc.  <a href="classoomph_1_1Problem.html#a220abfde16b8b1b544b4127e0e4cc9e4">More...</a><br /></td></tr>
<tr class="separator:a220abfde16b8b1b544b4127e0e4cc9e4 inherit pub_types_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a258f8f42491569c4727c54cd8f8f17d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1BiharmonicFluidProblem.html#a258f8f42491569c4727c54cd8f8f17d5">BiharmonicFluidProblem</a> ()</td></tr>
<tr class="memdesc:a258f8f42491569c4727c54cd8f8f17d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <a href="classoomph_1_1BiharmonicFluidProblem.html#a258f8f42491569c4727c54cd8f8f17d5">More...</a><br /></td></tr>
<tr class="separator:a258f8f42491569c4727c54cd8f8f17d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62b36f8b36faae1324fe29fcd8e0875"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1BiharmonicFluidProblem.html#ad62b36f8b36faae1324fe29fcd8e0875">actions_before_newton_solve</a> ()</td></tr>
<tr class="memdesc:ad62b36f8b36faae1324fe29fcd8e0875"><td class="mdescLeft">&#160;</td><td class="mdescRight">actions before solve, performs self test  <a href="classoomph_1_1BiharmonicFluidProblem.html#ad62b36f8b36faae1324fe29fcd8e0875">More...</a><br /></td></tr>
<tr class="separator:ad62b36f8b36faae1324fe29fcd8e0875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a69be0763564ffd22f598d734d11a26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1BiharmonicFluidProblem.html#a6a69be0763564ffd22f598d734d11a26">actions_after_newton_solve</a> ()</td></tr>
<tr class="memdesc:a6a69be0763564ffd22f598d734d11a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">action after solve  <a href="classoomph_1_1BiharmonicFluidProblem.html#a6a69be0763564ffd22f598d734d11a26">More...</a><br /></td></tr>
<tr class="separator:a6a69be0763564ffd22f598d734d11a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095e8526d834c05c492929bd5017dfa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1BiharmonicFluidProblem.html#a095e8526d834c05c492929bd5017dfa5">doc_solution</a> (<a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info, <a class="el" href="classoomph_1_1FiniteElement.html#a690fd33af26cc3e84f39bba6d5a85202">FiniteElement::SteadyExactSolutionFctPt</a> exact_soln_pt=0)</td></tr>
<tr class="memdesc:a095e8526d834c05c492929bd5017dfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">documents the solution, and if an exact solution is provided, then the error between the numerical and exact solution is presented  <a href="classoomph_1_1BiharmonicFluidProblem.html#a095e8526d834c05c492929bd5017dfa5">More...</a><br /></td></tr>
<tr class="separator:a095e8526d834c05c492929bd5017dfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classoomph_1_1Problem"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classoomph_1_1Problem')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classoomph_1_1Problem.html">oomph::Problem</a></td></tr>
<tr class="memitem:a36c95c8211cc02558118288888aab5e1 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a36c95c8211cc02558118288888aab5e1">debug_hook_fct</a> (const unsigned &amp;<a class="el" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>)</td></tr>
<tr class="memdesc:a36c95c8211cc02558118288888aab5e1 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook for debugging. Can be overloaded in driver code; argument allows identification of where we're coming from.  <a href="classoomph_1_1Problem.html#a36c95c8211cc02558118288888aab5e1">More...</a><br /></td></tr>
<tr class="separator:a36c95c8211cc02558118288888aab5e1 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecef49e98bbcede9b8c3137592c2cc5a inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aecef49e98bbcede9b8c3137592c2cc5a">set_analytic_dparameter</a> (double *const &amp;parameter_pt)</td></tr>
<tr class="memdesc:aecef49e98bbcede9b8c3137592c2cc5a inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to turn on analytic calculation of the parameter derivatives in continuation and bifurcation detection problems.  <a href="classoomph_1_1Problem.html#aecef49e98bbcede9b8c3137592c2cc5a">More...</a><br /></td></tr>
<tr class="separator:aecef49e98bbcede9b8c3137592c2cc5a inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7bcab5505ba482a8c9ba7bace68bc0 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aff7bcab5505ba482a8c9ba7bace68bc0">unset_analytic_dparameter</a> (double *const &amp;parameter_pt)</td></tr>
<tr class="memdesc:aff7bcab5505ba482a8c9ba7bace68bc0 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to turn off analytic calculation of the parameter derivatives in continuation and bifurcation detection problems.  <a href="classoomph_1_1Problem.html#aff7bcab5505ba482a8c9ba7bace68bc0">More...</a><br /></td></tr>
<tr class="separator:aff7bcab5505ba482a8c9ba7bace68bc0 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a7b9cf8e6fe1156fc92baa43c3fe4b inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a41a7b9cf8e6fe1156fc92baa43c3fe4b">is_dparameter_calculated_analytically</a> (double *const &amp;parameter_pt)</td></tr>
<tr class="memdesc:a41a7b9cf8e6fe1156fc92baa43c3fe4b inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to determine whether the parameter derivatives are calculated analytically.  <a href="classoomph_1_1Problem.html#a41a7b9cf8e6fe1156fc92baa43c3fe4b">More...</a><br /></td></tr>
<tr class="separator:a41a7b9cf8e6fe1156fc92baa43c3fe4b inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f64c33501e0f9c65927eefed253eef inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a45f64c33501e0f9c65927eefed253eef">set_analytic_hessian_products</a> ()</td></tr>
<tr class="memdesc:a45f64c33501e0f9c65927eefed253eef inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to turn on analytic calculation of the parameter derivatives in continuation and bifurcation detection problems.  <a href="classoomph_1_1Problem.html#a45f64c33501e0f9c65927eefed253eef">More...</a><br /></td></tr>
<tr class="separator:a45f64c33501e0f9c65927eefed253eef inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd672b3da8c5bf28ad6bd856e28d1cf inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#accd672b3da8c5bf28ad6bd856e28d1cf">unset_analytic_hessian_products</a> ()</td></tr>
<tr class="memdesc:accd672b3da8c5bf28ad6bd856e28d1cf inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to turn off analytic calculation of the parameter derivatives in continuation and bifurcation detection problems.  <a href="classoomph_1_1Problem.html#accd672b3da8c5bf28ad6bd856e28d1cf">More...</a><br /></td></tr>
<tr class="separator:accd672b3da8c5bf28ad6bd856e28d1cf inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6235ced9e7e85324f785f2681ab3872 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af6235ced9e7e85324f785f2681ab3872">are_hessian_products_calculated_analytically</a> ()</td></tr>
<tr class="memdesc:af6235ced9e7e85324f785f2681ab3872 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to determine whether the hessian products are calculated analytically.  <a href="classoomph_1_1Problem.html#af6235ced9e7e85324f785f2681ab3872">More...</a><br /></td></tr>
<tr class="separator:af6235ced9e7e85324f785f2681ab3872 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820d3c43c7d678b4fe186a8c83a90732 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a820d3c43c7d678b4fe186a8c83a90732">set_pinned_values_to_zero</a> ()</td></tr>
<tr class="memdesc:a820d3c43c7d678b4fe186a8c83a90732 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all pinned values to zero. Used to set boundary conditions to be homogeneous in the copy of the problem used in adaptive bifurcation tracking (ALH: TEMPORARY HACK, WILL BE FIXED)  <a href="classoomph_1_1Problem.html#a820d3c43c7d678b4fe186a8c83a90732">More...</a><br /></td></tr>
<tr class="separator:a820d3c43c7d678b4fe186a8c83a90732 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e9f1623cad361048856a4c0463ea23 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af5e9f1623cad361048856a4c0463ea23">distributed</a> () const</td></tr>
<tr class="memdesc:af5e9f1623cad361048856a4c0463ea23 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we have MPI return the "problem has been distributed" flag, otherwise it can't be distributed so return false.  <a href="classoomph_1_1Problem.html#af5e9f1623cad361048856a4c0463ea23">More...</a><br /></td></tr>
<tr class="separator:af5e9f1623cad361048856a4c0463ea23 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d329a86be53aee9f96a3428809db5f0 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Problem.html#a8fc1f40f2a9309e9ff02772fa2258402">Distributed_problem_matrix_distribution</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a4d329a86be53aee9f96a3428809db5f0">distributed_problem_matrix_distribution</a> ()</td></tr>
<tr class="memdesc:a4d329a86be53aee9f96a3428809db5f0 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">accesss function to the distributed matrix distribution method 1 - Automatic - the <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> distribution is employed, unless any processor has number of rows equal to 110% of N/P, in which case uniform distribution is employed. 2 - <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> - the jacobian on processor p only contains rows that correspond to equations that are on this processor. (minimises communication) 3 - Uniform - each processor holds as close to N/P matrix rows as possible. (very well load balanced)  <a href="classoomph_1_1Problem.html#a4d329a86be53aee9f96a3428809db5f0">More...</a><br /></td></tr>
<tr class="separator:a4d329a86be53aee9f96a3428809db5f0 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577bca9cc5ee9504480b372f82e924dd inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a577bca9cc5ee9504480b372f82e924dd">enable_doc_imbalance_in_parallel_assembly</a> ()</td></tr>
<tr class="memdesc:a577bca9cc5ee9504480b372f82e924dd inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable doc of load imbalance in parallel assembly of distributed problem.  <a href="classoomph_1_1Problem.html#a577bca9cc5ee9504480b372f82e924dd">More...</a><br /></td></tr>
<tr class="separator:a577bca9cc5ee9504480b372f82e924dd inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9365d2b0057089ae5551b97488a3a62a inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a9365d2b0057089ae5551b97488a3a62a">disable_doc_imbalance_in_parallel_assembly</a> ()</td></tr>
<tr class="memdesc:a9365d2b0057089ae5551b97488a3a62a inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable doc of load imbalance in parallel assembly of distributed problem.  <a href="classoomph_1_1Problem.html#a9365d2b0057089ae5551b97488a3a62a">More...</a><br /></td></tr>
<tr class="separator:a9365d2b0057089ae5551b97488a3a62a inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8da092e78c9af112580ddb667a15d97 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aa8da092e78c9af112580ddb667a15d97">elemental_assembly_time</a> ()</td></tr>
<tr class="memdesc:aa8da092e78c9af112580ddb667a15d97 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return vector of most-recent elemental assembly times (used for load balancing). Zero sized if no Jacobian has been computed since last re-assignment of equation numbers.  <a href="classoomph_1_1Problem.html#aa8da092e78c9af112580ddb667a15d97">More...</a><br /></td></tr>
<tr class="separator:aa8da092e78c9af112580ddb667a15d97 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bad546a91f9d13936be6dc0590fcd0 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a07bad546a91f9d13936be6dc0590fcd0">clear_elemental_assembly_time</a> ()</td></tr>
<tr class="memdesc:a07bad546a91f9d13936be6dc0590fcd0 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear storage of most-recent elemental assembly times (used for load balancing). Next load balancing operation will be based on the number of elements associated with a tree root.  <a href="classoomph_1_1Problem.html#a07bad546a91f9d13936be6dc0590fcd0">More...</a><br /></td></tr>
<tr class="separator:a07bad546a91f9d13936be6dc0590fcd0 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe4edae6a97460405e7f667d7d4f406 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a3fe4edae6a97460405e7f667d7d4f406">enable_problem_distributed</a> ()</td></tr>
<tr class="memdesc:a3fe4edae6a97460405e7f667d7d4f406 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable problem distributed.  <a href="classoomph_1_1Problem.html#a3fe4edae6a97460405e7f667d7d4f406">More...</a><br /></td></tr>
<tr class="separator:a3fe4edae6a97460405e7f667d7d4f406 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79752d23035158783ad19711027984dc inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a79752d23035158783ad19711027984dc">disable_problem_distributed</a> ()</td></tr>
<tr class="memdesc:a79752d23035158783ad19711027984dc inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable problem distributed.  <a href="classoomph_1_1Problem.html#a79752d23035158783ad19711027984dc">More...</a><br /></td></tr>
<tr class="separator:a79752d23035158783ad19711027984dc inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab002dc7a6faf97a1bfcd9c098a04f840 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ab002dc7a6faf97a1bfcd9c098a04f840">set_default_first_and_last_element_for_assembly</a> ()</td></tr>
<tr class="memdesc:ab002dc7a6faf97a1bfcd9c098a04f840 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default first and last elements for parallel assembly of non-distributed problem.  <a href="classoomph_1_1Problem.html#ab002dc7a6faf97a1bfcd9c098a04f840">More...</a><br /></td></tr>
<tr class="separator:ab002dc7a6faf97a1bfcd9c098a04f840 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dec80ab9a6834e10b2c2b0119e7133 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ac4dec80ab9a6834e10b2c2b0119e7133">set_first_and_last_element_for_assembly</a> (<a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;first_el_for_assembly, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;last_el_for_assembly)</td></tr>
<tr class="memdesc:ac4dec80ab9a6834e10b2c2b0119e7133 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually set first and last elements for parallel assembly of non-distributed problem.  <a href="classoomph_1_1Problem.html#ac4dec80ab9a6834e10b2c2b0119e7133">More...</a><br /></td></tr>
<tr class="separator:ac4dec80ab9a6834e10b2c2b0119e7133 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b3818d62b66e5cb52d72dcccc037fa inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a22b3818d62b66e5cb52d72dcccc037fa">get_first_and_last_element_for_assembly</a> (<a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;first_el_for_assembly, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;last_el_for_assembly) const</td></tr>
<tr class="memdesc:a22b3818d62b66e5cb52d72dcccc037fa inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get first and last elements for parallel assembly of non-distributed problem.  <a href="classoomph_1_1Problem.html#a22b3818d62b66e5cb52d72dcccc037fa">More...</a><br /></td></tr>
<tr class="separator:a22b3818d62b66e5cb52d72dcccc037fa inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6130d5c9a762cdd1569919a601620796 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a6130d5c9a762cdd1569919a601620796">actions_before_adapt</a> ()</td></tr>
<tr class="memdesc:a6130d5c9a762cdd1569919a601620796 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions that are to be performed before a mesh adaptation. These might include removing any additional elements, such as traction boundary elements before the adaptation.  <a href="classoomph_1_1Problem.html#a6130d5c9a762cdd1569919a601620796">More...</a><br /></td></tr>
<tr class="separator:a6130d5c9a762cdd1569919a601620796 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada40ec6730506c01109622c8383fe36e inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ada40ec6730506c01109622c8383fe36e">actions_after_adapt</a> ()</td></tr>
<tr class="memdesc:ada40ec6730506c01109622c8383fe36e inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions that are to be performed after a mesh adaptation.  <a href="classoomph_1_1Problem.html#ada40ec6730506c01109622c8383fe36e">More...</a><br /></td></tr>
<tr class="separator:ada40ec6730506c01109622c8383fe36e inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600bb1740edd0aa07c6d001033bf676a inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1OomphCommunicator.html">OomphCommunicator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a600bb1740edd0aa07c6d001033bf676a">communicator_pt</a> ()</td></tr>
<tr class="memdesc:a600bb1740edd0aa07c6d001033bf676a inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">access function to the oomph-lib communicator  <a href="classoomph_1_1Problem.html#a600bb1740edd0aa07c6d001033bf676a">More...</a><br /></td></tr>
<tr class="separator:a600bb1740edd0aa07c6d001033bf676a inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1875e771e99a2e8f1d344d8b880d0de inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classoomph_1_1OomphCommunicator.html">OomphCommunicator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af1875e771e99a2e8f1d344d8b880d0de">communicator_pt</a> () const</td></tr>
<tr class="memdesc:af1875e771e99a2e8f1d344d8b880d0de inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">access function to the oomph-lib communicator, const version  <a href="classoomph_1_1Problem.html#af1875e771e99a2e8f1d344d8b880d0de">More...</a><br /></td></tr>
<tr class="separator:af1875e771e99a2e8f1d344d8b880d0de inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f071f2f8be895dbe0d39d12ca59acf4 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a3f071f2f8be895dbe0d39d12ca59acf4">Problem</a> ()</td></tr>
<tr class="memdesc:a3f071f2f8be895dbe0d39d12ca59acf4 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor: Allocate space for one time stepper and set all pointers to NULL and set defaults for all parameters.  <a href="classoomph_1_1Problem.html#a3f071f2f8be895dbe0d39d12ca59acf4">More...</a><br /></td></tr>
<tr class="separator:a3f071f2f8be895dbe0d39d12ca59acf4 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f06ae01ba0bf2e827ccd9045c40183 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a32f06ae01ba0bf2e827ccd9045c40183">Problem</a> (const <a class="el" href="classoomph_1_1Problem.html">Problem</a> &amp;dummy)=delete</td></tr>
<tr class="memdesc:a32f06ae01ba0bf2e827ccd9045c40183 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broken copy constructor.  <a href="classoomph_1_1Problem.html#a32f06ae01ba0bf2e827ccd9045c40183">More...</a><br /></td></tr>
<tr class="separator:a32f06ae01ba0bf2e827ccd9045c40183 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae015f3c07e2218748b347f42abe45da1 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ae015f3c07e2218748b347f42abe45da1">operator=</a> (const <a class="el" href="classoomph_1_1Problem.html">Problem</a> &amp;)=delete</td></tr>
<tr class="memdesc:ae015f3c07e2218748b347f42abe45da1 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broken assignment operator.  <a href="classoomph_1_1Problem.html#ae015f3c07e2218748b347f42abe45da1">More...</a><br /></td></tr>
<tr class="separator:ae015f3c07e2218748b347f42abe45da1 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cd468ec03f7ede23c0dc8eea3be1cf inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ae2cd468ec03f7ede23c0dc8eea3be1cf">~Problem</a> ()</td></tr>
<tr class="memdesc:ae2cd468ec03f7ede23c0dc8eea3be1cf inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor to clean up memory.  <a href="classoomph_1_1Problem.html#ae2cd468ec03f7ede23c0dc8eea3be1cf">More...</a><br /></td></tr>
<tr class="separator:ae2cd468ec03f7ede23c0dc8eea3be1cf inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad122d70a22dc5302cfd5853d3cf3057 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aad122d70a22dc5302cfd5853d3cf3057">mesh_pt</a> ()</td></tr>
<tr class="memdesc:aad122d70a22dc5302cfd5853d3cf3057 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the global mesh.  <a href="classoomph_1_1Problem.html#aad122d70a22dc5302cfd5853d3cf3057">More...</a><br /></td></tr>
<tr class="separator:aad122d70a22dc5302cfd5853d3cf3057 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2e53542288a4140ea5b076ffa648db inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a3a2e53542288a4140ea5b076ffa648db">mesh_pt</a> () const</td></tr>
<tr class="memdesc:a3a2e53542288a4140ea5b076ffa648db inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the global mesh (const version)  <a href="classoomph_1_1Problem.html#a3a2e53542288a4140ea5b076ffa648db">More...</a><br /></td></tr>
<tr class="separator:a3a2e53542288a4140ea5b076ffa648db inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d882b768345fd916079ec184764f72 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ac9d882b768345fd916079ec184764f72">mesh_pt</a> (const unsigned &amp;imesh)</td></tr>
<tr class="memdesc:ac9d882b768345fd916079ec184764f72 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the i-th submesh. If there are no submeshes, the 0-th submesh is the global mesh itself.  <a href="classoomph_1_1Problem.html#ac9d882b768345fd916079ec184764f72">More...</a><br /></td></tr>
<tr class="separator:ac9d882b768345fd916079ec184764f72 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b503d711781552b6b56deb612816c4 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a35b503d711781552b6b56deb612816c4">mesh_pt</a> (const unsigned &amp;imesh) const</td></tr>
<tr class="memdesc:a35b503d711781552b6b56deb612816c4 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the i-th submesh (const version)  <a href="classoomph_1_1Problem.html#a35b503d711781552b6b56deb612816c4">More...</a><br /></td></tr>
<tr class="separator:a35b503d711781552b6b56deb612816c4 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc4e5a46953800933f07ae6bd67860e inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#accc4e5a46953800933f07ae6bd67860e">nsub_mesh</a> () const</td></tr>
<tr class="memdesc:accc4e5a46953800933f07ae6bd67860e inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of submeshes.  <a href="classoomph_1_1Problem.html#accc4e5a46953800933f07ae6bd67860e">More...</a><br /></td></tr>
<tr class="separator:accc4e5a46953800933f07ae6bd67860e inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd05109bc2c003c5c0686e6aa55d847 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a0cd05109bc2c003c5c0686e6aa55d847">add_sub_mesh</a> (<a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *const &amp;<a class="el" href="classoomph_1_1Problem.html#aad122d70a22dc5302cfd5853d3cf3057">mesh_pt</a>)</td></tr>
<tr class="memdesc:a0cd05109bc2c003c5c0686e6aa55d847 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a submesh to the problem and return its number, i, by which it can be accessed via mesh_pt(i).  <a href="classoomph_1_1Problem.html#a0cd05109bc2c003c5c0686e6aa55d847">More...</a><br /></td></tr>
<tr class="separator:a0cd05109bc2c003c5c0686e6aa55d847 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b2b42a03f9de7d7a4d24edcfa20179 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a42b2b42a03f9de7d7a4d24edcfa20179">flush_sub_meshes</a> ()</td></tr>
<tr class="memdesc:a42b2b42a03f9de7d7a4d24edcfa20179 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the problem's collection of sub-meshes. Must be followed by call to <a class="el" href="classoomph_1_1Problem.html#ac0a0e649f36b4a7ce992888c323d1571" title="If one of the submeshes has changed (e.g. by mesh adaptation) we need to update the global mesh....">rebuild_global_mesh()</a>.  <a href="classoomph_1_1Problem.html#a42b2b42a03f9de7d7a4d24edcfa20179">More...</a><br /></td></tr>
<tr class="separator:a42b2b42a03f9de7d7a4d24edcfa20179 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0faad6f705a6dc0ffe27229f9104ed7c inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a0faad6f705a6dc0ffe27229f9104ed7c">build_global_mesh</a> ()</td></tr>
<tr class="memdesc:a0faad6f705a6dc0ffe27229f9104ed7c inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the global mesh by combining the all the submeshes. <b>Note:</b> The nodes boundary information refers to the boundary numbers within the submesh!  <a href="classoomph_1_1Problem.html#a0faad6f705a6dc0ffe27229f9104ed7c">More...</a><br /></td></tr>
<tr class="separator:a0faad6f705a6dc0ffe27229f9104ed7c inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a0e649f36b4a7ce992888c323d1571 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ac0a0e649f36b4a7ce992888c323d1571">rebuild_global_mesh</a> ()</td></tr>
<tr class="memdesc:ac0a0e649f36b4a7ce992888c323d1571 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">If one of the submeshes has changed (e.g. by mesh adaptation) we need to update the global mesh. <b>Note:</b> The nodes boundary information refers to the boundary numbers within the submesh!  <a href="classoomph_1_1Problem.html#ac0a0e649f36b4a7ce992888c323d1571">More...</a><br /></td></tr>
<tr class="separator:ac0a0e649f36b4a7ce992888c323d1571 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220816aebf8c74c6c524088e3da4d793 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a220816aebf8c74c6c524088e3da4d793">build_mesh</a> ()</td></tr>
<tr class="memdesc:a220816aebf8c74c6c524088e3da4d793 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to build the <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a>'s base mesh; this must be supplied by the user if they wish to use the <a class="el" href="classoomph_1_1Problem.html#ad6309367fa379889012f25e3397ab425" title="Balance the load of a (possibly non-uniformly refined) problem that has already been distributed,...">load_balance()</a> functionality, which is only available to problems that have already been distributed. If the problem has multiple meshes, each mesh must be built, added as as a submesh, and a call to <a class="el" href="classoomph_1_1Problem.html#a0faad6f705a6dc0ffe27229f9104ed7c" title="Build the global mesh by combining the all the submeshes. Note: The nodes boundary information refers...">build_global_mesh()</a> must be made in this function. On return from this function all meshes must have been refined to the same level that they were in the when <a class="el" href="classoomph_1_1Problem.html#aa35e1adc0fdf14b217c7b608eb9cf20b" title="Distribute the problem and doc, using the specified partition; returns a vector which details the par...">Problem::distribute()</a> was first called.  <a href="classoomph_1_1Problem.html#a220816aebf8c74c6c524088e3da4d793">More...</a><br /></td></tr>
<tr class="separator:a220816aebf8c74c6c524088e3da4d793 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6309367fa379889012f25e3397ab425 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ad6309367fa379889012f25e3397ab425">load_balance</a> ()</td></tr>
<tr class="memdesc:ad6309367fa379889012f25e3397ab425 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the load of a (possibly non-uniformly refined) problem that has already been distributed, by re-distributing elements over processors.  <a href="classoomph_1_1Problem.html#ad6309367fa379889012f25e3397ab425">More...</a><br /></td></tr>
<tr class="separator:ad6309367fa379889012f25e3397ab425 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d78ad991995dca1f71ae83ccaa83e25 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a1d78ad991995dca1f71ae83ccaa83e25">load_balance</a> (const bool &amp;report_stats)</td></tr>
<tr class="memdesc:a1d78ad991995dca1f71ae83ccaa83e25 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the load of a (possibly non-uniformly refined) problem that has already been distributed, by re-distributing elements over processors. Produce explicit stats of load balancing process if boolean, report_stats, is set to true.  <a href="classoomph_1_1Problem.html#a1d78ad991995dca1f71ae83ccaa83e25">More...</a><br /></td></tr>
<tr class="separator:a1d78ad991995dca1f71ae83ccaa83e25 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2a02507c85322024b9859bfbd5b7bf inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#abc2a02507c85322024b9859bfbd5b7bf">load_balance</a> (<a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info, const bool &amp;report_stats)</td></tr>
<tr class="memdesc:abc2a02507c85322024b9859bfbd5b7bf inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the load of a (possibly non-uniformly refined) problem that has already been distributed, by re-distributing elements over processors. Produce explicit stats of load balancing process if boolean, report_stats, is set to true.  <a href="classoomph_1_1Problem.html#abc2a02507c85322024b9859bfbd5b7bf">More...</a><br /></td></tr>
<tr class="separator:abc2a02507c85322024b9859bfbd5b7bf inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7492ddb5663552ce8f61f1ef73c86a9d inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a7492ddb5663552ce8f61f1ef73c86a9d">load_balance</a> (<a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info, const bool &amp;report_stats, const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;input_target_domain_for_local_non_halo_element)</td></tr>
<tr class="memdesc:a7492ddb5663552ce8f61f1ef73c86a9d inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the load of a (possibly non-uniformly refined) problem that has already been distributed, by re-distributing elements over processors. Produce explicit stats of load balancing process if boolean, report_stats, is set to true and doc various bits of data (mainly for debugging) in directory specified by <a class="el" href="classoomph_1_1DocInfo.html" title="Information for documentation of results: Directory and file number to enable output in the form RESL...">DocInfo</a> object. If final input vector is non-zero-sized it provides an imposed partitioning.  <a href="classoomph_1_1Problem.html#a7492ddb5663552ce8f61f1ef73c86a9d">More...</a><br /></td></tr>
<tr class="separator:a7492ddb5663552ce8f61f1ef73c86a9d inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e641f64f436d4911c53c0f5c7ff239 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a23e641f64f436d4911c53c0f5c7ff239">set_default_partition_in_load_balance</a> ()</td></tr>
<tr class="memdesc:a23e641f64f436d4911c53c0f5c7ff239 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the use of the default partition in the load balance.  <a href="classoomph_1_1Problem.html#a23e641f64f436d4911c53c0f5c7ff239">More...</a><br /></td></tr>
<tr class="separator:a23e641f64f436d4911c53c0f5c7ff239 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1157876a05d112d523be03d9c30464de inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a1157876a05d112d523be03d9c30464de">unset_default_partition_in_load_balance</a> ()</td></tr>
<tr class="memdesc:a1157876a05d112d523be03d9c30464de inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not use the default partition in the load balance.  <a href="classoomph_1_1Problem.html#a1157876a05d112d523be03d9c30464de">More...</a><br /></td></tr>
<tr class="separator:a1157876a05d112d523be03d9c30464de inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65aef9c70c2f3b24ed4c9893a1236afe inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a65aef9c70c2f3b24ed4c9893a1236afe">refine_distributed_base_mesh</a> (<a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt;&gt;&gt; &amp;to_be_refined_on_each_root, const unsigned &amp;max_level_overall)</td></tr>
<tr class="memdesc:a65aef9c70c2f3b24ed4c9893a1236afe inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load balance helper routine: refine each new base (sub)mesh based upon the elements to be refined within each tree at each root on the current processor.  <a href="classoomph_1_1Problem.html#a65aef9c70c2f3b24ed4c9893a1236afe">More...</a><br /></td></tr>
<tr class="separator:a65aef9c70c2f3b24ed4c9893a1236afe inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689687cacc40dd351430545a7041f44c inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1LinearSolver.html">LinearSolver</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a689687cacc40dd351430545a7041f44c">linear_solver_pt</a> ()</td></tr>
<tr class="memdesc:a689687cacc40dd351430545a7041f44c inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the linear solver object.  <a href="classoomph_1_1Problem.html#a689687cacc40dd351430545a7041f44c">More...</a><br /></td></tr>
<tr class="separator:a689687cacc40dd351430545a7041f44c inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b5365e0de1212b9c07f41ae9deab5a inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1LinearSolver.html">LinearSolver</a> *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a50b5365e0de1212b9c07f41ae9deab5a">linear_solver_pt</a> () const</td></tr>
<tr class="memdesc:a50b5365e0de1212b9c07f41ae9deab5a inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the linear solver object (const version)  <a href="classoomph_1_1Problem.html#a50b5365e0de1212b9c07f41ae9deab5a">More...</a><br /></td></tr>
<tr class="separator:a50b5365e0de1212b9c07f41ae9deab5a inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93304d0c6be1022b944f21c0f4c07eab inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1LinearSolver.html">LinearSolver</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a93304d0c6be1022b944f21c0f4c07eab">mass_matrix_solver_for_explicit_timestepper_pt</a> ()</td></tr>
<tr class="memdesc:a93304d0c6be1022b944f21c0f4c07eab inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the linear solver object used for explicit time stepping.  <a href="classoomph_1_1Problem.html#a93304d0c6be1022b944f21c0f4c07eab">More...</a><br /></td></tr>
<tr class="separator:a93304d0c6be1022b944f21c0f4c07eab inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ffcfbf305940a05452d950df7a11c3 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1LinearSolver.html">LinearSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a10ffcfbf305940a05452d950df7a11c3">mass_matrix_solver_for_explicit_timestepper_pt</a> () const</td></tr>
<tr class="memdesc:a10ffcfbf305940a05452d950df7a11c3 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the linear solver object used for explicit time stepping (const version).  <a href="classoomph_1_1Problem.html#a10ffcfbf305940a05452d950df7a11c3">More...</a><br /></td></tr>
<tr class="separator:a10ffcfbf305940a05452d950df7a11c3 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00efa0059958df35858503e77111c362 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1EigenSolver.html">EigenSolver</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a00efa0059958df35858503e77111c362">eigen_solver_pt</a> ()</td></tr>
<tr class="memdesc:a00efa0059958df35858503e77111c362 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the eigen solver object.  <a href="classoomph_1_1Problem.html#a00efa0059958df35858503e77111c362">More...</a><br /></td></tr>
<tr class="separator:a00efa0059958df35858503e77111c362 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d44adcbf581d43154be19d127b6183 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1EigenSolver.html">EigenSolver</a> *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a14d44adcbf581d43154be19d127b6183">eigen_solver_pt</a> () const</td></tr>
<tr class="memdesc:a14d44adcbf581d43154be19d127b6183 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the eigen solver object (const version)  <a href="classoomph_1_1Problem.html#a14d44adcbf581d43154be19d127b6183">More...</a><br /></td></tr>
<tr class="separator:a14d44adcbf581d43154be19d127b6183 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46894b13c582f322082dc471a2485980 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Time.html">Time</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a46894b13c582f322082dc471a2485980">time_pt</a> ()</td></tr>
<tr class="memdesc:a46894b13c582f322082dc471a2485980 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the global time object.  <a href="classoomph_1_1Problem.html#a46894b13c582f322082dc471a2485980">More...</a><br /></td></tr>
<tr class="separator:a46894b13c582f322082dc471a2485980 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86b09eac493cfa9fcbe57734985ba19 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Time.html">Time</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aa86b09eac493cfa9fcbe57734985ba19">time_pt</a> () const</td></tr>
<tr class="memdesc:aa86b09eac493cfa9fcbe57734985ba19 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the global time object (const version).  <a href="classoomph_1_1Problem.html#aa86b09eac493cfa9fcbe57734985ba19">More...</a><br /></td></tr>
<tr class="separator:aa86b09eac493cfa9fcbe57734985ba19 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8c357349d20a28af70b2b7ea7f488d inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#acd8c357349d20a28af70b2b7ea7f488d">time</a> ()</td></tr>
<tr class="memdesc:acd8c357349d20a28af70b2b7ea7f488d inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current value of continuous time.  <a href="classoomph_1_1Problem.html#acd8c357349d20a28af70b2b7ea7f488d">More...</a><br /></td></tr>
<tr class="separator:acd8c357349d20a28af70b2b7ea7f488d inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925acb2e840deb4edc6305da8fced0e3 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a925acb2e840deb4edc6305da8fced0e3">time</a> () const</td></tr>
<tr class="memdesc:a925acb2e840deb4edc6305da8fced0e3 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current value of continuous time (const version)  <a href="classoomph_1_1Problem.html#a925acb2e840deb4edc6305da8fced0e3">More...</a><br /></td></tr>
<tr class="separator:a925acb2e840deb4edc6305da8fced0e3 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77413dc70a25d271f582ad3c3d7bf65 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1TimeStepper.html">TimeStepper</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ad77413dc70a25d271f582ad3c3d7bf65">time_stepper_pt</a> ()</td></tr>
<tr class="memdesc:ad77413dc70a25d271f582ad3c3d7bf65 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for the pointer to the first (presumably only) timestepper.  <a href="classoomph_1_1Problem.html#ad77413dc70a25d271f582ad3c3d7bf65">More...</a><br /></td></tr>
<tr class="separator:ad77413dc70a25d271f582ad3c3d7bf65 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f952a57b5238978250849c04e2fcbdb inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classoomph_1_1TimeStepper.html">TimeStepper</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a3f952a57b5238978250849c04e2fcbdb">time_stepper_pt</a> () const</td></tr>
<tr class="memdesc:a3f952a57b5238978250849c04e2fcbdb inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for the pointer to the first (presumably only) timestepper.  <a href="classoomph_1_1Problem.html#a3f952a57b5238978250849c04e2fcbdb">More...</a><br /></td></tr>
<tr class="separator:a3f952a57b5238978250849c04e2fcbdb inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cda2a0a02815a3de446723a2334293 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1TimeStepper.html">TimeStepper</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a76cda2a0a02815a3de446723a2334293">time_stepper_pt</a> (const unsigned &amp;<a class="el" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>)</td></tr>
<tr class="memdesc:a76cda2a0a02815a3de446723a2334293 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the i-th timestepper.  <a href="classoomph_1_1Problem.html#a76cda2a0a02815a3de446723a2334293">More...</a><br /></td></tr>
<tr class="separator:a76cda2a0a02815a3de446723a2334293 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac332634783a803c1c21bf5c520af280f inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1ExplicitTimeStepper.html">ExplicitTimeStepper</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ac332634783a803c1c21bf5c520af280f">explicit_time_stepper_pt</a> ()</td></tr>
<tr class="memdesc:ac332634783a803c1c21bf5c520af280f inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the explicit timestepper.  <a href="classoomph_1_1Problem.html#ac332634783a803c1c21bf5c520af280f">More...</a><br /></td></tr>
<tr class="separator:ac332634783a803c1c21bf5c520af280f inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be66e9917b39eaea90b91389f5a72fb inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a7be66e9917b39eaea90b91389f5a72fb">set_timestepper_for_all_data</a> (<a class="el" href="classoomph_1_1TimeStepper.html">TimeStepper</a> *const &amp;<a class="el" href="classoomph_1_1Problem.html#ad77413dc70a25d271f582ad3c3d7bf65">time_stepper_pt</a>, const bool &amp;preserve_existing_data=false)</td></tr>
<tr class="memdesc:a7be66e9917b39eaea90b91389f5a72fb inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all problem data to have the same timestepper (timestepper_pt) Return the new number of dofs in the problem.  <a href="classoomph_1_1Problem.html#a7be66e9917b39eaea90b91389f5a72fb">More...</a><br /></td></tr>
<tr class="separator:a7be66e9917b39eaea90b91389f5a72fb inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab27bdd1968e57cb3dffe78c1d63f762 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aab27bdd1968e57cb3dffe78c1d63f762">shift_time_values</a> ()</td></tr>
<tr class="memdesc:aab27bdd1968e57cb3dffe78c1d63f762 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift all values along to prepare for next timestep.  <a href="classoomph_1_1Problem.html#aab27bdd1968e57cb3dffe78c1d63f762">More...</a><br /></td></tr>
<tr class="separator:aab27bdd1968e57cb3dffe78c1d63f762 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381c30a8daede5c95bdda7e2efa24f19 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1AssemblyHandler.html">AssemblyHandler</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a381c30a8daede5c95bdda7e2efa24f19">assembly_handler_pt</a> ()</td></tr>
<tr class="memdesc:a381c30a8daede5c95bdda7e2efa24f19 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the assembly handler object.  <a href="classoomph_1_1Problem.html#a381c30a8daede5c95bdda7e2efa24f19">More...</a><br /></td></tr>
<tr class="separator:a381c30a8daede5c95bdda7e2efa24f19 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48905dc6c9a8811969407939b3e4ccb6 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1AssemblyHandler.html">AssemblyHandler</a> *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a48905dc6c9a8811969407939b3e4ccb6">assembly_handler_pt</a> () const</td></tr>
<tr class="memdesc:a48905dc6c9a8811969407939b3e4ccb6 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the assembly handler object (const version)  <a href="classoomph_1_1Problem.html#a48905dc6c9a8811969407939b3e4ccb6">More...</a><br /></td></tr>
<tr class="separator:a48905dc6c9a8811969407939b3e4ccb6 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffc8921bf61edac68ed017bcdc1d792 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#adffc8921bf61edac68ed017bcdc1d792">minimum_dt</a> ()</td></tr>
<tr class="memdesc:adffc8921bf61edac68ed017bcdc1d792 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function to min timestep in adaptive timestepping.  <a href="classoomph_1_1Problem.html#adffc8921bf61edac68ed017bcdc1d792">More...</a><br /></td></tr>
<tr class="separator:adffc8921bf61edac68ed017bcdc1d792 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5355154d4991ec634e74d4817176f5f inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ac5355154d4991ec634e74d4817176f5f">maximum_dt</a> ()</td></tr>
<tr class="memdesc:ac5355154d4991ec634e74d4817176f5f inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function to max timestep in adaptive timestepping.  <a href="classoomph_1_1Problem.html#ac5355154d4991ec634e74d4817176f5f">More...</a><br /></td></tr>
<tr class="separator:ac5355154d4991ec634e74d4817176f5f inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b68978063f7eb0e317cc90c883e8601 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a6b68978063f7eb0e317cc90c883e8601">target_error_safety_factor</a> ()</td></tr>
<tr class="memdesc:a6b68978063f7eb0e317cc90c883e8601 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function to the safety factor in adaptive timestepping.  <a href="classoomph_1_1Problem.html#a6b68978063f7eb0e317cc90c883e8601">More...</a><br /></td></tr>
<tr class="separator:a6b68978063f7eb0e317cc90c883e8601 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30b2e89f61a327ffb1be4ff30bb868f inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aa30b2e89f61a327ffb1be4ff30bb868f">max_newton_iterations</a> ()</td></tr>
<tr class="memdesc:aa30b2e89f61a327ffb1be4ff30bb868f inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function to max Newton iterations before giving up.  <a href="classoomph_1_1Problem.html#aa30b2e89f61a327ffb1be4ff30bb868f">More...</a><br /></td></tr>
<tr class="separator:aa30b2e89f61a327ffb1be4ff30bb868f inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92acc3c193a38f321fc318fafd142f7a inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a92acc3c193a38f321fc318fafd142f7a">problem_is_nonlinear</a> (const bool &amp;prob_lin)</td></tr>
<tr class="memdesc:a92acc3c193a38f321fc318fafd142f7a inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function to Problem_is_nonlinear.  <a href="classoomph_1_1Problem.html#a92acc3c193a38f321fc318fafd142f7a">More...</a><br /></td></tr>
<tr class="separator:a92acc3c193a38f321fc318fafd142f7a inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad78241135f621df36bc1b9634845ac inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a2ad78241135f621df36bc1b9634845ac">max_residuals</a> ()</td></tr>
<tr class="memdesc:a2ad78241135f621df36bc1b9634845ac inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function to max residuals in Newton iterations before giving up.  <a href="classoomph_1_1Problem.html#a2ad78241135f621df36bc1b9634845ac">More...</a><br /></td></tr>
<tr class="separator:a2ad78241135f621df36bc1b9634845ac inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a42b89a67e0770c68493b9569bffe16 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a7a42b89a67e0770c68493b9569bffe16">time_adaptive_newton_crash_on_solve_fail</a> ()</td></tr>
<tr class="memdesc:a7a42b89a67e0770c68493b9569bffe16 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for Time_adaptive_newton_crash_on_solve_fail.  <a href="classoomph_1_1Problem.html#a7a42b89a67e0770c68493b9569bffe16">More...</a><br /></td></tr>
<tr class="separator:a7a42b89a67e0770c68493b9569bffe16 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43a98d2303f2bce10d0887dc0b2eac5 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aa43a98d2303f2bce10d0887dc0b2eac5">newton_solver_tolerance</a> ()</td></tr>
<tr class="memdesc:aa43a98d2303f2bce10d0887dc0b2eac5 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function to tolererance of the Newton solver, i.e. the maximum value of the residuals that will be accepted.  <a href="classoomph_1_1Problem.html#aa43a98d2303f2bce10d0887dc0b2eac5">More...</a><br /></td></tr>
<tr class="separator:aa43a98d2303f2bce10d0887dc0b2eac5 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8856eae2daa9cea05e99bfcd4ef340a4 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a8856eae2daa9cea05e99bfcd4ef340a4">add_time_stepper_pt</a> (<a class="el" href="classoomph_1_1TimeStepper.html">TimeStepper</a> *const &amp;<a class="el" href="classoomph_1_1Problem.html#ad77413dc70a25d271f582ad3c3d7bf65">time_stepper_pt</a>)</td></tr>
<tr class="memdesc:a8856eae2daa9cea05e99bfcd4ef340a4 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a timestepper to the problem. The function will automatically create or resize the <a class="el" href="classoomph_1_1Time.html" title="Class to keep track of discrete/continous time. It is essential to have a single Time object when usi...">Time</a> object so that it contains the appropriate number of levels of storage.  <a href="classoomph_1_1Problem.html#a8856eae2daa9cea05e99bfcd4ef340a4">More...</a><br /></td></tr>
<tr class="separator:a8856eae2daa9cea05e99bfcd4ef340a4 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf44478e6f6abe95063b7bb2dd530a0 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a4cf44478e6f6abe95063b7bb2dd530a0">set_explicit_time_stepper_pt</a> (<a class="el" href="classoomph_1_1ExplicitTimeStepper.html">ExplicitTimeStepper</a> *const &amp;<a class="el" href="classoomph_1_1Problem.html#ac332634783a803c1c21bf5c520af280f">explicit_time_stepper_pt</a>)</td></tr>
<tr class="memdesc:a4cf44478e6f6abe95063b7bb2dd530a0 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the explicit timestepper for the problem. The function will automatically create or resize the <a class="el" href="classoomph_1_1Time.html" title="Class to keep track of discrete/continous time. It is essential to have a single Time object when usi...">Time</a> object so that it contains the appropriate number of levels of storage.  <a href="classoomph_1_1Problem.html#a4cf44478e6f6abe95063b7bb2dd530a0">More...</a><br /></td></tr>
<tr class="separator:a4cf44478e6f6abe95063b7bb2dd530a0 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342b9bd9c4bc142f514907ee1d23d613 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a342b9bd9c4bc142f514907ee1d23d613">initialise_dt</a> (const double &amp;dt)</td></tr>
<tr class="memdesc:a342b9bd9c4bc142f514907ee1d23d613 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all timesteps to the same value, dt, and assign weights for all timesteppers in the problem.  <a href="classoomph_1_1Problem.html#a342b9bd9c4bc142f514907ee1d23d613">More...</a><br /></td></tr>
<tr class="separator:a342b9bd9c4bc142f514907ee1d23d613 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48137f1c7b297de56078f6bc0c83b675 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a48137f1c7b297de56078f6bc0c83b675">initialise_dt</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;dt)</td></tr>
<tr class="memdesc:a48137f1c7b297de56078f6bc0c83b675 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the timesteps to be equal to the values passed in a vector and assign weights for all timesteppers in the problem.  <a href="classoomph_1_1Problem.html#a48137f1c7b297de56078f6bc0c83b675">More...</a><br /></td></tr>
<tr class="separator:a48137f1c7b297de56078f6bc0c83b675 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae508b2056d532cb8b6eb0dd5c16b9325 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Data.html">Data</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ae508b2056d532cb8b6eb0dd5c16b9325">global_data_pt</a> (const unsigned &amp;<a class="el" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>)</td></tr>
<tr class="memdesc:ae508b2056d532cb8b6eb0dd5c16b9325 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the the i-th global data object.  <a href="classoomph_1_1Problem.html#ae508b2056d532cb8b6eb0dd5c16b9325">More...</a><br /></td></tr>
<tr class="separator:ae508b2056d532cb8b6eb0dd5c16b9325 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0c24728351d390d4f0a86d07bd8678 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a6f0c24728351d390d4f0a86d07bd8678">add_global_data</a> (<a class="el" href="classoomph_1_1Data.html">Data</a> *const &amp;<a class="el" href="classoomph_1_1Problem.html#ae508b2056d532cb8b6eb0dd5c16b9325">global_data_pt</a>)</td></tr>
<tr class="memdesc:a6f0c24728351d390d4f0a86d07bd8678 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <a class="el" href="classoomph_1_1Data.html" title="A class that represents a collection of data; each Data object may contain many different individual ...">Data</a> to the <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a>'s global data &ndash; the <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> will perform equation numbering etc. for such <a class="el" href="classoomph_1_1Data.html" title="A class that represents a collection of data; each Data object may contain many different individual ...">Data</a>.  <a href="classoomph_1_1Problem.html#a6f0c24728351d390d4f0a86d07bd8678">More...</a><br /></td></tr>
<tr class="separator:a6f0c24728351d390d4f0a86d07bd8678 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8df5552c706bd949b29f5601f8c941e inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aa8df5552c706bd949b29f5601f8c941e">flush_global_data</a> ()</td></tr>
<tr class="memdesc:aa8df5552c706bd949b29f5601f8c941e inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a>'s global data &ndash; resizes container to zero. <a class="el" href="classoomph_1_1Data.html" title="A class that represents a collection of data; each Data object may contain many different individual ...">Data</a> objects are not deleted!  <a href="classoomph_1_1Problem.html#aa8df5552c706bd949b29f5601f8c941e">More...</a><br /></td></tr>
<tr class="separator:aa8df5552c706bd949b29f5601f8c941e inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af22a1cfead13bcad14c1b78d1cf273 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a9af22a1cfead13bcad14c1b78d1cf273">create_new_linear_algebra_distribution</a> (<a class="el" href="classoomph_1_1LinearAlgebraDistribution.html">LinearAlgebraDistribution</a> *&amp;dist_pt)</td></tr>
<tr class="memdesc:a9af22a1cfead13bcad14c1b78d1cf273 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get new linear algebra distribution (you're in charge of deleting it!)  <a href="classoomph_1_1Problem.html#a9af22a1cfead13bcad14c1b78d1cf273">More...</a><br /></td></tr>
<tr class="separator:a9af22a1cfead13bcad14c1b78d1cf273 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a5a4886c4213422179fe8346336a4e inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1LinearAlgebraDistribution.html">LinearAlgebraDistribution</a> *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a17a5a4886c4213422179fe8346336a4e">dof_distribution_pt</a> () const</td></tr>
<tr class="memdesc:a17a5a4886c4213422179fe8346336a4e inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pointer to the dof distribution (read-only)  <a href="classoomph_1_1Problem.html#a17a5a4886c4213422179fe8346336a4e">More...</a><br /></td></tr>
<tr class="separator:a17a5a4886c4213422179fe8346336a4e inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218d4dfff74bc14f3f5dc8416236e01d inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a218d4dfff74bc14f3f5dc8416236e01d">ndof</a> () const</td></tr>
<tr class="memdesc:a218d4dfff74bc14f3f5dc8416236e01d inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of dofs.  <a href="classoomph_1_1Problem.html#a218d4dfff74bc14f3f5dc8416236e01d">More...</a><br /></td></tr>
<tr class="separator:a218d4dfff74bc14f3f5dc8416236e01d inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3cdf55009c3bff21d2b7d3706d522a inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ace3cdf55009c3bff21d2b7d3706d522a">ntime_stepper</a> () const</td></tr>
<tr class="memdesc:ace3cdf55009c3bff21d2b7d3706d522a inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of time steppers.  <a href="classoomph_1_1Problem.html#ace3cdf55009c3bff21d2b7d3706d522a">More...</a><br /></td></tr>
<tr class="separator:ace3cdf55009c3bff21d2b7d3706d522a inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a9b6861928cf9115110b5bfc7d11a7 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a60a9b6861928cf9115110b5bfc7d11a7">nglobal_data</a> () const</td></tr>
<tr class="memdesc:a60a9b6861928cf9115110b5bfc7d11a7 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of global data values.  <a href="classoomph_1_1Problem.html#a60a9b6861928cf9115110b5bfc7d11a7">More...</a><br /></td></tr>
<tr class="separator:a60a9b6861928cf9115110b5bfc7d11a7 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb76c0b94aa3cc5470ce862d70a8017 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#acdb76c0b94aa3cc5470ce862d70a8017">self_test</a> ()</td></tr>
<tr class="memdesc:acdb76c0b94aa3cc5470ce862d70a8017 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-test: Check meshes and global data. Return 0 for OK.  <a href="classoomph_1_1Problem.html#acdb76c0b94aa3cc5470ce862d70a8017">More...</a><br /></td></tr>
<tr class="separator:acdb76c0b94aa3cc5470ce862d70a8017 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ba79405993ec52e3017d6ff3a42c8c inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a31ba79405993ec52e3017d6ff3a42c8c">enable_store_local_dof_pt_in_elements</a> ()</td></tr>
<tr class="memdesc:a31ba79405993ec52e3017d6ff3a42c8c inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insist that local dof pointers are set up in each element when equation numbering takes place.  <a href="classoomph_1_1Problem.html#a31ba79405993ec52e3017d6ff3a42c8c">More...</a><br /></td></tr>
<tr class="separator:a31ba79405993ec52e3017d6ff3a42c8c inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23468bc4101d3038e6b537b6fc87aa6 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ac23468bc4101d3038e6b537b6fc87aa6">disable_store_local_dof_pt_in_elements</a> ()</td></tr>
<tr class="memdesc:ac23468bc4101d3038e6b537b6fc87aa6 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insist that local dof pointers are NOT set up in each element when equation numbering takes place (the default)  <a href="classoomph_1_1Problem.html#ac23468bc4101d3038e6b537b6fc87aa6">More...</a><br /></td></tr>
<tr class="separator:ac23468bc4101d3038e6b537b6fc87aa6 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df501c6aed60c4938861df776b10119 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a0df501c6aed60c4938861df776b10119">assign_eqn_numbers</a> (const bool &amp;assign_local_eqn_numbers=true)</td></tr>
<tr class="memdesc:a0df501c6aed60c4938861df776b10119 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign all equation numbers for problem: Deals with global data (= data that isn't attached to any elements) and then does the equation numbering for the elements. Virtual so it can be overloaded in MPI problems. Bool argument can be set to false to ignore assigning local equation numbers (found to be necessary in the parallel implementation of locate_zeta between multiple meshes).  <a href="classoomph_1_1Problem.html#a0df501c6aed60c4938861df776b10119">More...</a><br /></td></tr>
<tr class="separator:a0df501c6aed60c4938861df776b10119 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0563ae60b5c372087398fc3c45af757d inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a0563ae60b5c372087398fc3c45af757d">describe_dofs</a> (std::ostream &amp;out= *(oomph_info.stream_pt())) const</td></tr>
<tr class="memdesc:a0563ae60b5c372087398fc3c45af757d inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to describe the dofs in terms of the global equation number, i.e. what type of value (nodal value of a <a class="el" href="classoomph_1_1Node.html" title="Nodes are derived from Data, but, in addition, have a definite (Eulerian) position in a space of a gi...">Node</a>; value in a <a class="el" href="classoomph_1_1Data.html" title="A class that represents a collection of data; each Data object may contain many different individual ...">Data</a> object; value of internal <a class="el" href="classoomph_1_1Data.html" title="A class that represents a collection of data; each Data object may contain many different individual ...">Data</a> in an element; etc) is the unknown with a certain global equation number. Output stream defaults to oomph_info.  <a href="classoomph_1_1Problem.html#a0563ae60b5c372087398fc3c45af757d">More...</a><br /></td></tr>
<tr class="separator:a0563ae60b5c372087398fc3c45af757d inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fbd755b3ce6b86fa0f1b1f29bd08f0 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af4fbd755b3ce6b86fa0f1b1f29bd08f0">enable_discontinuous_formulation</a> ()</td></tr>
<tr class="memdesc:af4fbd755b3ce6b86fa0f1b1f29bd08f0 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that the problem involves discontinuous elements This allows for a more efficiently assembly and inversion of the mass matrix.  <a href="classoomph_1_1Problem.html#af4fbd755b3ce6b86fa0f1b1f29bd08f0">More...</a><br /></td></tr>
<tr class="separator:af4fbd755b3ce6b86fa0f1b1f29bd08f0 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa64d728ceff0dd772bbbc8f2adcddfb inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#afa64d728ceff0dd772bbbc8f2adcddfb">disable_discontinuous_formulation</a> ()</td></tr>
<tr class="memdesc:afa64d728ceff0dd772bbbc8f2adcddfb inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the use of a discontinuous-element formulation. Note that the methods will all still work even if the elements are discontinuous, we will just be assembling a larger system matrix than necessary.  <a href="classoomph_1_1Problem.html#afa64d728ceff0dd772bbbc8f2adcddfb">More...</a><br /></td></tr>
<tr class="separator:afa64d728ceff0dd772bbbc8f2adcddfb inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ef66732d76053dba15001818c0605c inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ae2ef66732d76053dba15001818c0605c">get_dofs</a> (<a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;dofs) const</td></tr>
<tr class="memdesc:ae2ef66732d76053dba15001818c0605c inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of dofs, i.e. a vector containing the current values of all unknowns.  <a href="classoomph_1_1Problem.html#ae2ef66732d76053dba15001818c0605c">More...</a><br /></td></tr>
<tr class="separator:ae2ef66732d76053dba15001818c0605c inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb56c404b0dd6df75bcadab797d9a24e inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#abb56c404b0dd6df75bcadab797d9a24e">get_dofs</a> (const unsigned &amp;<a class="el" href="cfortran_8h.html#af6f0bd3dc13317f895c91323c25c2b8f">t</a>, <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;dofs) const</td></tr>
<tr class="memdesc:abb56c404b0dd6df75bcadab797d9a24e inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return vector of the t'th history value of all dofs.  <a href="classoomph_1_1Problem.html#abb56c404b0dd6df75bcadab797d9a24e">More...</a><br /></td></tr>
<tr class="separator:abb56c404b0dd6df75bcadab797d9a24e inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51480d18550c107c9f13629102f6b08 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ab51480d18550c107c9f13629102f6b08">set_dofs</a> (const <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;dofs)</td></tr>
<tr class="memdesc:ab51480d18550c107c9f13629102f6b08 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the values of the dofs.  <a href="classoomph_1_1Problem.html#ab51480d18550c107c9f13629102f6b08">More...</a><br /></td></tr>
<tr class="separator:ab51480d18550c107c9f13629102f6b08 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d7dbbf49388e6383e3b93e50351e89 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a62d7dbbf49388e6383e3b93e50351e89">set_dofs</a> (const unsigned &amp;<a class="el" href="cfortran_8h.html#af6f0bd3dc13317f895c91323c25c2b8f">t</a>, <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;dofs)</td></tr>
<tr class="memdesc:a62d7dbbf49388e6383e3b93e50351e89 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the history values of the dofs.  <a href="classoomph_1_1Problem.html#a62d7dbbf49388e6383e3b93e50351e89">More...</a><br /></td></tr>
<tr class="separator:a62d7dbbf49388e6383e3b93e50351e89 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b01ea8bfa914f1c9f40f9a2a7aa8ad5 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a4b01ea8bfa914f1c9f40f9a2a7aa8ad5">set_dofs</a> (const unsigned &amp;<a class="el" href="cfortran_8h.html#af6f0bd3dc13317f895c91323c25c2b8f">t</a>, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double * &gt; &amp;<a class="el" href="classoomph_1_1Problem.html#a02f480ec17e0b9b03c892be5ed0c64d1">dof_pt</a>)</td></tr>
<tr class="memdesc:a4b01ea8bfa914f1c9f40f9a2a7aa8ad5 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set history values of dofs from the type of vector stored in problem::Dof_pt.  <a href="classoomph_1_1Problem.html#a4b01ea8bfa914f1c9f40f9a2a7aa8ad5">More...</a><br /></td></tr>
<tr class="separator:a4b01ea8bfa914f1c9f40f9a2a7aa8ad5 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352210408b3eed3e7a834b8b9a33a99a inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a352210408b3eed3e7a834b8b9a33a99a">add_to_dofs</a> (const double &amp;lambda, const <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;increment_dofs)</td></tr>
<tr class="memdesc:a352210408b3eed3e7a834b8b9a33a99a inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add lambda x incremenet_dofs[l] to the l-th dof.  <a href="classoomph_1_1Problem.html#a352210408b3eed3e7a834b8b9a33a99a">More...</a><br /></td></tr>
<tr class="separator:a352210408b3eed3e7a834b8b9a33a99a inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491354401f780ccc114ceb76f5cacef0 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a491354401f780ccc114ceb76f5cacef0">global_dof_pt</a> (const unsigned &amp;<a class="el" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>)</td></tr>
<tr class="memdesc:a491354401f780ccc114ceb76f5cacef0 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the dof, indexed by global equation number which may be haloed or stored locally. If it is haloed, a local copy must have been requested on this processor in the Halo_scheme_pt.  <a href="classoomph_1_1Problem.html#a491354401f780ccc114ceb76f5cacef0">More...</a><br /></td></tr>
<tr class="separator:a491354401f780ccc114ceb76f5cacef0 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d71439b100fb5b66b94d1d69130f7c inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a74d71439b100fb5b66b94d1d69130f7c">dof</a> (const unsigned &amp;<a class="el" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>)</td></tr>
<tr class="memdesc:a74d71439b100fb5b66b94d1d69130f7c inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">i-th dof in the problem  <a href="classoomph_1_1Problem.html#a74d71439b100fb5b66b94d1d69130f7c">More...</a><br /></td></tr>
<tr class="separator:a74d71439b100fb5b66b94d1d69130f7c inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200cbd03828632d448c3525e9a921f27 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a200cbd03828632d448c3525e9a921f27">dof</a> (const unsigned &amp;<a class="el" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>) const</td></tr>
<tr class="memdesc:a200cbd03828632d448c3525e9a921f27 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">i-th dof in the problem (const version)  <a href="classoomph_1_1Problem.html#a200cbd03828632d448c3525e9a921f27">More...</a><br /></td></tr>
<tr class="separator:a200cbd03828632d448c3525e9a921f27 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f480ec17e0b9b03c892be5ed0c64d1 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a02f480ec17e0b9b03c892be5ed0c64d1">dof_pt</a> (const unsigned &amp;<a class="el" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>)</td></tr>
<tr class="memdesc:a02f480ec17e0b9b03c892be5ed0c64d1 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to i-th dof in the problem.  <a href="classoomph_1_1Problem.html#a02f480ec17e0b9b03c892be5ed0c64d1">More...</a><br /></td></tr>
<tr class="separator:a02f480ec17e0b9b03c892be5ed0c64d1 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf51914cb75a640f82b269493311c187 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#acf51914cb75a640f82b269493311c187">dof_pt</a> (const unsigned &amp;<a class="el" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>) const</td></tr>
<tr class="memdesc:acf51914cb75a640f82b269493311c187 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to i-th dof in the problem (const version)  <a href="classoomph_1_1Problem.html#acf51914cb75a640f82b269493311c187">More...</a><br /></td></tr>
<tr class="separator:acf51914cb75a640f82b269493311c187 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7cc317f4900e076dec400ce2493c19 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a8d7cc317f4900e076dec400ce2493c19">get_inverse_mass_matrix_times_residuals</a> (<a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;Mres)</td></tr>
<tr class="memdesc:a8d7cc317f4900e076dec400ce2493c19 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the residual vector multiplied by the inverse mass matrix Virtual so that it can be overloaded for mpi problems.  <a href="classoomph_1_1Problem.html#a8d7cc317f4900e076dec400ce2493c19">More...</a><br /></td></tr>
<tr class="separator:a8d7cc317f4900e076dec400ce2493c19 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d456362f4408556e879871ae34e57f1 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a2d456362f4408556e879871ae34e57f1">get_dvaluesdt</a> (<a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;f)</td></tr>
<tr class="memdesc:a2d456362f4408556e879871ae34e57f1 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time derivative of all values (using get_inverse_mass_matrix_times_residuals(..) with all time steppers set to steady) e.g. for use in explicit time steps. The approach used is slighty hacky, beware if you have a residual which is non-linear or implicit in the derivative or if you have overloaded get_jacobian(...).  <a href="classoomph_1_1Problem.html#a2d456362f4408556e879871ae34e57f1">More...</a><br /></td></tr>
<tr class="separator:a2d456362f4408556e879871ae34e57f1 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7300386d91390e3e5be993aca7459498 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a7300386d91390e3e5be993aca7459498">get_residuals</a> (<a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;residuals)</td></tr>
<tr class="memdesc:a7300386d91390e3e5be993aca7459498 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fully-assembled residuals <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> for the problem: Virtual so it can be overloaded in for mpi problems.  <a href="classoomph_1_1Problem.html#a7300386d91390e3e5be993aca7459498">More...</a><br /></td></tr>
<tr class="separator:a7300386d91390e3e5be993aca7459498 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba83bbea19db3a530539f3e9f88a7e4 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a4ba83bbea19db3a530539f3e9f88a7e4">get_jacobian</a> (<a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;residuals, <a class="el" href="classoomph_1_1DenseDoubleMatrix.html">DenseDoubleMatrix</a> &amp;jacobian)</td></tr>
<tr class="memdesc:a4ba83bbea19db3a530539f3e9f88a7e4 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fully-assembled Jacobian and residuals for the problem Interface for the case when the Jacobian matrix is dense. This is virtual so, if we feel like it (e.g. for testing iterative solvers with specific test matrices, we can bypass the default assembly procedure for the Jacobian and the residual vector.  <a href="classoomph_1_1Problem.html#a4ba83bbea19db3a530539f3e9f88a7e4">More...</a><br /></td></tr>
<tr class="separator:a4ba83bbea19db3a530539f3e9f88a7e4 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1369827c6970abfd41deae4ef185822c inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a1369827c6970abfd41deae4ef185822c">get_jacobian</a> (<a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;residuals, <a class="el" href="classoomph_1_1CRDoubleMatrix.html">CRDoubleMatrix</a> &amp;jacobian)</td></tr>
<tr class="memdesc:a1369827c6970abfd41deae4ef185822c inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fully-assembled Jacobian and residuals for the problem. Interface for the case when the Jacobian is in row-compressed storage format. This is virtual so, if we feel like it (e.g. for testing iterative solvers with specific test matrices), we can bypass the default assembly procedure for the Jacobian and the residual vector.  <a href="classoomph_1_1Problem.html#a1369827c6970abfd41deae4ef185822c">More...</a><br /></td></tr>
<tr class="separator:a1369827c6970abfd41deae4ef185822c inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6c6d71f95d96943a1a8487b6131e89 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a9e6c6d71f95d96943a1a8487b6131e89">get_jacobian</a> (<a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;residuals, <a class="el" href="classoomph_1_1CCDoubleMatrix.html">CCDoubleMatrix</a> &amp;jacobian)</td></tr>
<tr class="memdesc:a9e6c6d71f95d96943a1a8487b6131e89 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fully-assembled Jacobian and residuals for the problem. Interface for the case when the Jacobian is in column-compressed storage format. This is virtual so, if we feel like it (e.g. for testing iterative solvers with specific test matrices), we can bypass the default assembly procedure for the Jacobian and the residual vector.  <a href="classoomph_1_1Problem.html#a9e6c6d71f95d96943a1a8487b6131e89">More...</a><br /></td></tr>
<tr class="separator:a9e6c6d71f95d96943a1a8487b6131e89 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db16f9bcac7af964d0fecc8b6a5ea63 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a0db16f9bcac7af964d0fecc8b6a5ea63">get_jacobian</a> (<a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;residuals, <a class="el" href="classoomph_1_1SumOfMatrices.html">SumOfMatrices</a> &amp;jacobian)</td></tr>
<tr class="memdesc:a0db16f9bcac7af964d0fecc8b6a5ea63 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy virtual function that must be overloaded by the problem to specify which matrices should be summed to give the final Jacobian.  <a href="classoomph_1_1Problem.html#a0db16f9bcac7af964d0fecc8b6a5ea63">More...</a><br /></td></tr>
<tr class="separator:a0db16f9bcac7af964d0fecc8b6a5ea63 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f6540dc7228b21f5bc07c0477dfbe7 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a74f6540dc7228b21f5bc07c0477dfbe7">get_fd_jacobian</a> (<a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;residuals, <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt; &amp;jacobian)</td></tr>
<tr class="memdesc:a74f6540dc7228b21f5bc07c0477dfbe7 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fully-assembled Jacobian and residuals, generated by finite differences.  <a href="classoomph_1_1Problem.html#a74f6540dc7228b21f5bc07c0477dfbe7">More...</a><br /></td></tr>
<tr class="separator:a74f6540dc7228b21f5bc07c0477dfbe7 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d959a47ef6a8d50b394a6761dfab5a inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af4d959a47ef6a8d50b394a6761dfab5a">get_derivative_wrt_global_parameter</a> (double *const &amp;parameter_pt, <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;result)</td></tr>
<tr class="memdesc:af4d959a47ef6a8d50b394a6761dfab5a inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the derivative of the entire residuals vector wrt a global parameter, used in continuation problems.  <a href="classoomph_1_1Problem.html#af4d959a47ef6a8d50b394a6761dfab5a">More...</a><br /></td></tr>
<tr class="separator:af4d959a47ef6a8d50b394a6761dfab5a inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65cbe00a72cfc91ccaea10818f1a507 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ac65cbe00a72cfc91ccaea10818f1a507">get_hessian_vector_products</a> (<a class="el" href="classoomph_1_1DoubleVectorWithHaloEntries.html">DoubleVectorWithHaloEntries</a> const &amp;Y, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1DoubleVectorWithHaloEntries.html">DoubleVectorWithHaloEntries</a> &gt; const &amp;C, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1DoubleVectorWithHaloEntries.html">DoubleVectorWithHaloEntries</a> &gt; &amp;product)</td></tr>
<tr class="memdesc:ac65cbe00a72cfc91ccaea10818f1a507 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the global hessian (derivative of Jacobian matrix with respect to all variables) with an eigenvector, Y, and any number of other specified vectors C (d(J_{ij})/d u_{k}) Y_{j} C_{k}. This function is used in assembling and solving the augmented systems associated with bifurcation tracking. The default implementation is to use finite differences at the global level.  <a href="classoomph_1_1Problem.html#ac65cbe00a72cfc91ccaea10818f1a507">More...</a><br /></td></tr>
<tr class="separator:ac65cbe00a72cfc91ccaea10818f1a507 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6e5ef95c303d531f5949d7e9f6774a inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#afb6e5ef95c303d531f5949d7e9f6774a">solve_eigenproblem</a> (const unsigned &amp;n_eval, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt;&gt; &amp;alpha, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;beta, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &gt; &amp;eigenvector_real, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &gt; &amp;eigenvector_imag, const bool &amp;steady=true)</td></tr>
<tr class="memdesc:afb6e5ef95c303d531f5949d7e9f6774a inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve an eigenproblem as assembled by the <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a>'s constituent elements. Calculate (at least) n_eval eigenvalues and return the corresponding eigenvectors. The boolean flag (default true) specifies whether the steady jacobian should be assembled. If the flag is false then the weighted mass-matrix terms from the timestepper will be included in the jacobian &mdash; this is almost certainly never wanted. The eigenvalues and eigenvectors are, in general, complex. Eigenvalues may be infinite and are therefore returned as <img class="formulaInl" alt="$ \lambda_i = \alpha_i / \beta_i $" src="form_208.png" width="56" height="14"/> where <img class="formulaInl" alt="$ \alpha_i $" src="form_209.png" width="11" height="9"/> is complex while <img class="formulaInl" alt="$ \beta_i $" src="form_210.png" width="11" height="13"/> is real. The actual eigenvalues may then be computed by doing the division, checking for zero betas to avoid NaNs. There's a convenience wrapper to this function that simply computes these eigenvalues regardless. That version may die in NaN checking is enabled (via the fenv.h header and the associated feenable function).  <a href="classoomph_1_1Problem.html#afb6e5ef95c303d531f5949d7e9f6774a">More...</a><br /></td></tr>
<tr class="separator:afb6e5ef95c303d531f5949d7e9f6774a inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af2e46e4a98d88ccf85f96dd18c4d25 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a1af2e46e4a98d88ccf85f96dd18c4d25">solve_eigenproblem</a> (const unsigned &amp;n_eval, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt;&gt; &amp;eigenvalue, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &gt; &amp;eigenvector_real, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &gt; &amp;eigenvector_imag, const bool &amp;steady=true)</td></tr>
<tr class="memdesc:a1af2e46e4a98d88ccf85f96dd18c4d25 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve an eigenproblem as assembled by the <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a>'s constituent elements. Calculate (at least) n_eval eigenvalues and return the corresponding eigenvectors. The boolean flag (default true) specifies whether the steady jacobian should be assembled. If the flag is false then the weighted mass-matrix terms from the timestepper will be included in the jacobian &mdash; this is almost certainly never wanted. Note that the eigenvalues and eigenvectors are, in general, complex and the eigenvalues may be infinite. In this case it's safer to use the other version of this function which returns the eigenvalues in terms of a fractional representation.  <a href="classoomph_1_1Problem.html#a1af2e46e4a98d88ccf85f96dd18c4d25">More...</a><br /></td></tr>
<tr class="separator:a1af2e46e4a98d88ccf85f96dd18c4d25 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a607f961a4f5651972035abd8529b3 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a02a607f961a4f5651972035abd8529b3">solve_eigenproblem</a> (const unsigned &amp;n_eval, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt;&gt; &amp;eigenvalue, const bool &amp;make_timesteppers_steady=true)</td></tr>
<tr class="memdesc:a02a607f961a4f5651972035abd8529b3 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve an eigenproblem as assembled by the <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a>'s constituent elements but only return the eigenvalues, not the eigenvectors. At least n_eval eigenvalues are computed. The boolean flag (default true) is used to specify whether the weighted mass-matrix terms from the timestepping scheme should be included in the jacobian &mdash; this is almost certainly never wanted. Note that the eigenvalues may be infinite. In this case it's safer to use the other version of this function which returns the eigenvalues in terms of a fractional representation.  <a href="classoomph_1_1Problem.html#a02a607f961a4f5651972035abd8529b3">More...</a><br /></td></tr>
<tr class="separator:a02a607f961a4f5651972035abd8529b3 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdeda71a6cde679015d0a064a2122744 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#abdeda71a6cde679015d0a064a2122744">solve_eigenproblem</a> (const unsigned &amp;n_eval, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt;&gt; &amp;alpha, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;beta, const bool &amp;steady=true)</td></tr>
<tr class="memdesc:abdeda71a6cde679015d0a064a2122744 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve an eigenproblem as assembled by the <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a>'s constituent elements but only return the eigenvalues, not the eigenvectors. At least n_eval eigenvalues are computed. The boolean flag (default true) is used to specify whether the weighted mass-matrix terms from the timestepping scheme should be included in the jacobian &mdash; this is almost certainly never wanted. Note that the eigenvalues may be infinite and are therefore returned as <img class="formulaInl" alt="$ \lambda_i = \alpha_i / \beta_i $" src="form_208.png" width="56" height="14"/> where <img class="formulaInl" alt="$ \alpha_i $" src="form_209.png" width="11" height="9"/> is complex while <img class="formulaInl" alt="$ \beta_i $" src="form_210.png" width="11" height="13"/> is real. The actual eigenvalues may then be computed by doing the division, checking for zero betas to avoid NaNs.  <a href="classoomph_1_1Problem.html#abdeda71a6cde679015d0a064a2122744">More...</a><br /></td></tr>
<tr class="separator:abdeda71a6cde679015d0a064a2122744 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238820e0f1029699f362510557b77d24 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a238820e0f1029699f362510557b77d24">solve_adjoint_eigenproblem</a> (const unsigned &amp;n_eval, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt;&gt; &amp;eigenvalue, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &gt; &amp;eigenvector_real, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &gt; &amp;eigenvector_imag, const bool &amp;steady=true)</td></tr>
<tr class="memdesc:a238820e0f1029699f362510557b77d24 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve an adjoint eigenvalue problem using the same procedure as solve_eigenproblem. See the documentation on that function for more details.  <a href="classoomph_1_1Problem.html#a238820e0f1029699f362510557b77d24">More...</a><br /></td></tr>
<tr class="separator:a238820e0f1029699f362510557b77d24 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42812f6d3b950698cf0936e28f0e415 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ae42812f6d3b950698cf0936e28f0e415">solve_adjoint_eigenproblem</a> (const unsigned &amp;n_eval, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; std::complex&lt; double &gt;&gt; &amp;eigenvalue, const bool &amp;steady=true)</td></tr>
<tr class="memdesc:ae42812f6d3b950698cf0936e28f0e415 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve an adjoint eigenvalue problem using the same procedure as solve_eigenproblem but only return the eigenvalues, not the eigenvectors. At least n_eval eigenvalues are computed. See the documentation on that function for more details.  <a href="classoomph_1_1Problem.html#ae42812f6d3b950698cf0936e28f0e415">More...</a><br /></td></tr>
<tr class="separator:ae42812f6d3b950698cf0936e28f0e415 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e2d84700ac43c1db1d68143790ae5c inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a17e2d84700ac43c1db1d68143790ae5c">get_eigenproblem_matrices</a> (<a class="el" href="classoomph_1_1CRDoubleMatrix.html">CRDoubleMatrix</a> &amp;mass_matrix, <a class="el" href="classoomph_1_1CRDoubleMatrix.html">CRDoubleMatrix</a> &amp;main_matrix, const double &amp;shift=0.0)</td></tr>
<tr class="memdesc:a17e2d84700ac43c1db1d68143790ae5c inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the matrices required by a eigensolver. If the shift parameter is non-zero the second matrix will be shifted.  <a href="classoomph_1_1Problem.html#a17e2d84700ac43c1db1d68143790ae5c">More...</a><br /></td></tr>
<tr class="separator:a17e2d84700ac43c1db1d68143790ae5c inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f93315e1076dd9672167ed0a845ea34 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a8f93315e1076dd9672167ed0a845ea34">assign_eigenvector_to_dofs</a> (<a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;eigenvector)</td></tr>
<tr class="memdesc:a8f93315e1076dd9672167ed0a845ea34 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the eigenvector passed to the function to the dofs in the problem so that it can be output by the usual routines.  <a href="classoomph_1_1Problem.html#a8f93315e1076dd9672167ed0a845ea34">More...</a><br /></td></tr>
<tr class="separator:a8f93315e1076dd9672167ed0a845ea34 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa803fbccb2c8c70702b2c39837e7ad2e inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aa803fbccb2c8c70702b2c39837e7ad2e">add_eigenvector_to_dofs</a> (const double &amp;epsilon, const <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;eigenvector)</td></tr>
<tr class="memdesc:aa803fbccb2c8c70702b2c39837e7ad2e inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the eigenvector passed to the function scaled by the constat epsilon to the dofs in the problem so that it can be output by the usual routines.  <a href="classoomph_1_1Problem.html#aa803fbccb2c8c70702b2c39837e7ad2e">More...</a><br /></td></tr>
<tr class="separator:aa803fbccb2c8c70702b2c39837e7ad2e inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2906b9a6a22445d1dbb8aebbce9fa7 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a5a2906b9a6a22445d1dbb8aebbce9fa7">store_current_dof_values</a> ()</td></tr>
<tr class="memdesc:a5a2906b9a6a22445d1dbb8aebbce9fa7 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the current values of the degrees of freedom.  <a href="classoomph_1_1Problem.html#a5a2906b9a6a22445d1dbb8aebbce9fa7">More...</a><br /></td></tr>
<tr class="separator:a5a2906b9a6a22445d1dbb8aebbce9fa7 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19fe0723fe6356776cfbe28e46ea64b inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ad19fe0723fe6356776cfbe28e46ea64b">restore_dof_values</a> ()</td></tr>
<tr class="memdesc:ad19fe0723fe6356776cfbe28e46ea64b inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the stored values of the degrees of freedom.  <a href="classoomph_1_1Problem.html#ad19fe0723fe6356776cfbe28e46ea64b">More...</a><br /></td></tr>
<tr class="separator:ad19fe0723fe6356776cfbe28e46ea64b inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb2fedc3f64411cfbe1627a516447f9 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a8eb2fedc3f64411cfbe1627a516447f9">enable_jacobian_reuse</a> ()</td></tr>
<tr class="memdesc:a8eb2fedc3f64411cfbe1627a516447f9 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable recycling of Jacobian in Newton iteration (if the linear solver allows it). Useful for linear problems with constant Jacobians or nonlinear problems where you're willing to risk the trade-off between faster solve times and degraded Newton convergence rate.  <a href="classoomph_1_1Problem.html#a8eb2fedc3f64411cfbe1627a516447f9">More...</a><br /></td></tr>
<tr class="separator:a8eb2fedc3f64411cfbe1627a516447f9 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52489fed5942629199e4f720a7a86549 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a52489fed5942629199e4f720a7a86549">disable_jacobian_reuse</a> ()</td></tr>
<tr class="memdesc:a52489fed5942629199e4f720a7a86549 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable recycling of Jacobian in Newton iteration.  <a href="classoomph_1_1Problem.html#a52489fed5942629199e4f720a7a86549">More...</a><br /></td></tr>
<tr class="separator:a52489fed5942629199e4f720a7a86549 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c864f0dfc4f0ff33e07935944b7b435 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a5c864f0dfc4f0ff33e07935944b7b435">jacobian_reuse_is_enabled</a> ()</td></tr>
<tr class="memdesc:a5c864f0dfc4f0ff33e07935944b7b435 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is recycling of Jacobian in Newton iteration enabled?  <a href="classoomph_1_1Problem.html#a5c864f0dfc4f0ff33e07935944b7b435">More...</a><br /></td></tr>
<tr class="separator:a5c864f0dfc4f0ff33e07935944b7b435 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438bf1c7aafffda56f2acb34ba027fdb inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a438bf1c7aafffda56f2acb34ba027fdb">use_predictor_values_as_initial_guess</a> ()</td></tr>
<tr class="separator:a438bf1c7aafffda56f2acb34ba027fdb inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a989ae9a9169b9d905f844db59787f inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a62a989ae9a9169b9d905f844db59787f">newton_solve</a> ()</td></tr>
<tr class="memdesc:a62a989ae9a9169b9d905f844db59787f inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Newton method to solve the problem.  <a href="classoomph_1_1Problem.html#a62a989ae9a9169b9d905f844db59787f">More...</a><br /></td></tr>
<tr class="separator:a62a989ae9a9169b9d905f844db59787f inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c7711978f7c02becb4005414f945be inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ac7c7711978f7c02becb4005414f945be">enable_globally_convergent_newton_method</a> ()</td></tr>
<tr class="memdesc:ac7c7711978f7c02becb4005414f945be inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable globally convergent Newton method  <a href="classoomph_1_1Problem.html#ac7c7711978f7c02becb4005414f945be">More...</a><br /></td></tr>
<tr class="separator:ac7c7711978f7c02becb4005414f945be inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927d35230db6fc5021b68eadaedac9a6 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a927d35230db6fc5021b68eadaedac9a6">disable_globally_convergent_newton_method</a> ()</td></tr>
<tr class="memdesc:a927d35230db6fc5021b68eadaedac9a6 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">disable globally convergent Newton method  <a href="classoomph_1_1Problem.html#a927d35230db6fc5021b68eadaedac9a6">More...</a><br /></td></tr>
<tr class="separator:a927d35230db6fc5021b68eadaedac9a6 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5a30c124a14f32368f9607b7c8bf34 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a4a5a30c124a14f32368f9607b7c8bf34">newton_solve</a> (unsigned const &amp;max_adapt)</td></tr>
<tr class="memdesc:a4a5a30c124a14f32368f9607b7c8bf34 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Newton solve: up to max_adapt adaptations of all refineable submeshes are performed to achieve the the error targets specified in the refineable submeshes.  <a href="classoomph_1_1Problem.html#a4a5a30c124a14f32368f9607b7c8bf34">More...</a><br /></td></tr>
<tr class="separator:a4a5a30c124a14f32368f9607b7c8bf34 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de9b126bf5c8fce5d8e9602fa151090 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a6de9b126bf5c8fce5d8e9602fa151090">steady_newton_solve</a> (unsigned const &amp;max_adapt=0)</td></tr>
<tr class="memdesc:a6de9b126bf5c8fce5d8e9602fa151090 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a steady problem using adaptive Newton's method, but in the context of an overall unstady problem, perhaps to determine an initial condition. This is achieved by setting the weights in the timesteppers to be zero which has the effect of rendering them steady timesteppers. The optional argument max_adapt specifies the max. number of adaptations of all refineable submeshes are performed to achieve the the error targets specified in the refineable submeshes.  <a href="classoomph_1_1Problem.html#a6de9b126bf5c8fce5d8e9602fa151090">More...</a><br /></td></tr>
<tr class="separator:a6de9b126bf5c8fce5d8e9602fa151090 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac828f337a2d4e77e566ff95d01bad0 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a4ac828f337a2d4e77e566ff95d01bad0">copy</a> (<a class="el" href="classoomph_1_1Problem.html">Problem</a> *orig_problem_pt)</td></tr>
<tr class="memdesc:a4ac828f337a2d4e77e566ff95d01bad0 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy <a class="el" href="classoomph_1_1Data.html" title="A class that represents a collection of data; each Data object may contain many different individual ...">Data</a> values, nodal positions etc from specified problem. Note: This is not a copy constructor. We assume that the current and the "original" problem have both been created by calling the same problem constructor so that all <a class="el" href="classoomph_1_1Data.html" title="A class that represents a collection of data; each Data object may contain many different individual ...">Data</a> objects, time steppers etc. in the two problems are completely independent. This function copies the nodal, internal and global values, and the time parameters from the original problem into "this" one. This functionality is required, e.g. for multigrid computations.  <a href="classoomph_1_1Problem.html#a4ac828f337a2d4e77e566ff95d01bad0">More...</a><br /></td></tr>
<tr class="separator:a4ac828f337a2d4e77e566ff95d01bad0 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ac2b1d2483f49198203e192d3b2871 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoomph_1_1Problem.html">Problem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a78ac2b1d2483f49198203e192d3b2871">make_copy</a> ()</td></tr>
<tr class="memdesc:a78ac2b1d2483f49198203e192d3b2871 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make and return a pointer to the copy of the problem. A virtual function that must be filled in by the user is they wish to perform adaptive refinement in bifurcation tracking or in multigrid problems. ALH: WILL NOT BE NECESSARY IN BIFURCATION TRACKING IN LONG RUN...  <a href="classoomph_1_1Problem.html#a78ac2b1d2483f49198203e192d3b2871">More...</a><br /></td></tr>
<tr class="separator:a78ac2b1d2483f49198203e192d3b2871 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27a3057515ddaa60d2ecc684d517e8f inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ae27a3057515ddaa60d2ecc684d517e8f">read</a> (std::ifstream &amp;restart_file, bool &amp;unsteady_restart)</td></tr>
<tr class="memdesc:ae27a3057515ddaa60d2ecc684d517e8f inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read refinement pattern of all refineable meshes and refine them accordingly, then read all <a class="el" href="classoomph_1_1Data.html" title="A class that represents a collection of data; each Data object may contain many different individual ...">Data</a> and nodal position info from file for restart. Return flag to indicate if the restart was from steady or unsteady solution.  <a href="classoomph_1_1Problem.html#ae27a3057515ddaa60d2ecc684d517e8f">More...</a><br /></td></tr>
<tr class="separator:ae27a3057515ddaa60d2ecc684d517e8f inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561320c1b8deb3540d260c6c2c5f4fb4 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a561320c1b8deb3540d260c6c2c5f4fb4">read</a> (std::ifstream &amp;restart_file)</td></tr>
<tr class="memdesc:a561320c1b8deb3540d260c6c2c5f4fb4 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read refinement pattern of all refineable meshes and refine them accordingly, then read all <a class="el" href="classoomph_1_1Data.html" title="A class that represents a collection of data; each Data object may contain many different individual ...">Data</a> and nodal position info from file for restart.  <a href="classoomph_1_1Problem.html#a561320c1b8deb3540d260c6c2c5f4fb4">More...</a><br /></td></tr>
<tr class="separator:a561320c1b8deb3540d260c6c2c5f4fb4 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804050357ac754151b86c2aec4dabc2d inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a804050357ac754151b86c2aec4dabc2d">dump</a> (std::ofstream &amp;dump_file) const</td></tr>
<tr class="memdesc:a804050357ac754151b86c2aec4dabc2d inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump refinement pattern of all refineable meshes and all generic <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> data to file for restart.  <a href="classoomph_1_1Problem.html#a804050357ac754151b86c2aec4dabc2d">More...</a><br /></td></tr>
<tr class="separator:a804050357ac754151b86c2aec4dabc2d inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94771cdd9de79c17c9cf168f4a67a92 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af94771cdd9de79c17c9cf168f4a67a92">dump</a> (const std::string &amp;dump_file_name) const</td></tr>
<tr class="memdesc:af94771cdd9de79c17c9cf168f4a67a92 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump refinement pattern of all refineable meshes and all generic <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> data to file for restart.  <a href="classoomph_1_1Problem.html#af94771cdd9de79c17c9cf168f4a67a92">More...</a><br /></td></tr>
<tr class="separator:af94771cdd9de79c17c9cf168f4a67a92 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c302721bf6699ecf8c8760e49d47d8 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ad5c302721bf6699ecf8c8760e49d47d8">get_all_halo_data</a> (std::map&lt; unsigned, double * &gt; &amp;map_of_halo_data)</td></tr>
<tr class="memdesc:ad5c302721bf6699ecf8c8760e49d47d8 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointers to all possible halo data indexed by global equation number in a map.  <a href="classoomph_1_1Problem.html#ad5c302721bf6699ecf8c8760e49d47d8">More...</a><br /></td></tr>
<tr class="separator:ad5c302721bf6699ecf8c8760e49d47d8 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9ce9ee869ff79ee5596e434309f379 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a9a9ce9ee869ff79ee5596e434309f379">synchronise_eqn_numbers</a> (const bool &amp;assign_local_eqn_numbers=true)</td></tr>
<tr class="memdesc:a9a9ce9ee869ff79ee5596e434309f379 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classify any non-classified nodes into halo/haloed and synchronise equation numbers. Return the total number of degrees of freedom in the overall problem.  <a href="classoomph_1_1Problem.html#a9a9ce9ee869ff79ee5596e434309f379">More...</a><br /></td></tr>
<tr class="separator:a9a9ce9ee869ff79ee5596e434309f379 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccef4e26a7788424780da7555cdc772 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a1ccef4e26a7788424780da7555cdc772">synchronise_dofs</a> (const bool &amp;do_halos, const bool &amp;do_external_halos)</td></tr>
<tr class="memdesc:a1ccef4e26a7788424780da7555cdc772 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronise the degrees of freedom by overwriting the haloed values with their non-halo counterparts held on other processors. Bools control if we deal with data associated with external halo/ed elements/nodes or the "normal" halo/ed ones.  <a href="classoomph_1_1Problem.html#a1ccef4e26a7788424780da7555cdc772">More...</a><br /></td></tr>
<tr class="separator:a1ccef4e26a7788424780da7555cdc772 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9a3ba5696a7bcd275223ff16b7392e inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a5d9a3ba5696a7bcd275223ff16b7392e">synchronise_all_dofs</a> ()</td></tr>
<tr class="memdesc:a5d9a3ba5696a7bcd275223ff16b7392e inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform all required synchronisation in solvers.  <a href="classoomph_1_1Problem.html#a5d9a3ba5696a7bcd275223ff16b7392e">More...</a><br /></td></tr>
<tr class="separator:a5d9a3ba5696a7bcd275223ff16b7392e inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93dde63729e7cd332edc1f8904a80649 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a93dde63729e7cd332edc1f8904a80649">check_halo_schemes</a> (<a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info)</td></tr>
<tr class="memdesc:a93dde63729e7cd332edc1f8904a80649 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the halo/haloed node/element schemes.  <a href="classoomph_1_1Problem.html#a93dde63729e7cd332edc1f8904a80649">More...</a><br /></td></tr>
<tr class="separator:a93dde63729e7cd332edc1f8904a80649 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd5cb241ce6218fb476931e0879d7c8 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a8dd5cb241ce6218fb476931e0879d7c8">check_halo_schemes</a> ()</td></tr>
<tr class="memdesc:a8dd5cb241ce6218fb476931e0879d7c8 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the halo/haloed node/element schemes.  <a href="classoomph_1_1Problem.html#a8dd5cb241ce6218fb476931e0879d7c8">More...</a><br /></td></tr>
<tr class="separator:a8dd5cb241ce6218fb476931e0879d7c8 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35e1adc0fdf14b217c7b608eb9cf20b inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aa35e1adc0fdf14b217c7b608eb9cf20b">distribute</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;element_partition, <a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info, const bool &amp;report_stats=false)</td></tr>
<tr class="memdesc:aa35e1adc0fdf14b217c7b608eb9cf20b inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribute the problem and doc, using the specified partition; returns a vector which details the partitioning.  <a href="classoomph_1_1Problem.html#aa35e1adc0fdf14b217c7b608eb9cf20b">More...</a><br /></td></tr>
<tr class="separator:aa35e1adc0fdf14b217c7b608eb9cf20b inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bab7c41bf5d6d053259ff10920d7303 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a9bab7c41bf5d6d053259ff10920d7303">distribute</a> (<a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info, const bool &amp;report_stats=false)</td></tr>
<tr class="memdesc:a9bab7c41bf5d6d053259ff10920d7303 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribute the problem; returns a vector which details the partitioning.  <a href="classoomph_1_1Problem.html#a9bab7c41bf5d6d053259ff10920d7303">More...</a><br /></td></tr>
<tr class="separator:a9bab7c41bf5d6d053259ff10920d7303 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35f7ff2b0075cfd4dda519858a65d6c inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aa35f7ff2b0075cfd4dda519858a65d6c">distribute</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;element_partition, const bool &amp;report_stats=false)</td></tr>
<tr class="memdesc:aa35f7ff2b0075cfd4dda519858a65d6c inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribute the problem using the specified partition; returns a vector which details the partitioning.  <a href="classoomph_1_1Problem.html#aa35f7ff2b0075cfd4dda519858a65d6c">More...</a><br /></td></tr>
<tr class="separator:aa35f7ff2b0075cfd4dda519858a65d6c inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0365ddbe425b730ece6a575db1cd7dd inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af0365ddbe425b730ece6a575db1cd7dd">distribute</a> (const bool &amp;report_stats=false)</td></tr>
<tr class="memdesc:af0365ddbe425b730ece6a575db1cd7dd inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribute the problem; returns a vector which details the partitioning.  <a href="classoomph_1_1Problem.html#af0365ddbe425b730ece6a575db1cd7dd">More...</a><br /></td></tr>
<tr class="separator:af0365ddbe425b730ece6a575db1cd7dd inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29fc4bc4d4bead472059765fbbd3b11 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ad29fc4bc4d4bead472059765fbbd3b11">partition_global_mesh</a> (<a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *&amp;global_mesh_pt, <a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;element_domain, const bool &amp;report_stats=false)</td></tr>
<tr class="memdesc:ad29fc4bc4d4bead472059765fbbd3b11 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition the global mesh, return vector specifying the processor number for each element. Virtual so that it can be overloaded by any user; the default is to use <a class="el" href="namespaceoomph_1_1METIS.html" title="Namespace for METIS graph partitioning routines.">METIS</a> to perform the partitioning (with a bit of cleaning up afterwards to sort out "special cases").  <a href="classoomph_1_1Problem.html#ad29fc4bc4d4bead472059765fbbd3b11">More...</a><br /></td></tr>
<tr class="separator:ad29fc4bc4d4bead472059765fbbd3b11 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5982a9323392e31a166e23a0c7f0a3 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a8c5982a9323392e31a166e23a0c7f0a3">prune_halo_elements_and_nodes</a> (<a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info, const bool &amp;report_stats)</td></tr>
<tr class="memdesc:a8c5982a9323392e31a166e23a0c7f0a3 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Irreversibly) prune halo(ed) elements and nodes, usually after another round of refinement, to get rid of excessively wide halo layers. Note that the current mesh will be now regarded as the base mesh and no unrefinement relative to it will be possible once this function has been called.  <a href="classoomph_1_1Problem.html#a8c5982a9323392e31a166e23a0c7f0a3">More...</a><br /></td></tr>
<tr class="separator:a8c5982a9323392e31a166e23a0c7f0a3 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977f74f132157959d30e82cfcad41a97 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a977f74f132157959d30e82cfcad41a97">prune_halo_elements_and_nodes</a> (const bool &amp;report_stats=false)</td></tr>
<tr class="memdesc:a977f74f132157959d30e82cfcad41a97 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Irreversibly) prune halo(ed) elements and nodes, usually after another round of refinement, to get rid of excessively wide halo layers. Note that the current mesh will be now regarded as the base mesh and no unrefinement relative to it will be possible once this function has been called.  <a href="classoomph_1_1Problem.html#a977f74f132157959d30e82cfcad41a97">More...</a><br /></td></tr>
<tr class="separator:a977f74f132157959d30e82cfcad41a97 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44439175e6899a1a6c125f08b786301 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aa44439175e6899a1a6c125f08b786301">problem_has_been_distributed</a> ()</td></tr>
<tr class="memdesc:aa44439175e6899a1a6c125f08b786301 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to Problem_has_been_distributed flag.  <a href="classoomph_1_1Problem.html#aa44439175e6899a1a6c125f08b786301">More...</a><br /></td></tr>
<tr class="separator:aa44439175e6899a1a6c125f08b786301 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8eb3782046c64ea0e46205917440452 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ab8eb3782046c64ea0e46205917440452">delete_all_external_storage</a> ()</td></tr>
<tr class="memdesc:ab8eb3782046c64ea0e46205917440452 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function to delete external storage for each submesh of the problem.  <a href="classoomph_1_1Problem.html#ab8eb3782046c64ea0e46205917440452">More...</a><br /></td></tr>
<tr class="separator:ab8eb3782046c64ea0e46205917440452 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcf4965b6052758e49cf511947fd3f0 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#abbcf4965b6052758e49cf511947fd3f0">symmetrise_eigenfunction_for_adaptive_pitchfork_tracking</a> ()</td></tr>
<tr class="memdesc:abbcf4965b6052758e49cf511947fd3f0 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that is used to symmetrise the problem so that the current solution exactly satisfies any symmetries within the system. Used when adpativly solving pitchfork detection problems when small asymmetries in the coarse solution can be magnified leading to very inaccurate answers on the fine mesh. This is always problem-specific and must be filled in by the user The default issues a warning.  <a href="classoomph_1_1Problem.html#abbcf4965b6052758e49cf511947fd3f0">More...</a><br /></td></tr>
<tr class="separator:abbcf4965b6052758e49cf511947fd3f0 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf79b3067d1d794062ebb27e414dea9 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a3cf79b3067d1d794062ebb27e414dea9">bifurcation_parameter_pt</a> () const</td></tr>
<tr class="memdesc:a3cf79b3067d1d794062ebb27e414dea9 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to the parameter that is used in the bifurcation detection. If we are not tracking a bifurcation then an error will be thrown by the <a class="el" href="classoomph_1_1AssemblyHandler.html" title="A class that is used to define the functions used to assemble the elemental contributions to the resi...">AssemblyHandler</a>.  <a href="classoomph_1_1Problem.html#a3cf79b3067d1d794062ebb27e414dea9">More...</a><br /></td></tr>
<tr class="separator:a3cf79b3067d1d794062ebb27e414dea9 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b240c17750bdc32afafee35b50225a inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a85b240c17750bdc32afafee35b50225a">get_bifurcation_eigenfunction</a> (<a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &gt; &amp;eigenfunction)</td></tr>
<tr class="memdesc:a85b240c17750bdc32afafee35b50225a inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigenfunction calculated as part of a bifurcation tracking process. If we are not tracking a bifurcation then an error will be thrown by the <a class="el" href="classoomph_1_1AssemblyHandler.html" title="A class that is used to define the functions used to assemble the elemental contributions to the resi...">AssemblyHandler</a>.  <a href="classoomph_1_1Problem.html#a85b240c17750bdc32afafee35b50225a">More...</a><br /></td></tr>
<tr class="separator:a85b240c17750bdc32afafee35b50225a inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf20e92281911dfbb423ea82542c0485 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#acf20e92281911dfbb423ea82542c0485">activate_fold_tracking</a> (double *const &amp;parameter_pt, const bool &amp;block_solve=true)</td></tr>
<tr class="memdesc:acf20e92281911dfbb423ea82542c0485 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on fold tracking using the augmented system specified in the <a class="el" href="classoomph_1_1FoldHandler.html" title="A class that is used to assemble the augmented system that defines a fold (saddle-node) or limit poin...">FoldHandler</a> class. After a call to this function subsequent calls of the standard solution methods will converge to a fold (limit) point at a particular value of the variable addressed by parameter_pt. The system may not converge if the initial guess is sufficiently poor or, alternatively, if finite differencing is used to calculate the jacobian matrix in the elements. If the boolean flag block_solver is true (the default) then a block factorisation is used to solve the augmented system which is both faster and uses less memory.  <a href="classoomph_1_1Problem.html#acf20e92281911dfbb423ea82542c0485">More...</a><br /></td></tr>
<tr class="separator:acf20e92281911dfbb423ea82542c0485 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95359def89a0ee3d3df8976ab54c6591 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a95359def89a0ee3d3df8976ab54c6591">activate_bifurcation_tracking</a> (double *const &amp;parameter_pt, const <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;eigenvector, const bool &amp;block_solve=true)</td></tr>
<tr class="memdesc:a95359def89a0ee3d3df8976ab54c6591 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate generic bifurcation tracking for a single (real) eigenvalue where the initial guess for the eigenvector can be specified.  <a href="classoomph_1_1Problem.html#a95359def89a0ee3d3df8976ab54c6591">More...</a><br /></td></tr>
<tr class="separator:a95359def89a0ee3d3df8976ab54c6591 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4610ef4c4f4d7c1d7001fabf074c930c inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a4610ef4c4f4d7c1d7001fabf074c930c">activate_bifurcation_tracking</a> (double *const &amp;parameter_pt, const <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;eigenvector, const <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;normalisation, const bool &amp;block_solve=true)</td></tr>
<tr class="memdesc:a4610ef4c4f4d7c1d7001fabf074c930c inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate generic bifurcation tracking for a single (real) eigenvalue where the initial guess for the eigenvector can be specified and the normalisation condition can also be specified.  <a href="classoomph_1_1Problem.html#a4610ef4c4f4d7c1d7001fabf074c930c">More...</a><br /></td></tr>
<tr class="separator:a4610ef4c4f4d7c1d7001fabf074c930c inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5eb1f88a957cb3d8a11b558002d484 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a7f5eb1f88a957cb3d8a11b558002d484">activate_pitchfork_tracking</a> (double *const &amp;parameter_pt, const <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;symmetry_vector, const bool &amp;block_solve=true)</td></tr>
<tr class="memdesc:a7f5eb1f88a957cb3d8a11b558002d484 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on pitchfork tracking using the augmented system specified in the <a class="el" href="classoomph_1_1PitchForkHandler.html" title="A class that is used to assemble the augmented system that defines a pitchfork (symmetry-breaking) bi...">PitchForkHandler</a> class. After a call to this function subsequent calls of the standard solution methods will converge to a pitchfork bifurcation at a particular value of the variable addressed by parameter_pt. The symmetry that is to be broken must be specified by supplying a symmetry_vector(ndof). The easiest way to determine such a vector is to solve the associated eigenproblem <img class="formulaInl" alt="$ Jx = \lambda M x$" src="form_350.png" width="59" height="10"/> and pass in the eigenvector. This is not always necessary however, if the symmetry is easy to construct. The system may not converge if the initial guess is sufficiently poor or, alternatively, if finite differencing is used to calculate the jacobian matrix in the elements. If the boolean flag block_solver is true (the default) then a block factorisation is used to solve the augmented system which is both faster and requires less memory.  <a href="classoomph_1_1Problem.html#a7f5eb1f88a957cb3d8a11b558002d484">More...</a><br /></td></tr>
<tr class="separator:a7f5eb1f88a957cb3d8a11b558002d484 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5966d1a184e722195f96d797b52e64c inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ac5966d1a184e722195f96d797b52e64c">activate_hopf_tracking</a> (double *const &amp;parameter_pt, const bool &amp;block_solve=true)</td></tr>
<tr class="memdesc:ac5966d1a184e722195f96d797b52e64c inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on Hopf bifurcation tracking using the augmented system specified in the <a class="el" href="classoomph_1_1HopfHandler.html" title="A class that is used to assemble the augmented system that defines a Hopf bifurcation....">HopfHandler</a> class. After a call to this function subsequent calls of the standard solution methods will converge to a Hopf bifuraction at a particular value of the variable addressed by parameter_pt. The system may not converge if the initial guess is sufficiently poor or, alternatively, if finite differencing is used to calculate the jacobian matrix in the elements.  <a href="classoomph_1_1Problem.html#ac5966d1a184e722195f96d797b52e64c">More...</a><br /></td></tr>
<tr class="separator:ac5966d1a184e722195f96d797b52e64c inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e2d0e105da6b676262d75481bcc8e3 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aa0e2d0e105da6b676262d75481bcc8e3">activate_hopf_tracking</a> (double *const &amp;parameter_pt, const double &amp;omega, const <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;null_real, const <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;null_imag, const bool &amp;block_solve=true)</td></tr>
<tr class="memdesc:aa0e2d0e105da6b676262d75481bcc8e3 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on Hopf bifurcation tracking using the augmented system specified in the <a class="el" href="classoomph_1_1HopfHandler.html" title="A class that is used to assemble the augmented system that defines a Hopf bifurcation....">HopfHandler</a> class. After a call to this function subsequent calls of the standard solution methods will converge to a Hopf bifuraction at a particular value of the variable addressed by parameter_pt. The system may not converge if the initial guess is sufficiently poor or, alternatively, if finite differencing is used to calculate the jacobian matrix in the elements. This interface allows specification of an inital guess for the frequency and real and imaginary parts of the null vector, such as might be obtained from an eigensolve.  <a href="classoomph_1_1Problem.html#aa0e2d0e105da6b676262d75481bcc8e3">More...</a><br /></td></tr>
<tr class="separator:aa0e2d0e105da6b676262d75481bcc8e3 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b47ae12ed6445e52c65596dfa97c6d inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ac5b47ae12ed6445e52c65596dfa97c6d">deactivate_bifurcation_tracking</a> ()</td></tr>
<tr class="memdesc:ac5b47ae12ed6445e52c65596dfa97c6d inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate all bifuraction tracking, by reseting the assembly handler to the default.  <a href="classoomph_1_1Problem.html#ac5b47ae12ed6445e52c65596dfa97c6d">More...</a><br /></td></tr>
<tr class="separator:ac5b47ae12ed6445e52c65596dfa97c6d inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb590c73e64b0a85f7bec0053e2c51d inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aecb590c73e64b0a85f7bec0053e2c51d">reset_assembly_handler_to_default</a> ()</td></tr>
<tr class="memdesc:aecb590c73e64b0a85f7bec0053e2c51d inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the system to the standard non-augemented state.  <a href="classoomph_1_1Problem.html#aecb590c73e64b0a85f7bec0053e2c51d">More...</a><br /></td></tr>
<tr class="separator:aecb590c73e64b0a85f7bec0053e2c51d inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8414efbd8099d3e6cf3f4daea06cc8f inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ad8414efbd8099d3e6cf3f4daea06cc8f">arc_length_step_solve</a> (double *const &amp;parameter_pt, const double &amp;ds, const unsigned &amp;max_adapt=0)</td></tr>
<tr class="memdesc:ad8414efbd8099d3e6cf3f4daea06cc8f inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a steady problem using arc-length continuation, when the parameter that becomes a variable corresponding to the arc-length constraint equation is an external double: parameter_pt is a pointer to that double, ds is the desired arc_length and max_adapt is the maximum number of spatial adaptations (default zero, no adaptation).  <a href="classoomph_1_1Problem.html#ad8414efbd8099d3e6cf3f4daea06cc8f">More...</a><br /></td></tr>
<tr class="separator:ad8414efbd8099d3e6cf3f4daea06cc8f inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb723728ed26abe410b61ec38d42688 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aefb723728ed26abe410b61ec38d42688">arc_length_step_solve</a> (<a class="el" href="classoomph_1_1Data.html">Data</a> *const &amp;data_pt, const unsigned &amp;data_index, const double &amp;ds, const unsigned &amp;max_adapt=0)</td></tr>
<tr class="memdesc:aefb723728ed26abe410b61ec38d42688 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a steady problem using arc-length continuation, when the variable corresponding to the arc-length constraint equation is already stored in data used in the problem: data_pt is a pointer to the appropriate data object, data_index is the index of the value that will be traded for the constriant, ds is the desired arc_length and max_adapt is the maximum number of spatial adaptations (default zero, no adaptation). Note that the value must be pinned in order for this formulation to work.  <a href="classoomph_1_1Problem.html#aefb723728ed26abe410b61ec38d42688">More...</a><br /></td></tr>
<tr class="separator:aefb723728ed26abe410b61ec38d42688 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6477df6e8184dc78e9d9ff82c7627cef inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a6477df6e8184dc78e9d9ff82c7627cef">reset_arc_length_parameters</a> ()</td></tr>
<tr class="memdesc:a6477df6e8184dc78e9d9ff82c7627cef inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the "internal" arc-length continuation parameters, so as to allow continuation in another parameter. N.B. The parameters that are reset are the "minimum" that are required, others should perhaps be reset, depending upon the application.  <a href="classoomph_1_1Problem.html#a6477df6e8184dc78e9d9ff82c7627cef">More...</a><br /></td></tr>
<tr class="separator:a6477df6e8184dc78e9d9ff82c7627cef inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797cb28b5fffe976fc7541421eb423a1 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a797cb28b5fffe976fc7541421eb423a1">sign_of_jacobian</a> ()</td></tr>
<tr class="memdesc:a797cb28b5fffe976fc7541421eb423a1 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for the sign of the global jacobian matrix. This will be set by the linear solver, if possible (direct solver). If not alternative methods must be used to detect bifurcations (solving the associated eigenproblem).  <a href="classoomph_1_1Problem.html#a797cb28b5fffe976fc7541421eb423a1">More...</a><br /></td></tr>
<tr class="separator:a797cb28b5fffe976fc7541421eb423a1 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b74c5b1499b2d712a8545cccbd97c2 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ab8b74c5b1499b2d712a8545cccbd97c2">explicit_timestep</a> (const double &amp;dt, const bool &amp;shift_values=true)</td></tr>
<tr class="memdesc:ab8b74c5b1499b2d712a8545cccbd97c2 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an explicit timestep of size dt and optionally shift any stored values of the time history.  <a href="classoomph_1_1Problem.html#ab8b74c5b1499b2d712a8545cccbd97c2">More...</a><br /></td></tr>
<tr class="separator:ab8b74c5b1499b2d712a8545cccbd97c2 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef22157aadc15a512cca93e4c423ff73 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aef22157aadc15a512cca93e4c423ff73">unsteady_newton_solve</a> (const double &amp;dt)</td></tr>
<tr class="memdesc:aef22157aadc15a512cca93e4c423ff73 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance time by dt and solve by Newton's method. This version always shifts time values.  <a href="classoomph_1_1Problem.html#aef22157aadc15a512cca93e4c423ff73">More...</a><br /></td></tr>
<tr class="separator:aef22157aadc15a512cca93e4c423ff73 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8b8c9ee09df0ba8934382740a588de inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#abf8b8c9ee09df0ba8934382740a588de">unsteady_newton_solve</a> (const double &amp;dt, const bool &amp;shift_values)</td></tr>
<tr class="memdesc:abf8b8c9ee09df0ba8934382740a588de inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance time by dt and solve the system, using Newton's method. The boolean flag is used to control whether the time values should be shifted. If it is true the current data values will be shifted (copied to the locations where there are stored as previous timesteps) before solution.  <a href="classoomph_1_1Problem.html#abf8b8c9ee09df0ba8934382740a588de">More...</a><br /></td></tr>
<tr class="separator:abf8b8c9ee09df0ba8934382740a588de inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26bd71c24ba99c9391d6e932b68e5e8 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af26bd71c24ba99c9391d6e932b68e5e8">unsteady_newton_solve</a> (const double &amp;dt, const unsigned &amp;max_adapt, const bool &amp;first, const bool &amp;shift=true)</td></tr>
<tr class="memdesc:af26bd71c24ba99c9391d6e932b68e5e8 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsteady adaptive Newton solve: up to max_adapt adaptations of all refineable submeshes are performed to achieve the the error targets specified in the refineable submeshes. If first==true, the initial conditions are re-assigned after the mesh adaptations. Shifting of time can be suppressed by overwriting the default value of shift (true). [Shifting must be done if first_timestep==true because we're constantly re-assigning the initial conditions; if first_timestep==true and shift==false shifting is performed anyway and a warning is issued.  <a href="classoomph_1_1Problem.html#af26bd71c24ba99c9391d6e932b68e5e8">More...</a><br /></td></tr>
<tr class="separator:af26bd71c24ba99c9391d6e932b68e5e8 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7561d4f82e1fa625210c58a78294a301 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a7561d4f82e1fa625210c58a78294a301">doubly_adaptive_unsteady_newton_solve</a> (const double &amp;dt, const double &amp;epsilon, const unsigned &amp;max_adapt, const bool &amp;first, const bool &amp;shift=true)</td></tr>
<tr class="memdesc:a7561d4f82e1fa625210c58a78294a301 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsteady "doubly" adaptive Newton solve: Does temporal adaptation first, i.e. we try to do a timestep with an increment of dt, and adjusting dt until the solution on the given mesh satisfies the temporal error measure with tolerance epsilon. Following this, we do up to max_adapt spatial adaptions (without re-examining the temporal error). If first==true, the initial conditions are re-assigned after the mesh adaptations. Shifting of time can be suppressed by overwriting the default value of shift (true). [Shifting must be done if first_timestep==true because we're constantly re-assigning the initial conditions; if first_timestep==true and shift==false shifting is performed anyway and a warning is issued.  <a href="classoomph_1_1Problem.html#a7561d4f82e1fa625210c58a78294a301">More...</a><br /></td></tr>
<tr class="separator:a7561d4f82e1fa625210c58a78294a301 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c326bce8647c2a59cf62288ce4902e inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ae6c326bce8647c2a59cf62288ce4902e">doubly_adaptive_unsteady_newton_solve</a> (const double &amp;dt, const double &amp;epsilon, const unsigned &amp;max_adapt, const unsigned &amp;suppress_resolve_after_spatial_adapt_flag, const bool &amp;first, const bool &amp;shift=true)</td></tr>
<tr class="memdesc:ae6c326bce8647c2a59cf62288ce4902e inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsteady "doubly" adaptive Newton solve: Does temporal adaptation first, i.e. we try to do a timestep with an increment of dt, and adjusting dt until the solution on the given mesh satisfies the temporal error measure with tolerance epsilon. Following this, we do up to max_adapt spatial adaptions (without re-examining the temporal error). If first==true, the initial conditions are re-assigned after the mesh adaptations. Shifting of time can be suppressed by overwriting the default value of shift (true). [Shifting must be done if first_timestep==true because we're constantly re-assigning the initial conditions; if first_timestep==true and shift==false shifting is performed anyway and a warning is issued. Pseudo-Boolean flag suppress_resolve_after_spatial_adapt [0: false; 1: true] does what it says.].  <a href="classoomph_1_1Problem.html#ae6c326bce8647c2a59cf62288ce4902e">More...</a><br /></td></tr>
<tr class="separator:ae6c326bce8647c2a59cf62288ce4902e inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6681f21f614ed7f15cc675ed6f692a inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#abf6681f21f614ed7f15cc675ed6f692a">adaptive_unsteady_newton_solve</a> (const double &amp;dt_desired, const double &amp;epsilon)</td></tr>
<tr class="memdesc:abf6681f21f614ed7f15cc675ed6f692a inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to advance timestep by dt_desired. If the solution fails the timestep will be halved until convergence is achieved, or the timestep falls below NewtonSolverParameters::Minimum_time_step. The error control parameter epsilon represents the (approximate) desired magnitude of the global error at each timestep. The routine returns a double that is the suggested next timestep and should be passed as dt_desired the next time the routine is called. This version always shifts the time values.  <a href="classoomph_1_1Problem.html#abf6681f21f614ed7f15cc675ed6f692a">More...</a><br /></td></tr>
<tr class="separator:abf6681f21f614ed7f15cc675ed6f692a inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5bde6d7fa8972e01a20c522b5fb2ef inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a3f5bde6d7fa8972e01a20c522b5fb2ef">adaptive_unsteady_newton_solve</a> (const double &amp;dt_desired, const double &amp;epsilon, const bool &amp;shift_values)</td></tr>
<tr class="memdesc:a3f5bde6d7fa8972e01a20c522b5fb2ef inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to advance timestep by dt_desired. If the solution fails the timestep will be halved until convergence is achieved, or the timestep falls below NewtonSolverParameters::Minimum_time_step. The error control parameter epsilon represents the (approximate) desired magnitude of the global error at each timestep. The routine returns a double that is the suggested next timestep and should be passed as dt_desired the next time the routine is called. Once again the boolean flag, shift_values, is used to control whether the time values are shifted.  <a href="classoomph_1_1Problem.html#a3f5bde6d7fa8972e01a20c522b5fb2ef">More...</a><br /></td></tr>
<tr class="separator:a3f5bde6d7fa8972e01a20c522b5fb2ef inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e5dc4d944dfb2b141918e18e5e3de8 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a10e5dc4d944dfb2b141918e18e5e3de8">assign_initial_values_impulsive</a> ()</td></tr>
<tr class="memdesc:a10e5dc4d944dfb2b141918e18e5e3de8 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise data and nodal positions to simulate impulsive start from initial configuration/solution.  <a href="classoomph_1_1Problem.html#a10e5dc4d944dfb2b141918e18e5e3de8">More...</a><br /></td></tr>
<tr class="separator:a10e5dc4d944dfb2b141918e18e5e3de8 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296bd0ba13bd51a96bb7057845e5a800 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a296bd0ba13bd51a96bb7057845e5a800">assign_initial_values_impulsive</a> (const double &amp;dt)</td></tr>
<tr class="memdesc:a296bd0ba13bd51a96bb7057845e5a800 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise data and nodal positions to simulate an impulsive start and also set the initial and previous values of dt.  <a href="classoomph_1_1Problem.html#a296bd0ba13bd51a96bb7057845e5a800">More...</a><br /></td></tr>
<tr class="separator:a296bd0ba13bd51a96bb7057845e5a800 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474deeb0947b767566fa1d4630ad8b4a inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a474deeb0947b767566fa1d4630ad8b4a">calculate_predictions</a> ()</td></tr>
<tr class="memdesc:a474deeb0947b767566fa1d4630ad8b4a inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate predictions.  <a href="classoomph_1_1Problem.html#a474deeb0947b767566fa1d4630ad8b4a">More...</a><br /></td></tr>
<tr class="separator:a474deeb0947b767566fa1d4630ad8b4a inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9e63d6e585eabe4e3e551f01f658ae inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a6a9e63d6e585eabe4e3e551f01f658ae">enable_mass_matrix_reuse</a> ()</td></tr>
<tr class="memdesc:a6a9e63d6e585eabe4e3e551f01f658ae inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable recycling of the mass matrix in explicit timestepping schemes. Useful for timestepping on fixed meshes when you want to avoid the linear solve phase.  <a href="classoomph_1_1Problem.html#a6a9e63d6e585eabe4e3e551f01f658ae">More...</a><br /></td></tr>
<tr class="separator:a6a9e63d6e585eabe4e3e551f01f658ae inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399ca4ccf551f9bf5621f9855e899af6 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a399ca4ccf551f9bf5621f9855e899af6">disable_mass_matrix_reuse</a> ()</td></tr>
<tr class="memdesc:a399ca4ccf551f9bf5621f9855e899af6 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn off recyling of the mass matrix in explicit timestepping schemes.  <a href="classoomph_1_1Problem.html#a399ca4ccf551f9bf5621f9855e899af6">More...</a><br /></td></tr>
<tr class="separator:a399ca4ccf551f9bf5621f9855e899af6 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa46c693258868c126503cce3a663a85 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#afa46c693258868c126503cce3a663a85">mass_matrix_reuse_is_enabled</a> ()</td></tr>
<tr class="memdesc:afa46c693258868c126503cce3a663a85 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the mass matrix is being reused.  <a href="classoomph_1_1Problem.html#afa46c693258868c126503cce3a663a85">More...</a><br /></td></tr>
<tr class="separator:afa46c693258868c126503cce3a663a85 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181fa92838f77bd6b12b531dca222c41 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a181fa92838f77bd6b12b531dca222c41">refine_uniformly</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;nrefine_for_mesh)</td></tr>
<tr class="memdesc:a181fa92838f77bd6b12b531dca222c41 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine refineable sub-meshes, each as many times as specified in the vector and rebuild problem.  <a href="classoomph_1_1Problem.html#a181fa92838f77bd6b12b531dca222c41">More...</a><br /></td></tr>
<tr class="separator:a181fa92838f77bd6b12b531dca222c41 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ca1d18e9aa569a6417c45eef70d3ff inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a14ca1d18e9aa569a6417c45eef70d3ff">refine_uniformly</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;nrefine_for_mesh, <a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info)</td></tr>
<tr class="memdesc:a14ca1d18e9aa569a6417c45eef70d3ff inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine refineable sub-meshes, each as many times as specified in the vector and rebuild problem; doc refinement process.  <a href="classoomph_1_1Problem.html#a14ca1d18e9aa569a6417c45eef70d3ff">More...</a><br /></td></tr>
<tr class="separator:a14ca1d18e9aa569a6417c45eef70d3ff inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3930fc0977bdc33f52100e53f5d878d7 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a3930fc0977bdc33f52100e53f5d878d7">refine_uniformly_and_prune</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;nrefine_for_mesh)</td></tr>
<tr class="memdesc:a3930fc0977bdc33f52100e53f5d878d7 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine refineable sub-meshes, each as many times as specified in the vector and rebuild problem. Prune after refinements.  <a href="classoomph_1_1Problem.html#a3930fc0977bdc33f52100e53f5d878d7">More...</a><br /></td></tr>
<tr class="separator:a3930fc0977bdc33f52100e53f5d878d7 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea5168244acebb539fa29e36182ced3 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#adea5168244acebb539fa29e36182ced3">refine_uniformly_and_prune</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;nrefine_for_mesh, <a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info)</td></tr>
<tr class="memdesc:adea5168244acebb539fa29e36182ced3 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine refineable sub-meshes, each as many times as specified in the vector and rebuild problem; doc refinement process.  <a href="classoomph_1_1Problem.html#adea5168244acebb539fa29e36182ced3">More...</a><br /></td></tr>
<tr class="separator:adea5168244acebb539fa29e36182ced3 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ccf79fde59556d93af947618b6c80b inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ae4ccf79fde59556d93af947618b6c80b">refine_uniformly</a> (<a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info)</td></tr>
<tr class="memdesc:ae4ccf79fde59556d93af947618b6c80b inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine (all) refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process.  <a href="classoomph_1_1Problem.html#ae4ccf79fde59556d93af947618b6c80b">More...</a><br /></td></tr>
<tr class="separator:ae4ccf79fde59556d93af947618b6c80b inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0495df29dde90577e4702fcac496684 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ac0495df29dde90577e4702fcac496684">refine_uniformly_and_prune</a> (<a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info)</td></tr>
<tr class="memdesc:ac0495df29dde90577e4702fcac496684 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine (all) refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process.  <a href="classoomph_1_1Problem.html#ac0495df29dde90577e4702fcac496684">More...</a><br /></td></tr>
<tr class="separator:ac0495df29dde90577e4702fcac496684 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade208b7d7d8e866d5ba896f03edb1f9a inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ade208b7d7d8e866d5ba896f03edb1f9a">refine_uniformly</a> ()</td></tr>
<tr class="memdesc:ade208b7d7d8e866d5ba896f03edb1f9a inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine (all) refineable (sub)mesh(es) uniformly and rebuild problem.  <a href="classoomph_1_1Problem.html#ade208b7d7d8e866d5ba896f03edb1f9a">More...</a><br /></td></tr>
<tr class="separator:ade208b7d7d8e866d5ba896f03edb1f9a inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d1904dd72eaf71c015470a23caef5f inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a74d1904dd72eaf71c015470a23caef5f">refine_uniformly</a> (const unsigned &amp;i_mesh, <a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info)</td></tr>
<tr class="memdesc:a74d1904dd72eaf71c015470a23caef5f inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do uniform refinement for submesh i_mesh with documentation.  <a href="classoomph_1_1Problem.html#a74d1904dd72eaf71c015470a23caef5f">More...</a><br /></td></tr>
<tr class="separator:a74d1904dd72eaf71c015470a23caef5f inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae401b74b58d6312da32f153b78047d inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#afae401b74b58d6312da32f153b78047d">refine_uniformly</a> (const unsigned &amp;i_mesh)</td></tr>
<tr class="memdesc:afae401b74b58d6312da32f153b78047d inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do uniform refinement for submesh i_mesh without documentation.  <a href="classoomph_1_1Problem.html#afae401b74b58d6312da32f153b78047d">More...</a><br /></td></tr>
<tr class="separator:afae401b74b58d6312da32f153b78047d inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aaea4b1be43f5d4bb187a8c6d3ca16f inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a3aaea4b1be43f5d4bb187a8c6d3ca16f">p_refine_uniformly</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;nrefine_for_mesh)</td></tr>
<tr class="memdesc:a3aaea4b1be43f5d4bb187a8c6d3ca16f inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-refine p-refineable sub-meshes, each as many times as specified in the vector and rebuild problem  <a href="classoomph_1_1Problem.html#a3aaea4b1be43f5d4bb187a8c6d3ca16f">More...</a><br /></td></tr>
<tr class="separator:a3aaea4b1be43f5d4bb187a8c6d3ca16f inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a980d9659db60b113b6d4e7431594b7 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a0a980d9659db60b113b6d4e7431594b7">p_refine_uniformly</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;nrefine_for_mesh, <a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info)</td></tr>
<tr class="memdesc:a0a980d9659db60b113b6d4e7431594b7 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-refine p-refineable sub-meshes, each as many times as specified in the vector and rebuild problem; doc refinement process  <a href="classoomph_1_1Problem.html#a0a980d9659db60b113b6d4e7431594b7">More...</a><br /></td></tr>
<tr class="separator:a0a980d9659db60b113b6d4e7431594b7 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5155b2d5436a95b1ee27f914b4eb8f08 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a5155b2d5436a95b1ee27f914b4eb8f08">p_refine_uniformly_and_prune</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;nrefine_for_mesh)</td></tr>
<tr class="memdesc:a5155b2d5436a95b1ee27f914b4eb8f08 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-refine p-refineable sub-meshes, each as many times as specified in the vector and rebuild problem. Prune after refinements  <a href="classoomph_1_1Problem.html#a5155b2d5436a95b1ee27f914b4eb8f08">More...</a><br /></td></tr>
<tr class="separator:a5155b2d5436a95b1ee27f914b4eb8f08 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfa653ef203edf44cf9b6cf558865e1 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aabfa653ef203edf44cf9b6cf558865e1">p_refine_uniformly_and_prune</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;nrefine_for_mesh, <a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info)</td></tr>
<tr class="memdesc:aabfa653ef203edf44cf9b6cf558865e1 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-refine p-refineable sub-meshes, each as many times as specified in the vector and rebuild problem; doc refinement process  <a href="classoomph_1_1Problem.html#aabfa653ef203edf44cf9b6cf558865e1">More...</a><br /></td></tr>
<tr class="separator:aabfa653ef203edf44cf9b6cf558865e1 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355caf4c06c3b8b5d399115048453921 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a355caf4c06c3b8b5d399115048453921">p_refine_uniformly</a> (<a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info)</td></tr>
<tr class="memdesc:a355caf4c06c3b8b5d399115048453921 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-refine (all) p-refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process.  <a href="classoomph_1_1Problem.html#a355caf4c06c3b8b5d399115048453921">More...</a><br /></td></tr>
<tr class="separator:a355caf4c06c3b8b5d399115048453921 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ff24a4fc923660f2aabfaa763822bf inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a80ff24a4fc923660f2aabfaa763822bf">p_refine_uniformly_and_prune</a> (<a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info)</td></tr>
<tr class="memdesc:a80ff24a4fc923660f2aabfaa763822bf inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-refine (all) p-refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process.  <a href="classoomph_1_1Problem.html#a80ff24a4fc923660f2aabfaa763822bf">More...</a><br /></td></tr>
<tr class="separator:a80ff24a4fc923660f2aabfaa763822bf inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada439afd4d195644e53d6bdbc4b00587 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ada439afd4d195644e53d6bdbc4b00587">p_refine_uniformly</a> ()</td></tr>
<tr class="memdesc:ada439afd4d195644e53d6bdbc4b00587 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-refine (all) p-refineable (sub)mesh(es) uniformly and rebuild problem  <a href="classoomph_1_1Problem.html#ada439afd4d195644e53d6bdbc4b00587">More...</a><br /></td></tr>
<tr class="separator:ada439afd4d195644e53d6bdbc4b00587 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fed27f341b9eb68b5fb3e4673f26f9 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a04fed27f341b9eb68b5fb3e4673f26f9">p_refine_uniformly</a> (const unsigned &amp;i_mesh, <a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info)</td></tr>
<tr class="memdesc:a04fed27f341b9eb68b5fb3e4673f26f9 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do uniform p-refinement for submesh i_mesh with documentation.  <a href="classoomph_1_1Problem.html#a04fed27f341b9eb68b5fb3e4673f26f9">More...</a><br /></td></tr>
<tr class="separator:a04fed27f341b9eb68b5fb3e4673f26f9 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33dbab01dfa53e4d005818a2940085b0 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a33dbab01dfa53e4d005818a2940085b0">p_refine_uniformly</a> (const unsigned &amp;i_mesh)</td></tr>
<tr class="memdesc:a33dbab01dfa53e4d005818a2940085b0 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do uniform p-refinement for submesh i_mesh without documentation.  <a href="classoomph_1_1Problem.html#a33dbab01dfa53e4d005818a2940085b0">More...</a><br /></td></tr>
<tr class="separator:a33dbab01dfa53e4d005818a2940085b0 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bfce034f5b054e78a1c1a15d196aeb inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a88bfce034f5b054e78a1c1a15d196aeb">refine_selected_elements</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;elements_to_be_refined)</td></tr>
<tr class="memdesc:a88bfce034f5b054e78a1c1a15d196aeb inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine (one and only!) mesh by splitting the elements identified by their numbers relative to the problems' only mesh, then rebuild the problem.  <a href="classoomph_1_1Problem.html#a88bfce034f5b054e78a1c1a15d196aeb">More...</a><br /></td></tr>
<tr class="separator:a88bfce034f5b054e78a1c1a15d196aeb inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2274dbc96e0ae3caf20573152d19e7 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#abd2274dbc96e0ae3caf20573152d19e7">refine_selected_elements</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> * &gt; &amp;elements_to_be_refined_pt)</td></tr>
<tr class="memdesc:abd2274dbc96e0ae3caf20573152d19e7 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine (one and only!) mesh by splitting the elements identified by their pointers, then rebuild the problem.  <a href="classoomph_1_1Problem.html#abd2274dbc96e0ae3caf20573152d19e7">More...</a><br /></td></tr>
<tr class="separator:abd2274dbc96e0ae3caf20573152d19e7 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bd42a9612a31041b9d607340c6d68c inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af2bd42a9612a31041b9d607340c6d68c">refine_selected_elements</a> (const unsigned &amp;i_mesh, const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;elements_to_be_refined)</td></tr>
<tr class="memdesc:af2bd42a9612a31041b9d607340c6d68c inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine specified submesh by splitting the elements identified by their numbers relative to the submesh, then rebuild the problem.  <a href="classoomph_1_1Problem.html#af2bd42a9612a31041b9d607340c6d68c">More...</a><br /></td></tr>
<tr class="separator:af2bd42a9612a31041b9d607340c6d68c inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b480e2299c8526b27b09fa45ac20a9 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a77b480e2299c8526b27b09fa45ac20a9">refine_selected_elements</a> (const unsigned &amp;i_mesh, const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> * &gt; &amp;elements_to_be_refined_pt)</td></tr>
<tr class="memdesc:a77b480e2299c8526b27b09fa45ac20a9 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine specified submesh by splitting the elements identified by their pointers, then rebuild the problem.  <a href="classoomph_1_1Problem.html#a77b480e2299c8526b27b09fa45ac20a9">More...</a><br /></td></tr>
<tr class="separator:a77b480e2299c8526b27b09fa45ac20a9 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ab21d4aa86d5f732b1c1a640186386 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a85ab21d4aa86d5f732b1c1a640186386">refine_selected_elements</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt;&gt; &amp;elements_to_be_refined)</td></tr>
<tr class="memdesc:a85ab21d4aa86d5f732b1c1a640186386 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine all submeshes by splitting the elements identified by their numbers relative to each submesh in a <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> of Vectors, then rebuild the problem.  <a href="classoomph_1_1Problem.html#a85ab21d4aa86d5f732b1c1a640186386">More...</a><br /></td></tr>
<tr class="separator:a85ab21d4aa86d5f732b1c1a640186386 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e9f1c3973b5f7a701117a6e145cee9 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a91e9f1c3973b5f7a701117a6e145cee9">refine_selected_elements</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> * &gt;&gt; &amp;elements_to_be_refined_pt)</td></tr>
<tr class="memdesc:a91e9f1c3973b5f7a701117a6e145cee9 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine all submeshes by splitting the elements identified by their pointers within each submesh in a <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> of Vectors, then rebuild the problem.  <a href="classoomph_1_1Problem.html#a91e9f1c3973b5f7a701117a6e145cee9">More...</a><br /></td></tr>
<tr class="separator:a91e9f1c3973b5f7a701117a6e145cee9 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2042cdd88af58eedc66bfaf29b370ff1 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a2042cdd88af58eedc66bfaf29b370ff1">p_refine_selected_elements</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;elements_to_be_refined)</td></tr>
<tr class="memdesc:a2042cdd88af58eedc66bfaf29b370ff1 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-refine (one and only!) mesh by refining the elements identified by their numbers relative to the problems' only mesh, then rebuild the problem.  <a href="classoomph_1_1Problem.html#a2042cdd88af58eedc66bfaf29b370ff1">More...</a><br /></td></tr>
<tr class="separator:a2042cdd88af58eedc66bfaf29b370ff1 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd17da2aa90d68c4fb5120c90b2435d9 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#afd17da2aa90d68c4fb5120c90b2435d9">p_refine_selected_elements</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1PRefineableElement.html">PRefineableElement</a> * &gt; &amp;elements_to_be_refined_pt)</td></tr>
<tr class="memdesc:afd17da2aa90d68c4fb5120c90b2435d9 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-refine (one and only!) mesh by refining the elements identified by their pointers, then rebuild the problem.  <a href="classoomph_1_1Problem.html#afd17da2aa90d68c4fb5120c90b2435d9">More...</a><br /></td></tr>
<tr class="separator:afd17da2aa90d68c4fb5120c90b2435d9 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f7b013945049548f86377e489e23f1 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a86f7b013945049548f86377e489e23f1">p_refine_selected_elements</a> (const unsigned &amp;i_mesh, const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;elements_to_be_refined)</td></tr>
<tr class="memdesc:a86f7b013945049548f86377e489e23f1 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-refine specified submesh by refining the elements identified by their numbers relative to the submesh, then rebuild the problem.  <a href="classoomph_1_1Problem.html#a86f7b013945049548f86377e489e23f1">More...</a><br /></td></tr>
<tr class="separator:a86f7b013945049548f86377e489e23f1 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044b3cb5ffc2953c1990bd602567b99a inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a044b3cb5ffc2953c1990bd602567b99a">p_refine_selected_elements</a> (const unsigned &amp;i_mesh, const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1PRefineableElement.html">PRefineableElement</a> * &gt; &amp;elements_to_be_refined_pt)</td></tr>
<tr class="memdesc:a044b3cb5ffc2953c1990bd602567b99a inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-refine specified submesh by refining the elements identified by their pointers, then rebuild the problem.  <a href="classoomph_1_1Problem.html#a044b3cb5ffc2953c1990bd602567b99a">More...</a><br /></td></tr>
<tr class="separator:a044b3cb5ffc2953c1990bd602567b99a inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2b3bac619ee8270dfcd5f9f334501c inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aef2b3bac619ee8270dfcd5f9f334501c">p_refine_selected_elements</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt;&gt; &amp;elements_to_be_refined)</td></tr>
<tr class="memdesc:aef2b3bac619ee8270dfcd5f9f334501c inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-refine all submeshes by refining the elements identified by their numbers relative to each submesh in a <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> of Vectors, then rebuild the problem.  <a href="classoomph_1_1Problem.html#aef2b3bac619ee8270dfcd5f9f334501c">More...</a><br /></td></tr>
<tr class="separator:aef2b3bac619ee8270dfcd5f9f334501c inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7af48e91e943fb43fce31aa5bdeb505 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aa7af48e91e943fb43fce31aa5bdeb505">p_refine_selected_elements</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1PRefineableElement.html">PRefineableElement</a> * &gt;&gt; &amp;elements_to_be_refined_pt)</td></tr>
<tr class="memdesc:aa7af48e91e943fb43fce31aa5bdeb505 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-refine all submeshes by refining the elements identified by their pointers within each submesh in a <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> of Vectors, then rebuild the problem.  <a href="classoomph_1_1Problem.html#aa7af48e91e943fb43fce31aa5bdeb505">More...</a><br /></td></tr>
<tr class="separator:aa7af48e91e943fb43fce31aa5bdeb505 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dae99dec2f8202887f4e49e175f39c inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a10dae99dec2f8202887f4e49e175f39c">unrefine_uniformly</a> ()</td></tr>
<tr class="memdesc:a10dae99dec2f8202887f4e49e175f39c inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine (all) refineable (sub)mesh(es) uniformly and rebuild problem. Return 0 for success, 1 for failure (if unrefinement has reached the coarsest permitted level)  <a href="classoomph_1_1Problem.html#a10dae99dec2f8202887f4e49e175f39c">More...</a><br /></td></tr>
<tr class="separator:a10dae99dec2f8202887f4e49e175f39c inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd2996d4046e5a6176c92f4abc899d5 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aadd2996d4046e5a6176c92f4abc899d5">unrefine_uniformly</a> (const unsigned &amp;i_mesh)</td></tr>
<tr class="memdesc:aadd2996d4046e5a6176c92f4abc899d5 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do uniform refinement for submesh i_mesh without documentation. Return 0 for success, 1 for failure (if unrefinement has reached the coarsest permitted level)  <a href="classoomph_1_1Problem.html#aadd2996d4046e5a6176c92f4abc899d5">More...</a><br /></td></tr>
<tr class="separator:aadd2996d4046e5a6176c92f4abc899d5 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d8f0ff6813b09f35acbc7a76232397 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a21d8f0ff6813b09f35acbc7a76232397">p_unrefine_uniformly</a> (<a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info)</td></tr>
<tr class="memdesc:a21d8f0ff6813b09f35acbc7a76232397 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-unrefine (all) p-refineable (sub)mesh(es) uniformly and rebuild problem.  <a href="classoomph_1_1Problem.html#a21d8f0ff6813b09f35acbc7a76232397">More...</a><br /></td></tr>
<tr class="separator:a21d8f0ff6813b09f35acbc7a76232397 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706a2845212ece5535260cca6301653d inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a706a2845212ece5535260cca6301653d">p_unrefine_uniformly</a> (const unsigned &amp;i_mesh, <a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info)</td></tr>
<tr class="memdesc:a706a2845212ece5535260cca6301653d inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do uniform p-unrefinement for submesh i_mesh without documentation.  <a href="classoomph_1_1Problem.html#a706a2845212ece5535260cca6301653d">More...</a><br /></td></tr>
<tr class="separator:a706a2845212ece5535260cca6301653d inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4492ec2686c70467cb0cdb4638a45f inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#afc4492ec2686c70467cb0cdb4638a45f">adapt</a> (unsigned &amp;n_refined, unsigned &amp;n_unrefined)</td></tr>
<tr class="memdesc:afc4492ec2686c70467cb0cdb4638a45f inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt problem: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on their own error estimates and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-assign equation numbers. Return # of refined/unrefined elements. On return from this function, <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> can immediately be solved again.  <a href="classoomph_1_1Problem.html#afc4492ec2686c70467cb0cdb4638a45f">More...</a><br /></td></tr>
<tr class="separator:afc4492ec2686c70467cb0cdb4638a45f inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9e09ddfa2411f14fc723c3207decd1 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a0b9e09ddfa2411f14fc723c3207decd1">adapt</a> ()</td></tr>
<tr class="memdesc:a0b9e09ddfa2411f14fc723c3207decd1 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt problem: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on their own error estimates and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-assign equation numbers. On return from this function, <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> can immediately be solved again. [Argument-free wrapper].  <a href="classoomph_1_1Problem.html#a0b9e09ddfa2411f14fc723c3207decd1">More...</a><br /></td></tr>
<tr class="separator:a0b9e09ddfa2411f14fc723c3207decd1 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1303b2fde2fe84b71519cadabc18f868 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a1303b2fde2fe84b71519cadabc18f868">p_adapt</a> (unsigned &amp;n_refined, unsigned &amp;n_unrefined)</td></tr>
<tr class="memdesc:a1303b2fde2fe84b71519cadabc18f868 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-adapt problem: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on their own error estimates and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-assign equation numbers. Return # of refined/unrefined elements. On return from this function, <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> can immediately be solved again.  <a href="classoomph_1_1Problem.html#a1303b2fde2fe84b71519cadabc18f868">More...</a><br /></td></tr>
<tr class="separator:a1303b2fde2fe84b71519cadabc18f868 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad4443f87f3f3affe53fa9160802e7c inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aaad4443f87f3f3affe53fa9160802e7c">p_adapt</a> ()</td></tr>
<tr class="memdesc:aaad4443f87f3f3affe53fa9160802e7c inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-adapt problem: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on their own error estimates and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-assign equation numbers. On return from this function, <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> can immediately be solved again. [Argument-free wrapper]  <a href="classoomph_1_1Problem.html#aaad4443f87f3f3affe53fa9160802e7c">More...</a><br /></td></tr>
<tr class="separator:aaad4443f87f3f3affe53fa9160802e7c inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e7b874e120c2a3a89e227ad48e14c9 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af5e7b874e120c2a3a89e227ad48e14c9">adapt_based_on_error_estimates</a> (unsigned &amp;n_refined, unsigned &amp;n_unrefined, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt;&gt; &amp;elemental_error)</td></tr>
<tr class="memdesc:af5e7b874e120c2a3a89e227ad48e14c9 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt problem: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on the error estimates in elemental_error and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-assign equation numbers. Return # of refined/unrefined elements. On return from this function, <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> can immediately be solved again.  <a href="classoomph_1_1Problem.html#af5e7b874e120c2a3a89e227ad48e14c9">More...</a><br /></td></tr>
<tr class="separator:af5e7b874e120c2a3a89e227ad48e14c9 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3809e4ec25082a5b8686bd6fa1c61fce inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a3809e4ec25082a5b8686bd6fa1c61fce">adapt_based_on_error_estimates</a> (<a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt;&gt; &amp;elemental_error)</td></tr>
<tr class="memdesc:a3809e4ec25082a5b8686bd6fa1c61fce inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt problem: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on the error estimates in elemental_error and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-assign equation numbers. Return # of refined/unrefined elements. On return from this function, <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> can immediately be solved again. [Wrapper without n_refined and n_unrefined arguments].  <a href="classoomph_1_1Problem.html#a3809e4ec25082a5b8686bd6fa1c61fce">More...</a><br /></td></tr>
<tr class="separator:a3809e4ec25082a5b8686bd6fa1c61fce inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d29f621a3be66430960538c7c24a78 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af0d29f621a3be66430960538c7c24a78">get_all_error_estimates</a> (<a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt;&gt; &amp;elemental_error)</td></tr>
<tr class="memdesc:af0d29f621a3be66430960538c7c24a78 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the error estimates computed by (all) refineable (sub)mesh(es) in the elemental_error structure, which consists of a vector of vectors of elemental errors, one vector for each (sub)mesh.  <a href="classoomph_1_1Problem.html#af0d29f621a3be66430960538c7c24a78">More...</a><br /></td></tr>
<tr class="separator:af0d29f621a3be66430960538c7c24a78 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a77519885ccb13e4644c89b19c37a7 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af2a77519885ccb13e4644c89b19c37a7">doc_errors</a> (<a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;doc_info)</td></tr>
<tr class="memdesc:af2a77519885ccb13e4644c89b19c37a7 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get max and min error for all elements in submeshes.  <a href="classoomph_1_1Problem.html#af2a77519885ccb13e4644c89b19c37a7">More...</a><br /></td></tr>
<tr class="separator:af2a77519885ccb13e4644c89b19c37a7 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a9dfdb7b4f95bb941d48411f955f55 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af2a9dfdb7b4f95bb941d48411f955f55">doc_errors</a> ()</td></tr>
<tr class="memdesc:af2a9dfdb7b4f95bb941d48411f955f55 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get max and min error for all elements in submeshes.  <a href="classoomph_1_1Problem.html#af2a9dfdb7b4f95bb941d48411f955f55">More...</a><br /></td></tr>
<tr class="separator:af2a9dfdb7b4f95bb941d48411f955f55 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3226bf49118c8a4f02dbe01d22428f20 inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a3226bf49118c8a4f02dbe01d22428f20">enable_info_in_newton_solve</a> ()</td></tr>
<tr class="memdesc:a3226bf49118c8a4f02dbe01d22428f20 inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the output of information when in the newton solver (Default)  <a href="classoomph_1_1Problem.html#a3226bf49118c8a4f02dbe01d22428f20">More...</a><br /></td></tr>
<tr class="separator:a3226bf49118c8a4f02dbe01d22428f20 inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00e3623681347439fe3dac650423bbe inherit pub_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af00e3623681347439fe3dac650423bbe">disable_info_in_newton_solve</a> ()</td></tr>
<tr class="memdesc:af00e3623681347439fe3dac650423bbe inherit pub_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the output of information when in the newton solver.  <a href="classoomph_1_1Problem.html#af00e3623681347439fe3dac650423bbe">More...</a><br /></td></tr>
<tr class="separator:af00e3623681347439fe3dac650423bbe inherit pub_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classoomph_1_1ExplicitTimeSteppableObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classoomph_1_1ExplicitTimeSteppableObject.html">oomph::ExplicitTimeSteppableObject</a></td></tr>
<tr class="memitem:a07e82e7df9f289fc59fbf5ac438ad068 inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1ExplicitTimeSteppableObject.html#a07e82e7df9f289fc59fbf5ac438ad068">ExplicitTimeSteppableObject</a> ()</td></tr>
<tr class="memdesc:a07e82e7df9f289fc59fbf5ac438ad068 inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="classoomph_1_1ExplicitTimeSteppableObject.html#a07e82e7df9f289fc59fbf5ac438ad068">More...</a><br /></td></tr>
<tr class="separator:a07e82e7df9f289fc59fbf5ac438ad068 inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e1d1c57792a5540f0d31f3b36b4d7b inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1ExplicitTimeSteppableObject.html#af9e1d1c57792a5540f0d31f3b36b4d7b">ExplicitTimeSteppableObject</a> (const <a class="el" href="classoomph_1_1ExplicitTimeSteppableObject.html">ExplicitTimeSteppableObject</a> &amp;)=delete</td></tr>
<tr class="memdesc:af9e1d1c57792a5540f0d31f3b36b4d7b inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broken copy constructor.  <a href="classoomph_1_1ExplicitTimeSteppableObject.html#af9e1d1c57792a5540f0d31f3b36b4d7b">More...</a><br /></td></tr>
<tr class="separator:af9e1d1c57792a5540f0d31f3b36b4d7b inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c2f447b67a0afd64e910b558ac6f90 inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1ExplicitTimeSteppableObject.html#a85c2f447b67a0afd64e910b558ac6f90">operator=</a> (const <a class="el" href="classoomph_1_1ExplicitTimeSteppableObject.html">ExplicitTimeSteppableObject</a> &amp;)=delete</td></tr>
<tr class="memdesc:a85c2f447b67a0afd64e910b558ac6f90 inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broken assignment operator.  <a href="classoomph_1_1ExplicitTimeSteppableObject.html#a85c2f447b67a0afd64e910b558ac6f90">More...</a><br /></td></tr>
<tr class="separator:a85c2f447b67a0afd64e910b558ac6f90 inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed68ad4da79ddfdc5b545fa62292304 inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1ExplicitTimeSteppableObject.html#a0ed68ad4da79ddfdc5b545fa62292304">~ExplicitTimeSteppableObject</a> ()</td></tr>
<tr class="memdesc:a0ed68ad4da79ddfdc5b545fa62292304 inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty destructor.  <a href="classoomph_1_1ExplicitTimeSteppableObject.html#a0ed68ad4da79ddfdc5b545fa62292304">More...</a><br /></td></tr>
<tr class="separator:a0ed68ad4da79ddfdc5b545fa62292304 inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74eb2ebff3fc3066edccdfe4d3b6bc07 inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1ExplicitTimeSteppableObject.html#a74eb2ebff3fc3066edccdfe4d3b6bc07">actions_before_explicit_stage</a> ()</td></tr>
<tr class="memdesc:a74eb2ebff3fc3066edccdfe4d3b6bc07 inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty virtual function to do anything needed before a stage of an explicit time step (Runge-Kutta steps contain multiple stages per time step, most others only contain one).  <a href="classoomph_1_1ExplicitTimeSteppableObject.html#a74eb2ebff3fc3066edccdfe4d3b6bc07">More...</a><br /></td></tr>
<tr class="separator:a74eb2ebff3fc3066edccdfe4d3b6bc07 inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1eb700abad36e868a84c475f9866b7d inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1ExplicitTimeSteppableObject.html#ad1eb700abad36e868a84c475f9866b7d">actions_after_explicit_stage</a> ()</td></tr>
<tr class="memdesc:ad1eb700abad36e868a84c475f9866b7d inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty virtual function that should be overloaded to update any dependent data or boundary conditions that should be advanced after each stage of an explicit time step (Runge-Kutta steps contain multiple stages per time step, most others only contain one).  <a href="classoomph_1_1ExplicitTimeSteppableObject.html#ad1eb700abad36e868a84c475f9866b7d">More...</a><br /></td></tr>
<tr class="separator:ad1eb700abad36e868a84c475f9866b7d inherit pub_methods_classoomph_1_1ExplicitTimeSteppableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1a00fff232d2438c83b66437d8e86aab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1BiharmonicFluidProblem.html#a1a00fff232d2438c83b66437d8e86aab">impose_solid_boundary_on_edge</a> (const unsigned &amp;b, const double &amp;psi=0)</td></tr>
<tr class="memdesc:a1a00fff232d2438c83b66437d8e86aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imposes a solid boundary on boundary b - no flow into boundary or along boundary v_n = 0 and v_t = 0. User must presribe the streamfunction psi to ensure dpsi/dt = 0 is imposed at all points on the boundary and not just at the nodes.  <a href="classoomph_1_1BiharmonicFluidProblem.html#a1a00fff232d2438c83b66437d8e86aab">More...</a><br /></td></tr>
<tr class="separator:a1a00fff232d2438c83b66437d8e86aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc57555bbd0ceef1d93010c133ac597"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1BiharmonicFluidProblem.html#a1cc57555bbd0ceef1d93010c133ac597">impose_traction_free_edge</a> (const unsigned &amp;b)</td></tr>
<tr class="memdesc:a1cc57555bbd0ceef1d93010c133ac597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a traction free edge - i.e. v_t = 0 or dpsi/dn = 0. In general dpsi/dn = 0 can only be imposed using equation elements to set the DOFs dpsi/ds_n, however in the special case of dt/ds_n = 0, then dpsi/ds_n = 0 and can be imposed using pinning - this is handled automatically in this function. For a more detailed description of the equations see the description of the class <a class="el" href="classoomph_1_1BiharmonicFluidBoundaryElement.html" title="Point equation element used to impose the traction free edge (i.e. du/dn = 0) on the boundary when dt...">BiharmonicFluidBoundaryElement</a>.  <a href="classoomph_1_1BiharmonicFluidProblem.html#a1cc57555bbd0ceef1d93010c133ac597">More...</a><br /></td></tr>
<tr class="separator:a1cc57555bbd0ceef1d93010c133ac597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1006320d9024555042645ed6347ff8fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1BiharmonicFluidProblem.html#a1006320d9024555042645ed6347ff8fb">impose_fluid_flow_on_edge</a> (const unsigned &amp;b, <a class="el" href="classoomph_1_1BiharmonicFluidProblem.html#a93661d3b0c52bd82fd58496f9f853079">FluidBCFctPt</a> u_imposed_fn)</td></tr>
<tr class="memdesc:a1006320d9024555042645ed6347ff8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a prescribed fluid flow comprising the velocity normal to the boundary (u_imposed_fn[0]) and the velocity tangential to the boundary (u_imposed_fn[1])  <a href="classoomph_1_1BiharmonicFluidProblem.html#a1006320d9024555042645ed6347ff8fb">More...</a><br /></td></tr>
<tr class="separator:a1006320d9024555042645ed6347ff8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classoomph_1_1Problem"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classoomph_1_1Problem')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classoomph_1_1Problem.html">oomph::Problem</a></td></tr>
<tr class="memitem:a919a5f4752362df6005d24e51b5780e0 inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a919a5f4752362df6005d24e51b5780e0">setup_element_count_per_dof</a> ()</td></tr>
<tr class="memdesc:a919a5f4752362df6005d24e51b5780e0 inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that populates the Element_counter_per_dof vector with the number of elements that contribute to each dof. For example, with linear elements in 1D each dof contains contributions from two elements apart from those on the boundary. Returns the total number of elements in the problem.  <a href="classoomph_1_1Problem.html#a919a5f4752362df6005d24e51b5780e0">More...</a><br /></td></tr>
<tr class="separator:a919a5f4752362df6005d24e51b5780e0 inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216679e2a976e0205165bbe7ab558579 inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a216679e2a976e0205165bbe7ab558579">setup_dof_halo_scheme</a> ()</td></tr>
<tr class="memdesc:a216679e2a976e0205165bbe7ab558579 inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that is used to setup the halo scheme.  <a href="classoomph_1_1Problem.html#a216679e2a976e0205165bbe7ab558579">More...</a><br /></td></tr>
<tr class="separator:a216679e2a976e0205165bbe7ab558579 inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072f2894b20672be1a48783684c4a50b inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a072f2894b20672be1a48783684c4a50b">sparse_assemble_row_or_column_compressed</a> (<a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int * &gt; &amp;column_or_row_index, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int * &gt; &amp;row_or_column_start, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double * &gt; &amp;value, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;nnz, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double * &gt; &amp;residual, bool compressed_row_flag)</td></tr>
<tr class="memdesc:a072f2894b20672be1a48783684c4a50b inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected helper function that is used to assemble the Jacobian matrix in the case when the storage is row or column compressed. The boolean Flag indicates if we want compressed row format (true) or compressed column.  <a href="classoomph_1_1Problem.html#a072f2894b20672be1a48783684c4a50b">More...</a><br /></td></tr>
<tr class="separator:a072f2894b20672be1a48783684c4a50b inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ad96ddf5d48b517b89c9a9b879bc4b inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ae6ad96ddf5d48b517b89c9a9b879bc4b">actions_before_newton_convergence_check</a> ()</td></tr>
<tr class="memdesc:ae6ad96ddf5d48b517b89c9a9b879bc4b inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any actions that are to be performed before the residual is checked in the Newton method, e.g. update any boundary conditions that depend upon variables of the problem; update any &lsquo;dependent&rsquo; variables; or perform an update of the nodal positions in SpineMeshes etc. CAREFUL: This step should (and if the FD-based <a class="el" href="classoomph_1_1LinearSolver.html" title="Base class for all linear solvers. This merely defines standard interfaces for linear solvers,...">LinearSolver</a> <a class="el" href="classoomph_1_1FD__LU.html" title="Dense LU decomposition-based solve of linear system assembled via finite differencing of the residual...">FD_LU</a> is used, must) only update values that are pinned!  <a href="classoomph_1_1Problem.html#ae6ad96ddf5d48b517b89c9a9b879bc4b">More...</a><br /></td></tr>
<tr class="separator:ae6ad96ddf5d48b517b89c9a9b879bc4b inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fc81781c74b25c8a426ec18295b0d0 inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a07fc81781c74b25c8a426ec18295b0d0">actions_before_newton_step</a> ()</td></tr>
<tr class="memdesc:a07fc81781c74b25c8a426ec18295b0d0 inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any actions that are to be performed before each individual Newton step. Most likely to be used for diagnostic purposes to doc the solution during a non-converging iteration, say.  <a href="classoomph_1_1Problem.html#a07fc81781c74b25c8a426ec18295b0d0">More...</a><br /></td></tr>
<tr class="separator:a07fc81781c74b25c8a426ec18295b0d0 inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8bc6e7b0bb45b86d5b44737b554d50 inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aed8bc6e7b0bb45b86d5b44737b554d50">actions_after_newton_step</a> ()</td></tr>
<tr class="memdesc:aed8bc6e7b0bb45b86d5b44737b554d50 inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any actions that are to be performed after each individual Newton step. Most likely to be used for diagnostic purposes to doc the solution during a non-converging iteration, say.  <a href="classoomph_1_1Problem.html#aed8bc6e7b0bb45b86d5b44737b554d50">More...</a><br /></td></tr>
<tr class="separator:aed8bc6e7b0bb45b86d5b44737b554d50 inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f19896906d2c0274ad6798cd3ac38dc inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a4f19896906d2c0274ad6798cd3ac38dc">actions_before_implicit_timestep</a> ()</td></tr>
<tr class="memdesc:a4f19896906d2c0274ad6798cd3ac38dc inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions that should be performed before each implicit time step. This is needed when one wants to solve a steady problem before timestepping and needs to distinguish between the two cases.  <a href="classoomph_1_1Problem.html#a4f19896906d2c0274ad6798cd3ac38dc">More...</a><br /></td></tr>
<tr class="separator:a4f19896906d2c0274ad6798cd3ac38dc inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012692496c968960f4ea27db4e89cc7d inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a012692496c968960f4ea27db4e89cc7d">actions_after_implicit_timestep</a> ()</td></tr>
<tr class="memdesc:a012692496c968960f4ea27db4e89cc7d inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions that should be performed after each implicit time step. This is needed when one wants to solve a steady problem before timestepping and needs to distinguish between the two cases.  <a href="classoomph_1_1Problem.html#a012692496c968960f4ea27db4e89cc7d">More...</a><br /></td></tr>
<tr class="separator:a012692496c968960f4ea27db4e89cc7d inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d914a74e7998ddc74c205884d36d57 inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a38d914a74e7998ddc74c205884d36d57">actions_after_implicit_timestep_and_error_estimation</a> ()</td></tr>
<tr class="memdesc:a38d914a74e7998ddc74c205884d36d57 inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions that should be performed after each implicit time step. This is needed if your <a class="el" href="classoomph_1_1Problem.html#a012692496c968960f4ea27db4e89cc7d" title="Actions that should be performed after each implicit time step. This is needed when one wants to solv...">actions_after_implicit_timestep()</a> modify the solution in a way that affects the error estimate.  <a href="classoomph_1_1Problem.html#a38d914a74e7998ddc74c205884d36d57">More...</a><br /></td></tr>
<tr class="separator:a38d914a74e7998ddc74c205884d36d57 inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae06bc0ecba349ebdf76220c1a17546 inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a6ae06bc0ecba349ebdf76220c1a17546">actions_before_explicit_timestep</a> ()</td></tr>
<tr class="memdesc:a6ae06bc0ecba349ebdf76220c1a17546 inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions that should be performed before each explicit time step.  <a href="classoomph_1_1Problem.html#a6ae06bc0ecba349ebdf76220c1a17546">More...</a><br /></td></tr>
<tr class="separator:a6ae06bc0ecba349ebdf76220c1a17546 inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bfd872c45467a65ce977f3753a6d1d inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a51bfd872c45467a65ce977f3753a6d1d">actions_after_explicit_timestep</a> ()</td></tr>
<tr class="memdesc:a51bfd872c45467a65ce977f3753a6d1d inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions that should be performed after each explicit time step.  <a href="classoomph_1_1Problem.html#a51bfd872c45467a65ce977f3753a6d1d">More...</a><br /></td></tr>
<tr class="separator:a51bfd872c45467a65ce977f3753a6d1d inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10662119a7a0c3a47879fa0d0644452 inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af10662119a7a0c3a47879fa0d0644452">actions_before_read_unstructured_meshes</a> ()</td></tr>
<tr class="memdesc:af10662119a7a0c3a47879fa0d0644452 inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions that are to be performed before reading in restart data for problems involving unstructured bulk meshes. If the problem contains such meshes we need to strip out any face elements that are attached to them because restart of unstructured meshes re-creates their elements and nodes from scratch, leading to dangling pointers from the face elements to the old elements and nodes. This function is virtual and (practically) empty but toggles a flag to indicate that it has been called. This is used to issue a warning, prompting the user to consider overloading it if the problem is found to contain unstructured bulk meshes during restarts.  <a href="classoomph_1_1Problem.html#af10662119a7a0c3a47879fa0d0644452">More...</a><br /></td></tr>
<tr class="separator:af10662119a7a0c3a47879fa0d0644452 inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498317b3e390eddf2169ab989ee8d6b4 inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a498317b3e390eddf2169ab989ee8d6b4">actions_after_read_unstructured_meshes</a> ()</td></tr>
<tr class="memdesc:a498317b3e390eddf2169ab989ee8d6b4 inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions that are to be performed before reading in restart data for problems involving unstructured bulk meshes. Typically used to re-attach FaceElements, say, that were stripped out in <a class="el" href="classoomph_1_1Problem.html#af10662119a7a0c3a47879fa0d0644452" title="Actions that are to be performed before reading in restart data for problems involving unstructured b...">actions_before_read_unstructured_meshes()</a>. This function is virtual and (practically) empty but toggles a flag to indicate that it has been called. This is used to issue a warning, prompting the user to consider overloading it if the problem is found to contain unstructured bulk meshes during restarts.  <a href="classoomph_1_1Problem.html#a498317b3e390eddf2169ab989ee8d6b4">More...</a><br /></td></tr>
<tr class="separator:a498317b3e390eddf2169ab989ee8d6b4 inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1280f442f9352a614bada21324456d inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a1d1280f442f9352a614bada21324456d">actions_before_distribute</a> ()</td></tr>
<tr class="memdesc:a1d1280f442f9352a614bada21324456d inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions to be performed before a (mesh) distribution.  <a href="classoomph_1_1Problem.html#a1d1280f442f9352a614bada21324456d">More...</a><br /></td></tr>
<tr class="separator:a1d1280f442f9352a614bada21324456d inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3e3bd312518ca5afef94e169f81c39 inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a4d3e3bd312518ca5afef94e169f81c39">actions_after_distribute</a> ()</td></tr>
<tr class="memdesc:a4d3e3bd312518ca5afef94e169f81c39 inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions to be performed after a (mesh) distribution.  <a href="classoomph_1_1Problem.html#a4d3e3bd312518ca5afef94e169f81c39">More...</a><br /></td></tr>
<tr class="separator:a4d3e3bd312518ca5afef94e169f81c39 inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e90bbe5d279295b97ae704487259bcc inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a1e90bbe5d279295b97ae704487259bcc">actions_after_change_in_global_parameter</a> (double *const &amp;parameter_pt)</td></tr>
<tr class="memdesc:a1e90bbe5d279295b97ae704487259bcc inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions that are to be performed when the global parameter addressed by parameter_pt has been changed in the function <a class="el" href="classoomph_1_1Problem.html#af4d959a47ef6a8d50b394a6761dfab5a" title="Get the derivative of the entire residuals vector wrt a global parameter, used in continuation proble...">get_derivative_wrt_global_parameter()</a> The default is to call <a class="el" href="classoomph_1_1Problem.html#a0c8d70891f7369bb4bf8412fa1a08ecb" title="Any actions that are to be performed before a complete Newton solve (e.g. adjust boundary conditions)...">actions_before_newton_solve()</a>, <a class="el" href="classoomph_1_1Problem.html#ae6ad96ddf5d48b517b89c9a9b879bc4b" title="Any actions that are to be performed before the residual is checked in the Newton method,...">actions_before_newton_convergence_check()</a> and <a class="el" href="classoomph_1_1Problem.html#a033ec7301123deeb7e56d04c38f9f1da" title="Any actions that are to be performed after a complete Newton solve, e.g. post processing....">actions_after_newton_solve()</a>. This could be amazingly inefficient in certain problems and should be overloaded in such cases. An example would be when a remesh is required in general, but the global parameter does not affect the mesh directly.  <a href="classoomph_1_1Problem.html#a1e90bbe5d279295b97ae704487259bcc">More...</a><br /></td></tr>
<tr class="separator:a1e90bbe5d279295b97ae704487259bcc inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f08629e3c9c72b441ec7f19f175b2c7 inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a5f08629e3c9c72b441ec7f19f175b2c7">actions_after_change_in_bifurcation_parameter</a> ()</td></tr>
<tr class="memdesc:a5f08629e3c9c72b441ec7f19f175b2c7 inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions that are to be performed after a change in the parameter that is being varied as part of the solution of a bifurcation detection problem. The default is to call <a class="el" href="classoomph_1_1Problem.html#a0c8d70891f7369bb4bf8412fa1a08ecb" title="Any actions that are to be performed before a complete Newton solve (e.g. adjust boundary conditions)...">actions_before_newton_solve()</a>, <a class="el" href="classoomph_1_1Problem.html#ae6ad96ddf5d48b517b89c9a9b879bc4b" title="Any actions that are to be performed before the residual is checked in the Newton method,...">actions_before_newton_convergence_check()</a> and <a class="el" href="classoomph_1_1Problem.html#a033ec7301123deeb7e56d04c38f9f1da" title="Any actions that are to be performed after a complete Newton solve, e.g. post processing....">actions_after_newton_solve()</a>. This could be amazingly inefficient in certain problems and should be overloaded in such cases. An example would be when a remesh is required in general, but the global parameter does not affect the mesh directly.  <a href="classoomph_1_1Problem.html#a5f08629e3c9c72b441ec7f19f175b2c7">More...</a><br /></td></tr>
<tr class="separator:a5f08629e3c9c72b441ec7f19f175b2c7 inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e18ddf6073f9debd478f6b21a717de inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a54e18ddf6073f9debd478f6b21a717de">actions_after_parameter_increase</a> (double *const &amp;parameter_pt)</td></tr>
<tr class="memdesc:a54e18ddf6073f9debd478f6b21a717de inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty virtual function; provides hook to perform actions after the increase in the arclength parameter (during continuation)  <a href="classoomph_1_1Problem.html#a54e18ddf6073f9debd478f6b21a717de">More...</a><br /></td></tr>
<tr class="separator:a54e18ddf6073f9debd478f6b21a717de inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6df5fb0d282f25df1e94a665dd838e5 inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ad6df5fb0d282f25df1e94a665dd838e5">dof_derivative</a> (const unsigned &amp;<a class="el" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>)</td></tr>
<tr class="memdesc:ad6df5fb0d282f25df1e94a665dd838e5 inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function to the derivative of the i-th (local) dof with respect to the arc length, used in continuation.  <a href="classoomph_1_1Problem.html#ad6df5fb0d282f25df1e94a665dd838e5">More...</a><br /></td></tr>
<tr class="separator:ad6df5fb0d282f25df1e94a665dd838e5 inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fd6457ceceb02a0e11d860ac0017c5 inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a10fd6457ceceb02a0e11d860ac0017c5">dof_current</a> (const unsigned &amp;<a class="el" href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a>)</td></tr>
<tr class="memdesc:a10fd6457ceceb02a0e11d860ac0017c5 inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function to the current value of the i-th (local) dof at the start of a continuation step.  <a href="classoomph_1_1Problem.html#a10fd6457ceceb02a0e11d860ac0017c5">More...</a><br /></td></tr>
<tr class="separator:a10fd6457ceceb02a0e11d860ac0017c5 inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48be6d67071f7da5f6feb7c4fc918f0 inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ad48be6d67071f7da5f6feb7c4fc918f0">set_initial_condition</a> ()</td></tr>
<tr class="memdesc:ad48be6d67071f7da5f6feb7c4fc918f0 inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set initial condition (incl previous timesteps). We need to establish this interface because I.C. needs to be reset when problem is adapted during the first timestep.  <a href="classoomph_1_1Problem.html#ad48be6d67071f7da5f6feb7c4fc918f0">More...</a><br /></td></tr>
<tr class="separator:ad48be6d67071f7da5f6feb7c4fc918f0 inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7667864b71a3889c95c29307422ac8e inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ac7667864b71a3889c95c29307422ac8e">global_temporal_error_norm</a> ()</td></tr>
<tr class="memdesc:ac7667864b71a3889c95c29307422ac8e inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate a global error norm, used in adaptive timestepping to control the change in timestep. Individual errors for each data object can be obtained via the data timestepper's temporal_error_in_value or temporal_error_in_position functions and should be combined to construct a global norm. For example, in fluids problems a suitable norm is usually the weighted sum of the errors in the velocities; for moving mesh problems is it usually better to use the weighted sum of the errors in position.  <a href="classoomph_1_1Problem.html#ac7667864b71a3889c95c29307422ac8e">More...</a><br /></td></tr>
<tr class="separator:ac7667864b71a3889c95c29307422ac8e inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0efdeb4814de433fa2ffb3065831ce inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aea0efdeb4814de433fa2ffb3065831ce">newton_solve_continuation</a> (double *const &amp;parameter_pt)</td></tr>
<tr class="memdesc:aea0efdeb4814de433fa2ffb3065831ce inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a basic arc-length continuation step using Newton's method. Returns number of Newton steps taken.  <a href="classoomph_1_1Problem.html#aea0efdeb4814de433fa2ffb3065831ce">More...</a><br /></td></tr>
<tr class="separator:aea0efdeb4814de433fa2ffb3065831ce inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa539429593ad9ffe3a400a72db2063bd inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aa539429593ad9ffe3a400a72db2063bd">newton_solve_continuation</a> (double *const &amp;parameter_pt, <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;z)</td></tr>
<tr class="memdesc:aa539429593ad9ffe3a400a72db2063bd inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a basic continuation step using the Newton method. The number of Newton steps taken is returned, to be used in any external step-size control routines. The governing parameter of the problem is passed as a pointer to the routine, as is a vector in which to store the derivatives wrt the parameter, if required.  <a href="classoomph_1_1Problem.html#aa539429593ad9ffe3a400a72db2063bd">More...</a><br /></td></tr>
<tr class="separator:aa539429593ad9ffe3a400a72db2063bd inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f16ae8f6da042d40fddf01ee3ebd31 inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a58f16ae8f6da042d40fddf01ee3ebd31">calculate_continuation_derivatives</a> (double *const &amp;parameter_pt)</td></tr>
<tr class="memdesc:a58f16ae8f6da042d40fddf01ee3ebd31 inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to calculate the derivatives wrt the arc-length. This version of the function actually does a linear solve so that the derivatives are calculated "exactly" rather than using the values at the Newton step just before convergence. This is necessary in spatially adaptive problems, in which the number of degrees of freedom changes and so the appropriate derivatives must be calculated for the new variables. This function is called if no Newton steps were taken in the continuation routine ... i.e. the initial residuals were sufficiently small.  <a href="classoomph_1_1Problem.html#a58f16ae8f6da042d40fddf01ee3ebd31">More...</a><br /></td></tr>
<tr class="separator:a58f16ae8f6da042d40fddf01ee3ebd31 inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58edae16dc24830521b0df67452db1f7 inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a58edae16dc24830521b0df67452db1f7">calculate_continuation_derivatives</a> (const <a class="el" href="classoomph_1_1DoubleVector.html">DoubleVector</a> &amp;z)</td></tr>
<tr class="memdesc:a58edae16dc24830521b0df67452db1f7 inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to calculate the derivatives with respect to the arc-length required for continuation. The arguments is the solution of the linear system, Jz = dR/dparameter, that gives du/dparameter and the direction output from the newton_solve_continuation function. The derivatives are stored in the ContinuationParameters namespace.  <a href="classoomph_1_1Problem.html#a58edae16dc24830521b0df67452db1f7">More...</a><br /></td></tr>
<tr class="separator:a58edae16dc24830521b0df67452db1f7 inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc838287129a35ef60e38ea854b939c inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#addc838287129a35ef60e38ea854b939c">calculate_continuation_derivatives_fd</a> (double *const &amp;parameter_pt)</td></tr>
<tr class="memdesc:addc838287129a35ef60e38ea854b939c inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to calculate the derivatives with respect to the arc-length required for continuation by finite differences, using the previous values of the solution. The derivatives are stored in the ContinuationParameters namespace.  <a href="classoomph_1_1Problem.html#addc838287129a35ef60e38ea854b939c">More...</a><br /></td></tr>
<tr class="separator:addc838287129a35ef60e38ea854b939c inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a83b109e7662abd52ea552d89163cc inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af7a83b109e7662abd52ea552d89163cc">does_pointer_correspond_to_problem_data</a> (double *const &amp;parameter_pt)</td></tr>
<tr class="memdesc:af7a83b109e7662abd52ea552d89163cc inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean flag to indicate whether the pointer parameter_pt refers to values stored in a <a class="el" href="classoomph_1_1Data.html" title="A class that represents a collection of data; each Data object may contain many different individual ...">Data</a> object that is contained within the problem.  <a href="classoomph_1_1Problem.html#af7a83b109e7662abd52ea552d89163cc">More...</a><br /></td></tr>
<tr class="separator:af7a83b109e7662abd52ea552d89163cc inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9494223b38728ea186a68d6c70b7ebd4 inherit pro_methods_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a9494223b38728ea186a68d6c70b7ebd4">set_consistent_pinned_values_for_continuation</a> ()</td></tr>
<tr class="memdesc:a9494223b38728ea186a68d6c70b7ebd4 inherit pro_methods_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function that is used to set the appropriate pinned values for continuation.  <a href="classoomph_1_1Problem.html#a9494223b38728ea186a68d6c70b7ebd4">More...</a><br /></td></tr>
<tr class="separator:a9494223b38728ea186a68d6c70b7ebd4 inherit pro_methods_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a2dd20deeccc884a3859577a0b7f636e9"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1BiharmonicFluidProblem.html#a2dd20deeccc884a3859577a0b7f636e9">Npoint_element</a></td></tr>
<tr class="separator:a2dd20deeccc884a3859577a0b7f636e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classoomph_1_1Problem"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classoomph_1_1Problem')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classoomph_1_1Problem.html">oomph::Problem</a></td></tr>
<tr class="memitem:aeadae1fc5f49e66223ee09c69a9e506d inherit pub_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aeadae1fc5f49e66223ee09c69a9e506d">Max_permitted_error_for_halo_check</a></td></tr>
<tr class="memdesc:aeadae1fc5f49e66223ee09c69a9e506d inherit pub_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threshold for error throwing in <a class="el" href="classoomph_1_1Problem.html#a8dd5cb241ce6218fb476931e0879d7c8" title="Check the halo/haloed node/element schemes.">Problem::check_halo_schemes()</a>  <a href="classoomph_1_1Problem.html#aeadae1fc5f49e66223ee09c69a9e506d">More...</a><br /></td></tr>
<tr class="separator:aeadae1fc5f49e66223ee09c69a9e506d inherit pub_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a3743c23a2d1eed56981484636c958 inherit pub_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ab4a3743c23a2d1eed56981484636c958">Shut_up_in_newton_solve</a></td></tr>
<tr class="memdesc:ab4a3743c23a2d1eed56981484636c958 inherit pub_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean to indicate if all output is suppressed in <a class="el" href="classoomph_1_1Problem.html#a62a989ae9a9169b9d905f844db59787f" title="Use Newton method to solve the problem.">Problem::newton_solve()</a>. Defaults to false.  <a href="classoomph_1_1Problem.html#ab4a3743c23a2d1eed56981484636c958">More...</a><br /></td></tr>
<tr class="separator:ab4a3743c23a2d1eed56981484636c958 inherit pub_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classoomph_1_1Problem"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classoomph_1_1Problem')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classoomph_1_1Problem.html">oomph::Problem</a></td></tr>
<tr class="memitem:a223a45fe6b1c80ee0109037b63e162f9 inherit pub_static_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a223a45fe6b1c80ee0109037b63e162f9">Suppress_warning_about_actions_before_read_unstructured_meshes</a></td></tr>
<tr class="memdesc:a223a45fe6b1c80ee0109037b63e162f9 inherit pub_static_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to allow suppression of warning messages re reading in unstructured meshes during restart.  <a href="classoomph_1_1Problem.html#a223a45fe6b1c80ee0109037b63e162f9">More...</a><br /></td></tr>
<tr class="separator:a223a45fe6b1c80ee0109037b63e162f9 inherit pub_static_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classoomph_1_1Problem"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classoomph_1_1Problem')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classoomph_1_1Problem.html">oomph::Problem</a></td></tr>
<tr class="memitem:ac793c004113930938730ec04dd2245b7 inherit pro_types_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ac793c004113930938730ec04dd2245b7">Assembly_method</a> { <br />
&#160;&#160;<a class="el" href="classoomph_1_1Problem.html#ac793c004113930938730ec04dd2245b7aa00e1772bb5ccf1c837a2bad2f240241">Perform_assembly_using_vectors_of_pairs</a>
, <a class="el" href="classoomph_1_1Problem.html#ac793c004113930938730ec04dd2245b7a6008d2b6aa449ee405313b49632d18ff">Perform_assembly_using_two_vectors</a>
, <a class="el" href="classoomph_1_1Problem.html#ac793c004113930938730ec04dd2245b7a406ad24599e1a59450acdd09bac1d717">Perform_assembly_using_maps</a>
, <a class="el" href="classoomph_1_1Problem.html#ac793c004113930938730ec04dd2245b7ad73bb55e4e1f000cfd6930cb8b2a52f8">Perform_assembly_using_lists</a>
, <br />
&#160;&#160;<a class="el" href="classoomph_1_1Problem.html#ac793c004113930938730ec04dd2245b7a1383f03857ad8602ba7edef43bd947f5">Perform_assembly_using_two_arrays</a>
<br />
 }</td></tr>
<tr class="memdesc:ac793c004113930938730ec04dd2245b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated flags to determine which sparse assembly method is used.  <a href="classoomph_1_1Problem.html#ac793c004113930938730ec04dd2245b7">More...</a><br /></td></tr>
<tr class="separator:ac793c004113930938730ec04dd2245b7 inherit pro_types_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classoomph_1_1Problem"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classoomph_1_1Problem')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classoomph_1_1Problem.html">oomph::Problem</a></td></tr>
<tr class="memitem:aa2e04de221f29c13067e2fe4cf4c70f9 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Problem.html">Problem</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aa2e04de221f29c13067e2fe4cf4c70f9">Copy_of_problem_pt</a></td></tr>
<tr class="memdesc:aa2e04de221f29c13067e2fe4cf4c70f9 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> of pointers to copies of the problem used in adaptive bifurcation tracking problems (ALH: TEMPORARY HACK, WILL BE FIXED)  <a href="classoomph_1_1Problem.html#aa2e04de221f29c13067e2fe4cf4c70f9">More...</a><br /></td></tr>
<tr class="separator:aa2e04de221f29c13067e2fe4cf4c70f9 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22f10c348ef8afeb1bfd8609cd6a319 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">std::map&lt; double *, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ae22f10c348ef8afeb1bfd8609cd6a319">Calculate_dparameter_analytic</a></td></tr>
<tr class="memdesc:ae22f10c348ef8afeb1bfd8609cd6a319 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map used to determine whether the derivatives with respect to a parameter should be finite differenced. The default is that finite differences should be used.  <a href="classoomph_1_1Problem.html#ae22f10c348ef8afeb1bfd8609cd6a319">More...</a><br /></td></tr>
<tr class="separator:ae22f10c348ef8afeb1bfd8609cd6a319 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac353f1325a3b411b30fbc19314cc18ce inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ac353f1325a3b411b30fbc19314cc18ce">Calculate_hessian_products_analytic</a></td></tr>
<tr class="memdesc:ac353f1325a3b411b30fbc19314cc18ce inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map used to determine whether the hessian products should be computed using finite differences. The default is that finite differences will be used.  <a href="classoomph_1_1Problem.html#ac353f1325a3b411b30fbc19314cc18ce">More...</a><br /></td></tr>
<tr class="separator:ac353f1325a3b411b30fbc19314cc18ce inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade01b88db08dcec1706fe44eaa0090a3 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1LinearAlgebraDistribution.html">LinearAlgebraDistribution</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ade01b88db08dcec1706fe44eaa0090a3">Dof_distribution_pt</a></td></tr>
<tr class="memdesc:ade01b88db08dcec1706fe44eaa0090a3 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">The distribution of the DOFs in this problem. This object is created in the <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> constructor and setup when assign_eqn_numbers(...) is called. If this problem is distributed then this distribution will match the distribution of the equation numbers. If this problem is not distributed then this distribution will be uniform over all processors.  <a href="classoomph_1_1Problem.html#ade01b88db08dcec1706fe44eaa0090a3">More...</a><br /></td></tr>
<tr class="separator:ade01b88db08dcec1706fe44eaa0090a3 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e4cfff7e1dc295036b0e58bc11ae75 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aa9e4cfff7e1dc295036b0e58bc11ae75">Dof_pt</a></td></tr>
<tr class="memdesc:aa9e4cfff7e1dc295036b0e58bc11ae75 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> of pointers to dofs.  <a href="classoomph_1_1Problem.html#aa9e4cfff7e1dc295036b0e58bc11ae75">More...</a><br /></td></tr>
<tr class="separator:aa9e4cfff7e1dc295036b0e58bc11ae75 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4177b73a790b80d541b416d1e83c6c3 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1DoubleVectorWithHaloEntries.html">DoubleVectorWithHaloEntries</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ae4177b73a790b80d541b416d1e83c6c3">Element_count_per_dof</a></td></tr>
<tr class="memdesc:ae4177b73a790b80d541b416d1e83c6c3 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter that records how many elements contribute to each dof. Used to determine the (discrete) arc-length automatically. It really should be an integer, but is a double so that the distribution information can be used for distributed problems.  <a href="classoomph_1_1Problem.html#ae4177b73a790b80d541b416d1e83c6c3">More...</a><br /></td></tr>
<tr class="separator:ae4177b73a790b80d541b416d1e83c6c3 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2bcde2b051f47278ccf8446699bbfb inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a2b2bcde2b051f47278ccf8446699bbfb">Elemental_assembly_time</a></td></tr>
<tr class="memdesc:a2b2bcde2b051f47278ccf8446699bbfb inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for assembly times (used for load balancing)  <a href="classoomph_1_1Problem.html#a2b2bcde2b051f47278ccf8446699bbfb">More...</a><br /></td></tr>
<tr class="separator:a2b2bcde2b051f47278ccf8446699bbfb inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcaa04975d69c616ab294cbfaf53d55 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1DoubleVectorHaloScheme.html">DoubleVectorHaloScheme</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a1dcaa04975d69c616ab294cbfaf53d55">Halo_scheme_pt</a></td></tr>
<tr class="memdesc:a1dcaa04975d69c616ab294cbfaf53d55 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the halo scheme for any global vectors that have the Dof_distribution.  <a href="classoomph_1_1Problem.html#a1dcaa04975d69c616ab294cbfaf53d55">More...</a><br /></td></tr>
<tr class="separator:a1dcaa04975d69c616ab294cbfaf53d55 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59d9163cc5d008a2ade4de8da06dbf6 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ac59d9163cc5d008a2ade4de8da06dbf6">Halo_dof_pt</a></td></tr>
<tr class="memdesc:ac59d9163cc5d008a2ade4de8da06dbf6 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the halo degrees of freedom (only required) when accessing via the global equation number in distributed problems.  <a href="classoomph_1_1Problem.html#ac59d9163cc5d008a2ade4de8da06dbf6">More...</a><br /></td></tr>
<tr class="separator:ac59d9163cc5d008a2ade4de8da06dbf6 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c4feb98ec982a08dc84fb664f53abc inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a86c4feb98ec982a08dc84fb664f53abc">Relaxation_factor</a></td></tr>
<tr class="memdesc:a86c4feb98ec982a08dc84fb664f53abc inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relaxation fator for Newton method (only a fractional Newton correction is applied if this is less than 1; default 1).  <a href="classoomph_1_1Problem.html#a86c4feb98ec982a08dc84fb664f53abc">More...</a><br /></td></tr>
<tr class="separator:a86c4feb98ec982a08dc84fb664f53abc inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94536b381e949edf5bb4d44434e08925 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a94536b381e949edf5bb4d44434e08925">Newton_solver_tolerance</a></td></tr>
<tr class="memdesc:a94536b381e949edf5bb4d44434e08925 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tolerance below which the Newton Method is deemed to have converged.  <a href="classoomph_1_1Problem.html#a94536b381e949edf5bb4d44434e08925">More...</a><br /></td></tr>
<tr class="separator:a94536b381e949edf5bb4d44434e08925 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a58a98c3e2e7dbaefcfb1ee7830c35 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a52a58a98c3e2e7dbaefcfb1ee7830c35">Max_newton_iterations</a></td></tr>
<tr class="memdesc:a52a58a98c3e2e7dbaefcfb1ee7830c35 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of Newton iterations.  <a href="classoomph_1_1Problem.html#a52a58a98c3e2e7dbaefcfb1ee7830c35">More...</a><br /></td></tr>
<tr class="separator:a52a58a98c3e2e7dbaefcfb1ee7830c35 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c05eefd6891808a1ef01e51288e0108 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a3c05eefd6891808a1ef01e51288e0108">Nnewton_iter_taken</a></td></tr>
<tr class="memdesc:a3c05eefd6891808a1ef01e51288e0108 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual number of Newton iterations taken during the most recent iteration.  <a href="classoomph_1_1Problem.html#a3c05eefd6891808a1ef01e51288e0108">More...</a><br /></td></tr>
<tr class="separator:a3c05eefd6891808a1ef01e51288e0108 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f510bea9bdfcaf229415440a0a1c98 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ab6f510bea9bdfcaf229415440a0a1c98">Max_res</a></td></tr>
<tr class="memdesc:ab6f510bea9bdfcaf229415440a0a1c98 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum residuals at start and after each newton iteration.  <a href="classoomph_1_1Problem.html#ab6f510bea9bdfcaf229415440a0a1c98">More...</a><br /></td></tr>
<tr class="separator:ab6f510bea9bdfcaf229415440a0a1c98 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb8811cdf32f14be497917e922c623e inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#accb8811cdf32f14be497917e922c623e">Max_residuals</a></td></tr>
<tr class="memdesc:accb8811cdf32f14be497917e922c623e inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum desired residual: if the maximum residual exceeds this value, the program will exit.  <a href="classoomph_1_1Problem.html#accb8811cdf32f14be497917e922c623e">More...</a><br /></td></tr>
<tr class="separator:accb8811cdf32f14be497917e922c623e inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9aecf88bde320bc2d169b5f3c99fee inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a3e9aecf88bde320bc2d169b5f3c99fee">Time_adaptive_newton_crash_on_solve_fail</a></td></tr>
<tr class="memdesc:a3e9aecf88bde320bc2d169b5f3c99fee inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bool to specify what to do if a Newton solve fails within a time adaptive solve. Default (false) is to half the step and try again. If true then crash instead.  <a href="classoomph_1_1Problem.html#a3e9aecf88bde320bc2d169b5f3c99fee">More...</a><br /></td></tr>
<tr class="separator:a3e9aecf88bde320bc2d169b5f3c99fee inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022796f2c96f2dff6ed1db2338c93aaf inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a022796f2c96f2dff6ed1db2338c93aaf">Jacobian_reuse_is_enabled</a></td></tr>
<tr class="memdesc:a022796f2c96f2dff6ed1db2338c93aaf inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is re-use of Jacobian in Newton iteration enabled? Default: false.  <a href="classoomph_1_1Problem.html#a022796f2c96f2dff6ed1db2338c93aaf">More...</a><br /></td></tr>
<tr class="separator:a022796f2c96f2dff6ed1db2338c93aaf inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4702c75739c967ed582dbd0a7ba56f inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a2c4702c75739c967ed582dbd0a7ba56f">Jacobian_has_been_computed</a></td></tr>
<tr class="memdesc:a2c4702c75739c967ed582dbd0a7ba56f inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has a Jacobian been computed (and can therefore be re-used if required)? Default: false.  <a href="classoomph_1_1Problem.html#a2c4702c75739c967ed582dbd0a7ba56f">More...</a><br /></td></tr>
<tr class="separator:a2c4702c75739c967ed582dbd0a7ba56f inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2d3efba34f69aafaefc076ddb3b8d4 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ade2d3efba34f69aafaefc076ddb3b8d4">Problem_is_nonlinear</a></td></tr>
<tr class="memdesc:ade2d3efba34f69aafaefc076ddb3b8d4 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean flag indicating if we're dealing with a linear or nonlinear <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> &ndash; if set to false the Newton solver will not check the residual before or after the linear solve. Set to true by default; can be over-written in specific <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> class.  <a href="classoomph_1_1Problem.html#ade2d3efba34f69aafaefc076ddb3b8d4">More...</a><br /></td></tr>
<tr class="separator:ade2d3efba34f69aafaefc076ddb3b8d4 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedefa8337ace6043c2fdfd5a2d19afd3 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aedefa8337ace6043c2fdfd5a2d19afd3">Pause_at_end_of_sparse_assembly</a></td></tr>
<tr class="memdesc:aedefa8337ace6043c2fdfd5a2d19afd3 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected boolean flag to halt program execution during sparse assemble process to assess peak memory usage. Initialised to false (obviously!)  <a href="classoomph_1_1Problem.html#aedefa8337ace6043c2fdfd5a2d19afd3">More...</a><br /></td></tr>
<tr class="separator:aedefa8337ace6043c2fdfd5a2d19afd3 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524b68efcaae084ad7144f944cb39c69 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a524b68efcaae084ad7144f944cb39c69">Doc_time_in_distribute</a></td></tr>
<tr class="memdesc:a524b68efcaae084ad7144f944cb39c69 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected boolean flag to provide comprehensive timimings during problem distribution. Initialised to false.  <a href="classoomph_1_1Problem.html#a524b68efcaae084ad7144f944cb39c69">More...</a><br /></td></tr>
<tr class="separator:a524b68efcaae084ad7144f944cb39c69 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447f9d42b248f6c394581ff1a0b02513 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a447f9d42b248f6c394581ff1a0b02513">Sparse_assembly_method</a></td></tr>
<tr class="memdesc:a447f9d42b248f6c394581ff1a0b02513 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to determine which sparse assembly method to use By default we use assembly by vectors of pairs.  <a href="classoomph_1_1Problem.html#a447f9d42b248f6c394581ff1a0b02513">More...</a><br /></td></tr>
<tr class="separator:a447f9d42b248f6c394581ff1a0b02513 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d5f8e18619fafcff11727b1c55b3eb inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ad2d5f8e18619fafcff11727b1c55b3eb">Sparse_assemble_with_arrays_initial_allocation</a></td></tr>
<tr class="memdesc:ad2d5f8e18619fafcff11727b1c55b3eb inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of elements to initially allocate for a matrix row within the sparse_assembly_with_two_arrays(...) method (if a matrix of this size has not been assembled already). If a matrix of this size has been assembled then the number of elements in each row in that matrix is used as the initial allocation  <a href="classoomph_1_1Problem.html#ad2d5f8e18619fafcff11727b1c55b3eb">More...</a><br /></td></tr>
<tr class="separator:ad2d5f8e18619fafcff11727b1c55b3eb inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb58a3cead4d10697c4471523f705130 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aeb58a3cead4d10697c4471523f705130">Sparse_assemble_with_arrays_allocation_increment</a></td></tr>
<tr class="memdesc:aeb58a3cead4d10697c4471523f705130 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of elements to add to a matrix row when the initial allocation is exceeded within the sparse_assemble_with_two_arrays(...) method.  <a href="classoomph_1_1Problem.html#aeb58a3cead4d10697c4471523f705130">More...</a><br /></td></tr>
<tr class="separator:aeb58a3cead4d10697c4471523f705130 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547c85bfa6a2eb3effc4db1b46ebcdde inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a547c85bfa6a2eb3effc4db1b46ebcdde">Sparse_assemble_with_arrays_previous_allocation</a></td></tr>
<tr class="memdesc:a547c85bfa6a2eb3effc4db1b46ebcdde inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of elements in each row of a compressed matrix in the previous matrix assembly.  <a href="classoomph_1_1Problem.html#a547c85bfa6a2eb3effc4db1b46ebcdde">More...</a><br /></td></tr>
<tr class="separator:a547c85bfa6a2eb3effc4db1b46ebcdde inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a1ffc2bd685377ce7213452876b127 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ad1a1ffc2bd685377ce7213452876b127">Numerical_zero_for_sparse_assembly</a></td></tr>
<tr class="memdesc:ad1a1ffc2bd685377ce7213452876b127 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tolerance used to determine whether the entry in a sparse matrix is zero. If it is then storage need not be allocated.  <a href="classoomph_1_1Problem.html#ad1a1ffc2bd685377ce7213452876b127">More...</a><br /></td></tr>
<tr class="separator:ad1a1ffc2bd685377ce7213452876b127 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26c62f5aab816943144ac61fbf7725e inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ad26c62f5aab816943144ac61fbf7725e">FD_step_used_in_get_hessian_vector_products</a></td></tr>
<tr class="separator:ad26c62f5aab816943144ac61fbf7725e inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d25809ac090102a4d4a398e4ad0e26 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af4d25809ac090102a4d4a398e4ad0e26">Mass_matrix_reuse_is_enabled</a></td></tr>
<tr class="memdesc:af4d25809ac090102a4d4a398e4ad0e26 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is re-use of the mass matrix in explicit timestepping enabled Default:false.  <a href="classoomph_1_1Problem.html#af4d25809ac090102a4d4a398e4ad0e26">More...</a><br /></td></tr>
<tr class="separator:af4d25809ac090102a4d4a398e4ad0e26 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6067c6d344363a073fb8d02a99fb7ed0 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a6067c6d344363a073fb8d02a99fb7ed0">Mass_matrix_has_been_computed</a></td></tr>
<tr class="memdesc:a6067c6d344363a073fb8d02a99fb7ed0 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the mass matrix been computed (and can therefore be reused) Default: false.  <a href="classoomph_1_1Problem.html#a6067c6d344363a073fb8d02a99fb7ed0">More...</a><br /></td></tr>
<tr class="separator:a6067c6d344363a073fb8d02a99fb7ed0 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ca0078fff6adca318835c11503dc2d inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a97ca0078fff6adca318835c11503dc2d">Discontinuous_element_formulation</a></td></tr>
<tr class="memdesc:a97ca0078fff6adca318835c11503dc2d inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the problem a discontinuous one, i.e. can the elemental contributions be treated independently. Default: false.  <a href="classoomph_1_1Problem.html#a97ca0078fff6adca318835c11503dc2d">More...</a><br /></td></tr>
<tr class="separator:a97ca0078fff6adca318835c11503dc2d inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7456318933aa01114dc78498bfd6d79 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ad7456318933aa01114dc78498bfd6d79">Minimum_dt</a></td></tr>
<tr class="memdesc:ad7456318933aa01114dc78498bfd6d79 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum desired dt: if dt falls below this value, exit.  <a href="classoomph_1_1Problem.html#ad7456318933aa01114dc78498bfd6d79">More...</a><br /></td></tr>
<tr class="separator:ad7456318933aa01114dc78498bfd6d79 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5fde48b00a7fdc5f1fbbee138d0414 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a7b5fde48b00a7fdc5f1fbbee138d0414">Maximum_dt</a></td></tr>
<tr class="memdesc:a7b5fde48b00a7fdc5f1fbbee138d0414 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum desired dt.  <a href="classoomph_1_1Problem.html#a7b5fde48b00a7fdc5f1fbbee138d0414">More...</a><br /></td></tr>
<tr class="separator:a7b5fde48b00a7fdc5f1fbbee138d0414 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaeab9469b342a3b849ee5f2ef7051f3 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aaaeab9469b342a3b849ee5f2ef7051f3">DTSF_max_increase</a></td></tr>
<tr class="memdesc:aaaeab9469b342a3b849ee5f2ef7051f3 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum possible increase of dt between time-steps in adaptive schemes.  <a href="classoomph_1_1Problem.html#aaaeab9469b342a3b849ee5f2ef7051f3">More...</a><br /></td></tr>
<tr class="separator:aaaeab9469b342a3b849ee5f2ef7051f3 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb93979ed99d40eb845ba7296355965 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#abbb93979ed99d40eb845ba7296355965">DTSF_min_decrease</a></td></tr>
<tr class="memdesc:abbb93979ed99d40eb845ba7296355965 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum allowed decrease of dt between time-steps in adaptive schemes. Lower scaling values will reject the time-step (and retry with a smaller dt).  <a href="classoomph_1_1Problem.html#abbb93979ed99d40eb845ba7296355965">More...</a><br /></td></tr>
<tr class="separator:abbb93979ed99d40eb845ba7296355965 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb61c79a0cbdab75d68c95348898874 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aacb61c79a0cbdab75d68c95348898874">Target_error_safety_factor</a></td></tr>
<tr class="memdesc:aacb61c79a0cbdab75d68c95348898874 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safety factor to ensure we are aiming for a target error, TARGET, that is below our tolerance: TARGET = Target_error_safety_factor * TOL For this to make sense Target_error_safety_factor should be &lt;1.0. If Keep_temporal_error_below_tolerance is set to true (default) then, without this, timesteps suggested by the adaptive time-stepper can be expected to lead to rejection (because the error exceeds TOL) about half of the time. Harier et al. (1993, ISBN:978-3-540-56670-0, p168) suggest a value around 0.25-0.40 to be the most efficient, however this is highly problem and timestepper dependent and sometimes as high as 0.95 may be effective at improving the robustness of timestep prediction.  <a href="classoomph_1_1Problem.html#aacb61c79a0cbdab75d68c95348898874">More...</a><br /></td></tr>
<tr class="separator:aacb61c79a0cbdab75d68c95348898874 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdee700b2cec37540cf1e7e1462df6c3 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#abdee700b2cec37540cf1e7e1462df6c3">Minimum_dt_but_still_proceed</a></td></tr>
<tr class="memdesc:abdee700b2cec37540cf1e7e1462df6c3 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Minimum_dt_but_still_proceed positive, then dt will not be reduced below this value during adaptive timestepping and the computation will continue with this value, accepting the larger errors that this will incur). Note: This option is disabled by default as this value is initialised to -1.0.  <a href="classoomph_1_1Problem.html#abdee700b2cec37540cf1e7e1462df6c3">More...</a><br /></td></tr>
<tr class="separator:abdee700b2cec37540cf1e7e1462df6c3 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708322baf423e373970384006c2ca4db inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a708322baf423e373970384006c2ca4db">Scale_arc_length</a></td></tr>
<tr class="memdesc:a708322baf423e373970384006c2ca4db inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean to control whether arc-length should be scaled.  <a href="classoomph_1_1Problem.html#a708322baf423e373970384006c2ca4db">More...</a><br /></td></tr>
<tr class="separator:a708322baf423e373970384006c2ca4db inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fb791188428c8186ffd5c52b6cf576 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a37fb791188428c8186ffd5c52b6cf576">Desired_proportion_of_arc_length</a></td></tr>
<tr class="memdesc:a37fb791188428c8186ffd5c52b6cf576 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proportion of the arc-length to taken by the parameter.  <a href="classoomph_1_1Problem.html#a37fb791188428c8186ffd5c52b6cf576">More...</a><br /></td></tr>
<tr class="separator:a37fb791188428c8186ffd5c52b6cf576 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123843ca2ed6384342939ef2b19477ef inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a123843ca2ed6384342939ef2b19477ef">Theta_squared</a></td></tr>
<tr class="memdesc:a123843ca2ed6384342939ef2b19477ef inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of the scaling parameter required so that the parameter occupies the desired proportion of the arc length. NOTE: If you wish to change this then make sure to set the value of Scale_arc_length to false to ensure the value of this isn't overwritten during the arc-length process. Instead of changing this variable, it's better to actually update the Desired_proportion_of_arc_length value.  <a href="classoomph_1_1Problem.html#a123843ca2ed6384342939ef2b19477ef">More...</a><br /></td></tr>
<tr class="separator:a123843ca2ed6384342939ef2b19477ef inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca97d61840e46edc914e3cb4b98fd437 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aca97d61840e46edc914e3cb4b98fd437">Sign_of_jacobian</a></td></tr>
<tr class="memdesc:aca97d61840e46edc914e3cb4b98fd437 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the sign of the global Jacobian.  <a href="classoomph_1_1Problem.html#aca97d61840e46edc914e3cb4b98fd437">More...</a><br /></td></tr>
<tr class="separator:aca97d61840e46edc914e3cb4b98fd437 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6904003416e9a9257db70c009bdc69ed inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a6904003416e9a9257db70c009bdc69ed">Continuation_direction</a></td></tr>
<tr class="memdesc:a6904003416e9a9257db70c009bdc69ed inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">The direction of the change in parameter that will ensure that a branch is followed in one direction only.  <a href="classoomph_1_1Problem.html#a6904003416e9a9257db70c009bdc69ed">More...</a><br /></td></tr>
<tr class="separator:a6904003416e9a9257db70c009bdc69ed inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5082325ca4cafe5a9ec03ef79c67a6f inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#aa5082325ca4cafe5a9ec03ef79c67a6f">Parameter_derivative</a></td></tr>
<tr class="memdesc:aa5082325ca4cafe5a9ec03ef79c67a6f inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the derivative of the global parameter wrt arc-length.  <a href="classoomph_1_1Problem.html#aa5082325ca4cafe5a9ec03ef79c67a6f">More...</a><br /></td></tr>
<tr class="separator:aa5082325ca4cafe5a9ec03ef79c67a6f inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e29673eb80559888d1c6148c4f11e57 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a8e29673eb80559888d1c6148c4f11e57">Parameter_current</a></td></tr>
<tr class="memdesc:a8e29673eb80559888d1c6148c4f11e57 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the present value of the global parameter.  <a href="classoomph_1_1Problem.html#a8e29673eb80559888d1c6148c4f11e57">More...</a><br /></td></tr>
<tr class="separator:a8e29673eb80559888d1c6148c4f11e57 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbecce0cb1bd7b6b21285568e41ee3eb inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#adbecce0cb1bd7b6b21285568e41ee3eb">Use_continuation_timestepper</a></td></tr>
<tr class="memdesc:adbecce0cb1bd7b6b21285568e41ee3eb inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean to control original or new storage of dof stuff.  <a href="classoomph_1_1Problem.html#adbecce0cb1bd7b6b21285568e41ee3eb">More...</a><br /></td></tr>
<tr class="separator:adbecce0cb1bd7b6b21285568e41ee3eb inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0372f742b90bb402c6edc720ceeb421 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#af0372f742b90bb402c6edc720ceeb421">Dof_derivative_offset</a></td></tr>
<tr class="memdesc:af0372f742b90bb402c6edc720ceeb421 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the offset for the continuation derivatives from the original dofs (default is 1, but this will be differnet when continuing bifurcations and periodic orbits)  <a href="classoomph_1_1Problem.html#af0372f742b90bb402c6edc720ceeb421">More...</a><br /></td></tr>
<tr class="separator:af0372f742b90bb402c6edc720ceeb421 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57825be8c76db9e23e6a9aa0d73973b2 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a57825be8c76db9e23e6a9aa0d73973b2">Dof_current_offset</a></td></tr>
<tr class="memdesc:a57825be8c76db9e23e6a9aa0d73973b2 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the offset for the current values of dofs from the original dofs (default is 2, but this will be differnet when continuing bifurcations and periodic orbits)  <a href="classoomph_1_1Problem.html#a57825be8c76db9e23e6a9aa0d73973b2">More...</a><br /></td></tr>
<tr class="separator:a57825be8c76db9e23e6a9aa0d73973b2 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1861321b2d129707935bf1191238daca inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a1861321b2d129707935bf1191238daca">Dof_derivative</a></td></tr>
<tr class="memdesc:a1861321b2d129707935bf1191238daca inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the derivative of the problem variables wrt arc-length.  <a href="classoomph_1_1Problem.html#a1861321b2d129707935bf1191238daca">More...</a><br /></td></tr>
<tr class="separator:a1861321b2d129707935bf1191238daca inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366b50c490e9fd3ddafa05b2fbd0b883 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a366b50c490e9fd3ddafa05b2fbd0b883">Dof_current</a></td></tr>
<tr class="memdesc:a366b50c490e9fd3ddafa05b2fbd0b883 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the present values of the variables.  <a href="classoomph_1_1Problem.html#a366b50c490e9fd3ddafa05b2fbd0b883">More...</a><br /></td></tr>
<tr class="separator:a366b50c490e9fd3ddafa05b2fbd0b883 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad412d49617d0b0998e5eb440c7a20f3f inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ad412d49617d0b0998e5eb440c7a20f3f">Ds_current</a></td></tr>
<tr class="memdesc:ad412d49617d0b0998e5eb440c7a20f3f inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the current step value.  <a href="classoomph_1_1Problem.html#ad412d49617d0b0998e5eb440c7a20f3f">More...</a><br /></td></tr>
<tr class="separator:ad412d49617d0b0998e5eb440c7a20f3f inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe8db162a0bda98add0062a45f41cbf inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#abfe8db162a0bda98add0062a45f41cbf">Desired_newton_iterations_ds</a></td></tr>
<tr class="memdesc:abfe8db162a0bda98add0062a45f41cbf inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">The desired number of Newton Steps to reach convergence at each step along the arc.  <a href="classoomph_1_1Problem.html#abfe8db162a0bda98add0062a45f41cbf">More...</a><br /></td></tr>
<tr class="separator:abfe8db162a0bda98add0062a45f41cbf inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f8bb126a4f5ddeb559c23a8d451d8d inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ad0f8bb126a4f5ddeb559c23a8d451d8d">Minimum_ds</a></td></tr>
<tr class="memdesc:ad0f8bb126a4f5ddeb559c23a8d451d8d inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum desired value of arc-length.  <a href="classoomph_1_1Problem.html#ad0f8bb126a4f5ddeb559c23a8d451d8d">More...</a><br /></td></tr>
<tr class="separator:ad0f8bb126a4f5ddeb559c23a8d451d8d inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dfc704030bb65cea3d9784c5271af0 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a08dfc704030bb65cea3d9784c5271af0">Bifurcation_detection</a></td></tr>
<tr class="memdesc:a08dfc704030bb65cea3d9784c5271af0 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean to control bifurcation detection via determinant of Jacobian.  <a href="classoomph_1_1Problem.html#a08dfc704030bb65cea3d9784c5271af0">More...</a><br /></td></tr>
<tr class="separator:a08dfc704030bb65cea3d9784c5271af0 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab805e5e5fb94f941cc7ff1b850d83269 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ab805e5e5fb94f941cc7ff1b850d83269">Bisect_to_find_bifurcation</a></td></tr>
<tr class="memdesc:ab805e5e5fb94f941cc7ff1b850d83269 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean to control wheter bisection is used to located bifurcation.  <a href="classoomph_1_1Problem.html#ab805e5e5fb94f941cc7ff1b850d83269">More...</a><br /></td></tr>
<tr class="separator:ab805e5e5fb94f941cc7ff1b850d83269 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643f61299463a3bbf7be3f6a112aa130 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a643f61299463a3bbf7be3f6a112aa130">First_jacobian_sign_change</a></td></tr>
<tr class="memdesc:a643f61299463a3bbf7be3f6a112aa130 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean to indicate whether a sign change has occured in the Jacobian.  <a href="classoomph_1_1Problem.html#a643f61299463a3bbf7be3f6a112aa130">More...</a><br /></td></tr>
<tr class="separator:a643f61299463a3bbf7be3f6a112aa130 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8109bf56e9203d248ae30a50bb9cfe90 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a8109bf56e9203d248ae30a50bb9cfe90">Arc_length_step_taken</a></td></tr>
<tr class="memdesc:a8109bf56e9203d248ae30a50bb9cfe90 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean to indicate whether an arc-length step has been taken.  <a href="classoomph_1_1Problem.html#a8109bf56e9203d248ae30a50bb9cfe90">More...</a><br /></td></tr>
<tr class="separator:a8109bf56e9203d248ae30a50bb9cfe90 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dac9f70c77302805bb782cc6f1ad0f inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a80dac9f70c77302805bb782cc6f1ad0f">Use_finite_differences_for_continuation_derivatives</a></td></tr>
<tr class="memdesc:a80dac9f70c77302805bb782cc6f1ad0f inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean to specify which scheme to use to calculate the continuation derivatievs.  <a href="classoomph_1_1Problem.html#a80dac9f70c77302805bb782cc6f1ad0f">More...</a><br /></td></tr>
<tr class="separator:a80dac9f70c77302805bb782cc6f1ad0f inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6bd262be3544343a30767da278d846 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a5c6bd262be3544343a30767da278d846">Problem_has_been_distributed</a></td></tr>
<tr class="memdesc:a5c6bd262be3544343a30767da278d846 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the problem been distributed amongst multiple processors?  <a href="classoomph_1_1Problem.html#a5c6bd262be3544343a30767da278d846">More...</a><br /></td></tr>
<tr class="separator:a5c6bd262be3544343a30767da278d846 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cee2eaaf1ac49020fc76b3b6adb9bba inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a2cee2eaaf1ac49020fc76b3b6adb9bba">Bypass_increase_in_dof_check_during_pruning</a></td></tr>
<tr class="memdesc:a2cee2eaaf1ac49020fc76b3b6adb9bba inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean to bypass check of increase in dofs during pruning.  <a href="classoomph_1_1Problem.html#a2cee2eaaf1ac49020fc76b3b6adb9bba">More...</a><br /></td></tr>
<tr class="separator:a2cee2eaaf1ac49020fc76b3b6adb9bba inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937afdd0d5a039943482f8be9b24c82e inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1OomphCommunicator.html">OomphCommunicator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a937afdd0d5a039943482f8be9b24c82e">Communicator_pt</a></td></tr>
<tr class="memdesc:a937afdd0d5a039943482f8be9b24c82e inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">The communicator for this problem.  <a href="classoomph_1_1Problem.html#a937afdd0d5a039943482f8be9b24c82e">More...</a><br /></td></tr>
<tr class="separator:a937afdd0d5a039943482f8be9b24c82e inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d7376ab9cc06e4d5619b34fd39dee2 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a01d7376ab9cc06e4d5619b34fd39dee2">Always_take_one_newton_step</a></td></tr>
<tr class="memdesc:a01d7376ab9cc06e4d5619b34fd39dee2 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean to indicate whether a Newton step should be taken even if the initial residuals are below the required tolerance.  <a href="classoomph_1_1Problem.html#a01d7376ab9cc06e4d5619b34fd39dee2">More...</a><br /></td></tr>
<tr class="separator:a01d7376ab9cc06e4d5619b34fd39dee2 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359d1936bc2146e0a0ce697776efcf91 inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#a359d1936bc2146e0a0ce697776efcf91">Timestep_reduction_factor_after_nonconvergence</a></td></tr>
<tr class="memdesc:a359d1936bc2146e0a0ce697776efcf91 inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">What it says: If temporally adaptive Newton solver fails to to converge, reduce timestep by this factor and try again; defaults to 1/2; can be over-written by user in derived problem.  <a href="classoomph_1_1Problem.html#a359d1936bc2146e0a0ce697776efcf91">More...</a><br /></td></tr>
<tr class="separator:a359d1936bc2146e0a0ce697776efcf91 inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27af4a444de9f59125ee50ac778d97a inherit pro_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ab27af4a444de9f59125ee50ac778d97a">Keep_temporal_error_below_tolerance</a></td></tr>
<tr class="memdesc:ab27af4a444de9f59125ee50ac778d97a inherit pro_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean to decide if a timestep is to be rejected if the error estimate post-solve (computed by <a class="el" href="classoomph_1_1Problem.html#ac7667864b71a3889c95c29307422ac8e" title="Function to calculate a global error norm, used in adaptive timestepping to control the change in tim...">global_temporal_error_norm()</a>) exceeds the tolerance required in the call to adaptive_unsteady_newton_solve(...). Defaults to true.  <a href="classoomph_1_1Problem.html#ab27af4a444de9f59125ee50ac778d97a">More...</a><br /></td></tr>
<tr class="separator:ab27af4a444de9f59125ee50ac778d97a inherit pro_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classoomph_1_1Problem"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classoomph_1_1Problem')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classoomph_1_1Problem.html">oomph::Problem</a></td></tr>
<tr class="memitem:ade29c0a82218d50136b4b3860055ad30 inherit pro_static_attribs_classoomph_1_1Problem"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1ContinuationStorageScheme.html">ContinuationStorageScheme</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Problem.html#ade29c0a82218d50136b4b3860055ad30">Continuation_time_stepper</a></td></tr>
<tr class="memdesc:ade29c0a82218d50136b4b3860055ad30 inherit pro_static_attribs_classoomph_1_1Problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the single static continuation timestorage object.  <a href="classoomph_1_1Problem.html#ade29c0a82218d50136b4b3860055ad30">More...</a><br /></td></tr>
<tr class="separator:ade29c0a82218d50136b4b3860055ad30 inherit pro_static_attribs_classoomph_1_1Problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;unsigned DIM&gt;<br />
class oomph::BiharmonicFluidProblem&lt; DIM &gt;</h3>

<p>Biharmonic Fluid <a class="el" href="classoomph_1_1Problem.html" title="////////////////////////////////////////////////////////////////// //////////////////////////////////...">Problem</a> Class - describes stokes flow in 2D. Developed for the topologically rectangular Hermite Element <a class="el" href="classoomph_1_1Mesh.html" title="A general mesh class.">Mesh</a>. Contains functions allowing the following boundary conditions to be applied (on a given edge): </p>
<ul>
<li>wall : v_n = 0 and v_t = 0 (psi must also be prescribed)</li>
<li>traction free : v_t = 0</li>
<li>flow : v_n and v_t are prescribed NOTE 1 : psi is the stream function<ul>
<li>fluid velocity normal to boundary v_n = +/- dpsi/dt</li>
<li>fluid velocity tangential to boundary v_t = -/+ dpsi/dn NOTE 2 : when a solid wall boundary condition is applied to ensure that v_n = 0 the the streamfunction psi must also be prescribed (and constant) </li>
</ul>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="biharmonic__problem_8h_source.html#l00224">224</a> of file <a class="el" href="biharmonic__problem_8h_source.html">biharmonic_problem.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a93661d3b0c52bd82fd58496f9f853079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93661d3b0c52bd82fd58496f9f853079">&#9670;&nbsp;</a></span>FluidBCFctPt</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="classoomph_1_1BiharmonicFluidProblem.html">oomph::BiharmonicFluidProblem</a>&lt; DIM &gt;::FluidBCFctPt) (const double &amp;<a class="el" href="cfortran_8h.html#ab7123126e4885ef647dd9c6e3807a21c">s</a>, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of a dirichlet boundary condition function pointer. Takes the position along a boundary (s) in the macro element coordinate scheme and returns the fluid velocity normal (dpsi/dt) to the boundary (u[0]) and the fluid velocity tangential (dpsidn) to the boundary (u[1]). </p>

<p class="definition">Definition at line <a class="el" href="biharmonic__problem_8h_source.html#l00232">232</a> of file <a class="el" href="biharmonic__problem_8h_source.html">biharmonic_problem.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a258f8f42491569c4727c54cd8f8f17d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258f8f42491569c4727c54cd8f8f17d5">&#9670;&nbsp;</a></span>BiharmonicFluidProblem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1BiharmonicFluidProblem.html">oomph::BiharmonicFluidProblem</a>&lt; DIM &gt;::<a class="el" href="classoomph_1_1BiharmonicFluidProblem.html">BiharmonicFluidProblem</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor </p>

<p class="definition">Definition at line <a class="el" href="biharmonic__problem_8h_source.html#l00236">236</a> of file <a class="el" href="biharmonic__problem_8h_source.html">biharmonic_problem.h</a>.</p>

<p class="reference">References <a class="el" href="biharmonic__problem_8h_source.html#l00297">oomph::BiharmonicFluidProblem&lt; DIM &gt;::Npoint_element</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6a69be0763564ffd22f598d734d11a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a69be0763564ffd22f598d734d11a26">&#9670;&nbsp;</a></span>actions_after_newton_solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoomph_1_1BiharmonicFluidProblem.html">oomph::BiharmonicFluidProblem</a>&lt; DIM &gt;::actions_after_newton_solve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>action after solve </p>

<p>Reimplemented from <a class="el" href="classoomph_1_1Problem.html#a033ec7301123deeb7e56d04c38f9f1da">oomph::Problem</a>.</p>

<p class="definition">Definition at line <a class="el" href="biharmonic__problem_8h_source.html#l00260">260</a> of file <a class="el" href="biharmonic__problem_8h_source.html">biharmonic_problem.h</a>.</p>

</div>
</div>
<a id="ad62b36f8b36faae1324fe29fcd8e0875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62b36f8b36faae1324fe29fcd8e0875">&#9670;&nbsp;</a></span>actions_before_newton_solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoomph_1_1BiharmonicFluidProblem.html">oomph::BiharmonicFluidProblem</a>&lt; DIM &gt;::actions_before_newton_solve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>actions before solve, performs self test </p>

<p>Reimplemented from <a class="el" href="classoomph_1_1Problem.html#a0c8d70891f7369bb4bf8412fa1a08ecb">oomph::Problem</a>.</p>

<p class="definition">Definition at line <a class="el" href="biharmonic__problem_8h_source.html#l00244">244</a> of file <a class="el" href="biharmonic__problem_8h_source.html">biharmonic_problem.h</a>.</p>

<p class="reference">References <a class="el" href="oomph__definitions_8cc_source.html#l00319">oomph::oomph_info</a>, and <a class="el" href="problem_8cc_source.html#l13339">oomph::Problem::self_test()</a>.</p>

</div>
</div>
<a id="a095e8526d834c05c492929bd5017dfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095e8526d834c05c492929bd5017dfa5">&#9670;&nbsp;</a></span>doc_solution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoomph_1_1BiharmonicFluidProblem.html">oomph::BiharmonicFluidProblem</a>&lt; DIM &gt;::doc_solution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoomph_1_1DocInfo.html">DocInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>doc_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoomph_1_1FiniteElement.html#a690fd33af26cc3e84f39bba6d5a85202">FiniteElement::SteadyExactSolutionFctPt</a>&#160;</td>
          <td class="paramname"><em>exact_soln_pt</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>documents the solution, and if an exact solution is provided, then the error between the numerical and exact solution is presented </p>

<p class="definition">Definition at line <a class="el" href="biharmonic__problem_8cc_source.html#l00810">810</a> of file <a class="el" href="biharmonic__problem_8cc_source.html">biharmonic_problem.cc</a>.</p>

<p class="reference">References <a class="el" href="oomph__utilities_8h_source.html#l00524">oomph::DocInfo::directory()</a>, <a class="el" href="cfortran_8h_source.html#l00603">i</a>, <a class="el" href="oomph__utilities_8h_source.html#l00572">oomph::DocInfo::label()</a>, <a class="el" href="oomph__definitions_8cc_source.html#l00319">oomph::oomph_info</a>, and <a class="el" href="biharmonic__elements_8h_source.html#l00161">oomph::BiharmonicEquations&lt; DIM &gt;::output_fluid_velocity()</a>.</p>

</div>
</div>
<a id="a1006320d9024555042645ed6347ff8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1006320d9024555042645ed6347ff8fb">&#9670;&nbsp;</a></span>impose_fluid_flow_on_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoomph_1_1BiharmonicFluidProblem.html">oomph::BiharmonicFluidProblem</a>&lt; DIM &gt;::impose_fluid_flow_on_edge </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoomph_1_1BiharmonicFluidProblem.html#a93661d3b0c52bd82fd58496f9f853079">FluidBCFctPt</a>&#160;</td>
          <td class="paramname"><em>u_imposed_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose a prescribed fluid flow comprising the velocity normal to the boundary (u_imposed_fn[0]) and the velocity tangential to the boundary (u_imposed_fn[1]) </p>

<p class="definition">Definition at line <a class="el" href="biharmonic__problem_8cc_source.html#l00658">658</a> of file <a class="el" href="biharmonic__problem_8cc_source.html">biharmonic_problem.cc</a>.</p>

<p class="reference">References <a class="el" href="cfortran_8h_source.html#l00571">e</a>, and <a class="el" href="cfortran_8h_source.html#l00568">s</a>.</p>

</div>
</div>
<a id="a1a00fff232d2438c83b66437d8e86aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a00fff232d2438c83b66437d8e86aab">&#9670;&nbsp;</a></span>impose_solid_boundary_on_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoomph_1_1BiharmonicFluidProblem.html">oomph::BiharmonicFluidProblem</a>&lt; DIM &gt;::impose_solid_boundary_on_edge </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>psi</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Imposes a solid boundary on boundary b - no flow into boundary or along boundary v_n = 0 and v_t = 0. User must presribe the streamfunction psi to ensure dpsi/dt = 0 is imposed at all points on the boundary and not just at the nodes. </p>
<p>Imposes a solid boundary - no flow into boundary or along boundary v_n = 0 and v_t = 0. User must presribe the streamfunction psi to ensure dpsi/dt = 0 is imposed at all points on the boundary and not just at the nodes. </p>

<p class="definition">Definition at line <a class="el" href="biharmonic__problem_8cc_source.html#l00457">457</a> of file <a class="el" href="biharmonic__problem_8cc_source.html">biharmonic_problem.cc</a>.</p>

</div>
</div>
<a id="a1cc57555bbd0ceef1d93010c133ac597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc57555bbd0ceef1d93010c133ac597">&#9670;&nbsp;</a></span>impose_traction_free_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoomph_1_1BiharmonicFluidProblem.html">oomph::BiharmonicFluidProblem</a>&lt; DIM &gt;::impose_traction_free_edge </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose a traction free edge - i.e. v_t = 0 or dpsi/dn = 0. In general dpsi/dn = 0 can only be imposed using equation elements to set the DOFs dpsi/ds_n, however in the special case of dt/ds_n = 0, then dpsi/ds_n = 0 and can be imposed using pinning - this is handled automatically in this function. For a more detailed description of the equations see the description of the class <a class="el" href="classoomph_1_1BiharmonicFluidBoundaryElement.html" title="Point equation element used to impose the traction free edge (i.e. du/dn = 0) on the boundary when dt...">BiharmonicFluidBoundaryElement</a>. </p>
<p>Impose a traction free edge - i.e. v_t = 0 or dpsi/dn = 0. In general dpsi/dn = 0 can only be imposed using equation elements to set the DOFs dpsi/ds_n, however in the special case of dt/ds_n = 0, then dpsi/ds_n = 0 and can be imposed using pinning - this is handled automatically in this function. For a more detailed description of the equations see the description of the class : <a class="el" href="classoomph_1_1BiharmonicFluidBoundaryElement.html" title="Point equation element used to impose the traction free edge (i.e. du/dn = 0) on the boundary when dt...">BiharmonicFluidBoundaryElement</a>. </p>

<p class="definition">Definition at line <a class="el" href="biharmonic__problem_8cc_source.html#l00489">489</a> of file <a class="el" href="biharmonic__problem_8cc_source.html">biharmonic_problem.cc</a>.</p>

<p class="reference">References <a class="el" href="hijacked__elements_8h_source.html#l00214">oomph::Hijacked&lt; ELEMENT &gt;::hijack_nodal_value()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2dd20deeccc884a3859577a0b7f636e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd20deeccc884a3859577a0b7f636e9">&#9670;&nbsp;</a></span>Npoint_element</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classoomph_1_1BiharmonicFluidProblem.html">oomph::BiharmonicFluidProblem</a>&lt; DIM &gt;::Npoint_element</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="biharmonic__problem_8h_source.html#l00297">297</a> of file <a class="el" href="biharmonic__problem_8h_source.html">biharmonic_problem.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="biharmonic__problem_8h_source.html#l00236">oomph::BiharmonicFluidProblem&lt; DIM &gt;::BiharmonicFluidProblem()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="biharmonic__problem_8h_source.html">biharmonic_problem.h</a></li>
<li><a class="el" href="biharmonic__problem_8cc_source.html">biharmonic_problem.cc</a></li>
</ul>
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:10:37
        </div>
      </div>
    </footer>
</body>
</html>
