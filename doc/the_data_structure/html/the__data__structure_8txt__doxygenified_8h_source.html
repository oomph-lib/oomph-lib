<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: the_data_structure.txt_doxygenified.h Source File</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../figures/manifest.json">
<link rel="mask-icon" href="../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../html/index.html"><img alt="oomph-lib" src="../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Get it <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../doc/subversion/html/index.html">Get code from subversion repository</a></li>
            <li><a href="../../../doc/download/html/index.html">Get code as tar file</a></li>
            <li><a href="../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">the_data_structure.txt_doxygenified.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="the__data__structure_8txt__doxygenified_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/**</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">\mainpage The data structure</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">\section intro Introduction</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">\c oomph-lib is big! This document gives a &quot;bottom up&quot; overview of</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">the library&#39;s data structure and discusses how the various objects interact. </span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">In addition to the detailed discussion provided below, the following</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">doxygen-generated lists/indices provide quick access to </span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">the documentation of \c oomph-lib&#39;s classes: clicking on the </span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">hyperlinks associated with a class takes you directly to a </span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">detailed description of its inheritance structure and</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">its members.</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">&lt;ul&gt;</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">&lt;li&gt;&lt;a href=&quot;../../the_data_structure/html/classes.html&quot;&gt; Class index &lt;/a&gt;&lt;/li&gt;</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">&lt;li&gt;&lt;a href=&quot;../../the_data_structure/html/functions.html&quot;&gt; Class member index &lt;/a&gt;&lt;/li&gt;</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">&lt;/ul&gt;</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment"> This rest of this document provides a &quot;bottom up&quot; overview of the data </span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment"> structure in \c oomph-lib and discusses how the various objects interact. </span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment"> For brevity, we usually replace the list of arguments to functions </span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment"> by `(...)&#39; and explain the main input and </span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment"> output parameters in words. The full specifications of the </span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment"> interfaces may be found in the individual class documentation,</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment"> accessible via the links at the top of this page.</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment">   </span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment"> \subsection technical_terms Technical terms</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment"> Throughout this document, certain commonly used terms have a specific</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment"> technical meaning: </span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment"> - \b Value: A \e value is a (double precision) number (e.g. a &quot;nodal </span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">   value&quot;). A value can either be an \e unknown in the problem </span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">   or be determined by a boundary condition. </span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment"> - \b Unknown: An \e unknown is a \e value that is not determined by a</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment">   boundary condition.</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment"> - \b Degree \b of \b freedom: Synonym for \e unknown; often</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment">   abbreviated as &quot;dof&quot;.</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="comment"> - \b History \b value: \e History \e values are (double precision)</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment">   numbers that are used by \c TimeSteppers to calculate </span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment">   time-derivatives of values. For instance, history values are often,</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">   but \b not \b always, the values at previous timesteps.</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment"> - \b Pinned/free: \e Values that are (are not) determined by boundary</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment">   conditions are known as pinned (free) values.</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment"> - \b Adapt: \e Mesh \e adaptation refines/un-refines meshes</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">   by adding or deleting selected nodes and elements. </span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment"> \section general_data_structure Overview of the basic data structure</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment"> The main components of \c oomph-lib are \c Data, \c Node, </span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment">\c GeneralisedElement, \c Mesh and \c Problem.</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment"> \subsection data Data</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment"> The most elementary data structure in \c oomph-lib is \c Data (ha!).</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment"> Consider the solution of a scalar PDE </span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment"> (e.g. a Poisson equation) with certain boundary conditions. </span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment"> The numerical solution of this problem requires the computation of </span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment"> the function values (double precision numbers) at a finite number </span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment"> of spatial positions (the \c Nodes). Typically, these values fall into two</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment"> categories: those that are known \e a \e priori (i.e. are enforced by </span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment"> boundary conditions), and those that must be determined as part of the </span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment"> solution.</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="comment"> \c Data stores a value --- a double precision number.</span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment"> Typically,  the values of the unknowns are determined by</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="comment"> the solution of a system of algebraic equations. The solution</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="comment"> of this system usually requires a (linear) </span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="comment"> numbering of the unknowns and associated equations. Hence, \c Data also</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment"> stores a (long) integer that represents the number of the unknown</span></div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment"> in the global numbering scheme.  \b Convention: If the \c Data value </span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="comment"> is pinned, we set the equation number to the static member data</span></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="comment"> \c Data::Is_pinned, a negative number.</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="comment"> The number of an unknown is related to the</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="comment"> number of the equation that `determines its value&#39;, so we use</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="comment"> the terms `equation number&#39; and `number of the unknown&#39;</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="comment"> interchangeably. In fact, because the term `number of the unknown&#39;</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="comment"> is rather tedious, we \e only use the term `equation number&#39;. </span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="comment">  </span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="comment"> Two observations motivate a straightforward extension</span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="comment"> of this basic data structure:</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="comment"> - In time-dependent problems, the approximation of time-derivatives</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment">   requires the storage of a certain number of auxiliary values</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment">   (e.g. the values of the unknowns at a number of previous timesteps).</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment"> - In many problems, we are not dealing with scalars (i.e. individual </span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment">   doubles) but with vector-valued unknowns; for instance, in a </span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment">   3D fluids problem, we need to store three velocity components </span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment">   at every node. </span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="comment"> Therefore, \c Data allows the storage of multiple values </span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="comment"> (all of which can either be pinned or free, and all of which have their</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="comment"> own global equation number); \c Data can also store a certain number of </span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="comment"> auxiliary (history) values used for timestepping.</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="comment"> Finally, \c Data stores a pointer to a \c TimeStepper whose member</span></div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="comment"> functions relate the history values to the values&#39; time-derivatives.</span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="comment"> Direct, pointer-based read/write access to the \c Data values is provided by</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="comment"> the functions \code Data::value_pt(i) \endcode</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="comment"> which returns a pointer to the i-th value at the present time, and by</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="comment"> \code Data::value_pt(t,i) \endcode</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="comment"> which returns a pointer to the \c t -th history value associated with</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment"> value \c i. </span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="comment"> Read-only access is also provided by the functions </span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment"> \code</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment"> Data::value(i)</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment"> \endcode</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="comment"> and its time-dependent counterpart</span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment"> \code</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment"> Data::value(t,i)</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment"> \endcode</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment"> We recommend using these functions instead of the </span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment"> pointer-based access functions for read access </span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment"> because the two \c Data::value(...) functions are overloaded</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment"> in the \c Node class (discussed below) so that they return</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment"> suitably constrained nodal values if a \c Node is hanging.</span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment"> The \c Data::value(...) functions cannot be used to set \c Data</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment"> values. For this purpose we provide the functions</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="comment"> \code</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment"> Data::set_value(i,val)</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment"> \endcode</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment"> which sets the \c i -th \c Data value to the double precision number</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment"> \c val;  and its time-dependent counterpart</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment"> \code</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="comment"> Data::set_value(t,i,val)</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="comment"> \endcode</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="comment"> which sets the \c t -th history value associated with the </span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="comment"> \c i -th \c Data value to the double precision number</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="comment"> \c val.</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="comment"> The general convention for all time-dependent data is </span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="comment"> that the index t=0 refers to values at the present time, whereas</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="comment"> the values associated with t&gt;0 correspond to history values.</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="comment"> In many cases (e.g. BDF schemes)</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="comment"> these history values are simply the values at previous timesteps, but</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="comment"> this is not guaranteed. See the section \ref timestepping</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="comment"> for further details.</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="comment"> \subsection nodes Nodes</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="comment"> In FE computations, most (but not all; see below) \c Data are associated</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="comment"> with nodal points. Conversely, all \c Nodes in a finite element</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="comment"> mesh have \c Data associated with them. \c Nodes are therefore derived</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="comment"> from \c Data, but also store a spatial position, specified </span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment"> by a certain number of spatial (Eulerian) coordinates.</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment"> The nodal positions are accessed by the member function</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment"> \code Node::x(i) \endcode</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="comment"> which returns the current value of i-th nodal coordinate or</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="comment"> \code Node::x(t,i) \endcode</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="comment"> which returns the value of i-th nodal coordinate at the present</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="comment"> (t=0) timestep or a history value, if (t&gt;0); again, note that the</span></div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="comment"> history values are not necessarily positions at previous timesteps.</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="comment"> \subsubsection advanced_features_of_nodes Advanced features:</span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="comment"> \c Nodes have the following additional features:</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="comment"> - In moving-mesh problems, we must evaluate mesh velocities, which</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="comment">   requires the storage of the nodal position at a number of previous</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="comment">   timesteps. Storage for the positional history values is allocated </span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="comment">   by the \c Node constructor. A different \c TimeStepper may be used to </span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="comment">   represent time-derivatives of nodal position, so</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="comment">   \c Nodes store a separate pointer to a positional \c TimeStepper.</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="comment">   [Note: By default, we allocate the same amount of storage for</span></div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="comment">   the history of the nodal positions as we do for the history of</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="comment">   the nodal values;  e.g. if a \c BDF&lt;2&gt; scheme is used to evaluate</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="comment">   the time-derivatives of the fluid velocities, we assume that</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="comment">   the same timestepping scheme is used (and the same amount of storage </span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="comment">   required) to determine the mesh velocities from the nodal</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="comment">   positions.]</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="comment"> - For finite elements in which the </span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="comment">   global position of a point in an element is determined by interpolation </span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="comment">   from the position of the element&#39;s \c Nodes (Lagrange-type elements), </span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment">   we need only store</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="comment">   the spatial position of the \c Nodes. In many other elements (e.g.</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="comment">   Hermite-type elements), the interpolation of the geometry requires</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="comment">   additional quantities, representing, e.g. the derivative of the</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="comment">   mapping between local and global coordinates.</span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="comment">   Therefore, we allow the storage of additional positional variables </span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment">   at each \c Node, so that, in general, every \c Node</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment">   has a number of \e generalised coordinates for each spatial coordinate</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="comment">   direction. For instance, for nodes in 1D Hermite elements,</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="comment">   the nodal coordinate of type &#39;0&#39; stores the global position at the</span></div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment">   node; the nodal coordinate of type &#39;1&#39; stores the derivative</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment">   of the global position w.r.t. to the element&#39;s local</span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment">   coordinate. The member function \code Node::x_gen(k,i) \endcode</span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="comment">   returns the \c i -th coordinate of the \c k -th coordinate type. </span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="comment"> - In the context of mesh refinement, nodes can become hanging nodes</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="comment">   (i.e. nodes on an element&#39;s edge/face that are not shared by the </span></div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;<span class="comment">   adjacent element). The &quot;hanging&quot; </span></div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="comment">   status of a \c Node is indicated by the pointer to its \c HangInfo</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="comment">   object. For ordinary (non-hanging) \c Nodes this pointer is NULL, </span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="comment">   the default setting; see the section \ref Hanging_Nodes for a more</span></div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="comment">   detailed discussion of hanging nodes; in particular, the role of</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="comment">   the member functions \c Node::position() and \c Node::value()</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="comment"> - Mesh unrefinement can render nodes obsolete</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="comment">   and we use a boolean flag to indicate this status.</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="comment">   By default, \c Nodes are not obsolete.</span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="comment"> - \b BoundaryNodes: \c Nodes &quot;know&quot; the domain/mesh boundaries on which </span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="comment">   they are located. A \c Node can be located</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="comment">   on none, one or multiple boundaries; the latter case arises if the</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment">   \c Node is located on edges and corners of the mesh.    </span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment">   Storage of this information facilitates the automatic</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment">   determination of boundary conditions for new \c Nodes that are</span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="comment">   created during mesh refinement.\n </span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="comment">   The majority of the \c Nodes will \b not be located on boundaries,</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="comment">   however, and providing storage for the boundary information </span></div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="comment">   in every \c Node object is rather wasteful. The derived class</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="comment">   \c BoundaryNode adds the</span></div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="comment">   required additional storage to the \c Node class and it follows that  </span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="comment">   all \c Nodes that</span></div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="comment">   could lie on boundaries must be \c BoundaryNodes; see \ref meshes for</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment">   further details.</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="comment"> - \b SolidNodes: Many solid mechanics problems </span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="comment">   are formulated in Lagrangian coordinates. </span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="comment">   In this case, the governing equations are discretised in a fixed</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="comment">   Lagrangian domain; the nodal coordinates represent the \c Nodes&#39; fixed</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="comment">   positions in this domain. When the elastic body deforms,</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment">   material points (and hence the \c Nodes) are displaced </span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment">   to new Eulerian positions. The \c SolidNode class is derived from</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment">   \c Node and contains storage for </span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="comment">   the \c Nodes&#39;</span></div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="comment">   \b fixed positions (i.e. the Lagrangian coordinates)</span></div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="comment">   AND their \b variable  positions (i.e. the</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="comment">   Eulerian coordinates), which can be unknowns in the problem. </span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="comment">   To avoid confusion between the two, the access function for the nodal </span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="comment">   position, \code Node::x(...) \endcode \b always refers to a \c Node&#39;s </span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="comment">   Eulerian position/coordinate. In \c SolidNodes, we provide </span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="comment">   a wrapper \code SolidNode::xi(..) \endcode that provides access </span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="comment">   to the Lagrangian coordinates. Similarly, in the case of generalised</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="comment">   coordinates \code Node::x_gen(...) \endcode always refers to the</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="comment">   generalised Eulerian position and \code SolidNode::xi_gen(...)</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="comment">   \endcode refers to the generalised Lagrangian position.</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="comment"> \subsection elements Elements</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment">  </span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="comment"> \subsubsection Overview</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment"> Most (finite-)elements in \c oomph-lib have a four-level inheritance </span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="comment">structure which separates:</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="comment"> -# the basic functionality that is shared by all (generalised) elements.</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="comment"> -# the functionality that is shared by all finite elements.</span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="comment"> -# the implementation of the finite element geometry (i.e. the </span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment">    shape-function-based mapping between local and global coordinates).</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="comment"> -# the representation of the mathematics that describes a specific problem.</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="comment"> .</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="comment"> The distinction between geometry and `maths&#39; greatly </span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="comment"> facilitates code-reuse as a (geometric) quad-element, say, can</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="comment"> form the basis for elements that solve a variety of equations</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="comment"> (e.g. Poisson, Advection--Diffusion, Navier--Stokes, ...).</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="comment"> We shall now discuss the four levels of the element</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="comment"> hierarchy in more detail.</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment"> \subsubsection Generalised_Element Level 0: GeneralisedElement</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="comment"> The class \c GeneralisedElement forms the base class for all</span></div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="comment"> elements in \c oomph-lib. It incorporates the basic functionality that</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="comment"> all \b elements must have. The interfaces at this level are </span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="comment"> so general that a \c GeneralisedElement can represent discrete algebraic </span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment"> constraints (or even finite-difference stencils).</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="comment">   The main role of elements is to provide contributions to</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="comment">   a global residual vector and to the global Jacobian matrix.</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="comment">   The two virtual functions</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="comment">   \code  virtual void GeneralisedElement::get_residuals(...) \endcode</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="comment">   \code  virtual void GeneralisedElement::get_jacobian(...) \endcode</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="comment">   specify the appropriate interfaces.</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment">   In multi-physics problems, the elemental residuals and</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="comment">   Jacobian will be a combination of the residuals vectors and </span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="comment">   Jacobian matrices of the constituent</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment">   single-physics elements. An obvious implementation is to use</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="comment">   multiple inheritance and function overloading </span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment">   \code</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="comment">   class MultiPhysicsElement : public virtual SinglePhysicsOneElement,</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="comment">                               public virtual SinglePhysicsTwoElement</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="comment">    {   </span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="comment">     [...]</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="comment">                        </span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="comment">     void get_residuals(...) </span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="comment">      {</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="comment">       SinglePhysicsOneElement::get_residuals(...);</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="comment">       SinglePhysicsTwoElement::get_residuals(...);</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="comment">      }</span></div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="comment">     [...]</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="comment">    };</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="comment">    \endcode</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="comment">    where the \c MultiPhysicsElement inherits from \c</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="comment">   SinglePhysicsOneElement and \c SinglePhysicsTwoElement.</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;<span class="comment">   A problem with this implementation arises when we consider where to</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="comment">   initialise the residuals vector. If the second single-physics </span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;<span class="comment">   \c get_residuals(...) function initialises the residuals</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;<span class="comment">   vector, then the contribution of the first single-physics element</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;<span class="comment">   will be negated. When writing a single-physics element, however,</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="comment">   we cannot know whether it will ever be used as part of a</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="comment">   multi-physics element and, if so, in which order the \c get_residuals(...)</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="comment">   functions will be called. The solution adopted in \c oomph-lib is</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="comment">   to provide the two additional virtual functions</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="comment">   \code </span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="comment">   virtual void GeneralisedElement::fill_in_contribution_to_residuals(...)</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<span class="comment">   \endcode</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="comment">   \code </span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="comment">   virtual void GeneralisedElement::fill_in_contribution_to_jacobian(...)</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="comment">   \endcode</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="comment">   which \b must \b not initialise the residuals or Jacobian, but merely add</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="comment">   the contribution of the element to the vector or matrix.</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="comment">   We then use the default implementation</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<span class="comment">   \code </span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="comment">   virtual void GeneralisedElement::get_residuals(Vector&lt;double&gt; &amp;residuals) </span></div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;<span class="comment">    {</span></div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;<span class="comment">     //Zero the residuals vector</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="comment">     residuals.initialise(0.0);</span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="comment">  </span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="comment">     //Add the elemental contribution to the residuals vector</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="comment">     fill_in_contribution_to_residuals(residuals);</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="comment">     }</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="comment">    \endcode</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="comment">    which permits a simple multi-physics re-implementation</span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="comment">    \code</span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment">     class MultiPhysicsElement : public virtual SinglePhysicsOneElement,</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="comment">                                 public virtual SinglePhysicsTwoElement</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="comment">      {   </span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="comment">       [...]</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="comment">      void get_residuals(Vector&lt;double&gt; &amp;residuals) </span></div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="comment">       {</span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="comment">        //Zero the residuals vector</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="comment">        residuals.initialise(0.0);</span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="comment">        //Add the first elemental contribution to the residuals vector</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="comment">        SinglePhysicsOneElement::fill_in_contribution_to_residuals(residuals);</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="comment">        //Add the second elemental contribution to the residuals vector   </span></div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="comment">        SinglePhysicsTwoElement::fill_in_contribution_to_residuals(residuals); </span></div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="comment">       }</span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="comment">       [...]</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="comment">     };</span></div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="comment">     \endcode</span></div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="comment">    The default implementation of \c fill_in_contribution_to_jacobian(...)</span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="comment">    uses finite differences to calculate the Jacobian matrix. Hence,</span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;<span class="comment">    the simplest possible implementation of a new element requires</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="comment">    only the specification of \c fill_in_contribution_to_residuals(...).</span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="comment"> - When computing element residuals and Jacobian matrices, we need to </span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<span class="comment">   know which \c Data affects the residuals (and hence the Jacobian matrix). </span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;<span class="comment">   For a \c GeneralisedElement such \c Data exists in two forms, accessed </span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="comment">   via pointers:</span></div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="comment">   - \c Data that is internal to each element is accessed via pointers</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="comment">     to `Internal \c Data&#39;. For instance, in fluid (finite) elements with</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="comment">     discontinuous pressure interpolations, the pressure degrees of freedom </span></div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;<span class="comment">     are local to each element and are stored in </span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;<span class="comment">     the element&#39;s &#39;Internal \c Data&#39;.</span></div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;<span class="comment">   - \c Data that is external to the element. An example is</span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;<span class="comment">     a load parameter such as the external pressure that acts</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="comment">     on a shell structure. Such \c Data is accessed via pointers</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;<span class="comment">     to `External \c Data&#39;.  </span></div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;<span class="comment">   - As discussed above, all \c Data contains values that are either </span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;<span class="comment">     free (i.e. unknown) or pinned (i.e. prescribed by boundary </span></div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;<span class="comment">     conditions). Free/unknown values have a non-negative global</span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;<span class="comment">     (equation) number. When assembling an element&#39;s local </span></div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;<span class="comment">     contribution to the global residual vector and the Jacobian matrix,</span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="comment">     we refer to the unknowns by their local (equation) </span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="comment">     numbers. In order to add the elemental contribution to the appropriate </span></div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;<span class="comment">     global degree of freedom, every element has a lookup table that </span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;<span class="comment">     establishes the relation between local and global equation numbers.</span></div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;<span class="comment">     This lookup table is automatically generated by the </span></div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<span class="comment">     element&#39;s member function </span></div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;<span class="comment">     \code GeneralisedElement::assign_local_eqn_numbers() \endcode</span></div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;<span class="comment">     Access to the lookup scheme is provided by</span></div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;<span class="comment">     the member function \c eqn_number(...) so that</span></div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;<span class="comment">     \code </span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;<span class="comment">     unsigned i_local;</span></div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;<span class="comment">     GeneralisedElement el;</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;<span class="comment">     [...]</span></div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;<span class="comment">     unsigned i_global=el.eqn_number(i_local); </span></div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;<span class="comment">     \endcode </span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;<span class="comment">     returns the global equation number \c i_global corresponding </span></div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;<span class="comment">     to the local equation number \c i_local. </span></div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="comment">     The local equation numbers of the internal and external \c Data are</span></div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;<span class="comment">     stored in the private arrays \c Internal_local_eqn and \c</span></div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;<span class="comment">     External_local_eqn, accessed by the functions </span></div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;<span class="comment">     \c GeneralisedElement::internal_local_eqn(...) </span></div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;<span class="comment">     and \c GeneralisedElement::external_local_eqn(...), respectively. Thus, </span></div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;<span class="comment">     \c GeneralisedElement::internal_local_eqn(i_internal,i_value) </span></div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;<span class="comment">     returns the local</span></div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;<span class="comment">     equation number of the \c i_value -th value stored in the</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="comment">     \c i_internal -th internal \c Data object. </span></div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="comment">   - All elements have a pointer to a global \c Time object which </span></div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="comment">     allows the evaluation of time-dependent</span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="comment">     coefficients. </span></div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="comment">   .</span></div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="comment">.</span></div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="comment"> \subsubsection Finite_Element Level 1: FiniteElement</span></div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="comment"> The class \c FiniteElement is derived from \c GeneralisedElement and</span></div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="comment"> incorporates the basic functionality that all \b finite elements must have.</span></div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;<span class="comment"> - All \c FiniteElements have a certain</span></div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;<span class="comment">   number of \c Nodes. We access the \c Nodes (and their associated values) </span></div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="comment">   via pointers and identify them via their (local) node numbers so that</span></div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;<span class="comment">   \code  FiniteElement::Node_pt[n] \endcode</span></div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;<span class="comment">   or the access function</span></div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;<span class="comment">   \code FiniteElement::node_pt(n) \endcode</span></div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;<span class="comment">   returns a pointer to the element&#39;s \c n -th local \c Node.</span></div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;<span class="comment">  </span></div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;<span class="comment">  - The \c FiniteElement class provides wrapper functions that </span></div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;<span class="comment">    give direct access to an element&#39;s</span></div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;<span class="comment">    (possibly generalised) nodal positions at the present timestep or,</span></div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="comment">    where appropriate, its positional history values, so that rather than</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="comment">    \code FiniteElement::Node_pt[n]-&gt;x(i) \endcode</span></div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="comment">    we can write</span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="comment">    \code FiniteElement::nodal_position(n,i) \endcode</span></div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;<span class="comment">    Not only does this make the code more readable but also</span></div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;<span class="comment">    allows us to formulate the &quot;mathematics&quot; in general terms.\n </span></div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;<span class="comment">    [Furthermore,</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;<span class="comment">    the function \c FiniteElement::nodal_position(n,i) accesses </span></div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;<span class="comment">    the nodal positions indirectly</span></div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;<span class="comment">    via  \c Node::position(...) which ensures that the nodal position </span></div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;<span class="comment">    is consistent with any constraints associated with the \c Node&#39;s </span></div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;<span class="comment">    hanging status; see section \ref Hanging_Nodes for further details.]</span></div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;<span class="comment">  - When \c Nodes are created in a (templated) finite element mesh, </span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;<span class="comment">    it is important that \c Nodes of the correct type with the appropriate</span></div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="comment">    amount of storage are created.</span></div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;<span class="comment">    For instance, Poisson elements require \c Nodes that provide storage</span></div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<span class="comment">    for a single value at each \c Node, whereas 2D Taylor-Hood, Navier-Stokes </span></div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;<span class="comment">    elements require storage for three values (two velocities and one</span></div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;<span class="comment">    pressure) at the corner \c Nodes, </span></div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;<span class="comment">    but only two values (the two velocities) at all others. </span></div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;<span class="comment">    The member function</span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;<span class="comment">    \code FiniteElement::construct_node(...) \endcode </span></div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;<span class="comment">    creates a \c Node, stores a pointer to the \c Node in the </span></div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="comment">    \c FiniteElement::Node_pt </span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="comment">    vector and returns a pointer to the newly created \c Node. The</span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="comment">    function is overloaded in elements that require a different type</span></div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="comment">    of \c Node, for example \c SolidElement::construct_node(...) creates</span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="comment">    a \c SolidNode rather than a \c Node. \n</span></div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="comment">    The function </span></div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="comment">    \c FiniteElement::construct_node(...) determines</span></div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="comment">    the necessary parameters for the node construction from virtual</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="comment">    functions or internal data that must have been set during</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="comment">    construction of the particular element. </span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;<span class="comment">    \anchor set_commands</span></div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<span class="comment">    The spatial dimension of the \c Node and the number of</span></div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="comment">    generalised coordinates must be set in the constructor of a</span></div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;<span class="comment">    geometric \c FiniteElement (level 2 in the element hierarchy) </span></div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;<span class="comment">    by using the appropriate protected member</span></div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="comment">    functions. The only function that \b must be called is</span></div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;<span class="comment">    \code FiniteElement::set_dimension(dim), \endcode</span></div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;<span class="comment">    which sets the spatial dimension of the element; by default the</span></div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;<span class="comment">    spatial dimension of the \c FiniteElement&#39;s \c Nodes is assumed</span></div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;<span class="comment">    to be the same. For example,</span></div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;<span class="comment">    \code FiniteElement::set_dimension(2) \endcode sets both the</span></div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="comment">    spatial dimension of the element and the spatial dimension of </span></div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;<span class="comment">    its \c Nodes to be two. If the nodal dimension is not the same as the</span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;<span class="comment">    dimension of the element the member function</span></div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;<span class="comment">    \code FiniteElement::set_nodal_dimension(dim_node) \endcode</span></div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;<span class="comment">    should be used to change the value of the nodal dimension. By</span></div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;<span class="comment">    default, \c FiniteElements interpolate a single position type, the</span></div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="comment">    position itself. If generalised coordinates are used, the number of</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;<span class="comment">    generalised coordinates should be set using the function</span></div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;<span class="comment">    \code FiniteElement::set_n_nodal_position_type(n_pos_type). \endcode</span></div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;<span class="comment">    The number of values stored at each \c Node is determined from the</span></div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="comment">    virtual member function</span></div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;<span class="comment">    \code FiniteElement::required_nvalue(...)  \endcode</span></div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;<span class="comment">    In its default implementation this function returns zero so the </span></div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;<span class="comment">    function must be overloaded in specific derived \c FiniteElements</span></div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="comment">    that require storage for some values at its \c Nodes. </span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;<span class="comment">    </span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="comment">    See section \ref meshes for a full explanation of how </span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;<span class="comment">    and when \c Nodes are created.</span></div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;<span class="comment">  - The \c FiniteElement class also defines standard interfaces </span></div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;<span class="comment">    for member functions </span></div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;<span class="comment">    that compute the shape functions and their derivatives with </span></div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;<span class="comment">    respect to the local and global (Eulerian) coordinates,</span></div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;<span class="comment">    \code FiniteElement::shape(...) \endcode</span></div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;<span class="comment">    \code FiniteElement::dshape_local(...) \endcode</span></div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;<span class="comment">    The mappings from local to global Eulerian coordinates are</span></div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;<span class="comment">    implemented in complete generality in the class. The function</span></div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;<span class="comment">    \code  FiniteElement::interpolated_x(...) \endcode</span></div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;<span class="comment">    returns the interpolated Eulerian position within the element;</span></div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;<span class="comment">    \code FiniteElement::dshape_eulerian(...), \endcode</span></div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;<span class="comment">    returns the derivative of the shape functions with respect</span></div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;<span class="comment">    to the Eulerian coordinates; and</span></div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;<span class="comment">    \code  FiniteElement::J_eulerian(...) \endcode</span></div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;<span class="comment">    returns the Jacobian of the mapping from Eulerian</span></div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;<span class="comment">    coordinates to local coordinates.</span></div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;<span class="comment">  - The function \c GeneralisedElement::assign_local_eqn_numbers() </span></div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;<span class="comment">    is overloaded in the \c FiniteElement class to ensure</span></div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;<span class="comment">    that local equation numbers are also assigned to the nodal \c Data</span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="comment">    (which does not necessarily exist in all \c GeneralisedElements). These</span></div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;<span class="comment">    local equation numbers are stored in the private array</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="comment">    \c  FiniteElement::Nodal_local_eqn, accessed by the function \c</span></div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;<span class="comment">    \c FiniteElement::nodal_local_eqn(...).</span></div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;<span class="comment"> \subsubsection Geometric_Element Level 2: Geometric Elements</span></div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;<span class="comment"> At this level, we specify the element geometry and the</span></div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;<span class="comment"> mapping between local and global coordinates. </span></div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;<span class="comment"> Wherever possible, templating has been (and, for any newly</span></div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;<span class="comment"> developed elements, should be) used to formulate the elements </span></div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;<span class="comment"> in a dimension-independent way. For instance, Lagrange-type</span></div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;<span class="comment"> 1D line, 2D quad and 3D brick elements are implemented in</span></div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;<span class="comment"> the doubly-templated \c QElement&lt;DIM,NNODE_1D&gt; class.</span></div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;<span class="comment"> The template parameters indicate the spatial</span></div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;<span class="comment"> dimension of the element and the number of nodes </span></div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;<span class="comment"> along the element&#39;s one-dimensional edges. Hence, \c QElement&lt;1,3&gt;</span></div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;<span class="comment"> is a three-node line element with a quadratic mapping between</span></div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;<span class="comment"> local and global coordinates; \c QElement&lt;3,2&gt; is an 8 node brick element</span></div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;<span class="comment"> with a trilinear mapping between local and global coordinates. The</span></div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;<span class="comment"> dimension and the number of \c Nodes must be set by</span></div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;<span class="comment"> calling the appropriate \c set_ functions in the constructor, see</span></div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;<span class="comment"> \ref set_commands &quot;above&quot;.</span></div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;<span class="comment"> The most important member functions implemented at this level</span></div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;<span class="comment"> include</span></div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;<span class="comment"> - Functions that evaluate the shape functions (and their derivatives) </span></div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;<span class="comment">   at given values of the local coordinates.</span></div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;<span class="comment"> - Functions that specify the position of each \c Node inside</span></div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;<span class="comment">   its \c FiniteElement, in terms of the \c FiniteElement&#39;s local</span></div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;<span class="comment">   coordinates and, conversely, functions that determine whether </span></div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;<span class="comment">   a \c Node is located at a particular local coordinate. </span></div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;<span class="comment"> - Output functions that allow the element shapes to be plotted.</span></div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;<span class="comment"> .</span></div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;<span class="comment"> Finally, we specify a pointer to a spatial integration</span></div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;<span class="comment"> scheme (usually a Gauss rule). The order of the</span></div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;<span class="comment"> integration scheme is based on the order of the interpolation</span></div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;<span class="comment"> in the isoparametric mapping. If this is inappropriate for</span></div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;<span class="comment"> an element that is derived from a given geometric element, the default </span></div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;<span class="comment"> assignment can be over-written at a higher level. This is</span></div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;<span class="comment"> discussed in more detail in a </span></div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;<span class="comment"> &lt;A HREF=&quot;../../optimisation/html/index.html&quot;&gt;</span></div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;<span class="comment"> separate document.&lt;/A&gt;</span></div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;<span class="comment"> \subsubsection Maths_Element Level 3: `The Maths&#39;</span></div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;<span class="comment"> At this level, we implement the equations that are represented by</span></div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="comment"> the specific element. We implement the interpolation(s) for the </span></div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="comment"> unknown function(s),</span></div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="comment"> employing either the geometric shape functions that already exist</span></div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;<span class="comment"> on level 2, or employing additional shape functions </span></div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;<span class="comment"> defined at this level. This allows us to write further member </span></div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;<span class="comment"> functions such as \c interpolated_u(...), say, which compute </span></div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;<span class="comment"> the i-th velocity component at the local coordinate \c s like this</span></div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;<span class="comment"> \code</span></div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;<span class="comment"> // Create fluid element</span></div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;<span class="comment"> SomeFluidElement fluid_element;</span></div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;<span class="comment"> [...]</span></div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;<span class="comment"> // Vector of local coordinates</span></div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;<span class="comment"> Vector&lt;double&gt; s(3);</span></div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="comment"> // Vector of velocity components</span></div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;<span class="comment"> Vector&lt;double&gt; u(3);</span></div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="comment"> // Compute the velocity at local coordinate s</span></div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="comment"> fluid_element.interpolated_u(s,u);</span></div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="comment"> \endcode</span></div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="comment"> We introduce wrapper functions </span></div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;<span class="comment"> to access function values, so that we can formulate</span></div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="comment"> &quot;The Maths&quot; in generic terms. Rather than referring</span></div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<span class="comment"> to the pressure at node \c n, via</span></div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;<span class="comment"> \code</span></div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;<span class="comment"> unsigned n;</span></div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;<span class="comment"> double press = Node_pt[n]-&gt;value(3);</span></div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;<span class="comment"> \endcode</span></div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;<span class="comment"> (which forces us to remember that in this particular 3D fluid </span></div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;<span class="comment"> element, the pressure is stored as the fourth value at all nodes...),</span></div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;<span class="comment"> say, we provide an access function \c p_fluid(...) which allows us to write</span></div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;<span class="comment"> \code</span></div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;<span class="comment"> unsigned n;</span></div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;<span class="comment"> double press = fluid_element.p_fluid(n);</span></div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;<span class="comment"> \endcode</span></div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;<span class="comment"> When writing these wrapper functions, direct access to the</span></div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;<span class="comment"> nodal values should be avoided to ensure that the element </span></div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;<span class="comment"> remains functional in the presence of hanging nodes.</span></div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;<span class="comment"> Hence, the wrapper functions should make use of the </span></div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;<span class="comment"> \c Node::value(...) functions as in this example</span></div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;<span class="comment"> \code</span></div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;<span class="comment"> double SomeFluidElement::p_fluid(const unsigned&amp; n)</span></div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;<span class="comment">  { return Node_pt[n]-&gt;value(3);}</span></div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;<span class="comment"> \endcode</span></div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="comment"> [See section \ref Hanging_Nodes for a full description of hanging nodes.]</span></div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="comment"> The functions</span></div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;<span class="comment"> \code FiniteElement::assign_additional_local_eqn_numbers()  \endcode</span></div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;<span class="comment"> \code FiniteElement::get_residuals(...) \endcode</span></div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;<span class="comment"> \code FiniteElement::get_jacobian(...) \endcode</span></div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;<span class="comment"> that were defined (as virtual functions) in \c FiniteElement </span></div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;<span class="comment"> can now be implemented for the specific system of equations that</span></div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;<span class="comment"> are represented by this element. The function \c</span></div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;<span class="comment"> assign_additional_local_eqn_numbers() is called by \c</span></div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="comment"> FiniteElement::assign_local_eqn_numbers() and may be used to assign local</span></div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;<span class="comment"> equation numbers that correspond to particular physical</span></div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;<span class="comment"> variables. For example, in QCrouzeixRaviart &quot;fluid&quot; elements, the</span></div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;<span class="comment"> pressure is stored as &#39;internal \c Data&#39;, so an internal array \c P_local_eqn</span></div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;<span class="comment"> could be defined by </span></div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;<span class="comment"> \code P_local_eqn[i] = internal_local_eqn(0,i) \endcode</span></div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;<span class="comment"> but in QTaylorHood &quot;fluid&quot; elements, the pressure is stored as nodal</span></div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;<span class="comment"> \c Data, so that</span></div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;<span class="comment"> \code P_local_eqn[i] = nodal_local_eqn(Pconv[i],DIM+1) \endcode</span></div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;<span class="comment"> In the above, \c Pconv[i] is an array that returns the local node number</span></div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;<span class="comment"> at which the \c i -th pressure freedom is stored and \c DIM is the</span></div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;<span class="comment"> dimension of the element. </span></div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;<span class="comment"> The use of such an array introduces a memory overhead, however,</span></div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;<span class="comment"> because each element must permanently store these additional</span></div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;<span class="comment"> integers. In general, we prefer to use member functions for this</span></div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;<span class="comment"> purpose. In QCrouzeixRaviart elements, for example,</span></div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;<span class="comment"> \code </span></div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;<span class="comment"> int p_local_eqn(const unsigned &amp;n) </span></div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;<span class="comment">  {</span></div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;<span class="comment">   return internal_local_eqn(0,n);</span></div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;<span class="comment">  }</span></div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;<span class="comment"> \endcode</span></div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;<span class="comment"> Thus, in our standard equations the function \c</span></div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;<span class="comment"> assign_additional_local_eqn_numbers() is not used.</span></div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;<span class="comment"> Finally, the virtual function</span></div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;<span class="comment"> \code FiniteElement::required_nvalue(...)  \endcode</span></div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;<span class="comment"> should be implemented to specify the number of values that </span></div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;<span class="comment"> are stored at each of the element&#39;s local \c Nodes. The default </span></div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;<span class="comment"> number of values stored at a \c Node is zero. </span></div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;<span class="comment"> \subsubsection advanced_features_of_elements `Advanced&#39; features for the `Maths&#39; level:</span></div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;<span class="comment"> It often makes sense to subdivide the `Maths&#39; level further into</span></div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;<span class="comment"> -# A class that contains the abstract FE formulation of the mathematical</span></div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;<span class="comment">    problem.</span></div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;<span class="comment"> -# A class that combines the mathematical formulation with</span></div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;<span class="comment">    a specific geometrical element.</span></div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;<span class="comment"> An example is given by the \c QPoissonElements</span></div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;<span class="comment"> which inherit their maths from \c PoissonEquations (templated by the</span></div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;<span class="comment"> spatial dimension) and their geometry from \c QElement (templated by</span></div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;<span class="comment"> the spatial dimension and the number of nodes).  \c PoissonEquations</span></div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;<span class="comment"> specifies the weak form of the Poisson equation</span></div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;<span class="comment"> in terms of (virtual) shape and test functions. The \c QPoissonElements </span></div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;<span class="comment"> turn this abstract formulation into a specific (isoparametric) </span></div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;<span class="comment"> element, by specifying both test and shape functions </span></div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;<span class="comment"> as the geometric shape functions defined in \c QElement.</span></div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;<span class="comment"> \subsubsection no_args_for_element_constructors Important convention regarding element constructors</span></div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;<span class="comment"> To facilitate mesh generation and adaptation it is important that element</span></div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;<span class="comment"> constructors should \b not have \b any arguments! If arguments</span></div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;<span class="comment"> must be passed to an element (e.g. function pointers to </span></div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;<span class="comment"> source functions, etc.), this should be done \b after the mesh </span></div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;<span class="comment"> generation, usually in the \c Problem constructor. In adaptive mesh</span></div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;<span class="comment"> refinement procedures any function/data pointers in newly created</span></div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;<span class="comment"> elements are set to be the same as those of the father</span></div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;<span class="comment"> element. If this is not the desired behaviour, arguments should be</span></div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;<span class="comment"> passed to the elements in the function \c</span></div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;<span class="comment"> Problem::actions_after_adapt().</span></div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;<span class="comment"> \subsection meshes Meshes</span></div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;<span class="comment"> At its most basic level, a \c Mesh is simply a collection of elements</span></div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;<span class="comment"> and \c Nodes, accessed by the vectors of pointers, </span></div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;<span class="comment"> \c Mesh::Element_pt and \c Mesh::Node_pt, respectively. To facilitate </span></div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;<span class="comment"> the application of  boundary conditions, we also store vectors of</span></div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;<span class="comment"> pointers to the (\c Boundary)\c Nodes that lie on the boundaries of the mesh. </span></div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;<span class="comment"> They are accessible via the member function</span></div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;<span class="comment"> \code Mesh::boundary_node_pt(i,j) \endcode</span></div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;<span class="comment"> which returns a pointer to the \c j -th node on the \c i -th</span></div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;<span class="comment"> boundary of the mesh.</span></div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;<span class="comment"> \subsubsection Mesh_generation Mesh generation</span></div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;<span class="comment"> The \c oomph-lib data structure is designed to make the mesh generation </span></div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;<span class="comment"> process generic so that meshes developed for one </span></div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;<span class="comment"> particular problem can easily be re-used in others. For this reason, </span></div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;<span class="comment"> it is generally assumed that a \c Mesh contains only elements of a </span></div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;<span class="comment"> single type and that this element type is passed to the \c Mesh </span></div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;<span class="comment"> constructor as a template parameter. Problems that require </span></div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;<span class="comment"> multiple element types should use multiple meshes,</span></div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;<span class="comment"> which are discussed in more detail below. It is possible to mix types</span></div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;<span class="comment"> of elements within a single \c Mesh, if desired; this can</span></div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;<span class="comment"> be advantageous when the element types are very closely related, </span></div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;<span class="comment"> for example &quot;free surface&quot; elements in a mesh of &quot;Fluid&quot; elements.</span></div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;<span class="comment"> Mesh generation (usually performed in the \c Mesh &#39;s constructor) </span></div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;<span class="comment"> then works as follows:</span></div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;<span class="comment"> -# Create the first element and add the pointer to it to the </span></div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;<span class="comment">    \c Mesh::Element_pt vector. (We know which element to build </span></div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;<span class="comment">    because we have passed its type as a template parameter.)</span></div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;<span class="comment">    Since element constructors do not take any </span></div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;<span class="comment">    arguments, this step is completely generic </span></div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;<span class="comment">    and ensures that a \c Mesh that was originally</span></div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;<span class="comment">    created to solve a Poisson equation, say, can also be used to solve</span></div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;<span class="comment">    Navier-Stokes equations (provided the element topology</span></div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;<span class="comment">    is the same, i.e. provided the elements are derived from the</span></div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;<span class="comment">    same type of geometric element (e.g. quad or triangle). </span></div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;<span class="comment">    The element now exists but does not know anything about its </span></div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;<span class="comment">    \c Nodes etc.</span></div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;<span class="comment"> -# Loop over the element&#39;s \c Nodes and for each Node:</span></div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;<span class="comment">    -# Create the \c Node using</span></div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;<span class="comment">       the element&#39;s \code FiniteElement::construct_node(...) \endcode </span></div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;<span class="comment">       member function. </span></div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;<span class="comment">       As discussed above, this function creates \c Nodes of exactly the right</span></div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;<span class="comment">       type and fills in the  element&#39;s own \c Node_pt vector.</span></div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;<span class="comment">    -# \c FiniteElement::construct_node(...) returns a pointer to the</span></div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;<span class="comment">       newly created \c Node; add this to the \c Mesh::Node_pt vector.</span></div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;<span class="comment">    -# Assign the nodal coordinates.</span></div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;<span class="comment">    .</span></div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;<span class="comment">    The \c Node is now fully functional and (by default) all values</span></div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;<span class="comment">    that are stored with it are free (i.e. not pinned). </span></div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;<span class="comment"> -# If the \c Node is located on a mesh boundary then it must be a</span></div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;<span class="comment">    \c BoundaryNode. \c BoundaryNodes can be created using the function</span></div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;<span class="comment">    \code FiniteElement::construct_boundary_node(...) \endcode</span></div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;<span class="comment">    in place of \c FiniteElement::construct_node(...).</span></div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;<span class="comment">    Alternatively, if the \c Node has already been created, it can </span></div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;<span class="comment">    be upgraded to a \c BoundaryNode by using the function</span></div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;<span class="comment">    \code Mesh::convert_to_boundary_node(...) \endcode</span></div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;<span class="comment">    The function</span></div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;<span class="comment">    \code Mesh::add_boundary_node(i,&amp;node) \endcode </span></div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;<span class="comment">    should then be used to add (a pointer to) the \c BoundaryNode to </span></div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;<span class="comment">    the \c Mesh&#39;s boundary-storage scheme.</span></div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;<span class="comment">    In addition, the function </span></div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;<span class="comment">    \c Mesh::add_boundary_node() passes boundary</span></div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;<span class="comment">    information to the \c Node itself.</span></div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;<span class="comment"> -# Create the next element and loop over its \c Nodes. Some \c Nodes will</span></div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;<span class="comment">    already exist (because they have been created by the first </span></div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;<span class="comment">    element).</span></div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;<span class="comment">    For such \c Nodes, we merely add the pointer to the existing \c Nodes</span></div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;<span class="comment">    to the element&#39;s \c Node_pt vector. If a \c Node does not </span></div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;<span class="comment">    exist yet, we create it, as discussed above.</span></div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;<span class="comment"> -# Keep going until all the elements and \c Nodes have been built.</span></div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;<span class="comment">  </span></div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;<span class="comment"> \subsubsection Node_DOF_numbering Equation/DOF numbering at the mesh level</span></div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;<span class="comment"> Now that the \c Mesh is assembled, we can set up the numbering scheme for </span></div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;<span class="comment"> the unknowns that are associated with the \c Nodes and with the</span></div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;<span class="comment"> elements&#39; `internal \c Data &#39;. (For problems that </span></div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;<span class="comment"> involve `external \c Data &#39;, i.e. \c Data that is not associated with </span></div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;<span class="comment"> \c Nodes and elements, a further step is required; see section \ref problems </span></div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;<span class="comment"> below). </span></div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;<span class="comment"> As discussed above, whenever a \c Data object is created (either </span></div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;<span class="comment"> as part of a \c Node in the mesh or as `internal \c Data &#39; inside an </span></div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;<span class="comment"> element), its values are assumed to be free (i.e. not pinned).</span></div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;<span class="comment"> Before we can set up the equation numbering scheme, we must</span></div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;<span class="comment"> pin all those \c Data values that are prescribed by boundary</span></div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;<span class="comment"> conditions. This is generally done at the \c Problem level (see below) and for</span></div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;<span class="comment"> the subsequent discussion, we assume that this step has already taken</span></div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;<span class="comment"> place.</span></div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;<span class="comment"> The equation numbering scheme must achieve two</span></div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;<span class="comment"> things:</span></div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;<span class="comment"> - Every unknown value needs to be associated with a unique, non-negative</span></div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;<span class="comment">   global equation number.</span></div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;<span class="comment"> - All elements need to set up the lookup tables that establish</span></div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;<span class="comment">   the relation between local and global equation numbers.</span></div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;<span class="comment"> These tasks are performed in two steps. The function</span></div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;<span class="comment"> \code Mesh::assign_global_eqn_numbers(...) \endcode</span></div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;<span class="comment"> whose argument is a vector of pointers to doubles, \c dof_pt,</span></div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;<span class="comment"> assigns the (global) equation numbers for the element&#39;s internal \c Data </span></div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;<span class="comment"> and for all \c Data associated with the \c Mesh&#39;s \c Nodes.</span></div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;<span class="comment"> On return from this function, \c dof_pt[i] points to </span></div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;<span class="comment"> the value of the i-th global degree of freedom.  </span></div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;<span class="comment"> The setup scheme (which is fully implemented in \c oomph-lib) works </span></div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;<span class="comment"> as follows:</span></div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;<span class="comment"> -# Loop over all \c Nodes in the \c Mesh.</span></div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;<span class="comment">    - Loop over all values that are stored at that \c Node.</span></div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;<span class="comment">      - If the value is free (i.e. not pinned), add the</span></div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;<span class="comment">        pointer to the value to the \c dof_pt vector.</span></div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;<span class="comment"> -# Loop over all elements.</span></div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;<span class="comment">    - In every element, loop over the `internal \c Data &#39;</span></div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;<span class="comment">      - For every instance of `internal \c Data &#39;, loop over its values.</span></div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;<span class="comment">        - If the value is free (i.e. not pinned), add</span></div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;<span class="comment">          pointer to the value to the \c dof_pt vector.</span></div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;<span class="comment">        .</span></div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;<span class="comment">      .</span></div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;<span class="comment">    .</span></div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;<span class="comment"> .</span></div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;<span class="comment"> Once this has been done (for all \c Meshes, if there are multiple ones),</span></div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;<span class="comment"> the function</span></div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;<span class="comment"> \code Mesh::assign_local_eqn_numbers(...) \endcode</span></div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;<span class="comment"> loops over all elements and executes their</span></div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;<span class="comment"> \code FiniteElement::assign_local_eqn_numbers(); \endcode </span></div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;<span class="comment"> member function to set up the elements&#39; lookup table that translates</span></div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;<span class="comment"> between local and global equation numbers.</span></div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;<span class="comment"> \subsection problems Problems</span></div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;<span class="comment"> Finally, we reach the highest level of the \c oomph-lib hierarchy, the </span></div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;<span class="comment"> \c Problem itself. The generic components of \c Problem, </span></div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;<span class="comment"> provided in the base class of that name, are:</span></div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;<span class="comment"> - A pointer to the global \c Mesh (which can represent a number of</span></div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;<span class="comment">   submeshes, see below).</span></div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;<span class="comment"> - A pointer to the (discrete) \c Time (see section on \ref timestepping).</span></div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;<span class="comment"> - A vector of pointers to (possibly multiple) \c TimeSteppers.</span></div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;<span class="comment"> - A vector that holds pointers to any `global \c Data &#39;, i.e. \c Data </span></div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;<span class="comment">   that is not associated with elements or \c Nodes. </span></div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;<span class="comment"> - A vector \c Dof_pt that stores the pointers to all the unknown </span></div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;<span class="comment">   values (the degrees of freedom) in the problem. </span></div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;<span class="comment"> \b Multiple \b Meshes</span></div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;<span class="comment">  The mesh generation process previously described was for meshes</span></div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;<span class="comment"> that contain only elements of a single type. The process </span></div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;<span class="comment"> could easily be generalised to meshes that contain multiple element</span></div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;<span class="comment"> types by providing multiple template parameters.  </span></div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;<span class="comment"> When solving a fluid-structure interaction (FSI)</span></div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;<span class="comment"> problem we could, therefore, create a single mesh that discretises </span></div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;<span class="comment"> both the fluid and the solid domains with appropriate elements.</span></div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;<span class="comment"> However, to facilitate code re-use it is desirable to keep meshes</span></div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;<span class="comment"> as simple as possible so that a mesh that was originally</span></div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;<span class="comment"> developed for a pure fluids problem can also be used in an FSI </span></div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;<span class="comment"> context. For this reason, the \c Problem class </span></div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;<span class="comment"> allows a problem to have multiple (sub-)meshes. Pointers to each</span></div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;<span class="comment"> sub-mesh must be stored in Problem&#39;s \c Sub_mesh_pt vector by using</span></div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;<span class="comment"> the function</span></div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;<span class="comment"> \code Problem::add_sub_mesh(Mesh* const &amp;mesh_pt) \endcode</span></div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;<span class="comment"> However, many of the generic operations within \c oomph-lib </span></div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;<span class="comment"> (equation numbering,</span></div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;<span class="comment"> solving, output of solutions,...) involve looping over \b all elements</span></div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;<span class="comment"> and \c Nodes in the problem. Therefore, if a \c Problem contains multiple </span></div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;<span class="comment"> (sub-)meshes, the sub-meshes must be combined into a single</span></div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;<span class="comment"> global \c Mesh whose \c Element_pt and \c Node_pt vectors</span></div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="comment"> provide ordered access to the elements and \c Nodes in \b all</span></div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;<span class="comment"> submeshes. The function</span></div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;<span class="comment"> \code Problem::build_global_mesh() \endcode</span></div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;<span class="comment"> combines the sub-meshes into the global \c Mesh and</span></div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;<span class="comment"> must be called once all the sub-meshes have been</span></div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;<span class="comment"> constructed and &quot;added&quot; to the \c Problem.</span></div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;<span class="comment"> \b Important: Many operations (such as the shifting of </span></div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;<span class="comment"> history values in time-stepping) must be performed exactly</span></div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;<span class="comment"> once for each \c Node (or \c Data). Therefore, the vector of (pointers to) </span></div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;<span class="comment"> nodes in the global \c Mesh must not contain any duplicate entries. </span></div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;<span class="comment"> When copying (pointer to) \c Nodes from the submeshes into the global </span></div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;<span class="comment"> \c Mesh, the function \c Problem::build_global_mesh() ignores</span></div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;<span class="comment"> any \c Nodes that have already been copied from a previous submesh.</span></div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;<span class="comment"> [The \c Mesh::self_test()</span></div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;<span class="comment"> function checks for duplicates in the \c Mesh::Node_pt vector.]</span></div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;<span class="comment"> \b Convention: Recall that (\c Boundary)Nodes are `told&#39; about the number</span></div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;<span class="comment"> of the boundary they live on when the (sub-)meshes are constructed.</span></div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;<span class="comment"> In the context of multiple meshes, this raises the question</span></div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;<span class="comment"> if this number should continue to refer to the boundary number within</span></div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;<span class="comment"> the submesh or be updated to a boundary number within the global \c Mesh.</span></div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;<span class="comment"> We adopt the convention that boundary numbers remain those that were </span></div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;<span class="comment"> originally assigned when the submeshes were constructed.</span></div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;<span class="comment"> \b Multiple \b meshes \b and \b adaptivity:</span></div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;<span class="comment"> Mesh adaptation is performed separately for each submesh. Following the</span></div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;<span class="comment"> adaptation of one or more submeshes (in the process of which various</span></div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;<span class="comment"> \c Nodes/elements will have been created/deleted), we must also update</span></div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;<span class="comment"> the global \c Mesh. This is done by calling</span></div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;<span class="comment"> \code  Problem::rebuild_global_mesh(); \endcode</span></div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;<span class="comment"> and this function is executed automatically if the mesh </span></div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;<span class="comment"> adaptation/refinement is performed by</span></div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;<span class="comment"> \code  Problem::refine_uniformly(); \endcode</span></div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;<span class="comment"> or</span></div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;<span class="comment"> \code  Problem::adapt(); \endcode</span></div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;<span class="comment"> \subsubsection prob_setup Problem Construction</span></div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;<span class="comment"> Here&#39;s an overview of how \c Problems are set up and solved in \c oomph-lib. </span></div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;<span class="comment"> For simplicity, we illustrate the process for a problem with </span></div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;<span class="comment"> a single \c Mesh that contains elements of a single type.</span></div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;<span class="comment"> -# Define the element type and the \c TimeStepper (if the problem</span></div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;<span class="comment">    is time-dependent).</span></div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;<span class="comment"> -# Build the \c Mesh, passing the element type as a template parameter</span></div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;<span class="comment">    and the \c TimeStepper as an argument to the Mesh constructor.</span></div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;<span class="comment">    (Typically \c Mesh constructors take a pointer to a \c TimeStepper</span></div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;<span class="comment">    as an argument since the \c TimeStepper needs to be passed</span></div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;<span class="comment">    to the element&#39;s \c FiniteElement::construct_node(...) function.</span></div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;<span class="comment">    If the \c Problem has no time-dependence, we can pass a pointer to</span></div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;<span class="comment">    the static \c Mesh::Steady timestepper; many \c Mesh constructors</span></div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;<span class="comment">    use a pointer to this \c TimeStepper as the default argument). </span></div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;<span class="comment"> -# Create the \c Problem &#39;s global \c Data (if it has any).</span></div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;<span class="comment"> -# Apply the essential boundary conditions by pinning </span></div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;<span class="comment">    the appropriate values; all other values remain free.</span></div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;<span class="comment"> -# We now have a fully assembled \c Mesh and all elements know</span></div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;<span class="comment">    their constituent \c Nodes. However, because element constructors</span></div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;<span class="comment">    are not allowed to have any arguments, all but the simplest of</span></div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;<span class="comment">    elements will now have to be provided with additional information.</span></div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;<span class="comment">    For instance, we might need to set pointers to </span></div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;<span class="comment">    source functions, etc. </span></div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;<span class="comment"> -# Assign the equation numbers to all unknowns in the problem.</span></div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;<span class="comment">    This is accomplished in a two-stage process by</span></div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;<span class="comment">    \code Problem::assign_eqn_numbers(...) \endcode</span></div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;<span class="comment">    which </span></div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;<span class="comment">    -# Assigns the equation numbers for all global \c Data (if any)</span></div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;<span class="comment">    -# Loops over the submeshes to</span></div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;<span class="comment">       perform the global equation numbering for all values associated</span></div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;<span class="comment">       with the \c Meshes (i.e. \c Nodes and elements), using   </span></div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;<span class="comment">      \code Mesh::assign_global_eqn_numbers(...) \endcode</span></div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;<span class="comment">    -# Loops over the submeshes again to</span></div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;<span class="comment">       perform the local equation numbering for all elements associated</span></div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;<span class="comment">       with the meshes using   </span></div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;<span class="comment">      \code Mesh::assign_local_eqn_numbers(...) \endcode</span></div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;<span class="comment">    .</span></div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;<span class="comment">    [Note that we have to assign the global equation numbers for</span></div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;<span class="comment">    all meshes before we assign any local equation numbers. This is</span></div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;<span class="comment">    because the external \c Data of elements in one mesh might be</span></div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;<span class="comment">    nodal \c Data</span></div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;<span class="comment">    in another mesh -- think of fluid-structure interaction problems].</span></div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;<span class="comment">    At the end of this step, we will have filled in the \c Problem&#39;s</span></div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;<span class="comment">    \c Dof_pt vector which holds the pointers to the unknowns. [Note:</span></div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;<span class="comment">    The equation numbering scheme that is generated by the above procedure</span></div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;<span class="comment">    is unlikely to be optimal; it can (and in the interest of efficiency</span></div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;<span class="comment">    probably should) be changed afterwards </span></div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;<span class="comment">    by a problem-specific renumbering function.]</span></div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;<span class="comment"> -# Before we can solve the \c Problem we will usually have to </span></div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;<span class="comment">    perform a few additional (problem-dependent) initialisation steps.</span></div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;<span class="comment">    For instance, we might want to assign initial and/or boundary </span></div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;<span class="comment">    conditions and provide initial guesses for the unknowns.</span></div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;<span class="comment">    For time-dependent problems, the \c Problem class provides a member </span></div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;<span class="comment">    function</span></div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;<span class="comment">    \code Problem::assign_initial_values_impulsive() \endcode</span></div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;<span class="comment">    which creates a past history for all time-dependent</span></div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;<span class="comment">    unknowns, assuming an impulsive start. If you want a `smooth&#39;</span></div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;<span class="comment">    start from a given previous time-history, you will have to implement</span></div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;<span class="comment">    this yourself; in this case, consult the section </span></div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;<span class="comment">    \ref timestepping which outlines the time-stepping procedures </span></div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;<span class="comment">    in \c oomph-lib.</span></div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;<span class="comment"> -# Now we can solve the \c Problem by calling </span></div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;<span class="comment">    \code Problem::newton_solve() \endcode</span></div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;<span class="comment">    which employs the Newton-Raphson method to solve the nonlinear system</span></div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;<span class="comment">    of equations that is specified (formally) by the global Jacobian matrix</span></div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;<span class="comment">    and the global residual vectors. The function </span></div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;<span class="comment">    \c Problem::newton_solve() </span></div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;<span class="comment">    employs a linear solver which may be specified by </span></div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;<span class="comment">    \c Problem::linear_solver_pt(). The default linear solver is</span></div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;<span class="comment">    &lt;a href=&quot;http://crd.lbl.gov/~xiaoye/SuperLU/&quot;&gt; SuperLU &lt;/a&gt;.</span></div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;<span class="comment">    The Newton iteration proceeds</span></div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;<span class="comment">    until the maximum residual falls below </span></div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;<span class="comment">    \c Problem::Newton_solver_tolerance. [If the number of iterations</span></div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;<span class="comment">    exceeds \c Problem::Max_newton_iterations or if the</span></div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;<span class="comment">    the maximum residual exceeds \c Problem::Max_residuals, the</span></div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;<span class="comment">    Newton solver throws an error]. When a solution has been found, </span></div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;<span class="comment">    all unknowns in the problem (which are accessible to the \c Problem via</span></div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;<span class="comment">    its \c Dof_pt vector) are up-to-date. </span></div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;<span class="comment">    The \c Problem class also provides the function</span></div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;<span class="comment">    \code Problem::unsteady_newton_solve(...) \endcode</span></div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;<span class="comment">    for time-dependent problems. Given the current values of the</span></div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;<span class="comment">    unknowns (at time \c t = \c Problem::Time_pt-&gt;time() ) </span></div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;<span class="comment">    and their past histories, this function</span></div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;<span class="comment">    determines the solution at the advanced time \c t+dt. See </span></div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;<span class="comment">    section \ref timestepping  for more details on the conventions </span></div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;<span class="comment">    used in timestepping.</span></div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;<span class="comment"> .</span></div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;<span class="comment"> The \c Problem class also has member functions which assemble the </span></div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;<span class="comment"> global residual vector and the global Jacobian matrix.</span></div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;<span class="comment"> \b Important: \n \n Since the unknowns in the \c Problem are accessed</span></div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;<span class="comment"> directly via pointers, their values are automatically updated</span></div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;<span class="comment"> during the Newton iteration. If the \c Problem has any auxiliary</span></div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;<span class="comment"> parameters that depend on the unknowns, their values need</span></div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;<span class="comment"> to be updated whenever an unknown might have changed (i.e.</span></div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;<span class="comment"> after every step of the Newton iteration).</span></div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;<span class="comment"> For such cases, the \c Problem class provides the four (empty) </span></div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;<span class="comment"> virtual functions</span></div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;<span class="comment"> \code Problem::actions_before_newton_step() \endcode</span></div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;<span class="comment"> \code Problem::actions_after_newton_step() \endcode</span></div>
<div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;<span class="comment"> \code Problem::actions_before_newton_solve() \endcode</span></div>
<div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;<span class="comment"> and</span></div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;<span class="comment"> \code Problem::actions_after_newton_solve() \endcode</span></div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;<span class="comment"> which are executed before/after every step of the Newton iteration</span></div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;<span class="comment"> and before/after the nonlinear solve itself, respectively. </span></div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;<span class="comment"> In addition, the virtual function</span></div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;<span class="comment"> \code Problem::actions_before_newton_convergence_check() \endcode</span></div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;<span class="comment"> is executed before the residuals are calculated in the Newton solver.</span></div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;<span class="comment"> When you  formulate your own \c Problem, you will have to decide what </span></div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;<span class="comment"> (if anything)  should live in these functions. Typical examples of </span></div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;<span class="comment"> actions that should</span></div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;<span class="comment"> be taken before a solve are the update of any boundary conditions. If</span></div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;<span class="comment"> the boundary conditions depend upon variables in the problem, they must</span></div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;<span class="comment"> be updated before every Newton step and should therefore be placed in</span></div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;<span class="comment"> \c Problem::actions_before_newton_step(). Actions that take </span></div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;<span class="comment"> place after a Newton step</span></div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;<span class="comment"> or solve would include things like updating the nodal positions,</span></div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;<span class="comment"> writing output or any other</span></div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;<span class="comment"> post-processing/solution monitoring. For </span></div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;<span class="comment"> example, if the solution after each Newton step were to be documented</span></div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;<span class="comment"> this could be accomplished by calling a suitable output function in the</span></div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;<span class="comment"> \c Problem::actions_after_newton_step() function. </span></div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;<span class="comment"> In many cases, only the </span></div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;<span class="comment"> \c Problem::actions_before_newton_convergence_check() function is</span></div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;<span class="comment"> required. On entry to the Newton solver, the initial residuals are</span></div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;<span class="comment"> computed and checked, so the function is executed \b before any Newton steps</span></div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;<span class="comment"> are taken. After each Newton step, the residuals</span></div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;<span class="comment"> vector is recomputed and checked, so the function is also called</span></div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;<span class="comment"> after every Newton step (or before the next Newton</span></div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;<span class="comment"> step). Nonetheless, we provide all five functions for the greatest</span></div>
<div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;<span class="comment"> possible flexibility.</span></div>
<div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;<span class="comment"> \section timestepping Time-stepping </span></div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;<span class="comment"> \subsection time Time</span></div>
<div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;<span class="comment"> Time-derivatives are generally evaluated by finite difference</span></div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;<span class="comment"> expressions, e.g. by BDF schemes. Hence, within the code, functions are</span></div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;<span class="comment"> only ever evaluated at discrete time levels. The class \c Time contains </span></div>
<div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;<span class="comment"> (a pointer to) the `current&#39; value of the continuous time and a </span></div>
<div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;<span class="comment"> vector of current and previous timesteps so that the value of the </span></div>
<div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;<span class="comment"> continuous time at any previous timestep can easily be reconstructed. </span></div>
<div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;<span class="comment"> This is useful/necessary if there are any explicitly time-dependent </span></div>
<div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;<span class="comment"> parameters in the problem. The general convention within all timestepping</span></div>
<div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;<span class="comment"> procedures is to associate the values at the `present&#39; time (i.e. the </span></div>
<div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;<span class="comment"> time for which a solution is sought)  with time level `0&#39;,</span></div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;<span class="comment"> those at the previous time level (where the solution is</span></div>
<div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;<span class="comment"> already known) with time levels `1&#39;, `2&#39; etc. The function</span></div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;<span class="comment"> \code Time::time(t) \endcode</span></div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;<span class="comment"> therefore returns the `current&#39; value of the continuous time if t=0,</span></div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;<span class="comment"> the continuous time before the previous timestep if t=1, etc.</span></div>
<div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;<span class="comment"> \subsection basic_timestepping Basic Time-stepping</span></div>
<div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;<span class="comment"> The base class \c TimeStepper provides the basic functionality </span></div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;<span class="comment"> required to evaluate time derivatives, and to keep track of the time </span></div>
<div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;<span class="comment"> histories of the unknowns. Primarily, a \c TimeStepper stores the coefficients</span></div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;<span class="comment"> (weights) that allow the evaluation of time-derivatives (up to a certain</span></div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;<span class="comment"> order) in terms of the history values stored in \c Data. Synchronisation of</span></div>
<div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;<span class="comment"> multiple \c TimeStepper s is ensured by providing them with pointers to the</span></div>
<div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;<span class="comment"> \c Problem&#39;s (single) \c Time object. </span></div>
<div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;<span class="comment"> Here&#39;s an illustration of the time-stepping procedure for</span></div>
<div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;<span class="comment"> an implicit scheme. </span></div>
<div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;<span class="comment"> - \b Stage \b 1: \b Initialise</span></div>
<div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;<span class="comment">   -# Add a \c TimeStepper to the \c Problem. If a \c Time object has </span></div>
<div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;<span class="comment">      not yet been</span></div>
<div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;<span class="comment">      created, the \c Problem::add_time_stepper_pt(...) function </span></div>
<div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;<span class="comment">      creates one with the necessary storage. </span></div>
<div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;<span class="comment">      If the \c Time object already exists and the new \c TimeStepper </span></div>
<div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;<span class="comment">      requires more storage than presently exists,</span></div>
<div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;<span class="comment">      the storage in the \c Time object is resized. The function also passes</span></div>
<div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;<span class="comment">      a pointer to the global \c Time object to each \c TimeStepper.</span></div>
<div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;<span class="comment">   -# Set up the \c Problem as discussed in section \ref problems </span></div>
<div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;<span class="comment">   -# Initialise the history of the previous timesteps by calling</span></div>
<div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;<span class="comment">      \c Problem::initialise_dt(...).</span></div>
<div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;<span class="comment">   -# Provide initial values for all unknowns. \b Note: In many cases,</span></div>
<div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;<span class="comment">      the initial values may be the result of a steady calculation. The</span></div>
<div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;<span class="comment">      function \c Problem::steady_newton_solve() should be used to</span></div>
<div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;<span class="comment">      calculate these values. The function sets the weights of</span></div>
<div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;<span class="comment">      the time-stepping scheme such that the time derivatives are zero</span></div>
<div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;<span class="comment">      and a steady problem is solved, even when the \c Problem&#39;s</span></div>
<div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;<span class="comment">      \c TimeStepper is not the dummy timestepper, \c Steady.</span></div>
<div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;<span class="comment">   -# Provide time histories for the values (pinned \e and free!),</span></div>
<div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;<span class="comment">      either by imposing an impulsive start or by setting history</span></div>
<div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;<span class="comment">      values according to some given time-dependence:</span></div>
<div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;<span class="comment">      When generating the initial time history for the values</span></div>
<div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;<span class="comment">      from a given (`exact&#39;) solution, assign the current values and</span></div>
<div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;<span class="comment">      the history values so that the solution is represented correctly</span></div>
<div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;<span class="comment">      at the initial time, \c Time::time(). At the end of this stage,</span></div>
<div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;<span class="comment">      \c Data::value(...) must return the current values and  </span></div>
<div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;<span class="comment">      \c TimeStepper::time_derivative(...) must return their</span></div>
<div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;<span class="comment">      time-derivatives at the initial time.</span></div>
<div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;<span class="comment"> - \b Stage \b 2: \b Perform \b one \b timestep: </span></div>
<div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;<span class="comment">    \n A timestep is performed by using the </span></div>
<div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;<span class="comment">    \code  Problem::unsteady_newton_solve(...) \endcode function, </span></div>
<div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;<span class="comment">     which implements the following steps:</span></div>
<div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;<span class="comment">   -# Shift the time values back using</span></div>
<div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;<span class="comment">      \code Problem::shift_time_values() \endcode</span></div>
<div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;<span class="comment">      (For BDF timesteppers, this simply moves the history values</span></div>
<div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;<span class="comment">      back by one level; see below for a detailed discussion of</span></div>
<div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;<span class="comment">      how the shifting of the history values is performed).</span></div>
<div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;<span class="comment">   -# Solve the \c Problem at the advanced time by performing the</span></div>
<div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;<span class="comment">      following steps</span></div>
<div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;<span class="comment">       -# Choose a timestep \c dt.</span></div>
<div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;<span class="comment">       -# Advance the \c Problem&#39;s global time</span></div>
<div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;<span class="comment">          and (re-)calculate the weights for the \c TimeStepper(s). </span></div>
<div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;<span class="comment">       -# Update any time-dependent boundary conditions etc., </span></div>
<div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;<span class="comment">          usually via \code Problem::actions_before_newton_solve() \endcode</span></div>
<div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;<span class="comment">          or \code Problem::actions_before_implicit_timestep()</span></div>
<div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;<span class="comment">          \endcode</span></div>
<div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;<span class="comment">       -# Call the nonlinear solver to find the unknowns at the</span></div>
<div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;<span class="comment">          current (advanced) time. </span></div>
<div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;<span class="comment"> - \b Stage: \b 3 \b Document \b the \b solution \n</span></div>
<div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;<span class="comment">    We now have a completely consistent representation of the</span></div>
<div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;<span class="comment">    current and history values of the system&#39;s unknowns</span></div>
<div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;<span class="comment">    for the current value of \c Time::time().</span></div>
<div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;<span class="comment">    This is an excellent moment to dump the solutions to</span></div>
<div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;<span class="comment">    disk or do any other post-processing. These steps may be </span></div>
<div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;<span class="comment">    included in \code Problem::actions_after_newton_solve() \endcode </span></div>
<div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;<span class="comment">    or  \code Problem::actions_after_implicit_timestep() \endcode </span></div>
<div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;<span class="comment"> - Now return to \b Stage \b 2 for the next timestep.</span></div>
<div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;<span class="comment"> It is important to understand how the shifting of the timesteps</span></div>
<div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;<span class="comment"> (in preparation for the next timestep) is performed because certain default</span></div>
<div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;<span class="comment"> operations will not be appropriate for all \c Elements/ \c</span></div>
<div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;<span class="comment"> Problems. Recall that</span></div>
<div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;<span class="comment"> in time-dependent problems, \c Data::value_pt(i) points to the current</span></div>
<div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;<span class="comment"> (and, as yet, unknown) \c Data values, while \c Data::value_pt(t,i) for </span></div>
<div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;<span class="comment"> t&gt;0 points to the history values that the \c TimeStepper uses to</span></div>
<div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;<span class="comment"> work out time-derivatives. When we move to the next</span></div>
<div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;<span class="comment"> timestep, the history values need to be adjusted in the </span></div>
<div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;<span class="comment"> manner that is appropriate for the timestepping scheme. For instance, </span></div>
<div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;<span class="comment"> for BDF schemes, all values need to be pushed back by one time level.</span></div>
<div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;<span class="comment"> This operation is performed by the function</span></div>
<div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;<span class="comment"> \code  TimeStepper::shift_time_values(...) \endcode In the case of </span></div>
<div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;<span class="comment"> \c Nodes,</span></div>
<div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;<span class="comment"> the shifting of values associated with the nodal positions is</span></div>
<div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;<span class="comment"> performed by the function </span></div>
<div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;<span class="comment"> \code TimeStepper::shift_time_positions(...) \endcode</span></div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;<span class="comment"> To ensure that all \c Data in the \c Problem is shifted once (and only once!)</span></div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;<span class="comment"> \c Problem::shift_time_values()</span></div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;<span class="comment"> performs the following operations:</span></div>
<div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;<span class="comment"> -# Shift the values of the time history stored in the \c Time object.</span></div>
<div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;<span class="comment"> -# Shift the time values in the global \c Mesh. This involves the</span></div>
<div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;<span class="comment">    following steps:</span></div>
<div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;<span class="comment">    -# Loop over all elements and call </span></div>
<div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;<span class="comment">       \c TimeStepper::shift_time_values(...) for</span></div>
<div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;<span class="comment">       the \c TimeStepper corresponding to each internal \c Data value. This</span></div>
<div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;<span class="comment">       leads to the slightly ugly construction \code</span></div>
<div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;<span class="comment">       internal_pt(i)-&gt;time_stepper_pt()-&gt;shift_time_values(internal_pt(i))</span></div>
<div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;<span class="comment">        \endcode but there appears to be no way to avoid this.</span></div>
<div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;<span class="comment">    -# Loop over all \c Nodes in the mesh and</span></div>
<div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;<span class="comment">       -#  call \c TimeStepper::shift_time_values(...) </span></div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;<span class="comment">           for each \c Node &#39;s \c TimeStepper.</span></div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;<span class="comment">       -#  call \c TimeStepper::shift_time_positions(...) for each </span></div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;<span class="comment">           \c Node&#39;s positional \c TimeStepper.</span></div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;<span class="comment"> -# Shift the time values for all global \c Data.</span></div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;<span class="comment"> \subsection adaptive_time_stepping Adaptive time-stepping</span></div>
<div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;<span class="comment"> In adaptive time-stepping, the size of the timestep is adjusted</span></div>
<div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;<span class="comment"> automatically, so that the global (temporal) error estimate,</span></div>
<div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;<span class="comment"> computed by the Problem member function</span></div>
<div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;<span class="comment"> \code Problem::global_error_norm() \endcode</span></div>
<div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;<span class="comment"> remains below a preset threshold. However, the function </span></div>
<div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;<span class="comment"> \c Problem::global_error_norm() must be implemented for</span></div>
<div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;<span class="comment"> each specific problem. The error norm is usually </span></div>
<div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;<span class="comment"> constructed from the (estimated) errors of individual</span></div>
<div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;<span class="comment"> \c Data values. Estimates for these quantities are given by</span></div>
<div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;<span class="comment"> the differences between the actual value and </span></div>
<div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;<span class="comment"> a predicted value, as determined by</span></div>
<div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;<span class="comment"> \code TimeStepper::error_in_value(...) \endcode </span></div>
<div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;<span class="comment"> and the errors in positional \c Data values, found by</span></div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;<span class="comment"> \code TimeStepper::error_in_position(...) \endcode </span></div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;<span class="comment"> In moving mesh problems, a suitable norm is the root-mean-square</span></div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;<span class="comment"> of the errors in all positional coordinates at every \c Node. In fluid</span></div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;<span class="comment"> problems, the error is usually based on the velocity components, etc.</span></div>
<div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;<span class="comment"> Once a suitable norm has been chosen, a single adaptive timestep is</span></div>
<div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;<span class="comment"> taken by the function</span></div>
<div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;<span class="comment"> \code Problem::adaptive_unsteady_newton_solve(...) \endcode</span></div>
<div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;<span class="comment"> This function returns a double precision number that is the value </span></div>
<div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;<span class="comment"> of \c dt that should be</span></div>
<div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;<span class="comment"> taken at the next timestep. A typical calling loop is thus</span></div>
<div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;<span class="comment"> \code </span></div>
<div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;<span class="comment">  // Initial suggestion for timestep</span></div>
<div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;<span class="comment">  double dt=0.001;</span></div>
<div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;<span class="comment">  for(unsigned t=0;t&lt;100;t++)</span></div>
<div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;<span class="comment">   {</span></div>
<div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;<span class="comment">    // Try to take a timestep dt forward; if the computed</span></div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;<span class="comment">    // solution is not sufficiently accurate, reduce the</span></div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;<span class="comment">    // the timestep and repeat... Return the suggestion for</span></div>
<div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;<span class="comment">    // next timestep</span></div>
<div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;<span class="comment">    double dt_next = adaptive_unsteady_newton_solve(dt,...);</span></div>
<div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;<span class="comment">    dt = dt_next;</span></div>
<div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;<span class="comment">   }</span></div>
<div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;<span class="comment">  \endcode</span></div>
<div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;<span class="comment"> Within the \c Problem::adaptive_unsteady_newton_solve(..) function,</span></div>
<div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;<span class="comment"> if the global error norm is too large, the step is rejected, the timestep</span></div>
<div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;<span class="comment"> reduced and the step repeated. If the timestep falls below a </span></div>
<div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;<span class="comment"> preset tolerance \c Problem::Minimum_dt (which has the default value </span></div>
<div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;<span class="comment"> \c 1.0e-12), the program will terminate. It is also possible to</span></div>
<div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;<span class="comment"> set a maximum timestep by over-writing the (large) default</span></div>
<div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;<span class="comment"> for \c Problem::Maximum_dt (initialised to  \c 1.0e12) with a smaller</span></div>
<div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;<span class="comment"> value.</span></div>
<div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;<span class="comment"> \subsection restarts Restarts</span></div>
<div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;<span class="comment"> Time-dependent simulations can consume a lot of computer time, and</span></div>
<div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;<span class="comment"> it is essential to be able to restart simulations rather than having</span></div>
<div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;<span class="comment"> to re-do them from scratch if a computer crashes during the code</span></div>
<div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;<span class="comment"> execution. For this purpose </span></div>
<div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;<span class="comment"> the \c Problem class provides the two member functions</span></div>
<div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;<span class="comment"> \code Problem::dump(...) \endcode</span></div>
<div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;<span class="comment"> and </span></div>
<div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;<span class="comment"> \code Problem::read(...) \endcode</span></div>
<div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;<span class="comment"> which write/read the generic \c Problem components (i.e. the \c Data </span></div>
<div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;<span class="comment"> values and</span></div>
<div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;<span class="comment"> history values, the history of previous timestep increments, etc) to/from</span></div>
<div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;<span class="comment"> disk. These generic functions are typically called from within a specific \c</span></div>
<div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;<span class="comment"> Problem&#39;s own dump/read functions which also deal with any additional, </span></div>
<div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;<span class="comment"> problem-specific data that has to be recorded/reset to allow a proper </span></div>
<div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;<span class="comment"> restart.</span></div>
<div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;<span class="comment"> \section mesh_refinement Problem/Mesh adaptation</span></div>
<div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;<span class="comment"> \subsection RefineableProblems Adaptation at the Problem level</span></div>
<div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;<span class="comment"> The ability to adaptively refine/unrefine the \c Problem&#39;s mesh(es)</span></div>
<div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;<span class="comment"> in regions in which the solution undergoes rapid/slow variations </span></div>
<div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;<span class="comment"> is of crucial importance for the overall efficiency of the </span></div>
<div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;<span class="comment"> solution process. Mesh-adaptation involves the following steps:</span></div>
<div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;<span class="comment"> -# Compute an estimate of the error in the computed solution</span></div>
<div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;<span class="comment">    for all elements in the mesh.</span></div>
<div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;<span class="comment"> -# Label the elements whose error estimate is the above the maximum</span></div>
<div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;<span class="comment">    (or below the minimum) permissible error.</span></div>
<div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;<span class="comment"> -# Perform the actual mesh adaptation: elements whose error is too large</span></div>
<div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;<span class="comment">    are subdivided into `son&#39; elements; elements whose error is too </span></div>
<div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;<span class="comment">    small are merged with their `siblings&#39;, provided the `siblings&#39;</span></div>
<div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;<span class="comment">    are also scheduled for de-refinement. Usually, certain bounds are </span></div>
<div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;<span class="comment">    imposed on the maximum and minimum refinement levels </span></div>
<div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;<span class="comment">    to prevent excessive mesh refinement (e.g. near singularities)</span></div>
<div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;<span class="comment">    or de-refinement. (While the use of very large elements might be </span></div>
<div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;<span class="comment">    permissible in regions in which the solution varies little, such</span></div>
<div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;<span class="comment">    elements will provide a poor representation of the domain shape</span></div>
<div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;<span class="comment">    and thus lead to unsatisfactory post-processing.)</span></div>
<div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;<span class="comment"> -# Represent the previously computed solution on the newly created</span></div>
<div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;<span class="comment">    \c Nodes / elements.</span></div>
<div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;<span class="comment"> -# Once all the \c Problem&#39;s submeshes have been adapted, update the </span></div>
<div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;<span class="comment">    \c Problem itself by updating the global \c Mesh, re-generating </span></div>
<div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;<span class="comment">    the equation numbering scheme, etc.</span></div>
<div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;<span class="comment"> -# Solve the adapted \c Problem.</span></div>
<div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;<span class="comment"> The \c Problem class provides several</span></div>
<div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;<span class="comment"> functions that perform these tasks completely automatically. For </span></div>
<div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;<span class="comment"> instance, the function</span></div>
<div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;<span class="comment"> \code  Problem::refine_uniformly() \endcode</span></div>
<div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;<span class="comment"> performs one uniform mesh refinement step for all (refineable)</span></div>
<div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;<span class="comment"> submeshes in the \c Problem. Similarly, the function</span></div>
<div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;<span class="comment"> \code  Problem::adapt(...) \endcode</span></div>
<div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;<span class="comment"> performs one mesh adaptation step.</span></div>
<div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;<span class="comment"> In both functions, mesh adaptation is followed by the update of </span></div>
<div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;<span class="comment"> the global \c Mesh and the re-assignment of the equation numbers</span></div>
<div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;<span class="comment"> so that, on return from these functions, the \c Problem can immediately</span></div>
<div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;<span class="comment"> be solved again.</span></div>
<div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;<span class="comment"> The \c Problem class also provides overloaded versions</span></div>
<div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;<span class="comment"> of the steady and unsteady Newton solvers</span></div>
<div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;<span class="comment"> \code Problem::newton_solve(...) \endcode</span></div>
<div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;<span class="comment"> and </span></div>
<div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;<span class="comment"> \code Problem::unsteady_newton_solve(...) \endcode</span></div>
<div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;<span class="comment"> that automatically perform mesh adaptations until the computed </span></div>
<div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;<span class="comment"> solution satisfies the specified error bounds on all submeshes</span></div>
<div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;<span class="comment"> (or until a max. number of adaptations has been performed).</span></div>
<div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;<span class="comment"> The (empty) virtual member function</span></div>
<div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;<span class="comment"> \code Problem::set_initial_condition() \endcode</span></div>
<div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;<span class="comment"> establishes the interface to the function that sets</span></div>
<div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;<span class="comment"> all \c Data to their initial conditions. This function must be overloaded if</span></div>
<div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;<span class="comment"> nontrivial initial conditions are to be applied. (If mesh adaptations</span></div>
<div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;<span class="comment"> are performed while the first timestep is computed, the initial </span></div>
<div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;<span class="comment"> conditions on the adapted mesh can usually be represented more accurately</span></div>
<div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;<span class="comment"> by re-assigning them, rather than by interpolation from the </span></div>
<div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;<span class="comment"> coarse initial mesh). </span></div>
<div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;<span class="comment"> \subsection RefineableMeshes Adaptation at the Mesh level</span></div>
<div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;<span class="comment"> The ability to perform the adaptation at the \c Problem level relies</span></div>
<div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;<span class="comment"> on the availability of standardised interfaces to functions </span></div>
<div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;<span class="comment"> that handle the adaptation on the \c Mesh level. These </span></div>
<div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;<span class="comment"> interfaces are provided in the class \c RefineableMeshBase.</span></div>
<div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;<span class="comment">\c  RefineableMeshBase is derived from \c Mesh and stores</span></div>
<div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;<span class="comment"> a pointer to a spatial error estimator, as well as</span></div>
<div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;<span class="comment"> double precision numbers representing the target</span></div>
<div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;<span class="comment"> error levels for the adaptation. The member function</span></div>
<div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;<span class="comment"> \code  RefineableMeshBase::refine_uniformly(...) \endcode</span></div>
<div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;<span class="comment"> performs one uniform mesh refinement step. Similarly,</span></div>
<div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;<span class="comment"> \code  RefineableMeshBase::adapt(...) \endcode</span></div>
<div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;<span class="comment"> adapts the mesh according to the specified error bounds, using the mesh&#39;s</span></div>
<div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;<span class="comment"> spatial error estimator to compute the elemental errors.</span></div>
<div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;<span class="comment"> The details of the mesh adaptation process depend on the</span></div>
<div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;<span class="comment"> mesh topology; currently the virtual functions in</span></div>
<div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;<span class="comment"> \c  RefineableMeshBase are implemented in a general form for quad and</span></div>
<div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;<span class="comment"> brick elements. </span></div>
<div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;<span class="comment"> We shall discuss the mesh adaptation process </span></div>
<div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;<span class="comment"> in detail for meshes of a particular type: The \c RefineableQuadMesh</span></div>
<div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;<span class="comment"> class implements the mesh adaptation procedures for two-dimensional, </span></div>
<div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;<span class="comment"> block-structured </span></div>
<div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;<span class="comment"> meshes which consist of the refineable variant of 2D \c QElements.</span></div>
<div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;<span class="comment"> The description provides a template for the development of mesh refinement</span></div>
<div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;<span class="comment"> procedures for meshes with different element topologies (e.g. triangular</span></div>
<div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;<span class="comment"> elements, or 3D \c QElements). </span></div>
<div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;<span class="comment"> \subsection RefineableQuadMesh_section Mesh adaptation for 2D quadrilateral meshes</span></div>
<div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;<span class="comment"> \subsubsection RefineableQElementsInmeshes Refineable QElements</span></div>
<div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;<span class="comment"> The abstract base class \c RefineableQElement&lt;2&gt; `upgrades&#39; </span></div>
<div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;<span class="comment"> existing elements of (geometric) type \c QElement&lt;2,NNODE_1D&gt; to versions </span></div>
<div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;<span class="comment"> that are suitable for use in adaptive computations. &#39;Upgrading&#39;</span></div>
<div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;<span class="comment"> is achieved via inheritance so that, e.g., refineable </span></div>
<div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;<span class="comment"> Poisson elements are defined as:</span></div>
<div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;<span class="comment"> \code </span></div>
<div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;<span class="comment"> template &lt;unsigned DIM, unsigned NNODE_1D&gt;</span></div>
<div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;<span class="comment"> class RefineableQPoissonElement : public QPoissonElement&lt;DIM,NNODE_1D&gt;,</span></div>
<div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;<span class="comment"> public virtual RefineablePoissonEquations&lt;DIM&gt;,</span></div>
<div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;<span class="comment"> public virtual RefineableQElement&lt;DIM&gt;</span></div>
<div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;<span class="comment"> {</span></div>
<div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;<span class="comment">  [...]</span></div>
<div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;<span class="comment"> }</span></div>
<div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;<span class="comment"> \endcode</span></div>
<div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;<span class="comment"> The abstract base class \c RefineableQElement&lt;2&gt; defines</span></div>
<div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;<span class="comment"> virtual interfaces for those \c FiniteElement member functions</span></div>
<div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;<span class="comment"> that might have to be overloaded in the refineable version.</span></div>
<div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;<span class="comment"> In most cases, these member functions must be </span></div>
<div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;<span class="comment"> re-implemented to deal with the possible presence of hanging nodes,</span></div>
<div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;<span class="comment"> see below.</span></div>
<div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;<span class="comment"> \subsubsection QuadTreeInMeshes QuadTree procedures for mesh refinement</span></div>
<div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;<span class="comment"> Many of the mesh adaptation procedures for meshes of type </span></div>
<div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;<span class="comment"> \c RefineableQuadMesh use </span></div>
<div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;<span class="comment"> quadtree representations of the mesh. The quadtree navigation </span></div>
<div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;<span class="comment"> and search algorithms are based on those described in H. Samet&#39;s &quot;The </span></div>
<div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;<span class="comment"> design and analysis of spatial data structures&quot; (Addison-Wesley, 1990).</span></div>
<div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;<span class="comment"> [Note: Unfortunately, in the usual tree terminology, quadtrees are </span></div>
<div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;<span class="comment"> made of \e &quot;nodes&quot; which are, of</span></div>
<div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;<span class="comment"> course, completely unrelated to the \c Nodes in the finite element</span></div>
<div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;<span class="comment"> mesh! The context and -- within this document -- the different</span></div>
<div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;<span class="comment"> typefaces should make it clear which is which...]</span></div>
<div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;<span class="comment"> It is important to understand that each \c RefineableQElement&lt;2&gt; has an</span></div>
<div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;<span class="comment"> associated \c QuadTree and each \c QuadTree has an associated</span></div>
<div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;<span class="comment"> \c RefineableQElement&lt;2&gt;. This two-way &quot;has a&quot; relationship permits a</span></div>
<div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;<span class="comment"> &quot;clean&quot; implementation of the (generic) \c QuadTree algorithms, although</span></div>
<div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;<span class="comment"> it does incur the cost of two additional pointers.</span></div>
<div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;<span class="comment"> To illustrate the way in which \c RefineableQuadMeshes are represented </span></div>
<div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;<span class="comment"> by \c QuadTrees, the figure below shows a simple finite element mesh </span></div>
<div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;<span class="comment"> together with its quadtree-representation.</span></div>
<div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;<span class="comment"> There are two different types of quadtree classes: \c QuadTrees and</span></div>
<div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;<span class="comment"> \c QuadTreeRoots, which inherit from \c QuadTrees.</span></div>
<div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;<span class="comment"> The overall structure of the quadtree</span></div>
<div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;<span class="comment"> is defined by pointers between its \e &quot;nodes&quot;. </span></div>
<div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;<span class="comment"> Each \e &quot;node&quot; (an object of type \c QuadTree, shown in</span></div>
<div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;<span class="comment"> pink) in the quadtree</span></div>
<div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;<span class="comment"> has a pointer to its \e &quot;father&quot; (if this pointer is </span></div>
<div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;<span class="comment"> NULL, the \e &quot;node&quot; is the \e &quot;root node&quot;) and a vector of pointers to its</span></div>
<div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;<span class="comment"> four \e &quot;sons&quot; (if the vector is empty, the &quot;node&quot; is a \e &quot;leaf </span></div>
<div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;<span class="comment"> \e node&quot;). This data structure is sufficient to navigate the</span></div>
<div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;<span class="comment"> quadtree (e.g. identify the quadtree&#39;s \e &quot;leaf nodes&quot;, determine a </span></div>
<div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;<span class="comment"> \e &quot;node&quot;&#39;s </span></div>
<div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;<span class="comment"> neighbours, etc.) Each \c QuadTree also stores a pointer</span></div>
<div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;<span class="comment"> to an associated \e &quot;object&quot; of type \c RefineableElement (shown</span></div>
<div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;<span class="comment"> in light blue). The finite element mesh that is used in the computations</span></div>
<div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;<span class="comment"> only comprises those \c RefineableElements that are associated with</span></div>
<div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;<span class="comment"> \e &quot;leaf nodes&quot;. We refer to these elements as &quot;active elements&quot;. </span></div>
<div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;<span class="comment"> In the diagram below, the active elements are identified by thick blue</span></div>
<div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;<span class="comment"> boundaries and the blue element numbers correspond to those in the mesh.</span></div>
<div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;<span class="comment"> \image html QuadTree.gif &quot;Illustration of a QuadTree and the associated RefineableQuadMesh&quot; </span></div>
<div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;<span class="comment"> \subsubsection RefineableQuadMesh_setup_section Mesh generation</span></div>
<div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;<span class="comment"> Any \c Mesh that is designed to contain 2D \c QElement s forms a suitable </span></div>
<div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;<span class="comment"> basis for a \c RefineableQuadMesh mesh and the initial stages of </span></div>
<div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;<span class="comment"> the mesh generation process</span></div>
<div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;<span class="comment"> can be performed exactly as described in section \ref meshes above. </span></div>
<div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;<span class="comment"> Typically, the constructor for a \c RefineableQuadMesh</span></div>
<div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;<span class="comment"> will produce a relatively </span></div>
<div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;<span class="comment"> coarse background mesh (sometimes referred to as a &quot;root mesh&quot;) </span></div>
<div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;<span class="comment"> which can subsequently be refined as required. As</span></div>
<div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;<span class="comment"> discussed before,  the type of element will typically be passed as </span></div>
<div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;<span class="comment"> a template parameter and it is assumed that in any concrete </span></div>
<div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;<span class="comment"> instantiation of the \c RefineableQuadMesh class, </span></div>
<div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;<span class="comment"> the element is derived from the class \c RefineableQElement&lt;2&gt;.</span></div>
<div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;<span class="comment"> Following the generic setup of the mesh (creating elements, \c Nodes, etc), </span></div>
<div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;<span class="comment"> the constructor of the \c RefineableQuadMesh must associate each </span></div>
<div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;<span class="comment"> \c RefineableQElement&lt;2&gt; in the mesh with a \c QuadTreeRoot and vice versa.</span></div>
<div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;<span class="comment"> The association between \c RefineableQElement&lt;2&gt;s</span></div>
<div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;<span class="comment"> and \c QuadTreeRoots is established by the \c QuadTreeRoot constructor which</span></div>
<div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;<span class="comment"> takes the pointer to the \c RefineableQElement&lt;2&gt; as its argument.</span></div>
<div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;<span class="comment"> The different \c QuadTrees must then be combined into a \c QuadTreeForest,</span></div>
<div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;<span class="comment"> whose constructor establishes each \c QuadTree &#39;s </span></div>
<div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;<span class="comment"> N/S/W/E neighbours and their relative orientation. Here is an </span></div>
<div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;<span class="comment"> illustration:</span></div>
<div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;<span class="comment"> \image html QuarterCircleMesh.gif &quot;Mesh consisting of three RefineableQElement&lt;2&gt;s/ QuadTrees. Element/QuadTree numbers are blue, and the QuadTree&#39;s `northern&#39; direction is indicated by the red arrows. The QuadTrees are combined to a QuadTreeForest which establishes their adjacency (QuadTree 2 is QuadTree 0&#39;s northern neighbour etc.) and their relative orientation (QuadTree 1&#39;s North coincides with QuadTree 2&#39;s West, etc.) Note that the RefineableQElement&lt;2&gt;&#39;s local coordinates  s_0 and s_1  are aligned with the QuadTree &#39;s W--&gt;E and S--&gt;N directions, respectively.&quot; </span></div>
<div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;<span class="comment"> \image latex QuarterCircleMesh.eps &quot;Mesh consisting of three RefineableQElements&lt;2&gt;/ QuadTrees. Element/QuadTree numbers are blue, and the QuadTree&#39;s `northern&#39; direction is indicated by the red arrows. The QuadTrees are combined into a QuadTreeForest, which establishes their adjacency (QuadTree 2 is QuadTree 0&#39;s northern neighbour etc.) and their relative orientation (QuadTree 1&#39;s North coincides with QuadTree 2&#39;s West, etc.) Note that the RefineableQElement&lt;2&gt;&#39;s local coordinates  s_0 and s_1  are aligned with the QuadTree &#39;s W--&gt;E and S--&gt;N directions, respectively.&quot; </span></div>
<div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;<span class="comment"> The virtual member function </span></div>
<div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;<span class="comment"> \code RefineableQuadMesh::setup_quadtree_forest() \endcode</span></div>
<div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;<span class="comment"> creates the \c QuadTreeForest automatically and should be called at the end</span></div>
<div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;<span class="comment"> of the \c RefineableQuadMesh&#39;s constructor. </span></div>
<div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;<span class="comment"> Finally, the mesh must be given a pointer to a spatial error estimator.</span></div>
<div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;<span class="comment"> \subsubsection Hanging_Nodes Hanging Nodes</span></div>
<div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;<span class="comment"> Before explaining the details of the mesh adaptation process we</span></div>
<div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;<span class="comment"> discuss how hanging nodes are treated in \c oomph-lib. The figure below</span></div>
<div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;<span class="comment"> shows a \c RefineableQuadMesh that </span></div>
<div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;<span class="comment"> originally consisted of  four 4-node \c RefineableQElements </span></div>
<div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;<span class="comment"> and nine nodes (nodes 0 to 8). The mesh was adapted twice: During the first</span></div>
<div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;<span class="comment"> adaptation, the top right element was subdivided into </span></div>
<div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;<span class="comment"> four son elements and five new \c Nodes (nodes 9 to 13) were created.</span></div>
<div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;<span class="comment"> Then one of the newly created elements was subdivided again</span></div>
<div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;<span class="comment"> and in the process \c Nodes 14 to 18 were created. \n</span></div>
<div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;<span class="comment"> On this mesh, inter-element continuity is not ensured unless the</span></div>
<div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;<span class="comment"> hanging \c Nodes (=internal \c Nodes not shared by an adjacent </span></div>
<div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;<span class="comment"> element -- here \c Nodes 9, 10, 14, 15, 17 and 18) are suitably constrained.</span></div>
<div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;<span class="comment"> For instance, the nodal values at \c Node 10 must be linear</span></div>
<div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;<span class="comment"> combinations of the values at nodes 4 and 7 if the solution</span></div>
<div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;<span class="comment"> is to remain continuous across the eastern edge of element 2.</span></div>
<div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;<span class="comment"> We refer to nodes 4 and 7 as the &quot;master nodes&quot; of \c Node</span></div>
<div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;<span class="comment"> 10. \n</span></div>
<div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;<span class="comment"> The hanging node status of the \c Nodes can be determined </span></div>
<div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;<span class="comment"> by the following procedure:</span></div>
<div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;<span class="comment"> - Loop over all elements in the mesh. For each element \b E do:</span></div>
<div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;<span class="comment">   - Loop over the edges of element.  For each edge \b e_E do:</span></div>
<div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;<span class="comment">     - Identify the neighbouring element, \b N, that faces edge \b e_E. </span></div>
<div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;<span class="comment">     - If the neighbouring element, \b N, has the</span></div>
<div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;<span class="comment">       same size as element \b E then the hanging node </span></div>
<div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;<span class="comment">       status of the \c Nodes that are located on edge \b e_E does </span></div>
<div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;<span class="comment">       not need to be changed.</span></div>
<div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;<span class="comment">     - If the neighbouring element, \b N, is larger than  \b E, </span></div>
<div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;<span class="comment">       determine the edge \b e_N of element \b N that faces the</span></div>
<div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;<span class="comment">       edge \b e_E. Make all \c Nodes on edge \b e_N </span></div>
<div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;<span class="comment">       master nodes for all hanging \c Nodes on edge \b e_E.</span></div>
<div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;<span class="comment">     .</span></div>
<div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;<span class="comment">   . </span></div>
<div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;<span class="comment"> .</span></div>
<div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;<span class="comment"> If the difference in the refinement levels of two adjacent elements</span></div>
<div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;<span class="comment"> is greater than one, some of the master nodes determined by the</span></div>
<div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;<span class="comment"> above procedure will themselves be hanging nodes and</span></div>
<div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;<span class="comment"> these now need to be eliminated recursively. For instance, \c Nodes 9 and 11</span></div>
<div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;<span class="comment"> are initially classified as master nodes for \c Node 17. However, </span></div>
<div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;<span class="comment"> \c Node 9 is a hanging node which depends on \c Nodes 4 and 5. </span></div>
<div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;<span class="comment"> Hence, the ultimate master  nodes for \c Node 17 are \c Nodes 4, 5 and 11.</span></div>
<div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;<span class="comment"> \image html HangingNodes.gif &quot;Illustration of hanging nodes&quot;</span></div>
<div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;<span class="comment"> \image latex HangingNodes.eps &quot;Illustration of hanging nodes&quot;</span></div>
<div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;<span class="comment"> The presence of hanging nodes must not affect the </span></div>
<div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;<span class="comment"> node-based representations for the unknown function(s) and for the </span></div>
<div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;<span class="comment"> geometric </span></div>
<div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;<span class="comment"> mapping within the elements. Hence, within any</span></div>
<div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;<span class="comment"> element \f$ E \f$, a scalar function \f$ u \f$ should continue to </span></div>
<div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;<span class="comment"> be representable as</span></div>
<div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;<span class="comment"> \f[ u = \sum_{j} U_{J(j,E)} \psi_j(s) \mbox{\hspace{5cm} (1)} \f]</span></div>
<div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;<span class="comment"> while the mapping between local and global coordinates should retain </span></div>
<div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;<span class="comment"> the form</span></div>
<div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;<span class="comment">  \f[   {\bf x} = \sum_{j} {\bf X}_{J(j,E)} \psi_j(s),</span></div>
<div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;<span class="comment">        \mbox{\hspace{5cm} (2)} \f]</span></div>
<div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;<span class="comment"> where the sums are taken over the nodes \f$ j \f$ of </span></div>
<div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;<span class="comment"> the element. \f$ J(j,E) \f$</span></div>
<div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;<span class="comment"> represents the global node number of local node \f$ j \f$ in element </span></div>
<div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;<span class="comment"> \f$ E \f$ and \f$ U_J \f$ and \f$ {\bf X}_J \f$ represent </span></div>
<div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;<span class="comment"> the function value at and </span></div>
<div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;<span class="comment"> the position vector to global node  \f$ J \f$, respectively.</span></div>
<div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;<span class="comment"> To ensure inter-element continuity of \f$ u \f$ and  \f$ {\bf x} \f$, </span></div>
<div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;<span class="comment"> we constrain the nodal values and </span></div>
<div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;<span class="comment"> positions of the hanging nodes so that for every hanging</span></div>
<div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;<span class="comment"> node \f$ J \f$ we have</span></div>
<div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;<span class="comment">  \f[ U_J = \sum_{K} U_{K} \omega_{JK}  \f] </span></div>
<div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;<span class="comment"> and </span></div>
<div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;<span class="comment">  \f[ {\bf X}_J = \sum_{K} {\bf X}_{K} \omega_{JK} \f]</span></div>
<div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;<span class="comment"> where the sum is taken over the hanging node&#39;s master nodes \f$ K \f$</span></div>
<div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;<span class="comment"> and the \f$ \omega_{JK} \f$ are suitable weights.</span></div>
<div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;<span class="comment"> It is precisely this representation of the nodal positions and</span></div>
<div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;<span class="comment"> values that is implemented in \c Node::value(...) and \c Node::position().</span></div>
<div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;<span class="comment"> [Note that different nodal values can have different hanging node</span></div>
<div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;<span class="comment"> constraints; e.g. in Taylor-Hood elements where the pressure and </span></div>
<div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;<span class="comment"> velocities are interpolated by linear and quadratic basis functions.]</span></div>
<div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;<span class="comment"> For simply hanging nodes (e.g. \c Nodes 9, 10, 14 and 15 in the above sketch)</span></div>
<div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;<span class="comment"> the weights \f$ \omega_{JK} \f$ are determined as follows:</span></div>
<div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;<span class="comment"> - Find the neighbour element \b N that faces the hanging node \f$ J \f$.</span></div>
<div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;<span class="comment"> - Let \f$ s_J \f$ be the local coordinate of hanging node  \f$ J \f$ </span></div>
<div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;<span class="comment">   in the neighbour element \b N.</span></div>
<div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;<span class="comment"> - For each master node \f$ K \f$  in \b N, the weight \f$  \omega_{JK} \f$</span></div>
<div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;<span class="comment">   is then given by the shape function associated with master node</span></div>
<div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;<span class="comment">   \f$ K \f$, evaluated at \f$ s_J \f$, evaluated in element \b N.</span></div>
<div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;<span class="comment">   \f[ \omega_{JK} = \psi_K(s_J) \f]</span></div>
<div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;<span class="comment"> .</span></div>
<div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;<span class="comment"> For multiply hanging nodes (\c Nodes 17 and 18 in the above sketch),</span></div>
<div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;<span class="comment"> the weights of the ultimate master nodes are determined </span></div>
<div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;<span class="comment"> recursively, e.g. \f$ \omega_{17\ 4} = \omega_{17\ 9}  </span></div>
<div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;<span class="comment"> \times \omega_{9 \ 4}. \f$</span></div>
<div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;<span class="comment"> For \c RefineableQuadMesh meshes, </span></div>
<div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;<span class="comment"> the above procedures are fully implemented.</span></div>
<div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;<span class="comment"> Executing the function</span></div>
<div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;<span class="comment"> \code  RefineableQElement&lt;2&gt;::setup_hanging_nodes() \endcode</span></div>
<div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;<span class="comment"> for each element in the mesh establishes</span></div>
<div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;<span class="comment"> which of the elements&#39; \c Nodes are hanging and determines their </span></div>
<div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;<span class="comment"> primary master nodes and weights. Furthermore, it pins </span></div>
<div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;<span class="comment"> the values at the hanging nodes -- because the values are constrained,</span></div>
<div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;<span class="comment"> they cannot be unknowns in the problem. When this function has been </span></div>
<div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;<span class="comment"> executed for all elements in the mesh, the recursive</span></div>
<div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;<span class="comment"> elimination of hanging master nodes is performed by</span></div>
<div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;<span class="comment"> calling </span></div>
<div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;<span class="comment"> \code RefineableMesh::complete_hanging_nodes(); \endcode</span></div>
<div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;<span class="comment"> As mentioned above, the possible occurrence of hanging nodes </span></div>
<div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;<span class="comment"> needs to be reflected in</span></div>
<div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;<span class="comment"> the element&#39;s equation numbering scheme and in the functions that</span></div>
<div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;<span class="comment"> compute the elemental Jacobian matrix because the element</span></div>
<div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;<span class="comment"> residuals now potentially depend on \c Nodes outside the element. </span></div>
<div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;<span class="comment"> Therefore, \c RefineableQElement&lt;2&gt;s must re-implement</span></div>
<div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;<span class="comment"> various \c FiniteElement member functions, e.g., by re-implementing</span></div>
<div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;<span class="comment"> the virtual functions</span></div>
<div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;<span class="comment"> \code  RefineableQElement&lt;2&gt;::get_residuals() \endcode</span></div>
<div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;<span class="comment"> and </span></div>
<div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;<span class="comment"> \code  RefineableQElement&lt;2&gt;::get_jacobian(...) \endcode</span></div>
<div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;<span class="comment"> and various others, as specified in the \c RefineableQElement&lt;2&gt;</span></div>
<div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;<span class="comment"> class. </span></div>
<div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;<span class="comment"> In practice, we again distinguish between the &quot;geometry&quot; and the &quot;maths&quot;</span></div>
<div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;<span class="comment"> by writing a general \c RefineablePoissonEquations&lt;DIM&gt; class that</span></div>
<div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;<span class="comment"> inherits from \c PoissonEquations&lt;DIM&gt; and re-implements the appropriate</span></div>
<div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;<span class="comment"> member functions.</span></div>
<div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;<span class="comment"> \subsubsection RefineableQuadMesh_adaption_section Mesh adaptation</span></div>
<div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;<span class="comment"> We can now discuss the details of the mesh adaptation process</span></div>
<div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;<span class="comment"> for \c RefineableQuadMesh meshes, although the general procedure is, in fact,</span></div>
<div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;<span class="comment"> generic:</span></div>
<div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;<span class="comment"> Once a solution has been computed,</span></div>
<div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;<span class="comment"> \c Problem::adapt() loops over all refineable submeshes, and</span></div>
<div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;<span class="comment"> uses their error estimator functions to compute the vector of </span></div>
<div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;<span class="comment"> elemental errors. The vector of errors is then passed to the</span></div>
<div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;<span class="comment"> submeshes&#39;</span></div>
<div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;<span class="comment"> \code RefineableMesh::adapt(...) \endcode</span></div>
<div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;<span class="comment"> function which performs the actual mesh adaptation and</span></div>
<div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;<span class="comment"> entails the following steps:</span></div>
<div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;<span class="comment"> - Select all elements whose error exceeds the target maximum error </span></div>
<div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;<span class="comment">   for refinement, provided the elements have not already been refined </span></div>
<div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;<span class="comment">   to the maximum refinement level.</span></div>
<div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;<span class="comment"> - Select all elements whose error is smaller than the target minimum error </span></div>
<div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;<span class="comment">   for unrefinement, provided</span></div>
<div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;<span class="comment">   - their siblings (which can be identified via (Quad)Tree procedures)</span></div>
<div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;<span class="comment">     can also be unrefined</span></div>
<div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;<span class="comment">   .</span></div>
<div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;<span class="comment">   and</span></div>
<div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;<span class="comment">   - the unrefinement would not coarsen the mesh beyond the minimum</span></div>
<div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;<span class="comment">     refinement level.</span></div>
<div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;<span class="comment">   .</span></div>
<div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;<span class="comment"> - Now loop over all elements in the mesh (traversing through the leaves</span></div>
<div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;<span class="comment">   of the \c QuadTreeForest) and split those elements that are targeted for</span></div>
<div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;<span class="comment">   refinement. This involves the following steps: </span></div>
<div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;<span class="comment">   - Create new \c RefineableElements of the same type as the</span></div>
<div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;<span class="comment">     father element.</span></div>
<div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;<span class="comment">   - Create new \c QuadTrees --- as in the original setup, we </span></div>
<div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;<span class="comment">     pass the pointers to the newly created \c RefineableElements to the</span></div>
<div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;<span class="comment">     \c QuadTree constructors to establish the association between each</span></div>
<div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;<span class="comment">     \c QuadTree and its \c RefineableElement. </span></div>
<div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;<span class="comment">   - Declare the newly created \c QuadTrees to be the sons of the</span></div>
<div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;<span class="comment">     current \c QuadTree. This transforms the current \c QuadTree into a </span></div>
<div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;<span class="comment">     \e &quot;non-leaf node&quot; in the \c QuadTreeForest.</span></div>
<div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;<span class="comment">   Note that the \c RefineableElement is not deleted </span></div>
<div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;<span class="comment">   when it is split -- it retains its full functionality </span></div>
<div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;<span class="comment">   (e.g. its pointers to its \c Nodes, etc).  This ensures that the element </span></div>
<div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;<span class="comment">   is fully functional should its sons become scheduled for </span></div>
<div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;<span class="comment">   unrefinement at a later stage. Note that in cases when the \c Nodes are not</span></div>
<div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;<span class="comment"> uniformly-spaced, certain \c Nodes in the father will not be</span></div>
<div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;<span class="comment"> used by the sons. These \c Nodes will be marked as obsolete and deleted</span></div>
<div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;<span class="comment"> from the \c Mesh. The pointers to these \c Nodes must be set to NULL in</span></div>
<div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;<span class="comment"> the father element, but this cannot be done until after the hanging</span></div>
<div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;<span class="comment"> node procedures have been completed, see below.</span></div>
<div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;<span class="comment"> - The newly-created elements now exist (and are accessible via</span></div>
<div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;<span class="comment">   the leaves of the \c QuadTreeForest) but they have not been `built&#39;</span></div>
<div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;<span class="comment">   i.e. they do not have pointers to \c Nodes etc. We now </span></div>
<div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;<span class="comment">   loop over the \e &quot;leaf nodes&quot; in the \c QuadTreeForest and execute</span></div>
<div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;<span class="comment">   the virtual function</span></div>
<div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;<span class="comment">   \code RefineableElement::build() \endcode </span></div>
<div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;<span class="comment">   for all newly created elements. In the specific case of a 2D</span></div>
<div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;<span class="comment">   \c QuadMesh, the \c RefineableQElement&lt;2&gt;::build() function will be called.</span></div>
<div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;<span class="comment">   [\b Note: Elements that have not been built yet are identified</span></div>
<div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;<span class="comment">   by the fact that the entries in their \c Node_pt vector</span></div>
<div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;<span class="comment">   point to NULL. All other elements are ignored by the </span></div>
<div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;<span class="comment">   \c RefineableElement::build() function.] \n</span></div>
<div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;<span class="comment">   The \c RefineableElement::build() function</span></div>
<div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;<span class="comment">   establishes the element&#39;s pointers to its \c Nodes and creates</span></div>
<div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;<span class="comment">   new \c Nodes as and when required: some \c Nodes will already have existed </span></div>
<div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;<span class="comment">   in the old mesh; some new \c Nodes might already have been created</span></div>
<div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;<span class="comment">   by a neighbouring element, etc. If a new \c Node needs to </span></div>
<div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;<span class="comment">   be created, it is allocated with the element&#39;s </span></div>
<div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;<span class="comment">   \c FiniteElement::construct_node(...) or </span></div>
<div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;<span class="comment">   \c FiniteElement::construct_boundary_node(...) functions. </span></div>
<div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;<span class="comment">   By default, the </span></div>
<div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;<span class="comment">   current and previous positions</span></div>
<div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;<span class="comment">   of the new \c Nodes are determined via the father element&#39;s</span></div>
<div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;<span class="comment">   geometric mapping. However, rather than referring directly to</span></div>
<div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;<span class="comment">   \c QElement::interpolated_x(...), we determine the position</span></div>
<div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;<span class="comment">   with</span></div>
<div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;<span class="comment">   \code FiniteElement::get_x(...) \endcode </span></div>
<div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;<span class="comment">   which determines the nodal positions based on the father element&#39;s </span></div>
<div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;<span class="comment">   macro-element representation if it exists; see section \ref MacroElements</span></div>
<div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160;<span class="comment">   for a discussion of macro elements for mesh refinement in</span></div>
<div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;<span class="comment">   domains with curvilinear boundaries. \n</span></div>
<div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;<span class="comment">   By default, all values at a newly created \c Node are free (not pinned).</span></div>
<div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;<span class="comment">   If a new \c Node is located on the edge of the father element,</span></div>
<div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;<span class="comment">   we apply the same boundary conditions (if any) that apply along </span></div>
<div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;<span class="comment">   the father element&#39;s edge. \n</span></div>
<div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;<span class="comment">   If a \c Node lies on a \c Mesh boundary, we add it to the \c Mesh &#39;s storage</span></div>
<div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;<span class="comment">   scheme for \c BoundaryNodes. \n</span></div>
<div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;<span class="comment">   Finally, the values (and the history values) at the newly</span></div>
<div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;<span class="comment">   created \c Nodes must be assigned. This is done by using </span></div>
<div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;<span class="comment">   the interpolated values from the father element. Since the way in which</span></div>
<div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;<span class="comment">   values are interpolated inside an element is element-specific </span></div>
<div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;<span class="comment">   (e.g. in Taylor-Hood Navier-Stokes elements, different interpolations </span></div>
<div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;<span class="comment">   are used for the pressure and for the velocities), </span></div>
<div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;<span class="comment">   interpolated values are obtained from a call to the father element&#39;s</span></div>
<div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;<span class="comment">   \code  RefineableQElement&lt;2&gt;::get_interpolated_values(...) \endcode </span></div>
<div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;<span class="comment">   function which returns the vector of interpolated values (or history </span></div>
<div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;<span class="comment">   values) at a given local coordinate. This pure virtual </span></div>
<div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;<span class="comment">   function must be </span></div>
<div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;<span class="comment">   implemented for every specific \c RefineableElement. \n</span></div>
<div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;<span class="comment">   At this point, the generic steps in the build process are</span></div>
<div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;<span class="comment">   completed, but many particular \c RefineableElements now require further</span></div>
<div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160;<span class="comment">   build operations. For instance, in Crouzeix-Raviart Navier-Stokes</span></div>
<div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160;<span class="comment">   elements, the pressure interpolation is not based on nodal</span></div>
<div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;<span class="comment">   values but on internal \c Data which must be suitably initialised.</span></div>
<div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;<span class="comment">   For this purpose, we provide the interface</span></div>
<div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;<span class="comment">   \code RefineableElement::further_build(...) \endcode </span></div>
<div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;<span class="comment">   which is executed at the end of  \c RefineableElement::build(...) </span></div>
<div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;<span class="comment">   and can be used to perform any element-specific further build</span></div>
<div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;<span class="comment">   operations.</span></div>
<div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;<span class="comment"> - All new \c Nodes and elements have now been created.</span></div>
<div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;<span class="comment">   In the course of the mesh refinement, some </span></div>
<div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;<span class="comment">   of the previously existing \c Nodes that are (still) marked as hanging</span></div>
<div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;<span class="comment">   might have become non-hanging. Therefore, we now </span></div>
<div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;<span class="comment">   update the hanging nodes&#39; values and coordinates </span></div>
<div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;<span class="comment">   so that their entries</span></div>
<div class="line"><a name="l01648"></a><span class="lineno"> 1648</span>&#160;<span class="comment">   are consistent with their current hanging-node constraints and</span></div>
<div class="line"><a name="l01649"></a><span class="lineno"> 1649</span>&#160;<span class="comment">   then reset their hanging-node status to non-hanging. Finally, we </span></div>
<div class="line"><a name="l01650"></a><span class="lineno"> 1650</span>&#160;<span class="comment">   free (unpin) their nodal values. The hanging-node status </span></div>
<div class="line"><a name="l01651"></a><span class="lineno"> 1651</span>&#160;<span class="comment">   of all \c Nodes will be re-assessed later, when the de-refinement </span></div>
<div class="line"><a name="l01652"></a><span class="lineno"> 1652</span>&#160;<span class="comment">   phase is completed.</span></div>
<div class="line"><a name="l01653"></a><span class="lineno"> 1653</span>&#160;<span class="comment"> - Now we loop over \b all \e &quot;nodes&quot; in the </span></div>
<div class="line"><a name="l01654"></a><span class="lineno"> 1654</span>&#160;<span class="comment">   \c QuadTreeForest. If the sons of any \e &quot;non-leaf node&quot; in the</span></div>
<div class="line"><a name="l01655"></a><span class="lineno"> 1655</span>&#160;<span class="comment">   \c QuadTreeForest are scheduled for de-refinement, we merge them</span></div>
<div class="line"><a name="l01656"></a><span class="lineno"> 1656</span>&#160;<span class="comment">   into their father element. This entails the following steps:</span></div>
<div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;<span class="comment">   - First we execute the father element&#39;s </span></div>
<div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;<span class="comment">     \code RefineableElement::rebuild_from_sons() \endcode</span></div>
<div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;<span class="comment">     member function, which can be used, e.g., to determine </span></div>
<div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;<span class="comment">     suitable values for the father element&#39;s internal \c Data from</span></div>
<div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;<span class="comment">     the values of its sons. In addition, if any of the father&#39;s</span></div>
<div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;<span class="comment">     \c Nodes have been deleted during refinement, they must be</span></div>
<div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;<span class="comment">     re-created during the merge procedure.</span></div>
<div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;<span class="comment">   - Next, we &#39;unbuild&#39; the son elements by marking those of its \c Nodes</span></div>
<div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;<span class="comment">     that do not exist in their father element as obsolete (this</span></div>
<div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;<span class="comment">     classification can later be over-ruled by other elements that</span></div>
<div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;<span class="comment">     need to retain the \c Node).</span></div>
<div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;<span class="comment">   - Now we delete the son \c RefineableElements and the</span></div>
<div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;<span class="comment">     associated \c QuadTrees and empty the father element&#39;s</span></div>
<div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;<span class="comment">     vector of pointers to its sons. This (re)turns the father element</span></div>
<div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;<span class="comment">     into a fully functional element. </span></div>
<div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;<span class="comment">   .</span></div>
<div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;<span class="comment"> - Next, we empty the \c Mesh::Element_pt vector </span></div>
<div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;<span class="comment">   and refill it with the currently active elements which are accessible via</span></div>
<div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;<span class="comment">   the \c QuadTreeForest &#39;s \e &quot;leaf nodes&quot;. </span></div>
<div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;<span class="comment"> - Now we loop over all elements in the \c Mesh::Element_pt </span></div>
<div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160;<span class="comment">   vector and mark their \c Nodes as non-obsolete.</span></div>
<div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160;<span class="comment"> - We then update the \c Nodes hanging node status and adjust</span></div>
<div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;<span class="comment">   the nodal positions and values of the hanging nodes to make them</span></div>
<div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160;<span class="comment">   consistent with the current hanging-node constraints.</span></div>
<div class="line"><a name="l01681"></a><span class="lineno"> 1681</span>&#160;<span class="comment"> - We loop over all non-leaf elements in the \c QuadTreeForest</span></div>
<div class="line"><a name="l01682"></a><span class="lineno"> 1682</span>&#160;<span class="comment">   and call their \c deactivate_object() function, which sets</span></div>
<div class="line"><a name="l01683"></a><span class="lineno"> 1683</span>&#160;<span class="comment">   \c FiniteElement::Node_pt[n] to zero for any obsolete \c Nodes.</span></div>
<div class="line"><a name="l01684"></a><span class="lineno"> 1684</span>&#160;<span class="comment">   Any \c Nodes in the \c Mesh::Node_pt vector that are still labelled</span></div>
<div class="line"><a name="l01685"></a><span class="lineno"> 1685</span>&#160;<span class="comment">   as obsolete are truly obsolete and are deleted by calling</span></div>
<div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;<span class="comment">   \code Mesh::prune_dead_nodes() \endcode</span></div>
<div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;<span class="comment"> - Finally, in order to facilitate dump and restart operations we</span></div>
<div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;<span class="comment">   sort the \c Nodes into a standard order using </span></div>
<div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;<span class="comment">   \code Mesh::reorder_nodes() \endcode</span></div>
<div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;<span class="comment"> \section Macro_element_meshes Mesh adaptation in domains with curved boundaries</span></div>
<div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;<span class="comment"> The mesh refinement procedures outlined above are perfectly adequate</span></div>
<div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160;<span class="comment"> for meshes in polygonal domains. In such meshes the generation of</span></div>
<div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160;<span class="comment"> the new nodal positions and the transfer of the solution from the</span></div>
<div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;<span class="comment"> old to the new mesh can be performed by simple interpolation, using</span></div>
<div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;<span class="comment"> the `father&#39; element&#39;s geometric mapping and shape functions. </span></div>
<div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;<span class="comment"> However, in problems with curvilinear mesh boundaries we must</span></div>
<div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;<span class="comment"> ensure that the refined meshes provide a progressively more </span></div>
<div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;<span class="comment"> accurate representation of the curvilinear domain boundary.</span></div>
<div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;<span class="comment"> To facilitate these steps, we now introduce the concept of </span></div>
<div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;<span class="comment"> \c GeomObjects, \c Domains and \c MacroElements, which </span></div>
<div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;<span class="comment"> allow a convenient and generic representation of domains that are </span></div>
<div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;<span class="comment"> bounded by time-dependent and/or curvilinear boundaries.</span></div>
<div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;<span class="comment"> \subsection GeomObjects Geometric Objects</span></div>
<div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;<span class="comment"> Here are two examples of curvilinear boundaries</span></div>
<div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;<span class="comment"> that are frequently encountered in computations on moving domains:</span></div>
<div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;<span class="comment"> - In many problems the boundary  \f$\partial D\f$ of </span></div>
<div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;<span class="comment">   the moving domain \f$D\f$ is given explicitly in terms of a</span></div>
<div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;<span class="comment">   position vector \f[ {\bf r}_{_{\partial D}}(\boldmath{\xi},t), \f]</span></div>
<div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;<span class="comment">   where \f$ t \f$ is the (continuous) time and the components of the </span></div>
<div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;<span class="comment">   vector \f$ \boldmath{\xi} \f$  parametrise the boundary.</span></div>
<div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;<span class="comment">   We have \f$DIM({\bf r}_{_{\partial D}}) = DIM(\boldmath{\xi}) + 1\f$. </span></div>
<div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;<span class="comment">   For instance, the surface of a cylinder \f$C\f$ with time-dependent </span></div>
<div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;<span class="comment">   radius \f$R(t)\f$ can be represented as</span></div>
<div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;<span class="comment">   \f[ {\bf r}_{_{\partial C}} = \left( \begin{array}{c} </span></div>
<div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;<span class="comment">                         R(t) \cos(\xi_2) \\</span></div>
<div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;<span class="comment">                         R(t) \sin(\xi_2) \\ </span></div>
<div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;<span class="comment">                         \xi_1 \\ </span></div>
<div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;<span class="comment">                         \end{array} \right). \f]</span></div>
<div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;<span class="comment"> - In fluid problems with free surfaces or in fluid-structure</span></div>
<div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;<span class="comment">   interaction (FSI) problems, the domain boundary might have to be determined</span></div>
<div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;<span class="comment">   as part of the solution. In such cases, the boundary will have some</span></div>
<div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;<span class="comment">   computational representation. For instance, in an FSI computation</span></div>
<div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;<span class="comment">   in which a shell structure bounds the fluid domain, each shell </span></div>
<div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;<span class="comment">   finite element defines a small part of the fluid domain boundary and</span></div>
<div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;<span class="comment">   the shell element&#39;s local coordinates provide a parametrisation</span></div>
<div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;<span class="comment">   of some part of the boundary in a form similar to the one </span></div>
<div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;<span class="comment">   shown above.</span></div>
<div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;<span class="comment"> The common feature of these two examples is that, in both cases, the</span></div>
<div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;<span class="comment"> boundary is represented by a parametrised position vector.</span></div>
<div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;<span class="comment"> The \c GeomObject base class provides an abstract interface for such</span></div>
<div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;<span class="comment"> situations. In its most basic form, a `geometric object&#39;</span></div>
<div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;<span class="comment"> simply provides a parametrisation of its shape by</span></div>
<div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;<span class="comment"> implementing the \c GeomObject&#39;s pure virtual member function</span></div>
<div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;<span class="comment"> \code</span></div>
<div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;<span class="comment"> GeomObject::position(xi,r)</span></div>
<div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;<span class="comment"> \endcode</span></div>
<div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;<span class="comment"> which computes the position vector \c r at the coordinates</span></div>
<div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;<span class="comment"> specified by the vector \c xi. \c GeomObject also provides </span></div>
<div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;<span class="comment"> a large number of additional interfaces in the form of</span></div>
<div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;<span class="comment"> (broken) virtual functions. The most important of these is the</span></div>
<div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;<span class="comment"> time-dependent version of the above function</span></div>
<div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;<span class="comment"> \code</span></div>
<div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;<span class="comment"> GeomObject::position(xi,t,r)</span></div>
<div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;<span class="comment"> \endcode</span></div>
<div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;<span class="comment"> which computes the position vector \c r at the coordinates</span></div>
<div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;<span class="comment"> specified by the vector \c xi at the \b previous \b discrete</span></div>
<div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;<span class="comment"> time level \c t. We follow the usual convention that </span></div>
<div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;<span class="comment"> - for \c t=0 the vector \c r is the position vector at the current time,</span></div>
<div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;<span class="comment">   &lt;CODE&gt; time = Time::time() = Time::time(0) &lt;/CODE&gt;</span></div>
<div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;<span class="comment"> - for \c t=1 it represents the position at the previous (discrete) </span></div>
<div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;<span class="comment">   time level \c t, i.e. at the continuous time </span></div>
<div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;<span class="comment">   &lt;CODE&gt; time = Time::time() - Time::dt() = Time::time(1) &lt;/CODE&gt;</span></div>
<div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;<span class="comment"> - etc. </span></div>
<div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;<span class="comment"> .</span></div>
<div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;<span class="comment"> By default, the virtual member function \c GeomObject::position(xi,t,r)</span></div>
<div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;<span class="comment"> calls the steady version  \c GeomObject::position(xi,r), so it only </span></div>
<div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;<span class="comment"> needs to be overloaded for genuinely time-dependent geometric objects </span></div>
<div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;<span class="comment"> (by default, the</span></div>
<div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;<span class="comment"> code execution terminates if the time-dependent version is called </span></div>
<div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;<span class="comment"> for \f$ {\tt t} \ne 0; \f$ the function needs to be overloaded if this is </span></div>
<div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;<span class="comment"> not appropriate).</span></div>
<div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;<span class="comment"> Further virtual member functions provide interfaces for the determination</span></div>
<div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;<span class="comment"> of the first and second spatial and temporal derivatives of the </span></div>
<div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;<span class="comment"> position vector, allowing the computation of boundary velocities,</span></div>
<div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;<span class="comment"> accelerations and curvatures, etc. These interfaces are provided as</span></div>
<div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;<span class="comment"> broken virtual functions, so they only need to be overloaded if/when the</span></div>
<div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;<span class="comment"> functionality is actually required in a particular application.</span></div>
<div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;<span class="comment"> Typically, the shape of a \c GeomObject depends on a certain number of</span></div>
<div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;<span class="comment"> parameters (in the above examples, the radius \f$ R(t) \f$</span></div>
<div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;<span class="comment"> of the cylinder and the displacements of the shell element, respectively)</span></div>
<div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;<span class="comment"> which can be unknowns in the problem. We therefore store these parameters</span></div>
<div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;<span class="comment"> as (geometric) \c Data, whose values can be pinned or free.</span></div>
<div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;<span class="comment"> \subsection MacroElements Domains and Macro Elements</span></div>
<div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;<span class="comment"> For the purposes of mesh generation, we represent curvilinear </span></div>
<div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;<span class="comment"> domains by objects that are derived from the base class \c Domain </span></div>
<div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;<span class="comment"> and use \c GeomObjects to represent the curvilinear boundaries. </span></div>
<div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;<span class="comment"> For instance, the \c QuarterCircleSectorDomain sketched</span></div>
<div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;<span class="comment"> in the figure below is bounded by the geometric object \c Ellipse </span></div>
<div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;<span class="comment"> that parametrises the domain&#39;s curved boundary, shown in red.</span></div>
<div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;<span class="comment"> Consider the coarse discretisation of the domain </span></div>
<div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;<span class="comment"> shown in the Fig. (a) and assume that element 2 (a four-node quad </span></div>
<div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;<span class="comment"> element from the \c QElement family) is scheduled for </span></div>
<div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;<span class="comment"> refinement into four son elements. As discussed above, by default the</span></div>
<div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;<span class="comment"> \c Nodes</span></div>
<div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;<span class="comment"> of the son elements are established/created as follows:</span></div>
<div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;<span class="comment"> - If a \c Node already exists in the father element we store the pointer</span></div>
<div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;<span class="comment">   to the existing \c Node in the son element&#39;s \c Node_pt vector.</span></div>
<div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;<span class="comment"> - If a \c Node needs to be created, we determine its position from the </span></div>
<div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;<span class="comment">   geometric mapping of the father element. Thus the five new \c Nodes</span></div>
<div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;<span class="comment">   that need to be created when element 2 is refined,</span></div>
<div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160;<span class="comment">   are placed at their father element&#39;s (i.e. element 2&#39;s) local </span></div>
<div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;<span class="comment">   coordinates (0,0), (0,1), (0,-1), (1,0) and (-1,0). The</span></div>
<div class="line"><a name="l01804"></a><span class="lineno"> 1804</span>&#160;<span class="comment">   father element&#39;s</span></div>
<div class="line"><a name="l01805"></a><span class="lineno"> 1805</span>&#160;<span class="comment">   \code RefineableQElement&lt;2&gt;::get_x(...) \endcode</span></div>
<div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;<span class="comment">   determines the nodal position via a call to </span></div>
<div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;<span class="comment">   \c QElement::interpolated_x(...).</span></div>
<div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;<span class="comment">   Similarly, the nodal values of the new \c Nodes are determined by</span></div>
<div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;<span class="comment">   using the interpolated values in the father element. </span></div>
<div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;<span class="comment"> \image html MacroElementSketch.gif &quot;Illustration of mesh refinement with and without macro elements&quot;</span></div>
<div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;<span class="comment"> For the element 0, this procedure would be</span></div>
<div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;<span class="comment"> perfectly adequate, as the domain boundary after refinement </span></div>
<div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;<span class="comment"> would (still) be captured exactly.</span></div>
<div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;<span class="comment"> However, when refining element 2 by this procedure, the </span></div>
<div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;<span class="comment"> new \c Node on the boundary is positioned on the straight line </span></div>
<div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;<span class="comment"> between the two boundary \c Nodes in the father</span></div>
<div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;<span class="comment"> element and not on the curved boundary itself, as shown in Fig. (b).</span></div>
<div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;<span class="comment"> Hence repeated mesh refinement will not lead to a better </span></div>
<div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;<span class="comment"> representation of the domain geometry and preclude convergence </span></div>
<div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;<span class="comment"> to the exact solution. </span></div>
<div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;<span class="comment"> To overcome this problem, objects of type \c Domain</span></div>
<div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;<span class="comment"> provide a decomposition of the domain into a number</span></div>
<div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;<span class="comment"> of so-called \c MacroElements, as sketched in Fig. (c). Boundaries</span></div>
<div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;<span class="comment"> of the \c MacroElements are either given by (parts of) the (exact) </span></div>
<div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;<span class="comment"> curvilinear boundaries (as specified by the \c Domain&#39;s \c GeomObjects)</span></div>
<div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160;<span class="comment"> or by (arbitrary and usually straight) internal edges (or, in 3D, faces).</span></div>
<div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;<span class="comment"> In 2D, \c MacroElements provide a mapping \f$ {\bf r}(S_0,S_1) \f$</span></div>
<div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;<span class="comment"> from a local coordinate system \f$ (S_0, S_1) \f$,  with</span></div>
<div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;<span class="comment"> \f$ S_i \in [-1..1]^2 \f$, to the points inside the \c MacroElement</span></div>
<div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;<span class="comment"> via their member function</span></div>
<div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;<span class="comment"> \code MacroElement::macro_map(S,r) \endcode</span></div>
<div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;<span class="comment"> The mapping needs to be chosen such that for \f$ S_1\in [-1..1]\f$ </span></div>
<div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;<span class="comment"> the position vector \f$ {\bf r}(S_0=-1,S_1) \f$  sweeps</span></div>
<div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;<span class="comment"> along the `southern&#39; edge of the \c MacroElement, etc.; see Fig. (e).</span></div>
<div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;<span class="comment"> The form of the macro-element mapping is obviously not unique and it</span></div>
<div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;<span class="comment"> depends on the \c MacroElement&#39;s topology. The class </span></div>
<div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;<span class="comment"> \c QMacroElement&lt;2&gt; provides a mapping that is suitable for 2D quadrilateral </span></div>
<div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;<span class="comment"> elements and can therefore be used with \c RefineableQElement&lt;2&gt; s. </span></div>
<div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;<span class="comment"> The constructors for objects of</span></div>
<div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;<span class="comment"> type \c Domain typically require a vector of pointers to the </span></div>
<div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;<span class="comment"> \c GeomObjects that define its boundaries. The \c Domain constructor</span></div>
<div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;<span class="comment"> then usually employs function pointers to the </span></div>
<div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;<span class="comment"> \c GeomObject::position(...) function to define the \c MacroElement </span></div>
<div class="line"><a name="l01848"></a><span class="lineno"> 1848</span>&#160;<span class="comment"> boundaries. Once built, the \c MacroElements are accessible </span></div>
<div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160;<span class="comment"> via the member function \code Domain::macro_element_pt(...). \endcode</span></div>
<div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;<span class="comment"> We illustrate the macro-element based mesh generation and adaptation </span></div>
<div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;<span class="comment"> process for the case of \c RefineableQuadMesh meshes. </span></div>
<div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160;<span class="comment"> Assume that the domain </span></div>
<div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;<span class="comment"> is represented by an object of type \c Domain. </span></div>
<div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;<span class="comment"> We build a coarse initial mesh which contains as many</span></div>
<div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;<span class="comment"> \c RefineableQElement&lt;2&gt;s as there are \c QMacroElements in the \c Domain.</span></div>
<div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;<span class="comment"> We associate each \c RefineableQElement&lt;2&gt; with one of the \c QMacroElements</span></div>
<div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;<span class="comment"> by storing a pointer to the \c QMacroElement in </span></div>
<div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;<span class="comment"> \c FiniteElement::Macro_elem_pt. Next, we use the \c QMacroElements&#39;</span></div>
<div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;<span class="comment"> macro map to determine the \c RefineableQElement&lt;2&gt;&#39;s nodal positions such </span></div>
<div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;<span class="comment"> that, e.g., the \c RefineableQElement&lt;2&gt;&#39;s SW node is placed at the </span></div>
<div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;<span class="comment"> \c QMacroElement &#39;s local coordinates \f$(S_0,S_1)=(-1,-1)\f$, etc.</span></div>
<div class="line"><a name="l01863"></a><span class="lineno"> 1863</span>&#160;<span class="comment"> The fraction of the \c QMacroElement that is spanned by each</span></div>
<div class="line"><a name="l01864"></a><span class="lineno"> 1864</span>&#160;<span class="comment"> \c RefineableQElement&lt;2&gt; is represented by the maximum and minimum</span></div>
<div class="line"><a name="l01865"></a><span class="lineno"> 1865</span>&#160;<span class="comment"> values of the \c QMacroElement&#39;s local coordinates; the </span></div>
<div class="line"><a name="l01866"></a><span class="lineno"> 1866</span>&#160;<span class="comment"> \c RefineableQElement&lt;2&gt;</span></div>
<div class="line"><a name="l01867"></a><span class="lineno"> 1867</span>&#160;<span class="comment"> constructor initially sets these values to the defaults of +1.0 and -1.0, </span></div>
<div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;<span class="comment"> respectively, indicating that the \c RefineableQElement&lt;2&gt; spans the</span></div>
<div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160;<span class="comment"> entire area of the corresponding \c QMacroElement.</span></div>
<div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160;<span class="comment"> </span></div>
<div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;<span class="comment"> With this additional information, we modify the  </span></div>
<div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;<span class="comment"> \c RefineableQElement&lt;2&gt;::build() process as follows:</span></div>
<div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;<span class="comment"> - After creating the son elements, we set their </span></div>
<div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;<span class="comment">   \c FiniteElement::Macro_elem_pt to that of their father.</span></div>
<div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;<span class="comment"> - We adjust the son&#39;s maximum and </span></div>
<div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;<span class="comment">   minimum \c MacroElement coordinates so that they span the </span></div>
<div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;<span class="comment">   appropriate fraction of the \c MacroElement.</span></div>
<div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;<span class="comment">   For instance, for the SW son element of element 2 in the above</span></div>
<div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;<span class="comment">   sketch, we set</span></div>
<div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;<span class="comment">   \f$ S_0^{min}=-1, \  S_0^{max}=0, \ S_1^{min}=-1, \  S_1^{max}=0 \f$.</span></div>
<div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;<span class="comment">   Should this element get refined again, we set its NW son element&#39;s</span></div>
<div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;<span class="comment">   coordinates to \f$ S_0^{min}=-1, \  S_0^{max}=-0.5,</span></div>
<div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;<span class="comment">   \ S_1^{min}=-0.5, \  S_1^{max}=0 \f$, etc.</span></div>
<div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160;<span class="comment"> - The nodal positions of newly created \c Nodes are</span></div>
<div class="line"><a name="l01885"></a><span class="lineno"> 1885</span>&#160;<span class="comment">   determined via calls to the </span></div>
<div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;<span class="comment">   father element&#39;s \c RefineableQElement&lt;2&gt;::get_x(...) function.</span></div>
<div class="line"><a name="l01887"></a><span class="lineno"> 1887</span>&#160;<span class="comment">   If the father element is associated with a \c MacroElement</span></div>
<div class="line"><a name="l01888"></a><span class="lineno"> 1888</span>&#160;<span class="comment">   (indicated by a non-NULL \c RefineableQElement&lt;2&gt;::Macro_elem_pt pointer),</span></div>
<div class="line"><a name="l01889"></a><span class="lineno"> 1889</span>&#160;<span class="comment">   this function does not </span></div>
<div class="line"><a name="l01890"></a><span class="lineno"> 1890</span>&#160;<span class="comment">   refer to \c QElement::interpolated_x(...) (i.e. the FE mapping)</span></div>
<div class="line"><a name="l01891"></a><span class="lineno"> 1891</span>&#160;<span class="comment">   but places the new \c Node at the appropriate point inside the </span></div>
<div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;<span class="comment">   father&#39;s \c MacroElement. This ensures that \c Nodes that are created </span></div>
<div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160;<span class="comment">   on the \c Mesh boundaries get placed on the \c Domain boundary,</span></div>
<div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;<span class="comment">   as shown in Fig. (d).</span></div>
<div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;<span class="comment"> - In time-dependent, moving mesh problems, the history of the new \c Nodes&#39;</span></div>
<div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;<span class="comment">   position is established by calls to the time-dependent version of the</span></div>
<div class="line"><a name="l01897"></a><span class="lineno"> 1897</span>&#160;<span class="comment">   \c MacroElement::macro_map(...) function, which in turn refers to</span></div>
<div class="line"><a name="l01898"></a><span class="lineno"> 1898</span>&#160;<span class="comment">   the time-dependent \c GeomObject::position(...) function of the </span></div>
<div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;<span class="comment">   \c GeomObjects that define the \c Domain boundaries. Hence for all new </span></div>
<div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;<span class="comment">   \c Nodes, \c Node::x(t,i) for \c t&gt;0, returns the position the \c Node</span></div>
<div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;<span class="comment">   would have had if it had already existed at the previous time level t. </span></div>
<div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;<span class="comment"> - We retain the original procedure for initialising the current and </span></div>
<div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;<span class="comment">   previous values at the new \c Nodes and continue to determine them by </span></div>
<div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;<span class="comment">   interpolation from the father element, based on the father </span></div>
<div class="line"><a name="l01905"></a><span class="lineno"> 1905</span>&#160;<span class="comment">   element&#39;s local coordinates. (We cannot determine the function </span></div>
<div class="line"><a name="l01906"></a><span class="lineno"> 1906</span>&#160;<span class="comment">   values at the exact new nodal positions because new \c Nodes can be located </span></div>
<div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;<span class="comment">   outside their father elements.)</span></div>
<div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160;<span class="comment"> \subsection moving_mesh Macro-element-based node updates in moving mesh problems </span></div>
<div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;<span class="comment">  Once a \c Mesh is associated with a \c Domain, the function</span></div>
<div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;<span class="comment">  \c Mesh::node_update() updates the nodal positions in response</span></div>
<div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160;<span class="comment">  to a change in the shape of the \c GeomObjects that define the</span></div>
<div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;<span class="comment">  \c Domain boundaries. [Note: This function updates all nodal positions</span></div>
<div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;<span class="comment">  first and then updates the positions of the hanging nodes</span></div>
<div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;<span class="comment">  to subject them to the hanging node constraints.] </span></div>
<div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;<span class="comment">  Alternative procedures for the update of the nodal positions in </span></div>
<div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;<span class="comment">  response to changes in the domain boundary are implemented</span></div>
<div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;<span class="comment">  in the \c AlgebraicMesh, \c SpineMesh and \c SolidMesh classes. </span></div>
<div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;<span class="comment">&lt;hr&gt;</span></div>
<div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;<span class="comment">&lt;hr&gt;</span></div>
<div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;<span class="comment">\section pdf PDF file</span></div>
<div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;<span class="comment">A &lt;a href=&quot;../latex/refman.pdf&quot;&gt;pdf version&lt;/a&gt; of this document is available.</span></div>
<div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;<span class="comment">**/</span></div>
<div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160; </div>
</div><!-- fragment --></div><!-- contents -->
<div class="ttc" id="athe__data__structure_8txt_html_a17412bdebdfe9ca84e9d46790fc5c041"><div class="ttname"><a href="the__data__structure_8txt.html#a17412bdebdfe9ca84e9d46790fc5c041">problem</a></div><div class="ttdeci">often abbreviated as dof b History b history values are but b not b the values at previous timesteps b Pinned c c c Mesh and c Problem subsection data Data The most elementary data structure in c oomph lib is c these values fall into two and those that must be determined as part of the solution c Data stores a value a double precision number the values of the unknowns are determined by the solution of a system of algebraic equations The solution of this system usually requires c Data also stores a(long) integer that represents the number of the unknown in the global numbering scheme. \b Convention for in a fluids problem</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00092">the_data_structure.txt:92</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_aa1ca4f889ca19cc1f12e64bfec618d20"><div class="ttname"><a href="the__data__structure_8txt.html#aa1ca4f889ca19cc1f12e64bfec618d20">auxiliary</a></div><div class="ttdeci">c Data can also store a certain number of auxiliary(history) values used for timestepping. Finally</div></div>
<div class="ttc" id="anamespaceoomph_1_1QuadTreeNames_html_a8954a5947b19986b8c4b755bc7639f7da85b07d6c087e0cb66bac32a0b6a45198"><div class="ttname"><a href="namespaceoomph_1_1QuadTreeNames.html#a8954a5947b19986b8c4b755bc7639f7da85b07d6c087e0cb66bac32a0b6a45198">oomph::QuadTreeNames::S</a></div><div class="ttdeci">@ S</div><div class="ttdef"><b>Definition:</b> <a href="quadtree_8h_source.html#l00056">quadtree.h:56</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_aee4ee552ea7029a2c0fe78fe54198e82"><div class="ttname"><a href="the__data__structure_8txt.html#aee4ee552ea7029a2c0fe78fe54198e82">example</a></div><div class="ttdeci">endcode returns the global equation number c i_global corresponding to the equation number c i_local The equation numbers of the internal and external c Data are stored in the private arrays c Internal_local_eqn and c accessed by the functions c GeneralisedElement::internal_local_eqn(...) and \c GeneralisedElement see section ref Hanging_Nodes for further details When c Nodes are created in it is important that c Nodes of the correct type with the appropriate amount of storage are created For Poisson elements require c Nodes that provide storage for a single value at each c whereas Taylor Navier Stokes elements require storage for three but only two values(the two velocities) at all others. The member function \code FiniteElement by default the spatial dimension of the c FiniteElement s c Nodes is assumed to be the same For example</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00446">the_data_structure.txt:446</a></div></div>
<div class="ttc" id="acfortran_8h_html_ad66176dcd46750202b430effec302599"><div class="ttname"><a href="cfortran_8h.html#ad66176dcd46750202b430effec302599">for</a></div><div class="ttdeci">for(i=0;i&lt; sizeofcstr/elem_len;i++)</div><div class="ttdef"><b>Definition:</b> <a href="cfortran_8h_source.html#l00540">cfortran.h:540</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a67f37cd09cdb7525c4628aacc5d06cfa"><div class="ttname"><a href="the__data__structure_8txt.html#a67f37cd09cdb7525c4628aacc5d06cfa">again</a></div><div class="ttdeci">c Data can also store a certain number of c Data stores a pointer to a c TimeStepper whose member functions relate the history values to the values time derivatives pointer based read write access to the c Data values is provided by the functions code and by code Data::value_pt(t, i) \endcode which returns a pointer to the \c t -th history value associated with value \c i. Read-only access is also provided by the functions \code Data and its time dependent counterpart code whereas the values associated with t correspond to history values In many but this is not guaranteed See the section ref timestepping for further details subsection nodes Nodes In FE all c Nodes in a finite element mesh have c Data associated with them c Nodes are therefore derived from c but also store a spatial specified by a certain number of spatial(Eulerian) coordinates. The nodal positions are accessed by the member function \code Node again</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00149">the_data_structure.txt:149</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_ac9ebb4343c73c74aa1b4f977fadc3344"><div class="ttname"><a href="the__data__structure_8txt.html#ac9ebb4343c73c74aa1b4f977fadc3344">endcode</a></div><div class="ttdeci">endcode(which forces us to remember that in this particular 3D fluid element, the pressure is stored as the fourth value at all nodes...)</div></div>
<div class="ttc" id="athe__data__structure_8txt_html_aec9dd166dc17fde367203ca30cd7048e"><div class="ttname"><a href="the__data__structure_8txt.html#aec9dd166dc17fde367203ca30cd7048e">Thus</a></div><div class="ttdeci">endcode Thus</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00636">the_data_structure.txt:636</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a7c3176ec94505c0110432a370a2da0a3"><div class="ttname"><a href="the__data__structure_8txt.html#a7c3176ec94505c0110432a370a2da0a3">fluid</a></div><div class="ttdeci">endcode The default implementation of c the simplest possible implementation of a new element requires only the specification of c we need to know which c Data affects the accessed via in fluid(finite) elements with discontinuous pressure interpolations</div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a840078f64c4e152ec7f977fc08cf9155"><div class="ttname"><a href="the__data__structure_8txt.html#a840078f64c4e152ec7f977fc08cf9155">Nodes</a></div><div class="ttdeci">c Data can also store a certain number of c Data stores a pointer to a c TimeStepper whose member functions relate the history values to the values time derivatives pointer based read write access to the c Data values is provided by the functions code and by code Data::value_pt(t, i) \endcode which returns a pointer to the \c t -th history value associated with value \c i. Read-only access is also provided by the functions \code Data and its time dependent counterpart code whereas the values associated with t correspond to history values In many but this is not guaranteed See the section ref timestepping for further details subsection nodes Nodes In FE all c Nodes in a finite element mesh have c Data associated with them c Nodes are therefore derived from c but also store a spatial specified by a certain number of spatial(Eulerian) coordinates. The nodal positions are accessed by the member function \code Node note that the history values are not necessarily positions at previous timesteps subsubsection advanced_features_of_nodes Advanced we must evaluate mesh which requires the storage of the nodal position at a number of previous timesteps Storage for the positional history values is allocated by the c Node constructor A different c TimeStepper may be used to represent time derivatives of nodal so c Nodes store a separate pointer to a positional c TimeStepper[Note:By default, we allocate the same amount of storage for the history of the nodal positions as we do for the history of the nodal values;e.g. if a \c BDF&lt; 2 &gt; scheme is used to evaluate the time-derivatives of the fluid velocities, we assume that the same timestepping scheme is used(and the same amount of storage required) to determine the mesh velocities from the nodal positions.] For finite elements in which the global position of a point in an element is determined by interpolation from the position of the element s c Nodes(Lagrange-type elements)</div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a8582d62997a4d6558871208a0f2f1096"><div class="ttname"><a href="the__data__structure_8txt.html#a8582d62997a4d6558871208a0f2f1096">free</a></div><div class="ttdeci">often abbreviated as dof b History b history values are but b not b the values at previous timesteps b Pinned free</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00053">the_data_structure.txt:53</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a5448c72da3359c7796cf0c5f800732a1"><div class="ttname"><a href="the__data__structure_8txt.html#a5448c72da3359c7796cf0c5f800732a1">interpolated_u</a></div><div class="ttdeci">and code FiniteElement::J_eulerian(...) \endcode returns the Jacobian of the mapping from Eulerian coordinates to local coordinates. - The function \c GeneralisedElement c QElement&lt; 3, 2 &gt; is an node brick element with a trilinear mapping between and global coordinates The dimension and the number of c Nodes must be set by calling the appropriate c set_ functions in the see ref set_commands above The most important member functions implemented at this level include Functions that evaluate the shape in terms of the c FiniteElement s coordinates functions that determine whether a c Node is located at a particular coordinate Output functions that allow the element shapes to be plotted we specify a pointer to a spatial integration the default assignment can be over written at a higher level This is discussed in more detail in a&lt; A HREF=&quot;../../optimisation/html/index.html&quot;&gt; separate document&lt;/A &gt; subsubsection Maths_Element we implement the equations that are represented by the specific element We implement the employing either the geometric shape functions that already exist on or employing additional shape functions defined at this level This allows us to write further member functions such as c interpolated_u(...)</div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a1595240f817e8ed8141d94eae48bd2ed"><div class="ttname"><a href="the__data__structure_8txt.html#a1595240f817e8ed8141d94eae48bd2ed">level</a></div><div class="ttdeci">and code FiniteElement::J_eulerian(...) \endcode returns the Jacobian of the mapping from Eulerian coordinates to local coordinates. - The function \c GeneralisedElement c QElement&lt; 3, 2 &gt; is an node brick element with a trilinear mapping between and global coordinates The dimension and the number of c Nodes must be set by calling the appropriate c set_ functions in the see ref set_commands above The most important member functions implemented at this level include Functions that evaluate the shape in terms of the c FiniteElement s coordinates functions that determine whether a c Node is located at a particular coordinate Output functions that allow the element shapes to be plotted we specify a pointer to a spatial integration the default assignment can be over written at a higher level This is discussed in more detail in a&lt; A HREF=&quot;../../optimisation/html/index.html&quot;&gt; separate document&lt;/A &gt; subsubsection Maths_Element we implement the equations that are represented by the specific element We implement the employing either the geometric shape functions that already exist on level</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00560">the_data_structure.txt:560</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_ae56499a02d89f315ab025070e7a0058f"><div class="ttname"><a href="the__data__structure_8txt.html#ae56499a02d89f315ab025070e7a0058f">node</a></div><div class="ttdeci">c Data can also store a certain number of c Data stores a pointer to a c TimeStepper whose member functions relate the history values to the values time derivatives pointer based read write access to the c Data values is provided by the functions code and by code Data::value_pt(t, i) \endcode which returns a pointer to the \c t -th history value associated with value \c i. Read-only access is also provided by the functions \code Data and its time dependent counterpart code whereas the values associated with t correspond to history values In many but this is not guaranteed See the section ref timestepping for further details subsection nodes Nodes In FE all c Nodes in a finite element mesh have c Data associated with them c Nodes are therefore derived from c but also store a spatial specified by a certain number of spatial(Eulerian) coordinates. The nodal positions are accessed by the member function \code Node note that the history values are not necessarily positions at previous timesteps subsubsection advanced_features_of_nodes Advanced we must evaluate mesh which requires the storage of the nodal position at a number of previous timesteps Storage for the positional history values is allocated by the c Node constructor A different c TimeStepper may be used to represent time derivatives of nodal so c Nodes store a separate pointer to a positional c TimeStepper[Note:By default, we allocate the same amount of storage for the history of the nodal positions as we do for the history of the nodal values;e.g. if a \c BDF&lt; 2 &gt; scheme is used to evaluate the time-derivatives of the fluid velocities, we assume that the same timestepping scheme is used(and the same amount of storage required) to determine the mesh velocities from the nodal positions.] For finite elements in which the global position of a point in an element is determined by interpolation from the position of the element s c we need only store the spatial position of the c Nodes In many other the interpolation of the geometry requires additional e g the derivative of the mapping between and global coordinates we allow the storage of additional positional variables at each c so in every c Node has a number of e generalised coordinates for each spatial coordinate direction For for nodes in Hermite the nodal coordinate of type stores the global position at the node</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00190">the_data_structure.txt:190</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a4402588e1e4641199b2be1491d146b6e"><div class="ttname"><a href="the__data__structure_8txt.html#a4402588e1e4641199b2be1491d146b6e">Hence</a></div><div class="ttdeci">endcode When writing these wrapper direct access to the nodal values should be avoided to ensure that the element remains functional in the presence of hanging nodes Hence</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00597">the_data_structure.txt:597</a></div></div>
<div class="ttc" id="anamespaceoomph_1_1Orthpoly_html_a52ec97f3d99bf542a69568fbdddd68ec"><div class="ttname"><a href="namespaceoomph_1_1Orthpoly.html#a52ec97f3d99bf542a69568fbdddd68ec">oomph::Orthpoly::eps</a></div><div class="ttdeci">const double eps</div><div class="ttdef"><b>Definition:</b> <a href="orthpoly_8h_source.html#l00053">orthpoly.h:53</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a1400a973def57b85051cfe1070be1810"><div class="ttname"><a href="the__data__structure_8txt.html#a1400a973def57b85051cfe1070be1810">residuals</a></div><div class="ttdeci">endcode The default implementation of c the simplest possible implementation of a new element requires only the specification of c we need to know which c Data affects the residuals(and hence the Jacobian matrix). For a \c GeneralisedElement such \c Data exists in two forms</div></div>
<div class="ttc" id="anamespaceoomph_1_1QuadTreeNames_html_a8954a5947b19986b8c4b755bc7639f7da585070bd0e3801c3bbed287ef3c4a265"><div class="ttname"><a href="namespaceoomph_1_1QuadTreeNames.html#a8954a5947b19986b8c4b755bc7639f7da585070bd0e3801c3bbed287ef3c4a265">oomph::QuadTreeNames::E</a></div><div class="ttdeci">@ E</div><div class="ttdef"><b>Definition:</b> <a href="quadtree_8h_source.html#l00056">quadtree.h:56</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a75cae1eb9b52aff32cab056a6ea21da9"><div class="ttname"><a href="the__data__structure_8txt.html#a75cae1eb9b52aff32cab056a6ea21da9">Therefore</a></div><div class="ttdeci">often abbreviated as dof b History b history values are but b not b the values at previous timesteps b Pinned c c c Mesh and c Problem subsection data Data The most elementary data structure in c oomph lib is c these values fall into two and those that must be determined as part of the solution c Data stores a value a double precision number the values of the unknowns are determined by the solution of a system of algebraic equations The solution of this system usually requires c Data also stores a(long) integer that represents the number of the unknown in the global numbering scheme. \b Convention for in a fluids we need to store three velocity components at every node Therefore</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00095">the_data_structure.txt:95</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a9e432636a4a6b59e504772b968782704"><div class="ttname"><a href="the__data__structure_8txt.html#a9e432636a4a6b59e504772b968782704">by</a></div><div class="ttdeci">mainpage The data structure section intro Introduction c oomph lib is big ! This document gives a bottom up overview of the library s data structure and discusses how the various objects interact In addition to the detailed discussion provided the following doxygen generated lists indices provide quick access to the documentation of c oomph lib s we usually replace the list of arguments to functions by(...)' and explain the main input and output parameters in words. The full specifications of the interfaces may be found in the individual class documentation</div></div>
<div class="ttc" id="athe__data__structure_8txt_html_af2374cc183d898a3d5499aba088b219e"><div class="ttname"><a href="the__data__structure_8txt.html#af2374cc183d898a3d5499aba088b219e">that</a></div><div class="ttdeci">c Data can also store a certain number of c Data stores a pointer to a c TimeStepper whose member functions relate the history values to the values time derivatives pointer based read write access to the c Data values is provided by the functions code and by code Data::value_pt(t, i) \endcode which returns a pointer to the \c t -th history value associated with value \c i. Read-only access is also provided by the functions \code Data and its time dependent counterpart code whereas the values associated with t correspond to history values In many but this is not guaranteed See the section ref timestepping for further details subsection nodes Nodes In FE all c Nodes in a finite element mesh have c Data associated with them c Nodes are therefore derived from c but also store a spatial specified by a certain number of spatial(Eulerian) coordinates. The nodal positions are accessed by the member function \code Node note that the history values are not necessarily positions at previous timesteps subsubsection advanced_features_of_nodes Advanced we must evaluate mesh which requires the storage of the nodal position at a number of previous timesteps Storage for the positional history values is allocated by the c Node constructor A different c TimeStepper may be used to represent time derivatives of nodal so c Nodes store a separate pointer to a positional c TimeStepper[Note:By default, we allocate the same amount of storage for the history of the nodal positions as we do for the history of the nodal values;e.g. if a \c BDF&lt; 2 &gt; scheme is used to evaluate the time-derivatives of the fluid velocities, we assume that the same timestepping scheme is used(and the same amount of storage required) to determine the mesh velocities from the nodal positions.] For finite elements in which the global position of a point in an element is determined by interpolation from the position of the element s c we need only store the spatial position of the c Nodes In many other the interpolation of the geometry requires additional e g the derivative of the mapping between and global coordinates we allow the storage of additional positional variables at each c so that</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00186">the_data_structure.txt:186</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_aca39deab592c954bdca7bbec6d3879b2"><div class="ttname"><a href="the__data__structure_8txt.html#aca39deab592c954bdca7bbec6d3879b2">coordinates</a></div><div class="ttdeci">endcode returns the global equation number c i_global corresponding to the equation number c i_local The equation numbers of the internal and external c Data are stored in the private arrays c Internal_local_eqn and c accessed by the functions c GeneralisedElement::internal_local_eqn(...) and \c GeneralisedElement see section ref Hanging_Nodes for further details When c Nodes are created in it is important that c Nodes of the correct type with the appropriate amount of storage are created For Poisson elements require c Nodes that provide storage for a single value at each c whereas Taylor Navier Stokes elements require storage for three but only two values(the two velocities) at all others. The member function \code FiniteElement by default the spatial dimension of the c FiniteElement s c Nodes is assumed to be the same For code FiniteElement::set_dimension(2) \endcode sets both the spatial dimension of the element and the spatial dimension of its \c Nodes to be two. If the nodal dimension is not the same as the dimension of the element the member function \code FiniteElement code endcode returns the derivative of the shape functions with respect to the Eulerian coordinates</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00502">the_data_structure.txt:502</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_aecdcb19250d339765d0095e975875b2a"><div class="ttname"><a href="the__data__structure_8txt.html#aecdcb19250d339765d0095e975875b2a">position</a></div><div class="ttdeci">c Data can also store a certain number of c Data stores a pointer to a c TimeStepper whose member functions relate the history values to the values time derivatives pointer based read write access to the c Data values is provided by the functions code and by code Data::value_pt(t, i) \endcode which returns a pointer to the \c t -th history value associated with value \c i. Read-only access is also provided by the functions \code Data and its time dependent counterpart code whereas the values associated with t correspond to history values In many but this is not guaranteed See the section ref timestepping for further details subsection nodes Nodes In FE all c Nodes in a finite element mesh have c Data associated with them c Nodes are therefore derived from c but also store a spatial position</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00148">the_data_structure.txt:148</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_af8389ae6be77099ad63d360964d90450"><div class="ttname"><a href="the__data__structure_8txt.html#af8389ae6be77099ad63d360964d90450">document</a></div><div class="ttdeci">mainpage The data structure section intro Introduction c oomph lib is big ! This document gives a bottom up overview of the library s data structure and discusses how the various objects interact In addition to the detailed discussion provided the following doxygen generated lists indices provide quick access to the documentation of c oomph lib s we usually replace the list of arguments to functions accessible via the links at the top of this page subsection technical_terms Technical terms Throughout this document</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00033">the_data_structure.txt:33</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_add1ed445b05205014e92b32f072eb702"><div class="ttname"><a href="the__data__structure_8txt.html#add1ed445b05205014e92b32f072eb702">deforms</a></div><div class="ttdeci">the nodal coordinates represent the c Nodes fixed positions in this domain When the elastic body deforms</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00224">the_data_structure.txt:224</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a2a881956f4c1313252f5b07c697607bc"><div class="ttname"><a href="the__data__structure_8txt.html#a2a881956f4c1313252f5b07c697607bc">say</a></div><div class="ttdeci">and code FiniteElement::J_eulerian(...) \endcode returns the Jacobian of the mapping from Eulerian coordinates to local coordinates. - The function \c GeneralisedElement c QElement&lt; 3, 2 &gt; is an node brick element with a trilinear mapping between and global coordinates The dimension and the number of c Nodes must be set by calling the appropriate c set_ functions in the see ref set_commands above The most important member functions implemented at this level include Functions that evaluate the shape in terms of the c FiniteElement s coordinates functions that determine whether a c Node is located at a particular coordinate Output functions that allow the element shapes to be plotted we specify a pointer to a spatial integration the default assignment can be over written at a higher level This is discussed in more detail in a&lt; A HREF=&quot;../../optimisation/html/index.html&quot;&gt; separate document&lt;/A &gt; subsubsection Maths_Element we implement the equations that are represented by the specific element We implement the employing either the geometric shape functions that already exist on or employing additional shape functions defined at this level This allows us to write further member functions such as c say</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00562">the_data_structure.txt:562</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a8d43b99d8e5dbc19f03ea91f666d4261"><div class="ttname"><a href="the__data__structure_8txt.html#a8d43b99d8e5dbc19f03ea91f666d4261">always</a></div><div class="ttdeci">often abbreviated as dof b History b history values are but b not b always</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00045">the_data_structure.txt:45</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_ae2580b577c17ed58554378c11426b336"><div class="ttname"><a href="the__data__structure_8txt.html#ae2580b577c17ed58554378c11426b336">pointers</a></div><div class="ttdeci">endcode The default implementation of c the simplest possible implementation of a new element requires only the specification of c we need to know which c Data affects the accessed via pointers</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00362">the_data_structure.txt:362</a></div></div>
<div class="ttc" id="anamespaceoomph_1_1Locate__zeta__helpers_html_a473b3aa4666ed6dfeb49bff0c6ed0e71"><div class="ttname"><a href="namespaceoomph_1_1Locate__zeta__helpers.html#a473b3aa4666ed6dfeb49bff0c6ed0e71">oomph::Locate_zeta_helpers::Max_newton_iterations</a></div><div class="ttdeci">unsigned Max_newton_iterations</div><div class="ttdoc">Maximum number of newton iterations.</div><div class="ttdef"><b>Definition:</b> <a href="elements_8cc_source.html#l01623">elements.cc:1623</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a336e942cd35f2722d8ebab24a8258fc7"><div class="ttname"><a href="the__data__structure_8txt.html#a336e942cd35f2722d8ebab24a8258fc7">nodes</a></div><div class="ttdeci">see the section ref Hanging_Nodes for a more detailed discussion of hanging nodes</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00200">the_data_structure.txt:200</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a0ca71de52c9f65466ea6eefc4f332736"><div class="ttname"><a href="the__data__structure_8txt.html#a0ca71de52c9f65466ea6eefc4f332736">i_global</a></div><div class="ttdeci">unsigned i_global</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00391">the_data_structure.txt:391</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a23b5a245f0462b0a4823b0eb07a65baf"><div class="ttname"><a href="the__data__structure_8txt.html#a23b5a245f0462b0a4823b0eb07a65baf">element</a></div><div class="ttdeci">the nodal coordinates represent the c Nodes fixed positions in this domain When the elastic body material which can be unknowns in the problem To avoid confusion between the the access function for the nodal code we provide a wrapper code in the case of generalised coordinates code Node::x_gen(...) \endcode always refers to the generalised Eulerian position and \code SolidNode endcode where the c MultiPhysicsElement inherits from c SinglePhysicsOneElement and c SinglePhysicsTwoElement A problem with this implementation arises when we consider where to initialise the residuals vector If the second single physics c then the contribution of the first single physics element will be negated When writing a single physics element</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00302">the_data_structure.txt:302</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_af1ac6d88153e383bbb0a0d9f2dd78e60"><div class="ttname"><a href="the__data__structure_8txt.html#af1ac6d88153e383bbb0a0d9f2dd78e60">el</a></div><div class="ttdeci">GeneralisedElement el</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00387">the_data_structure.txt:387</a></div></div>
<div class="ttc" id="anamespaceoomph_1_1CumulativeTimings_html_aeafe5cb81741d54561e4b62572a1e3df"><div class="ttname"><a href="namespaceoomph_1_1CumulativeTimings.html#aeafe5cb81741d54561e4b62572a1e3df">oomph::CumulativeTimings::start</a></div><div class="ttdeci">void start(const unsigned &amp;i)</div><div class="ttdoc">(Re-)start i-th timer</div><div class="ttdef"><b>Definition:</b> <a href="oomph__utilities_8cc_source.html#l00248">oomph_utilities.cc:248</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a6ae5bd0929a31da250e325f39cde6099"><div class="ttname"><a href="the__data__structure_8txt.html#a6ae5bd0929a31da250e325f39cde6099">elements</a></div><div class="ttdeci">c Data can also store a certain number of c Data stores a pointer to a c TimeStepper whose member functions relate the history values to the values time derivatives pointer based read write access to the c Data values is provided by the functions code and by code Data::value_pt(t, i) \endcode which returns a pointer to the \c t -th history value associated with value \c i. Read-only access is also provided by the functions \code Data and its time dependent counterpart code whereas the values associated with t correspond to history values In many but this is not guaranteed See the section ref timestepping for further details subsection nodes Nodes In FE all c Nodes in a finite element mesh have c Data associated with them c Nodes are therefore derived from c but also store a spatial specified by a certain number of spatial(Eulerian) coordinates. The nodal positions are accessed by the member function \code Node note that the history values are not necessarily positions at previous timesteps subsubsection advanced_features_of_nodes Advanced we must evaluate mesh which requires the storage of the nodal position at a number of previous timesteps Storage for the positional history values is allocated by the c Node constructor A different c TimeStepper may be used to represent time derivatives of nodal so c Nodes store a separate pointer to a positional c TimeStepper[Note:By default, we allocate the same amount of storage for the history of the nodal positions as we do for the history of the nodal values;e.g. if a \c BDF&lt; 2 &gt; scheme is used to evaluate the time-derivatives of the fluid velocities, we assume that the same timestepping scheme is used(and the same amount of storage required) to determine the mesh velocities from the nodal positions.] For finite elements in which the global position of a point in an element is determined by interpolation from the position of the element s c we need only store the spatial position of the c Nodes In many other the interpolation of the geometry requires additional e g the derivative of the mapping between and global coordinates we allow the storage of additional positional variables at each c so in every c Node has a number of e generalised coordinates for each spatial coordinate direction For for nodes in Hermite elements</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00188">the_data_structure.txt:188</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a92944c1c6b9eca60b38b22831f47da95"><div class="ttname"><a href="the__data__structure_8txt.html#a92944c1c6b9eca60b38b22831f47da95">GeneralisedElement</a></div><div class="ttdeci">often abbreviated as dof b History b history values are but b not b the values at previous timesteps b Pinned c c GeneralisedElement</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00054">the_data_structure.txt:54</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_ac3335dcd8d8a94bd04fa5fcf4ca57d44"><div class="ttname"><a href="the__data__structure_8txt.html#ac3335dcd8d8a94bd04fa5fcf4ca57d44">p_fluid</a></div><div class="ttdeci">we provide an access function c p_fluid(...) which allows us to write \code unsigned n</div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a6573eb169cd4addb7e5c68cfd56f09d9"><div class="ttname"><a href="the__data__structure_8txt.html#a6573eb169cd4addb7e5c68cfd56f09d9">above</a></div><div class="ttdeci">endcode The default implementation of c the simplest possible implementation of a new element requires only the specification of c we need to know which c Data affects the accessed via in the pressure degrees of freedom are to each element and are stored in the element s Internal c Data c Data that is external to the element An example is a load parameter such as the external pressure that acts on a shell structure Such c Data is accessed via pointers to External c Data As discussed above</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00370">the_data_structure.txt:370</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a614cd5b691a8441c71c6418dabef282f"><div class="ttname"><a href="the__data__structure_8txt.html#a614cd5b691a8441c71c6418dabef282f">below</a></div><div class="ttdeci">mainpage The data structure section intro Introduction c oomph lib is big ! This document gives a bottom up overview of the library s data structure and discusses how the various objects interact In addition to the detailed discussion provided below</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00007">the_data_structure.txt:7</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a5641be16902d346c51580a49fb9885dc"><div class="ttname"><a href="the__data__structure_8txt.html#a5641be16902d346c51580a49fb9885dc">boundaries</a></div><div class="ttdeci">in the role of the member functions c Node::position() and \c Node the latter case arises if the c Node is located on edges and corners of the mesh Storage of this information facilitates the automatic determination of boundary conditions for new c Nodes that are created during mesh refinement n The majority of the c Nodes will b not be located on boundaries</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00201">the_data_structure.txt:201</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_ad22e1eba19a65ec7cdd50d59b6128aa8"><div class="ttname"><a href="the__data__structure_8txt.html#ad22e1eba19a65ec7cdd50d59b6128aa8">most</a></div><div class="ttdeci">c Data can also store a certain number of c Data stores a pointer to a c TimeStepper whose member functions relate the history values to the values time derivatives pointer based read write access to the c Data values is provided by the functions code and by code Data::value_pt(t, i) \endcode which returns a pointer to the \c t -th history value associated with value \c i. Read-only access is also provided by the functions \code Data and its time dependent counterpart code whereas the values associated with t correspond to history values In many but this is not guaranteed See the section ref timestepping for further details subsection nodes Nodes In FE most(but not all;see below) \c Data are associated with nodal points. Conversely</div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a70eaf7a61463de09f737da1f4bb551c3"><div class="ttname"><a href="the__data__structure_8txt.html#a70eaf7a61463de09f737da1f4bb551c3">values</a></div><div class="ttdeci">endcode We introduce wrapper functions to access function values</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00580">the_data_structure.txt:580</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a6180442cc1fa8cc605d3c308d12e3318"><div class="ttname"><a href="the__data__structure_8txt.html#a6180442cc1fa8cc605d3c308d12e3318">setting</a></div><div class="ttdeci">the nodal coordinate of type stores the derivative of the global position w r t to the element s coordinate The member function code nodes can become hanging the default setting</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00199">the_data_structure.txt:199</a></div></div>
<div class="ttc" id="acfortran_8h_html_af6f0bd3dc13317f895c91323c25c2b8f"><div class="ttname"><a href="cfortran_8h.html#af6f0bd3dc13317f895c91323c25c2b8f">t</a></div><div class="ttdeci">char t</div><div class="ttdef"><b>Definition:</b> <a href="cfortran_8h_source.html#l00568">cfortran.h:568</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a09d45d606dc2644096aef7d48c4cb13f"><div class="ttname"><a href="the__data__structure_8txt.html#a09d45d606dc2644096aef7d48c4cb13f">domain</a></div><div class="ttdeci">see ref meshes for further details b the governing equations are discretised in a fixed Lagrangian domain</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00223">the_data_structure.txt:223</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a64d88be10037cd950079684de8d4fa9b"><div class="ttname"><a href="the__data__structure_8txt.html#a64d88be10037cd950079684de8d4fa9b">quantities</a></div><div class="ttdeci">c Data can also store a certain number of c Data stores a pointer to a c TimeStepper whose member functions relate the history values to the values time derivatives pointer based read write access to the c Data values is provided by the functions code and by code Data::value_pt(t, i) \endcode which returns a pointer to the \c t -th history value associated with value \c i. Read-only access is also provided by the functions \code Data and its time dependent counterpart code whereas the values associated with t correspond to history values In many but this is not guaranteed See the section ref timestepping for further details subsection nodes Nodes In FE all c Nodes in a finite element mesh have c Data associated with them c Nodes are therefore derived from c but also store a spatial specified by a certain number of spatial(Eulerian) coordinates. The nodal positions are accessed by the member function \code Node note that the history values are not necessarily positions at previous timesteps subsubsection advanced_features_of_nodes Advanced we must evaluate mesh which requires the storage of the nodal position at a number of previous timesteps Storage for the positional history values is allocated by the c Node constructor A different c TimeStepper may be used to represent time derivatives of nodal so c Nodes store a separate pointer to a positional c TimeStepper[Note:By default, we allocate the same amount of storage for the history of the nodal positions as we do for the history of the nodal values;e.g. if a \c BDF&lt; 2 &gt; scheme is used to evaluate the time-derivatives of the fluid velocities, we assume that the same timestepping scheme is used(and the same amount of storage required) to determine the mesh velocities from the nodal positions.] For finite elements in which the global position of a point in an element is determined by interpolation from the position of the element s c we need only store the spatial position of the c Nodes In many other the interpolation of the geometry requires additional quantities</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00183">the_data_structure.txt:183</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a80f7344c0300e389acecd2d048f2bb58"><div class="ttname"><a href="the__data__structure_8txt.html#a80f7344c0300e389acecd2d048f2bb58">get_residuals</a></div><div class="ttdeci">the nodal coordinates represent the c Nodes fixed positions in this domain When the elastic body material which can be unknowns in the problem To avoid confusion between the the access function for the nodal code we provide a wrapper code in the case of generalised coordinates code Node::x_gen(...) \endcode always refers to the generalised Eulerian position and \code SolidNode endcode where the c MultiPhysicsElement inherits from c SinglePhysicsOneElement and c SinglePhysicsTwoElement A problem with this implementation arises when we consider where to initialise the residuals vector If the second single physics c get_residuals(...) function initialises the residuals vector</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00304">the_data_structure.txt:304</a></div></div>
<div class="ttc" id="anamespaceoomph_1_1QuadTreeNames_html_a8954a5947b19986b8c4b755bc7639f7daabab2a070c062503375f8264f1b6d7d6"><div class="ttname"><a href="namespaceoomph_1_1QuadTreeNames.html#a8954a5947b19986b8c4b755bc7639f7daabab2a070c062503375f8264f1b6d7d6">oomph::QuadTreeNames::W</a></div><div class="ttdeci">@ W</div><div class="ttdef"><b>Definition:</b> <a href="quadtree_8h_source.html#l00056">quadtree.h:56</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a3b0d20781021ec2f0e788713f8b0fec8"><div class="ttname"><a href="the__data__structure_8txt.html#a3b0d20781021ec2f0e788713f8b0fec8">value</a></div><div class="ttdeci">often abbreviated as dof b History b value</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00044">the_data_structure.txt:44</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a00351a84e9d112c9130f712f81afa2e8"><div class="ttname"><a href="the__data__structure_8txt.html#a00351a84e9d112c9130f712f81afa2e8">instance</a></div><div class="ttdeci">often abbreviated as dof b History b history values are but b not b the values at previous timesteps b Pinned c c c Mesh and c Problem subsection data Data The most elementary data structure in c oomph lib is c these values fall into two and those that must be determined as part of the solution c Data stores a value a double precision number the values of the unknowns are determined by the solution of a system of algebraic equations The solution of this system usually requires c Data also stores a(long) integer that represents the number of the unknown in the global numbering scheme. \b Convention for instance</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00073">the_data_structure.txt:73</a></div></div>
<div class="ttc" id="anamespaceoomph_1_1OneDimLagrange_html_a117f8b892dc89989ecdad99ff261e120"><div class="ttname"><a href="namespaceoomph_1_1OneDimLagrange.html#a117f8b892dc89989ecdad99ff261e120">oomph::OneDimLagrange::shape</a></div><div class="ttdeci">void shape(const double &amp;s, double *Psi)</div><div class="ttdoc">Definition for 1D Lagrange shape functions. The value of all the shape functions at the local coordin...</div><div class="ttdef"><b>Definition:</b> <a href="shape_8h_source.html#l00545">shape.h:545</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a6f78491c9fe8caf9552206cb5960262a"><div class="ttname"><a href="the__data__structure_8txt.html#a6f78491c9fe8caf9552206cb5960262a">conversely</a></div><div class="ttdeci">and code FiniteElement::J_eulerian(...) \endcode returns the Jacobian of the mapping from Eulerian coordinates to local coordinates. - The function \c GeneralisedElement c QElement&lt; 3, 2 &gt; is an node brick element with a trilinear mapping between and global coordinates The dimension and the number of c Nodes must be set by calling the appropriate c set_ functions in the see ref set_commands above The most important member functions implemented at this level include Functions that evaluate the shape in terms of the c FiniteElement s coordinates conversely</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00540">the_data_structure.txt:540</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_ae789c4a233fe5f1aa45cf1f92efdf494"><div class="ttname"><a href="the__data__structure_8txt.html#ae789c4a233fe5f1aa45cf1f92efdf494">Data</a></div><div class="ttdeci">c Data can also store a certain number of c Data stores a pointer to a c TimeStepper whose member functions relate the history values to the values time derivatives pointer based read write access to the c Data values is provided by the functions code and by code Data::value_pt(t, i) \endcode which returns a pointer to the \c t -th history value associated with value \c i. Read-only access is also provided by the functions \code Data and its time dependent counterpart code whereas the values associated with t correspond to history values In many but this is not guaranteed See the section ref timestepping for further details subsection nodes Nodes In FE all c Nodes in a finite element mesh have c Data associated with them c Nodes are therefore derived from c Data</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00148">the_data_structure.txt:148</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a9373a948322aa91e7cbca19c079e5e6b"><div class="ttname"><a href="the__data__structure_8txt.html#a9373a948322aa91e7cbca19c079e5e6b">BoundaryNodes</a></div><div class="ttdeci">in the role of the member functions c Node::position() and \c Node the latter case arises if the c Node is located on edges and corners of the mesh Storage of this information facilitates the automatic determination of boundary conditions for new c Nodes that are created during mesh refinement n The majority of the c Nodes will b not be located on and providing storage for the boundary information in every c Node object is rather wasteful The derived class c BoundaryNode adds the required additional storage to the c Node class and it follows that all c Nodes that could lie on boundaries must be c BoundaryNodes</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00214">the_data_structure.txt:214</a></div></div>
<div class="ttc" id="anamespaceoomph_1_1OcTreeNames_html_ae7e7e58298b85825061eeff362656c40a51292b8e4d96f2bb9f0d6bb0340d1620"><div class="ttname"><a href="namespaceoomph_1_1OcTreeNames.html#ae7e7e58298b85825061eeff362656c40a51292b8e4d96f2bb9f0d6bb0340d1620">oomph::OcTreeNames::D</a></div><div class="ttdeci">@ D</div><div class="ttdef"><b>Definition:</b> <a href="octree_8h_source.html#l00055">octree.h:55</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_acdf437512dc428cd2c5e8b3aa8b92896"><div class="ttname"><a href="the__data__structure_8txt.html#acdf437512dc428cd2c5e8b3aa8b92896">s</a></div><div class="ttdeci">Vector&lt; double &gt; s(3)</div></div>
<div class="ttc" id="athe__data__structure_8txt_html_af0900657173e37ac5791e247d9031e13"><div class="ttname"><a href="the__data__structure_8txt.html#af0900657173e37ac5791e247d9031e13">Hood</a></div><div class="ttdeci">endcode returns the global equation number c i_global corresponding to the equation number c i_local The equation numbers of the internal and external c Data are stored in the private arrays c Internal_local_eqn and c accessed by the functions c GeneralisedElement::internal_local_eqn(...) and \c GeneralisedElement see section ref Hanging_Nodes for further details When c Nodes are created in it is important that c Nodes of the correct type with the appropriate amount of storage are created For Poisson elements require c Nodes that provide storage for a single value at each c whereas Taylor Hood</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00443">the_data_structure.txt:443</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_abac4b89d42b6302469aceb39f50e0b19"><div class="ttname"><a href="the__data__structure_8txt.html#abac4b89d42b6302469aceb39f50e0b19">so</a></div><div class="ttdeci">the nodal coordinates represent the c Nodes fixed positions in this domain When the elastic body material which can be unknowns in the problem To avoid confusion between the the access function for the nodal code we provide a wrapper code in the case of generalised coordinates code Node::x_gen(...) \endcode always refers to the generalised Eulerian position and \code SolidNode endcode where the c MultiPhysicsElement inherits from c SinglePhysicsOneElement and c SinglePhysicsTwoElement A problem with this implementation arises when we consider where to initialise the residuals vector If the second single physics c then the contribution of the first single physics element will be negated When writing a single physics we cannot know whether it will ever be used as part of a multi physics element if so</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00304">the_data_structure.txt:304</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a0da96ee19f5f052118b3538e2a5e043a"><div class="ttname"><a href="the__data__structure_8txt.html#a0da96ee19f5f052118b3538e2a5e043a">assign_additional_local_eqn_numbers</a></div><div class="ttdeci">endcode in our standard equations the function c assign_additional_local_eqn_numbers() is not used. Finally</div></div>
<div class="ttc" id="anamespaceoomph_html"><div class="ttname"><a href="namespaceoomph.html">oomph</a></div><div class="ttdoc">DRAIG: Change all instances of (SPATIAL_DIM) to (DIM-1).</div><div class="ttdef"><b>Definition:</b> <a href="advection__diffusion__elements_8cc_source.html#l00029">advection_diffusion_elements.cc:29</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a1d53daa8e93a1fa428e4506a4bedf87e"><div class="ttname"><a href="the__data__structure_8txt.html#a1d53daa8e93a1fa428e4506a4bedf87e">velocities</a></div><div class="ttdeci">c Data can also store a certain number of c Data stores a pointer to a c TimeStepper whose member functions relate the history values to the values time derivatives pointer based read write access to the c Data values is provided by the functions code and by code Data::value_pt(t, i) \endcode which returns a pointer to the \c t -th history value associated with value \c i. Read-only access is also provided by the functions \code Data and its time dependent counterpart code whereas the values associated with t correspond to history values In many but this is not guaranteed See the section ref timestepping for further details subsection nodes Nodes In FE all c Nodes in a finite element mesh have c Data associated with them c Nodes are therefore derived from c but also store a spatial specified by a certain number of spatial(Eulerian) coordinates. The nodal positions are accessed by the member function \code Node note that the history values are not necessarily positions at previous timesteps subsubsection advanced_features_of_nodes Advanced we must evaluate mesh velocities</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00164">the_data_structure.txt:164</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a896b76f95e55296d70032d9226557b9a"><div class="ttname"><a href="the__data__structure_8txt.html#a896b76f95e55296d70032d9226557b9a">features</a></div><div class="ttdeci">c Data can also store a certain number of c Data stores a pointer to a c TimeStepper whose member functions relate the history values to the values time derivatives pointer based read write access to the c Data values is provided by the functions code and by code Data::value_pt(t, i) \endcode which returns a pointer to the \c t -th history value associated with value \c i. Read-only access is also provided by the functions \code Data and its time dependent counterpart code whereas the values associated with t correspond to history values In many but this is not guaranteed See the section ref timestepping for further details subsection nodes Nodes In FE all c Nodes in a finite element mesh have c Data associated with them c Nodes are therefore derived from c but also store a spatial specified by a certain number of spatial(Eulerian) coordinates. The nodal positions are accessed by the member function \code Node note that the history values are not necessarily positions at previous timesteps subsubsection advanced_features_of_nodes Advanced features</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00164">the_data_structure.txt:164</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a0dbf3ebf11b527f1f8f1b9f494ba38e9"><div class="ttname"><a href="the__data__structure_8txt.html#a0dbf3ebf11b527f1f8f1b9f494ba38e9">interpolation</a></div><div class="ttdeci">and code FiniteElement::J_eulerian(...) \endcode returns the Jacobian of the mapping from Eulerian coordinates to local coordinates. - The function \c GeneralisedElement c QElement&lt; 3, 2 &gt; is an node brick element with a trilinear mapping between and global coordinates The dimension and the number of c Nodes must be set by calling the appropriate c set_ functions in the see ref set_commands above The most important member functions implemented at this level include Functions that evaluate the shape in terms of the c FiniteElement s coordinates functions that determine whether a c Node is located at a particular coordinate Output functions that allow the element shapes to be plotted we specify a pointer to a spatial integration the default assignment can be over written at a higher level This is discussed in more detail in a&lt; A HREF=&quot;../../optimisation/html/index.html&quot;&gt; separate document&lt;/A &gt; subsubsection Maths_Element we implement the equations that are represented by the specific element We implement the interpolation(s) for the unknown function(s)</div></div>
<div class="ttc" id="athe__data__structure_8txt_html_aaa083a8a029dbd8b16a3cbfd81a4f7fc"><div class="ttname"><a href="the__data__structure_8txt.html#aaa083a8a029dbd8b16a3cbfd81a4f7fc">points</a></div><div class="ttdeci">the nodal coordinates represent the c Nodes fixed positions in this domain When the elastic body material points(and hence the \c Nodes) are displaced to new Eulerian positions. The \c SolidNode class is derived from \c Node and contains storage for the \c Nodes' \b fixed positions(i.e. the Lagrangian coordinates) AND their \b variable positions(i.e. the Eulerian coordinates)</div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a2a5e002771d34d2f9a3149b1bf7d79f3"><div class="ttname"><a href="the__data__structure_8txt.html#a2a5e002771d34d2f9a3149b1bf7d79f3">constructor</a></div><div class="ttdeci">and code FiniteElement::J_eulerian(...) \endcode returns the Jacobian of the mapping from Eulerian coordinates to local coordinates. - The function \c GeneralisedElement c QElement&lt; 3, 2 &gt; is an node brick element with a trilinear mapping between and global coordinates The dimension and the number of c Nodes must be set by calling the appropriate c set_ functions in the constructor</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00503">the_data_structure.txt:503</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_aa0b0f0685c750109cbf1b287e3d7911c"><div class="ttname"><a href="the__data__structure_8txt.html#aa0b0f0685c750109cbf1b287e3d7911c">representing</a></div><div class="ttdeci">c Data can also store a certain number of c Data stores a pointer to a c TimeStepper whose member functions relate the history values to the values time derivatives pointer based read write access to the c Data values is provided by the functions code and by code Data::value_pt(t, i) \endcode which returns a pointer to the \c t -th history value associated with value \c i. Read-only access is also provided by the functions \code Data and its time dependent counterpart code whereas the values associated with t correspond to history values In many but this is not guaranteed See the section ref timestepping for further details subsection nodes Nodes In FE all c Nodes in a finite element mesh have c Data associated with them c Nodes are therefore derived from c but also store a spatial specified by a certain number of spatial(Eulerian) coordinates. The nodal positions are accessed by the member function \code Node note that the history values are not necessarily positions at previous timesteps subsubsection advanced_features_of_nodes Advanced we must evaluate mesh which requires the storage of the nodal position at a number of previous timesteps Storage for the positional history values is allocated by the c Node constructor A different c TimeStepper may be used to represent time derivatives of nodal so c Nodes store a separate pointer to a positional c TimeStepper[Note:By default, we allocate the same amount of storage for the history of the nodal positions as we do for the history of the nodal values;e.g. if a \c BDF&lt; 2 &gt; scheme is used to evaluate the time-derivatives of the fluid velocities, we assume that the same timestepping scheme is used(and the same amount of storage required) to determine the mesh velocities from the nodal positions.] For finite elements in which the global position of a point in an element is determined by interpolation from the position of the element s c we need only store the spatial position of the c Nodes In many other the interpolation of the geometry requires additional representing</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00183">the_data_structure.txt:183</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_aff3ef4d47576bf2dc8e17c3d76a9d8e6"><div class="ttname"><a href="the__data__structure_8txt.html#aff3ef4d47576bf2dc8e17c3d76a9d8e6">Level</a></div><div class="ttdeci">and code FiniteElement::J_eulerian(...) \endcode returns the Jacobian of the mapping from Eulerian coordinates to local coordinates. - The function \c GeneralisedElement c QElement&lt; 3, 2 &gt; is an node brick element with a trilinear mapping between and global coordinates The dimension and the number of c Nodes must be set by calling the appropriate c set_ functions in the see ref set_commands above The most important member functions implemented at this level include Functions that evaluate the shape in terms of the c FiniteElement s coordinates functions that determine whether a c Node is located at a particular coordinate Output functions that allow the element shapes to be plotted we specify a pointer to a spatial integration the default assignment can be over written at a higher level This is discussed in more detail in a&lt; A HREF=&quot;../../optimisation/html/index.html&quot;&gt; separate document&lt;/A &gt; subsubsection Maths_Element Level</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00556">the_data_structure.txt:556</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a7f4f16dbb06d2c4aa38c0310d55a7c0b"><div class="ttname"><a href="the__data__structure_8txt.html#a7f4f16dbb06d2c4aa38c0310d55a7c0b">related</a></div><div class="ttdeci">endcode in our standard equations the function c virtual the function code FiniteElement::required_nvalue(...) \endcode should be implemented to specify the number of values that are stored at each of the element 's local \c Nodes. The default number of values stored at a \c Node is zero. \subsubsection advanced_features_of_elements `Advanced' features for the `Maths' level this can be advantageous when the element types are very closely related</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00640">the_data_structure.txt:640</a></div></div>
<div class="ttc" id="acfortran_8h_html_adb50e893b86b3e55e751a42eab3cba82"><div class="ttname"><a href="cfortran_8h.html#adb50e893b86b3e55e751a42eab3cba82">i</a></div><div class="ttdeci">cstr elem_len * i</div><div class="ttdef"><b>Definition:</b> <a href="cfortran_8h_source.html#l00603">cfortran.h:603</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a0dce8579b2a8d42faf1c51a2bb82af09"><div class="ttname"><a href="the__data__structure_8txt.html#a0dce8579b2a8d42faf1c51a2bb82af09">classes</a></div><div class="ttdeci">mainpage The data structure section intro Introduction c oomph lib is big ! This document gives a bottom up overview of the library s data structure and discusses how the various objects interact In addition to the detailed discussion provided the following doxygen generated lists indices provide quick access to the documentation of c oomph lib s classes</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00025">the_data_structure.txt:25</a></div></div>
<div class="ttc" id="anamespaceoomph_1_1QuadTreeNames_html_a8954a5947b19986b8c4b755bc7639f7dabc60bec4cc294aa2adf92726c6d6823a"><div class="ttname"><a href="namespaceoomph_1_1QuadTreeNames.html#a8954a5947b19986b8c4b755bc7639f7dabc60bec4cc294aa2adf92726c6d6823a">oomph::QuadTreeNames::N</a></div><div class="ttdeci">@ N</div><div class="ttdef"><b>Definition:</b> <a href="quadtree_8h_source.html#l00056">quadtree.h:56</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_ae1accb258c8081d6bdccc3b740b9f5ed"><div class="ttname"><a href="the__data__structure_8txt.html#ae1accb258c8081d6bdccc3b740b9f5ed">Node</a></div><div class="ttdeci">often abbreviated as dof b History b history values are but b not b the values at previous timesteps b Pinned c Node</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00053">the_data_structure.txt:53</a></div></div>
<div class="ttc" id="acfortran_8h_html_a6817bef1e2c0420fa284500e4875ffcb"><div class="ttname"><a href="cfortran_8h.html#a6817bef1e2c0420fa284500e4875ffcb">if</a></div><div class="ttdeci">if(e &gt;s)</div><div class="ttdef"><b>Definition:</b> <a href="cfortran_8h_source.html#l00572">cfortran.h:572</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a9e4c2f9cf218e996a79932ca1af8a170"><div class="ttname"><a href="the__data__structure_8txt.html#a9e4c2f9cf218e996a79932ca1af8a170">and</a></div><div class="ttdeci">the nodal coordinates represent the c Nodes fixed positions in this domain When the elastic body material which can be unknowns in the problem To avoid confusion between the the access function for the nodal code we provide a wrapper code in the case of generalised coordinates code Node::x_gen(...) \endcode always refers to the generalised Eulerian position and \code SolidNode endcode where the c MultiPhysicsElement inherits from c SinglePhysicsOneElement and c SinglePhysicsTwoElement A problem with this implementation arises when we consider where to initialise the residuals vector If the second single physics c then the contribution of the first single physics element will be negated When writing a single physics we cannot know whether it will ever be used as part of a multi physics element and</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00304">the_data_structure.txt:304</a></div></div>
<div class="ttc" id="anamespaceoomph_html_a2473930e2634d673e2a3bed63b6851f0"><div class="ttname"><a href="namespaceoomph.html#a2473930e2634d673e2a3bed63b6851f0">oomph::output</a></div><div class="ttdeci">void output(std::ostream &amp;outfile)</div><div class="ttdoc">Output with default number of plot points.</div><div class="ttdef"><b>Definition:</b> <a href="gen__axisym__advection__diffusion__elements_8h_source.html#l00160">gen_axisym_advection_diffusion_elements.h:160</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_af88b2d950fae19ab641bd1690e08445c"><div class="ttname"><a href="the__data__structure_8txt.html#af88b2d950fae19ab641bd1690e08445c">n</a></div><div class="ttdeci">endcode We introduce wrapper functions to access function so that we can formulate The Maths in generic terms Rather than referring to the pressure at node c n</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00582">the_data_structure.txt:582</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a5ee8c53ff4e7538382193801d5c0dcf4"><div class="ttname"><a href="the__data__structure_8txt.html#a5ee8c53ff4e7538382193801d5c0dcf4">often</a></div><div class="ttdeci">often abbreviated as dof b History b history values are often</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00044">the_data_structure.txt:44</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_adb5002bd6c1485971fbe7c5ebd457e16"><div class="ttname"><a href="the__data__structure_8txt.html#adb5002bd6c1485971fbe7c5ebd457e16">SolidNodes</a></div><div class="ttdeci">see ref meshes for further details b SolidNodes</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00222">the_data_structure.txt:222</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a15043ffc2013f4797ce93c4d1cc7a9ba"><div class="ttname"><a href="the__data__structure_8txt.html#a15043ffc2013f4797ce93c4d1cc7a9ba">press</a></div><div class="ttdeci">double press</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00585">the_data_structure.txt:585</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a8a293a5774af4ed42e35d91eac143214"><div class="ttname"><a href="the__data__structure_8txt.html#a8a293a5774af4ed42e35d91eac143214">External_local_eqn</a></div><div class="ttdeci">endcode returns the global equation number c i_global corresponding to the equation number c i_local The equation numbers of the internal and external c Data are stored in the private arrays c Internal_local_eqn and c External_local_eqn</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00398">the_data_structure.txt:398</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_af21603f9b8186c951238d1a4f1341093"><div class="ttname"><a href="the__data__structure_8txt.html#af21603f9b8186c951238d1a4f1341093">general</a></div><div class="ttdeci">c Data can also store a certain number of c Data stores a pointer to a c TimeStepper whose member functions relate the history values to the values time derivatives pointer based read write access to the c Data values is provided by the functions code and by code Data::value_pt(t, i) \endcode which returns a pointer to the \c t -th history value associated with value \c i. Read-only access is also provided by the functions \code Data and its time dependent counterpart code whereas the values associated with t correspond to history values In many but this is not guaranteed See the section ref timestepping for further details subsection nodes Nodes In FE all c Nodes in a finite element mesh have c Data associated with them c Nodes are therefore derived from c but also store a spatial specified by a certain number of spatial(Eulerian) coordinates. The nodal positions are accessed by the member function \code Node note that the history values are not necessarily positions at previous timesteps subsubsection advanced_features_of_nodes Advanced we must evaluate mesh which requires the storage of the nodal position at a number of previous timesteps Storage for the positional history values is allocated by the c Node constructor A different c TimeStepper may be used to represent time derivatives of nodal so c Nodes store a separate pointer to a positional c TimeStepper[Note:By default, we allocate the same amount of storage for the history of the nodal positions as we do for the history of the nodal values;e.g. if a \c BDF&lt; 2 &gt; scheme is used to evaluate the time-derivatives of the fluid velocities, we assume that the same timestepping scheme is used(and the same amount of storage required) to determine the mesh velocities from the nodal positions.] For finite elements in which the global position of a point in an element is determined by interpolation from the position of the element s c we need only store the spatial position of the c Nodes In many other the interpolation of the geometry requires additional e g the derivative of the mapping between and global coordinates we allow the storage of additional positional variables at each c so in general</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00186">the_data_structure.txt:186</a></div></div>
<div class="ttc" id="anamespaceoomph_1_1ObsoleteCode_html_aad204f6339b477642ef2ef32c3437eb1"><div class="ttname"><a href="namespaceoomph_1_1ObsoleteCode.html#aad204f6339b477642ef2ef32c3437eb1">oomph::ObsoleteCode::obsolete</a></div><div class="ttdeci">void obsolete()</div><div class="ttdoc">Output warning message.</div><div class="ttdef"><b>Definition:</b> <a href="oomph__utilities_8cc_source.html#l01095">oomph_utilities.cc:1095</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_aaa5287b1cf3ca06b3f413cb95bd1ec60"><div class="ttname"><a href="the__data__structure_8txt.html#aaa5287b1cf3ca06b3f413cb95bd1ec60">u</a></div><div class="ttdeci">Vector&lt; double &gt; u(3)</div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a9a527b4945e8a79d4398e29b7bd1a091"><div class="ttname"><a href="the__data__structure_8txt.html#a9a527b4945e8a79d4398e29b7bd1a091">however</a></div><div class="ttdeci">in the role of the member functions c Node::position() and \c Node the latter case arises if the c Node is located on edges and corners of the mesh Storage of this information facilitates the automatic determination of boundary conditions for new c Nodes that are created during mesh refinement n The majority of the c Nodes will b not be located on however</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00213">the_data_structure.txt:213</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_aeee3780947eb4807e5f92e17ae8a541a"><div class="ttname"><a href="the__data__structure_8txt.html#aeee3780947eb4807e5f92e17ae8a541a">their</a></div><div class="ttdeci">endcode The default implementation of c the simplest possible implementation of a new element requires only the specification of c we need to know which c Data affects the accessed via in the pressure degrees of freedom are to each element and are stored in the element s Internal c Data c Data that is external to the element An example is a load parameter such as the external pressure that acts on a shell structure Such c Data is accessed via pointers to External c Data As discussed all c Data contains values that are either we refer to the unknowns by their(equation) numbers. In order to add the elemental contribution to the appropriate global degree of freedom</div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a828197a2e8cdd2cda099535ca76b8a47"><div class="ttname"><a href="the__data__structure_8txt.html#a828197a2e8cdd2cda099535ca76b8a47">Finally</a></div><div class="ttdeci">and code FiniteElement::J_eulerian(...) \endcode returns the Jacobian of the mapping from Eulerian coordinates to local coordinates. - The function \c GeneralisedElement c QElement&lt; 3, 2 &gt; is an node brick element with a trilinear mapping between and global coordinates The dimension and the number of c Nodes must be set by calling the appropriate c set_ functions in the see ref set_commands above The most important member functions implemented at this level include Functions that evaluate the shape in terms of the c FiniteElement s coordinates functions that determine whether a c Node is located at a particular coordinate Output functions that allow the element shapes to be plotted Finally</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00544">the_data_structure.txt:544</a></div></div>
<div class="ttc" id="acfortran_8h_html_a37cd013acc76697829c324bdd8562d82"><div class="ttname"><a href="cfortran_8h.html#a37cd013acc76697829c324bdd8562d82">e</a></div><div class="ttdeci">e</div><div class="ttdef"><b>Definition:</b> <a href="cfortran_8h_source.html#l00571">cfortran.h:571</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a9e8b1f005bea4819b58e764897ec6f37"><div class="ttname"><a href="the__data__structure_8txt.html#a9e8b1f005bea4819b58e764897ec6f37">cases</a></div><div class="ttdeci">c Data can also store a certain number of c Data stores a pointer to a c TimeStepper whose member functions relate the history values to the values time derivatives pointer based read write access to the c Data values is provided by the functions code and by code Data::value_pt(t, i) \endcode which returns a pointer to the \c t -th history value associated with value \c i. Read-only access is also provided by the functions \code Data and its time dependent counterpart code whereas the values associated with t correspond to history values In many cases(e.g. BDF schemes) these history values are simply the values at previous timesteps</div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a5a99a6499dd6ccc7755850eca7bb334b"><div class="ttname"><a href="the__data__structure_8txt.html#a5a99a6499dd6ccc7755850eca7bb334b">fluid_element</a></div><div class="ttdeci">and code FiniteElement::J_eulerian(...) \endcode returns the Jacobian of the mapping from Eulerian coordinates to local coordinates. - The function \c GeneralisedElement c QElement&lt; 3, 2 &gt; is an node brick element with a trilinear mapping between and global coordinates The dimension and the number of c Nodes must be set by calling the appropriate c set_ functions in the see ref set_commands above The most important member functions implemented at this level include Functions that evaluate the shape in terms of the c FiniteElement s coordinates functions that determine whether a c Node is located at a particular coordinate Output functions that allow the element shapes to be plotted we specify a pointer to a spatial integration the default assignment can be over written at a higher level This is discussed in more detail in a&lt; A HREF=&quot;../../optimisation/html/index.html&quot;&gt; separate document&lt;/A &gt; subsubsection Maths_Element we implement the equations that are represented by the specific element We implement the employing either the geometric shape functions that already exist on or employing additional shape functions defined at this level This allows us to write further member functions such as c which compute the i th velocity component at the coordinate c s like this code SomeFluidElement fluid_element</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00566">the_data_structure.txt:566</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a26a1818885f7aebd0129ce36f6d391e8"><div class="ttname"><a href="the__data__structure_8txt.html#a26a1818885f7aebd0129ce36f6d391e8">a</a></div><div class="ttdeci">often abbreviated as dof b History b history values are but b not b the values at previous timesteps b Pinned c c c Mesh and c Problem subsection data Data The most elementary data structure in c oomph lib is c these values fall into two and those that must be determined as part of the solution c Data stores a value a double precision number the values of the unknowns are determined by the solution of a system of algebraic equations The solution of this system usually requires a(linear) numbering of the unknowns and associated equations. Hence</div></div>
<div class="ttc" id="athe__data__structure_8txt_html_aa761080bc57113d682fcb4b66e35d084"><div class="ttname"><a href="the__data__structure_8txt.html#aa761080bc57113d682fcb4b66e35d084">scheme</a></div><div class="ttdeci">and code FiniteElement::J_eulerian(...) \endcode returns the Jacobian of the mapping from Eulerian coordinates to local coordinates. - The function \c GeneralisedElement c QElement&lt; 3, 2 &gt; is an node brick element with a trilinear mapping between and global coordinates The dimension and the number of c Nodes must be set by calling the appropriate c set_ functions in the see ref set_commands above The most important member functions implemented at this level include Functions that evaluate the shape in terms of the c FiniteElement s coordinates functions that determine whether a c Node is located at a particular coordinate Output functions that allow the element shapes to be plotted we specify a pointer to a spatial integration scheme(usually a Gauss rule). The order of the integration scheme is based on the order of the interpolation in the isoparametric mapping. If this is inappropriate for an element that is derived from a given geometric element</div></div>
<div class="ttc" id="athe__data__structure_8txt_html_aae36f036c0d7b1178771b2e41ac8070a"><div class="ttname"><a href="the__data__structure_8txt.html#aae36f036c0d7b1178771b2e41ac8070a">particular</a></div><div class="ttdeci">in particular</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00200">the_data_structure.txt:200</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a266086ff7513dc7b1d7bb879a95b615d"><div class="ttname"><a href="the__data__structure_8txt.html#a266086ff7513dc7b1d7bb879a95b615d">functions</a></div><div class="ttdeci">endcode When writing these wrapper functions</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00594">the_data_structure.txt:594</a></div></div>
<div class="ttc" id="athe__data__structure_8txt_html_a91f07c5904cfdc8d4beede27714d72e1"><div class="ttname"><a href="the__data__structure_8txt.html#a91f07c5904cfdc8d4beede27714d72e1">two</a></div><div class="ttdeci">the nodal coordinates represent the c Nodes fixed positions in this domain When the elastic body material which can be unknowns in the problem To avoid confusion between the two</div><div class="ttdef"><b>Definition:</b> <a href="the__data__structure_8txt_source.html#l00232">the_data_structure.txt:232</a></div></div>

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Fri Aug 6 2021 14:46:25
        </div>
      </div>
    </footer>
</body>
</html>
