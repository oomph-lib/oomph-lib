<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: oomph::OcTree Class Reference</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../figures/manifest.json">
<link rel="mask-icon" href="../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../html/index.html"><img alt="oomph-lib" src="../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceoomph.html">oomph</a></li><li class="navelem"><a class="el" href="classoomph_1_1OcTree.html">OcTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classoomph_1_1OcTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">oomph::OcTree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> class: Recursively defined, generalised octree.  
 <a href="classoomph_1_1OcTree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="octree_8h_source.html">octree.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for oomph::OcTree:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classoomph_1_1OcTree.png" usemap="#oomph::OcTree_map" alt=""/>
  <map id="oomph::OcTree_map" name="oomph::OcTree_map">
<area href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u..." alt="oomph::Tree" shape="rect" coords="0,0,123,24"/>
<area href="classoomph_1_1OcTreeRoot.html" title="OcTreeRoot is a OcTree that forms the root of a (recursive) octree. The &quot;root node&quot; is special as it ..." alt="oomph::OcTreeRoot" shape="rect" coords="0,112,123,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5c7bf77c8700898c428dacbdff6b334c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a5c7bf77c8700898c428dacbdff6b334c">~OcTree</a> ()</td></tr>
<tr class="memdesc:a5c7bf77c8700898c428dacbdff6b334c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Note: Deleting a octree also deletes the objects associated with all non-leaf nodes!  <a href="classoomph_1_1OcTree.html#a5c7bf77c8700898c428dacbdff6b334c">More...</a><br /></td></tr>
<tr class="separator:a5c7bf77c8700898c428dacbdff6b334c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d729ac4b94328c7168bbcf423421edd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a2d729ac4b94328c7168bbcf423421edd">OcTree</a> (const <a class="el" href="classoomph_1_1OcTree.html">OcTree</a> &amp;dummy)=delete</td></tr>
<tr class="memdesc:a2d729ac4b94328c7168bbcf423421edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broken copy constructor.  <a href="classoomph_1_1OcTree.html#a2d729ac4b94328c7168bbcf423421edd">More...</a><br /></td></tr>
<tr class="separator:a2d729ac4b94328c7168bbcf423421edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14dba08782264f0d6008a8c1578b41e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a14dba08782264f0d6008a8c1578b41e1">operator=</a> (const <a class="el" href="classoomph_1_1OcTree.html">OcTree</a> &amp;)=delete</td></tr>
<tr class="memdesc:a14dba08782264f0d6008a8c1578b41e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broken assignment operator.  <a href="classoomph_1_1OcTree.html#a14dba08782264f0d6008a8c1578b41e1">More...</a><br /></td></tr>
<tr class="separator:a14dba08782264f0d6008a8c1578b41e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f894bab3cbde60d810de0ee43a9f023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Tree.html">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a2f894bab3cbde60d810de0ee43a9f023">construct_son</a> (<a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c">object_pt</a>, <a class="el" href="classoomph_1_1Tree.html">Tree</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a5f8444ddeda272b70669b8bbe929708a">father_pt</a>, const int &amp;<a class="el" href="classoomph_1_1Tree.html#a7537f8fe7c896d2220eb2da03567b34d">son_type</a>)</td></tr>
<tr class="memdesc:a2f894bab3cbde60d810de0ee43a9f023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload the function construct_son to ensure that the son is a specific <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> and not a general <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a>.  <a href="classoomph_1_1OcTree.html#a2f894bab3cbde60d810de0ee43a9f023">More...</a><br /></td></tr>
<tr class="separator:a2f894bab3cbde60d810de0ee43a9f023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690c4fbbca73bd48c0bc3b2913a9b39c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1OcTree.html">OcTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a690c4fbbca73bd48c0bc3b2913a9b39c">gteq_face_neighbour</a> (const int &amp;direction, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;translate_s, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;s_sw, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;s_ne, int &amp;face, int &amp;diff_level, bool &amp;in_neighbouring_tree) const</td></tr>
<tr class="memdesc:a690c4fbbca73bd48c0bc3b2913a9b39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find (pointer to) &lsquo;greater-or-equal-sized face neighbour&rsquo; in given direction (L/R/U/D/F/B). Another way of interpreting this is that we're looking for the neighbour across the present element's face 'direction'. The various arguments return additional information about the size and relative orientation of the neighbouring octree. To interpret these we use the following <b>General convention:</b>  <a href="classoomph_1_1OcTree.html#a690c4fbbca73bd48c0bc3b2913a9b39c">More...</a><br /></td></tr>
<tr class="separator:a690c4fbbca73bd48c0bc3b2913a9b39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a26409cd49a430095915c76060f476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1OcTree.html">OcTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#ab5a26409cd49a430095915c76060f476">gteq_true_edge_neighbour</a> (const int &amp;direction, const unsigned &amp;i_root_edge_neighbour, unsigned &amp;nroot_edge_neighbour, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;translate_s, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;s_lo, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;s_hi, int &amp;edge, int &amp;diff_level) const</td></tr>
<tr class="memdesc:ab5a26409cd49a430095915c76060f476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find (pointer to) &lsquo;greater-or-equal-sized true edge neighbour&rsquo; in the given direction (LB,RB,DB,UB [the back edges], LD,RD,LU,RU [the side edges], LF,RF,DF,UF [the front edges]).  <a href="classoomph_1_1OcTree.html#ab5a26409cd49a430095915c76060f476">More...</a><br /></td></tr>
<tr class="separator:ab5a26409cd49a430095915c76060f476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68218b6e02594bef23cb141af8a19ffb"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a68218b6e02594bef23cb141af8a19ffb">self_test</a> ()</td></tr>
<tr class="memdesc:a68218b6e02594bef23cb141af8a19ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-test: Check all neighbours. Return success (0) if the max. distance between corresponding points in the neighbours is less than the tolerance specified in the static value <a class="el" href="classoomph_1_1Tree.html#aef9abebc166fa3bf81ecb59ec0d5d6b2" title="Max. allowed discrepancy in neighbour finding routine (distance between points when identified from t...">Tree::Max_neighbour_finding_tolerance</a>.  <a href="classoomph_1_1OcTree.html#a68218b6e02594bef23cb141af8a19ffb">More...</a><br /></td></tr>
<tr class="separator:a68218b6e02594bef23cb141af8a19ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classoomph_1_1Tree"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classoomph_1_1Tree')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classoomph_1_1Tree.html">oomph::Tree</a></td></tr>
<tr class="memitem:ace0b4169cf94a040c280af8e14f6a283 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#ace0b4169cf94a040c280af8e14f6a283">~Tree</a> ()</td></tr>
<tr class="memdesc:ace0b4169cf94a040c280af8e14f6a283 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Note: Deleting a tree also deletes the objects associated with its non-leave nodes.  <a href="classoomph_1_1Tree.html#ace0b4169cf94a040c280af8e14f6a283">More...</a><br /></td></tr>
<tr class="separator:ace0b4169cf94a040c280af8e14f6a283 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dce113a40c6ac422353ab149b2d4eb inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a50dce113a40c6ac422353ab149b2d4eb">Tree</a> (const <a class="el" href="classoomph_1_1Tree.html">Tree</a> &amp;dummy)=delete</td></tr>
<tr class="memdesc:a50dce113a40c6ac422353ab149b2d4eb inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broken copy constructor.  <a href="classoomph_1_1Tree.html#a50dce113a40c6ac422353ab149b2d4eb">More...</a><br /></td></tr>
<tr class="separator:a50dce113a40c6ac422353ab149b2d4eb inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bce57d784f256d8d7b8d14432a7d77a inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a6bce57d784f256d8d7b8d14432a7d77a">operator=</a> (const <a class="el" href="classoomph_1_1Tree.html">Tree</a> &amp;)=delete</td></tr>
<tr class="memdesc:a6bce57d784f256d8d7b8d14432a7d77a inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broken assignment operator.  <a href="classoomph_1_1Tree.html#a6bce57d784f256d8d7b8d14432a7d77a">More...</a><br /></td></tr>
<tr class="separator:a6bce57d784f256d8d7b8d14432a7d77a inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2eeb0f1dd161f696cccc652974ff4c inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c">object_pt</a> () const</td></tr>
<tr class="memdesc:a2f2eeb0f1dd161f696cccc652974ff4c inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pointer to the object (<a class="el" href="classoomph_1_1RefineableElement.html" title="RefineableElements are FiniteElements that may be subdivided into children to provide a better local ...">RefineableElement</a>) represented by the tree.  <a href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c">More...</a><br /></td></tr>
<tr class="separator:a2f2eeb0f1dd161f696cccc652974ff4c inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a95bd9942e906fde87194845a1868c inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a96a95bd9942e906fde87194845a1868c">flush_object</a> ()</td></tr>
<tr class="memdesc:a96a95bd9942e906fde87194845a1868c inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the object represented by the tree.  <a href="classoomph_1_1Tree.html#a96a95bd9942e906fde87194845a1868c">More...</a><br /></td></tr>
<tr class="separator:a96a95bd9942e906fde87194845a1868c inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ca6416d7a368e29da6a6a998f460c7 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Tree.html">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#ab2ca6416d7a368e29da6a6a998f460c7">son_pt</a> (const int &amp;son_index) const</td></tr>
<tr class="memdesc:ab2ca6416d7a368e29da6a6a998f460c7 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to the son for a given index. Note that to aid code readability specific enums have been defined for specific trees. However, these are simply aliases for ints and the general interface can be implemented once, here.  <a href="classoomph_1_1Tree.html#ab2ca6416d7a368e29da6a6a998f460c7">More...</a><br /></td></tr>
<tr class="separator:ab2ca6416d7a368e29da6a6a998f460c7 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7026d14ead1a8d91ce417dfd0cd9478 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#ab7026d14ead1a8d91ce417dfd0cd9478">set_son_pt</a> (const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Tree.html">Tree</a> * &gt; &amp;<a class="el" href="classoomph_1_1Tree.html#ab2ca6416d7a368e29da6a6a998f460c7">son_pt</a>)</td></tr>
<tr class="memdesc:ab7026d14ead1a8d91ce417dfd0cd9478 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set vector of pointers to sons, indexed by the appropriate enum that identies son types. (To aid code readability specific enums have been defined for specific trees. However, these are simply aliases for ints and the general interface can be implemented once, here).  <a href="classoomph_1_1Tree.html#ab7026d14ead1a8d91ce417dfd0cd9478">More...</a><br /></td></tr>
<tr class="separator:ab7026d14ead1a8d91ce417dfd0cd9478 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e4123b40f6fb52d180a154c9123e85 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a31e4123b40f6fb52d180a154c9123e85">nsons</a> () const</td></tr>
<tr class="memdesc:a31e4123b40f6fb52d180a154c9123e85 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of sons (zero if it's a leaf node)  <a href="classoomph_1_1Tree.html#a31e4123b40f6fb52d180a154c9123e85">More...</a><br /></td></tr>
<tr class="separator:a31e4123b40f6fb52d180a154c9123e85 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34df656d2f298dbbdf60e7890a3dff2f inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a34df656d2f298dbbdf60e7890a3dff2f">flush_sons</a> ()</td></tr>
<tr class="memdesc:a34df656d2f298dbbdf60e7890a3dff2f inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the sons.  <a href="classoomph_1_1Tree.html#a34df656d2f298dbbdf60e7890a3dff2f">More...</a><br /></td></tr>
<tr class="separator:a34df656d2f298dbbdf60e7890a3dff2f inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48479dc463d2a8f10400b4b00643a27 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#ae48479dc463d2a8f10400b4b00643a27">root_pt</a> ()</td></tr>
<tr class="memdesc:ae48479dc463d2a8f10400b4b00643a27 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to root of the tree.  <a href="classoomph_1_1Tree.html#ae48479dc463d2a8f10400b4b00643a27">More...</a><br /></td></tr>
<tr class="separator:ae48479dc463d2a8f10400b4b00643a27 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4dee01da0a463c4a3a5be574943632 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a3e4dee01da0a463c4a3a5be574943632">root_pt</a> () const</td></tr>
<tr class="memdesc:a3e4dee01da0a463c4a3a5be574943632 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to root of the tree (const version)  <a href="classoomph_1_1Tree.html#a3e4dee01da0a463c4a3a5be574943632">More...</a><br /></td></tr>
<tr class="separator:a3e4dee01da0a463c4a3a5be574943632 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975ccfd63ffa14a04f14a37b3d2ff931 inherit pub_methods_classoomph_1_1Tree"><td class="memTemplParams" colspan="2">template&lt;class ELEMENT &gt; </td></tr>
<tr class="memitem:a975ccfd63ffa14a04f14a37b3d2ff931 inherit pub_methods_classoomph_1_1Tree"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a975ccfd63ffa14a04f14a37b3d2ff931">split_if_required</a> ()</td></tr>
<tr class="memdesc:a975ccfd63ffa14a04f14a37b3d2ff931 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">If required, split the leaf and create its sons &ndash; criterion: bool <a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c" title="Return the pointer to the object (RefineableElement) represented by the tree.">object_pt()</a>-&gt; to_be_refined() = true.  <a href="classoomph_1_1Tree.html#a975ccfd63ffa14a04f14a37b3d2ff931">More...</a><br /></td></tr>
<tr class="separator:a975ccfd63ffa14a04f14a37b3d2ff931 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6502324233a86eeeadba7f46505656af inherit pub_methods_classoomph_1_1Tree"><td class="memTemplParams" colspan="2">template&lt;class ELEMENT &gt; </td></tr>
<tr class="memitem:a6502324233a86eeeadba7f46505656af inherit pub_methods_classoomph_1_1Tree"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a6502324233a86eeeadba7f46505656af">p_refine_if_required</a> (<a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *&amp;mesh_pt)</td></tr>
<tr class="memdesc:a6502324233a86eeeadba7f46505656af inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">If required, p-refine the leaf &ndash; criterion: bool <a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c" title="Return the pointer to the object (RefineableElement) represented by the tree.">object_pt()</a>-&gt; to_be_p_refined() = true or bool <a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c" title="Return the pointer to the object (RefineableElement) represented by the tree.">object_pt()</a>-&gt; to_be_p_unrefined() = true.  <a href="classoomph_1_1Tree.html#a6502324233a86eeeadba7f46505656af">More...</a><br /></td></tr>
<tr class="separator:a6502324233a86eeeadba7f46505656af inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f977931ece6b719a9e616037bb2481 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#af4f977931ece6b719a9e616037bb2481">merge_sons_if_required</a> (<a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *&amp;mesh_pt)</td></tr>
<tr class="memdesc:af4f977931ece6b719a9e616037bb2481 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">If required, merge the four sons for unrefinement &ndash; criterion: bool <a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c" title="Return the pointer to the object (RefineableElement) represented by the tree.">object_pt()</a>-&gt; sons_to_be_unrefined() = true.  <a href="classoomph_1_1Tree.html#af4f977931ece6b719a9e616037bb2481">More...</a><br /></td></tr>
<tr class="separator:af4f977931ece6b719a9e616037bb2481 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea17489589a1872db51f2b142da4c1fb inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#aea17489589a1872db51f2b142da4c1fb">deactivate_object</a> ()</td></tr>
<tr class="memdesc:aea17489589a1872db51f2b142da4c1fb inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the <a class="el" href="classoomph_1_1RefineableElement.html" title="RefineableElements are FiniteElements that may be subdivided into children to provide a better local ...">RefineableElement</a>'s deactivate_element() function.  <a href="classoomph_1_1Tree.html#aea17489589a1872db51f2b142da4c1fb">More...</a><br /></td></tr>
<tr class="separator:aea17489589a1872db51f2b142da4c1fb inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caab39c8bee6fb65bbafed523aa6d3d inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a3caab39c8bee6fb65bbafed523aa6d3d">traverse_all</a> (<a class="el" href="classoomph_1_1Tree.html#a6b8ef236d41f52c92973682ca83679d5">Tree::VoidMemberFctPt</a> member_function)</td></tr>
<tr class="memdesc:a3caab39c8bee6fb65bbafed523aa6d3d inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree and execute void <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> member function member_function() at all its "nodes".  <a href="classoomph_1_1Tree.html#a3caab39c8bee6fb65bbafed523aa6d3d">More...</a><br /></td></tr>
<tr class="separator:a3caab39c8bee6fb65bbafed523aa6d3d inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c67186ca9c87eef9ce7eaa0af41057 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#af5c67186ca9c87eef9ce7eaa0af41057">traverse_all</a> (<a class="el" href="classoomph_1_1Tree.html#a498ffc10556f4335e831a06fc885a27a">Tree::VoidMeshPtArgumentMemberFctPt</a> member_function, <a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *&amp;mesh_pt)</td></tr>
<tr class="memdesc:af5c67186ca9c87eef9ce7eaa0af41057 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree and excute void <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> member function that takes a pointer to a mesh as an argument.  <a href="classoomph_1_1Tree.html#af5c67186ca9c87eef9ce7eaa0af41057">More...</a><br /></td></tr>
<tr class="separator:af5c67186ca9c87eef9ce7eaa0af41057 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef175445b09edb47624c4b88c6d548bc inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#aef175445b09edb47624c4b88c6d548bc">traverse_all_but_leaves</a> (<a class="el" href="classoomph_1_1Tree.html#a6b8ef236d41f52c92973682ca83679d5">Tree::VoidMemberFctPt</a> member_function)</td></tr>
<tr class="memdesc:aef175445b09edb47624c4b88c6d548bc inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree and execute void <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> member function member_function() at all its "nodes" aparat from the leaves.  <a href="classoomph_1_1Tree.html#aef175445b09edb47624c4b88c6d548bc">More...</a><br /></td></tr>
<tr class="separator:aef175445b09edb47624c4b88c6d548bc inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e0e3695dd8986e439927b7657ff741 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a22e0e3695dd8986e439927b7657ff741">traverse_leaves</a> (<a class="el" href="classoomph_1_1Tree.html#a6b8ef236d41f52c92973682ca83679d5">Tree::VoidMemberFctPt</a> member_function)</td></tr>
<tr class="memdesc:a22e0e3695dd8986e439927b7657ff741 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree and execute void <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> member function member_function() only at its leaves.  <a href="classoomph_1_1Tree.html#a22e0e3695dd8986e439927b7657ff741">More...</a><br /></td></tr>
<tr class="separator:a22e0e3695dd8986e439927b7657ff741 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914e74ef473b7e82299ea9337d37830d inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a914e74ef473b7e82299ea9337d37830d">traverse_leaves</a> (<a class="el" href="classoomph_1_1Tree.html#a498ffc10556f4335e831a06fc885a27a">Tree::VoidMeshPtArgumentMemberFctPt</a> member_function, <a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *&amp;mesh_pt)</td></tr>
<tr class="memdesc:a914e74ef473b7e82299ea9337d37830d inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the tree and execute void <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> member function that takes a pointer to a mesh as an argument only at its leaves.  <a href="classoomph_1_1Tree.html#a914e74ef473b7e82299ea9337d37830d">More...</a><br /></td></tr>
<tr class="separator:a914e74ef473b7e82299ea9337d37830d inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfbeb9178ce92a8a51e3a15293a86d1 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#accfbeb9178ce92a8a51e3a15293a86d1">stick_leaves_into_vector</a> (<a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Tree.html">Tree</a> * &gt; &amp;)</td></tr>
<tr class="memdesc:accfbeb9178ce92a8a51e3a15293a86d1 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse tree and stick pointers to leaf "nodes" (only) into <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a>.  <a href="classoomph_1_1Tree.html#accfbeb9178ce92a8a51e3a15293a86d1">More...</a><br /></td></tr>
<tr class="separator:accfbeb9178ce92a8a51e3a15293a86d1 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c84b4e4700a825ef0a6ca533b9ae895 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a2c84b4e4700a825ef0a6ca533b9ae895">stick_all_tree_nodes_into_vector</a> (<a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Tree.html">Tree</a> * &gt; &amp;)</td></tr>
<tr class="memdesc:a2c84b4e4700a825ef0a6ca533b9ae895 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse and stick pointers to all "nodes" into <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a>.  <a href="classoomph_1_1Tree.html#a2c84b4e4700a825ef0a6ca533b9ae895">More...</a><br /></td></tr>
<tr class="separator:a2c84b4e4700a825ef0a6ca533b9ae895 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7537f8fe7c896d2220eb2da03567b34d inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a7537f8fe7c896d2220eb2da03567b34d">son_type</a> () const</td></tr>
<tr class="memdesc:a7537f8fe7c896d2220eb2da03567b34d inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return son type.  <a href="classoomph_1_1Tree.html#a7537f8fe7c896d2220eb2da03567b34d">More...</a><br /></td></tr>
<tr class="separator:a7537f8fe7c896d2220eb2da03567b34d inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72000456c76880e3f78f8f8fb43d49d8 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a72000456c76880e3f78f8f8fb43d49d8">is_leaf</a> ()</td></tr>
<tr class="memdesc:a72000456c76880e3f78f8f8fb43d49d8 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the tree is a leaf node.  <a href="classoomph_1_1Tree.html#a72000456c76880e3f78f8f8fb43d49d8">More...</a><br /></td></tr>
<tr class="separator:a72000456c76880e3f78f8f8fb43d49d8 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8444ddeda272b70669b8bbe929708a inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Tree.html">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a5f8444ddeda272b70669b8bbe929708a">father_pt</a> () const</td></tr>
<tr class="memdesc:a5f8444ddeda272b70669b8bbe929708a inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to father: NULL if it's a root node.  <a href="classoomph_1_1Tree.html#a5f8444ddeda272b70669b8bbe929708a">More...</a><br /></td></tr>
<tr class="separator:a5f8444ddeda272b70669b8bbe929708a inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cf27d3116db0f8d2f18b3faf09ec15 inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#ac0cf27d3116db0f8d2f18b3faf09ec15">set_father_pt</a> (<a class="el" href="classoomph_1_1Tree.html">Tree</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a5f8444ddeda272b70669b8bbe929708a">father_pt</a>)</td></tr>
<tr class="memdesc:ac0cf27d3116db0f8d2f18b3faf09ec15 inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the father.  <a href="classoomph_1_1Tree.html#ac0cf27d3116db0f8d2f18b3faf09ec15">More...</a><br /></td></tr>
<tr class="separator:ac0cf27d3116db0f8d2f18b3faf09ec15 inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3eba84432fcc595684ac7eb8331b8ee inherit pub_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#ab3eba84432fcc595684ac7eb8331b8ee">level</a> () const</td></tr>
<tr class="memdesc:ab3eba84432fcc595684ac7eb8331b8ee inherit pub_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the level of the <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> (root=0)  <a href="classoomph_1_1Tree.html#ab3eba84432fcc595684ac7eb8331b8ee">More...</a><br /></td></tr>
<tr class="separator:ab3eba84432fcc595684ac7eb8331b8ee inherit pub_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a29d019becbc07f9ea2811a0ff0881d9a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a29d019becbc07f9ea2811a0ff0881d9a">faces_of_common_edge</a> (const int &amp;edge)</td></tr>
<tr class="memdesc:a29d019becbc07f9ea2811a0ff0881d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that, given an edge, returns the two faces on which it.  <a href="classoomph_1_1OcTree.html#a29d019becbc07f9ea2811a0ff0881d9a">More...</a><br /></td></tr>
<tr class="separator:a29d019becbc07f9ea2811a0ff0881d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7b0830cd9c913786e23259c69c71a0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a5d7b0830cd9c913786e23259c69c71a0">setup_static_data</a> ()</td></tr>
<tr class="memdesc:a5d7b0830cd9c913786e23259c69c71a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the static data, rotation and reflection schemes, etc.  <a href="classoomph_1_1OcTree.html#a5d7b0830cd9c913786e23259c69c71a0">More...</a><br /></td></tr>
<tr class="separator:a5d7b0830cd9c913786e23259c69c71a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd54b3cd1f4196d618e73d19bb4ba157"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#afd54b3cd1f4196d618e73d19bb4ba157">doc_face_neighbours</a> (<a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Tree.html">Tree</a> * &gt; forest_nodes_pt, std::ofstream &amp;neighbours_file, std::ofstream &amp;neighbours_txt_file, double &amp;max_error)</td></tr>
<tr class="memdesc:afd54b3cd1f4196d618e73d19bb4ba157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Doc/check all face neighbours of octree (nodes) contained in the <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> forest_node_pt. Output into neighbours_file which can be viewed from tecplot with OcTreeNeighbours.mcr Neighbour info and errors are displayed on neighbours_txt_file. Finally, compute the max. error between vertices when viewed from neighhbouring element. If the two filestreams are closed, output is suppressed.  <a href="classoomph_1_1OcTree.html#afd54b3cd1f4196d618e73d19bb4ba157">More...</a><br /></td></tr>
<tr class="separator:afd54b3cd1f4196d618e73d19bb4ba157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728b0580f568f9d5fb814458b6c75fe4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a728b0580f568f9d5fb814458b6c75fe4">doc_true_edge_neighbours</a> (<a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Tree.html">Tree</a> * &gt; forest_nodes_pt, std::ofstream &amp;neighbours_file, std::ofstream &amp;no_true_edge_file, std::ofstream &amp;neighbours_txt_file, double &amp;max_error)</td></tr>
<tr class="memdesc:a728b0580f568f9d5fb814458b6c75fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Doc/check all true edge neighbours of octree (nodes) contained in the <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> forest_node_pt. Output into neighbours_file which can be viewed from tecplot with OcTreeNeighbours.mcr Neighbour info and errors are displayed on neighbours_txt_file. Finally, compute the max. error between vertices when viewed from neighhbouring element. If the two filestreams are closed, output is suppressed.  <a href="classoomph_1_1OcTree.html#a728b0580f568f9d5fb814458b6c75fe4">More...</a><br /></td></tr>
<tr class="separator:a728b0580f568f9d5fb814458b6c75fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03edae455d5bd788acf426ca3f87b9d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#ab03edae455d5bd788acf426ca3f87b9d">get_the_other_face</a> (const unsigned &amp;n1, const unsigned &amp;n2, const unsigned &amp;nnode1d, const int &amp;face)</td></tr>
<tr class="memdesc:ab03edae455d5bd788acf426ca3f87b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an edge is bordered by the nodes whose local numbers are n1 and n2 in an element with nnode1d nodes along each coordinate direction, then this edge is shared by two faces. This function takes one of these faces as the argument <code>face</code> and returns the other one. (<code>face</code> is a direction in the set U,D,F,B,L,R).  <a href="classoomph_1_1OcTree.html#ab03edae455d5bd788acf426ca3f87b9d">More...</a><br /></td></tr>
<tr class="separator:ab03edae455d5bd788acf426ca3f87b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a129b95ad303ed340bb8bd86e05384"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#af2a129b95ad303ed340bb8bd86e05384">vertex_to_node_number</a> (const int &amp;vertex, const unsigned &amp;nnode1d)</td></tr>
<tr class="memdesc:af2a129b95ad303ed340bb8bd86e05384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the local node number of given vertex [LDB,RDB,...] in an element with nnode1d nodes in each coordinate direction.  <a href="classoomph_1_1OcTree.html#af2a129b95ad303ed340bb8bd86e05384">More...</a><br /></td></tr>
<tr class="separator:af2a129b95ad303ed340bb8bd86e05384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cbe5258a41168fe2d891e52ae64e6b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a43cbe5258a41168fe2d891e52ae64e6b">node_number_to_vertex</a> (const unsigned &amp;n, const unsigned &amp;nnode1d)</td></tr>
<tr class="memdesc:a43cbe5258a41168fe2d891e52ae64e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vertex [LDB,RDB,...] of local (vertex) node n in an element with nnode1d nodes in each coordinate direction.  <a href="classoomph_1_1OcTree.html#a43cbe5258a41168fe2d891e52ae64e6b">More...</a><br /></td></tr>
<tr class="separator:a43cbe5258a41168fe2d891e52ae64e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e5185f0395a19883e216fd80103cf7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a25e5185f0395a19883e216fd80103cf7">rotate</a> (const int &amp;new_up, const int &amp;new_right, const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; &amp;dir)</td></tr>
<tr class="memdesc:a25e5185f0395a19883e216fd80103cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If U[p] becomes new_up and R[ight] becomes new_right then the direction vector <code>dir</code> becomes rotate(new_up, new_right, dir)  <a href="classoomph_1_1OcTree.html#a25e5185f0395a19883e216fd80103cf7">More...</a><br /></td></tr>
<tr class="separator:a25e5185f0395a19883e216fd80103cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65a00f8f47eb8b6da56ffa9d6ba8f36"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#ab65a00f8f47eb8b6da56ffa9d6ba8f36">rotate</a> (const int &amp;new_up, const int &amp;new_right, const int &amp;dir)</td></tr>
<tr class="memdesc:ab65a00f8f47eb8b6da56ffa9d6ba8f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">If U[p] becomes new_up and R[ight] becomes new_right then the direction <code>dir</code> becomes <code>rotate(new_up, new_right, dir)</code>  <a href="classoomph_1_1OcTree.html#ab65a00f8f47eb8b6da56ffa9d6ba8f36">More...</a><br /></td></tr>
<tr class="separator:ab65a00f8f47eb8b6da56ffa9d6ba8f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classoomph_1_1Tree"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classoomph_1_1Tree')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classoomph_1_1Tree.html">oomph::Tree</a></td></tr>
<tr class="memitem:affbae3271da943dfc23645ade966aef9 inherit pub_static_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">static double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#affbae3271da943dfc23645ade966aef9">max_neighbour_finding_tolerance</a> ()</td></tr>
<tr class="memdesc:affbae3271da943dfc23645ade966aef9 inherit pub_static_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max. allowed discrepancy in neighbour finding routine (distance between points when identified from two neighbouring elements)  <a href="classoomph_1_1Tree.html#affbae3271da943dfc23645ade966aef9">More...</a><br /></td></tr>
<tr class="separator:affbae3271da943dfc23645ade966aef9 inherit pub_static_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a2e9487b716f4d583aada06a850b8eae9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a2e9487b716f4d583aada06a850b8eae9">Direct_string</a></td></tr>
<tr class="memdesc:a2e9487b716f4d583aada06a850b8eae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate (enumerated) directions into strings.  <a href="classoomph_1_1OcTree.html#a2e9487b716f4d583aada06a850b8eae9">More...</a><br /></td></tr>
<tr class="separator:a2e9487b716f4d583aada06a850b8eae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b5b6208e34976cb3fd50e84b5c2d05"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a50b5b6208e34976cb3fd50e84b5c2d05">Reflect_face</a></td></tr>
<tr class="memdesc:a50b5b6208e34976cb3fd50e84b5c2d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get opposite face, e.g. Reflect_face[L]=R.  <a href="classoomph_1_1OcTree.html#a50b5b6208e34976cb3fd50e84b5c2d05">More...</a><br /></td></tr>
<tr class="separator:a50b5b6208e34976cb3fd50e84b5c2d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb757b41fc1c4b7ea697de40c19b6c36"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#aeb757b41fc1c4b7ea697de40c19b6c36">Reflect_edge</a></td></tr>
<tr class="memdesc:aeb757b41fc1c4b7ea697de40c19b6c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get opposite edge, e.g. Reflect_edge[DB]=UF.  <a href="classoomph_1_1OcTree.html#aeb757b41fc1c4b7ea697de40c19b6c36">More...</a><br /></td></tr>
<tr class="separator:aeb757b41fc1c4b7ea697de40c19b6c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee0e40be5a1aa25e7356e23ec327636"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#acee0e40be5a1aa25e7356e23ec327636">Reflect_vertex</a></td></tr>
<tr class="memdesc:acee0e40be5a1aa25e7356e23ec327636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get opposite vertex, e.g. Reflect_vertex[LDB]=RUF.  <a href="classoomph_1_1OcTree.html#acee0e40be5a1aa25e7356e23ec327636">More...</a><br /></td></tr>
<tr class="separator:acee0e40be5a1aa25e7356e23ec327636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf182a71db90c350c3f1d334d73d103f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#acf182a71db90c350c3f1d334d73d103f">Vertex_at_end_of_edge</a></td></tr>
<tr class="memdesc:acf182a71db90c350c3f1d334d73d103f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a></code> of vectors containing the two vertices for each edge, e.g. <code>Vertex_at_end_of_edge</code>[LU][0]=LUB and <code>Vertex_at_end_of_edge</code>[LU][1]=LUF.  <a href="classoomph_1_1OcTree.html#acf182a71db90c350c3f1d334d73d103f">More...</a><br /></td></tr>
<tr class="separator:acf182a71db90c350c3f1d334d73d103f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec83bade91057d89aa3896274cb96b7e"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt;, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#aec83bade91057d89aa3896274cb96b7e">Vector_to_direction</a></td></tr>
<tr class="memdesc:aec83bade91057d89aa3896274cb96b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each vector representing a direction can be translated into a direction, either a son type (vertex), a face or an edge. E.g. : Vector_to_direction[(1,-1,1)]=RDF, Vector_to_direction[(0,1,0)]=U.  <a href="classoomph_1_1OcTree.html#aec83bade91057d89aa3896274cb96b7e">More...</a><br /></td></tr>
<tr class="separator:aec83bade91057d89aa3896274cb96b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf813fbb9cffe89fb51f3c8ccd3083ca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#adf813fbb9cffe89fb51f3c8ccd3083ca">Direction_to_vector</a></td></tr>
<tr class="memdesc:adf813fbb9cffe89fb51f3c8ccd3083ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each direction, i.e. a son_type (vertex), a face or an edge, this defines a vector that indicates this direction. E.g : Direction_to_vector[RDB]=(1,-1,-1), Direction_to_vector[U]=(0,1,0)  <a href="classoomph_1_1OcTree.html#adf813fbb9cffe89fb51f3c8ccd3083ca">More...</a><br /></td></tr>
<tr class="separator:adf813fbb9cffe89fb51f3c8ccd3083ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cff579697781e1ec50c86517feec77"><td class="memItemLeft" align="right" valign="top">static std::map&lt; std::pair&lt; std::pair&lt; int, int &gt;, std::pair&lt; int, int &gt; &gt;, std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a88cff579697781e1ec50c86517feec77">Up_and_right_equivalent_for_pairs_of_vertices</a></td></tr>
<tr class="memdesc:a88cff579697781e1ec50c86517feec77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the up/right-equivalents corresponding to two pairs of vertices along an element edge:  <a href="classoomph_1_1OcTree.html#a88cff579697781e1ec50c86517feec77">More...</a><br /></td></tr>
<tr class="separator:a88cff579697781e1ec50c86517feec77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classoomph_1_1Tree"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classoomph_1_1Tree')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classoomph_1_1Tree.html">oomph::Tree</a></td></tr>
<tr class="memitem:a9e532196340dcd859ff8207eea2ddbbc inherit pub_static_attribs_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a9e532196340dcd859ff8207eea2ddbbc">OMEGA</a> = 26</td></tr>
<tr class="memdesc:a9e532196340dcd859ff8207eea2ddbbc inherit pub_static_attribs_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value for an unassigned neighbour.  <a href="classoomph_1_1Tree.html#a9e532196340dcd859ff8207eea2ddbbc">More...</a><br /></td></tr>
<tr class="separator:a9e532196340dcd859ff8207eea2ddbbc inherit pub_static_attribs_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abb830075e2f08aa68bf65a07089039ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#abb830075e2f08aa68bf65a07089039ca">OcTree</a> ()</td></tr>
<tr class="memdesc:abb830075e2f08aa68bf65a07089039ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor (empty and broken)  <a href="classoomph_1_1OcTree.html#abb830075e2f08aa68bf65a07089039ca">More...</a><br /></td></tr>
<tr class="separator:abb830075e2f08aa68bf65a07089039ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0f7987566846a0451bdc1ed522a2d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a2c0f7987566846a0451bdc1ed522a2d4">OcTree</a> (<a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c">object_pt</a>)</td></tr>
<tr class="memdesc:a2c0f7987566846a0451bdc1ed522a2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for empty (root) tree: no father, no sons; just pass a pointer to its object (a <a class="el" href="classoomph_1_1RefineableQElement_3_013_01_4.html" title="Refineable version of QElement&lt;3,NNODE_1D&gt;.">RefineableQElement&lt;3&gt;</a>). This is protected because OcTrees can only be created internally, during the split operation. Only OcTreeRoots can be created externally.  <a href="classoomph_1_1OcTree.html#a2c0f7987566846a0451bdc1ed522a2d4">More...</a><br /></td></tr>
<tr class="separator:a2c0f7987566846a0451bdc1ed522a2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79e3cbf9d0c65f9e4a01207d65d4967"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#af79e3cbf9d0c65f9e4a01207d65d4967">OcTree</a> (<a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c">object_pt</a>, <a class="el" href="classoomph_1_1Tree.html">Tree</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a5f8444ddeda272b70669b8bbe929708a">father_pt</a>, const int &amp;<a class="el" href="classoomph_1_1Tree.html#a7537f8fe7c896d2220eb2da03567b34d">son_type</a>)</td></tr>
<tr class="memdesc:af79e3cbf9d0c65f9e4a01207d65d4967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for tree that has a father: Pass it the pointer to its object, the pointer to its father and tell it what type of son (LDB,RDB,...) it is. Protected because OcTrees can only be created internally, during the split operation. Only OcTreeRoots can be created externally.  <a href="classoomph_1_1OcTree.html#af79e3cbf9d0c65f9e4a01207d65d4967">More...</a><br /></td></tr>
<tr class="separator:af79e3cbf9d0c65f9e4a01207d65d4967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classoomph_1_1Tree"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classoomph_1_1Tree')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classoomph_1_1Tree.html">oomph::Tree</a></td></tr>
<tr class="memitem:ada92f1aa44ee6ef5b52ec5ad0af00359 inherit pro_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#ada92f1aa44ee6ef5b52ec5ad0af00359">Tree</a> ()</td></tr>
<tr class="memdesc:ada92f1aa44ee6ef5b52ec5ad0af00359 inherit pro_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor (empty and broken)  <a href="classoomph_1_1Tree.html#ada92f1aa44ee6ef5b52ec5ad0af00359">More...</a><br /></td></tr>
<tr class="separator:ada92f1aa44ee6ef5b52ec5ad0af00359 inherit pro_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e78c3a130add917de182ab5f1674531 inherit pro_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a6e78c3a130add917de182ab5f1674531">Tree</a> (<a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c">object_pt</a>)</td></tr>
<tr class="memdesc:a6e78c3a130add917de182ab5f1674531 inherit pro_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for empty (root) tree: no father, no sons; just pass a pointer to its object Protected because Trees can only be created internally, during the split operation. Only TreeRoots can be created externally.  <a href="classoomph_1_1Tree.html#a6e78c3a130add917de182ab5f1674531">More...</a><br /></td></tr>
<tr class="separator:a6e78c3a130add917de182ab5f1674531 inherit pro_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d611dde1f429500330f28e56ee71883 inherit pro_methods_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a9d611dde1f429500330f28e56ee71883">Tree</a> (<a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a2f2eeb0f1dd161f696cccc652974ff4c">object_pt</a>, <a class="el" href="classoomph_1_1Tree.html">Tree</a> *const &amp;<a class="el" href="classoomph_1_1Tree.html#a5f8444ddeda272b70669b8bbe929708a">father_pt</a>, const int &amp;<a class="el" href="classoomph_1_1Tree.html#a7537f8fe7c896d2220eb2da03567b34d">son_type</a>)</td></tr>
<tr class="memdesc:a9d611dde1f429500330f28e56ee71883 inherit pro_methods_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for tree that has a father: Pass it the pointer to its object, the pointer to its father and tell it what type of son it is. Protected because Trees can only be created internally, during the split operation. Only TreeRoots can be created externally.  <a href="classoomph_1_1Tree.html#a9d611dde1f429500330f28e56ee71883">More...</a><br /></td></tr>
<tr class="separator:a9d611dde1f429500330f28e56ee71883 inherit pro_methods_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:addaa397d11580ec949531c8ae9b082a5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#addaa397d11580ec949531c8ae9b082a5">Static_data_has_been_setup</a> = false</td></tr>
<tr class="memdesc:addaa397d11580ec949531c8ae9b082a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bool indicating that static member data has been setup.  <a href="classoomph_1_1OcTree.html#addaa397d11580ec949531c8ae9b082a5">More...</a><br /></td></tr>
<tr class="separator:addaa397d11580ec949531c8ae9b082a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classoomph_1_1Tree"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classoomph_1_1Tree')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classoomph_1_1Tree.html">oomph::Tree</a></td></tr>
<tr class="memitem:aef9abebc166fa3bf81ecb59ec0d5d6b2 inherit pro_static_attribs_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#aef9abebc166fa3bf81ecb59ec0d5d6b2">Max_neighbour_finding_tolerance</a> = 1.0e-14</td></tr>
<tr class="memdesc:aef9abebc166fa3bf81ecb59ec0d5d6b2 inherit pro_static_attribs_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max. allowed discrepancy in neighbour finding routine (distance between points when identified from two neighbouring elements)  <a href="classoomph_1_1Tree.html#aef9abebc166fa3bf81ecb59ec0d5d6b2">More...</a><br /></td></tr>
<tr class="separator:aef9abebc166fa3bf81ecb59ec0d5d6b2 inherit pro_static_attribs_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afd5ef9914c4b65f604bbf587343aca72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1OcTree.html">OcTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#afd5ef9914c4b65f604bbf587343aca72">gteq_face_neighbour</a> (const int &amp;direction, double &amp;s_difflo, double &amp;s_diffhi, int &amp;diff_level, bool &amp;in_neighbouring_tree, int max_level, <a class="el" href="classoomph_1_1OcTreeRoot.html">OcTreeRoot</a> *orig_root_pt) const</td></tr>
<tr class="memdesc:afd5ef9914c4b65f604bbf587343aca72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find &lsquo;greater-or-equal-sized face neighbour&rsquo; in given direction (L/R/U/D/B/F).  <a href="classoomph_1_1OcTree.html#afd5ef9914c4b65f604bbf587343aca72">More...</a><br /></td></tr>
<tr class="separator:afd5ef9914c4b65f604bbf587343aca72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa4c8bbf2fdbad7465af2c4964a915f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1OcTree.html">OcTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#abaa4c8bbf2fdbad7465af2c4964a915f">gteq_edge_neighbour</a> (const int &amp;direction, const unsigned &amp;i_root_edge_neighbour, unsigned &amp;nroot_edge_neighbour, double &amp;s_diff, int &amp;diff_level, int max_level, <a class="el" href="classoomph_1_1OcTreeRoot.html">OcTreeRoot</a> *orig_root_pt) const</td></tr>
<tr class="memdesc:abaa4c8bbf2fdbad7465af2c4964a915f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find &lsquo;greater-or-equal-sized edge neighbour&rsquo; in given direction (LB,RB,DB,UB [the back edges], LD,RD,LU,RU [the side edges], LF,RF,DF,UF [the front edges]).  <a href="classoomph_1_1OcTree.html#abaa4c8bbf2fdbad7465af2c4964a915f">More...</a><br /></td></tr>
<tr class="separator:abaa4c8bbf2fdbad7465af2c4964a915f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab780bf82a61230f23bc3d96774a63010"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#ab780bf82a61230f23bc3d96774a63010">edge_neighbour_is_face_neighbour</a> (const int &amp;edge, <a class="el" href="classoomph_1_1OcTree.html">OcTree</a> *edge_neighb_pt) const</td></tr>
<tr class="memdesc:ab780bf82a61230f23bc3d96774a63010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the edge neighbour (for edge "edge") specified via the pointer also a face neighbour for one of the two adjacent faces?  <a href="classoomph_1_1OcTree.html#ab780bf82a61230f23bc3d96774a63010">More...</a><br /></td></tr>
<tr class="separator:ab780bf82a61230f23bc3d96774a63010"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:ad3667015671b5dbc06fdc298c59e4064"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#ad3667015671b5dbc06fdc298c59e4064">construct_rotation_matrix</a> (int &amp;axis, int &amp;angle, <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; int &gt; &amp;mat)</td></tr>
<tr class="memdesc:ad3667015671b5dbc06fdc298c59e4064"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructs the rotation matrix of the rotation around the axis <code>axis</code> with an angle of <code>angle*90</code>.  <a href="classoomph_1_1OcTree.html#ad3667015671b5dbc06fdc298c59e4064">More...</a><br /></td></tr>
<tr class="separator:ad3667015671b5dbc06fdc298c59e4064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb0cccaedfcb4301edcc8dc7cead639"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a4cb0cccaedfcb4301edcc8dc7cead639">mult_mat_vect</a> (const <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; int &gt; &amp;mat, const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; &amp;vect1, <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; &amp;vect2)</td></tr>
<tr class="memdesc:a4cb0cccaedfcb4301edcc8dc7cead639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function: Performs the operation : vect2 = mat*vect1.  <a href="classoomph_1_1OcTree.html#a4cb0cccaedfcb4301edcc8dc7cead639">More...</a><br /></td></tr>
<tr class="separator:a4cb0cccaedfcb4301edcc8dc7cead639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67128675db4b8d5d3e5815134d78fd2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#ad67128675db4b8d5d3e5815134d78fd2">mult_mat_mat</a> (const <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; int &gt; &amp;mat1, const <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; int &gt; &amp;mat2, <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; int &gt; &amp;mat3)</td></tr>
<tr class="memdesc:ad67128675db4b8d5d3e5815134d78fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function: Performs the operation : mat3=mat1*mat2.  <a href="classoomph_1_1OcTree.html#ad67128675db4b8d5d3e5815134d78fd2">More...</a><br /></td></tr>
<tr class="separator:ad67128675db4b8d5d3e5815134d78fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2dfb7f1527f77cf2900eecef279ee0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a6f2dfb7f1527f77cf2900eecef279ee0">vertex_node_to_vector</a> (const unsigned &amp;n, const unsigned &amp;nnode1d)</td></tr>
<tr class="memdesc:a6f2dfb7f1527f77cf2900eecef279ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector of the coordinate directions of vertex node number n in an element with nnode1d element per dimension.  <a href="classoomph_1_1OcTree.html#a6f2dfb7f1527f77cf2900eecef279ee0">More...</a><br /></td></tr>
<tr class="separator:a6f2dfb7f1527f77cf2900eecef279ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:aa9c70aef8a78008e8fa668c5e0e516d9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#aa9c70aef8a78008e8fa668c5e0e516d9">Cosi</a></td></tr>
<tr class="memdesc:aa9c70aef8a78008e8fa668c5e0e516d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry in rotation matrix: cos(i*90)  <a href="classoomph_1_1OcTree.html#aa9c70aef8a78008e8fa668c5e0e516d9">More...</a><br /></td></tr>
<tr class="separator:aa9c70aef8a78008e8fa668c5e0e516d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5537d73ec80462fe6f03bdfd5ac836ff"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a5537d73ec80462fe6f03bdfd5ac836ff">Sini</a></td></tr>
<tr class="memdesc:a5537d73ec80462fe6f03bdfd5ac836ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry in rotation matrix sin(i*90)  <a href="classoomph_1_1OcTree.html#a5537d73ec80462fe6f03bdfd5ac836ff">More...</a><br /></td></tr>
<tr class="separator:a5537d73ec80462fe6f03bdfd5ac836ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e29b9da2bf17cc81d803af6925890b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a24e29b9da2bf17cc81d803af6925890b">Is_adjacent</a></td></tr>
<tr class="memdesc:a24e29b9da2bf17cc81d803af6925890b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of direction/octant adjacency scheme: Is_adjacent(direction,octant): Is face/edge <code>direction</code> adjacent to octant <code>octant</code> ? (Table in Samet's book)  <a href="classoomph_1_1OcTree.html#a24e29b9da2bf17cc81d803af6925890b">More...</a><br /></td></tr>
<tr class="separator:a24e29b9da2bf17cc81d803af6925890b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2497ec31766ebf0541ff6f2bffa790"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#aae2497ec31766ebf0541ff6f2bffa790">Reflect</a></td></tr>
<tr class="memdesc:aae2497ec31766ebf0541ff6f2bffa790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reflection scheme: Reflect(direction,octant): Get mirror of octant/edge in specified direction. E.g. Reflect(LDF,L)=RDF.  <a href="classoomph_1_1OcTree.html#aae2497ec31766ebf0541ff6f2bffa790">More...</a><br /></td></tr>
<tr class="separator:aae2497ec31766ebf0541ff6f2bffa790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a97dff32038087df0195dcf346405e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a50a97dff32038087df0195dcf346405e">Common_face</a></td></tr>
<tr class="memdesc:a50a97dff32038087df0195dcf346405e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine common face of edges or octants. Slightly bizarre lookup scheme from Samet's book.  <a href="classoomph_1_1OcTree.html#a50a97dff32038087df0195dcf346405e">More...</a><br /></td></tr>
<tr class="separator:a50a97dff32038087df0195dcf346405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11213866602c59eae49ac1c9164b9785"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a11213866602c59eae49ac1c9164b9785">Colour</a></td></tr>
<tr class="memdesc:a11213866602c59eae49ac1c9164b9785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Colours for neighbours in various directions.  <a href="classoomph_1_1OcTree.html#a11213866602c59eae49ac1c9164b9785">More...</a><br /></td></tr>
<tr class="separator:a11213866602c59eae49ac1c9164b9785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114adf939f2937d16a69a541b8e2ceb3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a114adf939f2937d16a69a541b8e2ceb3">S_base</a></td></tr>
<tr class="memdesc:a114adf939f2937d16a69a541b8e2ceb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">s_base(i,direction): Initial value for coordinate s[i] on the face indicated by direction (L/R/U/D/F/B)  <a href="classoomph_1_1OcTree.html#a114adf939f2937d16a69a541b8e2ceb3">More...</a><br /></td></tr>
<tr class="separator:a114adf939f2937d16a69a541b8e2ceb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c005f0207cae66390314859edd9bd1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#af1c005f0207cae66390314859edd9bd1">S_steplo</a></td></tr>
<tr class="memdesc:af1c005f0207cae66390314859edd9bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each face of the <a class="el" href="classoomph_1_1RefineableQElement_3_013_01_4.html" title="Refineable version of QElement&lt;3,NNODE_1D&gt;.">RefineableQElement&lt;3&gt;</a> that is represented by the octree is parametrised by two (of the three) local coordinates that parametrise the entire 3D element. E.g. the B[ack] face is parametrised by (s[0], s[1]); the D[own] face is parametrised by (s[0],s[2]); etc. We always identify the in-face coordinate with the lower (3D) index with the subscript <code>_lo</code> and the one with the larger (3D) index with the subscript <code>_hi</code>. Here we set up the translation scheme between the 2D in-face coordinates (s_lo,s_hi) and the corresponding 3D coordinates: If we're located on face <code>face</code> [L/R/F/B/U/D], then an increase in s_lo from -1 to +1 corresponds to a change of <code>s_steplo(i,face)</code> in the 3D coordinate <code>s</code>[i].  <a href="classoomph_1_1OcTree.html#af1c005f0207cae66390314859edd9bd1">More...</a><br /></td></tr>
<tr class="separator:af1c005f0207cae66390314859edd9bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcc327c9831b6c57f30c8596125c236"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#addcc327c9831b6c57f30c8596125c236">S_stephi</a></td></tr>
<tr class="memdesc:addcc327c9831b6c57f30c8596125c236"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we're located on face <code>face</code> [L/R/F/B/U/D], then an increase in s_hi from -1 to +1 corresponds to a change of <code>s_stephi(i,face)</code> in the 3D coordinate \ s[i]. [Read the discussion of <code>s_steplo</code> for an explanation of the subscripts <code>_hi</code> and <code>_lo</code>.].  <a href="classoomph_1_1OcTree.html#addcc327c9831b6c57f30c8596125c236">More...</a><br /></td></tr>
<tr class="separator:addcc327c9831b6c57f30c8596125c236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ece71f32cf50ba50851d2102af15426"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a2ece71f32cf50ba50851d2102af15426">S_directlo</a></td></tr>
<tr class="memdesc:a2ece71f32cf50ba50851d2102af15426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative to the left/down/back vertex in any (father) octree, the corresponding vertex in the son specified by <code>son_octant</code> has an offset. If we project the son_octant's left/down/back vertex onto the father's face <code>face</code>, it is located at the in-face coordinate <code>s_lo</code> = h/2 <code>S_directlo(face,son_octant)</code>. [See discussion of <code>s_steplo</code> for an explanation of the subscripts <code>_hi</code> and <code>_lo</code>.].  <a href="classoomph_1_1OcTree.html#a2ece71f32cf50ba50851d2102af15426">More...</a><br /></td></tr>
<tr class="separator:a2ece71f32cf50ba50851d2102af15426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11aca558846c26e31f802396508bea51"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a11aca558846c26e31f802396508bea51">S_directhi</a></td></tr>
<tr class="memdesc:a11aca558846c26e31f802396508bea51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative to the left/down/back vertex in any (father) octree, the corresponding vertex in the son specified by <code>son_octant</code> has an offset. If we project the son_octant's left/down/back vertex onto the father's face <code>face</code>, it is located at the in-face coordinate <code>s_hi</code> = h/2 <code>S_directlhi(face,son_octant)</code>. [See discussion of <code>s_steplo</code> for an explanation of the subscripts <code>_hi</code> and <code>_lo</code>.].  <a href="classoomph_1_1OcTree.html#a11aca558846c26e31f802396508bea51">More...</a><br /></td></tr>
<tr class="separator:a11aca558846c26e31f802396508bea51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8afa940d0ce2ceca2a064f3f1ec6b1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a9f8afa940d0ce2ceca2a064f3f1ec6b1">S_base_edge</a></td></tr>
<tr class="memdesc:a9f8afa940d0ce2ceca2a064f3f1ec6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">S_base_edge(i,edge): Initial value for coordinate s[i] on the specified edge (LF/RF/...).  <a href="classoomph_1_1OcTree.html#a9f8afa940d0ce2ceca2a064f3f1ec6b1">More...</a><br /></td></tr>
<tr class="separator:a9f8afa940d0ce2ceca2a064f3f1ec6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036d7e355507212bee6a53d42adbea26"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#a036d7e355507212bee6a53d42adbea26">S_step_edge</a></td></tr>
<tr class="memdesc:a036d7e355507212bee6a53d42adbea26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each edge of the <a class="el" href="classoomph_1_1RefineableQElement_3_013_01_4.html" title="Refineable version of QElement&lt;3,NNODE_1D&gt;.">RefineableQElement&lt;3&gt;</a> that is represented by the octree is parametrised by one (of the three) local coordinates that parametrise the entire 3D element. If we're located on edge <code>edge</code> [DB,UB,...], then an increase in s from -1 to +1 corresponds to a change of <code>s_step_edge(i,edge)</code> in the 3D coordinates <code>s</code>[i].  <a href="classoomph_1_1OcTree.html#a036d7e355507212bee6a53d42adbea26">More...</a><br /></td></tr>
<tr class="separator:a036d7e355507212bee6a53d42adbea26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf12711759332ae1d0b55da939b62aa0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1OcTree.html#abf12711759332ae1d0b55da939b62aa0">S_direct_edge</a></td></tr>
<tr class="memdesc:abf12711759332ae1d0b55da939b62aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative to the left/down/back vertex in any (father) octree, the corresponding vertex in the son specified by <code>son_octant</code> has an offset. If we project the son_octant's left/down/back vertex onto the father's edge <code>edge</code>, it is located at the in-face coordinate <code>s_lo</code> = h/2 <code>S_direct_edge(edge,son_octant)</code>.  <a href="classoomph_1_1OcTree.html#abf12711759332ae1d0b55da939b62aa0">More...</a><br /></td></tr>
<tr class="separator:abf12711759332ae1d0b55da939b62aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classoomph_1_1Tree"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classoomph_1_1Tree')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classoomph_1_1Tree.html">oomph::Tree</a></td></tr>
<tr class="memitem:a6b8ef236d41f52c92973682ca83679d5 inherit pub_types_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">typedef void(Tree::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a6b8ef236d41f52c92973682ca83679d5">VoidMemberFctPt</a>) ()</td></tr>
<tr class="memdesc:a6b8ef236d41f52c92973682ca83679d5 inherit pub_types_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to argument-free void <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> member function.  <a href="classoomph_1_1Tree.html#a6b8ef236d41f52c92973682ca83679d5">More...</a><br /></td></tr>
<tr class="separator:a6b8ef236d41f52c92973682ca83679d5 inherit pub_types_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498ffc10556f4335e831a06fc885a27a inherit pub_types_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">typedef void(Tree::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a498ffc10556f4335e831a06fc885a27a">VoidMeshPtArgumentMemberFctPt</a>) (<a class="el" href="classoomph_1_1Mesh.html">Mesh</a> *&amp;mesh_pt)</td></tr>
<tr class="memdesc:a498ffc10556f4335e831a06fc885a27a inherit pub_types_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to a void <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> member function that takes a pointer to a mesh as its argument.  <a href="classoomph_1_1Tree.html#a498ffc10556f4335e831a06fc885a27a">More...</a><br /></td></tr>
<tr class="separator:a498ffc10556f4335e831a06fc885a27a inherit pub_types_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classoomph_1_1Tree"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classoomph_1_1Tree')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classoomph_1_1Tree.html">oomph::Tree</a></td></tr>
<tr class="memitem:a61782afd668561ad7ab324f658ffeb6a inherit pro_attribs_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1TreeRoot.html">TreeRoot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a61782afd668561ad7ab324f658ffeb6a">Root_pt</a></td></tr>
<tr class="memdesc:a61782afd668561ad7ab324f658ffeb6a inherit pro_attribs_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the root of the tree.  <a href="classoomph_1_1Tree.html#a61782afd668561ad7ab324f658ffeb6a">More...</a><br /></td></tr>
<tr class="separator:a61782afd668561ad7ab324f658ffeb6a inherit pro_attribs_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001ce5515a3d76cdad248695e149504b inherit pro_attribs_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Tree.html">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a001ce5515a3d76cdad248695e149504b">Father_pt</a></td></tr>
<tr class="memdesc:a001ce5515a3d76cdad248695e149504b inherit pro_attribs_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the Father of the <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a>.  <a href="classoomph_1_1Tree.html#a001ce5515a3d76cdad248695e149504b">More...</a><br /></td></tr>
<tr class="separator:a001ce5515a3d76cdad248695e149504b inherit pro_attribs_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b9069f345b296654421604c5569af6 inherit pro_attribs_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Tree.html">Tree</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#ac6b9069f345b296654421604c5569af6">Son_pt</a></td></tr>
<tr class="memdesc:ac6b9069f345b296654421604c5569af6 inherit pro_attribs_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> of pointers to the sons of the <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a>.  <a href="classoomph_1_1Tree.html#ac6b9069f345b296654421604c5569af6">More...</a><br /></td></tr>
<tr class="separator:ac6b9069f345b296654421604c5569af6 inherit pro_attribs_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac30decb7a63027906880620f8b98ee inherit pro_attribs_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a9ac30decb7a63027906880620f8b98ee">Level</a></td></tr>
<tr class="memdesc:a9ac30decb7a63027906880620f8b98ee inherit pro_attribs_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level of the <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> (level 0 = root)  <a href="classoomph_1_1Tree.html#a9ac30decb7a63027906880620f8b98ee">More...</a><br /></td></tr>
<tr class="separator:a9ac30decb7a63027906880620f8b98ee inherit pro_attribs_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fe7895af25c9f60062c081fc51967c inherit pro_attribs_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a83fe7895af25c9f60062c081fc51967c">Son_type</a></td></tr>
<tr class="memdesc:a83fe7895af25c9f60062c081fc51967c inherit pro_attribs_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Son type (e.g. SW/SE/NW/NE in a quadtree)  <a href="classoomph_1_1Tree.html#a83fe7895af25c9f60062c081fc51967c">More...</a><br /></td></tr>
<tr class="separator:a83fe7895af25c9f60062c081fc51967c inherit pro_attribs_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ee20b575da510512d0e108cf7b06c6 inherit pro_attribs_classoomph_1_1Tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoomph_1_1Tree.html#a61ee20b575da510512d0e108cf7b06c6">Object_pt</a></td></tr>
<tr class="memdesc:a61ee20b575da510512d0e108cf7b06c6 inherit pro_attribs_classoomph_1_1Tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the object represented by the tree.  <a href="classoomph_1_1Tree.html#a61ee20b575da510512d0e108cf7b06c6">More...</a><br /></td></tr>
<tr class="separator:a61ee20b575da510512d0e108cf7b06c6 inherit pro_attribs_classoomph_1_1Tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> class: Recursively defined, generalised octree. </p>
<p>An <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> has:</p><ul>
<li>a pointer to the object (of type <a class="el" href="classoomph_1_1RefineableQElement_3_013_01_4.html" title="Refineable version of QElement&lt;3,NNODE_1D&gt;.">RefineableQElement&lt;3&gt;</a>) it represents</li>
<li><a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> of pointers to its eight (LDB,RDB,...,RUF) sons (which are octrees themselves). If the <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> of pointers to the sons has zero length, the <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> is a "leaf node" in the overall octree.</li>
<li>a pointer to its father. If this pointer is NULL, the <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> is the the root node of the overall octree. This data is stored in the <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a> base class.</li>
</ul>
<p>The tree can also be part of a forest. If that is the case, the root will have pointers to the roots of neighbouring octrees.</p>
<p>The objects contained in the octree are assumed to be (topologically) cubic elements whose geometry is parametrised by local coordinates <img class="formulaInl" alt="$ {\bf s} \in [-1,1]^3 $" src="form_341.png" width="61" height="15"/>.</p>
<p>The tree can be traversed while actions are being performed at all of its "nodes" or only at the leaf "nodes".</p>
<p>Finally, the leaf "nodes" can be split depending on criteria defined by the object.</p>
<p>Note that OcTrees are only generated by splitting existing OcTrees. Therefore, the constructors are protected. The only <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> that "Joe User" can create is the (derived) class <a class="el" href="classoomph_1_1OcTreeRoot.html" title="OcTreeRoot is a OcTree that forms the root of a (recursive) octree. The &quot;root node&quot; is special as it ...">OcTreeRoot</a>. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00113">113</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5c7bf77c8700898c428dacbdff6b334c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7bf77c8700898c428dacbdff6b334c">&#9670;&nbsp;</a></span>~OcTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual oomph::OcTree::~OcTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. Note: Deleting a octree also deletes the objects associated with all non-leaf nodes! </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00118">118</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

</div>
</div>
<a id="a2d729ac4b94328c7168bbcf423421edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d729ac4b94328c7168bbcf423421edd">&#9670;&nbsp;</a></span>OcTree() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">oomph::OcTree::OcTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoomph_1_1OcTree.html">OcTree</a> &amp;&#160;</td>
          <td class="paramname"><em>dummy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broken copy constructor. </p>

</div>
</div>
<a id="abb830075e2f08aa68bf65a07089039ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb830075e2f08aa68bf65a07089039ca">&#9670;&nbsp;</a></span>OcTree() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">oomph::OcTree::OcTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor (empty and broken) </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00382">382</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8h_source.html#l00129">construct_son()</a>.</p>

</div>
</div>
<a id="a2c0f7987566846a0451bdc1ed522a2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0f7987566846a0451bdc1ed522a2d4">&#9670;&nbsp;</a></span>OcTree() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">oomph::OcTree::OcTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *const &amp;&#160;</td>
          <td class="paramname"><em>object_pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for empty (root) tree: no father, no sons; just pass a pointer to its object (a <a class="el" href="classoomph_1_1RefineableQElement_3_013_01_4.html" title="Refineable version of QElement&lt;3,NNODE_1D&gt;.">RefineableQElement&lt;3&gt;</a>). This is protected because OcTrees can only be created internally, during the split operation. Only OcTreeRoots can be created externally. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00395">395</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

</div>
</div>
<a id="af79e3cbf9d0c65f9e4a01207d65d4967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79e3cbf9d0c65f9e4a01207d65d4967">&#9670;&nbsp;</a></span>OcTree() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">oomph::OcTree::OcTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *const &amp;&#160;</td>
          <td class="paramname"><em>object_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoomph_1_1Tree.html">Tree</a> *const &amp;&#160;</td>
          <td class="paramname"><em>father_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>son_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for tree that has a father: Pass it the pointer to its object, the pointer to its father and tell it what type of son (LDB,RDB,...) it is. Protected because OcTrees can only be created internally, during the split operation. Only OcTreeRoots can be created externally. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00404">404</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad3667015671b5dbc06fdc298c59e4064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3667015671b5dbc06fdc298c59e4064">&#9670;&nbsp;</a></span>construct_rotation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oomph::OcTree::construct_rotation_matrix </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This constructs the rotation matrix of the rotation around the axis <code>axis</code> with an angle of <code>angle*90</code>. </p>
<p>Build the rotation matrix for a rotation around the axis <code>axis</code> of an angle <code>angle*90</code>. </p>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l00609">609</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="Vector_8h_source.html#l00309">oomph::VectorHelpers::angle()</a>, <a class="el" href="octree_8h_source.html#l00520">Cosi</a>, <a class="el" href="octree_8h_source.html#l00074">oomph::OcTreeNames::F</a>, <a class="el" href="cfortran_8h_source.html#l00603">i</a>, <a class="el" href="binary__tree_8h_source.html#l00051">oomph::BinaryTreeNames::R</a>, <a class="el" href="octree_8h_source.html#l00070">oomph::OcTreeNames::R</a>, <a class="el" href="octree_8h_source.html#l00523">Sini</a>, and <a class="el" href="octree_8h_source.html#l00072">oomph::OcTreeNames::U</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l00750">rotate()</a>.</p>

</div>
</div>
<a id="a2f894bab3cbde60d810de0ee43a9f023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f894bab3cbde60d810de0ee43a9f023">&#9670;&nbsp;</a></span>construct_son()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1Tree.html">Tree</a>* oomph::OcTree::construct_son </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoomph_1_1RefineableElement.html">RefineableElement</a> *const &amp;&#160;</td>
          <td class="paramname"><em>object_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoomph_1_1Tree.html">Tree</a> *const &amp;&#160;</td>
          <td class="paramname"><em>father_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>son_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload the function construct_son to ensure that the son is a specific <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> and not a general <a class="el" href="classoomph_1_1Tree.html" title="A generalised tree base class that abstracts the common functionality between the quad- and octrees u...">Tree</a>. </p>

<p>Implements <a class="el" href="classoomph_1_1Tree.html#a5eb29718044b1bc56403ee9bd15a60b6">oomph::Tree</a>.</p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00129">129</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">References <a class="el" href="tree_8h_source.html#l00235">oomph::Tree::father_pt()</a>, <a class="el" href="tree_8h_source.html#l00088">oomph::Tree::object_pt()</a>, <a class="el" href="octree_8h_source.html#l00382">OcTree()</a>, and <a class="el" href="tree_8h_source.html#l00214">oomph::Tree::son_type()</a>.</p>

</div>
</div>
<a id="afd54b3cd1f4196d618e73d19bb4ba157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd54b3cd1f4196d618e73d19bb4ba157">&#9670;&nbsp;</a></span>doc_face_neighbours()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oomph::OcTree::doc_face_neighbours </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Tree.html">Tree</a> * &gt;&#160;</td>
          <td class="paramname"><em>forest_nodes_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>neighbours_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>neighbours_txt_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>max_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Doc/check all face neighbours of octree (nodes) contained in the <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> forest_node_pt. Output into neighbours_file which can be viewed from tecplot with OcTreeNeighbours.mcr Neighbour info and errors are displayed on neighbours_txt_file. Finally, compute the max. error between vertices when viewed from neighhbouring element. If the two filestreams are closed, output is suppressed. </p>
<p>Doc/check all face neighbours of octree (nodes) contained in the <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> forest_node_pt. Output into neighbours_file which can be viewed from tecplot with OcTreeNeighbours.mcr Neighbour info and errors are displayed on neighbours_txt_file. Finally, compute the max. error between vertices when viewed from neighbouring element. If the two filestreams are closed, output is suppressed. (Static function.) </p>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l04275">4275</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00540">Colour</a>, <a class="el" href="octree_8h_source.html#l00329">Direct_string</a>, <a class="el" href="octree_8h_source.html#l00074">oomph::OcTreeNames::F</a>, <a class="el" href="elements_8h_source.html#l01889">oomph::FiniteElement::get_x()</a>, <a class="el" href="octree_8cc_source.html#l03373">gteq_face_neighbour()</a>, <a class="el" href="cfortran_8h_source.html#l00603">i</a>, <a class="el" href="tree_8h_source.html#l00364">oomph::TreeRoot::is_neighbour_periodic()</a>, <a class="el" href="binary__tree_8h_source.html#l00050">oomph::BinaryTreeNames::L</a>, <a class="el" href="tree_8h_source.html#l00313">oomph::Tree::Max_neighbour_finding_tolerance</a>, <a class="el" href="refineable__elements_8h_source.html#l00389">oomph::RefineableElement::nodes_built()</a>, <a class="el" href="refineable__elements_8h_source.html#l00395">oomph::RefineableElement::number()</a>, <a class="el" href="tree_8h_source.html#l00088">oomph::Tree::object_pt()</a>, <a class="el" href="tree_8h_source.html#l00262">oomph::Tree::OMEGA</a>, <a class="el" href="oomph__utilities_8cc_source.html#l01265">oomph::pause()</a>, <a class="el" href="tree_8h_source.html#l00141">oomph::Tree::root_pt()</a>, <a class="el" href="cfortran_8h_source.html#l00568">s</a>, <a class="el" href="octree_8h_source.html#l00544">S_base</a>, <a class="el" href="octree_8h_source.html#l00565">S_stephi</a>, and <a class="el" href="octree_8h_source.html#l00558">S_steplo</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l05749">oomph::OcTreeForest::check_all_neighbours()</a>, <a class="el" href="octree_8cc_source.html#l04200">self_test()</a>, and <a class="el" href="octree_8cc_source.html#l05678">oomph::OcTreeForest::self_test()</a>.</p>

</div>
</div>
<a id="a728b0580f568f9d5fb814458b6c75fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728b0580f568f9d5fb814458b6c75fe4">&#9670;&nbsp;</a></span>doc_true_edge_neighbours()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oomph::OcTree::doc_true_edge_neighbours </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Tree.html">Tree</a> * &gt;&#160;</td>
          <td class="paramname"><em>forest_nodes_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>neighbours_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>no_true_edge_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>neighbours_txt_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>max_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Doc/check all true edge neighbours of octree (nodes) contained in the <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> forest_node_pt. Output into neighbours_file which can be viewed from tecplot with OcTreeNeighbours.mcr Neighbour info and errors are displayed on neighbours_txt_file. Finally, compute the max. error between vertices when viewed from neighhbouring element. If the two filestreams are closed, output is suppressed. </p>
<p>///////////////////////////////////////////////////////////////////</p>
<p>Doc/check all true edge neighbours of octree (nodes) contained in the <a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> forest_node_pt. Output into neighbours_file which can be viewed from tecplot with OcTreeNeighbours.mcr Neighbour info and errors are displayed on neighbours_txt_file. Finally, compute the max. error between vertices when viewed from neighbouring element. If the two filestreams are closed, output is suppressed. (Static function). </p>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l04552">4552</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00540">Colour</a>, <a class="el" href="octree_8h_source.html#l00329">Direct_string</a>, <a class="el" href="octree_8cc_source.html#l00268">faces_of_common_edge()</a>, <a class="el" href="elements_8h_source.html#l01889">oomph::FiniteElement::get_x()</a>, <a class="el" href="octree_8cc_source.html#l03618">gteq_true_edge_neighbour()</a>, <a class="el" href="cfortran_8h_source.html#l00603">i</a>, <a class="el" href="tree_8h_source.html#l00220">oomph::Tree::is_leaf()</a>, <a class="el" href="tree_8h_source.html#l00364">oomph::TreeRoot::is_neighbour_periodic()</a>, <a class="el" href="octree_8h_source.html#l00057">oomph::OcTreeNames::LB</a>, <a class="el" href="tree_8h_source.html#l00313">oomph::Tree::Max_neighbour_finding_tolerance</a>, <a class="el" href="refineable__elements_8h_source.html#l00389">oomph::RefineableElement::nodes_built()</a>, <a class="el" href="refineable__elements_8h_source.html#l00395">oomph::RefineableElement::number()</a>, <a class="el" href="tree_8h_source.html#l00088">oomph::Tree::object_pt()</a>, <a class="el" href="tree_8h_source.html#l00262">oomph::Tree::OMEGA</a>, <a class="el" href="oomph__utilities_8cc_source.html#l01265">oomph::pause()</a>, <a class="el" href="tree_8h_source.html#l00141">oomph::Tree::root_pt()</a>, <a class="el" href="cfortran_8h_source.html#l00568">s</a>, <a class="el" href="octree_8h_source.html#l00585">S_base_edge</a>, <a class="el" href="octree_8h_source.html#l00593">S_step_edge</a>, and <a class="el" href="octree_8h_source.html#l00068">oomph::OcTreeNames::UF</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l05749">oomph::OcTreeForest::check_all_neighbours()</a>, <a class="el" href="octree_8cc_source.html#l04200">self_test()</a>, and <a class="el" href="octree_8cc_source.html#l05678">oomph::OcTreeForest::self_test()</a>.</p>

</div>
</div>
<a id="ab780bf82a61230f23bc3d96774a63010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab780bf82a61230f23bc3d96774a63010">&#9670;&nbsp;</a></span>edge_neighbour_is_face_neighbour()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool oomph::OcTree::edge_neighbour_is_face_neighbour </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoomph_1_1OcTree.html">OcTree</a> *&#160;</td>
          <td class="paramname"><em>edge_neighb_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the edge neighbour (for edge "edge") specified via the pointer also a face neighbour for one of the two adjacent faces? </p>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l02769">2769</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00073">oomph::OcTreeNames::B</a>, <a class="el" href="octree_8h_source.html#l00071">oomph::OcTreeNames::D</a>, <a class="el" href="octree_8h_source.html#l00059">oomph::OcTreeNames::DB</a>, <a class="el" href="octree_8h_source.html#l00067">oomph::OcTreeNames::DF</a>, <a class="el" href="octree_8h_source.html#l00329">Direct_string</a>, <a class="el" href="octree_8h_source.html#l00074">oomph::OcTreeNames::F</a>, <a class="el" href="octree_8cc_source.html#l03373">gteq_face_neighbour()</a>, <a class="el" href="binary__tree_8h_source.html#l00050">oomph::BinaryTreeNames::L</a>, <a class="el" href="octree_8h_source.html#l00057">oomph::OcTreeNames::LB</a>, <a class="el" href="octree_8h_source.html#l00061">oomph::OcTreeNames::LD</a>, <a class="el" href="octree_8h_source.html#l00065">oomph::OcTreeNames::LF</a>, <a class="el" href="octree_8h_source.html#l00063">oomph::OcTreeNames::LU</a>, <a class="el" href="binary__tree_8h_source.html#l00051">oomph::BinaryTreeNames::R</a>, <a class="el" href="octree_8h_source.html#l00058">oomph::OcTreeNames::RB</a>, <a class="el" href="octree_8h_source.html#l00062">oomph::OcTreeNames::RD</a>, <a class="el" href="octree_8h_source.html#l00066">oomph::OcTreeNames::RF</a>, <a class="el" href="octree_8h_source.html#l00064">oomph::OcTreeNames::RU</a>, <a class="el" href="octree_8h_source.html#l00072">oomph::OcTreeNames::U</a>, <a class="el" href="octree_8h_source.html#l00060">oomph::OcTreeNames::UB</a>, and <a class="el" href="octree_8h_source.html#l00068">oomph::OcTreeNames::UF</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l03618">gteq_true_edge_neighbour()</a>.</p>

</div>
</div>
<a id="a29d019becbc07f9ea2811a0ff0881d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d019becbc07f9ea2811a0ff0881d9a">&#9670;&nbsp;</a></span>faces_of_common_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; oomph::OcTree::faces_of_common_edge </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that, given an edge, returns the two faces on which it. </p>
<p>Given an edge, this function returns the faces on which it lies. </p>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l00268">268</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00073">oomph::OcTreeNames::B</a>, <a class="el" href="octree_8h_source.html#l00071">oomph::OcTreeNames::D</a>, <a class="el" href="octree_8h_source.html#l00059">oomph::OcTreeNames::DB</a>, <a class="el" href="octree_8h_source.html#l00067">oomph::OcTreeNames::DF</a>, <a class="el" href="octree_8h_source.html#l00329">Direct_string</a>, <a class="el" href="octree_8h_source.html#l00074">oomph::OcTreeNames::F</a>, <a class="el" href="binary__tree_8h_source.html#l00050">oomph::BinaryTreeNames::L</a>, <a class="el" href="octree_8h_source.html#l00057">oomph::OcTreeNames::LB</a>, <a class="el" href="octree_8h_source.html#l00061">oomph::OcTreeNames::LD</a>, <a class="el" href="octree_8h_source.html#l00065">oomph::OcTreeNames::LF</a>, <a class="el" href="octree_8h_source.html#l00063">oomph::OcTreeNames::LU</a>, <a class="el" href="binary__tree_8h_source.html#l00051">oomph::BinaryTreeNames::R</a>, <a class="el" href="octree_8h_source.html#l00058">oomph::OcTreeNames::RB</a>, <a class="el" href="octree_8h_source.html#l00062">oomph::OcTreeNames::RD</a>, <a class="el" href="octree_8h_source.html#l00066">oomph::OcTreeNames::RF</a>, <a class="el" href="octree_8h_source.html#l00064">oomph::OcTreeNames::RU</a>, <a class="el" href="octree_8h_source.html#l00072">oomph::OcTreeNames::U</a>, <a class="el" href="octree_8h_source.html#l00060">oomph::OcTreeNames::UB</a>, and <a class="el" href="octree_8h_source.html#l00068">oomph::OcTreeNames::UF</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l04552">doc_true_edge_neighbours()</a>, <a class="el" href="hp__refineable__elements_8cc_source.html#l04956">oomph::PRefineableQElement&lt; 3, INITIAL_NNODE_1D &gt;::node_created_by_neighbour()</a>, <a class="el" href="refineable__brick__element_8cc_source.html#l00992">oomph::RefineableQElement&lt; 3 &gt;::node_created_by_neighbour()</a>, and <a class="el" href="hp__refineable__elements_8cc_source.html#l05271">oomph::PRefineableQElement&lt; 3, INITIAL_NNODE_1D &gt;::node_created_by_son_of_neighbour()</a>.</p>

</div>
</div>
<a id="ab03edae455d5bd788acf426ca3f87b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03edae455d5bd788acf426ca3f87b9d">&#9670;&nbsp;</a></span>get_the_other_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int oomph::OcTree::get_the_other_face </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>nnode1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If an edge is bordered by the nodes whose local numbers are n1 and n2 in an element with nnode1d nodes along each coordinate direction, then this edge is shared by two faces. This function takes one of these faces as the argument <code>face</code> and returns the other one. (<code>face</code> is a direction in the set U,D,F,B,L,R). </p>
<p>This function takes as argument two node numbers of two nodes delimiting an edge, and one face of this edge and returns the other face that is sharing this edge. The node numbers given to this function MUST be vertices nodes to work. it also need the value of nnode1d to work. (<code>face</code> is a direction in the set U,D,F,B,L,R). </p>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l00565">565</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00353">Direction_to_vector</a>, <a class="el" href="cfortran_8h_source.html#l00603">i</a>, <a class="el" href="octree_8h_source.html#l00348">Vector_to_direction</a>, and <a class="el" href="octree_8cc_source.html#l00232">vertex_node_to_vector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l05255">oomph::OcTreeForest::construct_up_right_equivalents()</a>.</p>

</div>
</div>
<a id="abaa4c8bbf2fdbad7465af2c4964a915f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa4c8bbf2fdbad7465af2c4964a915f">&#9670;&nbsp;</a></span>gteq_edge_neighbour()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1OcTree.html">OcTree</a> * oomph::OcTree::gteq_edge_neighbour </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>i_root_edge_neighbour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>nroot_edge_neighbour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>s_diff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>diff_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoomph_1_1OcTreeRoot.html">OcTreeRoot</a> *&#160;</td>
          <td class="paramname"><em>orig_root_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find &lsquo;greater-or-equal-sized edge neighbour&rsquo; in given direction (LB,RB,DB,UB [the back edges], LD,RD,LU,RU [the side edges], LF,RF,DF,UF [the front edges]). </p>
<p>This is an auxiliary routine which allows neighbour finding in adjacent octrees. Needs to keep track of the maximum level to which search is performed because in the presence of <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> forests, the search isn't purely recursive.</p>
<p>Parameters:</p><ul>
<li>direction: (LB/RB/...) Direction in which neighbour has to be found.</li>
<li>In a forest, an <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> can have multiple edge neighbours (across an edge where multiple trees meet). <code>i_root_edge_neighbour</code> specifies which of these is used. Use this as "reverse communication": First call with <code>i_root_edge_neighbour=0</code> and <code>n_root_edge_neighour</code> initialised to anything you want (zero, ideally). On return from the fct, <code>n_root_edge_neighour</code> contains the total number of true edge neighbours, so additional calls to the fct with <code>i_root_edge_neighbour&gt;0</code> can be made until they've all been visited.</li>
<li>s_diff: Offset of the edge's "low" vertex from corresponding vertex in neighbour. Note that this is input/output as it needs to be incremented/ decremented during the recursive calls to this function.</li>
<li>diff_level &lt;= 0 indicates the difference in octree levels between the current element and its neighbour.</li>
<li>max_level is the maximum level to which the neighbour search is allowed to proceed. This is necessary because in a forest, the neighbour search isn't based on pure recursion.</li>
<li>orig_root_pt identifies the root node of the element whose neighbour we're really trying to find by all these recursive calls.</li>
</ul>
<p><b>Note:</b> some of the auxiliary information may be incorrect if the neighbour is not a true edge neighbour. We don't care because we're not dealing with those!</p>
<p>This is an auxiliary routine which allows neighbour finding in adjacent octrees. Needs to keep track of previous son types and the maximum level to which search is performed.</p>
<p>Parameters:</p>
<ul>
<li>direction: (LB,RB/...) Direction in which neighbour has to be found.</li>
<li>In a forest, an <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> can have multiple edge neighbours (across an edge where multiple trees meet). <code>i_root_edge_neighbour</code> specifies which of these is used. Use this as "reverse communication": First call with <code>i_root_edge_neighbour=0</code> and <code>n_root_edge_neighour</code> initialised to anything you want (zero, ideally). On return from the fct, <code>n_root_edge_neighour</code> contains the total number of true edge neighbours, so additional calls to the fct with <code>i_root_edge_neighbour&gt;0</code> can be made until they've all been visited.</li>
<li>s_diff: Offset of left/down/back vertex from corresponding vertex in neighbour. Note that this is input/output as it needs to be incremented/ decremented during the recursive calls to this function.</li>
<li>diff_level &lt;= 0 indicates the difference in octree levels between the current element and its neighbour.</li>
<li>max_level is the maximum level to which the neighbour search is allowed to proceed. This is necessary because in a forest, the neighbour search isn't based on pure recursion.</li>
<li>orig_root_pt identifies the root node of the element whose neighbour we're really trying to find by all these recursive calls. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l04015">4015</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00537">Common_face</a>, <a class="el" href="octree_8h_source.html#l00059">oomph::OcTreeNames::DB</a>, <a class="el" href="octree_8h_source.html#l00067">oomph::OcTreeNames::DF</a>, <a class="el" href="octree_8h_source.html#l00329">Direct_string</a>, <a class="el" href="tree_8h_source.html#l00296">oomph::Tree::Father_pt</a>, <a class="el" href="octree_8cc_source.html#l03373">gteq_face_neighbour()</a>, <a class="el" href="octree_8h_source.html#l00529">Is_adjacent</a>, <a class="el" href="octree_8h_source.html#l00057">oomph::OcTreeNames::LB</a>, <a class="el" href="octree_8h_source.html#l00061">oomph::OcTreeNames::LD</a>, <a class="el" href="tree_8h_source.html#l00302">oomph::Tree::Level</a>, <a class="el" href="octree_8h_source.html#l00065">oomph::OcTreeNames::LF</a>, <a class="el" href="octree_8h_source.html#l00063">oomph::OcTreeNames::LU</a>, <a class="el" href="tree_8h_source.html#l00262">oomph::Tree::OMEGA</a>, <a class="el" href="octree_8h_source.html#l00058">oomph::OcTreeNames::RB</a>, <a class="el" href="octree_8h_source.html#l00062">oomph::OcTreeNames::RD</a>, <a class="el" href="octree_8h_source.html#l00533">Reflect</a>, <a class="el" href="octree_8h_source.html#l00066">oomph::OcTreeNames::RF</a>, <a class="el" href="tree_8h_source.html#l00292">oomph::Tree::Root_pt</a>, <a class="el" href="octree_8cc_source.html#l00750">rotate()</a>, <a class="el" href="octree_8h_source.html#l00064">oomph::OcTreeNames::RU</a>, <a class="el" href="octree_8h_source.html#l00600">S_direct_edge</a>, <a class="el" href="tree_8h_source.html#l00299">oomph::Tree::Son_pt</a>, <a class="el" href="tree_8h_source.html#l00305">oomph::Tree::Son_type</a>, <a class="el" href="octree_8h_source.html#l00060">oomph::OcTreeNames::UB</a>, and <a class="el" href="octree_8h_source.html#l00068">oomph::OcTreeNames::UF</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l03618">gteq_true_edge_neighbour()</a>.</p>

</div>
</div>
<a id="afd5ef9914c4b65f604bbf587343aca72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5ef9914c4b65f604bbf587343aca72">&#9670;&nbsp;</a></span>gteq_face_neighbour() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1OcTree.html">OcTree</a> * oomph::OcTree::gteq_face_neighbour </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>s_difflo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>s_diffhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>diff_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>in_neighbouring_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoomph_1_1OcTreeRoot.html">OcTreeRoot</a> *&#160;</td>
          <td class="paramname"><em>orig_root_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find &lsquo;greater-or-equal-sized face neighbour&rsquo; in given direction (L/R/U/D/B/F). </p>
<p>This is an auxiliary routine which allows neighbour finding in adjacent octrees. Needs to keep track of the maximum level to which search is performed because in the presence of <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> forests, the search isn't purely recursive.</p>
<p>Parameters:</p><ul>
<li>direction: (L/R/U/D/B/F) Direction in which neighbour has to be found.</li>
<li>s_difflo/s_diffhi: Offset of left/down/back vertex from corresponding vertex in neighbour. Note that this is input/output as it needs to be incremented/ decremented during the recursive calls to this function.</li>
<li>diff_level &lt;= 0 indicates the difference in octree levels between the current element and its neighbour.</li>
<li>max_level is the maximum level to which the neighbour search is allowed to proceed. This is necessary because in a forest, the neighbour search isn't based on pure recursion.</li>
<li>orig_root_pt identifies the root node of the element whose neighbour we're really trying to find by all these recursive calls.</li>
</ul>
<p>This is an auxiliary routine which allows neighbour finding in adjacent octrees. Needs to keep track of previous son types and the maximum level to which search is performed.</p>
<p>Parameters:</p>
<ul>
<li>direction: (L/R/U/D/B/F) Direction in which neighbour has to be found.</li>
<li>s_difflo/s_diffhi: Offset of left/down/back vertex from corresponding vertex in neighbour. Note that this is input/output as it needs to be incremented/decremented during the recursive calls to this function.</li>
<li>face: We're looking for the neighbour across our face 'direction' (L/R/U/D/B/F). When viewed from the neighbour, this face is &lsquo;face&rsquo; (L/R/U/D/B/F). [If there's no relative rotation between neighbours then this is a mere reflection, e.g. direction=F --&gt; face=B etc.]</li>
<li>diff_level &lt;= 0 indicates the difference in octree levels between the current element and its neighbour.</li>
<li>max_level is the maximum level to which the neighbour search is allowed to proceed. This is necessary because in a forest, the neighbour search isn't based on pure recursion.</li>
<li>orig_root_pt identifies the root node of the element whose neighbour we're really trying to find by all these recursive calls. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l03839">3839</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00073">oomph::OcTreeNames::B</a>, <a class="el" href="octree_8h_source.html#l00071">oomph::OcTreeNames::D</a>, <a class="el" href="octree_8h_source.html#l00329">Direct_string</a>, <a class="el" href="octree_8h_source.html#l00074">oomph::OcTreeNames::F</a>, <a class="el" href="tree_8h_source.html#l00296">oomph::Tree::Father_pt</a>, <a class="el" href="octree_8cc_source.html#l03373">gteq_face_neighbour()</a>, <a class="el" href="octree_8h_source.html#l00529">Is_adjacent</a>, <a class="el" href="binary__tree_8h_source.html#l00050">oomph::BinaryTreeNames::L</a>, <a class="el" href="tree_8h_source.html#l00302">oomph::Tree::Level</a>, <a class="el" href="tree_8h_source.html#l00357">oomph::TreeRoot::neighbour_pt()</a>, <a class="el" href="binary__tree_8h_source.html#l00051">oomph::BinaryTreeNames::R</a>, <a class="el" href="octree_8h_source.html#l00533">Reflect</a>, <a class="el" href="tree_8h_source.html#l00292">oomph::Tree::Root_pt</a>, <a class="el" href="octree_8cc_source.html#l00750">rotate()</a>, <a class="el" href="octree_8h_source.html#l00581">S_directhi</a>, <a class="el" href="octree_8h_source.html#l00573">S_directlo</a>, <a class="el" href="tree_8h_source.html#l00299">oomph::Tree::Son_pt</a>, <a class="el" href="tree_8h_source.html#l00305">oomph::Tree::Son_type</a>, and <a class="el" href="octree_8h_source.html#l00072">oomph::OcTreeNames::U</a>.</p>

</div>
</div>
<a id="a690c4fbbca73bd48c0bc3b2913a9b39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690c4fbbca73bd48c0bc3b2913a9b39c">&#9670;&nbsp;</a></span>gteq_face_neighbour() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1OcTree.html">OcTree</a> * oomph::OcTree::gteq_face_neighbour </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>translate_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>s_sw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>s_ne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>diff_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>in_neighbouring_tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find (pointer to) &lsquo;greater-or-equal-sized face neighbour&rsquo; in given direction (L/R/U/D/F/B). Another way of interpreting this is that we're looking for the neighbour across the present element's face 'direction'. The various arguments return additional information about the size and relative orientation of the neighbouring octree. To interpret these we use the following <b>General convention:</b> </p>
<ul>
<li>Each face of the element that is represented by the octree is parametrised by two (of the three) local coordinates that parametrise the entire 3D element. E.g. the B[ack] face is parametrised by (s[0], s[1]); the D[own] face is parametrised by (s[0],s[2]); etc. We always identify the in-face coordinate with the lower (3D) index with the subscript _lo and the one with the larger (3D) index with the subscript _hi.</li>
</ul>
<p>With this convention, the interpretation of the arguments is as follows:</p><ul>
<li>The vector <code>translate_s</code> turns the index of the local coordinate in the present octree into that of the neighbour. If there are no rotations then <code>translate_s</code>[i] = i.</li>
<li>In the present octree, the "south west" vertex of the face between the present octree and its neighbour is located at S_lo=-1, S_hi=-1. This point is located at the (3D) local coordinates (<code>s_sw</code>[0], <code>s_sw</code>[1], <code>s_sw</code>[2]) in the neighbouring octree.</li>
<li>ditto with s_ne: In the present octree, the "north east" vertex of the face between the present octree and its neighbour is located at S_lo=+1, S_hi=+1. This point is located at the (3D) local coordinates (<code>s_ne</code>[0], <code>s_ne</code>[1], <code>s_ne</code>[2]) in the neighbouring octree.</li>
<li>We're looking for a neighbour in the specified <code>direction</code>. When viewed from the neighbouring octree, the face that separates the present octree from its neighbour is the neighbour's face <code>face</code>. If there's no rotation between the two octrees, this is a simple reflection: For instance, if we're looking for a neighhbour in the <code>R</code> [ight] <code>direction</code>, <code>face</code> will be <code>L</code> [eft]</li>
<li><code>diff_level</code> &lt;= 0 indicates the difference in refinement levels between the two neighbours. If <code>diff_level==0</code>, the neighbour has the same size as the current octree. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l03373">3373</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00073">oomph::OcTreeNames::B</a>, <a class="el" href="octree_8h_source.html#l00071">oomph::OcTreeNames::D</a>, <a class="el" href="octree_8h_source.html#l00329">Direct_string</a>, <a class="el" href="octree_8h_source.html#l00353">Direction_to_vector</a>, <a class="el" href="octree_8h_source.html#l00074">oomph::OcTreeNames::F</a>, <a class="el" href="cfortran_8h_source.html#l00603">i</a>, <a class="el" href="binary__tree_8h_source.html#l00050">oomph::BinaryTreeNames::L</a>, <a class="el" href="tree_8h_source.html#l00302">oomph::Tree::Level</a>, <a class="el" href="binary__tree_8h_source.html#l00051">oomph::BinaryTreeNames::R</a>, <a class="el" href="octree_8h_source.html#l00332">Reflect_face</a>, <a class="el" href="octree_8h_source.html#l00790">oomph::OcTreeRoot::right_equivalent()</a>, <a class="el" href="tree_8h_source.html#l00292">oomph::Tree::Root_pt</a>, <a class="el" href="octree_8cc_source.html#l00750">rotate()</a>, <a class="el" href="octree_8h_source.html#l00544">S_base</a>, <a class="el" href="octree_8h_source.html#l00565">S_stephi</a>, <a class="el" href="octree_8h_source.html#l00558">S_steplo</a>, <a class="el" href="octree_8h_source.html#l00072">oomph::OcTreeNames::U</a>, and <a class="el" href="octree_8h_source.html#l00757">oomph::OcTreeRoot::up_equivalent()</a>.</p>

<p class="reference">Referenced by <a class="el" href="refineable__brick__element_8cc_source.html#l02509">oomph::RefineableQElement&lt; 3 &gt;::check_integrity()</a>, <a class="el" href="octree_8cc_source.html#l04275">doc_face_neighbours()</a>, <a class="el" href="octree_8cc_source.html#l02769">edge_neighbour_is_face_neighbour()</a>, <a class="el" href="octree_8cc_source.html#l04015">gteq_edge_neighbour()</a>, <a class="el" href="octree_8cc_source.html#l03839">gteq_face_neighbour()</a>, <a class="el" href="hp__refineable__elements_8cc_source.html#l04956">oomph::PRefineableQElement&lt; 3, INITIAL_NNODE_1D &gt;::node_created_by_neighbour()</a>, <a class="el" href="refineable__brick__element_8cc_source.html#l00992">oomph::RefineableQElement&lt; 3 &gt;::node_created_by_neighbour()</a>, <a class="el" href="hp__refineable__elements_8cc_source.html#l05271">oomph::PRefineableQElement&lt; 3, INITIAL_NNODE_1D &gt;::node_created_by_son_of_neighbour()</a>, <a class="el" href="refineable__brick__element_8cc_source.html#l02142">oomph::RefineableQElement&lt; 3 &gt;::oc_hang_helper()</a>, and <a class="el" href="hp__refineable__elements_8cc_source.html#l08351">oomph::PRefineableQElement&lt; 3, INITIAL_NNODE_1D &gt;::oc_hang_helper()</a>.</p>

</div>
</div>
<a id="ab5a26409cd49a430095915c76060f476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a26409cd49a430095915c76060f476">&#9670;&nbsp;</a></span>gteq_true_edge_neighbour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1OcTree.html">OcTree</a> * oomph::OcTree::gteq_true_edge_neighbour </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>i_root_edge_neighbour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>nroot_edge_neighbour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>translate_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>s_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>s_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>diff_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find (pointer to) &lsquo;greater-or-equal-sized true edge neighbour&rsquo; in the given direction (LB,RB,DB,UB [the back edges], LD,RD,LU,RU [the side edges], LF,RF,DF,UF [the front edges]). </p>
<p>Find (pointer to) &lsquo;greater-or-equal-sized true edge neighbour&rsquo; in the given direction (LB,RB,DB,UB [the back edges], LD,RD,LU,RU [the side edges], LF,RF,DF,UF [the front edges]). Another way of interpreting this is that we're looking for the neighbour across the present element's edge 'direction'. The various arguments return additional information about the size and relative orientation of the neighbouring octree. Each edge of the element that is represented by the octree is parametrised by one (of the three) local coordinates that parametrise the entire 3D element. E.g. the L[eft]B[ack] edge is parametrised by s[1]; the "low" vertex of this edge (located at the low value of this coordinate, i.e. at s[1]=-1) is L[eft]D[own]B[ack]. The "high" vertex of this edge (located at the high value of this coordinate, i.e. at s[1]=1) is L[eft]U[p]B[ack]; etc The interpretation of the arguments is as follows:</p>
<p>Another way of interpreting this is that we're looking for the neighbour across the present element's edge 'direction'. The various arguments return additional information about the size and relative orientation of the neighbouring octree. Each edge of the element that is represented by the octree is parametrised by one (of the three) local coordinates that parametrise the entire 3D element. E.g. the L[eft]B[ack] edge is parametrised by s[1]; the "low" vertex of this edge (located at the low value of this coordinate, i.e. at s[1]=-1) is L[eft]D[own]B[ack]. The "high" vertex of this edge (located at the high value of this coordinate, i.e. at s[1]=1) is L[eft]U[p]B[ack]; etc</p>
<p>The interpretation of the arguments is as follows:</p><ul>
<li>In a forest, an <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> can have multiple edge neighbours (across an edge where multiple trees meet). <code>i_root_edge_neighbour</code> specifies which of these is used. Use this as "reverse communication": First call with <code>i_root_edge_neighbour=0</code> and <code>n_root_edge_neighour</code> initialised to anything you want (zero, ideally). On return from the fct, <code>n_root_edge_neighour</code> contains the total number of true edge neighbours, so additional calls to the fct with <code>i_root_edge_neighbour&gt;0</code> can be made until they've all been visited.</li>
<li>The vector <code>translate_s</code> turns the index of the local coordinate in the present octree into that of the neighbour. If there are no rotations then <code>translate_s</code>[i] = i.</li>
<li>The "low" vertex of the edge in the present octree coincides with a certain vertex in the edge neighbour. In terms of the neighbour's local coordinates, this point is located at the (3D) local coordinates (<code>s_lo</code>[0], <code>s_lo</code>[1], <code>s_lo</code>[2])</li>
<li>ditto with s_hi: The "high" vertex of the edge in the present octree coincides with a certain vertex in the edge neighbour. In terms of the neighbour's local coordinates, this point is located at the (3D) local coordinates (<code>s_hi</code>[0], <code>s_hi</code>[1], <code>s_hi</code>[2])</li>
<li>We're looking for a neighbour in the specified <code>direction</code>. When viewed from the neighbouring octree, the edge that separates the present octree from its neighbour is the neighbour's edge <code>edge</code>. If there's no rotation between the two octrees, this is a simple reflection: For instance, if we're looking for a neighhbour in the <code>DB</code> <code>direction</code>, <code>edge</code> will be <code>UF</code>.</li>
<li><code>diff_level</code> &lt;= 0 indicates the difference in refinement levels between the two neighbours. If <code>diff_level==0</code>, the neighbour has the same size as the current octree.</li>
</ul>
<p><b>Important:</b> We're only looking for <b>true</b> edge neighbours i.e. edge neigbours that are not also face neighbours. This is an important difference to Samet's terminology. If the neighbour in a certain direction is not a true edge neighbour, or if there is no neighbour, then this function returns NULL.</p>
<ul>
<li>In a forest, an <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a> can have multiple edge neighbours (across an edge where multiple trees meet). <code>i_root_edge_neighbour</code> specifies which of these is used. Use this as "reverse communication": First call with <code>i_root_edge_neighbour=0</code> and <code>n_root_edge_neighour</code> initialised to anything you want (zero, ideally). On return from the fct, <code>n_root_edge_neighour</code> contains the total number of true edge neighbours, so additional calls to the fct with <code>i_root_edge_neighbour&gt;0</code> can be made until they've all been visited.</li>
<li>The vector <code>translate_s</code> turns the index of the local coordinate in the present octree into that of the neighbour. If there are no rotations then <code>translate_s</code>[i] = i.</li>
<li>The "low" vertex of the edge in the present octree coincides with a certain vertex in the edge neighbour. In terms of the neighbour's local coordinates, this point is located at the (3D) local coordinates (<code>s_lo</code>[0], <code>s_lo</code>[1], <code>s_lo</code>[2])</li>
<li>ditto with s_hi: The "high" vertex of the edge in the present octree coincides with a certain vertex in the edge neighbour. In terms of the neighbour's local coordinates, this point is located at the (3D) local coordinates (<code>s_hi</code>[0], <code>s_hi</code>[1], <code>s_hi</code>[2])</li>
<li>We're looking for a neighbour in the specified <code>direction</code>. When viewed from the neighbouring octree, the edge that separates the present octree from its neighbour is the neighbour's edge <code>edge</code>. If there's no rotation between the two octrees, this is a simple reflection: For instance, if we're looking for a neighhbour in the <code>DB</code> <code>direction</code>, <code>edge</code> will be <code>UF</code>.</li>
<li><code>diff_level</code> &lt;= 0 indicates the difference in refinement levels between the two neighbours. If <code>diff_level==0</code>, the neighbour has the same size as the current octree.</li>
</ul>
<p><b>Important:</b> We're only looking for <b>true</b> edge neighbours i.e. edge neigbours that are not also face neighbours. This is an important difference to Samet's terminology. If the neighbour in a certain direction is not a true edge neighbour, or if there is no neighbour, then this function returns NULL. </p>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l03618">3618</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00059">oomph::OcTreeNames::DB</a>, <a class="el" href="octree_8h_source.html#l00067">oomph::OcTreeNames::DF</a>, <a class="el" href="octree_8h_source.html#l00329">Direct_string</a>, <a class="el" href="octree_8h_source.html#l00353">Direction_to_vector</a>, <a class="el" href="octree_8cc_source.html#l02769">edge_neighbour_is_face_neighbour()</a>, <a class="el" href="octree_8h_source.html#l00074">oomph::OcTreeNames::F</a>, <a class="el" href="octree_8cc_source.html#l04015">gteq_edge_neighbour()</a>, <a class="el" href="cfortran_8h_source.html#l00603">i</a>, <a class="el" href="octree_8h_source.html#l00057">oomph::OcTreeNames::LB</a>, <a class="el" href="octree_8h_source.html#l00061">oomph::OcTreeNames::LD</a>, <a class="el" href="tree_8h_source.html#l00302">oomph::Tree::Level</a>, <a class="el" href="octree_8h_source.html#l00065">oomph::OcTreeNames::LF</a>, <a class="el" href="octree_8h_source.html#l00063">oomph::OcTreeNames::LU</a>, <a class="el" href="binary__tree_8h_source.html#l00051">oomph::BinaryTreeNames::R</a>, <a class="el" href="octree_8h_source.html#l00058">oomph::OcTreeNames::RB</a>, <a class="el" href="octree_8h_source.html#l00062">oomph::OcTreeNames::RD</a>, <a class="el" href="octree_8h_source.html#l00335">Reflect_edge</a>, <a class="el" href="octree_8h_source.html#l00066">oomph::OcTreeNames::RF</a>, <a class="el" href="octree_8h_source.html#l00790">oomph::OcTreeRoot::right_equivalent()</a>, <a class="el" href="tree_8h_source.html#l00292">oomph::Tree::Root_pt</a>, <a class="el" href="octree_8cc_source.html#l00750">rotate()</a>, <a class="el" href="octree_8h_source.html#l00064">oomph::OcTreeNames::RU</a>, <a class="el" href="octree_8h_source.html#l00585">S_base_edge</a>, <a class="el" href="octree_8h_source.html#l00593">S_step_edge</a>, <a class="el" href="octree_8h_source.html#l00072">oomph::OcTreeNames::U</a>, <a class="el" href="octree_8h_source.html#l00060">oomph::OcTreeNames::UB</a>, <a class="el" href="octree_8h_source.html#l00068">oomph::OcTreeNames::UF</a>, and <a class="el" href="octree_8h_source.html#l00757">oomph::OcTreeRoot::up_equivalent()</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l04552">doc_true_edge_neighbours()</a>, <a class="el" href="hp__refineable__elements_8cc_source.html#l04956">oomph::PRefineableQElement&lt; 3, INITIAL_NNODE_1D &gt;::node_created_by_neighbour()</a>, <a class="el" href="refineable__brick__element_8cc_source.html#l00992">oomph::RefineableQElement&lt; 3 &gt;::node_created_by_neighbour()</a>, <a class="el" href="hp__refineable__elements_8cc_source.html#l05271">oomph::PRefineableQElement&lt; 3, INITIAL_NNODE_1D &gt;::node_created_by_son_of_neighbour()</a>, and <a class="el" href="hp__refineable__elements_8cc_source.html#l08351">oomph::PRefineableQElement&lt; 3, INITIAL_NNODE_1D &gt;::oc_hang_helper()</a>.</p>

</div>
</div>
<a id="ad67128675db4b8d5d3e5815134d78fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67128675db4b8d5d3e5815134d78fd2">&#9670;&nbsp;</a></span>mult_mat_mat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oomph::OcTree::mult_mat_mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function: Performs the operation : mat3=mat1*mat2. </p>
<p>Helper: Performs the operation Mat3=Mat1*Mat2. </p>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l00664">664</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="cfortran_8h_source.html#l00603">i</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l00750">rotate()</a>.</p>

</div>
</div>
<a id="a4cb0cccaedfcb4301edcc8dc7cead639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb0cccaedfcb4301edcc8dc7cead639">&#9670;&nbsp;</a></span>mult_mat_vect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oomph::OcTree::mult_mat_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vect2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function: Performs the operation : vect2 = mat*vect1. </p>
<p>Helper: Performs the operation Vect2=Mat*Vect1. </p>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l00687">687</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="cfortran_8h_source.html#l00603">i</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l00750">rotate()</a>.</p>

</div>
</div>
<a id="a43cbe5258a41168fe2d891e52ae64e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cbe5258a41168fe2d891e52ae64e6b">&#9670;&nbsp;</a></span>node_number_to_vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int oomph::OcTree::node_number_to_vertex </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>nnode1d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the vertex [LDB,RDB,...] of local (vertex) node n in an element with nnode1d nodes in each coordinate direction. </p>
<p>Return the vertex of local (vertex) node n in an element with nnode1d nodes in each coordinate direction. </p>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l00491">491</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00049">oomph::OcTreeNames::LDB</a>, <a class="el" href="octree_8h_source.html#l00053">oomph::OcTreeNames::LDF</a>, <a class="el" href="octree_8h_source.html#l00051">oomph::OcTreeNames::LUB</a>, <a class="el" href="octree_8h_source.html#l00055">oomph::OcTreeNames::LUF</a>, <a class="el" href="octree_8h_source.html#l00050">oomph::OcTreeNames::RDB</a>, <a class="el" href="octree_8h_source.html#l00054">oomph::OcTreeNames::RDF</a>, <a class="el" href="octree_8h_source.html#l00052">oomph::OcTreeNames::RUB</a>, and <a class="el" href="octree_8h_source.html#l00056">oomph::OcTreeNames::RUF</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l05255">oomph::OcTreeForest::construct_up_right_equivalents()</a>.</p>

</div>
</div>
<a id="a14dba08782264f0d6008a8c1578b41e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14dba08782264f0d6008a8c1578b41e1">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oomph::OcTree::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoomph_1_1OcTree.html">OcTree</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broken assignment operator. </p>

</div>
</div>
<a id="ab65a00f8f47eb8b6da56ffa9d6ba8f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65a00f8f47eb8b6da56ffa9d6ba8f36">&#9670;&nbsp;</a></span>rotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int oomph::OcTree::rotate </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>new_up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>new_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If U[p] becomes new_up and R[ight] becomes new_right then the direction <code>dir</code> becomes <code>rotate(new_up, new_right, dir)</code> </p>
<p>A rotation is defined by the newUp and newRight directions; so if Up becomes newUp and Right becomes newRight then dir becomes rotate(newUp,newRight,dir);. </p>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l00709">709</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00073">oomph::OcTreeNames::B</a>, <a class="el" href="octree_8h_source.html#l00071">oomph::OcTreeNames::D</a>, <a class="el" href="octree_8h_source.html#l00329">Direct_string</a>, <a class="el" href="octree_8h_source.html#l00353">Direction_to_vector</a>, <a class="el" href="octree_8h_source.html#l00074">oomph::OcTreeNames::F</a>, <a class="el" href="binary__tree_8h_source.html#l00050">oomph::BinaryTreeNames::L</a>, <a class="el" href="binary__tree_8h_source.html#l00051">oomph::BinaryTreeNames::R</a>, <a class="el" href="octree_8cc_source.html#l00750">rotate()</a>, <a class="el" href="octree_8h_source.html#l00072">oomph::OcTreeNames::U</a>, and <a class="el" href="octree_8h_source.html#l00348">Vector_to_direction</a>.</p>

</div>
</div>
<a id="a25e5185f0395a19883e216fd80103cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e5185f0395a19883e216fd80103cf7">&#9670;&nbsp;</a></span>rotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; oomph::OcTree::rotate </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>new_up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>new_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If U[p] becomes new_up and R[ight] becomes new_right then the direction vector <code>dir</code> becomes rotate(new_up, new_right, dir) </p>
<p>This function rotates a vector according to a rotation of the axes that changes up to new_up and right to new_right. </p>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l00750">750</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00073">oomph::OcTreeNames::B</a>, <a class="el" href="octree_8cc_source.html#l00609">construct_rotation_matrix()</a>, <a class="el" href="octree_8h_source.html#l00071">oomph::OcTreeNames::D</a>, <a class="el" href="octree_8h_source.html#l00329">Direct_string</a>, <a class="el" href="octree_8h_source.html#l00074">oomph::OcTreeNames::F</a>, <a class="el" href="cfortran_8h_source.html#l00603">i</a>, <a class="el" href="binary__tree_8h_source.html#l00050">oomph::BinaryTreeNames::L</a>, <a class="el" href="octree_8cc_source.html#l00664">mult_mat_mat()</a>, <a class="el" href="octree_8cc_source.html#l00687">mult_mat_vect()</a>, <a class="el" href="binary__tree_8h_source.html#l00051">oomph::BinaryTreeNames::R</a>, and <a class="el" href="octree_8h_source.html#l00072">oomph::OcTreeNames::U</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l04015">gteq_edge_neighbour()</a>, <a class="el" href="octree_8cc_source.html#l03373">gteq_face_neighbour()</a>, <a class="el" href="octree_8cc_source.html#l03618">gteq_true_edge_neighbour()</a>, <a class="el" href="octree_8cc_source.html#l00709">rotate()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="a68218b6e02594bef23cb141af8a19ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68218b6e02594bef23cb141af8a19ffb">&#9670;&nbsp;</a></span>self_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned oomph::OcTree::self_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Self-test: Check all neighbours. Return success (0) if the max. distance between corresponding points in the neighbours is less than the tolerance specified in the static value <a class="el" href="classoomph_1_1Tree.html#aef9abebc166fa3bf81ecb59ec0d5d6b2" title="Max. allowed discrepancy in neighbour finding routine (distance between points when identified from t...">Tree::Max_neighbour_finding_tolerance</a>. </p>
<p>Self-test: Check neighbour finding routine. For each element in the tree and for each vertex, determine the distance between the vertex and its position in the neigbour. . If the difference is less than <a class="el" href="classoomph_1_1Tree.html#aef9abebc166fa3bf81ecb59ec0d5d6b2" title="Max. allowed discrepancy in neighbour finding routine (distance between points when identified from t...">Tree::Max_neighbour_finding_tolerance</a>. return success (0), otherwise failure (1) </p>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l04200">4200</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="octree_8cc_source.html#l04275">doc_face_neighbours()</a>, <a class="el" href="octree_8cc_source.html#l04552">doc_true_edge_neighbours()</a>, <a class="el" href="cfortran_8h_source.html#l00603">i</a>, <a class="el" href="tree_8h_source.html#l00313">oomph::Tree::Max_neighbour_finding_tolerance</a>, <a class="el" href="oomph__definitions_8cc_source.html#l00319">oomph::oomph_info</a>, and <a class="el" href="tree_8cc_source.html#l00277">oomph::Tree::stick_all_tree_nodes_into_vector()</a>.</p>

</div>
</div>
<a id="a5d7b0830cd9c913786e23259c69c71a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7b0830cd9c913786e23259c69c71a0">&#9670;&nbsp;</a></span>setup_static_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oomph::OcTree::setup_static_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setup the static data, rotation and reflection schemes, etc. </p>
<p>Setup static data for <a class="el" href="classoomph_1_1OcTree.html" title="OcTree class: Recursively defined, generalised octree.">OcTree</a>. </p>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l01040">1040</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00073">oomph::OcTreeNames::B</a>, <a class="el" href="octree_8h_source.html#l00540">Colour</a>, <a class="el" href="octree_8h_source.html#l00537">Common_face</a>, <a class="el" href="octree_8h_source.html#l00520">Cosi</a>, <a class="el" href="octree_8h_source.html#l00071">oomph::OcTreeNames::D</a>, <a class="el" href="octree_8h_source.html#l00059">oomph::OcTreeNames::DB</a>, <a class="el" href="octree_8h_source.html#l00067">oomph::OcTreeNames::DF</a>, <a class="el" href="octree_8h_source.html#l00329">Direct_string</a>, <a class="el" href="octree_8h_source.html#l00353">Direction_to_vector</a>, <a class="el" href="octree_8h_source.html#l00074">oomph::OcTreeNames::F</a>, <a class="el" href="cfortran_8h_source.html#l00603">i</a>, <a class="el" href="octree_8h_source.html#l00529">Is_adjacent</a>, <a class="el" href="binary__tree_8h_source.html#l00050">oomph::BinaryTreeNames::L</a>, <a class="el" href="octree_8h_source.html#l00057">oomph::OcTreeNames::LB</a>, <a class="el" href="octree_8h_source.html#l00061">oomph::OcTreeNames::LD</a>, <a class="el" href="octree_8h_source.html#l00049">oomph::OcTreeNames::LDB</a>, <a class="el" href="octree_8h_source.html#l00053">oomph::OcTreeNames::LDF</a>, <a class="el" href="octree_8h_source.html#l00065">oomph::OcTreeNames::LF</a>, <a class="el" href="octree_8h_source.html#l00063">oomph::OcTreeNames::LU</a>, <a class="el" href="octree_8h_source.html#l00051">oomph::OcTreeNames::LUB</a>, <a class="el" href="octree_8h_source.html#l00055">oomph::OcTreeNames::LUF</a>, <a class="el" href="cfortran_8h.html#ac5977f3790a2b5e5a4e7e5ea21259aa1">num_elem()</a>, <a class="el" href="tree_8h_source.html#l00262">oomph::Tree::OMEGA</a>, <a class="el" href="oomph__definitions_8cc_source.html#l00319">oomph::oomph_info</a>, <a class="el" href="binary__tree_8h_source.html#l00051">oomph::BinaryTreeNames::R</a>, <a class="el" href="octree_8h_source.html#l00058">oomph::OcTreeNames::RB</a>, <a class="el" href="octree_8h_source.html#l00062">oomph::OcTreeNames::RD</a>, <a class="el" href="octree_8h_source.html#l00050">oomph::OcTreeNames::RDB</a>, <a class="el" href="octree_8h_source.html#l00054">oomph::OcTreeNames::RDF</a>, <a class="el" href="octree_8h_source.html#l00533">Reflect</a>, <a class="el" href="octree_8h_source.html#l00335">Reflect_edge</a>, <a class="el" href="octree_8h_source.html#l00332">Reflect_face</a>, <a class="el" href="octree_8h_source.html#l00338">Reflect_vertex</a>, <a class="el" href="matrices_8h_source.html#l00498">oomph::DenseMatrix&lt; T &gt;::resize()</a>, <a class="el" href="octree_8h_source.html#l00066">oomph::OcTreeNames::RF</a>, <a class="el" href="octree_8cc_source.html#l00750">rotate()</a>, <a class="el" href="octree_8h_source.html#l00064">oomph::OcTreeNames::RU</a>, <a class="el" href="octree_8h_source.html#l00052">oomph::OcTreeNames::RUB</a>, <a class="el" href="octree_8h_source.html#l00056">oomph::OcTreeNames::RUF</a>, <a class="el" href="octree_8h_source.html#l00544">S_base</a>, <a class="el" href="octree_8h_source.html#l00585">S_base_edge</a>, <a class="el" href="octree_8h_source.html#l00600">S_direct_edge</a>, <a class="el" href="octree_8h_source.html#l00581">S_directhi</a>, <a class="el" href="octree_8h_source.html#l00573">S_directlo</a>, <a class="el" href="octree_8h_source.html#l00593">S_step_edge</a>, <a class="el" href="octree_8h_source.html#l00565">S_stephi</a>, <a class="el" href="octree_8h_source.html#l00558">S_steplo</a>, <a class="el" href="octree_8h_source.html#l00523">Sini</a>, <a class="el" href="octree_8h_source.html#l00412">Static_data_has_been_setup</a>, <a class="el" href="octree_8h_source.html#l00072">oomph::OcTreeNames::U</a>, <a class="el" href="octree_8h_source.html#l00060">oomph::OcTreeNames::UB</a>, <a class="el" href="octree_8h_source.html#l00068">oomph::OcTreeNames::UF</a>, <a class="el" href="octree_8h_source.html#l00377">Up_and_right_equivalent_for_pairs_of_vertices</a>, <a class="el" href="octree_8h_source.html#l00348">Vector_to_direction</a>, and <a class="el" href="octree_8h_source.html#l00343">Vertex_at_end_of_edge</a>.</p>

<p class="reference">Referenced by <a class="el" href="refineable__brick__mesh_8h_source.html#l00064">oomph::RefineableBrickMesh&lt; ELEMENT &gt;::RefineableBrickMesh()</a>, and <a class="el" href="eighth__sphere__mesh_8template_8h_source.html#l00095">oomph::RefineableEighthSphereMesh&lt; ELEMENT &gt;::RefineableEighthSphereMesh()</a>.</p>

</div>
</div>
<a id="a6f2dfb7f1527f77cf2900eecef279ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2dfb7f1527f77cf2900eecef279ee0">&#9670;&nbsp;</a></span>vertex_node_to_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; oomph::OcTree::vertex_node_to_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>nnode1d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the vector of the coordinate directions of vertex node number n in an element with nnode1d element per dimension. </p>
<p>This function is used to translate the position of a vertex node (given by his local number n into a vector giving the position of this node in the local coordinates system. It also needs the value of nnode1d to work. </p>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l00232">232</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l00565">get_the_other_face()</a>.</p>

</div>
</div>
<a id="af2a129b95ad303ed340bb8bd86e05384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a129b95ad303ed340bb8bd86e05384">&#9670;&nbsp;</a></span>vertex_to_node_number()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned oomph::OcTree::vertex_to_node_number </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>nnode1d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the local node number of given vertex [LDB,RDB,...] in an element with nnode1d nodes in each coordinate direction. </p>
<p>Return the local node number of given vertex in an element with nnode1d nodes in each coordinate direction. </p>

<p class="definition">Definition at line <a class="el" href="octree_8cc_source.html#l00414">414</a> of file <a class="el" href="octree_8cc_source.html">octree.cc</a>.</p>

<p class="reference">References <a class="el" href="octree_8h_source.html#l00329">Direct_string</a>, <a class="el" href="octree_8h_source.html#l00049">oomph::OcTreeNames::LDB</a>, <a class="el" href="octree_8h_source.html#l00053">oomph::OcTreeNames::LDF</a>, <a class="el" href="octree_8h_source.html#l00051">oomph::OcTreeNames::LUB</a>, <a class="el" href="octree_8h_source.html#l00055">oomph::OcTreeNames::LUF</a>, <a class="el" href="octree_8h_source.html#l00050">oomph::OcTreeNames::RDB</a>, <a class="el" href="octree_8h_source.html#l00054">oomph::OcTreeNames::RDF</a>, <a class="el" href="octree_8h_source.html#l00052">oomph::OcTreeNames::RUB</a>, and <a class="el" href="octree_8h_source.html#l00056">oomph::OcTreeNames::RUF</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l05255">oomph::OcTreeForest::construct_up_right_equivalents()</a>, and <a class="el" href="helmholtz__geometric__multigrid_8h_source.html#l02354">oomph::HelmholtzMGPreconditioner&lt; DIM &gt;::maximum_edge_width()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a11213866602c59eae49ac1c9164b9785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11213866602c59eae49ac1c9164b9785">&#9670;&nbsp;</a></span>Colour</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; std::string &gt; oomph::OcTree::Colour</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Colours for neighbours in various directions. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00540">540</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l04275">doc_face_neighbours()</a>, <a class="el" href="octree_8cc_source.html#l04552">doc_true_edge_neighbours()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="a50a97dff32038087df0195dcf346405e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a97dff32038087df0195dcf346405e">&#9670;&nbsp;</a></span>Common_face</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; int &gt; oomph::OcTree::Common_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine common face of edges or octants. Slightly bizarre lookup scheme from Samet's book. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00537">537</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l04015">gteq_edge_neighbour()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="aa9c70aef8a78008e8fa668c5e0e516d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c70aef8a78008e8fa668c5e0e516d9">&#9670;&nbsp;</a></span>Cosi</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; oomph::OcTree::Cosi</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry in rotation matrix: cos(i*90) </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00520">520</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l00609">construct_rotation_matrix()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="a2e9487b716f4d583aada06a850b8eae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9487b716f4d583aada06a850b8eae9">&#9670;&nbsp;</a></span>Direct_string</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; std::string &gt; oomph::OcTree::Direct_string</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate (enumerated) directions into strings. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00329">329</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8h_source.html#l00716">oomph::OcTreeRoot::add_edge_neighbour_pt()</a>, <a class="el" href="octree_8cc_source.html#l04275">doc_face_neighbours()</a>, <a class="el" href="octree_8cc_source.html#l04552">doc_true_edge_neighbours()</a>, <a class="el" href="octree_8cc_source.html#l02769">edge_neighbour_is_face_neighbour()</a>, <a class="el" href="octree_8h_source.html#l00668">oomph::OcTreeRoot::edge_neighbour_pt()</a>, <a class="el" href="octree_8cc_source.html#l00268">faces_of_common_edge()</a>, <a class="el" href="octree_8cc_source.html#l04015">gteq_edge_neighbour()</a>, <a class="el" href="octree_8cc_source.html#l03373">gteq_face_neighbour()</a>, <a class="el" href="octree_8cc_source.html#l03618">gteq_true_edge_neighbour()</a>, <a class="el" href="refineable__brick__element_8cc_source.html#l00582">oomph::RefineableQElement&lt; 3 &gt;::interpolated_zeta_on_face()</a>, <a class="el" href="eighth__sphere__domain_8h_source.html#l00074">oomph::EighthSphereDomain::macro_element_boundary()</a>, <a class="el" href="extruded__domain_8cc_source.html#l00148">oomph::ExtrudedDomain::macro_element_boundary()</a>, <a class="el" href="octree_8h_source.html#l00693">oomph::OcTreeRoot::nedge_neighbour()</a>, <a class="el" href="octree_8h_source.html#l00982">oomph::OcTreeForest::oc_face_neigh_pt()</a>, <a class="el" href="octree_8cc_source.html#l00709">rotate()</a>, <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>, and <a class="el" href="octree_8cc_source.html#l00414">vertex_to_node_number()</a>.</p>

</div>
</div>
<a id="adf813fbb9cffe89fb51f3c8ccd3083ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf813fbb9cffe89fb51f3c8ccd3083ca">&#9670;&nbsp;</a></span>Direction_to_vector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; &gt; oomph::OcTree::Direction_to_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each direction, i.e. a son_type (vertex), a face or an edge, this defines a vector that indicates this direction. E.g : Direction_to_vector[RDB]=(1,-1,-1), Direction_to_vector[U]=(0,1,0) </p>
<p><a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a> storing the information to translate a direction into a vector of directions (in the three coordinate directions) </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00353">353</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="generalised__newtonian__refineable__navier__stokes__elements_8cc_source.html#l01814">oomph::PRefineableGeneralisedNewtonianQCrouzeixRaviartElement&lt; DIM &gt;::further_build()</a>, <a class="el" href="generalised__newtonian__refineable__navier__stokes__elements_8h_source.html#l01737">oomph::RefineableGeneralisedNewtonianQCrouzeixRaviartElement&lt; DIM &gt;::further_build()</a>, <a class="el" href="refineable__navier__stokes__elements_8cc_source.html#l01916">oomph::PRefineableQCrouzeixRaviartElement&lt; DIM &gt;::further_build()</a>, <a class="el" href="refineable__navier__stokes__elements_8h_source.html#l01998">oomph::RefineableQCrouzeixRaviartElement&lt; DIM &gt;::further_build()</a>, <a class="el" href="refineable__solid__elements_8h_source.html#l00748">oomph::RefineableQPVDElementWithPressure&lt; DIM &gt;::further_build()</a>, <a class="el" href="refineable__brick__element_8cc_source.html#l00238">oomph::RefineableQElement&lt; 3 &gt;::get_bcs()</a>, <a class="el" href="refineable__brick__element_8cc_source.html#l00424">oomph::RefineableQElement&lt; 3 &gt;::get_boundaries()</a>, <a class="el" href="refineable__brick__element_8cc_source.html#l02764">oomph::RefineableSolidQElement&lt; 3 &gt;::get_solid_bcs()</a>, <a class="el" href="octree_8cc_source.html#l00565">get_the_other_face()</a>, <a class="el" href="octree_8cc_source.html#l03373">gteq_face_neighbour()</a>, <a class="el" href="octree_8cc_source.html#l03618">gteq_true_edge_neighbour()</a>, <a class="el" href="octree_8cc_source.html#l00709">rotate()</a>, <a class="el" href="refineable__brick__element_8cc_source.html#l00126">oomph::RefineableQElement&lt; 3 &gt;::setup_father_bounds()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="a24e29b9da2bf17cc81d803af6925890b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e29b9da2bf17cc81d803af6925890b">&#9670;&nbsp;</a></span>Is_adjacent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; bool &gt; oomph::OcTree::Is_adjacent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array of direction/octant adjacency scheme: Is_adjacent(direction,octant): Is face/edge <code>direction</code> adjacent to octant <code>octant</code> ? (Table in Samet's book) </p>
<p>Array of direction/octant adjacency scheme: Is_adjacent(direction,octant): Is face/edge <code>direction</code> adjacent to octant <code>octant</code> ? Table in Samet's book. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00529">529</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l04015">gteq_edge_neighbour()</a>, <a class="el" href="octree_8cc_source.html#l03839">gteq_face_neighbour()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="aae2497ec31766ebf0541ff6f2bffa790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2497ec31766ebf0541ff6f2bffa790">&#9670;&nbsp;</a></span>Reflect</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; int &gt; oomph::OcTree::Reflect</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reflection scheme: Reflect(direction,octant): Get mirror of octant/edge in specified direction. E.g. Reflect(LDF,L)=RDF. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00533">533</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l04015">gteq_edge_neighbour()</a>, <a class="el" href="octree_8cc_source.html#l03839">gteq_face_neighbour()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="aeb757b41fc1c4b7ea697de40c19b6c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb757b41fc1c4b7ea697de40c19b6c36">&#9670;&nbsp;</a></span>Reflect_edge</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; oomph::OcTree::Reflect_edge</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get opposite edge, e.g. Reflect_edge[DB]=UF. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00335">335</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l03618">gteq_true_edge_neighbour()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="a50b5b6208e34976cb3fd50e84b5c2d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b5b6208e34976cb3fd50e84b5c2d05">&#9670;&nbsp;</a></span>Reflect_face</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; oomph::OcTree::Reflect_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get opposite face, e.g. Reflect_face[L]=R. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00332">332</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l05255">oomph::OcTreeForest::construct_up_right_equivalents()</a>, <a class="el" href="octree_8cc_source.html#l03373">gteq_face_neighbour()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="acee0e40be5a1aa25e7356e23ec327636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee0e40be5a1aa25e7356e23ec327636">&#9670;&nbsp;</a></span>Reflect_vertex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; oomph::OcTree::Reflect_vertex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get opposite vertex, e.g. Reflect_vertex[LDB]=RUF. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00338">338</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="a114adf939f2937d16a69a541b8e2ceb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114adf939f2937d16a69a541b8e2ceb3">&#9670;&nbsp;</a></span>S_base</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt; oomph::OcTree::S_base</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>s_base(i,direction): Initial value for coordinate s[i] on the face indicated by direction (L/R/U/D/F/B) </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00544">544</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l04275">doc_face_neighbours()</a>, <a class="el" href="octree_8cc_source.html#l03373">gteq_face_neighbour()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="a9f8afa940d0ce2ceca2a064f3f1ec6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8afa940d0ce2ceca2a064f3f1ec6b1">&#9670;&nbsp;</a></span>S_base_edge</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt; oomph::OcTree::S_base_edge</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>S_base_edge(i,edge): Initial value for coordinate s[i] on the specified edge (LF/RF/...). </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00585">585</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l04552">doc_true_edge_neighbours()</a>, <a class="el" href="octree_8cc_source.html#l03618">gteq_true_edge_neighbour()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="abf12711759332ae1d0b55da939b62aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf12711759332ae1d0b55da939b62aa0">&#9670;&nbsp;</a></span>S_direct_edge</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt; oomph::OcTree::S_direct_edge</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relative to the left/down/back vertex in any (father) octree, the corresponding vertex in the son specified by <code>son_octant</code> has an offset. If we project the son_octant's left/down/back vertex onto the father's edge <code>edge</code>, it is located at the in-face coordinate <code>s_lo</code> = h/2 <code>S_direct_edge(edge,son_octant)</code>. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00600">600</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l04015">gteq_edge_neighbour()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="a11aca558846c26e31f802396508bea51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11aca558846c26e31f802396508bea51">&#9670;&nbsp;</a></span>S_directhi</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt; oomph::OcTree::S_directhi</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relative to the left/down/back vertex in any (father) octree, the corresponding vertex in the son specified by <code>son_octant</code> has an offset. If we project the son_octant's left/down/back vertex onto the father's face <code>face</code>, it is located at the in-face coordinate <code>s_hi</code> = h/2 <code>S_directlhi(face,son_octant)</code>. [See discussion of <code>s_steplo</code> for an explanation of the subscripts <code>_hi</code> and <code>_lo</code>.]. </p>
<p>Relative to the left/down/back vertex in any (father) octree, the corresponding vertex in the son specified by <code>son_octant</code> has an offset. If we project the son_octant's left/down/back vertex onto the father's face <code>face</code>, it is located at the in-face coordinate <code>s_hi</code> = h/2 <code>S_directlhi(face,son_octant)</code>. [See discussion of <code>S_steplo</code> for an explanation of the subscripts <code>_hi</code> and <code>_lo</code>.]. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00581">581</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l03839">gteq_face_neighbour()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="a2ece71f32cf50ba50851d2102af15426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ece71f32cf50ba50851d2102af15426">&#9670;&nbsp;</a></span>S_directlo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt; oomph::OcTree::S_directlo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relative to the left/down/back vertex in any (father) octree, the corresponding vertex in the son specified by <code>son_octant</code> has an offset. If we project the son_octant's left/down/back vertex onto the father's face <code>face</code>, it is located at the in-face coordinate <code>s_lo</code> = h/2 <code>S_directlo(face,son_octant)</code>. [See discussion of <code>s_steplo</code> for an explanation of the subscripts <code>_hi</code> and <code>_lo</code>.]. </p>
<p>Relative to the left/down/back vertex in any (father) octree, the corresponding vertex in the son specified by <code>son_octant</code> has an offset. If we project the son_octant's left/down/back vertex onto the father's face <code>face</code>, it is located at the in-face coordinate <code>s_lo</code> = h/2 <code>S_directlo(face,son_octant)</code>. [See discussion of <code>S_steplo</code> for an explanation of the subscripts <code>_hi</code> and <code>_lo</code>.]. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00573">573</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l03839">gteq_face_neighbour()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="a036d7e355507212bee6a53d42adbea26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036d7e355507212bee6a53d42adbea26">&#9670;&nbsp;</a></span>S_step_edge</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt; oomph::OcTree::S_step_edge</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Each edge of the <a class="el" href="classoomph_1_1RefineableQElement_3_013_01_4.html" title="Refineable version of QElement&lt;3,NNODE_1D&gt;.">RefineableQElement&lt;3&gt;</a> that is represented by the octree is parametrised by one (of the three) local coordinates that parametrise the entire 3D element. If we're located on edge <code>edge</code> [DB,UB,...], then an increase in s from -1 to +1 corresponds to a change of <code>s_step_edge(i,edge)</code> in the 3D coordinates <code>s</code>[i]. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00593">593</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l04552">doc_true_edge_neighbours()</a>, <a class="el" href="octree_8cc_source.html#l03618">gteq_true_edge_neighbour()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="addcc327c9831b6c57f30c8596125c236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addcc327c9831b6c57f30c8596125c236">&#9670;&nbsp;</a></span>S_stephi</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt; oomph::OcTree::S_stephi</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we're located on face <code>face</code> [L/R/F/B/U/D], then an increase in s_hi from -1 to +1 corresponds to a change of <code>s_stephi(i,face)</code> in the 3D coordinate \ s[i]. [Read the discussion of <code>s_steplo</code> for an explanation of the subscripts <code>_hi</code> and <code>_lo</code>.]. </p>
<p>If we're located on face <code>face</code> [L/R/F/B/U/D], then an increase in s_hi from -1 to +1 corresponds to a change of <code>S_stephi(i,face)</code> in the 3D coordinate \ s[i]. [Read the discussion of <code>S_steplo</code> for an explanation of the subscripts <code>_hi</code> and <code>_lo</code>.]. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00565">565</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l04275">doc_face_neighbours()</a>, <a class="el" href="octree_8cc_source.html#l03373">gteq_face_neighbour()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="af1c005f0207cae66390314859edd9bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c005f0207cae66390314859edd9bd1">&#9670;&nbsp;</a></span>S_steplo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1DenseMatrix.html">DenseMatrix</a>&lt; double &gt; oomph::OcTree::S_steplo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Each face of the <a class="el" href="classoomph_1_1RefineableQElement_3_013_01_4.html" title="Refineable version of QElement&lt;3,NNODE_1D&gt;.">RefineableQElement&lt;3&gt;</a> that is represented by the octree is parametrised by two (of the three) local coordinates that parametrise the entire 3D element. E.g. the B[ack] face is parametrised by (s[0], s[1]); the D[own] face is parametrised by (s[0],s[2]); etc. We always identify the in-face coordinate with the lower (3D) index with the subscript <code>_lo</code> and the one with the larger (3D) index with the subscript <code>_hi</code>. Here we set up the translation scheme between the 2D in-face coordinates (s_lo,s_hi) and the corresponding 3D coordinates: If we're located on face <code>face</code> [L/R/F/B/U/D], then an increase in s_lo from -1 to +1 corresponds to a change of <code>s_steplo(i,face)</code> in the 3D coordinate <code>s</code>[i]. </p>
<p>Each face of the <a class="el" href="classoomph_1_1RefineableQElement_3_013_01_4.html" title="Refineable version of QElement&lt;3,NNODE_1D&gt;.">RefineableQElement&lt;3&gt;</a> that is represented by the octree is parametrised by two (of the three) local coordinates that parametrise the entire 3D element. E.g. the B[ack] face is parametrised by (s[0], s[1]); the D[own] face is parametrised by (s[0],s[2]); etc. We always identify the in-face coordinate with the lower (3D) index with the subscript <code>_lo</code> and the one with the larger (3D) index with the subscript <code>_hi</code>. Here we set up the translation scheme between the 2D in-face coordinates (s_lo,s_hi) and the corresponding 3D coordinates: If we're located on face <code>face</code> [L/R/F/B/U/D], then an increase in s_lo from -1 to +1 corresponds to a change of <code>S_steplo(i,face)</code> in the 3D coordinate <code>s</code>[i]. S_steplo(i,direction) </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00558">558</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l04275">doc_face_neighbours()</a>, <a class="el" href="octree_8cc_source.html#l03373">gteq_face_neighbour()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="a5537d73ec80462fe6f03bdfd5ac836ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5537d73ec80462fe6f03bdfd5ac836ff">&#9670;&nbsp;</a></span>Sini</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; oomph::OcTree::Sini</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry in rotation matrix sin(i*90) </p>
<p>Entry in rotation matrix: sin(i*90) </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00523">523</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l00609">construct_rotation_matrix()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="addaa397d11580ec949531c8ae9b082a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addaa397d11580ec949531c8ae9b082a5">&#9670;&nbsp;</a></span>Static_data_has_been_setup</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool oomph::OcTree::Static_data_has_been_setup = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bool indicating that static member data has been setup. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00412">412</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8h_source.html#l00641">oomph::OcTreeRoot::OcTreeRoot()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="a88cff579697781e1ec50c86517feec77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cff579697781e1ec50c86517feec77">&#9670;&nbsp;</a></span>Up_and_right_equivalent_for_pairs_of_vertices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::pair&lt; std::pair&lt; int, int &gt;, std::pair&lt; int, int &gt; &gt;, std::pair&lt; int, int &gt; &gt; oomph::OcTree::Up_and_right_equivalent_for_pairs_of_vertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Storage for the up/right-equivalents corresponding to two pairs of vertices along an element edge: </p>
<ul>
<li>The first pair contains<ol type="1">
<li>the vertex in the reference element</li>
<li>the corresponding vertex in the edge neighbour (i.e. the vertex in the edge neighbour that is located at the same position as that first vertex).</li>
</ol>
</li>
</ul>
<ul>
<li>The second pair contains<ol type="1">
<li>the vertex at the other end of the edge in the reference element</li>
<li>the corresponding vertex in the edge neighbour.</li>
</ol>
</li>
</ul>
<p>These two pairs completely define the relative rotation between the reference element and its edge neighbour. The map returns a pair which contains the up_equivalent and the right_equivalent of the edge neighbour, i.e. it tells us which direction in the edge neighbour coincides with the up (or right) direction in the reference element. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00377">377</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l05255">oomph::OcTreeForest::construct_up_right_equivalents()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="aec83bade91057d89aa3896274cb96b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec83bade91057d89aa3896274cb96b7e">&#9670;&nbsp;</a></span>Vector_to_direction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt;, int &gt; oomph::OcTree::Vector_to_direction</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Each vector representing a direction can be translated into a direction, either a son type (vertex), a face or an edge. E.g. : Vector_to_direction[(1,-1,1)]=RDF, Vector_to_direction[(0,1,0)]=U. </p>
<p>Map storing the information to translate a vector of directions (in the three coordinate directions) into a direction. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00348">348</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="refineable__brick__element_8cc_source.html#l00238">oomph::RefineableQElement&lt; 3 &gt;::get_bcs()</a>, <a class="el" href="refineable__brick__element_8cc_source.html#l02764">oomph::RefineableSolidQElement&lt; 3 &gt;::get_solid_bcs()</a>, <a class="el" href="octree_8cc_source.html#l00565">get_the_other_face()</a>, <a class="el" href="octree_8cc_source.html#l00709">rotate()</a>, <a class="el" href="refineable__brick__element_8cc_source.html#l00126">oomph::RefineableQElement&lt; 3 &gt;::setup_father_bounds()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<a id="acf182a71db90c350c3f1d334d73d103f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf182a71db90c350c3f1d334d73d103f">&#9670;&nbsp;</a></span>Vertex_at_end_of_edge</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; <a class="el" href="classoomph_1_1Vector.html">Vector</a>&lt; int &gt; &gt; oomph::OcTree::Vertex_at_end_of_edge</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code><a class="el" href="classoomph_1_1Vector.html" title="A slight extension to the standard template vector class so that we can include &quot;graceful&quot; array rang...">Vector</a></code> of vectors containing the two vertices for each edge, e.g. <code>Vertex_at_end_of_edge</code>[LU][0]=LUB and <code>Vertex_at_end_of_edge</code>[LU][1]=LUF. </p>
<p>Map of vectors containing the two vertices for each edge. </p>

<p class="definition">Definition at line <a class="el" href="octree_8h_source.html#l00343">343</a> of file <a class="el" href="octree_8h_source.html">octree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="octree_8cc_source.html#l05255">oomph::OcTreeForest::construct_up_right_equivalents()</a>, and <a class="el" href="octree_8cc_source.html#l01040">setup_static_data()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="octree_8h_source.html">octree.h</a></li>
<li><a class="el" href="octree_8cc_source.html">octree.cc</a></li>
</ul>
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:11:29
        </div>
      </div>
    </footer>
</body>
</html>
