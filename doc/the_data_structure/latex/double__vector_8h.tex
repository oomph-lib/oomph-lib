\hypertarget{double__vector_8h}{}\doxysection{double\+\_\+vector.\+h File Reference}
\label{double__vector_8h}\index{double\_vector.h@{double\_vector.h}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classoomph_1_1DoubleVector}{oomph\+::\+Double\+Vector}}
\begin{DoxyCompactList}\small\item\em A vector in the mathematical sense, initially developed for linear algebra type applications. If MPI then this vector can be distributed -\/ its distribution is described by the \mbox{\hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution}} object at Distribution\+\_\+pt. \mbox{\hyperlink{classoomph_1_1Data}{Data}} is stored in a C-\/style pointer vector (double$\ast$) \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespaceoomph}{oomph}}
\begin{DoxyCompactList}\small\item\em //////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////// \end{DoxyCompactList}\item 
namespace \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers}{oomph\+::\+Double\+Vector\+Helpers}}
\begin{DoxyCompactList}\small\item\em Namespace for helper functions for Double\+Vectors. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers_acf43b80ace3f8a4633190ab36136083b}{oomph\+::\+Double\+Vector\+Helpers\+::concatenate}} (const Vector$<$ Double\+Vector $\ast$ $>$ \&in\+\_\+vector\+\_\+pt, Double\+Vector \&out\+\_\+vector)
\begin{DoxyCompactList}\small\item\em Concatenate Double\+Vectors. Takes a \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of Double\+Vectors. If the out vector is built, we will not build a new distribution. Otherwise we build a uniform distribution. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers_ae2e2b5728675ea85a48158f5d93f6593}{oomph\+::\+Double\+Vector\+Helpers\+::concatenate}} (Vector$<$ Double\+Vector $>$ \&in\+\_\+vector, Double\+Vector \&out\+\_\+vector)
\begin{DoxyCompactList}\small\item\em Wrapper around the other concatenate(...) function. Be careful with \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of vectors. If the Double\+Vectors are resized, there could be reallocation of memory. If we wanted to use the function which takes a \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of pointers to Double\+Vectors, we would either have to invoke new and remember to delete, or create a temporary \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} to store pointers to the \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} objects. This wrapper is meant to make life easier for the user by avoiding calls to new/delete AND without creating a temporary vector of pointers to Double\+Vectors. If we had C++ 11, this would be so much nicer since we can use smart pointers which will delete themselves, so we do not have to remember to delete! \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers_a3c0fa6de2c35301c556b9530c9ab2bc4}{oomph\+::\+Double\+Vector\+Helpers\+::split}} (const Double\+Vector \&in\+\_\+vector, Vector$<$ Double\+Vector $\ast$ $>$ \&out\+\_\+vector\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Split a \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} into the out Double\+Vectors. Let vec\+\_\+A be the in \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}, and let vec\+\_\+B and vec\+\_\+C be the out vectors. Then the splitting of vec\+\_\+A is depicted below\+: vec\+\_\+A\+: \mbox{[}a0 (on p0) a1\mbox{]} (on p0) \mbox{[}a2 (on p1) a3\mbox{]} (on p1) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers_a111654d0a7b7bfaae9cdd8101c8005ca}{oomph\+::\+Double\+Vector\+Helpers\+::split}} (const Double\+Vector \&in\+\_\+vector, Vector$<$ Double\+Vector $>$ \&out\+\_\+vector)
\begin{DoxyCompactList}\small\item\em Wrapper around the other split(...) function. Be careful with \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of vectors. If the Double\+Vectors are resized, there could be reallocation of memory. If we wanted to use the function which takes a \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of pointers to Double\+Vectors, we would either have to invoke new and remember to delete, or create a temporary \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} to store pointers to the \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} objects. This wrapper is meant to make life easier for the user by avoiding calls to new/delete AND without creating a temporary vector of pointers to Double\+Vectors. If we had C++ 11, this would be so much nicer since we can use smart pointers which will delete themselves, so we do not have to remember to delete! \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers_a3ea9f7c40548e1a88402312e6f15d1fc}{oomph\+::\+Double\+Vector\+Helpers\+::concatenate\+\_\+without\+\_\+communication}} (const Vector$<$ Double\+Vector $\ast$ $>$ \&in\+\_\+vector\+\_\+pt, Double\+Vector \&out\+\_\+vector)
\begin{DoxyCompactList}\small\item\em Concatenate Double\+Vectors. Takes a \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of Double\+Vectors. If the out vector is built, we will not build a new distribution. Otherwise a new distribution will be built using Linear\+Algebra\+Distribution\+::concatenate(...). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers_a568db46f65c1d234ac6f96ab54fafe60}{oomph\+::\+Double\+Vector\+Helpers\+::concatenate\+\_\+without\+\_\+communication}} (Vector$<$ Double\+Vector $>$ \&in\+\_\+vector, Double\+Vector \&out\+\_\+vector)
\begin{DoxyCompactList}\small\item\em Wrapper around the other concatenate\+\_\+without\+\_\+communication(...) function. Be careful with \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of vectors. If the Double\+Vectors are resized, there could be reallocation of memory. If we wanted to use the function which takes a \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of pointers to Double\+Vectors, we would either have to invoke new and remember to delete, or create a temporary \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} to store pointers to the \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} objects. This wrapper is meant to make life easier for the user by avoiding calls to new/delete AND without creating a temporary vector of pointers to Double\+Vectors. If we had C++ 11, this would be so much nicer since we can use smart pointers which will delete themselves, so we do not have to remember to delete! \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers_aa87594da930b3eed12a27838972f10f8}{oomph\+::\+Double\+Vector\+Helpers\+::split\+\_\+without\+\_\+communication}} (const Double\+Vector \&in\+\_\+vector, Vector$<$ Double\+Vector $\ast$ $>$ \&out\+\_\+vector\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Split a \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} into the out Double\+Vectors. \mbox{\hyperlink{classoomph_1_1Data}{Data}} stays on its current processor, no data is sent between processors. This results in our vectors which are a permutation of the in vector. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceoomph_1_1DoubleVectorHelpers_a66afcc493558424fb89f26bc23dd5bf2}{oomph\+::\+Double\+Vector\+Helpers\+::split\+\_\+without\+\_\+communication}} (const Double\+Vector \&in\+\_\+vector, Vector$<$ Double\+Vector $>$ \&out\+\_\+vector)
\begin{DoxyCompactList}\small\item\em Wrapper around the other split\+\_\+without\+\_\+communication(...) function. Be careful with \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of vectors. If the Double\+Vectors are resized, there could be reallocation of memory. If we wanted to use the function which takes a \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of pointers to Double\+Vectors, we would either have to invoke new and remember to delete, or create a temporary \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} to store pointers to the \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} objects. This wrapper is meant to make life easier for the user by avoiding calls to new/delete AND without creating a temporary vector of pointers to Double\+Vectors. If we had C++ 11, this would be so much nicer since we can use smart pointers which will delete themselves, so we do not have to remember to delete! \end{DoxyCompactList}\end{DoxyCompactItemize}
