\hypertarget{classoomph_1_1Problem}{}\doxysection{oomph\+::Problem Class Reference}
\label{classoomph_1_1Problem}\index{oomph::Problem@{oomph::Problem}}


////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////  




{\ttfamily \#include $<$problem.\+h$>$}

Inheritance diagram for oomph\+::Problem\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=9.095127cm]{classoomph_1_1Problem}
\end{center}
\end{figure}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402}{Distributed\+\_\+problem\+\_\+matrix\+\_\+distribution}} \{ \mbox{\hyperlink{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402ad7503f3fef4bc3556497018171c820e6}{Default\+\_\+matrix\+\_\+distribution}}
, \mbox{\hyperlink{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402aed8521359adcaf514039424b29893796}{Problem\+\_\+matrix\+\_\+distribution}}
, \mbox{\hyperlink{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402a741cb51275fde6a02373b2ffacf1273f}{Uniform\+\_\+matrix\+\_\+distribution}}
 \}
\begin{DoxyCompactList}\small\item\em enum for distribution of distributed jacobians. 1 -\/ Automatic -\/ the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} distribution is employed, unless any processor has number of rows equal to 110\% of N/P, in which case uniform distribution is employed. 2 -\/ \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} -\/ the jacobian on processor p only contains rows that correspond to equations that are on this processor. (minimises communication) 3 -\/ Uniform -\/ each processor holds as close to N/P matrix rows as possible. (very well load balanced) \end{DoxyCompactList}\item 
typedef void($\ast$ \mbox{\hyperlink{classoomph_1_1Problem_a638b525d7cae45e56160e3c282c8ad09}{Spatial\+Error\+Estimator\+Fct\+Pt}}) (\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$\&\mbox{\hyperlink{classoomph_1_1Problem_aad122d70a22dc5302cfd5853d3cf3057}{mesh\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&elemental\+\_\+error)
\begin{DoxyCompactList}\small\item\em Function pointer for spatial error estimator. \end{DoxyCompactList}\item 
typedef void($\ast$ \mbox{\hyperlink{classoomph_1_1Problem_a220abfde16b8b1b544b4127e0e4cc9e4}{Spatial\+Error\+Estimator\+With\+Doc\+Fct\+Pt}}) (\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$\&\mbox{\hyperlink{classoomph_1_1Problem_aad122d70a22dc5302cfd5853d3cf3057}{mesh\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&elemental\+\_\+error, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Function pointer for spatial error estimator with doc. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a36c95c8211cc02558118288888aab5e1}{debug\+\_\+hook\+\_\+fct}} (const unsigned \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})
\begin{DoxyCompactList}\small\item\em Hook for debugging. Can be overloaded in driver code; argument allows identification of where we\textquotesingle{}re coming from. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_aecef49e98bbcede9b8c3137592c2cc5a}{set\+\_\+analytic\+\_\+dparameter}} (double $\ast$const \&parameter\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Function to turn on analytic calculation of the parameter derivatives in continuation and bifurcation detection problems. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_aff7bcab5505ba482a8c9ba7bace68bc0}{unset\+\_\+analytic\+\_\+dparameter}} (double $\ast$const \&parameter\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Function to turn off analytic calculation of the parameter derivatives in continuation and bifurcation detection problems. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a41a7b9cf8e6fe1156fc92baa43c3fe4b}{is\+\_\+dparameter\+\_\+calculated\+\_\+analytically}} (double $\ast$const \&parameter\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Function to determine whether the parameter derivatives are calculated analytically. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a45f64c33501e0f9c65927eefed253eef}{set\+\_\+analytic\+\_\+hessian\+\_\+products}} ()
\begin{DoxyCompactList}\small\item\em Function to turn on analytic calculation of the parameter derivatives in continuation and bifurcation detection problems. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_accd672b3da8c5bf28ad6bd856e28d1cf}{unset\+\_\+analytic\+\_\+hessian\+\_\+products}} ()
\begin{DoxyCompactList}\small\item\em Function to turn off analytic calculation of the parameter derivatives in continuation and bifurcation detection problems. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_af6235ced9e7e85324f785f2681ab3872}{are\+\_\+hessian\+\_\+products\+\_\+calculated\+\_\+analytically}} ()
\begin{DoxyCompactList}\small\item\em Function to determine whether the hessian products are calculated analytically. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a820d3c43c7d678b4fe186a8c83a90732}{set\+\_\+pinned\+\_\+values\+\_\+to\+\_\+zero}} ()
\begin{DoxyCompactList}\small\item\em Set all pinned values to zero. Used to set boundary conditions to be homogeneous in the copy of the problem used in adaptive bifurcation tracking (ALH\+: TEMPORARY HACK, WILL BE FIXED) \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_af5e9f1623cad361048856a4c0463ea23}{distributed}} () const
\begin{DoxyCompactList}\small\item\em If we have MPI return the \char`\"{}problem has been distributed\char`\"{} flag, otherwise it can\textquotesingle{}t be distributed so return false. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402}{Distributed\+\_\+problem\+\_\+matrix\+\_\+distribution}} \& \mbox{\hyperlink{classoomph_1_1Problem_a4d329a86be53aee9f96a3428809db5f0}{distributed\+\_\+problem\+\_\+matrix\+\_\+distribution}} ()
\begin{DoxyCompactList}\small\item\em accesss function to the distributed matrix distribution method 1 -\/ Automatic -\/ the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} distribution is employed, unless any processor has number of rows equal to 110\% of N/P, in which case uniform distribution is employed. 2 -\/ \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} -\/ the jacobian on processor p only contains rows that correspond to equations that are on this processor. (minimises communication) 3 -\/ Uniform -\/ each processor holds as close to N/P matrix rows as possible. (very well load balanced) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a577bca9cc5ee9504480b372f82e924dd}{enable\+\_\+doc\+\_\+imbalance\+\_\+in\+\_\+parallel\+\_\+assembly}} ()
\begin{DoxyCompactList}\small\item\em Enable doc of load imbalance in parallel assembly of distributed problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a9365d2b0057089ae5551b97488a3a62a}{disable\+\_\+doc\+\_\+imbalance\+\_\+in\+\_\+parallel\+\_\+assembly}} ()
\begin{DoxyCompactList}\small\item\em Disable doc of load imbalance in parallel assembly of distributed problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \mbox{\hyperlink{classoomph_1_1Problem_aa8da092e78c9af112580ddb667a15d97}{elemental\+\_\+assembly\+\_\+time}} ()
\begin{DoxyCompactList}\small\item\em Return vector of most-\/recent elemental assembly times (used for load balancing). Zero sized if no Jacobian has been computed since last re-\/assignment of equation numbers. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a07bad546a91f9d13936be6dc0590fcd0}{clear\+\_\+elemental\+\_\+assembly\+\_\+time}} ()
\begin{DoxyCompactList}\small\item\em Clear storage of most-\/recent elemental assembly times (used for load balancing). Next load balancing operation will be based on the number of elements associated with a tree root. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a3fe4edae6a97460405e7f667d7d4f406}{enable\+\_\+problem\+\_\+distributed}} ()
\begin{DoxyCompactList}\small\item\em Enable problem distributed. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a79752d23035158783ad19711027984dc}{disable\+\_\+problem\+\_\+distributed}} ()
\begin{DoxyCompactList}\small\item\em Disable problem distributed. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ab002dc7a6faf97a1bfcd9c098a04f840}{set\+\_\+default\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly}} ()
\begin{DoxyCompactList}\small\item\em Set default first and last elements for parallel assembly of non-\/distributed problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ac4dec80ab9a6834e10b2c2b0119e7133}{set\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&first\+\_\+el\+\_\+for\+\_\+assembly, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&last\+\_\+el\+\_\+for\+\_\+assembly)
\begin{DoxyCompactList}\small\item\em Manually set first and last elements for parallel assembly of non-\/distributed problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a22b3818d62b66e5cb52d72dcccc037fa}{get\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&first\+\_\+el\+\_\+for\+\_\+assembly, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&last\+\_\+el\+\_\+for\+\_\+assembly) const
\begin{DoxyCompactList}\small\item\em Get first and last elements for parallel assembly of non-\/distributed problem. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a6130d5c9a762cdd1569919a601620796}{actions\+\_\+before\+\_\+adapt}} ()
\begin{DoxyCompactList}\small\item\em Actions that are to be performed before a mesh adaptation. These might include removing any additional elements, such as traction boundary elements before the adaptation. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_ada40ec6730506c01109622c8383fe36e}{actions\+\_\+after\+\_\+adapt}} ()
\begin{DoxyCompactList}\small\item\em Actions that are to be performed after a mesh adaptation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1OomphCommunicator}{Oomph\+Communicator}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_a600bb1740edd0aa07c6d001033bf676a}{communicator\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em access function to the oomph-\/lib communicator \end{DoxyCompactList}\item 
const \mbox{\hyperlink{classoomph_1_1OomphCommunicator}{Oomph\+Communicator}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_af1875e771e99a2e8f1d344d8b880d0de}{communicator\+\_\+pt}} () const
\begin{DoxyCompactList}\small\item\em access function to the oomph-\/lib communicator, const version \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Problem_a3f071f2f8be895dbe0d39d12ca59acf4}{Problem}} ()
\begin{DoxyCompactList}\small\item\em Constructor\+: Allocate space for one time stepper and set all pointers to NULL and set defaults for all parameters. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Problem_a32f06ae01ba0bf2e827ccd9045c40183}{Problem}} (const \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} \&dummy)=delete
\begin{DoxyCompactList}\small\item\em Broken copy constructor. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ae015f3c07e2218748b347f42abe45da1}{operator=}} (const \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} \&)=delete
\begin{DoxyCompactList}\small\item\em Broken assignment operator. \end{DoxyCompactList}\item 
virtual \mbox{\hyperlink{classoomph_1_1Problem_ae2cd468ec03f7ede23c0dc8eea3be1cf}{$\sim$\+Problem}} ()
\begin{DoxyCompactList}\small\item\em Virtual destructor to clean up memory. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$\& \mbox{\hyperlink{classoomph_1_1Problem_aad122d70a22dc5302cfd5853d3cf3057}{mesh\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Return a pointer to the global mesh. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$const  \& \mbox{\hyperlink{classoomph_1_1Problem_a3a2e53542288a4140ea5b076ffa648db}{mesh\+\_\+pt}} () const
\begin{DoxyCompactList}\small\item\em Return a pointer to the global mesh (const version) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$\& \mbox{\hyperlink{classoomph_1_1Problem_ac9d882b768345fd916079ec184764f72}{mesh\+\_\+pt}} (const unsigned \&imesh)
\begin{DoxyCompactList}\small\item\em Return a pointer to the i-\/th submesh. If there are no submeshes, the 0-\/th submesh is the global mesh itself. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$const  \& \mbox{\hyperlink{classoomph_1_1Problem_a35b503d711781552b6b56deb612816c4}{mesh\+\_\+pt}} (const unsigned \&imesh) const
\begin{DoxyCompactList}\small\item\em Return a pointer to the i-\/th submesh (const version) \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_accc4e5a46953800933f07ae6bd67860e}{nsub\+\_\+mesh}} () const
\begin{DoxyCompactList}\small\item\em Return number of submeshes. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_a0cd05109bc2c003c5c0686e6aa55d847}{add\+\_\+sub\+\_\+mesh}} (\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Problem_aad122d70a22dc5302cfd5853d3cf3057}{mesh\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Add a submesh to the problem and return its number, i, by which it can be accessed via mesh\+\_\+pt(i). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a42b2b42a03f9de7d7a4d24edcfa20179}{flush\+\_\+sub\+\_\+meshes}} ()
\begin{DoxyCompactList}\small\item\em Flush the problem\textquotesingle{}s collection of sub-\/meshes. Must be followed by call to \mbox{\hyperlink{classoomph_1_1Problem_ac0a0e649f36b4a7ce992888c323d1571}{rebuild\+\_\+global\+\_\+mesh()}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a0faad6f705a6dc0ffe27229f9104ed7c}{build\+\_\+global\+\_\+mesh}} ()
\begin{DoxyCompactList}\small\item\em Build the global mesh by combining the all the submeshes. {\bfseries{Note\+:}} The nodes boundary information refers to the boundary numbers within the submesh! \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ac0a0e649f36b4a7ce992888c323d1571}{rebuild\+\_\+global\+\_\+mesh}} ()
\begin{DoxyCompactList}\small\item\em If one of the submeshes has changed (e.\+g. by mesh adaptation) we need to update the global mesh. {\bfseries{Note\+:}} The nodes boundary information refers to the boundary numbers within the submesh! \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a220816aebf8c74c6c524088e3da4d793}{build\+\_\+mesh}} ()
\begin{DoxyCompactList}\small\item\em Function to build the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s base mesh; this must be supplied by the user if they wish to use the \mbox{\hyperlink{classoomph_1_1Problem_ad6309367fa379889012f25e3397ab425}{load\+\_\+balance()}} functionality, which is only available to problems that have already been distributed. If the problem has multiple meshes, each mesh must be built, added as as a submesh, and a call to \mbox{\hyperlink{classoomph_1_1Problem_a0faad6f705a6dc0ffe27229f9104ed7c}{build\+\_\+global\+\_\+mesh()}} must be made in this function. On return from this function all meshes must have been refined to the same level that they were in the when \mbox{\hyperlink{classoomph_1_1Problem_aa35e1adc0fdf14b217c7b608eb9cf20b}{Problem\+::distribute()}} was first called. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ad6309367fa379889012f25e3397ab425}{load\+\_\+balance}} ()
\begin{DoxyCompactList}\small\item\em Balance the load of a (possibly non-\/uniformly refined) problem that has already been distributed, by re-\/distributing elements over processors. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a1d78ad991995dca1f71ae83ccaa83e25}{load\+\_\+balance}} (const bool \&report\+\_\+stats)
\begin{DoxyCompactList}\small\item\em Balance the load of a (possibly non-\/uniformly refined) problem that has already been distributed, by re-\/distributing elements over processors. Produce explicit stats of load balancing process if boolean, report\+\_\+stats, is set to true. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_abc2a02507c85322024b9859bfbd5b7bf}{load\+\_\+balance}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info, const bool \&report\+\_\+stats)
\begin{DoxyCompactList}\small\item\em Balance the load of a (possibly non-\/uniformly refined) problem that has already been distributed, by re-\/distributing elements over processors. Produce explicit stats of load balancing process if boolean, report\+\_\+stats, is set to true. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a7492ddb5663552ce8f61f1ef73c86a9d}{load\+\_\+balance}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info, const bool \&report\+\_\+stats, const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&input\+\_\+target\+\_\+domain\+\_\+for\+\_\+local\+\_\+non\+\_\+halo\+\_\+element)
\begin{DoxyCompactList}\small\item\em Balance the load of a (possibly non-\/uniformly refined) problem that has already been distributed, by re-\/distributing elements over processors. Produce explicit stats of load balancing process if boolean, report\+\_\+stats, is set to true and doc various bits of data (mainly for debugging) in directory specified by \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} object. If final input vector is non-\/zero-\/sized it provides an imposed partitioning. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a23e641f64f436d4911c53c0f5c7ff239}{set\+\_\+default\+\_\+partition\+\_\+in\+\_\+load\+\_\+balance}} ()
\begin{DoxyCompactList}\small\item\em Set the use of the default partition in the load balance. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a1157876a05d112d523be03d9c30464de}{unset\+\_\+default\+\_\+partition\+\_\+in\+\_\+load\+\_\+balance}} ()
\begin{DoxyCompactList}\small\item\em Do not use the default partition in the load balance. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a65aef9c70c2f3b24ed4c9893a1236afe}{refine\+\_\+distributed\+\_\+base\+\_\+mesh}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$$>$$>$ \&to\+\_\+be\+\_\+refined\+\_\+on\+\_\+each\+\_\+root, const unsigned \&max\+\_\+level\+\_\+overall)
\begin{DoxyCompactList}\small\item\em Load balance helper routine\+: refine each new base (sub)mesh based upon the elements to be refined within each tree at each root on the current processor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} $\ast$\& \mbox{\hyperlink{classoomph_1_1Problem_a689687cacc40dd351430545a7041f44c}{linear\+\_\+solver\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Return a pointer to the linear solver object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} $\ast$const  \& \mbox{\hyperlink{classoomph_1_1Problem_a50b5365e0de1212b9c07f41ae9deab5a}{linear\+\_\+solver\+\_\+pt}} () const
\begin{DoxyCompactList}\small\item\em Return a pointer to the linear solver object (const version) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} $\ast$\& \mbox{\hyperlink{classoomph_1_1Problem_a93304d0c6be1022b944f21c0f4c07eab}{mass\+\_\+matrix\+\_\+solver\+\_\+for\+\_\+explicit\+\_\+timestepper\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Return a pointer to the linear solver object used for explicit time stepping. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_a10ffcfbf305940a05452d950df7a11c3}{mass\+\_\+matrix\+\_\+solver\+\_\+for\+\_\+explicit\+\_\+timestepper\+\_\+pt}} () const
\begin{DoxyCompactList}\small\item\em Return a pointer to the linear solver object used for explicit time stepping (const version). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1EigenSolver}{Eigen\+Solver}} $\ast$\& \mbox{\hyperlink{classoomph_1_1Problem_a00efa0059958df35858503e77111c362}{eigen\+\_\+solver\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Return a pointer to the eigen solver object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1EigenSolver}{Eigen\+Solver}} $\ast$const  \& \mbox{\hyperlink{classoomph_1_1Problem_a14d44adcbf581d43154be19d127b6183}{eigen\+\_\+solver\+\_\+pt}} () const
\begin{DoxyCompactList}\small\item\em Return a pointer to the eigen solver object (const version) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Time}{Time}} $\ast$\& \mbox{\hyperlink{classoomph_1_1Problem_a46894b13c582f322082dc471a2485980}{time\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Return a pointer to the global time object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Time}{Time}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_aa86b09eac493cfa9fcbe57734985ba19}{time\+\_\+pt}} () const
\begin{DoxyCompactList}\small\item\em Return a pointer to the global time object (const version). \end{DoxyCompactList}\item 
double \& \mbox{\hyperlink{classoomph_1_1Problem_acd8c357349d20a28af70b2b7ea7f488d}{time}} ()
\begin{DoxyCompactList}\small\item\em Return the current value of continuous time. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_a925acb2e840deb4edc6305da8fced0e3}{time}} () const
\begin{DoxyCompactList}\small\item\em Return the current value of continuous time (const version) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}} $\ast$\& \mbox{\hyperlink{classoomph_1_1Problem_ad77413dc70a25d271f582ad3c3d7bf65}{time\+\_\+stepper\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Access function for the pointer to the first (presumably only) timestepper. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_a3f952a57b5238978250849c04e2fcbdb}{time\+\_\+stepper\+\_\+pt}} () const
\begin{DoxyCompactList}\small\item\em Access function for the pointer to the first (presumably only) timestepper. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}} $\ast$\& \mbox{\hyperlink{classoomph_1_1Problem_a76cda2a0a02815a3de446723a2334293}{time\+\_\+stepper\+\_\+pt}} (const unsigned \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})
\begin{DoxyCompactList}\small\item\em Return a pointer to the i-\/th timestepper. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1ExplicitTimeStepper}{Explicit\+Time\+Stepper}} $\ast$\& \mbox{\hyperlink{classoomph_1_1Problem_ac332634783a803c1c21bf5c520af280f}{explicit\+\_\+time\+\_\+stepper\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Return a pointer to the explicit timestepper. \end{DoxyCompactList}\item 
unsigned long \mbox{\hyperlink{classoomph_1_1Problem_a7be66e9917b39eaea90b91389f5a72fb}{set\+\_\+timestepper\+\_\+for\+\_\+all\+\_\+data}} (\mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Problem_ad77413dc70a25d271f582ad3c3d7bf65}{time\+\_\+stepper\+\_\+pt}}, const bool \&preserve\+\_\+existing\+\_\+data=false)
\begin{DoxyCompactList}\small\item\em Set all problem data to have the same timestepper (timestepper\+\_\+pt) Return the new number of dofs in the problem. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_aab27bdd1968e57cb3dffe78c1d63f762}{shift\+\_\+time\+\_\+values}} ()
\begin{DoxyCompactList}\small\item\em Shift all values along to prepare for next timestep. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}} $\ast$\& \mbox{\hyperlink{classoomph_1_1Problem_a381c30a8daede5c95bdda7e2efa24f19}{assembly\+\_\+handler\+\_\+pt}} ()
\begin{DoxyCompactList}\small\item\em Return a pointer to the assembly handler object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}} $\ast$const  \& \mbox{\hyperlink{classoomph_1_1Problem_a48905dc6c9a8811969407939b3e4ccb6}{assembly\+\_\+handler\+\_\+pt}} () const
\begin{DoxyCompactList}\small\item\em Return a pointer to the assembly handler object (const version) \end{DoxyCompactList}\item 
double \& \mbox{\hyperlink{classoomph_1_1Problem_adffc8921bf61edac68ed017bcdc1d792}{minimum\+\_\+dt}} ()
\begin{DoxyCompactList}\small\item\em Access function to min timestep in adaptive timestepping. \end{DoxyCompactList}\item 
double \& \mbox{\hyperlink{classoomph_1_1Problem_ac5355154d4991ec634e74d4817176f5f}{maximum\+\_\+dt}} ()
\begin{DoxyCompactList}\small\item\em Access function to max timestep in adaptive timestepping. \end{DoxyCompactList}\item 
unsigned \& \mbox{\hyperlink{classoomph_1_1Problem_aa30b2e89f61a327ffb1be4ff30bb868f}{max\+\_\+newton\+\_\+iterations}} ()
\begin{DoxyCompactList}\small\item\em Access function to max Newton iterations before giving up. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a92acc3c193a38f321fc318fafd142f7a}{problem\+\_\+is\+\_\+nonlinear}} (const bool \&prob\+\_\+lin)
\begin{DoxyCompactList}\small\item\em Access function to Problem\+\_\+is\+\_\+nonlinear. \end{DoxyCompactList}\item 
double \& \mbox{\hyperlink{classoomph_1_1Problem_a2ad78241135f621df36bc1b9634845ac}{max\+\_\+residuals}} ()
\begin{DoxyCompactList}\small\item\em Access function to max residuals in Newton iterations before giving up. \end{DoxyCompactList}\item 
bool \& \mbox{\hyperlink{classoomph_1_1Problem_a7a42b89a67e0770c68493b9569bffe16}{time\+\_\+adaptive\+\_\+newton\+\_\+crash\+\_\+on\+\_\+solve\+\_\+fail}} ()
\begin{DoxyCompactList}\small\item\em Access function for Time\+\_\+adaptive\+\_\+newton\+\_\+crash\+\_\+on\+\_\+solve\+\_\+fail. \end{DoxyCompactList}\item 
double \& \mbox{\hyperlink{classoomph_1_1Problem_aa43a98d2303f2bce10d0887dc0b2eac5}{newton\+\_\+solver\+\_\+tolerance}} ()
\begin{DoxyCompactList}\small\item\em Access function to tolererance of the Newton solver, i.\+e. the maximum value of the residuals that will be accepted. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a8856eae2daa9cea05e99bfcd4ef340a4}{add\+\_\+time\+\_\+stepper\+\_\+pt}} (\mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Problem_ad77413dc70a25d271f582ad3c3d7bf65}{time\+\_\+stepper\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Add a timestepper to the problem. The function will automatically create or resize the \mbox{\hyperlink{classoomph_1_1Time}{Time}} object so that it contains the appropriate number of levels of storage. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a4cf44478e6f6abe95063b7bb2dd530a0}{set\+\_\+explicit\+\_\+time\+\_\+stepper\+\_\+pt}} (\mbox{\hyperlink{classoomph_1_1ExplicitTimeStepper}{Explicit\+Time\+Stepper}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Problem_ac332634783a803c1c21bf5c520af280f}{explicit\+\_\+time\+\_\+stepper\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Set the explicit timestepper for the problem. The function will automatically create or resize the \mbox{\hyperlink{classoomph_1_1Time}{Time}} object so that it contains the appropriate number of levels of storage. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a342b9bd9c4bc142f514907ee1d23d613}{initialise\+\_\+dt}} (const double \&dt)
\begin{DoxyCompactList}\small\item\em Set all timesteps to the same value, dt, and assign weights for all timesteppers in the problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a48137f1c7b297de56078f6bc0c83b675}{initialise\+\_\+dt}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&dt)
\begin{DoxyCompactList}\small\item\em Set the value of the timesteps to be equal to the values passed in a vector and assign weights for all timesteppers in the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Data}{Data}} $\ast$\& \mbox{\hyperlink{classoomph_1_1Problem_ae508b2056d532cb8b6eb0dd5c16b9325}{global\+\_\+data\+\_\+pt}} (const unsigned \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})
\begin{DoxyCompactList}\small\item\em Return a pointer to the the i-\/th global data object. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a6f0c24728351d390d4f0a86d07bd8678}{add\+\_\+global\+\_\+data}} (\mbox{\hyperlink{classoomph_1_1Data}{Data}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Problem_ae508b2056d532cb8b6eb0dd5c16b9325}{global\+\_\+data\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Add \mbox{\hyperlink{classoomph_1_1Data}{Data}} to the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s global data -- the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} will perform equation numbering etc. for such \mbox{\hyperlink{classoomph_1_1Data}{Data}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_aa8df5552c706bd949b29f5601f8c941e}{flush\+\_\+global\+\_\+data}} ()
\begin{DoxyCompactList}\small\item\em Flush the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s global data -- resizes container to zero. \mbox{\hyperlink{classoomph_1_1Data}{Data}} objects are not deleted! \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a9af22a1cfead13bcad14c1b78d1cf273}{create\+\_\+new\+\_\+linear\+\_\+algebra\+\_\+distribution}} (\mbox{\hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution}} $\ast$\&dist\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Get new linear algebra distribution (you\textquotesingle{}re in charge of deleting it!) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution}} $\ast$const  \& \mbox{\hyperlink{classoomph_1_1Problem_a17a5a4886c4213422179fe8346336a4e}{dof\+\_\+distribution\+\_\+pt}} () const
\begin{DoxyCompactList}\small\item\em Return the pointer to the dof distribution (read-\/only) \end{DoxyCompactList}\item 
unsigned long \mbox{\hyperlink{classoomph_1_1Problem_a218d4dfff74bc14f3f5dc8416236e01d}{ndof}} () const
\begin{DoxyCompactList}\small\item\em Return the number of dofs. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_ace3cdf55009c3bff21d2b7d3706d522a}{ntime\+\_\+stepper}} () const
\begin{DoxyCompactList}\small\item\em Return the number of time steppers. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_a60a9b6861928cf9115110b5bfc7d11a7}{nglobal\+\_\+data}} () const
\begin{DoxyCompactList}\small\item\em Return the number of global data values. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_acdb76c0b94aa3cc5470ce862d70a8017}{self\+\_\+test}} ()
\begin{DoxyCompactList}\small\item\em Self-\/test\+: Check meshes and global data. Return 0 for OK. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a31ba79405993ec52e3017d6ff3a42c8c}{enable\+\_\+store\+\_\+local\+\_\+dof\+\_\+pt\+\_\+in\+\_\+elements}} ()
\begin{DoxyCompactList}\small\item\em Insist that local dof pointers are set up in each element when equation numbering takes place. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ac23468bc4101d3038e6b537b6fc87aa6}{disable\+\_\+store\+\_\+local\+\_\+dof\+\_\+pt\+\_\+in\+\_\+elements}} ()
\begin{DoxyCompactList}\small\item\em Insist that local dof pointers are NOT set up in each element when equation numbering takes place (the default) \end{DoxyCompactList}\item 
unsigned long \mbox{\hyperlink{classoomph_1_1Problem_a0df501c6aed60c4938861df776b10119}{assign\+\_\+eqn\+\_\+numbers}} (const bool \&assign\+\_\+local\+\_\+eqn\+\_\+numbers=true)
\begin{DoxyCompactList}\small\item\em Assign all equation numbers for problem\+: Deals with global data (= data that isn\textquotesingle{}t attached to any elements) and then does the equation numbering for the elements. Virtual so it can be overloaded in MPI problems. Bool argument can be set to false to ignore assigning local equation numbers (found to be necessary in the parallel implementation of locate\+\_\+zeta between multiple meshes). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a0563ae60b5c372087398fc3c45af757d}{describe\+\_\+dofs}} (std\+::ostream \&out= $\ast$(oomph\+\_\+info.\+stream\+\_\+pt())) const
\begin{DoxyCompactList}\small\item\em Function to describe the dofs in terms of the global equation number, i.\+e. what type of value (nodal value of a \mbox{\hyperlink{classoomph_1_1Node}{Node}}; value in a \mbox{\hyperlink{classoomph_1_1Data}{Data}} object; value of internal \mbox{\hyperlink{classoomph_1_1Data}{Data}} in an element; etc) is the unknown with a certain global equation number. Output stream defaults to oomph\+\_\+info. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_af4fbd755b3ce6b86fa0f1b1f29bd08f0}{enable\+\_\+discontinuous\+\_\+formulation}} ()
\begin{DoxyCompactList}\small\item\em Indicate that the problem involves discontinuous elements This allows for a more efficiently assembly and inversion of the mass matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_afa64d728ceff0dd772bbbc8f2adcddfb}{disable\+\_\+discontinuous\+\_\+formulation}} ()
\begin{DoxyCompactList}\small\item\em Disable the use of a discontinuous-\/element formulation. Note that the methods will all still work even if the elements are discontinuous, we will just be assembling a larger system matrix than necessary. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ae2ef66732d76053dba15001818c0605c}{get\+\_\+dofs}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&dofs) const
\begin{DoxyCompactList}\small\item\em Return the vector of dofs, i.\+e. a vector containing the current values of all unknowns. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_abb56c404b0dd6df75bcadab797d9a24e}{get\+\_\+dofs}} (const unsigned \&\mbox{\hyperlink{cfortran_8h_af6f0bd3dc13317f895c91323c25c2b8f}{t}}, \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&dofs) const
\begin{DoxyCompactList}\small\item\em Return vector of the t\textquotesingle{}th history value of all dofs. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ab51480d18550c107c9f13629102f6b08}{set\+\_\+dofs}} (const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&dofs)
\begin{DoxyCompactList}\small\item\em Set the values of the dofs. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a62d7dbbf49388e6383e3b93e50351e89}{set\+\_\+dofs}} (const unsigned \&\mbox{\hyperlink{cfortran_8h_af6f0bd3dc13317f895c91323c25c2b8f}{t}}, \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&dofs)
\begin{DoxyCompactList}\small\item\em Set the history values of the dofs. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a4b01ea8bfa914f1c9f40f9a2a7aa8ad5}{set\+\_\+dofs}} (const unsigned \&\mbox{\hyperlink{cfortran_8h_af6f0bd3dc13317f895c91323c25c2b8f}{t}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&\mbox{\hyperlink{classoomph_1_1Problem_a02f480ec17e0b9b03c892be5ed0c64d1}{dof\+\_\+pt}})
\begin{DoxyCompactList}\small\item\em Set history values of dofs from the type of vector stored in problem\+::\+Dof\+\_\+pt. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a352210408b3eed3e7a834b8b9a33a99a}{add\+\_\+to\+\_\+dofs}} (const double \&lambda, const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&increment\+\_\+dofs)
\begin{DoxyCompactList}\small\item\em Add lambda x incremenet\+\_\+dofs\mbox{[}l\mbox{]} to the l-\/th dof. \end{DoxyCompactList}\item 
double $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_a491354401f780ccc114ceb76f5cacef0}{global\+\_\+dof\+\_\+pt}} (const unsigned \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})
\begin{DoxyCompactList}\small\item\em Return a pointer to the dof, indexed by global equation number which may be haloed or stored locally. If it is haloed, a local copy must have been requested on this processor in the Halo\+\_\+scheme\+\_\+pt. \end{DoxyCompactList}\item 
double \& \mbox{\hyperlink{classoomph_1_1Problem_a74d71439b100fb5b66b94d1d69130f7c}{dof}} (const unsigned \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})
\begin{DoxyCompactList}\small\item\em i-\/th dof in the problem \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_a200cbd03828632d448c3525e9a921f27}{dof}} (const unsigned \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}}) const
\begin{DoxyCompactList}\small\item\em i-\/th dof in the problem (const version) \end{DoxyCompactList}\item 
double $\ast$\& \mbox{\hyperlink{classoomph_1_1Problem_a02f480ec17e0b9b03c892be5ed0c64d1}{dof\+\_\+pt}} (const unsigned \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})
\begin{DoxyCompactList}\small\item\em Pointer to i-\/th dof in the problem. \end{DoxyCompactList}\item 
double $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_acf51914cb75a640f82b269493311c187}{dof\+\_\+pt}} (const unsigned \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}}) const
\begin{DoxyCompactList}\small\item\em Pointer to i-\/th dof in the problem (const version) \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a8d7cc317f4900e076dec400ce2493c19}{get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&Mres)
\begin{DoxyCompactList}\small\item\em Return the residual vector multiplied by the inverse mass matrix Virtual so that it can be overloaded for mpi problems. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a2d456362f4408556e879871ae34e57f1}{get\+\_\+dvaluesdt}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&f)
\begin{DoxyCompactList}\small\item\em Get the time derivative of all values (using get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals(..) with all time steppers set to steady) e.\+g. for use in explicit time steps. The approach used is slighty hacky, beware if you have a residual which is non-\/linear or implicit in the derivative or if you have overloaded get\+\_\+jacobian(...). \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a7300386d91390e3e5be993aca7459498}{get\+\_\+residuals}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&residuals)
\begin{DoxyCompactList}\small\item\em Return the fully-\/assembled residuals \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} for the problem\+: Virtual so it can be overloaded in for mpi problems. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a4ba83bbea19db3a530539f3e9f88a7e4}{get\+\_\+jacobian}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&residuals, \mbox{\hyperlink{classoomph_1_1DenseDoubleMatrix}{Dense\+Double\+Matrix}} \&jacobian)
\begin{DoxyCompactList}\small\item\em Return the fully-\/assembled Jacobian and residuals for the problem Interface for the case when the Jacobian matrix is dense. This is virtual so, if we feel like it (e.\+g. for testing iterative solvers with specific test matrices, we can bypass the default assembly procedure for the Jacobian and the residual vector. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a1369827c6970abfd41deae4ef185822c}{get\+\_\+jacobian}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&residuals, \mbox{\hyperlink{classoomph_1_1CRDoubleMatrix}{CRDouble\+Matrix}} \&jacobian)
\begin{DoxyCompactList}\small\item\em Return the fully-\/assembled Jacobian and residuals for the problem. Interface for the case when the Jacobian is in row-\/compressed storage format. This is virtual so, if we feel like it (e.\+g. for testing iterative solvers with specific test matrices), we can bypass the default assembly procedure for the Jacobian and the residual vector. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a9e6c6d71f95d96943a1a8487b6131e89}{get\+\_\+jacobian}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&residuals, \mbox{\hyperlink{classoomph_1_1CCDoubleMatrix}{CCDouble\+Matrix}} \&jacobian)
\begin{DoxyCompactList}\small\item\em Return the fully-\/assembled Jacobian and residuals for the problem. Interface for the case when the Jacobian is in column-\/compressed storage format. This is virtual so, if we feel like it (e.\+g. for testing iterative solvers with specific test matrices), we can bypass the default assembly procedure for the Jacobian and the residual vector. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a0db16f9bcac7af964d0fecc8b6a5ea63}{get\+\_\+jacobian}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&residuals, \mbox{\hyperlink{classoomph_1_1SumOfMatrices}{Sum\+Of\+Matrices}} \&jacobian)
\begin{DoxyCompactList}\small\item\em Dummy virtual function that must be overloaded by the problem to specify which matrices should be summed to give the final Jacobian. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a74f6540dc7228b21f5bc07c0477dfbe7}{get\+\_\+fd\+\_\+jacobian}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&residuals, \mbox{\hyperlink{classoomph_1_1DenseMatrix}{Dense\+Matrix}}$<$ double $>$ \&jacobian)
\begin{DoxyCompactList}\small\item\em Return the fully-\/assembled Jacobian and residuals, generated by finite differences. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_af4d959a47ef6a8d50b394a6761dfab5a}{get\+\_\+derivative\+\_\+wrt\+\_\+global\+\_\+parameter}} (double $\ast$const \&parameter\+\_\+pt, \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&result)
\begin{DoxyCompactList}\small\item\em Get the derivative of the entire residuals vector wrt a global parameter, used in continuation problems. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ac65cbe00a72cfc91ccaea10818f1a507}{get\+\_\+hessian\+\_\+vector\+\_\+products}} (\mbox{\hyperlink{classoomph_1_1DoubleVectorWithHaloEntries}{Double\+Vector\+With\+Halo\+Entries}} const \&Y, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVectorWithHaloEntries}{Double\+Vector\+With\+Halo\+Entries}} $>$ const \&C, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVectorWithHaloEntries}{Double\+Vector\+With\+Halo\+Entries}} $>$ \&product)
\begin{DoxyCompactList}\small\item\em Return the product of the global hessian (derivative of Jacobian matrix with respect to all variables) with an eigenvector, Y, and any number of other specified vectors C (d(J\+\_\+\{ij\})/d u\+\_\+\{k\}) Y\+\_\+\{j\} C\+\_\+\{k\}. This function is used in assembling and solving the augmented systems associated with bifurcation tracking. The default implementation is to use finite differences at the global level. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a8cde2d21879264ae7bc8a140142db8ea}{solve\+\_\+eigenproblem\+\_\+legacy}} (const unsigned \&n\+\_\+eval, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&eigenvalue, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&eigenvector, const bool \&steady=true)
\begin{DoxyCompactList}\small\item\em Get derivative of an element in the problem wrt a global parameter, used in continuation problems. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_aa4c4d1c36972399b365017b967622449}{solve\+\_\+eigenproblem\+\_\+legacy}} (const unsigned \&n\+\_\+eval, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&eigenvalue, const bool \&steady=true)
\begin{DoxyCompactList}\small\item\em Solve an eigenproblem as assembled by the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s constituent elements. Calculate (at least) n\+\_\+eval eigenvalues. The boolean flag (default true) specifies whether the steady jacobian should be assembled. If the flag is false then the weighted mass-\/matrix terms from the timestepper will be included in the jacobian --- this is almost certainly never wanted. Legacy version. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_afb6e5ef95c303d531f5949d7e9f6774a}{solve\+\_\+eigenproblem}} (const unsigned \&n\+\_\+eval, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&alpha, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&beta, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&eigenvector\+\_\+real, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&eigenvector\+\_\+imag, const bool \&steady=true)
\begin{DoxyCompactList}\small\item\em Solve an eigenproblem as assembled by the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s constituent elements. Calculate (at least) n\+\_\+eval eigenvalues and return the corresponding eigenvectors. The boolean flag (default true) specifies whether the steady jacobian should be assembled. If the flag is false then the weighted mass-\/matrix terms from the timestepper will be included in the jacobian --- this is almost certainly never wanted. The eigenvalues and eigenvectors are, in general, complex. Eigenvalues may be infinite and are therefore returned as $ \lambda_i = \alpha_i / \beta_i $ where $ \alpha_i $ is complex while $ \beta_i $ is real. The actual eigenvalues may then be computed by doing the division, checking for zero betas to avoid Na\+Ns. There\textquotesingle{}s a convenience wrapper to this function that simply computes these eigenvalues regardless. That version may die in NaN checking is enabled (via the fenv.\+h header and the associated feenable function). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a1af2e46e4a98d88ccf85f96dd18c4d25}{solve\+\_\+eigenproblem}} (const unsigned \&n\+\_\+eval, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&eigenvalue, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&eigenvector\+\_\+real, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&eigenvector\+\_\+imag, const bool \&steady=true)
\begin{DoxyCompactList}\small\item\em Solve an eigenproblem as assembled by the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s constituent elements. Calculate (at least) n\+\_\+eval eigenvalues and return the corresponding eigenvectors. The boolean flag (default true) specifies whether the steady jacobian should be assembled. If the flag is false then the weighted mass-\/matrix terms from the timestepper will be included in the jacobian --- this is almost certainly never wanted. Note that the eigenvalues and eigenvectors are, in general, complex and the eigenvalues may be infinite. In this case it\textquotesingle{}s safer to use the other version of this function which returns the eigenvalues in terms of a fractional representation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a02a607f961a4f5651972035abd8529b3}{solve\+\_\+eigenproblem}} (const unsigned \&n\+\_\+eval, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&eigenvalue, const bool \&make\+\_\+timesteppers\+\_\+steady=true)
\begin{DoxyCompactList}\small\item\em Solve an eigenproblem as assembled by the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s constituent elements but only return the eigenvalues, not the eigenvectors. At least n\+\_\+eval eigenvalues are computed. The boolean flag (default true) is used to specify whether the weighted mass-\/matrix terms from the timestepping scheme should be included in the jacobian --- this is almost certainly never wanted. Note that the eigenvalues may be infinite. In this case it\textquotesingle{}s safer to use the other version of this function which returns the eigenvalues in terms of a fractional representation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_abdeda71a6cde679015d0a064a2122744}{solve\+\_\+eigenproblem}} (const unsigned \&n\+\_\+eval, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&alpha, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&beta, const bool \&steady=true)
\begin{DoxyCompactList}\small\item\em Solve an eigenproblem as assembled by the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s constituent elements but only return the eigenvalues, not the eigenvectors. At least n\+\_\+eval eigenvalues are computed. The boolean flag (default true) is used to specify whether the weighted mass-\/matrix terms from the timestepping scheme should be included in the jacobian --- this is almost certainly never wanted. Note that the eigenvalues may be infinite and are therefore returned as $ \lambda_i = \alpha_i / \beta_i $ where $ \alpha_i $ is complex while $ \beta_i $ is real. The actual eigenvalues may then be computed by doing the division, checking for zero betas to avoid Na\+Ns. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a0a7c8ab31dc0297e049b15d67eb7661b}{solve\+\_\+adjoint\+\_\+eigenproblem\+\_\+legacy}} (const unsigned \&n\+\_\+eval, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&eigenvalue, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&eigenvector, const bool \&make\+\_\+timesteppers\+\_\+steady=true)
\begin{DoxyCompactList}\small\item\em Solve an adjoint eigenvalue problem using the same procedure as solve\+\_\+eigenproblem. See the documentation on that function for more details. Note\+: this is a legacy version of this function that stores re \& imag parts of eigenvectors in some solver-\/specific collection of real vectors. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a238820e0f1029699f362510557b77d24}{solve\+\_\+adjoint\+\_\+eigenproblem}} (const unsigned \&n\+\_\+eval, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&eigenvalue, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&eigenvector\+\_\+real, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&eigenvector\+\_\+imag, const bool \&steady=true)
\begin{DoxyCompactList}\small\item\em Solve an adjoint eigenvalue problem using the same procedure as solve\+\_\+eigenproblem. See the documentation on that function for more details. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ae42812f6d3b950698cf0936e28f0e415}{solve\+\_\+adjoint\+\_\+eigenproblem}} (const unsigned \&n\+\_\+eval, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&eigenvalue, const bool \&steady=true)
\begin{DoxyCompactList}\small\item\em Solve an adjoint eigenvalue problem using the same procedure as solve\+\_\+eigenproblem but only return the eigenvalues, not the eigenvectors. At least n\+\_\+eval eigenvalues are computed. See the documentation on that function for more details. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a17e2d84700ac43c1db1d68143790ae5c}{get\+\_\+eigenproblem\+\_\+matrices}} (\mbox{\hyperlink{classoomph_1_1CRDoubleMatrix}{CRDouble\+Matrix}} \&mass\+\_\+matrix, \mbox{\hyperlink{classoomph_1_1CRDoubleMatrix}{CRDouble\+Matrix}} \&main\+\_\+matrix, const double \&shift=0.\+0)
\begin{DoxyCompactList}\small\item\em Get the matrices required by a eigensolver. If the shift parameter is non-\/zero the second matrix will be shifted. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a8f93315e1076dd9672167ed0a845ea34}{assign\+\_\+eigenvector\+\_\+to\+\_\+dofs}} (\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&eigenvector)
\begin{DoxyCompactList}\small\item\em Assign the eigenvector passed to the function to the dofs in the problem so that it can be output by the usual routines. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_aa803fbccb2c8c70702b2c39837e7ad2e}{add\+\_\+eigenvector\+\_\+to\+\_\+dofs}} (const double \&epsilon, const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&eigenvector)
\begin{DoxyCompactList}\small\item\em Add the eigenvector passed to the function scaled by the constat epsilon to the dofs in the problem so that it can be output by the usual routines. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a5a2906b9a6a22445d1dbb8aebbce9fa7}{store\+\_\+current\+\_\+dof\+\_\+values}} ()
\begin{DoxyCompactList}\small\item\em Store the current values of the degrees of freedom. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ad19fe0723fe6356776cfbe28e46ea64b}{restore\+\_\+dof\+\_\+values}} ()
\begin{DoxyCompactList}\small\item\em Restore the stored values of the degrees of freedom. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a8eb2fedc3f64411cfbe1627a516447f9}{enable\+\_\+jacobian\+\_\+reuse}} ()
\begin{DoxyCompactList}\small\item\em Enable recycling of Jacobian in Newton iteration (if the linear solver allows it). Useful for linear problems with constant Jacobians or nonlinear problems where you\textquotesingle{}re willing to risk the trade-\/off between faster solve times and degraded Newton convergence rate. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a52489fed5942629199e4f720a7a86549}{disable\+\_\+jacobian\+\_\+reuse}} ()
\begin{DoxyCompactList}\small\item\em Disable recycling of Jacobian in Newton iteration. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a5c864f0dfc4f0ff33e07935944b7b435}{jacobian\+\_\+reuse\+\_\+is\+\_\+enabled}} ()
\begin{DoxyCompactList}\small\item\em Is recycling of Jacobian in Newton iteration enabled? \end{DoxyCompactList}\item 
bool \& \mbox{\hyperlink{classoomph_1_1Problem_a438bf1c7aafffda56f2acb34ba027fdb}{use\+\_\+predictor\+\_\+values\+\_\+as\+\_\+initial\+\_\+guess}} ()
\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a62a989ae9a9169b9d905f844db59787f}{newton\+\_\+solve}} ()
\begin{DoxyCompactList}\small\item\em Use Newton method to solve the problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ac7c7711978f7c02becb4005414f945be}{enable\+\_\+globally\+\_\+convergent\+\_\+newton\+\_\+method}} ()
\begin{DoxyCompactList}\small\item\em enable globally convergent Newton method \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a927d35230db6fc5021b68eadaedac9a6}{disable\+\_\+globally\+\_\+convergent\+\_\+newton\+\_\+method}} ()
\begin{DoxyCompactList}\small\item\em disable globally convergent Newton method \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a4a5a30c124a14f32368f9607b7c8bf34}{newton\+\_\+solve}} (unsigned const \&max\+\_\+adapt)
\begin{DoxyCompactList}\small\item\em Adaptive Newton solve\+: up to max\+\_\+adapt adaptations of all refineable submeshes are performed to achieve the the error targets specified in the refineable submeshes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a6de9b126bf5c8fce5d8e9602fa151090}{steady\+\_\+newton\+\_\+solve}} (unsigned const \&max\+\_\+adapt=0)
\begin{DoxyCompactList}\small\item\em Solve a steady problem using adaptive Newton\textquotesingle{}s method, but in the context of an overall unstady problem, perhaps to determine an initial condition. This is achieved by setting the weights in the timesteppers to be zero which has the effect of rendering them steady timesteppers. The optional argument max\+\_\+adapt specifies the max. number of adaptations of all refineable submeshes are performed to achieve the the error targets specified in the refineable submeshes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a4ac828f337a2d4e77e566ff95d01bad0}{copy}} (\mbox{\hyperlink{classoomph_1_1Problem}{Problem}} $\ast$orig\+\_\+problem\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Copy \mbox{\hyperlink{classoomph_1_1Data}{Data}} values, nodal positions etc from specified problem. Note\+: This is not a copy constructor. We assume that the current and the \char`\"{}original\char`\"{} problem have both been created by calling the same problem constructor so that all \mbox{\hyperlink{classoomph_1_1Data}{Data}} objects, time steppers etc. in the two problems are completely independent. This function copies the nodal, internal and global values, and the time parameters from the original problem into \char`\"{}this\char`\"{} one. This functionality is required, e.\+g. for multigrid computations. \end{DoxyCompactList}\item 
virtual \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_a78ac2b1d2483f49198203e192d3b2871}{make\+\_\+copy}} ()
\begin{DoxyCompactList}\small\item\em Make and return a pointer to the copy of the problem. A virtual function that must be filled in by the user is they wish to perform adaptive refinement in bifurcation tracking or in multigrid problems. ALH\+: WILL NOT BE NECESSARY IN BIFURCATION TRACKING IN LONG RUN... \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_ae27a3057515ddaa60d2ecc684d517e8f}{read}} (std\+::ifstream \&restart\+\_\+file, bool \&unsteady\+\_\+restart)
\begin{DoxyCompactList}\small\item\em Read refinement pattern of all refineable meshes and refine them accordingly, then read all \mbox{\hyperlink{classoomph_1_1Data}{Data}} and nodal position info from file for restart. Return flag to indicate if the restart was from steady or unsteady solution. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a561320c1b8deb3540d260c6c2c5f4fb4}{read}} (std\+::ifstream \&restart\+\_\+file)
\begin{DoxyCompactList}\small\item\em Read refinement pattern of all refineable meshes and refine them accordingly, then read all \mbox{\hyperlink{classoomph_1_1Data}{Data}} and nodal position info from file for restart. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a804050357ac754151b86c2aec4dabc2d}{dump}} (std\+::ofstream \&dump\+\_\+file) const
\begin{DoxyCompactList}\small\item\em Dump refinement pattern of all refineable meshes and all generic \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} data to file for restart. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_af94771cdd9de79c17c9cf168f4a67a92}{dump}} (const std\+::string \&dump\+\_\+file\+\_\+name) const
\begin{DoxyCompactList}\small\item\em Dump refinement pattern of all refineable meshes and all generic \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} data to file for restart. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ad5c302721bf6699ecf8c8760e49d47d8}{get\+\_\+all\+\_\+halo\+\_\+data}} (std\+::map$<$ unsigned, double $\ast$ $>$ \&map\+\_\+of\+\_\+halo\+\_\+data)
\begin{DoxyCompactList}\small\item\em Get pointers to all possible halo data indexed by global equation number in a map. \end{DoxyCompactList}\item 
long \mbox{\hyperlink{classoomph_1_1Problem_a9a9ce9ee869ff79ee5596e434309f379}{synchronise\+\_\+eqn\+\_\+numbers}} (const bool \&assign\+\_\+local\+\_\+eqn\+\_\+numbers=true)
\begin{DoxyCompactList}\small\item\em Classify any non-\/classified nodes into halo/haloed and synchronise equation numbers. Return the total number of degrees of freedom in the overall problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a1ccef4e26a7788424780da7555cdc772}{synchronise\+\_\+dofs}} (const bool \&do\+\_\+halos, const bool \&do\+\_\+external\+\_\+halos)
\begin{DoxyCompactList}\small\item\em Synchronise the degrees of freedom by overwriting the haloed values with their non-\/halo counterparts held on other processors. Bools control if we deal with data associated with external halo/ed elements/nodes or the \char`\"{}normal\char`\"{} halo/ed ones. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a5d9a3ba5696a7bcd275223ff16b7392e}{synchronise\+\_\+all\+\_\+dofs}} ()
\begin{DoxyCompactList}\small\item\em Perform all required synchronisation in solvers. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a93dde63729e7cd332edc1f8904a80649}{check\+\_\+halo\+\_\+schemes}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Check the halo/haloed node/element schemes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a8dd5cb241ce6218fb476931e0879d7c8}{check\+\_\+halo\+\_\+schemes}} ()
\begin{DoxyCompactList}\small\item\em Check the halo/haloed node/element schemes. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \mbox{\hyperlink{classoomph_1_1Problem_aa35e1adc0fdf14b217c7b608eb9cf20b}{distribute}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&element\+\_\+partition, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info, const bool \&report\+\_\+stats=false)
\begin{DoxyCompactList}\small\item\em Distribute the problem and doc, using the specified partition; returns a vector which details the partitioning. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \mbox{\hyperlink{classoomph_1_1Problem_a9bab7c41bf5d6d053259ff10920d7303}{distribute}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info, const bool \&report\+\_\+stats=false)
\begin{DoxyCompactList}\small\item\em Distribute the problem; returns a vector which details the partitioning. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \mbox{\hyperlink{classoomph_1_1Problem_aa35f7ff2b0075cfd4dda519858a65d6c}{distribute}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&element\+\_\+partition, const bool \&report\+\_\+stats=false)
\begin{DoxyCompactList}\small\item\em Distribute the problem using the specified partition; returns a vector which details the partitioning. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \mbox{\hyperlink{classoomph_1_1Problem_af0365ddbe425b730ece6a575db1cd7dd}{distribute}} (const bool \&report\+\_\+stats=false)
\begin{DoxyCompactList}\small\item\em Distribute the problem; returns a vector which details the partitioning. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_ad29fc4bc4d4bead472059765fbbd3b11}{partition\+\_\+global\+\_\+mesh}} (\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$\&global\+\_\+mesh\+\_\+pt, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&element\+\_\+domain, const bool \&report\+\_\+stats=false)
\begin{DoxyCompactList}\small\item\em Partition the global mesh, return vector specifying the processor number for each element. Virtual so that it can be overloaded by any user; the default is to use \mbox{\hyperlink{namespaceoomph_1_1METIS}{METIS}} to perform the partitioning (with a bit of cleaning up afterwards to sort out \char`\"{}special cases\char`\"{}). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a8c5982a9323392e31a166e23a0c7f0a3}{prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info, const bool \&report\+\_\+stats)
\begin{DoxyCompactList}\small\item\em (Irreversibly) prune halo(ed) elements and nodes, usually after another round of refinement, to get rid of excessively wide halo layers. Note that the current mesh will be now regarded as the base mesh and no unrefinement relative to it will be possible once this function has been called. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a977f74f132157959d30e82cfcad41a97}{prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes}} (const bool \&report\+\_\+stats=false)
\begin{DoxyCompactList}\small\item\em (Irreversibly) prune halo(ed) elements and nodes, usually after another round of refinement, to get rid of excessively wide halo layers. Note that the current mesh will be now regarded as the base mesh and no unrefinement relative to it will be possible once this function has been called. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_aa44439175e6899a1a6c125f08b786301}{problem\+\_\+has\+\_\+been\+\_\+distributed}} ()
\begin{DoxyCompactList}\small\item\em Access to Problem\+\_\+has\+\_\+been\+\_\+distributed flag. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ab8eb3782046c64ea0e46205917440452}{delete\+\_\+all\+\_\+external\+\_\+storage}} ()
\begin{DoxyCompactList}\small\item\em Wrapper function to delete external storage for each submesh of the problem. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_abbcf4965b6052758e49cf511947fd3f0}{symmetrise\+\_\+eigenfunction\+\_\+for\+\_\+adaptive\+\_\+pitchfork\+\_\+tracking}} ()
\begin{DoxyCompactList}\small\item\em Virtual function that is used to symmetrise the problem so that the current solution exactly satisfies any symmetries within the system. Used when adpativly solving pitchfork detection problems when small asymmetries in the coarse solution can be magnified leading to very inaccurate answers on the fine mesh. This is always problem-\/specific and must be filled in by the user The default issues a warning. \end{DoxyCompactList}\item 
double $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_a3cf79b3067d1d794062ebb27e414dea9}{bifurcation\+\_\+parameter\+\_\+pt}} () const
\begin{DoxyCompactList}\small\item\em Return pointer to the parameter that is used in the bifurcation detection. If we are not tracking a bifurcation then an error will be thrown by the \mbox{\hyperlink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a85b240c17750bdc32afafee35b50225a}{get\+\_\+bifurcation\+\_\+eigenfunction}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&eigenfunction)
\begin{DoxyCompactList}\small\item\em Return the eigenfunction calculated as part of a bifurcation tracking process. If we are not tracking a bifurcation then an error will be thrown by the \mbox{\hyperlink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_acf20e92281911dfbb423ea82542c0485}{activate\+\_\+fold\+\_\+tracking}} (double $\ast$const \&parameter\+\_\+pt, const bool \&block\+\_\+solve=true)
\begin{DoxyCompactList}\small\item\em Turn on fold tracking using the augmented system specified in the \mbox{\hyperlink{classoomph_1_1FoldHandler}{Fold\+Handler}} class. After a call to this function subsequent calls of the standard solution methods will converge to a fold (limit) point at a particular value of the variable addressed by parameter\+\_\+pt. The system may not converge if the initial guess is sufficiently poor or, alternatively, if finite differencing is used to calculate the jacobian matrix in the elements. If the boolean flag block\+\_\+solver is true (the default) then a block factorisation is used to solve the augmented system which is both faster and uses less memory. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a95359def89a0ee3d3df8976ab54c6591}{activate\+\_\+bifurcation\+\_\+tracking}} (double $\ast$const \&parameter\+\_\+pt, const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&eigenvector, const bool \&block\+\_\+solve=true)
\begin{DoxyCompactList}\small\item\em Activate generic bifurcation tracking for a single (real) eigenvalue where the initial guess for the eigenvector can be specified. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a4610ef4c4f4d7c1d7001fabf074c930c}{activate\+\_\+bifurcation\+\_\+tracking}} (double $\ast$const \&parameter\+\_\+pt, const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&eigenvector, const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&normalisation, const bool \&block\+\_\+solve=true)
\begin{DoxyCompactList}\small\item\em Activate generic bifurcation tracking for a single (real) eigenvalue where the initial guess for the eigenvector can be specified and the normalisation condition can also be specified. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a7f5eb1f88a957cb3d8a11b558002d484}{activate\+\_\+pitchfork\+\_\+tracking}} (double $\ast$const \&parameter\+\_\+pt, const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&symmetry\+\_\+vector, const bool \&block\+\_\+solve=true)
\begin{DoxyCompactList}\small\item\em Turn on pitchfork tracking using the augmented system specified in the \mbox{\hyperlink{classoomph_1_1PitchForkHandler}{Pitch\+Fork\+Handler}} class. After a call to this function subsequent calls of the standard solution methods will converge to a pitchfork bifurcation at a particular value of the variable addressed by parameter\+\_\+pt. The symmetry that is to be broken must be specified by supplying a symmetry\+\_\+vector(ndof). The easiest way to determine such a vector is to solve the associated eigenproblem $ Jx = \lambda M x$ and pass in the eigenvector. This is not always necessary however, if the symmetry is easy to construct. The system may not converge if the initial guess is sufficiently poor or, alternatively, if finite differencing is used to calculate the jacobian matrix in the elements. If the boolean flag block\+\_\+solver is true (the default) then a block factorisation is used to solve the augmented system which is both faster and requires less memory. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ac5966d1a184e722195f96d797b52e64c}{activate\+\_\+hopf\+\_\+tracking}} (double $\ast$const \&parameter\+\_\+pt, const bool \&block\+\_\+solve=true)
\begin{DoxyCompactList}\small\item\em Turn on Hopf bifurcation tracking using the augmented system specified in the \mbox{\hyperlink{classoomph_1_1HopfHandler}{Hopf\+Handler}} class. After a call to this function subsequent calls of the standard solution methods will converge to a Hopf bifuraction at a particular value of the variable addressed by parameter\+\_\+pt. The system may not converge if the initial guess is sufficiently poor or, alternatively, if finite differencing is used to calculate the jacobian matrix in the elements. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_aa0e2d0e105da6b676262d75481bcc8e3}{activate\+\_\+hopf\+\_\+tracking}} (double $\ast$const \&parameter\+\_\+pt, const double \&omega, const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&null\+\_\+real, const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&null\+\_\+imag, const bool \&block\+\_\+solve=true)
\begin{DoxyCompactList}\small\item\em Turn on Hopf bifurcation tracking using the augmented system specified in the \mbox{\hyperlink{classoomph_1_1HopfHandler}{Hopf\+Handler}} class. After a call to this function subsequent calls of the standard solution methods will converge to a Hopf bifuraction at a particular value of the variable addressed by parameter\+\_\+pt. The system may not converge if the initial guess is sufficiently poor or, alternatively, if finite differencing is used to calculate the jacobian matrix in the elements. This interface allows specification of an inital guess for the frequency and real and imaginary parts of the null vector, such as might be obtained from an eigensolve. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ac5b47ae12ed6445e52c65596dfa97c6d}{deactivate\+\_\+bifurcation\+\_\+tracking}} ()
\begin{DoxyCompactList}\small\item\em Deactivate all bifuraction tracking, by reseting the assembly handler to the default. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_aecb590c73e64b0a85f7bec0053e2c51d}{reset\+\_\+assembly\+\_\+handler\+\_\+to\+\_\+default}} ()
\begin{DoxyCompactList}\small\item\em Reset the system to the standard non-\/augemented state. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_ad8414efbd8099d3e6cf3f4daea06cc8f}{arc\+\_\+length\+\_\+step\+\_\+solve}} (double $\ast$const \&parameter\+\_\+pt, const double \&ds, const unsigned \&max\+\_\+adapt=0)
\begin{DoxyCompactList}\small\item\em Solve a steady problem using arc-\/length continuation, when the parameter that becomes a variable corresponding to the arc-\/length constraint equation is an external double\+: parameter\+\_\+pt is a pointer to that double, ds is the desired arc\+\_\+length and max\+\_\+adapt is the maximum number of spatial adaptations (default zero, no adaptation). \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_aefb723728ed26abe410b61ec38d42688}{arc\+\_\+length\+\_\+step\+\_\+solve}} (\mbox{\hyperlink{classoomph_1_1Data}{Data}} $\ast$const \&data\+\_\+pt, const unsigned \&data\+\_\+index, const double \&ds, const unsigned \&max\+\_\+adapt=0)
\begin{DoxyCompactList}\small\item\em Solve a steady problem using arc-\/length continuation, when the variable corresponding to the arc-\/length constraint equation is already stored in data used in the problem\+: data\+\_\+pt is a pointer to the appropriate data object, data\+\_\+index is the index of the value that will be traded for the constriant, ds is the desired arc\+\_\+length and max\+\_\+adapt is the maximum number of spatial adaptations (default zero, no adaptation). Note that the value must be pinned in order for this formulation to work. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a6477df6e8184dc78e9d9ff82c7627cef}{reset\+\_\+arc\+\_\+length\+\_\+parameters}} ()
\begin{DoxyCompactList}\small\item\em Reset the \char`\"{}internal\char`\"{} arc-\/length continuation parameters, so as to allow continuation in another parameter. N.\+B. The parameters that are reset are the \char`\"{}minimum\char`\"{} that are required, others should perhaps be reset, depending upon the application. \end{DoxyCompactList}\item 
int \& \mbox{\hyperlink{classoomph_1_1Problem_a797cb28b5fffe976fc7541421eb423a1}{sign\+\_\+of\+\_\+jacobian}} ()
\begin{DoxyCompactList}\small\item\em Access function for the sign of the global jacobian matrix. This will be set by the linear solver, if possible (direct solver). If not alternative methods must be used to detect bifurcations (solving the associated eigenproblem). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ab8b74c5b1499b2d712a8545cccbd97c2}{explicit\+\_\+timestep}} (const double \&dt, const bool \&shift\+\_\+values=true)
\begin{DoxyCompactList}\small\item\em Take an explicit timestep of size dt and optionally shift any stored values of the time history. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_aef22157aadc15a512cca93e4c423ff73}{unsteady\+\_\+newton\+\_\+solve}} (const double \&dt)
\begin{DoxyCompactList}\small\item\em Advance time by dt and solve by Newton\textquotesingle{}s method. This version always shifts time values. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_abf8b8c9ee09df0ba8934382740a588de}{unsteady\+\_\+newton\+\_\+solve}} (const double \&dt, const bool \&shift\+\_\+values)
\begin{DoxyCompactList}\small\item\em Advance time by dt and solve the system, using Newton\textquotesingle{}s method. The boolean flag is used to control whether the time values should be shifted. If it is true the current data values will be shifted (copied to the locations where there are stored as previous timesteps) before solution. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_af26bd71c24ba99c9391d6e932b68e5e8}{unsteady\+\_\+newton\+\_\+solve}} (const double \&dt, const unsigned \&max\+\_\+adapt, const bool \&first, const bool \&shift=true)
\begin{DoxyCompactList}\small\item\em Unsteady adaptive Newton solve\+: up to max\+\_\+adapt adaptations of all refineable submeshes are performed to achieve the the error targets specified in the refineable submeshes. If first==true, the initial conditions are re-\/assigned after the mesh adaptations. Shifting of time can be suppressed by overwriting the default value of shift (true). \mbox{[}Shifting must be done if first\+\_\+timestep==true because we\textquotesingle{}re constantly re-\/assigning the initial conditions; if first\+\_\+timestep==true and shift==false shifting is performed anyway and a warning is issued. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_a7561d4f82e1fa625210c58a78294a301}{doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve}} (const double \&dt, const double \&epsilon, const unsigned \&max\+\_\+adapt, const bool \&first, const bool \&shift=true)
\begin{DoxyCompactList}\small\item\em Unsteady \char`\"{}doubly\char`\"{} adaptive Newton solve\+: Does temporal adaptation first, i.\+e. we try to do a timestep with an increment of dt, and adjusting dt until the solution on the given mesh satisfies the temporal error measure with tolerance epsilon. Following this, we do up to max\+\_\+adapt spatial adaptions (without re-\/examining the temporal error). If first==true, the initial conditions are re-\/assigned after the mesh adaptations. Shifting of time can be suppressed by overwriting the default value of shift (true). \mbox{[}Shifting must be done if first\+\_\+timestep==true because we\textquotesingle{}re constantly re-\/assigning the initial conditions; if first\+\_\+timestep==true and shift==false shifting is performed anyway and a warning is issued. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_ae6c326bce8647c2a59cf62288ce4902e}{doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve}} (const double \&dt, const double \&epsilon, const unsigned \&max\+\_\+adapt, const unsigned \&suppress\+\_\+resolve\+\_\+after\+\_\+spatial\+\_\+adapt\+\_\+flag, const bool \&first, const bool \&shift=true)
\begin{DoxyCompactList}\small\item\em Unsteady \char`\"{}doubly\char`\"{} adaptive Newton solve\+: Does temporal adaptation first, i.\+e. we try to do a timestep with an increment of dt, and adjusting dt until the solution on the given mesh satisfies the temporal error measure with tolerance epsilon. Following this, we do up to max\+\_\+adapt spatial adaptions (without re-\/examining the temporal error). If first==true, the initial conditions are re-\/assigned after the mesh adaptations. Shifting of time can be suppressed by overwriting the default value of shift (true). \mbox{[}Shifting must be done if first\+\_\+timestep==true because we\textquotesingle{}re constantly re-\/assigning the initial conditions; if first\+\_\+timestep==true and shift==false shifting is performed anyway and a warning is issued. Pseudo-\/\+Boolean flag suppress\+\_\+resolve\+\_\+after\+\_\+spatial\+\_\+adapt \mbox{[}0\+: false; 1\+: true\mbox{]} does what it says.\mbox{]}. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_abf6681f21f614ed7f15cc675ed6f692a}{adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve}} (const double \&dt\+\_\+desired, const double \&epsilon)
\begin{DoxyCompactList}\small\item\em Attempt to advance timestep by dt\+\_\+desired. If the solution fails the timestep will be halved until convergence is achieved, or the timestep falls below Newton\+Solver\+Parameters\+::\+Minimum\+\_\+time\+\_\+step. The error control parameter epsilon represents the (approximate) desired magnitude of the global error at each timestep. The routine returns a double that is the suggested next timestep and should be passed as dt\+\_\+desired the next time the routine is called. This version always shifts the time values. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_a3f5bde6d7fa8972e01a20c522b5fb2ef}{adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve}} (const double \&dt\+\_\+desired, const double \&epsilon, const bool \&shift\+\_\+values)
\begin{DoxyCompactList}\small\item\em Attempt to advance timestep by dt\+\_\+desired. If the solution fails the timestep will be halved until convergence is achieved, or the timestep falls below Newton\+Solver\+Parameters\+::\+Minimum\+\_\+time\+\_\+step. The error control parameter epsilon represents the (approximate) desired magnitude of the global error at each timestep. The routine returns a double that is the suggested next timestep and should be passed as dt\+\_\+desired the next time the routine is called. Once again the boolean flag, shift\+\_\+values, is used to control whether the time values are shifted. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a10e5dc4d944dfb2b141918e18e5e3de8}{assign\+\_\+initial\+\_\+values\+\_\+impulsive}} ()
\begin{DoxyCompactList}\small\item\em Initialise data and nodal positions to simulate impulsive start from initial configuration/solution. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a296bd0ba13bd51a96bb7057845e5a800}{assign\+\_\+initial\+\_\+values\+\_\+impulsive}} (const double \&dt)
\begin{DoxyCompactList}\small\item\em Initialise data and nodal positions to simulate an impulsive start and also set the initial and previous values of dt. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a474deeb0947b767566fa1d4630ad8b4a}{calculate\+\_\+predictions}} ()
\begin{DoxyCompactList}\small\item\em Calculate predictions. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a6a9e63d6e585eabe4e3e551f01f658ae}{enable\+\_\+mass\+\_\+matrix\+\_\+reuse}} ()
\begin{DoxyCompactList}\small\item\em Enable recycling of the mass matrix in explicit timestepping schemes. Useful for timestepping on fixed meshes when you want to avoid the linear solve phase. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a399ca4ccf551f9bf5621f9855e899af6}{disable\+\_\+mass\+\_\+matrix\+\_\+reuse}} ()
\begin{DoxyCompactList}\small\item\em Turn off recyling of the mass matrix in explicit timestepping schemes. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_afa46c693258868c126503cce3a663a85}{mass\+\_\+matrix\+\_\+reuse\+\_\+is\+\_\+enabled}} ()
\begin{DoxyCompactList}\small\item\em Return whether the mass matrix is being reused. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a181fa92838f77bd6b12b531dca222c41}{refine\+\_\+uniformly}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nrefine\+\_\+for\+\_\+mesh)
\begin{DoxyCompactList}\small\item\em Refine refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a14ca1d18e9aa569a6417c45eef70d3ff}{refine\+\_\+uniformly}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nrefine\+\_\+for\+\_\+mesh, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Refine refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem; doc refinement process. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a3930fc0977bdc33f52100e53f5d878d7}{refine\+\_\+uniformly\+\_\+and\+\_\+prune}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nrefine\+\_\+for\+\_\+mesh)
\begin{DoxyCompactList}\small\item\em Refine refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem. Prune after refinements. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_adea5168244acebb539fa29e36182ced3}{refine\+\_\+uniformly\+\_\+and\+\_\+prune}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nrefine\+\_\+for\+\_\+mesh, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Refine refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem; doc refinement process. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ae4ccf79fde59556d93af947618b6c80b}{refine\+\_\+uniformly}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Refine (all) refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ac0495df29dde90577e4702fcac496684}{refine\+\_\+uniformly\+\_\+and\+\_\+prune}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Refine (all) refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ade208b7d7d8e866d5ba896f03edb1f9a}{refine\+\_\+uniformly}} ()
\begin{DoxyCompactList}\small\item\em Refine (all) refineable (sub)mesh(es) uniformly and rebuild problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a74d1904dd72eaf71c015470a23caef5f}{refine\+\_\+uniformly}} (const unsigned \&i\+\_\+mesh, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Do uniform refinement for submesh i\+\_\+mesh with documentation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_afae401b74b58d6312da32f153b78047d}{refine\+\_\+uniformly}} (const unsigned \&i\+\_\+mesh)
\begin{DoxyCompactList}\small\item\em Do uniform refinement for submesh i\+\_\+mesh without documentation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a3aaea4b1be43f5d4bb187a8c6d3ca16f}{p\+\_\+refine\+\_\+uniformly}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nrefine\+\_\+for\+\_\+mesh)
\begin{DoxyCompactList}\small\item\em p-\/refine p-\/refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a0a980d9659db60b113b6d4e7431594b7}{p\+\_\+refine\+\_\+uniformly}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nrefine\+\_\+for\+\_\+mesh, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em p-\/refine p-\/refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem; doc refinement process \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a5155b2d5436a95b1ee27f914b4eb8f08}{p\+\_\+refine\+\_\+uniformly\+\_\+and\+\_\+prune}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nrefine\+\_\+for\+\_\+mesh)
\begin{DoxyCompactList}\small\item\em p-\/refine p-\/refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem. Prune after refinements \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_aabfa653ef203edf44cf9b6cf558865e1}{p\+\_\+refine\+\_\+uniformly\+\_\+and\+\_\+prune}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nrefine\+\_\+for\+\_\+mesh, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em p-\/refine p-\/refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem; doc refinement process \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a355caf4c06c3b8b5d399115048453921}{p\+\_\+refine\+\_\+uniformly}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em p-\/refine (all) p-\/refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a80ff24a4fc923660f2aabfaa763822bf}{p\+\_\+refine\+\_\+uniformly\+\_\+and\+\_\+prune}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em p-\/refine (all) p-\/refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ada439afd4d195644e53d6bdbc4b00587}{p\+\_\+refine\+\_\+uniformly}} ()
\begin{DoxyCompactList}\small\item\em p-\/refine (all) p-\/refineable (sub)mesh(es) uniformly and rebuild problem \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a04fed27f341b9eb68b5fb3e4673f26f9}{p\+\_\+refine\+\_\+uniformly}} (const unsigned \&i\+\_\+mesh, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Do uniform p-\/refinement for submesh i\+\_\+mesh with documentation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a33dbab01dfa53e4d005818a2940085b0}{p\+\_\+refine\+\_\+uniformly}} (const unsigned \&i\+\_\+mesh)
\begin{DoxyCompactList}\small\item\em Do uniform p-\/refinement for submesh i\+\_\+mesh without documentation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a88bfce034f5b054e78a1c1a15d196aeb}{refine\+\_\+selected\+\_\+elements}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&elements\+\_\+to\+\_\+be\+\_\+refined)
\begin{DoxyCompactList}\small\item\em Refine (one and only!) mesh by splitting the elements identified by their numbers relative to the problems\textquotesingle{} only mesh, then rebuild the problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_abd2274dbc96e0ae3caf20573152d19e7}{refine\+\_\+selected\+\_\+elements}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$ $>$ \&elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Refine (one and only!) mesh by splitting the elements identified by their pointers, then rebuild the problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_af2bd42a9612a31041b9d607340c6d68c}{refine\+\_\+selected\+\_\+elements}} (const unsigned \&i\+\_\+mesh, const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&elements\+\_\+to\+\_\+be\+\_\+refined)
\begin{DoxyCompactList}\small\item\em Refine specified submesh by splitting the elements identified by their numbers relative to the submesh, then rebuild the problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a77b480e2299c8526b27b09fa45ac20a9}{refine\+\_\+selected\+\_\+elements}} (const unsigned \&i\+\_\+mesh, const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$ $>$ \&elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Refine specified submesh by splitting the elements identified by their pointers, then rebuild the problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a85ab21d4aa86d5f732b1c1a640186386}{refine\+\_\+selected\+\_\+elements}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$$>$ \&elements\+\_\+to\+\_\+be\+\_\+refined)
\begin{DoxyCompactList}\small\item\em Refine all submeshes by splitting the elements identified by their numbers relative to each submesh in a \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of Vectors, then rebuild the problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a91e9f1c3973b5f7a701117a6e145cee9}{refine\+\_\+selected\+\_\+elements}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$ $>$$>$ \&elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Refine all submeshes by splitting the elements identified by their pointers within each submesh in a \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of Vectors, then rebuild the problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a2042cdd88af58eedc66bfaf29b370ff1}{p\+\_\+refine\+\_\+selected\+\_\+elements}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&elements\+\_\+to\+\_\+be\+\_\+refined)
\begin{DoxyCompactList}\small\item\em p-\/refine (one and only!) mesh by refining the elements identified by their numbers relative to the problems\textquotesingle{} only mesh, then rebuild the problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_afd17da2aa90d68c4fb5120c90b2435d9}{p\+\_\+refine\+\_\+selected\+\_\+elements}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1PRefineableElement}{PRefineable\+Element}} $\ast$ $>$ \&elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt)
\begin{DoxyCompactList}\small\item\em p-\/refine (one and only!) mesh by refining the elements identified by their pointers, then rebuild the problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a86f7b013945049548f86377e489e23f1}{p\+\_\+refine\+\_\+selected\+\_\+elements}} (const unsigned \&i\+\_\+mesh, const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&elements\+\_\+to\+\_\+be\+\_\+refined)
\begin{DoxyCompactList}\small\item\em p-\/refine specified submesh by refining the elements identified by their numbers relative to the submesh, then rebuild the problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a044b3cb5ffc2953c1990bd602567b99a}{p\+\_\+refine\+\_\+selected\+\_\+elements}} (const unsigned \&i\+\_\+mesh, const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1PRefineableElement}{PRefineable\+Element}} $\ast$ $>$ \&elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt)
\begin{DoxyCompactList}\small\item\em p-\/refine specified submesh by refining the elements identified by their pointers, then rebuild the problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_aef2b3bac619ee8270dfcd5f9f334501c}{p\+\_\+refine\+\_\+selected\+\_\+elements}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$$>$ \&elements\+\_\+to\+\_\+be\+\_\+refined)
\begin{DoxyCompactList}\small\item\em p-\/refine all submeshes by refining the elements identified by their numbers relative to each submesh in a \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of Vectors, then rebuild the problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_aa7af48e91e943fb43fce31aa5bdeb505}{p\+\_\+refine\+\_\+selected\+\_\+elements}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1PRefineableElement}{PRefineable\+Element}} $\ast$ $>$$>$ \&elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt)
\begin{DoxyCompactList}\small\item\em p-\/refine all submeshes by refining the elements identified by their pointers within each submesh in a \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of Vectors, then rebuild the problem. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_a10dae99dec2f8202887f4e49e175f39c}{unrefine\+\_\+uniformly}} ()
\begin{DoxyCompactList}\small\item\em Refine (all) refineable (sub)mesh(es) uniformly and rebuild problem. Return 0 for success, 1 for failure (if unrefinement has reached the coarsest permitted level) \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_aadd2996d4046e5a6176c92f4abc899d5}{unrefine\+\_\+uniformly}} (const unsigned \&i\+\_\+mesh)
\begin{DoxyCompactList}\small\item\em Do uniform refinement for submesh i\+\_\+mesh without documentation. Return 0 for success, 1 for failure (if unrefinement has reached the coarsest permitted level) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a21d8f0ff6813b09f35acbc7a76232397}{p\+\_\+unrefine\+\_\+uniformly}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em p-\/unrefine (all) p-\/refineable (sub)mesh(es) uniformly and rebuild problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a706a2845212ece5535260cca6301653d}{p\+\_\+unrefine\+\_\+uniformly}} (const unsigned \&i\+\_\+mesh, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Do uniform p-\/unrefinement for submesh i\+\_\+mesh without documentation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_afc4492ec2686c70467cb0cdb4638a45f}{adapt}} (unsigned \&n\+\_\+refined, unsigned \&n\+\_\+unrefined)
\begin{DoxyCompactList}\small\item\em Adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on their own error estimates and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. Return \# of refined/unrefined elements. On return from this function, \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} can immediately be solved again. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a0b9e09ddfa2411f14fc723c3207decd1}{adapt}} ()
\begin{DoxyCompactList}\small\item\em Adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on their own error estimates and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. On return from this function, \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} can immediately be solved again. \mbox{[}Argument-\/free wrapper\mbox{]}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a1303b2fde2fe84b71519cadabc18f868}{p\+\_\+adapt}} (unsigned \&n\+\_\+refined, unsigned \&n\+\_\+unrefined)
\begin{DoxyCompactList}\small\item\em p-\/adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on their own error estimates and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. Return \# of refined/unrefined elements. On return from this function, \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} can immediately be solved again. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_aaad4443f87f3f3affe53fa9160802e7c}{p\+\_\+adapt}} ()
\begin{DoxyCompactList}\small\item\em p-\/adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on their own error estimates and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. On return from this function, \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} can immediately be solved again. \mbox{[}Argument-\/free wrapper\mbox{]} \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_af5e7b874e120c2a3a89e227ad48e14c9}{adapt\+\_\+based\+\_\+on\+\_\+error\+\_\+estimates}} (unsigned \&n\+\_\+refined, unsigned \&n\+\_\+unrefined, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$$>$ \&elemental\+\_\+error)
\begin{DoxyCompactList}\small\item\em Adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on the error estimates in elemental\+\_\+error and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. Return \# of refined/unrefined elements. On return from this function, \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} can immediately be solved again. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a3809e4ec25082a5b8686bd6fa1c61fce}{adapt\+\_\+based\+\_\+on\+\_\+error\+\_\+estimates}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$$>$ \&elemental\+\_\+error)
\begin{DoxyCompactList}\small\item\em Adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on the error estimates in elemental\+\_\+error and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. Return \# of refined/unrefined elements. On return from this function, \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} can immediately be solved again. \mbox{[}Wrapper without n\+\_\+refined and n\+\_\+unrefined arguments\mbox{]}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_af0d29f621a3be66430960538c7c24a78}{get\+\_\+all\+\_\+error\+\_\+estimates}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$$>$ \&elemental\+\_\+error)
\begin{DoxyCompactList}\small\item\em Return the error estimates computed by (all) refineable (sub)mesh(es) in the elemental\+\_\+error structure, which consists of a vector of vectors of elemental errors, one vector for each (sub)mesh. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_af2a77519885ccb13e4644c89b19c37a7}{doc\+\_\+errors}} (\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)
\begin{DoxyCompactList}\small\item\em Get max and min error for all elements in submeshes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_af2a9dfdb7b4f95bb941d48411f955f55}{doc\+\_\+errors}} ()
\begin{DoxyCompactList}\small\item\em Get max and min error for all elements in submeshes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a3226bf49118c8a4f02dbe01d22428f20}{enable\+\_\+info\+\_\+in\+\_\+newton\+\_\+solve}} ()
\begin{DoxyCompactList}\small\item\em Enable the output of information when in the newton solver (Default) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_af00e3623681347439fe3dac650423bbe}{disable\+\_\+info\+\_\+in\+\_\+newton\+\_\+solve}} ()
\begin{DoxyCompactList}\small\item\em Disable the output of information when in the newton solver. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
double \mbox{\hyperlink{classoomph_1_1Problem_aeadae1fc5f49e66223ee09c69a9e506d}{Max\+\_\+permitted\+\_\+error\+\_\+for\+\_\+halo\+\_\+check}}
\begin{DoxyCompactList}\small\item\em Threshold for error throwing in \mbox{\hyperlink{classoomph_1_1Problem_a8dd5cb241ce6218fb476931e0879d7c8}{Problem\+::check\+\_\+halo\+\_\+schemes()}} \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_ab4a3743c23a2d1eed56981484636c958}{Shut\+\_\+up\+\_\+in\+\_\+newton\+\_\+solve}}
\begin{DoxyCompactList}\small\item\em Boolean to indicate if all output is suppressed in \mbox{\hyperlink{classoomph_1_1Problem_a62a989ae9a9169b9d905f844db59787f}{Problem\+::newton\+\_\+solve()}}. Defaults to false. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static bool \mbox{\hyperlink{classoomph_1_1Problem_a223a45fe6b1c80ee0109037b63e162f9}{Suppress\+\_\+warning\+\_\+about\+\_\+actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes}}
\begin{DoxyCompactList}\small\item\em Flag to allow suppression of warning messages re reading in unstructured meshes during restart. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Types}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7}{Assembly\+\_\+method}} \{ \newline
\mbox{\hyperlink{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7aa00e1772bb5ccf1c837a2bad2f240241}{Perform\+\_\+assembly\+\_\+using\+\_\+vectors\+\_\+of\+\_\+pairs}}
, \mbox{\hyperlink{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7a6008d2b6aa449ee405313b49632d18ff}{Perform\+\_\+assembly\+\_\+using\+\_\+two\+\_\+vectors}}
, \mbox{\hyperlink{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7a406ad24599e1a59450acdd09bac1d717}{Perform\+\_\+assembly\+\_\+using\+\_\+maps}}
, \mbox{\hyperlink{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7ad73bb55e4e1f000cfd6930cb8b2a52f8}{Perform\+\_\+assembly\+\_\+using\+\_\+lists}}
, \newline
\mbox{\hyperlink{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7a1383f03857ad8602ba7edef43bd947f5}{Perform\+\_\+assembly\+\_\+using\+\_\+two\+\_\+arrays}}
 \}
\begin{DoxyCompactList}\small\item\em Enumerated flags to determine which sparse assembly method is used. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_a919a5f4752362df6005d24e51b5780e0}{setup\+\_\+element\+\_\+count\+\_\+per\+\_\+dof}} ()
\begin{DoxyCompactList}\small\item\em Function that populates the Element\+\_\+counter\+\_\+per\+\_\+dof vector with the number of elements that contribute to each dof. For example, with linear elements in 1D each dof contains contributions from two elements apart from those on the boundary. Returns the total number of elements in the problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a216679e2a976e0205165bbe7ab558579}{setup\+\_\+dof\+\_\+halo\+\_\+scheme}} ()
\begin{DoxyCompactList}\small\item\em Function that is used to setup the halo scheme. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a072f2894b20672be1a48783684c4a50b}{sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&column\+\_\+or\+\_\+row\+\_\+index, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&row\+\_\+or\+\_\+column\+\_\+start, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&value, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nnz, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&residual, bool compressed\+\_\+row\+\_\+flag)
\begin{DoxyCompactList}\small\item\em Protected helper function that is used to assemble the Jacobian matrix in the case when the storage is row or column compressed. The boolean Flag indicates if we want compressed row format (true) or compressed column. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a0c8d70891f7369bb4bf8412fa1a08ecb}{actions\+\_\+before\+\_\+newton\+\_\+solve}} ()
\begin{DoxyCompactList}\small\item\em Any actions that are to be performed before a complete Newton solve (e.\+g. adjust boundary conditions). CAREFUL\+: This step should (and if the FD-\/based \mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} \mbox{\hyperlink{classoomph_1_1FD__LU}{FD\+\_\+\+LU}} is used, must) only update values that are pinned! \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a033ec7301123deeb7e56d04c38f9f1da}{actions\+\_\+after\+\_\+newton\+\_\+solve}} ()
\begin{DoxyCompactList}\small\item\em Any actions that are to be performed after a complete Newton solve, e.\+g. post processing. CAREFUL\+: This step should (and if the FD-\/based \mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} \mbox{\hyperlink{classoomph_1_1FD__LU}{FD\+\_\+\+LU}} is used, must) only update values that are pinned! \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_ae6ad96ddf5d48b517b89c9a9b879bc4b}{actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check}} ()
\begin{DoxyCompactList}\small\item\em Any actions that are to be performed before the residual is checked in the Newton method, e.\+g. update any boundary conditions that depend upon variables of the problem; update any `dependent' variables; or perform an update of the nodal positions in Spine\+Meshes etc. CAREFUL\+: This step should (and if the FD-\/based \mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} \mbox{\hyperlink{classoomph_1_1FD__LU}{FD\+\_\+\+LU}} is used, must) only update values that are pinned! \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a07fc81781c74b25c8a426ec18295b0d0}{actions\+\_\+before\+\_\+newton\+\_\+step}} ()
\begin{DoxyCompactList}\small\item\em Any actions that are to be performed before each individual Newton step. Most likely to be used for diagnostic purposes to doc the solution during a non-\/converging iteration, say. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_aed8bc6e7b0bb45b86d5b44737b554d50}{actions\+\_\+after\+\_\+newton\+\_\+step}} ()
\begin{DoxyCompactList}\small\item\em Any actions that are to be performed after each individual Newton step. Most likely to be used for diagnostic purposes to doc the solution during a non-\/converging iteration, say. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a4f19896906d2c0274ad6798cd3ac38dc}{actions\+\_\+before\+\_\+implicit\+\_\+timestep}} ()
\begin{DoxyCompactList}\small\item\em Actions that should be performed before each implicit time step. This is needed when one wants to solve a steady problem before timestepping and needs to distinguish between the two cases. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a012692496c968960f4ea27db4e89cc7d}{actions\+\_\+after\+\_\+implicit\+\_\+timestep}} ()
\begin{DoxyCompactList}\small\item\em Actions that should be performed after each implicit time step. This is needed when one wants to solve a steady problem before timestepping and needs to distinguish between the two cases. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a38d914a74e7998ddc74c205884d36d57}{actions\+\_\+after\+\_\+implicit\+\_\+timestep\+\_\+and\+\_\+error\+\_\+estimation}} ()
\begin{DoxyCompactList}\small\item\em Actions that should be performed after each implicit time step. This is needed if your \mbox{\hyperlink{classoomph_1_1Problem_a012692496c968960f4ea27db4e89cc7d}{actions\+\_\+after\+\_\+implicit\+\_\+timestep()}} modify the solution in a way that affects the error estimate. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a6ae06bc0ecba349ebdf76220c1a17546}{actions\+\_\+before\+\_\+explicit\+\_\+timestep}} ()
\begin{DoxyCompactList}\small\item\em Actions that should be performed before each explicit time step. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a51bfd872c45467a65ce977f3753a6d1d}{actions\+\_\+after\+\_\+explicit\+\_\+timestep}} ()
\begin{DoxyCompactList}\small\item\em Actions that should be performed after each explicit time step. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_af10662119a7a0c3a47879fa0d0644452}{actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes}} ()
\begin{DoxyCompactList}\small\item\em Actions that are to be performed before reading in restart data for problems involving unstructured bulk meshes. If the problem contains such meshes we need to strip out any face elements that are attached to them because restart of unstructured meshes re-\/creates their elements and nodes from scratch, leading to dangling pointers from the face elements to the old elements and nodes. This function is virtual and (practically) empty but toggles a flag to indicate that it has been called. This is used to issue a warning, prompting the user to consider overloading it if the problem is found to contain unstructured bulk meshes during restarts. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a498317b3e390eddf2169ab989ee8d6b4}{actions\+\_\+after\+\_\+read\+\_\+unstructured\+\_\+meshes}} ()
\begin{DoxyCompactList}\small\item\em Actions that are to be performed before reading in restart data for problems involving unstructured bulk meshes. Typically used to re-\/attach Face\+Elements, say, that were stripped out in \mbox{\hyperlink{classoomph_1_1Problem_af10662119a7a0c3a47879fa0d0644452}{actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes()}}. This function is virtual and (practically) empty but toggles a flag to indicate that it has been called. This is used to issue a warning, prompting the user to consider overloading it if the problem is found to contain unstructured bulk meshes during restarts. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a1d1280f442f9352a614bada21324456d}{actions\+\_\+before\+\_\+distribute}} ()
\begin{DoxyCompactList}\small\item\em Actions to be performed before a (mesh) distribution. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a4d3e3bd312518ca5afef94e169f81c39}{actions\+\_\+after\+\_\+distribute}} ()
\begin{DoxyCompactList}\small\item\em Actions to be performed after a (mesh) distribution. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a1e90bbe5d279295b97ae704487259bcc}{actions\+\_\+after\+\_\+change\+\_\+in\+\_\+global\+\_\+parameter}} (double $\ast$const \&parameter\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Actions that are to be performed when the global parameter addressed by parameter\+\_\+pt has been changed in the function \mbox{\hyperlink{classoomph_1_1Problem_af4d959a47ef6a8d50b394a6761dfab5a}{get\+\_\+derivative\+\_\+wrt\+\_\+global\+\_\+parameter()}} The default is to call \mbox{\hyperlink{classoomph_1_1Problem_a0c8d70891f7369bb4bf8412fa1a08ecb}{actions\+\_\+before\+\_\+newton\+\_\+solve()}}, \mbox{\hyperlink{classoomph_1_1Problem_ae6ad96ddf5d48b517b89c9a9b879bc4b}{actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()}} and \mbox{\hyperlink{classoomph_1_1Problem_a033ec7301123deeb7e56d04c38f9f1da}{actions\+\_\+after\+\_\+newton\+\_\+solve()}}. This could be amazingly inefficient in certain problems and should be overloaded in such cases. An example would be when a remesh is required in general, but the global parameter does not affect the mesh directly. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a5f08629e3c9c72b441ec7f19f175b2c7}{actions\+\_\+after\+\_\+change\+\_\+in\+\_\+bifurcation\+\_\+parameter}} ()
\begin{DoxyCompactList}\small\item\em Actions that are to be performed after a change in the parameter that is being varied as part of the solution of a bifurcation detection problem. The default is to call \mbox{\hyperlink{classoomph_1_1Problem_a0c8d70891f7369bb4bf8412fa1a08ecb}{actions\+\_\+before\+\_\+newton\+\_\+solve()}}, \mbox{\hyperlink{classoomph_1_1Problem_ae6ad96ddf5d48b517b89c9a9b879bc4b}{actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()}} and \mbox{\hyperlink{classoomph_1_1Problem_a033ec7301123deeb7e56d04c38f9f1da}{actions\+\_\+after\+\_\+newton\+\_\+solve()}}. This could be amazingly inefficient in certain problems and should be overloaded in such cases. An example would be when a remesh is required in general, but the global parameter does not affect the mesh directly. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a54e18ddf6073f9debd478f6b21a717de}{actions\+\_\+after\+\_\+parameter\+\_\+increase}} (double $\ast$const \&parameter\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Empty virtual function; provides hook to perform actions after the increase in the arclength parameter (during continuation) \end{DoxyCompactList}\item 
double \& \mbox{\hyperlink{classoomph_1_1Problem_ad6df5fb0d282f25df1e94a665dd838e5}{dof\+\_\+derivative}} (const unsigned \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})
\begin{DoxyCompactList}\small\item\em Access function to the derivative of the i-\/th (local) dof with respect to the arc length, used in continuation. \end{DoxyCompactList}\item 
double \& \mbox{\hyperlink{classoomph_1_1Problem_a10fd6457ceceb02a0e11d860ac0017c5}{dof\+\_\+current}} (const unsigned \&\mbox{\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}})
\begin{DoxyCompactList}\small\item\em Access function to the current value of the i-\/th (local) dof at the start of a continuation step. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_ad48be6d67071f7da5f6feb7c4fc918f0}{set\+\_\+initial\+\_\+condition}} ()
\begin{DoxyCompactList}\small\item\em Set initial condition (incl previous timesteps). We need to establish this interface because I.\+C. needs to be reset when problem is adapted during the first timestep. \end{DoxyCompactList}\item 
virtual double \mbox{\hyperlink{classoomph_1_1Problem_ac7667864b71a3889c95c29307422ac8e}{global\+\_\+temporal\+\_\+error\+\_\+norm}} ()
\begin{DoxyCompactList}\small\item\em Function to calculate a global error norm, used in adaptive timestepping to control the change in timestep. Individual errors for each data object can be obtained via the data timestepper\textquotesingle{}s temporal\+\_\+error\+\_\+in\+\_\+value or temporal\+\_\+error\+\_\+in\+\_\+position functions and should be combined to construct a global norm. For example, in fluids problems a suitable norm is usually the weighted sum of the errors in the velocities; for moving mesh problems is it usually better to use the weighted sum of the errors in position. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_aea0efdeb4814de433fa2ffb3065831ce}{newton\+\_\+solve\+\_\+continuation}} (double $\ast$const \&parameter\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Perform a basic arc-\/length continuation step using Newton\textquotesingle{}s method. Returns number of Newton steps taken. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_aa539429593ad9ffe3a400a72db2063bd}{newton\+\_\+solve\+\_\+continuation}} (double $\ast$const \&parameter\+\_\+pt, \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&z)
\begin{DoxyCompactList}\small\item\em This function performs a basic continuation step using the Newton method. The number of Newton steps taken is returned, to be used in any external step-\/size control routines. The governing parameter of the problem is passed as a pointer to the routine, as is a vector in which to store the derivatives wrt the parameter, if required. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a58f16ae8f6da042d40fddf01ee3ebd31}{calculate\+\_\+continuation\+\_\+derivatives}} (double $\ast$const \&parameter\+\_\+pt)
\begin{DoxyCompactList}\small\item\em A function to calculate the derivatives wrt the arc-\/length. This version of the function actually does a linear solve so that the derivatives are calculated \char`\"{}exactly\char`\"{} rather than using the values at the Newton step just before convergence. This is necessary in spatially adaptive problems, in which the number of degrees of freedom changes and so the appropriate derivatives must be calculated for the new variables. This function is called if no Newton steps were taken in the continuation routine ... i.\+e. the initial residuals were sufficiently small. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a58edae16dc24830521b0df67452db1f7}{calculate\+\_\+continuation\+\_\+derivatives}} (const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&z)
\begin{DoxyCompactList}\small\item\em A function to calculate the derivatives with respect to the arc-\/length required for continuation. The arguments is the solution of the linear system, Jz = d\+R/dparameter, that gives du/dparameter and the direction output from the newton\+\_\+solve\+\_\+continuation function. The derivatives are stored in the Continuation\+Parameters namespace. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_addc838287129a35ef60e38ea854b939c}{calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd}} (double $\ast$const \&parameter\+\_\+pt)
\begin{DoxyCompactList}\small\item\em A function to calculate the derivatives with respect to the arc-\/length required for continuation by finite differences, using the previous values of the solution. The derivatives are stored in the Continuation\+Parameters namespace. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_af7a83b109e7662abd52ea552d89163cc}{does\+\_\+pointer\+\_\+correspond\+\_\+to\+\_\+problem\+\_\+data}} (double $\ast$const \&parameter\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Return a boolean flag to indicate whether the pointer parameter\+\_\+pt refers to values stored in a \mbox{\hyperlink{classoomph_1_1Data}{Data}} object that is contained within the problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a9494223b38728ea186a68d6c70b7ebd4}{set\+\_\+consistent\+\_\+pinned\+\_\+values\+\_\+for\+\_\+continuation}} ()
\begin{DoxyCompactList}\small\item\em Private helper function that is used to set the appropriate pinned values for continuation. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} $\ast$ $>$ \mbox{\hyperlink{classoomph_1_1Problem_aa2e04de221f29c13067e2fe4cf4c70f9}{Copy\+\_\+of\+\_\+problem\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of pointers to copies of the problem used in adaptive bifurcation tracking problems (ALH\+: TEMPORARY HACK, WILL BE FIXED) \end{DoxyCompactList}\item 
std\+::map$<$ double $\ast$, bool $>$ \mbox{\hyperlink{classoomph_1_1Problem_ae22f10c348ef8afeb1bfd8609cd6a319}{Calculate\+\_\+dparameter\+\_\+analytic}}
\begin{DoxyCompactList}\small\item\em Map used to determine whether the derivatives with respect to a parameter should be finite differenced. The default is that finite differences should be used. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_ac353f1325a3b411b30fbc19314cc18ce}{Calculate\+\_\+hessian\+\_\+products\+\_\+analytic}}
\begin{DoxyCompactList}\small\item\em Map used to determine whether the hessian products should be computed using finite differences. The default is that finite differences will be used. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_ade01b88db08dcec1706fe44eaa0090a3}{Dof\+\_\+distribution\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em The distribution of the DOFs in this problem. This object is created in the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} constructor and setup when assign\+\_\+eqn\+\_\+numbers(...) is called. If this problem is distributed then this distribution will match the distribution of the equation numbers. If this problem is not distributed then this distribution will be uniform over all processors. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \mbox{\hyperlink{classoomph_1_1Problem_aa9e4cfff7e1dc295036b0e58bc11ae75}{Dof\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of pointers to dofs. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1DoubleVectorWithHaloEntries}{Double\+Vector\+With\+Halo\+Entries}} \mbox{\hyperlink{classoomph_1_1Problem_ae4177b73a790b80d541b416d1e83c6c3}{Element\+\_\+count\+\_\+per\+\_\+dof}}
\begin{DoxyCompactList}\small\item\em Counter that records how many elements contribute to each dof. Used to determine the (discrete) arc-\/length automatically. It really should be an integer, but is a double so that the distribution information can be used for distributed problems. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \mbox{\hyperlink{classoomph_1_1Problem_a2b2bcde2b051f47278ccf8446699bbfb}{Elemental\+\_\+assembly\+\_\+time}}
\begin{DoxyCompactList}\small\item\em Storage for assembly times (used for load balancing) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1DoubleVectorHaloScheme}{Double\+Vector\+Halo\+Scheme}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_a1dcaa04975d69c616ab294cbfaf53d55}{Halo\+\_\+scheme\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Pointer to the halo scheme for any global vectors that have the Dof\+\_\+distribution. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \mbox{\hyperlink{classoomph_1_1Problem_ac59d9163cc5d008a2ade4de8da06dbf6}{Halo\+\_\+dof\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Storage for the halo degrees of freedom (only required) when accessing via the global equation number in distributed problems. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_a86c4feb98ec982a08dc84fb664f53abc}{Relaxation\+\_\+factor}}
\begin{DoxyCompactList}\small\item\em Relaxation fator for Newton method (only a fractional Newton correction is applied if this is less than 1; default 1). \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_a94536b381e949edf5bb4d44434e08925}{Newton\+\_\+solver\+\_\+tolerance}}
\begin{DoxyCompactList}\small\item\em The Tolerance below which the Newton Method is deemed to have converged. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_a52a58a98c3e2e7dbaefcfb1ee7830c35}{Max\+\_\+newton\+\_\+iterations}}
\begin{DoxyCompactList}\small\item\em Maximum number of Newton iterations. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_a3c05eefd6891808a1ef01e51288e0108}{Nnewton\+\_\+iter\+\_\+taken}}
\begin{DoxyCompactList}\small\item\em Actual number of Newton iterations taken during the most recent iteration. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \mbox{\hyperlink{classoomph_1_1Problem_ab6f510bea9bdfcaf229415440a0a1c98}{Max\+\_\+res}}
\begin{DoxyCompactList}\small\item\em Maximum residuals at start and after each newton iteration. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_accb8811cdf32f14be497917e922c623e}{Max\+\_\+residuals}}
\begin{DoxyCompactList}\small\item\em Maximum desired residual\+: if the maximum residual exceeds this value, the program will exit. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a3e9aecf88bde320bc2d169b5f3c99fee}{Time\+\_\+adaptive\+\_\+newton\+\_\+crash\+\_\+on\+\_\+solve\+\_\+fail}}
\begin{DoxyCompactList}\small\item\em Bool to specify what to do if a Newton solve fails within a time adaptive solve. Default (false) is to half the step and try again. If true then crash instead. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a022796f2c96f2dff6ed1db2338c93aaf}{Jacobian\+\_\+reuse\+\_\+is\+\_\+enabled}}
\begin{DoxyCompactList}\small\item\em Is re-\/use of Jacobian in Newton iteration enabled? Default\+: false. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a2c4702c75739c967ed582dbd0a7ba56f}{Jacobian\+\_\+has\+\_\+been\+\_\+computed}}
\begin{DoxyCompactList}\small\item\em Has a Jacobian been computed (and can therefore be re-\/used if required)? Default\+: false. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_ade2d3efba34f69aafaefc076ddb3b8d4}{Problem\+\_\+is\+\_\+nonlinear}}
\begin{DoxyCompactList}\small\item\em Boolean flag indicating if we\textquotesingle{}re dealing with a linear or nonlinear \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} -- if set to false the Newton solver will not check the residual before or after the linear solve. Set to true by default; can be over-\/written in specific \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} class. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_aedefa8337ace6043c2fdfd5a2d19afd3}{Pause\+\_\+at\+\_\+end\+\_\+of\+\_\+sparse\+\_\+assembly}}
\begin{DoxyCompactList}\small\item\em Protected boolean flag to halt program execution during sparse assemble process to assess peak memory usage. Initialised to false (obviously!) \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a524b68efcaae084ad7144f944cb39c69}{Doc\+\_\+time\+\_\+in\+\_\+distribute}}
\begin{DoxyCompactList}\small\item\em Protected boolean flag to provide comprehensive timimings during problem distribution. Initialised to false. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_a447f9d42b248f6c394581ff1a0b02513}{Sparse\+\_\+assembly\+\_\+method}}
\begin{DoxyCompactList}\small\item\em Flag to determine which sparse assembly method to use By default we use assembly by vectors of pairs. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_ad2d5f8e18619fafcff11727b1c55b3eb}{Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+initial\+\_\+allocation}}
\begin{DoxyCompactList}\small\item\em the number of elements to initially allocate for a matrix row within the sparse\+\_\+assembly\+\_\+with\+\_\+two\+\_\+arrays(...) method (if a matrix of this size has not been assembled already). If a matrix of this size has been assembled then the number of elements in each row in that matrix is used as the initial allocation \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_aeb58a3cead4d10697c4471523f705130}{Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+allocation\+\_\+increment}}
\begin{DoxyCompactList}\small\item\em the number of elements to add to a matrix row when the initial allocation is exceeded within the sparse\+\_\+assemble\+\_\+with\+\_\+two\+\_\+arrays(...) method. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ $>$ \mbox{\hyperlink{classoomph_1_1Problem_a547c85bfa6a2eb3effc4db1b46ebcdde}{Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+previous\+\_\+allocation}}
\begin{DoxyCompactList}\small\item\em the number of elements in each row of a compressed matrix in the previous matrix assembly. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_ad1a1ffc2bd685377ce7213452876b127}{Numerical\+\_\+zero\+\_\+for\+\_\+sparse\+\_\+assembly}}
\begin{DoxyCompactList}\small\item\em A tolerance used to determine whether the entry in a sparse matrix is zero. If it is then storage need not be allocated. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_ad26c62f5aab816943144ac61fbf7725e}{FD\+\_\+step\+\_\+used\+\_\+in\+\_\+get\+\_\+hessian\+\_\+vector\+\_\+products}}
\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_af4d25809ac090102a4d4a398e4ad0e26}{Mass\+\_\+matrix\+\_\+reuse\+\_\+is\+\_\+enabled}}
\begin{DoxyCompactList}\small\item\em Is re-\/use of the mass matrix in explicit timestepping enabled Default\+:false. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a6067c6d344363a073fb8d02a99fb7ed0}{Mass\+\_\+matrix\+\_\+has\+\_\+been\+\_\+computed}}
\begin{DoxyCompactList}\small\item\em Has the mass matrix been computed (and can therefore be reused) Default\+: false. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a97ca0078fff6adca318835c11503dc2d}{Discontinuous\+\_\+element\+\_\+formulation}}
\begin{DoxyCompactList}\small\item\em Is the problem a discontinuous one, i.\+e. can the elemental contributions be treated independently. Default\+: false. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_ad7456318933aa01114dc78498bfd6d79}{Minimum\+\_\+dt}}
\begin{DoxyCompactList}\small\item\em Minimum desired dt\+: if dt falls below this value, exit. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_a7b5fde48b00a7fdc5f1fbbee138d0414}{Maximum\+\_\+dt}}
\begin{DoxyCompactList}\small\item\em Maximum desired dt. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_aaaeab9469b342a3b849ee5f2ef7051f3}{DTSF\+\_\+max\+\_\+increase}}
\begin{DoxyCompactList}\small\item\em Maximum possible increase of dt between time-\/steps in adaptive schemes. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_abbb93979ed99d40eb845ba7296355965}{DTSF\+\_\+min\+\_\+decrease}}
\begin{DoxyCompactList}\small\item\em Minimum allowed decrease of dt between time-\/steps in adaptive schemes. Lower scaling values will reject the time-\/step (and retry with a smaller dt). \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_abdee700b2cec37540cf1e7e1462df6c3}{Minimum\+\_\+dt\+\_\+but\+\_\+still\+\_\+proceed}}
\begin{DoxyCompactList}\small\item\em If Minimum\+\_\+dt\+\_\+but\+\_\+still\+\_\+proceed positive, then dt will not be reduced below this value during adaptive timestepping and the computation will continue with this value, accepting the larger errors that this will incur). Note\+: This option is disabled by default as this value is initialised to -\/1.\+0. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a708322baf423e373970384006c2ca4db}{Scale\+\_\+arc\+\_\+length}}
\begin{DoxyCompactList}\small\item\em Boolean to control whether arc-\/length should be scaled. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_a37fb791188428c8186ffd5c52b6cf576}{Desired\+\_\+proportion\+\_\+of\+\_\+arc\+\_\+length}}
\begin{DoxyCompactList}\small\item\em Proportion of the arc-\/length to taken by the parameter. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_a123843ca2ed6384342939ef2b19477ef}{Theta\+\_\+squared}}
\begin{DoxyCompactList}\small\item\em Value of the scaling parameter required so that the parameter occupies the desired proportion of the arc length. NOTE\+: If you wish to change this then make sure to set the value of Scale\+\_\+arc\+\_\+length to false to ensure the value of this isn\textquotesingle{}t overwritten during the arc-\/length process. Instead of changing this variable, it\textquotesingle{}s better to actually update the Desired\+\_\+proportion\+\_\+of\+\_\+arc\+\_\+length value. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classoomph_1_1Problem_aca97d61840e46edc914e3cb4b98fd437}{Sign\+\_\+of\+\_\+jacobian}}
\begin{DoxyCompactList}\small\item\em Storage for the sign of the global Jacobian. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_a6904003416e9a9257db70c009bdc69ed}{Continuation\+\_\+direction}}
\begin{DoxyCompactList}\small\item\em The direction of the change in parameter that will ensure that a branch is followed in one direction only. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_aa5082325ca4cafe5a9ec03ef79c67a6f}{Parameter\+\_\+derivative}}
\begin{DoxyCompactList}\small\item\em Storage for the derivative of the global parameter wrt arc-\/length. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_a8e29673eb80559888d1c6148c4f11e57}{Parameter\+\_\+current}}
\begin{DoxyCompactList}\small\item\em Storage for the present value of the global parameter. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_adbecce0cb1bd7b6b21285568e41ee3eb}{Use\+\_\+continuation\+\_\+timestepper}}
\begin{DoxyCompactList}\small\item\em Boolean to control original or new storage of dof stuff. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_af0372f742b90bb402c6edc720ceeb421}{Dof\+\_\+derivative\+\_\+offset}}
\begin{DoxyCompactList}\small\item\em Storage for the offset for the continuation derivatives from the original dofs (default is 1, but this will be differnet when continuing bifurcations and periodic orbits) \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_a57825be8c76db9e23e6a9aa0d73973b2}{Dof\+\_\+current\+\_\+offset}}
\begin{DoxyCompactList}\small\item\em Storage for the offset for the current values of dofs from the original dofs (default is 2, but this will be differnet when continuing bifurcations and periodic orbits) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \mbox{\hyperlink{classoomph_1_1Problem_a1861321b2d129707935bf1191238daca}{Dof\+\_\+derivative}}
\begin{DoxyCompactList}\small\item\em Storage for the derivative of the problem variables wrt arc-\/length. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \mbox{\hyperlink{classoomph_1_1Problem_a366b50c490e9fd3ddafa05b2fbd0b883}{Dof\+\_\+current}}
\begin{DoxyCompactList}\small\item\em Storage for the present values of the variables. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_ad412d49617d0b0998e5eb440c7a20f3f}{Ds\+\_\+current}}
\begin{DoxyCompactList}\small\item\em Storage for the current step value. \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_abfe8db162a0bda98add0062a45f41cbf}{Desired\+\_\+newton\+\_\+iterations\+\_\+ds}}
\begin{DoxyCompactList}\small\item\em The desired number of Newton Steps to reach convergence at each step along the arc. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_ad0f8bb126a4f5ddeb559c23a8d451d8d}{Minimum\+\_\+ds}}
\begin{DoxyCompactList}\small\item\em Minimum desired value of arc-\/length. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a08dfc704030bb65cea3d9784c5271af0}{Bifurcation\+\_\+detection}}
\begin{DoxyCompactList}\small\item\em Boolean to control bifurcation detection via determinant of Jacobian. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_ab805e5e5fb94f941cc7ff1b850d83269}{Bisect\+\_\+to\+\_\+find\+\_\+bifurcation}}
\begin{DoxyCompactList}\small\item\em Boolean to control wheter bisection is used to located bifurcation. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a643f61299463a3bbf7be3f6a112aa130}{First\+\_\+jacobian\+\_\+sign\+\_\+change}}
\begin{DoxyCompactList}\small\item\em Boolean to indicate whether a sign change has occured in the Jacobian. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a8109bf56e9203d248ae30a50bb9cfe90}{Arc\+\_\+length\+\_\+step\+\_\+taken}}
\begin{DoxyCompactList}\small\item\em Boolean to indicate whether an arc-\/length step has been taken. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a80dac9f70c77302805bb782cc6f1ad0f}{Use\+\_\+finite\+\_\+differences\+\_\+for\+\_\+continuation\+\_\+derivatives}}
\begin{DoxyCompactList}\small\item\em Boolean to specify which scheme to use to calculate the continuation derivatievs. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a5c6bd262be3544343a30767da278d846}{Problem\+\_\+has\+\_\+been\+\_\+distributed}}
\begin{DoxyCompactList}\small\item\em Has the problem been distributed amongst multiple processors? \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a2cee2eaaf1ac49020fc76b3b6adb9bba}{Bypass\+\_\+increase\+\_\+in\+\_\+dof\+\_\+check\+\_\+during\+\_\+pruning}}
\begin{DoxyCompactList}\small\item\em Boolean to bypass check of increase in dofs during pruning. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1OomphCommunicator}{Oomph\+Communicator}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_a937afdd0d5a039943482f8be9b24c82e}{Communicator\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em The communicator for this problem. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a01d7376ab9cc06e4d5619b34fd39dee2}{Always\+\_\+take\+\_\+one\+\_\+newton\+\_\+step}}
\begin{DoxyCompactList}\small\item\em Boolean to indicate whether a Newton step should be taken even if the initial residuals are below the required tolerance. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_a359d1936bc2146e0a0ce697776efcf91}{Timestep\+\_\+reduction\+\_\+factor\+\_\+after\+\_\+nonconvergence}}
\begin{DoxyCompactList}\small\item\em What it says\+: If temporally adaptive Newton solver fails to to converge, reduce timestep by this factor and try again; defaults to 1/2; can be over-\/written by user in derived problem. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_ab27af4a444de9f59125ee50ac778d97a}{Keep\+\_\+temporal\+\_\+error\+\_\+below\+\_\+tolerance}}
\begin{DoxyCompactList}\small\item\em Boolean to decide if a timestep is to be rejected if the error estimate post-\/solve (computed by \mbox{\hyperlink{classoomph_1_1Problem_ac7667864b71a3889c95c29307422ac8e}{global\+\_\+temporal\+\_\+error\+\_\+norm()}}) exceeds the tolerance required in the call to adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(...). Defaults to true. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Protected Attributes}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{classoomph_1_1ContinuationStorageScheme}{Continuation\+Storage\+Scheme}} \mbox{\hyperlink{classoomph_1_1Problem_ade29c0a82218d50136b4b3860055ad30}{Continuation\+\_\+time\+\_\+stepper}}
\begin{DoxyCompactList}\small\item\em Storage for the single static continuation timestorage object. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
double \mbox{\hyperlink{classoomph_1_1Problem_a71ba0a8ba4cbcb66077324217482ee11}{doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve\+\_\+helper}} (const double \&dt, const double \&epsilon, const unsigned \&max\+\_\+adapt, const unsigned \&suppress\+\_\+resolve\+\_\+after\+\_\+spatial\+\_\+adapt, const bool \&first, const bool \&shift=true)
\begin{DoxyCompactList}\small\item\em Private helper function that actually performs the unsteady \char`\"{}doubly\char`\"{} adaptive Newton solve. See actual (non-\/helper) functions for description of parameters. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a0f86f3d5d65115dca81e10910e11ea19}{refine\+\_\+uniformly\+\_\+aux}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nrefine\+\_\+for\+\_\+mesh, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info, const bool \&prune)
\begin{DoxyCompactList}\small\item\em Helper function to do compund refinement of (all) refineable (sub)mesh(es) uniformly as many times as specified in vector and rebuild problem; doc refinement process. Set boolean argument to true if you want to prune immediately after refining the meshes individually. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a9e598cc12a894db00bfe62d87a0ff41b}{p\+\_\+refine\+\_\+uniformly\+\_\+aux}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nrefine\+\_\+for\+\_\+mesh, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info, const bool \&prune)
\begin{DoxyCompactList}\small\item\em Helper function to do compund p-\/refinement of (all) p-\/refineable (sub)mesh(es) uniformly as many times as specified in vector and rebuild problem; doc refinement process. Set boolean argument to true if you want to prune immediately after refining the meshes individually. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ab5f60ebc552c00ee681776bc7fa61203}{setup\+\_\+base\+\_\+mesh\+\_\+info\+\_\+after\+\_\+pruning}} ()
\begin{DoxyCompactList}\small\item\em Helper function to re-\/setup the Base\+\_\+mesh enumeration (used during load balancing) after pruning. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a3d5d5ac657381a2b2b077988e887fef8}{sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+vectors\+\_\+of\+\_\+pairs}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&column\+\_\+or\+\_\+row\+\_\+index, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&row\+\_\+or\+\_\+column\+\_\+start, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&value, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nnz, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&residual, bool compressed\+\_\+row\+\_\+flag)
\begin{DoxyCompactList}\small\item\em Private helper function that is used to assemble the Jacobian matrix in the case when the storage is row or column compressed. The boolean Flag indicates if we want compressed row format (true) or compressed column. This version uses vectors of pairs. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a767f7064ccbdcc2a039e0360b98dc48d}{sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+vectors}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&column\+\_\+or\+\_\+row\+\_\+index, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&row\+\_\+or\+\_\+column\+\_\+start, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&value, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nnz, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&residual, bool compressed\+\_\+row\+\_\+flag)
\begin{DoxyCompactList}\small\item\em Private helper function that is used to assemble the Jacobian matrix in the case when the storage is row or column compressed. The boolean Flag indicates if we want compressed row format (true) or compressed column. This version uses two vectors. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_ade9708e503889b48e0a1dbbe47906eba}{sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+maps}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&column\+\_\+or\+\_\+row\+\_\+index, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&row\+\_\+or\+\_\+column\+\_\+start, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&value, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nnz, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&residual, bool compressed\+\_\+row\+\_\+flag)
\begin{DoxyCompactList}\small\item\em Private helper function that is used to assemble the Jacobian matrix in the case when the storage is row or column compressed. The boolean Flag indicates if we want compressed row format (true) or compressed column. This version uses maps. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a18867724e4682e69f10fe19d7a20116d}{sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+lists}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&column\+\_\+or\+\_\+row\+\_\+index, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&row\+\_\+or\+\_\+column\+\_\+start, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&value, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nnz, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&residual, bool compressed\+\_\+row\+\_\+flag)
\begin{DoxyCompactList}\small\item\em Private helper function that is used to assemble the Jacobian matrix in the case when the storage is row or column compressed. The boolean Flag indicates if we want compressed row format (true) or compressed column. This version uses lists. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classoomph_1_1Problem_a19520f8a38dc1dabb33cd7f397ff3506}{sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&column\+\_\+or\+\_\+row\+\_\+index, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&row\+\_\+or\+\_\+column\+\_\+start, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&value, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nnz, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&residual, bool compressed\+\_\+row\+\_\+flag)
\begin{DoxyCompactList}\small\item\em Private helper function that is used to assemble the Jacobian matrix in the case when the storage is row or column compressed. The boolean Flag indicates if we want compressed row format (true) or compressed column. This version uses lists. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a9e860f40a5ca15767d2174893c9084d4}{calculate\+\_\+continuation\+\_\+derivatives\+\_\+helper}} (const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&z)
\begin{DoxyCompactList}\small\item\em A function that performs the guts of the continuation derivative calculation in arc length continuation problems. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a668e4c384b0513a943dee9411e640d74}{calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd\+\_\+helper}} (double $\ast$const \&parameter\+\_\+pt)
\begin{DoxyCompactList}\small\item\em A function that performs the guts of the continuation derivative calculation in arc-\/length continuation problems using finite differences. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a27d31a7a78f5d01b9d0a5e07c0e06e5d}{bifurcation\+\_\+adapt\+\_\+helper}} (unsigned \&n\+\_\+refined, unsigned \&n\+\_\+unrefined, const unsigned \&bifurcation\+\_\+type, const bool \&actually\+\_\+adapt=true)
\begin{DoxyCompactList}\small\item\em A function that is used to adapt a bifurcation-\/tracking problem, which requires separate interpolation of the associated eigenfunction. The error measure is chosen to be a suitable combination of the errors in the base flow and the eigenfunction. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ad36cedd508f3cfb352ddd44c18914d41}{bifurcation\+\_\+adapt\+\_\+doc\+\_\+errors}} (const unsigned \&bifurcation\+\_\+type)
\begin{DoxyCompactList}\small\item\em A function that is used to document the errors used in the adaptive solution of bifurcation problems. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ae222ce1fa229441a733d350105dfd1f7}{get\+\_\+my\+\_\+eqns}} (\mbox{\hyperlink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Problem_a381c30a8daede5c95bdda7e2efa24f19}{assembly\+\_\+handler\+\_\+pt}}, const unsigned \&el\+\_\+lo, const unsigned \&el\+\_\+hi, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&my\+\_\+eqns)
\begin{DoxyCompactList}\small\item\em Helper method that returns the (unique) global equations to which the elements in the range el\+\_\+lo to el\+\_\+hi contribute on this processor using the given assembly\+\_\+handler. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a0487a7ef40e6cc4dad88e99ac96193e2}{parallel\+\_\+sparse\+\_\+assemble}} (const \mbox{\hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution}} $\ast$const \&dist\+\_\+pt, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&column\+\_\+or\+\_\+row\+\_\+index, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&row\+\_\+or\+\_\+column\+\_\+start, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&value, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&nnz, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&residuals)
\begin{DoxyCompactList}\small\item\em Helper method to assemble CRDouble\+Matrices from distributed on multiple processors. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a3d06660ec06b402f14d4b33a84621214}{copy\+\_\+haloed\+\_\+eqn\+\_\+numbers\+\_\+helper}} (const bool \&do\+\_\+halos, const bool \&do\+\_\+external\+\_\+halos)
\begin{DoxyCompactList}\small\item\em A private helper function to copy the haloed equation numbers into the halo equation numbers, either for the problem\textquotesingle{}s one and only mesh or for all of its submeshes. Bools control if we deal with data associated with external halo/ed elements/nodes or the \char`\"{}normal\char`\"{} halo/ed ones. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a088570d2600c2e710da2717e9ed35404}{remove\+\_\+duplicate\+\_\+data}} (\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$const \&\mbox{\hyperlink{classoomph_1_1Problem_aad122d70a22dc5302cfd5853d3cf3057}{mesh\+\_\+pt}}, bool \&actually\+\_\+removed\+\_\+some\+\_\+data)
\begin{DoxyCompactList}\small\item\em Private helper function to remove repeated data in external haloed elements in specified mesh. Bool is true if some data was removed -- this usually requires re-\/running through certain parts of the equation numbering procedure. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_aee39a957d45bc474c1f5b27d96c9dcc0}{remove\+\_\+null\+\_\+pointers\+\_\+from\+\_\+external\+\_\+halo\+\_\+node\+\_\+storage}} ()
\begin{DoxyCompactList}\small\item\em Consolidate external halo node storage by removing nulled out pointers in external halo and haloed schemes for all meshes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_aa9d808bb5d62db0da8e962fa29c24af9}{recompute\+\_\+load\+\_\+balanced\+\_\+assembly}} ()
\begin{DoxyCompactList}\small\item\em Helper function to re-\/assign the first and last elements to be assembled by each processor during parallel assembly for non-\/distributed problem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ad150d0fa8f2e2ccff79f8ecd78cc1343}{get\+\_\+data\+\_\+to\+\_\+be\+\_\+sent\+\_\+during\+\_\+load\+\_\+balancing}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&element\+\_\+domain\+\_\+on\+\_\+this\+\_\+proc, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $>$ \&send\+\_\+n, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&send\+\_\+data, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $>$ \&send\+\_\+displacement, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&old\+\_\+domain\+\_\+for\+\_\+base\+\_\+element, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&new\+\_\+domain\+\_\+for\+\_\+base\+\_\+element, unsigned \&max\+\_\+refinement\+\_\+level\+\_\+overall)
\begin{DoxyCompactList}\small\item\em Load balance helper routine\+: Get data to be sent to other processors during load balancing and other information about re-\/distribution. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a94646da2c0dac6e7477c445fd41e5a90}{get\+\_\+flat\+\_\+packed\+\_\+refinement\+\_\+pattern\+\_\+for\+\_\+load\+\_\+balancing}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&old\+\_\+domain\+\_\+for\+\_\+base\+\_\+element, const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&new\+\_\+domain\+\_\+for\+\_\+base\+\_\+element, const unsigned \&max\+\_\+refinement\+\_\+level\+\_\+overall, std\+::map$<$ unsigned, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$$>$ \&flat\+\_\+packed\+\_\+refinement\+\_\+info\+\_\+for\+\_\+root)
\begin{DoxyCompactList}\small\item\em Get flat-\/packed refinement pattern for each root element in current mesh (labeled by unique number of root element in unrefined base mesh). The vector stored for each root element contains the following information\+: \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_a3e07d0acd3499ac7736fba1841ad1cf2}{send\+\_\+data\+\_\+to\+\_\+be\+\_\+sent\+\_\+during\+\_\+load\+\_\+balancing}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $>$ \&send\+\_\+n, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&send\+\_\+data, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $>$ \&send\+\_\+displacement)
\begin{DoxyCompactList}\small\item\em Load balance helper routine\+: Send data to other processors during load balancing. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_adf8cf244cf218c429e69f3728ef294b0}{send\+\_\+refinement\+\_\+info\+\_\+helper}} (\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&old\+\_\+domain\+\_\+for\+\_\+base\+\_\+element, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&new\+\_\+domain\+\_\+for\+\_\+base\+\_\+element, const unsigned \&max\+\_\+refinement\+\_\+level\+\_\+overall, std\+::map$<$ unsigned, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$$>$ \&refinement\+\_\+info\+\_\+for\+\_\+root\+\_\+local, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$$>$$>$ \&refinement\+\_\+info\+\_\+for\+\_\+root\+\_\+elements)
\begin{DoxyCompactList}\small\item\em Send refinement information between processors. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classoomph_1_1Problem_ac60d7455a13ee171060c3a81623840b2}{globally\+\_\+convergent\+\_\+line\+\_\+search}} (const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&x\+\_\+old, const double \&half\+\_\+residual\+\_\+squared\+\_\+old, \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&gradient, \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&newton\+\_\+dir, double \&half\+\_\+residual\+\_\+squared, const double \&stpmax)
\begin{DoxyCompactList}\small\item\em Line search helper for globally convergent Newton method. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classoomph_1_1Problem_afaa9689a9c73bb76caea5d24980e6788}{arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper}} (double $\ast$const \&parameter\+\_\+pt, const double \&ds, const unsigned \&max\+\_\+adapt)
\begin{DoxyCompactList}\small\item\em Private helper function that actually contains the guts of the arc-\/length stepping, parameter\+\_\+pt is a pointer to the parameter that is traded for the arc-\/length constraint, ds is the desired arc length and max\+\_\+adapt is the maximum number of spatial adaptations. The pointer to the parameter may be changed if this is called from the Data-\/based interface. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_aa4a3bf9419e495aaaaea0dcb00ea53e5}{Mesh\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em The mesh pointer. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$ $>$ \mbox{\hyperlink{classoomph_1_1Problem_ab65f6fc9c49860e6324457a7e6e76346}{Sub\+\_\+mesh\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of pointers to submeshes. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_a519de6f6f70c8b0f6bacbde5e0a35cd7}{Linear\+\_\+solver\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Pointer to the linear solver for the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_ad4b9d15269f624044d1730957b0a8c19}{Mass\+\_\+matrix\+\_\+solver\+\_\+for\+\_\+explicit\+\_\+timestepper\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Pointer to the linear solver used for explicit time steps (this is likely to be different to the linear solver for newton solves because explicit time steps only involve inverting a mass matrix. This can be done very efficiently by, e.\+g. \mbox{\hyperlink{classoomph_1_1CG}{CG}} with a diagonal predconditioner). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1EigenSolver}{Eigen\+Solver}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_ab7938313fa45df9be16515a6b0bfd324}{Eigen\+\_\+solver\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Pointer to the eigen solver for the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_aefc325e2e116c389a24c9871e41bdb55}{Assembly\+\_\+handler\+\_\+pt}}
\item 
\mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_ad01b385b2b4cd2e0b867754bea7b798a}{Default\+\_\+linear\+\_\+solver\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Pointer to the default linear solver. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1EigenSolver}{Eigen\+Solver}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_a39fd6a7e05c02befe9f2a09938a7a7a4}{Default\+\_\+eigen\+\_\+solver\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Pointer to the default eigensolver. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_ae0cebe288c8daddd9663bd10d8f1caa0}{Default\+\_\+assembly\+\_\+handler\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Pointer to the default assembly handler. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Time}{Time}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_ae33fbf5f34a7d06d88ad2c98538bbbe8}{Time\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Pointer to global time for the problem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}} $\ast$ $>$ \mbox{\hyperlink{classoomph_1_1Problem_af1e8f8a739453250eb3744fea2a3b983}{Time\+\_\+stepper\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em The \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of time steppers (there could be many different ones in multiphysics problems) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1ExplicitTimeStepper}{Explicit\+Time\+Stepper}} $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_af8466091ea4f5b57033bb3ad24831167}{Explicit\+\_\+time\+\_\+stepper\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Pointer to a single explicit timestepper. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ $\ast$ \mbox{\hyperlink{classoomph_1_1Problem_aeef791a0158657ca7c298ffcb63ed54e}{Saved\+\_\+dof\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em Pointer to vector for backup of dofs. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a83df3b5fcc3ebbae951021c8e7f03ef7}{Default\+\_\+set\+\_\+initial\+\_\+condition\+\_\+called}}
\begin{DoxyCompactList}\small\item\em Has default set\+\_\+initial\+\_\+condition function been called? Default\+: false. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_acf8b1ec937efdf2a0f892a41c18c0c53}{Use\+\_\+globally\+\_\+convergent\+\_\+newton\+\_\+method}}
\begin{DoxyCompactList}\small\item\em Use the globally convergent newton method. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a5f13ea67c29022392857b5c19bb3af71}{Empty\+\_\+actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes\+\_\+has\+\_\+been\+\_\+called}}
\begin{DoxyCompactList}\small\item\em Boolean to indicate that empty \mbox{\hyperlink{classoomph_1_1Problem_af10662119a7a0c3a47879fa0d0644452}{actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes()}} function has been called. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a71f87e46a571a54abd27a26f6c701c36}{Empty\+\_\+actions\+\_\+after\+\_\+read\+\_\+unstructured\+\_\+meshes\+\_\+has\+\_\+been\+\_\+called}}
\begin{DoxyCompactList}\small\item\em Boolean to indicate that empty \mbox{\hyperlink{classoomph_1_1Problem_a498317b3e390eddf2169ab989ee8d6b4}{actions\+\_\+after\+\_\+read\+\_\+unstructured\+\_\+meshes()}} function has been called. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a075696d6f4c4260ce860997c8c931de4}{Store\+\_\+local\+\_\+dof\+\_\+pt\+\_\+in\+\_\+elements}}
\begin{DoxyCompactList}\small\item\em Boolean to indicate whether local dof pointers should be stored in the elements. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_afe6f5bb841832b3c4d1f06c2d939f4a6}{Use\+\_\+predictor\+\_\+values\+\_\+as\+\_\+initial\+\_\+guess}}
\begin{DoxyCompactList}\small\item\em Use values from the time stepper predictor as an initial guess. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Data}{Data}} $\ast$ $>$ \mbox{\hyperlink{classoomph_1_1Problem_aa963c98e91d135d31cdcfbe1afa64603}{Global\+\_\+data\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of global data\+: \char`\"{}\+Nobody\char`\"{} (i.\+e. none of the elements etc.) is \char`\"{}in charge\char`\"{} of this \mbox{\hyperlink{classoomph_1_1Data}{Data}} so it would be overlooked when it comes to equation-\/numbering, timestepping etc. Including (pointers) to such \mbox{\hyperlink{classoomph_1_1Data}{Data}} in here, puts the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} itself \char`\"{}in charge\char`\"{} of these tasks. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a9a20957e3ef4c8142261363c85f6e276}{Doc\+\_\+imbalance\+\_\+in\+\_\+parallel\+\_\+assembly}}
\begin{DoxyCompactList}\small\item\em Boolean to switch on assessment of load imbalance in parallel assembly of distributed problem. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_a259414329d43257a71790ac2983e32d4}{Use\+\_\+default\+\_\+partition\+\_\+in\+\_\+load\+\_\+balance}}
\begin{DoxyCompactList}\small\item\em Flag to use \char`\"{}default partition\char`\"{} during load balance. Should only be set to true when run in validation mode. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \mbox{\hyperlink{classoomph_1_1Problem_a0caac0918eaaea840238ce83f5be7836}{First\+\_\+el\+\_\+for\+\_\+assembly}}
\begin{DoxyCompactList}\small\item\em First element to be assembled by given processor for non-\/distributed problem (only kept up to date when default assignment is used) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \mbox{\hyperlink{classoomph_1_1Problem_a4842a9a213197905b5a8e182a3c02cce}{Last\+\_\+el\+\_\+plus\+\_\+one\+\_\+for\+\_\+assembly}}
\begin{DoxyCompactList}\small\item\em Last element (plus one) to be assembled by given processor for non-\/distributed problem (only kept up to date when default assignment is used) \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classoomph_1_1Problem_aab187e716f470b32a01d7f0cee7f3bf4}{Must\+\_\+recompute\+\_\+load\+\_\+balance\+\_\+for\+\_\+assembly}}
\begin{DoxyCompactList}\small\item\em Boolean indicating that the division of elements over processors during the assembly process must be re-\/load-\/balanced. (only used for non-\/distributed problems) \end{DoxyCompactList}\item 
std\+::map$<$ \mbox{\hyperlink{classoomph_1_1GeneralisedElement}{Generalised\+Element}} $\ast$, unsigned $>$ \mbox{\hyperlink{classoomph_1_1Problem_acbdc545bf83974cef38c9dbfff0d2120}{Base\+\_\+mesh\+\_\+element\+\_\+number\+\_\+plus\+\_\+one}}
\begin{DoxyCompactList}\small\item\em Map which stores the correspondence between a root element and its element number (plus one) within the global mesh at the point when it is distributed. NB a root element in this instance is one of the elements in the uniformly-\/refined mesh at the point when \mbox{\hyperlink{classoomph_1_1Problem_aa35e1adc0fdf14b217c7b608eb9cf20b}{Problem\+::distribute()}} is called, since these elements become roots on each of the processors involved in the distribution. Null when element doesn\textquotesingle{}t exist following the adjustment of this when pruning. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1GeneralisedElement}{Generalised\+Element}} $\ast$ $>$ \mbox{\hyperlink{classoomph_1_1Problem_a74ce6267ea12fd59903b88e316283b6a}{Base\+\_\+mesh\+\_\+element\+\_\+pt}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} to store the correspondence between a root element and its element number within the global mesh at the point when it is distributed. NB a root element in this instance is one of the elements in the uniformly-\/refined mesh at the point when \mbox{\hyperlink{classoomph_1_1Problem_aa35e1adc0fdf14b217c7b608eb9cf20b}{Problem\+::distribute()}} is called, since these elements become roots on each of the processors involved in the distribution. Null when element doesn\textquotesingle{}t exist following the adjustment of this when pruning. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402}{Distributed\+\_\+problem\+\_\+matrix\+\_\+distribution}} \mbox{\hyperlink{classoomph_1_1Problem_a1da221c501adc7d58bd21f630207c6c3}{Dist\+\_\+problem\+\_\+matrix\+\_\+distribution}}
\begin{DoxyCompactList}\small\item\em The distributed matrix distribution method 1 -\/ Automatic -\/ the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} distribution is employed, unless any processor has number of rows equal to 110\% of N/P, in which case uniform distribution is employed. 2 -\/ \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} -\/ the jacobian on processor p only contains rows that correspond to equations that are on this processor. (minimises communication) 3 -\/ Uniform -\/ each processor holds as close to N/P matrix rows as possible. (very well load balanced) \end{DoxyCompactList}\item 
unsigned \mbox{\hyperlink{classoomph_1_1Problem_a6a96b64a44cb378db1c0a07c562f7dae}{Parallel\+\_\+sparse\+\_\+assemble\+\_\+previous\+\_\+allocation}}
\begin{DoxyCompactList}\small\item\em The amount of data allocated during the previous parallel sparse assemble. Used to optimise the next call to \mbox{\hyperlink{classoomph_1_1Problem_a0487a7ef40e6cc4dad88e99ac96193e2}{parallel\+\_\+sparse\+\_\+assemble()}} \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classoomph_1_1Problem_a1d79584bd556f960d5b92474681e0159}{Fold\+Handler}}
\item 
class \mbox{\hyperlink{classoomph_1_1Problem_a58bcd2e5d47842c64018e2c842bff302}{Pitch\+Fork\+Handler}}
\item 
class \mbox{\hyperlink{classoomph_1_1Problem_a5653c9ce9d673e348e945594469ce0d3}{Hopf\+Handler}}
\item 
{\footnotesize template$<$unsigned NNODE\+\_\+1D$>$ }\\class \mbox{\hyperlink{classoomph_1_1Problem_a2cbe986bcd27c28d5de7ada068d3d94c}{Periodic\+Orbit\+Assembly\+Handler}}
\item 
class \mbox{\hyperlink{classoomph_1_1Problem_a32e190795c94d11d2e206e62eb63994b}{Block\+Fold\+Linear\+Solver}}
\item 
class \mbox{\hyperlink{classoomph_1_1Problem_aba62ac8cc057be07657972adc4a78b45}{Block\+Pitch\+Fork\+Linear\+Solver}}
\item 
class \mbox{\hyperlink{classoomph_1_1Problem_a29d9c39e6a14d2a4cc4e0d7c716579fe}{Augmented\+Block\+Fold\+Linear\+Solver}}
\item 
class \mbox{\hyperlink{classoomph_1_1Problem_a223dd55e02e905ce0ce98e98f50b7e57}{Augmented\+Block\+Pitch\+Fork\+Linear\+Solver}}
\item 
class \mbox{\hyperlink{classoomph_1_1Problem_a199677d64d3b2f908690d10a2398b737}{Block\+Hopf\+Linear\+Solver}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
////////////////////////////////////////////////////////////////// ////////////////////////////////////////////////////////////////// 

The \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} class

The main components of a \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} are\+:
\begin{DoxyItemize}
\item a pointer to the (global) \mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} (which provides ordered access to the nodes, elements, etc of all submeshes in the problem -- if there are any)
\item pointers to the submeshes (if there are any)
\item pointers to any global \mbox{\hyperlink{classoomph_1_1Data}{Data}}
\item a pointer to the global \mbox{\hyperlink{classoomph_1_1Time}{Time}}
\item pointers to the Timestepper used in the problem
\item a pointer to the linear solver that will be used in Newton\textquotesingle{}s method
\item pointers to all DOFs in the problem.
\end{DoxyItemize}

Obviously, at this level in the code hierarchy, many things become very problem-\/dependent but when setting up a specific problem (as a class that inherits from \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}), the problem constructor will/should typically have a structure similar to this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Set up a timestepper}}
\DoxyCodeLine{ TimeStepper* \mbox{\hyperlink{classoomph_1_1Problem_ad77413dc70a25d271f582ad3c3d7bf65}{time\_stepper\_pt}}=\textcolor{keyword}{new} Steady;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Add timestepper to problem}}
\DoxyCodeLine{ \mbox{\hyperlink{classoomph_1_1Problem_a8856eae2daa9cea05e99bfcd4ef340a4}{add\_time\_stepper\_pt}}(\mbox{\hyperlink{classoomph_1_1Problem_ad77413dc70a25d271f582ad3c3d7bf65}{time\_stepper\_pt}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Build and assign mesh}}
\DoxyCodeLine{ \mbox{\hyperlink{classoomph_1_1Problem_aad122d70a22dc5302cfd5853d3cf3057}{Problem::mesh\_pt}}() = \textcolor{keyword}{new}}
\DoxyCodeLine{ SomeMesh<ELEMENT\_TYPE>(Nelement,\mbox{\hyperlink{classoomph_1_1Problem_ad77413dc70a25d271f582ad3c3d7bf65}{time\_stepper\_pt}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}}
\DoxyCodeLine{\textcolor{comment}{// free by default -\/-\/ just pin the ones that have Dirichlet conditions}}
\DoxyCodeLine{\textcolor{comment}{// here (boundary 0 in this example)}}
\DoxyCodeLine{\textcolor{keywordtype}{unsigned} i\_bound = 0}
\DoxyCodeLine{\textcolor{keywordtype}{unsigned} num\_nod= \mbox{\hyperlink{classoomph_1_1Problem_aad122d70a22dc5302cfd5853d3cf3057}{mesh\_pt}}()-\/>\mbox{\hyperlink{classoomph_1_1Mesh_a034677ceb48c67769acb83f304c84f7d}{nboundary\_node}}(ibound);}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)}
\DoxyCodeLine{   \{}
\DoxyCodeLine{     \mbox{\hyperlink{classoomph_1_1Problem_aad122d70a22dc5302cfd5853d3cf3057}{mesh\_pt}}()-\/>\mbox{\hyperlink{classoomph_1_1Mesh_aca0a21f4eab2d6fe8c7fa011b5c33c3c}{boundary\_node\_pt}}(ibound,inod)-\/>\mbox{\hyperlink{classoomph_1_1Data_a422231c58e423f0b43822827aa334d79}{pin}}(0);}
\DoxyCodeLine{   \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Complete the build of all elements so they are fully functional}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{comment}{// Setup equation numbering scheme}}
\DoxyCodeLine{ \mbox{\hyperlink{namespaceoomph_aec474227917784dc0a255faf289cfc16}{oomph\_info}} <<\textcolor{stringliteral}{"{}Number of equations: "{}} << \mbox{\hyperlink{classoomph_1_1Problem_a0df501c6aed60c4938861df776b10119}{assign\_eqn\_numbers}}() <<}
\DoxyCodeLine{ std::endl;}

\end{DoxyCode}
 For time-\/dependent problems, we can then use 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classoomph_1_1Problem_a10e5dc4d944dfb2b141918e18e5e3de8}{assign\_initial\_values\_impulsive}} (); }

\end{DoxyCode}
 to generate an initial guess (for an impulsive start) and the problem can then be solved, e.\+g. using the steady or unsteady Newton solvers 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classoomph_1_1Problem_a62a989ae9a9169b9d905f844db59787f}{newton\_solve}}() }

\end{DoxyCode}
 or 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classoomph_1_1Problem_aef22157aadc15a512cca93e4c423ff73}{unsteady\_newton\_solve}}(...) }

\end{DoxyCode}
 

Definition at line 150 of file problem.\+h.



\doxysubsection{Member Typedef Documentation}
\mbox{\Hypertarget{classoomph_1_1Problem_a638b525d7cae45e56160e3c282c8ad09}\label{classoomph_1_1Problem_a638b525d7cae45e56160e3c282c8ad09}} 
\index{oomph::Problem@{oomph::Problem}!SpatialErrorEstimatorFctPt@{SpatialErrorEstimatorFctPt}}
\index{SpatialErrorEstimatorFctPt@{SpatialErrorEstimatorFctPt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{SpatialErrorEstimatorFctPt}{SpatialErrorEstimatorFctPt}}
{\footnotesize\ttfamily typedef void($\ast$ oomph\+::\+Problem\+::\+Spatial\+Error\+Estimator\+Fct\+Pt) (\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$\&\mbox{\hyperlink{classoomph_1_1Problem_aad122d70a22dc5302cfd5853d3cf3057}{mesh\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&elemental\+\_\+error)}



Function pointer for spatial error estimator. 



Definition at line 1258 of file problem.\+h.

\mbox{\Hypertarget{classoomph_1_1Problem_a220abfde16b8b1b544b4127e0e4cc9e4}\label{classoomph_1_1Problem_a220abfde16b8b1b544b4127e0e4cc9e4}} 
\index{oomph::Problem@{oomph::Problem}!SpatialErrorEstimatorWithDocFctPt@{SpatialErrorEstimatorWithDocFctPt}}
\index{SpatialErrorEstimatorWithDocFctPt@{SpatialErrorEstimatorWithDocFctPt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{SpatialErrorEstimatorWithDocFctPt}{SpatialErrorEstimatorWithDocFctPt}}
{\footnotesize\ttfamily typedef void($\ast$ oomph\+::\+Problem\+::\+Spatial\+Error\+Estimator\+With\+Doc\+Fct\+Pt) (\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$\&\mbox{\hyperlink{classoomph_1_1Problem_aad122d70a22dc5302cfd5853d3cf3057}{mesh\+\_\+pt}}, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&elemental\+\_\+error, \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&doc\+\_\+info)}



Function pointer for spatial error estimator with doc. 



Definition at line 1262 of file problem.\+h.



\doxysubsection{Member Enumeration Documentation}
\mbox{\Hypertarget{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7}\label{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7}} 
\index{oomph::Problem@{oomph::Problem}!Assembly\_method@{Assembly\_method}}
\index{Assembly\_method@{Assembly\_method}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Assembly\_method}{Assembly\_method}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7}{oomph\+::\+Problem\+::\+Assembly\+\_\+method}}\hspace{0.3cm}{\ttfamily [protected]}}



Enumerated flags to determine which sparse assembly method is used. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{Perform\_assembly\_using\_vectors\_of\_pairs@{Perform\_assembly\_using\_vectors\_of\_pairs}!oomph::Problem@{oomph::Problem}}\index{oomph::Problem@{oomph::Problem}!Perform\_assembly\_using\_vectors\_of\_pairs@{Perform\_assembly\_using\_vectors\_of\_pairs}}}\mbox{\Hypertarget{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7aa00e1772bb5ccf1c837a2bad2f240241}\label{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7aa00e1772bb5ccf1c837a2bad2f240241}} 
Perform\+\_\+assembly\+\_\+using\+\_\+vectors\+\_\+of\+\_\+pairs&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Perform\_assembly\_using\_two\_vectors@{Perform\_assembly\_using\_two\_vectors}!oomph::Problem@{oomph::Problem}}\index{oomph::Problem@{oomph::Problem}!Perform\_assembly\_using\_two\_vectors@{Perform\_assembly\_using\_two\_vectors}}}\mbox{\Hypertarget{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7a6008d2b6aa449ee405313b49632d18ff}\label{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7a6008d2b6aa449ee405313b49632d18ff}} 
Perform\+\_\+assembly\+\_\+using\+\_\+two\+\_\+vectors&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Perform\_assembly\_using\_maps@{Perform\_assembly\_using\_maps}!oomph::Problem@{oomph::Problem}}\index{oomph::Problem@{oomph::Problem}!Perform\_assembly\_using\_maps@{Perform\_assembly\_using\_maps}}}\mbox{\Hypertarget{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7a406ad24599e1a59450acdd09bac1d717}\label{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7a406ad24599e1a59450acdd09bac1d717}} 
Perform\+\_\+assembly\+\_\+using\+\_\+maps&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Perform\_assembly\_using\_lists@{Perform\_assembly\_using\_lists}!oomph::Problem@{oomph::Problem}}\index{oomph::Problem@{oomph::Problem}!Perform\_assembly\_using\_lists@{Perform\_assembly\_using\_lists}}}\mbox{\Hypertarget{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7ad73bb55e4e1f000cfd6930cb8b2a52f8}\label{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7ad73bb55e4e1f000cfd6930cb8b2a52f8}} 
Perform\+\_\+assembly\+\_\+using\+\_\+lists&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Perform\_assembly\_using\_two\_arrays@{Perform\_assembly\_using\_two\_arrays}!oomph::Problem@{oomph::Problem}}\index{oomph::Problem@{oomph::Problem}!Perform\_assembly\_using\_two\_arrays@{Perform\_assembly\_using\_two\_arrays}}}\mbox{\Hypertarget{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7a1383f03857ad8602ba7edef43bd947f5}\label{classoomph_1_1Problem_ac793c004113930938730ec04dd2245b7a1383f03857ad8602ba7edef43bd947f5}} 
Perform\+\_\+assembly\+\_\+using\+\_\+two\+\_\+arrays&\\
\hline

\end{DoxyEnumFields}


Definition at line 644 of file problem.\+h.

\mbox{\Hypertarget{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402}\label{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402}} 
\index{oomph::Problem@{oomph::Problem}!Distributed\_problem\_matrix\_distribution@{Distributed\_problem\_matrix\_distribution}}
\index{Distributed\_problem\_matrix\_distribution@{Distributed\_problem\_matrix\_distribution}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Distributed\_problem\_matrix\_distribution}{Distributed\_problem\_matrix\_distribution}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402}{oomph\+::\+Problem\+::\+Distributed\+\_\+problem\+\_\+matrix\+\_\+distribution}}}



enum for distribution of distributed jacobians. 1 -\/ Automatic -\/ the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} distribution is employed, unless any processor has number of rows equal to 110\% of N/P, in which case uniform distribution is employed. 2 -\/ \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} -\/ the jacobian on processor p only contains rows that correspond to equations that are on this processor. (minimises communication) 3 -\/ Uniform -\/ each processor holds as close to N/P matrix rows as possible. (very well load balanced) 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{Default\_matrix\_distribution@{Default\_matrix\_distribution}!oomph::Problem@{oomph::Problem}}\index{oomph::Problem@{oomph::Problem}!Default\_matrix\_distribution@{Default\_matrix\_distribution}}}\mbox{\Hypertarget{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402ad7503f3fef4bc3556497018171c820e6}\label{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402ad7503f3fef4bc3556497018171c820e6}} 
Default\+\_\+matrix\+\_\+distribution&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Problem\_matrix\_distribution@{Problem\_matrix\_distribution}!oomph::Problem@{oomph::Problem}}\index{oomph::Problem@{oomph::Problem}!Problem\_matrix\_distribution@{Problem\_matrix\_distribution}}}\mbox{\Hypertarget{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402aed8521359adcaf514039424b29893796}\label{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402aed8521359adcaf514039424b29893796}} 
Problem\+\_\+matrix\+\_\+distribution&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Uniform\_matrix\_distribution@{Uniform\_matrix\_distribution}!oomph::Problem@{oomph::Problem}}\index{oomph::Problem@{oomph::Problem}!Uniform\_matrix\_distribution@{Uniform\_matrix\_distribution}}}\mbox{\Hypertarget{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402a741cb51275fde6a02373b2ffacf1273f}\label{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402a741cb51275fde6a02373b2ffacf1273f}} 
Uniform\+\_\+matrix\+\_\+distribution&\\
\hline

\end{DoxyEnumFields}


Definition at line 829 of file problem.\+h.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classoomph_1_1Problem_a3f071f2f8be895dbe0d39d12ca59acf4}\label{classoomph_1_1Problem_a3f071f2f8be895dbe0d39d12ca59acf4}} 
\index{oomph::Problem@{oomph::Problem}!Problem@{Problem}}
\index{Problem@{Problem}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Problem()}{Problem()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily oomph\+::\+Problem\+::\+Problem (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Constructor\+: Allocate space for one time stepper and set all pointers to NULL and set defaults for all parameters. 

Setup terminate helper

Definition at line 69 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, oomph\+::\+MPI\+\_\+\+Helpers\+::communicator\+\_\+pt(), Communicator\+\_\+pt, Default\+\_\+assembly\+\_\+handler\+\_\+pt, Default\+\_\+eigen\+\_\+solver\+\_\+pt, Default\+\_\+linear\+\_\+solver\+\_\+pt, Dof\+\_\+distribution\+\_\+pt, Eigen\+\_\+solver\+\_\+pt, Linear\+\_\+solver\+\_\+pt, Mass\+\_\+matrix\+\_\+solver\+\_\+for\+\_\+explicit\+\_\+timestepper\+\_\+pt, oomph\+::\+MPI\+\_\+\+Helpers\+::mpi\+\_\+has\+\_\+been\+\_\+initialised(), oomph\+::\+Terminate\+Helper\+::setup(), Sub\+\_\+mesh\+\_\+pt, Time\+\_\+stepper\+\_\+pt, and Use\+\_\+predictor\+\_\+values\+\_\+as\+\_\+initial\+\_\+guess.

\mbox{\Hypertarget{classoomph_1_1Problem_a32f06ae01ba0bf2e827ccd9045c40183}\label{classoomph_1_1Problem_a32f06ae01ba0bf2e827ccd9045c40183}} 
\index{oomph::Problem@{oomph::Problem}!Problem@{Problem}}
\index{Problem@{Problem}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Problem()}{Problem()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily oomph\+::\+Problem\+::\+Problem (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} \&}]{dummy }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}



Broken copy constructor. 

\mbox{\Hypertarget{classoomph_1_1Problem_ae2cd468ec03f7ede23c0dc8eea3be1cf}\label{classoomph_1_1Problem_ae2cd468ec03f7ede23c0dc8eea3be1cf}} 
\index{oomph::Problem@{oomph::Problem}!````~Problem@{$\sim$Problem}}
\index{````~Problem@{$\sim$Problem}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{$\sim$Problem()}{~Problem()}}
{\footnotesize\ttfamily oomph\+::\+Problem\+::$\sim$\+Problem (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Virtual destructor to clean up memory. 

Destructor to clean up memory. 

Definition at line 181 of file problem.\+cc.



References oomph\+::\+Terminate\+Helper\+::clean\+\_\+up\+\_\+memory(), Communicator\+\_\+pt, Copy\+\_\+of\+\_\+problem\+\_\+pt, Default\+\_\+assembly\+\_\+handler\+\_\+pt, Default\+\_\+eigen\+\_\+solver\+\_\+pt, Default\+\_\+linear\+\_\+solver\+\_\+pt, Dof\+\_\+distribution\+\_\+pt, oomph\+::\+Mesh\+::flush\+\_\+element\+\_\+and\+\_\+node\+\_\+storage(), Mesh\+\_\+pt, Sub\+\_\+mesh\+\_\+pt, and Time\+\_\+pt.



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classoomph_1_1Problem_ada40ec6730506c01109622c8383fe36e}\label{classoomph_1_1Problem_ada40ec6730506c01109622c8383fe36e}} 
\index{oomph::Problem@{oomph::Problem}!actions\_after\_adapt@{actions\_after\_adapt}}
\index{actions\_after\_adapt@{actions\_after\_adapt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_after\_adapt()}{actions\_after\_adapt()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+after\+\_\+adapt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Actions that are to be performed after a mesh adaptation. 



Definition at line 1025 of file problem.\+h.



Referenced by adapt(), adapt\+\_\+based\+\_\+on\+\_\+error\+\_\+estimates(), load\+\_\+balance(), p\+\_\+adapt(), p\+\_\+refine\+\_\+selected\+\_\+elements(), p\+\_\+refine\+\_\+uniformly(), p\+\_\+refine\+\_\+uniformly\+\_\+aux(), p\+\_\+unrefine\+\_\+uniformly(), read(), refine\+\_\+selected\+\_\+elements(), refine\+\_\+uniformly(), refine\+\_\+uniformly\+\_\+aux(), oomph\+::\+MGSolver$<$ DIM $>$\+::setup\+\_\+mg\+\_\+hierarchy(), oomph\+::\+Helmholtz\+MGPreconditioner$<$ DIM $>$\+::setup\+\_\+mg\+\_\+hierarchy(), and unrefine\+\_\+uniformly().

\mbox{\Hypertarget{classoomph_1_1Problem_a5f08629e3c9c72b441ec7f19f175b2c7}\label{classoomph_1_1Problem_a5f08629e3c9c72b441ec7f19f175b2c7}} 
\index{oomph::Problem@{oomph::Problem}!actions\_after\_change\_in\_bifurcation\_parameter@{actions\_after\_change\_in\_bifurcation\_parameter}}
\index{actions\_after\_change\_in\_bifurcation\_parameter@{actions\_after\_change\_in\_bifurcation\_parameter}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_after\_change\_in\_bifurcation\_parameter()}{actions\_after\_change\_in\_bifurcation\_parameter()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+after\+\_\+change\+\_\+in\+\_\+bifurcation\+\_\+parameter (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Actions that are to be performed after a change in the parameter that is being varied as part of the solution of a bifurcation detection problem. The default is to call \mbox{\hyperlink{classoomph_1_1Problem_a0c8d70891f7369bb4bf8412fa1a08ecb}{actions\+\_\+before\+\_\+newton\+\_\+solve()}}, \mbox{\hyperlink{classoomph_1_1Problem_ae6ad96ddf5d48b517b89c9a9b879bc4b}{actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()}} and \mbox{\hyperlink{classoomph_1_1Problem_a033ec7301123deeb7e56d04c38f9f1da}{actions\+\_\+after\+\_\+newton\+\_\+solve()}}. This could be amazingly inefficient in certain problems and should be overloaded in such cases. An example would be when a remesh is required in general, but the global parameter does not affect the mesh directly. 



Definition at line 1151 of file problem.\+h.



References actions\+\_\+after\+\_\+newton\+\_\+solve(), actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check(), and actions\+\_\+before\+\_\+newton\+\_\+solve().



Referenced by oomph\+::\+Fold\+Handler\+::get\+\_\+jacobian(), oomph\+::\+Pitch\+Fork\+Handler\+::get\+\_\+jacobian(), oomph\+::\+Hopf\+Handler\+::get\+\_\+jacobian(), oomph\+::\+Augmented\+Block\+Fold\+Linear\+Solver\+::resolve(), oomph\+::\+Augmented\+Block\+Pitch\+Fork\+Linear\+Solver\+::resolve(), oomph\+::\+Augmented\+Block\+Fold\+Linear\+Solver\+::solve(), oomph\+::\+Augmented\+Block\+Pitch\+Fork\+Linear\+Solver\+::solve(), oomph\+::\+Block\+Hopf\+Linear\+Solver\+::solve(), and oomph\+::\+Block\+Hopf\+Linear\+Solver\+::solve\+\_\+for\+\_\+two\+\_\+rhs().

\mbox{\Hypertarget{classoomph_1_1Problem_a1e90bbe5d279295b97ae704487259bcc}\label{classoomph_1_1Problem_a1e90bbe5d279295b97ae704487259bcc}} 
\index{oomph::Problem@{oomph::Problem}!actions\_after\_change\_in\_global\_parameter@{actions\_after\_change\_in\_global\_parameter}}
\index{actions\_after\_change\_in\_global\_parameter@{actions\_after\_change\_in\_global\_parameter}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_after\_change\_in\_global\_parameter()}{actions\_after\_change\_in\_global\_parameter()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+after\+\_\+change\+\_\+in\+\_\+global\+\_\+parameter (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Actions that are to be performed when the global parameter addressed by parameter\+\_\+pt has been changed in the function \mbox{\hyperlink{classoomph_1_1Problem_af4d959a47ef6a8d50b394a6761dfab5a}{get\+\_\+derivative\+\_\+wrt\+\_\+global\+\_\+parameter()}} The default is to call \mbox{\hyperlink{classoomph_1_1Problem_a0c8d70891f7369bb4bf8412fa1a08ecb}{actions\+\_\+before\+\_\+newton\+\_\+solve()}}, \mbox{\hyperlink{classoomph_1_1Problem_ae6ad96ddf5d48b517b89c9a9b879bc4b}{actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()}} and \mbox{\hyperlink{classoomph_1_1Problem_a033ec7301123deeb7e56d04c38f9f1da}{actions\+\_\+after\+\_\+newton\+\_\+solve()}}. This could be amazingly inefficient in certain problems and should be overloaded in such cases. An example would be when a remesh is required in general, but the global parameter does not affect the mesh directly. 



Definition at line 1133 of file problem.\+h.



References actions\+\_\+after\+\_\+newton\+\_\+solve(), actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check(), and actions\+\_\+before\+\_\+newton\+\_\+solve().



Referenced by get\+\_\+derivative\+\_\+wrt\+\_\+global\+\_\+parameter().

\mbox{\Hypertarget{classoomph_1_1Problem_a4d3e3bd312518ca5afef94e169f81c39}\label{classoomph_1_1Problem_a4d3e3bd312518ca5afef94e169f81c39}} 
\index{oomph::Problem@{oomph::Problem}!actions\_after\_distribute@{actions\_after\_distribute}}
\index{actions\_after\_distribute@{actions\_after\_distribute}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_after\_distribute()}{actions\_after\_distribute()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+after\+\_\+distribute (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Actions to be performed after a (mesh) distribution. 



Definition at line 1119 of file problem.\+h.



Referenced by distribute(), load\+\_\+balance(), and prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes().

\mbox{\Hypertarget{classoomph_1_1Problem_a51bfd872c45467a65ce977f3753a6d1d}\label{classoomph_1_1Problem_a51bfd872c45467a65ce977f3753a6d1d}} 
\index{oomph::Problem@{oomph::Problem}!actions\_after\_explicit\_timestep@{actions\_after\_explicit\_timestep}}
\index{actions\_after\_explicit\_timestep@{actions\_after\_explicit\_timestep}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_after\_explicit\_timestep()}{actions\_after\_explicit\_timestep()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+after\+\_\+explicit\+\_\+timestep (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Actions that should be performed after each explicit time step. 



Reimplemented from \mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject_a22371b17397f74660c8e9d54ed50ccea}{oomph\+::\+Explicit\+Time\+Steppable\+Object}}.



Definition at line 1081 of file problem.\+h.

\mbox{\Hypertarget{classoomph_1_1Problem_a012692496c968960f4ea27db4e89cc7d}\label{classoomph_1_1Problem_a012692496c968960f4ea27db4e89cc7d}} 
\index{oomph::Problem@{oomph::Problem}!actions\_after\_implicit\_timestep@{actions\_after\_implicit\_timestep}}
\index{actions\_after\_implicit\_timestep@{actions\_after\_implicit\_timestep}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_after\_implicit\_timestep()}{actions\_after\_implicit\_timestep()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+after\+\_\+implicit\+\_\+timestep (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Actions that should be performed after each implicit time step. This is needed when one wants to solve a steady problem before timestepping and needs to distinguish between the two cases. 



Definition at line 1070 of file problem.\+h.



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), unsteady\+\_\+newton\+\_\+solve(), and oomph\+::\+Segregatable\+FSIProblem\+::unsteady\+\_\+segregated\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a38d914a74e7998ddc74c205884d36d57}\label{classoomph_1_1Problem_a38d914a74e7998ddc74c205884d36d57}} 
\index{oomph::Problem@{oomph::Problem}!actions\_after\_implicit\_timestep\_and\_error\_estimation@{actions\_after\_implicit\_timestep\_and\_error\_estimation}}
\index{actions\_after\_implicit\_timestep\_and\_error\_estimation@{actions\_after\_implicit\_timestep\_and\_error\_estimation}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_after\_implicit\_timestep\_and\_error\_estimation()}{actions\_after\_implicit\_timestep\_and\_error\_estimation()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+after\+\_\+implicit\+\_\+timestep\+\_\+and\+\_\+error\+\_\+estimation (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Actions that should be performed after each implicit time step. This is needed if your \mbox{\hyperlink{classoomph_1_1Problem_a012692496c968960f4ea27db4e89cc7d}{actions\+\_\+after\+\_\+implicit\+\_\+timestep()}} modify the solution in a way that affects the error estimate. 



Definition at line 1075 of file problem.\+h.



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), and unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a033ec7301123deeb7e56d04c38f9f1da}\label{classoomph_1_1Problem_a033ec7301123deeb7e56d04c38f9f1da}} 
\index{oomph::Problem@{oomph::Problem}!actions\_after\_newton\_solve@{actions\_after\_newton\_solve}}
\index{actions\_after\_newton\_solve@{actions\_after\_newton\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_after\_newton\_solve()}{actions\_after\_newton\_solve()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+after\+\_\+newton\+\_\+solve (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Any actions that are to be performed after a complete Newton solve, e.\+g. post processing. CAREFUL\+: This step should (and if the FD-\/based \mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} \mbox{\hyperlink{classoomph_1_1FD__LU}{FD\+\_\+\+LU}} is used, must) only update values that are pinned! 



Reimplemented in \mbox{\hyperlink{classoomph_1_1WomersleyProblem_a248ab44d5058e1e29dab4fbfc52bf942}{oomph\+::\+Womersley\+Problem$<$ ELEMENT, DIM $>$}}, \mbox{\hyperlink{classoomph_1_1SolidICProblem_afef1ae777a009afd2329dcb091862f69}{oomph\+::\+Solid\+ICProblem}}, \mbox{\hyperlink{classoomph_1_1BiharmonicFluidProblem_a6a69be0763564ffd22f598d734d11a26}{oomph\+::\+Biharmonic\+Fluid\+Problem$<$ DIM $>$}}, and \mbox{\hyperlink{classoomph_1_1BiharmonicProblem_ad685995c81201b8e5dfa7136e1858713}{oomph\+::\+Biharmonic\+Problem$<$ DIM $>$}}.



Definition at line 1038 of file problem.\+h.



Referenced by actions\+\_\+after\+\_\+change\+\_\+in\+\_\+bifurcation\+\_\+parameter(), actions\+\_\+after\+\_\+change\+\_\+in\+\_\+global\+\_\+parameter(), adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), get\+\_\+fd\+\_\+jacobian(), newton\+\_\+solve(), and newton\+\_\+solve\+\_\+continuation().

\mbox{\Hypertarget{classoomph_1_1Problem_aed8bc6e7b0bb45b86d5b44737b554d50}\label{classoomph_1_1Problem_aed8bc6e7b0bb45b86d5b44737b554d50}} 
\index{oomph::Problem@{oomph::Problem}!actions\_after\_newton\_step@{actions\_after\_newton\_step}}
\index{actions\_after\_newton\_step@{actions\_after\_newton\_step}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_after\_newton\_step()}{actions\_after\_newton\_step()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+after\+\_\+newton\+\_\+step (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Any actions that are to be performed after each individual Newton step. Most likely to be used for diagnostic purposes to doc the solution during a non-\/converging iteration, say. 



Definition at line 1058 of file problem.\+h.



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), newton\+\_\+solve(), and newton\+\_\+solve\+\_\+continuation().

\mbox{\Hypertarget{classoomph_1_1Problem_a54e18ddf6073f9debd478f6b21a717de}\label{classoomph_1_1Problem_a54e18ddf6073f9debd478f6b21a717de}} 
\index{oomph::Problem@{oomph::Problem}!actions\_after\_parameter\_increase@{actions\_after\_parameter\_increase}}
\index{actions\_after\_parameter\_increase@{actions\_after\_parameter\_increase}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_after\_parameter\_increase()}{actions\_after\_parameter\_increase()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+after\+\_\+parameter\+\_\+increase (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Empty virtual function; provides hook to perform actions after the increase in the arclength parameter (during continuation) 



Definition at line 1161 of file problem.\+h.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_a498317b3e390eddf2169ab989ee8d6b4}\label{classoomph_1_1Problem_a498317b3e390eddf2169ab989ee8d6b4}} 
\index{oomph::Problem@{oomph::Problem}!actions\_after\_read\_unstructured\_meshes@{actions\_after\_read\_unstructured\_meshes}}
\index{actions\_after\_read\_unstructured\_meshes@{actions\_after\_read\_unstructured\_meshes}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_after\_read\_unstructured\_meshes()}{actions\_after\_read\_unstructured\_meshes()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+after\+\_\+read\+\_\+unstructured\+\_\+meshes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Actions that are to be performed before reading in restart data for problems involving unstructured bulk meshes. Typically used to re-\/attach Face\+Elements, say, that were stripped out in \mbox{\hyperlink{classoomph_1_1Problem_af10662119a7a0c3a47879fa0d0644452}{actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes()}}. This function is virtual and (practically) empty but toggles a flag to indicate that it has been called. This is used to issue a warning, prompting the user to consider overloading it if the problem is found to contain unstructured bulk meshes during restarts. 



Definition at line 1109 of file problem.\+h.



References Empty\+\_\+actions\+\_\+after\+\_\+read\+\_\+unstructured\+\_\+meshes\+\_\+has\+\_\+been\+\_\+called.



Referenced by read().

\mbox{\Hypertarget{classoomph_1_1Problem_a6130d5c9a762cdd1569919a601620796}\label{classoomph_1_1Problem_a6130d5c9a762cdd1569919a601620796}} 
\index{oomph::Problem@{oomph::Problem}!actions\_before\_adapt@{actions\_before\_adapt}}
\index{actions\_before\_adapt@{actions\_before\_adapt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_before\_adapt()}{actions\_before\_adapt()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+before\+\_\+adapt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Actions that are to be performed before a mesh adaptation. These might include removing any additional elements, such as traction boundary elements before the adaptation. 



Definition at line 1022 of file problem.\+h.



Referenced by adapt(), adapt\+\_\+based\+\_\+on\+\_\+error\+\_\+estimates(), load\+\_\+balance(), p\+\_\+adapt(), p\+\_\+refine\+\_\+selected\+\_\+elements(), p\+\_\+refine\+\_\+uniformly(), p\+\_\+refine\+\_\+uniformly\+\_\+aux(), p\+\_\+unrefine\+\_\+uniformly(), read(), refine\+\_\+selected\+\_\+elements(), refine\+\_\+uniformly(), refine\+\_\+uniformly\+\_\+aux(), oomph\+::\+MGSolver$<$ DIM $>$\+::setup\+\_\+mg\+\_\+hierarchy(), oomph\+::\+Helmholtz\+MGPreconditioner$<$ DIM $>$\+::setup\+\_\+mg\+\_\+hierarchy(), and unrefine\+\_\+uniformly().

\mbox{\Hypertarget{classoomph_1_1Problem_a1d1280f442f9352a614bada21324456d}\label{classoomph_1_1Problem_a1d1280f442f9352a614bada21324456d}} 
\index{oomph::Problem@{oomph::Problem}!actions\_before\_distribute@{actions\_before\_distribute}}
\index{actions\_before\_distribute@{actions\_before\_distribute}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_before\_distribute()}{actions\_before\_distribute()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+before\+\_\+distribute (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Actions to be performed before a (mesh) distribution. 



Definition at line 1116 of file problem.\+h.



Referenced by distribute(), load\+\_\+balance(), and prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes().

\mbox{\Hypertarget{classoomph_1_1Problem_a6ae06bc0ecba349ebdf76220c1a17546}\label{classoomph_1_1Problem_a6ae06bc0ecba349ebdf76220c1a17546}} 
\index{oomph::Problem@{oomph::Problem}!actions\_before\_explicit\_timestep@{actions\_before\_explicit\_timestep}}
\index{actions\_before\_explicit\_timestep@{actions\_before\_explicit\_timestep}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_before\_explicit\_timestep()}{actions\_before\_explicit\_timestep()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+before\+\_\+explicit\+\_\+timestep (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Actions that should be performed before each explicit time step. 



Reimplemented from \mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject_ae169b713aa971921bfd1269de898b934}{oomph\+::\+Explicit\+Time\+Steppable\+Object}}.



Definition at line 1078 of file problem.\+h.

\mbox{\Hypertarget{classoomph_1_1Problem_a4f19896906d2c0274ad6798cd3ac38dc}\label{classoomph_1_1Problem_a4f19896906d2c0274ad6798cd3ac38dc}} 
\index{oomph::Problem@{oomph::Problem}!actions\_before\_implicit\_timestep@{actions\_before\_implicit\_timestep}}
\index{actions\_before\_implicit\_timestep@{actions\_before\_implicit\_timestep}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_before\_implicit\_timestep()}{actions\_before\_implicit\_timestep()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+before\+\_\+implicit\+\_\+timestep (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Actions that should be performed before each implicit time step. This is needed when one wants to solve a steady problem before timestepping and needs to distinguish between the two cases. 



Reimplemented in \mbox{\hyperlink{classoomph_1_1WomersleyProblem_af87f80658aaadaee2d7c8d0c06ad159e}{oomph\+::\+Womersley\+Problem$<$ ELEMENT, DIM $>$}}.



Definition at line 1064 of file problem.\+h.



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), unsteady\+\_\+newton\+\_\+solve(), and oomph\+::\+Segregatable\+FSIProblem\+::unsteady\+\_\+segregated\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_ae6ad96ddf5d48b517b89c9a9b879bc4b}\label{classoomph_1_1Problem_ae6ad96ddf5d48b517b89c9a9b879bc4b}} 
\index{oomph::Problem@{oomph::Problem}!actions\_before\_newton\_convergence\_check@{actions\_before\_newton\_convergence\_check}}
\index{actions\_before\_newton\_convergence\_check@{actions\_before\_newton\_convergence\_check}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_before\_newton\_convergence\_check()}{actions\_before\_newton\_convergence\_check()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Any actions that are to be performed before the residual is checked in the Newton method, e.\+g. update any boundary conditions that depend upon variables of the problem; update any `dependent' variables; or perform an update of the nodal positions in Spine\+Meshes etc. CAREFUL\+: This step should (and if the FD-\/based \mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} \mbox{\hyperlink{classoomph_1_1FD__LU}{FD\+\_\+\+LU}} is used, must) only update values that are pinned! 



Definition at line 1048 of file problem.\+h.



Referenced by actions\+\_\+after\+\_\+change\+\_\+in\+\_\+bifurcation\+\_\+parameter(), actions\+\_\+after\+\_\+change\+\_\+in\+\_\+global\+\_\+parameter(), adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), oomph\+::\+Pitch\+Fork\+Handler\+::get\+\_\+dresiduals\+\_\+dparameter(), get\+\_\+fd\+\_\+jacobian(), get\+\_\+hessian\+\_\+vector\+\_\+products(), oomph\+::\+Fold\+Handler\+::get\+\_\+jacobian(), oomph\+::\+Pitch\+Fork\+Handler\+::get\+\_\+jacobian(), newton\+\_\+solve(), and newton\+\_\+solve\+\_\+continuation().

\mbox{\Hypertarget{classoomph_1_1Problem_a0c8d70891f7369bb4bf8412fa1a08ecb}\label{classoomph_1_1Problem_a0c8d70891f7369bb4bf8412fa1a08ecb}} 
\index{oomph::Problem@{oomph::Problem}!actions\_before\_newton\_solve@{actions\_before\_newton\_solve}}
\index{actions\_before\_newton\_solve@{actions\_before\_newton\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_before\_newton\_solve()}{actions\_before\_newton\_solve()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Any actions that are to be performed before a complete Newton solve (e.\+g. adjust boundary conditions). CAREFUL\+: This step should (and if the FD-\/based \mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}} \mbox{\hyperlink{classoomph_1_1FD__LU}{FD\+\_\+\+LU}} is used, must) only update values that are pinned! 



Reimplemented in \mbox{\hyperlink{classoomph_1_1WomersleyProblem_a7aa82fe18099c9770edf9fa8e79a2028}{oomph\+::\+Womersley\+Problem$<$ ELEMENT, DIM $>$}}, \mbox{\hyperlink{classoomph_1_1NonLinearElasticitySmoothMesh_a778763122903088b5234fcf7ca35a0b5}{oomph\+::\+Non\+Linear\+Elasticity\+Smooth\+Mesh$<$ ELEMENT $>$}}, \mbox{\hyperlink{classoomph_1_1SolidICProblem_ad234d3268b330cd2f532548103cb60fc}{oomph\+::\+Solid\+ICProblem}}, \mbox{\hyperlink{classoomph_1_1BiharmonicFluidProblem_ad62b36f8b36faae1324fe29fcd8e0875}{oomph\+::\+Biharmonic\+Fluid\+Problem$<$ DIM $>$}}, and \mbox{\hyperlink{classoomph_1_1BiharmonicProblem_a161f8a00ca635684bfd54880925cd5bf}{oomph\+::\+Biharmonic\+Problem$<$ DIM $>$}}.



Definition at line 1032 of file problem.\+h.



Referenced by actions\+\_\+after\+\_\+change\+\_\+in\+\_\+bifurcation\+\_\+parameter(), actions\+\_\+after\+\_\+change\+\_\+in\+\_\+global\+\_\+parameter(), get\+\_\+fd\+\_\+jacobian(), newton\+\_\+solve(), and newton\+\_\+solve\+\_\+continuation().

\mbox{\Hypertarget{classoomph_1_1Problem_a07fc81781c74b25c8a426ec18295b0d0}\label{classoomph_1_1Problem_a07fc81781c74b25c8a426ec18295b0d0}} 
\index{oomph::Problem@{oomph::Problem}!actions\_before\_newton\_step@{actions\_before\_newton\_step}}
\index{actions\_before\_newton\_step@{actions\_before\_newton\_step}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_before\_newton\_step()}{actions\_before\_newton\_step()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+before\+\_\+newton\+\_\+step (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Any actions that are to be performed before each individual Newton step. Most likely to be used for diagnostic purposes to doc the solution during a non-\/converging iteration, say. 



Definition at line 1053 of file problem.\+h.



Referenced by newton\+\_\+solve(), and newton\+\_\+solve\+\_\+continuation().

\mbox{\Hypertarget{classoomph_1_1Problem_af10662119a7a0c3a47879fa0d0644452}\label{classoomph_1_1Problem_af10662119a7a0c3a47879fa0d0644452}} 
\index{oomph::Problem@{oomph::Problem}!actions\_before\_read\_unstructured\_meshes@{actions\_before\_read\_unstructured\_meshes}}
\index{actions\_before\_read\_unstructured\_meshes@{actions\_before\_read\_unstructured\_meshes}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{actions\_before\_read\_unstructured\_meshes()}{actions\_before\_read\_unstructured\_meshes()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Actions that are to be performed before reading in restart data for problems involving unstructured bulk meshes. If the problem contains such meshes we need to strip out any face elements that are attached to them because restart of unstructured meshes re-\/creates their elements and nodes from scratch, leading to dangling pointers from the face elements to the old elements and nodes. This function is virtual and (practically) empty but toggles a flag to indicate that it has been called. This is used to issue a warning, prompting the user to consider overloading it if the problem is found to contain unstructured bulk meshes during restarts. 



Definition at line 1095 of file problem.\+h.



References Empty\+\_\+actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes\+\_\+has\+\_\+been\+\_\+called.



Referenced by read().

\mbox{\Hypertarget{classoomph_1_1Problem_a95359def89a0ee3d3df8976ab54c6591}\label{classoomph_1_1Problem_a95359def89a0ee3d3df8976ab54c6591}} 
\index{oomph::Problem@{oomph::Problem}!activate\_bifurcation\_tracking@{activate\_bifurcation\_tracking}}
\index{activate\_bifurcation\_tracking@{activate\_bifurcation\_tracking}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{activate\_bifurcation\_tracking()}{activate\_bifurcation\_tracking()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::activate\+\_\+bifurcation\+\_\+tracking (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt,  }\item[{const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{eigenvector,  }\item[{const bool \&}]{block\+\_\+solve = {\ttfamily true} }\end{DoxyParamCaption})}



Activate generic bifurcation tracking for a single (real) eigenvalue where the initial guess for the eigenvector can be specified. 

Activate the generic bifurcation ///tracking system by changing the assembly handler and initialising it using the parameter addressed by parameter\+\_\+pt. 

Definition at line 10322 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, Augmented\+Block\+Fold\+Linear\+Solver, Fold\+Handler, Linear\+\_\+solver\+\_\+pt, and reset\+\_\+assembly\+\_\+handler\+\_\+to\+\_\+default().

\mbox{\Hypertarget{classoomph_1_1Problem_a4610ef4c4f4d7c1d7001fabf074c930c}\label{classoomph_1_1Problem_a4610ef4c4f4d7c1d7001fabf074c930c}} 
\index{oomph::Problem@{oomph::Problem}!activate\_bifurcation\_tracking@{activate\_bifurcation\_tracking}}
\index{activate\_bifurcation\_tracking@{activate\_bifurcation\_tracking}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{activate\_bifurcation\_tracking()}{activate\_bifurcation\_tracking()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::activate\+\_\+bifurcation\+\_\+tracking (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt,  }\item[{const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{eigenvector,  }\item[{const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{normalisation,  }\item[{const bool \&}]{block\+\_\+solve = {\ttfamily true} }\end{DoxyParamCaption})}



Activate generic bifurcation tracking for a single (real) eigenvalue where the initial guess for the eigenvector can be specified and the normalisation condition can also be specified. 

Activate the generic bifurcation ///tracking system by changing the assembly handler and initialising it using the parameter addressed by parameter\+\_\+pt. 

Definition at line 10350 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, Augmented\+Block\+Fold\+Linear\+Solver, Fold\+Handler, Linear\+\_\+solver\+\_\+pt, and reset\+\_\+assembly\+\_\+handler\+\_\+to\+\_\+default().

\mbox{\Hypertarget{classoomph_1_1Problem_acf20e92281911dfbb423ea82542c0485}\label{classoomph_1_1Problem_acf20e92281911dfbb423ea82542c0485}} 
\index{oomph::Problem@{oomph::Problem}!activate\_fold\_tracking@{activate\_fold\_tracking}}
\index{activate\_fold\_tracking@{activate\_fold\_tracking}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{activate\_fold\_tracking()}{activate\_fold\_tracking()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::activate\+\_\+fold\+\_\+tracking (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt,  }\item[{const bool \&}]{block\+\_\+solve = {\ttfamily true} }\end{DoxyParamCaption})}



Turn on fold tracking using the augmented system specified in the \mbox{\hyperlink{classoomph_1_1FoldHandler}{Fold\+Handler}} class. After a call to this function subsequent calls of the standard solution methods will converge to a fold (limit) point at a particular value of the variable addressed by parameter\+\_\+pt. The system may not converge if the initial guess is sufficiently poor or, alternatively, if finite differencing is used to calculate the jacobian matrix in the elements. If the boolean flag block\+\_\+solver is true (the default) then a block factorisation is used to solve the augmented system which is both faster and uses less memory. 

Activate the fold tracking system by changing the assembly handler and initialising it using the parameter addressed by parameter\+\_\+pt. 

Definition at line 10296 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, Augmented\+Block\+Fold\+Linear\+Solver, Fold\+Handler, Linear\+\_\+solver\+\_\+pt, and reset\+\_\+assembly\+\_\+handler\+\_\+to\+\_\+default().



Referenced by bifurcation\+\_\+adapt\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_ac5966d1a184e722195f96d797b52e64c}\label{classoomph_1_1Problem_ac5966d1a184e722195f96d797b52e64c}} 
\index{oomph::Problem@{oomph::Problem}!activate\_hopf\_tracking@{activate\_hopf\_tracking}}
\index{activate\_hopf\_tracking@{activate\_hopf\_tracking}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{activate\_hopf\_tracking()}{activate\_hopf\_tracking()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::activate\+\_\+hopf\+\_\+tracking (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt,  }\item[{const bool \&}]{block\+\_\+solve = {\ttfamily true} }\end{DoxyParamCaption})}



Turn on Hopf bifurcation tracking using the augmented system specified in the \mbox{\hyperlink{classoomph_1_1HopfHandler}{Hopf\+Handler}} class. After a call to this function subsequent calls of the standard solution methods will converge to a Hopf bifuraction at a particular value of the variable addressed by parameter\+\_\+pt. The system may not converge if the initial guess is sufficiently poor or, alternatively, if finite differencing is used to calculate the jacobian matrix in the elements. 

Activate the hopf tracking system by changing the assembly handler and initialising it using the parameter addressed by parameter\+\_\+pt. 

Definition at line 10411 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, Block\+Hopf\+Linear\+Solver, Hopf\+Handler, Linear\+\_\+solver\+\_\+pt, and reset\+\_\+assembly\+\_\+handler\+\_\+to\+\_\+default().



Referenced by bifurcation\+\_\+adapt\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_aa0e2d0e105da6b676262d75481bcc8e3}\label{classoomph_1_1Problem_aa0e2d0e105da6b676262d75481bcc8e3}} 
\index{oomph::Problem@{oomph::Problem}!activate\_hopf\_tracking@{activate\_hopf\_tracking}}
\index{activate\_hopf\_tracking@{activate\_hopf\_tracking}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{activate\_hopf\_tracking()}{activate\_hopf\_tracking()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::activate\+\_\+hopf\+\_\+tracking (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt,  }\item[{const double \&}]{omega,  }\item[{const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{null\+\_\+real,  }\item[{const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{null\+\_\+imag,  }\item[{const bool \&}]{block\+\_\+solve = {\ttfamily true} }\end{DoxyParamCaption})}



Turn on Hopf bifurcation tracking using the augmented system specified in the \mbox{\hyperlink{classoomph_1_1HopfHandler}{Hopf\+Handler}} class. After a call to this function subsequent calls of the standard solution methods will converge to a Hopf bifuraction at a particular value of the variable addressed by parameter\+\_\+pt. The system may not converge if the initial guess is sufficiently poor or, alternatively, if finite differencing is used to calculate the jacobian matrix in the elements. This interface allows specification of an inital guess for the frequency and real and imaginary parts of the null vector, such as might be obtained from an eigensolve. 

Activate the hopf tracking system by changing the assembly handler and initialising it using the parameter addressed by parameter\+\_\+pt and the frequency and null vectors specified. 

Definition at line 10439 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, Block\+Hopf\+Linear\+Solver, Hopf\+Handler, Linear\+\_\+solver\+\_\+pt, and reset\+\_\+assembly\+\_\+handler\+\_\+to\+\_\+default().

\mbox{\Hypertarget{classoomph_1_1Problem_a7f5eb1f88a957cb3d8a11b558002d484}\label{classoomph_1_1Problem_a7f5eb1f88a957cb3d8a11b558002d484}} 
\index{oomph::Problem@{oomph::Problem}!activate\_pitchfork\_tracking@{activate\_pitchfork\_tracking}}
\index{activate\_pitchfork\_tracking@{activate\_pitchfork\_tracking}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{activate\_pitchfork\_tracking()}{activate\_pitchfork\_tracking()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::activate\+\_\+pitchfork\+\_\+tracking (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt,  }\item[{const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{symmetry\+\_\+vector,  }\item[{const bool \&}]{block\+\_\+solve = {\ttfamily true} }\end{DoxyParamCaption})}



Turn on pitchfork tracking using the augmented system specified in the \mbox{\hyperlink{classoomph_1_1PitchForkHandler}{Pitch\+Fork\+Handler}} class. After a call to this function subsequent calls of the standard solution methods will converge to a pitchfork bifurcation at a particular value of the variable addressed by parameter\+\_\+pt. The symmetry that is to be broken must be specified by supplying a symmetry\+\_\+vector(ndof). The easiest way to determine such a vector is to solve the associated eigenproblem $ Jx = \lambda M x$ and pass in the eigenvector. This is not always necessary however, if the symmetry is easy to construct. The system may not converge if the initial guess is sufficiently poor or, alternatively, if finite differencing is used to calculate the jacobian matrix in the elements. If the boolean flag block\+\_\+solver is true (the default) then a block factorisation is used to solve the augmented system which is both faster and requires less memory. 

Activate the pitchfork tracking system by changing the assembly handler and initialising it using the parameter addressed by parameter\+\_\+pt and a symmetry vector. The boolean flag is used to specify whether a block solver is used, default is true. 

Definition at line 10381 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, assembly\+\_\+handler\+\_\+pt(), Block\+Pitch\+Fork\+Linear\+Solver, Linear\+\_\+solver\+\_\+pt, Pitch\+Fork\+Handler, and reset\+\_\+assembly\+\_\+handler\+\_\+to\+\_\+default().



Referenced by bifurcation\+\_\+adapt\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_a0b9e09ddfa2411f14fc723c3207decd1}\label{classoomph_1_1Problem_a0b9e09ddfa2411f14fc723c3207decd1}} 
\index{oomph::Problem@{oomph::Problem}!adapt@{adapt}}
\index{adapt@{adapt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{adapt()}{adapt()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::adapt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on their own error estimates and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. On return from this function, \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} can immediately be solved again. \mbox{[}Argument-\/free wrapper\mbox{]}. 



Definition at line 2988 of file problem.\+h.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve\+\_\+helper(), newton\+\_\+solve(), and unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_afc4492ec2686c70467cb0cdb4638a45f}\label{classoomph_1_1Problem_afc4492ec2686c70467cb0cdb4638a45f}} 
\index{oomph::Problem@{oomph::Problem}!adapt@{adapt}}
\index{adapt@{adapt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{adapt()}{adapt()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::adapt (\begin{DoxyParamCaption}\item[{unsigned \&}]{n\+\_\+refined,  }\item[{unsigned \&}]{n\+\_\+unrefined }\end{DoxyParamCaption})}



Adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on their own error estimates and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. Return \# of refined/unrefined elements. On return from this function, \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} can immediately be solved again. 



Definition at line 13859 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), adapt\+\_\+based\+\_\+on\+\_\+error\+\_\+estimates(), Assembly\+\_\+handler\+\_\+pt, assign\+\_\+eqn\+\_\+numbers(), bifurcation\+\_\+adapt\+\_\+helper(), oomph\+::\+Assembly\+Handler\+::bifurcation\+\_\+type(), Copy\+\_\+of\+\_\+problem\+\_\+pt, oomph\+::\+Global\+\_\+timings\+::\+Doc\+\_\+comprehensive\+\_\+timings, Dof\+\_\+current, dof\+\_\+current(), Dof\+\_\+derivative, dof\+\_\+derivative(), Dof\+\_\+distribution\+\_\+pt, get\+\_\+all\+\_\+error\+\_\+estimates(), oomph\+::\+Error\+Estimator\+::get\+\_\+element\+\_\+errors(), i, make\+\_\+copy(), mesh\+\_\+pt(), oomph\+::\+Node\+::ndim(), ndof(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow\+\_\+local(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, rebuild\+\_\+global\+\_\+mesh(), oomph\+::\+Timing\+Helpers\+::timer(), Use\+\_\+continuation\+\_\+timestepper, and oomph\+::\+Node\+::x().

\mbox{\Hypertarget{classoomph_1_1Problem_af5e7b874e120c2a3a89e227ad48e14c9}\label{classoomph_1_1Problem_af5e7b874e120c2a3a89e227ad48e14c9}} 
\index{oomph::Problem@{oomph::Problem}!adapt\_based\_on\_error\_estimates@{adapt\_based\_on\_error\_estimates}}
\index{adapt\_based\_on\_error\_estimates@{adapt\_based\_on\_error\_estimates}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{adapt\_based\_on\_error\_estimates()}{adapt\_based\_on\_error\_estimates()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::adapt\+\_\+based\+\_\+on\+\_\+error\+\_\+estimates (\begin{DoxyParamCaption}\item[{unsigned \&}]{n\+\_\+refined,  }\item[{unsigned \&}]{n\+\_\+unrefined,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$$>$ \&}]{elemental\+\_\+error }\end{DoxyParamCaption})}



Adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on the error estimates in elemental\+\_\+error and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. Return \# of refined/unrefined elements. On return from this function, \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} can immediately be solved again. 

Perform mesh adaptation for (all) refineable (sub)mesh(es), based on the error estimates in elemental\+\_\+error and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. Return \# of refined/unrefined elements. On return from this function, \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} can immediately be solved again. 

Definition at line 14721 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, and rebuild\+\_\+global\+\_\+mesh().



Referenced by adapt(), adapt\+\_\+based\+\_\+on\+\_\+error\+\_\+estimates(), and bifurcation\+\_\+adapt\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_a3809e4ec25082a5b8686bd6fa1c61fce}\label{classoomph_1_1Problem_a3809e4ec25082a5b8686bd6fa1c61fce}} 
\index{oomph::Problem@{oomph::Problem}!adapt\_based\_on\_error\_estimates@{adapt\_based\_on\_error\_estimates}}
\index{adapt\_based\_on\_error\_estimates@{adapt\_based\_on\_error\_estimates}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{adapt\_based\_on\_error\_estimates()}{adapt\_based\_on\_error\_estimates()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::adapt\+\_\+based\+\_\+on\+\_\+error\+\_\+estimates (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$$>$ \&}]{elemental\+\_\+error }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on the error estimates in elemental\+\_\+error and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. Return \# of refined/unrefined elements. On return from this function, \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} can immediately be solved again. \mbox{[}Wrapper without n\+\_\+refined and n\+\_\+unrefined arguments\mbox{]}. 



Definition at line 3039 of file problem.\+h.



References adapt\+\_\+based\+\_\+on\+\_\+error\+\_\+estimates().

\mbox{\Hypertarget{classoomph_1_1Problem_abf6681f21f614ed7f15cc675ed6f692a}\label{classoomph_1_1Problem_abf6681f21f614ed7f15cc675ed6f692a}} 
\index{oomph::Problem@{oomph::Problem}!adaptive\_unsteady\_newton\_solve@{adaptive\_unsteady\_newton\_solve}}
\index{adaptive\_unsteady\_newton\_solve@{adaptive\_unsteady\_newton\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{adaptive\_unsteady\_newton\_solve()}{adaptive\_unsteady\_newton\_solve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve (\begin{DoxyParamCaption}\item[{const double \&}]{dt\+\_\+desired,  }\item[{const double \&}]{epsilon }\end{DoxyParamCaption})}



Attempt to advance timestep by dt\+\_\+desired. If the solution fails the timestep will be halved until convergence is achieved, or the timestep falls below Newton\+Solver\+Parameters\+::\+Minimum\+\_\+time\+\_\+step. The error control parameter epsilon represents the (approximate) desired magnitude of the global error at each timestep. The routine returns a double that is the suggested next timestep and should be passed as dt\+\_\+desired the next time the routine is called. This version always shifts the time values. 

Attempt to take one timestep forward using dt\+\_\+desired. The error control parameter, epsilon, is used to specify the desired approximate value of the global error norm per timestep. The routine returns the value an estimate of the next value of dt that should be taken. 

Definition at line 11249 of file problem.\+cc.



Referenced by doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_a3f5bde6d7fa8972e01a20c522b5fb2ef}\label{classoomph_1_1Problem_a3f5bde6d7fa8972e01a20c522b5fb2ef}} 
\index{oomph::Problem@{oomph::Problem}!adaptive\_unsteady\_newton\_solve@{adaptive\_unsteady\_newton\_solve}}
\index{adaptive\_unsteady\_newton\_solve@{adaptive\_unsteady\_newton\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{adaptive\_unsteady\_newton\_solve()}{adaptive\_unsteady\_newton\_solve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve (\begin{DoxyParamCaption}\item[{const double \&}]{dt\+\_\+desired,  }\item[{const double \&}]{epsilon,  }\item[{const bool \&}]{shift\+\_\+values }\end{DoxyParamCaption})}



Attempt to advance timestep by dt\+\_\+desired. If the solution fails the timestep will be halved until convergence is achieved, or the timestep falls below Newton\+Solver\+Parameters\+::\+Minimum\+\_\+time\+\_\+step. The error control parameter epsilon represents the (approximate) desired magnitude of the global error at each timestep. The routine returns a double that is the suggested next timestep and should be passed as dt\+\_\+desired the next time the routine is called. Once again the boolean flag, shift\+\_\+values, is used to control whether the time values are shifted. 

Attempt to take one timestep forward using the dt\+\_\+desired. This is the driver for a number of adaptive solvers. If the solution fails to converge at a given timestep, the routine will automatically halve the time step and try again, until the time step falls below the specified minimum value. The routine returns the value an estimate of the next value of dt that should be taken. Timestep is also rejected if the error estimate post-\/solve (computed by \mbox{\hyperlink{classoomph_1_1Problem_ac7667864b71a3889c95c29307422ac8e}{global\+\_\+temporal\+\_\+error\+\_\+norm()}}) exceeds epsilon. This behaviour can be over-\/ruled by setting the protected boolean \mbox{\hyperlink{classoomph_1_1Problem_ab27af4a444de9f59125ee50ac778d97a}{Problem\+::\+Keep\+\_\+temporal\+\_\+error\+\_\+below\+\_\+tolerance}} to false. 

Definition at line 11269 of file problem.\+cc.



References actions\+\_\+after\+\_\+implicit\+\_\+timestep(), actions\+\_\+after\+\_\+implicit\+\_\+timestep\+\_\+and\+\_\+error\+\_\+estimation(), actions\+\_\+after\+\_\+newton\+\_\+solve(), actions\+\_\+after\+\_\+newton\+\_\+step(), oomph\+::\+Time\+Stepper\+::actions\+\_\+after\+\_\+timestep(), actions\+\_\+before\+\_\+implicit\+\_\+timestep(), actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check(), oomph\+::\+Time\+Stepper\+::actions\+\_\+before\+\_\+timestep(), calculate\+\_\+predictions(), dof(), dof\+\_\+distribution\+\_\+pt(), oomph\+::\+Time\+::dt(), DTSF\+\_\+max\+\_\+increase, DTSF\+\_\+min\+\_\+decrease, e, global\+\_\+temporal\+\_\+error\+\_\+norm(), i, Keep\+\_\+temporal\+\_\+error\+\_\+below\+\_\+tolerance, oomph\+::\+Newton\+Solver\+Error\+::linear\+\_\+solver\+\_\+error, Maximum\+\_\+dt, Minimum\+\_\+dt, Minimum\+\_\+dt\+\_\+but\+\_\+still\+\_\+proceed, newton\+\_\+solve(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow\+\_\+local(), ntime\+\_\+stepper(), oomph\+::oomph\+\_\+info, oomph\+::\+Time\+Stepper\+::set\+\_\+error\+\_\+weights(), oomph\+::\+Time\+Stepper\+::set\+\_\+predictor\+\_\+weights(), oomph\+::\+Time\+Stepper\+::set\+\_\+weights(), shift\+\_\+time\+\_\+values(), oomph\+::\+Global\+\_\+string\+\_\+for\+\_\+annotation\+::string(), synchronise\+\_\+all\+\_\+dofs(), oomph\+::\+Time\+::time(), Time\+\_\+adaptive\+\_\+newton\+\_\+crash\+\_\+on\+\_\+solve\+\_\+fail, time\+\_\+pt(), time\+\_\+stepper\+\_\+pt(), and Timestep\+\_\+reduction\+\_\+factor\+\_\+after\+\_\+nonconvergence.

\mbox{\Hypertarget{classoomph_1_1Problem_aa803fbccb2c8c70702b2c39837e7ad2e}\label{classoomph_1_1Problem_aa803fbccb2c8c70702b2c39837e7ad2e}} 
\index{oomph::Problem@{oomph::Problem}!add\_eigenvector\_to\_dofs@{add\_eigenvector\_to\_dofs}}
\index{add\_eigenvector\_to\_dofs@{add\_eigenvector\_to\_dofs}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{add\_eigenvector\_to\_dofs()}{add\_eigenvector\_to\_dofs()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::add\+\_\+eigenvector\+\_\+to\+\_\+dofs (\begin{DoxyParamCaption}\item[{const double \&}]{epsilon,  }\item[{const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{eigenvector }\end{DoxyParamCaption})}



Add the eigenvector passed to the function scaled by the constat epsilon to the dofs in the problem so that it can be output by the usual routines. 

Add the eigenvector passed to the function to the dofs with magnitude epsilon. 

Definition at line 8933 of file problem.\+cc.



References dof(), Dof\+\_\+distribution\+\_\+pt, ndof(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::nrow(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::nrow\+\_\+local(), oomph\+::\+Double\+Vector\+::redistribute(), and synchronise\+\_\+all\+\_\+dofs().

\mbox{\Hypertarget{classoomph_1_1Problem_a6f0c24728351d390d4f0a86d07bd8678}\label{classoomph_1_1Problem_a6f0c24728351d390d4f0a86d07bd8678}} 
\index{oomph::Problem@{oomph::Problem}!add\_global\_data@{add\_global\_data}}
\index{add\_global\_data@{add\_global\_data}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{add\_global\_data()}{add\_global\_data()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::add\+\_\+global\+\_\+data (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Data}{Data}} $\ast$const \&}]{global\+\_\+data\+\_\+pt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Add \mbox{\hyperlink{classoomph_1_1Data}{Data}} to the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s global data -- the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} will perform equation numbering etc. for such \mbox{\hyperlink{classoomph_1_1Data}{Data}}. 



Definition at line 1654 of file problem.\+h.



References Global\+\_\+data\+\_\+pt, and global\+\_\+data\+\_\+pt().

\mbox{\Hypertarget{classoomph_1_1Problem_a0cd05109bc2c003c5c0686e6aa55d847}\label{classoomph_1_1Problem_a0cd05109bc2c003c5c0686e6aa55d847}} 
\index{oomph::Problem@{oomph::Problem}!add\_sub\_mesh@{add\_sub\_mesh}}
\index{add\_sub\_mesh@{add\_sub\_mesh}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{add\_sub\_mesh()}{add\_sub\_mesh()}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::add\+\_\+sub\+\_\+mesh (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$const \&}]{mesh\+\_\+pt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Add a submesh to the problem and return its number, i, by which it can be accessed via mesh\+\_\+pt(i). 



Definition at line 1330 of file problem.\+h.



References mesh\+\_\+pt(), and Sub\+\_\+mesh\+\_\+pt.



Referenced by oomph\+::\+Biharmonic\+Problem$<$ DIM $>$\+::build\+\_\+global\+\_\+mesh\+\_\+and\+\_\+assign\+\_\+eqn\+\_\+numbers(), oomph\+::\+Navier\+Stokes\+Schur\+Complement\+Preconditioner\+::get\+\_\+pressure\+\_\+advection\+\_\+diffusion\+\_\+matrix(), oomph\+::\+Non\+Linear\+Elasticity\+Smooth\+Mesh$<$ ELEMENT $>$\+::operator()(), oomph\+::\+Segregatable\+FSIProblem\+::rebuild\+\_\+monolithic\+\_\+mesh(), oomph\+::\+Segregatable\+FSIProblem\+::use\+\_\+only\+\_\+fluid\+\_\+elements(), and oomph\+::\+Segregatable\+FSIProblem\+::use\+\_\+only\+\_\+solid\+\_\+elements().

\mbox{\Hypertarget{classoomph_1_1Problem_a8856eae2daa9cea05e99bfcd4ef340a4}\label{classoomph_1_1Problem_a8856eae2daa9cea05e99bfcd4ef340a4}} 
\index{oomph::Problem@{oomph::Problem}!add\_time\_stepper\_pt@{add\_time\_stepper\_pt}}
\index{add\_time\_stepper\_pt@{add\_time\_stepper\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{add\_time\_stepper\_pt()}{add\_time\_stepper\_pt()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::add\+\_\+time\+\_\+stepper\+\_\+pt (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}} $\ast$const \&}]{time\+\_\+stepper\+\_\+pt }\end{DoxyParamCaption})}



Add a timestepper to the problem. The function will automatically create or resize the \mbox{\hyperlink{classoomph_1_1Time}{Time}} object so that it contains the appropriate number of levels of storage. 



Definition at line 1631 of file problem.\+cc.



References oomph\+::\+Time\+::ndt(), oomph\+::\+Time\+Stepper\+::ndt(), oomph\+::oomph\+\_\+info, oomph\+::\+Time\+::resize(), Time\+\_\+pt, oomph\+::\+Time\+Stepper\+::time\+\_\+pt(), Time\+\_\+stepper\+\_\+pt, and time\+\_\+stepper\+\_\+pt().



Referenced by oomph\+::\+Refineable\+Triangle\+Mesh$<$ ELEMENT $>$\+::adapt(), arc\+\_\+length\+\_\+step\+\_\+solve(), and oomph\+::\+Womersley\+Problem$<$ ELEMENT, DIM $>$\+::\+Womersley\+Problem().

\mbox{\Hypertarget{classoomph_1_1Problem_a352210408b3eed3e7a834b8b9a33a99a}\label{classoomph_1_1Problem_a352210408b3eed3e7a834b8b9a33a99a}} 
\index{oomph::Problem@{oomph::Problem}!add\_to\_dofs@{add\_to\_dofs}}
\index{add\_to\_dofs@{add\_to\_dofs}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{add\_to\_dofs()}{add\_to\_dofs()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::add\+\_\+to\+\_\+dofs (\begin{DoxyParamCaption}\item[{const double \&}]{lambda,  }\item[{const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{increment\+\_\+dofs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Add lambda x incremenet\+\_\+dofs\mbox{[}l\mbox{]} to the l-\/th dof. 

Function that adds the values to the dofs. 

Reimplemented from \mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject_a00f10d9ad6de867dd72ba175a5f0ec89}{oomph\+::\+Explicit\+Time\+Steppable\+Object}}.



Definition at line 3650 of file problem.\+cc.



References Dof\+\_\+pt, and ndof().

\mbox{\Hypertarget{classoomph_1_1Problem_aefb723728ed26abe410b61ec38d42688}\label{classoomph_1_1Problem_aefb723728ed26abe410b61ec38d42688}} 
\index{oomph::Problem@{oomph::Problem}!arc\_length\_step\_solve@{arc\_length\_step\_solve}}
\index{arc\_length\_step\_solve@{arc\_length\_step\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{arc\_length\_step\_solve()}{arc\_length\_step\_solve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::arc\+\_\+length\+\_\+step\+\_\+solve (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Data}{Data}} $\ast$const \&}]{data\+\_\+pt,  }\item[{const unsigned \&}]{data\+\_\+index,  }\item[{const double \&}]{ds,  }\item[{const unsigned \&}]{max\+\_\+adapt = {\ttfamily 0} }\end{DoxyParamCaption})}



Solve a steady problem using arc-\/length continuation, when the variable corresponding to the arc-\/length constraint equation is already stored in data used in the problem\+: data\+\_\+pt is a pointer to the appropriate data object, data\+\_\+index is the index of the value that will be traded for the constriant, ds is the desired arc\+\_\+length and max\+\_\+adapt is the maximum number of spatial adaptations (default zero, no adaptation). Note that the value must be pinned in order for this formulation to work. 

This function takes one step of length ds in pseudo-\/arclength.\+The argument data\+\_\+pt is a pointer to the data that holds the parameter (global variable) that is being traded for arc-\/length. The exact value is located at the location given by data\+\_\+index. The function returns the next desired arc-\/length according to criteria based upon the desired number of Newton Iterations per solve. 

Definition at line 10575 of file problem.\+cc.



References add\+\_\+time\+\_\+stepper\+\_\+pt(), arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), Arc\+\_\+length\+\_\+step\+\_\+taken, Continuation\+\_\+time\+\_\+stepper, i, oomph\+::\+Data\+::is\+\_\+pinned(), ntime\+\_\+stepper(), oomph\+::oomph\+\_\+info, set\+\_\+timestepper\+\_\+for\+\_\+all\+\_\+data(), time\+\_\+stepper\+\_\+pt(), Use\+\_\+continuation\+\_\+timestepper, and oomph\+::\+Data\+::value\+\_\+pt().

\mbox{\Hypertarget{classoomph_1_1Problem_ad8414efbd8099d3e6cf3f4daea06cc8f}\label{classoomph_1_1Problem_ad8414efbd8099d3e6cf3f4daea06cc8f}} 
\index{oomph::Problem@{oomph::Problem}!arc\_length\_step\_solve@{arc\_length\_step\_solve}}
\index{arc\_length\_step\_solve@{arc\_length\_step\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{arc\_length\_step\_solve()}{arc\_length\_step\_solve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::arc\+\_\+length\+\_\+step\+\_\+solve (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt,  }\item[{const double \&}]{ds,  }\item[{const unsigned \&}]{max\+\_\+adapt = {\ttfamily 0} }\end{DoxyParamCaption})}



Solve a steady problem using arc-\/length continuation, when the parameter that becomes a variable corresponding to the arc-\/length constraint equation is an external double\+: parameter\+\_\+pt is a pointer to that double, ds is the desired arc\+\_\+length and max\+\_\+adapt is the maximum number of spatial adaptations (default zero, no adaptation). 

This function takes one step of length ds in pseudo-\/arclength.\+The argument parameter\+\_\+pt is a pointer to the parameter (global variable) that is being traded for arc-\/length. The function returns the next desired arc-\/length according to criteria based upon the desired number of Newton Iterations per solve. 

Definition at line 10487 of file problem.\+cc.



References add\+\_\+time\+\_\+stepper\+\_\+pt(), arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), Arc\+\_\+length\+\_\+step\+\_\+taken, Continuation\+\_\+time\+\_\+stepper, does\+\_\+pointer\+\_\+correspond\+\_\+to\+\_\+problem\+\_\+data(), i, ntime\+\_\+stepper(), oomph\+::oomph\+\_\+info, set\+\_\+timestepper\+\_\+for\+\_\+all\+\_\+data(), time\+\_\+stepper\+\_\+pt(), and Use\+\_\+continuation\+\_\+timestepper.

\mbox{\Hypertarget{classoomph_1_1Problem_afaa9689a9c73bb76caea5d24980e6788}\label{classoomph_1_1Problem_afaa9689a9c73bb76caea5d24980e6788}} 
\index{oomph::Problem@{oomph::Problem}!arc\_length\_step\_solve\_helper@{arc\_length\_step\_solve\_helper}}
\index{arc\_length\_step\_solve\_helper@{arc\_length\_step\_solve\_helper}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{arc\_length\_step\_solve\_helper()}{arc\_length\_step\_solve\_helper()}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt,  }\item[{const double \&}]{ds,  }\item[{const unsigned \&}]{max\+\_\+adapt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Private helper function that actually contains the guts of the arc-\/length stepping, parameter\+\_\+pt is a pointer to the parameter that is traded for the arc-\/length constraint, ds is the desired arc length and max\+\_\+adapt is the maximum number of spatial adaptations. The pointer to the parameter may be changed if this is called from the Data-\/based interface. 

This function takes one step of length ds in pseudo-\/arclength.\+The argument parameter\+\_\+pt is a pointer to the parameter (global variable) that is being traded for arc-\/length. The function returns the next desired arc-\/length according to criteria based upon the desired number of Newton Iterations per solve. end of adaptation loop

Definition at line 10708 of file problem.\+cc.



References actions\+\_\+after\+\_\+parameter\+\_\+increase(), adapt(), Arc\+\_\+length\+\_\+step\+\_\+taken, Bifurcation\+\_\+detection, Bisect\+\_\+to\+\_\+find\+\_\+bifurcation, calculate\+\_\+continuation\+\_\+derivatives(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd(), communicator\+\_\+pt(), Desired\+\_\+newton\+\_\+iterations\+\_\+ds, Dof\+\_\+current, dof\+\_\+current(), Dof\+\_\+derivative, dof\+\_\+derivative(), Dof\+\_\+distribution\+\_\+pt, Dof\+\_\+pt, Ds\+\_\+current, First\+\_\+jacobian\+\_\+sign\+\_\+change, i, oomph\+::\+Time\+Stepper\+::is\+\_\+steady(), oomph\+::\+Newton\+Solver\+Error\+::linear\+\_\+solver\+\_\+error, oomph\+::\+Time\+Stepper\+::make\+\_\+steady(), Minimum\+\_\+ds, newton\+\_\+solve\+\_\+continuation(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow\+\_\+local(), ntime\+\_\+stepper(), oomph\+::oomph\+\_\+info, Parameter\+\_\+current, Parameter\+\_\+derivative, Problem\+\_\+has\+\_\+been\+\_\+distributed, set\+\_\+consistent\+\_\+pinned\+\_\+values\+\_\+for\+\_\+continuation(), Sign\+\_\+of\+\_\+jacobian, oomph\+::\+Global\+\_\+string\+\_\+for\+\_\+annotation\+::string(), time\+\_\+stepper\+\_\+pt(), oomph\+::\+Time\+Stepper\+::undo\+\_\+make\+\_\+steady(), Use\+\_\+continuation\+\_\+timestepper, and Use\+\_\+finite\+\_\+differences\+\_\+for\+\_\+continuation\+\_\+derivatives.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_af6235ced9e7e85324f785f2681ab3872}\label{classoomph_1_1Problem_af6235ced9e7e85324f785f2681ab3872}} 
\index{oomph::Problem@{oomph::Problem}!are\_hessian\_products\_calculated\_analytically@{are\_hessian\_products\_calculated\_analytically}}
\index{are\_hessian\_products\_calculated\_analytically@{are\_hessian\_products\_calculated\_analytically}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{are\_hessian\_products\_calculated\_analytically()}{are\_hessian\_products\_calculated\_analytically()}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::are\+\_\+hessian\+\_\+products\+\_\+calculated\+\_\+analytically (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Function to determine whether the hessian products are calculated analytically. 



Definition at line 303 of file problem.\+h.



References Calculate\+\_\+hessian\+\_\+products\+\_\+analytic.



Referenced by get\+\_\+hessian\+\_\+vector\+\_\+products().

\mbox{\Hypertarget{classoomph_1_1Problem_a381c30a8daede5c95bdda7e2efa24f19}\label{classoomph_1_1Problem_a381c30a8daede5c95bdda7e2efa24f19}} 
\index{oomph::Problem@{oomph::Problem}!assembly\_handler\_pt@{assembly\_handler\_pt}}
\index{assembly\_handler\_pt@{assembly\_handler\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{assembly\_handler\_pt()}{assembly\_handler\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}}$\ast$\& oomph\+::\+Problem\+::assembly\+\_\+handler\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the assembly handler object. 



Definition at line 1570 of file problem.\+h.



References Assembly\+\_\+handler\+\_\+pt.



Referenced by activate\+\_\+pitchfork\+\_\+tracking(), bifurcation\+\_\+adapt\+\_\+helper(), oomph\+::\+Fp\+Pressure\+Advection\+Diffusion\+Problem$<$ ELEMENT $>$\+::\+Fp\+Pressure\+Advection\+Diffusion\+Problem(), get\+\_\+hessian\+\_\+vector\+\_\+products(), get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals(), get\+\_\+jacobian(), get\+\_\+my\+\_\+eqns(), oomph\+::\+Navier\+Stokes\+Schur\+Complement\+Preconditioner\+::get\+\_\+pressure\+\_\+advection\+\_\+diffusion\+\_\+matrix(), get\+\_\+residuals(), parallel\+\_\+sparse\+\_\+assemble(), oomph\+::\+HSL\+\_\+\+MA42\+::reorder\+\_\+elements(), oomph\+::\+Augmented\+Block\+Fold\+Linear\+Solver\+::resolve(), oomph\+::\+Block\+Pitch\+Fork\+Linear\+Solver\+::resolve(), oomph\+::\+Augmented\+Block\+Pitch\+Fork\+Linear\+Solver\+::resolve(), oomph\+::\+Augmented\+Block\+Fold\+Linear\+Solver\+::solve(), oomph\+::\+Block\+Pitch\+Fork\+Linear\+Solver\+::solve(), oomph\+::\+Augmented\+Block\+Pitch\+Fork\+Linear\+Solver\+::solve(), oomph\+::\+Block\+Hopf\+Linear\+Solver\+::solve(), oomph\+::\+HSL\+\_\+\+MA42\+::solve(), oomph\+::\+HSL\+\_\+\+MA42\+::solve\+\_\+for\+\_\+one\+\_\+dof(), oomph\+::\+Block\+Hopf\+Linear\+Solver\+::solve\+\_\+for\+\_\+two\+\_\+rhs(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+lists(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+maps(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+vectors(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+vectors\+\_\+of\+\_\+pairs(), and synchronise\+\_\+all\+\_\+dofs().

\mbox{\Hypertarget{classoomph_1_1Problem_a48905dc6c9a8811969407939b3e4ccb6}\label{classoomph_1_1Problem_a48905dc6c9a8811969407939b3e4ccb6}} 
\index{oomph::Problem@{oomph::Problem}!assembly\_handler\_pt@{assembly\_handler\_pt}}
\index{assembly\_handler\_pt@{assembly\_handler\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{assembly\_handler\_pt()}{assembly\_handler\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}}$\ast$ const\& oomph\+::\+Problem\+::assembly\+\_\+handler\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the assembly handler object (const version) 



Definition at line 1576 of file problem.\+h.



References Assembly\+\_\+handler\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1Problem_a8f93315e1076dd9672167ed0a845ea34}\label{classoomph_1_1Problem_a8f93315e1076dd9672167ed0a845ea34}} 
\index{oomph::Problem@{oomph::Problem}!assign\_eigenvector\_to\_dofs@{assign\_eigenvector\_to\_dofs}}
\index{assign\_eigenvector\_to\_dofs@{assign\_eigenvector\_to\_dofs}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{assign\_eigenvector\_to\_dofs()}{assign\_eigenvector\_to\_dofs()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::assign\+\_\+eigenvector\+\_\+to\+\_\+dofs (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{eigenvector }\end{DoxyParamCaption})}



Assign the eigenvector passed to the function to the dofs in the problem so that it can be output by the usual routines. 

Assign the eigenvector passed to the function to the dofs. 

Definition at line 8896 of file problem.\+cc.



References dof(), Dof\+\_\+distribution\+\_\+pt, ndof(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::nrow(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::nrow\+\_\+local(), oomph\+::\+Double\+Vector\+::redistribute(), and synchronise\+\_\+all\+\_\+dofs().

\mbox{\Hypertarget{classoomph_1_1Problem_a0df501c6aed60c4938861df776b10119}\label{classoomph_1_1Problem_a0df501c6aed60c4938861df776b10119}} 
\index{oomph::Problem@{oomph::Problem}!assign\_eqn\_numbers@{assign\_eqn\_numbers}}
\index{assign\_eqn\_numbers@{assign\_eqn\_numbers}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{assign\_eqn\_numbers()}{assign\_eqn\_numbers()}}
{\footnotesize\ttfamily unsigned long oomph\+::\+Problem\+::assign\+\_\+eqn\+\_\+numbers (\begin{DoxyParamCaption}\item[{const bool \&}]{assign\+\_\+local\+\_\+eqn\+\_\+numbers = {\ttfamily true} }\end{DoxyParamCaption})}



Assign all equation numbers for problem\+: Deals with global data (= data that isn\textquotesingle{}t attached to any elements) and then does the equation numbering for the elements. Virtual so it can be overloaded in MPI problems. Bool argument can be set to false to ignore assigning local equation numbers (found to be necessary in the parallel implementation of locate\+\_\+zeta between multiple meshes). 

Assign all equation numbers for problem\+: Deals with global data (= data that isn\textquotesingle{}t attached to any elements) and then does the equation numbering for the elements. Bool argument can be set to false to ignore assigning local equation numbers (necessary in the parallel implementation of locate\+\_\+zeta between multiple meshes). 

Definition at line 2075 of file problem.\+cc.



References oomph\+::\+Mesh\+::assign\+\_\+global\+\_\+eqn\+\_\+numbers(), oomph\+::\+Mesh\+::assign\+\_\+local\+\_\+eqn\+\_\+numbers(), oomph\+::\+Linear\+Algebra\+Distribution\+::build(), Communicator\+\_\+pt, communicator\+\_\+pt(), oomph\+::\+Generalised\+Element\+::complete\+\_\+setup\+\_\+of\+\_\+dependencies(), oomph\+::\+Global\+\_\+timings\+::\+Doc\+\_\+comprehensive\+\_\+timings, Dof\+\_\+distribution\+\_\+pt, Dof\+\_\+pt, e, oomph\+::\+Mesh\+::element\+\_\+pt(), Elemental\+\_\+assembly\+\_\+time, oomph\+::\+Mesh\+::external\+\_\+halo\+\_\+element\+\_\+pt(), Global\+\_\+data\+\_\+pt, i, Mesh\+\_\+pt, mesh\+\_\+pt(), Must\+\_\+recompute\+\_\+load\+\_\+balance\+\_\+for\+\_\+assembly, oomph\+::\+Mesh\+::nelement(), oomph\+::\+Mesh\+::nexternal\+\_\+halo\+\_\+element(), nglobal\+\_\+data(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, Parallel\+\_\+sparse\+\_\+assemble\+\_\+previous\+\_\+allocation, Problem\+\_\+has\+\_\+been\+\_\+distributed, remove\+\_\+duplicate\+\_\+data(), remove\+\_\+null\+\_\+pointers\+\_\+from\+\_\+external\+\_\+halo\+\_\+node\+\_\+storage(), set\+\_\+default\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly(), Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+previous\+\_\+allocation, Store\+\_\+local\+\_\+dof\+\_\+pt\+\_\+in\+\_\+elements, Sub\+\_\+mesh\+\_\+pt, synchronise\+\_\+eqn\+\_\+numbers(), and oomph\+::\+Timing\+Helpers\+::timer().



Referenced by adapt(), adapt\+\_\+based\+\_\+on\+\_\+error\+\_\+estimates(), oomph\+::\+Periodic\+Orbit\+Assembly\+Handler$<$ NNODE\+\_\+1\+D $>$\+::adapt\+\_\+temporal\+\_\+mesh(), bifurcation\+\_\+adapt\+\_\+helper(), oomph\+::\+Biharmonic\+Problem$<$ DIM $>$\+::build\+\_\+global\+\_\+mesh\+\_\+and\+\_\+assign\+\_\+eqn\+\_\+numbers(), distribute(), oomph\+::\+Fp\+Pressure\+Advection\+Diffusion\+Problem$<$ ELEMENT $>$\+::get\+\_\+pressure\+\_\+advection\+\_\+diffusion\+\_\+jacobian(), load\+\_\+balance(), oomph\+::\+Non\+Linear\+Elasticity\+Smooth\+Mesh$<$ ELEMENT $>$\+::operator()(), oomph\+::\+Linear\+Elasticity\+Smooth\+Mesh$<$ LINEAR\+\_\+\+ELASTICITY\+\_\+\+ELEMENT $>$\+::operator()(), oomph\+::\+Poisson\+Smooth\+Mesh$<$ POISSON\+\_\+\+ELEMENT $>$\+::operator()(), p\+\_\+adapt(), p\+\_\+refine\+\_\+selected\+\_\+elements(), p\+\_\+refine\+\_\+uniformly(), p\+\_\+refine\+\_\+uniformly\+\_\+aux(), p\+\_\+unrefine\+\_\+uniformly(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::project(), prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes(), read(), refine\+\_\+selected\+\_\+elements(), refine\+\_\+uniformly(), refine\+\_\+uniformly\+\_\+aux(), oomph\+::\+Segregatable\+FSIProblem\+::segregated\+\_\+solve(), oomph\+::\+Solid\+ICProblem\+::set\+\_\+newmark\+\_\+initial\+\_\+condition\+\_\+consistently(), oomph\+::\+Solid\+ICProblem\+::set\+\_\+newmark\+\_\+initial\+\_\+condition\+\_\+directly(), oomph\+::\+Solid\+ICProblem\+::set\+\_\+static\+\_\+initial\+\_\+condition(), set\+\_\+timestepper\+\_\+for\+\_\+all\+\_\+data(), oomph\+::\+MGSolver$<$ DIM $>$\+::setup\+\_\+mg\+\_\+hierarchy(), oomph\+::\+Helmholtz\+MGPreconditioner$<$ DIM $>$\+::setup\+\_\+mg\+\_\+hierarchy(), oomph\+::\+Solid\+ICProblem\+::setup\+\_\+problem(), unrefine\+\_\+uniformly(), oomph\+::\+Fp\+Pressure\+Advection\+Diffusion\+Problem$<$ ELEMENT $>$\+::validate(), and oomph\+::\+Womersley\+Problem$<$ ELEMENT, DIM $>$\+::\+Womersley\+Problem().

\mbox{\Hypertarget{classoomph_1_1Problem_a10e5dc4d944dfb2b141918e18e5e3de8}\label{classoomph_1_1Problem_a10e5dc4d944dfb2b141918e18e5e3de8}} 
\index{oomph::Problem@{oomph::Problem}!assign\_initial\_values\_impulsive@{assign\_initial\_values\_impulsive}}
\index{assign\_initial\_values\_impulsive@{assign\_initial\_values\_impulsive}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{assign\_initial\_values\_impulsive()}{assign\_initial\_values\_impulsive()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::assign\+\_\+initial\+\_\+values\+\_\+impulsive (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Initialise data and nodal positions to simulate impulsive start from initial configuration/solution. 

Initialise the previous values of the variables for time stepping corresponding to an impulsive start. Previous history for all data is generated by the appropriate timesteppers. Previous nodal positions are simply copied backwards. 

Definition at line 11692 of file problem.\+cc.



References oomph\+::\+Mesh\+::assign\+\_\+initial\+\_\+values\+\_\+impulsive(), Global\+\_\+data\+\_\+pt, and Mesh\+\_\+pt.



Referenced by assign\+\_\+initial\+\_\+values\+\_\+impulsive(), oomph\+::\+Solid\+ICProblem\+::set\+\_\+static\+\_\+initial\+\_\+condition(), steady\+\_\+newton\+\_\+solve(), and oomph\+::\+Segregatable\+FSIProblem\+::steady\+\_\+segregated\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a296bd0ba13bd51a96bb7057845e5a800}\label{classoomph_1_1Problem_a296bd0ba13bd51a96bb7057845e5a800}} 
\index{oomph::Problem@{oomph::Problem}!assign\_initial\_values\_impulsive@{assign\_initial\_values\_impulsive}}
\index{assign\_initial\_values\_impulsive@{assign\_initial\_values\_impulsive}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{assign\_initial\_values\_impulsive()}{assign\_initial\_values\_impulsive()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::assign\+\_\+initial\+\_\+values\+\_\+impulsive (\begin{DoxyParamCaption}\item[{const double \&}]{dt }\end{DoxyParamCaption})}



Initialise data and nodal positions to simulate an impulsive start and also set the initial and previous values of dt. 

Assign the values for an impulsive start and also set the initial values of the previous dts to both be dt. 

Definition at line 11712 of file problem.\+cc.



References assign\+\_\+initial\+\_\+values\+\_\+impulsive(), and initialise\+\_\+dt().

\mbox{\Hypertarget{classoomph_1_1Problem_ad36cedd508f3cfb352ddd44c18914d41}\label{classoomph_1_1Problem_ad36cedd508f3cfb352ddd44c18914d41}} 
\index{oomph::Problem@{oomph::Problem}!bifurcation\_adapt\_doc\_errors@{bifurcation\_adapt\_doc\_errors}}
\index{bifurcation\_adapt\_doc\_errors@{bifurcation\_adapt\_doc\_errors}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{bifurcation\_adapt\_doc\_errors()}{bifurcation\_adapt\_doc\_errors()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::bifurcation\+\_\+adapt\+\_\+doc\+\_\+errors (\begin{DoxyParamCaption}\item[{const unsigned \&}]{bifurcation\+\_\+type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



A function that is used to document the errors used in the adaptive solution of bifurcation problems. 

A function that is used to document the errors when adapting a bifurcation-\/tracking problem, which requires separate interpolation of the associated eigenfunction. The error measure is chosen to be a suitable combination of the errors in the base flow and the eigenfunction. The bifurcation type is passed as an argument. 

Definition at line 13841 of file problem.\+cc.



References bifurcation\+\_\+adapt\+\_\+helper().



Referenced by doc\+\_\+errors().

\mbox{\Hypertarget{classoomph_1_1Problem_a27d31a7a78f5d01b9d0a5e07c0e06e5d}\label{classoomph_1_1Problem_a27d31a7a78f5d01b9d0a5e07c0e06e5d}} 
\index{oomph::Problem@{oomph::Problem}!bifurcation\_adapt\_helper@{bifurcation\_adapt\_helper}}
\index{bifurcation\_adapt\_helper@{bifurcation\_adapt\_helper}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{bifurcation\_adapt\_helper()}{bifurcation\_adapt\_helper()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::bifurcation\+\_\+adapt\+\_\+helper (\begin{DoxyParamCaption}\item[{unsigned \&}]{n\+\_\+refined,  }\item[{unsigned \&}]{n\+\_\+unrefined,  }\item[{const unsigned \&}]{bifurcation\+\_\+type,  }\item[{const bool \&}]{actually\+\_\+adapt = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



A function that is used to adapt a bifurcation-\/tracking problem, which requires separate interpolation of the associated eigenfunction. The error measure is chosen to be a suitable combination of the errors in the base flow and the eigenfunction. 

A function that is used to adapt a bifurcation-\/tracking problem, which requires separate interpolation of the associated eigenfunction. The error measure is chosen to be a suitable combination of the errors in the base flow and the eigenfunction. The bifurcation type is passed as an argument. 

Definition at line 13547 of file problem.\+cc.



References activate\+\_\+fold\+\_\+tracking(), activate\+\_\+hopf\+\_\+tracking(), activate\+\_\+pitchfork\+\_\+tracking(), adapt\+\_\+based\+\_\+on\+\_\+error\+\_\+estimates(), assembly\+\_\+handler\+\_\+pt(), assign\+\_\+eqn\+\_\+numbers(), bifurcation\+\_\+parameter\+\_\+pt(), Copy\+\_\+of\+\_\+problem\+\_\+pt, deactivate\+\_\+bifurcation\+\_\+tracking(), dof(), e, get\+\_\+all\+\_\+error\+\_\+estimates(), get\+\_\+bifurcation\+\_\+eigenfunction(), make\+\_\+copy(), mesh\+\_\+pt(), ndof(), and oomph\+::oomph\+\_\+info.



Referenced by adapt(), bifurcation\+\_\+adapt\+\_\+doc\+\_\+errors(), and p\+\_\+adapt().

\mbox{\Hypertarget{classoomph_1_1Problem_a3cf79b3067d1d794062ebb27e414dea9}\label{classoomph_1_1Problem_a3cf79b3067d1d794062ebb27e414dea9}} 
\index{oomph::Problem@{oomph::Problem}!bifurcation\_parameter\_pt@{bifurcation\_parameter\_pt}}
\index{bifurcation\_parameter\_pt@{bifurcation\_parameter\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{bifurcation\_parameter\_pt()}{bifurcation\_parameter\_pt()}}
{\footnotesize\ttfamily double $\ast$ oomph\+::\+Problem\+::bifurcation\+\_\+parameter\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Return pointer to the parameter that is used in the bifurcation detection. If we are not tracking a bifurcation then an error will be thrown by the \mbox{\hyperlink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}}. 



Definition at line 10274 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, and oomph\+::\+Assembly\+Handler\+::bifurcation\+\_\+parameter\+\_\+pt().



Referenced by bifurcation\+\_\+adapt\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_a0faad6f705a6dc0ffe27229f9104ed7c}\label{classoomph_1_1Problem_a0faad6f705a6dc0ffe27229f9104ed7c}} 
\index{oomph::Problem@{oomph::Problem}!build\_global\_mesh@{build\_global\_mesh}}
\index{build\_global\_mesh@{build\_global\_mesh}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{build\_global\_mesh()}{build\_global\_mesh()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::build\+\_\+global\+\_\+mesh (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Build the global mesh by combining the all the submeshes. {\bfseries{Note\+:}} The nodes boundary information refers to the boundary numbers within the submesh! 

Build a single (global) mesh from a number of submeshes which are passed as a vector of pointers to the submeshes. The ordering is not necessarily optimal. 

Definition at line 1579 of file problem.\+cc.



References Mesh\+\_\+pt, rebuild\+\_\+global\+\_\+mesh(), oomph\+::\+Global\+\_\+string\+\_\+for\+\_\+annotation\+::string(), and Sub\+\_\+mesh\+\_\+pt.



Referenced by oomph\+::\+Biharmonic\+Problem$<$ DIM $>$\+::build\+\_\+global\+\_\+mesh\+\_\+and\+\_\+assign\+\_\+eqn\+\_\+numbers(), and oomph\+::\+Non\+Linear\+Elasticity\+Smooth\+Mesh$<$ ELEMENT $>$\+::operator()().

\mbox{\Hypertarget{classoomph_1_1Problem_a220816aebf8c74c6c524088e3da4d793}\label{classoomph_1_1Problem_a220816aebf8c74c6c524088e3da4d793}} 
\index{oomph::Problem@{oomph::Problem}!build\_mesh@{build\_mesh}}
\index{build\_mesh@{build\_mesh}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{build\_mesh()}{build\_mesh()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::build\+\_\+mesh (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Function to build the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s base mesh; this must be supplied by the user if they wish to use the \mbox{\hyperlink{classoomph_1_1Problem_ad6309367fa379889012f25e3397ab425}{load\+\_\+balance()}} functionality, which is only available to problems that have already been distributed. If the problem has multiple meshes, each mesh must be built, added as as a submesh, and a call to \mbox{\hyperlink{classoomph_1_1Problem_a0faad6f705a6dc0ffe27229f9104ed7c}{build\+\_\+global\+\_\+mesh()}} must be made in this function. On return from this function all meshes must have been refined to the same level that they were in the when \mbox{\hyperlink{classoomph_1_1Problem_aa35e1adc0fdf14b217c7b608eb9cf20b}{Problem\+::distribute()}} was first called. 



Definition at line 1365 of file problem.\+h.



References oomph\+::\+Global\+\_\+string\+\_\+for\+\_\+annotation\+::string().



Referenced by load\+\_\+balance().

\mbox{\Hypertarget{classoomph_1_1Problem_a58edae16dc24830521b0df67452db1f7}\label{classoomph_1_1Problem_a58edae16dc24830521b0df67452db1f7}} 
\index{oomph::Problem@{oomph::Problem}!calculate\_continuation\_derivatives@{calculate\_continuation\_derivatives}}
\index{calculate\_continuation\_derivatives@{calculate\_continuation\_derivatives}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{calculate\_continuation\_derivatives()}{calculate\_continuation\_derivatives()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::calculate\+\_\+continuation\+\_\+derivatives (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{z }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



A function to calculate the derivatives with respect to the arc-\/length required for continuation. The arguments is the solution of the linear system, Jz = d\+R/dparameter, that gives du/dparameter and the direction output from the newton\+\_\+solve\+\_\+continuation function. The derivatives are stored in the Continuation\+Parameters namespace. 



Definition at line 9985 of file problem.\+cc.



References calculate\+\_\+continuation\+\_\+derivatives\+\_\+helper(), Desired\+\_\+proportion\+\_\+of\+\_\+arc\+\_\+length, Parameter\+\_\+derivative, Scale\+\_\+arc\+\_\+length, and Theta\+\_\+squared.

\mbox{\Hypertarget{classoomph_1_1Problem_a58f16ae8f6da042d40fddf01ee3ebd31}\label{classoomph_1_1Problem_a58f16ae8f6da042d40fddf01ee3ebd31}} 
\index{oomph::Problem@{oomph::Problem}!calculate\_continuation\_derivatives@{calculate\_continuation\_derivatives}}
\index{calculate\_continuation\_derivatives@{calculate\_continuation\_derivatives}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{calculate\_continuation\_derivatives()}{calculate\_continuation\_derivatives()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::calculate\+\_\+continuation\+\_\+derivatives (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



A function to calculate the derivatives wrt the arc-\/length. This version of the function actually does a linear solve so that the derivatives are calculated \char`\"{}exactly\char`\"{} rather than using the values at the Newton step just before convergence. This is necessary in spatially adaptive problems, in which the number of degrees of freedom changes and so the appropriate derivatives must be calculated for the new variables. This function is called if no Newton steps were taken in the continuation routine ... i.\+e. the initial residuals were sufficiently small. 

A function to calculate the derivatives wrt the arc-\/length. This version of the function actually does a linear solve so that the derivatives are calculated \char`\"{}exactly\char`\"{} rather than using the values at the Newton step just before convergence. This is only necessary in spatially adaptive problems, in which the number of degrees of freedom changes and so the appropriate derivatives must be calculated for the new variables. 

Definition at line 9908 of file problem.\+cc.



References Communicator\+\_\+pt, oomph\+::\+Linear\+Solver\+::disable\+\_\+resolve(), oomph\+::\+Linear\+Solver\+::enable\+\_\+resolve(), get\+\_\+derivative\+\_\+wrt\+\_\+global\+\_\+parameter(), oomph\+::\+Linear\+Solver\+::is\+\_\+resolve\+\_\+enabled(), Linear\+\_\+solver\+\_\+pt, ndof(), oomph\+::\+Linear\+Solver\+::resolve(), and oomph\+::\+Linear\+Solver\+::solve().



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_addc838287129a35ef60e38ea854b939c}\label{classoomph_1_1Problem_addc838287129a35ef60e38ea854b939c}} 
\index{oomph::Problem@{oomph::Problem}!calculate\_continuation\_derivatives\_fd@{calculate\_continuation\_derivatives\_fd}}
\index{calculate\_continuation\_derivatives\_fd@{calculate\_continuation\_derivatives\_fd}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{calculate\_continuation\_derivatives\_fd()}{calculate\_continuation\_derivatives\_fd()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



A function to calculate the derivatives with respect to the arc-\/length required for continuation by finite differences, using the previous values of the solution. The derivatives are stored in the Continuation\+Parameters namespace. 

A function to calculate the derivatives with respect to the arc-\/length required for continuation using finite differences. 

Definition at line 10011 of file problem.\+cc.



References calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd\+\_\+helper(), Desired\+\_\+proportion\+\_\+of\+\_\+arc\+\_\+length, Parameter\+\_\+derivative, Scale\+\_\+arc\+\_\+length, and Theta\+\_\+squared.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_a668e4c384b0513a943dee9411e640d74}\label{classoomph_1_1Problem_a668e4c384b0513a943dee9411e640d74}} 
\index{oomph::Problem@{oomph::Problem}!calculate\_continuation\_derivatives\_fd\_helper@{calculate\_continuation\_derivatives\_fd\_helper}}
\index{calculate\_continuation\_derivatives\_fd\_helper@{calculate\_continuation\_derivatives\_fd\_helper}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{calculate\_continuation\_derivatives\_fd\_helper()}{calculate\_continuation\_derivatives\_fd\_helper()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd\+\_\+helper (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



A function that performs the guts of the continuation derivative calculation in arc-\/length continuation problems using finite differences. 

A private helper function to calculate the derivatives with respect to the arc-\/length required for continuation using finite differences. 

Definition at line 10197 of file problem.\+cc.



References oomph\+::\+Linear\+Algebra\+Distribution\+::communicator\+\_\+pt(), oomph\+::\+Linear\+Algebra\+Distribution\+::distributed(), Dof\+\_\+current, dof\+\_\+derivative(), Dof\+\_\+distribution\+\_\+pt, Dof\+\_\+pt, Ds\+\_\+current, oomph\+::\+Linear\+Algebra\+Distribution\+::nrow\+\_\+local(), Parameter\+\_\+current, Parameter\+\_\+derivative, and Theta\+\_\+squared.



Referenced by calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd().

\mbox{\Hypertarget{classoomph_1_1Problem_a9e860f40a5ca15767d2174893c9084d4}\label{classoomph_1_1Problem_a9e860f40a5ca15767d2174893c9084d4}} 
\index{oomph::Problem@{oomph::Problem}!calculate\_continuation\_derivatives\_helper@{calculate\_continuation\_derivatives\_helper}}
\index{calculate\_continuation\_derivatives\_helper@{calculate\_continuation\_derivatives\_helper}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{calculate\_continuation\_derivatives\_helper()}{calculate\_continuation\_derivatives\_helper()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::calculate\+\_\+continuation\+\_\+derivatives\+\_\+helper (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{z }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



A function that performs the guts of the continuation derivative calculation in arc length continuation problems. 

A private helper function to calculate the derivatives with respect to the arc-\/length required for continuation. The arguments is the solution of the linear system, Jz = d\+R/dparameter, that gives du/dparameter and the direction output from the newton\+\_\+solve\+\_\+continuation function. The derivatives are stored in the Continuation\+Parameters namespace. 

Definition at line 10105 of file problem.\+cc.



References oomph\+::\+Linear\+Algebra\+Distribution\+::communicator\+\_\+pt(), Continuation\+\_\+direction, oomph\+::\+Linear\+Algebra\+Distribution\+::distributed(), Dof\+\_\+derivative, dof\+\_\+derivative(), Dof\+\_\+distribution\+\_\+pt, oomph\+::\+Double\+Vector\+::dot(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow\+\_\+local(), Parameter\+\_\+derivative, oomph\+::\+Double\+Vector\+::redistribute(), Theta\+\_\+squared, Use\+\_\+continuation\+\_\+timestepper, and oomph\+::\+Double\+Vector\+::values\+\_\+pt().



Referenced by calculate\+\_\+continuation\+\_\+derivatives().

\mbox{\Hypertarget{classoomph_1_1Problem_a474deeb0947b767566fa1d4630ad8b4a}\label{classoomph_1_1Problem_a474deeb0947b767566fa1d4630ad8b4a}} 
\index{oomph::Problem@{oomph::Problem}!calculate\_predictions@{calculate\_predictions}}
\index{calculate\_predictions@{calculate\_predictions}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{calculate\_predictions()}{calculate\_predictions()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::calculate\+\_\+predictions (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Calculate predictions. 

Calculate the predictions of all variables in problem. 

Definition at line 11849 of file problem.\+cc.



References oomph\+::\+Mesh\+::calculate\+\_\+predictions(), distributed(), dof(), Dof\+\_\+pt, oomph\+::\+Time\+::dt(), e, oomph\+::\+Time\+Stepper\+::explicit\+\_\+predictor\+\_\+pt(), explicit\+\_\+time\+\_\+stepper\+\_\+pt(), explicit\+\_\+timestep(), get\+\_\+dofs(), Global\+\_\+data\+\_\+pt, i, Mesh\+\_\+pt, ndof(), restore\+\_\+dof\+\_\+values(), set\+\_\+dofs(), store\+\_\+current\+\_\+dof\+\_\+values(), oomph\+::\+Global\+\_\+string\+\_\+for\+\_\+annotation\+::string(), time(), time\+\_\+pt(), Time\+\_\+stepper\+\_\+pt, time\+\_\+stepper\+\_\+pt(), oomph\+::\+String\+Conversion\+::to\+\_\+string(), oomph\+::\+Time\+Stepper\+::update\+\_\+predicted\+\_\+time(), and use\+\_\+predictor\+\_\+values\+\_\+as\+\_\+initial\+\_\+guess().



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a8dd5cb241ce6218fb476931e0879d7c8}\label{classoomph_1_1Problem_a8dd5cb241ce6218fb476931e0879d7c8}} 
\index{oomph::Problem@{oomph::Problem}!check\_halo\_schemes@{check\_halo\_schemes}}
\index{check\_halo\_schemes@{check\_halo\_schemes}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{check\_halo\_schemes()}{check\_halo\_schemes()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::check\+\_\+halo\+\_\+schemes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Check the halo/haloed node/element schemes. 



Definition at line 2245 of file problem.\+h.



References oomph\+::\+Doc\+Info\+::disable\+\_\+doc().



Referenced by self\+\_\+test().

\mbox{\Hypertarget{classoomph_1_1Problem_a93dde63729e7cd332edc1f8904a80649}\label{classoomph_1_1Problem_a93dde63729e7cd332edc1f8904a80649}} 
\index{oomph::Problem@{oomph::Problem}!check\_halo\_schemes@{check\_halo\_schemes}}
\index{check\_halo\_schemes@{check\_halo\_schemes}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{check\_halo\_schemes()}{check\_halo\_schemes()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::check\+\_\+halo\+\_\+schemes (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info }\end{DoxyParamCaption})}



Check the halo/haloed node/element schemes. 

Check the halo/haloed/shared node/element schemes. 

Definition at line 16596 of file problem.\+cc.



References oomph\+::\+Mesh\+::check\+\_\+halo\+\_\+schemes(), oomph\+::\+Doc\+Info\+::label(), Max\+\_\+permitted\+\_\+error\+\_\+for\+\_\+halo\+\_\+check, mesh\+\_\+pt(), nsub\+\_\+mesh(), and oomph\+::oomph\+\_\+info.

\mbox{\Hypertarget{classoomph_1_1Problem_a07bad546a91f9d13936be6dc0590fcd0}\label{classoomph_1_1Problem_a07bad546a91f9d13936be6dc0590fcd0}} 
\index{oomph::Problem@{oomph::Problem}!clear\_elemental\_assembly\_time@{clear\_elemental\_assembly\_time}}
\index{clear\_elemental\_assembly\_time@{clear\_elemental\_assembly\_time}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{clear\_elemental\_assembly\_time()}{clear\_elemental\_assembly\_time()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::clear\+\_\+elemental\+\_\+assembly\+\_\+time (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Clear storage of most-\/recent elemental assembly times (used for load balancing). Next load balancing operation will be based on the number of elements associated with a tree root. 



Definition at line 872 of file problem.\+h.



References Elemental\+\_\+assembly\+\_\+time, and Must\+\_\+recompute\+\_\+load\+\_\+balance\+\_\+for\+\_\+assembly.

\mbox{\Hypertarget{classoomph_1_1Problem_a600bb1740edd0aa07c6d001033bf676a}\label{classoomph_1_1Problem_a600bb1740edd0aa07c6d001033bf676a}} 
\index{oomph::Problem@{oomph::Problem}!communicator\_pt@{communicator\_pt}}
\index{communicator\_pt@{communicator\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{communicator\_pt()}{communicator\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1OomphCommunicator}{Oomph\+Communicator}}$\ast$ oomph\+::\+Problem\+::communicator\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



access function to the oomph-\/lib communicator 



Definition at line 1246 of file problem.\+h.



References Communicator\+\_\+pt.



Referenced by oomph\+::\+Periodic\+Orbit\+Assembly\+Handler$<$ NNODE\+\_\+1\+D $>$\+::adapt\+\_\+temporal\+\_\+mesh(), arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), assign\+\_\+eqn\+\_\+numbers(), oomph\+::\+Multi\+\_\+domain\+\_\+functions\+::aux\+\_\+setup\+\_\+multi\+\_\+domain\+\_\+interaction(), copy\+\_\+haloed\+\_\+eqn\+\_\+numbers\+\_\+helper(), oomph\+::\+Multi\+\_\+domain\+\_\+functions\+::create\+\_\+external\+\_\+halo\+\_\+elements(), distribute(), doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve\+\_\+helper(), dump(), oomph\+::\+Fold\+Handler\+::\+Fold\+Handler(), get\+\_\+data\+\_\+to\+\_\+be\+\_\+sent\+\_\+during\+\_\+load\+\_\+balancing(), oomph\+::\+Multi\+\_\+domain\+\_\+functions\+::get\+\_\+dim\+\_\+helper(), oomph\+::\+Fold\+Handler\+::get\+\_\+eigenfunction(), oomph\+::\+Hopf\+Handler\+::get\+\_\+eigenfunction(), get\+\_\+hessian\+\_\+vector\+\_\+products(), get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals(), get\+\_\+jacobian(), get\+\_\+residuals(), oomph\+::\+Hopf\+Handler\+::\+Hopf\+Handler(), load\+\_\+balance(), oomph\+::\+Multi\+\_\+domain\+\_\+functions\+::locate\+\_\+zeta\+\_\+for\+\_\+missing\+\_\+coordinates(), newton\+\_\+solve(), parallel\+\_\+sparse\+\_\+assemble(), oomph\+::\+METIS\+::partition\+\_\+distributed\+\_\+mesh(), partition\+\_\+global\+\_\+mesh(), oomph\+::\+METIS\+::partition\+\_\+mesh(), oomph\+::\+Pitch\+Fork\+Handler\+::\+Pitch\+Fork\+Handler(), prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes(), read(), recompute\+\_\+load\+\_\+balanced\+\_\+assembly(), remove\+\_\+duplicate\+\_\+data(), remove\+\_\+null\+\_\+pointers\+\_\+from\+\_\+external\+\_\+halo\+\_\+node\+\_\+storage(), oomph\+::\+Block\+Pitch\+Fork\+Linear\+Solver\+::resolve(), oomph\+::\+Augmented\+Block\+Pitch\+Fork\+Linear\+Solver\+::resolve(), oomph\+::\+Multi\+\_\+domain\+\_\+functions\+::send\+\_\+and\+\_\+receive\+\_\+located\+\_\+info(), oomph\+::\+Multi\+\_\+domain\+\_\+functions\+::send\+\_\+and\+\_\+receive\+\_\+missing\+\_\+zetas(), send\+\_\+data\+\_\+to\+\_\+be\+\_\+sent\+\_\+during\+\_\+load\+\_\+balancing(), send\+\_\+refinement\+\_\+info\+\_\+helper(), set\+\_\+default\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly(), oomph\+::\+Solid\+ICProblem\+::set\+\_\+static\+\_\+initial\+\_\+condition(), setup\+\_\+base\+\_\+mesh\+\_\+info\+\_\+after\+\_\+pruning(), setup\+\_\+element\+\_\+count\+\_\+per\+\_\+dof(), oomph\+::\+Augmented\+Block\+Fold\+Linear\+Solver\+::solve(), oomph\+::\+Block\+Pitch\+Fork\+Linear\+Solver\+::solve(), oomph\+::\+Augmented\+Block\+Pitch\+Fork\+Linear\+Solver\+::solve(), oomph\+::\+Block\+Hopf\+Linear\+Solver\+::solve(), oomph\+::\+HSL\+\_\+\+MA42\+::solve(), oomph\+::\+GS$<$ MATRIX $>$\+::solve(), oomph\+::\+GS$<$ CRDouble\+Matrix $>$\+::solve(), oomph\+::\+Damped\+Jacobi$<$ MATRIX $>$\+::solve(), oomph\+::\+GMRES$<$ MATRIX $>$\+::solve(), oomph\+::\+Augmented\+Problem\+GMRES\+::solve(), oomph\+::\+Super\+LUSolver\+::solve(), oomph\+::\+Mumps\+Solver\+::solve(), oomph\+::\+Helmholtz\+GMRESMG$<$ MATRIX $>$\+::solve(), oomph\+::\+Helmholtz\+FGMRESMG$<$ MATRIX $>$\+::solve(), oomph\+::\+Fold\+Handler\+::solve\+\_\+augmented\+\_\+block\+\_\+system(), oomph\+::\+Pitch\+Fork\+Handler\+::solve\+\_\+augmented\+\_\+block\+\_\+system(), oomph\+::\+Fold\+Handler\+::solve\+\_\+block\+\_\+system(), oomph\+::\+Hopf\+Handler\+::solve\+\_\+complex\+\_\+system(), oomph\+::\+LAPACK\+\_\+\+QZ\+::solve\+\_\+eigenproblem\+\_\+helper(), oomph\+::\+ARPACK\+::solve\+\_\+eigenproblem\+\_\+legacy(), oomph\+::\+Block\+Hopf\+Linear\+Solver\+::solve\+\_\+for\+\_\+two\+\_\+rhs(), oomph\+::\+Fold\+Handler\+::solve\+\_\+full\+\_\+system(), oomph\+::\+Pitch\+Fork\+Handler\+::solve\+\_\+full\+\_\+system(), oomph\+::\+Hopf\+Handler\+::solve\+\_\+full\+\_\+system(), oomph\+::\+Hopf\+Handler\+::solve\+\_\+standard\+\_\+system(), oomph\+::\+Super\+LUSolver\+::solve\+\_\+transpose(), oomph\+::\+Pitch\+Fork\+Handler\+::synchronise(), synchronise\+\_\+dofs(), unsteady\+\_\+newton\+\_\+solve(), oomph\+::\+Fold\+Handler\+::$\sim$\+Fold\+Handler(), and oomph\+::\+Hopf\+Handler\+::$\sim$\+Hopf\+Handler().

\mbox{\Hypertarget{classoomph_1_1Problem_af1875e771e99a2e8f1d344d8b880d0de}\label{classoomph_1_1Problem_af1875e771e99a2e8f1d344d8b880d0de}} 
\index{oomph::Problem@{oomph::Problem}!communicator\_pt@{communicator\_pt}}
\index{communicator\_pt@{communicator\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{communicator\_pt()}{communicator\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily const \mbox{\hyperlink{classoomph_1_1OomphCommunicator}{Oomph\+Communicator}}$\ast$ oomph\+::\+Problem\+::communicator\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



access function to the oomph-\/lib communicator, const version 



Definition at line 1252 of file problem.\+h.



References Communicator\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1Problem_a4ac828f337a2d4e77e566ff95d01bad0}\label{classoomph_1_1Problem_a4ac828f337a2d4e77e566ff95d01bad0}} 
\index{oomph::Problem@{oomph::Problem}!copy@{copy}}
\index{copy@{copy}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{copy()}{copy()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::copy (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Problem}{Problem}} $\ast$}]{orig\+\_\+problem\+\_\+pt }\end{DoxyParamCaption})}



Copy \mbox{\hyperlink{classoomph_1_1Data}{Data}} values, nodal positions etc from specified problem. Note\+: This is not a copy constructor. We assume that the current and the \char`\"{}original\char`\"{} problem have both been created by calling the same problem constructor so that all \mbox{\hyperlink{classoomph_1_1Data}{Data}} objects, time steppers etc. in the two problems are completely independent. This function copies the nodal, internal and global values, and the time parameters from the original problem into \char`\"{}this\char`\"{} one. This functionality is required, e.\+g. for multigrid computations. 

Copy \mbox{\hyperlink{classoomph_1_1Data}{Data}} values, nodal positions etc from specified problem. Note\+: This is not a copy constructor. We assume that the current and the \char`\"{}original\char`\"{} problem have both been created by calling the same problem constructor so that all \mbox{\hyperlink{classoomph_1_1Data}{Data}} objects, time steppers etc. in the two problems are completely independent. This function copies the nodal, internal and global values and the time parameters from the original problem into \char`\"{}this\char`\"{} one. This functionality is required, e.\+g. for multigrid computations. 

Definition at line 12058 of file problem.\+cc.



References oomph\+::\+Data\+::copy(), oomph\+::\+Node\+::copy(), oomph\+::\+Solid\+Node\+::copy(), oomph\+::\+Time\+::dt(), e, oomph\+::\+Mesh\+::element\+\_\+pt(), Global\+\_\+data\+\_\+pt, global\+\_\+data\+\_\+pt(), i, oomph\+::\+Generalised\+Element\+::internal\+\_\+data\+\_\+pt(), mesh\+\_\+pt(), oomph\+::\+Time\+::ndt(), oomph\+::\+Mesh\+::nelement(), nglobal\+\_\+data(), oomph\+::\+Generalised\+Element\+::ninternal\+\_\+data(), oomph\+::\+Mesh\+::nnode(), oomph\+::\+Mesh\+::node\+\_\+pt(), nsub\+\_\+mesh(), ntime\+\_\+stepper(), oomph\+::oomph\+\_\+info, oomph\+::\+Time\+::resize(), oomph\+::\+Time\+Stepper\+::set\+\_\+weights(), oomph\+::\+Time\+::time(), time\+\_\+pt(), and time\+\_\+stepper\+\_\+pt().

\mbox{\Hypertarget{classoomph_1_1Problem_a3d06660ec06b402f14d4b33a84621214}\label{classoomph_1_1Problem_a3d06660ec06b402f14d4b33a84621214}} 
\index{oomph::Problem@{oomph::Problem}!copy\_haloed\_eqn\_numbers\_helper@{copy\_haloed\_eqn\_numbers\_helper}}
\index{copy\_haloed\_eqn\_numbers\_helper@{copy\_haloed\_eqn\_numbers\_helper}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{copy\_haloed\_eqn\_numbers\_helper()}{copy\_haloed\_eqn\_numbers\_helper()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::copy\+\_\+haloed\+\_\+eqn\+\_\+numbers\+\_\+helper (\begin{DoxyParamCaption}\item[{const bool \&}]{do\+\_\+halos,  }\item[{const bool \&}]{do\+\_\+external\+\_\+halos }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



A private helper function to copy the haloed equation numbers into the halo equation numbers, either for the problem\textquotesingle{}s one and only mesh or for all of its submeshes. Bools control if we deal with data associated with external halo/ed elements/nodes or the \char`\"{}normal\char`\"{} halo/ed ones. 



Definition at line 17144 of file problem.\+cc.



References oomph\+::\+Data\+::add\+\_\+eqn\+\_\+numbers\+\_\+to\+\_\+vector(), oomph\+::\+Generalised\+Element\+::add\+\_\+internal\+\_\+eqn\+\_\+numbers\+\_\+to\+\_\+vector(), communicator\+\_\+pt(), e, oomph\+::\+Mesh\+::external\+\_\+halo\+\_\+element\+\_\+pt(), oomph\+::\+Mesh\+::external\+\_\+halo\+\_\+node\+\_\+pt(), oomph\+::\+Mesh\+::external\+\_\+haloed\+\_\+element\+\_\+pt(), oomph\+::\+Mesh\+::external\+\_\+haloed\+\_\+node\+\_\+pt(), oomph\+::\+Mesh\+::halo\+\_\+element\+\_\+pt(), oomph\+::\+Mesh\+::halo\+\_\+node\+\_\+pt(), oomph\+::\+Mesh\+::haloed\+\_\+element\+\_\+pt(), oomph\+::\+Mesh\+::haloed\+\_\+node\+\_\+pt(), mesh\+\_\+pt(), oomph\+::\+Mesh\+::nexternal\+\_\+halo\+\_\+element(), oomph\+::\+Mesh\+::nexternal\+\_\+halo\+\_\+node(), oomph\+::\+Mesh\+::nexternal\+\_\+haloed\+\_\+element(), oomph\+::\+Mesh\+::nexternal\+\_\+haloed\+\_\+node(), oomph\+::\+Mesh\+::nhalo\+\_\+node(), oomph\+::\+Mesh\+::nhaloed\+\_\+node(), nsub\+\_\+mesh(), oomph\+::\+Data\+::read\+\_\+eqn\+\_\+numbers\+\_\+from\+\_\+vector(), and oomph\+::\+Generalised\+Element\+::read\+\_\+internal\+\_\+eqn\+\_\+numbers\+\_\+from\+\_\+vector().



Referenced by synchronise\+\_\+eqn\+\_\+numbers().

\mbox{\Hypertarget{classoomph_1_1Problem_a9af22a1cfead13bcad14c1b78d1cf273}\label{classoomph_1_1Problem_a9af22a1cfead13bcad14c1b78d1cf273}} 
\index{oomph::Problem@{oomph::Problem}!create\_new\_linear\_algebra\_distribution@{create\_new\_linear\_algebra\_distribution}}
\index{create\_new\_linear\_algebra\_distribution@{create\_new\_linear\_algebra\_distribution}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{create\_new\_linear\_algebra\_distribution()}{create\_new\_linear\_algebra\_distribution()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::create\+\_\+new\+\_\+linear\+\_\+algebra\+\_\+distribution (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution}} $\ast$\&}]{dist\+\_\+pt }\end{DoxyParamCaption})}



Get new linear algebra distribution (you\textquotesingle{}re in charge of deleting it!) 

Build new \mbox{\hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution}}. Note\+: you\textquotesingle{}re in charge of deleting it! 

Definition at line 299 of file problem.\+cc.



References Communicator\+\_\+pt, Default\+\_\+matrix\+\_\+distribution, Dist\+\_\+problem\+\_\+matrix\+\_\+distribution, Dof\+\_\+distribution\+\_\+pt, ndof(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow\+\_\+local(), Problem\+\_\+has\+\_\+been\+\_\+distributed, Problem\+\_\+matrix\+\_\+distribution, and Uniform\+\_\+matrix\+\_\+distribution.



Referenced by get\+\_\+eigenproblem\+\_\+matrices(), get\+\_\+jacobian(), get\+\_\+residuals(), and oomph\+::\+ANASAZI\+::solve\+\_\+eigenproblem().

\mbox{\Hypertarget{classoomph_1_1Problem_ac5b47ae12ed6445e52c65596dfa97c6d}\label{classoomph_1_1Problem_ac5b47ae12ed6445e52c65596dfa97c6d}} 
\index{oomph::Problem@{oomph::Problem}!deactivate\_bifurcation\_tracking@{deactivate\_bifurcation\_tracking}}
\index{deactivate\_bifurcation\_tracking@{deactivate\_bifurcation\_tracking}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{deactivate\_bifurcation\_tracking()}{deactivate\_bifurcation\_tracking()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::deactivate\+\_\+bifurcation\+\_\+tracking (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Deactivate all bifuraction tracking, by reseting the assembly handler to the default. 



Definition at line 2482 of file problem.\+h.



References reset\+\_\+assembly\+\_\+handler\+\_\+to\+\_\+default().



Referenced by bifurcation\+\_\+adapt\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_a36c95c8211cc02558118288888aab5e1}\label{classoomph_1_1Problem_a36c95c8211cc02558118288888aab5e1}} 
\index{oomph::Problem@{oomph::Problem}!debug\_hook\_fct@{debug\_hook\_fct}}
\index{debug\_hook\_fct@{debug\_hook\_fct}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{debug\_hook\_fct()}{debug\_hook\_fct()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::debug\+\_\+hook\+\_\+fct (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Hook for debugging. Can be overloaded in driver code; argument allows identification of where we\textquotesingle{}re coming from. 



Definition at line 249 of file problem.\+h.



References i, and oomph\+::oomph\+\_\+info.

\mbox{\Hypertarget{classoomph_1_1Problem_ab8eb3782046c64ea0e46205917440452}\label{classoomph_1_1Problem_ab8eb3782046c64ea0e46205917440452}} 
\index{oomph::Problem@{oomph::Problem}!delete\_all\_external\_storage@{delete\_all\_external\_storage}}
\index{delete\_all\_external\_storage@{delete\_all\_external\_storage}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{delete\_all\_external\_storage()}{delete\_all\_external\_storage()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::delete\+\_\+all\+\_\+external\+\_\+storage (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Wrapper function to delete external storage for each submesh of the problem. 

Delete any external storage for any submeshes NB this would ordinarily take place within the adaptation procedure for each submesh (See Refineable\+Mesh\+::adapt\+\_\+mesh(...)), but there are instances where the actions\+\_\+before/after\+\_\+adapt routines are used and no adaptive routines are called in between (e.\+g. when doc-\/ing errors at the end of an adaptive newton solver) 

Definition at line 16548 of file problem.\+cc.



References oomph\+::\+Mesh\+::delete\+\_\+all\+\_\+external\+\_\+storage(), mesh\+\_\+pt(), and nsub\+\_\+mesh().



Referenced by load\+\_\+balance().

\mbox{\Hypertarget{classoomph_1_1Problem_a0563ae60b5c372087398fc3c45af757d}\label{classoomph_1_1Problem_a0563ae60b5c372087398fc3c45af757d}} 
\index{oomph::Problem@{oomph::Problem}!describe\_dofs@{describe\_dofs}}
\index{describe\_dofs@{describe\_dofs}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{describe\_dofs()}{describe\_dofs()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::describe\+\_\+dofs (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{out = {\ttfamily $\ast$(oomph\+\_\+info.stream\+\_\+pt())} }\end{DoxyParamCaption}) const}



Function to describe the dofs in terms of the global equation number, i.\+e. what type of value (nodal value of a \mbox{\hyperlink{classoomph_1_1Node}{Node}}; value in a \mbox{\hyperlink{classoomph_1_1Data}{Data}} object; value of internal \mbox{\hyperlink{classoomph_1_1Data}{Data}} in an element; etc) is the unknown with a certain global equation number. Output stream defaults to oomph\+\_\+info. 



Definition at line 2445 of file problem.\+cc.



References oomph\+::\+Mesh\+::describe\+\_\+dofs(), oomph\+::\+Mesh\+::describe\+\_\+local\+\_\+dofs(), Global\+\_\+data\+\_\+pt, i, Mesh\+\_\+pt, nglobal\+\_\+data(), nsub\+\_\+mesh(), oomph\+::\+Global\+\_\+string\+\_\+for\+\_\+annotation\+::string(), and Sub\+\_\+mesh\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1Problem_afa64d728ceff0dd772bbbc8f2adcddfb}\label{classoomph_1_1Problem_afa64d728ceff0dd772bbbc8f2adcddfb}} 
\index{oomph::Problem@{oomph::Problem}!disable\_discontinuous\_formulation@{disable\_discontinuous\_formulation}}
\index{disable\_discontinuous\_formulation@{disable\_discontinuous\_formulation}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{disable\_discontinuous\_formulation()}{disable\_discontinuous\_formulation()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::disable\+\_\+discontinuous\+\_\+formulation (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Disable the use of a discontinuous-\/element formulation. Note that the methods will all still work even if the elements are discontinuous, we will just be assembling a larger system matrix than necessary. 



Definition at line 1740 of file problem.\+h.



References Discontinuous\+\_\+element\+\_\+formulation.

\mbox{\Hypertarget{classoomph_1_1Problem_a9365d2b0057089ae5551b97488a3a62a}\label{classoomph_1_1Problem_a9365d2b0057089ae5551b97488a3a62a}} 
\index{oomph::Problem@{oomph::Problem}!disable\_doc\_imbalance\_in\_parallel\_assembly@{disable\_doc\_imbalance\_in\_parallel\_assembly}}
\index{disable\_doc\_imbalance\_in\_parallel\_assembly@{disable\_doc\_imbalance\_in\_parallel\_assembly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{disable\_doc\_imbalance\_in\_parallel\_assembly()}{disable\_doc\_imbalance\_in\_parallel\_assembly()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::disable\+\_\+doc\+\_\+imbalance\+\_\+in\+\_\+parallel\+\_\+assembly (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Disable doc of load imbalance in parallel assembly of distributed problem. 



Definition at line 856 of file problem.\+h.



References Doc\+\_\+imbalance\+\_\+in\+\_\+parallel\+\_\+assembly.

\mbox{\Hypertarget{classoomph_1_1Problem_a927d35230db6fc5021b68eadaedac9a6}\label{classoomph_1_1Problem_a927d35230db6fc5021b68eadaedac9a6}} 
\index{oomph::Problem@{oomph::Problem}!disable\_globally\_convergent\_newton\_method@{disable\_globally\_convergent\_newton\_method}}
\index{disable\_globally\_convergent\_newton\_method@{disable\_globally\_convergent\_newton\_method}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{disable\_globally\_convergent\_newton\_method()}{disable\_globally\_convergent\_newton\_method()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::disable\+\_\+globally\+\_\+convergent\+\_\+newton\+\_\+method (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



disable globally convergent Newton method 



Definition at line 2138 of file problem.\+h.



References Use\+\_\+globally\+\_\+convergent\+\_\+newton\+\_\+method.

\mbox{\Hypertarget{classoomph_1_1Problem_af00e3623681347439fe3dac650423bbe}\label{classoomph_1_1Problem_af00e3623681347439fe3dac650423bbe}} 
\index{oomph::Problem@{oomph::Problem}!disable\_info\_in\_newton\_solve@{disable\_info\_in\_newton\_solve}}
\index{disable\_info\_in\_newton\_solve@{disable\_info\_in\_newton\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{disable\_info\_in\_newton\_solve()}{disable\_info\_in\_newton\_solve()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::disable\+\_\+info\+\_\+in\+\_\+newton\+\_\+solve (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Disable the output of information when in the newton solver. 



Definition at line 3070 of file problem.\+h.



References Shut\+\_\+up\+\_\+in\+\_\+newton\+\_\+solve.



Referenced by oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::project().

\mbox{\Hypertarget{classoomph_1_1Problem_a52489fed5942629199e4f720a7a86549}\label{classoomph_1_1Problem_a52489fed5942629199e4f720a7a86549}} 
\index{oomph::Problem@{oomph::Problem}!disable\_jacobian\_reuse@{disable\_jacobian\_reuse}}
\index{disable\_jacobian\_reuse@{disable\_jacobian\_reuse}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{disable\_jacobian\_reuse()}{disable\_jacobian\_reuse()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::disable\+\_\+jacobian\+\_\+reuse (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Disable recycling of Jacobian in Newton iteration. 



Definition at line 2111 of file problem.\+h.



References Jacobian\+\_\+has\+\_\+been\+\_\+computed, and Jacobian\+\_\+reuse\+\_\+is\+\_\+enabled.

\mbox{\Hypertarget{classoomph_1_1Problem_a399ca4ccf551f9bf5621f9855e899af6}\label{classoomph_1_1Problem_a399ca4ccf551f9bf5621f9855e899af6}} 
\index{oomph::Problem@{oomph::Problem}!disable\_mass\_matrix\_reuse@{disable\_mass\_matrix\_reuse}}
\index{disable\_mass\_matrix\_reuse@{disable\_mass\_matrix\_reuse}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{disable\_mass\_matrix\_reuse()}{disable\_mass\_matrix\_reuse()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::disable\+\_\+mass\+\_\+matrix\+\_\+reuse (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Turn off recyling of the mass matrix in explicit timestepping schemes. 

Turn off the recyling of the mass matrix in explicit time-\/stepping schemes. 

Definition at line 12025 of file problem.\+cc.



References oomph\+::\+DGElement\+::disable\+\_\+mass\+\_\+matrix\+\_\+reuse(), Discontinuous\+\_\+element\+\_\+formulation, e, oomph\+::\+Mesh\+::element\+\_\+pt(), Mass\+\_\+matrix\+\_\+has\+\_\+been\+\_\+computed, Mass\+\_\+matrix\+\_\+reuse\+\_\+is\+\_\+enabled, mesh\+\_\+pt(), and oomph\+::\+Mesh\+::nelement().

\mbox{\Hypertarget{classoomph_1_1Problem_a79752d23035158783ad19711027984dc}\label{classoomph_1_1Problem_a79752d23035158783ad19711027984dc}} 
\index{oomph::Problem@{oomph::Problem}!disable\_problem\_distributed@{disable\_problem\_distributed}}
\index{disable\_problem\_distributed@{disable\_problem\_distributed}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{disable\_problem\_distributed()}{disable\_problem\_distributed()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::disable\+\_\+problem\+\_\+distributed (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Disable problem distributed. 



Definition at line 977 of file problem.\+h.



References Problem\+\_\+has\+\_\+been\+\_\+distributed.

\mbox{\Hypertarget{classoomph_1_1Problem_ac23468bc4101d3038e6b537b6fc87aa6}\label{classoomph_1_1Problem_ac23468bc4101d3038e6b537b6fc87aa6}} 
\index{oomph::Problem@{oomph::Problem}!disable\_store\_local\_dof\_pt\_in\_elements@{disable\_store\_local\_dof\_pt\_in\_elements}}
\index{disable\_store\_local\_dof\_pt\_in\_elements@{disable\_store\_local\_dof\_pt\_in\_elements}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{disable\_store\_local\_dof\_pt\_in\_elements()}{disable\_store\_local\_dof\_pt\_in\_elements()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::disable\+\_\+store\+\_\+local\+\_\+dof\+\_\+pt\+\_\+in\+\_\+elements (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Insist that local dof pointers are NOT set up in each element when equation numbering takes place (the default) 



Definition at line 1707 of file problem.\+h.



References Store\+\_\+local\+\_\+dof\+\_\+pt\+\_\+in\+\_\+elements.

\mbox{\Hypertarget{classoomph_1_1Problem_af0365ddbe425b730ece6a575db1cd7dd}\label{classoomph_1_1Problem_af0365ddbe425b730ece6a575db1cd7dd}} 
\index{oomph::Problem@{oomph::Problem}!distribute@{distribute}}
\index{distribute@{distribute}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{distribute()}{distribute()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ oomph\+::\+Problem\+::distribute (\begin{DoxyParamCaption}\item[{const bool \&}]{report\+\_\+stats = {\ttfamily false} }\end{DoxyParamCaption})}



Distribute the problem; returns a vector which details the partitioning. 

Distribute the problem without doc; report stats if required. Returns actual partitioning used, e.\+g. for restart. 

Definition at line 415 of file problem.\+cc.



References oomph\+::\+Doc\+Info\+::disable\+\_\+doc(), distribute(), mesh\+\_\+pt(), and oomph\+::\+Mesh\+::nelement().

\mbox{\Hypertarget{classoomph_1_1Problem_aa35f7ff2b0075cfd4dda519858a65d6c}\label{classoomph_1_1Problem_aa35f7ff2b0075cfd4dda519858a65d6c}} 
\index{oomph::Problem@{oomph::Problem}!distribute@{distribute}}
\index{distribute@{distribute}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{distribute()}{distribute()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ oomph\+::\+Problem\+::distribute (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{element\+\_\+partition,  }\item[{const bool \&}]{report\+\_\+stats = {\ttfamily false} }\end{DoxyParamCaption})}



Distribute the problem using the specified partition; returns a vector which details the partitioning. 

Distribute the problem according to specified partition. If all entries in partitioning vector are zero we use \mbox{\hyperlink{namespaceoomph_1_1METIS}{METIS}} to do the partitioning after all. Returns actual partitioning used, e.\+g. for restart. 

Definition at line 435 of file problem.\+cc.



References oomph\+::\+Doc\+Info\+::disable\+\_\+doc(), distribute(), and i.

\mbox{\Hypertarget{classoomph_1_1Problem_aa35e1adc0fdf14b217c7b608eb9cf20b}\label{classoomph_1_1Problem_aa35e1adc0fdf14b217c7b608eb9cf20b}} 
\index{oomph::Problem@{oomph::Problem}!distribute@{distribute}}
\index{distribute@{distribute}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{distribute()}{distribute()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ oomph\+::\+Problem\+::distribute (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{element\+\_\+partition,  }\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info,  }\item[{const bool \&}]{report\+\_\+stats = {\ttfamily false} }\end{DoxyParamCaption})}



Distribute the problem and doc, using the specified partition; returns a vector which details the partitioning. 

Distribute the problem according to specified partition. (If all entries in partitioning vector are zero we use \mbox{\hyperlink{namespaceoomph_1_1METIS}{METIS}} to do the partitioning after all) and doc. Returns actual partitioning used, e.\+g. for restart. 

Definition at line 490 of file problem.\+cc.



References actions\+\_\+after\+\_\+distribute(), actions\+\_\+before\+\_\+distribute(), assign\+\_\+eqn\+\_\+numbers(), Base\+\_\+mesh\+\_\+element\+\_\+number\+\_\+plus\+\_\+one, Base\+\_\+mesh\+\_\+element\+\_\+pt, communicator\+\_\+pt(), oomph\+::\+Mesh\+::distribute(), Doc\+\_\+time\+\_\+in\+\_\+distribute, e, oomph\+::\+Mesh\+::element\+\_\+pt(), Elemental\+\_\+assembly\+\_\+time, mesh\+\_\+pt(), Must\+\_\+recompute\+\_\+load\+\_\+balance\+\_\+for\+\_\+assembly, ndof(), oomph\+::\+Mesh\+::nelement(), nglobal\+\_\+data(), nsub\+\_\+mesh(), oomph\+::\+Doc\+Info\+::number(), oomph\+::oomph\+\_\+info, partition\+\_\+global\+\_\+mesh(), Problem\+\_\+has\+\_\+been\+\_\+distributed, rebuild\+\_\+global\+\_\+mesh(), oomph\+::\+Mesh\+::set\+\_\+communicator\+\_\+pt(), and oomph\+::\+Timing\+Helpers\+::timer().



Referenced by distribute().

\mbox{\Hypertarget{classoomph_1_1Problem_a9bab7c41bf5d6d053259ff10920d7303}\label{classoomph_1_1Problem_a9bab7c41bf5d6d053259ff10920d7303}} 
\index{oomph::Problem@{oomph::Problem}!distribute@{distribute}}
\index{distribute@{distribute}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{distribute()}{distribute()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ oomph\+::\+Problem\+::distribute (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info,  }\item[{const bool \&}]{report\+\_\+stats = {\ttfamily false} }\end{DoxyParamCaption})}



Distribute the problem; returns a vector which details the partitioning. 

Distribute the problem and doc to specified \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}}. Returns actual partitioning used, e.\+g. for restart. 

Definition at line 471 of file problem.\+cc.



References distribute(), mesh\+\_\+pt(), and oomph\+::\+Mesh\+::nelement().

\mbox{\Hypertarget{classoomph_1_1Problem_af5e9f1623cad361048856a4c0463ea23}\label{classoomph_1_1Problem_af5e9f1623cad361048856a4c0463ea23}} 
\index{oomph::Problem@{oomph::Problem}!distributed@{distributed}}
\index{distributed@{distributed}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{distributed()}{distributed()}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::distributed (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



If we have MPI return the \char`\"{}problem has been distributed\char`\"{} flag, otherwise it can\textquotesingle{}t be distributed so return false. 



Definition at line 808 of file problem.\+h.



References Problem\+\_\+has\+\_\+been\+\_\+distributed.



Referenced by calculate\+\_\+predictions(), get\+\_\+dofs(), oomph\+::\+Navier\+Stokes\+Schur\+Complement\+Preconditioner\+::get\+\_\+pressure\+\_\+advection\+\_\+diffusion\+\_\+matrix(), oomph\+::\+Pitch\+Fork\+Handler\+::\+Pitch\+Fork\+Handler(), oomph\+::\+Block\+Pitch\+Fork\+Linear\+Solver\+::resolve(), set\+\_\+dofs(), and oomph\+::\+Block\+Pitch\+Fork\+Linear\+Solver\+::solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a4d329a86be53aee9f96a3428809db5f0}\label{classoomph_1_1Problem_a4d329a86be53aee9f96a3428809db5f0}} 
\index{oomph::Problem@{oomph::Problem}!distributed\_problem\_matrix\_distribution@{distributed\_problem\_matrix\_distribution}}
\index{distributed\_problem\_matrix\_distribution@{distributed\_problem\_matrix\_distribution}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{distributed\_problem\_matrix\_distribution()}{distributed\_problem\_matrix\_distribution()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402}{Distributed\+\_\+problem\+\_\+matrix\+\_\+distribution}}\& oomph\+::\+Problem\+::distributed\+\_\+problem\+\_\+matrix\+\_\+distribution (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



accesss function to the distributed matrix distribution method 1 -\/ Automatic -\/ the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} distribution is employed, unless any processor has number of rows equal to 110\% of N/P, in which case uniform distribution is employed. 2 -\/ \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} -\/ the jacobian on processor p only contains rows that correspond to equations that are on this processor. (minimises communication) 3 -\/ Uniform -\/ each processor holds as close to N/P matrix rows as possible. (very well load balanced) 



Definition at line 842 of file problem.\+h.



References Dist\+\_\+problem\+\_\+matrix\+\_\+distribution.

\mbox{\Hypertarget{classoomph_1_1Problem_af2a9dfdb7b4f95bb941d48411f955f55}\label{classoomph_1_1Problem_af2a9dfdb7b4f95bb941d48411f955f55}} 
\index{oomph::Problem@{oomph::Problem}!doc\_errors@{doc\_errors}}
\index{doc\_errors@{doc\_errors}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{doc\_errors()}{doc\_errors()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::doc\+\_\+errors (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Get max and min error for all elements in submeshes. 



Definition at line 3055 of file problem.\+h.



References oomph\+::\+Doc\+Info\+::disable\+\_\+doc().

\mbox{\Hypertarget{classoomph_1_1Problem_af2a77519885ccb13e4644c89b19c37a7}\label{classoomph_1_1Problem_af2a77519885ccb13e4644c89b19c37a7}} 
\index{oomph::Problem@{oomph::Problem}!doc\_errors@{doc\_errors}}
\index{doc\_errors@{doc\_errors}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{doc\_errors()}{doc\_errors()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::doc\+\_\+errors (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info }\end{DoxyParamCaption})}



Get max and min error for all elements in submeshes. 



Definition at line 14967 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, bifurcation\+\_\+adapt\+\_\+doc\+\_\+errors(), oomph\+::\+Assembly\+Handler\+::bifurcation\+\_\+type(), oomph\+::\+Error\+Estimator\+::get\+\_\+element\+\_\+errors(), oomph\+::\+Doc\+Info\+::is\+\_\+doc\+\_\+enabled(), mesh\+\_\+pt(), nsub\+\_\+mesh(), and oomph\+::oomph\+\_\+info.

\mbox{\Hypertarget{classoomph_1_1Problem_af7a83b109e7662abd52ea552d89163cc}\label{classoomph_1_1Problem_af7a83b109e7662abd52ea552d89163cc}} 
\index{oomph::Problem@{oomph::Problem}!does\_pointer\_correspond\_to\_problem\_data@{does\_pointer\_correspond\_to\_problem\_data}}
\index{does\_pointer\_correspond\_to\_problem\_data@{does\_pointer\_correspond\_to\_problem\_data}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{does\_pointer\_correspond\_to\_problem\_data()}{does\_pointer\_correspond\_to\_problem\_data()}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::does\+\_\+pointer\+\_\+correspond\+\_\+to\+\_\+problem\+\_\+data (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Return a boolean flag to indicate whether the pointer parameter\+\_\+pt refers to values stored in a \mbox{\hyperlink{classoomph_1_1Data}{Data}} object that is contained within the problem. 

Function that returns a boolean flag to indicate whether the pointer parameter\+\_\+pt refers to memory that is a value in a \mbox{\hyperlink{classoomph_1_1Data}{Data}} object used within the problem. 

Definition at line 10039 of file problem.\+cc.



References oomph\+::\+Mesh\+::does\+\_\+pointer\+\_\+correspond\+\_\+to\+\_\+mesh\+\_\+data(), Global\+\_\+data\+\_\+pt, i, Mesh\+\_\+pt, nsub\+\_\+mesh(), and Sub\+\_\+mesh\+\_\+pt.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a74d71439b100fb5b66b94d1d69130f7c}\label{classoomph_1_1Problem_a74d71439b100fb5b66b94d1d69130f7c}} 
\index{oomph::Problem@{oomph::Problem}!dof@{dof}}
\index{dof@{dof}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{dof()}{dof()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double\& oomph\+::\+Problem\+::dof (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



i-\/th dof in the problem 



Definition at line 1817 of file problem.\+h.



References Dof\+\_\+pt, and i.



Referenced by oomph\+::\+IMRBy\+BDF\+::actions\+\_\+before\+\_\+timestep(), adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), add\+\_\+eigenvector\+\_\+to\+\_\+dofs(), assign\+\_\+eigenvector\+\_\+to\+\_\+dofs(), bifurcation\+\_\+adapt\+\_\+helper(), calculate\+\_\+predictions(), oomph\+::\+Periodic\+Orbit\+Assembly\+Handler$<$ NNODE\+\_\+1\+D $>$\+::get\+\_\+dofs\+\_\+for\+\_\+element(), get\+\_\+hessian\+\_\+vector\+\_\+products(), oomph\+::\+Augmented\+Block\+Fold\+Linear\+Solver\+::resolve(), oomph\+::\+Augmented\+Block\+Pitch\+Fork\+Linear\+Solver\+::resolve(), restore\+\_\+dof\+\_\+values(), oomph\+::\+Periodic\+Orbit\+Assembly\+Handler$<$ NNODE\+\_\+1\+D $>$\+::set\+\_\+dofs\+\_\+for\+\_\+element(), oomph\+::\+Periodic\+Orbit\+Assembly\+Handler$<$ NNODE\+\_\+1\+D $>$\+::set\+\_\+previous\+\_\+dofs\+\_\+to\+\_\+current\+\_\+dofs(), oomph\+::\+Augmented\+Block\+Fold\+Linear\+Solver\+::solve(), oomph\+::\+Augmented\+Block\+Pitch\+Fork\+Linear\+Solver\+::solve(), oomph\+::\+Block\+Hopf\+Linear\+Solver\+::solve(), oomph\+::\+Block\+Hopf\+Linear\+Solver\+::solve\+\_\+for\+\_\+two\+\_\+rhs(), and store\+\_\+current\+\_\+dof\+\_\+values().

\mbox{\Hypertarget{classoomph_1_1Problem_a200cbd03828632d448c3525e9a921f27}\label{classoomph_1_1Problem_a200cbd03828632d448c3525e9a921f27}} 
\index{oomph::Problem@{oomph::Problem}!dof@{dof}}
\index{dof@{dof}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{dof()}{dof()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::dof (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



i-\/th dof in the problem (const version) 



Definition at line 1823 of file problem.\+h.



References Dof\+\_\+pt, and i.

\mbox{\Hypertarget{classoomph_1_1Problem_a10fd6457ceceb02a0e11d860ac0017c5}\label{classoomph_1_1Problem_a10fd6457ceceb02a0e11d860ac0017c5}} 
\index{oomph::Problem@{oomph::Problem}!dof\_current@{dof\_current}}
\index{dof\_current@{dof\_current}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{dof\_current()}{dof\_current()}}
{\footnotesize\ttfamily double\& oomph\+::\+Problem\+::dof\+\_\+current (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}



Access function to the current value of the i-\/th (local) dof at the start of a continuation step. 



Definition at line 1182 of file problem.\+h.



References Dof\+\_\+current, Dof\+\_\+current\+\_\+offset, Dof\+\_\+pt, i, and Use\+\_\+continuation\+\_\+timestepper.



Referenced by adapt(), arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), and newton\+\_\+solve\+\_\+continuation().

\mbox{\Hypertarget{classoomph_1_1Problem_ad6df5fb0d282f25df1e94a665dd838e5}\label{classoomph_1_1Problem_ad6df5fb0d282f25df1e94a665dd838e5}} 
\index{oomph::Problem@{oomph::Problem}!dof\_derivative@{dof\_derivative}}
\index{dof\_derivative@{dof\_derivative}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{dof\_derivative()}{dof\_derivative()}}
{\footnotesize\ttfamily double\& oomph\+::\+Problem\+::dof\+\_\+derivative (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}



Access function to the derivative of the i-\/th (local) dof with respect to the arc length, used in continuation. 



Definition at line 1168 of file problem.\+h.



References Dof\+\_\+derivative, Dof\+\_\+derivative\+\_\+offset, Dof\+\_\+pt, i, and Use\+\_\+continuation\+\_\+timestepper.



Referenced by adapt(), arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd\+\_\+helper(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+helper(), and newton\+\_\+solve\+\_\+continuation().

\mbox{\Hypertarget{classoomph_1_1Problem_a17a5a4886c4213422179fe8346336a4e}\label{classoomph_1_1Problem_a17a5a4886c4213422179fe8346336a4e}} 
\index{oomph::Problem@{oomph::Problem}!dof\_distribution\_pt@{dof\_distribution\_pt}}
\index{dof\_distribution\_pt@{dof\_distribution\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{dof\_distribution\_pt()}{dof\_distribution\_pt()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution}}$\ast$ const\& oomph\+::\+Problem\+::dof\+\_\+distribution\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the pointer to the dof distribution (read-\/only) 



Definition at line 1672 of file problem.\+h.



References Dof\+\_\+distribution\+\_\+pt.



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), oomph\+::\+Adjoint\+Problem\+Based\+Shift\+Invert\+Operator\+::\+Adjoint\+Problem\+Based\+Shift\+Invert\+Operator(), oomph\+::\+Problem\+Based\+Shift\+Invert\+Operator\+::\+Problem\+Based\+Shift\+Invert\+Operator(), and oomph\+::\+ANASAZI\+::solve\+\_\+eigenproblem\+\_\+legacy().

\mbox{\Hypertarget{classoomph_1_1Problem_a02f480ec17e0b9b03c892be5ed0c64d1}\label{classoomph_1_1Problem_a02f480ec17e0b9b03c892be5ed0c64d1}} 
\index{oomph::Problem@{oomph::Problem}!dof\_pt@{dof\_pt}}
\index{dof\_pt@{dof\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{dof\_pt()}{dof\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double$\ast$\& oomph\+::\+Problem\+::dof\+\_\+pt (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Pointer to i-\/th dof in the problem. 



Definition at line 1829 of file problem.\+h.



References Dof\+\_\+pt, and i.



Referenced by oomph\+::\+Assembly\+Handler\+::local\+\_\+problem\+\_\+dof(), and set\+\_\+dofs().

\mbox{\Hypertarget{classoomph_1_1Problem_acf51914cb75a640f82b269493311c187}\label{classoomph_1_1Problem_acf51914cb75a640f82b269493311c187}} 
\index{oomph::Problem@{oomph::Problem}!dof\_pt@{dof\_pt}}
\index{dof\_pt@{dof\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{dof\_pt()}{dof\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double$\ast$ oomph\+::\+Problem\+::dof\+\_\+pt (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Pointer to i-\/th dof in the problem (const version) 



Definition at line 1835 of file problem.\+h.



References Dof\+\_\+pt, and i.

\mbox{\Hypertarget{classoomph_1_1Problem_a7561d4f82e1fa625210c58a78294a301}\label{classoomph_1_1Problem_a7561d4f82e1fa625210c58a78294a301}} 
\index{oomph::Problem@{oomph::Problem}!doubly\_adaptive\_unsteady\_newton\_solve@{doubly\_adaptive\_unsteady\_newton\_solve}}
\index{doubly\_adaptive\_unsteady\_newton\_solve@{doubly\_adaptive\_unsteady\_newton\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{doubly\_adaptive\_unsteady\_newton\_solve()}{doubly\_adaptive\_unsteady\_newton\_solve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve (\begin{DoxyParamCaption}\item[{const double \&}]{dt,  }\item[{const double \&}]{epsilon,  }\item[{const unsigned \&}]{max\+\_\+adapt,  }\item[{const bool \&}]{first,  }\item[{const bool \&}]{shift = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Unsteady \char`\"{}doubly\char`\"{} adaptive Newton solve\+: Does temporal adaptation first, i.\+e. we try to do a timestep with an increment of dt, and adjusting dt until the solution on the given mesh satisfies the temporal error measure with tolerance epsilon. Following this, we do up to max\+\_\+adapt spatial adaptions (without re-\/examining the temporal error). If first==true, the initial conditions are re-\/assigned after the mesh adaptations. Shifting of time can be suppressed by overwriting the default value of shift (true). \mbox{[}Shifting must be done if first\+\_\+timestep==true because we\textquotesingle{}re constantly re-\/assigning the initial conditions; if first\+\_\+timestep==true and shift==false shifting is performed anyway and a warning is issued. 



Definition at line 2600 of file problem.\+h.



References doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_ae6c326bce8647c2a59cf62288ce4902e}\label{classoomph_1_1Problem_ae6c326bce8647c2a59cf62288ce4902e}} 
\index{oomph::Problem@{oomph::Problem}!doubly\_adaptive\_unsteady\_newton\_solve@{doubly\_adaptive\_unsteady\_newton\_solve}}
\index{doubly\_adaptive\_unsteady\_newton\_solve@{doubly\_adaptive\_unsteady\_newton\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{doubly\_adaptive\_unsteady\_newton\_solve()}{doubly\_adaptive\_unsteady\_newton\_solve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve (\begin{DoxyParamCaption}\item[{const double \&}]{dt,  }\item[{const double \&}]{epsilon,  }\item[{const unsigned \&}]{max\+\_\+adapt,  }\item[{const unsigned \&}]{suppress\+\_\+resolve\+\_\+after\+\_\+spatial\+\_\+adapt\+\_\+flag,  }\item[{const bool \&}]{first,  }\item[{const bool \&}]{shift = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Unsteady \char`\"{}doubly\char`\"{} adaptive Newton solve\+: Does temporal adaptation first, i.\+e. we try to do a timestep with an increment of dt, and adjusting dt until the solution on the given mesh satisfies the temporal error measure with tolerance epsilon. Following this, we do up to max\+\_\+adapt spatial adaptions (without re-\/examining the temporal error). If first==true, the initial conditions are re-\/assigned after the mesh adaptations. Shifting of time can be suppressed by overwriting the default value of shift (true). \mbox{[}Shifting must be done if first\+\_\+timestep==true because we\textquotesingle{}re constantly re-\/assigning the initial conditions; if first\+\_\+timestep==true and shift==false shifting is performed anyway and a warning is issued. Pseudo-\/\+Boolean flag suppress\+\_\+resolve\+\_\+after\+\_\+spatial\+\_\+adapt \mbox{[}0\+: false; 1\+: true\mbox{]} does what it says.\mbox{]}. 



Definition at line 2633 of file problem.\+h.



References doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_a71ba0a8ba4cbcb66077324217482ee11}\label{classoomph_1_1Problem_a71ba0a8ba4cbcb66077324217482ee11}} 
\index{oomph::Problem@{oomph::Problem}!doubly\_adaptive\_unsteady\_newton\_solve\_helper@{doubly\_adaptive\_unsteady\_newton\_solve\_helper}}
\index{doubly\_adaptive\_unsteady\_newton\_solve\_helper@{doubly\_adaptive\_unsteady\_newton\_solve\_helper}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{doubly\_adaptive\_unsteady\_newton\_solve\_helper()}{doubly\_adaptive\_unsteady\_newton\_solve\_helper()}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve\+\_\+helper (\begin{DoxyParamCaption}\item[{const double \&}]{dt,  }\item[{const double \&}]{epsilon,  }\item[{const unsigned \&}]{max\+\_\+adapt,  }\item[{const unsigned \&}]{suppress\+\_\+resolve\+\_\+after\+\_\+spatial\+\_\+adapt,  }\item[{const bool \&}]{first,  }\item[{const bool \&}]{shift = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Private helper function that actually performs the unsteady \char`\"{}doubly\char`\"{} adaptive Newton solve. See actual (non-\/helper) functions for description of parameters. 

Private helper function to perform unsteady \char`\"{}doubly\char`\"{} adaptive Newton solve\+: Does temporal adaptation first, i.\+e. we try to do a timestep with an increment of dt, and adjusting dt until the solution on the given mesh satisfies the temporal error measure with tolerance epsilon. Following this, we do up to max\+\_\+adapt spatial adaptions (without re-\/examining the temporal error). If first==true, the initial conditions are re-\/assigned after the mesh adaptations. Shifting of time can be suppressed by overwriting the default value of shift (true). \mbox{[}Shifting must be done if first\+\_\+timestep==true because we\textquotesingle{}re constantly re-\/assigning the initial conditions; if first\+\_\+timestep==true and shift==false shifting is performed anyway and a warning is issued. Pseudo-\/\+Boolean flag suppress\+\_\+resolve\+\_\+after\+\_\+spatial\+\_\+adapt \mbox{[}0\+: false; 1\+: true\mbox{]} does what it says.\mbox{]}. 

Definition at line 11572 of file problem.\+cc.



References adapt(), adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), communicator\+\_\+pt(), Default\+\_\+set\+\_\+initial\+\_\+condition\+\_\+called, oomph\+::\+Time\+::dt(), oomph\+::oomph\+\_\+info, Problem\+\_\+has\+\_\+been\+\_\+distributed, set\+\_\+initial\+\_\+condition(), oomph\+::\+Time\+::time(), time\+\_\+pt(), and unsteady\+\_\+newton\+\_\+solve().



Referenced by doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_af94771cdd9de79c17c9cf168f4a67a92}\label{classoomph_1_1Problem_af94771cdd9de79c17c9cf168f4a67a92}} 
\index{oomph::Problem@{oomph::Problem}!dump@{dump}}
\index{dump@{dump}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{dump()}{dump()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::dump (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{dump\+\_\+file\+\_\+name }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Dump refinement pattern of all refineable meshes and all generic \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} data to file for restart. 



Definition at line 2207 of file problem.\+h.



References dump(), and oomph\+::\+Global\+\_\+string\+\_\+for\+\_\+annotation\+::string().

\mbox{\Hypertarget{classoomph_1_1Problem_a804050357ac754151b86c2aec4dabc2d}\label{classoomph_1_1Problem_a804050357ac754151b86c2aec4dabc2d}} 
\index{oomph::Problem@{oomph::Problem}!dump@{dump}}
\index{dump@{dump}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{dump()}{dump()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::dump (\begin{DoxyParamCaption}\item[{std\+::ofstream \&}]{dump\+\_\+file }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}



Dump refinement pattern of all refineable meshes and all generic \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} data to file for restart. 



Definition at line 12222 of file problem.\+cc.



References Base\+\_\+mesh\+\_\+element\+\_\+pt, communicator\+\_\+pt(), oomph\+::\+Time\+::dt(), oomph\+::\+Mesh\+::dump(), oomph\+::\+Triangle\+Mesh\+Base\+::dump\+\_\+distributed\+\_\+info\+\_\+for\+\_\+restart(), oomph\+::\+Triangle\+Mesh\+Base\+::dump\+\_\+triangulateio(), e, Global\+\_\+data\+\_\+pt, i, oomph\+::\+Generalised\+Element\+::is\+\_\+halo(), oomph\+::\+Mesh\+::is\+\_\+mesh\+\_\+distributed(), mesh\+\_\+pt(), oomph\+::\+Time\+::ndt(), nsub\+\_\+mesh(), Problem\+\_\+has\+\_\+been\+\_\+distributed, oomph\+::\+Time\+::time(), time\+\_\+pt(), and oomph\+::\+Triangle\+Mesh\+Base\+::use\+\_\+triangulateio\+\_\+restart().



Referenced by dump().

\mbox{\Hypertarget{classoomph_1_1Problem_a00efa0059958df35858503e77111c362}\label{classoomph_1_1Problem_a00efa0059958df35858503e77111c362}} 
\index{oomph::Problem@{oomph::Problem}!eigen\_solver\_pt@{eigen\_solver\_pt}}
\index{eigen\_solver\_pt@{eigen\_solver\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{eigen\_solver\_pt()}{eigen\_solver\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1EigenSolver}{Eigen\+Solver}}$\ast$\& oomph\+::\+Problem\+::eigen\+\_\+solver\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the eigen solver object. 



Definition at line 1492 of file problem.\+h.



References Eigen\+\_\+solver\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1Problem_a14d44adcbf581d43154be19d127b6183}\label{classoomph_1_1Problem_a14d44adcbf581d43154be19d127b6183}} 
\index{oomph::Problem@{oomph::Problem}!eigen\_solver\_pt@{eigen\_solver\_pt}}
\index{eigen\_solver\_pt@{eigen\_solver\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{eigen\_solver\_pt()}{eigen\_solver\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1EigenSolver}{Eigen\+Solver}}$\ast$ const\& oomph\+::\+Problem\+::eigen\+\_\+solver\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the eigen solver object (const version) 



Definition at line 1498 of file problem.\+h.



References Eigen\+\_\+solver\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1Problem_aa8da092e78c9af112580ddb667a15d97}\label{classoomph_1_1Problem_aa8da092e78c9af112580ddb667a15d97}} 
\index{oomph::Problem@{oomph::Problem}!elemental\_assembly\_time@{elemental\_assembly\_time}}
\index{elemental\_assembly\_time@{elemental\_assembly\_time}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{elemental\_assembly\_time()}{elemental\_assembly\_time()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$double$>$ oomph\+::\+Problem\+::elemental\+\_\+assembly\+\_\+time (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return vector of most-\/recent elemental assembly times (used for load balancing). Zero sized if no Jacobian has been computed since last re-\/assignment of equation numbers. 



Definition at line 864 of file problem.\+h.



References Elemental\+\_\+assembly\+\_\+time.



Referenced by oomph\+::\+METIS\+::partition\+\_\+distributed\+\_\+mesh().

\mbox{\Hypertarget{classoomph_1_1Problem_af4fbd755b3ce6b86fa0f1b1f29bd08f0}\label{classoomph_1_1Problem_af4fbd755b3ce6b86fa0f1b1f29bd08f0}} 
\index{oomph::Problem@{oomph::Problem}!enable\_discontinuous\_formulation@{enable\_discontinuous\_formulation}}
\index{enable\_discontinuous\_formulation@{enable\_discontinuous\_formulation}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{enable\_discontinuous\_formulation()}{enable\_discontinuous\_formulation()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::enable\+\_\+discontinuous\+\_\+formulation (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Indicate that the problem involves discontinuous elements This allows for a more efficiently assembly and inversion of the mass matrix. 



Definition at line 1731 of file problem.\+h.



References Discontinuous\+\_\+element\+\_\+formulation.

\mbox{\Hypertarget{classoomph_1_1Problem_a577bca9cc5ee9504480b372f82e924dd}\label{classoomph_1_1Problem_a577bca9cc5ee9504480b372f82e924dd}} 
\index{oomph::Problem@{oomph::Problem}!enable\_doc\_imbalance\_in\_parallel\_assembly@{enable\_doc\_imbalance\_in\_parallel\_assembly}}
\index{enable\_doc\_imbalance\_in\_parallel\_assembly@{enable\_doc\_imbalance\_in\_parallel\_assembly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{enable\_doc\_imbalance\_in\_parallel\_assembly()}{enable\_doc\_imbalance\_in\_parallel\_assembly()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::enable\+\_\+doc\+\_\+imbalance\+\_\+in\+\_\+parallel\+\_\+assembly (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Enable doc of load imbalance in parallel assembly of distributed problem. 



Definition at line 849 of file problem.\+h.



References Doc\+\_\+imbalance\+\_\+in\+\_\+parallel\+\_\+assembly.

\mbox{\Hypertarget{classoomph_1_1Problem_ac7c7711978f7c02becb4005414f945be}\label{classoomph_1_1Problem_ac7c7711978f7c02becb4005414f945be}} 
\index{oomph::Problem@{oomph::Problem}!enable\_globally\_convergent\_newton\_method@{enable\_globally\_convergent\_newton\_method}}
\index{enable\_globally\_convergent\_newton\_method@{enable\_globally\_convergent\_newton\_method}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{enable\_globally\_convergent\_newton\_method()}{enable\_globally\_convergent\_newton\_method()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::enable\+\_\+globally\+\_\+convergent\+\_\+newton\+\_\+method (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



enable globally convergent Newton method 



Definition at line 2132 of file problem.\+h.



References Use\+\_\+globally\+\_\+convergent\+\_\+newton\+\_\+method.

\mbox{\Hypertarget{classoomph_1_1Problem_a3226bf49118c8a4f02dbe01d22428f20}\label{classoomph_1_1Problem_a3226bf49118c8a4f02dbe01d22428f20}} 
\index{oomph::Problem@{oomph::Problem}!enable\_info\_in\_newton\_solve@{enable\_info\_in\_newton\_solve}}
\index{enable\_info\_in\_newton\_solve@{enable\_info\_in\_newton\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{enable\_info\_in\_newton\_solve()}{enable\_info\_in\_newton\_solve()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::enable\+\_\+info\+\_\+in\+\_\+newton\+\_\+solve (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Enable the output of information when in the newton solver (Default) 



Definition at line 3064 of file problem.\+h.



References Shut\+\_\+up\+\_\+in\+\_\+newton\+\_\+solve.

\mbox{\Hypertarget{classoomph_1_1Problem_a8eb2fedc3f64411cfbe1627a516447f9}\label{classoomph_1_1Problem_a8eb2fedc3f64411cfbe1627a516447f9}} 
\index{oomph::Problem@{oomph::Problem}!enable\_jacobian\_reuse@{enable\_jacobian\_reuse}}
\index{enable\_jacobian\_reuse@{enable\_jacobian\_reuse}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{enable\_jacobian\_reuse()}{enable\_jacobian\_reuse()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::enable\+\_\+jacobian\+\_\+reuse (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Enable recycling of Jacobian in Newton iteration (if the linear solver allows it). Useful for linear problems with constant Jacobians or nonlinear problems where you\textquotesingle{}re willing to risk the trade-\/off between faster solve times and degraded Newton convergence rate. 



Definition at line 2104 of file problem.\+h.



References Jacobian\+\_\+has\+\_\+been\+\_\+computed, and Jacobian\+\_\+reuse\+\_\+is\+\_\+enabled.

\mbox{\Hypertarget{classoomph_1_1Problem_a6a9e63d6e585eabe4e3e551f01f658ae}\label{classoomph_1_1Problem_a6a9e63d6e585eabe4e3e551f01f658ae}} 
\index{oomph::Problem@{oomph::Problem}!enable\_mass\_matrix\_reuse@{enable\_mass\_matrix\_reuse}}
\index{enable\_mass\_matrix\_reuse@{enable\_mass\_matrix\_reuse}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{enable\_mass\_matrix\_reuse()}{enable\_mass\_matrix\_reuse()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::enable\+\_\+mass\+\_\+matrix\+\_\+reuse (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Enable recycling of the mass matrix in explicit timestepping schemes. Useful for timestepping on fixed meshes when you want to avoid the linear solve phase. 



Definition at line 12000 of file problem.\+cc.



References Discontinuous\+\_\+element\+\_\+formulation, e, oomph\+::\+Mesh\+::element\+\_\+pt(), oomph\+::\+DGElement\+::enable\+\_\+mass\+\_\+matrix\+\_\+reuse(), Mass\+\_\+matrix\+\_\+has\+\_\+been\+\_\+computed, Mass\+\_\+matrix\+\_\+reuse\+\_\+is\+\_\+enabled, mesh\+\_\+pt(), and oomph\+::\+Mesh\+::nelement().

\mbox{\Hypertarget{classoomph_1_1Problem_a3fe4edae6a97460405e7f667d7d4f406}\label{classoomph_1_1Problem_a3fe4edae6a97460405e7f667d7d4f406}} 
\index{oomph::Problem@{oomph::Problem}!enable\_problem\_distributed@{enable\_problem\_distributed}}
\index{enable\_problem\_distributed@{enable\_problem\_distributed}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{enable\_problem\_distributed()}{enable\_problem\_distributed()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::enable\+\_\+problem\+\_\+distributed (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Enable problem distributed. 



Definition at line 971 of file problem.\+h.



References Problem\+\_\+has\+\_\+been\+\_\+distributed.



Referenced by oomph\+::\+Refineable\+Triangle\+Mesh$<$ ELEMENT $>$\+::adapt().

\mbox{\Hypertarget{classoomph_1_1Problem_a31ba79405993ec52e3017d6ff3a42c8c}\label{classoomph_1_1Problem_a31ba79405993ec52e3017d6ff3a42c8c}} 
\index{oomph::Problem@{oomph::Problem}!enable\_store\_local\_dof\_pt\_in\_elements@{enable\_store\_local\_dof\_pt\_in\_elements}}
\index{enable\_store\_local\_dof\_pt\_in\_elements@{enable\_store\_local\_dof\_pt\_in\_elements}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{enable\_store\_local\_dof\_pt\_in\_elements()}{enable\_store\_local\_dof\_pt\_in\_elements()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::enable\+\_\+store\+\_\+local\+\_\+dof\+\_\+pt\+\_\+in\+\_\+elements (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Insist that local dof pointers are set up in each element when equation numbering takes place. 



Definition at line 1700 of file problem.\+h.



References Store\+\_\+local\+\_\+dof\+\_\+pt\+\_\+in\+\_\+elements.

\mbox{\Hypertarget{classoomph_1_1Problem_ac332634783a803c1c21bf5c520af280f}\label{classoomph_1_1Problem_ac332634783a803c1c21bf5c520af280f}} 
\index{oomph::Problem@{oomph::Problem}!explicit\_time\_stepper\_pt@{explicit\_time\_stepper\_pt}}
\index{explicit\_time\_stepper\_pt@{explicit\_time\_stepper\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{explicit\_time\_stepper\_pt()}{explicit\_time\_stepper\_pt()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1ExplicitTimeStepper}{Explicit\+Time\+Stepper}}$\ast$\& oomph\+::\+Problem\+::explicit\+\_\+time\+\_\+stepper\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the explicit timestepper. 



Definition at line 1555 of file problem.\+h.



References Explicit\+\_\+time\+\_\+stepper\+\_\+pt.



Referenced by calculate\+\_\+predictions(), explicit\+\_\+timestep(), and set\+\_\+explicit\+\_\+time\+\_\+stepper\+\_\+pt().

\mbox{\Hypertarget{classoomph_1_1Problem_ab8b74c5b1499b2d712a8545cccbd97c2}\label{classoomph_1_1Problem_ab8b74c5b1499b2d712a8545cccbd97c2}} 
\index{oomph::Problem@{oomph::Problem}!explicit\_timestep@{explicit\_timestep}}
\index{explicit\_timestep@{explicit\_timestep}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{explicit\_timestep()}{explicit\_timestep()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::explicit\+\_\+timestep (\begin{DoxyParamCaption}\item[{const double \&}]{dt,  }\item[{const bool \&}]{shift\+\_\+values = {\ttfamily true} }\end{DoxyParamCaption})}



Take an explicit timestep of size dt and optionally shift any stored values of the time history. 

Take an explicit timestep of size dt. 

Definition at line 11111 of file problem.\+cc.



References oomph\+::\+Time\+::dt(), explicit\+\_\+time\+\_\+stepper\+\_\+pt(), shift\+\_\+time\+\_\+values(), time\+\_\+pt(), and oomph\+::\+Explicit\+Time\+Stepper\+::timestep().



Referenced by calculate\+\_\+predictions().

\mbox{\Hypertarget{classoomph_1_1Problem_aa8df5552c706bd949b29f5601f8c941e}\label{classoomph_1_1Problem_aa8df5552c706bd949b29f5601f8c941e}} 
\index{oomph::Problem@{oomph::Problem}!flush\_global\_data@{flush\_global\_data}}
\index{flush\_global\_data@{flush\_global\_data}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{flush\_global\_data()}{flush\_global\_data()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::flush\+\_\+global\+\_\+data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Flush the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s global data -- resizes container to zero. \mbox{\hyperlink{classoomph_1_1Data}{Data}} objects are not deleted! 



Definition at line 1662 of file problem.\+h.



References Global\+\_\+data\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1Problem_a42b2b42a03f9de7d7a4d24edcfa20179}\label{classoomph_1_1Problem_a42b2b42a03f9de7d7a4d24edcfa20179}} 
\index{oomph::Problem@{oomph::Problem}!flush\_sub\_meshes@{flush\_sub\_meshes}}
\index{flush\_sub\_meshes@{flush\_sub\_meshes}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{flush\_sub\_meshes()}{flush\_sub\_meshes()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::flush\+\_\+sub\+\_\+meshes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Flush the problem\textquotesingle{}s collection of sub-\/meshes. Must be followed by call to \mbox{\hyperlink{classoomph_1_1Problem_ac0a0e649f36b4a7ce992888c323d1571}{rebuild\+\_\+global\+\_\+mesh()}}. 



Definition at line 1339 of file problem.\+h.



References Sub\+\_\+mesh\+\_\+pt.



Referenced by oomph\+::\+Navier\+Stokes\+Schur\+Complement\+Preconditioner\+::get\+\_\+pressure\+\_\+advection\+\_\+diffusion\+\_\+matrix(), load\+\_\+balance(), oomph\+::\+Segregatable\+FSIProblem\+::rebuild\+\_\+monolithic\+\_\+mesh(), oomph\+::\+Segregatable\+FSIProblem\+::use\+\_\+only\+\_\+fluid\+\_\+elements(), and oomph\+::\+Segregatable\+FSIProblem\+::use\+\_\+only\+\_\+solid\+\_\+elements().

\mbox{\Hypertarget{classoomph_1_1Problem_af0d29f621a3be66430960538c7c24a78}\label{classoomph_1_1Problem_af0d29f621a3be66430960538c7c24a78}} 
\index{oomph::Problem@{oomph::Problem}!get\_all\_error\_estimates@{get\_all\_error\_estimates}}
\index{get\_all\_error\_estimates@{get\_all\_error\_estimates}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_all\_error\_estimates()}{get\_all\_error\_estimates()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+all\+\_\+error\+\_\+estimates (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$$>$ \&}]{elemental\+\_\+error }\end{DoxyParamCaption})}



Return the error estimates computed by (all) refineable (sub)mesh(es) in the elemental\+\_\+error structure, which consists of a vector of vectors of elemental errors, one vector for each (sub)mesh. 

Return the error estimates computed by (all) refineable (sub)mesh(es) in the elemental\+\_\+error structure, which consists of a vector of elemental errors for each (sub)mesh. 

Definition at line 14820 of file problem.\+cc.



References oomph\+::\+Error\+Estimator\+::get\+\_\+element\+\_\+errors(), mesh\+\_\+pt(), nsub\+\_\+mesh(), and oomph\+::oomph\+\_\+info.



Referenced by adapt(), and bifurcation\+\_\+adapt\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_ad5c302721bf6699ecf8c8760e49d47d8}\label{classoomph_1_1Problem_ad5c302721bf6699ecf8c8760e49d47d8}} 
\index{oomph::Problem@{oomph::Problem}!get\_all\_halo\_data@{get\_all\_halo\_data}}
\index{get\_all\_halo\_data@{get\_all\_halo\_data}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_all\_halo\_data()}{get\_all\_halo\_data()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+all\+\_\+halo\+\_\+data (\begin{DoxyParamCaption}\item[{std\+::map$<$ unsigned, double $\ast$ $>$ \&}]{map\+\_\+of\+\_\+halo\+\_\+data }\end{DoxyParamCaption})}



Get pointers to all possible halo data indexed by global equation number in a map. 

Get all the halo data stored on this processor and store pointers to the data in a map, indexed by the gobal eqn number. 

Definition at line 16570 of file problem.\+cc.



References oomph\+::\+Mesh\+::get\+\_\+all\+\_\+halo\+\_\+data(), mesh\+\_\+pt(), and nsub\+\_\+mesh().



Referenced by setup\+\_\+dof\+\_\+halo\+\_\+scheme().

\mbox{\Hypertarget{classoomph_1_1Problem_a85b240c17750bdc32afafee35b50225a}\label{classoomph_1_1Problem_a85b240c17750bdc32afafee35b50225a}} 
\index{oomph::Problem@{oomph::Problem}!get\_bifurcation\_eigenfunction@{get\_bifurcation\_eigenfunction}}
\index{get\_bifurcation\_eigenfunction@{get\_bifurcation\_eigenfunction}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_bifurcation\_eigenfunction()}{get\_bifurcation\_eigenfunction()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+bifurcation\+\_\+eigenfunction (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&}]{eigenfunction }\end{DoxyParamCaption})}



Return the eigenfunction calculated as part of a bifurcation tracking process. If we are not tracking a bifurcation then an error will be thrown by the \mbox{\hyperlink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}}. 



Definition at line 10284 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, and oomph\+::\+Assembly\+Handler\+::get\+\_\+eigenfunction().



Referenced by bifurcation\+\_\+adapt\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_ad150d0fa8f2e2ccff79f8ecd78cc1343}\label{classoomph_1_1Problem_ad150d0fa8f2e2ccff79f8ecd78cc1343}} 
\index{oomph::Problem@{oomph::Problem}!get\_data\_to\_be\_sent\_during\_load\_balancing@{get\_data\_to\_be\_sent\_during\_load\_balancing}}
\index{get\_data\_to\_be\_sent\_during\_load\_balancing@{get\_data\_to\_be\_sent\_during\_load\_balancing}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_data\_to\_be\_sent\_during\_load\_balancing()}{get\_data\_to\_be\_sent\_during\_load\_balancing()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+data\+\_\+to\+\_\+be\+\_\+sent\+\_\+during\+\_\+load\+\_\+balancing (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{target\+\_\+domain\+\_\+for\+\_\+local\+\_\+non\+\_\+halo\+\_\+element,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $>$ \&}]{send\+\_\+n,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&}]{send\+\_\+data,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $>$ \&}]{send\+\_\+displacement,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{old\+\_\+domain\+\_\+for\+\_\+base\+\_\+element,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{new\+\_\+domain\+\_\+for\+\_\+base\+\_\+element,  }\item[{unsigned \&}]{max\+\_\+refinement\+\_\+level\+\_\+overall }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Load balance helper routine\+: Get data to be sent to other processors during load balancing and other information about re-\/distribution. 


\begin{DoxyItemize}
\item target\+\_\+domain\+\_\+for\+\_\+local\+\_\+non\+\_\+halo\+\_\+element\+: Input, generated by \mbox{\hyperlink{namespaceoomph_1_1METIS}{METIS}}. target\+\_\+domain\+\_\+for\+\_\+local\+\_\+non\+\_\+halo\+\_\+element\mbox{[}e\mbox{]} contains the number of the domain \mbox{[}0,1,...,nproc-\/1\mbox{]} to which non-\/halo element e on THE CURRENT PROCESSOR ONLY has been assigned. The order of the non-\/halo elements is the same as in the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s mesh, with the halo elements being skipped.
\item send\+\_\+n\+: Output, number of data to be sent to each processor
\item send\+\_\+data\+: Output, storage for all values to be sent to all processors
\item send\+\_\+displacement\+: Output, start location within send\+\_\+data for data to be sent to each processor
\item max\+\_\+refinement\+\_\+level\+\_\+overall\+: Output, max. refinement level of any element 
\end{DoxyItemize}Where do I come from, where do I go to?

Where do I come from, where do I go to?

Definition at line 19472 of file problem.\+cc.



References oomph\+::\+Generalised\+Element\+::add\+\_\+internal\+\_\+data\+\_\+values\+\_\+to\+\_\+vector(), oomph\+::\+Node\+::add\+\_\+values\+\_\+to\+\_\+vector(), Base\+\_\+mesh\+\_\+element\+\_\+number\+\_\+plus\+\_\+one, Base\+\_\+mesh\+\_\+element\+\_\+pt, communicator\+\_\+pt(), e, oomph\+::\+Mesh\+::element\+\_\+pt(), i, oomph\+::\+Boundary\+Node\+Base\+::index\+\_\+of\+\_\+first\+\_\+value\+\_\+assigned\+\_\+by\+\_\+face\+\_\+element\+\_\+pt(), oomph\+::\+Generalised\+Element\+::is\+\_\+halo(), mesh\+\_\+pt(), oomph\+::\+Node\+::ndim(), oomph\+::\+Mesh\+::nelement(), oomph\+::\+Finite\+Element\+::nnode(), oomph\+::\+Finite\+Element\+::node\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::\+Data\+::ntstorage(), oomph\+::\+Data\+::nvalue(), oomph\+::\+Node\+::position(), oomph\+::\+Refineable\+Element\+::root\+\_\+element\+\_\+pt(), oomph\+::\+Data\+::set\+\_\+value(), oomph\+::\+Tree\+::stick\+\_\+leaves\+\_\+into\+\_\+vector(), t, oomph\+::\+Refineable\+Element\+::tree\+\_\+pt(), oomph\+::\+Node\+::value(), and oomph\+::\+Node\+::x().



Referenced by load\+\_\+balance().

\mbox{\Hypertarget{classoomph_1_1Problem_af4d959a47ef6a8d50b394a6761dfab5a}\label{classoomph_1_1Problem_af4d959a47ef6a8d50b394a6761dfab5a}} 
\index{oomph::Problem@{oomph::Problem}!get\_derivative\_wrt\_global\_parameter@{get\_derivative\_wrt\_global\_parameter}}
\index{get\_derivative\_wrt\_global\_parameter@{get\_derivative\_wrt\_global\_parameter}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_derivative\_wrt\_global\_parameter()}{get\_derivative\_wrt\_global\_parameter()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+derivative\+\_\+wrt\+\_\+global\+\_\+parameter (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt,  }\item[{\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{result }\end{DoxyParamCaption})}



Get the derivative of the entire residuals vector wrt a global parameter, used in continuation problems. 

Get derivative of the residuals vector wrt a global parameter This is required in continuation problems. 

Definition at line 7864 of file problem.\+cc.



References actions\+\_\+after\+\_\+change\+\_\+in\+\_\+global\+\_\+parameter(), Assembly\+\_\+handler\+\_\+pt, oomph\+::\+Black\+Box\+FDNewton\+Solver\+::\+FD\+\_\+step, get\+\_\+residuals(), is\+\_\+dparameter\+\_\+calculated\+\_\+analytically(), and oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::nrow\+\_\+local().



Referenced by calculate\+\_\+continuation\+\_\+derivatives(), oomph\+::\+Fold\+Handler\+::\+Fold\+Handler(), oomph\+::\+Hopf\+Handler\+::\+Hopf\+Handler(), newton\+\_\+solve\+\_\+continuation(), and oomph\+::\+Block\+Pitch\+Fork\+Linear\+Solver\+::solve().

\mbox{\Hypertarget{classoomph_1_1Problem_abb56c404b0dd6df75bcadab797d9a24e}\label{classoomph_1_1Problem_abb56c404b0dd6df75bcadab797d9a24e}} 
\index{oomph::Problem@{oomph::Problem}!get\_dofs@{get\_dofs}}
\index{get\_dofs@{get\_dofs}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_dofs()}{get\_dofs()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+dofs (\begin{DoxyParamCaption}\item[{const unsigned \&}]{t,  }\item[{\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{dofs }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}



Return vector of the t\textquotesingle{}th history value of all dofs. 

Get history values of dofs in a double vector. 

Reimplemented from \mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject_a370d8d077bb5e07290f4c2f31183d8d2}{oomph\+::\+Explicit\+Time\+Steppable\+Object}}.



Definition at line 2581 of file problem.\+cc.



References oomph\+::\+Double\+Vector\+::build(), distributed(), Dof\+\_\+distribution\+\_\+pt, oomph\+::\+Mesh\+::element\+\_\+pt(), oomph\+::\+Data\+::eqn\+\_\+number(), Global\+\_\+data\+\_\+pt, i, oomph\+::\+Generalised\+Element\+::internal\+\_\+data\+\_\+pt(), mesh\+\_\+pt(), nglobal\+\_\+data(), oomph\+::\+Generalised\+Element\+::ninternal\+\_\+data(), oomph\+::\+Mesh\+::node\+\_\+pt(), oomph\+::\+Data\+::nvalue(), t, oomph\+::\+Data\+::value(), and oomph\+::\+Node\+::value().

\mbox{\Hypertarget{classoomph_1_1Problem_ae2ef66732d76053dba15001818c0605c}\label{classoomph_1_1Problem_ae2ef66732d76053dba15001818c0605c}} 
\index{oomph::Problem@{oomph::Problem}!get\_dofs@{get\_dofs}}
\index{get\_dofs@{get\_dofs}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_dofs()}{get\_dofs()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+dofs (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{dofs }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}



Return the vector of dofs, i.\+e. a vector containing the current values of all unknowns. 

Get the vector of dofs, i.\+e. a vector containing the current values of all unknowns. 

Reimplemented from \mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject_a0fcf43487590dd723f25184067f26219}{oomph\+::\+Explicit\+Time\+Steppable\+Object}}.



Definition at line 2565 of file problem.\+cc.



References oomph\+::\+Double\+Vector\+::build(), Dof\+\_\+distribution\+\_\+pt, Dof\+\_\+pt, and ndof().



Referenced by oomph\+::\+IMRBy\+BDF\+::actions\+\_\+after\+\_\+timestep(), oomph\+::\+IMRBy\+BDF\+::actions\+\_\+before\+\_\+timestep(), and calculate\+\_\+predictions().

\mbox{\Hypertarget{classoomph_1_1Problem_a2d456362f4408556e879871ae34e57f1}\label{classoomph_1_1Problem_a2d456362f4408556e879871ae34e57f1}} 
\index{oomph::Problem@{oomph::Problem}!get\_dvaluesdt@{get\_dvaluesdt}}
\index{get\_dvaluesdt@{get\_dvaluesdt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_dvaluesdt()}{get\_dvaluesdt()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+dvaluesdt (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{f }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Get the time derivative of all values (using get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals(..) with all time steppers set to steady) e.\+g. for use in explicit time steps. The approach used is slighty hacky, beware if you have a residual which is non-\/linear or implicit in the derivative or if you have overloaded get\+\_\+jacobian(...). 



Reimplemented from \mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject_ab1e7d8d7ec548b26ed039b61a9eba9c4}{oomph\+::\+Explicit\+Time\+Steppable\+Object}}.



Definition at line 3770 of file problem.\+cc.



References get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals(), i, oomph\+::\+Time\+Stepper\+::is\+\_\+steady(), oomph\+::\+Time\+Stepper\+::make\+\_\+steady(), ntime\+\_\+stepper(), time\+\_\+stepper\+\_\+pt(), and oomph\+::\+Time\+Stepper\+::undo\+\_\+make\+\_\+steady().



Referenced by oomph\+::\+TR\+::setup\+\_\+initial\+\_\+derivative().

\mbox{\Hypertarget{classoomph_1_1Problem_a17e2d84700ac43c1db1d68143790ae5c}\label{classoomph_1_1Problem_a17e2d84700ac43c1db1d68143790ae5c}} 
\index{oomph::Problem@{oomph::Problem}!get\_eigenproblem\_matrices@{get\_eigenproblem\_matrices}}
\index{get\_eigenproblem\_matrices@{get\_eigenproblem\_matrices}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_eigenproblem\_matrices()}{get\_eigenproblem\_matrices()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+eigenproblem\+\_\+matrices (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1CRDoubleMatrix}{CRDouble\+Matrix}} \&}]{mass\+\_\+matrix,  }\item[{\mbox{\hyperlink{classoomph_1_1CRDoubleMatrix}{CRDouble\+Matrix}} \&}]{main\+\_\+matrix,  }\item[{const double \&}]{shift = {\ttfamily 0.0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Get the matrices required by a eigensolver. If the shift parameter is non-\/zero the second matrix will be shifted. 

Get the matrices required to solve an eigenproblem WARNING\+: temporarily this method only works with non-\/distributed matrices. 

Definition at line 8602 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, oomph\+::\+CRDouble\+Matrix\+::build(), oomph\+::\+CRDouble\+Matrix\+::build\+\_\+without\+\_\+copy(), Communicator\+\_\+pt, create\+\_\+new\+\_\+linear\+\_\+algebra\+\_\+distribution(), oomph\+::\+Linear\+Algebra\+Distribution\+::distributed(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distribution\+\_\+built(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distribution\+\_\+pt(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow(), oomph\+::\+CRDouble\+Matrix\+::nrow(), parallel\+\_\+sparse\+\_\+assemble(), oomph\+::\+CRDouble\+Matrix\+::redistribute(), and sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed().



Referenced by oomph\+::\+Adjoint\+Problem\+Based\+Shift\+Invert\+Operator\+::\+Adjoint\+Problem\+Based\+Shift\+Invert\+Operator(), oomph\+::\+Problem\+Based\+Shift\+Invert\+Operator\+::\+Problem\+Based\+Shift\+Invert\+Operator(), oomph\+::\+LAPACK\+\_\+\+QZ\+::solve\+\_\+eigenproblem\+\_\+helper(), and oomph\+::\+ARPACK\+::solve\+\_\+eigenproblem\+\_\+legacy().

\mbox{\Hypertarget{classoomph_1_1Problem_a74f6540dc7228b21f5bc07c0477dfbe7}\label{classoomph_1_1Problem_a74f6540dc7228b21f5bc07c0477dfbe7}} 
\index{oomph::Problem@{oomph::Problem}!get\_fd\_jacobian@{get\_fd\_jacobian}}
\index{get\_fd\_jacobian@{get\_fd\_jacobian}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_fd\_jacobian()}{get\_fd\_jacobian()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+fd\+\_\+jacobian (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{residuals,  }\item[{\mbox{\hyperlink{classoomph_1_1DenseMatrix}{Dense\+Matrix}}$<$ double $>$ \&}]{jacobian }\end{DoxyParamCaption})}



Return the fully-\/assembled Jacobian and residuals, generated by finite differences. 

Get the full Jacobian by finite differencing. 

Definition at line 7800 of file problem.\+cc.



References actions\+\_\+after\+\_\+newton\+\_\+solve(), actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check(), actions\+\_\+before\+\_\+newton\+\_\+solve(), Dof\+\_\+pt, oomph\+::\+Black\+Box\+FDNewton\+Solver\+::\+FD\+\_\+step, get\+\_\+residuals(), ndof(), Problem\+\_\+has\+\_\+been\+\_\+distributed, and oomph\+::\+Dense\+Matrix$<$ T $>$\+::resize().



Referenced by oomph\+::\+FD\+\_\+\+LU\+::solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a22b3818d62b66e5cb52d72dcccc037fa}\label{classoomph_1_1Problem_a22b3818d62b66e5cb52d72dcccc037fa}} 
\index{oomph::Problem@{oomph::Problem}!get\_first\_and\_last\_element\_for\_assembly@{get\_first\_and\_last\_element\_for\_assembly}}
\index{get\_first\_and\_last\_element\_for\_assembly@{get\_first\_and\_last\_element\_for\_assembly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_first\_and\_last\_element\_for\_assembly()}{get\_first\_and\_last\_element\_for\_assembly()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{first\+\_\+el\+\_\+for\+\_\+assembly,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{last\+\_\+el\+\_\+for\+\_\+assembly }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get first and last elements for parallel assembly of non-\/distributed problem. 



Definition at line 1004 of file problem.\+h.



References First\+\_\+el\+\_\+for\+\_\+assembly, i, and Last\+\_\+el\+\_\+plus\+\_\+one\+\_\+for\+\_\+assembly.



Referenced by oomph\+::\+Navier\+Stokes\+Schur\+Complement\+Preconditioner\+::get\+\_\+pressure\+\_\+advection\+\_\+diffusion\+\_\+matrix().

\mbox{\Hypertarget{classoomph_1_1Problem_a94646da2c0dac6e7477c445fd41e5a90}\label{classoomph_1_1Problem_a94646da2c0dac6e7477c445fd41e5a90}} 
\index{oomph::Problem@{oomph::Problem}!get\_flat\_packed\_refinement\_pattern\_for\_load\_balancing@{get\_flat\_packed\_refinement\_pattern\_for\_load\_balancing}}
\index{get\_flat\_packed\_refinement\_pattern\_for\_load\_balancing@{get\_flat\_packed\_refinement\_pattern\_for\_load\_balancing}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_flat\_packed\_refinement\_pattern\_for\_load\_balancing()}{get\_flat\_packed\_refinement\_pattern\_for\_load\_balancing()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+flat\+\_\+packed\+\_\+refinement\+\_\+pattern\+\_\+for\+\_\+load\+\_\+balancing (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{old\+\_\+domain\+\_\+for\+\_\+base\+\_\+element,  }\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{new\+\_\+domain\+\_\+for\+\_\+base\+\_\+element,  }\item[{const unsigned \&}]{max\+\_\+refinement\+\_\+level\+\_\+overall,  }\item[{std\+::map$<$ unsigned, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$$>$ \&}]{flat\+\_\+packed\+\_\+refinement\+\_\+info\+\_\+for\+\_\+root }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Get flat-\/packed refinement pattern for each root element in current mesh (labeled by unique number of root element in unrefined base mesh). The vector stored for each root element contains the following information\+: 


\begin{DoxyItemize}
\item First entry\+: Number of tree nodes (not just leaves!) in refinement tree emanating from this root \mbox{[}Zero if root element is not refineable\mbox{]}
\item Loop over all refinement levels
\begin{DoxyItemize}
\item Loop over all tree nodes (not just leaves!)
\begin{DoxyItemize}
\item If associated element exists when the mesh has been refined to this level (either because it has been refined to this level or because it\textquotesingle{}s less refined)\+: 1
\begin{DoxyItemize}
\item If the element is to be refined\+: 1; else\+: 0
\end{DoxyItemize}
\item else (element doesn\textquotesingle{}t exist when mesh is refined to this level (because it\textquotesingle{}s more refined)\+: 0
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}

Definition at line 20028 of file problem.\+cc.



References Base\+\_\+mesh\+\_\+element\+\_\+number\+\_\+plus\+\_\+one, e, oomph\+::\+Mesh\+::element\+\_\+pt(), oomph\+::\+Generalised\+Element\+::is\+\_\+halo(), mesh\+\_\+pt(), oomph\+::\+Mesh\+::nelement(), nsub\+\_\+mesh(), oomph\+::\+Refineable\+Element\+::root\+\_\+element\+\_\+pt(), oomph\+::\+Tree\+::stick\+\_\+all\+\_\+tree\+\_\+nodes\+\_\+into\+\_\+vector(), and oomph\+::\+Refineable\+Element\+::tree\+\_\+pt().



Referenced by load\+\_\+balance().

\mbox{\Hypertarget{classoomph_1_1Problem_ac65cbe00a72cfc91ccaea10818f1a507}\label{classoomph_1_1Problem_ac65cbe00a72cfc91ccaea10818f1a507}} 
\index{oomph::Problem@{oomph::Problem}!get\_hessian\_vector\_products@{get\_hessian\_vector\_products}}
\index{get\_hessian\_vector\_products@{get\_hessian\_vector\_products}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_hessian\_vector\_products()}{get\_hessian\_vector\_products()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+hessian\+\_\+vector\+\_\+products (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DoubleVectorWithHaloEntries}{Double\+Vector\+With\+Halo\+Entries}} const \&}]{Y,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVectorWithHaloEntries}{Double\+Vector\+With\+Halo\+Entries}} $>$ const \&}]{C,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVectorWithHaloEntries}{Double\+Vector\+With\+Halo\+Entries}} $>$ \&}]{product }\end{DoxyParamCaption})}



Return the product of the global hessian (derivative of Jacobian matrix with respect to all variables) with an eigenvector, Y, and any number of other specified vectors C (d(J\+\_\+\{ij\})/d u\+\_\+\{k\}) Y\+\_\+\{j\} C\+\_\+\{k\}. This function is used in assembling and solving the augmented systems associated with bifurcation tracking. The default implementation is to use finite differences at the global level. 

Alice\+: My bifurcation tracking converges better with this FD\+\_\+step as 1.\+0e-\/5. The default value remains at 1.\+0e-\/8.

Definition at line 7962 of file problem.\+cc.



References actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check(), are\+\_\+hessian\+\_\+products\+\_\+calculated\+\_\+analytically(), Assembly\+\_\+handler\+\_\+pt, assembly\+\_\+handler\+\_\+pt(), communicator\+\_\+pt(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distribution\+\_\+pt(), dof(), Dof\+\_\+distribution\+\_\+pt, e, oomph\+::\+Mesh\+::element\+\_\+pt(), oomph\+::\+Assembly\+Handler\+::eqn\+\_\+number(), oomph\+::\+Black\+Box\+FDNewton\+Solver\+::\+FD\+\_\+step, FD\+\_\+step\+\_\+used\+\_\+in\+\_\+get\+\_\+hessian\+\_\+vector\+\_\+products, oomph\+::\+Assembly\+Handler\+::get\+\_\+hessian\+\_\+vector\+\_\+products(), oomph\+::\+Assembly\+Handler\+::get\+\_\+jacobian(), global\+\_\+dof\+\_\+pt(), oomph\+::\+Double\+Vector\+With\+Halo\+Entries\+::global\+\_\+value(), Halo\+\_\+scheme\+\_\+pt, i, oomph\+::\+Vector$<$ \+\_\+\+Tp $>$\+::initialise(), oomph\+::\+Generalised\+Element\+::is\+\_\+halo(), Mesh\+\_\+pt, mesh\+\_\+pt(), oomph\+::\+Assembly\+Handler\+::ndof(), oomph\+::\+Mesh\+::nelement(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow\+\_\+local(), and Problem\+\_\+has\+\_\+been\+\_\+distributed.



Referenced by oomph\+::\+Block\+Pitch\+Fork\+Linear\+Solver\+::resolve(), and oomph\+::\+Block\+Pitch\+Fork\+Linear\+Solver\+::solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a8d7cc317f4900e076dec400ce2493c19}\label{classoomph_1_1Problem_a8d7cc317f4900e076dec400ce2493c19}} 
\index{oomph::Problem@{oomph::Problem}!get\_inverse\_mass\_matrix\_times\_residuals@{get\_inverse\_mass\_matrix\_times\_residuals}}
\index{get\_inverse\_mass\_matrix\_times\_residuals@{get\_inverse\_mass\_matrix\_times\_residuals}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_inverse\_mass\_matrix\_times\_residuals()}{get\_inverse\_mass\_matrix\_times\_residuals()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{Mres }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Return the residual vector multiplied by the inverse mass matrix Virtual so that it can be overloaded for mpi problems. 



Definition at line 3665 of file problem.\+cc.



References assembly\+\_\+handler\+\_\+pt(), oomph\+::\+Double\+Vector\+::build(), communicator\+\_\+pt(), Default\+\_\+assembly\+\_\+handler\+\_\+pt, Discontinuous\+\_\+element\+\_\+formulation, e, oomph\+::\+Mesh\+::element\+\_\+pt(), oomph\+::\+Linear\+Solver\+::enable\+\_\+resolve(), oomph\+::\+Generalised\+Element\+::eqn\+\_\+number(), oomph\+::\+DGElement\+::get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals(), get\+\_\+residuals(), i, Mass\+\_\+matrix\+\_\+has\+\_\+been\+\_\+computed, Mass\+\_\+matrix\+\_\+reuse\+\_\+is\+\_\+enabled, mass\+\_\+matrix\+\_\+solver\+\_\+for\+\_\+explicit\+\_\+timestepper\+\_\+pt(), mesh\+\_\+pt(), oomph\+::\+Generalised\+Element\+::ndof(), ndof(), oomph\+::\+Mesh\+::nelement(), oomph\+::oomph\+\_\+info, oomph\+::\+Linear\+Solver\+::resolve(), Shut\+\_\+up\+\_\+in\+\_\+newton\+\_\+solve, and oomph\+::\+Linear\+Solver\+::solve().



Referenced by get\+\_\+dvaluesdt().

\mbox{\Hypertarget{classoomph_1_1Problem_a9e6c6d71f95d96943a1a8487b6131e89}\label{classoomph_1_1Problem_a9e6c6d71f95d96943a1a8487b6131e89}} 
\index{oomph::Problem@{oomph::Problem}!get\_jacobian@{get\_jacobian}}
\index{get\_jacobian@{get\_jacobian}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_jacobian()}{get\_jacobian()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+jacobian (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{residuals,  }\item[{\mbox{\hyperlink{classoomph_1_1CCDoubleMatrix}{CCDouble\+Matrix}} \&}]{jacobian }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Return the fully-\/assembled Jacobian and residuals for the problem. Interface for the case when the Jacobian is in column-\/compressed storage format. This is virtual so, if we feel like it (e.\+g. for testing iterative solvers with specific test matrices), we can bypass the default assembly procedure for the Jacobian and the residual vector. 

Return the fully-\/assembled Jacobian and residuals for the problem, in the case when the jacobian matrix is in column-\/compressed storage format. 

Definition at line 4162 of file problem.\+cc.



References oomph\+::\+Double\+Vector\+::build(), oomph\+::\+CCMatrix$<$ T $>$\+::build\+\_\+without\+\_\+copy(), oomph\+::\+Double\+Vector\+::built(), communicator\+\_\+pt(), oomph\+::\+Linear\+Algebra\+Distribution\+::communicator\+\_\+pt(), Communicator\+\_\+pt, oomph\+::\+Linear\+Algebra\+Distribution\+::distributed(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distribution\+\_\+pt(), ndof(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow(), oomph\+::\+Double\+Vector\+::set\+\_\+external\+\_\+values(), and sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed().

\mbox{\Hypertarget{classoomph_1_1Problem_a1369827c6970abfd41deae4ef185822c}\label{classoomph_1_1Problem_a1369827c6970abfd41deae4ef185822c}} 
\index{oomph::Problem@{oomph::Problem}!get\_jacobian@{get\_jacobian}}
\index{get\_jacobian@{get\_jacobian}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_jacobian()}{get\_jacobian()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+jacobian (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{residuals,  }\item[{\mbox{\hyperlink{classoomph_1_1CRDoubleMatrix}{CRDouble\+Matrix}} \&}]{jacobian }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Return the fully-\/assembled Jacobian and residuals for the problem. Interface for the case when the Jacobian is in row-\/compressed storage format. This is virtual so, if we feel like it (e.\+g. for testing iterative solvers with specific test matrices), we can bypass the default assembly procedure for the Jacobian and the residual vector. 

Return the fully-\/assembled Jacobian and residuals for the problem, in the case where the Jacobian matrix is in a distributable row compressed storage format.


\begin{DoxyEnumerate}
\item If the distribution of the jacobian and residuals is setup then, they will be returned with that distribution. Note. the jacobian and residuals must have the same distribution.
\item If the distribution of the jacobian and residuals are not setup then their distribution will computed based on\+: Distributed\+\_\+problem\+\_\+matrix\+\_\+distribution. 
\end{DoxyEnumerate}

Definition at line 4028 of file problem.\+cc.



References oomph\+::\+Double\+Vector\+::build(), oomph\+::\+CRDouble\+Matrix\+::build(), oomph\+::\+CRDouble\+Matrix\+::build\+\_\+without\+\_\+copy(), oomph\+::\+Double\+Vector\+::built(), Communicator\+\_\+pt, create\+\_\+new\+\_\+linear\+\_\+algebra\+\_\+distribution(), oomph\+::\+Linear\+Algebra\+Distribution\+::distributed(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distribution\+\_\+built(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distribution\+\_\+pt(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow(), parallel\+\_\+sparse\+\_\+assemble(), oomph\+::\+Double\+Vector\+::redistribute(), oomph\+::\+CRDouble\+Matrix\+::redistribute(), oomph\+::\+Double\+Vector\+::set\+\_\+external\+\_\+values(), and sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed().

\mbox{\Hypertarget{classoomph_1_1Problem_a4ba83bbea19db3a530539f3e9f88a7e4}\label{classoomph_1_1Problem_a4ba83bbea19db3a530539f3e9f88a7e4}} 
\index{oomph::Problem@{oomph::Problem}!get\_jacobian@{get\_jacobian}}
\index{get\_jacobian@{get\_jacobian}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_jacobian()}{get\_jacobian()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+jacobian (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{residuals,  }\item[{\mbox{\hyperlink{classoomph_1_1DenseDoubleMatrix}{Dense\+Double\+Matrix}} \&}]{jacobian }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Return the fully-\/assembled Jacobian and residuals for the problem Interface for the case when the Jacobian matrix is dense. This is virtual so, if we feel like it (e.\+g. for testing iterative solvers with specific test matrices, we can bypass the default assembly procedure for the Jacobian and the residual vector. 

Get the fully assembled residual vector and Jacobian matrix in dense storage. The \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} residuals returned will be non-\/distributed. If on calling this method the \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} residuals is setup then it must be non-\/distributed and of the correct length. The matrix type \mbox{\hyperlink{classoomph_1_1DenseDoubleMatrix}{Dense\+Double\+Matrix}} is not distributable and therefore the residual vector is also assumed to be non distributable. 

Definition at line 3921 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, assembly\+\_\+handler\+\_\+pt(), oomph\+::\+Double\+Vector\+::build(), oomph\+::\+Double\+Vector\+::built(), oomph\+::\+Linear\+Algebra\+Distribution\+::communicator\+\_\+pt(), Communicator\+\_\+pt, oomph\+::\+Linear\+Algebra\+Distribution\+::distributed(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distribution\+\_\+pt(), e, oomph\+::\+Mesh\+::element\+\_\+pt(), oomph\+::\+Assembly\+Handler\+::eqn\+\_\+number(), oomph\+::\+Assembly\+Handler\+::get\+\_\+jacobian(), oomph\+::\+Double\+Vector\+::initialise(), oomph\+::\+Dense\+Matrix$<$ T $>$\+::initialise(), Mesh\+\_\+pt, ndof(), oomph\+::\+Assembly\+Handler\+::ndof(), oomph\+::\+Mesh\+::nelement(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow(), and oomph\+::\+Dense\+Matrix$<$ T $>$\+::resize().



Referenced by oomph\+::\+Fp\+Pressure\+Advection\+Diffusion\+Problem$<$ ELEMENT $>$\+::get\+\_\+pressure\+\_\+advection\+\_\+diffusion\+\_\+jacobian(), oomph\+::\+Navier\+Stokes\+Schur\+Complement\+Preconditioner\+::get\+\_\+pressure\+\_\+advection\+\_\+diffusion\+\_\+matrix(), oomph\+::\+CG$<$ MATRIX $>$\+::solve(), oomph\+::\+Bi\+CGStab$<$ MATRIX $>$\+::solve(), oomph\+::\+GS$<$ MATRIX $>$\+::solve(), oomph\+::\+GS$<$ CRDouble\+Matrix $>$\+::solve(), oomph\+::\+Damped\+Jacobi$<$ MATRIX $>$\+::solve(), oomph\+::\+GMRES$<$ MATRIX $>$\+::solve(), oomph\+::\+Augmented\+Problem\+GMRES\+::solve(), oomph\+::\+Dense\+LU\+::solve(), oomph\+::\+Super\+LUSolver\+::solve(), oomph\+::\+Mumps\+Solver\+::solve(), oomph\+::\+Helmholtz\+GMRESMG$<$ MATRIX $>$\+::solve(), oomph\+::\+Helmholtz\+FGMRESMG$<$ MATRIX $>$\+::solve(), oomph\+::\+Hypre\+Solver\+::solve(), oomph\+::\+Trilinos\+Aztec\+OOSolver\+::solve(), and oomph\+::\+Super\+LUSolver\+::solve\+\_\+transpose().

\mbox{\Hypertarget{classoomph_1_1Problem_a0db16f9bcac7af964d0fecc8b6a5ea63}\label{classoomph_1_1Problem_a0db16f9bcac7af964d0fecc8b6a5ea63}} 
\index{oomph::Problem@{oomph::Problem}!get\_jacobian@{get\_jacobian}}
\index{get\_jacobian@{get\_jacobian}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_jacobian()}{get\_jacobian()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::get\+\_\+jacobian (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{residuals,  }\item[{\mbox{\hyperlink{classoomph_1_1SumOfMatrices}{Sum\+Of\+Matrices}} \&}]{jacobian }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Dummy virtual function that must be overloaded by the problem to specify which matrices should be summed to give the final Jacobian. 



Definition at line 1883 of file problem.\+h.

\mbox{\Hypertarget{classoomph_1_1Problem_ae222ce1fa229441a733d350105dfd1f7}\label{classoomph_1_1Problem_ae222ce1fa229441a733d350105dfd1f7}} 
\index{oomph::Problem@{oomph::Problem}!get\_my\_eqns@{get\_my\_eqns}}
\index{get\_my\_eqns@{get\_my\_eqns}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_my\_eqns()}{get\_my\_eqns()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+my\+\_\+eqns (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}} $\ast$const \&}]{assembly\+\_\+handler\+\_\+pt,  }\item[{const unsigned \&}]{el\+\_\+lo,  }\item[{const unsigned \&}]{el\+\_\+hi,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{my\+\_\+eqns }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Helper method that returns the (unique) global equations to which the elements in the range el\+\_\+lo to el\+\_\+hi contribute on this processor using the given assembly\+\_\+handler. 

Helper method that returns the global equations to which the elements in the range el\+\_\+lo to el\+\_\+hi contribute on this processor. 

Definition at line 6486 of file problem.\+cc.



References assembly\+\_\+handler\+\_\+pt(), e, oomph\+::\+Mesh\+::element\+\_\+pt(), oomph\+::\+Assembly\+Handler\+::eqn\+\_\+number(), i, oomph\+::\+Generalised\+Element\+::is\+\_\+halo(), mesh\+\_\+pt(), and oomph\+::\+Assembly\+Handler\+::ndof().



Referenced by parallel\+\_\+sparse\+\_\+assemble(), and setup\+\_\+dof\+\_\+halo\+\_\+scheme().

\mbox{\Hypertarget{classoomph_1_1Problem_a7300386d91390e3e5be993aca7459498}\label{classoomph_1_1Problem_a7300386d91390e3e5be993aca7459498}} 
\index{oomph::Problem@{oomph::Problem}!get\_residuals@{get\_residuals}}
\index{get\_residuals@{get\_residuals}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{get\_residuals()}{get\_residuals()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::get\+\_\+residuals (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{residuals }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Return the fully-\/assembled residuals \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} for the problem\+: Virtual so it can be overloaded in for mpi problems. 

Get the total residuals \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} for the problem. 

Definition at line 3800 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, assembly\+\_\+handler\+\_\+pt(), oomph\+::\+Double\+Vector\+::build(), oomph\+::\+Double\+Vector\+::built(), communicator\+\_\+pt(), create\+\_\+new\+\_\+linear\+\_\+algebra\+\_\+distribution(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distribution\+\_\+pt(), e, oomph\+::\+Mesh\+::element\+\_\+pt(), oomph\+::\+Assembly\+Handler\+::eqn\+\_\+number(), oomph\+::\+Assembly\+Handler\+::get\+\_\+residuals(), Mesh\+\_\+pt, oomph\+::\+Assembly\+Handler\+::ndof(), oomph\+::\+Mesh\+::nelement(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow(), parallel\+\_\+sparse\+\_\+assemble(), and oomph\+::\+Double\+Vector\+::set\+\_\+external\+\_\+values().



Referenced by get\+\_\+derivative\+\_\+wrt\+\_\+global\+\_\+parameter(), get\+\_\+fd\+\_\+jacobian(), get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals(), globally\+\_\+convergent\+\_\+line\+\_\+search(), newton\+\_\+solve(), newton\+\_\+solve\+\_\+continuation(), oomph\+::\+Segregatable\+FSIProblem\+::segregated\+\_\+solve(), oomph\+::\+Solid\+ICProblem\+::set\+\_\+newmark\+\_\+initial\+\_\+condition\+\_\+consistently(), oomph\+::\+Block\+Hopf\+Linear\+Solver\+::solve(), and oomph\+::\+Block\+Hopf\+Linear\+Solver\+::solve\+\_\+for\+\_\+two\+\_\+rhs().

\mbox{\Hypertarget{classoomph_1_1Problem_ae508b2056d532cb8b6eb0dd5c16b9325}\label{classoomph_1_1Problem_ae508b2056d532cb8b6eb0dd5c16b9325}} 
\index{oomph::Problem@{oomph::Problem}!global\_data\_pt@{global\_data\_pt}}
\index{global\_data\_pt@{global\_data\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{global\_data\_pt()}{global\_data\_pt()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Data}{Data}}$\ast$\& oomph\+::\+Problem\+::global\+\_\+data\+\_\+pt (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the the i-\/th global data object. 



Definition at line 1647 of file problem.\+h.



References Global\+\_\+data\+\_\+pt, and i.



Referenced by oomph\+::\+IMRBy\+BDF\+::actions\+\_\+after\+\_\+timestep(), oomph\+::\+Periodic\+Orbit\+Assembly\+Handler$<$ NNODE\+\_\+1\+D $>$\+::adapt\+\_\+temporal\+\_\+mesh(), add\+\_\+global\+\_\+data(), and copy().

\mbox{\Hypertarget{classoomph_1_1Problem_a491354401f780ccc114ceb76f5cacef0}\label{classoomph_1_1Problem_a491354401f780ccc114ceb76f5cacef0}} 
\index{oomph::Problem@{oomph::Problem}!global\_dof\_pt@{global\_dof\_pt}}
\index{global\_dof\_pt@{global\_dof\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{global\_dof\_pt()}{global\_dof\_pt()}}
{\footnotesize\ttfamily double$\ast$ oomph\+::\+Problem\+::global\+\_\+dof\+\_\+pt (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the dof, indexed by global equation number which may be haloed or stored locally. If it is haloed, a local copy must have been requested on this processor in the Halo\+\_\+scheme\+\_\+pt. 



Definition at line 1768 of file problem.\+h.



References oomph\+::\+Double\+Vector\+Halo\+Scheme\+::distribution\+\_\+pt(), oomph\+::\+Linear\+Algebra\+Distribution\+::first\+\_\+row(), Halo\+\_\+dof\+\_\+pt, Halo\+\_\+scheme\+\_\+pt, i, oomph\+::\+Double\+Vector\+Halo\+Scheme\+::local\+\_\+index(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow\+\_\+local(), and Problem\+\_\+has\+\_\+been\+\_\+distributed.



Referenced by get\+\_\+hessian\+\_\+vector\+\_\+products(), oomph\+::\+Pitch\+Fork\+Handler\+::get\+\_\+jacobian(), and oomph\+::\+Pitch\+Fork\+Handler\+::get\+\_\+residuals().

\mbox{\Hypertarget{classoomph_1_1Problem_ac7667864b71a3889c95c29307422ac8e}\label{classoomph_1_1Problem_ac7667864b71a3889c95c29307422ac8e}} 
\index{oomph::Problem@{oomph::Problem}!global\_temporal\_error\_norm@{global\_temporal\_error\_norm}}
\index{global\_temporal\_error\_norm@{global\_temporal\_error\_norm}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{global\_temporal\_error\_norm()}{global\_temporal\_error\_norm()}}
{\footnotesize\ttfamily virtual double oomph\+::\+Problem\+::global\+\_\+temporal\+\_\+error\+\_\+norm (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Function to calculate a global error norm, used in adaptive timestepping to control the change in timestep. Individual errors for each data object can be obtained via the data timestepper\textquotesingle{}s temporal\+\_\+error\+\_\+in\+\_\+value or temporal\+\_\+error\+\_\+in\+\_\+position functions and should be combined to construct a global norm. For example, in fluids problems a suitable norm is usually the weighted sum of the errors in the velocities; for moving mesh problems is it usually better to use the weighted sum of the errors in position. 



Definition at line 1230 of file problem.\+h.



References oomph\+::\+Global\+\_\+string\+\_\+for\+\_\+annotation\+::string().



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_ac60d7455a13ee171060c3a81623840b2}\label{classoomph_1_1Problem_ac60d7455a13ee171060c3a81623840b2}} 
\index{oomph::Problem@{oomph::Problem}!globally\_convergent\_line\_search@{globally\_convergent\_line\_search}}
\index{globally\_convergent\_line\_search@{globally\_convergent\_line\_search}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{globally\_convergent\_line\_search()}{globally\_convergent\_line\_search()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::globally\+\_\+convergent\+\_\+line\+\_\+search (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&}]{x\+\_\+old,  }\item[{const double \&}]{half\+\_\+residual\+\_\+squared\+\_\+old,  }\item[{\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{gradient,  }\item[{\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{newton\+\_\+dir,  }\item[{double \&}]{half\+\_\+residual\+\_\+squared,  }\item[{const double \&}]{stpmax }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Line search helper for globally convergent Newton method. 

Helper function for the globally convergent Newton solver. 

Definition at line 9339 of file problem.\+cc.



References Dof\+\_\+pt, get\+\_\+residuals(), i, ndof(), and oomph\+::oomph\+\_\+info.



Referenced by newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a342b9bd9c4bc142f514907ee1d23d613}\label{classoomph_1_1Problem_a342b9bd9c4bc142f514907ee1d23d613}} 
\index{oomph::Problem@{oomph::Problem}!initialise\_dt@{initialise\_dt}}
\index{initialise\_dt@{initialise\_dt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{initialise\_dt()}{initialise\_dt()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::initialise\+\_\+dt (\begin{DoxyParamCaption}\item[{const double \&}]{dt }\end{DoxyParamCaption})}



Set all timesteps to the same value, dt, and assign weights for all timesteppers in the problem. 



Definition at line 13424 of file problem.\+cc.



References i, oomph\+::\+Time\+::initialise\+\_\+dt(), ntime\+\_\+stepper(), oomph\+::\+Time\+Stepper\+::set\+\_\+error\+\_\+weights(), oomph\+::\+Time\+Stepper\+::set\+\_\+weights(), Time\+\_\+pt, and time\+\_\+stepper\+\_\+pt().



Referenced by assign\+\_\+initial\+\_\+values\+\_\+impulsive(), and read().

\mbox{\Hypertarget{classoomph_1_1Problem_a48137f1c7b297de56078f6bc0c83b675}\label{classoomph_1_1Problem_a48137f1c7b297de56078f6bc0c83b675}} 
\index{oomph::Problem@{oomph::Problem}!initialise\_dt@{initialise\_dt}}
\index{initialise\_dt@{initialise\_dt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{initialise\_dt()}{initialise\_dt()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::initialise\+\_\+dt (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&}]{dt }\end{DoxyParamCaption})}



Set the value of the timesteps to be equal to the values passed in a vector and assign weights for all timesteppers in the problem. 



Definition at line 13447 of file problem.\+cc.



References i, oomph\+::\+Time\+::initialise\+\_\+dt(), ntime\+\_\+stepper(), oomph\+::\+Time\+Stepper\+::set\+\_\+error\+\_\+weights(), oomph\+::\+Time\+Stepper\+::set\+\_\+weights(), Time\+\_\+pt, and time\+\_\+stepper\+\_\+pt().

\mbox{\Hypertarget{classoomph_1_1Problem_a41a7b9cf8e6fe1156fc92baa43c3fe4b}\label{classoomph_1_1Problem_a41a7b9cf8e6fe1156fc92baa43c3fe4b}} 
\index{oomph::Problem@{oomph::Problem}!is\_dparameter\_calculated\_analytically@{is\_dparameter\_calculated\_analytically}}
\index{is\_dparameter\_calculated\_analytically@{is\_dparameter\_calculated\_analytically}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{is\_dparameter\_calculated\_analytically()}{is\_dparameter\_calculated\_analytically()}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::is\+\_\+dparameter\+\_\+calculated\+\_\+analytically (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Function to determine whether the parameter derivatives are calculated analytically. 



Definition at line 277 of file problem.\+h.



References Calculate\+\_\+dparameter\+\_\+analytic.



Referenced by get\+\_\+derivative\+\_\+wrt\+\_\+global\+\_\+parameter().

\mbox{\Hypertarget{classoomph_1_1Problem_a5c864f0dfc4f0ff33e07935944b7b435}\label{classoomph_1_1Problem_a5c864f0dfc4f0ff33e07935944b7b435}} 
\index{oomph::Problem@{oomph::Problem}!jacobian\_reuse\_is\_enabled@{jacobian\_reuse\_is\_enabled}}
\index{jacobian\_reuse\_is\_enabled@{jacobian\_reuse\_is\_enabled}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{jacobian\_reuse\_is\_enabled()}{jacobian\_reuse\_is\_enabled()}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::jacobian\+\_\+reuse\+\_\+is\+\_\+enabled (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Is recycling of Jacobian in Newton iteration enabled? 



Definition at line 2118 of file problem.\+h.



References Jacobian\+\_\+reuse\+\_\+is\+\_\+enabled.

\mbox{\Hypertarget{classoomph_1_1Problem_a689687cacc40dd351430545a7041f44c}\label{classoomph_1_1Problem_a689687cacc40dd351430545a7041f44c}} 
\index{oomph::Problem@{oomph::Problem}!linear\_solver\_pt@{linear\_solver\_pt}}
\index{linear\_solver\_pt@{linear\_solver\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{linear\_solver\_pt()}{linear\_solver\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}}$\ast$\& oomph\+::\+Problem\+::linear\+\_\+solver\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the linear solver object. 



Definition at line 1466 of file problem.\+h.



References Linear\+\_\+solver\+\_\+pt.



Referenced by oomph\+::\+Fold\+Handler\+::\+Fold\+Handler(), oomph\+::\+Hopf\+Handler\+::\+Hopf\+Handler(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::project(), oomph\+::\+Solid\+ICProblem\+::set\+\_\+newmark\+\_\+initial\+\_\+condition\+\_\+consistently(), oomph\+::\+ANASAZI\+::solve\+\_\+eigenproblem(), oomph\+::\+ANASAZI\+::solve\+\_\+eigenproblem\+\_\+legacy(), oomph\+::\+Fold\+Handler\+::$\sim$\+Fold\+Handler(), oomph\+::\+Hopf\+Handler\+::$\sim$\+Hopf\+Handler(), and oomph\+::\+Pitch\+Fork\+Handler\+::$\sim$\+Pitch\+Fork\+Handler().

\mbox{\Hypertarget{classoomph_1_1Problem_a50b5365e0de1212b9c07f41ae9deab5a}\label{classoomph_1_1Problem_a50b5365e0de1212b9c07f41ae9deab5a}} 
\index{oomph::Problem@{oomph::Problem}!linear\_solver\_pt@{linear\_solver\_pt}}
\index{linear\_solver\_pt@{linear\_solver\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{linear\_solver\_pt()}{linear\_solver\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}}$\ast$ const\& oomph\+::\+Problem\+::linear\+\_\+solver\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the linear solver object (const version) 



Definition at line 1472 of file problem.\+h.



References Linear\+\_\+solver\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1Problem_ad6309367fa379889012f25e3397ab425}\label{classoomph_1_1Problem_ad6309367fa379889012f25e3397ab425}} 
\index{oomph::Problem@{oomph::Problem}!load\_balance@{load\_balance}}
\index{load\_balance@{load\_balance}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{load\_balance()}{load\_balance()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::load\+\_\+balance (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Balance the load of a (possibly non-\/uniformly refined) problem that has already been distributed, by re-\/distributing elements over processors. 



Definition at line 1382 of file problem.\+h.



References oomph\+::\+Doc\+Info\+::disable\+\_\+doc().



Referenced by load\+\_\+balance(), and read().

\mbox{\Hypertarget{classoomph_1_1Problem_a1d78ad991995dca1f71ae83ccaa83e25}\label{classoomph_1_1Problem_a1d78ad991995dca1f71ae83ccaa83e25}} 
\index{oomph::Problem@{oomph::Problem}!load\_balance@{load\_balance}}
\index{load\_balance@{load\_balance}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{load\_balance()}{load\_balance()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::load\+\_\+balance (\begin{DoxyParamCaption}\item[{const bool \&}]{report\+\_\+stats }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Balance the load of a (possibly non-\/uniformly refined) problem that has already been distributed, by re-\/distributing elements over processors. Produce explicit stats of load balancing process if boolean, report\+\_\+stats, is set to true. 



Definition at line 1403 of file problem.\+h.



References oomph\+::\+Doc\+Info\+::disable\+\_\+doc(), and load\+\_\+balance().

\mbox{\Hypertarget{classoomph_1_1Problem_abc2a02507c85322024b9859bfbd5b7bf}\label{classoomph_1_1Problem_abc2a02507c85322024b9859bfbd5b7bf}} 
\index{oomph::Problem@{oomph::Problem}!load\_balance@{load\_balance}}
\index{load\_balance@{load\_balance}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{load\_balance()}{load\_balance()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::load\+\_\+balance (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info,  }\item[{const bool \&}]{report\+\_\+stats }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Balance the load of a (possibly non-\/uniformly refined) problem that has already been distributed, by re-\/distributing elements over processors. Produce explicit stats of load balancing process if boolean, report\+\_\+stats, is set to true. 



Definition at line 1422 of file problem.\+h.



References load\+\_\+balance().

\mbox{\Hypertarget{classoomph_1_1Problem_a7492ddb5663552ce8f61f1ef73c86a9d}\label{classoomph_1_1Problem_a7492ddb5663552ce8f61f1ef73c86a9d}} 
\index{oomph::Problem@{oomph::Problem}!load\_balance@{load\_balance}}
\index{load\_balance@{load\_balance}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{load\_balance()}{load\_balance()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::load\+\_\+balance (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info,  }\item[{const bool \&}]{report\+\_\+stats,  }\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{input\+\_\+target\+\_\+domain\+\_\+for\+\_\+local\+\_\+non\+\_\+halo\+\_\+element }\end{DoxyParamCaption})}



Balance the load of a (possibly non-\/uniformly refined) problem that has already been distributed, by re-\/distributing elements over processors. Produce explicit stats of load balancing process if boolean, report\+\_\+stats, is set to true and doc various bits of data (mainly for debugging) in directory specified by \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} object. If final input vector is non-\/zero-\/sized it provides an imposed partitioning. 

Balance the load of a (possibly non-\/uniformly refined) problem that has already been distributed, by re-\/distributing elements over the processors. Produce explicit stats of load balancing process if boolean, report\+\_\+stats, is set to true and doc various bits of data (mainly for debugging) in directory specified by \mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} object. 

Definition at line 17383 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+after\+\_\+distribute(), actions\+\_\+before\+\_\+adapt(), actions\+\_\+before\+\_\+distribute(), assign\+\_\+eqn\+\_\+numbers(), Base\+\_\+mesh\+\_\+element\+\_\+number\+\_\+plus\+\_\+one, Base\+\_\+mesh\+\_\+element\+\_\+pt, build\+\_\+mesh(), oomph\+::\+Face\+Element\+::bulk\+\_\+element\+\_\+pt(), Communicator\+\_\+pt, communicator\+\_\+pt(), delete\+\_\+all\+\_\+external\+\_\+storage(), oomph\+::\+Mesh\+::distribute(), e, oomph\+::\+Mesh\+::element\+\_\+pt(), oomph\+::\+Face\+Element\+::face\+\_\+index(), oomph\+::\+Mesh\+::finite\+\_\+element\+\_\+pt(), oomph\+::\+Mesh\+::flush\+\_\+element\+\_\+and\+\_\+node\+\_\+storage(), flush\+\_\+sub\+\_\+meshes(), get\+\_\+data\+\_\+to\+\_\+be\+\_\+sent\+\_\+during\+\_\+load\+\_\+balancing(), get\+\_\+flat\+\_\+packed\+\_\+refinement\+\_\+pattern\+\_\+for\+\_\+load\+\_\+balancing(), oomph\+::\+Tree\+Based\+Refineable\+Mesh\+Base\+::get\+\_\+refinement\+\_\+levels(), i, oomph\+::\+Generalised\+Element\+::is\+\_\+halo(), mesh\+\_\+pt(), ndof(), oomph\+::\+Mesh\+::nelement(), oomph\+::\+Mesh\+::nnon\+\_\+halo\+\_\+element(), nsub\+\_\+mesh(), oomph\+::\+Doc\+Info\+::number(), oomph\+::oomph\+\_\+info, oomph\+::\+METIS\+::partition\+\_\+distributed\+\_\+mesh(), Problem\+\_\+has\+\_\+been\+\_\+distributed, oomph\+::\+Mesh\+::prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes(), rebuild\+\_\+global\+\_\+mesh(), refine\+\_\+distributed\+\_\+base\+\_\+mesh(), oomph\+::\+Tree\+Based\+Refineable\+Mesh\+Base\+::refine\+\_\+uniformly(), send\+\_\+data\+\_\+to\+\_\+be\+\_\+sent\+\_\+during\+\_\+load\+\_\+balancing(), send\+\_\+refinement\+\_\+info\+\_\+helper(), setup\+\_\+base\+\_\+mesh\+\_\+info\+\_\+after\+\_\+pruning(), synchronise\+\_\+all\+\_\+dofs(), oomph\+::\+Timing\+Helpers\+::timer(), oomph\+::\+Tree\+Based\+Refineable\+Mesh\+Base\+::uniform\+\_\+refinement\+\_\+level\+\_\+when\+\_\+pruned(), and Use\+\_\+default\+\_\+partition\+\_\+in\+\_\+load\+\_\+balance.

\mbox{\Hypertarget{classoomph_1_1Problem_a78ac2b1d2483f49198203e192d3b2871}\label{classoomph_1_1Problem_a78ac2b1d2483f49198203e192d3b2871}} 
\index{oomph::Problem@{oomph::Problem}!make\_copy@{make\_copy}}
\index{make\_copy@{make\_copy}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{make\_copy()}{make\_copy()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} $\ast$ oomph\+::\+Problem\+::make\+\_\+copy (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Make and return a pointer to the copy of the problem. A virtual function that must be filled in by the user is they wish to perform adaptive refinement in bifurcation tracking or in multigrid problems. ALH\+: WILL NOT BE NECESSARY IN BIFURCATION TRACKING IN LONG RUN... 



Definition at line 12204 of file problem.\+cc.



Referenced by adapt(), and bifurcation\+\_\+adapt\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_afa46c693258868c126503cce3a663a85}\label{classoomph_1_1Problem_afa46c693258868c126503cce3a663a85}} 
\index{oomph::Problem@{oomph::Problem}!mass\_matrix\_reuse\_is\_enabled@{mass\_matrix\_reuse\_is\_enabled}}
\index{mass\_matrix\_reuse\_is\_enabled@{mass\_matrix\_reuse\_is\_enabled}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{mass\_matrix\_reuse\_is\_enabled()}{mass\_matrix\_reuse\_is\_enabled()}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::mass\+\_\+matrix\+\_\+reuse\+\_\+is\+\_\+enabled (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return whether the mass matrix is being reused. 



Definition at line 2697 of file problem.\+h.



References Mass\+\_\+matrix\+\_\+reuse\+\_\+is\+\_\+enabled.

\mbox{\Hypertarget{classoomph_1_1Problem_a93304d0c6be1022b944f21c0f4c07eab}\label{classoomph_1_1Problem_a93304d0c6be1022b944f21c0f4c07eab}} 
\index{oomph::Problem@{oomph::Problem}!mass\_matrix\_solver\_for\_explicit\_timestepper\_pt@{mass\_matrix\_solver\_for\_explicit\_timestepper\_pt}}
\index{mass\_matrix\_solver\_for\_explicit\_timestepper\_pt@{mass\_matrix\_solver\_for\_explicit\_timestepper\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{mass\_matrix\_solver\_for\_explicit\_timestepper\_pt()}{mass\_matrix\_solver\_for\_explicit\_timestepper\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}}$\ast$\& oomph\+::\+Problem\+::mass\+\_\+matrix\+\_\+solver\+\_\+for\+\_\+explicit\+\_\+timestepper\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the linear solver object used for explicit time stepping. 



Definition at line 1479 of file problem.\+h.



References Mass\+\_\+matrix\+\_\+solver\+\_\+for\+\_\+explicit\+\_\+timestepper\+\_\+pt.



Referenced by get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals().

\mbox{\Hypertarget{classoomph_1_1Problem_a10ffcfbf305940a05452d950df7a11c3}\label{classoomph_1_1Problem_a10ffcfbf305940a05452d950df7a11c3}} 
\index{oomph::Problem@{oomph::Problem}!mass\_matrix\_solver\_for\_explicit\_timestepper\_pt@{mass\_matrix\_solver\_for\_explicit\_timestepper\_pt}}
\index{mass\_matrix\_solver\_for\_explicit\_timestepper\_pt@{mass\_matrix\_solver\_for\_explicit\_timestepper\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{mass\_matrix\_solver\_for\_explicit\_timestepper\_pt()}{mass\_matrix\_solver\_for\_explicit\_timestepper\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}}$\ast$ oomph\+::\+Problem\+::mass\+\_\+matrix\+\_\+solver\+\_\+for\+\_\+explicit\+\_\+timestepper\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the linear solver object used for explicit time stepping (const version). 



Definition at line 1486 of file problem.\+h.



References Mass\+\_\+matrix\+\_\+solver\+\_\+for\+\_\+explicit\+\_\+timestepper\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1Problem_aa30b2e89f61a327ffb1be4ff30bb868f}\label{classoomph_1_1Problem_aa30b2e89f61a327ffb1be4ff30bb868f}} 
\index{oomph::Problem@{oomph::Problem}!max\_newton\_iterations@{max\_newton\_iterations}}
\index{max\_newton\_iterations@{max\_newton\_iterations}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{max\_newton\_iterations()}{max\_newton\_iterations()}}
{\footnotesize\ttfamily unsigned\& oomph\+::\+Problem\+::max\+\_\+newton\+\_\+iterations (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access function to max Newton iterations before giving up. 



Definition at line 1594 of file problem.\+h.



References Max\+\_\+newton\+\_\+iterations.

\mbox{\Hypertarget{classoomph_1_1Problem_a2ad78241135f621df36bc1b9634845ac}\label{classoomph_1_1Problem_a2ad78241135f621df36bc1b9634845ac}} 
\index{oomph::Problem@{oomph::Problem}!max\_residuals@{max\_residuals}}
\index{max\_residuals@{max\_residuals}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{max\_residuals()}{max\_residuals()}}
{\footnotesize\ttfamily double\& oomph\+::\+Problem\+::max\+\_\+residuals (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access function to max residuals in Newton iterations before giving up. 



Definition at line 1608 of file problem.\+h.



References Max\+\_\+residuals.

\mbox{\Hypertarget{classoomph_1_1Problem_ac5355154d4991ec634e74d4817176f5f}\label{classoomph_1_1Problem_ac5355154d4991ec634e74d4817176f5f}} 
\index{oomph::Problem@{oomph::Problem}!maximum\_dt@{maximum\_dt}}
\index{maximum\_dt@{maximum\_dt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{maximum\_dt()}{maximum\_dt()}}
{\footnotesize\ttfamily double\& oomph\+::\+Problem\+::maximum\+\_\+dt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access function to max timestep in adaptive timestepping. 



Definition at line 1588 of file problem.\+h.



References Maximum\+\_\+dt.

\mbox{\Hypertarget{classoomph_1_1Problem_aad122d70a22dc5302cfd5853d3cf3057}\label{classoomph_1_1Problem_aad122d70a22dc5302cfd5853d3cf3057}} 
\index{oomph::Problem@{oomph::Problem}!mesh\_pt@{mesh\_pt}}
\index{mesh\_pt@{mesh\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{mesh\_pt()}{mesh\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}}$\ast$\& oomph\+::\+Problem\+::mesh\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the global mesh. 



Definition at line 1280 of file problem.\+h.



References Mesh\+\_\+pt.



Referenced by oomph\+::\+IMRBy\+BDF\+::actions\+\_\+after\+\_\+timestep(), oomph\+::\+Refineable\+Gmsh\+Tet\+Mesh$<$ ELEMENT $>$\+::adapt(), oomph\+::\+Refineable\+Tetgen\+Mesh$<$ ELEMENT $>$\+::adapt(), oomph\+::\+Refineable\+Triangle\+Mesh$<$ ELEMENT $>$\+::adapt(), adapt(), adapt\+\_\+based\+\_\+on\+\_\+error\+\_\+estimates(), oomph\+::\+Periodic\+Orbit\+Assembly\+Handler$<$ NNODE\+\_\+1\+D $>$\+::adapt\+\_\+temporal\+\_\+mesh(), add\+\_\+sub\+\_\+mesh(), assign\+\_\+eqn\+\_\+numbers(), oomph\+::\+Solid\+ICProblem\+::backup\+\_\+original\+\_\+state(), bifurcation\+\_\+adapt\+\_\+helper(), check\+\_\+halo\+\_\+schemes(), copy(), copy\+\_\+haloed\+\_\+eqn\+\_\+numbers\+\_\+helper(), delete\+\_\+all\+\_\+external\+\_\+storage(), disable\+\_\+mass\+\_\+matrix\+\_\+reuse(), distribute(), doc\+\_\+errors(), oomph\+::\+Fp\+Pressure\+Advection\+Diffusion\+Problem$<$ ELEMENT $>$\+::doc\+\_\+solution(), dump(), enable\+\_\+mass\+\_\+matrix\+\_\+reuse(), oomph\+::\+Segregatable\+FSIProblem\+::extrapolate\+\_\+solid\+\_\+data(), oomph\+::\+Fold\+Handler\+::\+Fold\+Handler(), oomph\+::\+Fp\+Pressure\+Advection\+Diffusion\+Problem$<$ ELEMENT $>$\+::\+Fp\+Pressure\+Advection\+Diffusion\+Problem(), get\+\_\+all\+\_\+error\+\_\+estimates(), get\+\_\+all\+\_\+halo\+\_\+data(), get\+\_\+data\+\_\+to\+\_\+be\+\_\+sent\+\_\+during\+\_\+load\+\_\+balancing(), get\+\_\+dofs(), get\+\_\+flat\+\_\+packed\+\_\+refinement\+\_\+pattern\+\_\+for\+\_\+load\+\_\+balancing(), get\+\_\+hessian\+\_\+vector\+\_\+products(), get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals(), get\+\_\+my\+\_\+eqns(), oomph\+::\+Navier\+Stokes\+Schur\+Complement\+Preconditioner\+::get\+\_\+pressure\+\_\+advection\+\_\+diffusion\+\_\+matrix(), oomph\+::\+Fold\+Handler\+::get\+\_\+residuals(), oomph\+::\+Hopf\+Handler\+::get\+\_\+residuals(), oomph\+::\+Hopf\+Handler\+::\+Hopf\+Handler(), load\+\_\+balance(), oomph\+::\+Linear\+Elasticity\+Smooth\+Mesh$<$ LINEAR\+\_\+\+ELASTICITY\+\_\+\+ELEMENT $>$\+::operator()(), oomph\+::\+Poisson\+Smooth\+Mesh$<$ POISSON\+\_\+\+ELEMENT $>$\+::operator()(), oomph\+::\+Periodic\+Orbit\+Assembly\+Handler$<$ NNODE\+\_\+1\+D $>$\+::orbit\+\_\+output(), p\+\_\+adapt(), p\+\_\+refine\+\_\+selected\+\_\+elements(), p\+\_\+refine\+\_\+uniformly(), p\+\_\+refine\+\_\+uniformly\+\_\+aux(), p\+\_\+unrefine\+\_\+uniformly(), parallel\+\_\+sparse\+\_\+assemble(), oomph\+::\+METIS\+::partition\+\_\+distributed\+\_\+mesh(), oomph\+::\+METIS\+::partition\+\_\+mesh(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::pin\+\_\+all(), oomph\+::\+Fp\+Pressure\+Advection\+Diffusion\+Problem$<$ ELEMENT $>$\+::pin\+\_\+all\+\_\+non\+\_\+pressure\+\_\+dofs(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::pin\+\_\+dofs\+\_\+of\+\_\+coordinate(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::pin\+\_\+dofs\+\_\+of\+\_\+field(), oomph\+::\+Pitch\+Fork\+Handler\+::\+Pitch\+Fork\+Handler(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::project(), prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes(), read(), refine\+\_\+distributed\+\_\+base\+\_\+mesh(), refine\+\_\+selected\+\_\+elements(), refine\+\_\+uniformly(), refine\+\_\+uniformly\+\_\+aux(), remove\+\_\+duplicate\+\_\+data(), remove\+\_\+null\+\_\+pointers\+\_\+from\+\_\+external\+\_\+halo\+\_\+node\+\_\+storage(), oomph\+::\+HSL\+\_\+\+MA42\+::reorder\+\_\+elements(), oomph\+::\+Solid\+ICProblem\+::reset\+\_\+original\+\_\+state(), oomph\+::\+Fp\+Pressure\+Advection\+Diffusion\+Problem$<$ ELEMENT $>$\+::reset\+\_\+pin\+\_\+status(), oomph\+::\+Augmented\+Block\+Fold\+Linear\+Solver\+::resolve(), oomph\+::\+Augmented\+Block\+Pitch\+Fork\+Linear\+Solver\+::resolve(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::restore\+\_\+positions(), self\+\_\+test(), send\+\_\+refinement\+\_\+info\+\_\+helper(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::set\+\_\+coordinate\+\_\+for\+\_\+projection(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::set\+\_\+current\+\_\+field\+\_\+for\+\_\+projection(), set\+\_\+dofs(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::set\+\_\+lagrangian\+\_\+coordinate\+\_\+for\+\_\+projection(), oomph\+::\+Solid\+ICProblem\+::set\+\_\+newmark\+\_\+initial\+\_\+condition\+\_\+consistently(), oomph\+::\+Solid\+ICProblem\+::set\+\_\+newmark\+\_\+initial\+\_\+condition\+\_\+directly(), oomph\+::\+Solid\+ICProblem\+::set\+\_\+static\+\_\+initial\+\_\+condition(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::set\+\_\+time\+\_\+level\+\_\+for\+\_\+projection(), setup\+\_\+base\+\_\+mesh\+\_\+info\+\_\+after\+\_\+pruning(), setup\+\_\+dof\+\_\+halo\+\_\+scheme(), setup\+\_\+element\+\_\+count\+\_\+per\+\_\+dof(), oomph\+::\+Solid\+ICProblem\+::setup\+\_\+problem(), oomph\+::\+Segregatable\+FSIProblem\+::setup\+\_\+segregated\+\_\+solver(), oomph\+::\+Solid\+ICProblem\+::\+Solid\+ICProblem(), oomph\+::\+Augmented\+Block\+Fold\+Linear\+Solver\+::solve(), oomph\+::\+Augmented\+Block\+Pitch\+Fork\+Linear\+Solver\+::solve(), oomph\+::\+Block\+Hopf\+Linear\+Solver\+::solve(), oomph\+::\+HSL\+\_\+\+MA42\+::solve(), oomph\+::\+MGSolver$<$ DIM $>$\+::solve(), oomph\+::\+Helmholtz\+GMRESMG$<$ MATRIX $>$\+::solve(), oomph\+::\+Helmholtz\+FGMRESMG$<$ MATRIX $>$\+::solve(), oomph\+::\+HSL\+\_\+\+MA42\+::solve\+\_\+for\+\_\+one\+\_\+dof(), oomph\+::\+Block\+Hopf\+Linear\+Solver\+::solve\+\_\+for\+\_\+two\+\_\+rhs(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+lists(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+maps(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+vectors(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+vectors\+\_\+of\+\_\+pairs(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::store\+\_\+positions(), synchronise\+\_\+dofs(), synchronise\+\_\+eqn\+\_\+numbers(), oomph\+::\+METIS\+::uniform\+\_\+partition\+\_\+mesh(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::unpin\+\_\+all(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::unpin\+\_\+dofs\+\_\+of\+\_\+coordinate(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::unpin\+\_\+dofs\+\_\+of\+\_\+field(), unrefine\+\_\+uniformly(), oomph\+::\+Fp\+Pressure\+Advection\+Diffusion\+Problem$<$ ELEMENT $>$\+::validate(), and oomph\+::\+Womersley\+Problem$<$ ELEMENT, DIM $>$\+::\+Womersley\+Problem().

\mbox{\Hypertarget{classoomph_1_1Problem_a3a2e53542288a4140ea5b076ffa648db}\label{classoomph_1_1Problem_a3a2e53542288a4140ea5b076ffa648db}} 
\index{oomph::Problem@{oomph::Problem}!mesh\_pt@{mesh\_pt}}
\index{mesh\_pt@{mesh\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{mesh\_pt()}{mesh\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}}$\ast$ const\& oomph\+::\+Problem\+::mesh\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the global mesh (const version) 



Definition at line 1286 of file problem.\+h.



References Mesh\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1Problem_ac9d882b768345fd916079ec184764f72}\label{classoomph_1_1Problem_ac9d882b768345fd916079ec184764f72}} 
\index{oomph::Problem@{oomph::Problem}!mesh\_pt@{mesh\_pt}}
\index{mesh\_pt@{mesh\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{mesh\_pt()}{mesh\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}}$\ast$\& oomph\+::\+Problem\+::mesh\+\_\+pt (\begin{DoxyParamCaption}\item[{const unsigned \&}]{imesh }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the i-\/th submesh. If there are no submeshes, the 0-\/th submesh is the global mesh itself. 



Definition at line 1293 of file problem.\+h.



References Mesh\+\_\+pt, and Sub\+\_\+mesh\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1Problem_a35b503d711781552b6b56deb612816c4}\label{classoomph_1_1Problem_a35b503d711781552b6b56deb612816c4}} 
\index{oomph::Problem@{oomph::Problem}!mesh\_pt@{mesh\_pt}}
\index{mesh\_pt@{mesh\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{mesh\_pt()}{mesh\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}}$\ast$ const\& oomph\+::\+Problem\+::mesh\+\_\+pt (\begin{DoxyParamCaption}\item[{const unsigned \&}]{imesh }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the i-\/th submesh (const version) 



Definition at line 1308 of file problem.\+h.



References Mesh\+\_\+pt, and Sub\+\_\+mesh\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1Problem_adffc8921bf61edac68ed017bcdc1d792}\label{classoomph_1_1Problem_adffc8921bf61edac68ed017bcdc1d792}} 
\index{oomph::Problem@{oomph::Problem}!minimum\_dt@{minimum\_dt}}
\index{minimum\_dt@{minimum\_dt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{minimum\_dt()}{minimum\_dt()}}
{\footnotesize\ttfamily double\& oomph\+::\+Problem\+::minimum\+\_\+dt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access function to min timestep in adaptive timestepping. 



Definition at line 1582 of file problem.\+h.



References Minimum\+\_\+dt.

\mbox{\Hypertarget{classoomph_1_1Problem_a218d4dfff74bc14f3f5dc8416236e01d}\label{classoomph_1_1Problem_a218d4dfff74bc14f3f5dc8416236e01d}} 
\index{oomph::Problem@{oomph::Problem}!ndof@{ndof}}
\index{ndof@{ndof}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{ndof()}{ndof()}}
{\footnotesize\ttfamily unsigned long oomph\+::\+Problem\+::ndof (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the number of dofs. 



Definition at line 1678 of file problem.\+h.



References Dof\+\_\+distribution\+\_\+pt, and oomph\+::\+Linear\+Algebra\+Distribution\+::nrow().



Referenced by oomph\+::\+IMRBy\+BDF\+::actions\+\_\+after\+\_\+timestep(), oomph\+::\+IMRBy\+BDF\+::actions\+\_\+before\+\_\+timestep(), adapt(), add\+\_\+eigenvector\+\_\+to\+\_\+dofs(), add\+\_\+to\+\_\+dofs(), assign\+\_\+eigenvector\+\_\+to\+\_\+dofs(), bifurcation\+\_\+adapt\+\_\+helper(), calculate\+\_\+continuation\+\_\+derivatives(), calculate\+\_\+predictions(), create\+\_\+new\+\_\+linear\+\_\+algebra\+\_\+distribution(), distribute(), oomph\+::\+Fold\+Handler\+::\+Fold\+Handler(), get\+\_\+dofs(), get\+\_\+fd\+\_\+jacobian(), get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals(), get\+\_\+jacobian(), globally\+\_\+convergent\+\_\+line\+\_\+search(), oomph\+::\+Hopf\+Handler\+::\+Hopf\+Handler(), load\+\_\+balance(), newton\+\_\+solve(), oomph\+::\+Pitch\+Fork\+Handler\+::\+Pitch\+Fork\+Handler(), oomph\+::\+MGPreconditioner$<$ DIM $>$\+::preconditioner\+\_\+solve(), prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes(), oomph\+::\+HSL\+\_\+\+MA42\+::reorder\+\_\+elements(), oomph\+::\+Augmented\+Block\+Fold\+Linear\+Solver\+::resolve(), oomph\+::\+Augmented\+Block\+Pitch\+Fork\+Linear\+Solver\+::resolve(), restore\+\_\+dof\+\_\+values(), set\+\_\+dofs(), oomph\+::\+Augmented\+Block\+Fold\+Linear\+Solver\+::solve(), oomph\+::\+Augmented\+Block\+Pitch\+Fork\+Linear\+Solver\+::solve(), oomph\+::\+Block\+Hopf\+Linear\+Solver\+::solve(), oomph\+::\+HSL\+\_\+\+MA42\+::solve(), oomph\+::\+GS$<$ MATRIX $>$\+::solve(), oomph\+::\+GS$<$ CRDouble\+Matrix $>$\+::solve(), oomph\+::\+Damped\+Jacobi$<$ MATRIX $>$\+::solve(), oomph\+::\+GMRES$<$ MATRIX $>$\+::solve(), oomph\+::\+Augmented\+Problem\+GMRES\+::solve(), oomph\+::\+Dense\+LU\+::solve(), oomph\+::\+FD\+\_\+\+LU\+::solve(), oomph\+::\+Super\+LUSolver\+::solve(), oomph\+::\+Mumps\+Solver\+::solve(), oomph\+::\+Helmholtz\+GMRESMG$<$ MATRIX $>$\+::solve(), oomph\+::\+Helmholtz\+FGMRESMG$<$ MATRIX $>$\+::solve(), oomph\+::\+LAPACK\+\_\+\+QZ\+::solve\+\_\+eigenproblem(), oomph\+::\+LAPACK\+\_\+\+QZ\+::solve\+\_\+eigenproblem\+\_\+helper(), oomph\+::\+ARPACK\+::solve\+\_\+eigenproblem\+\_\+legacy(), oomph\+::\+LAPACK\+\_\+\+QZ\+::solve\+\_\+eigenproblem\+\_\+legacy(), oomph\+::\+HSL\+\_\+\+MA42\+::solve\+\_\+for\+\_\+one\+\_\+dof(), oomph\+::\+Block\+Hopf\+Linear\+Solver\+::solve\+\_\+for\+\_\+two\+\_\+rhs(), oomph\+::\+Super\+LUSolver\+::solve\+\_\+transpose(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+lists(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+maps(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+vectors(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+vectors\+\_\+of\+\_\+pairs(), and store\+\_\+current\+\_\+dof\+\_\+values().

\mbox{\Hypertarget{classoomph_1_1Problem_a62a989ae9a9169b9d905f844db59787f}\label{classoomph_1_1Problem_a62a989ae9a9169b9d905f844db59787f}} 
\index{oomph::Problem@{oomph::Problem}!newton\_solve@{newton\_solve}}
\index{newton\_solve@{newton\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{newton\_solve()}{newton\_solve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::newton\+\_\+solve (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Use Newton method to solve the problem. 

General Newton solver. Requires only a convergence tolerance. The linear solver takes a pointer to the problem (which defines the Jacobian {\bfseries{J}} and the residual \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} {\bfseries{r}}) and returns the solution {\bfseries{x}} of the system.

\[ {\bf J} {\bf x} = - \bf{r} \]. 

Definition at line 8976 of file problem.\+cc.



References actions\+\_\+after\+\_\+newton\+\_\+solve(), actions\+\_\+after\+\_\+newton\+\_\+step(), actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check(), actions\+\_\+before\+\_\+newton\+\_\+solve(), actions\+\_\+before\+\_\+newton\+\_\+step(), Always\+\_\+take\+\_\+one\+\_\+newton\+\_\+step, oomph\+::\+Double\+Vector\+::clear(), oomph\+::\+Timing\+Helpers\+::convert\+\_\+secs\+\_\+to\+\_\+formatted\+\_\+string(), Dof\+\_\+distribution\+\_\+pt, Dof\+\_\+pt, oomph\+::\+Linear\+Solver\+::enable\+\_\+computation\+\_\+of\+\_\+gradient(), oomph\+::\+Linear\+Solver\+::enable\+\_\+resolve(), oomph\+::\+Linear\+Solver\+::get\+\_\+gradient(), get\+\_\+residuals(), globally\+\_\+convergent\+\_\+line\+\_\+search(), i, Jacobian\+\_\+has\+\_\+been\+\_\+computed, Jacobian\+\_\+reuse\+\_\+is\+\_\+enabled, Linear\+\_\+solver\+\_\+pt, oomph\+::\+Double\+Vector\+::max(), Max\+\_\+newton\+\_\+iterations, Max\+\_\+res, Max\+\_\+residuals, oomph\+::\+MPI\+\_\+\+Helpers\+::mpi\+\_\+has\+\_\+been\+\_\+initialised(), ndof(), Newton\+\_\+solver\+\_\+tolerance, Nnewton\+\_\+iter\+\_\+taken, oomph\+::\+Linear\+Algebra\+Distribution\+::nrow\+\_\+local(), oomph\+::oomph\+\_\+info, Problem\+\_\+is\+\_\+nonlinear, oomph\+::\+Double\+Vector\+::redistribute(), Relaxation\+\_\+factor, oomph\+::\+Linear\+Solver\+::reset\+\_\+gradient(), oomph\+::\+Linear\+Solver\+::resolve(), Shut\+\_\+up\+\_\+in\+\_\+newton\+\_\+solve, oomph\+::\+Linear\+Solver\+::solve(), synchronise\+\_\+all\+\_\+dofs(), oomph\+::\+Timing\+Helpers\+::timer(), Use\+\_\+globally\+\_\+convergent\+\_\+newton\+\_\+method, and oomph\+::\+Double\+Vector\+::values\+\_\+pt().



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), newton\+\_\+solve(), oomph\+::\+Non\+Linear\+Elasticity\+Smooth\+Mesh$<$ ELEMENT $>$\+::operator()(), oomph\+::\+Linear\+Elasticity\+Smooth\+Mesh$<$ LINEAR\+\_\+\+ELASTICITY\+\_\+\+ELEMENT $>$\+::operator()(), oomph\+::\+Poisson\+Smooth\+Mesh$<$ POISSON\+\_\+\+ELEMENT $>$\+::operator()(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::project(), oomph\+::\+Segregatable\+FSIProblem\+::segregated\+\_\+solve(), oomph\+::\+Solid\+ICProblem\+::set\+\_\+newmark\+\_\+initial\+\_\+condition\+\_\+consistently(), oomph\+::\+Solid\+ICProblem\+::set\+\_\+newmark\+\_\+initial\+\_\+condition\+\_\+directly(), oomph\+::\+Solid\+ICProblem\+::set\+\_\+static\+\_\+initial\+\_\+condition(), steady\+\_\+newton\+\_\+solve(), unsteady\+\_\+newton\+\_\+solve(), and oomph\+::\+Fp\+Pressure\+Advection\+Diffusion\+Problem$<$ ELEMENT $>$\+::validate().

\mbox{\Hypertarget{classoomph_1_1Problem_a4a5a30c124a14f32368f9607b7c8bf34}\label{classoomph_1_1Problem_a4a5a30c124a14f32368f9607b7c8bf34}} 
\index{oomph::Problem@{oomph::Problem}!newton\_solve@{newton\_solve}}
\index{newton\_solve@{newton\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{newton\_solve()}{newton\_solve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::newton\+\_\+solve (\begin{DoxyParamCaption}\item[{unsigned const \&}]{max\+\_\+adapt }\end{DoxyParamCaption})}



Adaptive Newton solve\+: up to max\+\_\+adapt adaptations of all refineable submeshes are performed to achieve the the error targets specified in the refineable submeshes. 

Adaptive Newton solver. The linear solver takes a pointer to the problem (which defines the Jacobian {\bfseries{J}} and the residual \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} {\bfseries{r}}) and returns the solution {\bfseries{x}} of the system.

\[ {\bf J} {\bf x} = - \bf{r} \]. Performs at most max\+\_\+adapt adaptations on all meshes. 

Definition at line 16416 of file problem.\+cc.



References adapt(), communicator\+\_\+pt(), oomph\+::\+Newton\+Solver\+Error\+::iterations, Max\+\_\+newton\+\_\+iterations, Max\+\_\+residuals, oomph\+::\+Newton\+Solver\+Error\+::maxres, newton\+\_\+solve(), oomph\+::oomph\+\_\+info, and Problem\+\_\+has\+\_\+been\+\_\+distributed.

\mbox{\Hypertarget{classoomph_1_1Problem_aea0efdeb4814de433fa2ffb3065831ce}\label{classoomph_1_1Problem_aea0efdeb4814de433fa2ffb3065831ce}} 
\index{oomph::Problem@{oomph::Problem}!newton\_solve\_continuation@{newton\_solve\_continuation}}
\index{newton\_solve\_continuation@{newton\_solve\_continuation}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{newton\_solve\_continuation()}{newton\_solve\_continuation()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::newton\+\_\+solve\+\_\+continuation (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Perform a basic arc-\/length continuation step using Newton\textquotesingle{}s method. Returns number of Newton steps taken. 

Perform a basic continuation step using Newton\textquotesingle{}s method. The governing parameter of the problem is passed as a pointer to the routine. The number of Newton steps taken is returned. 

Definition at line 9569 of file problem.\+cc.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_aa539429593ad9ffe3a400a72db2063bd}\label{classoomph_1_1Problem_aa539429593ad9ffe3a400a72db2063bd}} 
\index{oomph::Problem@{oomph::Problem}!newton\_solve\_continuation@{newton\_solve\_continuation}}
\index{newton\_solve\_continuation@{newton\_solve\_continuation}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{newton\_solve\_continuation()}{newton\_solve\_continuation()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::newton\+\_\+solve\+\_\+continuation (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt,  }\item[{\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{z }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



This function performs a basic continuation step using the Newton method. The number of Newton steps taken is returned, to be used in any external step-\/size control routines. The governing parameter of the problem is passed as a pointer to the routine, as is a vector in which to store the derivatives wrt the parameter, if required. 

This function performs a basic continuation step using the Newton method. The number of Newton steps taken is returned, to be used in any external step-\/size control routines. The governing parameter of the problem is passed as a pointer to the routine, as is the sign of the Jacobian and a \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} in which to store the derivatives wrt the parameter, if required. 

Definition at line 9589 of file problem.\+cc.



References actions\+\_\+after\+\_\+newton\+\_\+solve(), actions\+\_\+after\+\_\+newton\+\_\+step(), actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check(), actions\+\_\+before\+\_\+newton\+\_\+solve(), actions\+\_\+before\+\_\+newton\+\_\+step(), Always\+\_\+take\+\_\+one\+\_\+newton\+\_\+step, oomph\+::\+Double\+Vector\+::clear(), oomph\+::\+Linear\+Algebra\+Distribution\+::communicator\+\_\+pt(), oomph\+::\+Linear\+Solver\+::disable\+\_\+resolve(), oomph\+::\+Linear\+Algebra\+Distribution\+::distributed(), dof\+\_\+current(), dof\+\_\+derivative(), Dof\+\_\+distribution\+\_\+pt, Dof\+\_\+pt, Ds\+\_\+current, oomph\+::\+Linear\+Solver\+::enable\+\_\+resolve(), get\+\_\+derivative\+\_\+wrt\+\_\+global\+\_\+parameter(), get\+\_\+residuals(), oomph\+::\+Linear\+Solver\+::is\+\_\+resolve\+\_\+enabled(), Linear\+\_\+solver\+\_\+pt, oomph\+::\+Double\+Vector\+::max(), Max\+\_\+newton\+\_\+iterations, Max\+\_\+residuals, Newton\+\_\+solver\+\_\+tolerance, oomph\+::\+Linear\+Algebra\+Distribution\+::nrow\+\_\+local(), oomph\+::oomph\+\_\+info, Parameter\+\_\+current, Parameter\+\_\+derivative, oomph\+::\+Double\+Vector\+::redistribute(), oomph\+::\+Linear\+Solver\+::resolve(), Shut\+\_\+up\+\_\+in\+\_\+newton\+\_\+solve, oomph\+::\+Linear\+Solver\+::solve(), synchronise\+\_\+all\+\_\+dofs(), Theta\+\_\+squared, and oomph\+::\+Double\+Vector\+::values\+\_\+pt().

\mbox{\Hypertarget{classoomph_1_1Problem_aa43a98d2303f2bce10d0887dc0b2eac5}\label{classoomph_1_1Problem_aa43a98d2303f2bce10d0887dc0b2eac5}} 
\index{oomph::Problem@{oomph::Problem}!newton\_solver\_tolerance@{newton\_solver\_tolerance}}
\index{newton\_solver\_tolerance@{newton\_solver\_tolerance}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{newton\_solver\_tolerance()}{newton\_solver\_tolerance()}}
{\footnotesize\ttfamily double\& oomph\+::\+Problem\+::newton\+\_\+solver\+\_\+tolerance (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access function to tolererance of the Newton solver, i.\+e. the maximum value of the residuals that will be accepted. 



Definition at line 1621 of file problem.\+h.



References Newton\+\_\+solver\+\_\+tolerance.

\mbox{\Hypertarget{classoomph_1_1Problem_a60a9b6861928cf9115110b5bfc7d11a7}\label{classoomph_1_1Problem_a60a9b6861928cf9115110b5bfc7d11a7}} 
\index{oomph::Problem@{oomph::Problem}!nglobal\_data@{nglobal\_data}}
\index{nglobal\_data@{nglobal\_data}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{nglobal\_data()}{nglobal\_data()}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::nglobal\+\_\+data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the number of global data values. 



Definition at line 1690 of file problem.\+h.



References Global\+\_\+data\+\_\+pt.



Referenced by oomph\+::\+IMRBy\+BDF\+::actions\+\_\+after\+\_\+timestep(), oomph\+::\+Periodic\+Orbit\+Assembly\+Handler$<$ NNODE\+\_\+1\+D $>$\+::adapt\+\_\+temporal\+\_\+mesh(), assign\+\_\+eqn\+\_\+numbers(), copy(), describe\+\_\+dofs(), distribute(), get\+\_\+dofs(), set\+\_\+dofs(), and set\+\_\+pinned\+\_\+values\+\_\+to\+\_\+zero().

\mbox{\Hypertarget{classoomph_1_1Problem_accc4e5a46953800933f07ae6bd67860e}\label{classoomph_1_1Problem_accc4e5a46953800933f07ae6bd67860e}} 
\index{oomph::Problem@{oomph::Problem}!nsub\_mesh@{nsub\_mesh}}
\index{nsub\_mesh@{nsub\_mesh}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{nsub\_mesh()}{nsub\_mesh()}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::nsub\+\_\+mesh (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return number of submeshes. 



Definition at line 1323 of file problem.\+h.



References Sub\+\_\+mesh\+\_\+pt.



Referenced by adapt(), adapt\+\_\+based\+\_\+on\+\_\+error\+\_\+estimates(), oomph\+::\+Periodic\+Orbit\+Assembly\+Handler$<$ NNODE\+\_\+1\+D $>$\+::adapt\+\_\+temporal\+\_\+mesh(), assign\+\_\+eqn\+\_\+numbers(), check\+\_\+halo\+\_\+schemes(), copy(), copy\+\_\+haloed\+\_\+eqn\+\_\+numbers\+\_\+helper(), delete\+\_\+all\+\_\+external\+\_\+storage(), describe\+\_\+dofs(), distribute(), doc\+\_\+errors(), does\+\_\+pointer\+\_\+correspond\+\_\+to\+\_\+problem\+\_\+data(), dump(), get\+\_\+all\+\_\+error\+\_\+estimates(), get\+\_\+all\+\_\+halo\+\_\+data(), get\+\_\+data\+\_\+to\+\_\+be\+\_\+sent\+\_\+during\+\_\+load\+\_\+balancing(), get\+\_\+flat\+\_\+packed\+\_\+refinement\+\_\+pattern\+\_\+for\+\_\+load\+\_\+balancing(), oomph\+::\+Navier\+Stokes\+Schur\+Complement\+Preconditioner\+::get\+\_\+pressure\+\_\+advection\+\_\+diffusion\+\_\+matrix(), load\+\_\+balance(), p\+\_\+adapt(), p\+\_\+refine\+\_\+selected\+\_\+elements(), p\+\_\+refine\+\_\+uniformly(), p\+\_\+refine\+\_\+uniformly\+\_\+and\+\_\+prune(), p\+\_\+refine\+\_\+uniformly\+\_\+aux(), p\+\_\+unrefine\+\_\+uniformly(), oomph\+::\+METIS\+::partition\+\_\+mesh(), prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes(), read(), refine\+\_\+distributed\+\_\+base\+\_\+mesh(), refine\+\_\+selected\+\_\+elements(), refine\+\_\+uniformly(), refine\+\_\+uniformly\+\_\+and\+\_\+prune(), refine\+\_\+uniformly\+\_\+aux(), remove\+\_\+null\+\_\+pointers\+\_\+from\+\_\+external\+\_\+halo\+\_\+node\+\_\+storage(), self\+\_\+test(), send\+\_\+data\+\_\+to\+\_\+be\+\_\+sent\+\_\+during\+\_\+load\+\_\+balancing(), send\+\_\+refinement\+\_\+info\+\_\+helper(), set\+\_\+consistent\+\_\+pinned\+\_\+values\+\_\+for\+\_\+continuation(), set\+\_\+timestepper\+\_\+for\+\_\+all\+\_\+data(), setup\+\_\+base\+\_\+mesh\+\_\+info\+\_\+after\+\_\+pruning(), oomph\+::\+Segregatable\+FSIProblem\+::setup\+\_\+segregated\+\_\+solver(), synchronise\+\_\+dofs(), synchronise\+\_\+eqn\+\_\+numbers(), and unrefine\+\_\+uniformly().

\mbox{\Hypertarget{classoomph_1_1Problem_ace3cdf55009c3bff21d2b7d3706d522a}\label{classoomph_1_1Problem_ace3cdf55009c3bff21d2b7d3706d522a}} 
\index{oomph::Problem@{oomph::Problem}!ntime\_stepper@{ntime\_stepper}}
\index{ntime\_stepper@{ntime\_stepper}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{ntime\_stepper()}{ntime\_stepper()}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::ntime\+\_\+stepper (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the number of time steppers. 



Definition at line 1684 of file problem.\+h.



References Time\+\_\+stepper\+\_\+pt.



Referenced by oomph\+::\+IMRBy\+BDF\+::actions\+\_\+before\+\_\+timestep(), adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), arc\+\_\+length\+\_\+step\+\_\+solve(), arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), copy(), get\+\_\+dvaluesdt(), oomph\+::\+Multi\+\_\+domain\+\_\+functions\+::get\+\_\+required\+\_\+master\+\_\+nodal\+\_\+information\+\_\+helper(), oomph\+::\+Multi\+\_\+domain\+\_\+functions\+::get\+\_\+required\+\_\+nodal\+\_\+information\+\_\+helper(), initialise\+\_\+dt(), solve\+\_\+adjoint\+\_\+eigenproblem(), solve\+\_\+adjoint\+\_\+eigenproblem\+\_\+legacy(), solve\+\_\+eigenproblem(), solve\+\_\+eigenproblem\+\_\+legacy(), steady\+\_\+newton\+\_\+solve(), oomph\+::\+Segregatable\+FSIProblem\+::steady\+\_\+segregated\+\_\+solve(), unsteady\+\_\+newton\+\_\+solve(), and oomph\+::\+Segregatable\+FSIProblem\+::unsteady\+\_\+segregated\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_ae015f3c07e2218748b347f42abe45da1}\label{classoomph_1_1Problem_ae015f3c07e2218748b347f42abe45da1}} 
\index{oomph::Problem@{oomph::Problem}!operator=@{operator=}}
\index{operator=@{operator=}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::operator= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}



Broken assignment operator. 

\mbox{\Hypertarget{classoomph_1_1Problem_aaad4443f87f3f3affe53fa9160802e7c}\label{classoomph_1_1Problem_aaad4443f87f3f3affe53fa9160802e7c}} 
\index{oomph::Problem@{oomph::Problem}!p\_adapt@{p\_adapt}}
\index{p\_adapt@{p\_adapt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_adapt()}{p\_adapt()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+adapt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



p-\/adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on their own error estimates and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. On return from this function, \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} can immediately be solved again. \mbox{[}Argument-\/free wrapper\mbox{]} 



Definition at line 3010 of file problem.\+h.

\mbox{\Hypertarget{classoomph_1_1Problem_a1303b2fde2fe84b71519cadabc18f868}\label{classoomph_1_1Problem_a1303b2fde2fe84b71519cadabc18f868}} 
\index{oomph::Problem@{oomph::Problem}!p\_adapt@{p\_adapt}}
\index{p\_adapt@{p\_adapt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_adapt()}{p\_adapt()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+adapt (\begin{DoxyParamCaption}\item[{unsigned \&}]{n\+\_\+refined,  }\item[{unsigned \&}]{n\+\_\+unrefined }\end{DoxyParamCaption})}



p-\/adapt problem\+: Perform mesh adaptation for (all) refineable (sub)mesh(es), based on their own error estimates and the target errors specified in the mesh(es). Following mesh adaptation, update global mesh, and re-\/assign equation numbers. Return \# of refined/unrefined elements. On return from this function, \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} can immediately be solved again. 



Definition at line 14436 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), Assembly\+\_\+handler\+\_\+pt, assign\+\_\+eqn\+\_\+numbers(), bifurcation\+\_\+adapt\+\_\+helper(), oomph\+::\+Assembly\+Handler\+::bifurcation\+\_\+type(), oomph\+::\+Global\+\_\+timings\+::\+Doc\+\_\+comprehensive\+\_\+timings, oomph\+::\+Error\+Estimator\+::get\+\_\+element\+\_\+errors(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, rebuild\+\_\+global\+\_\+mesh(), and oomph\+::\+Timing\+Helpers\+::timer().

\mbox{\Hypertarget{classoomph_1_1Problem_a044b3cb5ffc2953c1990bd602567b99a}\label{classoomph_1_1Problem_a044b3cb5ffc2953c1990bd602567b99a}} 
\index{oomph::Problem@{oomph::Problem}!p\_refine\_selected\_elements@{p\_refine\_selected\_elements}}
\index{p\_refine\_selected\_elements@{p\_refine\_selected\_elements}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_refine\_selected\_elements()}{p\_refine\_selected\_elements()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+refine\+\_\+selected\+\_\+elements (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i\+\_\+mesh,  }\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1PRefineableElement}{PRefineable\+Element}} $\ast$ $>$ \&}]{elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt }\end{DoxyParamCaption})}



p-\/refine specified submesh by refining the elements identified by their pointers, then rebuild the problem. 



Definition at line 15498 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, and rebuild\+\_\+global\+\_\+mesh().

\mbox{\Hypertarget{classoomph_1_1Problem_a86f7b013945049548f86377e489e23f1}\label{classoomph_1_1Problem_a86f7b013945049548f86377e489e23f1}} 
\index{oomph::Problem@{oomph::Problem}!p\_refine\_selected\_elements@{p\_refine\_selected\_elements}}
\index{p\_refine\_selected\_elements@{p\_refine\_selected\_elements}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_refine\_selected\_elements()}{p\_refine\_selected\_elements()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+refine\+\_\+selected\+\_\+elements (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i\+\_\+mesh,  }\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{elements\+\_\+to\+\_\+be\+\_\+refined }\end{DoxyParamCaption})}



p-\/refine specified submesh by refining the elements identified by their numbers relative to the submesh, then rebuild the problem. 

p-\/refine specified submesh by refining the elements identified by their numbers relative to the specified mesh, then rebuild the problem. 

Definition at line 15446 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, and rebuild\+\_\+global\+\_\+mesh().

\mbox{\Hypertarget{classoomph_1_1Problem_afd17da2aa90d68c4fb5120c90b2435d9}\label{classoomph_1_1Problem_afd17da2aa90d68c4fb5120c90b2435d9}} 
\index{oomph::Problem@{oomph::Problem}!p\_refine\_selected\_elements@{p\_refine\_selected\_elements}}
\index{p\_refine\_selected\_elements@{p\_refine\_selected\_elements}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_refine\_selected\_elements()}{p\_refine\_selected\_elements()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+refine\+\_\+selected\+\_\+elements (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1PRefineableElement}{PRefineable\+Element}} $\ast$ $>$ \&}]{elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt }\end{DoxyParamCaption})}



p-\/refine (one and only!) mesh by refining the elements identified by their pointers, then rebuild the problem. 



Definition at line 15399 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), and oomph\+::oomph\+\_\+info.

\mbox{\Hypertarget{classoomph_1_1Problem_a2042cdd88af58eedc66bfaf29b370ff1}\label{classoomph_1_1Problem_a2042cdd88af58eedc66bfaf29b370ff1}} 
\index{oomph::Problem@{oomph::Problem}!p\_refine\_selected\_elements@{p\_refine\_selected\_elements}}
\index{p\_refine\_selected\_elements@{p\_refine\_selected\_elements}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_refine\_selected\_elements()}{p\_refine\_selected\_elements()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+refine\+\_\+selected\+\_\+elements (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{elements\+\_\+to\+\_\+be\+\_\+refined }\end{DoxyParamCaption})}



p-\/refine (one and only!) mesh by refining the elements identified by their numbers relative to the problems\textquotesingle{} only mesh, then rebuild the problem. 



Definition at line 15352 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), and oomph\+::oomph\+\_\+info.

\mbox{\Hypertarget{classoomph_1_1Problem_aa7af48e91e943fb43fce31aa5bdeb505}\label{classoomph_1_1Problem_aa7af48e91e943fb43fce31aa5bdeb505}} 
\index{oomph::Problem@{oomph::Problem}!p\_refine\_selected\_elements@{p\_refine\_selected\_elements}}
\index{p\_refine\_selected\_elements@{p\_refine\_selected\_elements}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_refine\_selected\_elements()}{p\_refine\_selected\_elements()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+refine\+\_\+selected\+\_\+elements (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1PRefineableElement}{PRefineable\+Element}} $\ast$ $>$$>$ \&}]{elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt }\end{DoxyParamCaption})}



p-\/refine all submeshes by refining the elements identified by their pointers within each submesh in a \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of Vectors, then rebuild the problem. 



Definition at line 15593 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, and rebuild\+\_\+global\+\_\+mesh().

\mbox{\Hypertarget{classoomph_1_1Problem_aef2b3bac619ee8270dfcd5f9f334501c}\label{classoomph_1_1Problem_aef2b3bac619ee8270dfcd5f9f334501c}} 
\index{oomph::Problem@{oomph::Problem}!p\_refine\_selected\_elements@{p\_refine\_selected\_elements}}
\index{p\_refine\_selected\_elements@{p\_refine\_selected\_elements}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_refine\_selected\_elements()}{p\_refine\_selected\_elements()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+refine\+\_\+selected\+\_\+elements (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$$>$ \&}]{elements\+\_\+to\+\_\+be\+\_\+refined }\end{DoxyParamCaption})}



p-\/refine all submeshes by refining the elements identified by their numbers relative to each submesh in a \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of Vectors, then rebuild the problem. 



Definition at line 15551 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, and rebuild\+\_\+global\+\_\+mesh().

\mbox{\Hypertarget{classoomph_1_1Problem_ada439afd4d195644e53d6bdbc4b00587}\label{classoomph_1_1Problem_ada439afd4d195644e53d6bdbc4b00587}} 
\index{oomph::Problem@{oomph::Problem}!p\_refine\_uniformly@{p\_refine\_uniformly}}
\index{p\_refine\_uniformly@{p\_refine\_uniformly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_refine\_uniformly()}{p\_refine\_uniformly()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+refine\+\_\+uniformly (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



p-\/refine (all) p-\/refineable (sub)mesh(es) uniformly and rebuild problem 



Definition at line 2866 of file problem.\+h.



References oomph\+::\+Doc\+Info\+::disable\+\_\+doc().



Referenced by p\+\_\+refine\+\_\+uniformly().

\mbox{\Hypertarget{classoomph_1_1Problem_a33dbab01dfa53e4d005818a2940085b0}\label{classoomph_1_1Problem_a33dbab01dfa53e4d005818a2940085b0}} 
\index{oomph::Problem@{oomph::Problem}!p\_refine\_uniformly@{p\_refine\_uniformly}}
\index{p\_refine\_uniformly@{p\_refine\_uniformly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_refine\_uniformly()}{p\_refine\_uniformly()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+refine\+\_\+uniformly (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i\+\_\+mesh }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Do uniform p-\/refinement for submesh i\+\_\+mesh without documentation. 



Definition at line 2877 of file problem.\+h.



References oomph\+::\+Doc\+Info\+::disable\+\_\+doc(), and p\+\_\+refine\+\_\+uniformly().

\mbox{\Hypertarget{classoomph_1_1Problem_a04fed27f341b9eb68b5fb3e4673f26f9}\label{classoomph_1_1Problem_a04fed27f341b9eb68b5fb3e4673f26f9}} 
\index{oomph::Problem@{oomph::Problem}!p\_refine\_uniformly@{p\_refine\_uniformly}}
\index{p\_refine\_uniformly@{p\_refine\_uniformly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_refine\_uniformly()}{p\_refine\_uniformly()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+refine\+\_\+uniformly (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i\+\_\+mesh,  }\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info }\end{DoxyParamCaption})}



Do uniform p-\/refinement for submesh i\+\_\+mesh with documentation. 

p-\/refine submesh i\+\_\+mesh uniformly and rebuild problem; doc refinement process. 

Definition at line 15977 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, and rebuild\+\_\+global\+\_\+mesh().

\mbox{\Hypertarget{classoomph_1_1Problem_a3aaea4b1be43f5d4bb187a8c6d3ca16f}\label{classoomph_1_1Problem_a3aaea4b1be43f5d4bb187a8c6d3ca16f}} 
\index{oomph::Problem@{oomph::Problem}!p\_refine\_uniformly@{p\_refine\_uniformly}}
\index{p\_refine\_uniformly@{p\_refine\_uniformly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_refine\_uniformly()}{p\_refine\_uniformly()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+refine\+\_\+uniformly (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nrefine\+\_\+for\+\_\+mesh }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



p-\/refine p-\/refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem 



Definition at line 2789 of file problem.\+h.



References oomph\+::\+Doc\+Info\+::disable\+\_\+doc(), and p\+\_\+refine\+\_\+uniformly\+\_\+aux().

\mbox{\Hypertarget{classoomph_1_1Problem_a0a980d9659db60b113b6d4e7431594b7}\label{classoomph_1_1Problem_a0a980d9659db60b113b6d4e7431594b7}} 
\index{oomph::Problem@{oomph::Problem}!p\_refine\_uniformly@{p\_refine\_uniformly}}
\index{p\_refine\_uniformly@{p\_refine\_uniformly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_refine\_uniformly()}{p\_refine\_uniformly()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+refine\+\_\+uniformly (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nrefine\+\_\+for\+\_\+mesh,  }\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



p-\/refine p-\/refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem; doc refinement process 



Definition at line 2799 of file problem.\+h.



References p\+\_\+refine\+\_\+uniformly\+\_\+aux().

\mbox{\Hypertarget{classoomph_1_1Problem_a355caf4c06c3b8b5d399115048453921}\label{classoomph_1_1Problem_a355caf4c06c3b8b5d399115048453921}} 
\index{oomph::Problem@{oomph::Problem}!p\_refine\_uniformly@{p\_refine\_uniformly}}
\index{p\_refine\_uniformly@{p\_refine\_uniformly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_refine\_uniformly()}{p\_refine\_uniformly()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+refine\+\_\+uniformly (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



p-\/refine (all) p-\/refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process. 



Definition at line 2836 of file problem.\+h.



References nsub\+\_\+mesh(), and p\+\_\+refine\+\_\+uniformly().

\mbox{\Hypertarget{classoomph_1_1Problem_a5155b2d5436a95b1ee27f914b4eb8f08}\label{classoomph_1_1Problem_a5155b2d5436a95b1ee27f914b4eb8f08}} 
\index{oomph::Problem@{oomph::Problem}!p\_refine\_uniformly\_and\_prune@{p\_refine\_uniformly\_and\_prune}}
\index{p\_refine\_uniformly\_and\_prune@{p\_refine\_uniformly\_and\_prune}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_refine\_uniformly\_and\_prune()}{p\_refine\_uniformly\_and\_prune()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+refine\+\_\+uniformly\+\_\+and\+\_\+prune (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nrefine\+\_\+for\+\_\+mesh }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



p-\/refine p-\/refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem. Prune after refinements 



Definition at line 2809 of file problem.\+h.



References oomph\+::\+Doc\+Info\+::disable\+\_\+doc(), and p\+\_\+refine\+\_\+uniformly\+\_\+aux().



Referenced by p\+\_\+refine\+\_\+uniformly\+\_\+and\+\_\+prune().

\mbox{\Hypertarget{classoomph_1_1Problem_aabfa653ef203edf44cf9b6cf558865e1}\label{classoomph_1_1Problem_aabfa653ef203edf44cf9b6cf558865e1}} 
\index{oomph::Problem@{oomph::Problem}!p\_refine\_uniformly\_and\_prune@{p\_refine\_uniformly\_and\_prune}}
\index{p\_refine\_uniformly\_and\_prune@{p\_refine\_uniformly\_and\_prune}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_refine\_uniformly\_and\_prune()}{p\_refine\_uniformly\_and\_prune()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+refine\+\_\+uniformly\+\_\+and\+\_\+prune (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nrefine\+\_\+for\+\_\+mesh,  }\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



p-\/refine p-\/refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem; doc refinement process 



Definition at line 2823 of file problem.\+h.



References p\+\_\+refine\+\_\+uniformly\+\_\+aux().

\mbox{\Hypertarget{classoomph_1_1Problem_a80ff24a4fc923660f2aabfaa763822bf}\label{classoomph_1_1Problem_a80ff24a4fc923660f2aabfaa763822bf}} 
\index{oomph::Problem@{oomph::Problem}!p\_refine\_uniformly\_and\_prune@{p\_refine\_uniformly\_and\_prune}}
\index{p\_refine\_uniformly\_and\_prune@{p\_refine\_uniformly\_and\_prune}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_refine\_uniformly\_and\_prune()}{p\_refine\_uniformly\_and\_prune()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+refine\+\_\+uniformly\+\_\+and\+\_\+prune (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



p-\/refine (all) p-\/refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process. 



Definition at line 2849 of file problem.\+h.



References nsub\+\_\+mesh(), and p\+\_\+refine\+\_\+uniformly\+\_\+and\+\_\+prune().

\mbox{\Hypertarget{classoomph_1_1Problem_a9e598cc12a894db00bfe62d87a0ff41b}\label{classoomph_1_1Problem_a9e598cc12a894db00bfe62d87a0ff41b}} 
\index{oomph::Problem@{oomph::Problem}!p\_refine\_uniformly\_aux@{p\_refine\_uniformly\_aux}}
\index{p\_refine\_uniformly\_aux@{p\_refine\_uniformly\_aux}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_refine\_uniformly\_aux()}{p\_refine\_uniformly\_aux()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+refine\+\_\+uniformly\+\_\+aux (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nrefine\+\_\+for\+\_\+mesh,  }\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info,  }\item[{const bool \&}]{prune }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Helper function to do compund p-\/refinement of (all) p-\/refineable (sub)mesh(es) uniformly as many times as specified in vector and rebuild problem; doc refinement process. Set boolean argument to true if you want to prune immediately after refining the meshes individually. 



Definition at line 15785 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), Bypass\+\_\+increase\+\_\+in\+\_\+dof\+\_\+check\+\_\+during\+\_\+pruning, oomph\+::\+Global\+\_\+timings\+::\+Doc\+\_\+comprehensive\+\_\+timings, i, mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes(), rebuild\+\_\+global\+\_\+mesh(), and oomph\+::\+Timing\+Helpers\+::timer().



Referenced by p\+\_\+refine\+\_\+uniformly(), and p\+\_\+refine\+\_\+uniformly\+\_\+and\+\_\+prune().

\mbox{\Hypertarget{classoomph_1_1Problem_a706a2845212ece5535260cca6301653d}\label{classoomph_1_1Problem_a706a2845212ece5535260cca6301653d}} 
\index{oomph::Problem@{oomph::Problem}!p\_unrefine\_uniformly@{p\_unrefine\_uniformly}}
\index{p\_unrefine\_uniformly@{p\_unrefine\_uniformly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_unrefine\_uniformly()}{p\_unrefine\_uniformly()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+unrefine\+\_\+uniformly (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i\+\_\+mesh,  }\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info }\end{DoxyParamCaption})}



Do uniform p-\/unrefinement for submesh i\+\_\+mesh without documentation. 

p-\/unrefine submesh i\+\_\+mesh uniformly and rebuild problem; doc refinement process. 

Definition at line 16212 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, and rebuild\+\_\+global\+\_\+mesh().

\mbox{\Hypertarget{classoomph_1_1Problem_a21d8f0ff6813b09f35acbc7a76232397}\label{classoomph_1_1Problem_a21d8f0ff6813b09f35acbc7a76232397}} 
\index{oomph::Problem@{oomph::Problem}!p\_unrefine\_uniformly@{p\_unrefine\_uniformly}}
\index{p\_unrefine\_uniformly@{p\_unrefine\_uniformly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{p\_unrefine\_uniformly()}{p\_unrefine\_uniformly()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::p\+\_\+unrefine\+\_\+uniformly (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info }\end{DoxyParamCaption})}



p-\/unrefine (all) p-\/refineable (sub)mesh(es) uniformly and rebuild problem. 

p-\/unrefine (all) p-\/refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process. 

Definition at line 16153 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, and rebuild\+\_\+global\+\_\+mesh().

\mbox{\Hypertarget{classoomph_1_1Problem_a0487a7ef40e6cc4dad88e99ac96193e2}\label{classoomph_1_1Problem_a0487a7ef40e6cc4dad88e99ac96193e2}} 
\index{oomph::Problem@{oomph::Problem}!parallel\_sparse\_assemble@{parallel\_sparse\_assemble}}
\index{parallel\_sparse\_assemble@{parallel\_sparse\_assemble}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{parallel\_sparse\_assemble()}{parallel\_sparse\_assemble()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::parallel\+\_\+sparse\+\_\+assemble (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution}} $\ast$const \&}]{dist\+\_\+pt,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&}]{column\+\_\+or\+\_\+row\+\_\+index,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&}]{row\+\_\+or\+\_\+column\+\_\+start,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&}]{value,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nnz,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&}]{residuals }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Helper method to assemble CRDouble\+Matrices from distributed on multiple processors. 



Definition at line 6533 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, assembly\+\_\+handler\+\_\+pt(), Communicator\+\_\+pt, communicator\+\_\+pt(), Doc\+\_\+imbalance\+\_\+in\+\_\+parallel\+\_\+assembly, e, oomph\+::\+Mesh\+::element\+\_\+pt(), Elemental\+\_\+assembly\+\_\+time, oomph\+::\+Assembly\+Handler\+::eqn\+\_\+number(), First\+\_\+el\+\_\+for\+\_\+assembly, oomph\+::\+Linear\+Algebra\+Distribution\+::first\+\_\+row(), oomph\+::\+Assembly\+Handler\+::get\+\_\+all\+\_\+vectors\+\_\+and\+\_\+matrices(), get\+\_\+my\+\_\+eqns(), i, oomph\+::\+Generalised\+Element\+::is\+\_\+halo(), Last\+\_\+el\+\_\+plus\+\_\+one\+\_\+for\+\_\+assembly, mesh\+\_\+pt(), Must\+\_\+recompute\+\_\+load\+\_\+balance\+\_\+for\+\_\+assembly, oomph\+::\+Assembly\+Handler\+::ndof(), oomph\+::\+Mesh\+::nelement(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow\+\_\+local(), Numerical\+\_\+zero\+\_\+for\+\_\+sparse\+\_\+assembly, oomph\+::oomph\+\_\+info, Parallel\+\_\+sparse\+\_\+assemble\+\_\+previous\+\_\+allocation, Problem\+\_\+has\+\_\+been\+\_\+distributed, oomph\+::\+Linear\+Algebra\+Distribution\+::rank\+\_\+of\+\_\+global\+\_\+row(), recompute\+\_\+load\+\_\+balanced\+\_\+assembly(), Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+allocation\+\_\+increment, Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+initial\+\_\+allocation, Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+previous\+\_\+allocation, t, and oomph\+::\+Timing\+Helpers\+::timer().



Referenced by get\+\_\+eigenproblem\+\_\+matrices(), get\+\_\+jacobian(), and get\+\_\+residuals().

\mbox{\Hypertarget{classoomph_1_1Problem_ad29fc4bc4d4bead472059765fbbd3b11}\label{classoomph_1_1Problem_ad29fc4bc4d4bead472059765fbbd3b11}} 
\index{oomph::Problem@{oomph::Problem}!partition\_global\_mesh@{partition\_global\_mesh}}
\index{partition\_global\_mesh@{partition\_global\_mesh}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{partition\_global\_mesh()}{partition\_global\_mesh()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::partition\+\_\+global\+\_\+mesh (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$\&}]{global\+\_\+mesh\+\_\+pt,  }\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{element\+\_\+domain,  }\item[{const bool \&}]{report\+\_\+stats = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Partition the global mesh, return vector specifying the processor number for each element. Virtual so that it can be overloaded by any user; the default is to use \mbox{\hyperlink{namespaceoomph_1_1METIS}{METIS}} to perform the partitioning (with a bit of cleaning up afterwards to sort out \char`\"{}special cases\char`\"{}). 



Definition at line 964 of file problem.\+cc.



References communicator\+\_\+pt(), oomph\+::\+Doc\+Info\+::directory(), e, oomph\+::\+Doc\+Info\+::is\+\_\+doc\+\_\+enabled(), oomph\+::\+Doc\+Info\+::number(), oomph\+::oomph\+\_\+info, oomph\+::\+Mesh\+::output(), and oomph\+::\+METIS\+::partition\+\_\+mesh().



Referenced by distribute().

\mbox{\Hypertarget{classoomph_1_1Problem_aa44439175e6899a1a6c125f08b786301}\label{classoomph_1_1Problem_aa44439175e6899a1a6c125f08b786301}} 
\index{oomph::Problem@{oomph::Problem}!problem\_has\_been\_distributed@{problem\_has\_been\_distributed}}
\index{problem\_has\_been\_distributed@{problem\_has\_been\_distributed}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{problem\_has\_been\_distributed()}{problem\_has\_been\_distributed()}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::problem\+\_\+has\+\_\+been\+\_\+distributed (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access to Problem\+\_\+has\+\_\+been\+\_\+distributed flag. 



Definition at line 2307 of file problem.\+h.



References Problem\+\_\+has\+\_\+been\+\_\+distributed.



Referenced by oomph\+::\+Multi\+\_\+domain\+\_\+functions\+::aux\+\_\+setup\+\_\+multi\+\_\+domain\+\_\+interaction(), and oomph\+::\+Solid\+ICProblem\+::set\+\_\+static\+\_\+initial\+\_\+condition().

\mbox{\Hypertarget{classoomph_1_1Problem_a92acc3c193a38f321fc318fafd142f7a}\label{classoomph_1_1Problem_a92acc3c193a38f321fc318fafd142f7a}} 
\index{oomph::Problem@{oomph::Problem}!problem\_is\_nonlinear@{problem\_is\_nonlinear}}
\index{problem\_is\_nonlinear@{problem\_is\_nonlinear}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{problem\_is\_nonlinear()}{problem\_is\_nonlinear()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::problem\+\_\+is\+\_\+nonlinear (\begin{DoxyParamCaption}\item[{const bool \&}]{prob\+\_\+lin }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access function to Problem\+\_\+is\+\_\+nonlinear. 



Definition at line 1600 of file problem.\+h.



References Problem\+\_\+is\+\_\+nonlinear.

\mbox{\Hypertarget{classoomph_1_1Problem_a977f74f132157959d30e82cfcad41a97}\label{classoomph_1_1Problem_a977f74f132157959d30e82cfcad41a97}} 
\index{oomph::Problem@{oomph::Problem}!prune\_halo\_elements\_and\_nodes@{prune\_halo\_elements\_and\_nodes}}
\index{prune\_halo\_elements\_and\_nodes@{prune\_halo\_elements\_and\_nodes}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{prune\_halo\_elements\_and\_nodes()}{prune\_halo\_elements\_and\_nodes()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes (\begin{DoxyParamCaption}\item[{const bool \&}]{report\+\_\+stats = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



(Irreversibly) prune halo(ed) elements and nodes, usually after another round of refinement, to get rid of excessively wide halo layers. Note that the current mesh will be now regarded as the base mesh and no unrefinement relative to it will be possible once this function has been called. 



Definition at line 2296 of file problem.\+h.



References oomph\+::\+Doc\+Info\+::disable\+\_\+doc(), and prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes().

\mbox{\Hypertarget{classoomph_1_1Problem_a8c5982a9323392e31a166e23a0c7f0a3}\label{classoomph_1_1Problem_a8c5982a9323392e31a166e23a0c7f0a3}} 
\index{oomph::Problem@{oomph::Problem}!prune\_halo\_elements\_and\_nodes@{prune\_halo\_elements\_and\_nodes}}
\index{prune\_halo\_elements\_and\_nodes@{prune\_halo\_elements\_and\_nodes}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{prune\_halo\_elements\_and\_nodes()}{prune\_halo\_elements\_and\_nodes()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info,  }\item[{const bool \&}]{report\+\_\+stats }\end{DoxyParamCaption})}



(Irreversibly) prune halo(ed) elements and nodes, usually after another round of refinement, to get rid of excessively wide halo layers. Note that the current mesh will be now regarded as the base mesh and no unrefinement relative to it will be possible once this function has been called. 



Definition at line 1139 of file problem.\+cc.



References actions\+\_\+after\+\_\+distribute(), actions\+\_\+before\+\_\+distribute(), assign\+\_\+eqn\+\_\+numbers(), Base\+\_\+mesh\+\_\+element\+\_\+number\+\_\+plus\+\_\+one, Base\+\_\+mesh\+\_\+element\+\_\+pt, Bypass\+\_\+increase\+\_\+in\+\_\+dof\+\_\+check\+\_\+during\+\_\+pruning, communicator\+\_\+pt(), oomph\+::\+Global\+\_\+timings\+::\+Doc\+\_\+comprehensive\+\_\+timings, e, oomph\+::\+Mesh\+::element\+\_\+pt(), oomph\+::\+Generalised\+Element\+::is\+\_\+halo(), mesh\+\_\+pt(), ndof(), oomph\+::\+Mesh\+::nelement(), nsub\+\_\+mesh(), oomph\+::\+Tree\+::object\+\_\+pt(), oomph\+::oomph\+\_\+info, Problem\+\_\+has\+\_\+been\+\_\+distributed, oomph\+::\+Mesh\+::prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes(), rebuild\+\_\+global\+\_\+mesh(), oomph\+::\+Tree\+::root\+\_\+pt(), setup\+\_\+base\+\_\+mesh\+\_\+info\+\_\+after\+\_\+pruning(), oomph\+::\+Tree\+::stick\+\_\+all\+\_\+tree\+\_\+nodes\+\_\+into\+\_\+vector(), t, oomph\+::\+Timing\+Helpers\+::timer(), and oomph\+::\+Refineable\+Element\+::tree\+\_\+pt().



Referenced by p\+\_\+refine\+\_\+uniformly\+\_\+aux(), prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes(), read(), and refine\+\_\+uniformly\+\_\+aux().

\mbox{\Hypertarget{classoomph_1_1Problem_a561320c1b8deb3540d260c6c2c5f4fb4}\label{classoomph_1_1Problem_a561320c1b8deb3540d260c6c2c5f4fb4}} 
\index{oomph::Problem@{oomph::Problem}!read@{read}}
\index{read@{read}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{read()}{read()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::read (\begin{DoxyParamCaption}\item[{std\+::ifstream \&}]{restart\+\_\+file }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Read refinement pattern of all refineable meshes and refine them accordingly, then read all \mbox{\hyperlink{classoomph_1_1Data}{Data}} and nodal position info from file for restart. 



Definition at line 2195 of file problem.\+h.



References read().

\mbox{\Hypertarget{classoomph_1_1Problem_ae27a3057515ddaa60d2ecc684d517e8f}\label{classoomph_1_1Problem_ae27a3057515ddaa60d2ecc684d517e8f}} 
\index{oomph::Problem@{oomph::Problem}!read@{read}}
\index{read@{read}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{read()}{read()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::read (\begin{DoxyParamCaption}\item[{std\+::ifstream \&}]{restart\+\_\+file,  }\item[{bool \&}]{unsteady\+\_\+restart }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Read refinement pattern of all refineable meshes and refine them accordingly, then read all \mbox{\hyperlink{classoomph_1_1Data}{Data}} and nodal position info from file for restart. Return flag to indicate if the restart was from steady or unsteady solution. 



Definition at line 12444 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+after\+\_\+read\+\_\+unstructured\+\_\+meshes(), actions\+\_\+before\+\_\+adapt(), actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes(), assign\+\_\+eqn\+\_\+numbers(), Base\+\_\+mesh\+\_\+element\+\_\+number\+\_\+plus\+\_\+one, Base\+\_\+mesh\+\_\+element\+\_\+pt, oomph\+::\+Face\+Element\+::bulk\+\_\+element\+\_\+pt(), Communicator\+\_\+pt, communicator\+\_\+pt(), oomph\+::\+Doc\+Info\+::disable\+\_\+doc(), e, oomph\+::\+Mesh\+::element\+\_\+pt(), Empty\+\_\+actions\+\_\+after\+\_\+read\+\_\+unstructured\+\_\+meshes\+\_\+has\+\_\+been\+\_\+called, Empty\+\_\+actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes\+\_\+has\+\_\+been\+\_\+called, oomph\+::\+Tree\+Based\+Refineable\+Mesh\+Base\+::get\+\_\+refinement\+\_\+levels(), Global\+\_\+data\+\_\+pt, i, initialise\+\_\+dt(), oomph\+::\+Generalised\+Element\+::is\+\_\+halo(), oomph\+::\+Mesh\+::is\+\_\+mesh\+\_\+distributed(), load\+\_\+balance(), mesh\+\_\+pt(), oomph\+::\+Mesh\+::nelement(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, Problem\+\_\+has\+\_\+been\+\_\+distributed, prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes(), oomph\+::\+Mesh\+::read(), oomph\+::\+Triangle\+Mesh\+Base\+::read\+\_\+distributed\+\_\+info\+\_\+for\+\_\+restart(), rebuild\+\_\+global\+\_\+mesh(), oomph\+::\+Triangle\+Mesh\+Base\+::reestablish\+\_\+distribution\+\_\+info\+\_\+for\+\_\+restart(), refine\+\_\+uniformly(), oomph\+::\+Triangle\+Mesh\+Base\+::remesh\+\_\+from\+\_\+triangulateio(), oomph\+::\+Time\+::resize(), oomph\+::\+Global\+\_\+string\+\_\+for\+\_\+annotation\+::string(), Suppress\+\_\+warning\+\_\+about\+\_\+actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes, time(), oomph\+::\+Time\+::time(), time\+\_\+pt(), and oomph\+::\+Triangle\+Mesh\+Base\+::use\+\_\+triangulateio\+\_\+restart().



Referenced by read().

\mbox{\Hypertarget{classoomph_1_1Problem_ac0a0e649f36b4a7ce992888c323d1571}\label{classoomph_1_1Problem_ac0a0e649f36b4a7ce992888c323d1571}} 
\index{oomph::Problem@{oomph::Problem}!rebuild\_global\_mesh@{rebuild\_global\_mesh}}
\index{rebuild\_global\_mesh@{rebuild\_global\_mesh}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{rebuild\_global\_mesh()}{rebuild\_global\_mesh()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::rebuild\+\_\+global\+\_\+mesh (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



If one of the submeshes has changed (e.\+g. by mesh adaptation) we need to update the global mesh. {\bfseries{Note\+:}} The nodes boundary information refers to the boundary numbers within the submesh! 

If one of the submeshes has changed (e.\+g. by mesh adaptation) we need to update the global mesh. {\bfseries{Note\+:}} The nodes boundary information refers to the boundary numbers within the submesh! N.\+B. This is essentially the same function as the \mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} constructor that assembles a single global mesh from submeshes. 

Definition at line 1619 of file problem.\+cc.



References oomph\+::\+Mesh\+::merge\+\_\+meshes(), Mesh\+\_\+pt, and Sub\+\_\+mesh\+\_\+pt.



Referenced by adapt(), adapt\+\_\+based\+\_\+on\+\_\+error\+\_\+estimates(), build\+\_\+global\+\_\+mesh(), distribute(), load\+\_\+balance(), p\+\_\+adapt(), p\+\_\+refine\+\_\+selected\+\_\+elements(), p\+\_\+refine\+\_\+uniformly(), p\+\_\+refine\+\_\+uniformly\+\_\+aux(), p\+\_\+unrefine\+\_\+uniformly(), prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes(), read(), oomph\+::\+Segregatable\+FSIProblem\+::rebuild\+\_\+monolithic\+\_\+mesh(), refine\+\_\+distributed\+\_\+base\+\_\+mesh(), refine\+\_\+selected\+\_\+elements(), refine\+\_\+uniformly(), refine\+\_\+uniformly\+\_\+aux(), send\+\_\+data\+\_\+to\+\_\+be\+\_\+sent\+\_\+during\+\_\+load\+\_\+balancing(), unrefine\+\_\+uniformly(), oomph\+::\+Segregatable\+FSIProblem\+::use\+\_\+only\+\_\+fluid\+\_\+elements(), and oomph\+::\+Segregatable\+FSIProblem\+::use\+\_\+only\+\_\+solid\+\_\+elements().

\mbox{\Hypertarget{classoomph_1_1Problem_aa9d808bb5d62db0da8e962fa29c24af9}\label{classoomph_1_1Problem_aa9d808bb5d62db0da8e962fa29c24af9}} 
\index{oomph::Problem@{oomph::Problem}!recompute\_load\_balanced\_assembly@{recompute\_load\_balanced\_assembly}}
\index{recompute\_load\_balanced\_assembly@{recompute\_load\_balanced\_assembly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{recompute\_load\_balanced\_assembly()}{recompute\_load\_balanced\_assembly()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::recompute\+\_\+load\+\_\+balanced\+\_\+assembly (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Helper function to re-\/assign the first and last elements to be assembled by each processor during parallel assembly for non-\/distributed problem. 



Definition at line 1775 of file problem.\+cc.



References communicator\+\_\+pt(), e, Elemental\+\_\+assembly\+\_\+time, First\+\_\+el\+\_\+for\+\_\+assembly, Last\+\_\+el\+\_\+plus\+\_\+one\+\_\+for\+\_\+assembly, Mesh\+\_\+pt, oomph\+::\+Mesh\+::nelement(), oomph\+::oomph\+\_\+info, Shut\+\_\+up\+\_\+in\+\_\+newton\+\_\+solve, and Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+previous\+\_\+allocation.



Referenced by parallel\+\_\+sparse\+\_\+assemble(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+lists(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+maps(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+vectors(), and sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+vectors\+\_\+of\+\_\+pairs().

\mbox{\Hypertarget{classoomph_1_1Problem_a65aef9c70c2f3b24ed4c9893a1236afe}\label{classoomph_1_1Problem_a65aef9c70c2f3b24ed4c9893a1236afe}} 
\index{oomph::Problem@{oomph::Problem}!refine\_distributed\_base\_mesh@{refine\_distributed\_base\_mesh}}
\index{refine\_distributed\_base\_mesh@{refine\_distributed\_base\_mesh}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_distributed\_base\_mesh()}{refine\_distributed\_base\_mesh()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+distributed\+\_\+base\+\_\+mesh (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$$>$$>$ \&}]{to\+\_\+be\+\_\+refined\+\_\+on\+\_\+each\+\_\+root,  }\item[{const unsigned \&}]{max\+\_\+level\+\_\+overall }\end{DoxyParamCaption})}



Load balance helper routine\+: refine each new base (sub)mesh based upon the elements to be refined within each tree at each root on the current processor. 

Load balance helper routine\+: Function performs max\+\_\+level\+\_\+overall successive refinements of the problem\textquotesingle{}s mesh(es) using the following procdure\+: Given ID of root element, root\+\_\+element\+\_\+id, and current refinement level, level, the e-\/th entry in refinement\+\_\+info\+\_\+for\+\_\+root\+\_\+elements\mbox{[}root\+\_\+element\+\_\+id\mbox{]}\mbox{[}level\mbox{]}\mbox{[}e\mbox{]} is equal to 2 if the e-\/th element (using the enumeration when the mesh has been refined to the level-\/th level) is to be refined during the next refinement; it\textquotesingle{}s 1 if it\textquotesingle{}s not to be refined. 

Definition at line 20183 of file problem.\+cc.



References Base\+\_\+mesh\+\_\+element\+\_\+number\+\_\+plus\+\_\+one, e, oomph\+::\+Mesh\+::finite\+\_\+element\+\_\+pt(), mesh\+\_\+pt(), oomph\+::\+Mesh\+::nelement(), nsub\+\_\+mesh(), rebuild\+\_\+global\+\_\+mesh(), and oomph\+::\+Tree\+Based\+Refineable\+Mesh\+Base\+::refine\+\_\+base\+\_\+mesh().



Referenced by load\+\_\+balance().

\mbox{\Hypertarget{classoomph_1_1Problem_a77b480e2299c8526b27b09fa45ac20a9}\label{classoomph_1_1Problem_a77b480e2299c8526b27b09fa45ac20a9}} 
\index{oomph::Problem@{oomph::Problem}!refine\_selected\_elements@{refine\_selected\_elements}}
\index{refine\_selected\_elements@{refine\_selected\_elements}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_selected\_elements()}{refine\_selected\_elements()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+selected\+\_\+elements (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i\+\_\+mesh,  }\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$ $>$ \&}]{elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt }\end{DoxyParamCaption})}



Refine specified submesh by splitting the elements identified by their pointers, then rebuild the problem. 



Definition at line 15230 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, and rebuild\+\_\+global\+\_\+mesh().

\mbox{\Hypertarget{classoomph_1_1Problem_af2bd42a9612a31041b9d607340c6d68c}\label{classoomph_1_1Problem_af2bd42a9612a31041b9d607340c6d68c}} 
\index{oomph::Problem@{oomph::Problem}!refine\_selected\_elements@{refine\_selected\_elements}}
\index{refine\_selected\_elements@{refine\_selected\_elements}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_selected\_elements()}{refine\_selected\_elements()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+selected\+\_\+elements (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i\+\_\+mesh,  }\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{elements\+\_\+to\+\_\+be\+\_\+refined }\end{DoxyParamCaption})}



Refine specified submesh by splitting the elements identified by their numbers relative to the submesh, then rebuild the problem. 

Refine specified submesh by splitting the elements identified by their numbers relative to the specified mesh, then rebuild the problem. 

Definition at line 15183 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, and rebuild\+\_\+global\+\_\+mesh().

\mbox{\Hypertarget{classoomph_1_1Problem_abd2274dbc96e0ae3caf20573152d19e7}\label{classoomph_1_1Problem_abd2274dbc96e0ae3caf20573152d19e7}} 
\index{oomph::Problem@{oomph::Problem}!refine\_selected\_elements@{refine\_selected\_elements}}
\index{refine\_selected\_elements@{refine\_selected\_elements}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_selected\_elements()}{refine\_selected\_elements()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+selected\+\_\+elements (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$ $>$ \&}]{elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt }\end{DoxyParamCaption})}



Refine (one and only!) mesh by splitting the elements identified by their pointers, then rebuild the problem. 



Definition at line 15137 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), and oomph\+::oomph\+\_\+info.

\mbox{\Hypertarget{classoomph_1_1Problem_a88bfce034f5b054e78a1c1a15d196aeb}\label{classoomph_1_1Problem_a88bfce034f5b054e78a1c1a15d196aeb}} 
\index{oomph::Problem@{oomph::Problem}!refine\_selected\_elements@{refine\_selected\_elements}}
\index{refine\_selected\_elements@{refine\_selected\_elements}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_selected\_elements()}{refine\_selected\_elements()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+selected\+\_\+elements (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{elements\+\_\+to\+\_\+be\+\_\+refined }\end{DoxyParamCaption})}



Refine (one and only!) mesh by splitting the elements identified by their numbers relative to the problems\textquotesingle{} only mesh, then rebuild the problem. 



Definition at line 15091 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), and oomph\+::oomph\+\_\+info.

\mbox{\Hypertarget{classoomph_1_1Problem_a91e9f1c3973b5f7a701117a6e145cee9}\label{classoomph_1_1Problem_a91e9f1c3973b5f7a701117a6e145cee9}} 
\index{oomph::Problem@{oomph::Problem}!refine\_selected\_elements@{refine\_selected\_elements}}
\index{refine\_selected\_elements@{refine\_selected\_elements}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_selected\_elements()}{refine\_selected\_elements()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+selected\+\_\+elements (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1RefineableElement}{Refineable\+Element}} $\ast$ $>$$>$ \&}]{elements\+\_\+to\+\_\+be\+\_\+refined\+\_\+pt }\end{DoxyParamCaption})}



Refine all submeshes by splitting the elements identified by their pointers within each submesh in a \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of Vectors, then rebuild the problem. 



Definition at line 15315 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, and rebuild\+\_\+global\+\_\+mesh().

\mbox{\Hypertarget{classoomph_1_1Problem_a85ab21d4aa86d5f732b1c1a640186386}\label{classoomph_1_1Problem_a85ab21d4aa86d5f732b1c1a640186386}} 
\index{oomph::Problem@{oomph::Problem}!refine\_selected\_elements@{refine\_selected\_elements}}
\index{refine\_selected\_elements@{refine\_selected\_elements}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_selected\_elements()}{refine\_selected\_elements()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+selected\+\_\+elements (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$$>$ \&}]{elements\+\_\+to\+\_\+be\+\_\+refined }\end{DoxyParamCaption})}



Refine all submeshes by splitting the elements identified by their numbers relative to each submesh in a \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of Vectors, then rebuild the problem. 



Definition at line 15278 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, and rebuild\+\_\+global\+\_\+mesh().

\mbox{\Hypertarget{classoomph_1_1Problem_ade208b7d7d8e866d5ba896f03edb1f9a}\label{classoomph_1_1Problem_ade208b7d7d8e866d5ba896f03edb1f9a}} 
\index{oomph::Problem@{oomph::Problem}!refine\_uniformly@{refine\_uniformly}}
\index{refine\_uniformly@{refine\_uniformly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_uniformly()}{refine\_uniformly()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+uniformly (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Refine (all) refineable (sub)mesh(es) uniformly and rebuild problem. 



Definition at line 2769 of file problem.\+h.



References oomph\+::\+Doc\+Info\+::disable\+\_\+doc().



Referenced by read(), and refine\+\_\+uniformly().

\mbox{\Hypertarget{classoomph_1_1Problem_afae401b74b58d6312da32f153b78047d}\label{classoomph_1_1Problem_afae401b74b58d6312da32f153b78047d}} 
\index{oomph::Problem@{oomph::Problem}!refine\_uniformly@{refine\_uniformly}}
\index{refine\_uniformly@{refine\_uniformly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_uniformly()}{refine\_uniformly()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+uniformly (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i\+\_\+mesh }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Do uniform refinement for submesh i\+\_\+mesh without documentation. 



Definition at line 2780 of file problem.\+h.



References oomph\+::\+Doc\+Info\+::disable\+\_\+doc(), and refine\+\_\+uniformly().

\mbox{\Hypertarget{classoomph_1_1Problem_a74d1904dd72eaf71c015470a23caef5f}\label{classoomph_1_1Problem_a74d1904dd72eaf71c015470a23caef5f}} 
\index{oomph::Problem@{oomph::Problem}!refine\_uniformly@{refine\_uniformly}}
\index{refine\_uniformly@{refine\_uniformly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_uniformly()}{refine\_uniformly()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+uniformly (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i\+\_\+mesh,  }\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info }\end{DoxyParamCaption})}



Do uniform refinement for submesh i\+\_\+mesh with documentation. 

Refine submesh i\+\_\+mesh uniformly and rebuild problem; doc refinement process. 

Definition at line 15933 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, and rebuild\+\_\+global\+\_\+mesh().

\mbox{\Hypertarget{classoomph_1_1Problem_a181fa92838f77bd6b12b531dca222c41}\label{classoomph_1_1Problem_a181fa92838f77bd6b12b531dca222c41}} 
\index{oomph::Problem@{oomph::Problem}!refine\_uniformly@{refine\_uniformly}}
\index{refine\_uniformly@{refine\_uniformly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_uniformly()}{refine\_uniformly()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+uniformly (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nrefine\+\_\+for\+\_\+mesh }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Refine refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem. 



Definition at line 2704 of file problem.\+h.



References oomph\+::\+Doc\+Info\+::disable\+\_\+doc(), and refine\+\_\+uniformly\+\_\+aux().

\mbox{\Hypertarget{classoomph_1_1Problem_a14ca1d18e9aa569a6417c45eef70d3ff}\label{classoomph_1_1Problem_a14ca1d18e9aa569a6417c45eef70d3ff}} 
\index{oomph::Problem@{oomph::Problem}!refine\_uniformly@{refine\_uniformly}}
\index{refine\_uniformly@{refine\_uniformly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_uniformly()}{refine\_uniformly()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+uniformly (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nrefine\+\_\+for\+\_\+mesh,  }\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Refine refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem; doc refinement process. 



Definition at line 2714 of file problem.\+h.



References refine\+\_\+uniformly\+\_\+aux().

\mbox{\Hypertarget{classoomph_1_1Problem_ae4ccf79fde59556d93af947618b6c80b}\label{classoomph_1_1Problem_ae4ccf79fde59556d93af947618b6c80b}} 
\index{oomph::Problem@{oomph::Problem}!refine\_uniformly@{refine\_uniformly}}
\index{refine\_uniformly@{refine\_uniformly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_uniformly()}{refine\_uniformly()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+uniformly (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Refine (all) refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process. 



Definition at line 2743 of file problem.\+h.



References nsub\+\_\+mesh(), and refine\+\_\+uniformly().

\mbox{\Hypertarget{classoomph_1_1Problem_a3930fc0977bdc33f52100e53f5d878d7}\label{classoomph_1_1Problem_a3930fc0977bdc33f52100e53f5d878d7}} 
\index{oomph::Problem@{oomph::Problem}!refine\_uniformly\_and\_prune@{refine\_uniformly\_and\_prune}}
\index{refine\_uniformly\_and\_prune@{refine\_uniformly\_and\_prune}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_uniformly\_and\_prune()}{refine\_uniformly\_and\_prune()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+uniformly\+\_\+and\+\_\+prune (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nrefine\+\_\+for\+\_\+mesh }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Refine refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem. Prune after refinements. 



Definition at line 2724 of file problem.\+h.



References oomph\+::\+Doc\+Info\+::disable\+\_\+doc(), and refine\+\_\+uniformly\+\_\+aux().



Referenced by refine\+\_\+uniformly\+\_\+and\+\_\+prune().

\mbox{\Hypertarget{classoomph_1_1Problem_adea5168244acebb539fa29e36182ced3}\label{classoomph_1_1Problem_adea5168244acebb539fa29e36182ced3}} 
\index{oomph::Problem@{oomph::Problem}!refine\_uniformly\_and\_prune@{refine\_uniformly\_and\_prune}}
\index{refine\_uniformly\_and\_prune@{refine\_uniformly\_and\_prune}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_uniformly\_and\_prune()}{refine\_uniformly\_and\_prune()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+uniformly\+\_\+and\+\_\+prune (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nrefine\+\_\+for\+\_\+mesh,  }\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Refine refineable sub-\/meshes, each as many times as specified in the vector and rebuild problem; doc refinement process. 



Definition at line 2734 of file problem.\+h.



References refine\+\_\+uniformly\+\_\+aux().

\mbox{\Hypertarget{classoomph_1_1Problem_ac0495df29dde90577e4702fcac496684}\label{classoomph_1_1Problem_ac0495df29dde90577e4702fcac496684}} 
\index{oomph::Problem@{oomph::Problem}!refine\_uniformly\_and\_prune@{refine\_uniformly\_and\_prune}}
\index{refine\_uniformly\_and\_prune@{refine\_uniformly\_and\_prune}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_uniformly\_and\_prune()}{refine\_uniformly\_and\_prune()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+uniformly\+\_\+and\+\_\+prune (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Refine (all) refineable (sub)mesh(es) uniformly and rebuild problem; doc refinement process. 



Definition at line 2756 of file problem.\+h.



References nsub\+\_\+mesh(), and refine\+\_\+uniformly\+\_\+and\+\_\+prune().

\mbox{\Hypertarget{classoomph_1_1Problem_a0f86f3d5d65115dca81e10910e11ea19}\label{classoomph_1_1Problem_a0f86f3d5d65115dca81e10910e11ea19}} 
\index{oomph::Problem@{oomph::Problem}!refine\_uniformly\_aux@{refine\_uniformly\_aux}}
\index{refine\_uniformly\_aux@{refine\_uniformly\_aux}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{refine\_uniformly\_aux()}{refine\_uniformly\_aux()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::refine\+\_\+uniformly\+\_\+aux (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nrefine\+\_\+for\+\_\+mesh,  }\item[{\mbox{\hyperlink{classoomph_1_1DocInfo}{Doc\+Info}} \&}]{doc\+\_\+info,  }\item[{const bool \&}]{prune }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Helper function to do compund refinement of (all) refineable (sub)mesh(es) uniformly as many times as specified in vector and rebuild problem; doc refinement process. Set boolean argument to true if you want to prune immediately after refining the meshes individually. 



Definition at line 15638 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), Bypass\+\_\+increase\+\_\+in\+\_\+dof\+\_\+check\+\_\+during\+\_\+pruning, oomph\+::\+Global\+\_\+timings\+::\+Doc\+\_\+comprehensive\+\_\+timings, i, mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes(), rebuild\+\_\+global\+\_\+mesh(), and oomph\+::\+Timing\+Helpers\+::timer().



Referenced by refine\+\_\+uniformly(), and refine\+\_\+uniformly\+\_\+and\+\_\+prune().

\mbox{\Hypertarget{classoomph_1_1Problem_a088570d2600c2e710da2717e9ed35404}\label{classoomph_1_1Problem_a088570d2600c2e710da2717e9ed35404}} 
\index{oomph::Problem@{oomph::Problem}!remove\_duplicate\_data@{remove\_duplicate\_data}}
\index{remove\_duplicate\_data@{remove\_duplicate\_data}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{remove\_duplicate\_data()}{remove\_duplicate\_data()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::remove\+\_\+duplicate\+\_\+data (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}} $\ast$const \&}]{mesh\+\_\+pt,  }\item[{bool \&}]{actually\+\_\+removed\+\_\+some\+\_\+data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Private helper function to remove repeated data in external haloed elements in specified mesh. Bool is true if some data was removed -- this usually requires re-\/running through certain parts of the equation numbering procedure. 

Private helper function to remove repeated data in external haloed elements associated with specified mesh. Bool is true if some data was removed -- this usually requires re-\/running through certain parts of the equation numbering procedure. 

Definition at line 2654 of file problem.\+cc.



References communicator\+\_\+pt(), e, oomph\+::\+Mesh\+::element\+\_\+pt(), oomph\+::\+Data\+::eqn\+\_\+number(), oomph\+::\+Mesh\+::external\+\_\+halo\+\_\+element\+\_\+pt(), oomph\+::\+Node\+::get\+\_\+boundaries\+\_\+pt(), oomph\+::\+Node\+::hanging\+\_\+pt(), i, oomph\+::\+Node\+::is\+\_\+hanging(), oomph\+::\+Hang\+Info\+::master\+\_\+node\+\_\+pt(), oomph\+::\+Hang\+Info\+::master\+\_\+weight(), mesh\+\_\+pt(), oomph\+::\+Node\+::ndim(), oomph\+::\+Mesh\+::nelement(), oomph\+::\+Mesh\+::nexternal\+\_\+halo\+\_\+element(), oomph\+::\+Hang\+Info\+::nmaster(), oomph\+::\+Finite\+Element\+::nnode(), oomph\+::\+Finite\+Element\+::node\+\_\+pt(), oomph\+::\+Mesh\+::null\+\_\+external\+\_\+halo\+\_\+node(), oomph\+::\+Data\+::nvalue(), oomph\+::oomph\+\_\+info, oomph\+::\+Finite\+Element\+::output(), oomph\+::\+Mesh\+::remove\+\_\+boundary\+\_\+node(), oomph\+::\+Hang\+Info\+::set\+\_\+master\+\_\+node\+\_\+pt(), oomph\+::\+Oomph\+Info\+::stream\+\_\+pt(), oomph\+::\+Solid\+Node\+::variable\+\_\+position\+\_\+pt(), and oomph\+::\+Node\+::x().



Referenced by assign\+\_\+eqn\+\_\+numbers().

\mbox{\Hypertarget{classoomph_1_1Problem_aee39a957d45bc474c1f5b27d96c9dcc0}\label{classoomph_1_1Problem_aee39a957d45bc474c1f5b27d96c9dcc0}} 
\index{oomph::Problem@{oomph::Problem}!remove\_null\_pointers\_from\_external\_halo\_node\_storage@{remove\_null\_pointers\_from\_external\_halo\_node\_storage}}
\index{remove\_null\_pointers\_from\_external\_halo\_node\_storage@{remove\_null\_pointers\_from\_external\_halo\_node\_storage}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{remove\_null\_pointers\_from\_external\_halo\_node\_storage()}{remove\_null\_pointers\_from\_external\_halo\_node\_storage()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::remove\+\_\+null\+\_\+pointers\+\_\+from\+\_\+external\+\_\+halo\+\_\+node\+\_\+storage (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Consolidate external halo node storage by removing nulled out pointers in external halo and haloed schemes for all meshes. 



Definition at line 3264 of file problem.\+cc.



References communicator\+\_\+pt(), oomph\+::\+Mesh\+::external\+\_\+halo\+\_\+node\+\_\+pt(), oomph\+::\+Mesh\+::external\+\_\+haloed\+\_\+node\+\_\+pt(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::\+Mesh\+::set\+\_\+external\+\_\+halo\+\_\+node\+\_\+pt(), and oomph\+::\+Mesh\+::set\+\_\+external\+\_\+haloed\+\_\+node\+\_\+pt().



Referenced by assign\+\_\+eqn\+\_\+numbers().

\mbox{\Hypertarget{classoomph_1_1Problem_a6477df6e8184dc78e9d9ff82c7627cef}\label{classoomph_1_1Problem_a6477df6e8184dc78e9d9ff82c7627cef}} 
\index{oomph::Problem@{oomph::Problem}!reset\_arc\_length\_parameters@{reset\_arc\_length\_parameters}}
\index{reset\_arc\_length\_parameters@{reset\_arc\_length\_parameters}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{reset\_arc\_length\_parameters()}{reset\_arc\_length\_parameters()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::reset\+\_\+arc\+\_\+length\+\_\+parameters (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Reset the \char`\"{}internal\char`\"{} arc-\/length continuation parameters, so as to allow continuation in another parameter. N.\+B. The parameters that are reset are the \char`\"{}minimum\char`\"{} that are required, others should perhaps be reset, depending upon the application. 



Definition at line 2538 of file problem.\+h.



References Arc\+\_\+length\+\_\+step\+\_\+taken, Continuation\+\_\+direction, Dof\+\_\+derivative, First\+\_\+jacobian\+\_\+sign\+\_\+change, Parameter\+\_\+derivative, Sign\+\_\+of\+\_\+jacobian, and Theta\+\_\+squared.

\mbox{\Hypertarget{classoomph_1_1Problem_aecb590c73e64b0a85f7bec0053e2c51d}\label{classoomph_1_1Problem_aecb590c73e64b0a85f7bec0053e2c51d}} 
\index{oomph::Problem@{oomph::Problem}!reset\_assembly\_handler\_to\_default@{reset\_assembly\_handler\_to\_default}}
\index{reset\_assembly\_handler\_to\_default@{reset\_assembly\_handler\_to\_default}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{reset\_assembly\_handler\_to\_default()}{reset\_assembly\_handler\_to\_default()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::reset\+\_\+assembly\+\_\+handler\+\_\+to\+\_\+default (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Reset the system to the standard non-\/augemented state. 

Reset the assembly handler to default. 

Definition at line 10468 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, and Default\+\_\+assembly\+\_\+handler\+\_\+pt.



Referenced by activate\+\_\+bifurcation\+\_\+tracking(), activate\+\_\+fold\+\_\+tracking(), activate\+\_\+hopf\+\_\+tracking(), activate\+\_\+pitchfork\+\_\+tracking(), and deactivate\+\_\+bifurcation\+\_\+tracking().

\mbox{\Hypertarget{classoomph_1_1Problem_ad19fe0723fe6356776cfbe28e46ea64b}\label{classoomph_1_1Problem_ad19fe0723fe6356776cfbe28e46ea64b}} 
\index{oomph::Problem@{oomph::Problem}!restore\_dof\_values@{restore\_dof\_values}}
\index{restore\_dof\_values@{restore\_dof\_values}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{restore\_dof\_values()}{restore\_dof\_values()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::restore\+\_\+dof\+\_\+values (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Restore the stored values of the degrees of freedom. 

Restore the saved dofs. 

Definition at line 8833 of file problem.\+cc.



References dof(), Dof\+\_\+distribution\+\_\+pt, Dof\+\_\+pt, ndof(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow\+\_\+local(), Problem\+\_\+has\+\_\+been\+\_\+distributed, and Saved\+\_\+dof\+\_\+pt.



Referenced by calculate\+\_\+predictions().

\mbox{\Hypertarget{classoomph_1_1Problem_acdb76c0b94aa3cc5470ce862d70a8017}\label{classoomph_1_1Problem_acdb76c0b94aa3cc5470ce862d70a8017}} 
\index{oomph::Problem@{oomph::Problem}!self\_test@{self\_test}}
\index{self\_test@{self\_test}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{self\_test()}{self\_test()}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::self\+\_\+test (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Self-\/test\+: Check meshes and global data. Return 0 for OK. 



Definition at line 13469 of file problem.\+cc.



References check\+\_\+halo\+\_\+schemes(), oomph\+::\+Doc\+Info\+::disable\+\_\+doc(), Global\+\_\+data\+\_\+pt, mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, and Problem\+\_\+has\+\_\+been\+\_\+distributed.



Referenced by oomph\+::\+Biharmonic\+Problem$<$ DIM $>$\+::actions\+\_\+before\+\_\+newton\+\_\+solve(), and oomph\+::\+Biharmonic\+Fluid\+Problem$<$ DIM $>$\+::actions\+\_\+before\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a3e07d0acd3499ac7736fba1841ad1cf2}\label{classoomph_1_1Problem_a3e07d0acd3499ac7736fba1841ad1cf2}} 
\index{oomph::Problem@{oomph::Problem}!send\_data\_to\_be\_sent\_during\_load\_balancing@{send\_data\_to\_be\_sent\_during\_load\_balancing}}
\index{send\_data\_to\_be\_sent\_during\_load\_balancing@{send\_data\_to\_be\_sent\_during\_load\_balancing}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{send\_data\_to\_be\_sent\_during\_load\_balancing()}{send\_data\_to\_be\_sent\_during\_load\_balancing()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::send\+\_\+data\+\_\+to\+\_\+be\+\_\+sent\+\_\+during\+\_\+load\+\_\+balancing (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $>$ \&}]{send\+\_\+n,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&}]{send\+\_\+data,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $>$ \&}]{send\+\_\+displacement }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Load balance helper routine\+: Send data to other processors during load balancing. 


\begin{DoxyItemize}
\item send\+\_\+n\+: Input, number of data to be sent to each processor
\item send\+\_\+data\+: Input, storage for all values to be sent to all processors
\item send\+\_\+displacement\+: Input, start location within send\+\_\+data for data to be sent to each processor 
\end{DoxyItemize}

Definition at line 19142 of file problem.\+cc.



References Base\+\_\+mesh\+\_\+element\+\_\+pt, communicator\+\_\+pt(), e, i, oomph\+::\+Boundary\+Node\+Base\+::index\+\_\+of\+\_\+first\+\_\+value\+\_\+assigned\+\_\+by\+\_\+face\+\_\+element\+\_\+pt(), oomph\+::\+Finite\+Element\+::nnode(), oomph\+::\+Finite\+Element\+::node\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::\+Data\+::nvalue(), oomph\+::\+Generalised\+Element\+::read\+\_\+internal\+\_\+data\+\_\+values\+\_\+from\+\_\+vector(), oomph\+::\+Node\+::read\+\_\+values\+\_\+from\+\_\+vector(), rebuild\+\_\+global\+\_\+mesh(), oomph\+::\+Node\+::resize(), oomph\+::\+Tree\+::stick\+\_\+leaves\+\_\+into\+\_\+vector(), synchronise\+\_\+dofs(), and oomph\+::\+Refineable\+Element\+::tree\+\_\+pt().



Referenced by load\+\_\+balance().

\mbox{\Hypertarget{classoomph_1_1Problem_adf8cf244cf218c429e69f3728ef294b0}\label{classoomph_1_1Problem_adf8cf244cf218c429e69f3728ef294b0}} 
\index{oomph::Problem@{oomph::Problem}!send\_refinement\_info\_helper@{send\_refinement\_info\_helper}}
\index{send\_refinement\_info\_helper@{send\_refinement\_info\_helper}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{send\_refinement\_info\_helper()}{send\_refinement\_info\_helper()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::send\+\_\+refinement\+\_\+info\+\_\+helper (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{old\+\_\+domain\+\_\+for\+\_\+base\+\_\+element,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{new\+\_\+domain\+\_\+for\+\_\+base\+\_\+element,  }\item[{const unsigned \&}]{max\+\_\+refinement\+\_\+level\+\_\+overall,  }\item[{std\+::map$<$ unsigned, \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$$>$ \&}]{refinement\+\_\+info\+\_\+for\+\_\+root\+\_\+local,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$$>$$>$ \&}]{refinement\+\_\+info\+\_\+for\+\_\+root\+\_\+elements }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Send refinement information between processors. 



Definition at line 18521 of file problem.\+cc.



References Base\+\_\+mesh\+\_\+element\+\_\+number\+\_\+plus\+\_\+one, communicator\+\_\+pt(), e, oomph\+::\+Mesh\+::haloed\+\_\+element\+\_\+pt(), mesh\+\_\+pt(), and nsub\+\_\+mesh().



Referenced by load\+\_\+balance().

\mbox{\Hypertarget{classoomph_1_1Problem_aecef49e98bbcede9b8c3137592c2cc5a}\label{classoomph_1_1Problem_aecef49e98bbcede9b8c3137592c2cc5a}} 
\index{oomph::Problem@{oomph::Problem}!set\_analytic\_dparameter@{set\_analytic\_dparameter}}
\index{set\_analytic\_dparameter@{set\_analytic\_dparameter}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{set\_analytic\_dparameter()}{set\_analytic\_dparameter()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::set\+\_\+analytic\+\_\+dparameter (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Function to turn on analytic calculation of the parameter derivatives in continuation and bifurcation detection problems. 



Definition at line 256 of file problem.\+h.



References Calculate\+\_\+dparameter\+\_\+analytic.

\mbox{\Hypertarget{classoomph_1_1Problem_a45f64c33501e0f9c65927eefed253eef}\label{classoomph_1_1Problem_a45f64c33501e0f9c65927eefed253eef}} 
\index{oomph::Problem@{oomph::Problem}!set\_analytic\_hessian\_products@{set\_analytic\_hessian\_products}}
\index{set\_analytic\_hessian\_products@{set\_analytic\_hessian\_products}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{set\_analytic\_hessian\_products()}{set\_analytic\_hessian\_products()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::set\+\_\+analytic\+\_\+hessian\+\_\+products (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Function to turn on analytic calculation of the parameter derivatives in continuation and bifurcation detection problems. 



Definition at line 289 of file problem.\+h.



References Calculate\+\_\+hessian\+\_\+products\+\_\+analytic.

\mbox{\Hypertarget{classoomph_1_1Problem_a9494223b38728ea186a68d6c70b7ebd4}\label{classoomph_1_1Problem_a9494223b38728ea186a68d6c70b7ebd4}} 
\index{oomph::Problem@{oomph::Problem}!set\_consistent\_pinned\_values\_for\_continuation@{set\_consistent\_pinned\_values\_for\_continuation}}
\index{set\_consistent\_pinned\_values\_for\_continuation@{set\_consistent\_pinned\_values\_for\_continuation}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{set\_consistent\_pinned\_values\_for\_continuation()}{set\_consistent\_pinned\_values\_for\_continuation()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::set\+\_\+consistent\+\_\+pinned\+\_\+values\+\_\+for\+\_\+continuation (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Private helper function that is used to set the appropriate pinned values for continuation. 

Private helper function that is used to set the appropriate pinned values for continuation. If the data is pinned, the its current value is always the same as the original value and the derivative is always zero. If these are not set properly then interpolation and projection in spatial adaptivity will not give the best answers. 

Definition at line 10659 of file problem.\+cc.



References Continuation\+\_\+time\+\_\+stepper, Global\+\_\+data\+\_\+pt, i, Mesh\+\_\+pt, nsub\+\_\+mesh(), oomph\+::\+Continuation\+Storage\+Scheme\+::set\+\_\+consistent\+\_\+pinned\+\_\+values(), oomph\+::\+Mesh\+::set\+\_\+consistent\+\_\+pinned\+\_\+values\+\_\+for\+\_\+continuation(), and Sub\+\_\+mesh\+\_\+pt.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_ab002dc7a6faf97a1bfcd9c098a04f840}\label{classoomph_1_1Problem_ab002dc7a6faf97a1bfcd9c098a04f840}} 
\index{oomph::Problem@{oomph::Problem}!set\_default\_first\_and\_last\_element\_for\_assembly@{set\_default\_first\_and\_last\_element\_for\_assembly}}
\index{set\_default\_first\_and\_last\_element\_for\_assembly@{set\_default\_first\_and\_last\_element\_for\_assembly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{set\_default\_first\_and\_last\_element\_for\_assembly()}{set\_default\_first\_and\_last\_element\_for\_assembly()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::set\+\_\+default\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Set default first and last elements for parallel assembly of non-\/distributed problem. 



Definition at line 1699 of file problem.\+cc.



References communicator\+\_\+pt(), First\+\_\+el\+\_\+for\+\_\+assembly, Last\+\_\+el\+\_\+plus\+\_\+one\+\_\+for\+\_\+assembly, Mesh\+\_\+pt, oomph\+::\+Mesh\+::nelement(), oomph\+::oomph\+\_\+info, Problem\+\_\+has\+\_\+been\+\_\+distributed, and Shut\+\_\+up\+\_\+in\+\_\+newton\+\_\+solve.



Referenced by assign\+\_\+eqn\+\_\+numbers(), and oomph\+::\+Navier\+Stokes\+Schur\+Complement\+Preconditioner\+::get\+\_\+pressure\+\_\+advection\+\_\+diffusion\+\_\+matrix().

\mbox{\Hypertarget{classoomph_1_1Problem_a23e641f64f436d4911c53c0f5c7ff239}\label{classoomph_1_1Problem_a23e641f64f436d4911c53c0f5c7ff239}} 
\index{oomph::Problem@{oomph::Problem}!set\_default\_partition\_in\_load\_balance@{set\_default\_partition\_in\_load\_balance}}
\index{set\_default\_partition\_in\_load\_balance@{set\_default\_partition\_in\_load\_balance}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{set\_default\_partition\_in\_load\_balance()}{set\_default\_partition\_in\_load\_balance()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::set\+\_\+default\+\_\+partition\+\_\+in\+\_\+load\+\_\+balance (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Set the use of the default partition in the load balance. 



Definition at line 1445 of file problem.\+h.



References Use\+\_\+default\+\_\+partition\+\_\+in\+\_\+load\+\_\+balance.

\mbox{\Hypertarget{classoomph_1_1Problem_ab51480d18550c107c9f13629102f6b08}\label{classoomph_1_1Problem_ab51480d18550c107c9f13629102f6b08}} 
\index{oomph::Problem@{oomph::Problem}!set\_dofs@{set\_dofs}}
\index{set\_dofs@{set\_dofs}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{set\_dofs()}{set\_dofs()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::set\+\_\+dofs (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{dofs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Set the values of the dofs. 

Function that sets the values of the dofs in the object. 

Reimplemented from \mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject_a76a8d64f2d6aa8de955b44c86e9b3ecb}{oomph\+::\+Explicit\+Time\+Steppable\+Object}}.



Definition at line 3497 of file problem.\+cc.



References Dof\+\_\+pt, ndof(), and oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::nrow().



Referenced by calculate\+\_\+predictions(), and oomph\+::\+TR\+::setup\+\_\+initial\+\_\+derivative().

\mbox{\Hypertarget{classoomph_1_1Problem_a62d7dbbf49388e6383e3b93e50351e89}\label{classoomph_1_1Problem_a62d7dbbf49388e6383e3b93e50351e89}} 
\index{oomph::Problem@{oomph::Problem}!set\_dofs@{set\_dofs}}
\index{set\_dofs@{set\_dofs}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{set\_dofs()}{set\_dofs()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::set\+\_\+dofs (\begin{DoxyParamCaption}\item[{const unsigned \&}]{t,  }\item[{\mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} \&}]{dofs }\end{DoxyParamCaption})}



Set the history values of the dofs. 

Set history values of dofs. 

Definition at line 3519 of file problem.\+cc.



References distributed(), oomph\+::\+Mesh\+::element\+\_\+pt(), oomph\+::\+Data\+::eqn\+\_\+number(), Global\+\_\+data\+\_\+pt, i, oomph\+::\+Generalised\+Element\+::internal\+\_\+data\+\_\+pt(), mesh\+\_\+pt(), nglobal\+\_\+data(), oomph\+::\+Generalised\+Element\+::ninternal\+\_\+data(), oomph\+::\+Mesh\+::node\+\_\+pt(), oomph\+::\+Data\+::nvalue(), oomph\+::\+Data\+::set\+\_\+value(), and t.

\mbox{\Hypertarget{classoomph_1_1Problem_a4b01ea8bfa914f1c9f40f9a2a7aa8ad5}\label{classoomph_1_1Problem_a4b01ea8bfa914f1c9f40f9a2a7aa8ad5}} 
\index{oomph::Problem@{oomph::Problem}!set\_dofs@{set\_dofs}}
\index{set\_dofs@{set\_dofs}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{set\_dofs()}{set\_dofs()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::set\+\_\+dofs (\begin{DoxyParamCaption}\item[{const unsigned \&}]{t,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&}]{dof\+\_\+pt }\end{DoxyParamCaption})}



Set history values of dofs from the type of vector stored in problem\+::\+Dof\+\_\+pt. 



Definition at line 3583 of file problem.\+cc.



References distributed(), dof\+\_\+pt(), oomph\+::\+Mesh\+::element\+\_\+pt(), oomph\+::\+Data\+::eqn\+\_\+number(), Global\+\_\+data\+\_\+pt, i, oomph\+::\+Generalised\+Element\+::internal\+\_\+data\+\_\+pt(), mesh\+\_\+pt(), nglobal\+\_\+data(), oomph\+::\+Generalised\+Element\+::ninternal\+\_\+data(), oomph\+::\+Mesh\+::node\+\_\+pt(), oomph\+::\+Data\+::nvalue(), oomph\+::\+Data\+::set\+\_\+value(), and t.

\mbox{\Hypertarget{classoomph_1_1Problem_a4cf44478e6f6abe95063b7bb2dd530a0}\label{classoomph_1_1Problem_a4cf44478e6f6abe95063b7bb2dd530a0}} 
\index{oomph::Problem@{oomph::Problem}!set\_explicit\_time\_stepper\_pt@{set\_explicit\_time\_stepper\_pt}}
\index{set\_explicit\_time\_stepper\_pt@{set\_explicit\_time\_stepper\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{set\_explicit\_time\_stepper\_pt()}{set\_explicit\_time\_stepper\_pt()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::set\+\_\+explicit\+\_\+time\+\_\+stepper\+\_\+pt (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1ExplicitTimeStepper}{Explicit\+Time\+Stepper}} $\ast$const \&}]{explicit\+\_\+time\+\_\+stepper\+\_\+pt }\end{DoxyParamCaption})}



Set the explicit timestepper for the problem. The function will automatically create or resize the \mbox{\hyperlink{classoomph_1_1Time}{Time}} object so that it contains the appropriate number of levels of storage. 

Set the explicit time stepper for the problem and also ensure that a time object has been created. 

Definition at line 1672 of file problem.\+cc.



References Explicit\+\_\+time\+\_\+stepper\+\_\+pt, explicit\+\_\+time\+\_\+stepper\+\_\+pt(), oomph\+::oomph\+\_\+info, and Time\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1Problem_ac4dec80ab9a6834e10b2c2b0119e7133}\label{classoomph_1_1Problem_ac4dec80ab9a6834e10b2c2b0119e7133}} 
\index{oomph::Problem@{oomph::Problem}!set\_first\_and\_last\_element\_for\_assembly@{set\_first\_and\_last\_element\_for\_assembly}}
\index{set\_first\_and\_last\_element\_for\_assembly@{set\_first\_and\_last\_element\_for\_assembly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{set\_first\_and\_last\_element\_for\_assembly()}{set\_first\_and\_last\_element\_for\_assembly()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::set\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{first\+\_\+el\+\_\+for\+\_\+assembly,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{last\+\_\+el\+\_\+for\+\_\+assembly }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Manually set first and last elements for parallel assembly of non-\/distributed problem. 



Definition at line 988 of file problem.\+h.



References First\+\_\+el\+\_\+for\+\_\+assembly, i, and Last\+\_\+el\+\_\+plus\+\_\+one\+\_\+for\+\_\+assembly.



Referenced by oomph\+::\+Navier\+Stokes\+Schur\+Complement\+Preconditioner\+::get\+\_\+pressure\+\_\+advection\+\_\+diffusion\+\_\+matrix().

\mbox{\Hypertarget{classoomph_1_1Problem_ad48be6d67071f7da5f6feb7c4fc918f0}\label{classoomph_1_1Problem_ad48be6d67071f7da5f6feb7c4fc918f0}} 
\index{oomph::Problem@{oomph::Problem}!set\_initial\_condition@{set\_initial\_condition}}
\index{set\_initial\_condition@{set\_initial\_condition}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{set\_initial\_condition()}{set\_initial\_condition()}}
{\footnotesize\ttfamily virtual void oomph\+::\+Problem\+::set\+\_\+initial\+\_\+condition (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Set initial condition (incl previous timesteps). We need to establish this interface because I.\+C. needs to be reset when problem is adapted during the first timestep. 



Definition at line 1198 of file problem.\+h.



References Default\+\_\+set\+\_\+initial\+\_\+condition\+\_\+called.



Referenced by doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve\+\_\+helper(), and unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a820d3c43c7d678b4fe186a8c83a90732}\label{classoomph_1_1Problem_a820d3c43c7d678b4fe186a8c83a90732}} 
\index{oomph::Problem@{oomph::Problem}!set\_pinned\_values\_to\_zero@{set\_pinned\_values\_to\_zero}}
\index{set\_pinned\_values\_to\_zero@{set\_pinned\_values\_to\_zero}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{set\_pinned\_values\_to\_zero()}{set\_pinned\_values\_to\_zero()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::set\+\_\+pinned\+\_\+values\+\_\+to\+\_\+zero (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Set all pinned values to zero. Used to set boundary conditions to be homogeneous in the copy of the problem used in adaptive bifurcation tracking (ALH\+: TEMPORARY HACK, WILL BE FIXED) 



Definition at line 4281 of file problem.\+cc.



References e, oomph\+::\+Mesh\+::element\+\_\+pt(), Global\+\_\+data\+\_\+pt, i, oomph\+::\+Generalised\+Element\+::internal\+\_\+data\+\_\+pt(), oomph\+::\+Data\+::is\+\_\+pinned(), Mesh\+\_\+pt, oomph\+::\+Node\+::ndim(), oomph\+::\+Mesh\+::nelement(), nglobal\+\_\+data(), oomph\+::\+Generalised\+Element\+::ninternal\+\_\+data(), oomph\+::\+Mesh\+::nnode(), oomph\+::\+Mesh\+::node\+\_\+pt(), oomph\+::\+Node\+::nposition\+\_\+type(), oomph\+::\+Data\+::nvalue(), oomph\+::\+Solid\+Node\+::position\+\_\+is\+\_\+pinned(), oomph\+::\+Data\+::set\+\_\+value(), Sub\+\_\+mesh\+\_\+pt, and oomph\+::\+Node\+::x\+\_\+gen().

\mbox{\Hypertarget{classoomph_1_1Problem_a7be66e9917b39eaea90b91389f5a72fb}\label{classoomph_1_1Problem_a7be66e9917b39eaea90b91389f5a72fb}} 
\index{oomph::Problem@{oomph::Problem}!set\_timestepper\_for\_all\_data@{set\_timestepper\_for\_all\_data}}
\index{set\_timestepper\_for\_all\_data@{set\_timestepper\_for\_all\_data}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{set\_timestepper\_for\_all\_data()}{set\_timestepper\_for\_all\_data()}}
{\footnotesize\ttfamily unsigned long oomph\+::\+Problem\+::set\+\_\+timestepper\+\_\+for\+\_\+all\+\_\+data (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}} $\ast$const \&}]{time\+\_\+stepper\+\_\+pt,  }\item[{const bool \&}]{preserve\+\_\+existing\+\_\+data = {\ttfamily false} }\end{DoxyParamCaption})}



Set all problem data to have the same timestepper (timestepper\+\_\+pt) Return the new number of dofs in the problem. 

Set all problem data to have the same timestepper (timestepper\+\_\+pt). This is mainly used in continuation and bifurcation detection problems in which case the total number of unknowns may change and the changes to the underlying memory layout means that the Dof\+\_\+pt must be reallocated. Thus, the function calls \mbox{\hyperlink{classoomph_1_1Problem_a0df501c6aed60c4938861df776b10119}{assign\+\_\+eqn\+\_\+numbers()}} and returns the number of new equation numbers. 

Definition at line 11765 of file problem.\+cc.



References assign\+\_\+eqn\+\_\+numbers(), Global\+\_\+data\+\_\+pt, i, Mesh\+\_\+pt, nsub\+\_\+mesh(), Problem\+\_\+has\+\_\+been\+\_\+distributed, oomph\+::\+Mesh\+::set\+\_\+mesh\+\_\+level\+\_\+time\+\_\+stepper(), oomph\+::\+Mesh\+::set\+\_\+nodal\+\_\+and\+\_\+elemental\+\_\+time\+\_\+stepper(), Sub\+\_\+mesh\+\_\+pt, and time\+\_\+stepper\+\_\+pt().



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_ab5f60ebc552c00ee681776bc7fa61203}\label{classoomph_1_1Problem_ab5f60ebc552c00ee681776bc7fa61203}} 
\index{oomph::Problem@{oomph::Problem}!setup\_base\_mesh\_info\_after\_pruning@{setup\_base\_mesh\_info\_after\_pruning}}
\index{setup\_base\_mesh\_info\_after\_pruning@{setup\_base\_mesh\_info\_after\_pruning}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{setup\_base\_mesh\_info\_after\_pruning()}{setup\_base\_mesh\_info\_after\_pruning()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::setup\+\_\+base\+\_\+mesh\+\_\+info\+\_\+after\+\_\+pruning (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Helper function to re-\/setup the Base\+\_\+mesh enumeration (used during load balancing) after pruning. 



Definition at line 20295 of file problem.\+cc.



References Base\+\_\+mesh\+\_\+element\+\_\+number\+\_\+plus\+\_\+one, Base\+\_\+mesh\+\_\+element\+\_\+pt, communicator\+\_\+pt(), e, mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::\+Mesh\+::root\+\_\+halo\+\_\+element\+\_\+pt(), and oomph\+::\+Mesh\+::root\+\_\+haloed\+\_\+element\+\_\+pt().



Referenced by load\+\_\+balance(), and prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes().

\mbox{\Hypertarget{classoomph_1_1Problem_a216679e2a976e0205165bbe7ab558579}\label{classoomph_1_1Problem_a216679e2a976e0205165bbe7ab558579}} 
\index{oomph::Problem@{oomph::Problem}!setup\_dof\_halo\_scheme@{setup\_dof\_halo\_scheme}}
\index{setup\_dof\_halo\_scheme@{setup\_dof\_halo\_scheme}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{setup\_dof\_halo\_scheme()}{setup\_dof\_halo\_scheme()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::setup\+\_\+dof\+\_\+halo\+\_\+scheme (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Function that is used to setup the halo scheme. 

Setup the halo scheme for the degrees of freedom. 

Definition at line 386 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, Dof\+\_\+distribution\+\_\+pt, get\+\_\+all\+\_\+halo\+\_\+data(), get\+\_\+my\+\_\+eqns(), Halo\+\_\+dof\+\_\+pt, Halo\+\_\+scheme\+\_\+pt, mesh\+\_\+pt(), oomph\+::\+Mesh\+::nelement(), and oomph\+::\+Double\+Vector\+Halo\+Scheme\+::setup\+\_\+halo\+\_\+dofs().



Referenced by oomph\+::\+Pitch\+Fork\+Handler\+::\+Pitch\+Fork\+Handler().

\mbox{\Hypertarget{classoomph_1_1Problem_a919a5f4752362df6005d24e51b5780e0}\label{classoomph_1_1Problem_a919a5f4752362df6005d24e51b5780e0}} 
\index{oomph::Problem@{oomph::Problem}!setup\_element\_count\_per\_dof@{setup\_element\_count\_per\_dof}}
\index{setup\_element\_count\_per\_dof@{setup\_element\_count\_per\_dof}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{setup\_element\_count\_per\_dof()}{setup\_element\_count\_per\_dof()}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::setup\+\_\+element\+\_\+count\+\_\+per\+\_\+dof (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Function that populates the Element\+\_\+counter\+\_\+per\+\_\+dof vector with the number of elements that contribute to each dof. For example, with linear elements in 1D each dof contains contributions from two elements apart from those on the boundary. Returns the total number of elements in the problem. 

Setup the count vector that records how many elements contribute to each degree of freedom. Returns the total number of elements in the problem. 

Definition at line 230 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, oomph\+::\+Double\+Vector\+::build(), oomph\+::\+Double\+Vector\+With\+Halo\+Entries\+::build\+\_\+halo\+\_\+scheme(), communicator\+\_\+pt(), Dof\+\_\+distribution\+\_\+pt, e, Element\+\_\+count\+\_\+per\+\_\+dof, oomph\+::\+Mesh\+::element\+\_\+pt(), oomph\+::\+Assembly\+Handler\+::eqn\+\_\+number(), oomph\+::\+Double\+Vector\+With\+Halo\+Entries\+::global\+\_\+value(), Halo\+\_\+scheme\+\_\+pt, oomph\+::\+Generalised\+Element\+::is\+\_\+halo(), mesh\+\_\+pt(), oomph\+::\+Assembly\+Handler\+::ndof(), oomph\+::\+Mesh\+::nelement(), Problem\+\_\+has\+\_\+been\+\_\+distributed, and oomph\+::\+Double\+Vector\+With\+Halo\+Entries\+::sum\+\_\+all\+\_\+halo\+\_\+and\+\_\+haloed\+\_\+values().

\mbox{\Hypertarget{classoomph_1_1Problem_aab27bdd1968e57cb3dffe78c1d63f762}\label{classoomph_1_1Problem_aab27bdd1968e57cb3dffe78c1d63f762}} 
\index{oomph::Problem@{oomph::Problem}!shift\_time\_values@{shift\_time\_values}}
\index{shift\_time\_values@{shift\_time\_values}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{shift\_time\_values()}{shift\_time\_values()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::shift\+\_\+time\+\_\+values (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Shift all values along to prepare for next timestep. 

Shift all time-\/dependent data along for next timestep. 

Definition at line 11827 of file problem.\+cc.



References Global\+\_\+data\+\_\+pt, Mesh\+\_\+pt, oomph\+::\+Time\+::shift\+\_\+dt(), oomph\+::\+Mesh\+::shift\+\_\+time\+\_\+values(), and Time\+\_\+pt.



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), explicit\+\_\+timestep(), unsteady\+\_\+newton\+\_\+solve(), and oomph\+::\+Segregatable\+FSIProblem\+::unsteady\+\_\+segregated\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a797cb28b5fffe976fc7541421eb423a1}\label{classoomph_1_1Problem_a797cb28b5fffe976fc7541421eb423a1}} 
\index{oomph::Problem@{oomph::Problem}!sign\_of\_jacobian@{sign\_of\_jacobian}}
\index{sign\_of\_jacobian@{sign\_of\_jacobian}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{sign\_of\_jacobian()}{sign\_of\_jacobian()}}
{\footnotesize\ttfamily int\& oomph\+::\+Problem\+::sign\+\_\+of\+\_\+jacobian (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access function for the sign of the global jacobian matrix. This will be set by the linear solver, if possible (direct solver). If not alternative methods must be used to detect bifurcations (solving the associated eigenproblem). 



Definition at line 2553 of file problem.\+h.



References Sign\+\_\+of\+\_\+jacobian.



Referenced by oomph\+::\+Augmented\+Block\+Fold\+Linear\+Solver\+::solve(), oomph\+::\+Block\+Pitch\+Fork\+Linear\+Solver\+::solve(), oomph\+::\+Augmented\+Block\+Pitch\+Fork\+Linear\+Solver\+::solve(), oomph\+::\+Block\+Hopf\+Linear\+Solver\+::solve(), oomph\+::\+HSL\+\_\+\+MA42\+::solve(), oomph\+::\+Dense\+LU\+::solve(), oomph\+::\+FD\+\_\+\+LU\+::solve(), oomph\+::\+Super\+LUSolver\+::solve(), oomph\+::\+HSL\+\_\+\+MA42\+::solve\+\_\+for\+\_\+one\+\_\+dof(), oomph\+::\+Block\+Hopf\+Linear\+Solver\+::solve\+\_\+for\+\_\+two\+\_\+rhs(), and oomph\+::\+Super\+LUSolver\+::solve\+\_\+transpose().

\mbox{\Hypertarget{classoomph_1_1Problem_ae42812f6d3b950698cf0936e28f0e415}\label{classoomph_1_1Problem_ae42812f6d3b950698cf0936e28f0e415}} 
\index{oomph::Problem@{oomph::Problem}!solve\_adjoint\_eigenproblem@{solve\_adjoint\_eigenproblem}}
\index{solve\_adjoint\_eigenproblem@{solve\_adjoint\_eigenproblem}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{solve\_adjoint\_eigenproblem()}{solve\_adjoint\_eigenproblem()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::solve\+\_\+adjoint\+\_\+eigenproblem (\begin{DoxyParamCaption}\item[{const unsigned \&}]{n\+\_\+eval,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&}]{eigenvalue,  }\item[{const bool \&}]{steady = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Solve an adjoint eigenvalue problem using the same procedure as solve\+\_\+eigenproblem but only return the eigenvalues, not the eigenvectors. At least n\+\_\+eval eigenvalues are computed. See the documentation on that function for more details. 



Definition at line 2063 of file problem.\+h.



References solve\+\_\+adjoint\+\_\+eigenproblem().

\mbox{\Hypertarget{classoomph_1_1Problem_a238820e0f1029699f362510557b77d24}\label{classoomph_1_1Problem_a238820e0f1029699f362510557b77d24}} 
\index{oomph::Problem@{oomph::Problem}!solve\_adjoint\_eigenproblem@{solve\_adjoint\_eigenproblem}}
\index{solve\_adjoint\_eigenproblem@{solve\_adjoint\_eigenproblem}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{solve\_adjoint\_eigenproblem()}{solve\_adjoint\_eigenproblem()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::solve\+\_\+adjoint\+\_\+eigenproblem (\begin{DoxyParamCaption}\item[{const unsigned \&}]{n\+\_\+eval,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&}]{eigenvalue,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&}]{eigenvector\+\_\+real,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&}]{eigenvector\+\_\+imag,  }\item[{const bool \&}]{steady = {\ttfamily true} }\end{DoxyParamCaption})}



Solve an adjoint eigenvalue problem using the same procedure as solve\+\_\+eigenproblem. See the documentation on that function for more details. 

Solve the adjoint eigenproblem. 

Definition at line 8536 of file problem.\+cc.



References Eigen\+\_\+solver\+\_\+pt, i, oomph\+::\+Time\+Stepper\+::is\+\_\+steady(), oomph\+::\+Time\+Stepper\+::make\+\_\+steady(), ntime\+\_\+stepper(), oomph\+::\+Eigen\+Solver\+::solve\+\_\+eigenproblem(), time\+\_\+stepper\+\_\+pt(), and oomph\+::\+Time\+Stepper\+::undo\+\_\+make\+\_\+steady().



Referenced by solve\+\_\+adjoint\+\_\+eigenproblem().

\mbox{\Hypertarget{classoomph_1_1Problem_a0a7c8ab31dc0297e049b15d67eb7661b}\label{classoomph_1_1Problem_a0a7c8ab31dc0297e049b15d67eb7661b}} 
\index{oomph::Problem@{oomph::Problem}!solve\_adjoint\_eigenproblem\_legacy@{solve\_adjoint\_eigenproblem\_legacy}}
\index{solve\_adjoint\_eigenproblem\_legacy@{solve\_adjoint\_eigenproblem\_legacy}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{solve\_adjoint\_eigenproblem\_legacy()}{solve\_adjoint\_eigenproblem\_legacy()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::solve\+\_\+adjoint\+\_\+eigenproblem\+\_\+legacy (\begin{DoxyParamCaption}\item[{const unsigned \&}]{n\+\_\+eval,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&}]{eigenvalue,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&}]{eigenvector,  }\item[{const bool \&}]{make\+\_\+timesteppers\+\_\+steady = {\ttfamily true} }\end{DoxyParamCaption})}



Solve an adjoint eigenvalue problem using the same procedure as solve\+\_\+eigenproblem. See the documentation on that function for more details. Note\+: this is a legacy version of this function that stores re \& imag parts of eigenvectors in some solver-\/specific collection of real vectors. 

Solve the adjoint eigenproblem. 

Definition at line 8479 of file problem.\+cc.



References Eigen\+\_\+solver\+\_\+pt, i, oomph\+::\+Time\+Stepper\+::is\+\_\+steady(), oomph\+::\+Time\+Stepper\+::make\+\_\+steady(), ntime\+\_\+stepper(), oomph\+::\+Eigen\+Solver\+::solve\+\_\+eigenproblem\+\_\+legacy(), time\+\_\+stepper\+\_\+pt(), and oomph\+::\+Time\+Stepper\+::undo\+\_\+make\+\_\+steady().

\mbox{\Hypertarget{classoomph_1_1Problem_abdeda71a6cde679015d0a064a2122744}\label{classoomph_1_1Problem_abdeda71a6cde679015d0a064a2122744}} 
\index{oomph::Problem@{oomph::Problem}!solve\_eigenproblem@{solve\_eigenproblem}}
\index{solve\_eigenproblem@{solve\_eigenproblem}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{solve\_eigenproblem()}{solve\_eigenproblem()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::solve\+\_\+eigenproblem (\begin{DoxyParamCaption}\item[{const unsigned \&}]{n\+\_\+eval,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&}]{alpha,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&}]{beta,  }\item[{const bool \&}]{steady = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Solve an eigenproblem as assembled by the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s constituent elements but only return the eigenvalues, not the eigenvectors. At least n\+\_\+eval eigenvalues are computed. The boolean flag (default true) is used to specify whether the weighted mass-\/matrix terms from the timestepping scheme should be included in the jacobian --- this is almost certainly never wanted. Note that the eigenvalues may be infinite and are therefore returned as $ \lambda_i = \alpha_i / \beta_i $ where $ \alpha_i $ is complex while $ \beta_i $ is real. The actual eigenvalues may then be computed by doing the division, checking for zero betas to avoid Na\+Ns. 



Definition at line 2025 of file problem.\+h.



References solve\+\_\+eigenproblem().

\mbox{\Hypertarget{classoomph_1_1Problem_afb6e5ef95c303d531f5949d7e9f6774a}\label{classoomph_1_1Problem_afb6e5ef95c303d531f5949d7e9f6774a}} 
\index{oomph::Problem@{oomph::Problem}!solve\_eigenproblem@{solve\_eigenproblem}}
\index{solve\_eigenproblem@{solve\_eigenproblem}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{solve\_eigenproblem()}{solve\_eigenproblem()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::solve\+\_\+eigenproblem (\begin{DoxyParamCaption}\item[{const unsigned \&}]{n\+\_\+eval,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&}]{alpha,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $>$ \&}]{beta,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&}]{eigenvector\+\_\+real,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&}]{eigenvector\+\_\+imag,  }\item[{const bool \&}]{steady = {\ttfamily true} }\end{DoxyParamCaption})}



Solve an eigenproblem as assembled by the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s constituent elements. Calculate (at least) n\+\_\+eval eigenvalues and return the corresponding eigenvectors. The boolean flag (default true) specifies whether the steady jacobian should be assembled. If the flag is false then the weighted mass-\/matrix terms from the timestepper will be included in the jacobian --- this is almost certainly never wanted. The eigenvalues and eigenvectors are, in general, complex. Eigenvalues may be infinite and are therefore returned as $ \lambda_i = \alpha_i / \beta_i $ where $ \alpha_i $ is complex while $ \beta_i $ is real. The actual eigenvalues may then be computed by doing the division, checking for zero betas to avoid Na\+Ns. There\textquotesingle{}s a convenience wrapper to this function that simply computes these eigenvalues regardless. That version may die in NaN checking is enabled (via the fenv.\+h header and the associated feenable function). 

Solve the eigenproblem. 

Definition at line 8348 of file problem.\+cc.



References Eigen\+\_\+solver\+\_\+pt, i, oomph\+::\+Time\+Stepper\+::is\+\_\+steady(), oomph\+::\+Time\+Stepper\+::make\+\_\+steady(), ntime\+\_\+stepper(), oomph\+::\+Eigen\+Solver\+::solve\+\_\+eigenproblem(), time\+\_\+stepper\+\_\+pt(), and oomph\+::\+Time\+Stepper\+::undo\+\_\+make\+\_\+steady().



Referenced by solve\+\_\+eigenproblem().

\mbox{\Hypertarget{classoomph_1_1Problem_a02a607f961a4f5651972035abd8529b3}\label{classoomph_1_1Problem_a02a607f961a4f5651972035abd8529b3}} 
\index{oomph::Problem@{oomph::Problem}!solve\_eigenproblem@{solve\_eigenproblem}}
\index{solve\_eigenproblem@{solve\_eigenproblem}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{solve\_eigenproblem()}{solve\_eigenproblem()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::solve\+\_\+eigenproblem (\begin{DoxyParamCaption}\item[{const unsigned \&}]{n\+\_\+eval,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&}]{eigenvalue,  }\item[{const bool \&}]{make\+\_\+timesteppers\+\_\+steady = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Solve an eigenproblem as assembled by the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s constituent elements but only return the eigenvalues, not the eigenvectors. At least n\+\_\+eval eigenvalues are computed. The boolean flag (default true) is used to specify whether the weighted mass-\/matrix terms from the timestepping scheme should be included in the jacobian --- this is almost certainly never wanted. Note that the eigenvalues may be infinite. In this case it\textquotesingle{}s safer to use the other version of this function which returns the eigenvalues in terms of a fractional representation. 



Definition at line 2000 of file problem.\+h.



References solve\+\_\+eigenproblem().

\mbox{\Hypertarget{classoomph_1_1Problem_a1af2e46e4a98d88ccf85f96dd18c4d25}\label{classoomph_1_1Problem_a1af2e46e4a98d88ccf85f96dd18c4d25}} 
\index{oomph::Problem@{oomph::Problem}!solve\_eigenproblem@{solve\_eigenproblem}}
\index{solve\_eigenproblem@{solve\_eigenproblem}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{solve\_eigenproblem()}{solve\_eigenproblem()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::solve\+\_\+eigenproblem (\begin{DoxyParamCaption}\item[{const unsigned \&}]{n\+\_\+eval,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&}]{eigenvalue,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&}]{eigenvector\+\_\+real,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&}]{eigenvector\+\_\+imag,  }\item[{const bool \&}]{steady = {\ttfamily true} }\end{DoxyParamCaption})}



Solve an eigenproblem as assembled by the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s constituent elements. Calculate (at least) n\+\_\+eval eigenvalues and return the corresponding eigenvectors. The boolean flag (default true) specifies whether the steady jacobian should be assembled. If the flag is false then the weighted mass-\/matrix terms from the timestepper will be included in the jacobian --- this is almost certainly never wanted. Note that the eigenvalues and eigenvectors are, in general, complex and the eigenvalues may be infinite. In this case it\textquotesingle{}s safer to use the other version of this function which returns the eigenvalues in terms of a fractional representation. 

Solve the eigenproblem. 

Definition at line 8415 of file problem.\+cc.



References Eigen\+\_\+solver\+\_\+pt, i, oomph\+::\+Time\+Stepper\+::is\+\_\+steady(), oomph\+::\+Time\+Stepper\+::make\+\_\+steady(), ntime\+\_\+stepper(), oomph\+::\+Eigen\+Solver\+::solve\+\_\+eigenproblem(), time\+\_\+stepper\+\_\+pt(), and oomph\+::\+Time\+Stepper\+::undo\+\_\+make\+\_\+steady().

\mbox{\Hypertarget{classoomph_1_1Problem_aa4c4d1c36972399b365017b967622449}\label{classoomph_1_1Problem_aa4c4d1c36972399b365017b967622449}} 
\index{oomph::Problem@{oomph::Problem}!solve\_eigenproblem\_legacy@{solve\_eigenproblem\_legacy}}
\index{solve\_eigenproblem\_legacy@{solve\_eigenproblem\_legacy}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{solve\_eigenproblem\_legacy()}{solve\_eigenproblem\_legacy()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::solve\+\_\+eigenproblem\+\_\+legacy (\begin{DoxyParamCaption}\item[{const unsigned \&}]{n\+\_\+eval,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&}]{eigenvalue,  }\item[{const bool \&}]{steady = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Solve an eigenproblem as assembled by the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s constituent elements. Calculate (at least) n\+\_\+eval eigenvalues. The boolean flag (default true) specifies whether the steady jacobian should be assembled. If the flag is false then the weighted mass-\/matrix terms from the timestepper will be included in the jacobian --- this is almost certainly never wanted. Legacy version. 



Definition at line 1945 of file problem.\+h.



References solve\+\_\+eigenproblem\+\_\+legacy().

\mbox{\Hypertarget{classoomph_1_1Problem_a8cde2d21879264ae7bc8a140142db8ea}\label{classoomph_1_1Problem_a8cde2d21879264ae7bc8a140142db8ea}} 
\index{oomph::Problem@{oomph::Problem}!solve\_eigenproblem\_legacy@{solve\_eigenproblem\_legacy}}
\index{solve\_eigenproblem\_legacy@{solve\_eigenproblem\_legacy}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{solve\_eigenproblem\_legacy()}{solve\_eigenproblem\_legacy()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::solve\+\_\+eigenproblem\+\_\+legacy (\begin{DoxyParamCaption}\item[{const unsigned \&}]{n\+\_\+eval,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ std\+::complex$<$ double $>$$>$ \&}]{eigenvalue,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ \mbox{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector}} $>$ \&}]{eigenvector,  }\item[{const bool \&}]{make\+\_\+timesteppers\+\_\+steady = {\ttfamily true} }\end{DoxyParamCaption})}



Get derivative of an element in the problem wrt a global parameter, used in continuation problems. 

Get derivative of an element in the problem wrt a global parameter, to be used in continuation problems.

Solve an eigenproblem as assembled by the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}}\textquotesingle{}s constituent elements. Calculate (at least) n\+\_\+eval eigenvalues and return the corresponding eigenvectors. The boolean flag (default true) specifies whether the steady jacobian should be assembled. If the flag is false then the weighted mass-\/matrix terms from the timestepper will be included in the jacobian --- this is almost certainly never wanted. Legacy version that returns real vectors which are related in some solver-\/specific way to the real and imaginary parts of the actual, usually complex eigenvalues.

Solve the eigenproblem. Legacy version that returns real vectors which are related in some solver-\/specific way to the real and imaginary parts of the actual, usually complex eigenvalues. At least n\+\_\+eval eigenvalues are computed. 

Definition at line 8293 of file problem.\+cc.



References Eigen\+\_\+solver\+\_\+pt, i, oomph\+::\+Time\+Stepper\+::is\+\_\+steady(), oomph\+::\+Time\+Stepper\+::make\+\_\+steady(), ntime\+\_\+stepper(), oomph\+::\+Eigen\+Solver\+::solve\+\_\+eigenproblem\+\_\+legacy(), time\+\_\+stepper\+\_\+pt(), and oomph\+::\+Time\+Stepper\+::undo\+\_\+make\+\_\+steady().



Referenced by solve\+\_\+eigenproblem\+\_\+legacy().

\mbox{\Hypertarget{classoomph_1_1Problem_a072f2894b20672be1a48783684c4a50b}\label{classoomph_1_1Problem_a072f2894b20672be1a48783684c4a50b}} 
\index{oomph::Problem@{oomph::Problem}!sparse\_assemble\_row\_or\_column\_compressed@{sparse\_assemble\_row\_or\_column\_compressed}}
\index{sparse\_assemble\_row\_or\_column\_compressed@{sparse\_assemble\_row\_or\_column\_compressed}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{sparse\_assemble\_row\_or\_column\_compressed()}{sparse\_assemble\_row\_or\_column\_compressed()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&}]{column\+\_\+or\+\_\+row\+\_\+index,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&}]{row\+\_\+or\+\_\+column\+\_\+start,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&}]{value,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nnz,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&}]{residual,  }\item[{bool}]{compressed\+\_\+row\+\_\+flag }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Protected helper function that is used to assemble the Jacobian matrix in the case when the storage is row or column compressed. The boolean Flag indicates if we want compressed row format (true) or compressed column. 

This is a (private) helper function that is used to assemble system matrices in compressed row or column format and compute residual vectors. The default action is to assemble the jacobian matrix and residuals for the Newton method. The action can be overloaded at an elemental level by changing the default behaviour of the function Element\+::get\+\_\+all\+\_\+vectors\+\_\+and\+\_\+matrices(). column\+\_\+or\+\_\+row\+\_\+index\+: Column \mbox{[}or row\mbox{]} index of given entry row\+\_\+or\+\_\+column\+\_\+start\+: Index of first entry for given row \mbox{[}or column\mbox{]} value \+: \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of nonzero entries residuals \+: Residual vector compressed\+\_\+row\+\_\+flag\+: Bool flag to indicate if storage format is compressed row \mbox{[}if false interpretation of arguments is as stated in square brackets\mbox{]}. We provide four different assembly methods, each with different memory requirements/execution speeds. The method is set by the public flag \mbox{\hyperlink{classoomph_1_1Problem_a447f9d42b248f6c394581ff1a0b02513}{Problem\+::\+Sparse\+\_\+assembly\+\_\+method}}. 

Definition at line 4461 of file problem.\+cc.



References Perform\+\_\+assembly\+\_\+using\+\_\+lists, Perform\+\_\+assembly\+\_\+using\+\_\+maps, Perform\+\_\+assembly\+\_\+using\+\_\+two\+\_\+arrays, Perform\+\_\+assembly\+\_\+using\+\_\+two\+\_\+vectors, Perform\+\_\+assembly\+\_\+using\+\_\+vectors\+\_\+of\+\_\+pairs, sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+lists(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+maps(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+vectors(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+vectors\+\_\+of\+\_\+pairs(), and Sparse\+\_\+assembly\+\_\+method.



Referenced by get\+\_\+eigenproblem\+\_\+matrices(), and get\+\_\+jacobian().

\mbox{\Hypertarget{classoomph_1_1Problem_a18867724e4682e69f10fe19d7a20116d}\label{classoomph_1_1Problem_a18867724e4682e69f10fe19d7a20116d}} 
\index{oomph::Problem@{oomph::Problem}!sparse\_assemble\_row\_or\_column\_compressed\_with\_lists@{sparse\_assemble\_row\_or\_column\_compressed\_with\_lists}}
\index{sparse\_assemble\_row\_or\_column\_compressed\_with\_lists@{sparse\_assemble\_row\_or\_column\_compressed\_with\_lists}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{sparse\_assemble\_row\_or\_column\_compressed\_with\_lists()}{sparse\_assemble\_row\_or\_column\_compressed\_with\_lists()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+lists (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&}]{column\+\_\+or\+\_\+row\+\_\+index,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&}]{row\+\_\+or\+\_\+column\+\_\+start,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&}]{value,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nnz,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&}]{residual,  }\item[{bool}]{compressed\+\_\+row\+\_\+flag }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}



Private helper function that is used to assemble the Jacobian matrix in the case when the storage is row or column compressed. The boolean Flag indicates if we want compressed row format (true) or compressed column. This version uses lists. 

This is a (private) helper function that is used to assemble system matrices in compressed row or column format and compute residual vectors using lists The default action is to assemble the jacobian matrix and residuals for the Newton method. The action can be overloaded at an elemental level by chaging the default behaviour of the function Element\+::get\+\_\+all\+\_\+vectors\+\_\+and\+\_\+matrices(). column\+\_\+or\+\_\+row\+\_\+index\+: Column \mbox{[}or row\mbox{]} index of given entry row\+\_\+or\+\_\+column\+\_\+start\+: Index of first entry for given row \mbox{[}or column\mbox{]} value \+: \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of nonzero entries residuals \+: Residual vector compressed\+\_\+row\+\_\+flag\+: Bool flag to indicate if storage format is compressed row \mbox{[}if false interpretation of arguments is as stated in square brackets\mbox{]}. 

Definition at line 4907 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, assembly\+\_\+handler\+\_\+pt(), Communicator\+\_\+pt, e, oomph\+::\+Mesh\+::element\+\_\+pt(), Elemental\+\_\+assembly\+\_\+time, oomph\+::\+Assembly\+Handler\+::eqn\+\_\+number(), First\+\_\+el\+\_\+for\+\_\+assembly, oomph\+::\+Assembly\+Handler\+::get\+\_\+all\+\_\+vectors\+\_\+and\+\_\+matrices(), i, oomph\+::\+Generalised\+Element\+::is\+\_\+halo(), Last\+\_\+el\+\_\+plus\+\_\+one\+\_\+for\+\_\+assembly, mesh\+\_\+pt(), Must\+\_\+recompute\+\_\+load\+\_\+balance\+\_\+for\+\_\+assembly, ndof(), oomph\+::\+Assembly\+Handler\+::ndof(), oomph\+::\+Mesh\+::nelement(), Numerical\+\_\+zero\+\_\+for\+\_\+sparse\+\_\+assembly, oomph\+::oomph\+\_\+info, oomph\+::pause(), Pause\+\_\+at\+\_\+end\+\_\+of\+\_\+sparse\+\_\+assembly, Problem\+\_\+has\+\_\+been\+\_\+distributed, recompute\+\_\+load\+\_\+balanced\+\_\+assembly(), and oomph\+::\+Timing\+Helpers\+::timer().



Referenced by sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed().

\mbox{\Hypertarget{classoomph_1_1Problem_ade9708e503889b48e0a1dbbe47906eba}\label{classoomph_1_1Problem_ade9708e503889b48e0a1dbbe47906eba}} 
\index{oomph::Problem@{oomph::Problem}!sparse\_assemble\_row\_or\_column\_compressed\_with\_maps@{sparse\_assemble\_row\_or\_column\_compressed\_with\_maps}}
\index{sparse\_assemble\_row\_or\_column\_compressed\_with\_maps@{sparse\_assemble\_row\_or\_column\_compressed\_with\_maps}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{sparse\_assemble\_row\_or\_column\_compressed\_with\_maps()}{sparse\_assemble\_row\_or\_column\_compressed\_with\_maps()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+maps (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&}]{column\+\_\+or\+\_\+row\+\_\+index,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&}]{row\+\_\+or\+\_\+column\+\_\+start,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&}]{value,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nnz,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&}]{residual,  }\item[{bool}]{compressed\+\_\+row\+\_\+flag }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}



Private helper function that is used to assemble the Jacobian matrix in the case when the storage is row or column compressed. The boolean Flag indicates if we want compressed row format (true) or compressed column. This version uses maps. 

This is a (private) helper function that is used to assemble system matrices in compressed row or column format and compute residual vectors, using maps The default action is to assemble the jacobian matrix and residuals for the Newton method. The action can be overloaded at an elemental level by chaging the default behaviour of the function Element\+::get\+\_\+all\+\_\+vectors\+\_\+and\+\_\+matrices(). column\+\_\+or\+\_\+row\+\_\+index\+: Column \mbox{[}or row\mbox{]} index of given entry row\+\_\+or\+\_\+column\+\_\+start\+: Index of first entry for given row \mbox{[}or column\mbox{]} value \+: \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of nonzero entries residuals \+: Residual vector compressed\+\_\+row\+\_\+flag\+: Bool flag to indicate if storage format is compressed row \mbox{[}if false interpretation of arguments is as stated in square brackets\mbox{]}. 

Definition at line 4561 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, assembly\+\_\+handler\+\_\+pt(), Communicator\+\_\+pt, e, oomph\+::\+Mesh\+::element\+\_\+pt(), Elemental\+\_\+assembly\+\_\+time, oomph\+::\+Assembly\+Handler\+::eqn\+\_\+number(), First\+\_\+el\+\_\+for\+\_\+assembly, oomph\+::\+Assembly\+Handler\+::get\+\_\+all\+\_\+vectors\+\_\+and\+\_\+matrices(), i, oomph\+::\+Generalised\+Element\+::is\+\_\+halo(), Last\+\_\+el\+\_\+plus\+\_\+one\+\_\+for\+\_\+assembly, mesh\+\_\+pt(), Must\+\_\+recompute\+\_\+load\+\_\+balance\+\_\+for\+\_\+assembly, ndof(), oomph\+::\+Assembly\+Handler\+::ndof(), oomph\+::\+Mesh\+::nelement(), Numerical\+\_\+zero\+\_\+for\+\_\+sparse\+\_\+assembly, oomph\+::oomph\+\_\+info, oomph\+::pause(), Pause\+\_\+at\+\_\+end\+\_\+of\+\_\+sparse\+\_\+assembly, Problem\+\_\+has\+\_\+been\+\_\+distributed, recompute\+\_\+load\+\_\+balanced\+\_\+assembly(), and oomph\+::\+Timing\+Helpers\+::timer().



Referenced by sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed().

\mbox{\Hypertarget{classoomph_1_1Problem_a19520f8a38dc1dabb33cd7f397ff3506}\label{classoomph_1_1Problem_a19520f8a38dc1dabb33cd7f397ff3506}} 
\index{oomph::Problem@{oomph::Problem}!sparse\_assemble\_row\_or\_column\_compressed\_with\_two\_arrays@{sparse\_assemble\_row\_or\_column\_compressed\_with\_two\_arrays}}
\index{sparse\_assemble\_row\_or\_column\_compressed\_with\_two\_arrays@{sparse\_assemble\_row\_or\_column\_compressed\_with\_two\_arrays}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{sparse\_assemble\_row\_or\_column\_compressed\_with\_two\_arrays()}{sparse\_assemble\_row\_or\_column\_compressed\_with\_two\_arrays()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&}]{column\+\_\+or\+\_\+row\+\_\+index,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&}]{row\+\_\+or\+\_\+column\+\_\+start,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&}]{value,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nnz,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&}]{residual,  }\item[{bool}]{compressed\+\_\+row\+\_\+flag }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}



Private helper function that is used to assemble the Jacobian matrix in the case when the storage is row or column compressed. The boolean Flag indicates if we want compressed row format (true) or compressed column. This version uses lists. 

This is a (private) helper function that is used to assemble system matrices in compressed row or column format and compute residual vectors using two vectors. The default action is to assemble the jacobian matrix and residuals for the Newton method. The action can be overloaded at an elemental level by chaging the default behaviour of the function Element\+::get\+\_\+all\+\_\+vectors\+\_\+and\+\_\+matrices(). column\+\_\+or\+\_\+row\+\_\+index\+: Column \mbox{[}or row\mbox{]} index of given entry row\+\_\+or\+\_\+column\+\_\+start\+: Index of first entry for given row \mbox{[}or column\mbox{]} value \+: \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of nonzero entries residuals \+: Residual vector compressed\+\_\+row\+\_\+flag\+: Bool flag to indicate if storage format is compressed row \mbox{[}if false interpretation of arguments is as stated in square brackets\mbox{]}. 

Definition at line 6038 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, assembly\+\_\+handler\+\_\+pt(), Communicator\+\_\+pt, e, oomph\+::\+Mesh\+::element\+\_\+pt(), Elemental\+\_\+assembly\+\_\+time, oomph\+::\+Assembly\+Handler\+::eqn\+\_\+number(), First\+\_\+el\+\_\+for\+\_\+assembly, oomph\+::\+Assembly\+Handler\+::get\+\_\+all\+\_\+vectors\+\_\+and\+\_\+matrices(), i, oomph\+::\+Generalised\+Element\+::is\+\_\+halo(), Last\+\_\+el\+\_\+plus\+\_\+one\+\_\+for\+\_\+assembly, mesh\+\_\+pt(), Must\+\_\+recompute\+\_\+load\+\_\+balance\+\_\+for\+\_\+assembly, ndof(), oomph\+::\+Assembly\+Handler\+::ndof(), oomph\+::\+Mesh\+::nelement(), Numerical\+\_\+zero\+\_\+for\+\_\+sparse\+\_\+assembly, oomph\+::oomph\+\_\+info, oomph\+::pause(), Pause\+\_\+at\+\_\+end\+\_\+of\+\_\+sparse\+\_\+assembly, Problem\+\_\+has\+\_\+been\+\_\+distributed, recompute\+\_\+load\+\_\+balanced\+\_\+assembly(), Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+allocation\+\_\+increment, Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+initial\+\_\+allocation, Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+previous\+\_\+allocation, and oomph\+::\+Timing\+Helpers\+::timer().



Referenced by sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed().

\mbox{\Hypertarget{classoomph_1_1Problem_a767f7064ccbdcc2a039e0360b98dc48d}\label{classoomph_1_1Problem_a767f7064ccbdcc2a039e0360b98dc48d}} 
\index{oomph::Problem@{oomph::Problem}!sparse\_assemble\_row\_or\_column\_compressed\_with\_two\_vectors@{sparse\_assemble\_row\_or\_column\_compressed\_with\_two\_vectors}}
\index{sparse\_assemble\_row\_or\_column\_compressed\_with\_two\_vectors@{sparse\_assemble\_row\_or\_column\_compressed\_with\_two\_vectors}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{sparse\_assemble\_row\_or\_column\_compressed\_with\_two\_vectors()}{sparse\_assemble\_row\_or\_column\_compressed\_with\_two\_vectors()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+vectors (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&}]{column\+\_\+or\+\_\+row\+\_\+index,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&}]{row\+\_\+or\+\_\+column\+\_\+start,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&}]{value,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nnz,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&}]{residual,  }\item[{bool}]{compressed\+\_\+row\+\_\+flag }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}



Private helper function that is used to assemble the Jacobian matrix in the case when the storage is row or column compressed. The boolean Flag indicates if we want compressed row format (true) or compressed column. This version uses two vectors. 

This is a (private) helper function that is used to assemble system matrices in compressed row or column format and compute residual vectors using two vectors. The default action is to assemble the jacobian matrix and residuals for the Newton method. The action can be overloaded at an elemental level by chaging the default behaviour of the function Element\+::get\+\_\+all\+\_\+vectors\+\_\+and\+\_\+matrices(). column\+\_\+or\+\_\+row\+\_\+index\+: Column \mbox{[}or row\mbox{]} index of given entry row\+\_\+or\+\_\+column\+\_\+start\+: Index of first entry for given row \mbox{[}or column\mbox{]} value \+: \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of nonzero entries residuals \+: Residual vector compressed\+\_\+row\+\_\+flag\+: Bool flag to indicate if storage format is compressed row \mbox{[}if false interpretation of arguments is as stated in square brackets\mbox{]}. 

Definition at line 5675 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, assembly\+\_\+handler\+\_\+pt(), Communicator\+\_\+pt, e, oomph\+::\+Mesh\+::element\+\_\+pt(), Elemental\+\_\+assembly\+\_\+time, oomph\+::\+Assembly\+Handler\+::eqn\+\_\+number(), First\+\_\+el\+\_\+for\+\_\+assembly, oomph\+::\+Assembly\+Handler\+::get\+\_\+all\+\_\+vectors\+\_\+and\+\_\+matrices(), i, oomph\+::\+Generalised\+Element\+::is\+\_\+halo(), Last\+\_\+el\+\_\+plus\+\_\+one\+\_\+for\+\_\+assembly, mesh\+\_\+pt(), Must\+\_\+recompute\+\_\+load\+\_\+balance\+\_\+for\+\_\+assembly, ndof(), oomph\+::\+Assembly\+Handler\+::ndof(), oomph\+::\+Mesh\+::nelement(), Numerical\+\_\+zero\+\_\+for\+\_\+sparse\+\_\+assembly, oomph\+::oomph\+\_\+info, oomph\+::pause(), Pause\+\_\+at\+\_\+end\+\_\+of\+\_\+sparse\+\_\+assembly, Problem\+\_\+has\+\_\+been\+\_\+distributed, recompute\+\_\+load\+\_\+balanced\+\_\+assembly(), and oomph\+::\+Timing\+Helpers\+::timer().



Referenced by sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed().

\mbox{\Hypertarget{classoomph_1_1Problem_a3d5d5ac657381a2b2b077988e887fef8}\label{classoomph_1_1Problem_a3d5d5ac657381a2b2b077988e887fef8}} 
\index{oomph::Problem@{oomph::Problem}!sparse\_assemble\_row\_or\_column\_compressed\_with\_vectors\_of\_pairs@{sparse\_assemble\_row\_or\_column\_compressed\_with\_vectors\_of\_pairs}}
\index{sparse\_assemble\_row\_or\_column\_compressed\_with\_vectors\_of\_pairs@{sparse\_assemble\_row\_or\_column\_compressed\_with\_vectors\_of\_pairs}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{sparse\_assemble\_row\_or\_column\_compressed\_with\_vectors\_of\_pairs()}{sparse\_assemble\_row\_or\_column\_compressed\_with\_vectors\_of\_pairs()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+vectors\+\_\+of\+\_\+pairs (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&}]{column\+\_\+or\+\_\+row\+\_\+index,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ int $\ast$ $>$ \&}]{row\+\_\+or\+\_\+column\+\_\+start,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&}]{value,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ unsigned $>$ \&}]{nnz,  }\item[{\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$ double $\ast$ $>$ \&}]{residual,  }\item[{bool}]{compressed\+\_\+row\+\_\+flag }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}



Private helper function that is used to assemble the Jacobian matrix in the case when the storage is row or column compressed. The boolean Flag indicates if we want compressed row format (true) or compressed column. This version uses vectors of pairs. 

This is a (private) helper function that is used to assemble system matrices in compressed row or column format and compute residual vectors using vectors of pairs The default action is to assemble the jacobian matrix and residuals for the Newton method. The action can be overloaded at an elemental level by chaging the default behaviour of the function Element\+::get\+\_\+all\+\_\+vectors\+\_\+and\+\_\+matrices(). column\+\_\+or\+\_\+row\+\_\+index\+: Column \mbox{[}or row\mbox{]} index of given entry row\+\_\+or\+\_\+column\+\_\+start\+: Index of first entry for given row \mbox{[}or column\mbox{]} value \+: \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of nonzero entries residuals \+: Residual vector compressed\+\_\+row\+\_\+flag\+: Bool flag to indicate if storage format is compressed row \mbox{[}if false interpretation of arguments is as stated in square brackets\mbox{]}. 

Definition at line 5322 of file problem.\+cc.



References Assembly\+\_\+handler\+\_\+pt, assembly\+\_\+handler\+\_\+pt(), Communicator\+\_\+pt, e, oomph\+::\+Mesh\+::element\+\_\+pt(), Elemental\+\_\+assembly\+\_\+time, oomph\+::\+Assembly\+Handler\+::eqn\+\_\+number(), First\+\_\+el\+\_\+for\+\_\+assembly, oomph\+::\+Assembly\+Handler\+::get\+\_\+all\+\_\+vectors\+\_\+and\+\_\+matrices(), i, oomph\+::\+Generalised\+Element\+::is\+\_\+halo(), Last\+\_\+el\+\_\+plus\+\_\+one\+\_\+for\+\_\+assembly, mesh\+\_\+pt(), Must\+\_\+recompute\+\_\+load\+\_\+balance\+\_\+for\+\_\+assembly, ndof(), oomph\+::\+Assembly\+Handler\+::ndof(), oomph\+::\+Mesh\+::nelement(), Numerical\+\_\+zero\+\_\+for\+\_\+sparse\+\_\+assembly, oomph\+::oomph\+\_\+info, oomph\+::pause(), Pause\+\_\+at\+\_\+end\+\_\+of\+\_\+sparse\+\_\+assembly, Problem\+\_\+has\+\_\+been\+\_\+distributed, recompute\+\_\+load\+\_\+balanced\+\_\+assembly(), and oomph\+::\+Timing\+Helpers\+::timer().



Referenced by sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed().

\mbox{\Hypertarget{classoomph_1_1Problem_a6de9b126bf5c8fce5d8e9602fa151090}\label{classoomph_1_1Problem_a6de9b126bf5c8fce5d8e9602fa151090}} 
\index{oomph::Problem@{oomph::Problem}!steady\_newton\_solve@{steady\_newton\_solve}}
\index{steady\_newton\_solve@{steady\_newton\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{steady\_newton\_solve()}{steady\_newton\_solve()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::steady\+\_\+newton\+\_\+solve (\begin{DoxyParamCaption}\item[{unsigned const \&}]{max\+\_\+adapt = {\ttfamily 0} }\end{DoxyParamCaption})}



Solve a steady problem using adaptive Newton\textquotesingle{}s method, but in the context of an overall unstady problem, perhaps to determine an initial condition. This is achieved by setting the weights in the timesteppers to be zero which has the effect of rendering them steady timesteppers. The optional argument max\+\_\+adapt specifies the max. number of adaptations of all refineable submeshes are performed to achieve the the error targets specified in the refineable submeshes. 

Solve a steady problem, in the context of an overall unsteady problem. This is achieved by setting the weights in the timesteppers to be zero which has the effect of rendering them steady timesteppers The optional argument max\+\_\+adapt specifies the max. number of adaptations of all refineable submeshes are performed to achieve the the error targets specified in the refineable submeshes. 

Definition at line 9485 of file problem.\+cc.



References assign\+\_\+initial\+\_\+values\+\_\+impulsive(), i, oomph\+::\+Time\+Stepper\+::is\+\_\+steady(), oomph\+::\+Newton\+Solver\+Error\+::iterations, oomph\+::\+Newton\+Solver\+Error\+::linear\+\_\+solver\+\_\+error, oomph\+::\+Time\+Stepper\+::make\+\_\+steady(), Max\+\_\+newton\+\_\+iterations, Max\+\_\+residuals, oomph\+::\+Newton\+Solver\+Error\+::maxres, newton\+\_\+solve(), ntime\+\_\+stepper(), oomph\+::oomph\+\_\+info, time\+\_\+stepper\+\_\+pt(), and oomph\+::\+Time\+Stepper\+::undo\+\_\+make\+\_\+steady().

\mbox{\Hypertarget{classoomph_1_1Problem_a5a2906b9a6a22445d1dbb8aebbce9fa7}\label{classoomph_1_1Problem_a5a2906b9a6a22445d1dbb8aebbce9fa7}} 
\index{oomph::Problem@{oomph::Problem}!store\_current\_dof\_values@{store\_current\_dof\_values}}
\index{store\_current\_dof\_values@{store\_current\_dof\_values}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{store\_current\_dof\_values()}{store\_current\_dof\_values()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::store\+\_\+current\+\_\+dof\+\_\+values (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Store the current values of the degrees of freedom. 

Stored the current values of the dofs. 

Definition at line 8787 of file problem.\+cc.



References dof(), Dof\+\_\+distribution\+\_\+pt, Dof\+\_\+pt, i, ndof(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow\+\_\+local(), Problem\+\_\+has\+\_\+been\+\_\+distributed, and Saved\+\_\+dof\+\_\+pt.



Referenced by calculate\+\_\+predictions().

\mbox{\Hypertarget{classoomph_1_1Problem_abbcf4965b6052758e49cf511947fd3f0}\label{classoomph_1_1Problem_abbcf4965b6052758e49cf511947fd3f0}} 
\index{oomph::Problem@{oomph::Problem}!symmetrise\_eigenfunction\_for\_adaptive\_pitchfork\_tracking@{symmetrise\_eigenfunction\_for\_adaptive\_pitchfork\_tracking}}
\index{symmetrise\_eigenfunction\_for\_adaptive\_pitchfork\_tracking@{symmetrise\_eigenfunction\_for\_adaptive\_pitchfork\_tracking}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{symmetrise\_eigenfunction\_for\_adaptive\_pitchfork\_tracking()}{symmetrise\_eigenfunction\_for\_adaptive\_pitchfork\_tracking()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::symmetrise\+\_\+eigenfunction\+\_\+for\+\_\+adaptive\+\_\+pitchfork\+\_\+tracking (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Virtual function that is used to symmetrise the problem so that the current solution exactly satisfies any symmetries within the system. Used when adpativly solving pitchfork detection problems when small asymmetries in the coarse solution can be magnified leading to very inaccurate answers on the fine mesh. This is always problem-\/specific and must be filled in by the user The default issues a warning. 



Definition at line 10252 of file problem.\+cc.

\mbox{\Hypertarget{classoomph_1_1Problem_a5d9a3ba5696a7bcd275223ff16b7392e}\label{classoomph_1_1Problem_a5d9a3ba5696a7bcd275223ff16b7392e}} 
\index{oomph::Problem@{oomph::Problem}!synchronise\_all\_dofs@{synchronise\_all\_dofs}}
\index{synchronise\_all\_dofs@{synchronise\_all\_dofs}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{synchronise\_all\_dofs()}{synchronise\_all\_dofs()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::synchronise\+\_\+all\+\_\+dofs (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Perform all required synchronisation in solvers. 

Synchronise all dofs by calling the appropriate synchronisation routines for all meshes and the assembly handler. 

Definition at line 16632 of file problem.\+cc.



References assembly\+\_\+handler\+\_\+pt(), oomph\+::\+Assembly\+Handler\+::synchronise(), and synchronise\+\_\+dofs().



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), add\+\_\+eigenvector\+\_\+to\+\_\+dofs(), assign\+\_\+eigenvector\+\_\+to\+\_\+dofs(), load\+\_\+balance(), newton\+\_\+solve(), and newton\+\_\+solve\+\_\+continuation().

\mbox{\Hypertarget{classoomph_1_1Problem_a1ccef4e26a7788424780da7555cdc772}\label{classoomph_1_1Problem_a1ccef4e26a7788424780da7555cdc772}} 
\index{oomph::Problem@{oomph::Problem}!synchronise\_dofs@{synchronise\_dofs}}
\index{synchronise\_dofs@{synchronise\_dofs}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{synchronise\_dofs()}{synchronise\_dofs()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::synchronise\+\_\+dofs (\begin{DoxyParamCaption}\item[{const bool \&}]{do\+\_\+halos,  }\item[{const bool \&}]{do\+\_\+external\+\_\+halos }\end{DoxyParamCaption})}



Synchronise the degrees of freedom by overwriting the haloed values with their non-\/halo counterparts held on other processors. Bools control if we deal with data associated with external halo/ed elements/nodes or the \char`\"{}normal\char`\"{} halo/ed ones. 



Definition at line 16655 of file problem.\+cc.



References oomph\+::\+Generalised\+Element\+::add\+\_\+internal\+\_\+data\+\_\+values\+\_\+to\+\_\+vector(), oomph\+::\+Node\+::add\+\_\+values\+\_\+to\+\_\+vector(), communicator\+\_\+pt(), e, oomph\+::\+Mesh\+::external\+\_\+halo\+\_\+element\+\_\+pt(), oomph\+::\+Mesh\+::external\+\_\+halo\+\_\+node\+\_\+pt(), oomph\+::\+Mesh\+::external\+\_\+haloed\+\_\+element\+\_\+pt(), oomph\+::\+Mesh\+::external\+\_\+haloed\+\_\+node\+\_\+pt(), oomph\+::\+Mesh\+::halo\+\_\+element\+\_\+pt(), oomph\+::\+Mesh\+::halo\+\_\+node\+\_\+pt(), oomph\+::\+Mesh\+::haloed\+\_\+element\+\_\+pt(), oomph\+::\+Mesh\+::haloed\+\_\+node\+\_\+pt(), mesh\+\_\+pt(), oomph\+::\+Mesh\+::nexternal\+\_\+halo\+\_\+element(), oomph\+::\+Mesh\+::nexternal\+\_\+halo\+\_\+node(), oomph\+::\+Mesh\+::nexternal\+\_\+haloed\+\_\+element(), oomph\+::\+Mesh\+::nexternal\+\_\+haloed\+\_\+node(), oomph\+::\+Mesh\+::nhalo\+\_\+node(), oomph\+::\+Mesh\+::nhaloed\+\_\+node(), nsub\+\_\+mesh(), oomph\+::\+Generalised\+Element\+::read\+\_\+internal\+\_\+data\+\_\+values\+\_\+from\+\_\+vector(), and oomph\+::\+Node\+::read\+\_\+values\+\_\+from\+\_\+vector().



Referenced by send\+\_\+data\+\_\+to\+\_\+be\+\_\+sent\+\_\+during\+\_\+load\+\_\+balancing(), and synchronise\+\_\+all\+\_\+dofs().

\mbox{\Hypertarget{classoomph_1_1Problem_a9a9ce9ee869ff79ee5596e434309f379}\label{classoomph_1_1Problem_a9a9ce9ee869ff79ee5596e434309f379}} 
\index{oomph::Problem@{oomph::Problem}!synchronise\_eqn\_numbers@{synchronise\_eqn\_numbers}}
\index{synchronise\_eqn\_numbers@{synchronise\_eqn\_numbers}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{synchronise\_eqn\_numbers()}{synchronise\_eqn\_numbers()}}
{\footnotesize\ttfamily long oomph\+::\+Problem\+::synchronise\+\_\+eqn\+\_\+numbers (\begin{DoxyParamCaption}\item[{const bool \&}]{assign\+\_\+local\+\_\+eqn\+\_\+numbers = {\ttfamily true} }\end{DoxyParamCaption})}



Classify any non-\/classified nodes into halo/haloed and synchronise equation numbers. Return the total number of degrees of freedom in the overall problem. 

Synchronise equation numbers and return the total number of degrees of freedom in the overall problem. 

Definition at line 16898 of file problem.\+cc.



References oomph\+::\+Mesh\+::assign\+\_\+local\+\_\+eqn\+\_\+numbers(), oomph\+::\+Linear\+Algebra\+Distribution\+::build(), Communicator\+\_\+pt, copy\+\_\+haloed\+\_\+eqn\+\_\+numbers\+\_\+helper(), oomph\+::\+Global\+\_\+timings\+::\+Doc\+\_\+comprehensive\+\_\+timings, Dof\+\_\+distribution\+\_\+pt, Dof\+\_\+pt, e, oomph\+::\+Mesh\+::element\+\_\+pt(), oomph\+::\+Data\+::eqn\+\_\+number(), i, oomph\+::\+Generalised\+Element\+::internal\+\_\+data\+\_\+pt(), mesh\+\_\+pt(), oomph\+::\+Mesh\+::nelement(), oomph\+::\+Generalised\+Element\+::ninternal\+\_\+data(), oomph\+::\+Mesh\+::nnode(), oomph\+::\+Mesh\+::node\+\_\+pt(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow(), nsub\+\_\+mesh(), oomph\+::\+Data\+::nvalue(), oomph\+::oomph\+\_\+info, Store\+\_\+local\+\_\+dof\+\_\+pt\+\_\+in\+\_\+elements, oomph\+::\+Timing\+Helpers\+::timer(), and oomph\+::\+Solid\+Node\+::variable\+\_\+position\+\_\+pt().



Referenced by assign\+\_\+eqn\+\_\+numbers().

\mbox{\Hypertarget{classoomph_1_1Problem_acd8c357349d20a28af70b2b7ea7f488d}\label{classoomph_1_1Problem_acd8c357349d20a28af70b2b7ea7f488d}} 
\index{oomph::Problem@{oomph::Problem}!time@{time}}
\index{time@{time}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{time()}{time()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double \& oomph\+::\+Problem\+::time (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Return the current value of continuous time. 

Return the current value of continuous time. If not \mbox{\hyperlink{classoomph_1_1Time}{Time}} object has been assigned, then throw an error. 

Reimplemented from \mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject_a42fde674301963f01b8e41b3f333cc65}{oomph\+::\+Explicit\+Time\+Steppable\+Object}}.



Definition at line 11724 of file problem.\+cc.



References oomph\+::\+Time\+::time(), and Time\+\_\+pt.



Referenced by oomph\+::\+Womersley\+Problem$<$ ELEMENT, DIM $>$\+::actions\+\_\+before\+\_\+implicit\+\_\+timestep(), calculate\+\_\+predictions(), read(), oomph\+::\+Solid\+ICProblem\+::set\+\_\+static\+\_\+initial\+\_\+condition(), and oomph\+::\+Segregatable\+FSIProblem\+::t\+\_\+spent\+\_\+on\+\_\+actual\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a925acb2e840deb4edc6305da8fced0e3}\label{classoomph_1_1Problem_a925acb2e840deb4edc6305da8fced0e3}} 
\index{oomph::Problem@{oomph::Problem}!time@{time}}
\index{time@{time}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{time()}{time()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::time (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Return the current value of continuous time (const version) 

Return the current value of continuous time. If not \mbox{\hyperlink{classoomph_1_1Time}{Time}} object has been assigned, then throw an error. Const version. 

Definition at line 11742 of file problem.\+cc.



References oomph\+::\+Time\+::time(), and Time\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1Problem_a7a42b89a67e0770c68493b9569bffe16}\label{classoomph_1_1Problem_a7a42b89a67e0770c68493b9569bffe16}} 
\index{oomph::Problem@{oomph::Problem}!time\_adaptive\_newton\_crash\_on\_solve\_fail@{time\_adaptive\_newton\_crash\_on\_solve\_fail}}
\index{time\_adaptive\_newton\_crash\_on\_solve\_fail@{time\_adaptive\_newton\_crash\_on\_solve\_fail}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{time\_adaptive\_newton\_crash\_on\_solve\_fail()}{time\_adaptive\_newton\_crash\_on\_solve\_fail()}}
{\footnotesize\ttfamily bool\& oomph\+::\+Problem\+::time\+\_\+adaptive\+\_\+newton\+\_\+crash\+\_\+on\+\_\+solve\+\_\+fail (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access function for Time\+\_\+adaptive\+\_\+newton\+\_\+crash\+\_\+on\+\_\+solve\+\_\+fail. 



Definition at line 1614 of file problem.\+h.



References Time\+\_\+adaptive\+\_\+newton\+\_\+crash\+\_\+on\+\_\+solve\+\_\+fail.

\mbox{\Hypertarget{classoomph_1_1Problem_a46894b13c582f322082dc471a2485980}\label{classoomph_1_1Problem_a46894b13c582f322082dc471a2485980}} 
\index{oomph::Problem@{oomph::Problem}!time\_pt@{time\_pt}}
\index{time\_pt@{time\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{time\_pt()}{time\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Time}{Time}}$\ast$\& oomph\+::\+Problem\+::time\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the global time object. 



Definition at line 1504 of file problem.\+h.



References Time\+\_\+pt.



Referenced by oomph\+::\+IMRBy\+BDF\+::actions\+\_\+after\+\_\+timestep(), oomph\+::\+Womersley\+Problem$<$ ELEMENT, DIM $>$\+::actions\+\_\+before\+\_\+implicit\+\_\+timestep(), oomph\+::\+Periodic\+Orbit\+Assembly\+Handler$<$ NNODE\+\_\+1\+D $>$\+::adapt\+\_\+temporal\+\_\+mesh(), adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), calculate\+\_\+predictions(), copy(), doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve\+\_\+helper(), dump(), explicit\+\_\+timestep(), read(), unsteady\+\_\+newton\+\_\+solve(), and oomph\+::\+Segregatable\+FSIProblem\+::unsteady\+\_\+segregated\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_aa86b09eac493cfa9fcbe57734985ba19}\label{classoomph_1_1Problem_aa86b09eac493cfa9fcbe57734985ba19}} 
\index{oomph::Problem@{oomph::Problem}!time\_pt@{time\_pt}}
\index{time\_pt@{time\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{time\_pt()}{time\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Time}{Time}}$\ast$ oomph\+::\+Problem\+::time\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Return a pointer to the global time object (const version). 



Reimplemented from \mbox{\hyperlink{classoomph_1_1ExplicitTimeSteppableObject_a49ecd5e667dc16d4f2b991598d311b36}{oomph\+::\+Explicit\+Time\+Steppable\+Object}}.



Definition at line 1510 of file problem.\+h.



References Time\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1Problem_ad77413dc70a25d271f582ad3c3d7bf65}\label{classoomph_1_1Problem_ad77413dc70a25d271f582ad3c3d7bf65}} 
\index{oomph::Problem@{oomph::Problem}!time\_stepper\_pt@{time\_stepper\_pt}}
\index{time\_stepper\_pt@{time\_stepper\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{time\_stepper\_pt()}{time\_stepper\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}}$\ast$\& oomph\+::\+Problem\+::time\+\_\+stepper\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access function for the pointer to the first (presumably only) timestepper. 



Definition at line 1524 of file problem.\+h.



References Time\+\_\+stepper\+\_\+pt.



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), add\+\_\+time\+\_\+stepper\+\_\+pt(), arc\+\_\+length\+\_\+step\+\_\+solve(), arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), calculate\+\_\+predictions(), oomph\+::\+Multi\+\_\+domain\+\_\+functions\+::construct\+\_\+new\+\_\+external\+\_\+halo\+\_\+master\+\_\+node\+\_\+helper(), oomph\+::\+Multi\+\_\+domain\+\_\+functions\+::construct\+\_\+new\+\_\+external\+\_\+halo\+\_\+node\+\_\+helper(), copy(), get\+\_\+dvaluesdt(), oomph\+::\+Multi\+\_\+domain\+\_\+functions\+::get\+\_\+required\+\_\+master\+\_\+nodal\+\_\+information\+\_\+helper(), oomph\+::\+Multi\+\_\+domain\+\_\+functions\+::get\+\_\+required\+\_\+nodal\+\_\+information\+\_\+helper(), initialise\+\_\+dt(), set\+\_\+timestepper\+\_\+for\+\_\+all\+\_\+data(), solve\+\_\+adjoint\+\_\+eigenproblem(), solve\+\_\+adjoint\+\_\+eigenproblem\+\_\+legacy(), solve\+\_\+eigenproblem(), solve\+\_\+eigenproblem\+\_\+legacy(), steady\+\_\+newton\+\_\+solve(), oomph\+::\+Segregatable\+FSIProblem\+::steady\+\_\+segregated\+\_\+solve(), unsteady\+\_\+newton\+\_\+solve(), oomph\+::\+Segregatable\+FSIProblem\+::unsteady\+\_\+segregated\+\_\+solve(), and oomph\+::\+Womersley\+Problem$<$ ELEMENT, DIM $>$\+::\+Womersley\+Problem().

\mbox{\Hypertarget{classoomph_1_1Problem_a3f952a57b5238978250849c04e2fcbdb}\label{classoomph_1_1Problem_a3f952a57b5238978250849c04e2fcbdb}} 
\index{oomph::Problem@{oomph::Problem}!time\_stepper\_pt@{time\_stepper\_pt}}
\index{time\_stepper\_pt@{time\_stepper\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{time\_stepper\_pt()}{time\_stepper\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily const \mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}}$\ast$ oomph\+::\+Problem\+::time\+\_\+stepper\+\_\+pt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Access function for the pointer to the first (presumably only) timestepper. 



Definition at line 1537 of file problem.\+h.



References Time\+\_\+stepper\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1Problem_a76cda2a0a02815a3de446723a2334293}\label{classoomph_1_1Problem_a76cda2a0a02815a3de446723a2334293}} 
\index{oomph::Problem@{oomph::Problem}!time\_stepper\_pt@{time\_stepper\_pt}}
\index{time\_stepper\_pt@{time\_stepper\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{time\_stepper\_pt()}{time\_stepper\_pt()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}}$\ast$\& oomph\+::\+Problem\+::time\+\_\+stepper\+\_\+pt (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Return a pointer to the i-\/th timestepper. 



Definition at line 1549 of file problem.\+h.



References i, and Time\+\_\+stepper\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1Problem_a10dae99dec2f8202887f4e49e175f39c}\label{classoomph_1_1Problem_a10dae99dec2f8202887f4e49e175f39c}} 
\index{oomph::Problem@{oomph::Problem}!unrefine\_uniformly@{unrefine\_uniformly}}
\index{unrefine\_uniformly@{unrefine\_uniformly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{unrefine\_uniformly()}{unrefine\_uniformly()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::unrefine\+\_\+uniformly (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Refine (all) refineable (sub)mesh(es) uniformly and rebuild problem. Return 0 for success, 1 for failure (if unrefinement has reached the coarsest permitted level) 

Unrefine (all) refineable (sub)mesh(es) uniformly and rebuild problem. Return 0 for success, 1 for failure (if unrefinement has reached the coarsest permitted level) 

Definition at line 16024 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, and rebuild\+\_\+global\+\_\+mesh().

\mbox{\Hypertarget{classoomph_1_1Problem_aadd2996d4046e5a6176c92f4abc899d5}\label{classoomph_1_1Problem_aadd2996d4046e5a6176c92f4abc899d5}} 
\index{oomph::Problem@{oomph::Problem}!unrefine\_uniformly@{unrefine\_uniformly}}
\index{unrefine\_uniformly@{unrefine\_uniformly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{unrefine\_uniformly()}{unrefine\_uniformly()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::unrefine\+\_\+uniformly (\begin{DoxyParamCaption}\item[{const unsigned \&}]{i\+\_\+mesh }\end{DoxyParamCaption})}



Do uniform refinement for submesh i\+\_\+mesh without documentation. Return 0 for success, 1 for failure (if unrefinement has reached the coarsest permitted level) 

Unrefine submesh i\+\_\+mesh uniformly and rebuild problem. Return 0 for success, 1 for failure (if unrefinement has reached the coarsest permitted level) 

Definition at line 16095 of file problem.\+cc.



References actions\+\_\+after\+\_\+adapt(), actions\+\_\+before\+\_\+adapt(), assign\+\_\+eqn\+\_\+numbers(), mesh\+\_\+pt(), nsub\+\_\+mesh(), oomph\+::oomph\+\_\+info, and rebuild\+\_\+global\+\_\+mesh().

\mbox{\Hypertarget{classoomph_1_1Problem_aff7bcab5505ba482a8c9ba7bace68bc0}\label{classoomph_1_1Problem_aff7bcab5505ba482a8c9ba7bace68bc0}} 
\index{oomph::Problem@{oomph::Problem}!unset\_analytic\_dparameter@{unset\_analytic\_dparameter}}
\index{unset\_analytic\_dparameter@{unset\_analytic\_dparameter}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{unset\_analytic\_dparameter()}{unset\_analytic\_dparameter()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::unset\+\_\+analytic\+\_\+dparameter (\begin{DoxyParamCaption}\item[{double $\ast$const \&}]{parameter\+\_\+pt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Function to turn off analytic calculation of the parameter derivatives in continuation and bifurcation detection problems. 



Definition at line 263 of file problem.\+h.



References Calculate\+\_\+dparameter\+\_\+analytic.

\mbox{\Hypertarget{classoomph_1_1Problem_accd672b3da8c5bf28ad6bd856e28d1cf}\label{classoomph_1_1Problem_accd672b3da8c5bf28ad6bd856e28d1cf}} 
\index{oomph::Problem@{oomph::Problem}!unset\_analytic\_hessian\_products@{unset\_analytic\_hessian\_products}}
\index{unset\_analytic\_hessian\_products@{unset\_analytic\_hessian\_products}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{unset\_analytic\_hessian\_products()}{unset\_analytic\_hessian\_products()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::unset\+\_\+analytic\+\_\+hessian\+\_\+products (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Function to turn off analytic calculation of the parameter derivatives in continuation and bifurcation detection problems. 



Definition at line 296 of file problem.\+h.



References Calculate\+\_\+hessian\+\_\+products\+\_\+analytic.

\mbox{\Hypertarget{classoomph_1_1Problem_a1157876a05d112d523be03d9c30464de}\label{classoomph_1_1Problem_a1157876a05d112d523be03d9c30464de}} 
\index{oomph::Problem@{oomph::Problem}!unset\_default\_partition\_in\_load\_balance@{unset\_default\_partition\_in\_load\_balance}}
\index{unset\_default\_partition\_in\_load\_balance@{unset\_default\_partition\_in\_load\_balance}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{unset\_default\_partition\_in\_load\_balance()}{unset\_default\_partition\_in\_load\_balance()}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::unset\+\_\+default\+\_\+partition\+\_\+in\+\_\+load\+\_\+balance (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Do not use the default partition in the load balance. 



Definition at line 1451 of file problem.\+h.



References Use\+\_\+default\+\_\+partition\+\_\+in\+\_\+load\+\_\+balance.

\mbox{\Hypertarget{classoomph_1_1Problem_aef22157aadc15a512cca93e4c423ff73}\label{classoomph_1_1Problem_aef22157aadc15a512cca93e4c423ff73}} 
\index{oomph::Problem@{oomph::Problem}!unsteady\_newton\_solve@{unsteady\_newton\_solve}}
\index{unsteady\_newton\_solve@{unsteady\_newton\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{unsteady\_newton\_solve()}{unsteady\_newton\_solve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::unsteady\+\_\+newton\+\_\+solve (\begin{DoxyParamCaption}\item[{const double \&}]{dt }\end{DoxyParamCaption})}



Advance time by dt and solve by Newton\textquotesingle{}s method. This version always shifts time values. 

Do one timestep of size dt using Newton\textquotesingle{}s method with the specified tolerance and linear solver defined as member data of the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} class. This will be the most commonly used version of unsteady\+\_\+newton\+\_\+solve, in which the time values are always shifted This does not include any kind of adaptativity. If the solution fails to converge the program will end. 

Definition at line 11146 of file problem.\+cc.



Referenced by doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve\+\_\+helper(), and unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_abf8b8c9ee09df0ba8934382740a588de}\label{classoomph_1_1Problem_abf8b8c9ee09df0ba8934382740a588de}} 
\index{oomph::Problem@{oomph::Problem}!unsteady\_newton\_solve@{unsteady\_newton\_solve}}
\index{unsteady\_newton\_solve@{unsteady\_newton\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{unsteady\_newton\_solve()}{unsteady\_newton\_solve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::unsteady\+\_\+newton\+\_\+solve (\begin{DoxyParamCaption}\item[{const double \&}]{dt,  }\item[{const bool \&}]{shift\+\_\+values }\end{DoxyParamCaption})}



Advance time by dt and solve the system, using Newton\textquotesingle{}s method. The boolean flag is used to control whether the time values should be shifted. If it is true the current data values will be shifted (copied to the locations where there are stored as previous timesteps) before solution. 

Do one timestep forward of size dt using Newton\textquotesingle{}s method with the specified tolerance and linear solver defined via member data of the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} class. The boolean flag shift\+\_\+values is used to control whether the time values should be shifted or not. 

Definition at line 11159 of file problem.\+cc.



References actions\+\_\+after\+\_\+implicit\+\_\+timestep(), actions\+\_\+after\+\_\+implicit\+\_\+timestep\+\_\+and\+\_\+error\+\_\+estimation(), oomph\+::\+Time\+Stepper\+::actions\+\_\+after\+\_\+timestep(), actions\+\_\+before\+\_\+implicit\+\_\+timestep(), oomph\+::\+Time\+Stepper\+::actions\+\_\+before\+\_\+timestep(), oomph\+::\+Time\+::dt(), i, oomph\+::\+Newton\+Solver\+Error\+::iterations, oomph\+::\+Newton\+Solver\+Error\+::linear\+\_\+solver\+\_\+error, Max\+\_\+newton\+\_\+iterations, Max\+\_\+residuals, oomph\+::\+Newton\+Solver\+Error\+::maxres, newton\+\_\+solve(), ntime\+\_\+stepper(), oomph\+::oomph\+\_\+info, oomph\+::\+Time\+Stepper\+::set\+\_\+weights(), shift\+\_\+time\+\_\+values(), oomph\+::\+Time\+::time(), time\+\_\+pt(), and time\+\_\+stepper\+\_\+pt().

\mbox{\Hypertarget{classoomph_1_1Problem_af26bd71c24ba99c9391d6e932b68e5e8}\label{classoomph_1_1Problem_af26bd71c24ba99c9391d6e932b68e5e8}} 
\index{oomph::Problem@{oomph::Problem}!unsteady\_newton\_solve@{unsteady\_newton\_solve}}
\index{unsteady\_newton\_solve@{unsteady\_newton\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{unsteady\_newton\_solve()}{unsteady\_newton\_solve()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void oomph\+::\+Problem\+::unsteady\+\_\+newton\+\_\+solve (\begin{DoxyParamCaption}\item[{const double \&}]{dt,  }\item[{const unsigned \&}]{max\+\_\+adapt,  }\item[{const bool \&}]{first,  }\item[{const bool \&}]{shift = {\ttfamily true} }\end{DoxyParamCaption})}



Unsteady adaptive Newton solve\+: up to max\+\_\+adapt adaptations of all refineable submeshes are performed to achieve the the error targets specified in the refineable submeshes. If first==true, the initial conditions are re-\/assigned after the mesh adaptations. Shifting of time can be suppressed by overwriting the default value of shift (true). \mbox{[}Shifting must be done if first\+\_\+timestep==true because we\textquotesingle{}re constantly re-\/assigning the initial conditions; if first\+\_\+timestep==true and shift==false shifting is performed anyway and a warning is issued. 

Do one timestep, dt, forward using Newton\textquotesingle{}s method with specified tolerance and linear solver specified via member data. Keep adapting on all meshes to criteria specified in these meshes (up to max\+\_\+adapt adaptations are performed). If first\+\_\+timestep==true, re-\/set initial conditions after mesh adaptation. Shifting of time can be suppressed by overwriting the default value of shift (true). \mbox{[}Shifting must be done if first\+\_\+timestep==true because we\textquotesingle{}re constantly re-\/assigning the initial conditions; if first\+\_\+timestep==true and shift==false shifting is performed anyway and a warning is issued. 

Definition at line 16265 of file problem.\+cc.



References adapt(), communicator\+\_\+pt(), Default\+\_\+set\+\_\+initial\+\_\+condition\+\_\+called, oomph\+::oomph\+\_\+info, Problem\+\_\+has\+\_\+been\+\_\+distributed, set\+\_\+initial\+\_\+condition(), oomph\+::\+Time\+::time(), time\+\_\+pt(), and unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a438bf1c7aafffda56f2acb34ba027fdb}\label{classoomph_1_1Problem_a438bf1c7aafffda56f2acb34ba027fdb}} 
\index{oomph::Problem@{oomph::Problem}!use\_predictor\_values\_as\_initial\_guess@{use\_predictor\_values\_as\_initial\_guess}}
\index{use\_predictor\_values\_as\_initial\_guess@{use\_predictor\_values\_as\_initial\_guess}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{use\_predictor\_values\_as\_initial\_guess()}{use\_predictor\_values\_as\_initial\_guess()}}
{\footnotesize\ttfamily bool\& oomph\+::\+Problem\+::use\+\_\+predictor\+\_\+values\+\_\+as\+\_\+initial\+\_\+guess (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 2123 of file problem.\+h.



References Use\+\_\+predictor\+\_\+values\+\_\+as\+\_\+initial\+\_\+guess.



Referenced by oomph\+::\+IMRBy\+BDF\+::actions\+\_\+before\+\_\+timestep(), and calculate\+\_\+predictions().



\doxysubsection{Friends And Related Function Documentation}
\mbox{\Hypertarget{classoomph_1_1Problem_a29d9c39e6a14d2a4cc4e0d7c716579fe}\label{classoomph_1_1Problem_a29d9c39e6a14d2a4cc4e0d7c716579fe}} 
\index{oomph::Problem@{oomph::Problem}!AugmentedBlockFoldLinearSolver@{AugmentedBlockFoldLinearSolver}}
\index{AugmentedBlockFoldLinearSolver@{AugmentedBlockFoldLinearSolver}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{AugmentedBlockFoldLinearSolver}{AugmentedBlockFoldLinearSolver}}
{\footnotesize\ttfamily friend class \mbox{\hyperlink{classoomph_1_1AugmentedBlockFoldLinearSolver}{Augmented\+Block\+Fold\+Linear\+Solver}}\hspace{0.3cm}{\ttfamily [friend]}}



Definition at line 160 of file problem.\+h.



Referenced by activate\+\_\+bifurcation\+\_\+tracking(), and activate\+\_\+fold\+\_\+tracking().

\mbox{\Hypertarget{classoomph_1_1Problem_a223dd55e02e905ce0ce98e98f50b7e57}\label{classoomph_1_1Problem_a223dd55e02e905ce0ce98e98f50b7e57}} 
\index{oomph::Problem@{oomph::Problem}!AugmentedBlockPitchForkLinearSolver@{AugmentedBlockPitchForkLinearSolver}}
\index{AugmentedBlockPitchForkLinearSolver@{AugmentedBlockPitchForkLinearSolver}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{AugmentedBlockPitchForkLinearSolver}{AugmentedBlockPitchForkLinearSolver}}
{\footnotesize\ttfamily friend class \mbox{\hyperlink{classoomph_1_1AugmentedBlockPitchForkLinearSolver}{Augmented\+Block\+Pitch\+Fork\+Linear\+Solver}}\hspace{0.3cm}{\ttfamily [friend]}}



Definition at line 161 of file problem.\+h.

\mbox{\Hypertarget{classoomph_1_1Problem_a32e190795c94d11d2e206e62eb63994b}\label{classoomph_1_1Problem_a32e190795c94d11d2e206e62eb63994b}} 
\index{oomph::Problem@{oomph::Problem}!BlockFoldLinearSolver@{BlockFoldLinearSolver}}
\index{BlockFoldLinearSolver@{BlockFoldLinearSolver}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{BlockFoldLinearSolver}{BlockFoldLinearSolver}}
{\footnotesize\ttfamily friend class Block\+Fold\+Linear\+Solver\hspace{0.3cm}{\ttfamily [friend]}}



Definition at line 158 of file problem.\+h.

\mbox{\Hypertarget{classoomph_1_1Problem_a199677d64d3b2f908690d10a2398b737}\label{classoomph_1_1Problem_a199677d64d3b2f908690d10a2398b737}} 
\index{oomph::Problem@{oomph::Problem}!BlockHopfLinearSolver@{BlockHopfLinearSolver}}
\index{BlockHopfLinearSolver@{BlockHopfLinearSolver}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{BlockHopfLinearSolver}{BlockHopfLinearSolver}}
{\footnotesize\ttfamily friend class \mbox{\hyperlink{classoomph_1_1BlockHopfLinearSolver}{Block\+Hopf\+Linear\+Solver}}\hspace{0.3cm}{\ttfamily [friend]}}



Definition at line 162 of file problem.\+h.



Referenced by activate\+\_\+hopf\+\_\+tracking().

\mbox{\Hypertarget{classoomph_1_1Problem_aba62ac8cc057be07657972adc4a78b45}\label{classoomph_1_1Problem_aba62ac8cc057be07657972adc4a78b45}} 
\index{oomph::Problem@{oomph::Problem}!BlockPitchForkLinearSolver@{BlockPitchForkLinearSolver}}
\index{BlockPitchForkLinearSolver@{BlockPitchForkLinearSolver}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{BlockPitchForkLinearSolver}{BlockPitchForkLinearSolver}}
{\footnotesize\ttfamily friend class \mbox{\hyperlink{classoomph_1_1BlockPitchForkLinearSolver}{Block\+Pitch\+Fork\+Linear\+Solver}}\hspace{0.3cm}{\ttfamily [friend]}}



Definition at line 159 of file problem.\+h.



Referenced by activate\+\_\+pitchfork\+\_\+tracking().

\mbox{\Hypertarget{classoomph_1_1Problem_a1d79584bd556f960d5b92474681e0159}\label{classoomph_1_1Problem_a1d79584bd556f960d5b92474681e0159}} 
\index{oomph::Problem@{oomph::Problem}!FoldHandler@{FoldHandler}}
\index{FoldHandler@{FoldHandler}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{FoldHandler}{FoldHandler}}
{\footnotesize\ttfamily friend class \mbox{\hyperlink{classoomph_1_1FoldHandler}{Fold\+Handler}}\hspace{0.3cm}{\ttfamily [friend]}}



Definition at line 153 of file problem.\+h.



Referenced by activate\+\_\+bifurcation\+\_\+tracking(), and activate\+\_\+fold\+\_\+tracking().

\mbox{\Hypertarget{classoomph_1_1Problem_a5653c9ce9d673e348e945594469ce0d3}\label{classoomph_1_1Problem_a5653c9ce9d673e348e945594469ce0d3}} 
\index{oomph::Problem@{oomph::Problem}!HopfHandler@{HopfHandler}}
\index{HopfHandler@{HopfHandler}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{HopfHandler}{HopfHandler}}
{\footnotesize\ttfamily friend class \mbox{\hyperlink{classoomph_1_1HopfHandler}{Hopf\+Handler}}\hspace{0.3cm}{\ttfamily [friend]}}



Definition at line 155 of file problem.\+h.



Referenced by activate\+\_\+hopf\+\_\+tracking().

\mbox{\Hypertarget{classoomph_1_1Problem_a2cbe986bcd27c28d5de7ada068d3d94c}\label{classoomph_1_1Problem_a2cbe986bcd27c28d5de7ada068d3d94c}} 
\index{oomph::Problem@{oomph::Problem}!PeriodicOrbitAssemblyHandler@{PeriodicOrbitAssemblyHandler}}
\index{PeriodicOrbitAssemblyHandler@{PeriodicOrbitAssemblyHandler}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{PeriodicOrbitAssemblyHandler}{PeriodicOrbitAssemblyHandler}}
{\footnotesize\ttfamily template$<$unsigned NNODE\+\_\+1D$>$ \\
friend class \mbox{\hyperlink{classoomph_1_1PeriodicOrbitAssemblyHandler}{Periodic\+Orbit\+Assembly\+Handler}}\hspace{0.3cm}{\ttfamily [friend]}}



Definition at line 157 of file problem.\+h.

\mbox{\Hypertarget{classoomph_1_1Problem_a58bcd2e5d47842c64018e2c842bff302}\label{classoomph_1_1Problem_a58bcd2e5d47842c64018e2c842bff302}} 
\index{oomph::Problem@{oomph::Problem}!PitchForkHandler@{PitchForkHandler}}
\index{PitchForkHandler@{PitchForkHandler}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{PitchForkHandler}{PitchForkHandler}}
{\footnotesize\ttfamily friend class \mbox{\hyperlink{classoomph_1_1PitchForkHandler}{Pitch\+Fork\+Handler}}\hspace{0.3cm}{\ttfamily [friend]}}



Definition at line 154 of file problem.\+h.



Referenced by activate\+\_\+pitchfork\+\_\+tracking().



\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{classoomph_1_1Problem_a01d7376ab9cc06e4d5619b34fd39dee2}\label{classoomph_1_1Problem_a01d7376ab9cc06e4d5619b34fd39dee2}} 
\index{oomph::Problem@{oomph::Problem}!Always\_take\_one\_newton\_step@{Always\_take\_one\_newton\_step}}
\index{Always\_take\_one\_newton\_step@{Always\_take\_one\_newton\_step}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Always\_take\_one\_newton\_step}{Always\_take\_one\_newton\_step}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Always\+\_\+take\+\_\+one\+\_\+newton\+\_\+step\hspace{0.3cm}{\ttfamily [protected]}}



Boolean to indicate whether a Newton step should be taken even if the initial residuals are below the required tolerance. 



Definition at line 2326 of file problem.\+h.



Referenced by newton\+\_\+solve(), and newton\+\_\+solve\+\_\+continuation().

\mbox{\Hypertarget{classoomph_1_1Problem_a8109bf56e9203d248ae30a50bb9cfe90}\label{classoomph_1_1Problem_a8109bf56e9203d248ae30a50bb9cfe90}} 
\index{oomph::Problem@{oomph::Problem}!Arc\_length\_step\_taken@{Arc\_length\_step\_taken}}
\index{Arc\_length\_step\_taken@{Arc\_length\_step\_taken}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Arc\_length\_step\_taken}{Arc\_length\_step\_taken}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Arc\+\_\+length\+\_\+step\+\_\+taken\hspace{0.3cm}{\ttfamily [protected]}}



Boolean to indicate whether an arc-\/length step has been taken. 



Definition at line 799 of file problem.\+h.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve(), arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), and reset\+\_\+arc\+\_\+length\+\_\+parameters().

\mbox{\Hypertarget{classoomph_1_1Problem_aefc325e2e116c389a24c9871e41bdb55}\label{classoomph_1_1Problem_aefc325e2e116c389a24c9871e41bdb55}} 
\index{oomph::Problem@{oomph::Problem}!Assembly\_handler\_pt@{Assembly\_handler\_pt}}
\index{Assembly\_handler\_pt@{Assembly\_handler\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Assembly\_handler\_pt}{Assembly\_handler\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}}$\ast$ oomph\+::\+Problem\+::\+Assembly\+\_\+handler\+\_\+pt\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 185 of file problem.\+h.



Referenced by activate\+\_\+bifurcation\+\_\+tracking(), activate\+\_\+fold\+\_\+tracking(), activate\+\_\+hopf\+\_\+tracking(), activate\+\_\+pitchfork\+\_\+tracking(), adapt(), assembly\+\_\+handler\+\_\+pt(), bifurcation\+\_\+parameter\+\_\+pt(), doc\+\_\+errors(), get\+\_\+bifurcation\+\_\+eigenfunction(), get\+\_\+derivative\+\_\+wrt\+\_\+global\+\_\+parameter(), get\+\_\+eigenproblem\+\_\+matrices(), get\+\_\+hessian\+\_\+vector\+\_\+products(), get\+\_\+jacobian(), get\+\_\+residuals(), p\+\_\+adapt(), parallel\+\_\+sparse\+\_\+assemble(), Problem(), reset\+\_\+assembly\+\_\+handler\+\_\+to\+\_\+default(), setup\+\_\+dof\+\_\+halo\+\_\+scheme(), setup\+\_\+element\+\_\+count\+\_\+per\+\_\+dof(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+lists(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+maps(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+vectors(), and sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+vectors\+\_\+of\+\_\+pairs().

\mbox{\Hypertarget{classoomph_1_1Problem_acbdc545bf83974cef38c9dbfff0d2120}\label{classoomph_1_1Problem_acbdc545bf83974cef38c9dbfff0d2120}} 
\index{oomph::Problem@{oomph::Problem}!Base\_mesh\_element\_number\_plus\_one@{Base\_mesh\_element\_number\_plus\_one}}
\index{Base\_mesh\_element\_number\_plus\_one@{Base\_mesh\_element\_number\_plus\_one}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Base\_mesh\_element\_number\_plus\_one}{Base\_mesh\_element\_number\_plus\_one}}
{\footnotesize\ttfamily std\+::map$<$\mbox{\hyperlink{classoomph_1_1GeneralisedElement}{Generalised\+Element}}$\ast$, unsigned$>$ oomph\+::\+Problem\+::\+Base\+\_\+mesh\+\_\+element\+\_\+number\+\_\+plus\+\_\+one\hspace{0.3cm}{\ttfamily [private]}}



Map which stores the correspondence between a root element and its element number (plus one) within the global mesh at the point when it is distributed. NB a root element in this instance is one of the elements in the uniformly-\/refined mesh at the point when \mbox{\hyperlink{classoomph_1_1Problem_aa35e1adc0fdf14b217c7b608eb9cf20b}{Problem\+::distribute()}} is called, since these elements become roots on each of the processors involved in the distribution. Null when element doesn\textquotesingle{}t exist following the adjustment of this when pruning. 



Definition at line 538 of file problem.\+h.



Referenced by distribute(), get\+\_\+data\+\_\+to\+\_\+be\+\_\+sent\+\_\+during\+\_\+load\+\_\+balancing(), get\+\_\+flat\+\_\+packed\+\_\+refinement\+\_\+pattern\+\_\+for\+\_\+load\+\_\+balancing(), load\+\_\+balance(), prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes(), read(), refine\+\_\+distributed\+\_\+base\+\_\+mesh(), send\+\_\+refinement\+\_\+info\+\_\+helper(), and setup\+\_\+base\+\_\+mesh\+\_\+info\+\_\+after\+\_\+pruning().

\mbox{\Hypertarget{classoomph_1_1Problem_a74ce6267ea12fd59903b88e316283b6a}\label{classoomph_1_1Problem_a74ce6267ea12fd59903b88e316283b6a}} 
\index{oomph::Problem@{oomph::Problem}!Base\_mesh\_element\_pt@{Base\_mesh\_element\_pt}}
\index{Base\_mesh\_element\_pt@{Base\_mesh\_element\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Base\_mesh\_element\_pt}{Base\_mesh\_element\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$\mbox{\hyperlink{classoomph_1_1GeneralisedElement}{Generalised\+Element}}$\ast$$>$ oomph\+::\+Problem\+::\+Base\+\_\+mesh\+\_\+element\+\_\+pt\hspace{0.3cm}{\ttfamily [private]}}



\mbox{\hyperlink{classoomph_1_1Vector}{Vector}} to store the correspondence between a root element and its element number within the global mesh at the point when it is distributed. NB a root element in this instance is one of the elements in the uniformly-\/refined mesh at the point when \mbox{\hyperlink{classoomph_1_1Problem_aa35e1adc0fdf14b217c7b608eb9cf20b}{Problem\+::distribute()}} is called, since these elements become roots on each of the processors involved in the distribution. Null when element doesn\textquotesingle{}t exist following the adjustment of this when pruning. 



Definition at line 548 of file problem.\+h.



Referenced by distribute(), dump(), get\+\_\+data\+\_\+to\+\_\+be\+\_\+sent\+\_\+during\+\_\+load\+\_\+balancing(), load\+\_\+balance(), prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes(), read(), send\+\_\+data\+\_\+to\+\_\+be\+\_\+sent\+\_\+during\+\_\+load\+\_\+balancing(), and setup\+\_\+base\+\_\+mesh\+\_\+info\+\_\+after\+\_\+pruning().

\mbox{\Hypertarget{classoomph_1_1Problem_a08dfc704030bb65cea3d9784c5271af0}\label{classoomph_1_1Problem_a08dfc704030bb65cea3d9784c5271af0}} 
\index{oomph::Problem@{oomph::Problem}!Bifurcation\_detection@{Bifurcation\_detection}}
\index{Bifurcation\_detection@{Bifurcation\_detection}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Bifurcation\_detection}{Bifurcation\_detection}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Bifurcation\+\_\+detection\hspace{0.3cm}{\ttfamily [protected]}}



Boolean to control bifurcation detection via determinant of Jacobian. 



Definition at line 790 of file problem.\+h.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_ab805e5e5fb94f941cc7ff1b850d83269}\label{classoomph_1_1Problem_ab805e5e5fb94f941cc7ff1b850d83269}} 
\index{oomph::Problem@{oomph::Problem}!Bisect\_to\_find\_bifurcation@{Bisect\_to\_find\_bifurcation}}
\index{Bisect\_to\_find\_bifurcation@{Bisect\_to\_find\_bifurcation}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Bisect\_to\_find\_bifurcation}{Bisect\_to\_find\_bifurcation}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Bisect\+\_\+to\+\_\+find\+\_\+bifurcation\hspace{0.3cm}{\ttfamily [protected]}}



Boolean to control wheter bisection is used to located bifurcation. 



Definition at line 793 of file problem.\+h.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_a2cee2eaaf1ac49020fc76b3b6adb9bba}\label{classoomph_1_1Problem_a2cee2eaaf1ac49020fc76b3b6adb9bba}} 
\index{oomph::Problem@{oomph::Problem}!Bypass\_increase\_in\_dof\_check\_during\_pruning@{Bypass\_increase\_in\_dof\_check\_during\_pruning}}
\index{Bypass\_increase\_in\_dof\_check\_during\_pruning@{Bypass\_increase\_in\_dof\_check\_during\_pruning}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Bypass\_increase\_in\_dof\_check\_during\_pruning}{Bypass\_increase\_in\_dof\_check\_during\_pruning}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Bypass\+\_\+increase\+\_\+in\+\_\+dof\+\_\+check\+\_\+during\+\_\+pruning\hspace{0.3cm}{\ttfamily [protected]}}



Boolean to bypass check of increase in dofs during pruning. 



Definition at line 967 of file problem.\+h.



Referenced by p\+\_\+refine\+\_\+uniformly\+\_\+aux(), prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes(), and refine\+\_\+uniformly\+\_\+aux().

\mbox{\Hypertarget{classoomph_1_1Problem_ae22f10c348ef8afeb1bfd8609cd6a319}\label{classoomph_1_1Problem_ae22f10c348ef8afeb1bfd8609cd6a319}} 
\index{oomph::Problem@{oomph::Problem}!Calculate\_dparameter\_analytic@{Calculate\_dparameter\_analytic}}
\index{Calculate\_dparameter\_analytic@{Calculate\_dparameter\_analytic}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Calculate\_dparameter\_analytic}{Calculate\_dparameter\_analytic}}
{\footnotesize\ttfamily std\+::map$<$double$\ast$, bool$>$ oomph\+::\+Problem\+::\+Calculate\+\_\+dparameter\+\_\+analytic\hspace{0.3cm}{\ttfamily [protected]}}



Map used to determine whether the derivatives with respect to a parameter should be finite differenced. The default is that finite differences should be used. 



Definition at line 239 of file problem.\+h.



Referenced by is\+\_\+dparameter\+\_\+calculated\+\_\+analytically(), set\+\_\+analytic\+\_\+dparameter(), and unset\+\_\+analytic\+\_\+dparameter().

\mbox{\Hypertarget{classoomph_1_1Problem_ac353f1325a3b411b30fbc19314cc18ce}\label{classoomph_1_1Problem_ac353f1325a3b411b30fbc19314cc18ce}} 
\index{oomph::Problem@{oomph::Problem}!Calculate\_hessian\_products\_analytic@{Calculate\_hessian\_products\_analytic}}
\index{Calculate\_hessian\_products\_analytic@{Calculate\_hessian\_products\_analytic}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Calculate\_hessian\_products\_analytic}{Calculate\_hessian\_products\_analytic}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Calculate\+\_\+hessian\+\_\+products\+\_\+analytic\hspace{0.3cm}{\ttfamily [protected]}}



Map used to determine whether the hessian products should be computed using finite differences. The default is that finite differences will be used. 



Definition at line 244 of file problem.\+h.



Referenced by are\+\_\+hessian\+\_\+products\+\_\+calculated\+\_\+analytically(), set\+\_\+analytic\+\_\+hessian\+\_\+products(), and unset\+\_\+analytic\+\_\+hessian\+\_\+products().

\mbox{\Hypertarget{classoomph_1_1Problem_a937afdd0d5a039943482f8be9b24c82e}\label{classoomph_1_1Problem_a937afdd0d5a039943482f8be9b24c82e}} 
\index{oomph::Problem@{oomph::Problem}!Communicator\_pt@{Communicator\_pt}}
\index{Communicator\_pt@{Communicator\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Communicator\_pt}{Communicator\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1OomphCommunicator}{Oomph\+Communicator}}$\ast$ oomph\+::\+Problem\+::\+Communicator\+\_\+pt\hspace{0.3cm}{\ttfamily [protected]}}



The communicator for this problem. 



Definition at line 1242 of file problem.\+h.



Referenced by assign\+\_\+eqn\+\_\+numbers(), calculate\+\_\+continuation\+\_\+derivatives(), communicator\+\_\+pt(), create\+\_\+new\+\_\+linear\+\_\+algebra\+\_\+distribution(), get\+\_\+eigenproblem\+\_\+matrices(), get\+\_\+jacobian(), load\+\_\+balance(), parallel\+\_\+sparse\+\_\+assemble(), Problem(), read(), oomph\+::\+Solid\+ICProblem\+::set\+\_\+static\+\_\+initial\+\_\+condition(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+lists(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+maps(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+vectors(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+vectors\+\_\+of\+\_\+pairs(), synchronise\+\_\+eqn\+\_\+numbers(), and $\sim$\+Problem().

\mbox{\Hypertarget{classoomph_1_1Problem_a6904003416e9a9257db70c009bdc69ed}\label{classoomph_1_1Problem_a6904003416e9a9257db70c009bdc69ed}} 
\index{oomph::Problem@{oomph::Problem}!Continuation\_direction@{Continuation\_direction}}
\index{Continuation\_direction@{Continuation\_direction}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Continuation\_direction}{Continuation\_direction}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+Continuation\+\_\+direction\hspace{0.3cm}{\ttfamily [protected]}}



The direction of the change in parameter that will ensure that a branch is followed in one direction only. 



Definition at line 749 of file problem.\+h.



Referenced by calculate\+\_\+continuation\+\_\+derivatives\+\_\+helper(), and reset\+\_\+arc\+\_\+length\+\_\+parameters().

\mbox{\Hypertarget{classoomph_1_1Problem_ade29c0a82218d50136b4b3860055ad30}\label{classoomph_1_1Problem_ade29c0a82218d50136b4b3860055ad30}} 
\index{oomph::Problem@{oomph::Problem}!Continuation\_time\_stepper@{Continuation\_time\_stepper}}
\index{Continuation\_time\_stepper@{Continuation\_time\_stepper}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Continuation\_time\_stepper}{Continuation\_time\_stepper}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1ContinuationStorageScheme}{Continuation\+Storage\+Scheme}} oomph\+::\+Problem\+::\+Continuation\+\_\+time\+\_\+stepper\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}



Storage for the single static continuation timestorage object. 

The continuation timestepper object. 

Definition at line 761 of file problem.\+h.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve(), and set\+\_\+consistent\+\_\+pinned\+\_\+values\+\_\+for\+\_\+continuation().

\mbox{\Hypertarget{classoomph_1_1Problem_aa2e04de221f29c13067e2fe4cf4c70f9}\label{classoomph_1_1Problem_aa2e04de221f29c13067e2fe4cf4c70f9}} 
\index{oomph::Problem@{oomph::Problem}!Copy\_of\_problem\_pt@{Copy\_of\_problem\_pt}}
\index{Copy\_of\_problem\_pt@{Copy\_of\_problem\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Copy\_of\_problem\_pt}{Copy\_of\_problem\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$\mbox{\hyperlink{classoomph_1_1Problem}{Problem}}$\ast$$>$ oomph\+::\+Problem\+::\+Copy\+\_\+of\+\_\+problem\+\_\+pt\hspace{0.3cm}{\ttfamily [protected]}}



\mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of pointers to copies of the problem used in adaptive bifurcation tracking problems (ALH\+: TEMPORARY HACK, WILL BE FIXED) 



Definition at line 234 of file problem.\+h.



Referenced by adapt(), bifurcation\+\_\+adapt\+\_\+helper(), and $\sim$\+Problem().

\mbox{\Hypertarget{classoomph_1_1Problem_ae0cebe288c8daddd9663bd10d8f1caa0}\label{classoomph_1_1Problem_ae0cebe288c8daddd9663bd10d8f1caa0}} 
\index{oomph::Problem@{oomph::Problem}!Default\_assembly\_handler\_pt@{Default\_assembly\_handler\_pt}}
\index{Default\_assembly\_handler\_pt@{Default\_assembly\_handler\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Default\_assembly\_handler\_pt}{Default\_assembly\_handler\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1AssemblyHandler}{Assembly\+Handler}}$\ast$ oomph\+::\+Problem\+::\+Default\+\_\+assembly\+\_\+handler\+\_\+pt\hspace{0.3cm}{\ttfamily [private]}}



Pointer to the default assembly handler. 



Definition at line 194 of file problem.\+h.



Referenced by get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals(), Problem(), reset\+\_\+assembly\+\_\+handler\+\_\+to\+\_\+default(), and $\sim$\+Problem().

\mbox{\Hypertarget{classoomph_1_1Problem_a39fd6a7e05c02befe9f2a09938a7a7a4}\label{classoomph_1_1Problem_a39fd6a7e05c02befe9f2a09938a7a7a4}} 
\index{oomph::Problem@{oomph::Problem}!Default\_eigen\_solver\_pt@{Default\_eigen\_solver\_pt}}
\index{Default\_eigen\_solver\_pt@{Default\_eigen\_solver\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Default\_eigen\_solver\_pt}{Default\_eigen\_solver\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1EigenSolver}{Eigen\+Solver}}$\ast$ oomph\+::\+Problem\+::\+Default\+\_\+eigen\+\_\+solver\+\_\+pt\hspace{0.3cm}{\ttfamily [private]}}



Pointer to the default eigensolver. 



Definition at line 191 of file problem.\+h.



Referenced by Problem(), and $\sim$\+Problem().

\mbox{\Hypertarget{classoomph_1_1Problem_ad01b385b2b4cd2e0b867754bea7b798a}\label{classoomph_1_1Problem_ad01b385b2b4cd2e0b867754bea7b798a}} 
\index{oomph::Problem@{oomph::Problem}!Default\_linear\_solver\_pt@{Default\_linear\_solver\_pt}}
\index{Default\_linear\_solver\_pt@{Default\_linear\_solver\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Default\_linear\_solver\_pt}{Default\_linear\_solver\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}}$\ast$ oomph\+::\+Problem\+::\+Default\+\_\+linear\+\_\+solver\+\_\+pt\hspace{0.3cm}{\ttfamily [private]}}



Pointer to the default linear solver. 



Definition at line 188 of file problem.\+h.



Referenced by Problem(), and $\sim$\+Problem().

\mbox{\Hypertarget{classoomph_1_1Problem_a83df3b5fcc3ebbae951021c8e7f03ef7}\label{classoomph_1_1Problem_a83df3b5fcc3ebbae951021c8e7f03ef7}} 
\index{oomph::Problem@{oomph::Problem}!Default\_set\_initial\_condition\_called@{Default\_set\_initial\_condition\_called}}
\index{Default\_set\_initial\_condition\_called@{Default\_set\_initial\_condition\_called}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Default\_set\_initial\_condition\_called}{Default\_set\_initial\_condition\_called}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Default\+\_\+set\+\_\+initial\+\_\+condition\+\_\+called\hspace{0.3cm}{\ttfamily [private]}}



Has default set\+\_\+initial\+\_\+condition function been called? Default\+: false. 



Definition at line 211 of file problem.\+h.



Referenced by doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve\+\_\+helper(), set\+\_\+initial\+\_\+condition(), and unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_abfe8db162a0bda98add0062a45f41cbf}\label{classoomph_1_1Problem_abfe8db162a0bda98add0062a45f41cbf}} 
\index{oomph::Problem@{oomph::Problem}!Desired\_newton\_iterations\_ds@{Desired\_newton\_iterations\_ds}}
\index{Desired\_newton\_iterations\_ds@{Desired\_newton\_iterations\_ds}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Desired\_newton\_iterations\_ds}{Desired\_newton\_iterations\_ds}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::\+Desired\+\_\+newton\+\_\+iterations\+\_\+ds\hspace{0.3cm}{\ttfamily [protected]}}



The desired number of Newton Steps to reach convergence at each step along the arc. 



Definition at line 784 of file problem.\+h.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_a37fb791188428c8186ffd5c52b6cf576}\label{classoomph_1_1Problem_a37fb791188428c8186ffd5c52b6cf576}} 
\index{oomph::Problem@{oomph::Problem}!Desired\_proportion\_of\_arc\_length@{Desired\_proportion\_of\_arc\_length}}
\index{Desired\_proportion\_of\_arc\_length@{Desired\_proportion\_of\_arc\_length}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Desired\_proportion\_of\_arc\_length}{Desired\_proportion\_of\_arc\_length}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+Desired\+\_\+proportion\+\_\+of\+\_\+arc\+\_\+length\hspace{0.3cm}{\ttfamily [protected]}}



Proportion of the arc-\/length to taken by the parameter. 



Definition at line 734 of file problem.\+h.



Referenced by calculate\+\_\+continuation\+\_\+derivatives(), and calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd().

\mbox{\Hypertarget{classoomph_1_1Problem_a97ca0078fff6adca318835c11503dc2d}\label{classoomph_1_1Problem_a97ca0078fff6adca318835c11503dc2d}} 
\index{oomph::Problem@{oomph::Problem}!Discontinuous\_element\_formulation@{Discontinuous\_element\_formulation}}
\index{Discontinuous\_element\_formulation@{Discontinuous\_element\_formulation}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Discontinuous\_element\_formulation}{Discontinuous\_element\_formulation}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Discontinuous\+\_\+element\+\_\+formulation\hspace{0.3cm}{\ttfamily [protected]}}



Is the problem a discontinuous one, i.\+e. can the elemental contributions be treated independently. Default\+: false. 



Definition at line 700 of file problem.\+h.



Referenced by disable\+\_\+discontinuous\+\_\+formulation(), disable\+\_\+mass\+\_\+matrix\+\_\+reuse(), enable\+\_\+discontinuous\+\_\+formulation(), enable\+\_\+mass\+\_\+matrix\+\_\+reuse(), and get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals().

\mbox{\Hypertarget{classoomph_1_1Problem_a1da221c501adc7d58bd21f630207c6c3}\label{classoomph_1_1Problem_a1da221c501adc7d58bd21f630207c6c3}} 
\index{oomph::Problem@{oomph::Problem}!Dist\_problem\_matrix\_distribution@{Dist\_problem\_matrix\_distribution}}
\index{Dist\_problem\_matrix\_distribution@{Dist\_problem\_matrix\_distribution}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Dist\_problem\_matrix\_distribution}{Dist\_problem\_matrix\_distribution}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Problem_a8fc1f40f2a9309e9ff02772fa2258402}{Distributed\+\_\+problem\+\_\+matrix\+\_\+distribution}} oomph\+::\+Problem\+::\+Dist\+\_\+problem\+\_\+matrix\+\_\+distribution\hspace{0.3cm}{\ttfamily [private]}}



The distributed matrix distribution method 1 -\/ Automatic -\/ the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} distribution is employed, unless any processor has number of rows equal to 110\% of N/P, in which case uniform distribution is employed. 2 -\/ \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} -\/ the jacobian on processor p only contains rows that correspond to equations that are on this processor. (minimises communication) 3 -\/ Uniform -\/ each processor holds as close to N/P matrix rows as possible. (very well load balanced) 



Definition at line 956 of file problem.\+h.



Referenced by create\+\_\+new\+\_\+linear\+\_\+algebra\+\_\+distribution(), and distributed\+\_\+problem\+\_\+matrix\+\_\+distribution().

\mbox{\Hypertarget{classoomph_1_1Problem_a9a20957e3ef4c8142261363c85f6e276}\label{classoomph_1_1Problem_a9a20957e3ef4c8142261363c85f6e276}} 
\index{oomph::Problem@{oomph::Problem}!Doc\_imbalance\_in\_parallel\_assembly@{Doc\_imbalance\_in\_parallel\_assembly}}
\index{Doc\_imbalance\_in\_parallel\_assembly@{Doc\_imbalance\_in\_parallel\_assembly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Doc\_imbalance\_in\_parallel\_assembly}{Doc\_imbalance\_in\_parallel\_assembly}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Doc\+\_\+imbalance\+\_\+in\+\_\+parallel\+\_\+assembly\hspace{0.3cm}{\ttfamily [private]}}



Boolean to switch on assessment of load imbalance in parallel assembly of distributed problem. 



Definition at line 510 of file problem.\+h.



Referenced by disable\+\_\+doc\+\_\+imbalance\+\_\+in\+\_\+parallel\+\_\+assembly(), enable\+\_\+doc\+\_\+imbalance\+\_\+in\+\_\+parallel\+\_\+assembly(), and parallel\+\_\+sparse\+\_\+assemble().

\mbox{\Hypertarget{classoomph_1_1Problem_a524b68efcaae084ad7144f944cb39c69}\label{classoomph_1_1Problem_a524b68efcaae084ad7144f944cb39c69}} 
\index{oomph::Problem@{oomph::Problem}!Doc\_time\_in\_distribute@{Doc\_time\_in\_distribute}}
\index{Doc\_time\_in\_distribute@{Doc\_time\_in\_distribute}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Doc\_time\_in\_distribute}{Doc\_time\_in\_distribute}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Doc\+\_\+time\+\_\+in\+\_\+distribute\hspace{0.3cm}{\ttfamily [protected]}}



Protected boolean flag to provide comprehensive timimings during problem distribution. Initialised to false. 



Definition at line 637 of file problem.\+h.



Referenced by distribute().

\mbox{\Hypertarget{classoomph_1_1Problem_a366b50c490e9fd3ddafa05b2fbd0b883}\label{classoomph_1_1Problem_a366b50c490e9fd3ddafa05b2fbd0b883}} 
\index{oomph::Problem@{oomph::Problem}!Dof\_current@{Dof\_current}}
\index{Dof\_current@{Dof\_current}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Dof\_current}{Dof\_current}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$double$>$ oomph\+::\+Problem\+::\+Dof\+\_\+current\hspace{0.3cm}{\ttfamily [protected]}}



Storage for the present values of the variables. 



Definition at line 777 of file problem.\+h.



Referenced by adapt(), arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd\+\_\+helper(), and dof\+\_\+current().

\mbox{\Hypertarget{classoomph_1_1Problem_a57825be8c76db9e23e6a9aa0d73973b2}\label{classoomph_1_1Problem_a57825be8c76db9e23e6a9aa0d73973b2}} 
\index{oomph::Problem@{oomph::Problem}!Dof\_current\_offset@{Dof\_current\_offset}}
\index{Dof\_current\_offset@{Dof\_current\_offset}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Dof\_current\_offset}{Dof\_current\_offset}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::\+Dof\+\_\+current\+\_\+offset\hspace{0.3cm}{\ttfamily [protected]}}



Storage for the offset for the current values of dofs from the original dofs (default is 2, but this will be differnet when continuing bifurcations and periodic orbits) 



Definition at line 771 of file problem.\+h.



Referenced by dof\+\_\+current().

\mbox{\Hypertarget{classoomph_1_1Problem_a1861321b2d129707935bf1191238daca}\label{classoomph_1_1Problem_a1861321b2d129707935bf1191238daca}} 
\index{oomph::Problem@{oomph::Problem}!Dof\_derivative@{Dof\_derivative}}
\index{Dof\_derivative@{Dof\_derivative}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Dof\_derivative}{Dof\_derivative}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$double$>$ oomph\+::\+Problem\+::\+Dof\+\_\+derivative\hspace{0.3cm}{\ttfamily [protected]}}



Storage for the derivative of the problem variables wrt arc-\/length. 



Definition at line 774 of file problem.\+h.



Referenced by adapt(), arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+helper(), dof\+\_\+derivative(), and reset\+\_\+arc\+\_\+length\+\_\+parameters().

\mbox{\Hypertarget{classoomph_1_1Problem_af0372f742b90bb402c6edc720ceeb421}\label{classoomph_1_1Problem_af0372f742b90bb402c6edc720ceeb421}} 
\index{oomph::Problem@{oomph::Problem}!Dof\_derivative\_offset@{Dof\_derivative\_offset}}
\index{Dof\_derivative\_offset@{Dof\_derivative\_offset}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Dof\_derivative\_offset}{Dof\_derivative\_offset}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::\+Dof\+\_\+derivative\+\_\+offset\hspace{0.3cm}{\ttfamily [protected]}}



Storage for the offset for the continuation derivatives from the original dofs (default is 1, but this will be differnet when continuing bifurcations and periodic orbits) 



Definition at line 766 of file problem.\+h.



Referenced by dof\+\_\+derivative().

\mbox{\Hypertarget{classoomph_1_1Problem_ade01b88db08dcec1706fe44eaa0090a3}\label{classoomph_1_1Problem_ade01b88db08dcec1706fe44eaa0090a3}} 
\index{oomph::Problem@{oomph::Problem}!Dof\_distribution\_pt@{Dof\_distribution\_pt}}
\index{Dof\_distribution\_pt@{Dof\_distribution\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Dof\_distribution\_pt}{Dof\_distribution\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution}}$\ast$ oomph\+::\+Problem\+::\+Dof\+\_\+distribution\+\_\+pt\hspace{0.3cm}{\ttfamily [protected]}}



The distribution of the DOFs in this problem. This object is created in the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} constructor and setup when assign\+\_\+eqn\+\_\+numbers(...) is called. If this problem is distributed then this distribution will match the distribution of the equation numbers. If this problem is not distributed then this distribution will be uniform over all processors. 



Definition at line 460 of file problem.\+h.



Referenced by adapt(), oomph\+::\+Periodic\+Orbit\+Assembly\+Handler$<$ NNODE\+\_\+1\+D $>$\+::adapt\+\_\+temporal\+\_\+mesh(), add\+\_\+eigenvector\+\_\+to\+\_\+dofs(), arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), assign\+\_\+eigenvector\+\_\+to\+\_\+dofs(), assign\+\_\+eqn\+\_\+numbers(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd\+\_\+helper(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+helper(), create\+\_\+new\+\_\+linear\+\_\+algebra\+\_\+distribution(), dof\+\_\+distribution\+\_\+pt(), oomph\+::\+Fold\+Handler\+::\+Fold\+Handler(), get\+\_\+dofs(), get\+\_\+hessian\+\_\+vector\+\_\+products(), oomph\+::\+Hopf\+Handler\+::\+Hopf\+Handler(), ndof(), newton\+\_\+solve(), newton\+\_\+solve\+\_\+continuation(), oomph\+::\+Pitch\+Fork\+Handler\+::\+Pitch\+Fork\+Handler(), Problem(), restore\+\_\+dof\+\_\+values(), setup\+\_\+dof\+\_\+halo\+\_\+scheme(), setup\+\_\+element\+\_\+count\+\_\+per\+\_\+dof(), oomph\+::\+Fold\+Handler\+::solve\+\_\+augmented\+\_\+block\+\_\+system(), oomph\+::\+Pitch\+Fork\+Handler\+::solve\+\_\+augmented\+\_\+block\+\_\+system(), oomph\+::\+Fold\+Handler\+::solve\+\_\+block\+\_\+system(), oomph\+::\+Pitch\+Fork\+Handler\+::solve\+\_\+block\+\_\+system(), oomph\+::\+Hopf\+Handler\+::solve\+\_\+complex\+\_\+system(), oomph\+::\+Fold\+Handler\+::solve\+\_\+full\+\_\+system(), oomph\+::\+Pitch\+Fork\+Handler\+::solve\+\_\+full\+\_\+system(), oomph\+::\+Hopf\+Handler\+::solve\+\_\+full\+\_\+system(), oomph\+::\+Hopf\+Handler\+::solve\+\_\+standard\+\_\+system(), store\+\_\+current\+\_\+dof\+\_\+values(), synchronise\+\_\+eqn\+\_\+numbers(), oomph\+::\+Fold\+Handler\+::$\sim$\+Fold\+Handler(), oomph\+::\+Hopf\+Handler\+::$\sim$\+Hopf\+Handler(), oomph\+::\+Pitch\+Fork\+Handler\+::$\sim$\+Pitch\+Fork\+Handler(), and $\sim$\+Problem().

\mbox{\Hypertarget{classoomph_1_1Problem_aa9e4cfff7e1dc295036b0e58bc11ae75}\label{classoomph_1_1Problem_aa9e4cfff7e1dc295036b0e58bc11ae75}} 
\index{oomph::Problem@{oomph::Problem}!Dof\_pt@{Dof\_pt}}
\index{Dof\_pt@{Dof\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Dof\_pt}{Dof\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$double$\ast$$>$ oomph\+::\+Problem\+::\+Dof\+\_\+pt\hspace{0.3cm}{\ttfamily [protected]}}



\mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of pointers to dofs. 



Definition at line 554 of file problem.\+h.



Referenced by oomph\+::\+Periodic\+Orbit\+Assembly\+Handler$<$ NNODE\+\_\+1\+D $>$\+::adapt\+\_\+temporal\+\_\+mesh(), add\+\_\+to\+\_\+dofs(), arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), assign\+\_\+eqn\+\_\+numbers(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd\+\_\+helper(), calculate\+\_\+predictions(), dof(), dof\+\_\+current(), dof\+\_\+derivative(), dof\+\_\+pt(), oomph\+::\+Fold\+Handler\+::\+Fold\+Handler(), get\+\_\+dofs(), get\+\_\+fd\+\_\+jacobian(), oomph\+::\+Fold\+Handler\+::get\+\_\+jacobian(), oomph\+::\+Hopf\+Handler\+::get\+\_\+jacobian(), globally\+\_\+convergent\+\_\+line\+\_\+search(), oomph\+::\+Hopf\+Handler\+::\+Hopf\+Handler(), newton\+\_\+solve(), newton\+\_\+solve\+\_\+continuation(), oomph\+::\+Pitch\+Fork\+Handler\+::\+Pitch\+Fork\+Handler(), restore\+\_\+dof\+\_\+values(), set\+\_\+dofs(), oomph\+::\+Fold\+Handler\+::solve\+\_\+augmented\+\_\+block\+\_\+system(), oomph\+::\+Pitch\+Fork\+Handler\+::solve\+\_\+augmented\+\_\+block\+\_\+system(), oomph\+::\+Fold\+Handler\+::solve\+\_\+block\+\_\+system(), oomph\+::\+Pitch\+Fork\+Handler\+::solve\+\_\+block\+\_\+system(), oomph\+::\+Hopf\+Handler\+::solve\+\_\+complex\+\_\+system(), oomph\+::\+Fold\+Handler\+::solve\+\_\+full\+\_\+system(), oomph\+::\+Pitch\+Fork\+Handler\+::solve\+\_\+full\+\_\+system(), oomph\+::\+Hopf\+Handler\+::solve\+\_\+full\+\_\+system(), oomph\+::\+Hopf\+Handler\+::solve\+\_\+standard\+\_\+system(), store\+\_\+current\+\_\+dof\+\_\+values(), synchronise\+\_\+eqn\+\_\+numbers(), oomph\+::\+Fold\+Handler\+::$\sim$\+Fold\+Handler(), oomph\+::\+Hopf\+Handler\+::$\sim$\+Hopf\+Handler(), and oomph\+::\+Pitch\+Fork\+Handler\+::$\sim$\+Pitch\+Fork\+Handler().

\mbox{\Hypertarget{classoomph_1_1Problem_ad412d49617d0b0998e5eb440c7a20f3f}\label{classoomph_1_1Problem_ad412d49617d0b0998e5eb440c7a20f3f}} 
\index{oomph::Problem@{oomph::Problem}!Ds\_current@{Ds\_current}}
\index{Ds\_current@{Ds\_current}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Ds\_current}{Ds\_current}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+Ds\+\_\+current\hspace{0.3cm}{\ttfamily [protected]}}



Storage for the current step value. 



Definition at line 780 of file problem.\+h.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd\+\_\+helper(), and newton\+\_\+solve\+\_\+continuation().

\mbox{\Hypertarget{classoomph_1_1Problem_aaaeab9469b342a3b849ee5f2ef7051f3}\label{classoomph_1_1Problem_aaaeab9469b342a3b849ee5f2ef7051f3}} 
\index{oomph::Problem@{oomph::Problem}!DTSF\_max\_increase@{DTSF\_max\_increase}}
\index{DTSF\_max\_increase@{DTSF\_max\_increase}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{DTSF\_max\_increase}{DTSF\_max\_increase}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+DTSF\+\_\+max\+\_\+increase\hspace{0.3cm}{\ttfamily [protected]}}



Maximum possible increase of dt between time-\/steps in adaptive schemes. 



Definition at line 713 of file problem.\+h.



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_abbb93979ed99d40eb845ba7296355965}\label{classoomph_1_1Problem_abbb93979ed99d40eb845ba7296355965}} 
\index{oomph::Problem@{oomph::Problem}!DTSF\_min\_decrease@{DTSF\_min\_decrease}}
\index{DTSF\_min\_decrease@{DTSF\_min\_decrease}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{DTSF\_min\_decrease}{DTSF\_min\_decrease}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+DTSF\+\_\+min\+\_\+decrease\hspace{0.3cm}{\ttfamily [protected]}}



Minimum allowed decrease of dt between time-\/steps in adaptive schemes. Lower scaling values will reject the time-\/step (and retry with a smaller dt). 



Definition at line 718 of file problem.\+h.



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_ab7938313fa45df9be16515a6b0bfd324}\label{classoomph_1_1Problem_ab7938313fa45df9be16515a6b0bfd324}} 
\index{oomph::Problem@{oomph::Problem}!Eigen\_solver\_pt@{Eigen\_solver\_pt}}
\index{Eigen\_solver\_pt@{Eigen\_solver\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Eigen\_solver\_pt}{Eigen\_solver\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1EigenSolver}{Eigen\+Solver}}$\ast$ oomph\+::\+Problem\+::\+Eigen\+\_\+solver\+\_\+pt\hspace{0.3cm}{\ttfamily [private]}}



Pointer to the eigen solver for the problem. 



Definition at line 182 of file problem.\+h.



Referenced by eigen\+\_\+solver\+\_\+pt(), Problem(), solve\+\_\+adjoint\+\_\+eigenproblem(), solve\+\_\+adjoint\+\_\+eigenproblem\+\_\+legacy(), solve\+\_\+eigenproblem(), and solve\+\_\+eigenproblem\+\_\+legacy().

\mbox{\Hypertarget{classoomph_1_1Problem_ae4177b73a790b80d541b416d1e83c6c3}\label{classoomph_1_1Problem_ae4177b73a790b80d541b416d1e83c6c3}} 
\index{oomph::Problem@{oomph::Problem}!Element\_count\_per\_dof@{Element\_count\_per\_dof}}
\index{Element\_count\_per\_dof@{Element\_count\_per\_dof}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Element\_count\_per\_dof}{Element\_count\_per\_dof}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1DoubleVectorWithHaloEntries}{Double\+Vector\+With\+Halo\+Entries}} oomph\+::\+Problem\+::\+Element\+\_\+count\+\_\+per\+\_\+dof\hspace{0.3cm}{\ttfamily [protected]}}



Counter that records how many elements contribute to each dof. Used to determine the (discrete) arc-\/length automatically. It really should be an integer, but is a double so that the distribution information can be used for distributed problems. 



Definition at line 560 of file problem.\+h.



Referenced by setup\+\_\+element\+\_\+count\+\_\+per\+\_\+dof().

\mbox{\Hypertarget{classoomph_1_1Problem_a2b2bcde2b051f47278ccf8446699bbfb}\label{classoomph_1_1Problem_a2b2bcde2b051f47278ccf8446699bbfb}} 
\index{oomph::Problem@{oomph::Problem}!Elemental\_assembly\_time@{Elemental\_assembly\_time}}
\index{Elemental\_assembly\_time@{Elemental\_assembly\_time}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Elemental\_assembly\_time}{Elemental\_assembly\_time}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$double$>$ oomph\+::\+Problem\+::\+Elemental\+\_\+assembly\+\_\+time\hspace{0.3cm}{\ttfamily [protected]}}



Storage for assembly times (used for load balancing) 



Definition at line 573 of file problem.\+h.



Referenced by assign\+\_\+eqn\+\_\+numbers(), clear\+\_\+elemental\+\_\+assembly\+\_\+time(), distribute(), elemental\+\_\+assembly\+\_\+time(), parallel\+\_\+sparse\+\_\+assemble(), recompute\+\_\+load\+\_\+balanced\+\_\+assembly(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+lists(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+maps(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+vectors(), and sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+vectors\+\_\+of\+\_\+pairs().

\mbox{\Hypertarget{classoomph_1_1Problem_a71f87e46a571a54abd27a26f6c701c36}\label{classoomph_1_1Problem_a71f87e46a571a54abd27a26f6c701c36}} 
\index{oomph::Problem@{oomph::Problem}!Empty\_actions\_after\_read\_unstructured\_meshes\_has\_been\_called@{Empty\_actions\_after\_read\_unstructured\_meshes\_has\_been\_called}}
\index{Empty\_actions\_after\_read\_unstructured\_meshes\_has\_been\_called@{Empty\_actions\_after\_read\_unstructured\_meshes\_has\_been\_called}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Empty\_actions\_after\_read\_unstructured\_meshes\_has\_been\_called}{Empty\_actions\_after\_read\_unstructured\_meshes\_has\_been\_called}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Empty\+\_\+actions\+\_\+after\+\_\+read\+\_\+unstructured\+\_\+meshes\+\_\+has\+\_\+been\+\_\+called\hspace{0.3cm}{\ttfamily [private]}}



Boolean to indicate that empty \mbox{\hyperlink{classoomph_1_1Problem_a498317b3e390eddf2169ab989ee8d6b4}{actions\+\_\+after\+\_\+read\+\_\+unstructured\+\_\+meshes()}} function has been called. 



Definition at line 222 of file problem.\+h.



Referenced by actions\+\_\+after\+\_\+read\+\_\+unstructured\+\_\+meshes(), and read().

\mbox{\Hypertarget{classoomph_1_1Problem_a5f13ea67c29022392857b5c19bb3af71}\label{classoomph_1_1Problem_a5f13ea67c29022392857b5c19bb3af71}} 
\index{oomph::Problem@{oomph::Problem}!Empty\_actions\_before\_read\_unstructured\_meshes\_has\_been\_called@{Empty\_actions\_before\_read\_unstructured\_meshes\_has\_been\_called}}
\index{Empty\_actions\_before\_read\_unstructured\_meshes\_has\_been\_called@{Empty\_actions\_before\_read\_unstructured\_meshes\_has\_been\_called}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Empty\_actions\_before\_read\_unstructured\_meshes\_has\_been\_called}{Empty\_actions\_before\_read\_unstructured\_meshes\_has\_been\_called}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Empty\+\_\+actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes\+\_\+has\+\_\+been\+\_\+called\hspace{0.3cm}{\ttfamily [private]}}



Boolean to indicate that empty \mbox{\hyperlink{classoomph_1_1Problem_af10662119a7a0c3a47879fa0d0644452}{actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes()}} function has been called. 



Definition at line 218 of file problem.\+h.



Referenced by actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes(), and read().

\mbox{\Hypertarget{classoomph_1_1Problem_af8466091ea4f5b57033bb3ad24831167}\label{classoomph_1_1Problem_af8466091ea4f5b57033bb3ad24831167}} 
\index{oomph::Problem@{oomph::Problem}!Explicit\_time\_stepper\_pt@{Explicit\_time\_stepper\_pt}}
\index{Explicit\_time\_stepper\_pt@{Explicit\_time\_stepper\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Explicit\_time\_stepper\_pt}{Explicit\_time\_stepper\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1ExplicitTimeStepper}{Explicit\+Time\+Stepper}}$\ast$ oomph\+::\+Problem\+::\+Explicit\+\_\+time\+\_\+stepper\+\_\+pt\hspace{0.3cm}{\ttfamily [private]}}



Pointer to a single explicit timestepper. 



Definition at line 204 of file problem.\+h.



Referenced by explicit\+\_\+time\+\_\+stepper\+\_\+pt(), and set\+\_\+explicit\+\_\+time\+\_\+stepper\+\_\+pt().

\mbox{\Hypertarget{classoomph_1_1Problem_ad26c62f5aab816943144ac61fbf7725e}\label{classoomph_1_1Problem_ad26c62f5aab816943144ac61fbf7725e}} 
\index{oomph::Problem@{oomph::Problem}!FD\_step\_used\_in\_get\_hessian\_vector\_products@{FD\_step\_used\_in\_get\_hessian\_vector\_products}}
\index{FD\_step\_used\_in\_get\_hessian\_vector\_products@{FD\_step\_used\_in\_get\_hessian\_vector\_products}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{FD\_step\_used\_in\_get\_hessian\_vector\_products}{FD\_step\_used\_in\_get\_hessian\_vector\_products}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+FD\+\_\+step\+\_\+used\+\_\+in\+\_\+get\+\_\+hessian\+\_\+vector\+\_\+products\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line 685 of file problem.\+h.



Referenced by get\+\_\+hessian\+\_\+vector\+\_\+products().

\mbox{\Hypertarget{classoomph_1_1Problem_a0caac0918eaaea840238ce83f5be7836}\label{classoomph_1_1Problem_a0caac0918eaaea840238ce83f5be7836}} 
\index{oomph::Problem@{oomph::Problem}!First\_el\_for\_assembly@{First\_el\_for\_assembly}}
\index{First\_el\_for\_assembly@{First\_el\_for\_assembly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{First\_el\_for\_assembly}{First\_el\_for\_assembly}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$unsigned$>$ oomph\+::\+Problem\+::\+First\+\_\+el\+\_\+for\+\_\+assembly\hspace{0.3cm}{\ttfamily [private]}}



First element to be assembled by given processor for non-\/distributed problem (only kept up to date when default assignment is used) 



Definition at line 519 of file problem.\+h.



Referenced by get\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly(), parallel\+\_\+sparse\+\_\+assemble(), recompute\+\_\+load\+\_\+balanced\+\_\+assembly(), set\+\_\+default\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly(), set\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+lists(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+maps(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+vectors(), and sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+vectors\+\_\+of\+\_\+pairs().

\mbox{\Hypertarget{classoomph_1_1Problem_a643f61299463a3bbf7be3f6a112aa130}\label{classoomph_1_1Problem_a643f61299463a3bbf7be3f6a112aa130}} 
\index{oomph::Problem@{oomph::Problem}!First\_jacobian\_sign\_change@{First\_jacobian\_sign\_change}}
\index{First\_jacobian\_sign\_change@{First\_jacobian\_sign\_change}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{First\_jacobian\_sign\_change}{First\_jacobian\_sign\_change}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+First\+\_\+jacobian\+\_\+sign\+\_\+change\hspace{0.3cm}{\ttfamily [protected]}}



Boolean to indicate whether a sign change has occured in the Jacobian. 



Definition at line 796 of file problem.\+h.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), and reset\+\_\+arc\+\_\+length\+\_\+parameters().

\mbox{\Hypertarget{classoomph_1_1Problem_aa963c98e91d135d31cdcfbe1afa64603}\label{classoomph_1_1Problem_aa963c98e91d135d31cdcfbe1afa64603}} 
\index{oomph::Problem@{oomph::Problem}!Global\_data\_pt@{Global\_data\_pt}}
\index{Global\_data\_pt@{Global\_data\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Global\_data\_pt}{Global\_data\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$\mbox{\hyperlink{classoomph_1_1Data}{Data}}$\ast$$>$ oomph\+::\+Problem\+::\+Global\+\_\+data\+\_\+pt\hspace{0.3cm}{\ttfamily [private]}}



\mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of global data\+: \char`\"{}\+Nobody\char`\"{} (i.\+e. none of the elements etc.) is \char`\"{}in charge\char`\"{} of this \mbox{\hyperlink{classoomph_1_1Data}{Data}} so it would be overlooked when it comes to equation-\/numbering, timestepping etc. Including (pointers) to such \mbox{\hyperlink{classoomph_1_1Data}{Data}} in here, puts the \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} itself \char`\"{}in charge\char`\"{} of these tasks. 



Definition at line 425 of file problem.\+h.



Referenced by add\+\_\+global\+\_\+data(), assign\+\_\+eqn\+\_\+numbers(), assign\+\_\+initial\+\_\+values\+\_\+impulsive(), calculate\+\_\+predictions(), copy(), describe\+\_\+dofs(), does\+\_\+pointer\+\_\+correspond\+\_\+to\+\_\+problem\+\_\+data(), dump(), flush\+\_\+global\+\_\+data(), get\+\_\+dofs(), global\+\_\+data\+\_\+pt(), nglobal\+\_\+data(), read(), self\+\_\+test(), set\+\_\+consistent\+\_\+pinned\+\_\+values\+\_\+for\+\_\+continuation(), set\+\_\+dofs(), set\+\_\+pinned\+\_\+values\+\_\+to\+\_\+zero(), set\+\_\+timestepper\+\_\+for\+\_\+all\+\_\+data(), and shift\+\_\+time\+\_\+values().

\mbox{\Hypertarget{classoomph_1_1Problem_ac59d9163cc5d008a2ade4de8da06dbf6}\label{classoomph_1_1Problem_ac59d9163cc5d008a2ade4de8da06dbf6}} 
\index{oomph::Problem@{oomph::Problem}!Halo\_dof\_pt@{Halo\_dof\_pt}}
\index{Halo\_dof\_pt@{Halo\_dof\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Halo\_dof\_pt}{Halo\_dof\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$double$\ast$$>$ oomph\+::\+Problem\+::\+Halo\+\_\+dof\+\_\+pt\hspace{0.3cm}{\ttfamily [protected]}}



Storage for the halo degrees of freedom (only required) when accessing via the global equation number in distributed problems. 



Definition at line 581 of file problem.\+h.



Referenced by global\+\_\+dof\+\_\+pt(), and setup\+\_\+dof\+\_\+halo\+\_\+scheme().

\mbox{\Hypertarget{classoomph_1_1Problem_a1dcaa04975d69c616ab294cbfaf53d55}\label{classoomph_1_1Problem_a1dcaa04975d69c616ab294cbfaf53d55}} 
\index{oomph::Problem@{oomph::Problem}!Halo\_scheme\_pt@{Halo\_scheme\_pt}}
\index{Halo\_scheme\_pt@{Halo\_scheme\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Halo\_scheme\_pt}{Halo\_scheme\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1DoubleVectorHaloScheme}{Double\+Vector\+Halo\+Scheme}}$\ast$ oomph\+::\+Problem\+::\+Halo\+\_\+scheme\+\_\+pt\hspace{0.3cm}{\ttfamily [protected]}}



Pointer to the halo scheme for any global vectors that have the Dof\+\_\+distribution. 



Definition at line 577 of file problem.\+h.



Referenced by get\+\_\+hessian\+\_\+vector\+\_\+products(), global\+\_\+dof\+\_\+pt(), oomph\+::\+Pitch\+Fork\+Handler\+::\+Pitch\+Fork\+Handler(), oomph\+::\+Block\+Pitch\+Fork\+Linear\+Solver\+::resolve(), setup\+\_\+dof\+\_\+halo\+\_\+scheme(), setup\+\_\+element\+\_\+count\+\_\+per\+\_\+dof(), and oomph\+::\+Block\+Pitch\+Fork\+Linear\+Solver\+::solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a2c4702c75739c967ed582dbd0a7ba56f}\label{classoomph_1_1Problem_a2c4702c75739c967ed582dbd0a7ba56f}} 
\index{oomph::Problem@{oomph::Problem}!Jacobian\_has\_been\_computed@{Jacobian\_has\_been\_computed}}
\index{Jacobian\_has\_been\_computed@{Jacobian\_has\_been\_computed}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Jacobian\_has\_been\_computed}{Jacobian\_has\_been\_computed}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Jacobian\+\_\+has\+\_\+been\+\_\+computed\hspace{0.3cm}{\ttfamily [protected]}}



Has a Jacobian been computed (and can therefore be re-\/used if required)? Default\+: false. 



Definition at line 622 of file problem.\+h.



Referenced by disable\+\_\+jacobian\+\_\+reuse(), enable\+\_\+jacobian\+\_\+reuse(), and newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a022796f2c96f2dff6ed1db2338c93aaf}\label{classoomph_1_1Problem_a022796f2c96f2dff6ed1db2338c93aaf}} 
\index{oomph::Problem@{oomph::Problem}!Jacobian\_reuse\_is\_enabled@{Jacobian\_reuse\_is\_enabled}}
\index{Jacobian\_reuse\_is\_enabled@{Jacobian\_reuse\_is\_enabled}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Jacobian\_reuse\_is\_enabled}{Jacobian\_reuse\_is\_enabled}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Jacobian\+\_\+reuse\+\_\+is\+\_\+enabled\hspace{0.3cm}{\ttfamily [protected]}}



Is re-\/use of Jacobian in Newton iteration enabled? Default\+: false. 



Definition at line 618 of file problem.\+h.



Referenced by disable\+\_\+jacobian\+\_\+reuse(), enable\+\_\+jacobian\+\_\+reuse(), jacobian\+\_\+reuse\+\_\+is\+\_\+enabled(), and newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_ab27af4a444de9f59125ee50ac778d97a}\label{classoomph_1_1Problem_ab27af4a444de9f59125ee50ac778d97a}} 
\index{oomph::Problem@{oomph::Problem}!Keep\_temporal\_error\_below\_tolerance@{Keep\_temporal\_error\_below\_tolerance}}
\index{Keep\_temporal\_error\_below\_tolerance@{Keep\_temporal\_error\_below\_tolerance}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Keep\_temporal\_error\_below\_tolerance}{Keep\_temporal\_error\_below\_tolerance}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Keep\+\_\+temporal\+\_\+error\+\_\+below\+\_\+tolerance\hspace{0.3cm}{\ttfamily [protected]}}



Boolean to decide if a timestep is to be rejected if the error estimate post-\/solve (computed by \mbox{\hyperlink{classoomph_1_1Problem_ac7667864b71a3889c95c29307422ac8e}{global\+\_\+temporal\+\_\+error\+\_\+norm()}}) exceeds the tolerance required in the call to adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(...). Defaults to true. 



Definition at line 2338 of file problem.\+h.



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a4842a9a213197905b5a8e182a3c02cce}\label{classoomph_1_1Problem_a4842a9a213197905b5a8e182a3c02cce}} 
\index{oomph::Problem@{oomph::Problem}!Last\_el\_plus\_one\_for\_assembly@{Last\_el\_plus\_one\_for\_assembly}}
\index{Last\_el\_plus\_one\_for\_assembly@{Last\_el\_plus\_one\_for\_assembly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Last\_el\_plus\_one\_for\_assembly}{Last\_el\_plus\_one\_for\_assembly}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$unsigned$>$ oomph\+::\+Problem\+::\+Last\+\_\+el\+\_\+plus\+\_\+one\+\_\+for\+\_\+assembly\hspace{0.3cm}{\ttfamily [private]}}



Last element (plus one) to be assembled by given processor for non-\/distributed problem (only kept up to date when default assignment is used) 



Definition at line 524 of file problem.\+h.



Referenced by get\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly(), parallel\+\_\+sparse\+\_\+assemble(), recompute\+\_\+load\+\_\+balanced\+\_\+assembly(), set\+\_\+default\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly(), set\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+lists(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+maps(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+vectors(), and sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+vectors\+\_\+of\+\_\+pairs().

\mbox{\Hypertarget{classoomph_1_1Problem_a519de6f6f70c8b0f6bacbde5e0a35cd7}\label{classoomph_1_1Problem_a519de6f6f70c8b0f6bacbde5e0a35cd7}} 
\index{oomph::Problem@{oomph::Problem}!Linear\_solver\_pt@{Linear\_solver\_pt}}
\index{Linear\_solver\_pt@{Linear\_solver\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Linear\_solver\_pt}{Linear\_solver\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}}$\ast$ oomph\+::\+Problem\+::\+Linear\+\_\+solver\+\_\+pt\hspace{0.3cm}{\ttfamily [private]}}



Pointer to the linear solver for the problem. 



Definition at line 173 of file problem.\+h.



Referenced by activate\+\_\+bifurcation\+\_\+tracking(), activate\+\_\+fold\+\_\+tracking(), activate\+\_\+hopf\+\_\+tracking(), activate\+\_\+pitchfork\+\_\+tracking(), calculate\+\_\+continuation\+\_\+derivatives(), linear\+\_\+solver\+\_\+pt(), newton\+\_\+solve(), newton\+\_\+solve\+\_\+continuation(), and Problem().

\mbox{\Hypertarget{classoomph_1_1Problem_a6067c6d344363a073fb8d02a99fb7ed0}\label{classoomph_1_1Problem_a6067c6d344363a073fb8d02a99fb7ed0}} 
\index{oomph::Problem@{oomph::Problem}!Mass\_matrix\_has\_been\_computed@{Mass\_matrix\_has\_been\_computed}}
\index{Mass\_matrix\_has\_been\_computed@{Mass\_matrix\_has\_been\_computed}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Mass\_matrix\_has\_been\_computed}{Mass\_matrix\_has\_been\_computed}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Mass\+\_\+matrix\+\_\+has\+\_\+been\+\_\+computed\hspace{0.3cm}{\ttfamily [protected]}}



Has the mass matrix been computed (and can therefore be reused) Default\+: false. 



Definition at line 695 of file problem.\+h.



Referenced by disable\+\_\+mass\+\_\+matrix\+\_\+reuse(), enable\+\_\+mass\+\_\+matrix\+\_\+reuse(), and get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals().

\mbox{\Hypertarget{classoomph_1_1Problem_af4d25809ac090102a4d4a398e4ad0e26}\label{classoomph_1_1Problem_af4d25809ac090102a4d4a398e4ad0e26}} 
\index{oomph::Problem@{oomph::Problem}!Mass\_matrix\_reuse\_is\_enabled@{Mass\_matrix\_reuse\_is\_enabled}}
\index{Mass\_matrix\_reuse\_is\_enabled@{Mass\_matrix\_reuse\_is\_enabled}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Mass\_matrix\_reuse\_is\_enabled}{Mass\_matrix\_reuse\_is\_enabled}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Mass\+\_\+matrix\+\_\+reuse\+\_\+is\+\_\+enabled\hspace{0.3cm}{\ttfamily [protected]}}



Is re-\/use of the mass matrix in explicit timestepping enabled Default\+:false. 



Definition at line 691 of file problem.\+h.



Referenced by disable\+\_\+mass\+\_\+matrix\+\_\+reuse(), enable\+\_\+mass\+\_\+matrix\+\_\+reuse(), get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals(), and mass\+\_\+matrix\+\_\+reuse\+\_\+is\+\_\+enabled().

\mbox{\Hypertarget{classoomph_1_1Problem_ad4b9d15269f624044d1730957b0a8c19}\label{classoomph_1_1Problem_ad4b9d15269f624044d1730957b0a8c19}} 
\index{oomph::Problem@{oomph::Problem}!Mass\_matrix\_solver\_for\_explicit\_timestepper\_pt@{Mass\_matrix\_solver\_for\_explicit\_timestepper\_pt}}
\index{Mass\_matrix\_solver\_for\_explicit\_timestepper\_pt@{Mass\_matrix\_solver\_for\_explicit\_timestepper\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Mass\_matrix\_solver\_for\_explicit\_timestepper\_pt}{Mass\_matrix\_solver\_for\_explicit\_timestepper\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1LinearSolver}{Linear\+Solver}}$\ast$ oomph\+::\+Problem\+::\+Mass\+\_\+matrix\+\_\+solver\+\_\+for\+\_\+explicit\+\_\+timestepper\+\_\+pt\hspace{0.3cm}{\ttfamily [private]}}



Pointer to the linear solver used for explicit time steps (this is likely to be different to the linear solver for newton solves because explicit time steps only involve inverting a mass matrix. This can be done very efficiently by, e.\+g. \mbox{\hyperlink{classoomph_1_1CG}{CG}} with a diagonal predconditioner). 



Definition at line 179 of file problem.\+h.



Referenced by mass\+\_\+matrix\+\_\+solver\+\_\+for\+\_\+explicit\+\_\+timestepper\+\_\+pt(), and Problem().

\mbox{\Hypertarget{classoomph_1_1Problem_a52a58a98c3e2e7dbaefcfb1ee7830c35}\label{classoomph_1_1Problem_a52a58a98c3e2e7dbaefcfb1ee7830c35}} 
\index{oomph::Problem@{oomph::Problem}!Max\_newton\_iterations@{Max\_newton\_iterations}}
\index{Max\_newton\_iterations@{Max\_newton\_iterations}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Max\_newton\_iterations}{Max\_newton\_iterations}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::\+Max\+\_\+newton\+\_\+iterations\hspace{0.3cm}{\ttfamily [protected]}}



Maximum number of Newton iterations. 



Definition at line 599 of file problem.\+h.



Referenced by max\+\_\+newton\+\_\+iterations(), newton\+\_\+solve(), newton\+\_\+solve\+\_\+continuation(), steady\+\_\+newton\+\_\+solve(), and unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_aeadae1fc5f49e66223ee09c69a9e506d}\label{classoomph_1_1Problem_aeadae1fc5f49e66223ee09c69a9e506d}} 
\index{oomph::Problem@{oomph::Problem}!Max\_permitted\_error\_for\_halo\_check@{Max\_permitted\_error\_for\_halo\_check}}
\index{Max\_permitted\_error\_for\_halo\_check@{Max\_permitted\_error\_for\_halo\_check}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Max\_permitted\_error\_for\_halo\_check}{Max\_permitted\_error\_for\_halo\_check}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+Max\+\_\+permitted\+\_\+error\+\_\+for\+\_\+halo\+\_\+check}



Threshold for error throwing in \mbox{\hyperlink{classoomph_1_1Problem_a8dd5cb241ce6218fb476931e0879d7c8}{Problem\+::check\+\_\+halo\+\_\+schemes()}} 



Definition at line 2304 of file problem.\+h.



Referenced by check\+\_\+halo\+\_\+schemes().

\mbox{\Hypertarget{classoomph_1_1Problem_ab6f510bea9bdfcaf229415440a0a1c98}\label{classoomph_1_1Problem_ab6f510bea9bdfcaf229415440a0a1c98}} 
\index{oomph::Problem@{oomph::Problem}!Max\_res@{Max\_res}}
\index{Max\_res@{Max\_res}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Max\_res}{Max\_res}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$double$>$ oomph\+::\+Problem\+::\+Max\+\_\+res\hspace{0.3cm}{\ttfamily [protected]}}



Maximum residuals at start and after each newton iteration. 



Definition at line 606 of file problem.\+h.



Referenced by newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_accb8811cdf32f14be497917e922c623e}\label{classoomph_1_1Problem_accb8811cdf32f14be497917e922c623e}} 
\index{oomph::Problem@{oomph::Problem}!Max\_residuals@{Max\_residuals}}
\index{Max\_residuals@{Max\_residuals}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Max\_residuals}{Max\_residuals}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+Max\+\_\+residuals\hspace{0.3cm}{\ttfamily [protected]}}



Maximum desired residual\+: if the maximum residual exceeds this value, the program will exit. 



Definition at line 610 of file problem.\+h.



Referenced by max\+\_\+residuals(), newton\+\_\+solve(), newton\+\_\+solve\+\_\+continuation(), steady\+\_\+newton\+\_\+solve(), and unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_a7b5fde48b00a7fdc5f1fbbee138d0414}\label{classoomph_1_1Problem_a7b5fde48b00a7fdc5f1fbbee138d0414}} 
\index{oomph::Problem@{oomph::Problem}!Maximum\_dt@{Maximum\_dt}}
\index{Maximum\_dt@{Maximum\_dt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Maximum\_dt}{Maximum\_dt}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+Maximum\+\_\+dt\hspace{0.3cm}{\ttfamily [protected]}}



Maximum desired dt. 



Definition at line 709 of file problem.\+h.



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), and maximum\+\_\+dt().

\mbox{\Hypertarget{classoomph_1_1Problem_aa4a3bf9419e495aaaaea0dcb00ea53e5}\label{classoomph_1_1Problem_aa4a3bf9419e495aaaaea0dcb00ea53e5}} 
\index{oomph::Problem@{oomph::Problem}!Mesh\_pt@{Mesh\_pt}}
\index{Mesh\_pt@{Mesh\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Mesh\_pt}{Mesh\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}}$\ast$ oomph\+::\+Problem\+::\+Mesh\+\_\+pt\hspace{0.3cm}{\ttfamily [private]}}



The mesh pointer. 



Definition at line 167 of file problem.\+h.



Referenced by assign\+\_\+eqn\+\_\+numbers(), assign\+\_\+initial\+\_\+values\+\_\+impulsive(), build\+\_\+global\+\_\+mesh(), calculate\+\_\+predictions(), describe\+\_\+dofs(), does\+\_\+pointer\+\_\+correspond\+\_\+to\+\_\+problem\+\_\+data(), get\+\_\+hessian\+\_\+vector\+\_\+products(), get\+\_\+jacobian(), get\+\_\+residuals(), mesh\+\_\+pt(), rebuild\+\_\+global\+\_\+mesh(), recompute\+\_\+load\+\_\+balanced\+\_\+assembly(), set\+\_\+consistent\+\_\+pinned\+\_\+values\+\_\+for\+\_\+continuation(), set\+\_\+default\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly(), set\+\_\+pinned\+\_\+values\+\_\+to\+\_\+zero(), set\+\_\+timestepper\+\_\+for\+\_\+all\+\_\+data(), shift\+\_\+time\+\_\+values(), and $\sim$\+Problem().

\mbox{\Hypertarget{classoomph_1_1Problem_ad0f8bb126a4f5ddeb559c23a8d451d8d}\label{classoomph_1_1Problem_ad0f8bb126a4f5ddeb559c23a8d451d8d}} 
\index{oomph::Problem@{oomph::Problem}!Minimum\_ds@{Minimum\_ds}}
\index{Minimum\_ds@{Minimum\_ds}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Minimum\_ds}{Minimum\_ds}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+Minimum\+\_\+ds\hspace{0.3cm}{\ttfamily [protected]}}



Minimum desired value of arc-\/length. 



Definition at line 787 of file problem.\+h.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_ad7456318933aa01114dc78498bfd6d79}\label{classoomph_1_1Problem_ad7456318933aa01114dc78498bfd6d79}} 
\index{oomph::Problem@{oomph::Problem}!Minimum\_dt@{Minimum\_dt}}
\index{Minimum\_dt@{Minimum\_dt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Minimum\_dt}{Minimum\_dt}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+Minimum\+\_\+dt\hspace{0.3cm}{\ttfamily [protected]}}



Minimum desired dt\+: if dt falls below this value, exit. 



Definition at line 706 of file problem.\+h.



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), and minimum\+\_\+dt().

\mbox{\Hypertarget{classoomph_1_1Problem_abdee700b2cec37540cf1e7e1462df6c3}\label{classoomph_1_1Problem_abdee700b2cec37540cf1e7e1462df6c3}} 
\index{oomph::Problem@{oomph::Problem}!Minimum\_dt\_but\_still\_proceed@{Minimum\_dt\_but\_still\_proceed}}
\index{Minimum\_dt\_but\_still\_proceed@{Minimum\_dt\_but\_still\_proceed}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Minimum\_dt\_but\_still\_proceed}{Minimum\_dt\_but\_still\_proceed}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+Minimum\+\_\+dt\+\_\+but\+\_\+still\+\_\+proceed\hspace{0.3cm}{\ttfamily [protected]}}



If Minimum\+\_\+dt\+\_\+but\+\_\+still\+\_\+proceed positive, then dt will not be reduced below this value during adaptive timestepping and the computation will continue with this value, accepting the larger errors that this will incur). Note\+: This option is disabled by default as this value is initialised to -\/1.\+0. 



Definition at line 725 of file problem.\+h.



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_aab187e716f470b32a01d7f0cee7f3bf4}\label{classoomph_1_1Problem_aab187e716f470b32a01d7f0cee7f3bf4}} 
\index{oomph::Problem@{oomph::Problem}!Must\_recompute\_load\_balance\_for\_assembly@{Must\_recompute\_load\_balance\_for\_assembly}}
\index{Must\_recompute\_load\_balance\_for\_assembly@{Must\_recompute\_load\_balance\_for\_assembly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Must\_recompute\_load\_balance\_for\_assembly}{Must\_recompute\_load\_balance\_for\_assembly}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Must\+\_\+recompute\+\_\+load\+\_\+balance\+\_\+for\+\_\+assembly\hspace{0.3cm}{\ttfamily [private]}}



Boolean indicating that the division of elements over processors during the assembly process must be re-\/load-\/balanced. (only used for non-\/distributed problems) 



Definition at line 529 of file problem.\+h.



Referenced by assign\+\_\+eqn\+\_\+numbers(), clear\+\_\+elemental\+\_\+assembly\+\_\+time(), distribute(), parallel\+\_\+sparse\+\_\+assemble(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+lists(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+maps(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+vectors(), and sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+vectors\+\_\+of\+\_\+pairs().

\mbox{\Hypertarget{classoomph_1_1Problem_a94536b381e949edf5bb4d44434e08925}\label{classoomph_1_1Problem_a94536b381e949edf5bb4d44434e08925}} 
\index{oomph::Problem@{oomph::Problem}!Newton\_solver\_tolerance@{Newton\_solver\_tolerance}}
\index{Newton\_solver\_tolerance@{Newton\_solver\_tolerance}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Newton\_solver\_tolerance}{Newton\_solver\_tolerance}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+Newton\+\_\+solver\+\_\+tolerance\hspace{0.3cm}{\ttfamily [protected]}}



The Tolerance below which the Newton Method is deemed to have converged. 



Definition at line 596 of file problem.\+h.



Referenced by oomph\+::\+Segregatable\+FSIProblem\+::assess\+\_\+convergence\+\_\+based\+\_\+on\+\_\+absolute\+\_\+solid\+\_\+change(), oomph\+::\+Segregatable\+FSIProblem\+::assess\+\_\+convergence\+\_\+based\+\_\+on\+\_\+max\+\_\+global\+\_\+residual(), oomph\+::\+Segregatable\+FSIProblem\+::assess\+\_\+convergence\+\_\+based\+\_\+on\+\_\+relative\+\_\+solid\+\_\+change(), newton\+\_\+solve(), newton\+\_\+solve\+\_\+continuation(), newton\+\_\+solver\+\_\+tolerance(), and oomph\+::\+Segregatable\+FSIProblem\+::\+Segregatable\+FSIProblem().

\mbox{\Hypertarget{classoomph_1_1Problem_a3c05eefd6891808a1ef01e51288e0108}\label{classoomph_1_1Problem_a3c05eefd6891808a1ef01e51288e0108}} 
\index{oomph::Problem@{oomph::Problem}!Nnewton\_iter\_taken@{Nnewton\_iter\_taken}}
\index{Nnewton\_iter\_taken@{Nnewton\_iter\_taken}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Nnewton\_iter\_taken}{Nnewton\_iter\_taken}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::\+Nnewton\+\_\+iter\+\_\+taken\hspace{0.3cm}{\ttfamily [protected]}}



Actual number of Newton iterations taken during the most recent iteration. 



Definition at line 603 of file problem.\+h.



Referenced by newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_ad1a1ffc2bd685377ce7213452876b127}\label{classoomph_1_1Problem_ad1a1ffc2bd685377ce7213452876b127}} 
\index{oomph::Problem@{oomph::Problem}!Numerical\_zero\_for\_sparse\_assembly@{Numerical\_zero\_for\_sparse\_assembly}}
\index{Numerical\_zero\_for\_sparse\_assembly@{Numerical\_zero\_for\_sparse\_assembly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Numerical\_zero\_for\_sparse\_assembly}{Numerical\_zero\_for\_sparse\_assembly}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+Numerical\+\_\+zero\+\_\+for\+\_\+sparse\+\_\+assembly\hspace{0.3cm}{\ttfamily [protected]}}



A tolerance used to determine whether the entry in a sparse matrix is zero. If it is then storage need not be allocated. 



Definition at line 671 of file problem.\+h.



Referenced by parallel\+\_\+sparse\+\_\+assemble(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+lists(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+maps(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+vectors(), and sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+vectors\+\_\+of\+\_\+pairs().

\mbox{\Hypertarget{classoomph_1_1Problem_a6a96b64a44cb378db1c0a07c562f7dae}\label{classoomph_1_1Problem_a6a96b64a44cb378db1c0a07c562f7dae}} 
\index{oomph::Problem@{oomph::Problem}!Parallel\_sparse\_assemble\_previous\_allocation@{Parallel\_sparse\_assemble\_previous\_allocation}}
\index{Parallel\_sparse\_assemble\_previous\_allocation@{Parallel\_sparse\_assemble\_previous\_allocation}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Parallel\_sparse\_assemble\_previous\_allocation}{Parallel\_sparse\_assemble\_previous\_allocation}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::\+Parallel\+\_\+sparse\+\_\+assemble\+\_\+previous\+\_\+allocation\hspace{0.3cm}{\ttfamily [private]}}



The amount of data allocated during the previous parallel sparse assemble. Used to optimise the next call to \mbox{\hyperlink{classoomph_1_1Problem_a0487a7ef40e6cc4dad88e99ac96193e2}{parallel\+\_\+sparse\+\_\+assemble()}} 



Definition at line 960 of file problem.\+h.



Referenced by assign\+\_\+eqn\+\_\+numbers(), and parallel\+\_\+sparse\+\_\+assemble().

\mbox{\Hypertarget{classoomph_1_1Problem_a8e29673eb80559888d1c6148c4f11e57}\label{classoomph_1_1Problem_a8e29673eb80559888d1c6148c4f11e57}} 
\index{oomph::Problem@{oomph::Problem}!Parameter\_current@{Parameter\_current}}
\index{Parameter\_current@{Parameter\_current}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Parameter\_current}{Parameter\_current}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+Parameter\+\_\+current\hspace{0.3cm}{\ttfamily [protected]}}



Storage for the present value of the global parameter. 



Definition at line 755 of file problem.\+h.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd\+\_\+helper(), and newton\+\_\+solve\+\_\+continuation().

\mbox{\Hypertarget{classoomph_1_1Problem_aa5082325ca4cafe5a9ec03ef79c67a6f}\label{classoomph_1_1Problem_aa5082325ca4cafe5a9ec03ef79c67a6f}} 
\index{oomph::Problem@{oomph::Problem}!Parameter\_derivative@{Parameter\_derivative}}
\index{Parameter\_derivative@{Parameter\_derivative}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Parameter\_derivative}{Parameter\_derivative}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+Parameter\+\_\+derivative\hspace{0.3cm}{\ttfamily [protected]}}



Storage for the derivative of the global parameter wrt arc-\/length. 



Definition at line 752 of file problem.\+h.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), calculate\+\_\+continuation\+\_\+derivatives(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd\+\_\+helper(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+helper(), newton\+\_\+solve\+\_\+continuation(), and reset\+\_\+arc\+\_\+length\+\_\+parameters().

\mbox{\Hypertarget{classoomph_1_1Problem_aedefa8337ace6043c2fdfd5a2d19afd3}\label{classoomph_1_1Problem_aedefa8337ace6043c2fdfd5a2d19afd3}} 
\index{oomph::Problem@{oomph::Problem}!Pause\_at\_end\_of\_sparse\_assembly@{Pause\_at\_end\_of\_sparse\_assembly}}
\index{Pause\_at\_end\_of\_sparse\_assembly@{Pause\_at\_end\_of\_sparse\_assembly}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Pause\_at\_end\_of\_sparse\_assembly}{Pause\_at\_end\_of\_sparse\_assembly}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Pause\+\_\+at\+\_\+end\+\_\+of\+\_\+sparse\+\_\+assembly\hspace{0.3cm}{\ttfamily [protected]}}



Protected boolean flag to halt program execution during sparse assemble process to assess peak memory usage. Initialised to false (obviously!) 



Definition at line 633 of file problem.\+h.



Referenced by sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+lists(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+maps(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+vectors(), and sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+vectors\+\_\+of\+\_\+pairs().

\mbox{\Hypertarget{classoomph_1_1Problem_a5c6bd262be3544343a30767da278d846}\label{classoomph_1_1Problem_a5c6bd262be3544343a30767da278d846}} 
\index{oomph::Problem@{oomph::Problem}!Problem\_has\_been\_distributed@{Problem\_has\_been\_distributed}}
\index{Problem\_has\_been\_distributed@{Problem\_has\_been\_distributed}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Problem\_has\_been\_distributed}{Problem\_has\_been\_distributed}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Problem\+\_\+has\+\_\+been\+\_\+distributed\hspace{0.3cm}{\ttfamily [protected]}}



Has the problem been distributed amongst multiple processors? 



Definition at line 964 of file problem.\+h.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), assign\+\_\+eqn\+\_\+numbers(), create\+\_\+new\+\_\+linear\+\_\+algebra\+\_\+distribution(), disable\+\_\+problem\+\_\+distributed(), distribute(), distributed(), doubly\+\_\+adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve\+\_\+helper(), dump(), enable\+\_\+problem\+\_\+distributed(), get\+\_\+fd\+\_\+jacobian(), get\+\_\+hessian\+\_\+vector\+\_\+products(), global\+\_\+dof\+\_\+pt(), load\+\_\+balance(), newton\+\_\+solve(), parallel\+\_\+sparse\+\_\+assemble(), problem\+\_\+has\+\_\+been\+\_\+distributed(), prune\+\_\+halo\+\_\+elements\+\_\+and\+\_\+nodes(), read(), restore\+\_\+dof\+\_\+values(), self\+\_\+test(), set\+\_\+default\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly(), oomph\+::\+Solid\+ICProblem\+::set\+\_\+static\+\_\+initial\+\_\+condition(), set\+\_\+timestepper\+\_\+for\+\_\+all\+\_\+data(), setup\+\_\+element\+\_\+count\+\_\+per\+\_\+dof(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+lists(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+maps(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+vectors(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+vectors\+\_\+of\+\_\+pairs(), store\+\_\+current\+\_\+dof\+\_\+values(), and unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_ade2d3efba34f69aafaefc076ddb3b8d4}\label{classoomph_1_1Problem_ade2d3efba34f69aafaefc076ddb3b8d4}} 
\index{oomph::Problem@{oomph::Problem}!Problem\_is\_nonlinear@{Problem\_is\_nonlinear}}
\index{Problem\_is\_nonlinear@{Problem\_is\_nonlinear}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Problem\_is\_nonlinear}{Problem\_is\_nonlinear}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Problem\+\_\+is\+\_\+nonlinear\hspace{0.3cm}{\ttfamily [protected]}}



Boolean flag indicating if we\textquotesingle{}re dealing with a linear or nonlinear \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} -- if set to false the Newton solver will not check the residual before or after the linear solve. Set to true by default; can be over-\/written in specific \mbox{\hyperlink{classoomph_1_1Problem}{Problem}} class. 



Definition at line 628 of file problem.\+h.



Referenced by newton\+\_\+solve(), problem\+\_\+is\+\_\+nonlinear(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::project(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::\+Projection\+Problem(), and oomph\+::\+Womersley\+Problem$<$ ELEMENT, DIM $>$\+::\+Womersley\+Problem().

\mbox{\Hypertarget{classoomph_1_1Problem_a86c4feb98ec982a08dc84fb664f53abc}\label{classoomph_1_1Problem_a86c4feb98ec982a08dc84fb664f53abc}} 
\index{oomph::Problem@{oomph::Problem}!Relaxation\_factor@{Relaxation\_factor}}
\index{Relaxation\_factor@{Relaxation\_factor}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Relaxation\_factor}{Relaxation\_factor}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+Relaxation\+\_\+factor\hspace{0.3cm}{\ttfamily [protected]}}



Relaxation fator for Newton method (only a fractional Newton correction is applied if this is less than 1; default 1). 



Definition at line 592 of file problem.\+h.



Referenced by newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_aeef791a0158657ca7c298ffcb63ed54e}\label{classoomph_1_1Problem_aeef791a0158657ca7c298ffcb63ed54e}} 
\index{oomph::Problem@{oomph::Problem}!Saved\_dof\_pt@{Saved\_dof\_pt}}
\index{Saved\_dof\_pt@{Saved\_dof\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Saved\_dof\_pt}{Saved\_dof\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$double$>$$\ast$ oomph\+::\+Problem\+::\+Saved\+\_\+dof\+\_\+pt\hspace{0.3cm}{\ttfamily [private]}}



Pointer to vector for backup of dofs. 



Definition at line 207 of file problem.\+h.



Referenced by restore\+\_\+dof\+\_\+values(), and store\+\_\+current\+\_\+dof\+\_\+values().

\mbox{\Hypertarget{classoomph_1_1Problem_a708322baf423e373970384006c2ca4db}\label{classoomph_1_1Problem_a708322baf423e373970384006c2ca4db}} 
\index{oomph::Problem@{oomph::Problem}!Scale\_arc\_length@{Scale\_arc\_length}}
\index{Scale\_arc\_length@{Scale\_arc\_length}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Scale\_arc\_length}{Scale\_arc\_length}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Scale\+\_\+arc\+\_\+length\hspace{0.3cm}{\ttfamily [protected]}}



Boolean to control whether arc-\/length should be scaled. 



Definition at line 731 of file problem.\+h.



Referenced by calculate\+\_\+continuation\+\_\+derivatives(), and calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd().

\mbox{\Hypertarget{classoomph_1_1Problem_ab4a3743c23a2d1eed56981484636c958}\label{classoomph_1_1Problem_ab4a3743c23a2d1eed56981484636c958}} 
\index{oomph::Problem@{oomph::Problem}!Shut\_up\_in\_newton\_solve@{Shut\_up\_in\_newton\_solve}}
\index{Shut\_up\_in\_newton\_solve@{Shut\_up\_in\_newton\_solve}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Shut\_up\_in\_newton\_solve}{Shut\_up\_in\_newton\_solve}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Shut\+\_\+up\+\_\+in\+\_\+newton\+\_\+solve}



Boolean to indicate if all output is suppressed in \mbox{\hyperlink{classoomph_1_1Problem_a62a989ae9a9169b9d905f844db59787f}{Problem\+::newton\+\_\+solve()}}. Defaults to false. 



Definition at line 2320 of file problem.\+h.



Referenced by disable\+\_\+info\+\_\+in\+\_\+newton\+\_\+solve(), enable\+\_\+info\+\_\+in\+\_\+newton\+\_\+solve(), get\+\_\+inverse\+\_\+mass\+\_\+matrix\+\_\+times\+\_\+residuals(), newton\+\_\+solve(), newton\+\_\+solve\+\_\+continuation(), oomph\+::\+Projection\+Problem$<$ PROJECTABLE\+\_\+\+ELEMENT $>$\+::project(), recompute\+\_\+load\+\_\+balanced\+\_\+assembly(), and set\+\_\+default\+\_\+first\+\_\+and\+\_\+last\+\_\+element\+\_\+for\+\_\+assembly().

\mbox{\Hypertarget{classoomph_1_1Problem_aca97d61840e46edc914e3cb4b98fd437}\label{classoomph_1_1Problem_aca97d61840e46edc914e3cb4b98fd437}} 
\index{oomph::Problem@{oomph::Problem}!Sign\_of\_jacobian@{Sign\_of\_jacobian}}
\index{Sign\_of\_jacobian@{Sign\_of\_jacobian}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Sign\_of\_jacobian}{Sign\_of\_jacobian}}
{\footnotesize\ttfamily int oomph\+::\+Problem\+::\+Sign\+\_\+of\+\_\+jacobian\hspace{0.3cm}{\ttfamily [protected]}}



Storage for the sign of the global Jacobian. 



Definition at line 745 of file problem.\+h.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), reset\+\_\+arc\+\_\+length\+\_\+parameters(), and sign\+\_\+of\+\_\+jacobian().

\mbox{\Hypertarget{classoomph_1_1Problem_aeb58a3cead4d10697c4471523f705130}\label{classoomph_1_1Problem_aeb58a3cead4d10697c4471523f705130}} 
\index{oomph::Problem@{oomph::Problem}!Sparse\_assemble\_with\_arrays\_allocation\_increment@{Sparse\_assemble\_with\_arrays\_allocation\_increment}}
\index{Sparse\_assemble\_with\_arrays\_allocation\_increment@{Sparse\_assemble\_with\_arrays\_allocation\_increment}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Sparse\_assemble\_with\_arrays\_allocation\_increment}{Sparse\_assemble\_with\_arrays\_allocation\_increment}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::\+Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+allocation\+\_\+increment\hspace{0.3cm}{\ttfamily [protected]}}



the number of elements to add to a matrix row when the initial allocation is exceeded within the sparse\+\_\+assemble\+\_\+with\+\_\+two\+\_\+arrays(...) method. 



Definition at line 663 of file problem.\+h.



Referenced by parallel\+\_\+sparse\+\_\+assemble(), and sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays().

\mbox{\Hypertarget{classoomph_1_1Problem_ad2d5f8e18619fafcff11727b1c55b3eb}\label{classoomph_1_1Problem_ad2d5f8e18619fafcff11727b1c55b3eb}} 
\index{oomph::Problem@{oomph::Problem}!Sparse\_assemble\_with\_arrays\_initial\_allocation@{Sparse\_assemble\_with\_arrays\_initial\_allocation}}
\index{Sparse\_assemble\_with\_arrays\_initial\_allocation@{Sparse\_assemble\_with\_arrays\_initial\_allocation}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Sparse\_assemble\_with\_arrays\_initial\_allocation}{Sparse\_assemble\_with\_arrays\_initial\_allocation}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::\+Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+initial\+\_\+allocation\hspace{0.3cm}{\ttfamily [protected]}}



the number of elements to initially allocate for a matrix row within the sparse\+\_\+assembly\+\_\+with\+\_\+two\+\_\+arrays(...) method (if a matrix of this size has not been assembled already). If a matrix of this size has been assembled then the number of elements in each row in that matrix is used as the initial allocation 



Definition at line 658 of file problem.\+h.



Referenced by parallel\+\_\+sparse\+\_\+assemble(), and sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays().

\mbox{\Hypertarget{classoomph_1_1Problem_a547c85bfa6a2eb3effc4db1b46ebcdde}\label{classoomph_1_1Problem_a547c85bfa6a2eb3effc4db1b46ebcdde}} 
\index{oomph::Problem@{oomph::Problem}!Sparse\_assemble\_with\_arrays\_previous\_allocation@{Sparse\_assemble\_with\_arrays\_previous\_allocation}}
\index{Sparse\_assemble\_with\_arrays\_previous\_allocation@{Sparse\_assemble\_with\_arrays\_previous\_allocation}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Sparse\_assemble\_with\_arrays\_previous\_allocation}{Sparse\_assemble\_with\_arrays\_previous\_allocation}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$\mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$unsigned$>$ $>$ oomph\+::\+Problem\+::\+Sparse\+\_\+assemble\+\_\+with\+\_\+arrays\+\_\+previous\+\_\+allocation\hspace{0.3cm}{\ttfamily [protected]}}



the number of elements in each row of a compressed matrix in the previous matrix assembly. 



Definition at line 667 of file problem.\+h.



Referenced by assign\+\_\+eqn\+\_\+numbers(), oomph\+::\+Fold\+Handler\+::\+Fold\+Handler(), oomph\+::\+Hopf\+Handler\+::\+Hopf\+Handler(), parallel\+\_\+sparse\+\_\+assemble(), oomph\+::\+Pitch\+Fork\+Handler\+::\+Pitch\+Fork\+Handler(), recompute\+\_\+load\+\_\+balanced\+\_\+assembly(), oomph\+::\+Fold\+Handler\+::solve\+\_\+augmented\+\_\+block\+\_\+system(), oomph\+::\+Pitch\+Fork\+Handler\+::solve\+\_\+augmented\+\_\+block\+\_\+system(), oomph\+::\+Fold\+Handler\+::solve\+\_\+block\+\_\+system(), oomph\+::\+Pitch\+Fork\+Handler\+::solve\+\_\+block\+\_\+system(), oomph\+::\+Hopf\+Handler\+::solve\+\_\+complex\+\_\+system(), oomph\+::\+Fold\+Handler\+::solve\+\_\+full\+\_\+system(), oomph\+::\+Pitch\+Fork\+Handler\+::solve\+\_\+full\+\_\+system(), oomph\+::\+Hopf\+Handler\+::solve\+\_\+full\+\_\+system(), oomph\+::\+Hopf\+Handler\+::solve\+\_\+standard\+\_\+system(), sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed\+\_\+with\+\_\+two\+\_\+arrays(), oomph\+::\+Fold\+Handler\+::$\sim$\+Fold\+Handler(), oomph\+::\+Hopf\+Handler\+::$\sim$\+Hopf\+Handler(), and oomph\+::\+Pitch\+Fork\+Handler\+::$\sim$\+Pitch\+Fork\+Handler().

\mbox{\Hypertarget{classoomph_1_1Problem_a447f9d42b248f6c394581ff1a0b02513}\label{classoomph_1_1Problem_a447f9d42b248f6c394581ff1a0b02513}} 
\index{oomph::Problem@{oomph::Problem}!Sparse\_assembly\_method@{Sparse\_assembly\_method}}
\index{Sparse\_assembly\_method@{Sparse\_assembly\_method}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Sparse\_assembly\_method}{Sparse\_assembly\_method}}
{\footnotesize\ttfamily unsigned oomph\+::\+Problem\+::\+Sparse\+\_\+assembly\+\_\+method\hspace{0.3cm}{\ttfamily [protected]}}



Flag to determine which sparse assembly method to use By default we use assembly by vectors of pairs. 



Definition at line 641 of file problem.\+h.



Referenced by sparse\+\_\+assemble\+\_\+row\+\_\+or\+\_\+column\+\_\+compressed().

\mbox{\Hypertarget{classoomph_1_1Problem_a075696d6f4c4260ce860997c8c931de4}\label{classoomph_1_1Problem_a075696d6f4c4260ce860997c8c931de4}} 
\index{oomph::Problem@{oomph::Problem}!Store\_local\_dof\_pt\_in\_elements@{Store\_local\_dof\_pt\_in\_elements}}
\index{Store\_local\_dof\_pt\_in\_elements@{Store\_local\_dof\_pt\_in\_elements}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Store\_local\_dof\_pt\_in\_elements}{Store\_local\_dof\_pt\_in\_elements}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Store\+\_\+local\+\_\+dof\+\_\+pt\+\_\+in\+\_\+elements\hspace{0.3cm}{\ttfamily [private]}}



Boolean to indicate whether local dof pointers should be stored in the elements. 



Definition at line 226 of file problem.\+h.



Referenced by assign\+\_\+eqn\+\_\+numbers(), disable\+\_\+store\+\_\+local\+\_\+dof\+\_\+pt\+\_\+in\+\_\+elements(), enable\+\_\+store\+\_\+local\+\_\+dof\+\_\+pt\+\_\+in\+\_\+elements(), and synchronise\+\_\+eqn\+\_\+numbers().

\mbox{\Hypertarget{classoomph_1_1Problem_ab65f6fc9c49860e6324457a7e6e76346}\label{classoomph_1_1Problem_ab65f6fc9c49860e6324457a7e6e76346}} 
\index{oomph::Problem@{oomph::Problem}!Sub\_mesh\_pt@{Sub\_mesh\_pt}}
\index{Sub\_mesh\_pt@{Sub\_mesh\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Sub\_mesh\_pt}{Sub\_mesh\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$\mbox{\hyperlink{classoomph_1_1Mesh}{Mesh}}$\ast$$>$ oomph\+::\+Problem\+::\+Sub\+\_\+mesh\+\_\+pt\hspace{0.3cm}{\ttfamily [private]}}



\mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of pointers to submeshes. 



Definition at line 170 of file problem.\+h.



Referenced by add\+\_\+sub\+\_\+mesh(), assign\+\_\+eqn\+\_\+numbers(), build\+\_\+global\+\_\+mesh(), describe\+\_\+dofs(), does\+\_\+pointer\+\_\+correspond\+\_\+to\+\_\+problem\+\_\+data(), flush\+\_\+sub\+\_\+meshes(), mesh\+\_\+pt(), nsub\+\_\+mesh(), Problem(), rebuild\+\_\+global\+\_\+mesh(), set\+\_\+consistent\+\_\+pinned\+\_\+values\+\_\+for\+\_\+continuation(), set\+\_\+pinned\+\_\+values\+\_\+to\+\_\+zero(), set\+\_\+timestepper\+\_\+for\+\_\+all\+\_\+data(), and $\sim$\+Problem().

\mbox{\Hypertarget{classoomph_1_1Problem_a223a45fe6b1c80ee0109037b63e162f9}\label{classoomph_1_1Problem_a223a45fe6b1c80ee0109037b63e162f9}} 
\index{oomph::Problem@{oomph::Problem}!Suppress\_warning\_about\_actions\_before\_read\_unstructured\_meshes@{Suppress\_warning\_about\_actions\_before\_read\_unstructured\_meshes}}
\index{Suppress\_warning\_about\_actions\_before\_read\_unstructured\_meshes@{Suppress\_warning\_about\_actions\_before\_read\_unstructured\_meshes}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Suppress\_warning\_about\_actions\_before\_read\_unstructured\_meshes}{Suppress\_warning\_about\_actions\_before\_read\_unstructured\_meshes}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Suppress\+\_\+warning\+\_\+about\+\_\+actions\+\_\+before\+\_\+read\+\_\+unstructured\+\_\+meshes\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{=}
\DoxyCodeLine{    \textcolor{keyword}{false}}

\end{DoxyCode}


Flag to allow suppression of warning messages re reading in unstructured meshes during restart. 

Instantiation of public flag to allow suppression of warning messages re reading in unstructured meshes during restart. 

Definition at line 317 of file problem.\+h.



Referenced by read().

\mbox{\Hypertarget{classoomph_1_1Problem_a123843ca2ed6384342939ef2b19477ef}\label{classoomph_1_1Problem_a123843ca2ed6384342939ef2b19477ef}} 
\index{oomph::Problem@{oomph::Problem}!Theta\_squared@{Theta\_squared}}
\index{Theta\_squared@{Theta\_squared}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Theta\_squared}{Theta\_squared}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+Theta\+\_\+squared\hspace{0.3cm}{\ttfamily [protected]}}



Value of the scaling parameter required so that the parameter occupies the desired proportion of the arc length. NOTE\+: If you wish to change this then make sure to set the value of Scale\+\_\+arc\+\_\+length to false to ensure the value of this isn\textquotesingle{}t overwritten during the arc-\/length process. Instead of changing this variable, it\textquotesingle{}s better to actually update the Desired\+\_\+proportion\+\_\+of\+\_\+arc\+\_\+length value. 



Definition at line 742 of file problem.\+h.



Referenced by calculate\+\_\+continuation\+\_\+derivatives(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+fd\+\_\+helper(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+helper(), newton\+\_\+solve\+\_\+continuation(), and reset\+\_\+arc\+\_\+length\+\_\+parameters().

\mbox{\Hypertarget{classoomph_1_1Problem_a3e9aecf88bde320bc2d169b5f3c99fee}\label{classoomph_1_1Problem_a3e9aecf88bde320bc2d169b5f3c99fee}} 
\index{oomph::Problem@{oomph::Problem}!Time\_adaptive\_newton\_crash\_on\_solve\_fail@{Time\_adaptive\_newton\_crash\_on\_solve\_fail}}
\index{Time\_adaptive\_newton\_crash\_on\_solve\_fail@{Time\_adaptive\_newton\_crash\_on\_solve\_fail}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Time\_adaptive\_newton\_crash\_on\_solve\_fail}{Time\_adaptive\_newton\_crash\_on\_solve\_fail}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Time\+\_\+adaptive\+\_\+newton\+\_\+crash\+\_\+on\+\_\+solve\+\_\+fail\hspace{0.3cm}{\ttfamily [protected]}}



Bool to specify what to do if a Newton solve fails within a time adaptive solve. Default (false) is to half the step and try again. If true then crash instead. 



Definition at line 615 of file problem.\+h.



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve(), and time\+\_\+adaptive\+\_\+newton\+\_\+crash\+\_\+on\+\_\+solve\+\_\+fail().

\mbox{\Hypertarget{classoomph_1_1Problem_ae33fbf5f34a7d06d88ad2c98538bbbe8}\label{classoomph_1_1Problem_ae33fbf5f34a7d06d88ad2c98538bbbe8}} 
\index{oomph::Problem@{oomph::Problem}!Time\_pt@{Time\_pt}}
\index{Time\_pt@{Time\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Time\_pt}{Time\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Time}{Time}}$\ast$ oomph\+::\+Problem\+::\+Time\+\_\+pt\hspace{0.3cm}{\ttfamily [private]}}



Pointer to global time for the problem. 



Definition at line 197 of file problem.\+h.



Referenced by add\+\_\+time\+\_\+stepper\+\_\+pt(), initialise\+\_\+dt(), set\+\_\+explicit\+\_\+time\+\_\+stepper\+\_\+pt(), shift\+\_\+time\+\_\+values(), time(), time\+\_\+pt(), and $\sim$\+Problem().

\mbox{\Hypertarget{classoomph_1_1Problem_af1e8f8a739453250eb3744fea2a3b983}\label{classoomph_1_1Problem_af1e8f8a739453250eb3744fea2a3b983}} 
\index{oomph::Problem@{oomph::Problem}!Time\_stepper\_pt@{Time\_stepper\_pt}}
\index{Time\_stepper\_pt@{Time\_stepper\_pt}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Time\_stepper\_pt}{Time\_stepper\_pt}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoomph_1_1Vector}{Vector}}$<$\mbox{\hyperlink{classoomph_1_1TimeStepper}{Time\+Stepper}}$\ast$$>$ oomph\+::\+Problem\+::\+Time\+\_\+stepper\+\_\+pt\hspace{0.3cm}{\ttfamily [private]}}



The \mbox{\hyperlink{classoomph_1_1Vector}{Vector}} of time steppers (there could be many different ones in multiphysics problems) 



Definition at line 201 of file problem.\+h.



Referenced by add\+\_\+time\+\_\+stepper\+\_\+pt(), calculate\+\_\+predictions(), ntime\+\_\+stepper(), Problem(), and time\+\_\+stepper\+\_\+pt().

\mbox{\Hypertarget{classoomph_1_1Problem_a359d1936bc2146e0a0ce697776efcf91}\label{classoomph_1_1Problem_a359d1936bc2146e0a0ce697776efcf91}} 
\index{oomph::Problem@{oomph::Problem}!Timestep\_reduction\_factor\_after\_nonconvergence@{Timestep\_reduction\_factor\_after\_nonconvergence}}
\index{Timestep\_reduction\_factor\_after\_nonconvergence@{Timestep\_reduction\_factor\_after\_nonconvergence}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Timestep\_reduction\_factor\_after\_nonconvergence}{Timestep\_reduction\_factor\_after\_nonconvergence}}
{\footnotesize\ttfamily double oomph\+::\+Problem\+::\+Timestep\+\_\+reduction\+\_\+factor\+\_\+after\+\_\+nonconvergence\hspace{0.3cm}{\ttfamily [protected]}}



What it says\+: If temporally adaptive Newton solver fails to to converge, reduce timestep by this factor and try again; defaults to 1/2; can be over-\/written by user in derived problem. 



Definition at line 2331 of file problem.\+h.



Referenced by adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_adbecce0cb1bd7b6b21285568e41ee3eb}\label{classoomph_1_1Problem_adbecce0cb1bd7b6b21285568e41ee3eb}} 
\index{oomph::Problem@{oomph::Problem}!Use\_continuation\_timestepper@{Use\_continuation\_timestepper}}
\index{Use\_continuation\_timestepper@{Use\_continuation\_timestepper}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Use\_continuation\_timestepper}{Use\_continuation\_timestepper}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Use\+\_\+continuation\+\_\+timestepper\hspace{0.3cm}{\ttfamily [protected]}}



Boolean to control original or new storage of dof stuff. 



Definition at line 758 of file problem.\+h.



Referenced by adapt(), arc\+\_\+length\+\_\+step\+\_\+solve(), arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper(), calculate\+\_\+continuation\+\_\+derivatives\+\_\+helper(), dof\+\_\+current(), and dof\+\_\+derivative().

\mbox{\Hypertarget{classoomph_1_1Problem_a259414329d43257a71790ac2983e32d4}\label{classoomph_1_1Problem_a259414329d43257a71790ac2983e32d4}} 
\index{oomph::Problem@{oomph::Problem}!Use\_default\_partition\_in\_load\_balance@{Use\_default\_partition\_in\_load\_balance}}
\index{Use\_default\_partition\_in\_load\_balance@{Use\_default\_partition\_in\_load\_balance}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Use\_default\_partition\_in\_load\_balance}{Use\_default\_partition\_in\_load\_balance}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Use\+\_\+default\+\_\+partition\+\_\+in\+\_\+load\+\_\+balance\hspace{0.3cm}{\ttfamily [private]}}



Flag to use \char`\"{}default partition\char`\"{} during load balance. Should only be set to true when run in validation mode. 



Definition at line 514 of file problem.\+h.



Referenced by load\+\_\+balance(), set\+\_\+default\+\_\+partition\+\_\+in\+\_\+load\+\_\+balance(), and unset\+\_\+default\+\_\+partition\+\_\+in\+\_\+load\+\_\+balance().

\mbox{\Hypertarget{classoomph_1_1Problem_a80dac9f70c77302805bb782cc6f1ad0f}\label{classoomph_1_1Problem_a80dac9f70c77302805bb782cc6f1ad0f}} 
\index{oomph::Problem@{oomph::Problem}!Use\_finite\_differences\_for\_continuation\_derivatives@{Use\_finite\_differences\_for\_continuation\_derivatives}}
\index{Use\_finite\_differences\_for\_continuation\_derivatives@{Use\_finite\_differences\_for\_continuation\_derivatives}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Use\_finite\_differences\_for\_continuation\_derivatives}{Use\_finite\_differences\_for\_continuation\_derivatives}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Use\+\_\+finite\+\_\+differences\+\_\+for\+\_\+continuation\+\_\+derivatives\hspace{0.3cm}{\ttfamily [protected]}}



Boolean to specify which scheme to use to calculate the continuation derivatievs. 



Definition at line 803 of file problem.\+h.



Referenced by arc\+\_\+length\+\_\+step\+\_\+solve\+\_\+helper().

\mbox{\Hypertarget{classoomph_1_1Problem_acf8b1ec937efdf2a0f892a41c18c0c53}\label{classoomph_1_1Problem_acf8b1ec937efdf2a0f892a41c18c0c53}} 
\index{oomph::Problem@{oomph::Problem}!Use\_globally\_convergent\_newton\_method@{Use\_globally\_convergent\_newton\_method}}
\index{Use\_globally\_convergent\_newton\_method@{Use\_globally\_convergent\_newton\_method}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Use\_globally\_convergent\_newton\_method}{Use\_globally\_convergent\_newton\_method}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Use\+\_\+globally\+\_\+convergent\+\_\+newton\+\_\+method\hspace{0.3cm}{\ttfamily [private]}}



Use the globally convergent newton method. 



Definition at line 214 of file problem.\+h.



Referenced by disable\+\_\+globally\+\_\+convergent\+\_\+newton\+\_\+method(), enable\+\_\+globally\+\_\+convergent\+\_\+newton\+\_\+method(), and newton\+\_\+solve().

\mbox{\Hypertarget{classoomph_1_1Problem_afe6f5bb841832b3c4d1f06c2d939f4a6}\label{classoomph_1_1Problem_afe6f5bb841832b3c4d1f06c2d939f4a6}} 
\index{oomph::Problem@{oomph::Problem}!Use\_predictor\_values\_as\_initial\_guess@{Use\_predictor\_values\_as\_initial\_guess}}
\index{Use\_predictor\_values\_as\_initial\_guess@{Use\_predictor\_values\_as\_initial\_guess}!oomph::Problem@{oomph::Problem}}
\doxysubsubsection{\texorpdfstring{Use\_predictor\_values\_as\_initial\_guess}{Use\_predictor\_values\_as\_initial\_guess}}
{\footnotesize\ttfamily bool oomph\+::\+Problem\+::\+Use\+\_\+predictor\+\_\+values\+\_\+as\+\_\+initial\+\_\+guess\hspace{0.3cm}{\ttfamily [private]}}



Use values from the time stepper predictor as an initial guess. 



Definition at line 229 of file problem.\+h.



Referenced by Problem(), and use\+\_\+predictor\+\_\+values\+\_\+as\+\_\+initial\+\_\+guess().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{problem_8h}{problem.\+h}}\item 
\mbox{\hyperlink{problem_8cc}{problem.\+cc}}\end{DoxyCompactItemize}
