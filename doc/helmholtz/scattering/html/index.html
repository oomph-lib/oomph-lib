<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
<title>oomph-lib: Example problem: The Helmholtz equation &ndash; scattering problems</title>
<link rel="apple-touch-icon" sizes="57x57" href="../../../figures/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../../figures/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../../figures/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../../figures/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../../figures/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../../figures/apple-touch-icon-120x120.png">
<link rel="icon" type="image/png" href="../../../figures/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../figures/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../figures/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../figures/manifest.json">
<link rel="mask-icon" href="../../../figures/safari-pinned-tab.svg" color="#008000">
<link rel="shortcut icon" href="../../../figures/favicon.ico">
<meta name="msapplication-TileColor" content="#00a300">
<meta name="msapplication-config" content="../../../figures/browserconfig.xml">
<meta name="theme-color" content="#008000">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
<!-- Doxygen css-->
<!-- <link rel="stylesheet" type="text/css" href="doxygen.css"> -->
<!-- Bootstrap -->
<link href="../../../css/bootstrap.css" rel="stylesheet">
<!-- oomph-lib specific overrides -->
<link rel="stylesheet" type="text/css" href="../../../css/oomph_header.css">
</head>
<body>
<nav class="navbar navbar-default">
<div class="container">
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="../../../html/index.html"><img alt="oomph-lib" src="../../../figures/oomph_logo.png"></a>
  </div>
  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav">          
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li class="dropdown-header">Big picture</li>
          <li><a href="../../../../doc/intro/html/index.html">The finite element method</a></li>
          <li><a href="../../../../doc/the_data_structure/html/index.html">The data structure</a></li>
          <li><a href="../../../../doc/quick_guide/html/index.html">Not-so-quick guide</a></li>
          <li><a href="../../../../doc/optimisation/html/index.html">Optimisation</a></li>
          <li><a href="../../../../doc/order_of_action_functions/html/index.html">Order of action functions</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Example codes and tutorials</li>
          <li><a href="../../../../doc/example_code_list/html/index.html">List of example codes and tutorials</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#meshes">Meshing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#solvers">Solvers</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#parallel">MPI parallel processing</a></li>
          <li><a href="../../../../doc/example_code_list/html/index.html#visualisation">Post-processing/visualisation</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Other</li>
          <li><a href="../../../../doc/change_log/html/index.html">Change log</a></li>
          <li><a href="../../../../doc/creating_doc/html/index.html">Creating documentation</a></li>
          <li><a href="../../../../doc/coding_conventions/html/index.html">Coding conventions</a></li>
          <li><a href="../../../../doc/index/html/index.html">Index</a></li>
          <li><a href="../../../../doc/FAQ/html/index.html">FAQ</a></li>
        </ul>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Installation<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/the_distribution/html/index.html">Installation guide</a></li>
            <li><a href="../../../../doc/copyright/html/index.html">Copyright</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">About <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../../../../doc/people/html/index.html">People</a></li>            
            <li><a href="../../../../doc/contact/html/index.html">Contact/Get involved</a></li>
            <li><a href="../../../../doc/publications/html/index.html">Publications</a></li>
            <li><a href="../../../../doc/acknowledgements/html/index.html">Acknowledgements</a></li>
            <li><a href="../../../../doc/picture_show/index.html">Picture show</a></li>
          </ul>
        </li>
      </li>
    </ul>
    <ul class="nav navbar-nav navbar-right navbar-search">
      <form class="navbar-form" role="search" action="../../../../doc/search_results/html/index.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" name="q">
          <span class="input-group-btn">
            <button class="btn btn-default" type="submit">Go</button>
          </span>
        </div><!-- /input-group -->
       <!--<div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>-->
      </form>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</div>
</nav>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Example problem: The Helmholtz equation &ndash; scattering problems </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this document we discuss the finite-element-based solution of the Helmholtz equation, an elliptic PDE that describes time-harmonic wave propagation problems. We start by reviewing the relevant theory and then present the solution of a simple model problem &ndash; the scattering of a planar wave from a circular cylinder.</p>
<center> <table border="1," width="500px">
<tr>
<td bgcolor="cornsilk"><center> <b>Acknowledgement:</b> This tutorial and the associated driver codes were developed jointly with Tarak Kharrat (EnstaParisTech, Paris). </center>   </td></tr>
</table>
</center><hr  />
 <hr  />
<h1><a class="anchor" id="theory"></a>
Theory: The Helmholtz equation for time-harmonic scattering problems</h1>
<p>The Helmholtz equation governs time-harmonic solutions of problems governed by the linear wave equation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \nabla^2 U(x,y,t) = \frac{1}{c^2} \frac{\partial^2 U(x,y,t)}{\partial t^2}, \ \ \ \ \ \ \ \ \ \ \ \ (1) \]" src="form_0.png" width="231" height="29"/>
</p>
<p> where <img class="formulaInl" alt="$ c $" src="form_1.png" width="5" height="6"/> is the wavespeed. Assuming that <img class="formulaInl" alt="$ U(x,y,t) $" src="form_2.png" width="48" height="14"/> is time-harmonic, with frequency <img class="formulaInl" alt="$ \omega $" src="form_3.png" width="9" height="6"/>, we write the real function <img class="formulaInl" alt="$ U(x,y,t) $" src="form_2.png" width="48" height="14"/> as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ U(x,y,t) =Re (u(x,y) \ e^{-i \omega t}) \]" src="form_4.png" width="159" height="16"/>
</p>
<p> where <img class="formulaInl" alt="$ u(x,y) $" src="form_5.png" width="36" height="14"/> is complex-valued. This transforms (1) into the Helmholtz equation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \nabla^2 u(x,y) + k^2 u(x,y) = 0 \ \ \ \ \ \ \ \ \ \ \ \ (2) \]" src="form_6.png" width="204" height="16"/>
</p>
<p> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ k = \frac{\omega}{c} \ \ \ \ \ \ \ \ \ \ \ \ (3) \]" src="form_7.png" width="100" height="24"/>
</p>
<p> is the wave number. Like other elliptic PDEs the Helmholtz equation admits Dirichlet, Neumann (flux) and Robin boundary conditions.</p>
<p>If the equation is solved in an infinite domain (e.g. in scattering problems) the solution must satisfy the so-called <a href="http://en.wikipedia.org/wiki/Sommerfeld_radiation_condition">Sommerfeld radiation condition</a> which in 2D has the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \lim_{r\to \infty} \sqrt{r} \left(\frac{\partial u}{\partial r} - iku \right) =0. \]" src="form_8.png" width="141" height="31"/>
</p>
<p> Mathematically, this conditions is required to ensure the uniqueness of the solution (and hence the well-posedness of the problem). In a physical context, such as a scattering problem, the condition ensures that scattering of an incoming wave only produces outgoing not incoming waves from infinity.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="discr"></a>
Discretisation by finite elements</h1>
<p>The discretisation of the Helmholtz equation itself only requires a trivial modification of <code>oomph-lib's</code> Poisson elements &ndash; we simply add the term <img class="formulaInl" alt="$ k^2 u $" src="form_9.png" width="20" height="11"/> to the residual. Since most practical applications of the Helmholtz equation involve complex-valued solutions, we provide separate storage for the real and imaginary parts of the solution &ndash; each <code>Node</code> therefore stores two unknowns values. By default, the real and imaginary parts are stored as values 0 and 1, respectively; see the section <a class="el" href="index.html#numbering">The enumeration of the unknowns</a> for details.</p>
<p>The application of Dirichlet and Neumann boundary conditions is straightforward and follows the pattern employed for the solution of the Poisson equation:</p><ul>
<li>Dirichlet conditions are imposed by pinning the relevant nodal values and setting them to the appropriate prescribed values.</li>
<li>Neumann (flux) boundary conditions are imposed via <code>FaceElements</code> (here the <code>HelmholtzFluxElements</code>). <a href="../../../poisson/two_d_poisson_flux_bc/html/index.html">As usual</a> we attach these to the faces of the "bulk" elements that are subject to the Neumann boundary conditions.</li>
</ul>
<p>The imposition of the Sommerfeld radiation condition for problems in infinite domains is slightly more complicated. In the following discussion we will restrict ourselves to two dimensions and assume that the infinite domain is truncated at a circular artificial boundary <img class="formulaInl" alt="$ \Gamma $" src="form_10.png" width="9" height="9"/> of radius <img class="formulaInl" alt="$ R. $" src="form_11.png" width="13" height="10"/> [This assumption is also made in the implementation of <code>oomph-lib's</code> <code>FaceElements</code> that allow the (approximate) imposition of the Sommerfeld radiation condition. The methodology can easily be modified to deal with other geometries but this has not been done yet &ndash; any volunteers?] All methods exploit the fact that the relevant solution of the Helmholtz equation can be written in polar coordinates as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u(r,\varphi) = \sum_{n=-\infty}^{+\infty} A_n \ H_n^{(1)}(kr) \ e^{i n \varphi}, \ \ \ \ \ \ \ (4) \]" src="form_12.png" width="230" height="38"/>
</p>
<p> where the <img class="formulaInl" alt="$A_n $" src="form_13.png" width="16" height="13"/> are suitable coefficients and <img class="formulaInl" alt="$ H_n^{(1)}(r) $" src="form_14.png" width="39" height="18"/> is the <img class="formulaInl" alt="$ n $" src="form_15.png" width="9" height="6"/>-th-order Hankel function of the first kind.</p>
<hr  />
<h2><a class="anchor" id="ABCs"></a>
Approximate/absorbing boundary conditions (ABCs)</h2>
<p>It is possible to derive approximate versions of the Sommerfeld radiation condition in which the normal derivative of the solution on the artificial boundary is related to its value and possibly its tangential derivatives. Such boundary conditions (sometimes referred to as approximate or absorbing boundary conditions &ndash; ABCs) are typically derived from asymptotic expansions of the solution at large distances from the origin and become more accurate the larger the radius <img class="formulaInl" alt="$ R $" src="form_16.png" width="10" height="10"/> of the artificial boundary <img class="formulaInl" alt="$ \Gamma $" src="form_10.png" width="9" height="9"/> is. Higher accuracy can therefore only be achieved by increasing the size of the computational domain, with an associated increase in computational cost.</p>
<p><code>oomph-lib</code> provides an implementation of the following three boundary conditions (all taken from J. J. Shirron &amp; I. Babuska's paper "A comparison of approximate boundary conditions and infinite element methods for exterior Helmholtz problems", Computer Methods in Applied Mechanics and Engineering <b>164</b> 121-139 (1998), in which the authors compare the accuracy of these and many other approximate boundary conditions).</p>
<ul>
<li><b>Feng's first order ABC:</b> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac {\partial u}{\partial n}-\bigg( ik - \frac{1}{2R}\bigg) u =0 \mbox{\ \ \ \ \ on\ }\Gamma \]" src="form_17.png" width="173" height="31"/>
</p>
 (This is identical to the first-order Bayliss and Turkel boundary condition).</li>
<li><b>Feng's second order ABC:</b> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial u}{\partial n}-\bigg[ik-\frac {1}{2R}+\frac{i}{8kR^{2}}\bigg(1+4 \frac {\partial^{2}}{\partial \varphi^{2}}\bigg)\bigg]u =0 \mbox{\ \ \ \ \ on\ }\Gamma \]" src="form_18.png" width="283" height="31"/>
</p>
</li>
<li><b>Feng's third order ABC:</b> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac {\partial u}{\partial n}-\bigg[ik-\frac {1}{2R}+\frac{1}{8k^{2}R^{2}}\bigg(ik+ \frac {1}{R}\bigg) \bigg(1+4 \frac {\partial^{2}}{\partial \varphi^{2}}\bigg)\bigg]u =0 \mbox{\ \ \ \ \ on\ }\Gamma \]" src="form_19.png" width="345" height="31"/>
</p>
</li>
</ul>
<p>All three boundary conditions are implemented in the class <code>HelmholtzAbsorbingBCElement</code>. The order of the approximation can be set via the member function <code>HelmholtzAbsorbingBCElement::abc_order()</code>. All three boundary conditions are local (relating the function to its normal derivative) and do therefore not change the sparsity of the resulting finite element equations.</p>
<hr  />
<h2><a class="anchor" id="DtN"></a>
The Dirichlet-to-Neumann mapping (DtN)</h2>
<p>Using (4), it is easy to show (see, e.g., J. Jin "The Finite Element Method in Electromagnetics (second
edition)", Wiley (2002) p. 501ff &ndash; but note that Jin assumes that the potential varies like <img class="formulaInl" alt="$ \exp(i\omega t)$" src="form_20.png" width="46" height="14"/> rather than <img class="formulaInl" alt="$ \exp(-i\omega t)$" src="form_21.png" width="56" height="14"/> as assumed here) that the normal (radial) derivative, <img class="formulaInl" alt="$ \partial u / \partial n = \partial u / \partial r, $" src="form_22.png" width="89" height="14"/> on the artificial boundary <br  />
 <img class="formulaInl" alt="$ \Gamma $" src="form_10.png" width="9" height="9"/> is given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac {\partial u}{\partial r}\bigg|_{r=R} = \frac {\partial u}{\partial n}\bigg|_{r=R} = \gamma (u) \ \ \ \ \ \ \ (5) \]" src="form_23.png" width="186" height="33"/>
</p>
<p> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \gamma (u) = \frac {k}{2 \pi} \sum_{n=-\infty}^{+\infty} \frac {H_n^{(1)^{'}}(kR)}{H_n^{(1)}(kR)} \quad \int_0^{2\pi}u(R,\varphi^{'}) \ e^{in(\varphi-\varphi^{'})} \,d\varphi^{'}. \ \ \ \ \ \ \ (6) \]" src="form_24.png" width="358" height="41"/>
</p>
<p> Equation (5) again provides a condition on the normal derivative of the solution along the artificial boundary and is implemented in the <code>HelmholtzDtNBoundaryElement</code> class. Since <img class="formulaInl" alt="$ \gamma $" src="form_25.png" width="9" height="9"/> depends on the solution everywhere along the artificial boundary (see (6)), the application of the boundary condition (5) introduces a non-local coupling between all the degrees of freedom located on that boundary. This is handled by classifying the unknowns that affect <img class="formulaInl" alt="$ \gamma $" src="form_25.png" width="9" height="9"/> but are not associated with the element's own nodes as external <code>Data</code>.</p>
<p>To facilitate the setup of the interaction between the <code>HelmholtzDtNBoundaryElements</code>, <code>oomph-lib</code> provides the class <code>HelmholtzDtNMesh</code> which provides storage for (the pointers to) the <code>HelmholtzDtNBoundaryElements</code> that discretise the artificial boundary. The member function <code>HelmholtzDtNMesh::setup_gamma()</code> pre-computes the <img class="formulaInl" alt="$ \gamma $" src="form_25.png" width="9" height="9"/> values required for the imposition of equation (5). The radius <img class="formulaInl" alt="$ R $" src="form_16.png" width="10" height="10"/> of the artificial boundary and the (finite) number of (Fourier) terms used in the sum in (6) are specified as arguments to the constructor of the <code>HelmholtzDtNMesh</code>.</p>
<p><b>NOTE:</b> Since <img class="formulaInl" alt="$ \gamma $" src="form_25.png" width="9" height="9"/> depends on the solution, it must be recomputed whenever the unknowns are updated during the Newton iteration. This is best done by adding a call to <code>HelmholtzDtNMesh::setup_gamma()</code> to <code>Problem::actions_before_newton_convergence_check()</code>. [If Helmholtz's equation is solved in isolation (or within a coupled, but linear problem), Newton's method will converge in one iteration. In such cases the unnecessary recomputation of <img class="formulaInl" alt="$ \gamma $" src="form_25.png" width="9" height="9"/> after the one-and-only Newton iteration can be suppressed by setting <code>Problem::Problem_is_nonlinear</code> to <code>false</code>.]</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="scattering"></a>
A specific example: Scattering of an acoustic wave from a sound-hard obstacle</h1>
<p>We will now demonstrate the methodology for a specific example: the scattering of sound waves in an acoustic medium of density <img class="formulaInl" alt="$ \rho $" src="form_26.png" width="8" height="9"/> and bulk modulus <img class="formulaInl" alt="$ B $" src="form_27.png" width="10" height="10"/>. Assuming that an incoming sound wave impacts a rigid, impermeable obstacle as shown in this sketch,</p>
<div class="image">
<img src="scattering.gif" alt=""/>
<div class="caption">
Scattering of an incoming wave from a sound-hard obstacle -- the scatterer. </div></div>
 <p>we wish to find the wave field that is scattered from the body.</p>
<p>For this purpose we denote the time-dependent displacement of the fluid particle in the acoustic medium by <img class="formulaInl" alt="$ {\bf u}^*(x^*,y^*,t^*) $" src="form_28.png" width="69" height="14"/> and introduce a displacement potential <img class="formulaInl" alt="$ \Phi^*(x^*,y^*,t^*) $" src="form_29.png" width="70" height="14"/> such that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf u}^* = \nabla^* \Phi^*. \]" src="form_30.png" width="64" height="11"/>
</p>
<p> (As usual we employ asterisks to distinguish dimensional quantities from their non-dimensional equivalents, to be introduced below.) It is easy to show that <img class="formulaInl" alt="$ \Phi^* $" src="form_31.png" width="14" height="10"/> satisfies the linear wave equation (1) with wave speed <img class="formulaInl" alt="$ c = \sqrt{B/\rho}$" src="form_32.png" width="58" height="16"/>.</p>
<p>Since the surface <img class="formulaInl" alt="$ \partial D_{bound}$" src="form_33.png" width="44" height="13"/> of the scatterer is impenetrable, the normal displacement of the fluid has to vanish on <img class="formulaInl" alt="$ \partial D_{bound}$" src="form_33.png" width="44" height="13"/> and the boundary condition for the displacement potential becomes </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left. \frac{\partial \Phi^*}{\partial n^*}\right|_{\partial D_{bound}} = 0. \ \ \ \ \ \ \ \ \ \ \ \ \ (7) \]" src="form_34.png" width="163" height="34"/>
</p>
<p>We non-dimensionalise all lengths and displacements on some problem-dependent lengthscale <img class="formulaInl" alt="$ {\cal L}$" src="form_35.png" width="10" height="10"/> (e.g. the radius of the scatterer), non-dimensionalise the potential as <img class="formulaInl" alt="$ \Phi^* = a^2 \Phi $" src="form_36.png" width="53" height="11"/> and scale time on the period of the oscillation, <img class="formulaInl" alt="$ t^* = \frac{2\pi}{\omega} t.$" src="form_37.png" width="49" height="16"/> The governing equation then becomes </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \nabla^2 \Phi + k^2 \Phi = 0, \ \ \ \ \ \ \ \ \ \ \ (8) \]" src="form_38.png" width="151" height="16"/>
</p>
<p> where the square of the wavenumber is given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ k^2 = \frac{\rho (a\omega)^2}{B}. \]" src="form_39.png" width="71" height="29"/>
</p>
<p>Assuming that the incoming wave (already satisfying (8)) is described by a (known) non-dimensional displacement potential of the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Phi_{inc}(x,y,t) = \phi_{inc}(x,y) \ e^{-i 2\pi t}, \]" src="form_40.png" width="171" height="16"/>
</p>
<p> we write the total potential as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Phi(x,y,t) = \bigg( \phi_{inc}(x,y) + u(x,y) \bigg) \ e^{-i 2\pi t}, \]" src="form_41.png" width="226" height="31"/>
</p>
<p> where <img class="formulaInl" alt="$ u(x,y) \ e^{-i 2\pi t} $" src="form_42.png" width="74" height="15"/> represents the displacement potential associated with the scattered field which must satisfy (2). The boundary condition (7) then becomes a Neumann (flux) boundary condition for the scattered field, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left. \frac{\partial u}{\partial n}\right|_{\partial D_{bound}} = - \left. \frac{\partial \phi_{inc}}{\partial n}\right|_{\partial D_{bound}}. \ \ \ \ \ \ \ \ \ \ \ \ \ (9) \]" src="form_43.png" width="240" height="34"/>
</p>
<p>For the special case of the incoming wave being a planar wave, propagating along the x-axis, the incoming field can be written in polar coordinates as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \phi_{inc}(r, \varphi) = \sum_{n=-\infty}^{+\infty} i^n J_n(kr) e^{in\varphi}, \]" src="form_44.png" width="174" height="38"/>
</p>
<p> where <img class="formulaInl" alt="$ J_n $" src="form_45.png" width="13" height="13"/> is the Bessel function of the first kind of order <img class="formulaInl" alt="$ n $" src="form_15.png" width="9" height="6"/>. The exact solution for the scattering of such a wave from a circular disk is given by the series </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_{ex}(r,\varphi) = -\sum_{n=-\infty}^{+\infty} i^n \frac {H^{'}_{n}(k)}{J^{'}_{n}(k)} H_n(kr) e^{in\varphi}, \ \ \ \ \ \ \ \ \ \ \ \ \ (10) \]" src="form_46.png" width="300" height="38"/>
</p>
<p> where we have chosen the disk's radius, <img class="formulaInl" alt="$ a $" src="form_47.png" width="6" height="6"/>, as the lengthscale by setting <img class="formulaInl" alt="$ {\cal L} = a$" src="form_48.png" width="33" height="10"/>. In the above expression, <img class="formulaInl" alt="$ H_n $" src="form_49.png" width="16" height="13"/> denotes the Hankel function of the first kind of order <img class="formulaInl" alt="$ n $" src="form_15.png" width="9" height="6"/> and the prime denotes differentiation with respect to the function's argument.</p>
<p>A quantity that is of particular interest in wave propagation problems is the time-average of the power radiated by the scatterer, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \overline{\cal P}^* = \frac{\omega}{2\pi} \int_{0}^{2\pi/\omega} {\cal P}^*(t) \ dt^*. \]" src="form_50.png" width="143" height="34"/>
</p>
<p> In the context of an acoustic wave, the total instantaneous power, <img class="formulaInl" alt="$ {\cal P}^*(t), $" src="form_51.png" width="34" height="14"/> radiated over a closed boundary is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\cal P}^*(t) = \oint \frac{\partial {\bf u^*} }{\partial t^*} \cdot p^* {\bf n} \ dS^*, \]" src="form_52.png" width="143" height="29"/>
</p>
<p> where the pressure is related to the displacement potential via </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ p^* = \rho \omega^2 \Phi^*. \]" src="form_53.png" width="68" height="15"/>
</p>
<p> The non-dimensional time-averaged radiated power can be expressed in terms of the complex potential <img class="formulaInl" alt="$ \phi $" src="form_54.png" width="8" height="13"/> as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \overline{\cal P} = \frac{\overline{\cal P}^*}{\rho \omega^3 {\cal L}^4} = \frac{1}{2} \oint\bigg[Im\bigg(\frac{\partial \phi}{\partial n}\bigg) \ Re(\phi) - Re\bigg(\frac{\partial \phi}{\partial n}\bigg) \ Im(\phi) \bigg] \ dS. \]" src="form_55.png" width="338" height="34"/>
</p>
 <hr  />
 <hr  />
<h1><a class="anchor" id="results"></a>
Results</h1>
<p>The figure below shows an animation of the displacement potential <img class="formulaInl" alt="$ Re(u(x,y,t)) $" src="form_56.png" width="70" height="14"/> for scattering from a circular disk for a non-dimensional wavenumber of <img class="formulaInl" alt="$ k=1 $" src="form_57.png" width="29" height="10"/> over one period of the oscillation. The simulation was performed in an annular computational domain, bounded by the outer surface the (unit) disk and an artificial outer boundary of non-dimensional radius <img class="formulaInl" alt="$ R=1.5. $" src="form_58.png" width="45" height="10"/> The Sommerfeld radiation condition was imposed using the DtN mapping and the simulation was performed with spatial adaptivity (note the non-uniform refinement).</p>
<p>The "carpet plot" compares the exact (green) and computed (red) solutions for the displacement potential. The colours in the contour plot at the bottom of the figure provide an alternative visualisation of the magnitude of the scattered field.</p>
<div class="image">
<img src="scattering_animation.gif" alt=""/>
<div class="caption">
The displacement potential associated with the scattered wave, animated over one period of the oscillation. </div></div>
 <hr  />
 <hr  />
<h1><a class="anchor" id="num_soln"></a>
The numerical solution</h1>
<h2><a class="anchor" id="namespace"></a>
The global namespace</h2>
<p>As usual, we define the problem parameters in a global namespace. The main physical parameter is the (square of the) wave number, <img class="formulaInl" alt="$ k^2 $" src="form_59.png" width="11" height="11"/>. <code>N_fourier</code> is the number of (Fourier) terms to be used in evaluation of the series in equations (6) and (10). The remaining parameters determine how the Sommerfeld radiation condition is applied.</p>
 <div class="fragment"><div class="line"><span class="comment">//===== start_of_namespace=============================================</span></div>
</div><!-- fragment --><p>The function <code>get_exact_u</code> returns the exact solution for the scattering problem. We will use this function for the validation of our results.</p>
 <div class="fragment"><div class="line"> <span class="comment">/// Exact solution for scattered field </span></div>
<div class="line"><span class="comment"> /// (vector returns real and impaginary parts).</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceGlobalParameters.html#ae2320da6053f5527b2af5ebb362a8a07">get_exact_u</a>(<span class="keyword">const</span> Vector&lt;double&gt;&amp; x, Vector&lt;double&gt;&amp; u)</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// Switch to polar coordinates</span></div>
<div class="line">  <span class="keywordtype">double</span> r;</div>
<div class="line">  r=sqrt(x[0]*x[0]+x[1]*x[1]);</div>
<div class="line">  <span class="keywordtype">double</span> theta;</div>
<div class="line">  theta=atan2(x[1],x[0]);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Argument for Bessel/Hankel functions</span></div>
<div class="line">  <span class="keywordtype">double</span> rr=sqrt(<a class="code" href="namespaceGlobalParameters.html#aae73cb63b27d51a87845c3392cd944eb">K_squared</a>)*r;  </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Evaluate Bessel/Hankel functions</span></div>
<div class="line">  complex &lt;double &gt; u_ex(0.0,0.0);</div>
<div class="line">  Vector&lt;double&gt; jn(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>+1), yn(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>+1),</div>
<div class="line">   jnp(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>+1), ynp(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>+1);</div>
<div class="line">  Vector&lt;double&gt; jn_a(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>+1),yn_a(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>+1),</div>
<div class="line">   jnp_a(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>+1), ynp_a(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>+1);</div>
<div class="line">  Vector&lt;complex&lt;double&gt; &gt; h(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>+1),h_a(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>+1),</div>
<div class="line">   hp(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>+1), hp_a(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>+1);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We want to compute N_fourier terms but the function</span></div>
<div class="line">  <span class="comment">// may return fewer than that.</span></div>
<div class="line">  <span class="keywordtype">int</span> n_actual=0;</div>
<div class="line">  CRBond_Bessel::bessjyna(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>,sqrt(<a class="code" href="namespaceGlobalParameters.html#aae73cb63b27d51a87845c3392cd944eb">K_squared</a>),n_actual,</div>
<div class="line">                          &amp;jn_a[0],&amp;yn_a[0],</div>
<div class="line">                          &amp;jnp_a[0],&amp;ynp_a[0]); </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Shout if things went wrong  </span></div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line">  <span class="keywordflow">if</span> (n_actual!=<span class="keywordtype">int</span>(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>))</div>
<div class="line">   {</div>
<div class="line">    std::ostringstream error_stream; </div>
<div class="line">    error_stream &lt;&lt; <span class="stringliteral">&quot;CRBond_Bessel::bessjyna() only computed &quot;</span></div>
<div class="line">                 &lt;&lt; n_actual &lt;&lt; <span class="stringliteral">&quot; rather than &quot;</span> &lt;&lt; <a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a> </div>
<div class="line">                 &lt;&lt; <span class="stringliteral">&quot; Bessel functions.\n&quot;</span>;    </div>
<div class="line">    <span class="keywordflow">throw</span> OomphLibError(error_stream.str(),</div>
<div class="line">                        OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                        OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">   }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Evaluate Hankel at actual radius</span></div>
<div class="line">  Hankel_functions_for_helmholtz_problem::Hankel_first(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>,rr,h,hp);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Evaluate Hankel at inner (unit) radius</span></div>
<div class="line">  Hankel_functions_for_helmholtz_problem::Hankel_first(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a></div>
<div class="line">                                                       ,sqrt(<a class="code" href="namespaceGlobalParameters.html#aae73cb63b27d51a87845c3392cd944eb">K_squared</a>),</div>
<div class="line">                                                       h_a,hp_a);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Compute the sum: Separate the computation of the negative </span></div>
<div class="line">  <span class="comment">// and positive terms</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>;i++)</div>
<div class="line">   {</div>
<div class="line">    u_ex-=pow(<a class="code" href="namespaceGlobalParameters.html#a7642bd7303d39de0d680340586b7df60">I</a>,i)*h[i]*((jnp_a[i])/hp_a[i])*pow(exp(<a class="code" href="namespaceGlobalParameters.html#a7642bd7303d39de0d680340586b7df60">I</a>*theta),i);</div>
<div class="line">   }</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=1;i&lt;<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>;i++)</div>
<div class="line">   {</div>
<div class="line">    u_ex-=pow(<a class="code" href="namespaceGlobalParameters.html#a7642bd7303d39de0d680340586b7df60">I</a>,i)*h[i]*((jnp_a[i])/hp_a[i])*pow(exp(-<a class="code" href="namespaceGlobalParameters.html#a7642bd7303d39de0d680340586b7df60">I</a>*theta),i);</div>
<div class="line">   }</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Get the real &amp; imaginary part of the result</span></div>
<div class="line">  u[0]=real(u_ex);</div>
<div class="line">  u[1]=imag(u_ex);</div>
<div class="line">  </div>
<div class="line"> }<span class="comment">// end of get_exact_u</span></div>
<div class="ttc" id="anamespaceGlobalParameters_html_a7642bd7303d39de0d680340586b7df60"><div class="ttname"><a href="namespaceGlobalParameters.html#a7642bd7303d39de0d680340586b7df60">GlobalParameters::I</a></div><div class="ttdeci">std::complex&lt; double &gt; I(0.0, 1.0)</div><div class="ttdoc">Imaginary unit.</div></div>
<div class="ttc" id="anamespaceGlobalParameters_html_aae73cb63b27d51a87845c3392cd944eb"><div class="ttname"><a href="namespaceGlobalParameters.html#aae73cb63b27d51a87845c3392cd944eb">GlobalParameters::K_squared</a></div><div class="ttdeci">double K_squared</div><div class="ttdoc">Square of the wavenumber.</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00064">scattering.cc:64</a></div></div>
<div class="ttc" id="anamespaceGlobalParameters_html_ae2320da6053f5527b2af5ebb362a8a07"><div class="ttname"><a href="namespaceGlobalParameters.html#ae2320da6053f5527b2af5ebb362a8a07">GlobalParameters::get_exact_u</a></div><div class="ttdeci">void get_exact_u(const Vector&lt; double &gt; &amp;x, Vector&lt; double &gt; &amp;u)</div><div class="ttdoc">Exact solution for scattered field (vector returns real and impaginary parts).</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00086">scattering.cc:86</a></div></div>
<div class="ttc" id="anamespaceGlobalParameters_html_ae4df03bf0ffa55b741ac846ca7b6c155"><div class="ttname"><a href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">GlobalParameters::N_fourier</a></div><div class="ttdeci">unsigned N_fourier</div><div class="ttdoc">Number of terms used in the computation of the exact solution.</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00068">scattering.cc:68</a></div></div>
</div><!-- fragment --><p> Next we provide a function that computes the prescribed flux (normal derivative) of the solution, <img class="formulaInl" alt="$ \partial u/\partial n = -\partial \phi_{inc}/\partial n $" src="form_60.png" width="113" height="14"/>, evaluated on the surface of the unit disk.</p>
 <div class="fragment"><div class="line"> <span class="comment">/// Flux (normal derivative) on the unit disk</span></div>
<div class="line"><span class="comment"> /// for a planar incoming wave</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceGlobalParameters.html#a5183de63b992338ee60bb4da78a45039">prescribed_incoming_flux</a>(<span class="keyword">const</span> Vector&lt;double&gt;&amp; x, </div>
<div class="line">                               complex&lt;double&gt;&amp; flux)</div>
<div class="line"> {</div>
<div class="line">  <span class="comment">// Switch to polar coordinates</span></div>
<div class="line">  <span class="keywordtype">double</span> r;</div>
<div class="line">  r=sqrt(x[0]*x[0]+x[1]*x[1]);</div>
<div class="line">  <span class="keywordtype">double</span> theta;</div>
<div class="line">  theta=atan2(x[1],x[0]);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Argument of the Bessel/Hankel fcts</span></div>
<div class="line">  <span class="keywordtype">double</span> rr=sqrt(<a class="code" href="namespaceGlobalParameters.html#aae73cb63b27d51a87845c3392cd944eb">K_squared</a>)*r;  </div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Compute Bessel/Hankel functions</span></div>
<div class="line">  Vector&lt;double&gt; jn(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>+1), yn(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>+1),</div>
<div class="line">   jnp(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>+1), ynp(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>+1);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We want to compute N_fourier terms but the function</span></div>
<div class="line">  <span class="comment">// may return fewer than that.</span></div>
<div class="line">  <span class="keywordtype">int</span> n_actual=0;</div>
<div class="line">  CRBond_Bessel::bessjyna(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>,rr,n_actual,&amp;jn[0],&amp;yn[0],</div>
<div class="line">                          &amp;jnp[0],&amp;ynp[0]);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Shout if things went wrong...</span></div>
<div class="line"><span class="preprocessor">#ifdef PARANOID</span></div>
<div class="line">  <span class="keywordflow">if</span> (n_actual!=<span class="keywordtype">int</span>(<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>))</div>
<div class="line">   {</div>
<div class="line">    std::ostringstream error_stream; </div>
<div class="line">    error_stream &lt;&lt; <span class="stringliteral">&quot;CRBond_Bessel::bessjyna() only computed &quot;</span></div>
<div class="line">                 &lt;&lt; n_actual &lt;&lt; <span class="stringliteral">&quot; rather than &quot;</span> &lt;&lt; <a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a> </div>
<div class="line">                 &lt;&lt; <span class="stringliteral">&quot; Bessel functions.\n&quot;</span>;    </div>
<div class="line">    <span class="keywordflow">throw</span> OomphLibError(error_stream.str(),</div>
<div class="line">                        OOMPH_CURRENT_FUNCTION,</div>
<div class="line">                        OOMPH_EXCEPTION_LOCATION);</div>
<div class="line">   }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Compute the sum: Separate the computation of the negative and </span></div>
<div class="line">  <span class="comment">// positive terms</span></div>
<div class="line">  flux=std::complex&lt;double&gt;(0.0,0.0);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>;i++)</div>
<div class="line">   {</div>
<div class="line">    flux+=pow(<a class="code" href="namespaceGlobalParameters.html#a7642bd7303d39de0d680340586b7df60">I</a>,i)*(sqrt(<a class="code" href="namespaceGlobalParameters.html#aae73cb63b27d51a87845c3392cd944eb">K_squared</a>))*pow(exp(<a class="code" href="namespaceGlobalParameters.html#a7642bd7303d39de0d680340586b7df60">I</a>*theta),i)*jnp[i];</div>
<div class="line">   }</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=1;i&lt;<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">N_fourier</a>;i++)</div>
<div class="line">   {</div>
<div class="line">    flux+=pow(<a class="code" href="namespaceGlobalParameters.html#a7642bd7303d39de0d680340586b7df60">I</a>,i)*(sqrt(<a class="code" href="namespaceGlobalParameters.html#aae73cb63b27d51a87845c3392cd944eb">K_squared</a>))*pow(exp(-<a class="code" href="namespaceGlobalParameters.html#a7642bd7303d39de0d680340586b7df60">I</a>*theta),i)*jnp[i];</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> }<span class="comment">// end of prescribed_incoming_flux </span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of namespace</span></div>
<div class="ttc" id="anamespaceGlobalParameters_html_a5183de63b992338ee60bb4da78a45039"><div class="ttname"><a href="namespaceGlobalParameters.html#a5183de63b992338ee60bb4da78a45039">GlobalParameters::prescribed_incoming_flux</a></div><div class="ttdeci">void prescribed_incoming_flux(const Vector&lt; double &gt; &amp;x, complex&lt; double &gt; &amp;flux)</div><div class="ttdoc">Flux (normal derivative) on the unit disk for a planar incoming wave.</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00156">scattering.cc:156</a></div></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h2><a class="anchor" id="main"></a>
The driver code</h2>
<p>The driver code is very straightforward. We parse the command line to determine which boundary condition to use and set the flags in the global namespace accordingly.</p>
 <div class="fragment"><div class="line"><span class="comment">//==========start_of_main=================================================</span></div>
<div class="line"><span class="comment">/// Solve 2D Helmholtz problem for scattering of a planar wave from a </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// unit disk </span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="scattering_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Store command line arguments</span></div>
<div class="line"> CommandLineArgs::setup(argc,argv);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Define case to be run</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> i_case=0;</div>
<div class="line"> CommandLineArgs::specify_command_line_flag(<span class="stringliteral">&quot;--case&quot;</span>,&amp;i_case);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Parse command line</span></div>
<div class="line"> CommandLineArgs::parse_and_assign(); </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Doc what has actually been specified on the command line</span></div>
<div class="line"> CommandLineArgs::doc_specified_flags();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Now set flags accordingly</span></div>
<div class="line"> <span class="keywordflow">switch</span>(i_case)</div>
<div class="line">  {</div>
<div class="line">  <span class="keywordflow">case</span> 0:</div>
<div class="line">   <a class="code" href="namespaceGlobalParameters.html#a6e2bba1769e86a5d3db88e2c7062bc63">GlobalParameters::DtN_BC</a>=<span class="keyword">true</span>;</div>
<div class="line">   <span class="keywordflow">break</span>;</div>
<div class="line">   </div>
<div class="line">  <span class="keywordflow">case</span> 1:</div>
<div class="line">   <a class="code" href="namespaceGlobalParameters.html#a6e2bba1769e86a5d3db88e2c7062bc63">GlobalParameters::DtN_BC</a>=<span class="keyword">false</span>;</div>
<div class="line">   <a class="code" href="namespaceGlobalParameters.html#a552eed3548a269715a95161ad3c4b96a">GlobalParameters::ABC_order</a>=1;</div>
<div class="line">   <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">case</span> 2:</div>
<div class="line">   <a class="code" href="namespaceGlobalParameters.html#a6e2bba1769e86a5d3db88e2c7062bc63">GlobalParameters::DtN_BC</a>=<span class="keyword">false</span>;</div>
<div class="line">   <a class="code" href="namespaceGlobalParameters.html#a552eed3548a269715a95161ad3c4b96a">GlobalParameters::ABC_order</a>=2;</div>
<div class="line">   <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">case</span> 3:</div>
<div class="line">   <a class="code" href="namespaceGlobalParameters.html#a6e2bba1769e86a5d3db88e2c7062bc63">GlobalParameters::DtN_BC</a>=<span class="keyword">false</span>;</div>
<div class="line">   <a class="code" href="namespaceGlobalParameters.html#a552eed3548a269715a95161ad3c4b96a">GlobalParameters::ABC_order</a>=3;</div>
<div class="line">   <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="ttc" id="anamespaceGlobalParameters_html_a552eed3548a269715a95161ad3c4b96a"><div class="ttname"><a href="namespaceGlobalParameters.html#a552eed3548a269715a95161ad3c4b96a">GlobalParameters::ABC_order</a></div><div class="ttdeci">unsigned ABC_order</div><div class="ttdoc">Flag to choose wich order to use.</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00076">scattering.cc:76</a></div></div>
<div class="ttc" id="anamespaceGlobalParameters_html_a6e2bba1769e86a5d3db88e2c7062bc63"><div class="ttname"><a href="namespaceGlobalParameters.html#a6e2bba1769e86a5d3db88e2c7062bc63">GlobalParameters::DtN_BC</a></div><div class="ttdeci">bool DtN_BC</div><div class="ttdoc">Flag to choose the Dirichlet to Neumann BC or ABC BC.</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00072">scattering.cc:72</a></div></div>
<div class="ttc" id="ascattering_8cc_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="scattering_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdoc">Solve 2D Helmholtz problem for scattering of a planar wave from a unit disk.</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00709">scattering.cc:709</a></div></div>
</div><!-- fragment --><p> Next we build the problem, either with or without enabling spatial adaptivity and define the output directory.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Set up the problem</span></div>
<div class="line"> <span class="comment">//------------------</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef ADAPTIVE</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Set up the problem with 2D nine-node elements from the</span></div>
<div class="line"> <span class="comment">//QHelmholtzElement family.</span></div>
<div class="line"> <a class="code" href="classScatteringProblem.html">ScatteringProblem&lt;RefineableQHelmholtzElement&lt;2,3&gt;</a> &gt; </div>
<div class="line">  problem;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Set up the problem with 2D nine-node elements from the</span></div>
<div class="line"> <span class="comment">//QHelmholtzElement family. </span></div>
<div class="line"> <a class="code" href="classScatteringProblem.html">ScatteringProblem&lt;QHelmholtzElement&lt;2,3&gt;</a> &gt; </div>
<div class="line">  problem;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create label for output</span></div>
<div class="line"> <span class="comment">//------------------------</span></div>
<div class="line"> DocInfo doc_info;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set output directory</span></div>
<div class="line"> doc_info.set_directory(<span class="stringliteral">&quot;RESLT&quot;</span>);</div>
<div class="ttc" id="aclassScatteringProblem_html"><div class="ttname"><a href="classScatteringProblem.html">ScatteringProblem</a></div><div class="ttdoc">////////////////////////////////////////////////////////////////// //////////////////////////////////...</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00222">scattering.cc:223</a></div></div>
</div><!-- fragment --><p> Finally, we solve the problem and document the results.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef ADAPTIVE</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Max. number of adaptations</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> max_adapt=1;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Solve the problem with Newton&#39;s method, allowing</span></div>
<div class="line">   <span class="comment">// up to max_adapt mesh adaptations after every solve.</span></div>
<div class="line">   problem.newton_solve(max_adapt);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Solve the problem with Newton&#39;s method</span></div>
<div class="line">   problem.newton_solve();</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">//Output solution</span></div>
<div class="line"> problem.<a class="code" href="classScatteringProblem.html#af83ab14c4f4750ea17c21466f6c6364f">doc_solution</a>(doc_info);</div>
<div class="line">    </div>
<div class="line">} <span class="comment">//end of main</span></div>
<div class="ttc" id="aclassScatteringProblem_html_af83ab14c4f4750ea17c21466f6c6364f"><div class="ttname"><a href="classScatteringProblem.html#af83ab14c4f4750ea17c21466f6c6364f">ScatteringProblem::doc_solution</a></div><div class="ttdeci">void doc_solution(DocInfo &amp;doc_info)</div><div class="ttdoc">Doc the solution. DocInfo object stores flags/labels for where the output gets written to.</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00516">scattering.cc:516</a></div></div>
</div><!-- fragment --><hr  />
 <hr  />
<h2><a class="anchor" id="class"></a>
The problem class</h2>
<p>The problem class is very similar to that employed for the <a href="../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html">adaptive solution of the 2D Poisson equation with flux boundary conditions.</a> The only difference is that we provide two separate meshes of <code>FaceElements:</code> one for the inner boundary where the <code>HelmholtzFluxElements</code> apply the Neumann condition (9), and one for the outer boundary where we apply the (approximate) Sommerfeld radiation condition. As discussed in section <a class="el" href="index.html#DtN">The Dirichlet-to-Neumann mapping (DtN)</a> , we use the function <code>actions_before_newton_convergence_check()</code> to recompute the <img class="formulaInl" alt="$ \gamma $" src="form_25.png" width="9" height="9"/> integral whenever the unknowns are updated during the Newton iteration.</p>
 <div class="fragment"><div class="line"><span class="comment">//========= start_of_problem_class=====================================</span></div>
<div class="line"><span class="comment">/// Problem class to compute scattering of planar wave from unit disk</span></div>
<div class="line"><span class="comment"></span><span class="comment">//=====================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt; </div>
<div class="line"><span class="keyword">class </span><a class="code" href="classScatteringProblem.html">ScatteringProblem</a> : <span class="keyword">public</span> Problem</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Constructor</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classScatteringProblem.html#a94710f5d2ee52abc3df9dc8d1fd3eb71">ScatteringProblem</a>();</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Destructor (empty)</span></div>
<div class="line"><span class="comment"></span> <a class="code" href="classScatteringProblem.html#a0a9838027d0286f22706fe6945bbac0a">~ScatteringProblem</a>(){}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Doc the solution. DocInfo object stores flags/labels for where the</span></div>
<div class="line"><span class="comment"> /// output gets written to</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classScatteringProblem.html#af83ab14c4f4750ea17c21466f6c6364f">doc_solution</a>(DocInfo&amp; doc_info);</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Update the problem specs before solve (empty)</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classScatteringProblem.html#a91ce14b928ec6edbb9d85515a310b1fb">actions_before_newton_solve</a>(){} </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Update the problem specs after solve (empty)</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classScatteringProblem.html#abf1e7b97518c94e12802205dec08b15e">actions_after_newton_solve</a>(){}</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Recompute gamma integral before checking Newton residuals</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classScatteringProblem.html#ad096c311ee474d23514656d2ba76a4b8">actions_before_newton_convergence_check</a>()</div>
<div class="line">  {</div>
<div class="line">   <span class="keywordflow">if</span> (<a class="code" href="namespaceGlobalParameters.html#a6e2bba1769e86a5d3db88e2c7062bc63">GlobalParameters::DtN_BC</a>)</div>
<div class="line">    {</div>
<div class="line">     <a class="code" href="classScatteringProblem.html#a9692c8592b57a4363e557e5b012c744b">Helmholtz_outer_boundary_mesh_pt</a>-&gt;setup_gamma();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Actions before adapt: Wipe the mesh of prescribed flux elements</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classScatteringProblem.html#aca1b756a307f9c1d8a70c7b7e68a296b">actions_before_adapt</a>();</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Actions after adapt: Rebuild the mesh of prescribed flux elements</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classScatteringProblem.html#a13d8f85e74666c260de7364917359ed5">actions_after_adapt</a>();</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Create BC elements on boundary b of the Mesh pointed</span></div>
<div class="line"><span class="comment"> /// to by bulk_mesh_pt and add them to the specified survace Mesh </span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classScatteringProblem.html#a408e05fbe1f1456ab7013a7e8ab29ccc">create_outer_bc_elements</a>(</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;b, Mesh* <span class="keyword">const</span> &amp;bulk_mesh_pt,</div>
<div class="line">  Mesh* <span class="keyword">const</span> &amp; helmholtz_outer_boundary_mesh_pt);</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Create Helmholtz flux elements on boundary b of the Mesh pointed</span></div>
<div class="line"><span class="comment"> /// to by bulk_mesh_pt and add them to the specified surface Mesh </span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classScatteringProblem.html#af06ff518ad3250f914c0c659af3001c8">create_flux_elements</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;b, Mesh* <span class="keyword">const</span> &amp;bulk_mesh_pt,</div>
<div class="line">                           Mesh* <span class="keyword">const</span> &amp; helmholtz_inner_boundary_mesh_pt);</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Delete boundary face elements and wipe the surface mesh</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classScatteringProblem.html#aaef8a78e317333ddadd0be6a500c1134">delete_face_elements</a>( Mesh* <span class="keyword">const</span> &amp; boundary_mesh_pt);</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Set pointer to prescribed-flux function for all</span></div>
<div class="line"><span class="comment"> /// elements in the surface mesh on the surface of the unit disk</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classScatteringProblem.html#ae75307dde909513a0f11057c96cdd622">set_prescribed_incoming_flux_pt</a>();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Set up boundary condition elements on outer boundary</span></div>
<div class="line"><span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="classScatteringProblem.html#a76bd8299ea7ed559681b294acfb2aad4">setup_outer_boundary</a>();</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef ADAPTIVE</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/// Pointer to the &quot;bulk&quot; mesh</span></div>
<div class="line"><span class="comment"></span> RefineableTwoDAnnularMesh&lt;ELEMENT&gt;* <a class="code" href="classScatteringProblem.html#a8c61657a1d09ce49a5871ca3febe5658">Bulk_mesh_pt</a>;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to the &quot;bulk&quot; mesh</span></div>
<div class="line"><span class="comment"></span> TwoDAnnularMesh&lt;ELEMENT&gt;* <a class="code" href="classScatteringProblem.html#a8c61657a1d09ce49a5871ca3febe5658">Bulk_mesh_pt</a>;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> /// Pointer to mesh containing the DtN (or ABC) boundary</span></div>
<div class="line"><span class="comment"> /// condition elements</span></div>
<div class="line"><span class="comment"></span> HelmholtzDtNMesh&lt;ELEMENT&gt;* <a class="code" href="classScatteringProblem.html#a9692c8592b57a4363e557e5b012c744b">Helmholtz_outer_boundary_mesh_pt</a>;</div>
<div class="line"> <span class="comment"></span></div>
<div class="line"><span class="comment"> /// Pointer to the mesh containing </span></div>
<div class="line"><span class="comment"> /// the Helmholtz inner boundary condition elements </span></div>
<div class="line"><span class="comment"></span> Mesh* <a class="code" href="classScatteringProblem.html#a56b5fc73bbb51b701a43dc38f9815104">Helmholtz_inner_boundary_mesh_pt</a>;</div>
<div class="line"> </div>
<div class="line">}; <span class="comment">// end of problem class</span></div>
<div class="ttc" id="aclassScatteringProblem_html_a0a9838027d0286f22706fe6945bbac0a"><div class="ttname"><a href="classScatteringProblem.html#a0a9838027d0286f22706fe6945bbac0a">ScatteringProblem::~ScatteringProblem</a></div><div class="ttdeci">~ScatteringProblem()</div><div class="ttdoc">Destructor (empty)</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00231">scattering.cc:231</a></div></div>
<div class="ttc" id="aclassScatteringProblem_html_a13d8f85e74666c260de7364917359ed5"><div class="ttname"><a href="classScatteringProblem.html#a13d8f85e74666c260de7364917359ed5">ScatteringProblem::actions_after_adapt</a></div><div class="ttdeci">void actions_after_adapt()</div><div class="ttdoc">Actions after adapt: Rebuild the mesh of prescribed flux elements.</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00429">scattering.cc:429</a></div></div>
<div class="ttc" id="aclassScatteringProblem_html_a408e05fbe1f1456ab7013a7e8ab29ccc"><div class="ttname"><a href="classScatteringProblem.html#a408e05fbe1f1456ab7013a7e8ab29ccc">ScatteringProblem::create_outer_bc_elements</a></div><div class="ttdeci">void create_outer_bc_elements(const unsigned &amp;b, Mesh *const &amp;bulk_mesh_pt, Mesh *const &amp;helmholtz_outer_boundary_mesh_pt)</div><div class="ttdoc">Create BC elements on boundary b of the Mesh pointed to by bulk_mesh_pt and add them to the specified...</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00644">scattering.cc:645</a></div></div>
<div class="ttc" id="aclassScatteringProblem_html_a56b5fc73bbb51b701a43dc38f9815104"><div class="ttname"><a href="classScatteringProblem.html#a56b5fc73bbb51b701a43dc38f9815104">ScatteringProblem::Helmholtz_inner_boundary_mesh_pt</a></div><div class="ttdeci">Mesh * Helmholtz_inner_boundary_mesh_pt</div><div class="ttdoc">Pointer to the mesh containing the Helmholtz inner boundary condition elements.</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00297">scattering.cc:297</a></div></div>
<div class="ttc" id="aclassScatteringProblem_html_a76bd8299ea7ed559681b294acfb2aad4"><div class="ttname"><a href="classScatteringProblem.html#a76bd8299ea7ed559681b294acfb2aad4">ScatteringProblem::setup_outer_boundary</a></div><div class="ttdeci">void setup_outer_boundary()</div><div class="ttdoc">Set up boundary condition elements on outer boundary.</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00451">scattering.cc:451</a></div></div>
<div class="ttc" id="aclassScatteringProblem_html_a8c61657a1d09ce49a5871ca3febe5658"><div class="ttname"><a href="classScatteringProblem.html#a8c61657a1d09ce49a5871ca3febe5658">ScatteringProblem::Bulk_mesh_pt</a></div><div class="ttdeci">RefineableTwoDAnnularMesh&lt; ELEMENT &gt; * Bulk_mesh_pt</div><div class="ttdoc">Pointer to the &quot;bulk&quot; mesh.</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00282">scattering.cc:282</a></div></div>
<div class="ttc" id="aclassScatteringProblem_html_a91ce14b928ec6edbb9d85515a310b1fb"><div class="ttname"><a href="classScatteringProblem.html#a91ce14b928ec6edbb9d85515a310b1fb">ScatteringProblem::actions_before_newton_solve</a></div><div class="ttdeci">void actions_before_newton_solve()</div><div class="ttdoc">Update the problem specs before solve (empty)</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00238">scattering.cc:238</a></div></div>
<div class="ttc" id="aclassScatteringProblem_html_a94710f5d2ee52abc3df9dc8d1fd3eb71"><div class="ttname"><a href="classScatteringProblem.html#a94710f5d2ee52abc3df9dc8d1fd3eb71">ScatteringProblem::ScatteringProblem</a></div><div class="ttdeci">ScatteringProblem()</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00307">scattering.cc:308</a></div></div>
<div class="ttc" id="aclassScatteringProblem_html_a9692c8592b57a4363e557e5b012c744b"><div class="ttname"><a href="classScatteringProblem.html#a9692c8592b57a4363e557e5b012c744b">ScatteringProblem::Helmholtz_outer_boundary_mesh_pt</a></div><div class="ttdeci">HelmholtzDtNMesh&lt; ELEMENT &gt; * Helmholtz_outer_boundary_mesh_pt</div><div class="ttdoc">Pointer to mesh containing the DtN (or ABC) boundary condition elements.</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00293">scattering.cc:293</a></div></div>
<div class="ttc" id="aclassScatteringProblem_html_aaef8a78e317333ddadd0be6a500c1134"><div class="ttname"><a href="classScatteringProblem.html#aaef8a78e317333ddadd0be6a500c1134">ScatteringProblem::delete_face_elements</a></div><div class="ttdeci">void delete_face_elements(Mesh *const &amp;boundary_mesh_pt)</div><div class="ttdoc">Delete boundary face elements and wipe the surface mesh.</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00687">scattering.cc:688</a></div></div>
<div class="ttc" id="aclassScatteringProblem_html_abf1e7b97518c94e12802205dec08b15e"><div class="ttname"><a href="classScatteringProblem.html#abf1e7b97518c94e12802205dec08b15e">ScatteringProblem::actions_after_newton_solve</a></div><div class="ttdeci">void actions_after_newton_solve()</div><div class="ttdoc">Update the problem specs after solve (empty)</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00241">scattering.cc:241</a></div></div>
<div class="ttc" id="aclassScatteringProblem_html_aca1b756a307f9c1d8a70c7b7e68a296b"><div class="ttname"><a href="classScatteringProblem.html#aca1b756a307f9c1d8a70c7b7e68a296b">ScatteringProblem::actions_before_adapt</a></div><div class="ttdeci">void actions_before_adapt()</div><div class="ttdoc">Actions before adapt: Wipe the mesh of prescribed flux elements.</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00413">scattering.cc:413</a></div></div>
<div class="ttc" id="aclassScatteringProblem_html_ad096c311ee474d23514656d2ba76a4b8"><div class="ttname"><a href="classScatteringProblem.html#ad096c311ee474d23514656d2ba76a4b8">ScatteringProblem::actions_before_newton_convergence_check</a></div><div class="ttdeci">void actions_before_newton_convergence_check()</div><div class="ttdoc">Recompute gamma integral before checking Newton residuals.</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00244">scattering.cc:244</a></div></div>
<div class="ttc" id="aclassScatteringProblem_html_ae75307dde909513a0f11057c96cdd622"><div class="ttname"><a href="classScatteringProblem.html#ae75307dde909513a0f11057c96cdd622">ScatteringProblem::set_prescribed_incoming_flux_pt</a></div><div class="ttdeci">void set_prescribed_incoming_flux_pt()</div><div class="ttdoc">Set pointer to prescribed-flux function for all elements in the surface mesh on the surface of the un...</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00493">scattering.cc:493</a></div></div>
<div class="ttc" id="aclassScatteringProblem_html_af06ff518ad3250f914c0c659af3001c8"><div class="ttname"><a href="classScatteringProblem.html#af06ff518ad3250f914c0c659af3001c8">ScatteringProblem::create_flux_elements</a></div><div class="ttdeci">void create_flux_elements(const unsigned &amp;b, Mesh *const &amp;bulk_mesh_pt, Mesh *const &amp;helmholtz_inner_boundary_mesh_pt)</div><div class="ttdoc">Create Helmholtz flux elements on boundary b of the Mesh pointed to by bulk_mesh_pt and add them to t...</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00610">scattering.cc:611</a></div></div>
</div><!-- fragment --><hr  />
 <hr  />
<h2><a class="anchor" id="constr"></a>
The problem constructor</h2>
<p>We start by building the bulk mesh, using the refineable or non-refineable version of the <code>TwoDAnnularMesh</code>, depending on the macro <code>ADAPTIVE</code>. (The error tolerances for the adaptive version are chosen such that the mesh is refined non-uniformly &ndash; with the default tolerances, <code>oomph-lib's</code> automatic mesh adaptation procedure refine the mesh uniformly.)</p>
 <div class="fragment"><div class="line"><span class="comment">//=======start_of_constructor=============================================</span></div>
<div class="line"><span class="comment">/// Constructor for Helmholtz problem</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><a class="code" href="classScatteringProblem.html#a94710f5d2ee52abc3df9dc8d1fd3eb71">ScatteringProblem&lt;ELEMENT&gt;::</a></div>
<div class="line"><a class="code" href="classScatteringProblem.html#a94710f5d2ee52abc3df9dc8d1fd3eb71">ScatteringProblem</a>()</div>
<div class="line">{ </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Setup &quot;bulk&quot; mesh</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// # of elements in theta</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_theta=15;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// # of elements in radius</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_r=5;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Inner radius</span></div>
<div class="line"> <span class="keywordtype">double</span> a=1.0;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Thickness of annular computational domain</span></div>
<div class="line"> <span class="keywordtype">double</span> h=0.5; </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set outer radius</span></div>
<div class="line"> <a class="code" href="namespaceGlobalParameters.html#a61b086072a6b8fd38af1a85f1dd1674a">GlobalParameters::Outer_radius</a>=a+h;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Mesh is periodic</span></div>
<div class="line"> <span class="keywordtype">bool</span> periodic=<span class="keyword">true</span>; </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Full circle</span></div>
<div class="line"> <span class="keywordtype">double</span> azimuthal_fraction=1.0;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef ADAPTIVE</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build &quot;bulk&quot; mesh</span></div>
<div class="line"> Bulk_mesh_pt=</div>
<div class="line">  <span class="keyword">new</span> RefineableTwoDAnnularMesh&lt;ELEMENT&gt;(periodic,</div>
<div class="line">                                         azimuthal_fraction,n_theta,n_r,a,h);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create/set error estimator</span></div>
<div class="line"> Bulk_mesh_pt-&gt;spatial_error_estimator_pt()=<span class="keyword">new</span> Z2ErrorEstimator;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Choose error tolerances to force some uniform refinement</span></div>
<div class="line"> Bulk_mesh_pt-&gt;min_permitted_error()=0.004;</div>
<div class="line"> Bulk_mesh_pt-&gt;max_permitted_error()=0.01;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Build &quot;bulk&quot; mesh</span></div>
<div class="line"> Bulk_mesh_pt=</div>
<div class="line">  <span class="keyword">new</span> TwoDAnnularMesh&lt;ELEMENT&gt;(periodic,</div>
<div class="line">                               azimuthal_fraction,n_theta,n_r,a,h);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="ttc" id="anamespaceGlobalParameters_html_a61b086072a6b8fd38af1a85f1dd1674a"><div class="ttname"><a href="namespaceGlobalParameters.html#a61b086072a6b8fd38af1a85f1dd1674a">GlobalParameters::Outer_radius</a></div><div class="ttdeci">double Outer_radius</div><div class="ttdoc">Radius of outer boundary (must be a circle!)</div><div class="ttdef"><b>Definition:</b> <a href="scattering_8cc_source.html#l00079">scattering.cc:79</a></div></div>
</div><!-- fragment --><p> Next we create the two (empty) meshes for the <code>FaceElements</code>,</p>
 <div class="fragment"><div class="line"> <span class="comment">// Pointer to mesh containing the Helmholtz outer boundary condition</span></div>
<div class="line"> <span class="comment">// elements. Specify outer radius and number of Fourier terms to be</span></div>
<div class="line"> <span class="comment">// used in gamma integral</span></div>
<div class="line"> Helmholtz_outer_boundary_mesh_pt = </div>
<div class="line">  <span class="keyword">new</span> HelmholtzDtNMesh&lt;ELEMENT&gt;(a+h,<a class="code" href="namespaceGlobalParameters.html#ae4df03bf0ffa55b741ac846ca7b6c155">GlobalParameters::N_fourier</a>);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Pointer to mesh containing the Helmholtz inner boundary condition</span></div>
<div class="line"> <span class="comment">// elements. Specify outer radius</span></div>
<div class="line"> Helmholtz_inner_boundary_mesh_pt = <span class="keyword">new</span> Mesh;</div>
</div><!-- fragment --><p> and populate them using the functions <code>create_flux_elements(...)</code> and <code>create_outer_bc_elements(...)</code>.</p>
 <div class="fragment"><div class="line"> <span class="comment">// Create prescribed-flux elements from all elements that are </span></div>
<div class="line"> <span class="comment">// adjacent to the inner boundary , but add them to a separate mesh.</span></div>
<div class="line"> create_flux_elements(0,Bulk_mesh_pt,Helmholtz_inner_boundary_mesh_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Create outer boundary elements from all elements that are </span></div>
<div class="line"> <span class="comment">// adjacent to the outer boundary , but add them to a separate mesh.</span></div>
<div class="line"> create_outer_bc_elements(2,Bulk_mesh_pt,Helmholtz_outer_boundary_mesh_pt);</div>
</div><!-- fragment --><p> We add the various (sub-)meshes to the problem and build the global mesh</p>
 <div class="fragment"><div class="line"> <span class="comment">// Add the several  sub meshes to the problem</span></div>
<div class="line"> add_sub_mesh(Bulk_mesh_pt);</div>
<div class="line"> add_sub_mesh(Helmholtz_outer_boundary_mesh_pt); </div>
<div class="line"> add_sub_mesh(Helmholtz_inner_boundary_mesh_pt);   </div>
<div class="line">  </div>
<div class="line"> <span class="comment">// Build the Problem&#39;s global mesh from its various sub-meshes</span></div>
<div class="line"> build_global_mesh();</div>
</div><!-- fragment --><p> Finally, we complete the build of the various elements by by passing pointers to the relevant quantities to them, and assign the equation numbers.  </p><div class="fragment"><div class="line"> <span class="comment">// Complete the build of all elements so they are fully functional</span></div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop over the Helmholtz bulk elements to set up element-specific </span></div>
<div class="line"> <span class="comment">// things that cannot be handled by constructor: Pass pointer to </span></div>
<div class="line"> <span class="comment">// wave number squared</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_element = Bulk_mesh_pt-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Upcast from GeneralisedElement to Helmholtz bulk element</span></div>
<div class="line">   ELEMENT *el_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(Bulk_mesh_pt-&gt;element_pt(e));</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Set the k_squared  pointer</span></div>
<div class="line">   el_pt-&gt;k_squared_pt() = &amp;<a class="code" href="namespaceGlobalParameters.html#aae73cb63b27d51a87845c3392cd944eb">GlobalParameters::K_squared</a>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set up elements on outer boundary</span></div>
<div class="line"> setup_outer_boundary();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set pointer to prescribed flux function for flux elements</span></div>
<div class="line"> set_prescribed_incoming_flux_pt();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Setup equation numbering scheme</span></div>
<div class="line"> cout &lt;&lt;<span class="stringliteral">&quot;Number of equations: &quot;</span> &lt;&lt; assign_eqn_numbers() &lt;&lt; std::endl; </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of constructor</span></div>
</div><!-- fragment --><p> The problem is now ready to be solved.</p>
<hr  />
 <hr  />
<h2><a class="anchor" id="before_adapt"></a>
Actions before adapt</h2>
<p>The mesh adaptation is driven by the error estimates for the bulk elements. The various <code>FaceElements</code> must therefore be removed from the global mesh before the adaptation takes place. We do this by calling the function <code>delete_flux_elements(...)</code> for the two face meshes, before rebuilding the Problem's global mesh.</p>
 <div class="fragment"><div class="line"><span class="comment">//=====================start_of_actions_before_adapt======================</span></div>
<div class="line"><span class="comment">/// Actions before adapt: Wipe the mesh of face elements</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classScatteringProblem.html#aca1b756a307f9c1d8a70c7b7e68a296b">ScatteringProblem&lt;ELEMENT&gt;::actions_before_adapt</a>()</div>
<div class="line">{ </div>
<div class="line"> <span class="comment">// Kill the flux elements and wipe the boundary meshs</span></div>
<div class="line"> delete_face_elements(Helmholtz_outer_boundary_mesh_pt);</div>
<div class="line"> delete_face_elements(Helmholtz_inner_boundary_mesh_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Rebuild the Problem&#39;s global mesh from its various sub-meshes</span></div>
<div class="line"> rebuild_global_mesh();</div>
<div class="line"> </div>
<div class="line">}<span class="comment">// end of actions_before_adapt</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h2><a class="anchor" id="after_adapt"></a>
Actions after adapt</h2>
<p>After the (bulk-)mesh has been adapted, the flux elements must be re-attached. This is done by calling the functions <code>create_flux_elements(...)</code> and <code>create_outer_bc_elements</code>, followed by rebuilding the Problem's global mesh. Finally, we complete the build of the <code>FaceElements</code> by calling the functions <code>setup_outer_boundary()</code> and <code>set_prescribed_incoming_flux_pt()</code>.</p>
 <div class="fragment"><div class="line"><span class="comment">//=====================start_of_actions_after_adapt=======================</span></div>
<div class="line"><span class="comment">///  Actions after adapt: Rebuild the face element meshes</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classScatteringProblem.html#a13d8f85e74666c260de7364917359ed5">ScatteringProblem&lt;ELEMENT&gt;::actions_after_adapt</a>()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Create prescribed-flux elements and BC elements </span></div>
<div class="line"> <span class="comment">// from all elements that are adjacent to the boundaries and add them to </span></div>
<div class="line"> <span class="comment">// Helmholtz_boundary_meshes</span></div>
<div class="line"> create_outer_bc_elements(2,Bulk_mesh_pt,Helmholtz_outer_boundary_mesh_pt);</div>
<div class="line"> create_flux_elements(0,Bulk_mesh_pt,Helmholtz_inner_boundary_mesh_pt);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Rebuild the Problem&#39;s global mesh from its various sub-meshes</span></div>
<div class="line"> rebuild_global_mesh();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Set pointer to prescribed flux function and DtN mesh</span></div>
<div class="line"> setup_outer_boundary();</div>
<div class="line"> set_prescribed_incoming_flux_pt(); </div>
<div class="line">  </div>
<div class="line">}<span class="comment">// end of actions_after_adapt</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h2><a class="anchor" id="delete"></a>
Delete flux elements</h2>
<p>The helper function <code>delete_face_elements()</code> is used to delete all <code>FaceElements</code> in a given surface mesh before the mesh adaptation.</p>
 <div class="fragment"><div class="line"><span class="comment">//============start_of_delete_face_elements================</span></div>
<div class="line"><span class="comment">/// Delete face elements and wipe the boundary mesh</span></div>
<div class="line"><span class="comment"></span><span class="comment">//==========================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classScatteringProblem.html#aaef8a78e317333ddadd0be6a500c1134">ScatteringProblem&lt;ELEMENT&gt;::</a></div>
<div class="line"><a class="code" href="classScatteringProblem.html#aaef8a78e317333ddadd0be6a500c1134">delete_face_elements</a>(Mesh* <span class="keyword">const</span> &amp; boundary_mesh_pt)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Loop over the surface elements</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_element = boundary_mesh_pt-&gt;nelement();</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Kill surface element</span></div>
<div class="line">   <span class="keyword">delete</span>  boundary_mesh_pt-&gt;element_pt(e);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Wipe the mesh</span></div>
<div class="line"> boundary_mesh_pt-&gt;flush_element_and_node_storage();</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of delete_outer_face_elements</span></div>
</div><!-- fragment --> <hr  />
 <hr  />
<h2><a class="anchor" id="create_flux"></a>
Creating the face elements</h2>
<p>The functions <code>create_flux_elements(...)</code> and <code>create_outer_bc_elements(...)</code> create the <code>FaceElements</code> required to apply the boundary conditions on the inner and outer boundaries of the annular computational domain. They both loop over the bulk elements that are adjacent to the appropriate mesh boundary and attach the required <code>FaceElements</code> to their faces. The newly created <code>FaceElements</code> are then added to the appropriate mesh.</p>
 <div class="fragment"><div class="line"><span class="comment">//============start_of_create_outer_bc_elements==============================</span></div>
<div class="line"><span class="comment">/// Create outer BC elements on the b-th boundary of </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// the Mesh object pointed to by bulk_mesh_pt and add the elements </span></div>
<div class="line"><span class="comment"></span><span class="comment">/// to the Mesh object pointed to by helmholtz_outer_boundary_mesh_pt.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//===========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classScatteringProblem.html#a408e05fbe1f1456ab7013a7e8ab29ccc">ScatteringProblem&lt;ELEMENT&gt;::</a></div>
<div class="line"><a class="code" href="classScatteringProblem.html#a408e05fbe1f1456ab7013a7e8ab29ccc">create_outer_bc_elements</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> &amp;b, Mesh* <span class="keyword">const</span> &amp;bulk_mesh_pt,</div>
<div class="line">                         Mesh* <span class="keyword">const</span> &amp; helmholtz_outer_boundary_mesh_pt)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Loop over the bulk elements adjacent to boundary b?</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> n_element = bulk_mesh_pt-&gt;nboundary_element(b);</div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;n_element;e++)</div>
<div class="line">  {</div>
<div class="line">   <span class="comment">// Get pointer to the bulk element that is adjacent to boundary b</span></div>
<div class="line">   ELEMENT* bulk_elem_pt = <span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(</div>
<div class="line">    bulk_mesh_pt-&gt;boundary_element_pt(b,e));</div>
<div class="line">   </div>
<div class="line">   <span class="comment">//Find the index of the face of element e along boundary b </span></div>
<div class="line">   <span class="keywordtype">int</span> face_index = bulk_mesh_pt-&gt;face_index_at_boundary(b,e);</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Build the corresponding outer flux element</span></div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Dirichlet to Neumann boundary conditon</span></div>
<div class="line">   <span class="keywordflow">if</span> (<a class="code" href="namespaceGlobalParameters.html#a6e2bba1769e86a5d3db88e2c7062bc63">GlobalParameters::DtN_BC</a>)</div>
<div class="line">    {</div>
<div class="line">     HelmholtzDtNBoundaryElement&lt;ELEMENT&gt;* flux_element_pt = <span class="keyword">new</span> </div>
<div class="line">      HelmholtzDtNBoundaryElement&lt;ELEMENT&gt;(bulk_elem_pt,face_index);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">//Add the flux boundary element to the  helmholtz_outer_boundary_mesh</span></div>
<div class="line">     helmholtz_outer_boundary_mesh_pt-&gt;add_element_pt(flux_element_pt);</div>
<div class="line">    }</div>
<div class="line">   <span class="comment">//  ABCs BC</span></div>
<div class="line">   <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">     HelmholtzAbsorbingBCElement&lt;ELEMENT&gt;* flux_element_pt = <span class="keyword">new</span> </div>
<div class="line">      HelmholtzAbsorbingBCElement&lt;ELEMENT&gt;(bulk_elem_pt,face_index);</div>
<div class="line">     </div>
<div class="line">     <span class="comment">//Add the flux boundary element to the  helmholtz_outer_boundary_mesh</span></div>
<div class="line">     helmholtz_outer_boundary_mesh_pt-&gt;add_element_pt(flux_element_pt);</div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">//end of loop over bulk elements adjacent to boundary b</span></div>
<div class="line">} <span class="comment">// end of create_outer_bc_elements</span></div>
</div><!-- fragment --><p> (We omit the listing of the function <code>create_flux_elements(...)</code> because it is very similar. Feel free to inspect in the <a href="../../../../demo_drivers/helmholtz/scattering/scattering.cc">source code.</a>)</p>
<hr  />
 <hr  />
<h2><a class="anchor" id="doc"></a>
Post-processing</h2>
<p>The post-processing function <code>doc_solution(...)</code> computes and outputs the total radiated power, and plots the computed and exact solutions (real and complex parts).</p>
 <div class="fragment"><div class="line"><span class="comment">//=====================start_of_doc=======================================</span></div>
<div class="line"><span class="comment">/// Doc the solution: doc_info contains labels/output directory etc.</span></div>
<div class="line"><span class="comment"></span><span class="comment">//========================================================================</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ELEMENT&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classScatteringProblem.html#af83ab14c4f4750ea17c21466f6c6364f">ScatteringProblem&lt;ELEMENT&gt;::doc_solution</a>(DocInfo&amp; </div>
<div class="line">                                              doc_info) </div>
<div class="line">{ </div>
<div class="line"> </div>
<div class="line"> ofstream some_file,some_file2;</div>
<div class="line"> <span class="keywordtype">char</span> filename[100];</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Number of plot points</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> npts;</div>
<div class="line"> npts=5; </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Compute/output the radiated power</span></div>
<div class="line"> <span class="comment">//----------------------------------</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/power%i.dat&quot;</span>,doc_info.directory().c_str(),</div>
<div class="line">         doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Accumulate contribution from elements</span></div>
<div class="line"> <span class="keywordtype">double</span> power=0.0;</div>
<div class="line"> <span class="keywordtype">unsigned</span> nn_element=Helmholtz_outer_boundary_mesh_pt-&gt;nelement(); </div>
<div class="line"> <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> e=0;e&lt;nn_element;e++)</div>
<div class="line">  {</div>
<div class="line">   HelmholtzBCElementBase&lt;ELEMENT&gt; *el_pt = </div>
<div class="line">    <span class="keyword">dynamic_cast&lt;</span> HelmholtzBCElementBase&lt;ELEMENT&gt;*<span class="keyword">&gt;</span>(</div>
<div class="line">     Helmholtz_outer_boundary_mesh_pt-&gt;element_pt(e)); </div>
<div class="line">   power += el_pt-&gt;global_power_contribution(some_file);</div>
<div class="line">  }</div>
<div class="line"> some_file.close();</div>
<div class="line"> oomph_info &lt;&lt; <span class="stringliteral">&quot;Total radiated power: &quot;</span> &lt;&lt; power &lt;&lt; std::endl; </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Output solution </span></div>
<div class="line"> <span class="comment">//-----------------</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/soln%i.dat&quot;</span>,doc_info.directory().c_str(),</div>
<div class="line">         doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> Bulk_mesh_pt-&gt;output(some_file,npts);</div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Output exact solution </span></div>
<div class="line"> <span class="comment">//----------------------</span></div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/exact_soln%i.dat&quot;</span>,doc_info.directory().c_str(),</div>
<div class="line">         doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> Bulk_mesh_pt-&gt;output_fct(some_file,npts,<a class="code" href="namespaceGlobalParameters.html#ae2320da6053f5527b2af5ebb362a8a07">GlobalParameters::get_exact_u</a>); </div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">double</span> error,norm;</div>
<div class="line"> sprintf(filename,<span class="stringliteral">&quot;%s/error%i.dat&quot;</span>,doc_info.directory().c_str(),</div>
<div class="line">         doc_info.number());</div>
<div class="line"> some_file.open(filename);</div>
<div class="line"> Bulk_mesh_pt-&gt;compute_error(some_file,<a class="code" href="namespaceGlobalParameters.html#ae2320da6053f5527b2af5ebb362a8a07">GlobalParameters::get_exact_u</a>,</div>
<div class="line">                             error,norm); </div>
<div class="line"> some_file.close();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Doc L2 error and norm of solution</span></div>
<div class="line"> oomph_info &lt;&lt; <span class="stringliteral">&quot;\nNorm of error   : &quot;</span> &lt;&lt; sqrt(error) &lt;&lt; std::endl; </div>
<div class="line"> oomph_info &lt;&lt; <span class="stringliteral">&quot;Norm of solution: &quot;</span> &lt;&lt; sqrt(norm) &lt;&lt; std::endl &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> Finally, we create the data required to produce an animation of the actual (real) potential at 40 instants during a period of the oscillation.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Do animation of Helmholtz solution</span></div>
<div class="line"> <span class="comment">//-----------------------------------</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> nstep=40;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;nstep;i++)</div>
<div class="line">  {</div>
<div class="line">   sprintf(filename,<span class="stringliteral">&quot;%s/helmholtz_animation%i_frame%i.dat&quot;</span>,</div>
<div class="line">           doc_info.directory().c_str(),</div>
<div class="line">           doc_info.number(),i);</div>
<div class="line">   some_file.open(filename);</div>
<div class="line">   sprintf(filename,<span class="stringliteral">&quot;%s/exact_helmholtz_animation%i_frame%i.dat&quot;</span>,</div>
<div class="line">           doc_info.directory().c_str(),</div>
<div class="line">           doc_info.number(),i);</div>
<div class="line">   some_file2.open(filename);</div>
<div class="line">   <span class="keywordtype">double</span> phi=2.0*MathematicalConstants::Pi*double(i)/double(nstep-1);</div>
<div class="line">   <span class="keywordtype">unsigned</span> nelem=Bulk_mesh_pt-&gt;nelement();</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> e=0;e&lt;nelem;e++)</div>
<div class="line">    {</div>
<div class="line">     ELEMENT* el_pt=<span class="keyword">dynamic_cast&lt;</span>ELEMENT*<span class="keyword">&gt;</span>(</div>
<div class="line">      Bulk_mesh_pt-&gt;element_pt(e));</div>
<div class="line">     el_pt-&gt;output_real(some_file,phi,npts);    </div>
<div class="line">     el_pt-&gt;output_real_fct(some_file2,phi,npts,</div>
<div class="line">                            <a class="code" href="namespaceGlobalParameters.html#ae2320da6053f5527b2af5ebb362a8a07">GlobalParameters::get_exact_u</a>); </div>
<div class="line">    }</div>
<div class="line">   some_file.close();</div>
<div class="line">   some_file2.close();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// end of doc</span></div>
</div><!-- fragment --><hr  />
 <hr  />
<h1><a class="anchor" id="comm_ex"></a>
Comments and Exercises</h1>
<h2><a class="anchor" id="numbering"></a>
The enumeration of the unknowns</h2>
<p>As discussed in the introduction, most practically relevant solutions of the Helmholtz equation are complex valued. Since <code>oomph-lib's</code> solvers only deal with real (double precision) unknowns, the equations are separated into their real and imaginary parts. In the implementation of the Helmholtz elements, we store the real and imaginary parts of the solution as two separate values at each node. By default, the real and imaginary parts are accessible via <code>Node::value(0)</code> and <code>Node::value(1)</code>. However, to facilitate the use of the elements in multi-physics problems we avoid accessing the unknowns directly in this manner but provide the virtual function </p><div class="fragment"><div class="line">std::complex&lt;unsigned&gt; HelmholtzEquations&lt;DIM&gt;::u_index_helmholtz()</div>
</div><!-- fragment --><p> which returns a complex number made of the two unsigneds that indicate which nodal value represents the real and imaginary parts of the solution. This function may be overloaded in combined multi-physics elements in which a Helmholtz element is combined (by multiple inheritance) with another element, using the strategy described in <a href="../../../multi_physics/b_convection/html/index.html">the Boussinesq convection tutorial</a>.</p>
<hr  />
<h2><a class="anchor" id="ex"></a>
Exercises</h2>
<h3><a class="anchor" id="lin"></a>
Exploiting linearity</h3>
<p>Confirm that the (costly) re-computation of the <img class="formulaInl" alt="$ \gamma $" src="form_25.png" width="9" height="9"/> integral in <code>actions_before_newton_convergence_check()</code> after the first (and only) linear solve in the Newton iteration can be avoided by declaring the problem to be linear.</p>
<h3><a class="anchor" id="acc"></a>
The accuracy of the boundary condition elements</h3>
<p>Explore the accuracy (and computational cost) of the various <code>FaceElements</code> that apply the Sommmerfeld radiation condition. In particular, confirm that the accuracy of the DtN boundary condition is (nearly) independent of the radius of the artificial outer boundary, whereas the accuracy of the ABC boundary condition can only be improved by increasing the size of the computational domain.</p>
<hr  />
 <hr  />
<h1><a class="anchor" id="sources"></a>
Source files for this tutorial</h1>
<ul>
<li>The source files for this tutorial are located in the directory: <center> <a href="../../../../demo_drivers/helmholtz/scattering">demo_drivers/helmholtz/scattering/ </a> </center></li>
<li>The driver code is: <center> <a href="../../../../demo_drivers/helmholtz/scattering/scattering.cc">demo_drivers/helmholtz/scattering/scattering.cc </a> </center></li>
</ul>
<hr  />
 <hr  />
 <h1><a class="anchor" id="pdf"></a>
PDF file</h1>
<p>A <a href="../latex/refman.pdf">pdf version</a> of this document is available. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->

    <!-- jQuery for Bootstrap and Doxygen -->
    <script src="../../../js/jquery-1.12.0.min.js"></script>
    <!-- Minified boostrap plugins-->
    <script src="../../../js/bootstrap.js"></script>
    <!-- Doxygen dependency to add powertips to source code-->
    <script src="../../../js/jquery.powertip.min.js"></script>
    <!-- The  following script is generated by doxygen and hides/shows levels in 
         the data structure lists and adds powertips to source code-->
    <script src="../../../js/dynsections.js" ></script>
    <!-- add to Doxygen's class names so bootstrap css and js recognises them-->
    <script type="text/javascript">
    $(".contents").addClass("container");
    $(".header").addClass("container");
    $(".navpath").addClass("container");
    $("#navrow3").addClass("container");
    $("#navrow4").addClass("container");
    $(".mlabel").addClass("label");
    $(".mlabel").addClass("label-default");
    $(".memitem").addClass("panel");
    $(".memitem").addClass("panel-info");
    $(".memproto").addClass("panel-heading");
    $(".memdoc").addClass("panel-body");
    </script>
    <footer>
      <div class="container">
        <div class="text-muted" style="float:right;">Generated by <a href="http://www.doxygen.org/index.html">
          <img style="height:18px;" class="footer-img" src="doxygen.png" alt="doxygen"></a> on Thu Dec 19 2024 11:16:42
        </div>
      </div>
    </footer>
</body>
</html>
