//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC// Copyright (C) 2006-2021 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//Header file for specific (two-dimensional) fluid free surface elements

//Include guards, to prevent multiple includes
#ifndef OOMPH_SPECIFIC_NODE_UPDATE_INTERFACE_ELEMENTS_HEADER
#define OOMPH_SPECIFIC_NODE_UPDATE_INTERFACE_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

//OOMPH-LIB headers
#include "../generic/Qelements.h"
#include "../generic/spines.h"
#include "../generic/hijacked_elements.h"
#include "interface_elements.h"

namespace oomph
{

//=======================================================================
/// \short This policy class is used to associate specific bounding
/// elements with specific FluidInterface elements. It must be filled
/// in for every class that uses the SpineUpdateFluidInterface<...>
/// or ElasticUpdateFluidInterface<....> generic template classes.
/// Examples for our default Line, Axisymmetric and Surface types
/// are included below
//=======================================================================
 template<class ELEMENT> 
  class BoundingElementType
  {};

//======================================================================
/// \short This policy class is used to allow additional values to be
/// added to the nodes from new surface equations, for examples of
/// usage see the SurfactantTransportFluidInterfaceElements.
/// The use of this class avoids issues with calling virtual
/// functions in constructors and avoids having a global look-up
/// able, although it functions in much the same way.
/// Typically, this will only be filled in by "expert users" and
/// is only required if you want to write generic surface-element
/// classes. Specific classes can always be overloaded on a
/// case-by-case basis.
//=====================================================================
 template<class ELEMENT>
  class FluidInterfaceAdditionalValues
  {
    private:
   //Issue an error message if this base class is called
   void error_message()
   {
    std::ostringstream error_message;
    error_message
     <<
     "The generic FluidInterfaceAdditionalValues<ELEMENT> class has been\n"
     <<
     "called. This should never happen. If you are creating your own\n"
     <<
     "surface equations you must overload the policy class to specify\n"
     <<
     "how many additional values are required at the surface nodes.\n"
     <<
     "For an example, see src/fluid_interface/surfactant_transport_elements.h\n"
     << std::endl;
    throw OomphLibError(error_message.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
     
    public:
   
   ///Empty constructor
   FluidInterfaceAdditionalValues<ELEMENT>() {}
   
   ///\short Specific interface that states how many additional values are
   ///required for the n-th node. Default is zero, but issue error_message.
   inline unsigned nadditional_values(const unsigned &n)
   {error_message(); return 0;}
   
   ///\short Specify any additional index setup information that is required;
   ///i.e. the look-up schemes for the additional values.
   ///Default is empty with error message
   inline void setup_equation_indices(ELEMENT* const &element_pt, const unsigned &id)
   {error_message();}
  };
 

//======================================================================
/// \short Specific policy class for the FluidInterfaceElemetnts,
/// which do not require any additional values at the nodes.
 //=====================================================================
 template<>
  class FluidInterfaceAdditionalValues<FluidInterfaceElement>
  {
    public:
   
   ///Empty constructor
   FluidInterfaceAdditionalValues<FluidInterfaceElement>() {}
   
   ///\short Specific interface that states how many additional values are
   ///required for the n-th node. No additional values
   inline unsigned nadditional_values(const unsigned &n)
   {return 0;}
   
   ///\short Specify any additional index setup information that is required;
   ///i.e. the look-up schemes for the additional values.
   ///Empty
   inline void setup_equation_indices(FluidInterfaceElement* const &element_pt, const unsigned &id)
   {}
  };
 

 
//-------------SPINE NODE UPDATE CLASSES-------------------------------
//---------------------------------------------------------------------

//======================================================================
/// \short Generic Spine node update interface template class that can
/// be combined with a given surface equations class and surface
/// derivative class to provide
/// a concrete implementation of any surface element that uses spines.
//======================================================================
 template<class EQUATION_CLASS, class DERIVATIVE_CLASS, class ELEMENT>
  class SpineUpdateFluidInterfaceElement : 
  public virtual Hijacked<SpineElement<FaceGeometry<ELEMENT> > >, 
  public virtual EQUATION_CLASS, public DERIVATIVE_CLASS 
 {
   private:
  
  /// \short In spine elements, the kinematic condition is the equation 
  /// used to determine the unknown spine heights. Overload the
  /// function accordingly
  int kinematic_local_eqn(const unsigned &n) 
  {return this->spine_local_eqn(n);}
  
  /// \short Hijacking the kinematic condition corresponds to hijacking the
  /// variables associated with the spine heights.
  void hijack_kinematic_conditions(const Vector<unsigned> &bulk_node_number)
  {
   //Loop over all the node numbers that are passed in
   for(Vector<unsigned>::const_iterator it=bulk_node_number.begin();
       it!=bulk_node_number.end();++it)
    {
     //Hijack the spine heights. (and delete the returned data object)
     delete this->hijack_nodal_spine_value(*it,0);
    }
  }
  
   protected:
  
  ///\short Fill in the specific surface derivative calculations
  /// by calling the appropriate class function
  double compute_surface_derivatives(const Shape &psi, const DShape &dpsids,
                                     const DenseMatrix<double> &interpolated_t,
                                     const Vector<double> &interpolated_x,
                                     DShape &surface_gradient,
                                     DShape &surface_divergence)
  {return DERIVATIVE_CLASS::compute_surface_derivatives(
    psi,dpsids,interpolated_t,interpolated_x,surface_gradient,
    surface_divergence);}
  
 
   public:
 
 
  /// \short Constructor, the arguments are a pointer to the  "bulk" element 
  /// and the index of the face to be created
   SpineUpdateFluidInterfaceElement(FiniteElement* const &element_pt, 
                                    const int &face_index,
                                    const unsigned &id=0) : 
  Hijacked<SpineElement<FaceGeometry<ELEMENT> > >(), 
   EQUATION_CLASS(), DERIVATIVE_CLASS()
   {
    //Attach the geometrical information to the element, by
    //making the face element from the bulk element
    element_pt->build_face_element(face_index,this);
    
#ifdef PARANOID
    //Is it refineable
    RefineableElement* ref_el_pt=dynamic_cast<RefineableElement*>(element_pt);
    if(ref_el_pt!=0)
     {
      if (this->has_hanging_nodes())
       {
        throw OomphLibError(
         "This interface element will not work correctly if nodes are hanging\n",
         OOMPH_CURRENT_FUNCTION,
         OOMPH_EXCEPTION_LOCATION);
       }
     }
#endif
    
    //Find the index at which the velocity unknowns are stored 
    //from the bulk element and allocate the local storage
    ELEMENT* cast_element_pt = dynamic_cast<ELEMENT*>(element_pt);
    //Find number of momentum equation required
    const unsigned n_u_index = cast_element_pt->n_u_nst();
    this->U_index_interface.resize(n_u_index);
    for(unsigned i=0;i<n_u_index;i++)
     {
      this->U_index_interface[i] = cast_element_pt->u_index_nst(i);
     }
   
    //Add any additional values required by the equations class
    unsigned n_node_face = this->nnode();
    //Create an instance of the policy class that determines
    //how many additional values are required
    FluidInterfaceAdditionalValues<EQUATION_CLASS>
     *interface_additional_values_pt =
     new FluidInterfaceAdditionalValues<EQUATION_CLASS>();
    //Do we need to add any values
    //By default the spines don't need to so we can save
    //some effort here
    bool add_values = false;
    //Storage for the number of additional values required
    //for each node
    Vector<unsigned> additional_data_values(n_node_face);
    for(unsigned i=0;i<n_node_face;++i)
     {
      //Read out additional values for each node
      additional_data_values[i] = interface_additional_values_pt->nadditional_values(i);
      //If any of these are non-zero it will set the boolean to true
      add_values |= additional_data_values[i];
     }
   
    // If storage is needed allocate it and call
    // the associated local index setup function
    if(add_values)
     {
      this->add_additional_values(additional_data_values,id);
      //Call any local setup from the interface policy class
      interface_additional_values_pt->setup_equation_indices(this,id);
     }
   
    //Delete the policy class, it's work is done.
    delete interface_additional_values_pt; interface_additional_values_pt=0;
   }
 
  /// Calculate the contribution to the residuals and the jacobian
  void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
                                        DenseMatrix<double> &jacobian)
  {
   //Call the generic routine with the flag set to 1
   EQUATION_CLASS::fill_in_generic_residual_contribution_interface(residuals,jacobian,1);
  
   //Call the generic routine to handle the shape derivatives
   this->fill_in_jacobian_from_geometric_data(jacobian);
  }
 
  /// \short
  /// Helper function to calculate the additional contributions
  /// These are those filled in by the particular equations
  void add_additional_residual_contributions_interface(
   Vector<double> &residuals, 
   DenseMatrix<double> &jacobian,
   const unsigned &flag,
   const Shape &psif,
   const DShape &dpsifds,
   const DShape &dpsifdS,
   const DShape &dpsifdS_div,
   const Vector<double> &s,
   const Vector<double> &interpolated_x, 
   const Vector<double> &interpolated_n, 
   const double &W, 
   const double &J)
  {
   EQUATION_CLASS::add_additional_residual_contributions_interface(
    residuals,jacobian,flag,psif,dpsifds,dpsifdS,dpsifdS_div,s,interpolated_x,interpolated_n,W,J);
  }
 
  /// Overload the output function
  void output(std::ostream &outfile) {EQUATION_CLASS::output(outfile);}
 
  /// Output the element
  void output(std::ostream &outfile, const unsigned &n_plot)
  {EQUATION_CLASS::output(outfile,n_plot);}
 
  ///Overload the C-style output function
  void output(FILE* file_pt) {EQUATION_CLASS::output(file_pt);}
 
  ///C-style Output function
  void output(FILE* file_pt, const unsigned &n_plot)
  {EQUATION_CLASS::output(file_pt,n_plot);}
    
 
  /// \short Create an "bounding" element of the type
  /// specified by the BoundingElementType policy class
  /// Here, this allows
  /// the application of a contact angle boundary condition on the
  /// the specified face.
  virtual FluidInterfaceBoundingElement* make_bounding_element(
   const int &face_index)
  {
   //Create a temporary pointer to the appropriate FaceElement read our from
   //our policy class
   BoundingElementType<SpineUpdateFluidInterfaceElement<EQUATION_CLASS,
    DERIVATIVE_CLASS,ELEMENT> > *face_el_pt =
    new BoundingElementType<SpineUpdateFluidInterfaceElement<EQUATION_CLASS,
    DERIVATIVE_CLASS,ELEMENT> >;
  
   //Attach the geometrical information to the new element
   this->build_face_element(face_index,face_el_pt);
  
   //Set the index at which the velocity nodes are stored
   face_el_pt->u_index_interface_boundary() = this->U_index_interface;
  
   //Set the value of the nbulk_value, the node is not resized
   //in this bounding element,
   //so it will just be the actual nvalue here
   // There is some ambiguity about what this means (however)
   // We are interpreting it to mean the number of
   // values in this FaceElement before creating the new
   // bounding element.
   const unsigned n_node_bounding = face_el_pt->nnode();
   for(unsigned n=0;n<n_node_bounding;n++)
    {
     face_el_pt->nbulk_value(n) =
      face_el_pt->node_pt(n)->nvalue();
    }
  
   //Set of unique geometric data that is used to update the bulk,
   //but is not used to update the face
   std::set<Data*> unique_additional_geom_data;
  
   //Get all the geometric data for this (bulk) element
   this->assemble_set_of_all_geometric_data(unique_additional_geom_data);
  
   //Now assemble the set of geometric data for the face element
   std::set<Data*> unique_face_geom_data_pt;
   face_el_pt->assemble_set_of_all_geometric_data(unique_face_geom_data_pt);
  
   //Erase the face geometric data from the additional data
   for(std::set<Data*>::iterator it=unique_face_geom_data_pt.begin();
       it!=unique_face_geom_data_pt.end();++it)
    {unique_additional_geom_data.erase(*it);}
  
   //Finally add all unique additional data as external data
   for(std::set<Data*>::iterator it = unique_additional_geom_data.begin();
       it!= unique_additional_geom_data.end();++it)
    {
     face_el_pt->add_external_data(*it);
    }
  
   //Return the value of the pointer
   return face_el_pt;
  }
 
 };
 

//=====================================================================
///Spine version of the PointFluidInterfaceBoundingElement
//===================================================================== 
 template<class ELEMENT>
  class SpinePointFluidInterfaceBoundingElement : 
  public Hijacked< SpineElement<FaceGeometry<FaceGeometry<ELEMENT> > > >,
  public PointFluidInterfaceBoundingElement
   
  {
    public:
 

   /// Constructor
    SpinePointFluidInterfaceBoundingElement() : 
   Hijacked<SpineElement<FaceGeometry<FaceGeometry<ELEMENT> > > >(),
    PointFluidInterfaceBoundingElement() {}
 
   /// Overload the output function
   void output(std::ostream &outfile) {FiniteElement::output(outfile);}
 
   /// Output the element
   void output(std::ostream &outfile, const unsigned &n_plot)
   {FluidInterfaceBoundingElement::output(outfile,n_plot);}
 
   ///Overload the C-style output function
   void output(FILE* file_pt) {FiniteElement::output(file_pt);}
 
   ///C-style Output function
   void output(FILE* file_pt, const unsigned &n_plot)
   {FluidInterfaceBoundingElement::output(file_pt,n_plot);}
 
   /// Calculate the elemental residual vector and the Jacobian
   void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
                                         DenseMatrix<double> &jacobian)
   {
    //Call the generic routine with the flag set to 1
    this->fill_in_generic_residual_contribution_interface_boundary(residuals,
                                                                   jacobian,1);
    //Call generic FD routine for the external data
    this->fill_in_jacobian_from_external_by_fd(jacobian);
  
    //Call the generic routine to handle the spine variables
    this->fill_in_jacobian_from_geometric_data(jacobian);
   }
 
   /// \short Return local equation number associated with the kinematic
   /// constraint for local node n
   int kinematic_local_eqn(const unsigned &n) 
   {return this->spine_local_eqn(n);}
 
  }; 



//=========================================================================
/// Spine version of the LineFluidInterfaceBoundingElement
//========================================================================
 template<class ELEMENT>
  class SpineLineFluidInterfaceBoundingElement : public 
  Hijacked<SpineElement<FaceGeometry<FaceGeometry<ELEMENT> > > >,
  public LineFluidInterfaceBoundingElement
                                       
  {
    public:
 
   /// Constructor
    SpineLineFluidInterfaceBoundingElement() : 
   Hijacked<SpineElement<FaceGeometry<FaceGeometry<ELEMENT> > > >(),
    LineFluidInterfaceBoundingElement() {}
 
   /// Overload the output function
   void output(std::ostream &outfile) {FiniteElement::output(outfile);}
 
   /// Output the element
   void output(std::ostream &outfile, const unsigned &n_plot)
   {FluidInterfaceBoundingElement::output(outfile,n_plot);}
 
   ///Overload the C-style output function
   void output(FILE* file_pt) {FiniteElement::output(file_pt);}
 
   ///C-style Output function
   void output(FILE* file_pt, const unsigned &n_plot)
   {FluidInterfaceBoundingElement::output(file_pt,n_plot);}
 
 
   /// Calculate the jacobian
   void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
                                         DenseMatrix<double> &jacobian)
   {
    //Call the generic routine with the flag set to 1
    this->fill_in_generic_residual_contribution_interface_boundary(residuals,
                                                                   jacobian,1);
    //Call generic FD routine for the external data
    this->fill_in_jacobian_from_external_by_fd(jacobian);
  
    //Call the generic routine to handle the spine variables
    this->fill_in_jacobian_from_geometric_data(jacobian);
   }
 

   /// Local eqn number of the kinematic bc associated with local node n
   int kinematic_local_eqn(const unsigned &n) 
   {
    //Kinematic bc is always associated with the n-th spine height
    return this->spine_local_eqn(n);
   }
 
  }; 


//============GEOMETRIC SPECIALISATIONS============================
 
 
//Specialise the spine update template class to concrete 1D case
 template<class ELEMENT>
  class SpineLineFluidInterfaceElement :
  public SpineUpdateFluidInterfaceElement<FluidInterfaceElement,
  LineDerivatives,ELEMENT>
  {
    public:
  
    SpineLineFluidInterfaceElement(
     FiniteElement* const &element_pt, 
     const int &face_index) : 
   SpineUpdateFluidInterfaceElement<FluidInterfaceElement,
    LineDerivatives,ELEMENT>(element_pt,face_index) {}
  };


//Define the BoundingElement type associated with the 1D surface element
 template<class ELEMENT>
  class BoundingElementType<SpineUpdateFluidInterfaceElement<
  FluidInterfaceElement,LineDerivatives,ELEMENT> >:
 public SpinePointFluidInterfaceBoundingElement<ELEMENT>
 {
   public:
 
  BoundingElementType<SpineUpdateFluidInterfaceElement<
   FluidInterfaceElement,LineDerivatives,ELEMENT> >() :
  SpinePointFluidInterfaceBoundingElement<ELEMENT>() { }
 };


//Specialise Spine update case to concrete axisymmetric case
 template<class ELEMENT>
  class SpineAxisymmetricFluidInterfaceElement :
  public SpineUpdateFluidInterfaceElement<FluidInterfaceElement,
  AxisymmetricDerivatives,ELEMENT>
  {
    public:
  
    SpineAxisymmetricFluidInterfaceElement(
     FiniteElement* const &element_pt, 
     const int &face_index) : 
   SpineUpdateFluidInterfaceElement<FluidInterfaceElement,
    AxisymmetricDerivatives,ELEMENT>(element_pt,face_index) {}
  };

//Define the bounding element associated with the axisymmetric fluid interface element 
 template<class ELEMENT>
  class BoundingElementType<SpineUpdateFluidInterfaceElement<
  FluidInterfaceElement,AxisymmetricDerivatives,ELEMENT> >:
 public SpinePointFluidInterfaceBoundingElement<ELEMENT>
 {
   public:
 
  BoundingElementType<SpineUpdateFluidInterfaceElement<
   FluidInterfaceElement,AxisymmetricDerivatives,ELEMENT> >() :
  SpinePointFluidInterfaceBoundingElement<ELEMENT>() { }
 };

//Specialise Spine update case to concrete 2D case 
 template<class ELEMENT>
  class SpineSurfaceFluidInterfaceElement :
  public SpineUpdateFluidInterfaceElement<FluidInterfaceElement,
  SurfaceDerivatives,ELEMENT>
  {
    public:
  
    SpineSurfaceFluidInterfaceElement(
     FiniteElement* const &element_pt, 
     const int &face_index) : 
   SpineUpdateFluidInterfaceElement<FluidInterfaceElement,
    SurfaceDerivatives,ELEMENT>(element_pt,face_index) {}
  };

//Define the bounding element type for the 2D surface 
 template<class ELEMENT>
  class BoundingElementType<SpineUpdateFluidInterfaceElement<
  FluidInterfaceElement,SurfaceDerivatives,ELEMENT> >:
 public SpineLineFluidInterfaceBoundingElement<ELEMENT>
 {
   public:
 
  BoundingElementType<SpineUpdateFluidInterfaceElement<
   FluidInterfaceElement,SurfaceDerivatives,ELEMENT> >() :
  SpineLineFluidInterfaceBoundingElement<ELEMENT>() { }
 };


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

//-------------ELASTIC NODE UPDATE CLASSES-------------------------------
//---------------------------------------------------------------------


//=======================================================================
/// \short Generic Elastic node update interface template class that can
/// be combined with a given surface equations class and surface derivative
/// class to provide a concrete implementation of any surface element
/// that uses elastic node updates.
//======================================================================
 template<class EQUATION_CLASS, class DERIVATIVE_CLASS, class ELEMENT>
  class ElasticUpdateFluidInterfaceElement : 
  public virtual Hijacked<FaceGeometry<ELEMENT> >, 
  public EQUATION_CLASS, public DERIVATIVE_CLASS
 {
   private:
 
  /// \short Storage for the location of the Lagrange multiplier
  /// (If other additional values have been added we need
  /// to add the Lagrange multiplier at the end)
  Vector<unsigned> Lagrange_index;
 
  /// \short Return the index at which the lagrange multiplier is
  ///stored at the n-th node
  inline unsigned lagrange_index(const unsigned &n)
  {return this->Lagrange_index[n];}
 
  /// \short Equation number of the kinematic BC associated with node j.
  /// (This is the equation for the Lagrange multiplier) 
  inline int kinematic_local_eqn(const unsigned &n)
  {
   // Get the index of the nodal value associated with Lagrange multiplier
   return this->nodal_local_eqn(n,this->lagrange_index(n));
  }
 
  /// \short Hijacking the kinematic condition corresponds to hijacking the
  /// variables associated with the Lagrange multipliers that are assigned
  /// on construction of this element.
  void hijack_kinematic_conditions(const Vector<unsigned> &bulk_node_number)
  {    
   //Loop over all the nodes that are passed in
   for(Vector<unsigned>::const_iterator it=bulk_node_number.begin();
       it!=bulk_node_number.end();++it)
    {
     //Hijack the appropriate value and delete the returned Node
     delete this->hijack_nodal_value(*it,this->lagrange_index(*it));  
    }
  }
 
   protected:
 
  ///\short Fill in the specific surface derivative calculations
  /// by calling the appropriate function from the derivative class
  double compute_surface_derivatives(const Shape &psi, const DShape &dpsids,
                                     const DenseMatrix<double> &interpolated_t,
                                     const Vector<double> &interpolated_x,
                                     DShape &surface_gradient,
                                     DShape &surface_divergence)
  {return DERIVATIVE_CLASS::compute_surface_derivatives(
    psi,dpsids,interpolated_t,interpolated_x,surface_gradient,
    surface_divergence);}
 
 
   public:
 
  /// \short Constructor, pass a pointer to the bulk element and the face 
  /// index of the bulk element to which the element is to be attached to.
  /// The optional identifier can be used
  /// to distinguish the additional nodal value (Lagr mult) created by 
  /// this element from those created by other FaceElements.
   ElasticUpdateFluidInterfaceElement(FiniteElement* const &element_pt, 
                                      const int &face_index,
                                      const unsigned &id=0) : 
  FaceGeometry<ELEMENT>(), EQUATION_CLASS(), DERIVATIVE_CLASS()
   {
    //Attach the geometrical information to the element
    //This function also assigned nbulk_value from required_nvalue of the
    //bulk element
    element_pt->build_face_element(face_index,this);
   
#ifdef PARANOID
    //Is it refineable
    RefineableElement* ref_el_pt=dynamic_cast<RefineableElement*>(element_pt);
    if(ref_el_pt!=0)
     {
      if (this->has_hanging_nodes())
       {
        throw OomphLibError(
         "This flux element will not work correctly if nodes are hanging\n",
         OOMPH_CURRENT_FUNCTION,
         OOMPH_EXCEPTION_LOCATION);
       }
     }
#endif
   
    //Find the index at which the velocity unknowns are stored 
    //from the bulk element and resize the local storage scheme
    ELEMENT* cast_element_pt = dynamic_cast<ELEMENT*>(element_pt);
    const unsigned n_u_index = cast_element_pt->n_u_nst();
    this->U_index_interface.resize(n_u_index);
    for(unsigned i=0;i<n_u_index;i++)
     {
      this->U_index_interface[i] = cast_element_pt->u_index_nst(i);
     }
   
    //Read out the number of nodes on the face
    unsigned n_node_face = this->nnode();
   
    //Create an instance of the policy class that determines
    //how many additional values are required
    FluidInterfaceAdditionalValues<EQUATION_CLASS>
     *interface_additional_values_pt =
     new FluidInterfaceAdditionalValues<EQUATION_CLASS>();
   
    //Set the additional data values in the face
    //There is always also one additional values at each node --- the Lagrange multiplier
    Vector<unsigned> additional_data_values(n_node_face);
    for(unsigned n=0;n<n_node_face;n++)
     {
      //Now add one to the addtional values at every single node
      additional_data_values[n] = interface_additional_values_pt->nadditional_values(n) + 1; 
     }
   
    // Now add storage for Lagrange multipliers and set the map containing 
    // the position of the first entry of this face element's 
    // additional values.
    this->add_additional_values(additional_data_values,id);     
   
    //Now I can just store the lagrange index offset to give the storage
    //location of the nodes
    Lagrange_index.resize(n_node_face);
    for(unsigned n=0;n<n_node_face;++n)
     {
      Lagrange_index[n] = additional_data_values[n] -1 + 
       dynamic_cast<BoundaryNodeBase*>(this->node_pt(n))->index_of_first_value_assigned_by_face_element(id);
     }

    //Call any local setup from the interface policy class
    interface_additional_values_pt->setup_equation_indices(this,id);
   
    //Can now delete the policy class
    delete interface_additional_values_pt; interface_additional_values_pt=0;
   }
 
  /// \short The "global" intrinsic coordinate of the element when 
  /// viewed as part of a geometric object should be given by 
  /// the FaceElement representation, by default
  double zeta_nodal(const unsigned &n, const unsigned &k,
                    const unsigned &i) const                              
  {return FaceElement::zeta_nodal(n,k,i);}  
 
  /// Return the lagrange multiplier at local node n
  double &lagrange(const unsigned &n)
  {
   return *this->node_pt(n)->value_pt(this->lagrange_index(n)); 
  }
 
 
  /// Fill in contribution to residuals and Jacobian
  void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
                                        DenseMatrix<double> &jacobian)
  {
   //Call the generic routine with the flag set to 1
   EQUATION_CLASS::fill_in_generic_residual_contribution_interface(residuals,jacobian,1);
  
   //Call the generic finite difference routine for the solid variables
   this->fill_in_jacobian_from_solid_position_by_fd(jacobian);
  }
 
  /// Overload the output function
  void output(std::ostream &outfile) {EQUATION_CLASS::output(outfile);}
 
  /// Output the element
  void output(std::ostream &outfile, const unsigned &n_plot)
  {EQUATION_CLASS::output(outfile,n_plot);}
 
  ///Overload the C-style output function
  void output(FILE* file_pt) {EQUATION_CLASS::output(file_pt);}
 
  ///C-style Output function
  void output(FILE* file_pt, const unsigned &n_plot)
  {EQUATION_CLASS::output(file_pt,n_plot);}
 
 
  /// \short Helper function to calculate the additional contributions
  /// to be added at each integration point. This deals with 
  /// Lagrange multiplier contribution, as well as any
  /// additional contributions by the other equations.
  void add_additional_residual_contributions_interface(
   Vector<double> &residuals, 
   DenseMatrix<double> &jacobian,
   const unsigned &flag,
   const Shape &psif,
   const DShape &dpsifds,
   const DShape &dpsifdS,
   const DShape &dpsifdS_div,
   const Vector<double> &s,
   const Vector<double> &interpolated_x, 
   const Vector<double> &interpolated_n, 
   const double &W, 
   const double &J)
  {
   EQUATION_CLASS::add_additional_residual_contributions_interface(
    residuals,jacobian,flag,psif,dpsifds,dpsifdS,dpsifdS_div,s,interpolated_x,interpolated_n,W,J);
  
   //Assemble Lagrange multiplier by loop over the shape functions
   const unsigned n_node = this->nnode();
   //Read out the dimension of the node
   const unsigned nodal_dimension = this->nodal_dimension();
  
   double interpolated_lagrange = 0.0;
   for(unsigned l=0;l<n_node;l++)
    {
     //Note same shape functions used for lagrange multiplier field
     interpolated_lagrange += lagrange(l)*psif(l);
    }
  
   int local_eqn=0, local_unknown = 0;
  
   //Loop over the shape functions
   for(unsigned l=0;l<n_node;l++)
    {
     //Loop over the directions
     for(unsigned i=0;i<nodal_dimension;i++)
      {
       //Now using the same shape functions for the elastic equations,
       //so we can stay in the loop
       local_eqn = this->position_local_eqn(l,0,i);
       if(local_eqn >= 0)
        {
         //Add in the Lagrange multiplier contribution
         residuals[local_eqn] -= 
          interpolated_lagrange*interpolated_n[i]*psif(l)*J*W;
        
         //Do the Jacobian calculation
         if(flag)
          {
           //Loop over the nodes 
           for(unsigned l2=0;l2<n_node;l2++)
            {
             // Dependence on solid positions will be handled by FDs
             //That leaves the Lagrange multiplier contribution
             local_unknown = this->kinematic_local_eqn(l2);
             if(local_unknown >= 0)
              {
               jacobian(local_eqn,local_unknown) -=
                psif(l2)*interpolated_n[i]*psif(l)*J*W;
              }
            }
          } //End of Jacobian calculation
        } 
      } 
    
    }
  }
    
 
 
  /// \short Create an "bounding" element (here actually a 2D line element
  /// of type ElasticLineFluidInterfaceBoundingElement<ELEMENT> that allows
  /// the application of a contact angle boundary condition on the
  /// the specified face. 
  virtual FluidInterfaceBoundingElement* make_bounding_element(
   const int &face_index)
  {
   //Create a temporary pointer to the appropriate FaceElement
   BoundingElementType<ElasticUpdateFluidInterfaceElement<EQUATION_CLASS,
    DERIVATIVE_CLASS,ELEMENT> > *face_el_pt =
    new BoundingElementType<ElasticUpdateFluidInterfaceElement<EQUATION_CLASS,DERIVATIVE_CLASS,ELEMENT> >;
  
   //Attach the geometrical information to the new element
   this->build_face_element(face_index,face_el_pt);

   //Set the index at which the velocity nodes are stored
   face_el_pt->u_index_interface_boundary() = this->U_index_interface;
  
   //Set the value of the nbulk_value, the node is not resized
   //in this bounding element,
   //so it will just be the actual nvalue here
   // There is some ambiguity about what this means (however)
   const unsigned n_node_bounding = face_el_pt->nnode();
   //Storage for lagrange multiplier index at the face nodes
   Vector<unsigned> local_lagrange_index(n_node_bounding);
   for(unsigned n=0;n<n_node_bounding;n++)
    {
     face_el_pt->nbulk_value(n) =
      face_el_pt->node_pt(n)->nvalue();
     //At the moment the assumption is that it is stored at all nodes, but that is consistent with
     //the assumption in this element
     local_lagrange_index[n] = this->Lagrange_index[face_el_pt->bulk_node_number(n)];
    }
  
   //Pass the ID and offset down
   face_el_pt->set_lagrange_index(local_lagrange_index);
  
   //Find the nodes
   std::set<SolidNode*> set_of_solid_nodes;
   const unsigned n_node = this->nnode();
   for(unsigned n=0;n<n_node;n++)
    {
     set_of_solid_nodes.insert(static_cast<SolidNode*>(this->node_pt(n)));
    }
  
   //Delete the nodes from the face
   //n_node = face_el_pt->nnode();
   for(unsigned n=0;n<n_node_bounding;n++)
    {
     //Set the value of the nbulk_value, from the present element
     face_el_pt->nbulk_value(n) = 
      this->nbulk_value(face_el_pt->bulk_node_number(n));
    
     //Now delete the nodes from the set
     set_of_solid_nodes.erase(static_cast<SolidNode*>(
                               face_el_pt->node_pt(n)));
    }
  
   //Now add these as external data
   for(std::set<SolidNode*>::iterator it=set_of_solid_nodes.begin();
       it!=set_of_solid_nodes.end();++it)
    {
     face_el_pt->add_external_data((*it)->variable_position_pt());
    }
  
  
   //Return the value of the pointer
   return face_el_pt;
  }
 
 };

 
//=========================================================================
/// Pseudo-elasticity version of the PointFluidInterfaceBoundingElement
//========================================================================
 template<class ELEMENT>
  class ElasticPointFluidInterfaceBoundingElement : 
  public  FaceGeometry<FaceGeometry<ELEMENT> > ,
  public PointFluidInterfaceBoundingElement, public virtual SolidFiniteElement
 
 {
   private:
 
  /// Short Storage for the index of the Lagrange multiplier at the chosen nodes
  Vector<unsigned> Lagrange_index;
 
   public:
 
  ///\short Set the Id and offset
  void set_lagrange_index(const Vector<unsigned> &lagrange_index)
  {Lagrange_index = lagrange_index;}
 
 
  /// \short Specify the value of nodal zeta from the face geometry
  /// The "global" intrinsic coordinate of the element when
  /// viewed as part of a geometric object should be given by
  /// the FaceElement representation, by default
  double zeta_nodal(const unsigned &n, const unsigned &k,           
                    const unsigned &i) const 
  {return FaceElement::zeta_nodal(n,k,i);}     
 
 
  /// Constructor
   ElasticPointFluidInterfaceBoundingElement() : 
  FaceGeometry<FaceGeometry<ELEMENT> >(),
   PointFluidInterfaceBoundingElement() {}
 
  /// Overload the output function
  void output(std::ostream &outfile) {FiniteElement::output(outfile);}
 
  /// Output the element
  void output(std::ostream &outfile, const unsigned &n_plot)
  {FluidInterfaceBoundingElement::output(outfile,n_plot);}
 
  ///Overload the C-style output function
  void output(FILE* file_pt) {FiniteElement::output(file_pt);}
  
  ///C-style Output function
  void output(FILE* file_pt, const unsigned &n_plot)
  {FluidInterfaceBoundingElement::output(file_pt,n_plot);}
 
  /// Calculate the element's residual vector and Jacobian
  void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
                                        DenseMatrix<double> &jacobian)
  {
   //Call the generic routine with the flag set to 1
   fill_in_generic_residual_contribution_interface_boundary(residuals,
                                                            jacobian,1);
   //Call the generic FD routine to get external data
   this->fill_in_jacobian_from_external_by_fd(jacobian);
  
   //Call the generic finite difference routine to handle the solid variables
   this->fill_in_jacobian_from_solid_position_by_fd(jacobian);
  }
 
  ///Set the kinematic local equation
  inline int kinematic_local_eqn(const unsigned &n)
  {
   return this->nodal_local_eqn(n,this->Lagrange_index[n]);
  }
 
 }; 
 

//=========================================================================
/// Pseudo-elasticity version of the LineFluidInterfaceBoundingElement
//========================================================================
 template<class ELEMENT>
  class ElasticLineFluidInterfaceBoundingElement : 
  public  FaceGeometry<FaceGeometry<ELEMENT> > ,
  public LineFluidInterfaceBoundingElement, public virtual SolidFiniteElement
 
 {

  /// Short Storage for the index of Lagrange multiplier
  Vector<unsigned> Lagrange_index;
  
   public:
  
  ///\short Set the Id
  void set_lagrange_index(const Vector<unsigned> &lagrange_index)
  {Lagrange_index = lagrange_index;}
 
  /// Constructor
   ElasticLineFluidInterfaceBoundingElement() : 
  FaceGeometry<FaceGeometry<ELEMENT> >(),
   LineFluidInterfaceBoundingElement() {}
 
  /// \short Specify the value of nodal zeta from the face geometry
  /// The "global" intrinsic coordinate of the element when
  /// viewed as part of a geometric object should be given by
  /// the FaceElement representation, by default
  double zeta_nodal(const unsigned &n, const unsigned &k,           
                    const unsigned &i) const 
  {return FaceElement::zeta_nodal(n,k,i);}     

 
  /// Overload the output function
  void output(std::ostream &outfile) {FiniteElement::output(outfile);}
 
  /// Output the element
  void output(std::ostream &outfile, const unsigned &n_plot)
  {
   FluidInterfaceBoundingElement::output(outfile,n_plot);
  }
 
  ///Overload the C-style output function
  void output(FILE* file_pt) {FiniteElement::output(file_pt);}
 
  ///C-style Output function
  void output(FILE* file_pt, const unsigned &n_plot)
  {FluidInterfaceBoundingElement::output(file_pt,n_plot);}
 
  /// Calculate the elemental residual vector and Jacobian
  void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
                                        DenseMatrix<double> &jacobian)
  {
   //Call the generic routine with the flag set to 1
   fill_in_generic_residual_contribution_interface_boundary(residuals,jacobian,1);
  
   //Call the generic FD routine to get externals
   this->fill_in_jacobian_from_external_by_fd(jacobian);

   //Call the generic finite difference routine to handle the solid variables
   this->fill_in_jacobian_from_solid_position_by_fd(jacobian);
  }
 
  /// Local eqn number of kinematic bc associated with local node n
  int kinematic_local_eqn(const unsigned &n) 
  {
   //Read out the kinematic constraint from the Id which is passed down
   //from the constructing element
   return this->nodal_local_eqn(n,this->Lagrange_index[n]);
  }
 
 }; 


//==================GEOMETRIC SPECIALISATIONS==========================
 

///Specialise the elastic update template class to concrete 1D case
 template<class ELEMENT>
  class ElasticLineFluidInterfaceElement :
  public ElasticUpdateFluidInterfaceElement<FluidInterfaceElement,
  LineDerivatives,ELEMENT>
  {
    public:
 
    ElasticLineFluidInterfaceElement(
     FiniteElement* const &element_pt, 
     const int &face_index, const unsigned &id=0) : 
   ElasticUpdateFluidInterfaceElement<FluidInterfaceElement,
    LineDerivatives,ELEMENT>(element_pt,face_index,id) {}
  };

///Define the BoundingElement type associated with the 1D surface element
 template<class ELEMENT>
  class BoundingElementType<ElasticUpdateFluidInterfaceElement<
  FluidInterfaceElement,LineDerivatives,ELEMENT> >:
 public ElasticPointFluidInterfaceBoundingElement<ELEMENT>
 {
   public:
  
  BoundingElementType<ElasticUpdateFluidInterfaceElement<
   FluidInterfaceElement,LineDerivatives,ELEMENT> >() :
  ElasticPointFluidInterfaceBoundingElement<ELEMENT>() { }
 };


///Specialise the Elastic update case to axisymmetric equations
 template<class ELEMENT>
  class ElasticAxisymmetricFluidInterfaceElement :
  public ElasticUpdateFluidInterfaceElement<FluidInterfaceElement,
  AxisymmetricDerivatives,ELEMENT>
  {
    public:
 
    ElasticAxisymmetricFluidInterfaceElement(
     FiniteElement* const &element_pt, 
     const int &face_index, const unsigned &id=0) : 
   ElasticUpdateFluidInterfaceElement<
    FluidInterfaceElement,AxisymmetricDerivatives,ELEMENT>(
     element_pt,face_index,id) {}
  };

//Define the bounding element associated with the axsymmetric elastic fluid interface element
 template<class ELEMENT>
  class BoundingElementType<ElasticUpdateFluidInterfaceElement<
  FluidInterfaceElement,AxisymmetricDerivatives,ELEMENT> >:
 public ElasticPointFluidInterfaceBoundingElement<ELEMENT>
 {
   public:
  
  BoundingElementType<ElasticUpdateFluidInterfaceElement<
   FluidInterfaceElement,AxisymmetricDerivatives,ELEMENT> >() :
  ElasticPointFluidInterfaceBoundingElement<ELEMENT>() { }
 };


///Specialise Elastic update case to the concrete 2D case
 template<class ELEMENT>
  class ElasticSurfaceFluidInterfaceElement :
  public ElasticUpdateFluidInterfaceElement<FluidInterfaceElement,
  SurfaceDerivatives,ELEMENT>
  {
    public:
 
    ElasticSurfaceFluidInterfaceElement(
     FiniteElement* const &element_pt, 
     const int &face_index, const unsigned &id=0) : 
   ElasticUpdateFluidInterfaceElement<FluidInterfaceElement,
    SurfaceDerivatives,ELEMENT>(element_pt,face_index,id) {}
  };


//Define the bounding element associated with the 2D surface elements
 template<class ELEMENT>
  class BoundingElementType<ElasticUpdateFluidInterfaceElement<
  FluidInterfaceElement,SurfaceDerivatives,ELEMENT> >:
 public ElasticLineFluidInterfaceBoundingElement<ELEMENT>
 {
   public:
  
  BoundingElementType<ElasticUpdateFluidInterfaceElement<
   FluidInterfaceElement,SurfaceDerivatives,ELEMENT> >() :
  ElasticLineFluidInterfaceBoundingElement<ELEMENT>() { }
 };


 
}

#endif






