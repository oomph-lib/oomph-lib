// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC// Copyright (C) 2006-2021 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
// Header file for elements that are used to apply surface loads to
// the Darcy equations

#ifndef OOMPH_AXISYM_POROELASITICTY_FACE_ELEMENTS_HEADER
#define OOMPH_AXISYM_POROELASITICTY_FACE_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif


// OOMPH-LIB headers
#include "generic/Qelements.h"
#include "generic/element_with_external_element.h"

namespace oomph
{
  //=======================================================================
  /// Namespace containing the zero pressure function for Darcy pressure
  /// elements
  //=======================================================================
  namespace AxisymmetricPoroelasticityTractionElementHelper
  {
    //=======================================================================
    /// Default load function (zero traction)
    //=======================================================================
    void Zero_traction_fct(const double& time,
                           const Vector<double>& x,
                           const Vector<double>& N,
                           Vector<double>& load)
    {
      unsigned n_dim = load.size();
      for (unsigned i = 0; i < n_dim; i++)
      {
        load[i] = 0.0;
      }
    }

    //=======================================================================
    /// Default load function (zero pressure)
    //=======================================================================
    void Zero_pressure_fct(const double& time,
                           const Vector<double>& x,
                           const Vector<double>& N,
                           double& load)
    {
      load = 0.0;
    }

    /// Public boolean to allow gap between poro-elastic and Navier
    /// Stokes element in FSI computations. Useful in hybrid linear/nonlinear
    /// geometry runs where this will happen
    bool Allow_gap_in_FSI = false;

  } // namespace AxisymmetricPoroelasticityTractionElementHelper


  //======================================================================
  /// A class for elements that allow the imposition of an applied combined
  /// traction and pore fluid pressure in the axisym poroelasticity equations.
  /// The geometrical information can be read from the FaceGeometry<ELEMENT>
  /// class and thus, we can be generic enough without the need to have
  /// a separate equations class.
  //======================================================================
  template<class ELEMENT>
  class AxisymmetricPoroelasticityTractionElement
    : public virtual FaceGeometry<ELEMENT>,
      public virtual FaceElement
  {
  protected:
    /// Pointer to an imposed traction function. Arguments:
    /// Eulerian coordinate; outer unit normal; applied traction.
    /// (Not all of the input arguments will be required for all specific load
    /// functions but the list should cover all cases)
    void (*Traction_fct_pt)(const double& time,
                            const Vector<double>& x,
                            const Vector<double>& n,
                            Vector<double>& result);

    /// Pointer to an imposed pressure function. Arguments:
    /// Eulerian coordinate; outer unit normal; applied pressure.
    /// (Not all of the input arguments will be required for all specific load
    /// functions but the list should cover all cases)
    void (*Pressure_fct_pt)(const double& time,
                            const Vector<double>& x,
                            const Vector<double>& n,
                            double& result);


    /// Get the traction vector: Pass number of integration point
    /// (dummy), Eulerrian coordinate and normal vector and return the pressure
    /// (not all of the input arguments will be required for all specific load
    /// functions but the list should cover all cases). This function is virtual
    /// so it can be overloaded for FSI.
    virtual void get_traction(const double& time,
                              const unsigned& intpt,
                              const Vector<double>& x,
                              const Vector<double>& n,
                              Vector<double>& traction)
    {
      Traction_fct_pt(time, x, n, traction);
    }

    /// Get the pressure value: Pass number of integration point (dummy),
    /// Eulerrian coordinate and normal vector and return the pressure
    /// (not all of the input arguments will be required for all specific load
    /// functions but the list should cover all cases). This function is virtual
    /// so it can be overloaded for FSI.
    virtual void get_pressure(const double& time,
                              const unsigned& intpt,
                              const Vector<double>& x,
                              const Vector<double>& n,
                              double& pressure)
    {
      Pressure_fct_pt(time, x, n, pressure);
    }


    /// Helper function that actually calculates the residuals
    // This small level of indirection is required to avoid calling
    // fill_in_contribution_to_residuals in fill_in_contribution_to_jacobian
    // which causes all kinds of pain if overloading later on
    void fill_in_contribution_to_residuals_axisym_poroelasticity_face(
      Vector<double>& residuals);


  public:
    /// Constructor, which takes a "bulk" element and the value of the
    /// index and its limit
    AxisymmetricPoroelasticityTractionElement(FiniteElement* const& element_pt,
                                              const int& face_index)
      : FaceGeometry<ELEMENT>(), FaceElement()
    {
#ifdef PARANOID
      {
        // Check that the element is not a refineable 3d element
        ELEMENT* elem_pt = dynamic_cast<ELEMENT*>(element_pt);
        // If it's three-d
        if (elem_pt->dim() == 3)
        {
          // Is it refineable
          RefineableElement* ref_el_pt =
            dynamic_cast<RefineableElement*>(elem_pt);
          if (ref_el_pt != 0)
          {
            if (this->has_hanging_nodes())
            {
              throw OomphLibError("This flux element will not work correctly "
                                  "if nodes are hanging\n",
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
            }
          }
        }
      }
#endif

      // Attach the geometrical information to the element. N.B. This function
      // also assigns nbulk_value from the required_nvalue of the bulk element
      element_pt->build_face_element(face_index, this);

      // Zero traction
      Traction_fct_pt =
        &AxisymmetricPoroelasticityTractionElementHelper::Zero_traction_fct;

      // Zero pressure
      Pressure_fct_pt =
        &AxisymmetricPoroelasticityTractionElementHelper::Zero_pressure_fct;
    }


    /// Default constructor
    AxisymmetricPoroelasticityTractionElement() {}

    /// Reference to the traction function pointer
    void (*&traction_fct_pt())(const double& time,
                               const Vector<double>& x,
                               const Vector<double>& n,
                               Vector<double>& traction)
    {
      return Traction_fct_pt;
    }


    /// Reference to the pressure function pointer
    void (*&pressure_fct_pt())(const double& time,
                               const Vector<double>& x,
                               const Vector<double>& n,
                               double& pressure)
    {
      return Pressure_fct_pt;
    }


    /// Return the residuals
    void fill_in_contribution_to_residuals(Vector<double>& residuals)
    {
      fill_in_contribution_to_residuals_axisym_poroelasticity_face(residuals);
    }


    /// Fill in contribution from Jacobian
    void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                          DenseMatrix<double>& jacobian)
    {
      // Call the residuals (element makes no contribution to Jacobian)
      fill_in_contribution_to_residuals_axisym_poroelasticity_face(residuals);
    }

    /// Specify the value of nodal zeta from the face geometry
    /// The "global" intrinsic coordinate of the element when
    /// viewed as part of a geometric object should be given by
    /// the FaceElement representation, by default (needed to break
    /// indeterminacy if bulk element is SolidElement)
    double zeta_nodal(const unsigned& n,
                      const unsigned& k,
                      const unsigned& i) const
    {
      return FaceElement::zeta_nodal(n, k, i);
    }

    /// Output function
    void output(std::ostream& outfile)
    {
      unsigned n_plot = 5;
      output(outfile, n_plot);
    }


    /// Output function
    void output(std::ostream& outfile, const unsigned& n_plot)
    {
      // Get continuous time from timestepper of first node
      double time = node_pt(0)->time_stepper_pt()->time_pt()->time();
      unsigned n_dim = this->nodal_dimension();

      // Find out how many nodes there are
      unsigned n_node = nnode();

      Vector<double> x(n_dim);
      Vector<double> s(n_dim - 1);
      Vector<double> s_bulk(n_dim);
      Vector<double> disp(n_dim);
      Shape psi(n_node);
      DShape dpsids(n_node, n_dim - 1);

      // Tecplot header info
      outfile << this->tecplot_zone_string(n_plot);

      // Loop over plot points
      unsigned num_plot_points = this->nplot_points(n_plot);
      for (unsigned iplot = 0; iplot < num_plot_points; iplot++)
      {
        // Get local coordinates of plot point
        this->get_s_plot(iplot, n_plot, s);

        // Call the derivatives of the shape function at the knot point
        this->dshape_local(s, psi, dpsids);

        // Get pointer to bulk element
        ELEMENT* bulk_pt = dynamic_cast<ELEMENT*>(bulk_element_pt());
        s_bulk = local_coordinate_in_bulk(s);


        // Get Eulerian coordinates
        this->interpolated_x(s, x);

        // Outer unit normal
        Vector<double> unit_normal(n_dim);
        outer_unit_normal(s, unit_normal);

        /// Calculate the FE representation of u -- the skeleton displacement
        bulk_pt->interpolated_u(s_bulk, disp);

        /// Skeleton velocity
        Vector<double> du_dt(2);
        bulk_pt->interpolated_du_dt(s_bulk, du_dt);

        // Porous seepage flux
        Vector<double> q(2);
        bulk_pt->interpolated_q(s_bulk, q);

        // Get permeability from the bulk poroelasticity element
        const double permeability = bulk_pt->permeability();


        // Surface area: S = 2 \pi \int r \sqrt((dr/ds)^2+(dz/ds)^2) ds
        //                 = 2 \pi \int r \sqrt( 1 + ( (dr/ds)/(dz/ds) )^2 )
        //                 dz/ds ds = 2 \pi \int J dz
        // where J is an objective measure of the length of the line element
        // (indep of local coordinates) so should be the same from fluid
        // and solid.

        // Get deformed and undeformed tangent vectors
        Vector<double> interpolated_t1(2, 0.0);
        Vector<double> interpolated_T1(2, 0.0);
        for (unsigned l = 0; l < n_node; l++)
        {
          // Loop over directional components
          for (unsigned i = 0; i < 2; i++)
          {
            // Index at which the nodal value is stored
            unsigned u_nodal_index = bulk_pt->u_index_axisym_poroelasticity(i);

            interpolated_t1[i] += this->nodal_position(l, i) * dpsids(l, 0);
            interpolated_T1[i] +=
              (this->nodal_position(l, i) + nodal_value(l, u_nodal_index)) *
              dpsids(l, 0);
          }
        }

        // Set the Jacobian of the undeformed line element
        double J_undef =
          sqrt(1.0 + (interpolated_t1[0] * interpolated_t1[0]) /
                       (interpolated_t1[1] * interpolated_t1[1])) *
          x[0];


        // Set the Jacobian of the deformed line element
        double J_def = sqrt(1.0 + (interpolated_T1[0] * interpolated_T1[0]) /
                                    (interpolated_T1[1] * interpolated_T1[1])) *
                       (x[0] + disp[0]);

        // Dummy
        unsigned ipt = 0;

        // Now calculate the traction load
        Vector<double> traction(n_dim);
        get_traction(time, ipt, x, unit_normal, traction);

        // Now calculate the load
        double pressure;
        get_pressure(time, ipt, x, unit_normal, pressure);

        // Get correction factor for geometry
        double lagr_euler_translation_factor =
          lagrangian_eulerian_translation_factor(s);

        // Output the x,y,..
        for (unsigned i = 0; i < n_dim; i++)
        {
          outfile << x[i] << " ";
        } // column 1,2

        // Output displacement
        for (unsigned i = 0; i < n_dim; i++)
        {
          outfile << disp[i] << " "; // column 3,4
        }

        // Output imposed traction
        for (unsigned i = 0; i < n_dim; i++)
        {
          outfile << traction[i] << " "; // column 5,6
        }

        // Output imposed pressure
        outfile << pressure << " "; // column 7

        // Output seepage flux
        outfile << permeability * q[0] << " " // column 8
                << permeability * q[1] << " "; // column 9

        // Output skeleton velocity
        outfile << du_dt[0] << " " // column 10
                << du_dt[1] << " "; // column 11

        // Total veloc
        outfile << du_dt[0] + permeability * q[0] << " " // column 12
                << du_dt[1] + permeability * q[1] << " "; // column 13

        // Outer unit normal
        outfile << unit_normal[0] << " " // column 14
                << unit_normal[1] << " "; // column 15

        // Output FE representation of div u at s_bulk
        outfile << bulk_pt->interpolated_div_q(s_bulk) << " "; // column 16

        // Output FE representation of p at s_bulk
        outfile << bulk_pt->interpolated_p(s_bulk) << " "; // column 17

        // Output undeformed jacobian
        outfile << J_undef << " "; // column 18

        // Output deformed jacobian
        outfile << J_def << " "; // column 19

        // Lagranian/Eulerian translation factor
        outfile << lagr_euler_translation_factor << " "; // column 20

        outfile << std::endl;
      }

      // Write tecplot footer (e.g. FE connectivity lists)
      this->write_tecplot_zone_footer(outfile, n_plot);
    }

    /// C_style output function
    void output(FILE* file_pt)
    {
      FaceGeometry<ELEMENT>::output(file_pt);
    }

    /// C-style output function
    void output(FILE* file_pt, const unsigned& n_plot)
    {
      FaceGeometry<ELEMENT>::output(file_pt, n_plot);
    }


    /// Ratio of lengths of line elements (or annular surface areas)
    /// in the undeformed and deformed configuration (needed to translate
    /// normal flux correctly between small displacement formulation used
    /// here and the possibly large displacement NSt formulation used in
    /// FSI problems. Maths is as follows:
    /// Surface area: A = 2 \pi \int r \sqrt((dr/ds)^2+(dz/ds)^2) ds
    ///                 = 2 \pi \int J ds
    /// This function returns the ratio of J in the undeformed
    /// configuration (used here) to that in the deformed configuration
    /// where (r,z) = (r,z)_undef + (u_r,u_z).
    double lagrangian_eulerian_translation_factor(const Vector<double>& s)
    {
      // Get continuous time from timestepper of first node
      unsigned n_dim = this->nodal_dimension();

      // Find out how many nodes there are
      unsigned n_node = nnode();

      Vector<double> x(n_dim);
      Vector<double> s_bulk(n_dim);
      Vector<double> disp(n_dim);
      Shape psi(n_node);
      DShape dpsids(n_node, n_dim - 1);

      // Call the derivatives of the shape function at the knot point
      this->dshape_local(s, psi, dpsids);

      // Get pointer to bulk element
      ELEMENT* bulk_pt = dynamic_cast<ELEMENT*>(bulk_element_pt());
      s_bulk = local_coordinate_in_bulk(s);

      // Get Eulerian coordinates
      this->interpolated_x(s, x);

      // Outer unit normal
      Vector<double> unit_normal(n_dim);
      outer_unit_normal(s, unit_normal);

      /// Calculate the FE representation of u -- the skeleton displacement
      bulk_pt->interpolated_u(s_bulk, disp);

      // Get deformed and undeformed tangent vectors
      Vector<double> interpolated_t1(2, 0.0);
      Vector<double> interpolated_T1(2, 0.0);
      for (unsigned l = 0; l < n_node; l++)
      {
        // Loop over directional components
        for (unsigned i = 0; i < 2; i++)
        {
          // Index at which the nodal value is stored
          unsigned u_nodal_index = bulk_pt->u_index_axisym_poroelasticity(i);

          interpolated_t1[i] += this->nodal_position(l, i) * dpsids(l, 0);
          interpolated_T1[i] +=
            (this->nodal_position(l, i) + nodal_value(l, u_nodal_index)) *
            dpsids(l, 0);
        }
      }

      // Set the Jacobian of the undeformed line element
      double J_undef = sqrt(interpolated_t1[0] * interpolated_t1[0] +
                            interpolated_t1[1] * interpolated_t1[1]) *
                       x[0];


      // Set the Jacobian of the deformed line element
      double J_def = sqrt(interpolated_T1[0] * interpolated_T1[0] +
                          interpolated_T1[1] * interpolated_T1[1]) *
                     (x[0] + disp[0]);

      double return_val = 1.0;
      if (J_def != 0.0) return_val = J_undef / J_def;
      return return_val;
    }

    /// Compute traction vector at specified local coordinate
    /// Should only be used for post-processing; ignores dependence
    /// on integration point!
    void traction(const double& time,
                  const Vector<double>& s,
                  Vector<double>& traction);

    /// Compute pressure value at specified local coordinate
    /// Should only be used for post-processing; ignores dependence
    /// on integration point!
    void pressure(const double& time,
                  const Vector<double>& s,
                  double& pressure);


    /// Compute contributions to integrated porous flux over boundary:
    /// q_skeleton = \int \partial u_displ / \partial t \cdot n ds
    /// q_seepage  = \int k q \cdot n ds
    void contribution_to_total_porous_flux(double& skeleton_flux_contrib,
                                           double& seepage_flux_contrib)
    {
      // Get pointer to bulk element
      ELEMENT* bulk_el_pt = dynamic_cast<ELEMENT*>(bulk_element_pt());

      // Get permeability from the bulk poroelasticity element
      const double permeability = bulk_el_pt->permeability();

      // Find out how many nodes there are
      const unsigned n_node = this->nnode();

      // Set up memeory for the shape functions
      Shape psi(n_node);
      DShape dpsids(n_node, 1);

      // Get the value of Nintpt
      const unsigned n_intpt = integral_pt()->nweight();

      // Set the Vector to hold local coordinates
      Vector<double> s(1);
      Vector<double> s_bulk(2);

      // Loop over the integration points
      skeleton_flux_contrib = 0.0;
      seepage_flux_contrib = 0.0;
      for (unsigned ipt = 0; ipt < n_intpt; ipt++)
      {
        // Assign values of s
        s[0] = integral_pt()->knot(ipt, 0);

        // Get the integral weight
        double W = this->integral_pt()->weight(ipt);

        // Call the derivatives of the shape function at the knot point
        this->dshape_local_at_knot(ipt, psi, dpsids);

        // Get position and tangent vector
        Vector<double> interpolated_t1(2, 0.0);
        Vector<double> interpolated_x(2, 0.0);
        for (unsigned l = 0; l < n_node; l++)
        {
          // Loop over directional components
          for (unsigned i = 0; i < 2; i++)
          {
            interpolated_x[i] += this->nodal_position(l, i) * psi(l);
            interpolated_t1[i] += this->nodal_position(l, i) * dpsids(l, 0);
          }
        }

        // Calculate the length of the tangent Vector
        double tlength = interpolated_t1[0] * interpolated_t1[0] +
                         interpolated_t1[1] * interpolated_t1[1];

        // Set the Jacobian of the line element
        double J = sqrt(tlength) * interpolated_x[0];

        // Get the outer unit normal
        Vector<double> interpolated_normal(2);
        outer_unit_normal(s, interpolated_normal);

        // Get coordinate in bulk element
        s_bulk = this->local_coordinate_in_bulk(s);

        /// Calculate the FE representation of q
        Vector<double> q(2);
        bulk_el_pt->interpolated_q(s_bulk, q);

        // Skeleton velocity from bulk
        Vector<double> du_dt(2);
        bulk_el_pt->interpolated_du_dt(s_bulk, du_dt);

#ifdef PARANOID
        Vector<double> x_bulk(2);
        x_bulk[0] = bulk_el_pt->interpolated_x(s_bulk, 0);
        x_bulk[1] = bulk_el_pt->interpolated_x(s_bulk, 1);
        double error = sqrt(
          (interpolated_x[0] - x_bulk[0]) * (interpolated_x[0] - x_bulk[0]) +
          (interpolated_x[1] - x_bulk[1]) * (interpolated_x[1] - x_bulk[1]));
        double tol = 1.0e-10;
        if (error > tol)
        {
          std::stringstream junk;
          junk << "Gap between bulk and face element coordinate\n"
               << "is suspiciously large: " << error
               << "\nBulk at: " << x_bulk[0] << " " << x_bulk[1] << "\n"
               << "Face at: " << interpolated_x[0] << " " << interpolated_x[1]
               << "\n";
          OomphLibWarning(
            junk.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // Get net flux through boundary
        double q_flux = 0.0;
        double dudt_flux = 0.0;
        for (unsigned i = 0; i < 2; i++)
        {
          q_flux += permeability * q[i] * interpolated_normal[i];
          dudt_flux += du_dt[i] * interpolated_normal[i];
        }

        // Add
        seepage_flux_contrib +=
          2.0 * MathematicalConstants::Pi * q_flux * W * J;
        skeleton_flux_contrib +=
          2.0 * MathematicalConstants::Pi * dudt_flux * W * J;
      }
    }
  };

  ///////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////

  //=====================================================================
  /// Compute traction vector at specified local coordinate
  /// Should only be used for post-processing; ignores dependence
  /// on integration point!
  //=====================================================================
  template<class ELEMENT>
  void AxisymmetricPoroelasticityTractionElement<ELEMENT>::traction(
    const double& time, const Vector<double>& s, Vector<double>& traction)
  {
    unsigned n_dim = this->nodal_dimension();

    // Position vector
    Vector<double> x(n_dim);
    interpolated_x(s, x);

    // Outer unit normal
    Vector<double> unit_normal(n_dim);
    outer_unit_normal(s, unit_normal);

    // Dummy
    unsigned ipt = 0;

    // Pressure value
    get_traction(time, ipt, x, unit_normal, traction);
  }

  //=====================================================================
  /// Compute pressure value at specified local coordinate
  /// Should only be used for post-processing; ignores dependence
  /// on integration point!
  //=====================================================================
  template<class ELEMENT>
  void AxisymmetricPoroelasticityTractionElement<ELEMENT>::pressure(
    const double& time, const Vector<double>& s, double& pressure)
  {
    unsigned n_dim = this->nodal_dimension();

    // Position vector
    Vector<double> x(n_dim);
    interpolated_x(s, x);

    // Outer unit normal
    Vector<double> unit_normal(n_dim);
    outer_unit_normal(s, unit_normal);

    // Dummy
    unsigned ipt = 0;

    // Pressure value
    get_pressure(time, ipt, x, unit_normal, pressure);
  }


  //=====================================================================
  /// Return the residuals for the AxisymmetricPoroelasticityTractionElement
  /// equations
  //=====================================================================
  template<class ELEMENT>
  void AxisymmetricPoroelasticityTractionElement<ELEMENT>::
    fill_in_contribution_to_residuals_axisym_poroelasticity_face(
      Vector<double>& residuals)
  {
    // Find out how many nodes there are
    unsigned n_node = nnode();

    // Get continuous time from timestepper of first node
    double time = node_pt(0)->time_stepper_pt()->time_pt()->time();

#ifdef PARANOID
    // Find out how many positional dofs there are
    unsigned n_position_type = this->nnodal_position_type();
    if (n_position_type != 1)
    {
      throw OomphLibError("Poroelasticity equations are not yet implemented "
                          "for more than one position type",
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Find out the dimension of the node
    unsigned n_dim = this->nodal_dimension();


    // Get bulk element
    ELEMENT* bulk_el_pt = dynamic_cast<ELEMENT*>(bulk_element_pt());

    unsigned n_q_basis = bulk_el_pt->nq_basis();
    unsigned n_q_basis_edge = bulk_el_pt->nq_basis_edge();

    // Integer to hold the local equation number
    int local_eqn = 0;

    // Set up memory for the shape functions
    // Note that in this case, the number of lagrangian coordinates is always
    // equal to the dimension of the nodes
    Shape psi(n_node);
    DShape dpsids(n_node, n_dim - 1);
    Shape q_basis(n_q_basis, n_dim);

    // Set the value of n_intpt
    unsigned n_intpt = integral_pt()->nweight();

    // Storage for the local coordinates
    Vector<double> s_face(n_dim - 1, 0.0), s_bulk(n_dim, 0.0);

    // Loop over the integration points
    for (unsigned ipt = 0; ipt < n_intpt; ipt++)
    {
      // Get the integral weight
      double w = integral_pt()->weight(ipt);

      // Only need to call the local derivatives
      dshape_local_at_knot(ipt, psi, dpsids);

      // Assign values of s in FaceElement and local coordinates in bulk element
      for (unsigned i = 0; i < n_dim - 1; i++)
      {
        s_face[i] = integral_pt()->knot(ipt, i);
      }
      s_bulk = local_coordinate_in_bulk(s_face);

      // Get bulk element
      ELEMENT* bulk_el_pt = dynamic_cast<ELEMENT*>(bulk_element_pt());

      // Get the q basis at bulk local coordinate s_bulk,
      // corresponding to face local
      // coordinate s_face
      bulk_el_pt->get_q_basis(s_bulk, q_basis);

      // Calculate the Eulerian and Lagrangian coordinates
      Vector<double> interpolated_x(n_dim, 0.0);

      // Also calculate the surface Vectors (derivatives wrt local coordinates)
      DenseMatrix<double> interpolated_A(n_dim - 1, n_dim, 0.0);

      // Calculate displacements and derivatives
      for (unsigned l = 0; l < n_node; l++)
      {
        // Loop over directions
        for (unsigned i = 0; i < n_dim; i++)
        {
          // Calculate the Eulerian coords
          const double x_local = nodal_position(l, i);
          interpolated_x[i] += x_local * psi(l);

          // Loop over LOCAL derivative directions, to calculate the tangent(s)
          for (unsigned j = 0; j < n_dim - 1; j++)
          {
            interpolated_A(j, i) += x_local * dpsids(l, j);
          }
        }
      }

      // Now find the local metric tensor from the tangent vectors
      DenseMatrix<double> A(n_dim - 1);
      for (unsigned i = 0; i < n_dim - 1; i++)
      {
        for (unsigned j = 0; j < n_dim - 1; j++)
        {
          // Initialise surface metric tensor to zero
          A(i, j) = 0.0;

          // Take the dot product
          for (unsigned k = 0; k < n_dim; k++)
          {
            A(i, j) += interpolated_A(i, k) * interpolated_A(j, k);
          }
        }
      }

      // Get the outer unit normal
      Vector<double> interpolated_normal(n_dim);
      outer_unit_normal(ipt, interpolated_normal);

      // Find the determinant of the metric tensor
      double Adet = 0.0;
      switch (n_dim)
      {
        case 2:
          Adet = A(0, 0);
          break;
        case 3:
          Adet = A(0, 0) * A(1, 1) - A(0, 1) * A(1, 0);
          break;
        default:
          throw OomphLibError(
            "Wrong dimension in AxisymmetricPoroelasticityTractionElement",
            OOMPH_CURRENT_FUNCTION,
            OOMPH_EXCEPTION_LOCATION);
      }

      // Premultiply the weights and the square-root of the determinant of
      // the metric tensor
      double W = w * sqrt(Adet);

      // Now calculate the traction load
      Vector<double> traction(n_dim);
      get_traction(time, ipt, interpolated_x, interpolated_normal, traction);

      // Now calculate the load
      double pressure;
      get_pressure(time, ipt, interpolated_x, interpolated_normal, pressure);

      // Loop over the test functions, nodes of the element
      for (unsigned l = 0; l < n_node; l++)
      {
        // Loop over the displacement components
        for (unsigned i = 0; i < n_dim; i++)
        {
          local_eqn = this->nodal_local_eqn(
            l, bulk_el_pt->u_index_axisym_poroelasticity(i));
          /*IF it's not a boundary condition*/
          if (local_eqn >= 0)
          {
            // Add the traction loading terms to the residuals
            residuals[local_eqn] -=
              traction[i] * psi(l) * interpolated_x[0] * W;
          } // End of if not boundary condition
        }
      } // End of loop over shape functions

      // Loop over the q edge test functions only (internal basis functions
      // have zero normal component on the boundary)
      for (unsigned l = 0; l < n_q_basis_edge; l++)
      {
        local_eqn = this->nodal_local_eqn(1, bulk_el_pt->q_edge_index(l));

        /*IF it's not a boundary condition*/
        if (local_eqn >= 0)
        {
          // Loop over the displacement components
          for (unsigned i = 0; i < n_dim; i++)
          {
            // Add the loading terms to the residuals
            residuals[local_eqn] += pressure * q_basis(l, i) *
                                    interpolated_normal[i] * interpolated_x[0] *
                                    W;
          }
        } // End of if not boundary condition
      } // End of loop over shape functions
    } // End of loop over integration points
  }

  ///////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////

  //======================================================================
  /// A class for elements that allow the imposition of an applied combined
  /// traction and pore fluid pressure in the poroelasticity equations.
  /// The geometrical information can be read from the FaceGeometry<ELEMENT>
  /// class and thus, we can be generic enough without the need to have
  /// a separate equations class.
  //======================================================================
  template<class POROELASTICITY_BULK_ELEMENT, class NAVIER_STOKES_BULK_ELEMENT>
  class FSILinearisedAxisymPoroelasticTractionElement
    : public virtual AxisymmetricPoroelasticityTractionElement<
        POROELASTICITY_BULK_ELEMENT>,
      public virtual ElementWithExternalElement
  {
  protected:
    /// Pointer to the ratio, \f$ Q \f$, of the stress used to
    /// non-dimensionalise the fluid stresses to the stress used to
    /// non-dimensionalise the poroelastic stresses.
    double* Q_pt;

    /// Static default value for the ratio of stress scales
    /// used in the fluid and poroelasticity equations (default is 1.0)
    static double Default_Q_Value;


  public:
    /// Return the ratio of the stress scales used to non-dimensionalise
    /// the fluid and poroelasticity equations.
    const double& q() const
    {
      return *Q_pt;
    }

    /// Return a pointer the ratio of stress scales used to
    /// non-dimensionalise the fluid and poroelastic equations.
    double*& q_pt()
    {
      return Q_pt;
    }

    /// Get the (combined) traction from the neighbouring Navier-Stokes
    /// bulk element's stress
    void get_traction(const double& time,
                      const unsigned& intpt,
                      const Vector<double>& x,
                      const Vector<double>& n,
                      Vector<double>& traction)
    {
      // Get traction from Navier-Stokes
      NAVIER_STOKES_BULK_ELEMENT* ext_el_pt =
        dynamic_cast<NAVIER_STOKES_BULK_ELEMENT*>(
          external_element_pt(0, intpt));
      Vector<double> s_ext(external_element_local_coord(0, intpt));

      // Find the dimension of the problem
      unsigned n_dim = this->nodal_dimension();

      // Get the outer unit normal
      Vector<double> interpolated_normal(n_dim);
      this->outer_unit_normal(intpt, interpolated_normal);

      // Get all 3 (r,z,theta) components of the nst traction
      Vector<double> traction_nst(3);
      ext_el_pt->traction(s_ext, interpolated_normal, traction_nst);


#ifdef PARANOID
      if (!AxisymmetricPoroelasticityTractionElementHelper::Allow_gap_in_FSI)
      {
        // Get own coordinates:
        Vector<double> s(n_dim - 1);
        for (unsigned i = 0; i < (n_dim - 1); i++)
        {
          s[i] = integral_pt()->knot(intpt, i);
        }
        Vector<double> x_local(n_dim);
        this->interpolated_x(s, x_local);

        // Get bulk coordinates in external element
        Vector<double> x_bulk(n_dim);
        x_bulk[0] = ext_el_pt->interpolated_x(s_ext, 0);
        x_bulk[1] = ext_el_pt->interpolated_x(s_ext, 1);
        double error =
          sqrt((x_local[0] - x_bulk[0]) * (x_local[0] - x_bulk[0]) +
               (x_local[1] - x_bulk[1]) * (x_local[1] - x_bulk[1]));
        double tol = 1.0e-10;
        if (error > tol)
        {
          std::stringstream junk;
          junk << "Gap between external and face element coordinate\n"
               << "is suspiciously large:" << error << " ( tol = " << tol
               << " ) "
               << "\nExternal/bulk at: " << x_bulk[0] << " " << x_bulk[1]
               << "\n"
               << "Face at: " << x_local[0] << " " << x_local[1] << "\n";
          throw OomphLibError(
            junk.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
        }
      }
#endif


      // Get FSI parameter
      const double q_value = q();

      // Just assign the r and z components - we require the NST "swirl"
      // velocity to be 0 since axisym_poroelasticity doesn't support a theta
      // component. Premulitply by the FSI parameter Q
      traction[0] = q_value * traction_nst[0];
      traction[1] = q_value * traction_nst[1];
    }

    /// Get the pore fluid pressure from the neighbouring Navier-Stokes
    /// bulk element's stress
    void get_pressure(const double& time,
                      const unsigned& intpt,
                      const Vector<double>& x,
                      const Vector<double>& n,
                      double& pressure)
    {
      // Get pressure from Navier-Stokes
      NAVIER_STOKES_BULK_ELEMENT* ext_el_pt =
        dynamic_cast<NAVIER_STOKES_BULK_ELEMENT*>(
          external_element_pt(0, intpt));
      Vector<double> s_ext(external_element_local_coord(0, intpt));

      // Find the dimension of the problem
      unsigned n_dim = this->nodal_dimension();

      // Get the outer unit normal
      Vector<double> interpolated_normal(n_dim);
      this->outer_unit_normal(intpt, interpolated_normal);

      // Get all 3 components of the nst traction
      Vector<double> traction_nst(3);
      ext_el_pt->traction(s_ext, interpolated_normal, traction_nst);

      // Get FSI parameter
      const double q_value = q();

      // Just use the r and z components the calculate the pore pressure - we
      // require the "swirl" nst velocity to be 0 since axisym_poroelasticity
      // doesn't support a theta component. Premultiply by the FSI parameter Q
      pressure = -q_value * (interpolated_normal[0] * traction_nst[0] +
                             interpolated_normal[1] * traction_nst[1]);
    }

  public:
    /// Constructor, which takes a "bulk" element and the
    /// value of the index and its limit
    FSILinearisedAxisymPoroelasticTractionElement(
      FiniteElement* const& element_pt, const int& face_index)
      : AxisymmetricPoroelasticityTractionElement<POROELASTICITY_BULK_ELEMENT>(
          element_pt, face_index),
        Q_pt(&Default_Q_Value)
    {
      // Set source element storage: one interaction with an external
      // element -- the Navier Stokes bulk element that provides the traction
      this->set_ninteraction(1);
    }

    /// Default constructor
    FSILinearisedAxisymPoroelasticTractionElement() {}

    /// Output function -- overloaded version -- ignores
    /// n_plot since fsi elements can only evaluate traction at
    /// Gauss points.
    void output(std::ostream& outfile, const unsigned& n_plot)
    {
      // Get continuous time from timestepper of first node
      double time = node_pt(0)->time_stepper_pt()->time_pt()->time();
      unsigned n_dim = this->nodal_dimension();

      Vector<double> x(n_dim);
      Vector<double> s(n_dim - 1);
      Vector<double> s_bulk(n_dim);
      Vector<double> disp(n_dim);

      // Set the value of n_intpt
      unsigned n_intpt = integral_pt()->nweight();

      // Tecplot header info
      outfile << this->tecplot_zone_string(n_intpt);

      // Loop over the integration points
      for (unsigned ipt = 0; ipt < n_intpt; ipt++)
      {
        // Assign values of s in FaceElement and local coordinates in bulk
        // element
        for (unsigned i = 0; i < n_dim - 1; i++)
        {
          s[i] = integral_pt()->knot(ipt, i);
        }

        // Get Eulerian coordinates
        this->interpolated_x(s, x);

        // Outer unit normal
        Vector<double> unit_normal(n_dim);
        this->outer_unit_normal(s, unit_normal);

        // Get pointer to bulk element
        POROELASTICITY_BULK_ELEMENT* bulk_pt =
          dynamic_cast<POROELASTICITY_BULK_ELEMENT*>(this->bulk_element_pt());
        s_bulk = this->local_coordinate_in_bulk(s);

        // Get permeability from the bulk poroelasticity element
        const double local_permeability = bulk_pt->permeability();

        // Porous seepage flux
        Vector<double> q(2);
        bulk_pt->interpolated_q(s_bulk, q);

        /// Calculate the FE representation of u
        bulk_pt->interpolated_u(s_bulk, disp);

        // Now calculate the traction load
        Vector<double> traction(n_dim);
        this->get_traction(time, ipt, x, unit_normal, traction);

        // Now calculate the load
        double pressure;
        this->get_pressure(time, ipt, x, unit_normal, pressure);


        // Output the x,y,..
        for (unsigned i = 0; i < n_dim; i++)
        {
          outfile << x[i] << " ";
        } // column 1,2

        // Output displacement
        for (unsigned i = 0; i < n_dim; i++)
        {
          outfile << disp[i] << " "; // column 3,4
        }

        // Output traction
        for (unsigned i = 0; i < n_dim; i++)
        {
          outfile << traction[i] << " "; // column 5,6
        }

        // Output pressure
        outfile << pressure << " "; // column 7

        // Output seepage flux
        outfile << local_permeability * q[0] << " " // column 8
                << local_permeability * q[1] << " "; // column 9

        // Output skeleton velocity
        Vector<double> du_dt(2);
        bulk_pt->interpolated_du_dt(s_bulk, du_dt);
        outfile << du_dt[0] << " " // column 10
                << du_dt[1] << " "; // column 11

        // Total veloc
        outfile << du_dt[0] + local_permeability * q[0] << " " // column 12
                << du_dt[1] + local_permeability * q[1] << " "; // column 13

        // Outer unit normal
        outfile << unit_normal[0] << " " // column 14
                << unit_normal[1] << " "; // column 15

        // Output FE representation of div u at s_bulk
        outfile << bulk_pt->interpolated_div_q(s_bulk) << " "; // column 16

        // Output FE representation of p at s_bulk
        outfile << bulk_pt->interpolated_p(s_bulk) << " "; // column 17
        outfile << std::endl;
      }

      // Write tecplot footer (e.g. FE connectivity lists)
      this->write_tecplot_zone_footer(outfile, n_plot);
    }


    /// Fill in contribution from Jacobian
    void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                          DenseMatrix<double>& jacobian)
    {
      // Call the residuals
      this->fill_in_contribution_to_residuals_axisym_poroelasticity_face(
        residuals);

      // Derivatives w.r.t. external data
      fill_in_jacobian_from_external_interaction_by_fd(residuals, jacobian);
    }
  };

  //=================================================================
  /// Static default value for the ratio of stress scales
  /// used in the fluid and solid equations (default is 1.0)
  //=================================================================
  template<class POROELASTICITY_BULK_ELEMENT, class NAVIER_STOKES_BULK_ELEMENT>
  double FSILinearisedAxisymPoroelasticTractionElement<
    POROELASTICITY_BULK_ELEMENT,
    NAVIER_STOKES_BULK_ELEMENT>::Default_Q_Value = 1.0;

} // namespace oomph
#endif
