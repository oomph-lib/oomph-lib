//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
#ifndef OOMPH_TRIANGLE_MESH_HEADER
#define OOMPH_TRIANGLE_MESH_HEADER
// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

#ifdef OOMPH_HAS_MPI
//mpi headers
#include <mpi.h>
#endif

//Standards
#include<float.h>
#include <iostream>
#include <fstream>
#include <string.h>

#include "../generic/problem.h" 
#include "../generic/triangle_scaffold_mesh.h" 
#include "../generic/triangle_mesh.h"
#include "../generic/refineable_mesh.h"
#include "../rigid_body/immersed_rigid_body_elements.h"


namespace oomph
{

#ifdef OOMPH_HAS_TRIANGLE_LIB

// Interface to triangulate function
extern "C" {
 void triangulate(char *triswitches, struct oomph::TriangulateIO *in,
                  struct oomph::TriangulateIO *out, 
                  struct oomph::TriangulateIO *vorout);
}

#endif




////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////




//=========================================================================
/// \short Helper object for dealing with the parameters used for the
/// TriangleMesh objects
//=========================================================================
class TriangleMeshParameters
{

 public:

 /// Constructor: It can take all the parameters or just the outer boundary
 TriangleMeshParameters(TriangleMeshClosedCurve *outer_boundary_pt)
  : Outer_boundary_pt(outer_boundary_pt),
  Element_area(0.2),
  Use_attributes(false), Boundary_refinement(true), 
  Internal_boundary_refinement(true)
  { }
 
 /// Empty destructor
 virtual ~TriangleMeshParameters() { }
 
 /// Helper function for getting the outer boundary
 TriangleMeshClosedCurve *outer_boundary_pt() const
  {return Outer_boundary_pt;}

 /// Helper function for getting access to the outer boundary
 TriangleMeshClosedCurve* &outer_boundary_pt()
  {return Outer_boundary_pt;}
  
 /// Helper function for getting the internal closed boundaries
 Vector<TriangleMeshClosedCurve*> internal_closed_curve_pt() const
  {return Internal_closed_curve_pt;}
  
 /// \short Helper function for getting access to the internal
 /// closed boundaries
 Vector<TriangleMeshClosedCurve*> &internal_closed_curve_pt()
  {return Internal_closed_curve_pt;}

 /// Helper function for getting the internal open boundaries
 Vector<TriangleMeshOpenCurve*> internal_open_curves_pt() const
  {return Internal_open_curves_pt;}
 
 /// \short Helper function for getting access to the internal
 /// open boundaries
 Vector<TriangleMeshOpenCurve*> &internal_open_curves_pt()
  {return Internal_open_curves_pt;}
 
 /// Helper function for getting the element area
 double element_area() const {return Element_area;}

 /// Helper function for getting access to the element area
 double &element_area(){return Element_area;}

 /// Helper function for getting the extra holes
 Vector<Vector<double> > extra_holes_coordinates() const
  {return Extra_holes_coordinates;}
 
 /// Helper function for getting access to the extra holes
 Vector<Vector<double> > &extra_holes_coordinates()
  {return Extra_holes_coordinates;}

 /// Helper function for getting the extra regions
 void add_region_coordinates(const unsigned &i,
                             Vector<double> &region_coordinates)
  {
   // Verify if not using the default region number (zero)
   if (i == 0) 
    {
     std::ostringstream error_message;
     error_message << "Please use another region id different from zero.\n"
                   << "It is internally used as the default region number.\n";
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);     
    }
   
   // First check if the region with the specified id does not already exist
   std::map<unsigned, Vector<double> >::iterator it;
   it = Regions_coordinates.find(i);
   // If it is already a region defined with that id throw an error
   if (it != Regions_coordinates.end())
    {
     std::ostringstream error_message;
     error_message << "The region id ("<<i<<") that you are using for"
                   << "defining\n"
                   << "your region is already in use. Use another\n"
                   << "region id and verify that you are not re-using\n"
                   <<" previously defined regions ids\n"<<std::endl;
     OomphLibWarning(error_message.str(),
                     OOMPH_CURRENT_FUNCTION,
                     OOMPH_EXCEPTION_LOCATION);
    }

   // If it does not exist then create the map
   Regions_coordinates[i] = region_coordinates;
   // Automatically set the using of attributes to enable
   this->Use_attributes = true;
  }
 
 /// Helper function for getting access to the regions coordinates
 std::map<unsigned, Vector<double> >&regions_coordinates()
  {return Regions_coordinates;}

 /// Helper function to specify target area for region
 void set_target_area_for_region(const unsigned &i, const double& area)
 {
   Regions_areas[i] = area;
 }

 /// Helper function for getting access to the region's target areas
 std::map<unsigned, double >&target_area_for_region()
  {return Regions_areas;}

 /// \short Helper function for getting the status of use_attributes 
 /// variable
 bool is_use_attributes() const {return Use_attributes;}

 /// \short Helper function for enabling the use of boundary refinement
 void enable_boundary_refinement() {Boundary_refinement=true;}
 
 /// \short Helper function for disabling the use of boundary refinement
 void disable_boundary_refinement() {Boundary_refinement=false;}

 /// \short Helper function for getting the status of boundary refinement
 bool is_boundary_refinement_allowed() const {return Boundary_refinement;}

 /// \short Helper function for enabling the use of boundary refinement
 void enable_internal_boundary_refinement() {Internal_boundary_refinement=true;}
 
 /// \short Helper function for disabling the use of boundary refinement
 void disable_internal_boundary_refinement() 
 {Internal_boundary_refinement=false;}

 /// \short Helper function for getting the status of boundary refinement
 bool is_internal_boundary_refinement_allowed() const 
 {return Internal_boundary_refinement;}


  protected:
 
 /// The outer boundary
 TriangleMeshClosedCurve *Outer_boundary_pt;

 /// Internal closed boundaries
 Vector<TriangleMeshClosedCurve*> Internal_closed_curve_pt;
 
 /// Internal boundaries
 Vector<TriangleMeshOpenCurve*> Internal_open_curves_pt;

 /// The element are when calling triangulate external routine
 double Element_area;
 
 /// Store the coordinates for defining extra holes
 Vector<Vector<double> > Extra_holes_coordinates;
 
 /// \short Store the coordinates for defining extra regions
 /// The key on the map is the region id
 std::map<unsigned, Vector<double> > Regions_coordinates;
 
 /// \short Target areas for regions; defaults to 0.0 which (luckily)
 /// implies "no specific target area" for triangle!
 std::map<unsigned, double> Regions_areas;

 /// Define the use of attributes (regions)
 bool Use_attributes;
 
 /// Do not allow refinement of nodes on the boundary
 bool Boundary_refinement;

  /// Do not allow refinement of nodes on the internal boundary
 bool Internal_boundary_refinement;


};


////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


//============start_of_triangle_class===================================
/// Triangle mesh build with the help of the scaffold mesh coming  
/// from the triangle mesh generator Triangle.
/// http://www.cs.cmu.edu/~quake/triangle.html
//======================================================================
 template <class ELEMENT>
  class TriangleMesh : public virtual TriangleMeshBase
 {
   public:

   /// \short Empty constructor 
  TriangleMesh()
   {
#ifdef OOMPH_HAS_TRIANGLE_LIB  
    // Using this constructor no Triangulateio object is built
    Triangulateio_exists=false;
#endif

    // Mesh can only be built with 2D Telements.
    MeshChecker::assert_geometric_element<TElementGeometricBase,ELEMENT>(2);
   }
  
  /// \short Constructor with the input files
  TriangleMesh(const std::string& node_file_name,
               const std::string& element_file_name,
               const std::string& poly_file_name,
               TimeStepper* time_stepper_pt=
                   &Mesh::Default_TimeStepper)
   {
    // Mesh can only be built with 2D Telements.
    MeshChecker::assert_geometric_element<TElementGeometricBase,ELEMENT>(2);

    // Store Timestepper used to build elements
    Time_stepper_pt=time_stepper_pt;

    bool use_attributes = false;

#ifdef OOMPH_HAS_TRIANGLE_LIB

    // Using this constructor build the triangulatio
    TriangleHelper::create_triangulateio_from_polyfiles(node_file_name,
                                                        element_file_name,
                                                        poly_file_name,
                                                        Triangulateio,
                                                        use_attributes);
    //Record that the triangulateio object has been created
    Triangulateio_exists=true;

#endif

    // Keep track of the attributes info.
    Use_attributes = use_attributes;

    // Build scaffold
    Tmp_mesh_pt= new 
     TriangleScaffoldMesh(node_file_name,
                          element_file_name,
                          poly_file_name);

    // Convert mesh from scaffold to actual mesh
    build_from_scaffold(time_stepper_pt,use_attributes);
    
    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
    
    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }
   }

#ifdef OOMPH_HAS_TRIANGLE_LIB

  /// \short Constructor based on TriangulateIO object 
  TriangleMesh(TriangulateIO& triangulate_io,
               TimeStepper* time_stepper_pt=
                   &Mesh::Default_TimeStepper,
               const bool &use_attributes=false)
   {
    // Mesh can only be built with 2D Telements.
    MeshChecker::assert_geometric_element<TElementGeometricBase,ELEMENT>(2);

    //Store the attributes flag
    Use_attributes = use_attributes;

    // Store Timestepper used to build elements
    Time_stepper_pt=time_stepper_pt;
    
    // Build scaffold
    Tmp_mesh_pt= new TriangleScaffoldMesh(triangulate_io);
    
    // Initialize TriangulateIO structure
    TriangleHelper::initialise_triangulateio(Triangulateio);
    
    // Triangulation has been created -- remember to wipe it!
    Triangulateio_exists=true;
    
    // Deep-copy triangulateio data into the Triangulateio private object
    bool quiet=true;
    Triangulateio=TriangleHelper::deep_copy_of_triangulateio_representation(
     triangulate_io,quiet);
    
    // Convert mesh from scaffold to actual mesh
    build_from_scaffold(time_stepper_pt,use_attributes);
    
    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
    
    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }
   }

  /// \short Build mesh, based on the specifications on
  /// TriangleMeshParameters
  TriangleMesh(TriangleMeshParameters &triangle_mesh_parameters, 
               TimeStepper* time_stepper_pt=&Mesh::Default_TimeStepper)
   {
    // Mesh can only be built with 2D Telements.
    MeshChecker::assert_geometric_element<TElementGeometricBase,ELEMENT>(2);
    
   // ********************************************************************
   // First part - Get polylines representations
   // ********************************************************************

   // Create the polyline representation of all the boundaries and
   // then create the mesh by calling to "generic_constructor()"

   // Initialise highest boundary id
   unsigned max_boundary_id = 0;

   // *****************************************************************
   // Part 1.1 - Outer boundary
   // *****************************************************************
   // Get the representation of the outer boundary from the
   // TriangleMeshParameters object
   TriangleMeshClosedCurve *outer_boundary_pt =
     triangle_mesh_parameters.outer_boundary_pt();

   // Get the polygon representation and compute the max boundary_id on
   // the outer polygon. Does nothing (i.e. just returns a pointer to
   // the outer boundary that was input) if the outer boundary is
   // already a polygon
   TriangleMeshPolygon* outer_boundary_polygon_pt =
     closed_curve_to_polygon_helper(outer_boundary_pt, max_boundary_id);

   // *****************************************************************
   // Part 1.2 - Internal closed boundaries (possible holes)
   // *****************************************************************
   // Get the representation of the internal closed boundaries from the
   // TriangleMeshParameters object
   Vector<TriangleMeshClosedCurve *> internal_closed_curve_pt =
     triangle_mesh_parameters.internal_closed_curve_pt();

   // Find the number of internal closed curves
   unsigned n_internal_closed_curves = internal_closed_curve_pt.size();

   // Create the storage for the polygons that define the internal closed
   // boundaries (again nothing happens (as above) if an internal closed
   // curve is already a polygon)
   Vector<TriangleMeshPolygon*> internal_polygon_pt(n_internal_closed_curves);

   // Loop over the number of internal closed curves
   for(unsigned i=0;i<n_internal_closed_curves;++i)
    {
     // Get the polygon representation and compute the max boundary_id on
     // each internal polygon
     internal_polygon_pt[i] =
       closed_curve_to_polygon_helper(
         internal_closed_curve_pt[i], max_boundary_id);
    }

   // *****************************************************************
   // Part 1.3 - Internal open boundaries
   // *****************************************************************
   // Get the representation of open boundaries from the
   // TriangleMeshParameteres object
   Vector<TriangleMeshOpenCurve*> internal_open_curve_pt =
     triangle_mesh_parameters.internal_open_curves_pt();

   // Sort the open polylines so that when connections exists only
   // depend on already defined polylines
   sort_open_curves_based_on_connections_order(internal_open_curve_pt);

   //Find the number of internal open curves
   unsigned n_internal_open_curves = internal_open_curve_pt.size();

   // Create the storage for the polylines that define the open boundaries
   Vector<TriangleMeshOpenCurve*> internal_open_curve_poly_pt(
     n_internal_open_curves);

   // Loop over the number of internal open curves
   for (unsigned i = 0; i < n_internal_open_curves; i++)
    {
     // Get the open polyline representation and compute the max boundary_id
     // on each open polyline (again, nothing happens if there are curve
     // sections on the current internal open curve)
     internal_open_curve_poly_pt[i] =
       create_open_curve_with_polyline_helper(
         internal_open_curve_pt[i], max_boundary_id);
    }

   // ********************************************************************
   // Second part - Get associated geom objects and coordinate limits
   // ********************************************************************

   // ***************************************************************
   // Part 2.1 Outer boundary
   // ***************************************************************
   set_geom_objects_and_coordinate_limits_for_close_curve(outer_boundary_pt);

   // ***************************************************************
   // Part 2.2 - Internal closed boundaries (possible holes)
   // ***************************************************************
   for (unsigned i = 0; i < n_internal_closed_curves; i++)
    {
     set_geom_objects_and_coordinate_limits_for_close_curve(
       internal_closed_curve_pt[i]);
    }

   // ********************************************************************
   // Part 2.3 - Internal open boundaries
   // ********************************************************************
   for (unsigned i = 0; i < n_internal_open_curves; i++)
    {
     set_geom_objects_and_coordinate_limits_for_open_curve(
       internal_open_curve_pt[i]);
    }

   // ********************************************************************
   // Third part - Creates the TriangulateIO object by calling the
   //              "generic_constructor()" function
   // ********************************************************************
   // Get all the other parameters from the TriangleMeshParameters object
   // The maximum element area
   const double element_area =
     triangle_mesh_parameters.element_area();

   // The holes coordinates
   Vector<Vector<double> > extra_holes_coordinates =
     triangle_mesh_parameters.extra_holes_coordinates();

   // The regions coordinates
   std::map<unsigned, Vector<double> > regions =
     triangle_mesh_parameters.regions_coordinates();

   // If we use regions then we use attributes
   const bool use_attributes = triangle_mesh_parameters.is_use_attributes();

   const bool refine_boundary = 
    triangle_mesh_parameters.is_boundary_refinement_allowed();

   const bool refine_internal_boundary = 
    triangle_mesh_parameters.is_internal_boundary_refinement_allowed();

   if(!refine_internal_boundary && refine_boundary)
    {
     std::ostringstream error_stream;
     error_stream 
      << 
      "You have specified that Triangle may refine the outer boundary, but\n"
      << 
      "not internal boundaries. Triangle does not support this combination.\n"
      << 
      "If you do not want Triangle to refine internal boundaries, it can't\n"
      <<
      "refine outer boundaries either!\n"
      << "Please either disable all boundary refinement\n"
      << "(call TriangleMeshParameters::disable_boundary_refinement()\n"
      << "or enable internal boundary refinement (the default)\n";

     throw OomphLibError(error_stream.str().c_str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }

   this->generic_constructor(outer_boundary_polygon_pt,
                             internal_polygon_pt,
                             internal_open_curve_poly_pt,
                             element_area,
                             extra_holes_coordinates,
                             regions,
                             triangle_mesh_parameters.target_area_for_region(),
                             time_stepper_pt,
                             use_attributes,
                             refine_boundary,
                             refine_internal_boundary);

   // Setup boundary coordinates for boundaries
   unsigned nb=nboundary();

   for (unsigned b=0;b<nb;b++)
    {
     this->setup_boundary_coordinates(b);
    }

   // Snap it!
   this->snap_nodes_onto_geometric_objects();

  }

  /// \short Build mesh from poly file, with specified target
  /// area for all elements.
  TriangleMesh(const std::string& poly_file_name,
               const double& element_area,
               TimeStepper* time_stepper_pt=
                   &Mesh::Default_TimeStepper,
               const bool &use_attributes=false)
   {
    // Mesh can only be built with 2D Telements.
    MeshChecker::assert_geometric_element<TElementGeometricBase,ELEMENT>(2);
  
    // Disclaimer
    std::string message=
     "This constructor hasn't been tested since last cleanup.\n";
    OomphLibWarning(message,
                    "TriangleMesh::TriangleMesh()",
                    OOMPH_EXCEPTION_LOCATION);
    
    //Store the attributes flag
    Use_attributes = use_attributes;

    // Store Timestepper used to build elements
    Time_stepper_pt=time_stepper_pt;
    
    // Create the data structures required to call the triangulate function
    TriangulateIO triangle_in;
    
    // Input string for triangle
    std::stringstream input_string_stream;

    // MH: Like everything else, this hasn't been tested!
    // used to be input_string_stream<<"-pA -a" << element_area << "q30";
    input_string_stream<<"-pA -a -a" << element_area << "q30";
    
    // Convert to a *char required by the triangulate function
    char triswitches[100];
    sprintf(triswitches,"%s",input_string_stream.str().c_str());
    
    // Build the input triangulateio object from the .poly file
    build_triangulateio(poly_file_name, triangle_in);
    
    // Build the triangulateio out object
    triangulate(triswitches, &triangle_in, &Triangulateio, 0);
    
    // Build scaffold
    Tmp_mesh_pt= new TriangleScaffoldMesh(Triangulateio);
    
    // Convert mesh from scaffold to actual mesh
    build_from_scaffold(time_stepper_pt,use_attributes);
    
    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
    
    // Cleanup but leave hole alone
    bool clear_hole_data=false;
    TriangleHelper::clear_triangulateio(triangle_in,clear_hole_data);

    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }
   }

#endif

  
  /// Broken copy constructor
  TriangleMesh(const TriangleMesh& dummy) 
   {
    BrokenCopy::broken_copy("TriangleMesh");
   } 
  
  /// Broken assignment operator
  void operator=(const TriangleMesh&) 
   {
    BrokenCopy::broken_assign("TriangleMesh");
   }
  
  /// Destructor 
  virtual ~TriangleMesh() 
  {
#ifdef OOMPH_HAS_TRIANGLE_LIB
   if (Triangulateio_exists)
    {
     TriangleHelper::clear_triangulateio(Triangulateio);
    }

   std::set<TriangleMeshCurveSection*>::iterator it_polyline;
   for (it_polyline = Free_curve_section_pt.begin();
     it_polyline != Free_curve_section_pt.end();
     it_polyline++)
    {
     delete (*it_polyline);
    }

   std::set<TriangleMeshPolygon*>::iterator it_polygon;
   for (it_polygon = Free_polygon_pt.begin();
     it_polygon != Free_polygon_pt.end();
     it_polygon++)
    {
     delete (*it_polygon);
    }

   std::set<TriangleMeshOpenCurve*>::iterator it_open_polyline;
   for (it_open_polyline = Free_open_curve_pt.begin();
     it_open_polyline != Free_open_curve_pt.end();
     it_open_polyline++)
    {
     delete (*it_open_polyline);
    }

#endif
  }

  /// \short Overload set_mesh_level_time_stepper so that the stored
  /// time stepper now corresponds to the new timestepper
  void set_mesh_level_time_stepper(TimeStepper* const &time_stepper_pt,
                                   const bool &preserve_existing_data)
  {this->Time_stepper_pt = time_stepper_pt;}

  /// \short Setup boundary coordinate on boundary b.
  /// Boundary coordinate increases continously along
  /// polygonal boundary. It's zero at the lowest left
  /// smallest node on the boundary.
  void setup_boundary_coordinates(const unsigned& b)
  {
   // Dummy file
   std::ofstream some_file;
   setup_boundary_coordinates(b,some_file);
  }
  
  /// \short Setup boundary coordinate on boundary b. Doc Faces
  /// in outfile.
  /// Boundary coordinate increases continously along
  /// polygonal boundary. It's zero at the lowest left
  /// node on the boundary.
  void setup_boundary_coordinates(const unsigned& b,
                                  std::ofstream& outfile);
  
  /// Return the number of elements adjacent to boundary b in region r
  inline unsigned nboundary_element_in_region(const unsigned &b,
                                        const unsigned &r) const
  {
   //Need to use a constant iterator here to keep the function "const"
   //Return an iterator to the appropriate entry, if we find it
   std::map<unsigned,Vector<FiniteElement*> >::const_iterator it =
     Boundary_region_element_pt[b].find(r);
   if(it!=Boundary_region_element_pt[b].end())
    {
     return (it->second).size();
    }
   //Otherwise there are no elements adjacent to boundary b in the region r
   else
    {
     return 0;
    }
  }

  /// Return pointer to the e-th element adjacent to boundary b in region r
  FiniteElement* boundary_element_in_region_pt(const unsigned &b, 
                                               const unsigned &r,
                                               const unsigned &e) const
  {
   //Use a constant iterator here to keep function "const" overall
   std::map<unsigned,Vector<FiniteElement*> >::const_iterator it =
     Boundary_region_element_pt[b].find(r);
   if(it!=Boundary_region_element_pt[b].end())
    {
     return (it->second)[e];
    }
   else
    {
     return 0;
    }
  }

  /// Return face index of the e-th element adjacent to boundary b in region r
  int face_index_at_boundary_in_region(const unsigned &b, 
                                       const unsigned &r,
                                       const unsigned &e) const
  {
   //Use a constant iterator here to keep function "const" overall
   std::map<unsigned,Vector<int> >::const_iterator it =
     Face_index_region_at_boundary[b].find(r);
   if(it!=Face_index_region_at_boundary[b].end())
    {
     return (it->second)[e];
    }
   else
    {
     std::ostringstream error_message;
     error_message << "Face indices not set up for boundary "
       << b << " in region " << r << "\n";
     error_message
     << "This probably means that the boundary is not adjacent to region\n";
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
    }
  }

  /// Return the number of regions specified by attributes
  unsigned nregion() {return Region_element_pt.size();}
  
  /// Return the number of elements in region i
  unsigned nregion_element(const unsigned &i) 
   {
    std::map<unsigned,Vector<FiniteElement*> >::iterator it =
     Region_element_pt.find(i);
    if(it!=Region_element_pt.end())
     {
      return (it->second).size();
     }
    else
     {
      return 0;
     }
   }
  
  /// Return the attribute associated with region i
  double region_attribute(const unsigned &i)
  {return Region_attribute[i];}
  
  /// Return the e-th element in the i-th region
  FiniteElement* region_element_pt(const unsigned &i,
                                   const unsigned &e)
   {
    std::map<unsigned,Vector<FiniteElement*> >::iterator it =
     Region_element_pt.find(i);
    if(it!=Region_element_pt.end())
     {
      return (it->second)[e];
     }
    else
     {
      std::ostringstream error_message;
      error_message << "There are not elements associated with region ("
                    << i << ")\n";
      error_message
       << "This probably means that you are using a non defined region id\n";
      throw OomphLibError(error_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     }
   }

  /// \short Return the geometric object associated with the b-th boundary or
  /// null if the boundary has associated geometric object.
  GeomObject* boundary_geom_object_pt(const unsigned &b)
   {
    std::map<unsigned,GeomObject*>::iterator it;
    it = Boundary_geom_object_pt.find(b);
    if(it == Boundary_geom_object_pt.end()) 
     {return 0;}
    else 
     {return (*it).second;}
   }
  
  /// \short Return direct access to the geometric object storage
  std::map<unsigned,GeomObject*> &boundary_geom_object_pt()  
   {return Boundary_geom_object_pt;}
  
  /// \short Return access to the vector of boundary coordinates associated
  /// with each geometric object
  std::map<unsigned,Vector<double> > &boundary_coordinate_limits()
   {return Boundary_coordinate_limits;}
  
  /// \short Return access to the coordinate limits associated with 
  /// the geometric object associated with boundary b
  Vector<double> &boundary_coordinate_limits(const unsigned &b)
   {
    std::map<unsigned,Vector<double> >::iterator it;
    it = Boundary_coordinate_limits.find(b);
    if(it == Boundary_coordinate_limits.end())
     {
      throw OomphLibError(
       "No coordinate limits associated with this boundary\n",
       "TESTER",
       OOMPH_EXCEPTION_LOCATION);
     }
    else
     {
      return (*it).second;
     }
   }
  
  /// \short Return pointer to the current polyline that describes
  /// the b-th mesh boundary
  TriangleMeshPolyLine *boundary_polyline_pt(const unsigned &b)
  {return
    dynamic_cast<TriangleMeshPolyLine*>(Boundary_curve_section_pt[b]);}

  /// \short Return access to the associated set of vertices that
  /// receive connections on the specified boundary
  std::set<Vector<double> > &boundary_connections(const unsigned &b)
  {return Boundary_connections_pt[b];}

#ifdef OOMPH_HAS_TRIANGLE_LIB

  /// \short Update the TriangulateIO object to the current nodal position
  /// and the centre hole coordinates.
  void update_triangulateio(Vector<Vector<double> >&internal_point)
  {
    // Move the hole center
    // Get number of holes
   unsigned nhole=Triangulateio.numberofholes;
   unsigned count_coord=0;
   for(unsigned ihole=0;ihole<nhole;ihole++)
    {
     Triangulateio.holelist[count_coord]+=internal_point[ihole][0];
     Triangulateio.holelist[count_coord+1]+=internal_point[ihole][1]; 
     
     // Increment counter
     count_coord+=2;
    }
   
   // Do the update
   update_triangulateio();
  }
   
  /// \short Update the triangulateio object to the current nodal positions
  void update_triangulateio()
  {   
   // Get number of points
   unsigned nnode = Triangulateio.numberofpoints;
   double new_x=0;
   double new_y=0;
   
   // Loop over the points
   for(unsigned inod=0;inod<nnode;inod++)
    {      
     // Get the node Id to be updated
     unsigned count=Oomph_vertex_nodes_id[inod];
     
     // Update vertices using the vertex_node_id giving for the TriangulateIO
     // vertex enumeration the corresponding oomphlib mesh enumeration
     Node* mesh_node_pt=this->node_pt(inod);
     new_x=mesh_node_pt->x(0); 
     new_y=mesh_node_pt->x(1); 
     Triangulateio.pointlist[count*2] = new_x;  
     Triangulateio.pointlist[(count*2)+1] = new_y;       
    }
  }
  
  /// \short Completely regenerate the mesh from the trianglateio structure
  void remesh_from_internal_triangulateio()
   {
    //Remove all the boundary node information
    this->remove_boundary_nodes();

    //Delete exisiting nodes
    unsigned n_node = this->nnode();
    for(unsigned n=n_node;n>0;--n)
     {
      delete this->Node_pt[n-1];
      this->Node_pt[n-1] = 0;
     }
    //Delete exisiting elements
    unsigned n_element = this->nelement();
    for(unsigned e=n_element;e>0;--e)
     {
      delete this->Element_pt[e-1];
      this->Element_pt[e-1] = 0;
     }
    //Flush the storage
    this->flush_element_and_node_storage();

    //Delete all boundary element information
    //ALH: Kick up the object hierarchy?
    this->Boundary_element_pt.clear();
    this->Face_index_at_boundary.clear();
    this->Region_element_pt.clear();
    this->Region_attribute.clear();
    this->Boundary_region_element_pt.clear();
    this->Face_index_region_at_boundary.clear();
    this->Boundary_curve_section_pt.clear();
    this->Boundary_connections_pt.clear();
    unsigned nbound=nboundary();
    Boundary_coordinate_exists.resize(nbound,false);

    //Now build the new scaffold
    Tmp_mesh_pt= new TriangleScaffoldMesh(this->Triangulateio);
     
    // Triangulation has been created -- remember to wipe it!
    Triangulateio_exists=true;
    
    // Convert mesh from scaffold to actual mesh
    build_from_scaffold(this->Time_stepper_pt,this->Use_attributes);
        
    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
   }

  /// Boolean defining if Triangulateio object has been built or not
  bool triangulateio_exists(){return Triangulateio_exists;}

#endif


  /// \short Return the vector that contains the oomph-lib node number
  /// for all vertex nodes in the TriangulateIO representation of the mesh
  Vector<unsigned> oomph_vertex_nodes_id(){return Oomph_vertex_nodes_id;}
   
  /// \short Snap the boundary nodes onto any curvilinear boundaries
  /// defined by geometric objects
  void snap_nodes_onto_geometric_objects();

  /// \short Gets a pointer to a set with all the nodes
  /// related with a boundary
  std::map<unsigned, std::set<Node*> > &nodes_on_boundary_pt() {
	  return Nodes_on_boundary_pt;
  }

  /// \short Stores a pointer to a set with all the nodes
  /// related with a boundary
  std::map<unsigned, std::set<Node*> > Nodes_on_boundary_pt;

    protected:

  /// Build mesh from scaffold
  void build_from_scaffold(TimeStepper* time_stepper_pt,
                           const bool &use_attributes);

#ifdef OOMPH_HAS_TRIANGLE_LIB  
  
  /// \short Build TriangulateIO object from TriangleMeshPolygon (outer
  /// boundary) and TriangleMeshPolygon list (internal boundaries) and
  /// TriangleMeshOpenCurve list for internal curves
  void build_triangulateio(TriangleMeshPolygon* &outer_boundary_pt,
                           Vector<TriangleMeshPolygon*> &internal_polygon_pt,
                           Vector<TriangleMeshOpenCurve*>
                           &open_polylines_pt,
                           Vector<Vector<double> > &extra_holes_coordinates,
                           std::map<unsigned, Vector<double> >
                           &regions_coordinates,
                           std::map<unsigned, double>
                           &regions_areas,
                           TriangulateIO& triangulate_io);

  /// \short Helper function to create TriangulateIO object (return in
  /// triangulate_io) from the .poly file 
  void build_triangulateio(const std::string& poly_file_name,
                           TriangulateIO& triangulate_io);


  /// \short A general-purpose construction function that builds the
  /// mesh once the different specific constructors have assembled the
  /// appropriate information.
  void generic_constructor(TriangleMeshPolygon* &outer_boundary_pt,
                           Vector<TriangleMeshPolygon*> &internal_polygon_pt,
                           Vector<TriangleMeshOpenCurve*>
                           &open_polylines_pt,
                           const double &element_area,
                           Vector<Vector<double> > &extra_holes_coordinates,
                           std::map<unsigned, Vector<double> >
                           &regions_coordinates,
                           std::map<unsigned, double >
                           &regions_areas,
                           TimeStepper* time_stepper_pt,
                           const bool &use_attributes,
                           const bool &refine_boundary,
                           const bool &refine_internal_boundary) 
   {
    // Mesh can only be built with 2D Telements.
    MeshChecker::assert_geometric_element<TElementGeometricBase,ELEMENT>(2);
    
#ifdef PARANOID
    if (element_area < 10e-14)
     {
      std::ostringstream warning_message;
      warning_message
       << "The current elements area was stated to (" << element_area 
       << ").\nThe current precision to generate the input to triangle "
       << "is fixed to 14 digits\n\n";
       OomphLibWarning(warning_message.str(),
                       OOMPH_CURRENT_FUNCTION,
                       OOMPH_EXCEPTION_LOCATION);
     }    
#endif
    
    //Store the attribute flag
    Use_attributes = use_attributes;

    // Store Timestepper used to build elements
    Time_stepper_pt=time_stepper_pt;
    
    // Store outer polygon
    Outer_boundary_pt=outer_boundary_pt;
    
    // Store internal polygons by copy constructor
    Internal_polygon_pt=internal_polygon_pt;

    // Store internal polylines by copy constructor
    Internal_open_curve_pt = open_polylines_pt;
    
    // Store the extra holes coordinates
    Extra_holes_coordinates = extra_holes_coordinates;
    
    // Store the extra regions coordinates
    Regions_coordinates = regions_coordinates;
    
    // Create the data structures required to call the triangulate function
    TriangulateIO triangulate_io;
    
    // Initialize TriangulateIO structure
    TriangleHelper::initialise_triangulateio(triangulate_io);
    
    // Convert TriangleMeshPolyLine and TriangleMeshClosedCurvePolyLine
    // to a triangulateio object
    build_triangulateio(outer_boundary_pt,
                        internal_polygon_pt,
                        open_polylines_pt,
                        extra_holes_coordinates,
                        regions_coordinates,
                        regions_areas,
                        triangulate_io);

    // Initialize TriangulateIO structure
    TriangleHelper::initialise_triangulateio(Triangulateio);

    // Triangulation has been created -- remember to wipe it!
    Triangulateio_exists=true;
    
    // Input string for triangle
    std::stringstream input_string_stream;
    input_string_stream.precision(14);
    input_string_stream.setf(std::ios_base::fixed, 
                             std::ios_base::floatfield);

    // MH: Used to be:
    // input_string_stream<<"-pA -a" << element_area << " -q30" << std::fixed;
    // The repeated -a allows the specification of areas for different
    // regions (if any)
    input_string_stream <<"-pA -a -a" << element_area << " -q30" << std::fixed;
    
    //Suppress insertion of additional points on outer boundary
    if(refine_boundary==false) 
     {
      input_string_stream << "-Y";
      //Add the extra flag to suppress additional points on interior segments
      if(refine_internal_boundary==false) {input_string_stream << "Y";}
     }

    // Convert the Input string in *char required by the triangulate function
    char triswitches[100];
    sprintf(triswitches,"%s",input_string_stream.str().c_str());
    
    // Build the mesh using triangulate function
    triangulate(triswitches, &triangulate_io, &Triangulateio, 0);
    
    // Build scaffold
    Tmp_mesh_pt= new TriangleScaffoldMesh(Triangulateio);

    //If we have filled holes then we must use the attributes
    if(!regions_coordinates.empty())
     {
      // Convert mesh from scaffold to actual mesh
      build_from_scaffold(time_stepper_pt,true);
      //Record the attribute flag
      Use_attributes=true;
     }
    //Otherwise use what was asked
    else
     {
      // Convert mesh from scaffold to actual mesh
      build_from_scaffold(time_stepper_pt,use_attributes);
     }

    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
    
    // Cleanup but leave hole and regions alone since it's still used
    bool clear_hole_data=false;
    TriangleHelper::clear_triangulateio(triangulate_io,clear_hole_data);
   }
  
  /// \short Solve dependencies for connections between internal open
  /// curves. When an internal polyline is connected to another internal
  /// polyline that has not been created (because of the storing order of
  /// the open curves) this method sort the open curves to ensure that an
  /// open curve is always connected to an already created open curve
  void sort_open_curves_based_on_connections_order(
   Vector<TriangleMeshOpenCurve*> &open_curves_pt)
  {
   // 1) Go through all the open curves and their respective polylines
   // 2) If connected (initial or final end) then get the boundaries id
   //    to which they are connected
   // 3) Verify that all the boundaries to which each polyline is connected
   //    are stored before in the open curves Vector (use a list to re-sort
   //    the open curves)
   unsigned nopen_curves = open_curves_pt.size();

   // Return
   if (nopen_curves <= 1)
    {return;}
   
   // The list of sorted open curves according to their connections
   // dependencies
   // pair(open curve, set of boundaries id to which depends)
   std::list<std::pair<TriangleMeshOpenCurve *, std::set<unsigned> > > 
    sorted_open_curves;
   
   // *******************************************************************
   // Insert the first open curve to the list
   // Get the set of boundaries ids to which the first open curve depends
   // and add it to the sorted open curves list
   std::set<unsigned> connected_with;
   unsigned npolylines = open_curves_pt[0]->ncurve_section();
   for (unsigned p = 0; p < npolylines; p++)
    {
     TriangleMeshCurveSection *curve_section_pt = 
      open_curves_pt[0]->curve_section_pt(p);
     if (curve_section_pt->is_initial_vertex_connected())
      {
       // We need to get the boundary id of the destination/connected
       // boundary
       unsigned dst_bnd_id = 
        curve_section_pt->initial_vertex_connected_bnd_id();
       // ... and store it on the "is connected with" set
       connected_with.insert(dst_bnd_id);
      }
     if (curve_section_pt->is_final_vertex_connected())
      {
       // We need to get the boundary id of the destination/connected
       // boundary
       unsigned dst_bnd_id = 
        curve_section_pt->final_vertex_connected_bnd_id();
       // ... and store it on the "is connected with" set
       connected_with.insert(dst_bnd_id);
      }
    } // for p (polylines on the current open curve)

   // Make the pair to insert to the list
   std::pair<TriangleMeshOpenCurve*, std::set<unsigned> > insert_pair = 
    std::make_pair(open_curves_pt[0], connected_with);
   
   // Insert the last open curve as the base one
   sorted_open_curves.push_back(insert_pair);

   // *******************************************************************
   // Sort the open curves in the vector
   for (unsigned i = 1; i < nopen_curves; i++)
    {
     // Stores the boundaries id to which the current open curve is
     // connected
     connected_with.clear();
     // Store the boundaries ids with the current open curve
     std::set<unsigned> bnd_ids;
     unsigned npolylines = open_curves_pt[i]->ncurve_section();
     for (unsigned p = 0; p < npolylines; p++)
      {
       TriangleMeshCurveSection *curve_section_pt = 
        open_curves_pt[i]->curve_section_pt(p);

       bnd_ids.insert(curve_section_pt->boundary_id());

       if (curve_section_pt->is_initial_vertex_connected())
        {
         // We need to get the boundary id of the destination/connected
         // boundary
         unsigned dst_bnd_id = 
          curve_section_pt->initial_vertex_connected_bnd_id();
         // ... and store it on the "is connected with" set
         connected_with.insert(dst_bnd_id);
        }
       if (curve_section_pt->is_final_vertex_connected())
        {
         // We need to get the boundary id of the destination/connected
         // boundary
         unsigned dst_bnd_id = 
          curve_section_pt->final_vertex_connected_bnd_id();
         // ... and store it on the "is connected with" set
         connected_with.insert(dst_bnd_id);
        }
      } // for p (polylines on the current open curve)

     // Now we have all the boundaries id's to which the current open curve
     // is connected. This information will be useful to store the current
     // open curve in the list

     // Insert the current open curve in the open curve's list
     // according to its dependency in connections (if has dependency go
     // to the rigth -- after -- and if has no dependency go to the left
     // -- before --)
     std::list<std::pair<TriangleMeshOpenCurve *, 
      std::set<unsigned> > >::iterator it_list;
     it_list = sorted_open_curves.begin();
     bool inserted_open_curve = false;
     for (; it_list != sorted_open_curves.end(); it_list++)
      {
       std::set<unsigned> depends_on = (*it_list).second;

       // Verify dependencies
       std::set<unsigned>::iterator it;
       it = depends_on.begin();
       for (; it != depends_on.end(); it++)
        {
         unsigned b = (*it);
         std::set<unsigned>::iterator it_found;
         it_found = bnd_ids.find(b);
         // Is there a dependency?
         if (it_found!=bnd_ids.end())
          {
           // Insert the current open curve to the left of the open curve
           // in the list
           // Make the pair to insert to the list
           std::pair<TriangleMeshOpenCurve*, std::set<unsigned> >
            insert_pair = std::make_pair(open_curves_pt[i], connected_with);
            
           // Insert the last open curve as the base one
           sorted_open_curves.insert(it_list, insert_pair);
           inserted_open_curve = true;
           break; // With one dependency is enough
          }
        }
       // Break, no need to check for more open curves
       if (inserted_open_curve) break;
      }

     // Not necessary to re-sort the open curves, insert at the end of
     // the list
     if (!inserted_open_curve)
      {
       // Make the pair to insert to the list
       std::pair<TriangleMeshOpenCurve*, std::set<unsigned> >
        insert_pair = std::make_pair(open_curves_pt[i], connected_with);
       sorted_open_curves.push_back(insert_pair);
      }

    } // for i (open curves)

   // Now copy the list
   unsigned counter = 0;
   std::list<std::pair<TriangleMeshOpenCurve *, 
    std::set<unsigned> > >::iterator it_list;
   it_list = sorted_open_curves.begin();
   for (; it_list != sorted_open_curves.end(); it_list++)
    {
     open_curves_pt[counter] = (*it_list).first;
     counter++;
    }
  }

  /// \short Helper function to create polyline vertex coordinates for 
  /// curvilinear boundary specified by boundary_pt, using either
  /// equal increments in zeta or in (approximate) arclength
  /// along the curviline. vertex_coord[i_vertex][i_dim] stores
  /// i_dim-th coordinate of i_vertex-th vertex. 
  /// polygonal_vertex_arclength_info[i_vertex] contains the pair of doubles
  /// made of the arclength of the i_vertex-th vertex along the polygonal 
  /// representation (.first), and the corresponding coordinate on the
  /// GeomObject (.second)
  void create_vertex_coordinates_for_polyline_no_connections(
   TriangleMeshCurviLine* boundary_pt,
   Vector<Vector<double> >& vertex_coord,
   Vector<std::pair<double,double> >& polygonal_vertex_arclength_info)
  {
   
   // Intrinsic coordinate along GeomObjects
   Vector<double> zeta(1);
   
   // Position vector to point on GeomObject
   Vector<double> posn(2); 
   
   // Start coordinate
   double zeta_initial = boundary_pt->zeta_start();

   //How many segments do we want on this polyline?
   unsigned n_seg = boundary_pt->nsegment();
   vertex_coord.resize(n_seg+1);
   polygonal_vertex_arclength_info.resize(n_seg+1);
   polygonal_vertex_arclength_info[0].first=0.0;
   polygonal_vertex_arclength_info[0].second=zeta_initial;
  
   // Vertices placed in equal zeta increments
   if (!(boundary_pt->space_vertices_evenly_in_arclength()))
    {
     //Read the values of the limiting coordinates, assuming equal
     //spacing of the nodes
     double zeta_increment = 
      (boundary_pt->zeta_end()-boundary_pt->zeta_start())/(double(n_seg));
   
     //Loop over the n_seg+1 points bounding the segments
     for(unsigned s=0;s<n_seg+1;s++)
      {
       // Get the coordinates
       zeta[0]= zeta_initial + zeta_increment*double(s);            
       boundary_pt->geom_object_pt()->position(zeta,posn);
       vertex_coord[s]=posn;

       // Bump up the polygonal arclength
       if (s>0)
        {
         polygonal_vertex_arclength_info[s].first=
          polygonal_vertex_arclength_info[s-1].first+
          sqrt(pow(vertex_coord[s][0]-vertex_coord[s-1][0],2)+
               pow(vertex_coord[s][1]-vertex_coord[s-1][1],2));
         polygonal_vertex_arclength_info[s].second=zeta[0];

        }
      }
    }
   // Vertices placed in equal increments in (approximate) arclength
   else
    {
     // Number of sampling points to compute arclength and
     // arclength increments
     unsigned nsample_per_segment=100;
     unsigned nsample=nsample_per_segment*n_seg;
   
     // Work out start and increment
     double zeta_increment=(boundary_pt->zeta_end()-
                            boundary_pt->zeta_start())/(double(nsample));
   
     // Get coordinate of first point
     Vector<double> start_point(2);
     zeta[0]=zeta_initial;

     boundary_pt->geom_object_pt()->position(zeta,start_point);
   
     // Storage for coordinates of end point
     Vector<double> end_point(2);
   
     // Compute total arclength
     double total_arclength=0.0;
     for (unsigned i=1;i<nsample;i++)
      {
       // Next point
       zeta[0]+=zeta_increment;
     
       // Get coordinate of end point
       boundary_pt->geom_object_pt()->position(zeta,end_point);
     
       // Increment arclength
       total_arclength+=sqrt(pow(end_point[0]-start_point[0],2)+
                             pow(end_point[1]-start_point[1],2));
     
       // Shift back
       start_point=end_point;
      }
   
     // Desired arclength increment
     double target_s_increment=total_arclength/(double(n_seg));

     // Get coordinate of first point again
     zeta[0]=zeta_initial;
     boundary_pt->geom_object_pt()->position(zeta,start_point);
   
     // Assign as coordinate
     vertex_coord[0]=start_point;
   
     // Start sampling point 
     unsigned i_lo=1;
   
     //Loop over the n_seg-1 internal points bounding the segments
     for(unsigned s=1;s<n_seg;s++)
      {
       // Visit potentially all sample points until we've found
       // the one at which we exceed the target arclength increment
       double arclength_increment=0.0;
       for (unsigned i=i_lo;i<nsample;i++)
        {
         // Next point
         zeta[0]+=zeta_increment;
       
         // Get coordinate of end point
         boundary_pt->geom_object_pt()->position(zeta,end_point);
       
         // Increment arclength increment
         arclength_increment+=sqrt(pow(end_point[0]-start_point[0],2)+
                                   pow(end_point[1]-start_point[1],2));
       
         // Shift back
         start_point=end_point;
       
         // Are we there yet?
         if (arclength_increment>target_s_increment)
          {
           // Remember how far we've got
           i_lo=i;

           // And bail out
           break;
          }
        }
     
       // Store the coordinates
       vertex_coord[s]=end_point;
       
       // Bump up the polygonal arclength
       if (s>0)
        {
         polygonal_vertex_arclength_info[s].first=
          polygonal_vertex_arclength_info[s-1].first+
          sqrt(pow(vertex_coord[s][0]-vertex_coord[s-1][0],2)+
               pow(vertex_coord[s][1]-vertex_coord[s-1][1],2));
         polygonal_vertex_arclength_info[s].second=zeta[0];
        }
      }
   
     // Final point
     unsigned s=n_seg;
     zeta[0]=boundary_pt->zeta_end();
     boundary_pt->geom_object_pt()->position(zeta,end_point);
     vertex_coord[s]=end_point;
     polygonal_vertex_arclength_info[s].first=
      polygonal_vertex_arclength_info[s-1].first+
      sqrt(pow(vertex_coord[s][0]-vertex_coord[s-1][0],2)+
           pow(vertex_coord[s][1]-vertex_coord[s-1][1],2));
     polygonal_vertex_arclength_info[s].second=zeta[0];
    }
  }

  /// \short Helper function to create polyline vertex coordinates for
  /// curvilinear boundary specified by boundary_pt, using either
  /// equal increments in zeta or in (approximate) arclength
  /// along the curviline. vertex_coord[i_vertex][i_dim] stores
  /// i_dim-th coordinate of i_vertex-th vertex.
  /// polygonal_vertex_arclength_info[i_vertex] contains the pair of doubles
  /// made of the arclength of the i_vertex-th vertex along the polygonal
  /// representation (.first), and the corresponding coordinate on the
  /// GeomObject (.second)
  void create_vertex_coordinates_for_polyline_connections(
      TriangleMeshCurviLine* boundary_pt,
      Vector<Vector<double> >& vertex_coord,
      Vector<std::pair<double,double> >& polygonal_vertex_arclength_info)
  {

   // Start coordinate
   double zeta_initial = boundary_pt->zeta_start();
   // Final coordinate
   double zeta_final = boundary_pt->zeta_end();

   Vector<double> *connection_points_pt =
     boundary_pt->connection_points_pt();

   unsigned n_connections = connection_points_pt->size();

   // We need to sort the connection points
   if (n_connections > 1)
    {
     std::sort(connection_points_pt->begin(), connection_points_pt->end());
    }

#ifdef PARANOID
   bool f = false;
   std::ostringstream error_message;
   // Check if the curviline should be created on a reversed way
   bool reversed = false;
   if (zeta_final < zeta_initial)
     {reversed = true;}
   if(!reversed)
    {
     if (zeta_initial > (*connection_points_pt)[0])
      {
       error_message
       << "One of the specified connection points is out of the\n"
       << "curviline limits. We found that the point ("
       << (*connection_points_pt)[0] << ") is\n" << "less than the"
       << "initial s value which is (" << zeta_initial << ").\n"
       << "Initial value: ("<<zeta_initial<<")\n"
       << "Final value: ("<<zeta_final<<")\n"
       << std::endl;
       f = true;
      }

     if (zeta_final < (*connection_points_pt)[n_connections-1])
      {
       error_message
       << "One of the specified connection points is out of the\n"
       << "curviline limits. We found that the point ("
       << (*connection_points_pt)[n_connections-1] << ") is\n"
       << "greater than the final s value which is ("
       << zeta_final << ").\n"
       << "Initial value: ("<<zeta_initial<<")\n"
       << "Final value: ("<<zeta_final<<")\n"
       << std::endl;
       f = true;
      }
    }
   else
    {
     if (zeta_initial < (*connection_points_pt)[0])
      {
       error_message
       << "One of the specified connection points is out of the\n"
       << "curviline limits. We found that the point ("
       << (*connection_points_pt)[0] << ") is\n" << "greater than the"
       << "initial s value which is (" << zeta_initial  << ").\n"
       << "Initial value: ("<<zeta_initial<<")\n"
       << "Final value: ("<<zeta_final<<")\n"
       << std::endl;
       f = true;
      }

     if (zeta_final > (*connection_points_pt)[n_connections-1])
      {
       error_message
       << "One of the specified connection points is out of the\n"
       << "curviline limits. We found that the point ("
       << (*connection_points_pt)[n_connections-1] << ") is\n"
       << "less than the final s value which is ("
       << zeta_final << ").\n"
       << "Initial value: ("<<zeta_initial<<")\n"
       << "Final value: ("<<zeta_final<<")\n"
       << std::endl;
       f = true;
      }
    }

   if (f)
    {
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
    }

#endif

   // Intrinsic coordinate along GeomObjects
   Vector<double> zeta(1);

   // Position vector to point on GeomObject
   Vector<double> posn(2);

   //How many segments do we want on this polyline?
   unsigned n_seg = boundary_pt->nsegment();

   // How many connection vertices have we already created
   unsigned i_connection = 0;
   Vector<double> zeta_connection(1);

   // If we have more connection points than the generated
   // by the number of segments then we have to change the
   // number of segments and create all the vertices
   // according to the connection points list
   if (n_connections >= n_seg - 1)
    {
     std::ostringstream warning_message;
     warning_message
     << "The number of segments specified for the curviline with\n"
     << "boundary id (" <<  boundary_pt->boundary_id() << ") is less "
     << "(or equal) than the ones that will be\ngenerated by using "
     << "the specified number of connection points.\n"
     << "You specified (" << n_seg << ") segments but ("
     << n_connections + 1 << ") segments\nwill be generated."
     << std::endl;
     OomphLibWarning(warning_message.str(),
       "TriangleMesh::create_vertex_coordinates_for_polyline_connections()",
       OOMPH_EXCEPTION_LOCATION);

     // We have to explicitly change the number of segments
     boundary_pt->nsegment() = n_connections + 1;
     n_seg = boundary_pt->nsegment();
     vertex_coord.resize(n_seg+1);

     // Initial coordinate and initial values
     zeta[0]= zeta_initial;
     boundary_pt->geom_object_pt()->position(zeta, posn);
     vertex_coord[0]=posn;

     polygonal_vertex_arclength_info.resize(n_seg+1);
     polygonal_vertex_arclength_info[0].first=0.0;
     polygonal_vertex_arclength_info[0].second=zeta_initial;

     //Loop over the n_connections points bounding the segments
     for(i_connection = 0; i_connection < n_connections; i_connection++)
      {

       // Get the coordinates
       zeta[0]= (*connection_points_pt)[i_connection];
       boundary_pt->geom_object_pt()->position(zeta, posn);
       vertex_coord[i_connection + 1] = posn;

       // Bump up the polygonal arclength
       polygonal_vertex_arclength_info[i_connection + 1].first=
         polygonal_vertex_arclength_info[i_connection].first+
         sqrt(pow(vertex_coord[i_connection + 1][0]-
           vertex_coord[i_connection][0],2)+
           pow(vertex_coord[i_connection + 1][1]-
             vertex_coord[i_connection][1],2));
       polygonal_vertex_arclength_info[i_connection + 1].second=zeta[0];

      }

     // Final coordinate and final values
     zeta[0] = zeta_final;
     boundary_pt->geom_object_pt()->position(zeta, posn);
     vertex_coord[n_seg]=posn;

     polygonal_vertex_arclength_info[n_seg].first=
       polygonal_vertex_arclength_info[n_seg-1].first+
       sqrt(pow(vertex_coord[n_seg][0]-vertex_coord[n_seg-1][0],2)+
         pow(vertex_coord[n_seg][1]-vertex_coord[n_seg-1][1],2));
     polygonal_vertex_arclength_info[n_seg].second = zeta_final;

    }
   else
    {

     // Total number of vertices
     unsigned n_t_vertices = n_seg+1;
     // Number of vertices left for creation
     unsigned l_vertices = n_t_vertices;
     // Total number of already created vertices
     unsigned n_assigned_vertices = 0;

     // Stores the distance between current vertices in the list
     // Edge vertices + Connection points - 1
     Vector<double> delta_z(2 + n_connections - 1);

     std::list<double> zeta_values_pt;
     zeta_values_pt.push_back(zeta_initial);
     for (unsigned s = 0; s < n_connections; s++)
      {
       zeta_values_pt.push_back((*connection_points_pt)[s]);
      }
     zeta_values_pt.push_back(zeta_final);

     l_vertices-= 2; // Edge vertices
     l_vertices-= n_connections; // Connection points
     n_assigned_vertices+= 2; // Edge vertices
     n_assigned_vertices+= n_connections; // Connection points

     // Vertices placed in equal zeta increments
     if (!(boundary_pt->space_vertices_evenly_in_arclength()))
      {
       double local_zeta_initial;
       double local_zeta_final;
       double local_zeta_increment;
       double local_zeta_insert;
       // How many vertices for each section
       unsigned local_n_vertices;

       std::list<double>::iterator l_it = zeta_values_pt.begin();
       std::list<double>::iterator r_it = zeta_values_pt.begin();
       r_it++;

       for (unsigned h = 0; r_it!=zeta_values_pt.end(); l_it++,r_it++,h++)
        {
         delta_z[h] = *r_it-*l_it;
        }

       l_it = r_it = zeta_values_pt.begin();
       r_it++;

       for (unsigned h = 0; r_it!=zeta_values_pt.end(); h++)
        {
         local_n_vertices =
          static_cast<unsigned>(((double)n_t_vertices * delta_z[h]) /
                    std::fabs(zeta_final - zeta_initial));

         local_zeta_initial = *l_it;
         local_zeta_final = *r_it;
         local_zeta_increment =
           (local_zeta_final - local_zeta_initial) /
           (double)(local_n_vertices + 1);

         for (unsigned s=0; s<local_n_vertices;s++)
          {
           local_zeta_insert =
             local_zeta_initial + local_zeta_increment*double(s+1);
           zeta_values_pt.insert(r_it, local_zeta_insert);
           n_assigned_vertices++;
          }
         // Moving to the next segment
         l_it = r_it;
         r_it++;

        }

       // Finishing it ...!!!
#ifdef PARANOID
       // Counting the vertices number and the total of
       // assigned vertices values
       unsigned s = zeta_values_pt.size();

       if (s!=n_assigned_vertices)
        {
         error_message
         << "The total number of assigned vertices is different from\n"
         << "the number of elements in the z_values list. The number"
         << "of\nelements in the z_values list is (" << s << ") but "
         << "the number\n"
         << "of assigned vertices is (" << n_assigned_vertices << ")."
         << std::endl << std::endl;
         throw OomphLibError(error_message.str(),
                             OOMPH_CURRENT_FUNCTION,
           OOMPH_EXCEPTION_LOCATION);
        }
#endif

       vertex_coord.resize(n_assigned_vertices);
       polygonal_vertex_arclength_info.resize(n_assigned_vertices);
       polygonal_vertex_arclength_info[0].first=0.0;
       polygonal_vertex_arclength_info[0].second=zeta_initial;

       // Creating the vertices with the corresponding z_values
       l_it = zeta_values_pt.begin();
       for (unsigned s = 0; l_it!=zeta_values_pt.end(); s++,l_it++)
        {
         // Get the coordinates
         zeta[0]= *l_it;
         boundary_pt->geom_object_pt()->position(zeta, posn);
         vertex_coord[s] = posn;

         // Bump up the polygonal arclength
         if (s>0)
          {
           polygonal_vertex_arclength_info[s].first=
             polygonal_vertex_arclength_info[s-1].first+
             sqrt(pow(vertex_coord[s][0]-vertex_coord[s-1][0],2)+
               pow(vertex_coord[s][1]-vertex_coord[s-1][1],2));
          }
        }
      }
     // Vertices placed in equal increments in (approximate) arclength
     else
      {
       // Compute the total arclength
       // Number of sampling points to compute arclength and
       // arclength increments
       unsigned nsample_per_segment=100;
       unsigned nsample=nsample_per_segment*n_seg;

       // Work out start and increment
       double zeta_increment=
         (zeta_final-zeta_initial)/(double(nsample));

       // Get coordinate of first point
       Vector<double> start_point(2);
       zeta[0]=zeta_initial;
       boundary_pt->geom_object_pt()->position(zeta,start_point);

       // Storage for coordinates of end point
       Vector<double> end_point(2);

       // Compute total arclength
       double total_arclength=0.0;
       for (unsigned i=1;i<nsample;i++)
        {
         // Next point
         zeta[0]+=zeta_increment;

         // Get coordinate of end point
         boundary_pt->geom_object_pt()->position(zeta,end_point);

         // Increment arclength
         total_arclength+=sqrt(pow(end_point[0]-start_point[0],2)+
           pow(end_point[1]-start_point[1],2));

         // Shift back
         start_point=end_point;
        }

       double local_zeta_initial;
       double local_zeta_final;
       double local_zeta_increment;

       // How many vertices per section
       unsigned local_n_vertices;

       std::list<double>::iterator l_it = zeta_values_pt.begin();
       std::list<double>::iterator r_it = zeta_values_pt.begin();
       r_it++;

       for (unsigned h = 0; r_it!=zeta_values_pt.end(); h++)
        {
         // There is no need to move the r_it iterator since it is
         // moved at the final of this loop
         local_zeta_initial = *l_it;
         local_zeta_final = *r_it;
         local_zeta_increment =
           (local_zeta_final - local_zeta_initial) /
           (double)(nsample);

         // Compute local arclength
         // Get coordinate of first point
         zeta[0]=local_zeta_initial;
         boundary_pt->geom_object_pt()->position(zeta, start_point);

         delta_z[h] = 0.0;

         for (unsigned i=1;i<nsample;i++)
          {
           // Next point
           zeta[0]+=local_zeta_increment;

           // Get coordinate of end point
           boundary_pt->geom_object_pt()->position(zeta, end_point);

           // Increment arclength
           delta_z[h]+=sqrt(pow(end_point[0]-start_point[0],2)+
             pow(end_point[1]-start_point[1],2));

           // Shift back
           start_point=end_point;
          }

         local_n_vertices =
          static_cast<unsigned>(((double)n_t_vertices * delta_z[h]) / 
                                (total_arclength));

         // Desired arclength increment
         double local_target_s_increment=
           delta_z[h]/double(local_n_vertices+1);

         // Get coordinate of first point again
         zeta[0]=local_zeta_initial;
         boundary_pt->geom_object_pt()->position(zeta, start_point);

         // Start sampling point
         unsigned i_lo=1;

         //Loop over the n_seg-1 internal points bounding the segments
         for(unsigned s=0;s<local_n_vertices;s++)
          {
           // Visit potentially all sample points until we've found
           // the one at which we exceed the target arclength increment
           double local_arclength_increment=0.0;
           for (unsigned i=i_lo;i<nsample;i++)
            //for (unsigned i=i_lo;i<nsample_per_segment;i++)
            {
             // Next point
             zeta[0]+=local_zeta_increment;

             // Get coordinate of end point
             boundary_pt->geom_object_pt()->position(zeta, end_point);

             // Increment arclength increment
             local_arclength_increment+=
               sqrt(pow(end_point[0]-start_point[0],2)+
                 pow(end_point[1]-start_point[1],2));

             // Shift back
             start_point=end_point;

             // Are we there yet?
             if (local_arclength_increment>local_target_s_increment)
              {
               // Remember how far we've got
               i_lo=i;

               // And bail out
               break;
              }
            }

           zeta_values_pt.insert(r_it, zeta[0]);
           n_assigned_vertices++;

          }
         // Moving to the next segments
         l_it = r_it;
         r_it++;
        }

       // Finishing it ... !!!
#ifdef PARANOID
       // Counting the vertices number and the total of
       // assigned vertices values
       unsigned h = zeta_values_pt.size();

       if (h!=n_assigned_vertices)
        {
         error_message
         << "The total number of assigned vertices is different from\n"
         << "the number of elements in the z_values list. The number of\n"
         << "elements in the z_values list is (" << h << ") but the number\n"
         << "of assigned vertices is (" << n_assigned_vertices << ")."
         << std::endl << std::endl;
         throw OomphLibError(error_message.str(),
                             OOMPH_CURRENT_FUNCTION,
           OOMPH_EXCEPTION_LOCATION);
        }
#endif

       vertex_coord.resize(n_assigned_vertices);
       polygonal_vertex_arclength_info.resize(n_assigned_vertices);
       polygonal_vertex_arclength_info[0].first=0.0;
       polygonal_vertex_arclength_info[0].second=zeta_initial;

       // Creating the vertices with the corresponding z_values
       l_it = zeta_values_pt.begin();
       for (unsigned s = 0; l_it!=zeta_values_pt.end(); s++,l_it++)
        {
         // Get the coordinates
         zeta[0]= *l_it;
         boundary_pt->geom_object_pt()->position(zeta, posn);
         vertex_coord[s] = posn;

         // Bump up the polygonal arclength
         if (s>0)
          {
           polygonal_vertex_arclength_info[s].first=
             polygonal_vertex_arclength_info[s-1].first+
             sqrt(pow(vertex_coord[s][0]-vertex_coord[s-1][0],2)+
               pow(vertex_coord[s][1]-vertex_coord[s-1][1],2));
           polygonal_vertex_arclength_info[s].second=zeta[0];
          }
        }
      } // Arclength uniformly spaced
    } // Less number of insertion points than vertices
  } // Function

  /// Boolean defining if Triangulateio object has been built or not
  bool Triangulateio_exists;

#endif
    
  /// Temporary scaffold mesh
  TriangleScaffoldMesh* Tmp_mesh_pt;
    
  /// \short Vector storing oomph-lib node number
  /// for all vertex nodes in the TriangulateIO representation of the mesh
  Vector<unsigned> Oomph_vertex_nodes_id;
  
  /// Vector of elements in each region differentiated by attribute (the key 
  /// of the map is the attribute)
  std::map<unsigned, Vector<FiniteElement* > > Region_element_pt;
  
  /// Vector of attributes associated with the elements in each region
  Vector<double> Region_attribute;
  
  /// Polygon that defines outer boundaries
  TriangleMeshPolygon* Outer_boundary_pt;
  
  /// Vector of polygons that define internal polygons
  Vector<TriangleMeshPolygon*> Internal_polygon_pt;
  
  /// Vector of open polylines that define internal curves
  Vector<TriangleMeshOpenCurve*> Internal_open_curve_pt;

  /// \short Storage for the geometric objects associated with any boundaries
  std::map<unsigned, GeomObject*> Boundary_geom_object_pt;

  /// Storage for extra coordinates for holes
  Vector<Vector<double> > Extra_holes_coordinates;

  /// Storage for extra coordinates for regions
  /// The key on the map is the region id
  std::map<unsigned, Vector<double> > Regions_coordinates;

  /// A map that stores the associated curve section of the specified
  /// boundary id
  std::map<unsigned, TriangleMeshCurveSection*> Boundary_curve_section_pt;

  /// A map that stores the vertices that receive connections, they
  /// are identified by the boundary number that receive the connection
  /// This is necessary for not erasing them on the adaptation process,
  /// specifically for the un-refinement process
  std::map<unsigned, std::set<Vector<double> > > Boundary_connections_pt;

  /// Storage for elements adjacent to a boundary in a particular region
  Vector<std::map<unsigned,Vector<FiniteElement*> > > 
   Boundary_region_element_pt;

  /// \short Storage for the face index adjacent to a boundary in a particular
  /// region
  Vector<std::map<unsigned,Vector<int> > > Face_index_region_at_boundary;

  /// \short  Storage for the limits of the boundary coordinates 
  /// defined by the of geometric objects. Only used for curvilinear
  /// boundaries.
  std::map<unsigned, Vector<double> > Boundary_coordinate_limits;

  /// \short Storage for pairs of doubles representing:
  /// .first: the arclength along the polygonal representation of
  ///         the curviline 
  /// .second: the corresponding intrinsic coordinate on the associated
  ///          geometric object
  /// at which the vertices on the specified boundary are located.
  /// Only used for boundaries represented by geom objects.
  std::map<unsigned,Vector<std::pair<double,double> > > 
   Polygonal_vertex_arclength_info;

  /// Timestepper used to build elements
  TimeStepper* Time_stepper_pt;

  /// Boolean flag to indicate whether to use attributes or not
  /// (required for multidomain meshes
  bool Use_attributes;

protected:

  // \short A set that contains the curve sections created by this object
  /// therefore it is necessary to free their associated memory
  std::set<TriangleMeshCurveSection*> Free_curve_section_pt;

  // \short A set that contains the polygons created by this object
  /// therefore it is necessary to free their associated memory
  std::set<TriangleMeshPolygon*> Free_polygon_pt;

  // \short A set that contains the open curves created by this
  /// object therefore it is necessary to free their associated memory
  std::set<TriangleMeshOpenCurve*> Free_open_curve_pt;
  
  /// \short Helper function for passing the connection information
  // from the input curve(polyline or curviline) to the output polyline
  void compute_connection_information(
      TriangleMeshCurveSection* input_curve_pt,
      TriangleMeshCurveSection* output_curve_pt,
      const bool invert_connection_information = false)
  {
   // Pass vertices connection information
   
   // Are we inverting the connection information?
   if (!invert_connection_information)
    {
     // Initial vertex
     if (input_curve_pt->is_initial_vertex_connected())
      {
       output_curve_pt->set_initial_vertex_connected();

       output_curve_pt->initial_vertex_connected_bnd_id() =
        input_curve_pt->initial_vertex_connected_bnd_id();

       // We need to know if we have to compute the vertex number or
       // if we need just to copy it
       if (input_curve_pt->is_initial_vertex_connected_to_curviline())
        {
         double initial_s_connection =
          input_curve_pt->initial_s_connection_value();

         unsigned bnd_id =
          output_curve_pt->initial_vertex_connected_bnd_id();

         double s_tolerance =
          input_curve_pt->tolerance_for_s_connection();

         output_curve_pt->initial_vertex_connected_n_vertex() =
          get_associated_vertex_to_svalue(
           initial_s_connection, bnd_id, s_tolerance);

         // The output polyline is not longer connected to a curviline because
         // we will be using the polyline representation of the curviline
         output_curve_pt->unset_initial_vertex_connected_to_curviline();

        }
       else
        {
         output_curve_pt->initial_vertex_connected_n_vertex() =
          input_curve_pt->initial_vertex_connected_n_vertex();

        }

       // Get the initial vertex coordinates
       Vector<double> initial_vertex;
       output_curve_pt->initial_vertex_coordinate(initial_vertex);

       // Boundary id to which the curve is connected
       unsigned bnd_id = output_curve_pt->initial_vertex_connected_bnd_id();

       // Establish the vertex coordinates as untouchable for the adaptation
       // process. It means that un-refinement can not take off the vertices
       // that receive connections
       this->Boundary_connections_pt[bnd_id].insert(initial_vertex);

      }

     // Final vertex
     if (input_curve_pt->is_final_vertex_connected())
      {
       output_curve_pt->set_final_vertex_connected();

       output_curve_pt->final_vertex_connected_bnd_id() =
        input_curve_pt->final_vertex_connected_bnd_id();

       // We need to know if we have to compute the vertex number or
       // if we need just to copy it
       if (input_curve_pt->is_final_vertex_connected_to_curviline())
        {
         double final_s_connection =
          input_curve_pt->final_s_connection_value();

         unsigned bnd_id =
          input_curve_pt->final_vertex_connected_bnd_id();

         double s_tolerance =
          input_curve_pt->tolerance_for_s_connection();

         output_curve_pt->final_vertex_connected_n_vertex() =
          get_associated_vertex_to_svalue(
           final_s_connection, bnd_id, s_tolerance);

         // The output polyline is not longer connected to a curviline because
         // we will be using the polyline representation of the curviline
         output_curve_pt->unset_final_vertex_connected_to_curviline();
        }
       else
        {
         output_curve_pt->final_vertex_connected_n_vertex() =
          input_curve_pt->final_vertex_connected_n_vertex();

        }

       // Get the final vertex coordinates
       Vector<double> final_vertex;
       output_curve_pt->final_vertex_coordinate(final_vertex);

       // Boundary id to which the curve is connected
       unsigned bnd_id = output_curve_pt->final_vertex_connected_bnd_id();

       // Establish the vertex coordinates as untouchable for the adaptation
       // process. It means that un-refinement can not take off the vertices
       // that receive connections
       this->Boundary_connections_pt[bnd_id].insert(final_vertex);

      }

    } // if (!invert_connection_information)
   else
    {
     // Invert the connection information
     // Initial vertex
     if (input_curve_pt->is_initial_vertex_connected())
      {
       output_curve_pt->set_final_vertex_connected();

       output_curve_pt->final_vertex_connected_bnd_id() =
        input_curve_pt->initial_vertex_connected_bnd_id();

       // We need to know if we have to compute the vertex number or
       // if we need just to copy it
       if (input_curve_pt->is_initial_vertex_connected_to_curviline())
        {
         double initial_s_connection =
          input_curve_pt->initial_s_connection_value();

         unsigned bnd_id =
          input_curve_pt->initial_vertex_connected_bnd_id();

         double s_tolerance =
          input_curve_pt->tolerance_for_s_connection();

         output_curve_pt->final_vertex_connected_n_vertex() =
          get_associated_vertex_to_svalue(
           initial_s_connection, bnd_id, s_tolerance);
         
         // The output polyline is not longer connected to a curviline because
         // we will be using the polyline representation of the curviline
         output_curve_pt->unset_final_vertex_connected_to_curviline();

        }
       else
        {
         output_curve_pt->final_vertex_connected_n_vertex() =
          input_curve_pt->initial_vertex_connected_n_vertex();

        }

       // Get the final vertex coordinates
       Vector<double> final_vertex;
       output_curve_pt->final_vertex_coordinate(final_vertex);

       // Boundary id to which the curve is connected
       unsigned bnd_id = output_curve_pt->final_vertex_connected_bnd_id();

       // Establish the vertex coordinates as untouchable for the adaptation
       // process. It means that un-refinement can not take off the vertices
       // that receive connections
       this->Boundary_connections_pt[bnd_id].insert(final_vertex);

      }

     // Final vertex
     if (input_curve_pt->is_final_vertex_connected())
      {
       output_curve_pt->set_initial_vertex_connected();

       output_curve_pt->initial_vertex_connected_bnd_id() =
        input_curve_pt->final_vertex_connected_bnd_id();

       // We need to know if we have to compute the vertex number or
       // if we need just to copy it
       if (input_curve_pt->is_final_vertex_connected_to_curviline())
        {
         double final_s_connection =
          input_curve_pt->final_s_connection_value();

         unsigned bnd_id =
          input_curve_pt->final_vertex_connected_bnd_id();

         double s_tolerance =
          input_curve_pt->tolerance_for_s_connection();

         output_curve_pt->initial_vertex_connected_n_vertex() =
          get_associated_vertex_to_svalue(
           final_s_connection, bnd_id, s_tolerance);

         // The output polyline is not longer connected to a curviline because
         // we will be using the polyline representation of the curviline
         output_curve_pt->unset_initial_vertex_connected_to_curviline();
        }
       else
        {
         output_curve_pt->initial_vertex_connected_n_vertex() =
          input_curve_pt->final_vertex_connected_n_vertex();

        }

       // Get the final vertex coordinates
       Vector<double> initial_vertex;
       output_curve_pt->initial_vertex_coordinate(initial_vertex);

       // Boundary id to which the curve is connected
       unsigned bnd_id = output_curve_pt->initial_vertex_connected_bnd_id();

       // Establish the vertex coordinates as untouchable for the adaptation
       // process. It means that un-refinement can not take off the vertices
       // that receive connections
       this->Boundary_connections_pt[bnd_id].insert(initial_vertex);

      }
     
    } // else if (!invert_connection_information)

  }

private:

  /// \short Helper function that creates the associated polyline
  /// representation for curvilines
  TriangleMeshCurveSection *curviline_to_polyline(
      TriangleMeshCurviLine* &curviline_pt,  unsigned &bnd_id)
  {

   // Create vertex coordinates for polygonal representation
   Vector<Vector<double> > bound;
   Vector<std::pair<double,double> > polygonal_vertex_arclength;

   if (curviline_pt->are_there_connection_points())
    {
     create_vertex_coordinates_for_polyline_connections(
       curviline_pt, bound, polygonal_vertex_arclength);
    }
   else
    {
     create_vertex_coordinates_for_polyline_no_connections(
       curviline_pt, bound, polygonal_vertex_arclength);
    }

   // Store the vertex-arclength information
   Polygonal_vertex_arclength_info[bnd_id]=polygonal_vertex_arclength;

   // Build associated polyline
   return new TriangleMeshPolyLine(bound, bnd_id);

  }

  /// \short Get the associated vertex to the given s value by looking to
  /// the list of s values created when changing from curviline to polyline
  unsigned get_associated_vertex_to_svalue(
      double &target_s_value,
      unsigned &bnd_id,
      const double &s_tolerance = 1.0e-14)
  {
   // Create a pointer to the list of s coordinates and arclength values
   // associated with a vertex
    Vector<std::pair<double, double> > *vertex_info =
      &Polygonal_vertex_arclength_info[bnd_id];

    // Total vertex number
    unsigned vector_size = vertex_info->size();

    // Counter for current vertex number
    unsigned n_vertex = 0;

    // Find the associated value to the given s value
    do {
        // Store the current zeta value
        double s = (*vertex_info)[n_vertex].second;

        // When find it save the vertex number and return it
        if (std::fabs(s - target_s_value) < s_tolerance)
         {
          break;
         }

        n_vertex++;

    }while(n_vertex < vector_size);

#ifdef PARANOID
    if (n_vertex >= vector_size)
      {
        std::ostringstream error_message;
        error_message
        << "Could not find the associated vertex number in\n"
        << "boundary " << bnd_id << " with the given s\n"
        << "connection value (" << target_s_value << ") using\n"
        << "this tolerance: " << s_tolerance << std::endl;
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
            OOMPH_EXCEPTION_LOCATION);
      }
#endif

    return n_vertex;

  }

  // \short Helper function that returns a polygon representation for
  /// the given closed curve, it also computes the maximum boundary id of
  /// the constituent curves.
  /// If the TriangleMeshClosedCurve is already a TriangleMeshPolygon
  /// we simply return a pointer to it. Otherwise a new TrilangleMeshPolygon
  /// is created -- this is deleted automatically when the TriangleMesh
  /// destructor is called, so no external book-keeping is required.
  TriangleMeshPolygon *closed_curve_to_polygon_helper(
    TriangleMeshClosedCurve* closed_curve_pt,
    unsigned &max_bnd_id_local)
  {
   // How many separate boundaries do we have
   unsigned nb = closed_curve_pt->ncurve_section();

#ifdef PARANOID
   if (nb<2)
    {
     std::ostringstream error_message;
     error_message
     << "TriangleMeshClosedCurve that defines outer boundary\n"
     << "must be made up of at least two "
     << "TriangleMeshCurveSections\n"
     << "to allow the automatic set up boundary coordinates.\n"
     << "Yours only has (" << nb << ")" << std::endl;
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
    }
#endif
   
   // Provide storage for accompanying polylines
   Vector<TriangleMeshCurveSection*> my_boundary_polyline_pt(nb);
   // Store refinement tolerance
   Vector<double> refinement_tolerance(nb);
   // Store unrefinement tolerance
   Vector<double> unrefinement_tolerance(nb);
   // Store max. length
   Vector<double> max_length(nb);
   
   // Loop over boundaries that make up this boundary
   for (unsigned b=0;b<nb;b++)
    {
     // Get pointer to the curve segment boundary that makes up
     // this part of the boundary
     TriangleMeshCurviLine *curviline_pt =
      dynamic_cast<TriangleMeshCurviLine*>(
       closed_curve_pt->curve_section_pt(b));
     
     TriangleMeshPolyLine *polyline_pt =
      dynamic_cast<TriangleMeshPolyLine*>(
       closed_curve_pt->curve_section_pt(b));
     
     if (curviline_pt != 0)
      {
       // Boundary id
       unsigned bnd_id = curviline_pt->boundary_id();
       
       // Build associated polyline
       my_boundary_polyline_pt[b] =
        curviline_to_polyline(curviline_pt, bnd_id);
       
       // Copy the unrefinement tolerance
       unrefinement_tolerance[b] = curviline_pt->unrefinement_tolerance();
       // Copy the refinement tolerance
       refinement_tolerance[b] = curviline_pt->refinement_tolerance();
       // Copy the maximum length
       max_length[b] = curviline_pt->maximum_length();
       
       // Updates bnd_id<--->curve section map
       Boundary_curve_section_pt[bnd_id] = my_boundary_polyline_pt[b];
         
       // Keep track of curve sections that need to be deleted!!!
       Free_curve_section_pt.insert(my_boundary_polyline_pt[b]);

       // Keep track...
       if (bnd_id>max_bnd_id_local)
        {
         max_bnd_id_local=bnd_id;
        }

      }
     else if (polyline_pt != 0)
      {
       // Boundary id
       unsigned bnd_id=polyline_pt->boundary_id();
       
       // Pass the pointer of the already existing polyline
       my_boundary_polyline_pt[b] = polyline_pt;
       
       // Copy the unrefinement tolerance
       unrefinement_tolerance[b] = polyline_pt->unrefinement_tolerance();
       // Copy the refinement tolerance
       refinement_tolerance[b] = polyline_pt->refinement_tolerance();
       // Copy the maximum length
       max_length[b] = polyline_pt->maximum_length();
       
       // Updates bnd_id<--->curve section map
       Boundary_curve_section_pt[bnd_id] = my_boundary_polyline_pt[b];

       // Keep track...
       if (bnd_id>max_bnd_id_local)
        {
         max_bnd_id_local=bnd_id;
        }
      }
     else
      {
       std::ostringstream error_stream;
       error_stream
        << "The 'curve_segment' is not a curviline neither a\n "
        << "polyline: What is it?\n"
        << std::endl;
       throw OomphLibError(
        error_stream.str(),
        OOMPH_CURRENT_FUNCTION,
        OOMPH_EXCEPTION_LOCATION);
      }

    } //end of loop over boundaries
   
   // Create a new polygon by using the new created polylines
   TriangleMeshPolygon *output_polygon_pt =
    new TriangleMeshPolygon(my_boundary_polyline_pt,
                            closed_curve_pt->internal_point());
   
   // Keep track of new created polygons that need to be deleted!!!
   Free_polygon_pt.insert(output_polygon_pt);
   
   // Pass on refinement information
   output_polygon_pt->set_polyline_refinement_tolerance(
    closed_curve_pt->polyline_refinement_tolerance());
   output_polygon_pt->set_polyline_unrefinement_tolerance(
    closed_curve_pt->polyline_unrefinement_tolerance());
   
   // Loop over boundaries that make up this boundary and copy
   // refinement, unrefinement and max length information
   for (unsigned b=0;b<nb;b++)
     {
       // Set the unrefinement and refinement information
       my_boundary_polyline_pt[b]->
         set_unrefinement_tolerance(unrefinement_tolerance[b]);
       
       my_boundary_polyline_pt[b]->
         set_refinement_tolerance(refinement_tolerance[b]);
       
       // Copy the maximum length constraint
       my_boundary_polyline_pt[b]->set_maximum_length(max_length[b]);
     }
   
   return output_polygon_pt;

  }
  
  // \short Helper function that creates and returns an open curve with
  /// the polyline representation of its constituent curve sections. The
  /// new created open curve is deleted when the TriangleMesh destructor
  /// is called
  TriangleMeshOpenCurve *create_open_curve_with_polyline_helper(
    TriangleMeshOpenCurve* open_curve_pt,
    unsigned &max_bnd_id_local)
  {
   unsigned nb=open_curve_pt->ncurve_section();

   // Provide storage for accompanying polylines
   Vector<TriangleMeshCurveSection*> my_boundary_polyline_pt(nb);
   // Store refinement tolerance
   Vector<double> refinement_tolerance(nb);
   // Store unrefinement tolerance
   Vector<double> unrefinement_tolerance(nb);
   // Store max. length
   Vector<double> max_length(nb);
   
   //Loop over the number of curve sections on the open curve
   for (unsigned i = 0; i < nb; i++)
    {
     // Get pointer to the curve segment boundary that makes up
     // this part of the boundary
     TriangleMeshCurviLine *curviline_pt =
       dynamic_cast<TriangleMeshCurviLine*>(
         open_curve_pt->curve_section_pt(i));
     TriangleMeshPolyLine *polyline_pt =
       dynamic_cast<TriangleMeshPolyLine*>(
         open_curve_pt->curve_section_pt(i));

     if (curviline_pt != 0)
      {
       // Boundary id
       unsigned bnd_id = curviline_pt->boundary_id();

       // Build associated polyline
       my_boundary_polyline_pt[i] =
         curviline_to_polyline(curviline_pt, bnd_id);
       
       // Copy the unrefinement tolerance
       unrefinement_tolerance[i] = curviline_pt->unrefinement_tolerance();
       // Copy the refinement tolerance
       refinement_tolerance[i] = curviline_pt->refinement_tolerance();
       // Copy the maximum length
       max_length[i] = curviline_pt->maximum_length();
       
       // Pass the connection information to the polyline representation
       compute_connection_information(
         curviline_pt, my_boundary_polyline_pt[i]);
       
       // Updates bnd_id<--->curve section map
       Boundary_curve_section_pt[bnd_id] = my_boundary_polyline_pt[i];

       // Keep track of curve sections that need to be deleted!!!
       Free_curve_section_pt.insert(my_boundary_polyline_pt[i]);

       // Keep track...
       if (bnd_id>max_bnd_id_local)
        {
         max_bnd_id_local=bnd_id;
        }

      }
     else if (polyline_pt != 0)
      {
       // Boundary id
       unsigned bnd_id=polyline_pt->boundary_id();

       // Storage pointer
       my_boundary_polyline_pt[i] = polyline_pt;
       
       // Copy the unrefinement tolerance
       unrefinement_tolerance[i] = polyline_pt->unrefinement_tolerance();
       // Copy the refinement tolerance
       refinement_tolerance[i] = polyline_pt->refinement_tolerance();
       // Copy the maximum length
       max_length[i] = polyline_pt->maximum_length();
       
       // Pass the connection information to the polyline representation
       compute_connection_information(polyline_pt, my_boundary_polyline_pt[i]);
       
       // Updates bnd_id<--->curve section map
       Boundary_curve_section_pt[bnd_id] = my_boundary_polyline_pt[i];

       // Keep track...
       if (bnd_id>max_bnd_id_local)
        {
         max_bnd_id_local=bnd_id;
        }

      }
     else
      {
       std::ostringstream error_stream;
       error_stream
       << "The 'curve_segment' (open) is not a curviline neither a\n "
       << "polyline: What is it?\n"
       << std::endl;
       throw OomphLibError(error_stream.str(),
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
      }

    } // end of loop over boundaries

   // Create open curve with polylines boundaries
   TriangleMeshOpenCurve *output_open_polyline_pt =
     new TriangleMeshOpenCurve(my_boundary_polyline_pt);

   // Keep track of open polylines that need to be deleted!!!
   Free_open_curve_pt.insert(output_open_polyline_pt);

   // Pass on refinement information
   output_open_polyline_pt->set_polyline_refinement_tolerance(
     open_curve_pt->polyline_refinement_tolerance());
   output_open_polyline_pt->set_polyline_unrefinement_tolerance(
     open_curve_pt->polyline_unrefinement_tolerance());
   
   // Loop over boundaries that make up this boundary and copy
   // refinement, unrefinement and max length information
   for (unsigned b=0;b<nb;b++)
     {
       // Set the unrefinement and refinement information
       my_boundary_polyline_pt[b]->
         set_unrefinement_tolerance(unrefinement_tolerance[b]);
       
       my_boundary_polyline_pt[b]->
         set_refinement_tolerance(refinement_tolerance[b]);
       
       // Copy the maximum length constraint
       my_boundary_polyline_pt[b]->set_maximum_length(max_length[b]);
     }
   
   return output_open_polyline_pt;

  }

  // \short Stores the geometric objects associated to the
  /// curve sections that compound the closed curve. It also
  /// stores the limits defined by these geometric objects
  void set_geom_objects_and_coordinate_limits_for_close_curve(
    TriangleMeshClosedCurve* input_closed_curve_pt)
  {

   unsigned nb=input_closed_curve_pt->ncurve_section();

#ifdef PARANOID
   if (nb<2)
    {
     std::ostringstream error_message;
     error_message
     << "TriangleMeshCurve that defines closed boundary\n"
     << "must be made up of at least two "
     << "TriangleMeshCurveSection\n"
     << "to allow the automatic set up boundary coordinates.\n"
     << "Yours only has " << nb << std::endl;
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
    }
#endif

   // TODO: Used for the ImmersedRigidBodyTriangleMeshPolygon objects only
   //ImmersedRigidBodyTriangleMeshPolygon* bound_geom_obj_pt
   GeomObject* bound_geom_obj_pt
    //= dynamic_cast<ImmersedRigidBodyTriangleMeshPolygon*>(
    = dynamic_cast<GeomObject*>(
      input_closed_curve_pt);

   //If cast successful set up the coordinates
   if(bound_geom_obj_pt!=0)
    {
     unsigned n_poly = input_closed_curve_pt->ncurve_section();
     for(unsigned p=0;p<n_poly;p++)
      {
       //Read out the index of the boundary from the polyline
       unsigned b_index =
         input_closed_curve_pt->curve_section_pt(p)->boundary_id();

       //Set the geometric object
       Boundary_geom_object_pt[b_index] = bound_geom_obj_pt;

       //The coordinates along each polyline boundary are scaled to
       //of unit length so the total coordinate limits are simply
       //(p,p+1)
       Boundary_coordinate_limits[b_index].resize(2);
       Boundary_coordinate_limits[b_index][0] = p;
       Boundary_coordinate_limits[b_index][1] = p + 1.0;
      }
    }
   else
    {
     // Loop over curve sections that make up this boundary
     for (unsigned b=0;b<nb;b++)
      {
       TriangleMeshCurviLine* curviline_pt =
         dynamic_cast<TriangleMeshCurviLine*>
       (input_closed_curve_pt->curve_section_pt(b));

       if (curviline_pt != 0)
        {
         //Read the values of the limiting coordinates
         Vector<double> zeta_bound(2);
         zeta_bound[0] = curviline_pt->zeta_start();
         zeta_bound[1] = curviline_pt->zeta_end();

         // Boundary id
         unsigned bnd_id=curviline_pt->boundary_id();

         //Set the boundary geometric object and limits
         Boundary_geom_object_pt[bnd_id] =
           curviline_pt->geom_object_pt();
         Boundary_coordinate_limits[bnd_id] = zeta_bound;
        }
      } // for
    } // else
  } // function

  // \short Stores the geometric objects associated to the
  /// curve sections that compound the open curve. It also
  /// stores the limits defined by these geometric objects
  void set_geom_objects_and_coordinate_limits_for_open_curve(
    TriangleMeshOpenCurve* input_open_curve_pt)
  {
   unsigned nb=input_open_curve_pt->ncurve_section();

   // Loop over curve sections that make up this boundary
   for (unsigned b=0;b<nb;b++)
    {

     TriangleMeshCurviLine* curviline_pt =
       dynamic_cast<TriangleMeshCurviLine*>
     (input_open_curve_pt->curve_section_pt(b));

     if (curviline_pt != 0)
      {
       //Read the values of the limiting coordinates
       Vector<double> zeta_bound(2);
       zeta_bound[0] = curviline_pt->zeta_start();
       zeta_bound[1] = curviline_pt->zeta_end();

       // Boundary id
       unsigned bnd_id=curviline_pt->boundary_id();

       //Set the boundary geometric object and limits
       Boundary_geom_object_pt[bnd_id] =
         curviline_pt->geom_object_pt();
       Boundary_coordinate_limits[bnd_id] = zeta_bound;
      }
    } // for
  } // function

 };


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////



#ifdef OOMPH_HAS_TRIANGLE_LIB  
 
//=========================================================================
/// Unstructured refineable Triangle Mesh 
//=========================================================================
template<class ELEMENT>
 class RefineableTriangleMesh : public virtual TriangleMesh<ELEMENT>,
  public virtual RefineableMeshBase
  {
   
    public:

   /// \short Function pointer to function that updates the 
   /// mesh following the snapping of boundary nodes to the
   /// boundaries (e.g. to move boundary nodes very slightly 
   /// to satisfy volume constraints)
   typedef void (*MeshUpdateFctPt)(Mesh* mesh_pt);

   /// \short Build mesh, based on the specifications on
   /// TriangleMeshParameters
   RefineableTriangleMesh(
     TriangleMeshParameters &triangle_mesh_parameters, 
     TimeStepper* time_stepper_pt=&Mesh::Default_TimeStepper)
    : TriangleMesh<ELEMENT>(triangle_mesh_parameters, time_stepper_pt)
      {
        // Initialise the data associated with adaptation
        initialise_adaptation_data();
      }
   
   /// \short Build mesh, based on the polyfiles
    RefineableTriangleMesh(const std::string& node_file_name,
                           const std::string& element_file_name,
                           const std::string& poly_file_name,
                           TimeStepper* time_stepper_pt=
                           &Mesh::Default_TimeStepper)
     : TriangleMesh<ELEMENT>(node_file_name, 
                             element_file_name, 
                             poly_file_name, 
                             time_stepper_pt)
     {
      // Create and fill the data structures to give rise to polylines so that
      // the mesh can use the adapt methods
      create_polylines_from_polyfiles(node_file_name, poly_file_name);
      
      // Initialise the data associated with adaptation
      initialise_adaptation_data();
     }
    
   /// \short Build mesh from specified triangulation and
   /// associated target areas for elements in it
   RefineableTriangleMesh(const Vector<double> &target_area,
                          TriangulateIO& triangulate_io,
                          TimeStepper* time_stepper_pt=
                              &Mesh::Default_TimeStepper,
                          const bool &use_attributes=false)
    {
     // Initialise the data associated with adaptation
     initialise_adaptation_data();
     
     // Store Timestepper used to build elements
     this->Time_stepper_pt=time_stepper_pt;

     // Create triangulateio object to refine
     TriangulateIO triangle_refine;
     
     // Initialize triangulateio structure
     TriangleHelper::initialise_triangulateio(this->Triangulateio);
     
     // Triangulation has been created -- remember to wipe it!
     this->Triangulateio_exists=true;
     
     // Create refined  TriangulateIO structure based on target areas
     this->refine_triangulateio(triangulate_io,
                                target_area,
                                triangle_refine);

     // Input string for triangle
     std::stringstream input_string_stream;
     input_string_stream<<"-pq30-ra"; 
     
     // Convert to a *char required by the triangulate function
     char triswitches[100];
     sprintf(triswitches,"%s",input_string_stream.str().c_str());
     
     // Build triangulateio refined object
     triangulate(triswitches, &triangle_refine, &this->Triangulateio, 0);
     // Build scaffold
     this->Tmp_mesh_pt=new TriangleScaffoldMesh(this->Triangulateio);

     // Convert mesh from scaffold to actual mesh
     this->build_from_scaffold(time_stepper_pt,use_attributes);
     
     // Kill the scaffold
     delete this->Tmp_mesh_pt;
     this->Tmp_mesh_pt=0;
     
     // Cleanup but leave hole alone as it's still used
     bool clear_hole_data=false;
     TriangleHelper::clear_triangulateio(triangle_refine,clear_hole_data);

     // Setup boundary coordinates for boundaries
     unsigned nb=nboundary();
     for (unsigned b=0;b<nb;b++)
      {
       this->setup_boundary_coordinates(b);
      }       
    }   
   
   /// Empty Destructor
   virtual ~RefineableTriangleMesh() {}
     
  /// \short Read/write access to number of bins in the x-direction
  /// when transferring target areas by bin method
  unsigned& nbin_x_for_area_transfer(){return Nbin_x_for_area_transfer;}
  
  /// \short Read/write access to number of bins in the y-direction
  /// when transferring target areas by bin method
  unsigned& nbin_y_for_area_transfer(){return Nbin_y_for_area_transfer;}
  
  /// \short Read/write access to number of bins in the x-direction
  /// when projecting old solution onto new mesh
  unsigned& nbin_x_for_projection(){return Nbin_x_for_projection;}
  
  /// \short Read/write access to number of bins in the y-direction
  /// when projecting old solution onto new mesh
  unsigned& nbin_y_for_projection(){return Nbin_y_for_projection;}
  
  /// Max element size allowed during adaptation
  double& max_element_size(){return Max_element_size;}
  
  /// Min element size allowed during adaptation
  double& min_element_size(){return Min_element_size;}
  
  /// Min angle before remesh gets triggered
  double& min_permitted_angle(){return Min_permitted_angle;}
  
  /// Doc the targets for mesh adaptation
  void doc_adaptivity_targets(std::ostream &outfile)
  {
   outfile << std::endl;
   outfile << "Targets for mesh adaptation: " << std::endl;
   outfile << "---------------------------- " << std::endl;
   outfile << "Target for max. error: " << Max_permitted_error << std::endl;
   outfile << "Target for min. error: " << Min_permitted_error << std::endl;
   outfile << "Target min angle: " << Min_permitted_angle << std::endl;
   outfile << "Min. allowed element size: " << Min_element_size << std::endl;
   outfile << "Max. allowed element size: " << Max_element_size << std::endl;
   outfile << "Don't unrefine if less than " << Max_keep_unrefined 
           << " elements need unrefinement." << std::endl;
   outfile << std::endl;
  }
  
   
   /// Refine mesh uniformly and doc process
   void refine_uniformly(DocInfo& doc_info)
   {
    // Set the element error to something big
    unsigned nelem=nelement();
    Vector<double> elem_error(nelem,DBL_MAX);

    // Limit the min element size to 1/3 of the current minimum
    double backup=Min_element_size;
    
    // Get current max and min element size
    double orig_max_area, orig_min_area;
    this->max_and_min_element_size(orig_max_area, orig_min_area);

    // Limit
    Min_element_size=orig_min_area/3.0;

    // Do it...
    adapt(elem_error);

    // Reset 
    Min_element_size=backup;

/*     throw OomphLibError("refine_uniformly() not implemented yet", */
/*                         OOMPH_CURRENT_FUNCTION, */
/*                         OOMPH_EXCEPTION_LOCATION);  */
   }    
   
   
   /// \short Unrefine mesh uniformly: Return 0 for success,
   /// 1 for failure (if unrefinement has reached the coarsest permitted
   /// level)
   unsigned unrefine_uniformly()
   {
    throw OomphLibError("unrefine_uniformly() not implemented yet",
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION); 
    // dummy return
    return 0;
   }
   
   /// Adapt mesh, based on elemental error provided
   void adapt(const Vector<double>& elem_error); 
   
   /// \short Access to function pointer to function that updates the 
   /// mesh following the snapping of boundary nodes to the
   /// boundaries (e.g. to move boundary nodes very slightly 
   /// to satisfy volume constraints)
   MeshUpdateFctPt& mesh_update_fct_pt()
   {
    return Mesh_update_fct_pt;
   }
   
    protected:
   
   /// Helper function to create polylines and fill associate data 
   // structures, used when creating from a mesh from polyfiles
   void create_polylines_from_polyfiles(const std::string& node_file_name,
                                        const std::string& poly_file_name);
   
   /// Helper function that checks if a given point is inside a polygon
   bool is_point_inside_polygon(Vector<Vector<double> > polygon_vertices,
                                Vector<double> point);
   
   /// \short Helper function that performs the unrefinement process
   /// on the specified boundary by using the provided vertices
   /// representation. Optional boolean is used to run it as test only (if
   /// true is specified as input) in which case vertex coordinates aren't
   /// actually modified. Returned boolean indicates if polyline was (or
   /// would have been -- if called with check_only=false) changed.
   bool unrefine_boundary(const unsigned &b,
                          Vector<Vector<double> > &vector_bnd_vertices,
                          double &unrefinement_tolerance,
                          const bool &check_only = false);

   /// \short Helper function that performs the refinement process
   /// on the specified boundary by using the provided vertices
   /// representation. Optional boolean is used to run it as test only (if
   /// true is specified as input) in which case vertex coordinates aren't
   /// actually modified. Returned boolean indicates if polyline was (or
   /// would have been -- if called with check_only=false) changed.
   bool refine_boundary(Mesh* face_mesh_pt,
                        Vector<Vector<double> > &vector_bnd_vertices,
                        double &refinement_tolerance,
                        const bool &check_only = false);

   // \short Helper function that applies the maximum length constraint
   // when it was specified. This will increase the number of points in
   // the current curve section in case that any segment on it does not
   // fulfils the requirement
   bool apply_max_length_constraint(Mesh* face_mesh_pt,
				    Vector<Vector<double> > 
				    &vector_bnd_vertices,
				    double &max_length_constraint);

   /// \short Computes the associated vertex number on the destination
   /// boundary
   bool get_connected_vertex_number_on_dst_boundary(
     Vector<double> &vertex_coordinates,
     const unsigned &dst_b_id, unsigned &vertex_number);

   /// \short Restore the connections on the specific internal
   /// boundary. They could be change on the vertices numbering when
   /// adding (refinement) or erasing (unrefinement) nodes (vertices).
   /// If we call with the "first_try = true" it returns false in case
   /// it could not restore any connections and is expected to invert
   /// the connection information of the polyline.  When it is called
   /// with "first_try = false" (only after inverting the connection
   /// information of the polyline) then it throws an error in case it
   /// could not restore the connections
   bool restore_connections_on_internal_boundary(
    TriangleMeshPolyLine* polyline_pt,
    const bool first_try = true);
   
   /// \short Helper function that updates the input polygon's PSLG
   /// by using the end-points of elements from FaceMesh(es) that are
   /// constructed for the boundaries associated with the segments of the
   /// polygon. Optional boolean is used to run it as test only (if 
   /// true is specified as input) in which case polygon isn't actually
   /// modified. Returned boolean indicates if polygon was (or would have
   /// been -- if called with check_only=false) changed. 
   bool update_polygon_using_face_mesh(TriangleMeshPolygon* polygon_pt,
                                       const bool& check_only=false);
   
   /// \short Helper function that updates the input open curve by using
   /// end-points of elements from FaceMesh(es) that are constructed for the
   /// boundaries associated with the polylines. Optional boolean is used to
   /// run it as test only (if true is specified as input) in which case the
   /// polylines are not actually modified. Returned boolean indicates if
   /// polylines were (or would have been -- if called with check_only=false)
   /// changed.
   bool update_open_curve_using_face_mesh(
     TriangleMeshOpenCurve* open_polyline_pt,
     const bool& check_only=false);

   /// \short Generate a new PSLG representation of the inner hole
   /// boundaries. Optional boolean is used to run it as test only (if 
   /// true is specified as input) in which case PSLG isn't actually
   /// modified. Returned boolean indicates if PSLG was (or would have
   /// been -- if called with check_only=false) changed. 
   virtual bool surface_remesh_for_inner_hole_boundaries(
    Vector<Vector<double> > &internal_point_coord,
    const bool& check_only=false);
   
  /// \short Snap the boundary nodes onto any curvilinear boundaries
  void snap_nodes_onto_boundary(RefineableTriangleMesh<ELEMENT>* &new_mesh_pt,
                                const unsigned &b);
 
  /// \short Helper function
  /// Creates an unsorted face mesh representation from the specified
  /// boundary id. It means that the elements are not sorted along the
  /// boundary
  void create_unsorted_face_mesh_representation(
      const unsigned &boundary_id,
      Mesh* face_mesh_pt);

  /// \short Helper function
  /// Creates a sorted face mesh representation of the specified PolyLine
  /// It means that the elements are sorted along the boundary
  /// It also returns a map that indicated the inverted elements
  void create_sorted_face_mesh_representation(
      const unsigned &boundary_id,
      Mesh* face_mesh_pt,
      std::map<FiniteElement*, bool> &is_inverted,
      bool &inverted_face_mesh);

  /// \short Helper function to construct face mesh representation of all 
  /// polylines, possibly with segments re-distributed between polylines 
  /// to maintain an appxroximately even sub-division of the polygon
  void get_face_mesh_representation(TriangleMeshPolygon* polygon_pt,
                                    Vector<Mesh*>& face_mesh_pt);
 
  /// \short Helper function to construct face mesh representation of
  /// open curves
  void get_face_mesh_representation(
    TriangleMeshOpenCurve* open_polyline_pt,
    Vector<Mesh*>& face_mesh_pt);

  /// Helper function to initialise data associated with adaptation
  void initialise_adaptation_data()
  {
   // Number of bins in the x-direction
   // when transferring target areas by bin method
   this->Nbin_x_for_area_transfer=100;

   // Number of bins in the y-direction
   // when transferring target areas by bin method
   this->Nbin_y_for_area_transfer=100;
   
   /// Number of bins in the x-direction when projecting the solution
   /// from the old mesh into the new mesh
   this->Nbin_x_for_projection=100;
   
   /// Number of bins in the y-direction when projecting the solution
   /// from the old mesh into the new mesh
   this->Nbin_y_for_projection=100;
   
   // Set max and min targets for adaptation
   this->Max_element_size=1.0;
   this->Min_element_size=0.001;
   this->Min_permitted_angle=15.0;


   // Initialise function pointer to function that updates the
   // mesh following the snapping of boundary nodes to the
   // boundaries (e.g. to move boundary nodes very slightly
   // to satisfy volume constraints)
   Mesh_update_fct_pt=0;

  }
   
   /// \short Build a new TriangulateIO object from previous TriangulateIO
   /// based on target area for each element
   void refine_triangulateio(TriangulateIO& triangulate_io, 
                             const Vector<double> &target_area,
                             TriangulateIO &triangle_refine);
   

   /// \short Compute target area based on the element's error and the
   /// error target; return minimum angle (in degrees)
   double compute_area_target(const Vector<double> &elem_error,
                              Vector<double> &target_area)
   {
    double min_angle=DBL_MAX;
    unsigned count_unrefined=0;
    unsigned count_refined=0;
    this->Nrefinement_overruled=0;
    
    unsigned nel=this->nelement();
    for (unsigned e=0;e<nel;e++)
     {
      
      // Get element
      FiniteElement* el_pt=this->finite_element_pt(e);
      
      // Area 
      double area=el_pt->size();


      // Min angle based on vertex coordinates
      // (vertices are enumerated first)
      double ax=el_pt->node_pt(0)->x(0);
      double ay=el_pt->node_pt(0)->x(1);
        
      double bx=el_pt->node_pt(1)->x(0);
      double by=el_pt->node_pt(1)->x(1);
        
      double cx=el_pt->node_pt(2)->x(0);
      double cy=el_pt->node_pt(2)->x(1);
        
      // Min angle
      double angle0=
       acos(((ax-cx)*(bx-cx)+(ay-cy)*(by-cy))/
            (sqrt((ax-cx)*(ax-cx)+(ay-cy)*(ay-cy))*
             sqrt((bx-cx)*(bx-cx)+(by-cy)*(by-cy))))*
       180.0/MathematicalConstants::Pi;
      min_angle=std::min(min_angle,angle0);
        
      double angle1=
       acos(((ax-bx)*(cx-bx)+(ay-by)*(cy-by))/
            (sqrt((ax-bx)*(ax-bx)+(ay-by)*(ay-by))*
             sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by))))*
       180.0/MathematicalConstants::Pi;
      min_angle=std::min(min_angle,angle1);
        
      double angle2=180.0-angle0-angle1;
      min_angle=std::min(min_angle,angle2);
        
        // Mimick refinement in tree-based procedure: Target areas
        // for elements that exceed permitted error is 1/3 of their
        // current area, corresponding to a uniform sub-division.
        double size_ratio=3.0;
        if (elem_error[e]>max_permitted_error())
         {
          // Reduce area
          target_area[e]=std::max(area/size_ratio,Min_element_size);
          
          //...but also make sure we're below the max element size
          target_area[e]=std::min(target_area[e],Max_element_size);
          
          if (target_area[e]!=Min_element_size)
           {
            count_refined++;
           }
          else
           {
            this->Nrefinement_overruled++;
           }
         }
        else if (elem_error[e]<min_permitted_error())
         {
          // Increase the area
          target_area[e]=std::min(size_ratio*area,Max_element_size);
          
          //...but also make sure we're above the min element size
          target_area[e]=std::max(target_area[e],Min_element_size);
          
          if (target_area[e]!=Max_element_size)
           {
            count_unrefined++;
           }
         }
        else
         {
          // Leave it alone but enforce size limits
          double area_leave_alone = std::max(area,Min_element_size); 
          target_area[e] = std::min(area_leave_alone,Max_element_size); 
         }
     }
      
    
    // Tell everybody
    this->Nrefined=count_refined;
    this->Nunrefined=count_unrefined;
    
    if (this->Nrefinement_overruled!=0)
     {
      oomph_info 
       << "\nNOTE: Refinement of " 
       << this->Nrefinement_overruled << " elements was "
       << "overruled \nbecause the target area would have "
       << "been below \nthe minimum permitted area of " 
       << Min_element_size 
       << ".\nYou can change the minimum permitted area with the\n"
       << "function RefineableTriangleMesh::min_element_size().\n\n";
     }
    return min_angle;
   }
  
   /// \short Number of bins in the x-direction
   /// when transferring target areas by bin method.
   unsigned Nbin_x_for_area_transfer;

   /// \short Number of bins in the y-direction
   /// when transferring target areas by bin method.
   unsigned Nbin_y_for_area_transfer;

   /// \short Number of bins in the x-direction when projecting the
   /// solution from the old mesh into the new mesh
   unsigned Nbin_x_for_projection;
   
   /// \short Number of bins in the y-direction when projecting the
   /// solution from the old mesh into the new mesh
   unsigned Nbin_y_for_projection;
   
   /// Max permitted element size
   double Max_element_size;
   
   /// Min permitted element size
   double Min_element_size;
   
   /// Min angle before remesh gets triggered
   double Min_permitted_angle;
   
   /// \short Function pointer to function that updates the 
   /// mesh following the snapping of boundary nodes to the
   /// boundaries (e.g. to move boundary nodes very slightly 
   /// to satisfy volume constraints)
   MeshUpdateFctPt Mesh_update_fct_pt;

  }; 

#endif


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////


#ifdef OOMPH_HAS_TRIANGLE_LIB  

//=========================================================================
/// Unstructured Triangle Mesh upgraded to solid mesh
//=========================================================================
 template<class ELEMENT>
  class SolidTriangleMesh : public virtual TriangleMesh<ELEMENT>,
  public virtual SolidMesh
  {
   
    public:
   
  /// \short Build mesh, based on closed curve that specifies
  /// the outer boundary of the domain and any number of internal
  /// clsed curves. Specify target area for uniform element size.
    SolidTriangleMesh(
       TriangleMeshParameters &triangle_mesh_parameters, 
       TimeStepper* time_stepper_pt=&Mesh::Default_TimeStepper)
     : TriangleMesh<ELEMENT>(triangle_mesh_parameters, time_stepper_pt)
       {
         //Assign the Lagrangian coordinates
         set_lagrangian_nodal_coordinates();
       }

   SolidTriangleMesh(const std::string& node_file_name,
                     const std::string& element_file_name,
                     const std::string& poly_file_name,
                     TimeStepper* time_stepper_pt=
                     &Mesh::Default_TimeStepper,
                     const bool &use_attributes=false) :
    TriangleMesh<ELEMENT>(node_file_name,
                          element_file_name,
                          poly_file_name,
                          time_stepper_pt,
                          use_attributes)
    {
     //Assign the Lagrangian coordinates
     set_lagrangian_nodal_coordinates();
    }

   /// Empty Destructor
     virtual ~SolidTriangleMesh() { }
  };

#endif

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

#ifdef OOMPH_HAS_TRIANGLE_LIB

//=========================================================================
/// Unstructured refineable Triangle Mesh upgraded to solid mesh
//=========================================================================
 template<class ELEMENT>
  class RefineableSolidTriangleMesh :
public virtual RefineableTriangleMesh<ELEMENT>,
 public virtual SolidMesh
 {

   public:

  /// \short Build mesh, based on the specifications on
  /// TriangleMeshParameters
  RefineableSolidTriangleMesh(
    TriangleMeshParameters &triangle_mesh_parameters, 
    TimeStepper* time_stepper_pt=&Mesh::Default_TimeStepper)
  : TriangleMesh<ELEMENT>(triangle_mesh_parameters, time_stepper_pt),
    RefineableTriangleMesh<ELEMENT>(triangle_mesh_parameters, time_stepper_pt)
    {
      //Assign the Lagrangian coordinates
      set_lagrangian_nodal_coordinates();
    }
   
   /// \short Build mesh from specified triangulation and
   /// associated target areas for elements in it.
   RefineableSolidTriangleMesh(const Vector<double> &target_area,
                               TriangulateIO& triangulate_io,
                               TimeStepper* time_stepper_pt=
                                   &Mesh::Default_TimeStepper,
                               const bool &use_attributes=false)  :
    RefineableTriangleMesh<ELEMENT>(target_area,
                                    triangulate_io,
                                    time_stepper_pt,
                                    use_attributes)
    {
     //Assign the Lagrangian coordinates
     set_lagrangian_nodal_coordinates();
    }
    
    /// Empty Destructor
    virtual ~RefineableSolidTriangleMesh() {}
    
 };

#endif // #ifdef OOMPH_HAS_TRIANGLE_LIB

}

#endif
