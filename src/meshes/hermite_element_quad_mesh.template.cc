//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC// Copyright (C) 2006-2021 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
// the mesh assembly functions for the hermite element quad mesh
#ifndef OOMPH_HERMITE_QUAD_MESH_TEMPLATE_CC
#define OOMPH_HERMITE_QUAD_MESH_TEMPLATE_CC


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//oomph-lib includes
#include "hermite_element_quad_mesh.template.h"


namespace oomph
{


//=============================================================================
/// \short sets the generalised position of the node (i.e. - x_i, dx_i/ds_0, 
/// dx_i/ds_1 & d2x_i/ds_0ds_1 for i = 1,2). Takes the x,y coordinates of the 
/// node from which its position can be determined.
//=============================================================================
template<class ELEMENT>
void HermiteQuadMesh<ELEMENT>::set_position_of_node(const unsigned& node_num_x,
                                                    const unsigned& node_num_y,
                                                    Node* node_pt)
{
 
 // get the generalised macro element position of the node
 DenseMatrix<double> m_gen(4,2);
 generalised_macro_element_position_of_node(node_num_x,node_num_y,m_gen);
 
 // copy the macro element coordinates
 Vector<double> node_macro_position(2);
 node_macro_position[0] = m_gen(0,0);
 node_macro_position[1] = m_gen(0,1);
 
 // get the global position of the nodes
 Vector<double> x_node(2);
 Domain_pt->macro_element_pt(0)->macro_map(node_macro_position,x_node);
 
 // get the jacobian of the mapping from macro to eulerian coordinates
 DenseMatrix<double> jacobian_MX(2,2);
 Domain_pt->macro_element_pt(0)->
  assemble_macro_to_eulerian_jacobian(node_macro_position,jacobian_MX);
 
 
 // get the jacobian2 of the mapping from macro to eulerian coordinates
 DenseMatrix<double> jacobian2_MX(3,2);
 Domain_pt->macro_element_pt(0)->
  assemble_macro_to_eulerian_jacobian2(node_macro_position,jacobian2_MX);   
 
 // set x_0
 node_pt->x_gen(0,0) = x_node[0];
 // set x_1
 node_pt->x_gen(0,1) = x_node[1];
 
 // set dxi/dsj for i = 0,1 and j = 0,1
 // computation : dxi/dsj = dm0/dsj*dxi/dm0 + dm1/dsj*dxi/dm1
 for (unsigned i = 0; i < 2; i++)
  {
   for (unsigned j = 0; j < 2; j++)
    {
     node_pt->x_gen(j+1,i) = m_gen(j+1,0)*jacobian_MX(0,i) 
      + m_gen(j+1,1)*jacobian_MX(1,i);
    }
  }
 
 // set d2xi/ds0ds1 for i = 0,1
 // d2xi/ds0ds1 = d2m0/ds0ds1*dxi/dm0 
 //               + d2m1/ds0ds1*dxi/dm1
 //               + (dm0/ds1*d2xi/dm0^2 + dm1/ds1*d2xi/dm0dm1)*dm0/ds0
 //               + (dm0/ds1*d2xi/dm0dm1 + dm1/ds1*d2xi/dm1^2)*dm1/ds0   
 for (unsigned i = 0; i < 2; i++)
  {
   node_pt->x_gen(3,i) = m_gen(3,0)*jacobian_MX(0,i) 
    + m_gen(3,1)*jacobian_MX(1,i) 
    + m_gen(1,0)*(m_gen(2,0)*jacobian2_MX(0,i) + 
                  m_gen(2,1)*jacobian2_MX(2,i))
    + m_gen(1,1)*(m_gen(2,0)*jacobian2_MX(2,i) + 
                  m_gen(2,1)*jacobian2_MX(1,i));
  }
}


 //=============================================================================
/// \short sets the generalised position of the node (i.e. - x_i, dx_i/ds_0, 
/// dx_i/ds_1 & d2x_i/ds_0ds_1 for i = 1,2). Takes the x,y coordinates of the 
/// node from which its position can be determined. Also sets coordinates
/// on boundary vector for the node to be the generalised position of the node
/// in macro element coordinates
//=============================================================================
template<class ELEMENT>
void HermiteQuadMesh<ELEMENT>::
set_position_of_boundary_node(const unsigned& node_num_x,
                              const unsigned& node_num_y, 
                              BoundaryNode<Node>* node_pt)
{
 
 // get the generalised macro element position of the node
 DenseMatrix<double> m_gen(4,2,0.0);
 generalised_macro_element_position_of_node(node_num_x,node_num_y,m_gen);
 
 // copy the macro element coordinates
 Vector<double> node_macro_position(2);
 node_macro_position[0] = m_gen(0,0);
 node_macro_position[1] = m_gen(0,1);
 
 // get the global position of the nodes
 Vector<double> x_node(2);
 Domain_pt->macro_element_pt(0)->macro_map(node_macro_position,x_node);
 
 // get the jacobian of the mapping from macro to eulerian coordinates
 DenseMatrix<double> jacobian_MX(2,2);
 Domain_pt->macro_element_pt(0)->
  assemble_macro_to_eulerian_jacobian(node_macro_position,jacobian_MX);
 
 // get the jacobian2 of the mapping from macro to eulerian coordinates
 DenseMatrix<double> jacobian2_MX(3,2);
 Domain_pt->macro_element_pt(0)->
  assemble_macro_to_eulerian_jacobian2(node_macro_position,jacobian2_MX); 
 
 // set x_0
 node_pt->x_gen(0,0) = x_node[0];
 // set x_1
 node_pt->x_gen(0,1) = x_node[1];
 
 // set dxi/dsj for i = 0,1 and j = 0,1
 // computation : dxi/dsj = dm0/dsj*dxi/dm0 + dm1/dsj*dxi/dm1
 for (unsigned i = 0; i < 2; i++)
  {
   for (unsigned j = 0; j < 2; j++)
    {
     node_pt->x_gen(j+1,i) = m_gen(j+1,0)*jacobian_MX(0,i) 
      + m_gen(j+1,1)*jacobian_MX(1,i);
    }
  }
 
 // set d2xi/ds0ds1 for i = 0,1
 // d2xi/ds0ds1 = d2m0/ds0ds1*dxi/dm0 
 //               + d2m1/ds0ds1*dxi/dm1
 //               + (dm0/ds1*d2xi/dm0^2 + dm1/ds1*d2xi/dm0dm1)*dm0/ds0
 //               + (dm0/ds1*d2xi/dm0dm1 + dm1/ds1*d2xi/dm1^2)*dm1/ds0   
 for (unsigned i = 0; i < 2; i++)
  {
   node_pt->x_gen(3,i) = m_gen(3,0)*jacobian_MX(0,i) 
    + m_gen(3,1)*jacobian_MX(1,i) 
    + m_gen(1,0)*(m_gen(2,0)*jacobian2_MX(0,i) + 
                  m_gen(2,1)*jacobian2_MX(2,i))
    + m_gen(1,1)*(m_gen(2,0)*jacobian2_MX(2,i) + 
                    m_gen(2,1)*jacobian2_MX(1,i));
  }
 
 
 // pass generalised macro element position to vector to pass to boundary
 // node
 for (unsigned b = 0; b < 4; b++)
  {
   if (node_pt->is_on_boundary(b))
    { 
     Vector<double> boundary_macro_position(2,0);
     boundary_macro_position[0] = m_gen(0,b%2);
     boundary_macro_position[1] = m_gen(1+b%2,b%2);
     node_pt->set_coordinates_on_boundary(b,boundary_macro_position);
    }
  }
}


//=============================================================================
/// \short computes the generalised position of the node at position 
/// (node_num_x, node_num_y) in the macro element coordinate scheme.
///     index 0 of m_gen : 0 - m_i
///                        1 - dm_i/ds_0
///                        2 - dm_i/ds_1
///                        3 - d2m_i/ds_0ds_1    (where i is index 1 of m_gen)
//=============================================================================
template<class ELEMENT>
void HermiteQuadMesh<ELEMENT>::generalised_macro_element_position_of_node
(const unsigned& node_num_x,const unsigned& node_num_y, 
 DenseMatrix<double>& m_gen)
{  
   // obtain position of node
   Vector<double> s_macro_N(2);
   macro_coordinate_position(node_num_x,node_num_y,s_macro_N);

   // set position of node in macro element coordinates
   m_gen(0,0) = s_macro_N[0];
   m_gen(0,1) = s_macro_N[1];

   // if on left hand edge
   if (node_num_x == 0)
    {

     // first dm0ds0 and dm1ds0

     // get position of right node
     Vector<double> s_macro_R(2);
     macro_coordinate_position(node_num_x+1,node_num_y,s_macro_R);

     // compute dm0ds0
     m_gen(1,0) = 0.5*(s_macro_R[0]-s_macro_N[0]);

     // compute dm1ds0
     m_gen(1,1) = 0.5*(s_macro_R[1]-s_macro_N[1]);

     // now d2m0/ds0ds1 and d2m1/ds0ds1

     // if lower left hand corner
     if (node_num_y == 0)
      {

       // get position of upper right node
       Vector<double> s_macro_UR(2);
       macro_coordinate_position(node_num_x+1,node_num_y+1,s_macro_UR);
       
       // get position of upper node
       Vector<double> s_macro_U(2);
       macro_coordinate_position(node_num_x,node_num_y+1,s_macro_U);       

       // compute d2m0/ds0ds1
       m_gen(3,0) = 0.5 * (0.5*(s_macro_UR[0] - s_macro_U[0]) - m_gen(1,0));

        // compute d2m1/ds0ds1
       m_gen(3,1) = 0.5 * (0.5*(s_macro_UR[1] - s_macro_U[1]) - m_gen(1,1));
      }

     // else if upper left hand corner
     else if (node_num_y == Nelement[1])
      {

       // get position of lower right node
       Vector<double> s_macro_DR(2);
       macro_coordinate_position(node_num_x+1,node_num_y-1,s_macro_DR);
       
       // get position of lower node
       Vector<double> s_macro_D(2);
       macro_coordinate_position(node_num_x,node_num_y-1,s_macro_D);    

       // compute d2m0/ds0ds1
       m_gen(3,0) = 0.5 * (m_gen(1,0) - 0.5*(s_macro_DR[0]-s_macro_D[0]));

       // compute d2m0/ds0ds1
       m_gen(3,1) = 0.5 * (m_gen(1,1) - 0.5*(s_macro_DR[1]-s_macro_D[1]));
      }

     // else left hand edge (not corner)
     else
      {
       
       // get position of lower right node
       Vector<double> s_macro_DR(2);
       macro_coordinate_position(node_num_x+1,node_num_y-1,s_macro_DR);
       
       // get position of lower node
       Vector<double> s_macro_D(2);
       macro_coordinate_position(node_num_x,node_num_y-1,s_macro_D);    

       // get position of upper right node
       Vector<double> s_macro_UR(2);
       macro_coordinate_position(node_num_x+1,node_num_y+1,s_macro_UR);
       
       // get position of upper node
       Vector<double> s_macro_U(2);
       macro_coordinate_position(node_num_x,node_num_y+1,s_macro_U);  

       // compute d2m0/ds0ds1
       m_gen(3,0) = 0.5*std::min(m_gen(1,0)-0.5*(s_macro_DR[0]-s_macro_D[0]),
                                 0.5*(s_macro_UR[0]-s_macro_U[0])-m_gen(1,0));

       // compute d2m1/ds0ds1
       m_gen(3,1) = 0.5*std::min(m_gen(1,1)-0.5*(s_macro_DR[1]-s_macro_D[1]),
                                 0.5*(s_macro_UR[1]-s_macro_U[1])-m_gen(1,1));
      }
    }

   // if on right hand edge
   else if (node_num_x == Nelement[0])
    {

     // first dm0ds0 and dm1ds0

     // get position of left node
     Vector<double> s_macro_L(2);
     macro_coordinate_position(node_num_x-1,node_num_y,s_macro_L);

     // compute dm0ds0
     m_gen(1,0) = 0.5*(s_macro_N[0]-s_macro_L[0]);

     // compute dm1ds0
     m_gen(1,1) = 0.5*(s_macro_N[1]-s_macro_L[1]);

     // now d2m0/ds0ds1 and d2m1/ds0ds1

     // if lower right hand corner
     if (node_num_y == 0)
      {

       // get position of upper left node
       Vector<double> s_macro_UL(2);
       macro_coordinate_position(node_num_x-1,node_num_y+1,s_macro_UL);   
       
       // get position of upper node
       Vector<double> s_macro_U(2);
       macro_coordinate_position(node_num_x,node_num_y+1,s_macro_U);       

       // compute d2m0/ds0ds1
       m_gen(3,0) = 0.5 * (0.5*(s_macro_U[0] - s_macro_UL[0]) - m_gen(1,0));

        // compute d2m1/ds0ds1
       m_gen(3,1) = 0.5 * (0.5*(s_macro_U[1] - s_macro_UL[1]) - m_gen(1,1));
      }

     // else if upper right hand corner
     else if (node_num_y == Nelement[1])
      {

       // get position of lower left node
       Vector<double> s_macro_DL(2);
       macro_coordinate_position(node_num_x-1,node_num_y-1,s_macro_DL);
       
       // get position of lower node
       Vector<double> s_macro_D(2);
       macro_coordinate_position(node_num_x,node_num_y-1,s_macro_D);    

       // compute d2m0/ds0ds1
       m_gen(3,0) = 0.5 * (m_gen(1,0) - 0.5*(s_macro_D[0]-s_macro_DL[0]));

       // compute d2m0/ds0ds1
       m_gen(3,1) = 0.5 * (m_gen(1,1) - 0.5*(s_macro_D[1]-s_macro_DL[1]));
      }

     // else left hand edge (not corner)
     else
      {
       

       // get position of lower left node
       Vector<double> s_macro_DL(2);
       macro_coordinate_position(node_num_x-1,node_num_y-1,s_macro_DL);
       
       // get position of lower node
       Vector<double> s_macro_D(2);
       macro_coordinate_position(node_num_x,node_num_y-1,s_macro_D);    

       // get position of upper left node
       Vector<double> s_macro_UL(2);
       macro_coordinate_position(node_num_x-1,node_num_y+1,s_macro_UL);   
       
       // get position of upper node
       Vector<double> s_macro_U(2);
       macro_coordinate_position(node_num_x,node_num_y+1,s_macro_U);  

       // compute d2m0/ds0ds1
       m_gen(3,0) = 0.5*std::min(m_gen(1,0)-0.5*(s_macro_D[0]-s_macro_DL[0]),
                                 0.5*(s_macro_U[0]-s_macro_UL[0])-m_gen(1,0));

       // compute d2m0/ds0ds1
       m_gen(3,1) = 0.5*std::min(m_gen(1,1)-0.5*(s_macro_D[1]-s_macro_DL[1]),
                                 0.5*(s_macro_U[1]-s_macro_UL[1])-m_gen(1,1));
      }
    }
   // 
   else
    {
     // get position of left node
     Vector<double> s_macro_L(2);
     macro_coordinate_position(node_num_x-1,node_num_y,s_macro_L);

     // get position of right node
     Vector<double> s_macro_R(2);    
     macro_coordinate_position(node_num_x+1,node_num_y,s_macro_R);

     // compute dm0/ds0
     m_gen(1,0) = 0.5*std::min(s_macro_N[0]-s_macro_L[0],
                              s_macro_R[0]-s_macro_N[0]);

     //compute dm1/ds0
     Vector<double> node_space(2);
     node_space[0] = s_macro_N[1]-s_macro_L[1];
     node_space[1] = s_macro_R[1]-s_macro_N[1];
     // set nodal dof
     if (node_space[0] > 0 && node_space[1] > 0)
      m_gen(1,1)  = 0.5 * std::min(node_space[0],node_space[1]);
     else if (node_space[0] < 0 && node_space[1] < 0)
      m_gen(1,1)  = 0.5 * std::max(node_space[0],node_space[1]);
     else
      m_gen(1,1) = 0;
    }

   // if node in lower row
   if (node_num_y == 0)
    {

     // now dm0ds1 and dm1ds1

     // get position of upper node
     Vector<double> s_macro_U(2);
     macro_coordinate_position(node_num_x,node_num_y+1,s_macro_U);

     // compute dm0ds1
     m_gen(2,0) = 0.5*(s_macro_U[0]-s_macro_N[0]);

     // compute dm1ds1
     m_gen(2,1) = 0.5*(s_macro_U[1]-s_macro_N[1]);
    
     // and if not corner node
     if (node_num_x > 0 && node_num_x < Nelement[0])
      {

       // now dm0/ds0ds1 and dm1/ds0ds1

       // get position of upper left node
       Vector<double> s_macro_UL(2);
       macro_coordinate_position(node_num_x-1,node_num_y+1,s_macro_UL);       
       
       // get position of left node
       Vector<double> s_macro_L(2);
       macro_coordinate_position(node_num_x-1,node_num_y,s_macro_L);
       
       // get position of right node
       Vector<double> s_macro_R(2);
       macro_coordinate_position(node_num_x+1,node_num_y,s_macro_R);
       
       // get position of upper right node
       Vector<double> s_macro_UR(2);
       macro_coordinate_position(node_num_x+1,node_num_y+1,s_macro_UR);
       
       // set dm0/ds0ds1
       m_gen(3,0) = 0.5*std::min(m_gen(2,0)-0.5*(s_macro_UL[0]-s_macro_L[0]),
                                 0.5*(s_macro_UR[0]-s_macro_R[0])-m_gen(2,0));

       // set dm1/ds0ds1
       m_gen(3,1) = 0.5*std::min(m_gen(2,1)-0.5*(s_macro_UL[1]-s_macro_L[1]),
                                 0.5*(s_macro_UR[1]-s_macro_R[1])-m_gen(2,1));

      }
    }

   // else if node in upper row
   else if (node_num_y == Nelement[1])
    {

     // now dm0ds1 and dm1ds1

     // get position of lower node
     Vector<double> s_macro_D(2);
     macro_coordinate_position(node_num_x,node_num_y-1,s_macro_D);

     // compute dm0ds1
     m_gen(2,0) = 0.5*(s_macro_N[0]-s_macro_D[0]);

     // compute dm1ds1
     m_gen(2,1) = 0.5*(s_macro_N[1]-s_macro_D[1]);
    
     // and if not corner node
     if (node_num_x > 0 && node_num_x < Nelement[0])
      {

       // now dm0/ds0ds1 and dm1/ds0ds1

       // get position of lower left node
       Vector<double> s_macro_DL(2);
       macro_coordinate_position(node_num_x-1,node_num_y-1,s_macro_DL);
       
       // get position of left node
       Vector<double> s_macro_L(2);
       macro_coordinate_position(node_num_x-1,node_num_y,s_macro_L);
       
       // get position of right node
       Vector<double> s_macro_R(2);
       macro_coordinate_position(node_num_x+1,node_num_y,s_macro_R);
       
       // get position of lower right node
       Vector<double> s_macro_DR(2);
       macro_coordinate_position(node_num_x+1,node_num_y-1,s_macro_DR);
       
       // set dm0/ds0ds1
       m_gen(3,0) = 0.5*std::min(m_gen(2,0)-0.5*(s_macro_L[0]-s_macro_DL[0]),
                                 0.5*(s_macro_R[0]-s_macro_DR[0])-m_gen(2,0));

       // set dm1/ds0ds1
       m_gen(3,1) = 0.5*std::min(m_gen(2,1)-0.5*(s_macro_L[1]-s_macro_DL[1]),
                                 0.5*(s_macro_R[1]-s_macro_DR[1])-m_gen(2,1));
      }
    }
   else
    {
    
     // get position of upper node
     Vector<double> s_macro_U(2);
     macro_coordinate_position(node_num_x,node_num_y+1,s_macro_U);

     // get position of lower node
     Vector<double> s_macro_D(2);
     macro_coordinate_position(node_num_x,node_num_y-1,s_macro_D);

     //compute dm0/ds1
     Vector<double> node_space(2);
     node_space[0] = s_macro_N[0]-s_macro_D[0];
     node_space[1] = s_macro_U[0]-s_macro_N[0];        
     // set nodal coordinate
     if (node_space[0] > 0 && node_space[1] > 0)
      m_gen(2,0)  = 0.5 * std::min(node_space[0],node_space[1]);
     else if (node_space[0] < 0 && node_space[1] < 0)
      m_gen(2,0)  = 0.5 * std::max(node_space[0],node_space[1]);
     else
      m_gen(2,0) = 0;

     // compute dm1/ds1
     m_gen(2,1) = 0.5*std::min(s_macro_N[1]-s_macro_D[1],
                               s_macro_U[1]-s_macro_N[1]);

     // for interior nodes
     if (node_num_x > 0 && node_num_x < Nelement[0])
      {

       // get position of left node
       Vector<double> s_macro_L(2);
       macro_coordinate_position(node_num_x-1,node_num_y,s_macro_L);
       
       // get position of upper left node
       Vector<double> s_macro_UL(2);
       macro_coordinate_position(node_num_x-1,node_num_y+1,s_macro_UL);   
       
       // get position of upper right node
       Vector<double> s_macro_UR(2);
       macro_coordinate_position(node_num_x+1,node_num_y+1,s_macro_UR);
       
       // get position of right node
       Vector<double> s_macro_R(2);
       macro_coordinate_position(node_num_x+1,node_num_y,s_macro_R);
       
       // get position of lower right node
       Vector<double> s_macro_DR(2);
       macro_coordinate_position(node_num_x+1,node_num_y-1,s_macro_DR);
       
       // get position of lower left node
       Vector<double> s_macro_DL(2);
       macro_coordinate_position(node_num_x-1,node_num_y-1,s_macro_DL);

       Vector<double> node_space(2);
       // comute dm0/ds0ds1 wrt to node above and below
       node_space[0] = m_gen(1,0) - 0.5*std::min(s_macro_D[0]-s_macro_DL[0],
                                          s_macro_DR[0]-s_macro_D[0]);
       node_space[1] = 0.5*std::min(s_macro_U[0]-s_macro_UL[0],
                              s_macro_UR[0]-s_macro_U[0]) - m_gen(1,0);
       // set nodal dof
       if (node_space[0] > 0 && node_space[1] > 0)
        m_gen(3,0) = 0.5 * std::min(node_space[0],node_space[1]);
       else if (node_space[0] < 0 && node_space[1] < 0)
        m_gen(3,0) = 0.5 * std::max(node_space[0],node_space[1]);
       else
        m_gen(3,0) = 0;  
       
       // comute dm1/ds0ds1 wrt node left and right
       node_space[0] = m_gen(2,1) - 0.5*std::min(s_macro_L[0]-s_macro_DL[0],
                                          s_macro_UL[0]-s_macro_L[0]);
       node_space[1] = 0.5*std::min(s_macro_R[0]-s_macro_DR[0],
                              s_macro_UR[0]-s_macro_R[0]) - m_gen(2,1);
       // set nodal dof
       if (node_space[0] > 0 && node_space[1] > 0)
        m_gen(3,1)  = 0.5 * std::min(node_space[0],node_space[1]);
       else if (node_space[0] < 0 && node_space[1] < 0)
        m_gen(3,1) = 0.5 * std::max(node_space[0],node_space[1]);
       else
        m_gen(3,1) = 0;  
      }
    }
  }


//=============================================================================
/// \short Generic mesh construction function to build the mesh
//=============================================================================
template<class ELEMENT>
void HermiteQuadMesh<ELEMENT>::build_mesh(TimeStepper* time_stepper_pt)
{
 // Mesh can only be built with 2D QHermiteElements.
 MeshChecker::assert_geometric_element<QHermiteElementBase,ELEMENT>(2);

 //Set the number of boundaries
 set_nboundary(4);
 
 //Allocate the store for the elements
 Element_pt.resize(Nelement[0]*Nelement[1]); 
 
 //Allocate the memory for the first element
 Element_pt[0] = new ELEMENT;
 finite_element_pt(0)->set_macro_elem_pt(Domain_pt->macro_element_pt(0));
 
 //Can now allocate the store for the nodes 
 Node_pt.resize((1 + Nelement[0])*(1 + Nelement[1]));
 
 //Set up geometrical data
 unsigned long node_count=0;
 
 //Now assign the topology
 //Boundaries are numbered 0 1 2 3 from the bottom proceeding anticlockwise
 //Pinned value are denoted by an integer value 1
 //Thus if a node is on two boundaries, ORing the values of the 
 //boundary conditions will give the most restrictive case (pinning)
 
 
 // we first create the lowest row of elements
 // ##########################################
 // ##########################################
 
 
 // FIRST ELEMENT - lower left hand corner
 // **************************************
 
 
 // LOWER LEFT HAND NODE
 
 //Set the corner node
 //Allocate memory for the node
 Node_pt[node_count] = 
  finite_element_pt(0)->construct_boundary_node(0,time_stepper_pt);
 
 //Push the node back onto boundaries
 add_boundary_node(0,Node_pt[node_count]);
 add_boundary_node(3,Node_pt[node_count]);
 
 // set the position of the boundary node
 set_position_of_boundary_node
  (0,0,dynamic_cast<BoundaryNode<Node> *>(Node_pt[node_count]));
 
 //Increment the node number
 node_count++;
 
 // LOWER RIGHT HAND NODE
 
 //Allocate memory for the node
 Node_pt[node_count] = 
  finite_element_pt(0)->construct_boundary_node(1,time_stepper_pt);
 
 //Push the node back onto boundaries
 add_boundary_node(0,Node_pt[node_count]);
 
 //If we only have one column then the RHS node is on the right boundary
 if(Nelement[0]==1)
  {add_boundary_node(1,Node_pt[node_count]);}
 
 // set the position of the node
 set_position_of_boundary_node
  (1,0,dynamic_cast<BoundaryNode<Node> *>(Node_pt[node_count]));
 
 //Increment the node number
 node_count++;
 
 // UPPER LEFT HAND NODE
 
 //Allocate memory for the node
 Node_pt[node_count] = 
  finite_element_pt(0)->construct_boundary_node(2,time_stepper_pt);
 
 //Push the node back onto boundaries
 add_boundary_node(3,Node_pt[node_count]);
 
 //If we only have one row, then the top node is on the top boundary
 if(Nelement[1]==1)
  {add_boundary_node(2,Node_pt[node_count]);}
 
 // set the position of the boundary node
 set_position_of_boundary_node
  (0,1,dynamic_cast<BoundaryNode<Node> *>(Node_pt[node_count]));
 
 //Increment the node number 
 node_count++;
 
 // UPPER RIGHT NODE
 
 //Allocate the memory for the node
 Node_pt[node_count] = 
  finite_element_pt(0)->construct_node(3,time_stepper_pt);
 
 //If we only have one column then the RHS node is on the right boundary
 if(Nelement[0]==1)
  {add_boundary_node(1,Node_pt[node_count]);}
 //If we only have one row, then the top node is on the top boundary
 if(Nelement[1]==1)
  {add_boundary_node(2,Node_pt[node_count]);}
 
 // if the node is a boundary node
 if (Nelement[0]==1 || Nelement[1]==1)
  {
   // set the position of the boundary node
   set_position_of_boundary_node
    (1,1,dynamic_cast<BoundaryNode<Node> *>(Node_pt[node_count]));
  }
 else
  {
   // set the position of the node
   set_position_of_node(1,1,Node_pt[node_count]);
  }

 //Increment the node number
 node_count++;
 
 // END OF FIRST ELEMENT

 
 // CENTRE OF FIRST ROW OF ELEMENTS
 // *******************************
 
 
 //Now loop over the first row of elements, apart from final element
 for(unsigned j=1;j<(Nelement[0]-1);j++)
  {
   //Allocate memory for new element
   Element_pt[j] = new ELEMENT;
   finite_element_pt(j)->set_macro_elem_pt(Domain_pt->macro_element_pt(0));
   
   // LOWER LEFT NODE
   
   //lower left hand node column of nodes is same as lower right hand node
   //in neighbouring element
   finite_element_pt(j)->node_pt(0) = 
    finite_element_pt(j-1)->node_pt(1);
   
   // LOWER RIGHT NODE
   
   //Allocate memory for the nodes
   Node_pt[node_count] = 
    finite_element_pt(j)->construct_boundary_node(1,time_stepper_pt);
   
   //Push the node back onto boundaries
   add_boundary_node(0,Node_pt[node_count]);
   
   // set the position of the boundary node
   set_position_of_boundary_node
    (j+1,0,dynamic_cast<BoundaryNode<Node> *>(Node_pt[node_count]));
   
   //Increment the node number
   node_count++;
   
   // UPPER LEFT NODE
   
   //First column of nodes is same as neighbouring element
   finite_element_pt(j)->node_pt(2) = 
    finite_element_pt(j-1)->node_pt(3);
   
   // UPPER RIGHT NODE
   
   //Allocate memory for the nodes
   Node_pt[node_count] = 
    finite_element_pt(j)->construct_node(3,time_stepper_pt);
   
   //If we only have one row, then the top node is on the top boundary
   if(Nelement[0]==1)
    {add_boundary_node(2,Node_pt[node_count]);}
   
   // set the position of the (boundary) node
   if (Nelement[0]==1)
    set_position_of_boundary_node
     (j+1,1,dynamic_cast<BoundaryNode<Node> *>(Node_pt[node_count]));
   else
    set_position_of_node(j+1,1,Node_pt[node_count]);
   
   //Increment the node number
   node_count++;
  } 
 
 // FINAL ELEMENT IN FIRST ROW (lower right corner element)
 // **************************
 
 
 //Only allocate if there is more than one element in the row
 if(Nelement[0] > 1)
  {
   //Allocate memory for element
   Element_pt[Nelement[0]-1] = new ELEMENT;
   finite_element_pt(Nelement[0]-1)->
    set_macro_elem_pt(Domain_pt->macro_element_pt(0));
   
   // LOWER LEFT NODE
   
   //First column of nodes is same as neighbouring element
   finite_element_pt(Nelement[0]-1)->node_pt(0) = 
    finite_element_pt(Nelement[0]-2)->node_pt(1);
   
   // LOWER RIGHT NODE
   
   //If we have an Xperiodic mesh then the final node is the first node in
   //the row
   if(Xperiodic==true)
    {
     //Note that this is periodic in the x-direction   
     finite_element_pt(Nelement[0]-1)->node_pt(1) = 
      finite_element_pt(0)->node_pt(0);
    }
   //Otherwise it's a new final node
   else
    {
     //Allocate memory for the node
     Node_pt[node_count] = 
      finite_element_pt(Nelement[0]-1)->
      construct_boundary_node(1,time_stepper_pt);
    }
   
   //Push the node back onto boundaries
   add_boundary_node(0,Node_pt[node_count]);
   add_boundary_node(1,Node_pt[node_count]);

   // set the position of the boundary node
   set_position_of_boundary_node
    (Nelement[0],0,dynamic_cast<BoundaryNode<Node> *>(Node_pt[node_count]));

   // if not periodic mesh
   if(Xperiodic==false)
    {
     node_count++;
    }
   
   // UPPER LEFT NODE
   
   // same as upper right node in element to left
   finite_element_pt(Nelement[0]-1)->node_pt(2) = 
    finite_element_pt(Nelement[0]-2)->node_pt(3);
   
   //If we only have one row, then the top node is on the top boundary
   if(Nelement[1]==1)
    {add_boundary_node(2,Node_pt[node_count]);}   

   // set the position of the (boundary) node
   if (Nelement[1]==1)
    set_position_of_boundary_node
     (Nelement[0]-1,1,
      dynamic_cast<BoundaryNode<Node> *>
      (finite_element_pt(Nelement[0]-2)->node_pt(3)));

   // UPPER RIGHT NODE   
   
   //If we have an Xperiodic mesh then the nodes in the final column are 
   //those in the first column
   if(Xperiodic==true)
    { 
     //Note that these are periodic in the x-direction
     finite_element_pt(Nelement[0]-1)->node_pt(3) = 
      finite_element_pt(0)->node_pt(2);
    }
   //Otherwise we need new nodes for the final column
   else
    {
     //Allocate memory for node
     Node_pt[node_count] = finite_element_pt(Nelement[0]-1)->
      construct_boundary_node(3,time_stepper_pt);
    }   
   
   //If we only have one row, then the top node is on the top boundary
   if(Nelement[1]==1)
    {add_boundary_node(2,Node_pt[node_count]);}
   
   // boundary 1 node
   add_boundary_node(1,Node_pt[node_count]);
   
   // set the position of the boundary node
   set_position_of_boundary_node
    (Nelement[0],1,dynamic_cast<BoundaryNode<Node> *>(Node_pt[node_count]));

   //Increment the node number
   if(Xperiodic==false)
    {   
     //Increment the node number
     node_count++;
    }
  }
 
 // now create all remaining central rows
 // #####################################
 // #####################################
 
 
 //Loop over remaining element rows in the mesh
 for(unsigned i=1;i<(Nelement[1]-1);i++)
  {
   
   
   // set the first element in the row
   // ********************************
   
   
   //Allocate memory for element
   Element_pt[Nelement[0]*i] = new ELEMENT;
   finite_element_pt(Nelement[0]*i)
    ->set_macro_elem_pt(Domain_pt->macro_element_pt(0));

   //The first row of nodes is copied from the element below
   for(unsigned l=0;l<2;l++)
    {  
     finite_element_pt(Nelement[0]*i)->node_pt(l) = 
      finite_element_pt(Nelement[0]*(i-1))->node_pt(2 + l);
    }
   
   // UPPER LEFT HAND NODE
   
   //Allocate memory for node
   Node_pt[node_count] = finite_element_pt(Nelement[0]*i)->
    construct_boundary_node(2,time_stepper_pt);
   
   //Push the node back onto boundaries
   add_boundary_node(3,Node_pt[node_count]);
   
   // set the position of the boundary node
   set_position_of_boundary_node
    (0,i+1,dynamic_cast<BoundaryNode<Node> *>(Node_pt[node_count]));

   //Increment the node number
   node_count++;
   
   // UPPER RIGHT HAND NODE
   
   //If we only have one column, the node could be on the boundary
   if(Nelement[0]==1)
    {
     Node_pt[node_count] = finite_element_pt(Nelement[0]*i)->
      construct_boundary_node(3,time_stepper_pt);
    }
   else
    {
     Node_pt[node_count] = 
      finite_element_pt(Nelement[0]*i)->
      construct_node(3,time_stepper_pt);
    }
   
   //If we only have one column then the RHS node is on the 
   //right boundary
   if(Nelement[0]==1)
    {add_boundary_node(1,Node_pt[node_count]);}
   
   // set the position of the (boundary) node
   if (Nelement[0]==1)
    set_position_of_boundary_node
     (1,i+1,dynamic_cast<BoundaryNode<Node> *>(Node_pt[node_count]));
   else
    set_position_of_node(1,i+1,Node_pt[node_count]);

   //Increment the node number
   node_count++;

     
   // loop over central elements in row
   // *********************************
   
   //Now loop over the rest of the elements in the row, apart from the last
   for(unsigned j=1;j<(Nelement[0]-1);j++)
    {
     //Allocate memory for new element
     Element_pt[Nelement[0]*i+j] = new ELEMENT;
     finite_element_pt(Nelement[0]*i+j)->
      set_macro_elem_pt(Domain_pt->macro_element_pt(0));

     // LOWER LEFT AND RIGHT NODES
     
     //The first row is copied from the lower element
     for(unsigned l=0;l<2;l++)
      {  
       finite_element_pt(Nelement[0]*i+j)->node_pt(l) = 
        finite_element_pt(Nelement[0]*(i-1)+j)->node_pt(2 + l);
      }
     
     // UPPER LEFT NODE
     
     //First column is same as neighbouring element
     finite_element_pt(Nelement[0]*i+j)->node_pt(2) = 
      finite_element_pt(Nelement[0]*i+(j-1))->node_pt(3);
     
     // UPPER RIGHT NODE
     
     //Allocate memory for the nodes
     Node_pt[node_count] = 
      finite_element_pt(Nelement[0]*i+j)->
      construct_node(3,time_stepper_pt);

     // set position of node
     set_position_of_node(j+1,i+1,Node_pt[node_count]);
     
     //Increment the node number
     node_count++;
    } 
   
   
   // final element in row
   // ********************
   
   
   //Only if there is more than one column
   if(Nelement[0] > 1)
    {
     //Allocate memory for element
     Element_pt[Nelement[0]*i+Nelement[0]-1] = new ELEMENT;
     finite_element_pt(Nelement[0]*i+Nelement[0]-1)->
      set_macro_elem_pt(Domain_pt->macro_element_pt(0));

     // LOWER LEFT AND RIGHT NODES
     
     //The first row is copied from the lower element
     for(unsigned l=0;l<2;l++)
      {  
       finite_element_pt(Nelement[0]*i+Nelement[0]-1)->node_pt(l) = 
        finite_element_pt(Nelement[0]*(i-1)
                          +Nelement[0]-1)->node_pt(2 + l);
      }
     
     // UPPER LEFT NODE
     
     // First node is same as neighbouring element
     finite_element_pt(Nelement[0]*i+Nelement[0]-1)->node_pt(2) = 
      finite_element_pt(Nelement[0]*i+Nelement[0]-2)->node_pt(3);
     
     // UPPER RIGHT NODE
     
     //If we have an Xperiodic mesh then this node is the same 
     //as the first node
     if(Xperiodic==true)
      {
       //Allocate memory for node, periodic in x-direction
     finite_element_pt(Nelement[0]*i+Nelement[0]-1)->node_pt(3) = 
      finite_element_pt(Nelement[0]*i)->node_pt(2);
      }
     //Otherwise allocate memory for a new node
     else
      {
       Node_pt[node_count] = 
        finite_element_pt(Nelement[0]*i+Nelement[0]-1)->
        construct_boundary_node(3,time_stepper_pt);
      }
     
     //Push the node back onto boundaries
     add_boundary_node(1,Node_pt[node_count]);
     
     // set position of boundary node
     set_position_of_boundary_node
      (Nelement[0],i+1,
       dynamic_cast<BoundaryNode<Node> *>(Node_pt[node_count]));

     //Increment the node number
     node_count++;
    }
  }
 

 // final element row
 // #################
 // #################
 
 
 // only if there is more than one row
 if(Nelement[1] > 1)
  {
   
   // first element in upper row (upper left corner)
   // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
   //Allocate memory for element
   Element_pt[Nelement[0]*(Nelement[1]-1)] = new ELEMENT;
   finite_element_pt(Nelement[0]*(Nelement[1]-1))->
    set_macro_elem_pt(Domain_pt->macro_element_pt(0));
   
   // LOWER LEFT AND LOWER RIGHT NODES
   
   //The first row of nodes is copied from the element below
   for(unsigned l=0;l<2;l++)
    {  
     finite_element_pt(Nelement[0]*(Nelement[1]-1))->node_pt(l) 
      = finite_element_pt(Nelement[0]*(Nelement[1]-2))->node_pt(2 + l);
    }
   
   // UPPER LEFT NODE
   
   //Allocate memory for node
   Node_pt[node_count] = finite_element_pt(Nelement[0]*(Nelement[1]-1))->
    construct_boundary_node(2,time_stepper_pt);
   
   //Push the node back onto boundaries
   add_boundary_node(2,Node_pt[node_count]);
   add_boundary_node(3,Node_pt[node_count]);
   
   // set position of boundary node
   set_position_of_boundary_node
    (0,Nelement[1],dynamic_cast<BoundaryNode<Node> *>(Node_pt[node_count]));
   
   //Increment the node number
   node_count++;
   
   // UPPER RIGHT NODE
   
   //Allocate memory for the node
   Node_pt[node_count] = 
    finite_element_pt(Nelement[0]*(Nelement[1]-1))->
    construct_boundary_node(3,time_stepper_pt);
   
   //Push the node back onto boundaries
   add_boundary_node(2,Node_pt[node_count]);
   
   // set position of boundary node
   set_position_of_boundary_node
    (1,Nelement[1],dynamic_cast<BoundaryNode<Node> *>(Node_pt[node_count]));

   //Increment the node number
   node_count++;
   
   
   // loop over central elements of upper element row
   // ***********************************************
   
   
   //Now loop over the rest of the elements in the row, apart from the last
   for(unsigned j=1;j<(Nelement[0]-1);j++)
    {
     
     //Allocate memory for element
     Element_pt[Nelement[0]*(Nelement[1]-1)+j] = new ELEMENT;
     finite_element_pt(Nelement[0]*(Nelement[1]-1)+j)->
      set_macro_elem_pt(Domain_pt->macro_element_pt(0));
     
     // LOWER LEFT AND LOWER RIGHT NODES
     
     //The first row is copied from the lower element
     for(unsigned l=0;l<2;l++)
      {  
       finite_element_pt(Nelement[0]*(Nelement[1]-1)+j)->node_pt(l) = 
        finite_element_pt(Nelement[0]*(Nelement[1]-2)+j)->node_pt(2 + l);
      }
     
     // UPPER LEFT NODE
     
     //First column is same as neighbouring element
     finite_element_pt(Nelement[0]*(Nelement[1]-1)+j)->node_pt(2) 
      = finite_element_pt(Nelement[0]*(Nelement[1]-1)+(j-1))->node_pt(3);
     
     // UPPER RIGHT NODE
     
     //Allocate memory for node
     Node_pt[node_count] = 
      finite_element_pt(Nelement[0]*(Nelement[1]-1)+j)->
      construct_boundary_node(3,time_stepper_pt);
     
     //Push the node back onto boundaries
     add_boundary_node(2,Node_pt[node_count]);
     
     // set position of boundary node
     set_position_of_boundary_node
      (j+1,Nelement[1],
       dynamic_cast<BoundaryNode<Node> *>(Node_pt[node_count]));
     
     //Increment the node number   
     node_count++;
     
    } //End of loop over central elements in row
   
   
   // final element in row (upper right corner)
   // *****************************************
   
   //Only if there is more than one column
   if(Nelement[0] > 1)
    {
     
     //Allocate memory for element
     Element_pt[Nelement[0]*(Nelement[1]-1)+Nelement[0]-1] = new ELEMENT;
     finite_element_pt(Nelement[0]*(Nelement[1]-1)+Nelement[0]-1)->
      set_macro_elem_pt(Domain_pt->macro_element_pt(0));
     
     // LOWER LEFT AND LOWER RIGHT NODES
     
     //The first row is copied from the lower element
     for(unsigned l=0;l<2;l++)
      {  
       finite_element_pt(Nelement[0]*(Nelement[1]-1)+Nelement[0]-1)->
        node_pt(l) = finite_element_pt(Nelement[0]*(Nelement[1]-2)+
                                       Nelement[0]-1)->node_pt(2 + l);
      }
     
     // UPPER LEFT NODE
     
     //First column is same as neighbouring element
     finite_element_pt(Nelement[0]*(Nelement[1]-1)+Nelement[0]-1)
      ->node_pt(2) = finite_element_pt(Nelement[0]*(Nelement[1]-1)+
                                       Nelement[0]-2)->node_pt(3);
     
     // UPPER RIGHT NODE
     
     //If we have an Xperiodic mesh, the node must be copied from 
     //the first column
     if(Xperiodic==true)
      {
       //Allocate memory for node, periodic in x-direction     
       finite_element_pt(Nelement[0]*(Nelement[1]-1)
                         +Nelement[0]-1)->node_pt(3) = 
        finite_element_pt(Nelement[0]*(Nelement[1]-1))->node_pt(2);
      }
     //Otherwise, allocate new memory for node
     else
      {
       Node_pt[node_count] = finite_element_pt(Nelement[0]*(Nelement[1]-1)+
                                               Nelement[0]-1)->
        construct_boundary_node(3,time_stepper_pt);
      }
     
     //Push the node back onto boundaries
     add_boundary_node(1,Node_pt[node_count]);
     add_boundary_node(2,Node_pt[node_count]);
     
     // set position of boundary node
     set_position_of_boundary_node
      (Nelement[0],Nelement[1],
       dynamic_cast<BoundaryNode<Node> *>(Node_pt[node_count]));

     //Increment the node number
     node_count++;         
    }
  }
 
 // Setup boundary element lookup schemes
 setup_boundary_element_info(); 
}



//=============================================================================
/// \short Setup lookup schemes which establish which elements are located next
/// to which boundaries (Doc to outfile if it's open).
/// Specific version for HermiteQuadMesh to ensure that the order of the 
/// elements in Boundary_element_pt matches the actual order along the 
/// boundary. This is required when hijacking the BiharmonicElement to apply
/// the BiharmonicFluidBoundaryElement in 
/// BiharmonicFluidProblem::impose_traction_free_edge(...)
//================================================================
template <class ELEMENT>
void HermiteQuadMesh<ELEMENT>::
setup_boundary_element_info(std::ostream &outfile)
{

 bool doc=false;
 if (outfile) doc=true;
 
 // Number of boundaries
 unsigned nbound=nboundary();
 
 // Wipe/allocate storage for arrays
 Boundary_element_pt.clear();
 Face_index_at_boundary.clear();
 Boundary_element_pt.resize(nbound);
 Face_index_at_boundary.resize(nbound);
 
 // Temporary vector of sets of pointers to elements on the boundaries: 
 Vector<Vector<FiniteElement*> > vector_of_boundary_element_pt;
 vector_of_boundary_element_pt.resize(nbound);
 
 // Matrix map for working out the fixed local coord for elements on boundary
 MapMatrixMixed<unsigned,FiniteElement*,Vector<int>* > 
  boundary_identifier;
 

 // Loop over elements
 //-------------------
 unsigned nel=nelement();
 for (unsigned e=0;e<nel;e++)
  {
   // Get pointer to element
   FiniteElement* fe_pt=finite_element_pt(e);
   
   if (doc) outfile << "Element: " << e << " " << fe_pt << std::endl;
   
   // Only include 2D elements! Some meshes contain interface elements too.
   if (fe_pt->dim()==2)
    {
     // Loop over the element's nodes and find out which boundaries they're on
     // ----------------------------------------------------------------------
     unsigned nnode_1d=fe_pt->nnode_1d();
     
     // Loop over nodes in order
     for (unsigned i0=0;i0<nnode_1d;i0++)
      {
       for (unsigned i1=0;i1<nnode_1d;i1++)
        {
         // Local node number
         unsigned j=i0+i1*nnode_1d;
         
         // Get pointer to vector of boundaries that this
         // node lives on
         std::set<unsigned>* boundaries_pt=0;
         fe_pt->node_pt(j)->get_boundaries_pt(boundaries_pt);

         // If the node lives on some boundaries....
         if (boundaries_pt!=0)
          {
           // Loop over boundaries
           //unsigned nbound=(*boundaries_pt).size();
           for (std::set<unsigned>::iterator it=boundaries_pt->begin();
                it != boundaries_pt->end();++it)
            {
             // Add pointer to finite element to set for the appropriate 
             // boundary -- storage in set makes sure we don't count elements
             // multiple times
             unsigned temp_size = vector_of_boundary_element_pt[*it].size();
             bool temp_flag = true;
             for (unsigned temp_i = 0; temp_i < temp_size; temp_i++)
              {
               if (vector_of_boundary_element_pt[*it][temp_i] == fe_pt)
                temp_flag = false;
              }
             if (temp_flag)
              vector_of_boundary_element_pt[*it].push_back(fe_pt);
             
             // For the current element/boundary combination, create
             // a vector that stores an indicator which element boundaries
             // the node is located (boundary_identifier=-/+1 for nodes
             // on the left/right boundary; boundary_identifier=-/+2 for nodes
             // on the lower/upper boundary. We determine these indices
             // for all corner nodes of the element and add them to a vector
             // to a vector. This allows us to decide which face of the element
             // coincides with the boundary since the (quad!) element must 
             // have exactly two corner nodes on the boundary.
             if (boundary_identifier(*it,fe_pt)==0)
              {
               boundary_identifier(*it,fe_pt)=new Vector<int>;
              }
             
             // Are we at a corner node?
             if (((i0==0)||(i0==nnode_1d-1))&&((i1==0)||(i1==nnode_1d-1)))
              {
               // Create index to represent position relative to s_0
               (*boundary_identifier(*it,fe_pt)).
                push_back(1*(2*i0/(nnode_1d-1)-1));               
               
               // Create index to represent position relative to s_1
               (*boundary_identifier(*it,fe_pt)).
                push_back(2*(2*i1/(nnode_1d-1)-1));
              } 

            }
          }
         //else
         // {
         //  oomph_info << "...does not live on any boundaries " << std::endl;
         // }
  
        }
      }
    }
    //else
    //{
     //oomph_info << "Element " << e << " does not qualify" << std::endl;
    //}
  }

 
 // Now copy everything across into permanent arrays
 //-------------------------------------------------

 // Note: vector_of_boundary_element_pt contains all elements
 // that have (at least) one corner node on a boundary -- can't copy 
 // them across into Boundary_element_pt
 // yet because some of them might have only one node on the
 // the boundary in which case they don't qualify as 
 // boundary elements!

 // Loop over boundaries
 //---------------------
 for (unsigned i=0;i<nbound;i++)
  {
   // Number of elements on this boundary (currently stored in a set)
   unsigned nel=vector_of_boundary_element_pt[i].size();
    
   // Allocate storage for the coordinate identifiers
   Face_index_at_boundary[i].resize(nel);
   
   // Loop over elements that have at least one corner node on this boundary
   //-----------------------------------------------------------------------
   unsigned e_count=0;
   typedef Vector<FiniteElement*>::iterator IT;
   for (IT it=vector_of_boundary_element_pt[i].begin();
        it!=vector_of_boundary_element_pt[i].end();
        it++)
    {    
     // Recover pointer to element
     FiniteElement* fe_pt=*it;

     // Initialise count for boundary identiers (-2,-1,1,2)
     std::map<int,unsigned> count;
     
     // Loop over coordinates
     for (unsigned ii=0;ii<2;ii++)
      {
       // Loop over upper/lower end of coordinates
       for (int sign=-1;sign<3;sign+=2)
        {
         count[(ii+1)*sign]=0;
        }
      }
     
     // Loop over boundary indicators for this element/boundary
     unsigned n_indicators=(*boundary_identifier(i,fe_pt)).size();
     for (unsigned j=0;j<n_indicators;j++)
      {
       count[(*boundary_identifier(i,fe_pt))[j] ]++;
      }
     delete boundary_identifier(i,fe_pt);

     // Determine the correct boundary indicator by checking that it 
     // occurs twice (since two corner nodes of the element's boundary
     // need to be located on the domain boundary
     int indicator=-10;

     //Check that we're finding exactly one boundary indicator
     bool found=false;

     // Loop over coordinates
     for (unsigned ii=0;ii<2;ii++)
      {
       // Loop over upper/lower end of coordinates
       for (int sign=-1;sign<3;sign+=2)
        {
         if (count[(ii+1)*sign]==2)
          {
           // Check that we haven't found multiple boundaries
           if (found)
            {
             std::string error_message=
              "Trouble: Multiple boundary identifiers!\n";
             error_message += 
              "Elements should only have at most 2 corner ";
             error_message += 
              "nodes on any one boundary.\n";

             throw OomphLibError(
              error_message,
              OOMPH_CURRENT_FUNCTION,
              OOMPH_EXCEPTION_LOCATION);
            }
           found=true;
           indicator=(ii+1)*sign;
          }
        }
      }
     
     // Element has exactly two corner nodes on boundary
     if (found)
      {
       // Add to permanent storage
       Boundary_element_pt[i].push_back(fe_pt);

       // Now convert boundary indicator into information required
       // for FaceElements
       switch (indicator)
        {
         
        case -2:
         
         // s_1 is fixed at -1.0:
         Face_index_at_boundary[i][e_count]= -2;
         break;
         
        case -1:
         
         // s_0 is fixed at -1.0:
         Face_index_at_boundary[i][e_count] = -1;
         break;
         
         
        case 1:
         
         // s_0 is fixed at 1.0:
         Face_index_at_boundary[i][e_count] = 1;
         break;
         
        case 2:
         
         // s_1 is fixed at 1.0:
         Face_index_at_boundary[i][e_count] = 2;
         break;
         
        default:

         throw OomphLibError("Never get here",
                             OOMPH_CURRENT_FUNCTION,
                             OOMPH_EXCEPTION_LOCATION);
        }

       // Increment counter
       e_count++;
      }
     
    }
  }
 


 // Doc?
 //-----
 if (doc)
  {
   // Loop over boundaries
   for (unsigned i=0;i<nbound;i++)
    {
     unsigned nel=Boundary_element_pt[i].size();
     outfile << "Boundary: " << i
             << " is adjacent to " << nel
             << " elements" << std::endl;
     
     // Loop over elements on given boundary
     for (unsigned e=0;e<nel;e++)
      {
       FiniteElement* fe_pt=Boundary_element_pt[i][e];
       outfile << "Boundary element:" <<  fe_pt
               << " Face index of element along boundary is " 
               <<  Face_index_at_boundary[i][e] << std::endl;
      }
    }
  }
 

 // Lookup scheme has now been setup yet
 Lookup_for_elements_next_boundary_is_setup=true;

}
}

#endif
