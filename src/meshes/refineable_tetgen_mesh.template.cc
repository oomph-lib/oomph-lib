// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC// Copyright (C) 2006-2021 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================

#ifndef OOMPH_REFINEABLE_TETGEN_MESH_TEMPLATE_CC
#define OOMPH_REFINEABLE_TETGEN_MESH_TEMPLATE_CC

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

// OOMPH-LIB Headers
#include "refineable_tetgen_mesh.template.h"
#include "../generic/sample_point_parameters.h"
#include "../generic/mesh_as_geometric_object.h"
#include "../generic/projection.h"
#include "../generic/face_element_as_geometric_object.h"

namespace oomph
{
  ///  Helper function that updates the input faceted surface
  /// by using the flattened elements from FaceMesh(es) that are
  /// constructed for the boundaries associated with the segments of the
  /// polygon.
  template<class ELEMENT>
  void RefineableTetgenMesh<ELEMENT>::update_faceted_surface_using_face_mesh(
    TetMeshFacetedSurface*& faceted_surface_pt)
  {
    // The easiest thing to do is simply to update the
    // positions of the key control nodes, leaving the connectivity alone,
    // but that doesn't allow for any surface remeshing

    /// List of vertex nodes
    std::list<Node*> new_vertex_nodes;
    // List of facets and boundary ids
    std::list<std::pair<Vector<unsigned>, unsigned>> new_facet_list;

    // Loop over the number of old facets
    unsigned n_old_facet = faceted_surface_pt->nfacet();
    for (unsigned f = 0; f < n_old_facet; f++)
    {
      // Get the boundary id of the facet. Need to subtract one,
      // which is confusing now I think about it.
      // ALH: Should fix this.
      unsigned bound = faceted_surface_pt->one_based_facet_boundary_id(f) - 1;

      // Create a face mesh adjacent to the fluid mesh's bound-th boundary.
      // The face mesh consists of FaceElements that may also be
      // interpreted as GeomObjects
      Mesh* face_mesh_pt = new Mesh;
      this->template build_face_mesh<ELEMENT, FaceElementAsGeomObject>(
        bound, face_mesh_pt);

      // Loop over these new face elements and tell them the boundary number
      // from the bulk fluid mesh -- this is required to they can
      // get access to the boundary coordinates!
      unsigned n_face_element = face_mesh_pt->nelement();
      for (unsigned e = 0; e < n_face_element; e++)
      {
        // Cast the element pointer to the correct thing!
        FaceElementAsGeomObject<ELEMENT>* el_pt =
          dynamic_cast<FaceElementAsGeomObject<ELEMENT>*>(
            face_mesh_pt->element_pt(e));

        // Set bulk boundary number
        el_pt->set_boundary_number_in_bulk_mesh(bound);
      }

      // In order to set up the new faceted representation
      // Need to know the positions of the corner nodes
      // and the connectivity

      // Storage for the connectivity information
      Vector<unsigned> new_local_facet(3);

      // Now we have the face mesh loop over the face elements and
      // print out the end points
      for (unsigned e = 0; e < n_face_element; ++e)
      {
        // Cache pointer to the element
        FiniteElement const* elem_pt = face_mesh_pt->finite_element_pt(e);

        // Just use the three primary (corner) nodes to define the facet
        unsigned n_vertex_node = 3;
        for (unsigned n = 0; n < n_vertex_node; n++)
        {
          // Cache the pointer to the node
          Node* const nod_pt = elem_pt->node_pt(n);
          // If the vertex node is in the list return the number
          unsigned counter = 0;
          bool found_it = false;
          for (std::list<Node*>::iterator it = new_vertex_nodes.begin();
               it != new_vertex_nodes.end();
               ++it, ++counter)
          {
            // If we have found the node then store it
            if (*it == nod_pt)
            {
              new_local_facet[n] = counter;
              found_it = true;
              break;
            }
          }

          // If we haven't found it
          // then add the node to the list and fill in the counter
          if (!found_it)
          {
            new_vertex_nodes.push_back(nod_pt);
            // We know where it is
            new_local_facet[n] = counter;
          }
        }

        // Add the new facet connectivity to the list
        new_facet_list.push_back(std::make_pair(new_local_facet, bound + 1));
      }
    } // End of loop over old facets


    // Probably want the surface mesh in a better data structure so
    // that we can perform refinement or coarsening on it
    // i.e. want neighbours, edge flips all that fun stuff
    // That will go here!

    // Now we need to put the information into the appropriate data structures
    // for the Surface

    // Now sort out the facet nodes
    unsigned n_facet_vertex = new_vertex_nodes.size();
    // Vector<Vector<double> > facet_point(n_facet_vertex);
    Vector<Node*> facet_nodes_pt(n_facet_vertex);
    unsigned count = 0;
    for (std::list<Node*>::iterator it = new_vertex_nodes.begin();
         it != new_vertex_nodes.end();
         ++it)
    {
      facet_nodes_pt[count] = *it;
      // facet_point[count].resize(3);
      //   for(unsigned i=0;i<3;i++)
      //    {
      //     facet_point[count][i] = (*it)->x(i);
      //    }
      ++count;
    }

    // And also the facets
    unsigned n_facet = new_facet_list.size();
    Vector<Vector<unsigned>> new_facet(n_facet);
    Vector<unsigned> new_facet_boundary_id(n_facet);
    count = 0;
    for (std::list<std::pair<Vector<unsigned>, unsigned>>::iterator it =
           new_facet_list.begin();
         it != new_facet_list.end();
         ++it)
    {
      new_facet[count] = (*it).first;
      new_facet_boundary_id[count] = (*it).second;
      ++count;
    }

    for (unsigned f = 0; f < n_facet; f++)
    {
      for (unsigned i = 0; i < 3; i++)
      {
        oomph_info << new_facet[f][i] << " ";
      }
      oomph_info << " : ";
      oomph_info << new_facet_boundary_id[f] << "\n";
    }

    // Now just create the new boundary
    delete faceted_surface_pt;
    faceted_surface_pt = new TetMeshFacetedClosedSurfaceForRemesh(
      facet_nodes_pt, new_facet, new_facet_boundary_id);

    // Also need to setup the reverse look-up scheme again
    this->setup_reverse_lookup_schemes_for_faceted_surface(faceted_surface_pt);

    // Take average to get a new hole position (Won't always work)
    Vector<double> inner_point(3, 0.0);
    for (unsigned n = 0; n < n_facet_vertex; n++)
    {
      for (unsigned i = 0; i < 3; i++)
      {
        inner_point[i] += facet_nodes_pt[n]->x(i);
      }
    }

    for (unsigned i = 0; i < 3; i++)
    {
      inner_point[i] /= n_facet_vertex;
    }

    // Now set the hole if required
    dynamic_cast<TetMeshFacetedClosedSurface*>(faceted_surface_pt)
      ->set_hole_for_tetgen(inner_point);
  }


  ///  Generate a new faceted representation of the inner hole
  /// boundaries
  template<class ELEMENT>
  void RefineableTetgenMesh<ELEMENT>::surface_remesh_for_inner_hole_boundaries()
  {
    // Loop over the number of internal boundarys
    unsigned n_hole = this->Internal_surface_pt.size();
    for (unsigned ihole = 0; ihole < n_hole; ihole++)
    {
      // Now can the surface update its own representation goes in here

      // If not we have to generate it from the new mesh
      {
        // Update the faceted surface associated with the ihole-th hole
        this->update_faceted_surface_using_face_mesh(
          this->Internal_surface_pt[ihole]);
      }
    }
  }

  ///  Snap the boundary nodes onto any curvilinear boundaries
  template<class ELEMENT>
  void RefineableTetgenMesh<ELEMENT>::snap_nodes_onto_boundary(
    RefineableTetgenMesh<ELEMENT>*& new_mesh_pt, const unsigned& b)
  {
    // Quick return
    if (!Boundary_coordinate_exists[b])
    {
      oomph_info << "Not snapping nodes on boundary " << b
                 << " because no boundary coordinate has been set up.\n";
      return;
    }

    // Firstly we set the boundary coordinates of the new nodes
    // In case the mapping between the geometric object's intrinsic coordiante
    // and the arc-length coordinate is nonlinear.
    // This is only an approximation,
    // but it will ensure that the nodes that were input to triangle will
    // retain exactly the same boundary coordinates and
    // then linear interpolation
    // is used between those values for any newly created nodes.


    // Create a face mesh adjacent to the fluid mesh's b-th boundary.
    // The face mesh consists of FaceElements that may also be
    // interpreted as GeomObjects
    Mesh* face_mesh_pt = new Mesh;
    this->template build_face_mesh<ELEMENT, FaceElementAsGeomObject>(
      b, face_mesh_pt);

    // Loop over these new face elements and tell them the boundary number
    // from the bulk fluid mesh -- this is required to they can
    // get access to the boundary coordinates!
    unsigned n_face_element = face_mesh_pt->nelement();
    for (unsigned e = 0; e < n_face_element; e++)
    {
      // Cast the element pointer to the correct thing!
      FaceElementAsGeomObject<ELEMENT>* el_pt =
        dynamic_cast<FaceElementAsGeomObject<ELEMENT>*>(
          face_mesh_pt->element_pt(e));

      // Set bulk boundary number
      el_pt->set_boundary_number_in_bulk_mesh(b);
    }


    // Compare face meshes
    {
      Mesh* new_face_mesh_pt = new Mesh;
      new_mesh_pt->template build_face_mesh<ELEMENT, FaceElementAsGeomObject>(
        b, new_face_mesh_pt);

      std::ostringstream filestring;
      filestring << "old_mesh_boundary" << b << ".dat";
      face_mesh_pt->output(filestring.str().c_str());
      filestring.clear();
      filestring << "new_mesh_boundary" << b << ".dat";
      new_face_mesh_pt->output(filestring.str().c_str());

      Vector<double> b_coo(2);
      std::cout << "OLD---\n";
      // Now let's look at the boundary coordinates
      unsigned n_tmp_node = this->nboundary_node(b);
      for (unsigned n = 0; n < n_tmp_node; ++n)
      {
        Node* const nod_pt = this->boundary_node_pt(b, n);
        nod_pt->get_coordinates_on_boundary(b, b_coo);
        std::cout << nod_pt->x(0) << " " << nod_pt->x(1) << " " << nod_pt->x(2)
                  << " " << b_coo[0] << " " << b_coo[1] << "\n";
      }

      std::cout << "NEW-----------\n";
      // Now let's look at the boundary coordinates
      n_tmp_node = new_mesh_pt->nboundary_node(b);
      for (unsigned n = 0; n < n_tmp_node; ++n)
      {
        Node* const nod_pt = new_mesh_pt->boundary_node_pt(b, n);
        nod_pt->get_coordinates_on_boundary(b, b_coo);
        std::cout << nod_pt->x(0) << " " << nod_pt->x(1) << " " << nod_pt->x(2)
                  << " " << b_coo[0] << " " << b_coo[1] << "\n";
      }
    }


    // Now make the mesh as geometric object
    MeshAsGeomObject* mesh_geom_obj_pt = new MeshAsGeomObject(face_mesh_pt);

    // Now assign the new nodes positions based on the old meshes
    // potentially curvilinear boundary (its geom object incarnation)
    Vector<double> new_x(3);
    Vector<double> b_coord(2);
    unsigned n_new_boundary_node = new_mesh_pt->nboundary_node(b);
    for (unsigned n = 0; n < n_new_boundary_node; n++)
    {
      // Get the boundary coordinate of all new nodes
      Node* const nod_pt = new_mesh_pt->boundary_node_pt(b, n);
      nod_pt->get_coordinates_on_boundary(b, b_coord);
      // Let's find boundary coordinates of the new node
      mesh_geom_obj_pt->position(b_coord, new_x);
      // Now snap to the boundary
      for (unsigned i = 0; i < 3; i++)
      {
        nod_pt->x(i) = new_x[i];
      }
    }


    // Delete the allocated memory for the geometric object and face mesh
    delete mesh_geom_obj_pt;
    face_mesh_pt->flush_element_and_node_storage();
    delete face_mesh_pt;

    // Loop over the elements adjacent to the boundary
    unsigned n_element = new_mesh_pt->nboundary_element(b);
    if (n_element > 0)
    {
      // Make a dummy simplex element
      TElement<3, 2> dummy_four_node_element;
      // Make a dummy quadratic element
      TElement<3, 3> dummy_ten_node_element;
      Vector<double> s(3);
      Vector<double> x_new(3);
      for (unsigned n = 0; n < 4; n++)
      {
        dummy_four_node_element.construct_node(n);
      }
      for (unsigned n = 0; n < 10; n++)
      {
        dummy_ten_node_element.construct_node(n);
      }
      for (unsigned e = 0; e < n_element; e++)
      {
        // Cache the element pointer
        ELEMENT* elem_pt =
          dynamic_cast<ELEMENT*>(new_mesh_pt->boundary_element_pt(b, e));

        // Find the number of nodes
        const unsigned n_node = elem_pt->nnode();
        // Only do something if not simplex element
        if (n_node > 4)
        {
          // Copy the nodes into the dummy
          for (unsigned n = 0; n < 4; n++)
          {
            for (unsigned i = 0; i < 3; i++)
            {
              dummy_four_node_element.node_pt(n)->x(i) =
                elem_pt->node_pt(n)->x(i);
            }
          }

          // Now sort out the mid-side nodes
          for (unsigned n = 4; n < 10; n++)
          {
            // If it's not on a boundary then reset to be interpolated
            // from the simplex
            if (!elem_pt->node_pt(n)->is_on_boundary())
            {
              elem_pt->local_coordinate_of_node(n, s);
              dummy_four_node_element.interpolated_x(s, x_new);
              for (unsigned i = 0; i < 3; i++)
              {
                elem_pt->node_pt(n)->x(i) = x_new[i];
              }
            }
          }
        }

        // If we have more than 10 nodes interpolate from the quadratic shape
        if (n_node > 10)
        {
          // Copy the nodes into the dummy
          for (unsigned n = 0; n < 10; n++)
          {
            for (unsigned i = 0; i < 3; i++)
            {
              dummy_ten_node_element.node_pt(n)->x(i) =
                elem_pt->node_pt(n)->x(i);
            }
          }

          // Now sort out the mid-face and central nodes
          for (unsigned n = 10; n < n_node; n++)
          {
            // If it's not on a boundary then reset to be interpolated
            // from the simplex
            if (!elem_pt->node_pt(n)->is_on_boundary())
            {
              elem_pt->local_coordinate_of_node(n, s);
              dummy_ten_node_element.interpolated_x(s, x_new);
              for (unsigned i = 0; i < 3; i++)
              {
                elem_pt->node_pt(n)->x(i) = x_new[i];
              }
            }
          }
        }
      }
    } // End of fix up of elements
  }


  //======================================================================
  /// Adapt problem based on specified elemental error estimates
  //======================================================================
  template<class ELEMENT>
  void RefineableTetgenMesh<ELEMENT>::adapt(const Vector<double>& elem_error)
  {
    double t_start = 0.0;
    //###################################
    t_start = TimingHelpers::timer();
    //###################################

    // Get refinement targets
    Vector<double> target_size(elem_error.size());
    double max_edge_ratio =
      this->compute_volume_target(elem_error, target_size);
    // Get maximum target volume
    unsigned n = target_size.size();
    double max_size = 0.0;
    double min_size = DBL_MAX;
    for (unsigned e = 0; e < n; e++)
    {
      if (target_size[e] > max_size) max_size = target_size[e];
      if (target_size[e] < min_size) min_size = target_size[e];
    }

    oomph_info << "Maximum target size: " << max_size << std::endl;
    oomph_info << "Minimum target size: " << min_size << std::endl;
    oomph_info << "Number of elements to be refined " << this->Nrefined
               << std::endl;
    oomph_info << "Number of elements to be unrefined " << this->Nunrefined
               << std::endl;
    oomph_info << "Max edge ratio " << max_edge_ratio << std::endl;

    double orig_max_size, orig_min_size;
    this->max_and_min_element_size(orig_max_size, orig_min_size);
    oomph_info << "Max/min element size in original mesh: " << orig_max_size
               << " " << orig_min_size << std::endl;

    //##################################################################
    oomph_info
      << "adapt: Time for getting volume targets                      : "
      << TimingHelpers::timer() - t_start << " sec " << std::endl;
    //##################################################################

    //===============================================================
    // END: Compute target volumes
    //===============================================================

    // Check if boundaries need to be updated (regardless of
    // requirements of bulk error estimator) but don't do anything!
    bool check_only = true;
    bool outer_boundary_update_necessary = false;
    bool inner_boundary_update_necessary = false; // true;

    // Should we bother to adapt?
    if ((Nrefined > 0) || (Nunrefined > this->max_keep_unrefined()) ||
        (max_edge_ratio > this->max_permitted_edge_ratio()))
    {
      if (!((Nrefined > 0) || (Nunrefined > max_keep_unrefined())))
      {
        oomph_info << "Mesh regeneration triggered by edge ratio criterion\n";
      }

      // Generate remesh of inner surface
      if (inner_boundary_update_necessary)
      {
        this->surface_remesh_for_inner_hole_boundaries();


        // If there is not a geometric object associated with the boundary
        // the reset the boundary coordinates so that the lengths are consistent
        // in the new mesh and the old mesh.
        const unsigned n_boundary = this->nboundary();
        for (unsigned b = 0; b < n_boundary; ++b)
        {
          // if(this->boundary_geom_object_pt(b)==0)
          {
            this->template setup_boundary_coordinates<ELEMENT>(b);
          }
        }
      }


      //###################################
      t_start = TimingHelpers::timer();
      //###################################

      // Are we dealing with a solid mesh?
      SolidMesh* solid_mesh_pt = dynamic_cast<SolidMesh*>(this);

      // Build temporary uniform background mesh
      //----------------------------------------
      // with volume set by maximum required volume
      //---------------------------------------
      RefineableTetgenMesh<ELEMENT>* tmp_new_mesh_pt = 0;
      if (solid_mesh_pt != 0)
      {
        /*throw OomphLibError("Solid RefineableTetgenMesh not done yet.",
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);*/
        tmp_new_mesh_pt = new RefineableSolidTetgenMesh<ELEMENT>(
          this->Outer_boundary_pt,
          this->Internal_surface_pt,
          max_size,
          this->Time_stepper_pt,
          this->Use_attributes,
          this->Corner_elements_must_be_split);
      }
      else
      {
        tmp_new_mesh_pt = new RefineableTetgenMesh<ELEMENT>(
          this->Outer_boundary_pt,
          this->Internal_surface_pt,
          max_size,
          this->Time_stepper_pt,
          this->Use_attributes,
          this->Corner_elements_must_be_split);
      }


      //##################################################################
      oomph_info
        << "adapt: Time for building temp mesh                        : "
        << TimingHelpers::timer() - t_start << " sec " << std::endl;
      //##################################################################

      // tmp_new_mesh_pt->output("pre_mesh_nodes_snapped_0.dat");

      // //Move the nodes on the new boundary onto the
      // //old curvilinear boundary
      // //If the boundary is straight this will do precisely nothing
      // //but will be somewhat inefficient
      // {
      //  const unsigned n_boundary = this->nboundary();
      //  for(unsigned b=0;b<n_boundary;b++)
      //   {
      //    std::cout << "Snapping to boundary " << b << "\n";
      //    this->snap_nodes_onto_boundary(tmp_new_mesh_pt,b);
      //   }
      // }

      // tmp_new_mesh_pt->output("mesh_nodes_snapped_0.dat");


      // Get the tetgenio object associated with that mesh
      tetgenio* tmp_new_tetgenio_pt = tmp_new_mesh_pt->tetgenio_pt();
      RefineableTetgenMesh<ELEMENT>* new_mesh_pt = 0;

      // If the mesh is a solid mesh then do the mapping based on the
      // Eulerian coordinates
      bool use_eulerian_coords = false;
      if (solid_mesh_pt != 0)
      {
        use_eulerian_coords = true;
      }

#ifdef OOMPH_HAS_CGAL

      // Make cgal-based bin
      CGALSamplePointContainerParameters cgal_params(this);
      if (use_eulerian_coords)
      {
        cgal_params.enable_use_eulerian_coordinates_during_setup();
      }
      MeshAsGeomObject* mesh_geom_obj_pt = new MeshAsGeomObject(&cgal_params);

#else

      std::ostringstream error_message;
      error_message << "Non-CGAL-based target size transfer not implemented.\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);

      // Here's the relevant construction from the triangle mesh. Update...

      // // Make nonrefineable bin
      // NonRefineableBinArrayParameters params(this);
      // if (use_eulerian_coords)
      //  {
      //   params.enable_use_eulerian_coordinates_during_setup();
      //  }
      // Vector<unsigned> bin_dim(2);
      // bin_dim[0]=Nbin_x_for_area_transfer;
      // bin_dim[1]=Nbin_y_for_area_transfer;
      // params.dimensions_of_bin_array()=bin_dim;
      // MeshAsGeomObject* mesh_geom_obj_pt=new MeshAsGeomObject(&params);

#endif

      // Set up a map from pointer to element to its number
      // in the mesh
      std::map<GeneralisedElement*, unsigned> element_number;
      unsigned nelem = this->nelement();
      for (unsigned e = 0; e < nelem; e++)
      {
        element_number[this->element_pt(e)] = e;
      }

      // Now start iterating to refine mesh recursively
      //-----------------------------------------------
      bool done = false;
      unsigned iter = 0;
      while (!done)
      {
        // Accept by default but overwrite if things go wrong below
        done = true;

        // Loop over elements in new (tmp) mesh and visit all
        // its integration points. Check where it's located in the bin
        // structure of the current mesh and pass the target size
        // to the new element
        unsigned nelem = tmp_new_mesh_pt->nelement();

        // Store the target sizes for elements in the temporary
        // mesh
        Vector<double> new_transferred_target_size(nelem, 0.0);
        for (unsigned e = 0; e < nelem; e++)
        {
          ELEMENT* el_pt =
            dynamic_cast<ELEMENT*>(tmp_new_mesh_pt->element_pt(e));
          unsigned nint = el_pt->integral_pt()->nweight();
          for (unsigned ipt = 0; ipt < nint; ipt++)
          {
            // Get the coordinate of current point
            Vector<double> s(3);
            for (unsigned i = 0; i < 3; i++)
            {
              s[i] = el_pt->integral_pt()->knot(ipt, i);
            }

            Vector<double> x(3);
            el_pt->interpolated_x(s, x);

#if OOMPH_HAS_CGAL

            // Try the five nearest sample points for Newton search
            // then just settle on the nearest one
            GeomObject* geom_obj_pt = 0;
            unsigned max_sample_points = 5;
            dynamic_cast<CGALSamplePointContainer*>(
              mesh_geom_obj_pt->sample_point_container_pt())
              ->limited_locate_zeta(x, max_sample_points, geom_obj_pt, s);
#ifdef PARANOID
            if (geom_obj_pt == 0)
            {
              std::stringstream error_message;
              error_message << "Limited locate zeta failed for zeta = [ "
                            << x[0] << " " << x[1] << " " << x[2]
                            << " ]. Makes no sense!\n";
              throw OomphLibError(error_message.str(),
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
            }
            else
            {
#endif
              FiniteElement* fe_pt = dynamic_cast<FiniteElement*>(geom_obj_pt);
#ifdef PARANOID
              if (fe_pt == 0)
              {
                std::stringstream error_message;
                error_message << "Cast to FE for GeomObject returned by "
                                 "limited locate zeta failed for zeta = [ "
                              << x[0] << " " << x[1] << " " << x[2]
                              << " ]. Makes no sense!\n";
                throw OomphLibError(error_message.str(),
                                    OOMPH_CURRENT_FUNCTION,
                                    OOMPH_EXCEPTION_LOCATION);
              }
              else
              {
#endif
                // What's the target size of the element that contains this
                // point
                double tg_size = target_size[element_number[fe_pt]];

                // Go for smallest target size over all integration
                // points in new element
                // to force "one level" of refinement (the one-level-ness
                // is enforced below by limiting the actual reduction in
                // size
                if (new_transferred_target_size[e] != 0.0)
                {
                  new_transferred_target_size[e] =
                    std::min(new_transferred_target_size[e], tg_size);
                }
                else
                {
                  new_transferred_target_size[e] = tg_size;
                }
#ifdef PARANOID
              }
            }
#endif

// Non-CGAL
#else

            std::ostringstream error_message;
            error_message
              << "Non-CGAL-based target size transfer not implemented.\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);

            // Here's the relevant construction from the triangle mesh.
            // Update...

            // // Find the bin that contains that point and its contents
            // int bin_number=0;
            // bin_array_pt->get_bin(x,bin_number);

            // // Did we find it?
            // if (bin_number<0)
            //  {
            //   // Not even within bin boundaries... odd
            //   std::stringstream error_message;
            //   error_message
            //    << "Very odd -- we're looking for a point[ "
            //    << x[0] << " " << x[1] << " " << x[2] << " ] that's not even
            //    \n"
            //    << "located within the bin boundaries.\n";
            //   throw OomphLibError(error_message.str(),
            //                       OOMPH_CURRENT_FUNCTION,
            //                       OOMPH_EXCEPTION_LOCATION);
            //  } // if (bin_number<0)
            // else
            //  {
            //   // Go for smallest target size of any element in this bin
            //   // to force "one level" of refinement (the one-level-ness
            //   // is enforced below by limiting the actual reduction in
            //   // size
            //   if (new_transferred_target_size[e]!=0)
            //    {
            //      std::min(new_transferred_target_size[e],
            //               bin_min_target_size[bin_number]);
            //    }
            //   else
            //    {
            //     new_transferred_target_size[e]=bin_min_target_size[bin_number];
            //    }

            //  }

#endif

          } // for (ipt<nint)

        } // for (e<nelem)


        // do some output (keep it alive!)
        const bool output_target_sizes = false;
        if (output_target_sizes)
        {
          unsigned length = new_transferred_target_size.size();
          for (unsigned u = 0; u < length; u++)
          {
            oomph_info << "Element" << u
                       << ",target size: " << new_transferred_target_size[u]
                       << std::endl;
          }
        }

        // Now copy into target size for temporary mesh but limit to
        // the equivalent of one sub-division per iteration
#ifdef OOMPH_HAS_MPI
        unsigned n_ele_need_refinement_iter = 0;
#endif


        // Don't delete! Keep these around for debugging
        // ofstream tmp_mesh_file;
        // tmp_mesh_file.open("tmp_mesh_file.dat");
        // tmp_new_mesh_pt->output(tmp_mesh_file);
        // tmp_mesh_file.close();

        std::ofstream target_sizes_file;
        char filename[100];
        sprintf(filename, "target_sizes%i.dat", iter);
        if (output_target_sizes)
        {
          target_sizes_file.open(filename);
        }

        const unsigned nel_new = tmp_new_mesh_pt->nelement();
        Vector<double> new_target_size(nel_new);
        for (unsigned e = 0; e < nel_new; e++)
        {
          // The finite element
          FiniteElement* f_ele_pt = tmp_new_mesh_pt->finite_element_pt(e);

          // Transferred target size
          const double new_size = new_transferred_target_size[e];
          if (new_size <= 0.0)
          {
            std::ostringstream error_stream;
            error_stream
              << "This shouldn't happen! Element whose centroid is at "
              << (f_ele_pt->node_pt(0)->x(0) + f_ele_pt->node_pt(1)->x(0) +
                  f_ele_pt->node_pt(2)->x(0) + f_ele_pt->node_pt(3)->x(0)) /
                   4.0
              << " "
              << (f_ele_pt->node_pt(0)->x(1) + f_ele_pt->node_pt(1)->x(1) +
                  f_ele_pt->node_pt(2)->x(1) + f_ele_pt->node_pt(3)->x(1)) /
                   4.0
              << " "
              << (f_ele_pt->node_pt(0)->x(2) + f_ele_pt->node_pt(1)->x(2) +
                  f_ele_pt->node_pt(2)->x(2) + f_ele_pt->node_pt(3)->x(2)) /
                   4.0
              << " "
              << " has no target size assigned\n";
            throw OomphLibError(error_stream.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }
          else
          {
            // Limit target size to the equivalent of uniform refinement
            // during this stage of the iteration
            new_target_size[e] = new_size;
            if (new_target_size[e] < f_ele_pt->size() / 4.0)
            {
              new_target_size[e] = f_ele_pt->size() / 4.0;

              // ALH: It seems that tetgen "enlarges" the volume constraint
              // so this criterion can never be met unless dividing by 1.2
              // as well. MH: Is this the reason why Andrew's version of
              // adaptation never converges? Took it out.
              // new_target_size[e] /= 1.2;

              // We'll need to give it another go later
              done = false;
            }

            // Don't delete! Keep around for debugging
            if (output_target_sizes)
            {
              target_sizes_file << "ZONE N=4, E=1, F=FEPOINT, ET=TETRAHEDRON\n";
              for (unsigned j = 0; j < 4; j++)
              {
                target_sizes_file << f_ele_pt->node_pt(j)->x(0) << " "
                                  << f_ele_pt->node_pt(j)->x(1) << " "
                                  << f_ele_pt->node_pt(j)->x(2) << " "
                                  << new_size << " " << new_target_size[e]
                                  << std::endl;
              }
              target_sizes_file << "1 2 3 4\n"; // connectivity

              // Keep around; just doc at centroid
              /* target_sizes_file  */
              /*  <<  (f_ele_pt->node_pt(0)->x(0)+ */
              /*       f_ele_pt->node_pt(1)->x(0)+ */
              /*       f_ele_pt->node_pt(2)->x(0)+ */
              /*       f_ele_pt->node_pt(3)->x(0))/4.0 << " " */
              /*  << (f_ele_pt->node_pt(0)->x(1)+ */
              /*      f_ele_pt->node_pt(1)->x(1)+ */
              /*      f_ele_pt->node_pt(2)->x(1)+ */
              /*      f_ele_pt->node_pt(3)->x(1))/4.0 << " " */
              /*  << (f_ele_pt->node_pt(0)->x(2)+ */
              /*      f_ele_pt->node_pt(1)->x(2)+ */
              /*      f_ele_pt->node_pt(2)->x(2)+ */
              /*      f_ele_pt->node_pt(3)->x(2))/4.0 << " " */
              /*  << new_size << " "  */
              /*  << new_target_size[e] << std::endl; */
            }

#ifdef OOMPH_HAS_MPI
            // Keep track of the elements that require (un)refinement
            n_ele_need_refinement_iter++;
#endif

          } // else if (new_size <= 0.0)

        } // for (e < nel_new)

        // Don't delete! Keep around for debugging
        if (output_target_sizes)
        {
          target_sizes_file.close();
        }

        if (done)
        {
          oomph_info
            << "All size adjustments accommodated by max. permitted size"
            << " reduction during iter " << iter << "\n";
        }
        else
        {
          oomph_info << "NOT all size adjustments accommodated by max. "
                     << "permitted size reduction  during iter " << iter
                     << "\n";
        }


        oomph_info
          << "\n\n\n==================================================\n"
          << "==================================================\n"
          << "==================================================\n"
          << "==================================================\n"
          << "\n\n\n";

        //##################################################################
        oomph_info
          << "adapt: Time for new_target_size[.]                      : "
          << TimingHelpers::timer() - t_start << " sec " << std::endl;
        //##################################################################


        // Now create the new mesh from TriangulateIO structure
        //-----------------------------------------------------
        // associated with uniform background mesh and the
        //------------------------------------------------
        // associated target element sizes.
        //---------------------------------

        //###################################
        t_start = TimingHelpers::timer();
        //###################################

        // Solid mesh?
        if (solid_mesh_pt != 0)
        {
          /*std::ostringstream error_message;
          error_message
           << "RefineableSolidTetgenMesh not implemented yet.\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);*/
          new_mesh_pt =
            new RefineableSolidTetgenMesh<ELEMENT>(new_target_size,
                                                   tmp_new_tetgenio_pt,
                                                   this->Outer_boundary_pt,
                                                   this->Internal_surface_pt,
                                                   this->Time_stepper_pt,
                                                   this->Use_attributes);
        }
        // No solid mesh
        else
        {
          new_mesh_pt =
            new RefineableTetgenMesh<ELEMENT>(new_target_size,
                                              tmp_new_tetgenio_pt,
                                              this->Outer_boundary_pt,
                                              this->Internal_surface_pt,
                                              this->Time_stepper_pt,
                                              this->Use_attributes);
        }

        //##################################################################
        oomph_info
          << "adapt: Time for new_mesh_pt                            : "
          << TimingHelpers::timer() - t_start << " sec " << std::endl;
        //##################################################################


        // Not done: get ready for another iteration
        iter++;


        // Check if the new mesh actually differs from the old one
        // If not, we're done.
        if (!done)
        {
          unsigned nnod = tmp_new_mesh_pt->nnode();
          if (nnod == new_mesh_pt->nnode())
          {
            unsigned nel = tmp_new_mesh_pt->nelement();
            if (nel == new_mesh_pt->nelement())
            {
              bool nodes_identical = true;
              for (unsigned j = 0; j < nnod; j++)
              {
                bool coords_identical = true;
                for (unsigned i = 0; i < 3; i++)
                {
                  if (new_mesh_pt->node_pt(j)->x(i) !=
                      tmp_new_mesh_pt->node_pt(j)->x(i))
                  {
                    coords_identical = false;
                  }
                }
                if (!coords_identical)
                {
                  nodes_identical = false;
                  break;
                }
              }
              if (nodes_identical)
              {
                done = true;
              }
            }
          }
        }

        // Delete the temporary mesh
        delete tmp_new_mesh_pt;

        // Now transfer over the pointers
        if (!done)
        {
          tmp_new_mesh_pt = new_mesh_pt;
          tmp_new_tetgenio_pt = new_mesh_pt->tetgenio_pt();
        }

      } // end of iteration

      // Move the nodes on the new boundary onto the
      // old curvilinear boundary
      // If the boundary is straight this will do precisely nothing
      // but will be somewhat inefficient
      /*{
       const unsigned n_boundary = this->nboundary();
       for(unsigned b=0;b<n_boundary;b++)
        {
         this->snap_nodes_onto_boundary(new_mesh_pt,b);
        }
        }*/


      // Check that the projection step is not disabled
      if (!Projection_is_disabled)
      {
        //###################################
        t_start = TimingHelpers::timer();
        //###################################

        // Project current solution onto new mesh
        //---------------------------------------
        ProjectionProblem<ELEMENT>* project_problem_pt =
          new ProjectionProblem<ELEMENT>;
        project_problem_pt->mesh_pt() = new_mesh_pt;
        project_problem_pt->project(this);
        delete project_problem_pt;

        //##################################################################
        oomph_info
          << "adapt: Time for project soln onto new mesh                : "
          << TimingHelpers::timer() - t_start << " sec " << std::endl;
        //##################################################################
      }

      //###################################
      t_start = TimingHelpers::timer();
      //###################################

      // this->output("pre_proj",5);
      // new_mesh_pt->output("post_proj.dat",5);

      // Flush the old mesh
      unsigned nnod = nnode();
      for (unsigned j = nnod; j > 0; j--)
      {
        delete Node_pt[j - 1];
        Node_pt[j - 1] = 0;
      }
      unsigned nel = nelement();
      for (unsigned e = nel; e > 0; e--)
      {
        delete Element_pt[e - 1];
        Element_pt[e - 1] = 0;
      }

      // Now copy back to current mesh
      //------------------------------
      nnod = new_mesh_pt->nnode();
      Node_pt.resize(nnod);
      nel = new_mesh_pt->nelement();
      Element_pt.resize(nel);
      for (unsigned j = 0; j < nnod; j++)
      {
        Node_pt[j] = new_mesh_pt->node_pt(j);
      }
      for (unsigned e = 0; e < nel; e++)
      {
        Element_pt[e] = new_mesh_pt->element_pt(e);
      }

      // Copy the boundary schemes
      unsigned nbound = new_mesh_pt->nboundary();
      Boundary_element_pt.resize(nbound);
      Face_index_at_boundary.resize(nbound);
      Boundary_node_pt.resize(nbound);
      for (unsigned b = 0; b < nbound; b++)
      {
        unsigned nel = new_mesh_pt->nboundary_element(b);
        Boundary_element_pt[b].resize(nel);
        Face_index_at_boundary[b].resize(nel);
        for (unsigned e = 0; e < nel; e++)
        {
          Boundary_element_pt[b][e] = new_mesh_pt->boundary_element_pt(b, e);
          Face_index_at_boundary[b][e] =
            new_mesh_pt->face_index_at_boundary(b, e);
        }
        unsigned nnod = new_mesh_pt->nboundary_node(b);
        Boundary_node_pt[b].resize(nnod);
        for (unsigned j = 0; j < nnod; j++)
        {
          Boundary_node_pt[b][j] = new_mesh_pt->boundary_node_pt(b, j);
        }
      }

      // Also copy over the new boundary and region information
      unsigned n_region = new_mesh_pt->nregion();

      // Only bother if we have regions
      if (n_region > 1)
      {
        // Deal with the region information first
        this->Region_element_pt.resize(n_region);
        this->Region_attribute.resize(n_region);
        for (unsigned i = 0; i < n_region; i++)
        {
          // Copy across region attributes (region ids!)
          this->Region_attribute[i] = new_mesh_pt->region_attribute(i);

          // Find the number of elements in the region
          unsigned r = this->Region_attribute[i];
          unsigned n_region_element = new_mesh_pt->nregion_element(r);
          this->Region_element_pt[i].resize(n_region_element);
          for (unsigned e = 0; e < n_region_element; e++)
          {
            this->Region_element_pt[i][e] =
              new_mesh_pt->region_element_pt(r, e);
          }
        }

        // Now the boundary region information
        this->Boundary_region_element_pt.resize(nbound);
        this->Face_index_region_at_boundary.resize(nbound);

        // Now loop over the boundaries
        for (unsigned b = 0; b < nbound; ++b)
        {
          // Loop over the regions
          for (unsigned i = 0; i < n_region; ++i)
          {
            unsigned r = this->Region_attribute[i];

            unsigned n_boundary_el_in_region =
              new_mesh_pt->nboundary_element_in_region(b, r);
            if (n_boundary_el_in_region > 0)
            {
              // Allocate storage in the map
              this->Boundary_region_element_pt[b][r].resize(
                n_boundary_el_in_region);
              this->Face_index_region_at_boundary[b][r].resize(
                n_boundary_el_in_region);

              // Copy over the information
              for (unsigned e = 0; e < n_boundary_el_in_region; ++e)
              {
                this->Boundary_region_element_pt[b][r][e] =
                  new_mesh_pt->boundary_element_in_region_pt(b, r, e);
                this->Face_index_region_at_boundary[b][r][e] =
                  new_mesh_pt->face_index_at_boundary_in_region(b, r, e);
              }
            }
          }
        } // End of loop over boundaries

      } // End of case when more than one region

      // Copy TriangulateIO representation
      this->set_deep_copy_tetgenio_pt(new_mesh_pt->tetgenio_pt());

      // Flush the mesh
      new_mesh_pt->flush_element_and_node_storage();

      // Delete the mesh and the problem
      delete new_mesh_pt;


      //##################################################################
      oomph_info
        << "adapt: Time for moving nodes etc. to actual mesh          : "
        << TimingHelpers::timer() - t_start << " sec " << std::endl;
      //##################################################################

      // Solid mesh?
      if (solid_mesh_pt != 0)
      {
        // Warning
        std::stringstream error_message;
        error_message
          << "Lagrangian coordinates are currently not projected but are\n"
          << "are re-set during adaptation. This is not appropriate for\n"
          << "real solid mechanics problems!\n";
        OomphLibWarning(error_message.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);

        // Reset Lagrangian coordinates
        dynamic_cast<SolidMesh*>(this)->set_lagrangian_nodal_coordinates();
      }

      double max_area;
      double min_area;
      this->max_and_min_element_size(max_area, min_area);
      oomph_info << "Max/min element size in adapted mesh: " << max_area << " "
                 << min_area << std::endl;
    }
    else
    {
      oomph_info << "Not enough benefit in adaptation.\n";
      Nrefined = 0;
      Nunrefined = 0;
    }
  }

} // namespace oomph

#endif
