//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC// Copyright (C) 2006-2021 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================

#ifndef OOMPH_REFINEABLE_TETGEN_MESH_TEMPLATE_CC
#define OOMPH_REFINEABLE_TETGEN_MESH_TEMPLATE_CC

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

// OOMPH-LIB Headers
#include "refineable_tetgen_mesh.template.h"
#include "../generic/sample_point_parameters.h"
#include "../generic/mesh_as_geometric_object.h"
#include "../generic/projection.h"
#include "../generic/face_element_as_geometric_object.h"

namespace oomph
{

   /// \short Helper function that updates the input faceted surface
   /// by using the flattened elements from FaceMesh(es) that are
   /// constructed for the boundaries associated with the segments of the
   /// polygon.
 template <class ELEMENT>
 void RefineableTetgenMesh<ELEMENT>::update_faceted_surface_using_face_mesh(
  TetMeshFacetedSurface* &faceted_surface_pt)
 {
  //The easiest thing to do is simply to update the
  //positions of the key control nodes, leaving the connectivity alone,
  //but that doesn't allow for any surface remeshing
  
  ///List of vertex nodes
  std::list<Node*> new_vertex_nodes;
  //List of facets and boundary ids
  std::list<std::pair<Vector<unsigned>, unsigned>  > new_facet_list;
  
  //Loop over the number of old facets
  unsigned n_old_facet = faceted_surface_pt->nfacet();
  for(unsigned f=0;f<n_old_facet;f++)
   {
    //Get the boundary id of the facet. Need to subtract one, 
    //which is confusing now I think about it.
    //ALH: Should fix this.
    unsigned bound = faceted_surface_pt->one_based_facet_boundary_id(f) -1;
    
    // Create a face mesh adjacent to the fluid mesh's bound-th boundary. 
    // The face mesh consists of FaceElements that may also be 
    // interpreted as GeomObjects
    Mesh* face_mesh_pt = new Mesh;
    this->template build_face_mesh
     <ELEMENT,FaceElementAsGeomObject>(bound, face_mesh_pt);
    
    // Loop over these new face elements and tell them the boundary number
    // from the bulk fluid mesh -- this is required to they can
    // get access to the boundary coordinates!
    unsigned n_face_element = face_mesh_pt->nelement();
    for(unsigned e=0;e<n_face_element;e++)
     {
      //Cast the element pointer to the correct thing!
      FaceElementAsGeomObject<ELEMENT>* el_pt=
       dynamic_cast<FaceElementAsGeomObject<ELEMENT>*>
       (face_mesh_pt->element_pt(e));
      
      // Set bulk boundary number
      el_pt->set_boundary_number_in_bulk_mesh(bound);
     }
    
    //In order to set up the new faceted representation
    //Need to know the positions of the corner nodes
    //and the connectivity
    
    //Storage for the connectivity information
    Vector<unsigned> new_local_facet(3);
    
    //Now we have the face mesh loop over the face elements and 
    //print out the end points
    for(unsigned e=0;e<n_face_element;++e)
     {
      //Cache pointer to the element
      FiniteElement const *elem_pt = face_mesh_pt->finite_element_pt(e);
      
      //Just use the three primary (corner) nodes to define the facet
      unsigned n_vertex_node = 3;
      for(unsigned n=0;n<n_vertex_node;n++)
       {
        //Cache the pointer to the node
        Node* const nod_pt = elem_pt->node_pt(n);
        //If the vertex node is in the list return the number
        unsigned counter=0; bool found_it=false;
        for(std::list<Node*>::iterator it = new_vertex_nodes.begin();
            it!=new_vertex_nodes.end();++it,++counter)
         {
          //If we have found the node then store it
          if(*it==nod_pt) 
           {
            new_local_facet[n] = counter; 
            found_it=true; 
            break;
           }
         }
        
        //If we haven't found it
        //then add the node to the list and fill in the counter
        if(!found_it)
         {
          new_vertex_nodes.push_back(nod_pt);
          //We know where it is
          new_local_facet[n] = counter;
         }
       }
      
      //Add the new facet connectivity to the list
      new_facet_list.push_back(std::make_pair(new_local_facet,bound+1));
     }
   } //End of loop over old facets
  
  
     //Probably want the surface mesh in a better data structure so
     //that we can perform refinement or coarsening on it
     //i.e. want neighbours, edge flips all that fun stuff
     //That will go here!

  //Now we need to put the information into the appropriate data structures
  //for the Surface
  
  //Now sort out the facet nodes
  unsigned n_facet_vertex = new_vertex_nodes.size();
  //Vector<Vector<double> > facet_point(n_facet_vertex);
  Vector<Node*> facet_nodes_pt(n_facet_vertex);
  unsigned count=0;
  for(std::list<Node*>::iterator it=new_vertex_nodes.begin();
      it!=new_vertex_nodes.end();++it)
   {
    facet_nodes_pt[count] = *it;
    //facet_point[count].resize(3);
    //   for(unsigned i=0;i<3;i++)
    //    {
    //     facet_point[count][i] = (*it)->x(i);
    //    }
       ++count;
   }
  
  //And also the facets
  unsigned n_facet = new_facet_list.size();
  Vector<Vector<unsigned> > new_facet(n_facet);
  Vector<unsigned> new_facet_boundary_id(n_facet);
  count=0;
  for(std::list<std::pair<Vector<unsigned>, unsigned> >::iterator 
       it=new_facet_list.begin();it!=new_facet_list.end();++it)
   {
    new_facet[count] = (*it).first;
    new_facet_boundary_id[count] = (*it).second;
    ++count;
   }
  
  for(unsigned f=0;f<n_facet;f++)
   {
    for(unsigned i=0;i<3;i++)
     {
      oomph_info << new_facet[f][i] << " " ;
     }
    oomph_info << " : ";
    oomph_info << new_facet_boundary_id[f] << "\n";
   }
  
  //Now just create the new boundary
  delete faceted_surface_pt; 
  faceted_surface_pt = new TetMeshFacetedClosedSurfaceForRemesh(
   facet_nodes_pt,new_facet,new_facet_boundary_id);

  //Also need to setup the reverse look-up scheme again
  this->setup_reverse_lookup_schemes_for_faceted_surface(
   faceted_surface_pt);
  
  //Take average to get a new hole position (Won't always work)
  Vector<double> inner_point(3,0.0);
  for(unsigned n=0;n<n_facet_vertex;n++)
   {
    for(unsigned i=0;i<3;i++)
     {
      inner_point[i] += facet_nodes_pt[n]->x(i);
     }
   }
  
  for(unsigned i=0;i<3;i++) {inner_point[i] /= n_facet_vertex;}
  
     //Now set the hole if required
  dynamic_cast<TetMeshFacetedClosedSurface*>(faceted_surface_pt)->set_hole_for_tetgen(inner_point);

    }


   /// \short Generate a new faceted representation of the inner hole
   /// boundaries
 template <class ELEMENT>
void RefineableTetgenMesh<ELEMENT>::surface_remesh_for_inner_hole_boundaries()
    {
     //Loop over the number of internal boundarys
     unsigned n_hole = this->Internal_surface_pt.size();
     for(unsigned ihole=0;ihole<n_hole;ihole++)
      {
       //Now can the surface update its own representation goes in here
       
       //If not we have to generate it from the new mesh
       {
        //Update the faceted surface associated with the ihole-th hole
        this->update_faceted_surface_using_face_mesh(
         this->Internal_surface_pt[ihole]);
       }

      }
    }

  /// \short Snap the boundary nodes onto any curvilinear boundaries
 template<class ELEMENT>
 void RefineableTetgenMesh<ELEMENT>::snap_nodes_onto_boundary(
  RefineableTetgenMesh<ELEMENT>* &new_mesh_pt,
  const unsigned &b)
 {
  // Quick return
  if (!Boundary_coordinate_exists[b])
   {
    oomph_info << "Not snapping nodes on boundary " << b 
               << " because no boundary coordinate has been set up.\n";
    return;
   }
  
  //Firstly we set the boundary coordinates of the new nodes
  //In case the mapping between the geometric object's intrinsic coordiante
  //and the arc-length coordinate is nonlinear. 
  //This is only an approximation, 
  //but it will ensure that the nodes that were input to triangle will
  //retain exactly the same boundary coordinates and 
  //then linear interpolation
  //is used between those values for any newly created nodes.
  
  
  // Create a face mesh adjacent to the fluid mesh's b-th boundary. 
  // The face mesh consists of FaceElements that may also be 
  // interpreted as GeomObjects
  Mesh* face_mesh_pt = new Mesh;
  this->template build_face_mesh
   <ELEMENT,FaceElementAsGeomObject>(b, face_mesh_pt);
  
  // Loop over these new face elements and tell them the boundary number
  // from the bulk fluid mesh -- this is required to they can
  // get access to the boundary coordinates!
  unsigned n_face_element = face_mesh_pt->nelement();
  for(unsigned e=0;e<n_face_element;e++)
   {
    //Cast the element pointer to the correct thing!
    FaceElementAsGeomObject<ELEMENT>* el_pt=
     dynamic_cast<FaceElementAsGeomObject<ELEMENT>*>
     (face_mesh_pt->element_pt(e));
    
    // Set bulk boundary number
    el_pt->set_boundary_number_in_bulk_mesh(b);
   }   


  //Compare face meshes
  {
  Mesh* new_face_mesh_pt = new Mesh;
  new_mesh_pt->template build_face_mesh
   <ELEMENT,FaceElementAsGeomObject>(b, new_face_mesh_pt);

  std::ostringstream filestring;
  filestring << "old_mesh_boundary" << b << ".dat";
  face_mesh_pt->output(filestring.str().c_str());
  filestring.clear();
  filestring << "new_mesh_boundary" << b << ".dat";
  new_face_mesh_pt->output(filestring.str().c_str());

  Vector<double> b_coo(2);
  std::cout << "OLD---\n";
  //Now let's look at the boundary coordinates
  unsigned n_tmp_node = this->nboundary_node(b);
  for(unsigned n=0;n<n_tmp_node;++n)
   {
    Node* const nod_pt = this->boundary_node_pt(b,n);
    nod_pt->get_coordinates_on_boundary(b,b_coo);
    std::cout << nod_pt->x(0) << " "
              << nod_pt->x(1) << " "
              << nod_pt->x(2) << " "
              << b_coo[0] << " " << b_coo[1] << "\n";
   }

  std::cout << "NEW-----------\n";
  //Now let's look at the boundary coordinates
  n_tmp_node = new_mesh_pt->nboundary_node(b);
  for(unsigned n=0;n<n_tmp_node;++n)
   {
    Node* const nod_pt = new_mesh_pt->boundary_node_pt(b,n);
    nod_pt->get_coordinates_on_boundary(b,b_coo);
    std::cout << nod_pt->x(0) << " "
              << nod_pt->x(1) << " "
              << nod_pt->x(2) << " "
              << b_coo[0] << " " << b_coo[1] << "\n";
   }

  
  }
  
  
  //Now make the mesh as geometric object
  MeshAsGeomObject* mesh_geom_obj_pt = new MeshAsGeomObject(face_mesh_pt);
  
  //Now assign the new nodes positions based on the old meshes
  //potentially curvilinear boundary (its geom object incarnation)
  Vector<double> new_x(3);
  Vector<double> b_coord(2);
  unsigned n_new_boundary_node = new_mesh_pt->nboundary_node(b);
  for(unsigned n=0;n<n_new_boundary_node;n++)
   {
    //Get the boundary coordinate of all new nodes
    Node* const nod_pt = new_mesh_pt->boundary_node_pt(b,n);
    nod_pt->get_coordinates_on_boundary(b,b_coord);
    //Let's find boundary coordinates of the new node
    mesh_geom_obj_pt->position(b_coord,new_x);
    //Now snap to the boundary
    for(unsigned i=0;i<3;i++)
     {
      nod_pt->x(i) = new_x[i];
     }
   }
  
  
  //Delete the allocated memory for the geometric object and face mesh
  delete mesh_geom_obj_pt;
  face_mesh_pt->flush_element_and_node_storage();
  delete face_mesh_pt;
  
  //Loop over the elements adjacent to the boundary
  unsigned n_element = new_mesh_pt->nboundary_element(b);
  if(n_element > 0)
   {
    //Make a dummy simplex element
    TElement<3,2> dummy_four_node_element;
    //Make a dummy quadratic element
    TElement<3,3> dummy_ten_node_element;
    Vector<double> s(3);
    Vector<double> x_new(3);
    for(unsigned n=0;n<4;n++) {dummy_four_node_element.construct_node(n);}
    for(unsigned n=0;n<10;n++) {dummy_ten_node_element.construct_node(n);}
    for(unsigned e=0;e<n_element;e++)
     {
      //Cache the element pointer
      ELEMENT* elem_pt = dynamic_cast<ELEMENT*>(
       new_mesh_pt->boundary_element_pt(b,e));
      
      //Find the number of nodes
      const unsigned n_node = elem_pt->nnode();
      //Only do something if not simplex element
      if(n_node > 4)
       {
        //Copy the nodes into the dummy
        for(unsigned n=0;n<4;n++)
         {
          for(unsigned i=0;i<3;i++)
           {
            dummy_four_node_element.node_pt(n)->x(i) = 
             elem_pt->node_pt(n)->x(i);
           }
         }
        
        //Now sort out the mid-side nodes
        for(unsigned n=4;n<10;n++)
         {
          //If it's not on a boundary then reset to be interpolated
          //from the simplex
          if(!elem_pt->node_pt(n)->is_on_boundary())
           {
            elem_pt->local_coordinate_of_node(n,s);
            dummy_four_node_element.interpolated_x(s,x_new);
            for(unsigned i=0;i<3;i++) {elem_pt->node_pt(n)->x(i) = x_new[i];}
           }
         }
       }
      
      //If we have more than 10 nodes interpolate from the quadratic shape
      if(n_node > 10)
       {
        //Copy the nodes into the dummy
        for(unsigned n=0;n<10;n++)
         {
          for(unsigned i=0;i<3;i++)
           {
            dummy_ten_node_element.node_pt(n)->x(i) = 
             elem_pt->node_pt(n)->x(i);
           }
         }
        
        //Now sort out the mid-face and central nodes
        for(unsigned n=10;n<n_node;n++)
         {
          //If it's not on a boundary then reset to be interpolated
          //from the simplex
          if(!elem_pt->node_pt(n)->is_on_boundary())
           {
            elem_pt->local_coordinate_of_node(n,s);
            dummy_ten_node_element.interpolated_x(s,x_new);
            for(unsigned i=0;i<3;i++) {elem_pt->node_pt(n)->x(i) = x_new[i];}
           }
         }
       }
     }
   } //End of fix up of elements
 }




 
 
//======================================================================
/// Adapt problem based on specified elemental error estimates
//======================================================================
template <class ELEMENT>
void RefineableTetgenMesh<ELEMENT>::adapt(const Vector<double>& elem_error)
 {    


  double t_start=0.0;
  //###################################
  t_start=TimingHelpers::timer();
  //###################################

  // Get refinement targets
  Vector<double> target_size(elem_error.size());
  double max_edge_ratio=this->compute_volume_target(elem_error,
                                                    target_size);
  // Get maximum target volume
  unsigned n=target_size.size();
  double max_size=0.0;
  double min_size=DBL_MAX;
  for (unsigned e=0;e<n;e++)
   {
    if (target_size[e]>max_size) max_size=target_size[e];
    if (target_size[e]<min_size) min_size=target_size[e];
   }
  
  oomph_info << "Maximum target size: " << max_size << std::endl;
  oomph_info << "Minimum target size: " << min_size << std::endl;
  oomph_info << "Number of elements to be refined " 
             << this->Nrefined << std::endl;
  oomph_info << "Number of elements to be unrefined "
             << this->Nunrefined << std::endl;
  oomph_info << "Max edge ratio "<< max_edge_ratio << std::endl;

  double orig_max_size, orig_min_size;
  this->max_and_min_element_size(orig_max_size, orig_min_size);
  oomph_info << "Max/min element size in original mesh: " 
             << orig_max_size  << " "
             << orig_min_size << std::endl;    

  //##################################################################
  oomph_info << "adapt: Time for getting volume targets                      : "
             << TimingHelpers::timer()-t_start
             << " sec " << std::endl;
  //##################################################################

  //===============================================================
  // END: Compute target volumes
  //===============================================================

  // Check if boundaries need to be updated (regardless of
  // requirements of bulk error estimator) but don't do anything!
  bool check_only=true;
  bool outer_boundary_update_necessary= false;
  bool inner_boundary_update_necessary= false; //true; 
  
  // Should we bother to adapt?
  if ( (Nrefined > 0) || (Nunrefined > this->max_keep_unrefined()) ||
       (max_edge_ratio > this->max_permitted_edge_ratio()) )
   {

    if (! ( (Nrefined > 0) || (Nunrefined > max_keep_unrefined()) ) )
     {
      oomph_info 
       << "Mesh regeneration triggered by edge ratio criterion\n";
     }

    //Generate remesh of inner surface
    if(inner_boundary_update_necessary)
     {

      this->surface_remesh_for_inner_hole_boundaries();

      
      //If there is not a geometric object associated with the boundary
      //the reset the boundary coordinates so that the lengths are consistent
      //in the new mesh and the old mesh.
      const  unsigned n_boundary = this->nboundary();
      for(unsigned b=0;b<n_boundary;++b)
       {
        //if(this->boundary_geom_object_pt(b)==0)
        {
         this->template setup_boundary_coordinates<ELEMENT>(b);
        }
       }
     }

    
    //###################################
    t_start=TimingHelpers::timer();
    //###################################

    // Are we dealing with a solid mesh?
    SolidMesh* solid_mesh_pt=dynamic_cast<SolidMesh*>(this);
    
    // Build temporary uniform background mesh
    //----------------------------------------
    // with volume set by maximum required volume
    //---------------------------------------
    RefineableTetgenMesh<ELEMENT>* tmp_new_mesh_pt=0;
    if (solid_mesh_pt!=0)
     {
      /*throw OomphLibError("Solid RefineableTetgenMesh not done yet.",
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);*/
      tmp_new_mesh_pt=new RefineableSolidTetgenMesh<ELEMENT>
       (this->Outer_boundary_pt,
        this->Internal_surface_pt,
        max_size,
        this->Time_stepper_pt,
        this->Use_attributes,
	this->Corner_elements_must_be_split);
        }
    else
     {
      tmp_new_mesh_pt=new RefineableTetgenMesh<ELEMENT>
       (this->Outer_boundary_pt,
        this->Internal_surface_pt,
        max_size,
        this->Time_stepper_pt,
        this->Use_attributes,
	this->Corner_elements_must_be_split);
     }
    

    //##################################################################
    oomph_info << "adapt: Time for building temp mesh                        : "
               << TimingHelpers::timer()-t_start
               << " sec " << std::endl;
    //##################################################################

    // tmp_new_mesh_pt->output("pre_mesh_nodes_snapped_0.dat");
    
    // //Move the nodes on the new boundary onto the 
    // //old curvilinear boundary
    // //If the boundary is straight this will do precisely nothing
    // //but will be somewhat inefficient
    // {
    //  const unsigned n_boundary = this->nboundary();
    //  for(unsigned b=0;b<n_boundary;b++)
    //   {
    //    std::cout << "Snapping to boundary " << b << "\n";
    //    this->snap_nodes_onto_boundary(tmp_new_mesh_pt,b);
    //   }
    // }

    // tmp_new_mesh_pt->output("mesh_nodes_snapped_0.dat");
    

    // Get the tetgenio object associated with that mesh
    tetgenio *tmp_new_tetgenio_pt = tmp_new_mesh_pt->tetgenio_pt();
    RefineableTetgenMesh<ELEMENT>* new_mesh_pt=0;

     // If the mesh is a solid mesh then do the mapping based on the
     // Eulerian coordinates
     bool use_eulerian_coords=false;
     if (solid_mesh_pt!=0)
      {
       use_eulerian_coords=true;
      }

#ifdef OOMPH_HAS_CGAL

     // Make cgal-based bin
     CGALSamplePointContainerParameters cgal_params(this);
     if (use_eulerian_coords)
      {
       cgal_params.enable_use_eulerian_coordinates_during_setup();
      }
     MeshAsGeomObject* mesh_geom_obj_pt=new MeshAsGeomObject(&cgal_params);
     
#else

     std::ostringstream error_message;
     error_message << "Non-CGAL-based target size transfer not implemented.\n";
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);

     // Here's the relevant construction from the triangle mesh. Update...

     // // Make nonrefineable bin
     // NonRefineableBinArrayParameters params(this); 
     // if (use_eulerian_coords)
     //  {
     //   params.enable_use_eulerian_coordinates_during_setup();
     //  }
     // Vector<unsigned> bin_dim(2);
     // bin_dim[0]=Nbin_x_for_area_transfer;
     // bin_dim[1]=Nbin_y_for_area_transfer;
     // params.dimensions_of_bin_array()=bin_dim;
     // MeshAsGeomObject* mesh_geom_obj_pt=new MeshAsGeomObject(&params);
     
#endif

    // Set up a map from pointer to element to its number
    // in the mesh
    std::map<GeneralisedElement*,unsigned> element_number;
    unsigned nelem=this->nelement();
    for (unsigned e=0;e<nelem;e++)
     {
      element_number[this->element_pt(e)]=e;
     }

    // Now start iterating to refine mesh recursively
    //-----------------------------------------------
    bool done=false;
    unsigned iter=0;
    while (!done)
     {
      // Accept by default but overwrite if things go wrong below
      done=true;
      
      // Loop over elements in new (tmp) mesh and visit all
      // its integration points. Check where it's located in the bin
      // structure of the current mesh and pass the target size
      // to the new element
      unsigned nelem=tmp_new_mesh_pt->nelement();
      
      // Store the target sizes for elements in the temporary
      // mesh
      Vector<double> new_transferred_target_size(nelem,0.0);
      for (unsigned e=0;e<nelem;e++)
       { 
        ELEMENT* el_pt=dynamic_cast<ELEMENT*>(tmp_new_mesh_pt->element_pt(e));
        unsigned nint=el_pt->integral_pt()->nweight();
        for (unsigned ipt=0;ipt<nint;ipt++)
         {
          // Get the coordinate of current point
          Vector<double> s(3);
          for(unsigned i=0;i<3;i++)
           {
            s[i] = el_pt->integral_pt()->knot(ipt,i);
           }
          
          Vector<double> x(3);
          el_pt->interpolated_x(s,x);
          
#if OOMPH_HAS_CGAL
          
          // Try the five nearest sample points for Newton search
          // then just settle on the nearest one
          GeomObject* geom_obj_pt=0;
          unsigned max_sample_points=5;
          dynamic_cast<CGALSamplePointContainer*>(mesh_geom_obj_pt->
                                                  sample_point_container_pt())->
           limited_locate_zeta(x,max_sample_points,
                               geom_obj_pt,s);
#ifdef PARANOID
          if (geom_obj_pt==0)
           {
            std::stringstream error_message;
            error_message
             << "Limited locate zeta failed for zeta = [ "
             << x[0] << " " << x[1] << " " << x[2] << " ]. Makes no sense!\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
           }
          else
           {
#endif
            FiniteElement* fe_pt=dynamic_cast<FiniteElement*>(geom_obj_pt);
#ifdef PARANOID
            if (fe_pt==0)
             {
              std::stringstream error_message;
              error_message
               << "Cast to FE for GeomObject returned by limited locate zeta failed for zeta = [ "
               << x[0] << " " << x[1] << " " << x[2] << " ]. Makes no sense!\n";
              throw OomphLibError(error_message.str(),
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
             }
            else
             {
#endif
              // What's the target size of the element that contains this point
              double tg_size=target_size[element_number[fe_pt]];
              
              // Go for smallest target size over all integration 
              // points in new element
              // to force "one level" of refinement (the one-level-ness
              // is enforced below by limiting the actual reduction in
              // size
              if (new_transferred_target_size[e]!=0.0)
               {
                new_transferred_target_size[e]=
                 std::min(new_transferred_target_size[e], 
                          tg_size);
               }
              else
               {
                new_transferred_target_size[e]=tg_size;
               }
#ifdef PARANOID
             }
           }
#endif
       
// Non-CGAL   
#else
          
          std::ostringstream error_message;
          error_message 
           << "Non-CGAL-based target size transfer not implemented.\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);

          // Here's the relevant construction from the triangle mesh. Update...

          // // Find the bin that contains that point and its contents
          // int bin_number=0;
          // bin_array_pt->get_bin(x,bin_number);
          
          // // Did we find it?
          // if (bin_number<0)
          //  {
          //   // Not even within bin boundaries... odd
          //   std::stringstream error_message;
          //   error_message
          //    << "Very odd -- we're looking for a point[ "
          //    << x[0] << " " << x[1] << " " << x[2] << " ] that's not even \n"
          //    << "located within the bin boundaries.\n";
          //   throw OomphLibError(error_message.str(),
          //                       OOMPH_CURRENT_FUNCTION,
          //                       OOMPH_EXCEPTION_LOCATION);
          //  } // if (bin_number<0)
          // else
          //  {            
          //   // Go for smallest target size of any element in this bin
          //   // to force "one level" of refinement (the one-level-ness
          //   // is enforced below by limiting the actual reduction in
          //   // size
          //   if (new_transferred_target_size[e]!=0)
          //    {
          //      std::min(new_transferred_target_size[e],
          //               bin_min_target_size[bin_number]);
          //    }
          //   else
          //    {
          //     new_transferred_target_size[e]=bin_min_target_size[bin_number];
          //    }
            
          //  }
          
#endif
          
         } // for (ipt<nint)
        
       } // for (e<nelem)
      
      
      // do some output (keep it alive!)
      const bool output_target_sizes=false;
      if (output_target_sizes)
       {
        unsigned length=new_transferred_target_size.size();
        for (unsigned u = 0; u < length;u++)
         {
          oomph_info << "Element" << u << ",target size: "
                     << new_transferred_target_size[u] << std::endl;
         }
       }
      
      // Now copy into target size for temporary mesh but limit to
      // the equivalent of one sub-division per iteration
#ifdef OOMPH_HAS_MPI
      unsigned n_ele_need_refinement_iter = 0;
#endif 


      // Don't delete! Keep these around for debugging
      // ofstream tmp_mesh_file;
      // tmp_mesh_file.open("tmp_mesh_file.dat");
      // tmp_new_mesh_pt->output(tmp_mesh_file);
      // tmp_mesh_file.close();

      std::ofstream target_sizes_file; 
      char filename[100];
      sprintf(filename,"target_sizes%i.dat",iter);
      if (output_target_sizes)
       {
        target_sizes_file.open(filename);
       }

      const unsigned nel_new=tmp_new_mesh_pt->nelement();
      Vector<double> new_target_size(nel_new);   
      for (unsigned e=0;e<nel_new;e++)
       {
        // The finite element
        FiniteElement* f_ele_pt = tmp_new_mesh_pt->finite_element_pt(e);
        
        // Transferred target size
        const double new_size=new_transferred_target_size[e];
        if (new_size<=0.0)
         {
          std::ostringstream error_stream;
          error_stream << "This shouldn't happen! Element whose centroid is at "
                       <<  (f_ele_pt->node_pt(0)->x(0)+
                            f_ele_pt->node_pt(1)->x(0)+ 
                            f_ele_pt->node_pt(2)->x(0)+
                            f_ele_pt->node_pt(3)->x(0))/4.0 << " "
                       << (f_ele_pt->node_pt(0)->x(1)+
                           f_ele_pt->node_pt(1)->x(1)+
                           f_ele_pt->node_pt(2)->x(1)+
                           f_ele_pt->node_pt(3)->x(1))/4.0 << " "
                       << (f_ele_pt->node_pt(0)->x(2)+
                           f_ele_pt->node_pt(1)->x(2)+
                           f_ele_pt->node_pt(2)->x(2)+
                           f_ele_pt->node_pt(3)->x(2))/4.0 << " "
                       << " has no target size assigned\n";
          throw OomphLibError(error_stream.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
         }
        else
         {
          // Limit target size to the equivalent of uniform refinement
          // during this stage of the iteration
          new_target_size[e]=new_size;
          if (new_target_size[e]<f_ele_pt->size()/4.0)
           {
            new_target_size[e]=f_ele_pt->size()/4.0;

            // ALH: It seems that tetgen "enlarges" the volume constraint
            // so this criterion can never be met unless dividing by 1.2
            // as well. MH: Is this the reason why Andrew's version of
            // adaptation never converges? Took it out.
            // new_target_size[e] /= 1.2;

            // We'll need to give it another go later
            done=false;
           } 
          
          // Don't delete! Keep around for debugging
          if (output_target_sizes)
           {
            target_sizes_file << "ZONE N=4, E=1, F=FEPOINT, ET=TETRAHEDRON\n";
            for (unsigned j=0;j<4;j++)
             {
              target_sizes_file << f_ele_pt->node_pt(j)->x(0) << " "
                                << f_ele_pt->node_pt(j)->x(1) << " "
                                << f_ele_pt->node_pt(j)->x(2) << " "
                                << new_size << " " 
                                << new_target_size[e] 
                                << std::endl;
             }
            target_sizes_file << "1 2 3 4\n"; // connectivity
            
            // Keep around; just doc at centroid
            /* target_sizes_file  */
            /*  <<  (f_ele_pt->node_pt(0)->x(0)+ */
            /*       f_ele_pt->node_pt(1)->x(0)+ */
            /*       f_ele_pt->node_pt(2)->x(0)+ */
            /*       f_ele_pt->node_pt(3)->x(0))/4.0 << " " */
            /*  << (f_ele_pt->node_pt(0)->x(1)+ */
            /*      f_ele_pt->node_pt(1)->x(1)+ */
            /*      f_ele_pt->node_pt(2)->x(1)+ */
            /*      f_ele_pt->node_pt(3)->x(1))/4.0 << " " */
            /*  << (f_ele_pt->node_pt(0)->x(2)+ */
            /*      f_ele_pt->node_pt(1)->x(2)+ */
            /*      f_ele_pt->node_pt(2)->x(2)+ */
            /*      f_ele_pt->node_pt(3)->x(2))/4.0 << " " */
            /*  << new_size << " "  */
            /*  << new_target_size[e] << std::endl; */
           }
          
#ifdef OOMPH_HAS_MPI
          // Keep track of the elements that require (un)refinement
          n_ele_need_refinement_iter++;
#endif
          
         } // else if (new_size <= 0.0)
        
       } // for (e < nel_new)
            
      // Don't delete! Keep around for debugging
      if (output_target_sizes)
       {
        target_sizes_file.close();   
       }

      if (done) 
       {
        oomph_info 
         << "All size adjustments accommodated by max. permitted size"
         << " reduction during iter " << iter << "\n";
       }
      else
       {
        oomph_info 
         << "NOT all size adjustments accommodated by max. "
         << "permitted size reduction  during iter " << iter << "\n";
       }
      

      oomph_info << "\n\n\n==================================================\n"
                 << "==================================================\n"
                 << "==================================================\n"
                 << "==================================================\n"
                 << "\n\n\n";

      //##################################################################
      oomph_info << "adapt: Time for new_target_size[.]                      : "
                 << TimingHelpers::timer()-t_start
                 << " sec " << std::endl;
      //##################################################################


      // Now create the new mesh from TriangulateIO structure
      //-----------------------------------------------------
      // associated with uniform background mesh and the
      //------------------------------------------------
      // associated target element sizes.
      //---------------------------------
      
      //###################################
      t_start=TimingHelpers::timer();
      //###################################
      
      // Solid mesh?
      if (solid_mesh_pt!=0)
       {
        /*std::ostringstream error_message;
        error_message 
         << "RefineableSolidTetgenMesh not implemented yet.\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);*/
        new_mesh_pt=new RefineableSolidTetgenMesh<ELEMENT>
         (new_target_size,
          tmp_new_tetgenio_pt,
          this->Outer_boundary_pt,
          this->Internal_surface_pt,
          this->Time_stepper_pt,
          this->Use_attributes);
       }      
      // No solid mesh
      else
       { 
        new_mesh_pt=new RefineableTetgenMesh<ELEMENT>
         (new_target_size,
          tmp_new_tetgenio_pt,
          this->Outer_boundary_pt,
          this->Internal_surface_pt,
          this->Time_stepper_pt,
          this->Use_attributes);
       }    
      
      //##################################################################
      oomph_info << "adapt: Time for new_mesh_pt                            : "
                 << TimingHelpers::timer()-t_start
                 << " sec " << std::endl;
      //##################################################################
      
      
      // Not done: get ready for another iteration
      iter++;


      // Check if the new mesh actually differs from the old one
      // If not, we're done.
      if (!done)
       {
        unsigned nnod=tmp_new_mesh_pt->nnode();
        if (nnod==new_mesh_pt->nnode())
         {
          unsigned nel=tmp_new_mesh_pt->nelement();
          if (nel==new_mesh_pt->nelement())
           {
            bool nodes_identical=true;
            for (unsigned j=0;j<nnod;j++)
             {
              bool coords_identical=true;
              for (unsigned i=0;i<3;i++)
               {
                if (new_mesh_pt->node_pt(j)->x(i)!=
                    tmp_new_mesh_pt->node_pt(j)->x(i))
                 {
                  coords_identical=false;
                 }
               }
              if (!coords_identical)
               {
                nodes_identical=false;                    
                break;
               }
             }
            if (nodes_identical)
             {
              done=true;
             }
           }
         }
       }

      //Delete the temporary mesh
      delete tmp_new_mesh_pt;

      //Now transfer over the pointers
      if (!done)
       {
        tmp_new_mesh_pt=new_mesh_pt;
        tmp_new_tetgenio_pt=new_mesh_pt->tetgenio_pt();
       }
      
     } // end of iteration

    //Move the nodes on the new boundary onto the 
    //old curvilinear boundary
    //If the boundary is straight this will do precisely nothing
    //but will be somewhat inefficient
    /*{
     const unsigned n_boundary = this->nboundary();
     for(unsigned b=0;b<n_boundary;b++)
      {
       this->snap_nodes_onto_boundary(new_mesh_pt,b);
      }
      }*/

    
    // Check that the projection step is not disabled
    if (!Projection_is_disabled)
     {
      //###################################
      t_start=TimingHelpers::timer();
      //###################################
      
      // Project current solution onto new mesh
      //---------------------------------------
      ProjectionProblem<ELEMENT>* project_problem_pt=
       new ProjectionProblem<ELEMENT>;
      project_problem_pt->mesh_pt()=new_mesh_pt;
      project_problem_pt->project(this);
      delete project_problem_pt;

      //##################################################################
      oomph_info 
       << "adapt: Time for project soln onto new mesh                : "
       << TimingHelpers::timer()-t_start
       << " sec " << std::endl;
      //##################################################################
     }

    //###################################
    t_start=TimingHelpers::timer();
    //###################################
    
    //this->output("pre_proj",5);
    //new_mesh_pt->output("post_proj.dat",5);
    
    //Flush the old mesh 
    unsigned nnod=nnode();
    for(unsigned j=nnod;j>0;j--)  
     { 
      delete Node_pt[j-1];  
      Node_pt[j-1] = 0; 
     } 
    unsigned nel=nelement(); 
    for(unsigned e=nel;e>0;e--)  
     { 
      delete Element_pt[e-1];  
      Element_pt[e-1] = 0; 
     } 
    
    // Now copy back to current mesh
    //------------------------------
    nnod=new_mesh_pt->nnode();
    Node_pt.resize(nnod);
    nel=new_mesh_pt->nelement();
    Element_pt.resize(nel);  
    for(unsigned j=0;j<nnod;j++)
     { 
      Node_pt[j] = new_mesh_pt->node_pt(j);
     } 
    for(unsigned e=0;e<nel;e++)
     { 
      Element_pt[e] = new_mesh_pt->element_pt(e);
     } 
    
    //Copy the boundary schemes
    unsigned nbound=new_mesh_pt->nboundary();
    Boundary_element_pt.resize(nbound);
    Face_index_at_boundary.resize(nbound);
    Boundary_node_pt.resize(nbound);
    for (unsigned b=0;b<nbound;b++)
     {
      unsigned nel=new_mesh_pt->nboundary_element(b);
      Boundary_element_pt[b].resize(nel);
      Face_index_at_boundary[b].resize(nel);
      for (unsigned e=0;e<nel;e++)
       {
        Boundary_element_pt[b][e]=new_mesh_pt->boundary_element_pt(b,e);
        Face_index_at_boundary[b][e]=new_mesh_pt->face_index_at_boundary(b,e);
       }
      unsigned nnod=new_mesh_pt->nboundary_node(b);
      Boundary_node_pt[b].resize(nnod);
      for (unsigned j=0;j<nnod;j++)
       {
        Boundary_node_pt[b][j]=new_mesh_pt->boundary_node_pt(b,j);
       }
     }

    //Also copy over the new boundary and region information
    unsigned n_region = new_mesh_pt->nregion();

    //Only bother if we have regions
    if(n_region > 1)
     {
      //Deal with the region information first
      this->Region_element_pt.resize(n_region);
      this->Region_attribute.resize(n_region);
      for(unsigned i=0;i<n_region;i++)
       {
        // Copy across region attributes (region ids!)
        this->Region_attribute[i] = new_mesh_pt->region_attribute(i);

        //Find the number of elements in the region
        unsigned r=this->Region_attribute[i];
        unsigned n_region_element = new_mesh_pt->nregion_element(r);
        this->Region_element_pt[i].resize(n_region_element);
        for(unsigned e=0;e<n_region_element;e++)
         {
          this->Region_element_pt[i][e] = new_mesh_pt->region_element_pt(r,e);
         }
       }

      //Now the boundary region information
      this->Boundary_region_element_pt.resize(nbound);
      this->Face_index_region_at_boundary.resize(nbound);
      
      //Now loop over the boundaries
      for(unsigned b=0;b<nbound;++b)
       {
        //Loop over the regions
        for(unsigned i=0;i<n_region;++i)
         {        
          unsigned r=this->Region_attribute[i];

          unsigned n_boundary_el_in_region = 
           new_mesh_pt->nboundary_element_in_region(b,r);
          if(n_boundary_el_in_region > 0)
           {
            //Allocate storage in the map
            this->Boundary_region_element_pt[b][r].
             resize(n_boundary_el_in_region);
            this->Face_index_region_at_boundary[b][r].
             resize(n_boundary_el_in_region);

            //Copy over the information
            for(unsigned e=0;e<n_boundary_el_in_region;++e)
             {
              this->Boundary_region_element_pt[b][r][e]
               = new_mesh_pt->boundary_element_in_region_pt(b,r,e);
              this->Face_index_region_at_boundary[b][r][e] 
               = new_mesh_pt->face_index_at_boundary_in_region(b,r,e);
             }
           }
         }
       } //End of loop over boundaries

     } //End of case when more than one region
    
    // Copy TriangulateIO representation
    this->set_deep_copy_tetgenio_pt(new_mesh_pt->tetgenio_pt());
    
    // Flush the mesh
    new_mesh_pt->flush_element_and_node_storage();
    
    // Delete the mesh and the problem
    delete new_mesh_pt;


    //##################################################################
    oomph_info << "adapt: Time for moving nodes etc. to actual mesh          : "
               << TimingHelpers::timer()-t_start
               << " sec " << std::endl;
    //##################################################################

    // Solid mesh?
    if (solid_mesh_pt!=0)
     {
      // Warning
      std::stringstream error_message;
      error_message 
       << "Lagrangian coordinates are currently not projected but are\n"
       << "are re-set during adaptation. This is not appropriate for\n"
       << "real solid mechanics problems!\n";
      OomphLibWarning(error_message.str(),
                      OOMPH_CURRENT_FUNCTION,
                      OOMPH_EXCEPTION_LOCATION);
      
      // Reset Lagrangian coordinates
      dynamic_cast<SolidMesh*>(this)->set_lagrangian_nodal_coordinates();
     }
    
    double max_area;
    double min_area;
    this->max_and_min_element_size(max_area, min_area);
    oomph_info << "Max/min element size in adapted mesh: " 
               << max_area  << " "
               << min_area << std::endl;    
   }
  else
   {
    oomph_info << "Not enough benefit in adaptation.\n";
    Nrefined=0;
    Nunrefined=0;
   }
 }

}

#endif
