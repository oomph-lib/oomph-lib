//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC// Copyright (C) 2006-2021 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
#ifndef OOMPH_TRIANGLE_MESH_TEMPLATE_CC
#define OOMPH_TRIANGLE_MESH_TEMPLATE_CC

#include <iostream>

#include "triangle_mesh.template.h"
#include "../generic/map_matrix.h"
#include "../generic/multi_domain.h"
#include "../generic/projection.h"
#include "../generic/face_element_as_geometric_object.h"

namespace oomph
{

 //======================================================================
 /// Build with the help of the scaffold mesh coming
 /// from the triangle mesh generator Triangle.
 //======================================================================
 template<class ELEMENT>
  void TriangleMesh<ELEMENT>::build_from_scaffold(TimeStepper* time_stepper_pt,
						  const bool &use_attributes)
 {
  // Mesh can only be built with 2D Telements.
  MeshChecker::assert_geometric_element<TElementGeometricBase,ELEMENT>(2);
  
  // Create space for elements
  unsigned nelem = Tmp_mesh_pt->nelement();
  Element_pt.resize(nelem);
  
  // Create space for nodes
  unsigned nnode_scaffold = Tmp_mesh_pt->nnode();
  
  // Create a map storing the node_id of the mesh used to update the
  // node position in the update_triangulateio function
  std::map<Node*, unsigned> old_global_number;
  
  // Store the TriangulateIO node id
  for (unsigned inod = 0; inod < nnode_scaffold; inod++)
   {
    Node* old_node_pt = Tmp_mesh_pt->node_pt(inod);
    old_global_number[old_node_pt] = inod;
   }
  
  // Initialize the old node id vector
  Oomph_vertex_nodes_id.resize(nnode_scaffold);
  
  // Create space for nodes
  Node_pt.resize(nnode_scaffold, 0);
  
  // Set number of boundaries
  unsigned nbound = Tmp_mesh_pt->nboundary();
  
  // Resize the boundary information
  set_nboundary(nbound);
  Boundary_element_pt.resize(nbound);
  Face_index_at_boundary.resize(nbound);
  
  //If we have different regions, then resize the region
  //information
  if (use_attributes)
   {
    Boundary_region_element_pt.resize(nbound);
    Face_index_region_at_boundary.resize(nbound);
   }

  // Loop over elements in scaffold mesh, visit their nodes
  for (unsigned e = 0; e < nelem; e++)
   {
    Element_pt[e] = new ELEMENT;
   }
  
  //Number of nodes per element from the scaffold mesh
  unsigned nnod_el = Tmp_mesh_pt->finite_element_pt(0)->nnode();
  
  // Setup map to check the (pseudo-)global node number
  // Nodes whose number is zero haven't been copied across
  // into the mesh yet.
  std::map<Node*, unsigned> global_number;
  unsigned global_count = 0;
  
  // Map of Element attribute pairs
  std::map<double, Vector<FiniteElement*> > element_attribute_map;

  // If we're using attributes
  if (use_attributes)
  {  
   // If we're using attributes then we need attribute 0 which will
   // be associated with region 0
   element_attribute_map[0].resize(0);
  }
    
  // Loop over elements in scaffold mesh, visit their nodes
  for (unsigned e = 0; e < nelem; e++)
   {
    // Loop over all nodes in element
    for (unsigned j = 0; j < nnod_el; j++)
     {
      // Pointer to node in the scaffold mesh
      Node* scaffold_node_pt = Tmp_mesh_pt->finite_element_pt(e)->node_pt(j);

      // Get the (pseudo-)global node number in scaffold mesh
      // (It's zero [=default] if not visited this one yet)
      unsigned j_global = global_number[scaffold_node_pt];

      // Haven't done this one yet
      if (j_global == 0)
       {
        // Find and store the node_id in the old nodes map
        Oomph_vertex_nodes_id[global_count] =
         old_global_number[scaffold_node_pt];

        // Get pointer to set of mesh boundaries that this
        // scaffold node occupies; NULL if the node is not on any boundary
        std::set<unsigned>* boundaries_pt;
        scaffold_node_pt->get_boundaries_pt(boundaries_pt);

        //Storage for the new node
        Node* new_node_pt = 0;

        //Is it on boundaries
        if (boundaries_pt != 0)
         {
          //Create new boundary node
          new_node_pt=
           finite_element_pt(e)->construct_boundary_node(j,time_stepper_pt);

          // Add to boundaries
          for (std::set<unsigned>::iterator it = boundaries_pt->begin(); it
                != boundaries_pt->end(); ++it)
           {
            add_boundary_node(*it, new_node_pt);
           }
         }
        //Build normal node
        else
         {
          //Create new normal node
          new_node_pt = finite_element_pt(e)->construct_node(j,time_stepper_pt);
         }

        // Give it a number (not necessarily the global node
        // number in the scaffold mesh -- we just need something
        // to keep track...)
        global_count++;
        global_number[scaffold_node_pt] = global_count;

        // Copy new node, created using the NEW element's construct_node
        // function into global storage, using the same global
        // node number that we've just associated with the
        // corresponding node in the scaffold mesh
        Node_pt[global_count - 1] = new_node_pt;

        // Assign coordinates
        for (unsigned i = 0; i < finite_element_pt(e)->dim(); i++)
         {
          new_node_pt->x(i) = scaffold_node_pt->x(i);
         }
       }
      // This one has already been done: Copy accross
      else
       {
        finite_element_pt(e)->node_pt(j) = Node_pt[j_global - 1];
       }
     }

    // If we're using attributes
    if (use_attributes)
    {      
     element_attribute_map[Tmp_mesh_pt->element_attribute(e)].push_back(
      finite_element_pt(e));
    }
   }
  
  //Now let's construct lists
  //Find the number of attributes
  if (use_attributes)
   {
    unsigned n_attribute = element_attribute_map.size();

    //There are n_attribute different regions
    this->Region_attribute.resize(n_attribute);
    
    //Copy the vectors in the map over to our internal storage
    unsigned count = 0;
    for (std::map<double, Vector<FiniteElement*> >::iterator it =
          element_attribute_map.begin(); it!=element_attribute_map.end(); ++it)
     {
      this->Region_attribute[count] = it->first;
      Region_element_pt[static_cast<unsigned>(Region_attribute[count])] = 
       it->second;
      ++count;
     }
    
   }

  // At this point we've created all the elements and
  // created their vertex nodes. Now we need to create
  // the additional (midside and internal) nodes!

  unsigned boundary_id=0;

  // Get number of nodes along element edge and dimension of element (2)
  // from first element
  unsigned n_node_1d = finite_element_pt(0)->nnode_1d();
  unsigned dim = finite_element_pt(0)->dim();

  // Storage for the local coordinate of the new node
  Vector<double> s(dim);

  // Get number of nodes in the element from first element
  unsigned n_node = finite_element_pt(0)->nnode();

  //Storage for each global edge of the mesh
  unsigned n_global_edge = Tmp_mesh_pt->nglobal_edge();
  Vector < Vector<Node*> > nodes_on_global_edge(n_global_edge);

  // Loop over elements
  for (unsigned e = 0; e < nelem; e++)
   {
    //Cache pointers to the elements
    FiniteElement* const elem_pt = finite_element_pt(e);
    FiniteElement* const tmp_elem_pt = Tmp_mesh_pt->finite_element_pt(e);

    //The number of edge nodes is  3*(nnode_1d-1)
    unsigned n_edge_node = 3 * (n_node_1d - 1);

    //If there are any more nodes, these are internal and can be
    //constructed and added directly to the mesh
    for (unsigned n = n_edge_node; n < n_node; ++n)
     {
      // Create new node (it can never be a boundary node)
      Node* new_node_pt = elem_pt->construct_node(n, time_stepper_pt);

      // What are the node's local coordinates?
      elem_pt->local_coordinate_of_node(n, s);

      // Find the coordinates of the new node from the existing
      // and fully-functional element in the scaffold mesh
      for (unsigned i = 0; i < dim; i++)
       {
        new_node_pt->x(i) = tmp_elem_pt->interpolated_x(s, i);
       }

      //Add the node to the mesh's global look-up scheme
      Node_pt.push_back(new_node_pt);
     }

    //Now loop over the mid-side edge nodes
    //Start from node number 3
    unsigned n = 3;

    // Loop over edges
    for (unsigned j = 0; j < 3; j++)
     {
      //Find the boundary id of the edge
      boundary_id = Tmp_mesh_pt->edge_boundary(e, j);

      //Find the global edge index
      unsigned edge_index = Tmp_mesh_pt->edge_index(e, j);

      //If the nodes on the edge have not been allocated, construct them
      if (nodes_on_global_edge[edge_index].size() == 0)
       {
        //Loop over the nodes on the edge excluding the ends
        for (unsigned j2 = 0; j2 < n_node_1d - 2; ++j2)
         {
          //Storage for the new node
          Node* new_node_pt = 0;

          //If the edge is on a boundary, construct a boundary node
          if (boundary_id > 0)
           {
            new_node_pt = elem_pt->construct_boundary_node(n, time_stepper_pt);
            //Add it to the boundary
            this->add_boundary_node(boundary_id - 1, new_node_pt);
           }
          //Otherwise construct a normal node
          else
           {
            new_node_pt = elem_pt->construct_node(n, time_stepper_pt);
           }

          // What are the node's local coordinates?
          elem_pt->local_coordinate_of_node(n, s);

          // Find the coordinates of the new node from the existing
          // and fully-functional element in the scaffold mesh
          for (unsigned i = 0; i < dim; i++)
           {
            new_node_pt->x(i) = tmp_elem_pt->interpolated_x(s, i);
           }

          //Add to the global node list
          Node_pt.push_back(new_node_pt);

          //Add to the edge index
          nodes_on_global_edge[edge_index].push_back(new_node_pt);
          //Increment the node number
          ++n;
         }
       }
      //Otherwise just set the pointers
      //using the fact that the next time the edge is visited
      //the nodes must be arranged in the other order because all
      //triangles have the same orientation
      else
       {
        //Loop over the nodes on the edge excluding the ends
        for (unsigned j2 = 0; j2 < n_node_1d - 2; ++j2)
         {
          //Set the local node from the edge but indexed the other
          //way around
          elem_pt->node_pt(n) = nodes_on_global_edge[edge_index][n_node_1d - 3
                                                                 - j2];
          ++n;
         }
       }
       
      //Set the elements adjacent to the boundary from the
      //boundary id information
      if (boundary_id > 0)
       {
        Boundary_element_pt[boundary_id - 1].push_back(elem_pt);
        //Need to put a shift in here because of an inconsistent naming
        //convention between triangle and face elements
        Face_index_at_boundary[boundary_id - 1].push_back((j + 2) % 3);
       
        //If using regions set up the boundary information
        if (use_attributes)
         {
          unsigned tmp_region =
           static_cast<unsigned> (Tmp_mesh_pt->element_attribute(e));
          //Element adjacent to boundary
          Boundary_region_element_pt[boundary_id - 1]
           [tmp_region].push_back(elem_pt);
          //Need to put a shift in here because of an inconsistent naming
          //convention between triangle and face elements
          Face_index_region_at_boundary[boundary_id - 1]
           [tmp_region].push_back((j + 2) % 3);
         }
       }
       
     } //end of loop over edges
   } //end of loop over elements


  // Lookup scheme has now been setup
  Lookup_for_elements_next_boundary_is_setup = true;

 }

#ifdef OOMPH_HAS_MPI
 
 //======================================================================
 /// \short Identify the segments from the old mesh (original mesh)
 /// in the new mesh (this) and assign initial and final boundary
 /// coordinates for the segments that create the boundary
 //======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::
 identify_boundary_segments_and_assign_initial_zeta_values(
  const unsigned& b, TriangleMesh<ELEMENT>* original_mesh_pt)
 {
  // ------------------------------------------------------------------
  // First: Get the face elements associated with the current boundary
  // (nonhalo elements only)
  // ------------------------------------------------------------------  
  // Temporary storage for face elements
  Vector<FiniteElement*> face_el_pt;
  
  // Temporary storage for number of elements adjacent to the boundary
  unsigned nele = 0;
  
  // Temporary storage for elements adjacent to the boundary that have
  // a common edge (related with internal boundaries)
  unsigned n_repeated_ele = 0;
  
  const unsigned n_regions = this->nregion();
  
  // map to associate the face element to the bulk element, necessary
  // to attach halo face elements at both sides of each found segment
  std::map<FiniteElement*,FiniteElement*> face_to_bulk_element_pt;
  
  // Temporary storage for already done nodes
  Vector<std::pair<Node*, Node*> > done_nodes_pt;
  
  // If there is more than one region then only use boundary
  // coordinates from the bulk side (region 0)
  if (n_regions > 1)
   {
    for (unsigned rr = 0 ; rr < n_regions; rr++)
     {
      const unsigned region_id = 
       static_cast<unsigned>(this->Region_attribute[rr]);
      
      // Loop over all elements on boundaries in region i_r
      const unsigned nel_in_region = 
       this->nboundary_element_in_region(b, region_id);
      
      unsigned nel_repetead_in_region = 0;
      
      // Only bother to do anything else, if there are elements
      // associated with the boundary and the current region
      if (nel_in_region > 0)
       {
        // Flag that activates when a repeated face element is found,
        // possibly because we are dealing with an internal boundary
        bool repeated = false;
        
        // Loop over the bulk elements adjacent to boundary b
        for (unsigned e = 0; e < nel_in_region; e++)
         {
          // Get pointer to the bulk element that is adjacent to boundary b
          FiniteElement* bulk_elem_pt =
           this->boundary_element_in_region_pt(b, region_id, e);
          
#ifdef OOMPH_HAS_MPI
          // In a distributed mesh only work with nonhalo elements
          if (this->is_mesh_distributed() && bulk_elem_pt->is_halo())
           {
            // Increase the number of repeated elements
            n_repeated_ele++;
            // Go for the next element
            continue;
           }
#endif
          
          //Find the index of the face of element e along boundary b
          int face_index = 
           this->face_index_at_boundary_in_region(b,region_id,e);
          
          // Before adding the new element we need to be sure that
          // the edge that this element represent has not been
          // already added
          FiniteElement* tmp_ele_pt = 
           new DummyFaceElement<ELEMENT>(bulk_elem_pt, face_index);
          
          const unsigned n_nodes = tmp_ele_pt->nnode();
          
          std::pair<Node*, Node*> tmp_pair = 
           std::make_pair(tmp_ele_pt->node_pt(0),
                          tmp_ele_pt->node_pt(n_nodes - 1));
          
          std::pair<Node*, Node*> tmp_pair_inverse = 
           std::make_pair(tmp_ele_pt->node_pt(n_nodes - 1),
                          tmp_ele_pt->node_pt(0));
          
          // Search for repeated nodes
          const unsigned n_done_nodes = done_nodes_pt.size();
          for (unsigned l = 0; l < n_done_nodes; l++)
           {
            if (tmp_pair == done_nodes_pt[l] || 
                tmp_pair_inverse == done_nodes_pt[l])
             {
              nel_repetead_in_region++;
              repeated = true;
              break;
             }
           }
          
          // Create new face element
          if (!repeated)
           {
            // Add the pair of nodes (edge) to the node dones
            done_nodes_pt.push_back(tmp_pair);
            // Create the map to know if the element is halo
            face_el_pt.push_back(tmp_ele_pt);
            // Add the element to the face elements
            face_to_bulk_element_pt[tmp_ele_pt] = bulk_elem_pt;
           }
          else
           {
            // Clean up
            delete tmp_ele_pt;
            tmp_ele_pt = 0;
           }
          
          // Re-start
          repeated = false;
          
         } // for (e < nel_in_region)
        
        nele += nel_in_region;
        
        n_repeated_ele += nel_repetead_in_region;
        
       } // if (nel_in_region > 0)
     } // for (rr < n_regions)
   } // if (n_regions > 1)
  //Otherwise it's just the normal boundary functions
  else
   {
    // Loop over all elements on boundaries
    nele = this->nboundary_element(b);
    
    //Only bother to do anything else, if there are elements
    if (nele > 0)
     {
      // Flag that activates when a repeated face element is found,
      // possibly because we are dealing with an internal boundary
      bool repeated = false;
      
      // Loop over the bulk elements adjacent to boundary b
      for (unsigned e = 0; e < nele; e++)
       {
        // Get pointer to the bulk element that is adjacent to boundary b
        FiniteElement* bulk_elem_pt = this->boundary_element_pt(b, e);
        
#ifdef OOMPH_HAS_MPI
        // In a distributed mesh only work with nonhalo elements
        if (this->is_mesh_distributed() && bulk_elem_pt->is_halo())
         {
          // Increase the number of repeated elements
          n_repeated_ele++;
          // Go for the next element
          continue;
         }
#endif
        
        //Find the index of the face of element e along boundary b
        int face_index = this->face_index_at_boundary(b, e);
        
        // Before adding the new element we need to be sure that
        // the edge that this element represents has not been
        // already added (only applies for internal boundaries)
        FiniteElement* tmp_ele_pt = 
         new DummyFaceElement<ELEMENT>(bulk_elem_pt, face_index);
        
        const unsigned n_nodes = tmp_ele_pt->nnode();
        
        std::pair<Node*, Node*> tmp_pair = 
         std::make_pair(tmp_ele_pt->node_pt(0),
                        tmp_ele_pt->node_pt(n_nodes - 1));
        
        std::pair<Node*, Node*> tmp_pair_inverse = 
         std::make_pair(tmp_ele_pt->node_pt(n_nodes - 1),
                        tmp_ele_pt->node_pt(0));
        
        // Search for repeated nodes
        const unsigned n_done_nodes = done_nodes_pt.size();
        for (unsigned l = 0; l < n_done_nodes; l++)
         {
          if (tmp_pair == done_nodes_pt[l] || 
              tmp_pair_inverse == done_nodes_pt[l])
           {
            // Increase the number of repeated elements
            n_repeated_ele++;
            // Mark the element as repeated
            repeated = true;
            break;
           }
         }
        
        // Create new face element
        if (!repeated)
         {
          // Add the pair of nodes (edge) to the node dones
          done_nodes_pt.push_back(tmp_pair);
          // Add the element to the face elements
          face_el_pt.push_back(tmp_ele_pt);
          // Create the map to know if the element is halo
          face_to_bulk_element_pt[tmp_ele_pt] = bulk_elem_pt;
         }
        else
         {
          // Free the repeated bulk element!!
          delete tmp_ele_pt;
          tmp_ele_pt = 0;
         }
        
        // Re-start
        repeated = false;
        
       } // for (e < nel)
     } // if (nel > 0)
    
   } // else (n_regions > 1)
  
  // Do not consider the repeated elements
  nele-= n_repeated_ele;
  
#ifdef PARANOID
  if (nele!=face_el_pt.size())
   {
    std::ostringstream error_message;
    error_message
     << "The independent counting of face elements ("<<nele<<") for "
     << "boundary ("<<b<<") is different\n"
     << "from the real number of face elements in the container ("
     << face_el_pt.size() <<")\n";
    throw OomphLibError(error_message.str(),
                        "TriangleMesh::identify_boundary_segments_and_assign_initial_zeta_values()",
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
  // Continue even thought there are no elements, the processor needs
  // to participate in the communications
  
  // ----------------------------------------------------------------
  // Second: Sort the face elements, only consider nonhalo elements
  // ----------------------------------------------------------------
  
  // A flag vector to mark those face elements that are considered as
  // halo in the current processor
  std::vector<bool> is_halo_face_element(nele,false);
  
  // Count the total number of non halo face elements
  unsigned nnon_halo_face_elements = 0;
  
  // We will have halo face elements if the mesh is distributed
  for (unsigned ie = 0; ie < nele; ie++)
   {
    // Get the face element
    FiniteElement* face_ele_pt = face_el_pt[ie];
    // Get the bulk element
    FiniteElement* tmp_bulk_ele_pt = face_to_bulk_element_pt[face_ele_pt];
    // Check if the bulk element is halo
    if (!tmp_bulk_ele_pt->is_halo())
     {
      is_halo_face_element[ie] = false;
      nnon_halo_face_elements++;
     }
    else
     {
      // Mark the face element as halo
      is_halo_face_element[ie] = true;
     }
   } // for (ie < nele)
  
#ifdef PARANOID
  // Get the total number of halo face elements
  const unsigned nhalo_face_element = nele - nnon_halo_face_elements;
  if (nhalo_face_element > 0)
   {
    std::ostringstream error_message;
    error_message
     << "There should not be halo face elements since they were not "
     << "considered when computing the face elements\n\n"
     << "The number of found halo face elements is: " 
     << nhalo_face_element << "\n\n";
    throw OomphLibError(error_message.str(),
                        "TriangleMesh::identify_boundary_segments_and_assign_initial_zeta_values()",
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
  // The vector of list to store the "segments" that compound the
  // boundary (segments may appear only in a distributed mesh)
  Vector<std::list<FiniteElement*> > segment_sorted_ele_pt;
  
  // Number of already sorted face elements (only nonhalo elements for
  // a distributed mesh)
  unsigned nsorted_face_elements = 0;
  
  // Keep track of who's done (this apply to nonhalo only, remember we
  // are only working with nonhalo elements)
  std::map<FiniteElement*, bool> done_el;
  
  // Keep track of which element is inverted (in distributed mesh the
  // elements may be inverted with respect to the segment they belong)
  std::map<FiniteElement*, bool> is_inverted;
  
  // Iterate until all possible segments have been created
  while(nsorted_face_elements < nnon_halo_face_elements)
   {
    // The ordered list of face elements (in a distributed mesh a
    // collection of contiguous face elements define a segment)
    std::list<FiniteElement*> sorted_el_pt;
    sorted_el_pt.clear();
    
#ifdef PARANOID
    // Select an initial element for the segment
    bool found_initial_face_element = false;
#endif
    
    FiniteElement* ele_face_pt = 0;
    
    unsigned iface = 0;
    for (iface = 0; iface < nele; iface++)
     {
      if (!is_halo_face_element[iface])
       {
        ele_face_pt = face_el_pt[iface];
        // If not done then take it as initial face element
        if (!done_el[ele_face_pt])
         {
#ifdef PARANOID
          found_initial_face_element = true;
#endif
          nsorted_face_elements++;
          iface++; // The next element number
          sorted_el_pt.push_back(ele_face_pt);
          // Mark as done
          done_el[ele_face_pt] = true;
          break;
         }
       }
     } // for (iface < nele)
    
#ifdef PARANOID
    if (!found_initial_face_element)
     {
      std::ostringstream error_message;
      error_message
       <<"Could not find an initial face element for the current segment\n";
      throw OomphLibError(error_message.str(),
                          "TriangleMesh::identify_boundary_segments_and_assign_initial_zeta_values()",
                          OOMPH_EXCEPTION_LOCATION);
     }
#endif
    
    // Number of nodes
    const unsigned nnod = ele_face_pt->nnode();
    
    // Left and right most nodes (the left and right nodes of the
    // current face element)
    Node* left_node_pt = ele_face_pt->node_pt(0);
    Node* right_node_pt = ele_face_pt->node_pt(nnod - 1);
        
    // Continue iterating if a new face element has been added to the
    // list
    bool face_element_added = false;
    
    // While a new face element has been added to the set of sorted
    // face elements then re-iterate
    do
     {
      // Start from the next face element since we have already added
      // the previous one as the initial face element (any previous
      // face element had to be added on previous iterations)
      for (unsigned iiface = iface; iiface < nele; iiface++)
       {
        // Re-start flag
        face_element_added = false;
        
        // Get the candidate element
        ele_face_pt = face_el_pt[iiface];
        
        // Check that the candidate element has not been done and is
        // not a halo element
        if (!(done_el[ele_face_pt] || is_halo_face_element[iiface]))
         {
          // Get the left and right nodes of the current element
          Node* local_left_node_pt = ele_face_pt->node_pt(0);
          Node* local_right_node_pt = ele_face_pt->node_pt(nnod - 1);          
          // New element fits at the left of segment and is not inverted
          if (left_node_pt == local_right_node_pt)
           {
            left_node_pt = local_left_node_pt;
            sorted_el_pt.push_front(ele_face_pt);
            is_inverted[ele_face_pt] = false;
            face_element_added = true;
           }
          // New element fits at the left of segment and is inverted
          else if (left_node_pt == local_left_node_pt)
           {
            left_node_pt = local_right_node_pt;
            sorted_el_pt.push_front(ele_face_pt);
            is_inverted[ele_face_pt] = true;
            face_element_added = true;
           }
          // New element fits on the right of segment and is not inverted
          else if (right_node_pt == local_left_node_pt)
           {
            right_node_pt = local_right_node_pt;
            sorted_el_pt.push_back(ele_face_pt);
            is_inverted[ele_face_pt] = false;
            face_element_added = true;
           }
          // New element fits on the right of segment and is inverted
          else if (right_node_pt == local_right_node_pt)
           {
            right_node_pt = local_left_node_pt;
            sorted_el_pt.push_back(ele_face_pt);
            is_inverted[ele_face_pt] = true;
            face_element_added = true;
           }
          
          if (face_element_added)
           {
            done_el[ele_face_pt] = true;
            nsorted_face_elements++;
            break;
           }
             
         } // if (!(done_el[ele_face_pt] || is_halo_face_element[iiface]))
       } // for (iiface<nnon_halo_face_element)
     }while(face_element_added &&
            (nsorted_face_elements < nnon_halo_face_elements));
    
    // Store the created segment in the vector of segments
    segment_sorted_ele_pt.push_back(sorted_el_pt);
    
   } // while(nsorted_face_elements < nnon_halo_face_elements);
  
  // The number of segments in this processor
  const unsigned nsegments = segment_sorted_ele_pt.size();
  
  // ------------------------------------------------------------------
  // Third: We have the face elements sorted (nonhalo only), now
  // assign boundary coordinates to the nodes in the segments. This is
  // the LOCAL boundary coordinate which is required if the zeta
  // values need to be inverted
  // ------------------------------------------------------------------
  // Necessary in case boundaries with no geom object associated need
  // to be inverted the zeta values (It is necessary to compute the
  // arclength but also to store the nodes in a container (set))
  // ------------------------------------------------------------------
  
  // Vector of sets that stores the nodes of each segment based on a
  // lexicographically order starting from the bottom left node of
  // each segment
  Vector<std::set<Node*> > segment_all_nodes_pt;
  
  // The arclength of each segment in the current processor
  Vector<double> segment_arclength(nsegments);
  
  // The number of vertices of each segment
  Vector<unsigned> nvertices_per_segment(nsegments);
  
  // The initial zeta for the segment
  Vector<double> initial_zeta_segment(nsegments);
  
  // The final zeta for the segment
  Vector<double> final_zeta_segment(nsegments);
  
#ifdef PARANOID
  if (nnon_halo_face_elements > 0 && nsegments == 0)
   {
    std::ostringstream error_message;
    error_message
     << "The number of segments is zero, but the number of nonhalo\n"
     << "elements is: (" << nnon_halo_face_elements << ")\n";
    throw OomphLibError(error_message.str(),
                        "TriangleMesh::identify_boundary_segments_and_assign_initial_zeta_values()",
                        OOMPH_EXCEPTION_LOCATION);
   } // if (nnon_halo_face_elements > 0 && nsegments == 0)
#endif
  
  // Go through all the segments and compute the LOCAL boundary
  // coordinates
  for (unsigned is = 0; is < nsegments; is++)
   {
#ifdef PARANOID
    if (segment_sorted_ele_pt[is].size() == 0)
     {
      std::ostringstream error_message;
      error_message
       << "The (" << is << ")-th segment has no elements\n";
       throw OomphLibError(error_message.str(),
                           "TriangleMesh::identify_boundary_segments_and_assign_initial_zeta_values()",
                           OOMPH_EXCEPTION_LOCATION);
     } // if (segment_sorted_ele_pt[is].size() == 0)
#endif
    
    // Get access to the first element on the segment
    FiniteElement* first_ele_pt = segment_sorted_ele_pt[is].front();
    
    // Number of nodes
    const unsigned nnod = first_ele_pt->nnode();
    
    // Get the first node of the current segment
    Node *first_node_pt = first_ele_pt->node_pt(0);
    if (is_inverted[first_ele_pt])
     {
      first_node_pt = first_ele_pt->node_pt(nnod-1);
     }
    
    // Get access to the last element on the segment
    FiniteElement* last_ele_pt = segment_sorted_ele_pt[is].back();
    
    // Get the last node of the current segment
    Node *last_node_pt = last_ele_pt->node_pt(nnod-1);
    if (is_inverted[last_ele_pt])
     {
      last_node_pt = last_ele_pt->node_pt(0);
     }
    
    // Coordinates of left node
    double x_left = first_node_pt->x(0);
    double y_left = first_node_pt->x(1);
    
    // Initialise boundary coordinate (local boundary coordinate for
    // boundaries with more than one segment)
    Vector<double> zeta(1, 0.0);
    
    // If the boundary has an associated GeomObject then it is not
    // necessary to compute the arclength, only read the values from
    // the nodes at the edges
    if (this->boundary_geom_object_pt(b)!=0)
     {
      first_node_pt->get_coordinates_on_boundary(b, zeta);
      initial_zeta_segment[is] = zeta[0];
      last_node_pt->get_coordinates_on_boundary(b, zeta);
      final_zeta_segment[is] = zeta[0];
     }
    
    // Lexicographically bottom left node
    std::set<Node*> local_nodes_pt;
    local_nodes_pt.insert(first_node_pt);
    
    // Now loop over nodes in order
    for (std::list<FiniteElement*>::iterator it = 
          segment_sorted_ele_pt[is].begin();
         it != segment_sorted_ele_pt[is].end(); it++)
     {
      // Get element
      FiniteElement* el_pt = *it;
      
      // Start node and increment
      unsigned k_nod = 1;
      int nod_diff = 1;
      if (is_inverted[el_pt])
       {
        k_nod = nnod - 2;
        nod_diff = -1;
       }
      
      // Loop over nodes
      for (unsigned j = 1; j < nnod; j++)
       {
        Node* nod_pt = el_pt->node_pt(k_nod);
        k_nod += nod_diff;
        
        // Coordinates of right node
        double x_right = nod_pt->x(0);
        double y_right = nod_pt->x(1);
        
        // Increment boundary coordinate (the arclength)
        zeta[0] += sqrt(
         (x_right - x_left) * (x_right - x_left) + (y_right - y_left)
         * (y_right - y_left));
        
        // // When we have a GeomObject associated to the boundary we already
        // // know the zeta values for the nodes, there is no need to compute
        // // the arclength
        // if (this->boundary_geom_object_pt(b)==0)
        //  {
        //   // Set boundary coordinate
        //   nod_pt->set_coordinates_on_boundary(b, zeta);
        //  }
        
        // Increment reference coordinate
        x_left = x_right;
        y_left = y_right;
        
        // Get lexicographically bottom left node but only
        // use vertex nodes as candidates
        local_nodes_pt.insert(nod_pt);
       } // for (j < nnod)
      
     } // iterator over the elements in the segment
    
    // Store the arclength of the segment
    segment_arclength[is] = zeta[0];
    
    // Store the number of vertices in the segment
    nvertices_per_segment[is] = local_nodes_pt.size();
    
    // Add the nodes for the corresponding segment in the container
    segment_all_nodes_pt.push_back(local_nodes_pt);
    
   } // for (is < nsegments)
  
  // Get the number of sets for nodes
#ifdef PARANOID
  if (segment_all_nodes_pt.size() != nsegments)
   {
    std::ostringstream error_message;
    error_message 
     <<"The number of segments ("<<nsegments<<") and the number of "
     <<"sets of nodes ("<<segment_all_nodes_pt.size()<<") representing\n"
     <<"the\nsegments is different!!!\n\n";
    throw OomphLibError(
     error_message.str(),
     OOMPH_CURRENT_FUNCTION,
     OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
  // Store the initial arclength for each segment of boundary in the
  // current processor, initalise to zero in case we have a non
  // distributed boundary
  Vector<double> initial_segment_arclength(nsegments,0.0);
  
  // Associated the index of the current segment to the segment index
  // in the original mesh (input mesh)
  Vector<unsigned> current_segment_to_original_segment_index(nsegments);
    
  // Each segment needs to know whether it has to be inverted or not
  // Store whether a segment needs to be inverted or not
  Vector<unsigned> segment_inverted(nsegments);
  
  // -----------------------------------------------------------------
  // Fourth: Identify the segments with the ones in the original mesh
  // (has sense only in the adaptation process)
  // -----------------------------------------------------------------
  
  // Now check if there are segments associated to this boundary
  if (nsegments > 0)
   {
#ifdef PARANOID
    // Double check that the same number of coordinates (nsegments)
    // have been established for the boundary
    const unsigned nsegments_initial_coordinates = 
     original_mesh_pt->boundary_segment_initial_coordinate(b).size();
    
    const unsigned nsegments_final_coordinates = 
     original_mesh_pt->boundary_segment_final_coordinate(b).size();
    
    if (nsegments_initial_coordinates!=nsegments_final_coordinates)
     {
      std::stringstream error_message;
      error_message
       <<"The number of segments that present initial coordinates "
       <<nsegments_initial_coordinates<<" is different from "
       <<"the\nnumber of segments that present final coordinates "
       <<nsegments_final_coordinates<<"\n\n";
      throw OomphLibError(
       error_message.str(),
       OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
     } // if (nsegments_initial_coordinates!=nsegments_final_coordinates)
    
    // Also check that the number of segments found in the previous
    // mesh is the same as the number of segments found in this mesh
    if (nsegments_initial_coordinates != nsegments)
     {
      std::stringstream error_message;
      error_message
       <<"Working with boundary ("<< b << ").\n The number of initial and "
       <<"final coordinates ("
       <<nsegments_initial_coordinates<<") is different from\n"
       <<"the number of found segments ("<< nsegments <<").\n\n";
      throw OomphLibError(
       error_message.str(),
       OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
     } // if (nsegments_initial_coordinates != nsegments)
#endif
    
    // Create a backup for the data from the original mesh
    // Backup for the coordinates
    Vector<Vector<double> >original_mesh_segment_initial_coordinate(nsegments);
    Vector<Vector<double> >original_mesh_segment_final_coordinate(nsegments);
    // Backup for the zeta values
    Vector<double> original_mesh_segment_initial_zeta(nsegments);
    Vector<double> original_mesh_segment_final_zeta(nsegments);
    // Backup for the arclengths
    Vector<double> original_mesh_segment_initial_arclength(nsegments);
    Vector<double> original_mesh_segment_final_arclength(nsegments);
    // Do the backup
    for (unsigned is = 0; is < nsegments; is++)
     {
      original_mesh_segment_initial_coordinate[is].resize(2);
      original_mesh_segment_final_coordinate[is].resize(2);
      for (unsigned k = 0; k < 2; k++)
       {
        original_mesh_segment_initial_coordinate[is][k] = 
         original_mesh_pt->boundary_segment_initial_coordinate(b)[is][k];
        original_mesh_segment_final_coordinate[is][k] = 
         original_mesh_pt->boundary_segment_final_coordinate(b)[is][k];
       }
      // Check if the boudary has an associated GeomObject
      if (this->boundary_geom_object_pt(b)!=0)
       {
        original_mesh_segment_initial_zeta[is] = 
         original_mesh_pt->boundary_segment_initial_zeta(b)[is];
        original_mesh_segment_final_zeta[is] = 
         original_mesh_pt->boundary_segment_final_zeta(b)[is];
       }
      else
       {
        original_mesh_segment_initial_arclength[is] = 
         original_mesh_pt->boundary_segment_initial_arclength(b)[is];
        original_mesh_segment_final_arclength[is] = 
         original_mesh_pt->boundary_segment_final_arclength(b)[is];
       }
     } // for (is < nsegments)
    
    // Clear all the storage
    Boundary_segment_inverted[b].clear();
    Boundary_segment_initial_coordinate[b].clear();
    Boundary_segment_final_coordinate[b].clear();
    
    Boundary_segment_initial_zeta[b].clear();
    Boundary_segment_final_zeta[b].clear();
    
    Boundary_segment_initial_arclength[b].clear();
    Boundary_segment_final_arclength[b].clear();
    
    // Identify each segment in the processor with the ones created
    // by the original mesh
    // -----------------------------------------------------------------
    // Keep track of the already identified segments
    std::map<unsigned,bool> segment_done;
    for (unsigned is = 0; is < nsegments; is++)
     {
#ifdef PARANOID
      // Flag to know if the segment was identified
      bool found_original_segment = false;
#endif      
      
      // Get the initial and final coordinates of the current segment
      Vector<double> current_seg_initial_coord(2);
      Vector<double> current_seg_final_coord(2);
      
      // Get access to the initial element on the segment
      FiniteElement* current_seg_initial_ele_pt = 
       segment_sorted_ele_pt[is].front();
      
      // Number of nodes
      const unsigned nnod = current_seg_initial_ele_pt->nnode();
      
      // Get the first node of the current segment
      Node *current_seg_first_node_pt=
       current_seg_initial_ele_pt->node_pt(0);
      if (is_inverted[current_seg_initial_ele_pt])
       {
        current_seg_first_node_pt = 
         current_seg_initial_ele_pt->node_pt(nnod-1);
       }
      
      // Get access to the last element on the segment
      FiniteElement* current_seg_last_ele_pt = 
       segment_sorted_ele_pt[is].back();
      
      // Get the last node of the current segment
      Node *current_seg_last_node_pt = 
       current_seg_last_ele_pt->node_pt(nnod-1);
      if (is_inverted[current_seg_last_ele_pt])
       {
        current_seg_last_node_pt = 
         current_seg_last_ele_pt->node_pt(0);
       }
      
      // Get the coordinates for the first and last seg node
      for (unsigned i = 0; i < 2; i++)
       {
        current_seg_initial_coord[i]=current_seg_first_node_pt->x(i);
        current_seg_final_coord[i]=current_seg_last_node_pt->x(i);
       }
      
      // We have got the initial and final coordinates of the current
      // segment, compare those with the initial and final coordinates
      // of the original mesh segments to identify which segments is
      // which
      for (unsigned orig_s = 0; orig_s < nsegments; orig_s++)
       {
        if (!segment_done[orig_s])
         {
          // Get the coordinates to compare
          Vector<double> initial_coordinate = 
           original_mesh_segment_initial_coordinate[orig_s];
          Vector<double> final_coordinate = 
           original_mesh_segment_final_coordinate[orig_s];
          
          // Compute the distance initial(current)-initial(original)
          // coordinates
          double dist = 
           ((current_seg_initial_coord[0] - initial_coordinate[0])*
            (current_seg_initial_coord[0] - initial_coordinate[0]))
           +
           ((current_seg_initial_coord[1] - initial_coordinate[1])*
            (current_seg_initial_coord[1] - initial_coordinate[1]));
          dist = sqrt(dist);
          
          // If the initial node is the same, check for the last node
          if (dist < 
              ToleranceForVertexMismatchInPolygons::Tolerable_error)
           {
            // Compute the distance final(current)-final(original)
            // coordinates
            dist = 
             ((current_seg_final_coord[0] - final_coordinate[0])*
              (current_seg_final_coord[0] - final_coordinate[0]))
             +
             ((current_seg_final_coord[1] - final_coordinate[1])*
              (current_seg_final_coord[1] - final_coordinate[1]));
            dist = sqrt(dist);
            
            // The final node is the same, we have identified the
            // segments
            if (dist < 
                ToleranceForVertexMismatchInPolygons::Tolerable_error)
             {
              // Store the index that relates the previous index with the
              // current one
              current_segment_to_original_segment_index[is] = orig_s;
              
              // In this case the segment is not inverted
              Boundary_segment_inverted[b].push_back(0);
              
              // Copy the initial and final coordinates for each segment
              Boundary_segment_initial_coordinate[b].push_back(
               initial_coordinate);
              Boundary_segment_final_coordinate[b].push_back(
               final_coordinate);
              
              // Check if the boundary has an associated GeomObject
              if (this->boundary_geom_object_pt(b)!=0)
               {
                // Copy the initial zeta value for the segment
                Boundary_segment_initial_zeta[b].push_back(
                 original_mesh_segment_initial_zeta[orig_s]);
                Boundary_segment_final_zeta[b].push_back(
                 original_mesh_segment_final_zeta[orig_s]);
               }
              else
               {
                // Copy the initial and final arclength for each
                // segment
                Boundary_segment_initial_arclength[b].push_back(
                 original_mesh_segment_initial_arclength[orig_s]);
                Boundary_segment_final_arclength[b].push_back(
                 original_mesh_segment_final_arclength[orig_s]);
               }
              // Mark the segment as done
              segment_done[orig_s] = true;
#ifdef PARANOID
              found_original_segment = true;
#endif
              break;
             } // The final(current) node matched with the
               // final(original) node
           } // The initial(current) node matched with the
             // initial(original) node
          else
           {
            // Check the inverted case Compute the distance
            // initial(current)-final(original) coordinates
            double dist_inv = 
             ((current_seg_initial_coord[0] - final_coordinate[0])*
              (current_seg_initial_coord[0] - final_coordinate[0]))
             +
             ((current_seg_initial_coord[1] - final_coordinate[1])*
              (current_seg_initial_coord[1] - final_coordinate[1]));
            dist_inv = sqrt(dist_inv);
            
            // If the initial node is the same as the final node of
            // the segment, check for the last node
            if (dist_inv < 
                ToleranceForVertexMismatchInPolygons::Tolerable_error)
             {
              // Compute the distance final(current)-initial(original)
              // coordinates
              dist_inv = 
               ((current_seg_final_coord[0] - initial_coordinate[0])*
                (current_seg_final_coord[0] - initial_coordinate[0]))
               +
               ((current_seg_final_coord[1] - initial_coordinate[1])*
                (current_seg_final_coord[1] - initial_coordinate[1]));
              dist_inv = sqrt(dist_inv);
              
              // The final node is the same as the initial node, we
              // have identified the segments
              if (dist_inv < 
                  ToleranceForVertexMismatchInPolygons::Tolerable_error)
               {
                // Store the index that related the previous index with the
                // current one
                current_segment_to_original_segment_index[is] = orig_s;
                
                // In this case the segment is inverted
                Boundary_segment_inverted[b].push_back(1);
                
                // Copy the initial and final coordinates for each segment
                Boundary_segment_initial_coordinate[b].push_back(
                 initial_coordinate);
                Boundary_segment_final_coordinate[b].push_back(
                 final_coordinate);
                
                // Check that the boudary has an associated GeomObject
                if (this->boundary_geom_object_pt(b)!=0)
                 {
                  // Copy the initial zeta value for the segments
                  Boundary_segment_initial_zeta[b].push_back(
                   original_mesh_segment_initial_zeta[orig_s]);
                  Boundary_segment_final_zeta[b].push_back(
                   original_mesh_segment_final_zeta[orig_s]);
                 }
                else
                 {
                  // Copy the initial and final arclength for each segment
                  Boundary_segment_initial_arclength[b].push_back(
                   original_mesh_segment_initial_arclength[orig_s]);
                  Boundary_segment_final_arclength[b].push_back(
                   original_mesh_segment_final_arclength[orig_s]);
                 }
                // Mark the segment as done
                segment_done[orig_s] = true;
#ifdef PARANOID
                found_original_segment = true;
#endif
                break;                
               } // The final(current) node matched with the
                 // initial(original) node
             } // The initial(current) node matched with the
               // final(original) node
           } // else (the first(current) node did not matched with the
             // first(original) node. Else do the inverted case
          
         } // (!segment_done[orig_s])
        
       } // (orig_s < nsegments)
      
#ifdef PARANOID
      if (!found_original_segment)
       {
        std::stringstream error_message;
        error_message
         <<"The ("<<is<<")-th segment on the current segment was not\n"
         << "found when trying to identify it with the original mesh's\n"
         << "segment coordinates\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
       } // if (!found_original_segment)
#endif
     } // for (is < nsegments)
    
   } // if (nsegments > 0)
    
  // -------------------------------------------------------------------
  // Fourth: The original mesh is different from the current mesh
  // (this). For boundaries with no geom object associated check if it
  // is required to reverse the zeta values. In order to reverse the
  // zeta values it is required to previously compute the arclength of
  // the segments and store the nodes in a container (set). NOTE that
  // the setup_boundary_coordinate() method is not called for
  // boundaries with NO GeomObject associated, so this is the LAST
  // CHANCE to do it
  // -------------------------------------------------------------------
  // The original mesh is the same as the current mesh (this). The
  // setup_boundary_method() will be called only for the boundaries
  // with NO GeomObject associated
  // -------------------------------------------------------------------
  if (this != original_mesh_pt)
   {
    // Get the boundary arclength
    
    // Get the initial and final zeta values for the boundary
    // (arclength) from the original mesh
    Vector<double> first_node_zeta_coordinate = 
     original_mesh_pt->boundary_initial_zeta_coordinate(b);
    Vector<double> last_node_zeta_coordinate = 
     original_mesh_pt->boundary_final_zeta_coordinate(b);
        
    // The boundary arclength is the maximum of the initial and final
    // zeta coordinate
    const double boundary_arclength = 
     std::max(first_node_zeta_coordinate[0],
              last_node_zeta_coordinate[0]);
    
    for (unsigned is = 0; is < nsegments; is++)
     {
      // Here check if need to invert the elements and the boundary
      // coordinates for the segments in a boundary with no GeomObject
      // associated
      if (boundary_geom_object_pt(b)==0)
       {
        // This case only applies for the initial and iterative mesh in
        // the adaptation process because the method
        // setup_boundary_coordinates() is called by the original mesh
        // for boundaries with no GeomObject associated
        
        // We are goind to check if it is necessary to invert the order
        // of the zeta values
        
        // Get the first and last node of the current segment and their
        // zeta values (arclength)
        
        // There is no need to check for nonhalo elements since the
        // container has only nonhalo face elements
        
        // Get access to the first element on the segment
        FiniteElement* first_ele_pt=segment_sorted_ele_pt[is].front();
        
        // Number of nodes
        const unsigned nnod = first_ele_pt->nnode();
        
        // Get the first node of the current segment
        Node *first_node_pt = first_ele_pt->node_pt(0);
        if (is_inverted[first_ele_pt])
         {
          first_node_pt = first_ele_pt->node_pt(nnod-1);
         }
        
        // Get access to the last element on the segment
        FiniteElement* last_ele_pt=segment_sorted_ele_pt[is].back();
        
        // Get the last node of the current segment
        Node *last_node_pt = last_ele_pt->node_pt(nnod-1);
        if (is_inverted[last_ele_pt])
         {
          last_node_pt = last_ele_pt->node_pt(0);
         }
        
        // Get the zeta coordinates for the first and last node
        Vector<double> current_segment_initial_arclen(1);
        Vector<double> current_segment_final_arclen(1);
        // Is the segment in the current mesh (this) inverted?
        if (!Boundary_segment_inverted[b][is]) // Not inverted
         {
          first_node_pt->
           get_coordinates_on_boundary(b, current_segment_initial_arclen);
          last_node_pt->
           get_coordinates_on_boundary(b, current_segment_final_arclen);
         }
        else // Inverted
         {
          first_node_pt->
           get_coordinates_on_boundary(b, current_segment_final_arclen);
          last_node_pt->
           get_coordinates_on_boundary(b, current_segment_initial_arclen);
         }
        
        // Once the zeta values have been obtained check if they are set
        // in increasing or decreasing order
        
        // Flag to state that the values in the segment are in increasing
        // order
        bool increasing_order = false;
        
        // If the initial zeta value is smaller than the final zeta
        // value then they are in increasing order
        if (current_segment_initial_arclen[0] < 
            current_segment_final_arclen[0])
         {
          increasing_order = true;
         }
        // If the initial zeta value is greater than the initial zeta
        // value then they are in decreasing order
        else if (current_segment_initial_arclen[0] > 
                 current_segment_final_arclen[0])
         {
          increasing_order = false;
         }
#ifdef PARANOID
        else
         {
          std::stringstream error_message;
          error_message
           << "It was not possible to identify if the zeta values on "
           << "boundary ("<<b<<")\nand segment ("<<is<<") should go in "
           << "increasing or decreasing order.\n--- New mesh ---\n"
           << "Current segment initial arclength: ("
           << current_segment_initial_arclen[0]<<")\n"
           << "First node coordinates: ("
           << first_node_pt->x(0) << ",  " << first_node_pt->x(1) << ")\n"
           << "Current segment final arclength: ("
           << current_segment_final_arclen[0]<<")\n"
           << "Last node coordinates: ("
           << last_node_pt->x(0) << ",  " << last_node_pt->x(1) << ")\n"
           << "Current segment arclength: ("
           << segment_arclength[is] <<")\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
         }
#endif
        
        // Now get the original initial and final arclengths and check
        // if they are in increasing or decreasing order
        const unsigned prev_s = 
         current_segment_to_original_segment_index[is];
        const double original_segment_initial_arclength = 
         original_mesh_pt->boundary_segment_initial_arclength(b)[prev_s];
        const double original_segment_final_arclength = 
         original_mesh_pt->boundary_segment_final_arclength(b)[prev_s];
        
        // Flag to check if the values go in increasing or decreasing
        // order in the original mesh segment
        bool original_increasing_order = false;
        
        // Now check if the arclengths on the original mesh go in
        // increase or decrease order, this is also used to choose the
        // starting value to map the values in the current segment
        double starting_arclength = 0.0;
        if (original_segment_final_arclength > 
            original_segment_initial_arclength)
         {
          // ... in increasing order in the original mesh ...
          original_increasing_order = true;
          // Select the starting arclength
          starting_arclength = original_segment_initial_arclength;
         }
        else if (original_segment_final_arclength <
                 original_segment_initial_arclength)
         {
          // ... in decreasing order in the original mesh ...
          original_increasing_order = false;
          // Select the starting arclength
          starting_arclength = original_segment_final_arclength;
         }
#ifdef PARANOID
        else
         {
          std::stringstream error_message;
          error_message
           << "It was not possible to identify if the zeta values on "
           << "boundary ("<<b<<")\nand segment ("<<is<<") should go in "
           << "increasing or decreasing order.\n--- Original mesh ---\n"
           << "Original segment initial arclength: ("
           << original_segment_initial_arclength<<")\n"
           << "Original segment final arclength: ("
           << original_segment_final_arclength<<")\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
         }
#endif
        
        // Now scale the zeta values based considering if the zeta
        // values from the current mesh (this) go in the same order as
        // in the original mesh
        if (increasing_order && original_increasing_order)
         {
          // Current seg
          // |------|
          // 0 ---- 1
          //
          // Is mapped to the new values
          // |------|
          // a ---- b
          // a = original_segment_initial_arclength
          // b = original_segment_final_arclength
          // s = starting_arclength
          // The mapping is given by
          // new_z = s + z_old * (b - a)
          
          // Get the nodes associated to the segment
          std::set<Node*> seg_nodes_pt = segment_all_nodes_pt[is];
          // Go through all the nodes in the segment an change their
          // zeta values
          for (std::set<Node*>::iterator it = seg_nodes_pt.begin();
               it != seg_nodes_pt.end(); it++)
           {
            // Storing for the zeta value
            Vector<double> zeta(1);
            // Get each node
            Node* nod_pt = (*it);
            // Get the zeta value of the current node
            nod_pt->get_coordinates_on_boundary(b, zeta);
            // ... and re-assign it
            const double temp = 
              starting_arclength + (zeta[0] * segment_arclength[is]);
            // The zeta value
            zeta[0] = temp / boundary_arclength;
            // Correct
            if (std::fabs(zeta[0] - 1.0) < 1.0e-14)
              {
                zeta[0] = 1.0;
              }
            else if (std::fabs(zeta[0]) < 1.0e-14)
              {
                zeta[0] = 0.0;
              }
            
            // Set the new value
            nod_pt->set_coordinates_on_boundary(b, zeta);
           } // Go through all the nodes
         } // if (increasing_order && original_increasing_order)
        else if (!increasing_order && original_increasing_order)
         {
          // Current seg
          // |------|
          // 1 ---- 0
          //
          // Is mapped to the new values
          // |------|
          // a ---- b
          // a = original_segment_initial_arclength
          // b = original_segment_final_arclength
          // s = starting_arclength
          // The mapping is given by
          // new_z = s + (1.0 - z_old) * (b - a)
          
          // Get the nodes associated to the segment
          std::set<Node*> seg_nodes_pt = segment_all_nodes_pt[is];
          // Go through all the nodes in the segment an change their
          // zeta values
          for (std::set<Node*>::iterator it = seg_nodes_pt.begin();
               it != seg_nodes_pt.end(); it++)
           {
            // Storing for the zeta value
            Vector<double> zeta(1);
            // Get each node
            Node* nod_pt = (*it);
            // Get the zeta value of the current node
            nod_pt->get_coordinates_on_boundary(b, zeta);
            // ... and re-assign it
            const double temp = 
              starting_arclength + ((1.0 - zeta[0]) * segment_arclength[is]);
            // The zeta value
            zeta[0] = temp / boundary_arclength;
            // Correct
            if (std::fabs(zeta[0] - 1.0) < 1.0e-14)
              {
                zeta[0] = 1.0;
              }
            else if (std::fabs(zeta[0]) < 1.0e-14)
              {
                zeta[0] = 0.0;
              }
            // Set the new value
            nod_pt->set_coordinates_on_boundary(b, zeta);
           } // Go through all the nodes
         } // else if (!increasing_order && original_increasing_order)
        else if (increasing_order && !original_increasing_order)
         {
          // Current seg
          // |------|
          // 0 ---- 1
          //
          // Is mapped to the new values
          // |------|
          // b ---- a
          // a = original_segment_initial_arclength
          // b = original_segment_final_arclength
          // s = starting_arclength
          // The mapping is given by
          // new_z = s + (1.0 - z_old) * |(b - a)|
          
          // Get the nodes associated to the segment
          std::set<Node*> seg_nodes_pt = segment_all_nodes_pt[is];
          // Go through all the nodes in the segment an change their
          // zeta values
          for (std::set<Node*>::iterator it = seg_nodes_pt.begin();
               it != seg_nodes_pt.end(); it++)
           {
            // Storing for the zeta value
            Vector<double> zeta(1);
            // Get each node
            Node* nod_pt = (*it);
            // Get the zeta value of the current node
            nod_pt->get_coordinates_on_boundary(b, zeta);
            // ... and re-assign it
            const double temp = 
              starting_arclength + ((1.0 - zeta[0]) * segment_arclength[is]);
            // The zeta value
            zeta[0] = temp / boundary_arclength;
            // Correct
            if (std::fabs(zeta[0] - 1.0) < 1.0e-14)
              {
                zeta[0] = 1.0;
              }
            else if (std::fabs(zeta[0]) < 1.0e-14)
              {
                zeta[0] = 0.0;
              }
            // Set the new value
            nod_pt->set_coordinates_on_boundary(b, zeta);
           } // Go through all the nodes
         } // else if (increasing_order && !original_increasing_order)
        else if (!increasing_order && !original_increasing_order)
         {
          // Current seg
          // |------|
          // 0 ---- 1
          //
          // Is mapped to the new values
          // |------|
          // a ---- b
          // a = original_segment_initial_arclength
          // b = original_segment_final_arclength
          // s = starting_arclength
          // The mapping is given by
          // new_z = s + z_old * |(b - a)|
          
          // Get the nodes associated to the segment
          std::set<Node*> seg_nodes_pt = segment_all_nodes_pt[is];
          // Go through all the nodes in the segment an change their
          // zeta values
          for (std::set<Node*>::iterator it = seg_nodes_pt.begin();
               it != seg_nodes_pt.end(); it++)
           {
            // Storing for the zeta value
            Vector<double> zeta(1);
            // Get each node
            Node* nod_pt = (*it);
            // Get the zeta value of the current node
            nod_pt->get_coordinates_on_boundary(b, zeta);
            // ... and re-assign it
            const double temp = 
              starting_arclength + (zeta[0] * segment_arclength[is]);
            // The zeta value
            zeta[0] = temp / boundary_arclength;
            // Correct
            if (std::fabs(zeta[0] - 1.0) < 1.0e-14)
              {
                zeta[0] = 1.0;
              }
            else if (std::fabs(zeta[0]) < 1.0e-14)
              {
                zeta[0] = 0.0;
              }
            // Set the new value
            nod_pt->set_coordinates_on_boundary(b, zeta);
           } // Go through all the nodes          
         } // else if (!increasing_order && !original_increasing_order)
        
#ifdef PARANOID
        // Verify that the z values of the first and last node are not
        // out of the range [0,1]
        for (std::list<FiniteElement*>::iterator it_list =
              segment_sorted_ele_pt[is].begin();
             it_list != segment_sorted_ele_pt[is].end();
             it_list++)
         {
          // Number of nodes in the segment
          const unsigned nnod = (*it_list)->nnode();
          
          // Get the first node of the current segment
          Node *first_node_pt = (*it_list)->node_pt(0);
          if(is_inverted[(*it_list)])
           {
            first_node_pt = (*it_list)->node_pt(nnod-1);
           }
          
          // Get the last node of the current segment
          Node *last_node_pt = (*it_list)->node_pt(nnod-1);
          if(is_inverted[(*it_list)])
           {
            last_node_pt = (*it_list)->node_pt(0);
           }
          
          // The z value for the first node
          Vector<double> zeta(1);
          first_node_pt->get_coordinates_on_boundary(b, zeta);
          if (zeta[0] < 0.0 || zeta[0] > 1.0)
           {
            std::ostringstream error_message;
            error_message 
             <<"The boundary coordinate of the first node on boundary ("
             << b << ")\nand segment (" << is << ") is out of the "
             << "allowed values [0,1]\n"
             << "The node boundary coordinate: (" << zeta[0] << ")\n"
             << "The vertex coordinates are: (" 
             << first_node_pt->x(0) << ", " << first_node_pt->x(1) << ")\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
           }
          
          // The z value for the last node
          last_node_pt->get_coordinates_on_boundary(b, zeta);
          if (zeta[0] < 0.0 || zeta[0] > 1.0)
           {
            std::ostringstream error_message;
            error_message 
             <<"The boundary coordinate of the last node on boundary ("
             << b << ")\nand segment (" << is << ") is out of the "
             << "allowed values [0,1]\n"
             << "The node boundary coordinate: (" << zeta[0] << ")\n"
             << "The vertex coordinates are: (" 
             << last_node_pt->x(0) << ", " << last_node_pt->x(1) << ")\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
           }
         }
#endif // #ifdef PARANOID
        
       } // if (boundary_geom_object_pt(b)==0)
      
     } //  for (is < nsegments)
    
   } // if (this != original_mesh_pt)
  
  // ------------------------------------------------------------------
  // Copy the corrected (possible reversed) info. to the containers of
  // the current mesh
  // ------------------------------------------------------------------
  // Check if there are segments of b boundary in this processor
  if (nsegments > 0)
   {
    // Copy the initial and final coordinates
    Boundary_initial_coordinate[b] = 
     original_mesh_pt->boundary_initial_coordinate(b);
    
    Boundary_final_coordinate[b] = 
     original_mesh_pt->boundary_final_coordinate(b);
    
    // The initial and final zeta coordinates (In case of a geometric
    // object those are the limits of the geom object)
    Boundary_initial_zeta_coordinate[b] = 
     original_mesh_pt->boundary_initial_zeta_coordinate(b);
    
    Boundary_final_zeta_coordinate[b] = 
     original_mesh_pt->boundary_final_zeta_coordinate(b);
    
   } // if (nsegments > 0)
  
  // Set the flag to indicate that the zeta values have been assigned
  // for the current boundary
  Assigned_segments_initial_zeta_values[b] = true;
  
  // Clean all the created face elements
  for (unsigned i = 0; i < nele; i++)
   {
    delete face_el_pt[i];
    face_el_pt[i] = 0;
   }
  
 }

 //======================================================================
 /// \short Compute the boundary segments connectivity for those
 /// boundaries that were splited during the distribution process
 /// and also the initial zeta values for each segment (the initial
 /// and final boundary nodes coordinates)
 //======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::
 compute_boundary_segments_connectivity_and_initial_zeta_values(
  const unsigned& b)
 {
  // ------------------------------------------------------------------
  // First: Get the face elements associated with the current boundary
  // ------------------------------------------------------------------
  
  // Get the communicator of the mesh
  OomphCommunicator* comm_pt = this->communicator_pt();
  
  // Get the number of processors
  const unsigned nproc = comm_pt->nproc();
  // Get the rank of the current processor
  const unsigned my_rank = comm_pt->my_rank();
  
  // Temporary storage for face elements
  Vector<FiniteElement*> all_face_ele_pt;
  
  // Flag to know whether we are working with an internal open curve
  // and then re-assign the initial and final zeta coordinates for
  // each segment (only used when the mesh is distributed)
  bool is_internal_boundary = false;
  
  // map to associate the face element to the bulk element, necessary
  // to attach halo face elements at both sides of each found segment
  std::map<FiniteElement*,FiniteElement*> face_to_bulk_element_pt;
  
  // Select the boundary face elements, using the criteria of highest
  // processor in charge and bottom-left element
  select_boundary_face_elements(all_face_ele_pt, b, is_internal_boundary,
                                face_to_bulk_element_pt);
  
  // Get the number of face elements
  const unsigned n_all_face_ele = all_face_ele_pt.size();
  
  // ----------------------------------------------------------------
  // Second: Sort the face elements, only consider nonhalo elements
  // ----------------------------------------------------------------
  
  // A flag vector to mark those face elements that are considered as
  // halo in the current processor
  std::vector<bool> is_halo_face_element(n_all_face_ele, false);
  
  // Count the total number of non halo face elements
  unsigned nnon_halo_face_elements = 0;
  
  // Only mark the face elements as halo if the mesh is marked as
  // distributed
  for (unsigned ie = 0; ie < n_all_face_ele; ie++)
    {
    FiniteElement* face_ele_pt = all_face_ele_pt[ie];
    // Get the bulk element
    FiniteElement* tmp_bulk_ele_pt = face_to_bulk_element_pt[face_ele_pt];
    // Check if the bulk element is halo
    if (!tmp_bulk_ele_pt->is_halo())
     {
      // Set the flag for non halo element
      is_halo_face_element[ie] = false;
      // Increase the non halo elements counter
      nnon_halo_face_elements++;
     }
    else
     {
      // Mark the face element as halo
      is_halo_face_element[ie] = true;
     }
    
   } // for (ie < n_ele)
  
  // Get the total number of halo face elements
  const unsigned nhalo_face_element = n_all_face_ele - nnon_halo_face_elements;
  
  // The vector of list to store the "segments" that compound the
  // boundary (segments may appear only in a distributed mesh)
  Vector<std::list<FiniteElement*> > segment_sorted_ele_pt;
  
  // Number of already sorted face elements (only nonhalo elements for
  // a distributed mesh)
  unsigned nsorted_face_elements = 0;
  
  // Keep track of who's done (this apply to nonhalo only, remember we
  // are only working with halo elements)
  std::map<FiniteElement*, bool> done_el;
  
  // Keep track of which element is inverted (in distributed mesh the
  // elements may be inverted with respect to the segment they belong)
  std::map<FiniteElement*, bool> is_inverted;
  
  // Iterate until all possible segments have been created
  while(nsorted_face_elements < nnon_halo_face_elements)
   {
    // The ordered list of face elements (in a distributed mesh a
    // collection of contiguous face elements define a segment)
    std::list<FiniteElement*> sorted_el_pt;
    sorted_el_pt.clear();
    
#ifdef PARANOID
    // Select an initial element for the segment (the first not done
    // nonhalo element)
    bool found_initial_face_element = false;
#endif
    
    FiniteElement* ele_face_pt = 0;
    
    unsigned iface = 0;
    for (iface = 0; iface < n_all_face_ele; iface++)
     {
      if (!is_halo_face_element[iface])
       {
        ele_face_pt = all_face_ele_pt[iface];
        // If not done then take it as initial face element
        if (!done_el[ele_face_pt])
         {
#ifdef PARANOID
          found_initial_face_element = true;
#endif
          nsorted_face_elements++;
          iface++; // The next element number
          sorted_el_pt.push_back(ele_face_pt);
          // Mark as done
          done_el[ele_face_pt] = true;
          break;
         }
       }
     } // for (iface < nele)

#ifdef PARANOID
    if (!found_initial_face_element)
     {
      std::ostringstream error_message;
      error_message
       <<"Could not find an initial face element for the current segment\n";
      // << "----- Possible memory leak -----\n";
      throw OomphLibError(error_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     }
#endif
    
    // Number of nodes
    const unsigned nnod = ele_face_pt->nnode();
    
    // Left and rightmost nodes (the left and right nodes of the
    // current face element)
    Node* left_node_pt = ele_face_pt->node_pt(0);
    Node* right_node_pt = ele_face_pt->node_pt(nnod - 1);
    
    // Continue iterating if a new face element has been added to the
    // list
    bool face_element_added = false;
    
    // While a new face element has been added to the set of sorted
    // face elements then re-iterate
    do
     {
      // Start from the next face element since we have already added
      // the previous one as the initial face element (any previous
      // face element had to be added on previous iterations)
      for (unsigned iiface = iface; iiface < n_all_face_ele; iiface++)
       {
        // Re-start flag
        face_element_added = false;
        
        // Get the candidate element
        ele_face_pt = all_face_ele_pt[iiface];
        
        // Check that the candidate element has not been done and is
        // not a halo element
        if (!(done_el[ele_face_pt] || is_halo_face_element[iiface]))
         {
          // Get the left and right nodes of the current element
          Node* local_left_node_pt = ele_face_pt->node_pt(0);
          Node* local_right_node_pt = ele_face_pt->node_pt(nnod - 1);
          
          // New element fits at the left of segment and is not inverted
          if (left_node_pt == local_right_node_pt)
           {
            left_node_pt = local_left_node_pt;
            sorted_el_pt.push_front(ele_face_pt);
            is_inverted[ele_face_pt] = false;
            face_element_added = true;
           }
          // New element fits at the left of segment and is inverted
          else if (left_node_pt == local_left_node_pt)
           {
            left_node_pt = local_right_node_pt;
            sorted_el_pt.push_front(ele_face_pt);
            is_inverted[ele_face_pt] = true;
            face_element_added = true;
           }
          // New element fits on the right of segment and is not inverted
          else if (right_node_pt == local_left_node_pt)
           {
            right_node_pt = local_right_node_pt;
            sorted_el_pt.push_back(ele_face_pt);
            is_inverted[ele_face_pt] = false;
            face_element_added = true;
           }
          // New element fits on the right of segment and is inverted
          else if (right_node_pt == local_right_node_pt)
           {
            right_node_pt = local_left_node_pt;
            sorted_el_pt.push_back(ele_face_pt);
            is_inverted[ele_face_pt] = true;
            face_element_added = true;
           }
          
          if (face_element_added)
           {
            done_el[ele_face_pt] = true;
            nsorted_face_elements++;
            break;
           }
             
         } // if (!(done_el[ele_face_pt] || is_halo_face_element[iiface]))
       } // for (iiface<nnon_halo_face_element)
     }while(face_element_added &&
            (nsorted_face_elements < nnon_halo_face_elements));
    
    // Store the created segment in the vector of segments
    segment_sorted_ele_pt.push_back(sorted_el_pt);
    
   } // while(nsorted_face_elements < nnon_halo_face_elements);
  
  // -----------------------------------------------------------------
  // Third: We have the face elements sorted (in segments), now assign
  // boundary coordinates to the nodes in the segments, this is the
  // LOCAL boundary coordinate and further communication is needed to
  // compute the GLOBAL boundary coordinates
  // -----------------------------------------------------------------
  
  // Vector of sets that stores the nodes of each segment based on a
  // lexicographically order starting from the bottom left node of
  // each segment
  Vector<std::set<Node*> > segment_all_nodes_pt;
  
  // The number of segments in this processor
  const unsigned nsegments = segment_sorted_ele_pt.size();
//  DEBP(nsegments);
  
#ifdef PARANOID
  if (nnon_halo_face_elements > 0 && nsegments == 0)
   {
    std::ostringstream error_message;
    error_message
     << "The number of segments is zero, but the number of nonhalo\n"
     << "elements is: (" << nnon_halo_face_elements << ")\n";
    throw OomphLibError(error_message.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   } // if (nnon_halo_face_elements > 0 && nsegments == 0)
#endif

  // The arclength of each segment in the current processor
  Vector<double> segment_arclength(nsegments);
  
  // The number of vertices of each segment
  Vector<unsigned> nvertices_per_segment(nsegments);
  
  // The initial zeta for the segment
  Vector<double> initial_zeta_segment(nsegments);
  
  // The final zeta for the segment
  Vector<double> final_zeta_segment(nsegments);
    
  // Go through all the segments and compute its ARCLENGTH (if the
  // boundary has a GeomObject associated then assign the initial and
  // final zeta values for the segment)
  for (unsigned is = 0; is < nsegments; is++)
   {
#ifdef PARANOID
    if (segment_sorted_ele_pt[is].size() == 0)
     {
      std::ostringstream error_message;
      error_message
       << "The (" << is << ")-th segment has no elements\n";
      throw OomphLibError(error_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);      
     } // if (segment_sorted_ele_pt[is].size() == 0)
#endif
    
    // Get access to the first element on the segment
    FiniteElement* first_ele_pt = segment_sorted_ele_pt[is].front();
    
    // Number of nodes
    const unsigned nnod = first_ele_pt->nnode();
    
    // Get the first node of the current segment
    Node *first_node_pt = first_ele_pt->node_pt(0);
    if (is_inverted[first_ele_pt])
     {
      first_node_pt = first_ele_pt->node_pt(nnod-1);
     }
    
    // Coordinates of left node
    double x_left = first_node_pt->x(0);
    double y_left = first_node_pt->x(1);
    
    // Initialise boundary coordinate (local boundary coordinate for
    // boundaries with more than one segment)
    Vector<double> zeta(1, 0.0);
    
    // If we have associated a GeomObject then it is not necessary to
    // compute the arclength, only read the values from the nodes at
    // the edges and set the initial and final zeta segment values
    if (this->boundary_geom_object_pt(b)!=0)
     {
      // Get the initial node coordinate
      first_node_pt->get_coordinates_on_boundary(b, zeta);
      // Set the initial zeta segment value
      initial_zeta_segment[is] = zeta[0];
      
      // Get access to the last element on the segment
      FiniteElement* last_ele_pt = segment_sorted_ele_pt[is].back();
      
      // Get the last node of the current segment
      Node *last_node_pt = last_ele_pt->node_pt(nnod-1);
      if (is_inverted[last_ele_pt])
       {
        last_node_pt = last_ele_pt->node_pt(0);
       }
      
      // Get the final node coordinate
      last_node_pt->get_coordinates_on_boundary(b, zeta);
      // Set the final zeta segment value
      final_zeta_segment[is] = zeta[0];
      
     }
    
    // Sort the nodes in the segment (lexicographically bottom left
    // node)
    std::set<Node*> local_nodes_pt;
    // Insert the first node
    local_nodes_pt.insert(first_node_pt);
    
    // Now loop over nodes in order and increase the ARCLENGTH
    for (std::list<FiniteElement*>::iterator it = 
          segment_sorted_ele_pt[is].begin();
         it != segment_sorted_ele_pt[is].end(); it++)
     {
      // Get the pointer to the element
      FiniteElement* el_pt = (*it);

      // Start node and increment
      unsigned k_nod = 1;
      int nod_diff = 1;
      // Access nodes in reverse?
      if (is_inverted[el_pt])
       {
        k_nod = nnod - 2;
        nod_diff = -1;
       }
      
      // Loop over nodes in the face element
      for (unsigned j = 1; j < nnod; j++)
       {
        Node* nod_pt = el_pt->node_pt(k_nod);
        k_nod += nod_diff;
        
        // Coordinates of right node
        double x_right = nod_pt->x(0);
        double y_right = nod_pt->x(1);
        
        // Increment boundary coordinate (the arclength)
        zeta[0] += sqrt(
         (x_right - x_left) * (x_right - x_left) + (y_right - y_left)
         * (y_right - y_left));
        
        // When we have a GeomObject associated to the boundary we already
        // know the zeta values for the nodes, there is no need to compute
        // the arclength
//         if (this->boundary_geom_object_pt(b)==0)
//          {
//           // Set boundary coordinate
// //           nod_pt->set_coordinates_on_boundary(b, zeta);
//          }
        
        // Increment reference coordinate
        x_left = x_right;
        y_left = y_right;
        
        // Get lexicographically bottom left node but only
        // use vertex nodes as candidates
        local_nodes_pt.insert(nod_pt);
        
       } // for (j < nnod)
      
     } // iterator over the elements in the segment
    
    // Info. to be passed to other processors
    // The initial arclength for the segment that goes after this depends
    // on the current segment arclength
    segment_arclength[is] = zeta[0];
    
    // Info. to be passed to the other processors
    // The initial vertex number for the segment that goes after this
    // depends on the current segment vertices number
    nvertices_per_segment[is] = local_nodes_pt.size();
    
    // Add the nodes for the corresponding segment in the container
    segment_all_nodes_pt.push_back(local_nodes_pt);
    
    // The attaching of the halo elements at both sides of the segments is
    // performed only if segments connectivity needs to be computed
    
   } // for (is < nsegments)
  
  // Container to store the number of vertices before each segment,
  // initialise to zero in case we have a non distributed boundary
  Vector<unsigned> nvertices_before_segment(nsegments,0);
  
  // Store the initial arclength for each segment of boundary in the
  // current processor, initalise to zero in case we have a non
  // distributed boundary
  Vector<double> initial_segment_arclength(nsegments,0.0);
  
  // Info. to be passed to other processors
  // If the boundary is distributed we need to know which processors does
  // have the initial and final segments, this helps to get the first and
  // last nodes coordinates (info. used to scale the bound coordinates)
  
  // Processors with the initial and final segment
  unsigned proc_with_initial_seg = 0;
  unsigned proc_with_final_seg = 0;
  
  // ... and the index of those segments (only of interest in the
  // processors that have the initial and final segments)
  unsigned initial_segment = 0;
  unsigned final_segment = 0;
  
  // Each segment needs to know whether it has to be inverted or not
  // Store whether a segment needs to be inverted or not
  Vector<unsigned> segment_inverted(nsegments);
  
  // Before attaching the halo elements create a copy of the data
  // structure without halo elements
  Vector<std::list<FiniteElement*> > segment_sorted_nonhalo_ele_pt(nsegments);
  for (unsigned is = 0; is < nsegments; is++)
   {
    for (std::list<FiniteElement*>::iterator it_seg = 
          segment_sorted_ele_pt[is].begin();
         it_seg != segment_sorted_ele_pt[is].end();
         it_seg++)
     {
      segment_sorted_nonhalo_ele_pt[is].push_back((*it_seg));
     }
    
   } // for (is < nsegments)
  
  // --------------------------------------------------------------
  // Attach the halo elements at both sides of the segments
  for (unsigned is = 0; is < nsegments; is++)
   {
    // Get access to the first element on the segment
    FiniteElement* first_ele_pt = segment_sorted_ele_pt[is].front();
    
    // Number of nodes
    const unsigned nnod = first_ele_pt->nnode();
    
    // Get the first node of the current segment
    Node *first_node_pt = first_ele_pt->node_pt(0);
    if (is_inverted[first_ele_pt])
     {
      first_node_pt = first_ele_pt->node_pt(nnod-1);
     }
    
    // Get access to the last element on the segment
    FiniteElement* last_ele_pt = segment_sorted_ele_pt[is].back();
    
    // Get the last node of the current segment
    Node *last_node_pt = last_ele_pt->node_pt(nnod-1);
    if (is_inverted[last_ele_pt])
     {
      last_node_pt = last_ele_pt->node_pt(0);
     }
    
    // -----------------------------------------------------------------
    // Fourth: Now attach the halo elements to the left and right side
    // of each segment
    // -----------------------------------------------------------------
    bool attached_left_halo = false;
    bool attached_right_halo = false;
    if (nhalo_face_element > 0)
     {
      for (unsigned iiface = 0; iiface < n_all_face_ele; iiface++)
       {
        // Get the candidate element
        FiniteElement* halo_face_ele_pt = all_face_ele_pt[iiface];
        
        // Check that the element is a halo face element, we do not check
        // if the element has been already done since the halo elements
        // may be connected to more than one segment (2 at most), to the
        // left and right of different segments
        //
        //      Segment k        Halo         Segment r
        //   |---|---|---|      |xxx|      |---|---|---|
        //
        //          Segment k    Halo  Segment r
        //          |---|---|---|xxx|---|---|---|
        // 
        if (is_halo_face_element[iiface])
         {
          // Get its left and right nodes
          Node* left_node_pt = halo_face_ele_pt->node_pt(0);
          Node* right_node_pt = halo_face_ele_pt->node_pt(nnod-1);
          // The halo element fits to the left of segment
          if (!attached_left_halo && (first_node_pt == right_node_pt ||
                                      first_node_pt == left_node_pt))
           {
            // Add the halo element to the left of the segment
            segment_sorted_ele_pt[is].push_front(halo_face_ele_pt);
            
            // Once a halo face element has been added to the left
            // mark as found halo to the left
            attached_left_halo = true;
           }
          // The halo element fits to the right of the segment
          else if (!attached_right_halo && (last_node_pt == left_node_pt ||
                                            last_node_pt == right_node_pt))
           {
            // Add the halo element to the right of the segment
            segment_sorted_ele_pt[is].push_back(halo_face_ele_pt);
            // Once a halo face element has been added to the right
            // mark as found halo to the right
            attached_right_halo = true;
           }
          // If we have already found elements to left and right then
          // break the loop
          if (attached_left_halo && attached_right_halo)
           {break;}
          
         } // if (is_halo_face_element[iiface])
        
       } // for (iiface < nel)
      
     } // if (nhalo_face_element > 0)
    
   } // for (is < nsegments)
  
  // The segments now have local coordinates assigned and halo
  // elements attached to them. Store that info. in the corresponding
  // data structures and be ready to send that info. to a root
  // processor. The root processor will be in charge of computing the
  // boundary coordinates for each segment of the boundary.
  
  // For each segment store the following information
  // --------------------------------------------------------------------
  // Stores the "rank" of the processor to the left of each segment,
  // zero if there is no processor to the left which states that the
  // segment is the first one on the boundary
  Vector<unsigned> left_processor_plus_one(nsegments);
  
  // Stores the "rank" of the processor to the right of each segment,
  // zero if there is no processor to the right which states that the
  // segment is the last one on the boundary
  Vector<unsigned> right_processor_plus_one(nsegments);
  
  // The id. of the halo element to the left of the segment, note that
  // this info. is not necessary if there is no processor to the left
  // of the segment
  Vector<unsigned> left_halo_element(nsegments);
  
  // The id. of the halo element to the right of the segment, note that
  // this info. is not necessary if there is no processor to the right
  // of the segment
  Vector<unsigned> right_halo_element(nsegments);
  
  // The id. of the haloed element to the left of the segment, note that
  // this info. is not necessary if there is no processor to the left
  // of the segment
  Vector<unsigned> left_haloed_element(nsegments);
  
  // The id. of the haloed element to the right of the segment, note
  // that this info. is not necessary if there is no processor to the
  // right of the segment
  Vector<unsigned> right_haloed_element(nsegments);
  
  // Go through all the segments and get the info.
  for (unsigned is = 0; is < nsegments; is++)
   {
    // Get access to the left most face element on the segment
    FiniteElement* left_face_ele_pt=segment_sorted_ele_pt[is].front();
    
    // Get the corresponding bulk element and check whether it is a halo
    // element or not
    FiniteElement* tmp_left_bulk_ele_pt = 
     face_to_bulk_element_pt[left_face_ele_pt];
    
    // Check if the bulk element is halo
    if (tmp_left_bulk_ele_pt->is_halo())
     {
      // Then store the corresponding info.
      int left_proc = tmp_left_bulk_ele_pt->non_halo_proc_ID();
#ifdef PARANOID
      if (left_proc < 0)
       {
        std::ostringstream error_message;
        error_message 
         << "The current bulk element (left) is marked as halo but "
         << "the processor holding\nthe non-halo counterpart is "
         << "negative!\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
       }
#endif
      // The processor "rank" to the left
      unsigned left_processor = static_cast<unsigned>(left_proc);
      left_processor_plus_one[is] = left_processor + 1;
      
      // Now get the id of the halo element to the left
      GeneralisedElement *left_element_pt = tmp_left_bulk_ele_pt;
      
      // Get the halo elements with left processor
      Vector<GeneralisedElement*> left_halo_element_pt = 
       this->halo_element_pt(left_processor);
      
#ifdef PARANOID
      // Flag to state that the halo element was found
      bool left_halo_element_found = false;
#endif
      
      const unsigned n_halo_left = left_halo_element_pt.size();
      for (unsigned lh = 0; lh < n_halo_left; lh++)
       {
        if (left_element_pt == left_halo_element_pt[lh])
         {
          left_halo_element[is] = lh;
#ifdef PARANOID
          left_halo_element_found = true;
#endif
          break;
         }
       } // for (lh < n_halo_left)
      
#ifdef PARANOID
      if (!left_halo_element_found)
       {
        std::ostringstream error_message;
        error_message 
         << "The current bulk element (left) marked as halo was "
         << "not found in the vector of halo\nelements associated "
         << "with the (" << left_processor << ") processor.\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
       } // if (!left_halo_element_found)
#endif
      
      // Get the left-most nonhalo element (use the backup list of
      // nonhalo elements)
      left_face_ele_pt = segment_sorted_nonhalo_ele_pt[is].front();
      
      // Get the corresponding bulk element
      tmp_left_bulk_ele_pt = face_to_bulk_element_pt[left_face_ele_pt];
      
#ifdef PARANOID
      // This element should not be marked as halo
      if (tmp_left_bulk_ele_pt->is_halo())
       {
        std::ostringstream error_message;
        error_message 
         << "The bulk element represetation of the left-most nonhalo face\n"
         << "element of the current segment ("<<is<<") is marked as halo,\n"
         << "but the face element created from it is nonhalo\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
       } // if (tmp_left_bulk_ele_pt->is_halo())
#endif
      
      // Cast from "FiniteElement*" to "GeneralisedElement*" to be able
      // to search in the haloed vector
      left_element_pt = tmp_left_bulk_ele_pt;
      
#ifdef PARANOID
      // Flag to state that the haloed element was found
      bool left_haloed_element_found = false;
#endif
      
      // Now get the id for the haloed element to the left, get the
      // haloed elements from the processor to the left
      Vector<GeneralisedElement*> left_haloed_element_pt = 
       this->haloed_element_pt(left_processor);
      
      const unsigned nhaloed_left = left_haloed_element_pt.size();
      for (unsigned lhd = 0; lhd < nhaloed_left; lhd++)
       {
        if (left_element_pt == left_haloed_element_pt[lhd])
         {
          left_haloed_element[is] = lhd;
#ifdef PARANOID
          left_haloed_element_found = true;
#endif
          break;
         }
       } // for (lhd < nhaloed_left)
      
#ifdef PARANOID
      if (!left_haloed_element_found)
       {
        std::ostringstream error_message;
        error_message 
         << "The current bulk element (left) marked as haloed was "
         << "not found in the vector of haloed\nelements associated "
         << "with processor ("<< left_processor << ").\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
       }
#endif
     } // if (tmp_left_bulk_ele_pt->is_halo())
    else
     {
      // If not halo then state the info. to indicate that
      left_processor_plus_one[is] = 0;
      // Null this info.
      left_halo_element[is] = 0;
      // Null this info.
      left_haloed_element[is] = 0;
     }
    
    // Get access to the right most face element on the segment
    FiniteElement* right_face_ele_pt = segment_sorted_ele_pt[is].back();
    
    // Get the corresponding bulk element and check whether it is
    // a halo element or not
    FiniteElement* tmp_right_bulk_ele_pt = 
     face_to_bulk_element_pt[right_face_ele_pt];
    
    // Check if the bulk element is halo
    if (tmp_right_bulk_ele_pt->is_halo())
     {
      // Then store the corresponding info.
      int right_proc = tmp_right_bulk_ele_pt->non_halo_proc_ID();
#ifdef PARANOID
      if (right_proc < 0)
       {
        std::ostringstream error_message;
        error_message 
         << "The current bulk element (right) is marked as halo but "
         << "the processor holding\nthe non-halo counterpart is "
         << "negative!\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::compute_boundary_segments_connectivity_and_initial_zeta_values()",
                            OOMPH_EXCEPTION_LOCATION);
       }
#endif
      // The processor "rank" to the right
      unsigned right_processor = static_cast<unsigned>(right_proc);
      right_processor_plus_one[is] = right_processor + 1;
      
      // Now get the id of the halo element to the right
      GeneralisedElement *right_element_pt = tmp_right_bulk_ele_pt;
      
      // Get the halo elements with right processor
      Vector<GeneralisedElement*> right_halo_element_pt = 
       this->halo_element_pt(right_processor);
      
#ifdef PARANOID
      // Flag to state that the halo element was found
      bool right_halo_element_found = false;
#endif
      
      const unsigned nhalo_right = right_halo_element_pt.size();
      for (unsigned rh = 0; rh < nhalo_right; rh++)
       {
        if (right_element_pt == right_halo_element_pt[rh])
         {
          right_halo_element[is] = rh;
#ifdef PARANOID
          right_halo_element_found = true;
#endif
          break;
         }
       } // for (rh < nhalo_right)
#ifdef PARANOID
      if (!right_halo_element_found)
       {
        std::ostringstream error_message;
        error_message 
         << "The current bulk element (right) marked as halo was not "
         << "found in the vector of halo\nelements associated with "
         << "the (" << right_processor << ") processor.\n\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::compute_boundary_segments_connectivity_and_initial_zeta_values()",
                            OOMPH_EXCEPTION_LOCATION);
       }
#endif
      
      // Get the right-most nonhalo element (use the backup list of
      // nonhalo elements)
      right_face_ele_pt = segment_sorted_nonhalo_ele_pt[is].back();
      
      // Get the corresponding bulk element
      tmp_right_bulk_ele_pt=face_to_bulk_element_pt[right_face_ele_pt];
#ifdef PARANOID
      // This element should not be marked as halo
      if (tmp_right_bulk_ele_pt->is_halo())
       {
        std::ostringstream error_message;
        error_message 
         << "The bulk element represetation of the right-most nonhalo face\n"
         << "element of the current segment ("<<is<<") is marked as halo,\n"
         << "but the face element created from it is nonhalo\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::compute_boundary_segments_connectivity_and_initial_zeta_values()",
                            OOMPH_EXCEPTION_LOCATION);
       } // if (tmp_right_bulk_ele_pt->is_halo())
#endif
      
      // Cast from "FiniteElement*" to "GeneralisedElement*" to be able
      // to search in the haloed vector
      right_element_pt = tmp_right_bulk_ele_pt;
      
#ifdef PARANOID
      // Flag to state that the haloed element was found
      bool right_haloed_element_found = false;
#endif
      
      // Now get the id for the haloed element to the right
      Vector<GeneralisedElement*> right_haloed_element_pt = 
       this->haloed_element_pt(right_processor);
        
      const unsigned nhaloed_right = right_haloed_element_pt.size();
      for (unsigned rhd = 0; rhd < nhaloed_right; rhd++)
       {
        if (right_element_pt == right_haloed_element_pt[rhd])
         {
          right_haloed_element[is] = rhd;
#ifdef PARANOID
          right_haloed_element_found = true;
#endif
          break;
         }
       } // for (rhd < nhaloed_right)
      
#ifdef PARANOID
      if (!right_haloed_element_found)
       {
        std::ostringstream error_message;
        error_message 
         << "The current bulk element (right) marked as haloed was not "
         << "found in the vector of haloed\nelements associated with "
         << "the ("<< right_processor << ") processor.\n\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::compute_boundary_segments_connectivity_and_initial_zeta_values()",
                            OOMPH_EXCEPTION_LOCATION);
       }
#endif
        
     } // if (tmp_right_bulk_ele_pt->is_halo())
    else
     {
      // If not halo then state the info. to indicate that
      right_processor_plus_one[is] = 0;
      // Null this info.
      right_halo_element[is] = 0;
      // Null this info.
      right_haloed_element[is] = 0;
     }
    
   } // for (is < nsegments). Used to get the halo info. of the
     // segments
  
  // Now we have all the info. to be sent to the root processor and
  // compute the correct (global) boundary coordinates for the current
  // boundary
  
  // The root processor will be in charge of performing the computing
  // of the coordinate values along the boundary, all the other
  // processors only send their info. and wait for receiving the new
  // starting values for each of its segments
  
  // Choose the root processor
  const unsigned root_processor = 0;
  // ------------------------------------------------------------------
  // Starts the MPI stage
  
  // The root processor receives the number of segments of each
  // processor associated to the current boundary
  Vector<unsigned> root_nsegments_per_processor(nproc);
  unsigned nsegments_mpi = nsegments;
  MPI_Gather(&nsegments_mpi, 1, MPI_UNSIGNED, 
             &root_nsegments_per_processor[0], 1, MPI_UNSIGNED,
             root_processor, comm_pt->mpi_comm());
  
  // Package the info. and prepare it to be sent
  // For the packaged info. we send 7 data per each segment, the indexes
  // are as follow; 0 left proc, 1 right proc, 2 left halo, 3 right
  // halo, 4 left haloed, 5 right haloed and 6 for nvertices per
  // segment
  // The size of the package (unsigned)
  const unsigned spu = 7;
  Vector<unsigned> flat_packed_unsigned_send_data(nsegments*spu);
  for (unsigned is = 0; is < nsegments; is++)
   {
    flat_packed_unsigned_send_data[(spu*is)+0]=left_processor_plus_one[is];
    flat_packed_unsigned_send_data[(spu*is)+1]=right_processor_plus_one[is];
    flat_packed_unsigned_send_data[(spu*is)+2]=left_halo_element[is];
    flat_packed_unsigned_send_data[(spu*is)+3]=right_halo_element[is];
    flat_packed_unsigned_send_data[(spu*is)+4]=left_haloed_element[is];
    flat_packed_unsigned_send_data[(spu*is)+5]=right_haloed_element[is];
    flat_packed_unsigned_send_data[(spu*is)+6]=nvertices_per_segment[is];
   }
  
  // How many data will this processor send
  const unsigned nudata_to_send = flat_packed_unsigned_send_data.size();
  
  // How many data does the root processor will receive from each
  // processor
  Vector<int> root_nudata_to_receive(nproc,0);
  // Total number of data to receive from all processors
  unsigned root_nutotal_data_receive = 0;
  for (unsigned ip = 0; ip < nproc; ip++)
   {
    // Compute the number of data the root processor will receive from
    // each processor
    root_nudata_to_receive[ip] = root_nsegments_per_processor[ip] * spu;
    // Add on the total number of data to receive
    root_nutotal_data_receive+= root_nudata_to_receive[ip];
   }
  
  // Stores and compute the offsets (in root) for the data received
  // from each processor
  Vector<int> root_uoffsets_receive(nproc,0);
  root_uoffsets_receive[0] = 0;
  for (unsigned ip = 1; ip < nproc; ip++)
   {
    // Compute the offset to store the values from each processor
    root_uoffsets_receive[ip] = 
     root_uoffsets_receive[ip-1] + root_nudata_to_receive[ip-1];
   }
  
  // Create at least one entry so we don't get a seg fault below
  if (flat_packed_unsigned_send_data.size()==0)
   {
    flat_packed_unsigned_send_data.resize(1);
   }
  
  // Vector where to receive the info.
  Vector<unsigned> flat_packed_unsigned_receive_data(
   root_nutotal_data_receive);
  if (my_rank!=root_processor)
   {
    // Create at least one entry so we don't get a seg fault below
    if (flat_packed_unsigned_receive_data.size()==0)
     {
      flat_packed_unsigned_receive_data.resize(1);
     }
   } // if (my_rank!=root_processor)
  
  MPI_Gatherv(&flat_packed_unsigned_send_data[0], // Flat package to
                                                  // send info. from
                                                  // each processor
              nudata_to_send, // Total number of data to send from
                              // each processor
              MPI_UNSIGNED,
              &flat_packed_unsigned_receive_data[0], // Container
                                                     // where to
                                                     // receive the
                                                     // info. from all
                                                     // the processors
              &root_nudata_to_receive[0], // Number of data to receive
                                          // from each processor
              &root_uoffsets_receive[0], // The offset to store the
                                         // info. from each processor
              MPI_UNSIGNED,
              root_processor, //The processor that receives all the
                              //info.
              comm_pt->mpi_comm());
  
  // Clear the flat package to send
  flat_packed_unsigned_send_data.clear();
  flat_packed_unsigned_send_data.resize(0);
  
  // Package the info. and prepare it to be sent
  // For the packaged info. we send 1 data per each segment which is
  // at the moment the arclength of each segment
  // The size of the package
  const unsigned spd = 1;
  Vector<double> flat_packed_double_send_data(nsegments*spd);
  for (unsigned is = 0; is < nsegments; is++)
   {
    flat_packed_double_send_data[(spd*is)+0]=segment_arclength[is];
   }
  
  // How many data will this processor send
  const unsigned nddata_to_send = flat_packed_double_send_data.size();
  // How many data does the root processor will receive from each
  // processor
  Vector<int> root_nddata_to_receive(nproc,0);
  // Total number of data to receive from all processors
  unsigned root_ndtotal_data_receive = 0;
  for (unsigned ip =0; ip < nproc; ip++)
   {
    root_nddata_to_receive[ip] = root_nsegments_per_processor[ip] * spd;
    root_ndtotal_data_receive+= root_nddata_to_receive[ip];
   }
  
  // Stores and compute the offsets for the data received from each
  // processor
  Vector<int> root_doffsets_receive(nproc,0);
  root_doffsets_receive[0] = 0;
  for (unsigned ip = 1; ip < nproc; ip++)
   {
    // Compute the offset to store the values from each processor
    root_doffsets_receive[ip] = 
     root_doffsets_receive[ip-1] + root_nddata_to_receive[ip-1];
   }
  
  // Create at least one entry so we don't get a seg fault below
  if (flat_packed_double_send_data.size()==0)
   {
    flat_packed_double_send_data.resize(1);
   }
  
  // Vector where to receive the info.
  Vector<double> flat_packed_double_receive_data(root_ndtotal_data_receive);
  if (my_rank!=root_processor)
   {
    // Create at least one entry so we don't get a seg fault below
    if (flat_packed_double_receive_data.size()==0)
     {
      flat_packed_double_receive_data.resize(1);
     }
   }
  
  MPI_Gatherv(&flat_packed_double_send_data[0], // Flat package to
                                                // send info. from
                                                // each processor
              nddata_to_send, // Total number of data to send from
                              // each processor
              MPI_DOUBLE,                       
              &flat_packed_double_receive_data[0], // Container where
                                                   // to receive the
                                                   // info. from all
                                                   // the processors
              &root_nddata_to_receive[0], // Number of data to receive
                                          // from each processor
              &root_doffsets_receive[0], // The offset to store the
                                         // info. from each processor
              MPI_DOUBLE,
              root_processor, //The processor that receives all the
                              //info.
              comm_pt->mpi_comm());
  
  // Clear the flat package to send
  flat_packed_double_send_data.clear();
  flat_packed_double_send_data.resize(0);
  
  // The next three containers are only used by the root processor at
  // the end of its computations but it is necessary that all the
  // processors know them when calling back the info.
  
  // Container that state the initial arclength for each segments
  // of each processor
  Vector<Vector<double> > root_initial_segment_arclength(nproc);
  
  // Container that state the number of vertices before each segment
  // in a given processor
  Vector<Vector<unsigned> > root_nvertices_before_segment(nproc);
  
  // The root processor needs to tell the other processor if it was
  // necessary to reverse a segment. Each processor should therefore
  // invert the face elements that compose every segment that was
  // inverted by the root processor
  Vector<Vector<unsigned> > root_segment_inverted(nproc);
  
  // Used to store the accumulated arclength, used at the end of
  // communications to store the total arclength
  double root_accumulated_arclength = 0.0;
  
  // Store the accumulated number of vertices, it means the total number
  // of vertices before each segment (counter)
  unsigned root_accumulated_vertices_before_segment = 0;
  
  // The root processor is in charge of performing the connections
  // of the segments that define the complete boundary
  if (my_rank == root_processor)
   {
    // From the flat packaged received data re-create the data
    // structures storing the info. regarding the connectivity of the
    // segments, the number of vertices per segment and the local
    // arclength of each segment
    
    // Stores the "rank" of the processor to the left of each segment,
    // zero if there is no processor to the left which states that the
    // segment is the first one on the boundary
    Vector<Vector<unsigned> > root_left_processor_plus_one(nproc);
    
    // Stores the "rank" of the processor to the right of each segment,
    // zero if there is no processor to the right which states that the
    // segment is the last one on the boundary
    Vector<Vector<unsigned> > root_right_processor_plus_one(nproc);
    
    // The id. of the halo element to the left of the segment, note that
    // this info. is not necessary if there is no processor to the left
    // of the segment or if the processor has no info about the boundary
    Vector<Vector<unsigned> > root_left_halo_element(nproc);
    
    // The id. of the halo element to the right of the segment, note
    // that this info. is not necessary if there is no processor to
    // the right of the segment or if the processor has no info about
    // the boundary
    Vector<Vector<unsigned> > root_right_halo_element(nproc);
    
    // The id. of the haloed element to the left of the segment, note
    // that this info. is not necessary if there is no processor to
    // the left of the segment or if the processor has no info about
    // the boundary
    Vector<Vector<unsigned> > root_left_haloed_element(nproc);
    
    // The id. of the haloed element to the right of the segment, note
    // that this info. is not necessary if there is no processor to the
    // right of the segment or if the processor has no info about the
    // boundary
    Vector<Vector<unsigned> > root_right_haloed_element(nproc);
    
    // The number of vertices per segment in each processor
    Vector<Vector<unsigned> > root_nvertices_per_segment(nproc);
    
    // The arclength of each of the segments in the processors
    Vector<Vector<double> > root_segment_arclength(nproc);
    
    unsigned ucounter = 0;
    unsigned dcounter = 0;
    for (unsigned ip = 0; ip < nproc; ip++)
     {
      // Get the number of segments in the current processor
      const unsigned nsegs_iproc = root_nsegments_per_processor[ip];
      
      root_left_processor_plus_one[ip].resize(nsegs_iproc);
      root_right_processor_plus_one[ip].resize(nsegs_iproc);
      root_left_halo_element[ip].resize(nsegs_iproc);
      root_right_halo_element[ip].resize(nsegs_iproc);
      root_left_haloed_element[ip].resize(nsegs_iproc);
      root_right_haloed_element[ip].resize(nsegs_iproc);
      
      // Additional info.
      root_nvertices_per_segment[ip].resize(nsegs_iproc);
      root_segment_arclength[ip].resize(nsegs_iproc);
      root_segment_inverted[ip].resize(nsegs_iproc);
      
      // Extract the info. from the BIG package received from all
      // processors
      for(unsigned is = 0; is < nsegs_iproc; is++)
       {
        // ------ The flat unsigned package ------
        root_left_processor_plus_one[ip][is] = 
         flat_packed_unsigned_receive_data[ucounter++];
        root_right_processor_plus_one[ip][is] = 
         flat_packed_unsigned_receive_data[ucounter++];
        root_left_halo_element[ip][is] = 
         flat_packed_unsigned_receive_data[ucounter++];
        root_right_halo_element[ip][is] = 
         flat_packed_unsigned_receive_data[ucounter++];
        root_left_haloed_element[ip][is] = 
         flat_packed_unsigned_receive_data[ucounter++];
        root_right_haloed_element[ip][is] = 
         flat_packed_unsigned_receive_data[ucounter++];
        root_nvertices_per_segment[ip][is] = 
         flat_packed_unsigned_receive_data[ucounter++];
          
        // ------ The flat double package ------
        root_segment_arclength[ip][is] = 
         flat_packed_double_receive_data[dcounter++];
       } // for (is < nsegs_iproc)
     } // for (ip < nproc)
    
    // Now the root processor has all the info. to find out the
    // CONNECTIVITY of the segments in each processor
    
    // Container that stores the info. related with the connectivity
    // of the segments of each processor
    Vector<Vector<int> > left_connected_segment_plus_one(nproc);
    Vector<Vector<int> > right_connected_segment_plus_one(nproc);
    for (unsigned ip = 0; ip < nproc; ip++)
     {
      const unsigned nsegs_iproc = root_nsegments_per_processor[ip];
      left_connected_segment_plus_one[ip].resize(nsegs_iproc,-1);
      right_connected_segment_plus_one[ip].resize(nsegs_iproc,-1);
     } // for (ip < nprocs)
    
    // In charge of storing the connectivity of the segments, the pair
    // indicates the processor and the segment number
    std::list<std::pair<unsigned, unsigned> > proc_seg_connectivity;
    proc_seg_connectivity.clear();
    
    // Done segments on processor
    std::map<std::pair<unsigned, unsigned>, bool> done_segment;
    
    // Take the first segment of the first processor with segments and
    // add it to the list of segments
    unsigned left_proc = 0;
    unsigned right_proc = 0;
    unsigned left_seg = 0;
    unsigned right_seg = 0;
    for (unsigned ip = 0; ip < nproc; ip++)
     {
      const unsigned nsegs_iproc = root_nsegments_per_processor[ip];
      if (nsegs_iproc > 0)
       {
        right_proc = left_proc = ip;
        right_seg = left_seg = 0;
        break; // Break because it is the first processor with at
               // least one segment
       }
     } // for (ip < nproc)
    
    // ... and add it to the list of segments
    std::pair<unsigned, unsigned> add_segment = 
     std::make_pair(left_proc, left_seg);
    done_segment[add_segment] = true;
    proc_seg_connectivity.push_back(add_segment);
    
    // Flags to indicate when a segment was added to the left or right
    // of the current list of segments
    bool added_segment_to_the_left = false;
    bool added_segment_to_the_right = false;
      
    do // while(added_segment_to_the_left || added_segment_to_the_right)
     {
      // Read the left-most processor and segment in the list
      std::pair<unsigned, unsigned> left_pair = 
       proc_seg_connectivity.front();
      left_proc = left_pair.first;
      left_seg = left_pair.second;
      
      // Get the processor number to the left of the left-most
      // segment in the list
      const unsigned new_left_proc = 
       root_left_processor_plus_one[left_proc][left_seg];
      
      if (new_left_proc != 0)
       {
        // Initialise flag
        added_segment_to_the_left = false;
        // Get the left halo element id
        const unsigned left_halo_id = 
         root_left_halo_element[left_proc][left_seg];
        
        // Get the left haloed element id
        const unsigned left_haloed_id = 
         root_left_haloed_element[left_proc][left_seg];
        
        // Go through the segments on the new left processor and look
        // for the corresponding left_halo_id in the haloed_ids
        const unsigned nsegs_new_left_proc = 
         root_nsegments_per_processor[new_left_proc-1];
        
        for (unsigned ils = 0; ils < nsegs_new_left_proc; ils++)
         {
          std::pair<unsigned, unsigned> candidate_seg =
           std::make_pair(new_left_proc-1, ils);
          
          // Check that the segment has not been already added
          if (!done_segment[candidate_seg])
           {
            // Only consider the segments on new left processor which
            // right processor is the current one (left_proc)
            const unsigned right_proc_of_new_left_proc = 
             root_right_processor_plus_one[new_left_proc-1][ils];
            // Also get the left_proc_of_new_left_proc (in case that it
            // be necessary to invert the segment)
            const unsigned left_proc_of_new_left_proc = 
             root_left_processor_plus_one[new_left_proc-1][ils];
            // Check the not inverted case (to the left and not
            // inverted)
            if (right_proc_of_new_left_proc != 0 && 
                right_proc_of_new_left_proc-1 == left_proc)
             {
              // Get the haloed/haloed element id of the current segment
              // in the new left processor and compare it to the
              // halo/haloed element id of the left_processor
              const unsigned right_halo_id = 
               root_right_halo_element[new_left_proc-1][ils];
              const unsigned right_haloed_id = 
               root_right_haloed_element[new_left_proc-1][ils];
              if (left_halo_id == right_haloed_id && 
                  left_haloed_id == right_halo_id)
               {
                // We have a match of the segments (store the segment
                // number plus one on the processor to the left)
                left_connected_segment_plus_one[left_proc][left_seg]=
                 ils+1;
                // Add the pair to the connectivity list
                proc_seg_connectivity.push_front(candidate_seg);
                added_segment_to_the_left = true;
                break;
               }
             } // if (right_proc_of_new_left_proc-1 == left_proc)
            
            // Check the inverted case (to the left and inverted)
            if (left_proc_of_new_left_proc != 0 && 
                left_proc_of_new_left_proc-1 == left_proc)
             {
              // Get the haloed element id of the current segment
              // (inverted version) in the new left processor and
              // compare it to the halo element id of the left_processor
              const unsigned inv_left_halo_id = 
               root_left_halo_element[new_left_proc-1][ils];
              const unsigned inv_left_haloed_id = 
               root_left_haloed_element[new_left_proc-1][ils];
              if (left_halo_id == inv_left_haloed_id &&
                  left_haloed_id == inv_left_halo_id)
               {
                // We have a match of the segments (store the segment
                // number plus one on the processor to the left)
                left_connected_segment_plus_one[left_proc][left_seg]=
                 ils+1;
                // Add the pair to the connectivity list
                proc_seg_connectivity.push_front(candidate_seg);
                
                // In addition to the connectivity we need to invert the
                // segment (the information)
                const unsigned tmp_proc = 
                 root_left_processor_plus_one[new_left_proc-1][ils];
                const unsigned tmp_halo = 
                 root_left_halo_element[new_left_proc-1][ils];
                const unsigned tmp_haloed = 
                 root_left_haloed_element[new_left_proc-1][ils];
                
                root_left_processor_plus_one[new_left_proc-1][ils] = 
                 root_right_processor_plus_one[new_left_proc-1][ils];
                root_left_halo_element[new_left_proc-1][ils] = 
                 root_right_halo_element[new_left_proc-1][ils];
                root_left_haloed_element[new_left_proc-1][ils] = 
                 root_right_haloed_element[new_left_proc-1][ils];
                
                root_right_processor_plus_one[new_left_proc-1][ils] = 
                 tmp_proc;
                root_right_halo_element[new_left_proc-1][ils]=tmp_halo;
                root_right_haloed_element[new_left_proc-1][ils] = 
                 tmp_haloed;
                
                // ... and mark the segment as inverted in the root
                // processor to inform back to the owner processor
                root_segment_inverted[new_left_proc-1][ils] = 1;
                
                added_segment_to_the_left = true;
                break;
               }
             } // if (left_proc_of_new_left_proc-1 == left_proc)
           } // if (!done_segment[candidate_segment])
         } // for (ils < nsegs_new_left_proc)
        
#ifdef PARANOID
        if (!added_segment_to_the_left)
         {
          std::ostringstream error_message;
          error_message 
           << "The corresponding processor and segment to the left of "
           << "the current left\nmost segment was not found\n";
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::compute_boundary_segments_connectivity_and_initial_zeta_values()",
                              OOMPH_EXCEPTION_LOCATION);
         }
#endif
       } // if (new_left_proc != 0)
      else
       {
        // No more segments to the left
        added_segment_to_the_left = false;
       }
      
      // Read the info. of the right processor and the right segment
      std::pair<unsigned, unsigned> right_pair =
       proc_seg_connectivity.back();
      right_proc = right_pair.first;
      right_seg = right_pair.second;
      
      // Get the processor number to the right of the right-most
      // segment in the list
      const unsigned new_right_proc = 
       root_right_processor_plus_one[right_proc][right_seg];
      
      if (new_right_proc != 0)
       {
        // Initialise flag
        added_segment_to_the_right = false;
        // Get the right halo element id
        const unsigned right_halo_id = 
         root_right_halo_element[right_proc][right_seg];
        
        // Get the right halo element id
        const unsigned right_haloed_id = 
         root_right_haloed_element[right_proc][right_seg];
        
        // Go through the segments on the new right processor and look
        // for the corresponding right_halo_id in the haloed_ids
        const unsigned nsegs_new_right_proc = 
         root_nsegments_per_processor[new_right_proc-1];
        
        for (unsigned irs = 0; irs < nsegs_new_right_proc; irs++)
         {
          std::pair<unsigned, unsigned> candidate_seg =
           std::make_pair(new_right_proc-1, irs);
             
          // Check that the segment has not been already added
          if (!done_segment[candidate_seg])
           {
            // Only consider the segments on new right processor which
            // left processor is the current one (right_proc)
            const unsigned left_proc_of_new_right_proc = 
             root_left_processor_plus_one[new_right_proc-1][irs];
            // Also get the right_proc_of_new_right_proc (in case
            // that it be necessary to invert the segment)
            const unsigned right_proc_of_new_right_proc = 
             root_right_processor_plus_one[new_right_proc-1][irs];
            // Check the not inverted case (to the right and not
            // inverted)
            if (left_proc_of_new_right_proc != 0 && 
                left_proc_of_new_right_proc-1 == right_proc)
             {
              // Get the haloed element id of the current segment in the
              // new right processor and compare it to the halo element
              // id of the right_processor
              const unsigned left_halo_id = 
               root_left_halo_element[new_right_proc-1][irs];
              const unsigned left_haloed_id = 
               root_left_haloed_element[new_right_proc-1][irs];
              
              if (right_halo_id == left_haloed_id &&
                  right_haloed_id == left_halo_id)
               {
                // We have a match of the segments (store the segment
                // number plus one on the processor to the right)
                right_connected_segment_plus_one[right_proc][right_seg]=
                 irs+1;
                // Add the connectivity information to the list
                proc_seg_connectivity.push_back(candidate_seg);
                added_segment_to_the_right = true;
                break;
               }
             } // if (left_proc_of_new_right_proc-1 == right_proc)
            
            // Check the inverted case (to the right and inverted)
            if (right_proc_of_new_right_proc != 0 && 
                right_proc_of_new_right_proc-1 == right_proc)
             {
              // Get the haloed element id of the current segment
              // (inverted version) in the new right processor and
              // compare it to the halo element id of the
              // right_processor
              const unsigned inv_right_halo_id = 
               root_right_halo_element[new_right_proc-1][irs];
              const unsigned inv_right_haloed_id = 
               root_right_haloed_element[new_right_proc-1][irs];
              if (right_halo_id == inv_right_haloed_id &&
                  right_haloed_id == inv_right_halo_id)
               {
                // We have a match of the segments (store the segment
                // number plus one on the processor to the right)
                right_connected_segment_plus_one[right_proc][right_seg]=
                 irs+1;
                // Add the connectivity information to the list
                proc_seg_connectivity.push_back(candidate_seg);
                // In addition to the connectivity we need to invert the
                // segment
                const unsigned tmp_proc = 
                 root_left_processor_plus_one[new_right_proc-1][irs];
                const unsigned tmp_halo = 
                 root_left_halo_element[new_right_proc-1][irs];
                const unsigned tmp_haloed = 
                 root_left_haloed_element[new_right_proc-1][irs];
                
                root_left_processor_plus_one[new_right_proc-1][irs] = 
                 root_right_processor_plus_one[new_right_proc-1][irs];
                root_left_halo_element[new_right_proc-1][irs] = 
                 root_right_halo_element[new_right_proc-1][irs];
                root_left_haloed_element[new_right_proc-1][irs] = 
                 root_right_haloed_element[new_right_proc-1][irs];
                
                root_right_processor_plus_one[new_right_proc-1][irs] = 
                 tmp_proc;
                root_right_halo_element[new_right_proc-1][irs]=tmp_halo;
                root_right_haloed_element[new_right_proc-1][irs] = 
                 tmp_haloed;
                
                // ... and mark the segment as inverted in the root
                // processor to inform back to the owner processor
                root_segment_inverted[new_right_proc-1][irs] = 1;
                
                added_segment_to_the_right = true;
                break;
               }
             } // if (right_proc_of_new_right_proc-1 == right_proc)
           } // if (!done_segment[candidate_segment])
         } // for (irs < nsegs_new_left_proc)
        
#ifdef PARANOID
        if (!added_segment_to_the_right)
         {
          std::ostringstream error_message;
          error_message 
           << "The corresponding processor and segment to the right of "
           << "the current right\nmost segment was not found\n";
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::compute_boundary_segments_connectivity_and_initial_zeta_values()",
                              OOMPH_EXCEPTION_LOCATION);
         }
#endif
       } // if (new_right_proc != 0)
      else
       {
        // No more segments to the left
        added_segment_to_the_right = false;
       }
      
     }while(added_segment_to_the_left || added_segment_to_the_right);
    
    // Once we have connected the segments then we can compute the
    // initial and final zeta values based on the arclength of each
    // individual segment
    
    // Get the total number of segments, which MUST be the same as the
    // total number of segments in all processors
    const unsigned ntotal_segments = proc_seg_connectivity.size();
#ifdef PARANOID
    unsigned tmp_total_segments = 0;
    for (unsigned ip =0; ip < nproc; ip++)
     {
      tmp_total_segments+= root_nsegments_per_processor[ip];
     }
    
    // Check that the total number of segments in all processors is
    // the same as the number of segments that form the boundary
    if (ntotal_segments!=tmp_total_segments)
     {
      std::ostringstream error_message;
      error_message 
       << "The number of sorted segments (" << ntotal_segments << ") on "
       << "boundary ("<< b <<")\nis different from the total number of "
       <<"segments ("<< tmp_total_segments <<") in all\nprocessors.\n\n";
      throw OomphLibError(error_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     } // if (ntotal_segments!=tmp_total_segments)
#endif
    
    // Now that we know the connectivity of the segments we can
    // compute the initial arclength of each segment in the
    // processors. Additionally we also get the number of vertices
    // before each of the segments. Resize the containers considering
    // the number of segments in each processor
    for (unsigned ip = 0; ip < nproc; ip++)
     {
      const unsigned nsegs_iproc = root_nsegments_per_processor[ip];
      root_initial_segment_arclength[ip].resize(nsegs_iproc);
      root_nvertices_before_segment[ip].resize(nsegs_iproc);
     }
    
    Vector<double> aux_initial_segment_arclength(ntotal_segments);
    Vector<unsigned> aux_nvertices_before_segment(ntotal_segments);
    
    ucounter = 0;
    for (std::list<std::pair<unsigned, unsigned> >::iterator 
          it_list = proc_seg_connectivity.begin();
         it_list != proc_seg_connectivity.end(); it_list++)
     {
      const unsigned iproc = static_cast<unsigned>((*it_list).first);
      const unsigned iseg = static_cast<unsigned>((*it_list).second);
      const double iseg_arclength = root_segment_arclength[iproc][iseg];
      const unsigned iseg_nvertices = root_nvertices_per_segment[iproc][iseg];
      
      aux_initial_segment_arclength[ucounter] = root_accumulated_arclength;
      aux_nvertices_before_segment[ucounter] = 
       root_accumulated_vertices_before_segment;
      
      // Set the initial zeta value for the segment
      root_initial_segment_arclength[iproc][iseg] = root_accumulated_arclength;
      // Set the number of vertices before the current segment
      root_nvertices_before_segment[iproc][iseg] = 
       root_accumulated_vertices_before_segment;
      
      // Add the arclength of the segment to the global arclength
      root_accumulated_arclength+= iseg_arclength;
      // Add the number of vertices to the global number of vertices
      root_accumulated_vertices_before_segment+= iseg_nvertices - 1;
      
      // Increase the counter
      ucounter++;
     } // for (loop over the sorted segments to assigne initial
       // arlength and initial number of vertices)
    
    // Increase by one to get the total number of vertices on the
    // boundary
    root_accumulated_vertices_before_segment++;
    
    // Get the processors with the initial and final segment.
    proc_with_initial_seg = proc_seg_connectivity.front().first;
    proc_with_final_seg = proc_seg_connectivity.back().first;
    // Also get the corresponding initial and final segment indexes
    // (on the initial and final processors)
    initial_segment = proc_seg_connectivity.front().second;
    final_segment = proc_seg_connectivity.back().second;
    
   } // if (my_rank == root_processor)
  
  // Get the total number of segments
  unsigned root_ntotal_segments = 0;
  for (unsigned ip =0; ip < nproc; ip++)
   {
    root_ntotal_segments+= root_nsegments_per_processor[ip];
   }
  
  // Package the info. that will be sent to each processor. For the
  // unsigned package we send the number of vertices before each
  // segment in each processor and whether it was inverted or not
  // Package size
  const unsigned rspu = 2;
  flat_packed_unsigned_send_data.clear();
  flat_packed_unsigned_send_data.resize(root_ntotal_segments*rspu);
  unsigned ucounter = 0;
  // Collect the info. from all the segments in the processors
  for (unsigned ip = 0; ip < nproc; ip++)
   {
    const unsigned nsegs_iproc = root_nsegments_per_processor[ip];
    for (unsigned is = 0; is < nsegs_iproc; is++)
     {
      flat_packed_unsigned_send_data[ucounter++] = 
       root_nvertices_before_segment[ip][is];
      flat_packed_unsigned_send_data[ucounter++] = 
       root_segment_inverted[ip][is];
     } // for (is < nsegs_iproc)
   } // for (ip < nproc)
  
  // How many data does the root processor will send to each processor
  Vector<int> root_nudata_to_send(nproc,0);
  for (unsigned ip =0; ip < nproc; ip++)
   {
    // Get the number of data to send to ip processor
    root_nudata_to_send[ip] = root_nsegments_per_processor[ip] * rspu;
   }
  
  // Store and compute the offsets for the data sent to each processor
  Vector<int> root_uoffsets_send(nproc,0);
  root_uoffsets_send[0] = 0;
  for (unsigned ip = 1; ip < nproc; ip++)
   {
    // Compute the offset to send the values to each processor
    root_uoffsets_send[ip] = 
     root_uoffsets_send[ip-1] + root_nudata_to_send[ip-1];
   }
  
  // Number of data to receive from root
  unsigned nutotal_data_receive = nsegments * rspu;
  
  if (my_rank!=root_processor)
   {
    // Create at least one entry so we don't get a seg fault below
    if (flat_packed_unsigned_send_data.size()==0)
     {
      flat_packed_unsigned_send_data.resize(1);
     }
   }
  
  // Clear and resize the vector where to receive the info.
  flat_packed_unsigned_receive_data.clear();
  flat_packed_unsigned_receive_data.resize(nutotal_data_receive);
  // Create at least one entry so we don't get a seg fault below
  if (flat_packed_unsigned_receive_data.size()==0)
   {
    flat_packed_unsigned_receive_data.resize(1);
   }
  
  MPI_Scatterv(&flat_packed_unsigned_send_data[0],
               &root_nudata_to_send[0],
               &root_uoffsets_send[0],
               MPI_UNSIGNED,
               &flat_packed_unsigned_receive_data[0],
               nutotal_data_receive,
               MPI_UNSIGNED,
               root_processor,
               comm_pt->mpi_comm());
  
  // Package the info. that will be sent to each processor, for the
  // double package we send (one data per segment) the initial
  // arclength for each segment
  const unsigned rspd = 1;
  flat_packed_double_send_data.clear();
  flat_packed_double_send_data.resize(root_ntotal_segments*rspd);
  unsigned dcounter = 0;
  // Collect the info. from all the segments in the processors
  for (unsigned ip = 0; ip < nproc; ip++)
   {
    const unsigned nsegs_iproc = root_nsegments_per_processor[ip];
    for (unsigned is = 0; is < nsegs_iproc; is++)
     {
      flat_packed_double_send_data[dcounter++] = 
       root_initial_segment_arclength[ip][is];
     }
   }
    
  // How many data does the root processor will send to each processor
  Vector<int> root_nddata_to_send(nproc,0);
  for (unsigned ip =0; ip < nproc; ip++)
   {
    // Number of data send to ip processor
    root_nddata_to_send[ip] = root_nsegments_per_processor[ip] * rspd;
   }
  
  // Store and compute the offsets for the data sent to each processor
  Vector<int> root_doffsets_send(nproc,0);
  root_doffsets_send[0] = 0;
  for (unsigned ip = 1; ip < nproc; ip++)
   {
    // Compute the offset to send the values to each processor
    root_doffsets_send[ip] = 
     root_doffsets_send[ip-1] + root_nddata_to_send[ip-1];
   }
  
  // Number of double data to receive from root
  unsigned ndtotal_data_receive = nsegments * rspd;
  
  if (my_rank!=root_processor)
   {
    // Create at least one entry so we don't get a seg fault below
    if (flat_packed_double_send_data.size()==0)
     {
      flat_packed_double_send_data.resize(1);
     }
   }
  
  // Clear and resize the vector where to receive the info.
  flat_packed_double_receive_data.clear();
  flat_packed_double_receive_data.resize(ndtotal_data_receive);
  // Create at least one entry so we don't get a seg fault below
  if (flat_packed_double_receive_data.size()==0)
   {
    flat_packed_double_receive_data.resize(1);
   }
  
  MPI_Scatterv(&flat_packed_double_send_data[0],
               &root_nddata_to_send[0],
               &root_doffsets_send[0],
               MPI_DOUBLE,
               &flat_packed_double_receive_data[0],
               ndtotal_data_receive,
               MPI_DOUBLE,
               root_processor,
               comm_pt->mpi_comm());
  
  // Read if the segments need to be inverted and read the initial
  // arclengths
  ucounter = 0;
  dcounter = 0;
  
  // Read the info. from the flat package and store it in their
  // corresponding containers
  for (unsigned is = 0; is < nsegments; is++)
   {
    // The flat unsigned package
    nvertices_before_segment[is] = 
     flat_packed_unsigned_receive_data[ucounter++];
    // The segment inverted flag
    segment_inverted[is] = flat_packed_unsigned_receive_data[ucounter++];
    // The flat double package
    initial_segment_arclength[is] =
     flat_packed_double_receive_data[dcounter++];
   } // for (is < nsegments)
  
  // Perform two additional communications to get the total number of
  // vertices, the processors with the initial and final segments, the
  // corresponding initial and final segments ...
  const unsigned numore_info = 5;
  Vector<unsigned> flat_package_unsigned_more_info(numore_info);
  // Prepare the info ...
  flat_package_unsigned_more_info[0] = root_accumulated_vertices_before_segment;
  flat_package_unsigned_more_info[1] = proc_with_initial_seg;
  flat_package_unsigned_more_info[2] = proc_with_final_seg;
  flat_package_unsigned_more_info[3] = initial_segment;
  flat_package_unsigned_more_info[4] = final_segment;
  
  // Send the info. to all processors
  MPI_Bcast(&flat_package_unsigned_more_info[0], numore_info,
            MPI_UNSIGNED, root_processor, comm_pt->mpi_comm());
  
  // ... and store the info. in the proper containers
  root_accumulated_vertices_before_segment = flat_package_unsigned_more_info[0];
  proc_with_initial_seg = flat_package_unsigned_more_info[1];
  proc_with_final_seg = flat_package_unsigned_more_info[2];
  initial_segment = flat_package_unsigned_more_info[3];
  final_segment = flat_package_unsigned_more_info[4];
  
  // Do the same for the maximum zeta value
  MPI_Bcast(&root_accumulated_arclength, 1, MPI_DOUBLE,
            root_processor, comm_pt->mpi_comm());
    
  // -----------------------------------------------------------------
  // Clear the storage to store the data that will be used by the
  // setup boundary coordinates method, if we do not perform the
  // cleaning then previous data from previous iterations will remain
  // there
  // -----------------------------------------------------------------
  // The info. for the boundary
  Boundary_initial_coordinate[b].clear();
  Boundary_final_coordinate[b].clear();
  
  Boundary_initial_zeta_coordinate[b].clear();
  Boundary_final_zeta_coordinate[b].clear();
  
  // The info. for the segments
  Boundary_segment_inverted[b].clear();
  Boundary_segment_initial_coordinate[b].clear();
  Boundary_segment_final_coordinate[b].clear();
  
  Boundary_segment_initial_zeta[b].clear();
  Boundary_segment_final_zeta[b].clear();
  
  Boundary_segment_initial_arclength[b].clear();
  Boundary_segment_final_arclength[b].clear();
  
  // Now copy all the info. to the containers to be sent to any other
  // mesh (in the adaptation method)
  for (unsigned is = 0; is < nsegments; is++)
   {
    // At this point we can get the initial and final coordinates for
    // each segment
    Vector<double> first_seg_coord(2);
    Vector<double> last_seg_coord(2);
    
    // In order to get the first and last coordinates of each segment we
    // first need to identify the first and last nonhalo element of each
    // segment, and then get the first and last node of the segment
    
    // Get the first nonhalo face element on the segment
    FiniteElement* first_seg_ele_pt = 
     segment_sorted_nonhalo_ele_pt[is].front();
    
#ifdef PARANOID
    // Check if the face element is nonhalo, it shouldn't, but better
    // check
    if (first_seg_ele_pt->is_halo())
     {
      std::ostringstream error_message;
      error_message 
       << "The first face element in the (" << is << ")-th segment is halo\n";
       throw OomphLibError(error_message.str(),
                           "TriangleMesh::compute_boundary_segments_connectivity_and_initial_zeta_values()",
                           OOMPH_EXCEPTION_LOCATION);
     } // if (tmp_first_bulk_ele_pt->is_halo())
#endif
    
    // Number of nodes
    const unsigned nnod = first_seg_ele_pt->nnode();
    
    // Get the first node of the current segment
    Node *first_seg_node_pt = first_seg_ele_pt->node_pt(0);
    if (is_inverted[first_seg_ele_pt])
     {
      first_seg_node_pt = first_seg_ele_pt->node_pt(nnod-1);
     }
    
    // Get the last nonhalo face element on the segment
    FiniteElement* last_seg_ele_pt = 
     segment_sorted_nonhalo_ele_pt[is].back();
    
#ifdef PARANOID
    // Check if the face element is nonhalo, it shouldn't, but better
    // check
    if (last_seg_ele_pt->is_halo())
     {
      std::ostringstream error_message;
      error_message 
       << "The last face element in the (" << is << ")-th segment is halo\n";
       throw OomphLibError(error_message.str(),
                           "TriangleMesh::compute_boundary_segments_connectivity_and_initial_zeta_values()",
                           OOMPH_EXCEPTION_LOCATION);
     } // if (tmp_first_bulk_ele_pt->is_halo())
#endif
    
    // Get the last node of the current segment
    Node *last_seg_node_pt = last_seg_ele_pt->node_pt(nnod-1);
    if (is_inverted[last_seg_ele_pt])
     {
      last_seg_node_pt = last_seg_ele_pt->node_pt(0);
     }
    
    // Get the coordinates for the first and last segment's node
    for (unsigned i = 0; i < 2; i++)
     {
      first_seg_coord[i] = first_seg_node_pt->x(i);
      last_seg_coord[i] = last_seg_node_pt->x(i);
     }
    
    // -----------------------------------------------------------------
    // Copy the info. if the segment is inverted
    Boundary_segment_inverted[b].push_back(segment_inverted[is]);
    
    // Check if the segment is inverted, if that is the case then invert
    // the first and last seg. coordinates
    if (!segment_inverted[is])
     {
      // Store the initial and final coordinates that will help to
      // identify the segments in the new meshes created from this one
      Boundary_segment_initial_coordinate[b].push_back(first_seg_coord);
      Boundary_segment_final_coordinate[b].push_back(last_seg_coord);      
     }
    else
     {
      // Store the initial and final coordinates that will help to
      // identify the segments in the new meshes created from this one
      // Invert the initial and final coordinates
      Boundary_segment_initial_coordinate[b].push_back(last_seg_coord);
      Boundary_segment_final_coordinate[b].push_back(first_seg_coord);
     }
    
    // Now assign initial and final zeta boundary coordinates for each
    // segment
    // -----------------------------------------------------------------
    // If there is a geom object then
    if (boundary_geom_object_pt(b)!=0)
     {
      // Store the initial and final zeta for the current segments (we
      // got this when we assigned arclength to the segments in the
      // current processor)
      if (segment_inverted[is])
       {
        Boundary_segment_initial_zeta[b].push_back(final_zeta_segment[is]);
        Boundary_segment_final_zeta[b].push_back(initial_zeta_segment[is]);
       }
      else
       {
        Boundary_segment_initial_zeta[b].push_back(initial_zeta_segment[is]);
        Boundary_segment_final_zeta[b].push_back(final_zeta_segment[is]);
       }
     } // if (boundary_geom_object_pt(b)!=0)
    else
     {
      // Store the initial arclength and vertices number for the
      // current segment
      Boundary_segment_initial_arclength[b].push_back(
       initial_segment_arclength[is]);
      
      Boundary_segment_final_arclength[b].push_back(
       initial_segment_arclength[is] + segment_arclength[is]);
            
     } // else if (boundary_geom_object_pt(b)!=0)
    
   } // //  for (is < nsegments)
  
  // Get the number of segments from the sets of nodes
#ifdef PARANOID
  if (segment_all_nodes_pt.size() != nsegments)
   {
    std::ostringstream error_message;
    error_message 
     <<"The number of segments ("<<nsegments<<") and the number of "
     <<"set of nodes ("<<segment_all_nodes_pt.size()<<") representing\n"
     <<"the\nsegments is different!!!\n\n";
    throw OomphLibError(error_message.str(),
                        "TriangleMesh::compute_boundary_segments_connectivity_and_initial_zeta_values()",
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
  // The nodes have been assigned arc-length coordinates from one end
  // or the other of the connected segment.
  
  // -----------------------------------------------------------------
  // If mesh is distributed get the info. regarding the initial and
  // final nodes coordinates on the boundary, same as the zeta
  // boundary values for those nodes
  
  // Storage for the coordinates of the first and last nodes on the
  // boundary
  Vector<double> first_coordinate(2);
  Vector<double> last_coordinate(2);
  
  // Storage for the zeta coordinate of the first and last nodes on
  // the boundary
  Vector<double> first_node_zeta_coordinate(1,0.0);
  Vector<double> last_node_zeta_coordinate(1,0.0);
  
  // Send three data to all processors, the x[0], x[1] coordinate and
  // the zeta coordinate
  const unsigned ndtotal_data = 3;
  Vector<double> flat_packed_double_data_initial_seg(ndtotal_data);
  
  // If the mesh is distributed then check if this processor has the
  // initial segment
  if (my_rank == proc_with_initial_seg)
   {
    // Stores the firts element of the segment
    FiniteElement* first_ele_pt = 0;
    // Stores the first node of the boundary
    Node *first_node_pt = 0;
    // Check if the segment is inverted
    if (!segment_inverted[initial_segment])
     {
      // Get access to the first element on the segment marked as
      // initial
      first_ele_pt = segment_sorted_ele_pt[initial_segment].front();
      
      // Number of nodes
      const unsigned nnod = first_ele_pt->nnode();
      
      // Get the first node of the current segment
      first_node_pt = first_ele_pt->node_pt(0);
      if (is_inverted[first_ele_pt])
       {
        first_node_pt = first_ele_pt->node_pt(nnod-1);
       }
     } // if (!segment_inverted[initial_segment])
    else
     {
      // Get access to the first element on the segment marked as
      // initial
      first_ele_pt = segment_sorted_ele_pt[initial_segment].back();
      
      // Number of nodes
      const unsigned nnod = first_ele_pt->nnode();
      
      // Get the first node of the current segment
      first_node_pt = first_ele_pt->node_pt(nnod-1);
      if (is_inverted[first_ele_pt])
       {
        first_node_pt = first_ele_pt->node_pt(0);
       }
     } // else if (!segment_inverted[initial_segment])
    
    // Get the coordinates for the first node
    for (unsigned i = 0; i < 2; i++)
     {
      flat_packed_double_data_initial_seg[i] = first_node_pt->x(i);
     }
    
    // Get the zeta coordinates for the first node
    Vector<double> tmp_zeta(1);
    first_node_pt->get_coordinates_on_boundary(b, tmp_zeta);
    
    // If there is a geometric object associated to the boundary then
    // further process is necessary
    if (this->boundary_geom_object_pt(b)!=0)
     {
      //tmp_zeta[0] = this->boundary_coordinate_limits(b)[0];
     }
    else
     {
      // Check if the initial boundary coordinate is different from
      // zero, if that is the case then we need to set it to zero
      if (tmp_zeta[0] >= 1.0e-14)
       {
        tmp_zeta[0]=0;
       }
     } // if (this->boundary_geom_object_pt(b)!=0)
    
    // Store the initial zeta value
    flat_packed_double_data_initial_seg[2] = tmp_zeta[0];
    
   } // if (my_rank == proc_with_initial_seg)
  
  // All processor receive the info. from the processor that has the
  // initial segment
  MPI_Bcast(&flat_packed_double_data_initial_seg[0], ndtotal_data,
            MPI_DOUBLE, proc_with_initial_seg, comm_pt->mpi_comm());
  
  // ... and all processor put that info. into the appropriate
  // storages
  for (unsigned i = 0; i < 2; i++)
   {
    first_coordinate[i] = flat_packed_double_data_initial_seg[i];
   }
  first_node_zeta_coordinate[0]=flat_packed_double_data_initial_seg[2];
  
  // -----------------------------------------------------------------
  // Send three data to all processors, the x[0], x[1] coordinate and
  // the zeta coordinate
  Vector<double> flat_packed_double_data_final_seg(ndtotal_data);
  
  // If the mesh is distributed then check if this processor has the
  // final segment
  if (my_rank == proc_with_final_seg)
   {
    // Get access to the last element on the segment
    FiniteElement* last_ele_pt = 0;
    
    // Get the last node of the current segment
    Node *last_node_pt = 0;
    
    // Check if the segment is inverted
    if (!segment_inverted[final_segment])
     {
      // Get access to the last element on the segment marked as
      // final
      last_ele_pt = segment_sorted_ele_pt[final_segment].back();
      
      // Number of nodes
      const unsigned nnod = last_ele_pt->nnode();
      
      // Get the last node of the current segment
      last_node_pt = last_ele_pt->node_pt(nnod-1);
      if (is_inverted[last_ele_pt])
       {
        last_node_pt = last_ele_pt->node_pt(0);
       }
     } // if (!segment_inverted[final_segment])
    else
     {
      // Get access to the first element on the segment marked as
      // initial
      last_ele_pt = segment_sorted_ele_pt[final_segment].front();
      
      // Number of nodes
      const unsigned nnod = last_ele_pt->nnode();
      
      // Get the first node of the current segment
      last_node_pt = last_ele_pt->node_pt(0);
      if (is_inverted[last_ele_pt])
       {
        last_node_pt = last_ele_pt->node_pt(nnod-1);
       }
     } // if (!segment_inverted[final_segment])
    
    // Get the coordinates for the last node
    for (unsigned i = 0; i < 2; i++)
     {
      flat_packed_double_data_final_seg[i]=last_node_pt->x(i);
     }
    
    // Get the zeta coordinates for the last node
    Vector<double> tmp_zeta(1);
    last_node_pt->get_coordinates_on_boundary(b, tmp_zeta);
    
    // If there is not a geometric object associated to the boundary
    // then further process is required
    if (this->boundary_geom_object_pt(b)!=0)
     {
      // Do nothing
     } // if (this->boundary_geom_object_pt(b)!=0)
    else
     {      
      // Check if the final boundary coordinate is different from
      // the boundary arclength, if that is the case then we need
      // to set it to the accumulated arclength
      if (std::fabs(tmp_zeta[0] - root_accumulated_arclength) >= 1.0e-14)
       {
        tmp_zeta[0] = root_accumulated_arclength;
       }
     } // else if (this->boundary_geom_object_pt(b)!=0)
    
    // Store the final zeta value
    flat_packed_double_data_final_seg[2] = tmp_zeta[0];
    
   } // if (my_rank == proc_with_final_seg)
  
  // All processor receive the info. from the processor that has the
  // final segment
  MPI_Bcast(&flat_packed_double_data_final_seg[0], ndtotal_data,
            MPI_DOUBLE, proc_with_final_seg, comm_pt->mpi_comm());
  
  // All processor receive the info. from the processor that has the
  // final segment
  for (unsigned i = 0; i < 2; i++)
   {
    last_coordinate[i] = flat_packed_double_data_final_seg[i];
   }
  last_node_zeta_coordinate[0]=flat_packed_double_data_final_seg[2];
  
  // -----------------------------------------------------------------
  // Copy the values to the permanent storage
  Boundary_initial_coordinate[b] = first_coordinate;
  Boundary_final_coordinate[b] = last_coordinate;
  
  Boundary_initial_zeta_coordinate[b] = first_node_zeta_coordinate;
  Boundary_final_zeta_coordinate[b] = last_node_zeta_coordinate;
  
  // If we are dealing with an internal boundary then re-assign the
  // initial and final zeta values for the segments
  if (is_internal_boundary)
   {
    // Only re-assign zeta values if there are at least one nonhalo
    // segment, if all the possible segments are halo then the
    // synchronisation method will be in charge of assigning the
    // correct boundary coordinates
    if (nsegments > 0)
     {
      // Call the following method to re-construct the segments but
      // using only the nonhalo elements, therefore the boundary
      // coordinates need to be re-assigned      
      re_assign_initial_zeta_values_for_internal_boundary(
       b, segment_sorted_nonhalo_ele_pt, is_inverted);
     }
    
   } // if (is_internal_boundary)
  
  // Now identify the boundary segments
  if (nsegments > 0)
    {
      // Identify the boundary segments in the current mesh
      //identify_boundary_segments_and_assign_initial_zeta_values(
      //  b, all_face_ele_pt, is_internal_boundary, face_to_bulk_element_pt);
      identify_boundary_segments_and_assign_initial_zeta_values(b,this);
    } // if (nsegments > 0)
  
  // Clean all the created face elements
  for (unsigned i = 0; i < n_all_face_ele; i++)
    {
      delete all_face_ele_pt[i];
      all_face_ele_pt[i] = 0;
    }
  
 }
  
 //======================================================================
 /// \short Re-assign the boundary segments initial zeta (arclength)
 /// for those internal boundaries that were splited during the
 /// distribution process. Those boundaries that have one face element
 /// at each side of the boundary. Here we create the segments only
 /// with the nonhalo elements, therefore the boundary coordinates
 /// need to be re-assigned to be passed to the new meshes
 //======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::
 re_assign_initial_zeta_values_for_internal_boundary(
  const unsigned& b,
  Vector<std::list<FiniteElement*> > &old_segment_sorted_ele_pt,
  std::map<FiniteElement*, bool> &old_is_inverted)
 {
  // ------------------------------------------------------------------
  // First: Get the face elements associated with the current boundary
  //        Only include nonhalo face elements
  // ------------------------------------------------------------------
  // Temporary storage for face elements
  Vector<FiniteElement*> face_el_pt;
  
  // Temporary storage for the number of elements adjacent to the
  // boundary
  unsigned nele = 0;
  
  // Temporary storage for elements adjacent to the boundary that have
  // a common edge (related with internal boundaries)
  unsigned n_repeated_ele = 0;
  
  const unsigned n_regions = this->nregion();
  
  // Temporary storage for already done nodes
  Vector<std::pair<Node*, Node*> > done_nodes_pt;
  
  // If there is more than one region then only use boundary
  // coordinates from the bulk side (region 0)
  if (n_regions > 1)
   {
    for (unsigned rr = 0 ; rr < n_regions; rr++)
     {
      const unsigned region_id = 
       static_cast<unsigned>(this->Region_attribute[rr]);
      
      // Loop over all elements on boundaries in region i_r
      const unsigned nel_in_region = 
       this->nboundary_element_in_region(b, region_id);
      
      unsigned nel_repetead_in_region = 0;
      
      // Only bother to do anything else, if there are elements
      // associated with the boundary and the current region
      if (nel_in_region > 0)
       {
        bool repeated = false;
        
        // Loop over the bulk elements adjacent to boundary b
        for (unsigned e = 0; e < nel_in_region; e++)
         {
          // Get pointer to the bulk element that is adjacent to
          // boundary b
          FiniteElement* bulk_elem_pt =
           this->boundary_element_in_region_pt(b, region_id, e);
          
          // Remember only work with non halo elements
          if (bulk_elem_pt->is_halo())
           {
            n_repeated_ele++;
            continue;
           }
          
          // Find the index of the face of element e along boundary b
          int face_index = 
           this->face_index_at_boundary_in_region(b,region_id,e);
          
          // Before adding the new element we need to be sure that the
          // edge that this element represent has not been already
          // added
          FiniteElement* tmp_ele_pt = 
           new DummyFaceElement<ELEMENT>(bulk_elem_pt, face_index);
          
          const unsigned n_nodes = tmp_ele_pt->nnode();
          
          std::pair<Node*, Node*> tmp_pair = 
           std::make_pair(tmp_ele_pt->node_pt(0),
                          tmp_ele_pt->node_pt(n_nodes - 1));

          std::pair<Node*, Node*> tmp_pair_inverse = 
           std::make_pair(tmp_ele_pt->node_pt(n_nodes - 1),
                          tmp_ele_pt->node_pt(0));
          
          // Search for repeated nodes
          const unsigned repeated_nodes_size = done_nodes_pt.size();
          for (unsigned l = 0; l < repeated_nodes_size; l++)
           {
            if (tmp_pair == done_nodes_pt[l] || 
                tmp_pair_inverse == done_nodes_pt[l])
             {
              nel_repetead_in_region++;
              repeated = true;
              break;
             }
           }
          
          // Create new face element
          if (!repeated)
           {
            // Add the pair of nodes (edge) to the node dones
            done_nodes_pt.push_back(tmp_pair);
            // Add the element to the face elements
            face_el_pt.push_back(tmp_ele_pt);
           }
          else
           {
            // Clean up
            delete tmp_ele_pt;
            tmp_ele_pt = 0;
           }
          
          // Re-start
          repeated = false;
          
         } // for nel
        
        nele += nel_in_region;
        
        n_repeated_ele += nel_repetead_in_region;
        
       } // if (nel_in_region > 0)
     } // for (rr < n_regions)
   } // if (n_regions > 1)
  //Otherwise it's just the normal boundary functions
  else
   {
    // Loop over all elements on boundaries
    nele = this->nboundary_element(b);
    
    //Only bother to do anything else, if there are elements
    if (nele > 0)
     {
      // Check for repeated ones
      bool repeated = false;
      
      // Loop over the bulk elements adjacent to boundary b
      for (unsigned e = 0; e < nele; e++)
       {
        // Get pointer to the bulk element that is adjacent to
        // boundary b
        FiniteElement* bulk_elem_pt = this->boundary_element_pt(b, e);
        
        // Skip the halo elements, they are not included
        if (bulk_elem_pt->is_halo())
         {
          n_repeated_ele++;
          continue;
         }
                
        //Find the index of the face of element e along boundary b
        int face_index = this->face_index_at_boundary(b, e);
        
        // Before adding the new element we need to be sure that the
        // edge that this element represents has not been already
        // added (only applies for internal boundaries)
        FiniteElement* tmp_ele_pt = 
         new DummyFaceElement<ELEMENT>(bulk_elem_pt, face_index);
        
        const unsigned n_nodes = tmp_ele_pt->nnode();
        
        std::pair<Node*, Node*> tmp_pair = 
         std::make_pair(tmp_ele_pt->node_pt(0),
                        tmp_ele_pt->node_pt(n_nodes - 1));
        
        std::pair<Node*, Node*> tmp_pair_inverse = 
         std::make_pair(tmp_ele_pt->node_pt(n_nodes - 1),
                        tmp_ele_pt->node_pt(0));
        
        // Search for repeated nodes
        const unsigned repeated_nodes_size = done_nodes_pt.size();
        for (unsigned l = 0; l < repeated_nodes_size; l++)
         {
          if (tmp_pair == done_nodes_pt[l] || 
              tmp_pair_inverse == done_nodes_pt[l])
           {
            // Increase the number of repeated elements
            n_repeated_ele++;
            // Mark the element as repeated
            repeated = true;
            break;
           }
         }
        
        // Create new face element
        if (!repeated)
         {
          // Add the pair of nodes (edge) to the node dones
          done_nodes_pt.push_back(tmp_pair);
          // Add the element to the face elements
          face_el_pt.push_back(tmp_ele_pt);
         }
        else
         {
          // Free the repeated bulk element!!
          delete tmp_ele_pt;
          tmp_ele_pt = 0;
         }

        // Re-start
        repeated = false;
        
       } // for (e < nel)
     } // if (nel > 0)
    
   } // else (n_regions > 1)
  
  // Do not consider the repeated elements
  nele-= n_repeated_ele;
  
#ifdef PARANOID
  if (nele!=face_el_pt.size())
   {
    std::ostringstream error_message;
    error_message
     << "The independet counting of face elements ("<<nele<<") for "
     << "boundary ("<<b<<") is different\n"
     << "from the real number of face elements in the container ("
     << face_el_pt.size() <<")\n";
    //<< "Possible memory leak\n"
    throw OomphLibError(error_message.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
  // ----------------------------------------------------------------
  // Second: Sort the face elements, only consider nonhalo elements
  // ----------------------------------------------------------------
  
  // Get the total number of nonhalo face elements
  const unsigned nnon_halo_face_elements = face_el_pt.size();
  
  // The vector of list to store the "segments" that compound the
  // boundary (segments may appear only in a distributed mesh)
  Vector<std::list<FiniteElement*> > segment_sorted_ele_pt;
  
  // Number of already sorted face elements
  unsigned nsorted_face_elements = 0;
  
  // Keep track of who's done
  std::map<FiniteElement*, bool> done_el;
  
  // Keep track of which element is inverted
  std::map<FiniteElement*, bool> is_inverted;
  
  // Iterate until all possible segments have been created
  while(nsorted_face_elements < nnon_halo_face_elements)
   {
    // The ordered list of face elements (in a distributed mesh a
    // collection of contiguous face elements define a segment)
    std::list<FiniteElement*> sorted_el_pt;
    
#ifdef PARANOID
    // Select an initial element for the segment
    bool found_initial_face_element = false;
#endif
    
    FiniteElement* ele_face_pt = 0;
    
    unsigned iface = 0;
    for (iface = 0; iface < nele; iface++)
     {
      ele_face_pt = face_el_pt[iface];
      // If not done then take it as initial face element
      if (!done_el[ele_face_pt])
       {
#ifdef PARANOID
        // Mark as found the root face element
        found_initial_face_element = true;
#endif
        // Increase the number of sorted face elements
        nsorted_face_elements++;
        // Increase the counter to mark the position of the next
        // element number
        iface++;
        // Add the face element in the list of sorted face elements
        sorted_el_pt.push_back(ele_face_pt);
        // Mark as done
        done_el[ele_face_pt] = true;
        break;
       } // if (!done_el[ele_face_pt])
     } // for (iface < nele)
    
#ifdef PARANOID
    if (!found_initial_face_element)
     {
      std::ostringstream error_message;
      error_message
       <<"Could not find an initial face element for the current segment\n";
      throw OomphLibError(error_message.str(),
                          "TriangleMesh::re_assign_initial_zeta_values_for_internal_boundary()",
                          OOMPH_EXCEPTION_LOCATION);
     }
#endif
    
    // Number of nodes
    const unsigned nnod = ele_face_pt->nnode();
    
    // Left and rightmost nodes (the left and right nodes of the
    // current face element)
    Node* left_node_pt = ele_face_pt->node_pt(0);
    Node* right_node_pt = ele_face_pt->node_pt(nnod - 1);
    
    // Continue iterating if a new face element has been added to the
    // list
    bool face_element_added = false;
    
    // While a new face element has been added to the set of sorted
    // face elements then re-iterate
    do
     {
      // Start from the next face element since we have already added
      // the previous one as the initial face element (any previous
      // face element had to be added on previous iterations)
      for (unsigned iiface = iface; iiface < nele; iiface++)
       {
        // Re-start flag
        face_element_added = false;
        
        // Get the candidate element
        ele_face_pt = face_el_pt[iiface];
        
        // Check that the candidate element has not been done and is
        // not a halo element
        if (!(done_el[ele_face_pt]))
         {
          // Get the left and right nodes of the current element
          Node* local_left_node_pt = ele_face_pt->node_pt(0);
          Node* local_right_node_pt = ele_face_pt->node_pt(nnod - 1);
          
          // New element fits at the left of segment and is not inverted
          if (left_node_pt == local_right_node_pt)
           {
            left_node_pt = local_left_node_pt;
            sorted_el_pt.push_front(ele_face_pt);
            is_inverted[ele_face_pt] = false;
            face_element_added = true;
           }
          // New element fits at the left of segment and is inverted
          else if (left_node_pt == local_left_node_pt)
           {
            left_node_pt = local_right_node_pt;
            sorted_el_pt.push_front(ele_face_pt);
            is_inverted[ele_face_pt] = true;
            face_element_added = true;
           }
          // New element fits on the right of segment and is not inverted
          else if (right_node_pt == local_left_node_pt)
           {
            right_node_pt = local_right_node_pt;
            sorted_el_pt.push_back(ele_face_pt);
            is_inverted[ele_face_pt] = false;
            face_element_added = true;
           }
          // New element fits on the right of segment and is inverted
          else if (right_node_pt == local_right_node_pt)
           {
            right_node_pt = local_left_node_pt;
            sorted_el_pt.push_back(ele_face_pt);
            is_inverted[ele_face_pt] = true;
            face_element_added = true;
           }
          
          if (face_element_added)
           {
            done_el[ele_face_pt] = true;
            nsorted_face_elements++;
            break;
           } // if (face_element_added)
          
         } // if (!(done_el[ele_face_pt]))
        
       } // for (iiface<nnon_halo_face_element)
      
     }while(face_element_added &&
            (nsorted_face_elements < nnon_halo_face_elements));
    
    // Store the created segment in the vector of segments
    segment_sorted_ele_pt.push_back(sorted_el_pt);
    
   } // while(nsorted_face_elements < nnon_halo_face_elements);
  
  // --------------------------------------------------------------
  // Third: We have the face elements sorted, now assign boundary
  // coordinates to the nodes in the segments and compute the
  // arclength of the segment.
  // --------------------------------------------------------------
  
  // The number of segments in this processor
  const unsigned nsegments = segment_sorted_ele_pt.size();
  
#ifdef PARANOID
  if (nnon_halo_face_elements > 0 && nsegments == 0)
   {
    std::ostringstream error_message;
    error_message
     << "The number of segments is zero, but the number of nonhalo\n"
     << "elements is: (" << nnon_halo_face_elements << ")\n";
    throw OomphLibError(error_message.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   } // if (nnon_halo_face_elements > 0 && nsegments == 0)
#endif
  
  // Vector of sets that stores the nodes of each segment based on a
  // lexicographically order starting from the bottom left node of
  // each segment
  Vector<std::set<Node*> > segment_all_nodes_pt(nsegments);
  
  // Stores the nodes on each segment in the order they appear in the
  // face elements
  Vector<Vector<Node*> > sorted_segment_all_nodes_pt(nsegments);
  
  // Associate and arclength to each node on each segment of the
  // boundary, the nodes and therefore the arclength come in the same
  // order as the face elements
  Vector<Vector<double> > sorted_segment_node_arclength(nsegments);
  
  // The arclength of each segment in the current processor
  Vector<double> segment_arclength(nsegments);
  
  // The number of vertices of each segment
  Vector<unsigned> nvertices_per_segment(nsegments);
  
  // The initial zeta for the segment
  Vector<double> initial_zeta_segment(nsegments);
  
  // The final zeta for the segment
  Vector<double> final_zeta_segment(nsegments);
  
  // Go through all the segments and compute the LOCAL boundary
  // coordinates
  for (unsigned is = 0; is < nsegments; is++)
   {
#ifdef PARANOID
    if (segment_sorted_ele_pt[is].size() == 0)
     {
      std::ostringstream error_message;
      error_message
       << "The (" << is << ")-th segment has no elements\n";
       throw OomphLibError(error_message.str(),
                           "TriangleMesh::re_assign_initial_zeta_values_for_internal_boundary()",
                           OOMPH_EXCEPTION_LOCATION);      
     } // if (segment_sorted_ele_pt[is].size() == 0)
#endif
    
    // Get access to the first element on the segment
    FiniteElement* first_ele_pt = segment_sorted_ele_pt[is].front();
    
    // Number of nodes
    const unsigned nnod = first_ele_pt->nnode();
    
    // Get the first node of the current segment
    Node *first_node_pt = first_ele_pt->node_pt(0);
    if (is_inverted[first_ele_pt])
     {
      first_node_pt = first_ele_pt->node_pt(nnod-1);
     }
    
    // Coordinates of left node
    double x_left = first_node_pt->x(0);
    double y_left = first_node_pt->x(1);
    
    // Initialise boundary coordinate (local boundary coordinate for
    // boundaries with more than one segment)
    Vector<double> zeta(1, 0.0);
    
    // If we have associated a GeomObject then it is not necessary
    // to compute the arclength, only read the values from the nodes at
    // the edges
    if (this->boundary_geom_object_pt(b)!=0)
     {
      first_node_pt->get_coordinates_on_boundary(b, zeta);
      initial_zeta_segment[is] = zeta[0];
      
      // Get access to the last element on the segment
      FiniteElement* last_ele_pt = segment_sorted_ele_pt[is].back();
      
      // Get the last node of the current segment
      Node *last_node_pt = last_ele_pt->node_pt(nnod-1);
      if (is_inverted[last_ele_pt])
       {
        last_node_pt = last_ele_pt->node_pt(0);
       }
      
      last_node_pt->get_coordinates_on_boundary(b, zeta);
      final_zeta_segment[is] = zeta[0];
     }
    
    // Sort the nodes in the segment (lexicographically bottom left
    // node)
    std::set<Node*> local_nodes_pt;
    local_nodes_pt.insert(first_node_pt);
    
    // Associate and arclength to the sorted nodes
    Vector<double> sorted_node_arclength;
    sorted_node_arclength.push_back(0.0);
    
    // Sorts the nodes in the segments according their sorting in the
    // face elements
    Vector<Node*> sorted_nodes_pt;
    sorted_nodes_pt.push_back(first_node_pt);
    
    // Now loop over nodes in order
    for (std::list<FiniteElement*>::iterator it = 
          segment_sorted_ele_pt[is].begin();
         it != segment_sorted_ele_pt[is].end(); it++)
     {
      // Get the face element
      FiniteElement* el_pt = *it;
      
      // Start node and increment
      unsigned k_nod = 1;
      int nod_diff = 1;
      if (is_inverted[el_pt])
       {
        k_nod = nnod - 2;
        nod_diff = -1;
       }
      
      // Loop over nodes
      for (unsigned j = 1; j < nnod; j++)
       {
        Node* nod_pt = el_pt->node_pt(k_nod);
        k_nod += nod_diff;
        
        // Coordinates of right node
        double x_right = nod_pt->x(0);
        double y_right = nod_pt->x(1);
        
        // Increment boundary coordinate
        zeta[0] += sqrt(
         (x_right - x_left) * (x_right - x_left) + (y_right - y_left)
         * (y_right - y_left));
        
        // When we have a GeomObject associated to the boundary we already
        // know the zeta values for the nodes, there is no need to compute
        // the arclength
        if (this->boundary_geom_object_pt(b)==0)
         {
          // Set boundary coordinate
//           nod_pt->set_coordinates_on_boundary(b, zeta);
         }
        
        // Increment reference coordinate
        x_left = x_right;
        y_left = y_right;
        
        // Get lexicographically bottom left node but only
        // use vertex nodes as candidates
        local_nodes_pt.insert(nod_pt);
        
        // Associate the arclength for the current node
        sorted_node_arclength.push_back(zeta[0]);
        
        // Store the node in the sorted nodes storage
        sorted_nodes_pt.push_back(nod_pt);
        
       } // for (j < nnod)
      
     } // iterator over the elements in the segment
    
    // Info. to be passed to the other processors
    // The initial arclength for the segment that goes after this depends
    // on the current segment arclength
    segment_arclength[is] = zeta[0];
    
    // Info. to be passed to the other processors
    // The initial vertex number for the segment that goes after this
    // depends on the current sement vertices number
    nvertices_per_segment[is] = local_nodes_pt.size();
    
    // Add the nodes for the corresponding segment in the container
    segment_all_nodes_pt[is] = local_nodes_pt;
    
    // Add the arclengths to the nodes in the segment
    sorted_segment_node_arclength[is] = sorted_node_arclength;
    
    // Add the sorted nodes to the storage
    sorted_segment_all_nodes_pt[is] = sorted_nodes_pt;
    
    // The attaching of the halo elements at both sides of the segments is
    // performed only if segments connectivity needs to be computed
    
   } // for (is < nsegments)
  
  // ------------------------------------------------------------------
  // Fourth: Now we have the segments sorted, with arclength and with
  // LOCAL boundary coordinates assigned to the nodes. Identify the
  // nodes on the segments with the input segments and re-assign all
  // the info. related with the identification of segments
  // ------------------------------------------------------------------
  
  // Get the number of segments for the old sorted segments
  const unsigned old_nsegments = old_segment_sorted_ele_pt.size();
  
  // ------------------------------------------------------------------
  // Copy the old info. in temporary storages
  Vector<unsigned> old_boundary_segment_inverted(old_nsegments);
  
  Vector<Vector<double> > 
   old_boundary_segment_initial_coordinate(old_nsegments);
  Vector<Vector<double> > 
   old_boundary_segment_final_coordinate(old_nsegments);
  
  Vector<double> old_boundary_segment_initial_zeta(old_nsegments);
  Vector<double> old_boundary_segment_final_zeta(old_nsegments);
  
  Vector<double> old_boundary_segment_initial_arclength(old_nsegments);
  Vector<double> old_boundary_segment_final_arclength(old_nsegments);
  
  // Back-up the information
  for (unsigned old_is = 0; old_is < old_nsegments; old_is++)
   {
    old_boundary_segment_inverted[old_is] = 
     boundary_segment_inverted(b)[old_is];
    
    old_boundary_segment_initial_coordinate[old_is].resize(2);
    old_boundary_segment_final_coordinate[old_is].resize(2);
    for (unsigned i = 0; i < 2; i++)
     {
      old_boundary_segment_initial_coordinate[old_is][i] = 
       boundary_segment_initial_coordinate(b)[old_is][i];
      
      old_boundary_segment_final_coordinate[old_is][i] = 
       boundary_segment_final_coordinate(b)[old_is][i];
     }
    
    // Check if the boundary has an associated GeomObject
    if (this->boundary_geom_object_pt(b)!=0)
     {
      old_boundary_segment_initial_zeta[old_is] = 
       boundary_segment_initial_zeta(b)[old_is];
      
      old_boundary_segment_final_zeta[old_is] = 
       boundary_segment_final_zeta(b)[old_is];
      
     } // if (this->boundary_geom_object_pt(b)!=0)
    else
     {
      old_boundary_segment_initial_arclength[old_is] = 
       boundary_segment_initial_arclength(b)[old_is];
      
      old_boundary_segment_final_arclength[old_is] = 
       boundary_segment_final_arclength(b)[old_is];
      
     } // else if (this->boundary_geom_object_pt(b)!=0)
    
   } // for (old_is < old_nsegments)
  
  // ------------------------------------------------------------------
  // Now clear the original storages
  Boundary_segment_inverted[b].clear();
  Boundary_segment_initial_coordinate[b].clear();
  Boundary_segment_final_coordinate[b].clear();
  
  Boundary_segment_initial_zeta[b].clear();
  Boundary_segment_final_zeta[b].clear();
  
  Boundary_segment_initial_arclength[b].clear();
  Boundary_segment_final_arclength[b].clear();
  // ------------------------------------------------------------------
  // .. and resize the storages for the new number of segments
  Boundary_segment_inverted[b].resize(nsegments);
  Boundary_segment_initial_coordinate[b].resize(nsegments);
  Boundary_segment_final_coordinate[b].resize(nsegments);
  
  // Check if the boundary has an associated GeomObject
  if (this->boundary_geom_object_pt(b)!=0)
   {
    Boundary_segment_initial_zeta[b].resize(nsegments);
    Boundary_segment_final_zeta[b].resize(nsegments);
   }
  else
   {
    Boundary_segment_initial_arclength[b].resize(nsegments);
    Boundary_segment_final_arclength[b].resize(nsegments);
   }
  // ------------------------------------------------------------------
  // map to know if the new segment has been re-assigned the info.
  std::map<unsigned, bool> done_segment;
  
  // Count the number of re-assigned segments with the new values
  unsigned re_assigned_segments = 0;
  
  // Go through all the old segments (the input segments)
  for (unsigned old_is = 0; old_is < old_nsegments; old_is++)
   {
    // Get the first and last zeta values for the current segment
    const double old_initial_arclength = 
     old_boundary_segment_initial_arclength[old_is];
    const double old_final_arclength = 
     old_boundary_segment_final_arclength[old_is];
    // Get the "is inverted" segment information
    const unsigned old_inverted_segment = 
     old_boundary_segment_inverted[old_is];
    
    // Check if the boundary coordinates in the segment go in
    // increasing or decreasing order
    bool old_increasing_order = false;
    if (old_initial_arclength < old_final_arclength)
     {old_increasing_order = true;}
    
    // Now get the first and last node of the current segment
    // Get the first element
    FiniteElement* first_old_seg_ele_pt = 
     old_segment_sorted_ele_pt[old_is].front();
    
    // Number of nodes
    const unsigned nnod = first_old_seg_ele_pt->nnode();
    
    // Get the first node of the current segment
    Node *first_old_seg_node_pt = first_old_seg_ele_pt->node_pt(0);
    if (old_is_inverted[first_old_seg_ele_pt])
     {
      first_old_seg_node_pt = first_old_seg_ele_pt->node_pt(nnod-1);
     }
    
    // Get access to the last element on the segment
    FiniteElement* last_old_seg_ele_pt = 
     old_segment_sorted_ele_pt[old_is].back();
    
    // Get the last node of the current segment
    Node *last_old_seg_node_pt = last_old_seg_ele_pt->node_pt(nnod-1);
    if (old_is_inverted[last_old_seg_ele_pt])
     {
      last_old_seg_node_pt = last_old_seg_ele_pt->node_pt(0);
     }
    // Check if the segment is inverted, if that is the case then
    // also invert the nodes
    if (old_inverted_segment)
     {
      Node* temp_node_pt = first_old_seg_node_pt;
      first_old_seg_node_pt = last_old_seg_node_pt;
      last_old_seg_node_pt = temp_node_pt;
     }
    
    // We have the first and last node of the old segment (input
    // segment), now identify in which segment, of those with only
    // nonhalo face elements, they are
    for (unsigned is = 0; is < nsegments; is++)
     {
      if (!done_segment[is])
       {
        // Go through the nodes of the current segment and try to find
        // the old nodes
        bool found_first_old_seg_node = false;
        bool found_last_old_seg_node = false;
        bool same_order = false;
        
        // Get the first node of the current segment
        FiniteElement* first_seg_ele_pt = segment_sorted_ele_pt[is].front();
        Node* first_seg_node_pt = first_seg_ele_pt->node_pt(0);
        if (is_inverted[first_seg_ele_pt])
         {first_seg_node_pt = first_seg_ele_pt->node_pt(nnod-1);}
        
        // Get the arclength for the first node
        const double segment_first_node_zeta = 
         sorted_segment_node_arclength[is][0];
        
        // Get the node coordinates for the first node
        Vector<double> first_node_coord(2);
        for (unsigned i = 0; i < 2; i++)
         {first_node_coord[i] = first_seg_node_pt->x(i);}
        
        // Get the last node of the current segment
        FiniteElement* last_seg_ele_pt = segment_sorted_ele_pt[is].back();
        Node* last_seg_node_pt = last_seg_ele_pt->node_pt(nnod-1);
        if (is_inverted[last_seg_ele_pt])
         {last_seg_node_pt = last_seg_ele_pt->node_pt(0);}
        
        // Get the arclength for the last node
        const double segment_final_node_zeta = segment_arclength[is];
        
        // Get the node coordinates for the last node
        Vector<double> last_node_coord(2);
        for (unsigned i = 0; i < 2; i++)
         {last_node_coord[i] = last_seg_node_pt->x(i);}
        
        // Temporary storage for the nodes of the current segment
        Vector<Node*> segment_node_pt = sorted_segment_all_nodes_pt[is];
        // Get the number of nodes in the segment
        const unsigned nsegment_node = segment_node_pt.size();
        for (unsigned in = 0; in < nsegment_node; in++)
         {
          Node* current_node_pt = segment_node_pt[in];
          if (!found_first_old_seg_node && 
              first_old_seg_node_pt == current_node_pt)
           {
            // Get the arclength assigned to the node on the old
            // segment
            const double current_node_zeta = 
             sorted_segment_node_arclength[is][in];
            
            // Now check if the new segment has the same orientation
            // as the old one
            if (!found_last_old_seg_node) // has the same orientation
             {
              // Re-assign the first node coordinates
              Boundary_segment_initial_coordinate[b][is] = first_node_coord;
              
              // Check if the boundary has an associated GeomObject
              if (this->boundary_geom_object_pt(b)!=0)
               {
                // Assign the zeta values if the current segment has the
                // nodes of the old one
                
                // If we are in the same order then pass the values as
                // they are
                Boundary_segment_initial_zeta[b][is] = 
                 initial_zeta_segment[is];
                
               } // if (this->boundary_geom_object_pt(b)!=0)
              else
               {
                // Get the distance to the first node
                const double distance = 
                 std::fabs(current_node_zeta - segment_first_node_zeta);
                
                double new_initial_arclength = old_initial_arclength;
                
                // Now check if the zeta values are in increasing order
                if (old_increasing_order)
                 {
                  // Substract the distance
                  new_initial_arclength-= distance;
                 }
                else
                 {
                  // Add the distance
                  new_initial_arclength+= distance;
                 }
                
                // Re-assign the initial arclength for the current segment
                Boundary_segment_initial_arclength[b][is] = 
                 new_initial_arclength;
                
               } // else if (this->boundary_geom_object_pt(b)!=0)
             } // if (!found_last_old_seg_node)
            else // has different orientation
             {
              // Re-assign the first node coordinates
              Boundary_segment_initial_coordinate[b][is] = last_node_coord;
              
              // Check if the boundary has an associated GeomObject
              if (this->boundary_geom_object_pt(b)!=0)
               {
                // Assign the zeta values if the current segment has the
                // nodes of the old one
                
                // Not the same order, we need to copy the zeta values
                // from the other end, the inverted flag is changed at
                // the end. Copy the value from the final end
                Boundary_segment_initial_zeta[b][is] = 
                 final_zeta_segment[is];
                
               } // if (this->boundary_geom_object_pt(b)!=0)
              else
               {
                // Get the distance to the final node
                const double distance = 
                 std::fabs(current_node_zeta - segment_final_node_zeta);
                
                double new_initial_arclength = old_initial_arclength;
                
                // Now check if the zeta values are in increasing order
                if (old_increasing_order)
                 {
                  // Substract the distance
                  new_initial_arclength-= distance;
                 }
                else
                 {
                  // Add the distance
                  new_initial_arclength+= distance;
                 }
                
                // Re-assign the initial arclength for the current segment
                Boundary_segment_initial_arclength[b][is] = 
                 new_initial_arclength;
                
               } // else if (this->boundary_geom_object_pt(b)!=0)
             } // else if (!found_last_old_seg_node)
            
            // Mark as found the first node
            found_first_old_seg_node = true;
            
           } 
             // if (!found_first_old_seg_node && 
             //     first_old_seg_node_pt == current_node_pt)
          
          // If we found first the first node then the segments have
          // the same order
          if (found_first_old_seg_node && !found_last_old_seg_node)
           {same_order = true;}
          
          if (!found_last_old_seg_node && 
              last_old_seg_node_pt == current_node_pt)
           {
            // Get the boundary coordinates assigned to the node on
            // the old segment
            const double current_node_zeta = 
             sorted_segment_node_arclength[is][in];
            
            // Now check if the new segment has the same orientation
            // as the old one
            if (found_first_old_seg_node) // has the same orientation
             {
              // Re-assign the last node coordinates
              Boundary_segment_final_coordinate[b][is] = last_node_coord;
              
              // Check if the boundary has an associated GeomObject
              if (this->boundary_geom_object_pt(b)!=0)
               {
                // Assign the zeta values if the current segment has the
                // nodes of the old one
                
                // If we are in the same order then pass the values as
                // they are
                Boundary_segment_final_zeta[b][is] = 
                 final_zeta_segment[is];
                
               } // if (this->boundary_geom_object_pt(b)!=0)
              else
               {
                // Get the distance to the last node
                const double distance = 
                 std::fabs(current_node_zeta - segment_final_node_zeta);
                
                double new_final_arclength = old_final_arclength;
                
                // Now check if the zeta values are in increasing order
                if (old_increasing_order)
                 {
                  // Add the distance
                  new_final_arclength+= distance;
                 }
                else
                 {
                  // Substract the distance
                  new_final_arclength-= distance;
                 }
                
                // Re-assign the final arclength for the current segment
                Boundary_segment_final_arclength[b][is] = new_final_arclength;
                
               } // else if (this->boundary_geom_object_pt(b)!=0)
             } // if (found_first_old_seg_node)
            else
             {
              // Re-assign the last node coordinates
              Boundary_segment_final_coordinate[b][is] = first_node_coord;
              
              // Check if the boundary has an associated GeomObject
              if (this->boundary_geom_object_pt(b)!=0)
               {
                // Assign the zeta values if the current segment has the
                // nodes of the old one
                
                // Not the same order, we need to copy the zeta values
                // from the other end, the inverted flag is changed at
                // the end. Copy the value from the initial end
                Boundary_segment_final_zeta[b][is] = 
                 initial_zeta_segment[is];
                
               } // if (this->boundary_geom_object_pt(b)!=0)
              else
               {
                // Get the distance to the last node
                const double distance = 
                 std::fabs(current_node_zeta - segment_first_node_zeta);
                
                double new_final_arclength = old_final_arclength;
                
                // Now check if the zeta values are in increasing order
                if (old_increasing_order)
                 {
                  // Add the distance
                  new_final_arclength+= distance;
                 }
                else
                 {
                  // Substract the distance
                  new_final_arclength-= distance;
                 }
                
                // Re-assign the final arclength for the current segment
                Boundary_segment_final_arclength[b][is] = new_final_arclength;
                
               } // else if (this->boundary_geom_object_pt(b)!=0)
             } // if (found_first_old_seg_node)
            
            // Mark as found the last node
            found_last_old_seg_node = true;
            
           } // if (!found_last_old_seg_node && 
             //     last_old_seg_node_pt == current_node_pt)
          
          // If we found the last node first then the segments have
          // not the same order
          if (!found_first_old_seg_node && found_last_old_seg_node)
           {same_order = false;}
          
          if (found_first_old_seg_node && found_last_old_seg_node)
           {
            // Check if necessary to change the information that
            // states if a segment is inverted or not
            if (same_order)
             {Boundary_segment_inverted[b][is] = old_inverted_segment;}
            else
             {Boundary_segment_inverted[b][is] = !old_inverted_segment;}
            
            // Mark the segment as done
            done_segment[is] = true;
            
            // Increase the number of re-assigned segments
            re_assigned_segments++;
            
            // Break the for that look for the nodes in the segments
            break;
           }
          
         } // for (in < nsegment_node)
        
#ifdef PARANOID
        if ((found_first_old_seg_node && !found_last_old_seg_node) ||
            (!found_first_old_seg_node && found_last_old_seg_node))
         {
          std::stringstream error_message;
          error_message
           << "Working with boundary ("<< b << ").\nOnly the first node or "
           << "the last node of the old segment (" << old_is << ") was\n"
           << "found. Both, first and last node should have been found in "
           << "the same segment!!!.\n"
           << "Found first seg node:" << found_first_old_seg_node << "\n"
           << "Found last seg node:" << found_last_old_seg_node << "\n\n";
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::re_assign_initial_zeta_values_for_internal_boundary()",
                              OOMPH_EXCEPTION_LOCATION);
         }
#endif
        
       } // if (!done_segment[is])
     } // for (is < nsegments)
   } // for (old_is < old_nsegments)
  
  // For those segments not identified set dummy values, the boundary
  // coordinates should be corrected at the synchronisation stage
  
  // loop over the new segments and check if there not identified
  // segments
  for (unsigned is = 0; is < nsegments; is++)
    {
      // Was the segment identified
      if (!done_segment[is])
        {
          // Get the first node of the current segment
          FiniteElement* first_seg_ele_pt = 
            segment_sorted_ele_pt[is].front();
          // Number of nodes
          const unsigned nnod = first_seg_ele_pt->nnode();
          
          Node* first_seg_node_pt = first_seg_ele_pt->node_pt(0);
          if (is_inverted[first_seg_ele_pt])
            {first_seg_node_pt = first_seg_ele_pt->node_pt(nnod-1);}
          
          // Get the arclength for the first node
          const double segment_first_node_zeta = 
            sorted_segment_node_arclength[is][0];
          
          // Get the node coordinates for the first node
          Vector<double> first_node_coord(2);
          for (unsigned i = 0; i < 2; i++)
            {first_node_coord[i] = first_seg_node_pt->x(i);}
          
          // Get the last node of the current segment
          FiniteElement* last_seg_ele_pt = 
            segment_sorted_ele_pt[is].back();
          Node* last_seg_node_pt = last_seg_ele_pt->node_pt(nnod-1);
          if (is_inverted[last_seg_ele_pt])
            {last_seg_node_pt = last_seg_ele_pt->node_pt(0);}
          
          // Get the arclength for the last node
          const double segment_final_node_zeta = segment_arclength[is];
          
          // Get the node coordinates for the last node
          Vector<double> last_node_coord(2);
          for (unsigned i = 0; i < 2; i++)
            {last_node_coord[i] = last_seg_node_pt->x(i);}
          
          // Re-assign the initial node coordinates
          Boundary_segment_initial_coordinate[b][is] = first_node_coord;
          
          // Check if the boundary has an associated GeomObject
          if (this->boundary_geom_object_pt(b)!=0)
            {
              // Assign the zeta values if the current segment has the
              // nodes of the old one
              
              // If we are in the same order then pass the values as
              // they are
              Boundary_segment_initial_zeta[b][is] = 
                initial_zeta_segment[is];
              
            } // if (this->boundary_geom_object_pt(b)!=0)
          else
            {
              // Re-assign the initial arclength for the current segment
              Boundary_segment_initial_arclength[b][is] = 
                segment_first_node_zeta;
              
            } // else if (this->boundary_geom_object_pt(b)!=0)
          
          // Re-assign the initial node coordinates
          Boundary_segment_final_coordinate[b][is] = last_node_coord;
          
          // Check if the boundary has an associated GeomObject
          if (this->boundary_geom_object_pt(b)!=0)
            {
              // Assign the zeta values if the current segment has the
              // nodes of the old one
              
              // If we are in the same order then pass the values as
              // they are
              Boundary_segment_final_zeta[b][is] = 
                final_zeta_segment[is];
              
            } // if (this->boundary_geom_object_pt(b)!=0)
          else
            {               
              // Re-assign the final arclength for the current segment
              Boundary_segment_final_arclength[b][is] = 
                segment_final_node_zeta;
              
            } // else if (this->boundary_geom_object_pt(b)!=0)
          
          Boundary_segment_inverted[b][is] = 0;
          
          // Mark the segment as done
          done_segment[is] = true;
          
          // Increase the number of re-assigned segments
          re_assigned_segments++;

        } // if (!done_segment[is])

    } // for (is < nsegments)
  
#ifdef PARANOID
  // Compare the number of new segments identified with the old segments
  if (re_assigned_segments != nsegments)
   {
    std::stringstream error_message;
    error_message
     << "Working with boundary ("<< b << ").\nThe number of re-assigned "
     << "segments (" << re_assigned_segments
     << ") is different from the number\nof segments ("<< nsegments 
     << ")\n\n";
    throw OomphLibError(error_message.str(),
                        "TriangleMesh::re_assign_initial_zeta_values_for_internal_boundary()",
                        OOMPH_EXCEPTION_LOCATION);    
   } // if (re_assigned_segments != nsegments)
#endif
  
  // Clean all the created face elements
  for (unsigned i = 0; i < nele; i++)
   {
    delete face_el_pt[i];
    face_el_pt[i] = 0;
   }
  
 }
  
 ///=====================================================================
 /// Select face elements from a given boundary. In case the we are
 /// dealing with an internal boundary we use a set of criterias to
 /// decide which of the two face elements should be used on represent
 /// the internal boundary. We return the face elements, halo or
 /// haloed on this processor that form the boundary. The caller method
 /// should be in charge of selecting nonhalo elements and deleting the face
 /// elements created by this method
 /// =====================================================================
 template <class ELEMENT>
 void TriangleMesh<ELEMENT>::
 select_boundary_face_elements(Vector<FiniteElement*> &face_ele_pt,
                               const unsigned &b,
                               bool &is_internal_boundary,
                               std::map<FiniteElement*,FiniteElement*> 
                               &face_to_bulk_element_pt)
 {
   // Get the communicator of the mesh
   OomphCommunicator* comm_pt = this->communicator_pt();
   
   const unsigned my_rank = comm_pt->my_rank();
   
   // ------------------------------------------------------------------
   // 1) Get the face elements associated with the current boundary
   // ------------------------------------------------------------------
   
   // Temporary storage for face elements (do not take care of
   // repeated face elements)
   Vector<FiniteElement*> tmp_face_ele_pt;
   
   const unsigned nregions = this->nregion();
   
   // If there is more than one region then only use boundary
   // coordinates from the bulk side (region 0)
   if (nregions > 1)
     {
       for (unsigned ir = 0 ; ir < nregions; ir++)
         {
           const unsigned region_id = 
             static_cast<unsigned>(this->Region_attribute[ir]);
           
           // Loop over all elements on boundaries in region -ir-
           const unsigned nele_in_region = 
             this->nboundary_element_in_region(b, region_id);
           
           // Only bother to do anything else, if there are elements
           // associated with the boundary and the current region
           if (nele_in_region > 0)
             {
               // Loop over the bulk elements adjacent to boundary b
               for (unsigned e = 0; e < nele_in_region; e++)
                 {
                   // Get pointer to the bulk element that is adjacent
                   // to boundary b
                   FiniteElement* bulk_ele_pt = 
                     this->boundary_element_in_region_pt(b, region_id, e);
                   
                   // Get the index of the face of element e along
                   // boundary b
                   int face_index = 
                     this->face_index_at_boundary_in_region(b,region_id,e);
                   
                   // Create the face element
                   FiniteElement* tmp_face_el_pt = 
                     new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);
                   
                   // Associated the face element with the bulk
                   face_to_bulk_element_pt[tmp_face_el_pt] = bulk_ele_pt;
                   
                   // ... and add it to the tmp storage for all the
                   // face elements, do not take care for repeated
                   // ones (at the moment)
                   tmp_face_ele_pt.push_back(tmp_face_el_pt);
                   
                 } // for (e < nele_in_region)
               
             } // if (nele_in_region > 0)
           
         } // for (ir < n_regions)
       
     } // if (n_regions > 1)
   
   //Otherwise it's just the normal boundary functions
   else
     {
       // Loop over all elements on boundaries
       const unsigned nbound_ele = this->nboundary_element(b);
       
       //Only bother to do anything else, if there are elements
       if (nbound_ele > 0)
         {
           // Loop over the bulk elements adjacent to boundary b
           for (unsigned e = 0; e < nbound_ele; e++)
             {
               // Get pointer to the bulk element that is adjacent to
               // boundary b
               FiniteElement* bulk_ele_pt = this->boundary_element_pt(b, e);
               
               // Get the index of the face of element e along
               // boundary b
               int face_index = this->face_index_at_boundary(b, e);
               
               // Create the face element
               FiniteElement* tmp_face_el_pt = 
                 new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);
               
               // Associated the face element with the bulk
               face_to_bulk_element_pt[tmp_face_el_pt] = bulk_ele_pt;
               
               // ... and add it to the tmp storage for all the face
               // elements, do not care for repeated ones (at the
               // moment)
               tmp_face_ele_pt.push_back(tmp_face_el_pt);
               
             } // (e < nbound_ele)
           
         } // (nbound_ele > 0)
       
     } // else (n_regions > 1)
   
   // map to know which face element has been already done
   std::map<FiniteElement*,bool> done_face;
   
   // Set the flag to indicate if we are working with an internal
   // boundary
   is_internal_boundary = false;
   
   // Free the memory of the elements in this container (only used
   // when working with internal boundaries)
   Vector<FiniteElement*> free_memory_face_ele_pt;
   
   // Get the number of face elements in the boundary (including
   // repeated)
   const unsigned n_tmp_face_ele = tmp_face_ele_pt.size();
   for (unsigned ie = 0; ie < n_tmp_face_ele; ie++)
     {
       // Get the possible main element
       FiniteElement* main_face_ele_pt = tmp_face_ele_pt[ie];
       if (!done_face[main_face_ele_pt])
         {
           // Mark the face element as done
           done_face[main_face_ele_pt] = true;
           // Get the number of nodes for the face element
           const unsigned nnodes = main_face_ele_pt->nnode(); 
           // Get the first and last node of the main face element
           Node* main_first_node_pt = main_face_ele_pt->node_pt(0);
           Node* main_last_node_pt = main_face_ele_pt->node_pt(nnodes-1);
           // Look for the other side face element (we can start from
           // the next one, all previous face elements have been
           // already identified with its other side face)
           for (unsigned iie = ie + 1; iie < n_tmp_face_ele; iie++)
             {
               // Get the possible dependant element
               FiniteElement* dependant_face_ele_pt = tmp_face_ele_pt[iie];
               if (!done_face[dependant_face_ele_pt])
                 {
                   // Get the first and last node of the dependant
                   // face element
                   Node* dependant_first_node_pt = 
                     dependant_face_ele_pt->node_pt(0);
                   Node* dependant_last_node_pt = 
                     dependant_face_ele_pt->node_pt(nnodes-1);
                   // Check if the nodes at the ends of both face
                   // elements match (also check the reversed case)
                   if (((dependant_first_node_pt == main_first_node_pt) &&
                        (dependant_last_node_pt == main_last_node_pt)) ||
                       ((dependant_first_node_pt == main_last_node_pt) &&
                        (dependant_last_node_pt == main_first_node_pt)))
                     {
                       // Set the flag to indicate we are working with an
                       // internal boundary
                       is_internal_boundary = true;
                       // Mark the face element as done
                       done_face[dependant_face_ele_pt] = true;
                       
                       // Now choose which face element will be used
                       // as the main element. We get the processor in
                       // charge of the element and choose the one
                       // with the highest processor in charge or the
                       // bottom-left bulk element in case the both
                       // faces are on the same processor
                       
                       // Get the bulk element for each face element
                       // (the main and the dependant face element)
                       FiniteElement *main_bulk_ele_pt = 
                         face_to_bulk_element_pt[main_face_ele_pt];
                       FiniteElement *dependant_bulk_ele_pt = 
                         face_to_bulk_element_pt[dependant_face_ele_pt];
                       
                       // Get the processor in charge for each bulk
                       // element
                       int processor_in_charge_main_bulk_ele = 
                         main_bulk_ele_pt->non_halo_proc_ID();
                       int processor_in_charge_dependant_bulk_ele = 
                         dependant_bulk_ele_pt->non_halo_proc_ID();
                       
                       // If the processor in charge is negative the
                       // element is not halo, therefore the processor
                       // in charge is the current one
                       if (processor_in_charge_main_bulk_ele < 0)
                         {
                           processor_in_charge_main_bulk_ele=
                             static_cast<int>(my_rank);
                         }
                       if (processor_in_charge_dependant_bulk_ele < 0)
                         {
                           processor_in_charge_dependant_bulk_ele=
                             static_cast<int>(my_rank);
                         }
                       
                       // Flag to know if add the main or dependant
                       // face element
                       bool add_main_face_element = true;
                       if (processor_in_charge_dependant_bulk_ele > 
                           processor_in_charge_main_bulk_ele)
                         {
                           // Include the dependant element
                           add_main_face_element = false;
                         }
                       else if (processor_in_charge_main_bulk_ele == 
                                processor_in_charge_dependant_bulk_ele)
                         {
                           // When the processor in charge for both
                           // elements is the same then use the
                           // bottom-left criteria on the bulk
                           // elements to choose the main face element
                           Vector<double> main_ele_coordinates(2);
                           Vector<double> dependant_ele_coordinates(2);
                           // Get the number of nodes on the bulk
                           // elements
                           const unsigned n_bulk_nodes = 
                             main_bulk_ele_pt->nnode();
                           for (unsigned inode = 0; inode < n_bulk_nodes; 
                                inode++)
                             {
                               for (unsigned idim = 0; idim < 2; idim++)
                                 {
                                   main_ele_coordinates[idim]+=
                                     main_bulk_ele_pt->node_pt(inode)->
                                     x(idim);
                                   dependant_ele_coordinates[idim]+=
                                     dependant_bulk_ele_pt->node_pt(inode)->
                                     x(idim);
                                 } // (idim < 2)
                               
                             } // (inode < n_bulk_nodes)
                           
                           // Get the average of the nodes coordinates
                           for (unsigned idim = 0; idim < 2; idim++)
                             {
                               main_ele_coordinates[idim]/=
                                 (double)n_bulk_nodes;
                               dependant_ele_coordinates[idim]/=
                                 (double)n_bulk_nodes;
                             }
                           
                           // Once we know the average coordinates for
                           // each element then we choose the one with
                           // the bottom-left averaged coordinates
                           if (dependant_ele_coordinates[1] < 
                               main_ele_coordinates[1])
                             {add_main_face_element = false;}
                           else if(dependant_ele_coordinates[1]==
                                   main_ele_coordinates[1])
                             {
                               // The left-most element
                               if(dependant_ele_coordinates[0] < 
                                  main_ele_coordinates[0])
                                 {add_main_face_element = false;}
                             }
                         } // else -- The processor in charge is the
                           // same for both elements
                       
                       if (add_main_face_element)
                         {
                           // Add the main face element to the storage
                           // so we get the halo and haloed nodes from
                           // it
                           face_ele_pt.push_back(main_face_ele_pt);
                           // Mark the dependat face element to free
                           // its memory
                           free_memory_face_ele_pt.
                             push_back(dependant_face_ele_pt);
                         }
                       else
                         {
                           // Add the dependant face element to the
                           // storage so we get the halo and haloed
                           // nodes from it
                           face_ele_pt.push_back(dependant_face_ele_pt);
                           // Mark the main face element to free its
                           // memory
                           free_memory_face_ele_pt.
                             push_back(main_face_ele_pt);
                         }
                       
                       // Break the for to look for the next face
                       // element
                       break;
                       
                     } // if -- matching of nodes from main ele and
                       // dependant ele
                   
                 } // if (!done_face[dependant_face_ele_pt])
               
             } // for (iie < n_tmp_face_ele)
           
         } // if (!done_face[main_face_ele_pt])
       
     } // for (ie < n_tmp_face_ele)
   
   // Are there any face element to free its memory
   const unsigned n_free_face_ele = free_memory_face_ele_pt.size();
   if (n_free_face_ele == 0)
     {
       // If there is not face elements to free memory that means that
       // we are not working with an internal boundary, therefore copy
       // all the element from the tmp face elements into the face
       // elements container
       
       // Resize the container
       face_ele_pt.resize(n_tmp_face_ele);
       // loop over the elements and copy them
       for (unsigned i = 0; i < n_tmp_face_ele; i++)
         {
           face_ele_pt[i] = tmp_face_ele_pt[i];
         } // for (i < n_tmp_face_ele)
              
     } // if (n_free_face_ele == 0)
   else
     {
       // ... otherwise free the memory of the indicated elements
       // loop over the elements to free its memory
       for (unsigned i = 0; i < n_free_face_ele; i++)
         {
           delete free_memory_face_ele_pt[i];
           free_memory_face_ele_pt[i] = 0;
         } // for (i < n_free_face_ele)
     }
   
 }
 
 ///========================================================================
 /// In charge of sinchronize the boundary coordinates for internal
 /// boundaries that were split as part of the distribution
 /// process. Called after setup_boundary_coordinates() for the
 /// original mesh only
 ///========================================================================
 template <class ELEMENT>
 void TriangleMesh<ELEMENT>::
 synchronize_boundary_coordinates(const unsigned& b)
 {
  // ------------------------------------------------------------------
  // First: Get the face elements associated with the current boundary
  // ------------------------------------------------------------------
  
  // Get the communicator of the mesh
  OomphCommunicator* comm_pt = this->communicator_pt();
  
  const unsigned nproc = comm_pt->nproc();
  const unsigned my_rank = comm_pt->my_rank();
  
  // Temporary storage for face elements (do not take care of repeated
  // face elements)
  Vector<FiniteElement*> tmp_face_ele_pt;
  
  const unsigned nregions = this->nregion();
  
  // map to associate the face element to the bulk element, necessary
  // to get the processor in charge for the halo elements
  std::map<FiniteElement*,FiniteElement*> face_to_bulk_element_pt;
  
  // If there is more than one region then only use boundary
  // coordinates from the bulk side (region 0)
  if (nregions > 1)
   {
    for (unsigned ir = 0 ; ir < nregions; ir++)
     {
      const unsigned region_id = 
       static_cast<unsigned>(this->Region_attribute[ir]);
      
      // Loop over all elements on boundaries in region -ir-
      const unsigned nele_in_region = 
       this->nboundary_element_in_region(b, region_id);
      
      // Only bother to do anything else, if there are elements
      // associated with the boundary and the current region
      if (nele_in_region > 0)
       {
        // Loop over the bulk elements adjacent to boundary b
        for (unsigned e = 0; e < nele_in_region; e++)
         {
          // Get pointer to the bulk element that is adjacent to boundary b
          FiniteElement* bulk_ele_pt = 
           this->boundary_element_in_region_pt(b, region_id, e);
          
          // Get the index of the face of element e along boundary b
          int face_index=this->face_index_at_boundary_in_region(b,region_id,e);
          
          // Create the face element
          FiniteElement* tmp_face_el_pt = 
           new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);
          
          // ... and add it to the tmp storage for all the face
          // elements, do not take care for repeated ones (at the
          // moment)
          tmp_face_ele_pt.push_back(tmp_face_el_pt);
          // Create the map to know if the element is halo
          face_to_bulk_element_pt[tmp_face_el_pt] = bulk_ele_pt;
          
         } // for (e < nele_in_region)
        
       } // if (nele_in_region > 0)
      
     } // for (ir < n_regions)
    
   } // if (n_regions > 1)
  
  //Otherwise it's just the normal boundary functions
  else
   {
    // Loop over all elements on boundaries
    const unsigned nbound_ele = this->nboundary_element(b);
    
    //Only bother to do anything else, if there are elements
    if (nbound_ele > 0)
     {
      // Loop over the bulk elements adjacent to boundary b
      for (unsigned e = 0; e < nbound_ele; e++)
       {
        // Get pointer to the bulk element that is adjacent to boundary b
        FiniteElement* bulk_ele_pt = this->boundary_element_pt(b, e);
        
        // Get the index of the face of element e along boundary b
        int face_index = this->face_index_at_boundary(b, e);
        
        // Create the face element
        FiniteElement* tmp_face_el_pt = 
         new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);
        
        // ... and add it to the tmp storage for all the face
        // elements, do not care for repeated ones (at the moment)
        tmp_face_ele_pt.push_back(tmp_face_el_pt);
        // Create the map to know if the element is halo
        face_to_bulk_element_pt[tmp_face_el_pt] = bulk_ele_pt;
        
       } // (e < nbound_ele)
      
     } // (nbound_ele > 0)
    
   } // else (n_regions > 1)
  
  // Temporary storage for one side face elements. In case we are
  // working with an internal boundary here we store only one of the
  // face elements that are at each side of the boundary
  Vector<FiniteElement*> face_ele_pt;
  
  // map to know which face element has been already done
  std::map<FiniteElement*,bool> done_face;
  
  // Flag to indicate if we are working with an internal boundary
  bool is_internal_boundary = false;
  
#ifdef PARANOID
  // Flag to indicate if we are working with an internal boundary (paranoid)
  bool is_internal_boundary_paranoid = false;
  
  // Count the number of other side face elements found in case we are
  // working with an internal boundary
  unsigned nfound_face_elements = 0;
#endif
  
  // Get the number of face elements in the boundary
  const unsigned nbound_ele = tmp_face_ele_pt.size();
  for (unsigned ie = 0; ie < nbound_ele; ie++)
   {
    // Get the possible main element
    FiniteElement* main_face_ele_pt = tmp_face_ele_pt[ie];
    if (!done_face[main_face_ele_pt])
     {
      // Mark the face element as done
      done_face[main_face_ele_pt] = true;
      // Get the number of nodes for the face element
      const unsigned nnodes = main_face_ele_pt->nnode(); 
      // Get the first and last node of the main face element
      Node* main_first_node_pt = main_face_ele_pt->node_pt(0);
      Node* main_last_node_pt = main_face_ele_pt->node_pt(nnodes-1);
      // Look for the other side face element
      for (unsigned iie = ie + 1; iie < nbound_ele; iie++)
       {
        // Get the possible dependant element
        FiniteElement* dependant_face_ele_pt = tmp_face_ele_pt[iie];
        if (!done_face[dependant_face_ele_pt])
         {
          // Get the first and last node of the dependant face element
          Node* dependant_first_node_pt = 
           dependant_face_ele_pt->node_pt(0);
          Node* dependant_last_node_pt = 
           dependant_face_ele_pt->node_pt(nnodes-1);
          // Check if the nodes at the ends of both face elements
          // match (also check the reversed case)
          if (((dependant_first_node_pt == main_first_node_pt) &&
               (dependant_last_node_pt == main_last_node_pt)) ||
              ((dependant_first_node_pt == main_last_node_pt) &&
               (dependant_last_node_pt == main_first_node_pt)))
           {
#ifdef PARANOID
            // Increase the number of found face elements
            nfound_face_elements+=2;
#endif
            // Set the flag to indicate we are working with an
            // internal boundary
            is_internal_boundary = true;
            // Mark the face element as done
            done_face[dependant_face_ele_pt] = true;
            
            // Now choose which face element will be used as the main
            // element. Use the same criteria as the compute segments
            // connectivity method (highest processor in charge or
            // bottom-left bulk element)
            
            // Get the bulk element for each face element (the main
            // and the dependant face element)
            FiniteElement *main_bulk_ele_pt = 
             face_to_bulk_element_pt[main_face_ele_pt];
            FiniteElement *dependant_bulk_ele_pt = 
             face_to_bulk_element_pt[dependant_face_ele_pt];
            
            // Get the processor in charge for each bulk element
            int processor_in_charge_main_bulk_ele = 
             main_bulk_ele_pt->non_halo_proc_ID();
            int processor_in_charge_dependant_bulk_ele = 
             dependant_bulk_ele_pt->non_halo_proc_ID();
            
            // If the processor in charge is negative the element is
            // not halo, therefore the processor in charge is the
            // current one
            if (processor_in_charge_main_bulk_ele < 0)
             {
              processor_in_charge_main_bulk_ele=static_cast<int>(my_rank);
             }
            if (processor_in_charge_dependant_bulk_ele < 0)
             {
              processor_in_charge_dependant_bulk_ele=static_cast<int>(my_rank);
             }
            
            // Flag to know if add the main or dependant face element
            bool add_main_face_element = true;
            if (processor_in_charge_dependant_bulk_ele > 
                processor_in_charge_main_bulk_ele)
             {
              // Include the dependant element
              add_main_face_element = false;
             }
            else if (processor_in_charge_main_bulk_ele == 
                     processor_in_charge_dependant_bulk_ele)
             {
              // When the processor in charge for both elements is the same
              // then use the bottom-left criteria on the bulk elements to
              // choose the main face element
              Vector<double> main_ele_coordinates(2);
              Vector<double> dependant_ele_coordinates(2);
              // Get the number of nodes on the bulk elements
              const unsigned n_bulk_nodes = main_bulk_ele_pt->nnode();
              for (unsigned inode = 0; inode < n_bulk_nodes; inode++)
               {
                for (unsigned idim = 0; idim < 2; idim++)
                 {
                  main_ele_coordinates[idim]+=
                   main_bulk_ele_pt->node_pt(inode)->x(idim);
                  dependant_ele_coordinates[idim]+=
                   dependant_bulk_ele_pt->node_pt(inode)->x(idim);
                 } // (idim < 2)
               } // (inode < n_bulk_nodes)
              
              // Get the average of the nodes coordinates
              for (unsigned idim = 0; idim < 2; idim++)
               {
                main_ele_coordinates[idim]/=(double)n_bulk_nodes;
                dependant_ele_coordinates[idim]/=(double)n_bulk_nodes;
               }
              
              // Once we know the average coordinates for each element 
              // then we choose the one with the bottom-left averaged 
              // coordinates
              if (dependant_ele_coordinates[1] < main_ele_coordinates[1])
               {add_main_face_element = false;}
              else if(dependant_ele_coordinates[1]==main_ele_coordinates[1])
               {
                // The left-most element
                if(dependant_ele_coordinates[0] < main_ele_coordinates[0])
                 {add_main_face_element = false;}
               }
             } // else -- The processor in charge is the same for both 
               //         elements
            
            if (add_main_face_element)
             {
              // Add the main face element to the storage so we get
              // the halo and haloed nodes from these face element
              face_ele_pt.push_back(main_face_ele_pt);
             }
            else
             {
              // Add the main face element to the storage so we get
              // the halo and haloed nodes from these face element
              face_ele_pt.push_back(dependant_face_ele_pt);
             }
            
            // Break the for to look for the next face element
            break;
            
           } // if -- matching of nodes from main ele and dependant ele
         } // if (!done_face[dependant_face_ele_pt])
       } // for (iie < nbound_ele)
     } // if (!done_face[main_face_ele_pt])
   } // for (ie < nbound_ele)
  
  // Get the number of face elements
  const unsigned nface_ele = face_ele_pt.size();
  
#ifdef PARANOID
  // Check if we are working with an internal open curve. First check
  // if there are elements, in a distributed approach they may be no
  // elements associated to the boundary
  if (nbound_ele > 0 && nfound_face_elements == nbound_ele)
   {is_internal_boundary_paranoid = true;}
  
  if (nbound_ele > 0 && is_internal_boundary_paranoid && 
      nbound_ele!=nface_ele*2)
   {
    std::ostringstream error_message;
    error_message
     << "The info. to perform the synchronisation of the boundary "
     << "coordinates was not completely established\n"
     << "In this case it was the number of non repeated boundary elements\n"
     << "Number of boundary elements: (" << nbound_ele << ")\n"
     << "Number of nonrepeated boundary elements: (" << nface_ele << ")\n";
    throw OomphLibError(error_message.str(),
                        "TriangleMesh::synchronize_boundary_coordinates()",
                        OOMPH_EXCEPTION_LOCATION);
   }    
#endif
  
  // ----------------------------------------------------------------
  // Second: Identify the halo face elements
  // ----------------------------------------------------------------
  
  // A flag vector to mark those face elements that are considered as
  // halo in the current processor
  std::vector<bool> is_halo_face_element(nface_ele, false);
  
  // Count the total number of non halo face elements
  unsigned nnon_halo_face_elements = 0;
  
  for (unsigned ie = 0; ie < nface_ele; ie++)
   {
    FiniteElement* face_el_pt = face_ele_pt[ie];
    // Get the bulk element
    FiniteElement* tmp_bulk_ele_pt = face_to_bulk_element_pt[face_el_pt];
    // Check if the bulk element is halo
    if (!tmp_bulk_ele_pt->is_halo())
     {
      is_halo_face_element[ie] = false;
      nnon_halo_face_elements++;
     }
    else
     {
      // Mark the face element as halo
      is_halo_face_element[ie] = true;
     }
   } // for (ie < nface_ele)
  
  // -----------------------------------------------------------------
  // Third: Go through the face elements and get the nodes from the
  // elements. The boundary coordinate from each node is sent to its
  // processor in charge, then that processor will be responsible to
  // send the bound coordinate to all the processors that have a halo
  // representation of the node
  // -----------------------------------------------------------------
  
  // A map to know which nodes are already done
  std::map<Node*,bool> done_node;
  
  // The storage for the halo nodes on face elements in this processor
  // with other processors
  Vector<Vector<Node*> > face_halo_node_pt(nproc);
  
  // The storage for the ids of the halo nodes on face elements in
  // this processor with other processors
  Vector<Vector<unsigned> > face_halo_node_id(nproc);
  
  // The storage for the haloed nodes on face elements in this
  // processor with other processors
  Vector<Vector<Node*> > face_haloed_node_pt(nproc);
  
  // The storage for the ids of the haloed nodes on face elements in
  // this processor with other processors
  Vector<Vector<unsigned> > face_haloed_node_id(nproc);
  
  // A map to know which nodes are face nodes and the processor in
  // charge is the current one
  std::map<Node*,bool> done_haloed_face_node;
  
  // Go through all the face elements
  for (unsigned iface = 0; iface < nface_ele; iface++)
   {
    // Only work with the non halo face elements
    if (!is_halo_face_element[iface])
     {
      // Get the face element
      FiniteElement *ele_face_pt = face_ele_pt[iface];
      // The number of nodes of the face elements
      const unsigned nnodes = ele_face_pt->nnode();
      // Go through all the nodes in the face element
      for (unsigned in = 0; in < nnodes; in++)
       {
        Node* face_node_pt = ele_face_pt->node_pt(in);
        // Check if node is done
        if (!done_node[face_node_pt])
         {
          // Mark the node as done
          done_node[face_node_pt] = true;
          // First check if the node is halo
          if (face_node_pt->is_halo())
           {
            // Get the processor in charge for the current node
            int int_nonhalo_ID = face_node_pt->non_halo_proc_ID();
#ifdef PARANOID
            if (int_nonhalo_ID < 0)
             {
              std::ostringstream error_message;
              error_message
               << "The node was marked to be halo but the processor in "
               << "charge was found to be -1\n\n";
              throw OomphLibError(error_message.str(),
                       "TriangleMesh::synchronize_boundary_coordinates()",
                                  OOMPH_EXCEPTION_LOCATION);
             }
#endif
            const unsigned ip = static_cast<unsigned>(int_nonhalo_ID);
            // Add the node to the structure that holds the halo
            // nodes, the current processor will need to send the
            // info. to the processor in charge.
            face_halo_node_pt[ip].push_back(face_node_pt);
            // ... finally look for the halo id with the processor in
            // charge
#ifdef PARANOID
            bool found_halo_node = false;
#endif
            const unsigned nhalo_iproc = this->nhalo_node(ip);
            for (unsigned ihn = 0; ihn < nhalo_iproc; ihn++)
             {
              Node* compare_face_node_pt = this->halo_node_pt(ip, ihn);
              if (compare_face_node_pt == face_node_pt)
               {
                // Once found the id of the node with the processor
                // store the id in the proper storage
                face_halo_node_id[ip].push_back(ihn);
#ifdef PARANOID
                // Set the flag to mark as found the halo node
                found_halo_node = true;
#endif
                // Break the loop
                break;
               }
             } // for (ih < nhalo_iproc)
#ifdef PARANOID
            if (!found_halo_node)
             {
              std::ostringstream error_message;
              error_message
               << "The halo id of the current node: (" 
               << face_node_pt->x(0) << ", " << face_node_pt->x(1) 
               << ") with processor (" << ip << ") was not found!!!\n\n";
              throw OomphLibError(error_message.str(),
                       "TriangleMesh::synchronize_boundary_coordinates()",
                                  OOMPH_EXCEPTION_LOCATION);
             }
#endif
           } // if (face_node_pt->is_halo())
          // If the node is not halo then it could be haloed. If that
          // is the case then store the processors at which the node
          // is haloed and its id. The info. of these nodes will be
          // sent to all the processors with a halo counterpart
          else
           {
            for (unsigned ip = 0; ip < nproc; ip++)
             {
              // Only work with processors different that the current one
              if (ip != my_rank)
               {
                // If the node is found to be haloed with the "ip"
                // processor then save the haloed id in the storage.
                // The current processor needs to send info. to the
                // other processors to establish the boundary
                // coordinates
                
                // Get the number of haloed nodes with processor ip
                const unsigned nhaloed_iproc = this->nhaloed_node(ip);
                for (unsigned ihdn = 0; ihdn < nhaloed_iproc; ihdn++)
                 {
                  Node* compare_face_node_pt=this->haloed_node_pt(ip, ihdn);
                  if (face_node_pt == compare_face_node_pt)
                   {
                    // Store the node on the haloed node vector for
                    // the corresponding processor
                    face_haloed_node_pt[ip].push_back(face_node_pt);
                    // Now store the halo id of the node with the
                    // current processor
                    face_haloed_node_id[ip].push_back(ihdn);
                    // Mark the node as haloed with other processors,
                    // so we know the processor in charge is the
                    // current one "my_rank".
                    done_haloed_face_node[face_node_pt] = true;
                    // Break looking in the current processor, look in
                    // the next one
                    break;
                   } // if (face_node_pt == compare_face_node_pt)
                 } // for (ihdn < nhaloed_node_iproc)
               } // if (ip != my_rank)
             } // for (ip < nproc)
           } // else (non halo node)
         } // if (!done_node[node_face_pt])
       } // for (in < nnodes)
     } // if (!is_halo_face_element[iface])
   } // for (iface < nface_ele)
  
  // -----------------------------------------------------------------
  // Fourth: Go through the halo nodes, package and send the
  // info. necessary to identify the face nodes in the processor in
  // charge. Identify the haloed nodes in the processor in charge and
  // establish the boundary coordinates, check if those nodes are
  // (already) marked as faced nodes, if that is the case then do not
  // establish the boundary coordinates but register them to send back
  // the info. to all the processors that have a halo representation
  // of the face node
  // -----------------------------------------------------------------
  
  // Go through all processors
  for (unsigned ip = 0; ip < nproc; ip++)
   {
    // Only work with processors different than the current one
    if (ip != my_rank)
     {
      const unsigned nhalo_face_nodes = face_halo_node_pt[ip].size();
#ifdef PARANOID
      if (nhalo_face_nodes!=face_halo_node_id[ip].size())
       {
        std::ostringstream error_message;
        error_message
         << "The number of found halo face nodes (" << nhalo_face_nodes 
         << ") is different from the number of\nfound halo face ids (" 
         << face_halo_node_id[ip].size() << ")!!!\n\n";
        throw OomphLibError(error_message.str(),
                  "TriangleMesh::synchronize_boundary_coordinates()",
                            OOMPH_EXCEPTION_LOCATION);
       }
#endif
      
      // Container to send the info. related with the halo nodes to be
      // identified in the processors in charge
      Vector<unsigned> flat_unsigned_send_packed_data;
      Vector<double> flat_double_send_packed_data;
      
      // Go through the halo face nodes in the "ip" processor
      for (unsigned ihfn = 0; ihfn < nhalo_face_nodes; ihfn++)
       {
        // Get the "ihfn"-th face node with the "ip" processor
        Node *halo_face_node_pt = face_halo_node_pt[ip][ihfn];
        // Get the halo id with the "ip" processor
        const unsigned halo_id = face_halo_node_id[ip][ihfn];
        // Get the boundary coordinate of the node
        Vector<double> zeta(1);
        halo_face_node_pt->get_coordinates_on_boundary(b, zeta);
        // Store the info. in the containers
        flat_unsigned_send_packed_data.push_back(halo_id);
        flat_double_send_packed_data.push_back(zeta[0]);
       }
      
      // Send the info.
      MPI_Status status;
      MPI_Request request;
      
      // Processor to which send the info
      int send_proc = static_cast<int>(ip);
      // Processor from which receive the info
      int receive_proc = static_cast<int>(ip);
      
      // Storage to receive the info.
      Vector<unsigned> flat_unsigned_receive_packed_data;
      Vector<double> flat_double_receive_packed_data;
      
      // --------------
      // Unsigned data
      unsigned nflat_unsigned_send = flat_unsigned_send_packed_data.size();
      MPI_Isend(&nflat_unsigned_send,1,MPI_UNSIGNED,
                send_proc,1,comm_pt->mpi_comm(),&request);
      
      unsigned nflat_unsigned_receive = 0;
      MPI_Recv(&nflat_unsigned_receive,1,MPI_UNSIGNED,
               receive_proc,1,comm_pt->mpi_comm(),&status);
      
      MPI_Wait(&request,MPI_STATUS_IGNORE);
      
      if (nflat_unsigned_send!=0)
       {
        MPI_Isend(&flat_unsigned_send_packed_data[0],nflat_unsigned_send,
                  MPI_UNSIGNED,send_proc,2,comm_pt->mpi_comm(),&request);
       }
      
      if (nflat_unsigned_receive!=0)
       {
        flat_unsigned_receive_packed_data.resize(nflat_unsigned_receive);
        MPI_Recv(&flat_unsigned_receive_packed_data[0],nflat_unsigned_receive,
                 MPI_UNSIGNED,receive_proc,2,comm_pt->mpi_comm(),&status);
       }
      
      if (nflat_unsigned_send!=0)
       {
        MPI_Wait(&request,MPI_STATUS_IGNORE);
       }
      
      // --------------
      // Double data
      unsigned nflat_double_send = flat_double_send_packed_data.size();
      MPI_Isend(&nflat_double_send,1,MPI_DOUBLE,
                send_proc,3,comm_pt->mpi_comm(),&request);
      
      unsigned nflat_double_receive = 0;
      MPI_Recv(&nflat_double_receive,1,MPI_DOUBLE,
               receive_proc,3,comm_pt->mpi_comm(),&status);
      
      MPI_Wait(&request,MPI_STATUS_IGNORE);
      
      if (nflat_double_send!=0)
       {
        MPI_Isend(&flat_double_send_packed_data[0],nflat_double_send,
                  MPI_DOUBLE,send_proc,4,comm_pt->mpi_comm(),&request);
       }
      
      if (nflat_double_receive!=0)
       {
        flat_double_receive_packed_data.resize(nflat_double_receive);
        MPI_Recv(&flat_double_receive_packed_data[0],nflat_double_receive,
                 MPI_DOUBLE,receive_proc,4,comm_pt->mpi_comm(),&status);
       }
      
      if (nflat_double_send!=0)
       {
        MPI_Wait(&request,MPI_STATUS_IGNORE);
       }
      // --------------
      
#ifdef PARANOID
      if (nflat_unsigned_receive!=nflat_double_receive)
       {
        std::ostringstream error_message;
        error_message
         << "The number of unsigned received data (" 
         << nflat_unsigned_receive << ") is different from the "
         << "number\nof double received data (" 
         << nflat_double_receive << ")!!!\n\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::synchronize_boundary_coordinates()",
                            OOMPH_EXCEPTION_LOCATION);
       }
#endif
      
      // With the received info. establish the boundary coordinates
      // for the face nodes that this processor is in charge (haloed
      // nodes)
      for (unsigned iflat_packed = 0; iflat_packed < nflat_unsigned_receive;
           iflat_packed++)
       {
        // Get the haloed id for the node
        const unsigned haloed_id = 
         flat_unsigned_receive_packed_data[iflat_packed];
        // Get the boundary coordinates
        Vector<double> zeta(1);
        zeta[0] = flat_double_receive_packed_data[iflat_packed];
        
        // Get the haloed node
        Node* haloed_face_node_pt = this->haloed_node_pt(ip, haloed_id);
        
        // If the node has already set the boundary coordinates then
        // do not establish it. This is the case for the nodes that
        // lie on the boundary, for those nodes not identified on the
        // boundary since no elements lie on the boundary but the node
        // is on the boundary (a corner of an element lies on the
        // boundary) set boundary coordinates and register them to
        // send their info. to the processors with a halo counterpart
        
        // If the node is not haloed face in the procesor in charge
        // then set the boundary coordinates and register the node to
        // send back the boundary coordinates to the processors with a
        // halo counterpart
        if (!done_haloed_face_node[haloed_face_node_pt])
         {
          // Establish the boundary coordinates
          haloed_face_node_pt->set_coordinates_on_boundary(b, zeta);
          
          // Look in all processors where the node could be halo
          for (unsigned iiproc = 0; iiproc < nproc; iiproc++)
           {
            // Only work with processors different than the current one
            if (iiproc != my_rank)
             {
              // Get the number of haloed nodes with processor iiproc
              const unsigned nhaloed_node_iiproc = this->nhaloed_node(iiproc);
              for (unsigned ihdn = 0; ihdn < nhaloed_node_iiproc; ihdn++)
               {
                Node* compare_haloed_node_pt=this->haloed_node_pt(iiproc,ihdn);
                if (haloed_face_node_pt == compare_haloed_node_pt)
                 {
                  // Store the node on the haloed node vector for the
                  // corresponding processor
                  face_haloed_node_pt[iiproc].push_back(haloed_face_node_pt);
                  // Now store the halo id of the node with the current
                  // processor
                  face_haloed_node_id[iiproc].push_back(ihdn);
                  // Break searching in the current processor, search in
                  // the next one
                  break;
                 }// if (haloed_face_node_pt==compare_haloed_face_node_pt)
               } // for (ihdn < nhaloed_node_iproc)
             } // if (iiproc != my_rank)
           } // for (iiproc < nproc)
         } // if (!done_haloed_face_node[haloed_face_node_pt])
       } // for (iflat_packed < nflat_unsigned_receive)
     } // if (ip != my_rank)
   } // for (ip < nproc)
  
  // -----------------------------------------------------------------
  // Fifth: The boundary coordinates have been established in the
  // processors in charge of the nodes. Now each processor send back
  // the boundary coordinates to all the processors where there is a
  // halo representation of the node
  // -----------------------------------------------------------------
  
  // Go through all processors
  for (unsigned ip = 0; ip < nproc; ip++)
   {
    // Only work with processors different than the current one
    if (ip != my_rank)
     {
      // Container to send the info. of the haloed nodes to all the
      // processors
      Vector<unsigned> flat_unsigned_send_packed_data;
      Vector<double> flat_double_send_packed_data;
      
      // Get the total number of haloed face nodes with the "ip"
      // processor
      const unsigned nhaloed_face_nodes = face_haloed_node_pt[ip].size();
      // Go through the haloed face nodes in the "ip" processor
      for (unsigned ihdfn = 0; ihdfn < nhaloed_face_nodes; ihdfn++)
       {
        // Get the "ihdfn"-th face node with the "ip" processor
        Node *haloed_face_node_pt = face_haloed_node_pt[ip][ihdfn];
        // Get the haloed id with the "ip" processor
        const unsigned haloed_id = face_haloed_node_id[ip][ihdfn];
        // Get the boundary coordinate of the node
        Vector<double> zeta(1);
        haloed_face_node_pt->get_coordinates_on_boundary(b, zeta);
        // Store the info. in the containers
        flat_unsigned_send_packed_data.push_back(haloed_id);
        flat_double_send_packed_data.push_back(zeta[0]);
       }
      
      // Send the info.
      MPI_Status status;
      MPI_Request request;
      
      // Processor to which send the info
      int send_proc = static_cast<int>(ip);
      // Processor from which receive the info
      int receive_proc = static_cast<int>(ip);
      
      // Storage to receive the info.
      Vector<unsigned> flat_unsigned_receive_packed_data;
      Vector<double> flat_double_receive_packed_data;
      
      // --------------
      // Unsigned data
      unsigned nflat_unsigned_send = flat_unsigned_send_packed_data.size();
      MPI_Isend(&nflat_unsigned_send,1,MPI_UNSIGNED,
                send_proc,1,comm_pt->mpi_comm(),&request);
      
      unsigned nflat_unsigned_receive = 0;
      MPI_Recv(&nflat_unsigned_receive,1,MPI_UNSIGNED,
               receive_proc,1,comm_pt->mpi_comm(),&status);
      
      MPI_Wait(&request,MPI_STATUS_IGNORE);
      
      if (nflat_unsigned_send!=0)
       {
        MPI_Isend(&flat_unsigned_send_packed_data[0],nflat_unsigned_send,
                  MPI_UNSIGNED,send_proc,2,comm_pt->mpi_comm(),&request);
       }
      
      if (nflat_unsigned_receive!=0)
       {
        flat_unsigned_receive_packed_data.resize(nflat_unsigned_receive);
        MPI_Recv(&flat_unsigned_receive_packed_data[0],nflat_unsigned_receive,
                 MPI_UNSIGNED,receive_proc,2,comm_pt->mpi_comm(),&status);
       }
      
      if (nflat_unsigned_send!=0)
       {
        MPI_Wait(&request,MPI_STATUS_IGNORE);
       }
      
      // --------------
      // Double data
      unsigned nflat_double_send = flat_double_send_packed_data.size();
      MPI_Isend(&nflat_double_send,1,MPI_DOUBLE,
                send_proc,3,comm_pt->mpi_comm(),&request);
      
      unsigned nflat_double_receive = 0;
      MPI_Recv(&nflat_double_receive,1,MPI_DOUBLE,
               receive_proc,3,comm_pt->mpi_comm(),&status);
      
      MPI_Wait(&request,MPI_STATUS_IGNORE);
      
      if (nflat_double_send!=0)
       {
        MPI_Isend(&flat_double_send_packed_data[0],nflat_double_send,
                  MPI_DOUBLE,send_proc,4,comm_pt->mpi_comm(),&request);
       }
      
      if (nflat_double_receive!=0)
       {
        flat_double_receive_packed_data.resize(nflat_double_receive);
        MPI_Recv(&flat_double_receive_packed_data[0],nflat_double_receive,
                 MPI_DOUBLE,receive_proc,4,comm_pt->mpi_comm(),&status);
       }
      
      if (nflat_double_send!=0)
       {
        MPI_Wait(&request,MPI_STATUS_IGNORE);
       }
      // --------------
      
#ifdef PARANOID
      if (nflat_unsigned_receive!=nflat_double_receive)
       {
        std::ostringstream error_message;
        error_message
         << "The number of unsigned received data (" 
         << nflat_unsigned_receive << ") is different from the "
         << "number\nof double received data (" 
         << nflat_double_receive << ")!!!\n\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::synchronize_boundary_coordinates()",
                            OOMPH_EXCEPTION_LOCATION);
       }
#endif
      
      // With the received info. establish the boundary coordinates
      // received for the face nodes that this processor is not in
      // charge (halo nodes)
      for (unsigned iflat_packed = 0; iflat_packed < nflat_unsigned_receive;
           iflat_packed++)
       {
        // Get the halo id for the node
        const unsigned halo_id = 
         flat_unsigned_receive_packed_data[iflat_packed];
        // Get the boundary coordinates
        Vector<double> zeta(1);
        zeta[0] = flat_double_receive_packed_data[iflat_packed];
        
        // Get the halo node
        Node* halo_face_node_pt = this->halo_node_pt(ip, halo_id);
                
        // It could be possible that the node has been already
        // established boundary coordinates since it is a halo face
        // node. However, for those elements not on the boundary, but
        // having a corner node on the boundary this procedure will
        // establish boundary coordinates for those nodes
        
        //this->add_boundary_node(b, halo_face_node_pt);
        
        // Establish the boundary coordinates
        halo_face_node_pt->set_coordinates_on_boundary(b, zeta);
       } // for (iflat_packed < nflat_unsigned_receive)
     } // if (ip != my_rank)
   } // for (ip < nproc)
  
  // Clean all the created face elements
  for (unsigned ie = 0; ie < nbound_ele; ie++)
   {
    delete tmp_face_ele_pt[ie];
    tmp_face_ele_pt[ie] = 0;
   }
  
  // Now get a new face mesh representation and fill the data for those
  // processors with halo segments
  if (is_internal_boundary)
   {
    re_scale_re_assigned_initial_zeta_values_for_internal_boundary(b);
   }
  
 }
 
 //======================================================================
 /// \short Re-assign the boundary segments initial zeta (arclength)
 /// for those internal boundaries that were splited during the
 /// distribution process (only apply for internal boundaries that
 /// have one face element at each side of the boundary)
 //======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::
 re_scale_re_assigned_initial_zeta_values_for_internal_boundary(
  const unsigned& b)
 {
  // ------------------------------------------------------------------
  // First: Get the face elements associated with the current boundary
  //        Only include nonhalo face elements
  // ------------------------------------------------------------------
  // Temporary storage for face elements
  Vector<FiniteElement*> face_el_pt;
  
  // Temporary storage for the number of elements adjacent to the
  // boundary
  unsigned nele = 0;
  
  // Temporary storage for elements adjacent to the boundary that have
  // a common edge (related with internal boundaries)
  unsigned n_repeated_ele = 0;
  
  const unsigned n_regions = this->nregion();
  
  // Temporary storage for already done nodes
  Vector<std::pair<Node*, Node*> > done_nodes_pt;
  
  // If there is more than one region then only use boundary
  // coordinates from the bulk side (region 0)
  if (n_regions > 1)
   {
    for (unsigned rr = 0 ; rr < n_regions; rr++)
     {
      const unsigned region_id = 
       static_cast<unsigned>(this->Region_attribute[rr]);
      
      // Loop over all elements on boundaries in region i_r
      const unsigned nel_in_region = 
       this->nboundary_element_in_region(b, region_id);
      
      unsigned nel_repetead_in_region = 0;
      
      // Only bother to do anything else, if there are elements
      // associated with the boundary and the current region
      if (nel_in_region > 0)
       {
        bool repeated = false;
        
        // Loop over the bulk elements adjacent to boundary b
        for (unsigned e = 0; e < nel_in_region; e++)
         {
          // Get pointer to the bulk element that is adjacent to
          // boundary b
          FiniteElement* bulk_elem_pt =
           this->boundary_element_in_region_pt(b, region_id, e);
          
          // Remember only to work with nonhalo elements
          if (bulk_elem_pt->is_halo())
           {
            n_repeated_ele++;
            continue;
           }
          
          // Find the index of the face of element e along boundary b
          int face_index = 
           this->face_index_at_boundary_in_region(b,region_id,e);
          
          // Before adding the new element we need to be sure that the
          // edge that this element represent has not been already
          // added
          FiniteElement* tmp_ele_pt = 
           new DummyFaceElement<ELEMENT>(bulk_elem_pt, face_index);

          const unsigned n_nodes = tmp_ele_pt->nnode();

          std::pair<Node*, Node*> tmp_pair = 
           std::make_pair(tmp_ele_pt->node_pt(0),
                          tmp_ele_pt->node_pt(n_nodes - 1));
          
          std::pair<Node*, Node*> tmp_pair_inverse = 
           std::make_pair(tmp_ele_pt->node_pt(n_nodes - 1),
                          tmp_ele_pt->node_pt(0));
          
          // Search for repeated nodes
          const unsigned n_done_nodes = done_nodes_pt.size();
          for (unsigned l = 0; l < n_done_nodes; l++)
           {
            if (tmp_pair == done_nodes_pt[l] || 
                tmp_pair_inverse == done_nodes_pt[l])
             {
              nel_repetead_in_region++;
              repeated = true;
              break;
             }
           }
          
          // Create new face element
          if (!repeated)
           {
            // Add the pair of nodes (edge) to the node dones
            done_nodes_pt.push_back(tmp_pair);
            // Add the element to the face elements
            face_el_pt.push_back(tmp_ele_pt);
           }
          else
           {
            // Clean up
            delete tmp_ele_pt;
            tmp_ele_pt = 0;
           }
          
          // Re-start
          repeated = false;
          
         } // for nel
        
        nele += nel_in_region;
        
        n_repeated_ele += nel_repetead_in_region;
        
       } // if (nel_in_region > 0)
     } // for (rr < n_regions)
   } // if (n_regions > 1)
  //Otherwise it's just the normal boundary functions
  else
   {
    // Loop over all elements on boundaries
    nele = this->nboundary_element(b);
    
    //Only bother to do anything else, if there are elements
    if (nele > 0)
     {
      // Check for repeated ones
      bool repeated = false;
      
      // Loop over the bulk elements adjacent to boundary b
      for (unsigned e = 0; e < nele; e++)
       {
        // Get pointer to the bulk element that is adjacent to
        // boundary b
        FiniteElement* bulk_elem_pt = this->boundary_element_pt(b, e);
        
        // Remember only to work with nonhalo elements
        if (bulk_elem_pt->is_halo())
         {
          n_repeated_ele++;
          // Skip the halo element
          continue;
         }
        
        //Find the index of the face of element e along boundary b
        int face_index = this->face_index_at_boundary(b, e);
        
        // Before adding the new element we need to be sure that the
        // edge that this element represents has not been already
        // added (only applies for internal boundaries)
        FiniteElement* tmp_ele_pt = 
         new DummyFaceElement<ELEMENT>(bulk_elem_pt, face_index);
        
        const unsigned n_nodes = tmp_ele_pt->nnode();
        
        std::pair<Node*, Node*> tmp_pair = 
         std::make_pair(tmp_ele_pt->node_pt(0),
                        tmp_ele_pt->node_pt(n_nodes - 1));
        
        std::pair<Node*, Node*> tmp_pair_inverse = 
         std::make_pair(tmp_ele_pt->node_pt(n_nodes - 1),
                        tmp_ele_pt->node_pt(0));
        
        // Search for repeated nodes
        const unsigned n_done_nodes = done_nodes_pt.size();
        for (unsigned l = 0; l < n_done_nodes; l++)
         {
          if (tmp_pair == done_nodes_pt[l] || 
              tmp_pair_inverse == done_nodes_pt[l])
           {
            // Increase the number of repeated elements
            n_repeated_ele++;
            // Mark the element as repeated
            repeated = true;
            break;
           }
         }
        
        // Create new face element
        if (!repeated)
         {
          // Add the pair of nodes (edge) to the node dones
          done_nodes_pt.push_back(tmp_pair);
          // Add the element to the face elements
          face_el_pt.push_back(tmp_ele_pt);
         }
        else
         {
          // Free the repeated bulk element!!
          delete tmp_ele_pt;
          tmp_ele_pt = 0;
         }
        
        // Re-start
        repeated = false;
        
       } // for (e < nel)
     } // if (nel > 0)
    
   } // else (n_regions > 1)
  
  // Do not consider the repeated elements
  nele-= n_repeated_ele;
  
#ifdef PARANOID
  if (nele!=face_el_pt.size())
   {
    std::ostringstream error_message;
    error_message
     << "The independet counting of face elements ("<<nele<<") for "
     << "boundary ("<<b<<") is different\n"
     << "from the real number of face elements in the container ("
     << face_el_pt.size() <<")\n";
    //<< "Possible memory leak\n"
    throw OomphLibError(error_message.str(),
                        "TriangleMesh::re_scale_re_assigned_initial_zeta_values_for_internal_boundary()",
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
  // ----------------------------------------------------------------
  // Second: Sort the face elements (to create segments), only
  // consider nonhalo elements
  // ----------------------------------------------------------------
  
  // Get the total number of nonhalo face elements
  const unsigned nnon_halo_face_elements = face_el_pt.size();
  
  // The vector of list to store the "segments" that compound the
  // boundary (segments may appear only in a distributed mesh)
  Vector<std::list<FiniteElement*> > segment_sorted_ele_pt;
  
  // Number of already sorted face elements
  unsigned nsorted_face_elements = 0;
  
  // Keep track of who's done
  std::map<FiniteElement*, bool> done_el;
  
  // Keep track of which element is inverted
  std::map<FiniteElement*, bool> is_inverted;
  
  // Iterate until all possible segments have been created
  while(nsorted_face_elements < nnon_halo_face_elements)
   {
    // The ordered list of face elements (in a distributed mesh a
    // collection of contiguous face elements define a segment)
    std::list<FiniteElement*> sorted_el_pt;
    
#ifdef PARANOID
    // Select an initial element for the segment
    bool found_initial_face_element = false;
#endif
    
    FiniteElement* ele_face_pt = 0;
    
    unsigned iface = 0;
    for (iface = 0; iface < nele; iface++)
     {
      ele_face_pt = face_el_pt[iface];
      // If not done then take it as initial face element
      if (!done_el[ele_face_pt])
       {
#ifdef PARANOID
        found_initial_face_element = true;
#endif
        nsorted_face_elements++;
        iface++; // The next element number
        sorted_el_pt.push_back(ele_face_pt);
        // Mark as done
        done_el[ele_face_pt] = true;
        break;
       }
     } // for (iface < nele)
    
#ifdef PARANOID
    if (!found_initial_face_element)
     {
      std::ostringstream error_message;
      error_message
       <<"Could not find an initial face element for the current segment\n";
      // << "----- Possible memory leak -----\n";
      throw OomphLibError(error_message.str(),
                          "TriangleMesh::re_scale_re_assigned_initial_zeta_values_for_internal_boundary()",
                          OOMPH_EXCEPTION_LOCATION);
     }
#endif
    
    // Number of nodes
    const unsigned nnod = ele_face_pt->nnode();
    
    // Left and rightmost nodes (the left and right nodes of the
    // current face element)
    Node* left_node_pt = ele_face_pt->node_pt(0);
    Node* right_node_pt = ele_face_pt->node_pt(nnod - 1);
    
    // Continue iterating if a new face element has been added to the
    // list
    bool face_element_added = false;
    
    // While a new face element has been added to the set of sorted
    // face elements then re-iterate
    do
     {
      // Start from the next face element since we have already added
      // the previous one as the initial face element (any previous
      // face element had to be added on previous iterations)
      for (unsigned iiface = iface; iiface < nele; iiface++)
       {
        // Re-start flag
        face_element_added = false;
        
        // Get the candidate element
        ele_face_pt = face_el_pt[iiface];
        
        // Check that the candidate element has not been done
        if (!(done_el[ele_face_pt]))
         {
          // Get the left and right nodes of the current element
          Node* local_left_node_pt = ele_face_pt->node_pt(0);
          Node* local_right_node_pt = ele_face_pt->node_pt(nnod - 1);
          
          // New element fits at the left of segment and is not inverted
          if (left_node_pt == local_right_node_pt)
           {
            left_node_pt = local_left_node_pt;
            sorted_el_pt.push_front(ele_face_pt);
            is_inverted[ele_face_pt] = false;
            face_element_added = true;
           }
          // New element fits at the left of segment and is inverted
          else if (left_node_pt == local_left_node_pt)
           {
            left_node_pt = local_right_node_pt;
            sorted_el_pt.push_front(ele_face_pt);
            is_inverted[ele_face_pt] = true;
            face_element_added = true;
           }
          // New element fits on the right of segment and is not inverted
          else if (right_node_pt == local_left_node_pt)
           {
            right_node_pt = local_right_node_pt;
            sorted_el_pt.push_back(ele_face_pt);
            is_inverted[ele_face_pt] = false;
            face_element_added = true;
           }
          // New element fits on the right of segment and is inverted
          else if (right_node_pt == local_right_node_pt)
           {
            right_node_pt = local_left_node_pt;
            sorted_el_pt.push_back(ele_face_pt);
            is_inverted[ele_face_pt] = true;
            face_element_added = true;
           }
          
          if (face_element_added)
           {
            done_el[ele_face_pt] = true;
            nsorted_face_elements++;
            break;
           }
          
         } // if (!(done_el[ele_face_pt]))
       } // for (iiface<nnon_halo_face_element)
     }while(face_element_added &&
            (nsorted_face_elements < nnon_halo_face_elements));
    
    // Store the created segment in the vector of segments
    segment_sorted_ele_pt.push_back(sorted_el_pt);
    
   } // while(nsorted_face_elements < nnon_halo_face_elements);
  
  // --------------------------------------------------------------
  // Third: We have the face elements sorted, now assign boundary
  // coordinates to the nodes in the segments and compute the
  // arclength of the segment
  // --------------------------------------------------------------
  
  // Vector of sets that stores the nodes of each segment based on a
  // lexicographically order starting from the bottom left node of
  // each segment
  Vector<std::set<Node*> > segment_all_nodes_pt;
  
  // The number of segments in this processor
  const unsigned nsegments = segment_sorted_ele_pt.size();
  
#ifdef PARANOID
  if (nnon_halo_face_elements > 0 && nsegments == 0)
   {
    std::ostringstream error_message;
    error_message
     << "The number of segments is zero, but the number of nonhalo\n"
     << "elements is: (" << nnon_halo_face_elements << ")\n";
    throw OomphLibError(error_message.str(),
                        "TriangleMesh::re_scale_re_assigned_initial_zeta_values_for_internal_boundary()",
                        OOMPH_EXCEPTION_LOCATION);
   } // if (nnon_halo_face_elements > 0 && nsegments == 0)
#endif
  
  // The arclength of each segment in the current processor
  Vector<double> segment_arclength(nsegments);
  
  // The initial zeta for the segment
  Vector<double> initial_zeta_segment(nsegments);
  
  // The final zeta for the segment
  Vector<double> final_zeta_segment(nsegments);
  
  // Go through all the segments and compute the LOCAL boundary
  // coordinates
  for (unsigned is = 0; is < nsegments; is++)
   {
#ifdef PARANOID
    if (segment_sorted_ele_pt[is].size() == 0)
     {
      std::ostringstream error_message;
      error_message
       << "The (" << is << ")-th segment has no elements\n";
       throw OomphLibError(error_message.str(),
                           "TriangleMesh::re_scale_re_assigned_initial_zeta_values_for_internal_boundary()",
                           OOMPH_EXCEPTION_LOCATION);      
     } // if (segment_sorted_ele_pt[is].size() == 0)
#endif
    
    // Get access to the first element on the segment
    FiniteElement* first_ele_pt = segment_sorted_ele_pt[is].front();
    
    // Number of nodes
    const unsigned nnod = first_ele_pt->nnode();
    
    // Get the first node of the current segment
    Node *first_node_pt = first_ele_pt->node_pt(0);
    if (is_inverted[first_ele_pt])
     {
      first_node_pt = first_ele_pt->node_pt(nnod-1);
     }
    
    // Get access to the last element on the segment
    FiniteElement* last_ele_pt = segment_sorted_ele_pt[is].back();
    
    // Get the last node of the current segment
    Node *last_node_pt = last_ele_pt->node_pt(nnod-1);
    if (is_inverted[last_ele_pt])
     {
      last_node_pt = last_ele_pt->node_pt(0);
     }
    
    // Coordinates of left node
    double x_left = first_node_pt->x(0);
    double y_left = first_node_pt->x(1);
    
    // Initialise boundary coordinate (local boundary coordinate for
    // boundaries with more than one segment)
    Vector<double> zeta(1, 0.0);
    
    // If we have associated a GeomObject then it is not necessary to
    // compute the arclength, only read the values from the nodes at
    // the edges
    if (this->boundary_geom_object_pt(b)!=0)
     {
      first_node_pt->get_coordinates_on_boundary(b, zeta);
      initial_zeta_segment[is] = zeta[0];
      last_node_pt->get_coordinates_on_boundary(b, zeta);
      final_zeta_segment[is] = zeta[0];
     }
    
    // Lexicographically bottom left node
    std::set<Node*> local_nodes_pt;
    local_nodes_pt.insert(first_node_pt);
    
    // Now loop over nodes in order
    for (std::list<FiniteElement*>::iterator it = 
          segment_sorted_ele_pt[is].begin();
         it != segment_sorted_ele_pt[is].end(); it++)
     {
      // Get element
      FiniteElement* el_pt = *it;
      
      // Start node and increment
      unsigned k_nod = 1;
      int nod_diff = 1;
      if (is_inverted[el_pt])
       {
        k_nod = nnod - 2;
        nod_diff = -1;
       }
      
      // Loop over nodes
      for (unsigned j = 1; j < nnod; j++)
       {
        Node* nod_pt = el_pt->node_pt(k_nod);
        k_nod += nod_diff;
        
        // Coordinates of right node
        double x_right = nod_pt->x(0);
        double y_right = nod_pt->x(1);
        
        // Increment boundary coordinate
        zeta[0] += sqrt(
         (x_right - x_left) * (x_right - x_left) + (y_right - y_left)
         * (y_right - y_left));
        
        // Increment reference coordinate
        x_left = x_right;
        y_left = y_right;
        
        // Get lexicographically bottom left node but only
        // use vertex nodes as candidates
        local_nodes_pt.insert(nod_pt);
        
       } // for (j < nnod)
     } // iterator over the elements in the segment
    
    // Store the arclength of the segment
    segment_arclength[is] = zeta[0];
    
    // Add the nodes for the corresponding segment in the container
    segment_all_nodes_pt.push_back(local_nodes_pt);
    
   } // for (is < nsegments)
  
  // ------------------------------------------------------------------
  // Fourth: Now we have the segments sorted, with arclength and with
  // LOCAL arclength assigned to the nodes. Procced to re-scale the
  // coordinates on the nodes based on the arclength
  // ------------------------------------------------------------------
  
  // ------------------------------------------------------------------
  // Clear the original storages
  Boundary_segment_inverted[b].clear();
  Boundary_segment_initial_coordinate[b].clear();
  Boundary_segment_final_coordinate[b].clear();
  
  Boundary_segment_initial_zeta[b].clear();
  Boundary_segment_final_zeta[b].clear();
  
  Boundary_segment_initial_arclength[b].clear();
  Boundary_segment_final_arclength[b].clear();
  
  // Get the zeta values for the first and last node in the boundary
  Vector<double> first_node_zeta_coordinate(1,0.0);
  Vector<double> last_node_zeta_coordinate(1,0.0);
  first_node_zeta_coordinate = boundary_initial_zeta_coordinate(b);
  last_node_zeta_coordinate = boundary_final_zeta_coordinate(b);
  
  // Get the boundary arclength
  const double boundary_arclength = 
   std::max(first_node_zeta_coordinate[0], last_node_zeta_coordinate[0]);
  
  // Go through the segments and get the first and last node for each
  // segment
  for (unsigned is = 0; is < nsegments; is++)
   {
    // Get the first face element of the segment
    FiniteElement* first_face_ele_pt = segment_sorted_ele_pt[is].front();
    
    // The number of nodes
    const unsigned nnod = first_face_ele_pt->nnode();
    
    // ... and the first node of the segment
    Node* first_node_pt = first_face_ele_pt->node_pt(0);
    if (is_inverted[first_face_ele_pt])
     {
      first_node_pt = first_face_ele_pt->node_pt(nnod-1);
     }
    
    // Get the bound coordinates of the node
    Vector<double> zeta_first(1);
    first_node_pt->get_coordinates_on_boundary(b, zeta_first);
    
    // Get the last face element of the segment
    FiniteElement* last_face_ele_pt = segment_sorted_ele_pt[is].back();
    
    // ... and the last node of the segment
    Node* last_node_pt = last_face_ele_pt->node_pt(nnod-1);
    if (is_inverted[last_face_ele_pt])
     {
      last_node_pt = last_face_ele_pt->node_pt(0);
     }
    
    // Get the bound coordinates of the node
    Vector<double> zeta_last(1);
    last_node_pt->get_coordinates_on_boundary(b, zeta_last);
    
    // Now that we have the first and last node of the segment, get
    // the coordinates of the nodes
    Vector<double> first_node_coord(2);
    Vector<double> last_node_coord(2);
    for (unsigned i = 0; i < 2; i++)
     {
      first_node_coord[i] = first_node_pt->x(i);
      last_node_coord[i] = last_node_pt->x(i);
     }
    
    // Re-assign the values to identify the segments on the new mesh
    Boundary_segment_inverted[b].push_back(0);
    Boundary_segment_initial_coordinate[b].push_back(first_node_coord);
    Boundary_segment_final_coordinate[b].push_back(last_node_coord);
    
    // Check if the boudary has an associated GeomObject
    if (this->boundary_geom_object_pt(b)!=0)
     {
      Boundary_segment_initial_zeta[b].push_back(zeta_first[0]);
      Boundary_segment_final_zeta[b].push_back(zeta_last[0]);
     }
    else
     {
      // Re-assign the values and re-scale them
      Boundary_segment_initial_arclength[b].push_back(
       zeta_first[0] * boundary_arclength);
      Boundary_segment_final_arclength[b].push_back(
       zeta_last[0] * boundary_arclength);
     }
    
   } // for (is < nsegments)
  
  // Clean all the created face elements
  for (unsigned i = 0; i < nele; i++)
   {
    delete face_el_pt[i];
    face_el_pt[i] = 0;
   }
  
 }
 
#endif // OOMPH_HAS_MPI



#ifdef OOMPH_HAS_TRIANGLE_LIB
 
 //========================================================================
 /// Create TriangulateIO object via the .poly file
 //========================================================================
 template <class ELEMENT>
 void TriangleMesh<ELEMENT>::
 build_triangulateio(const std::string& poly_file_name,
		     TriangulateIO& triangulate_io,
		     bool &use_attributes)
  {

   // Process poly file
   // -----------------
   std::ifstream poly_file(poly_file_name.c_str(),std::ios_base::in);
   if(!poly_file)
    {
     throw OomphLibError("Error opening .poly file\n",
                         OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
    }

   // Initialize triangulateio structure
   TriangleHelper::initialise_triangulateio(triangulate_io);

   // Ignore the first line with structure description
   poly_file.ignore(80,'\n');

   // Read and store number of nodes
   unsigned invertices;
   poly_file>>invertices;
   triangulate_io.numberofpoints=invertices;

   // Initialisation of the point list
   triangulate_io.pointlist =
   (double *) malloc(triangulate_io.numberofpoints * 2 * sizeof(double));

   // Read and store spatial dimension of nodes
   unsigned mesh_dim;
   poly_file>>mesh_dim;

   if(mesh_dim == 0)
    {
     mesh_dim=2;
    }

#ifdef PARANOID
   if(mesh_dim!=2)
    {
     throw OomphLibError("The dimension must be 2\n",
                         OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
    }
#endif

   // Read and check the flag for attributes
   unsigned nextras;
   poly_file>> nextras;

   triangulate_io.numberofpointattributes = 0;
   triangulate_io.pointattributelist = (double *) NULL;

   // Read and check the flag for boundary markers
   unsigned nodemarkers;
   poly_file>>nodemarkers;
   triangulate_io.pointmarkerlist = (int *) NULL;

#ifdef PARANOID
   // Reading the .poly with the oomph.lib we need
   // to set the point attribute and markers to 0
   if(nextras!=0 || nodemarkers!=0)
    {
     oomph_info << "===================================================="
     << std::endl<<std::endl;
     oomph_info <<"Reading the .poly file via oomph_lib \n"
     <<"point's attribute and point's markers \n"
     <<"are automatically set to 0"<<std::endl;
     oomph_info << "===================================================="
     <<std::endl;
    }
#endif

   // Dummy for node number (and attribute or markers if included)
   unsigned dummy_value;
   unsigned count_point=0;
   std::string test_string;

   // Skip line with commentary
   getline(poly_file,test_string,'#');
   poly_file.ignore(80,'\n');

   // Read and store all the nodes coordinates
   // (hole's vertices as well)
   for(unsigned count=0;count<invertices;count++)
    {
     poly_file>>dummy_value;
     poly_file>>triangulate_io.pointlist[count_point];
     poly_file>>triangulate_io.pointlist[count_point+1];
     if(nextras!=0 || nodemarkers!=0)
      {
       for(unsigned j=0;j<nextras;j++)
        {
         poly_file>>dummy_value;
        }
      }
     else if(nextras!=0 && nodemarkers!=0)
      {
       for(unsigned j=0;j<nextras;j++)
        {
         poly_file>>dummy_value;
         poly_file>>dummy_value;
        }
      }
     // Read the next line
     poly_file.ignore(80,'\n');

     // Skip line with commentary for internal box whether found
     if(poly_file.get() == '#')
      {
       poly_file.ignore(80,'\n');
      }
     // If read the char should be put back in the string

     else
      {
       poly_file.unget();
      }
     count_point+=2;
    }

   // The line with the segment's commentary has been skipped
   // by the command of the last loop

   // Read and store the number of segments
   unsigned dummy_seg;
   unsigned inelements;
   poly_file>>inelements;

   unsigned segment_markers;
   poly_file>>segment_markers;

   // Marker list should be provided by the user to assign
   // each segment to a boundary
#ifdef PARANOID
   if(segment_markers!=1)
    {

     std::ostringstream error_stream;
     error_stream
     <<"The segment marker should be provided \n"
     <<"In order to assign each segment to a boundary \n "<< std::endl;

     throw OomphLibError(error_stream.str(),
                         OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
    }
#endif

   triangulate_io.numberofsegments = inelements;
   triangulate_io.segmentlist =
   (int *) malloc(triangulate_io.numberofsegments * 2 * sizeof(int));
   triangulate_io.segmentmarkerlist =
   (int *) malloc(triangulate_io.numberofsegments * sizeof(int));

   // Read all the segments edges and markers
   for(unsigned i=0;i<2*inelements;i+=2)
    {
     poly_file>>dummy_seg;
     poly_file>>triangulate_io.segmentlist[i];
     poly_file>>triangulate_io.segmentlist[i+1];
     if(segment_markers!=0)
      {
       poly_file>>triangulate_io.segmentmarkerlist[i/2];
      }

     //Skip line with commentary
     poly_file.ignore(80,'\n');
    }

   // Read and store the number of holes if given
   // Skip line with commentary
   if(getline(poly_file,test_string,'#'))
    {
     poly_file.ignore(80,'\n');

     unsigned dummy_hole;
     unsigned nhole;
     poly_file>>nhole;

     triangulate_io.numberofholes = nhole;
     triangulate_io.holelist =
     (double *) malloc(triangulate_io.numberofholes * 2 * sizeof(double));

     // Loop over the holes to get centre coords and store value onto the
     // TriangulateIO object
     for(unsigned i=0;i<2*nhole;i+=2)
      {
       poly_file>>dummy_hole;
       poly_file>>triangulate_io.holelist[i];
       poly_file>>triangulate_io.holelist[i+1];
      }
    }

   // Read and store the number of regions if given
   // Skip line with commentary
   if(getline(poly_file,test_string,'#'))
    {
     poly_file.ignore(80,'\n');

     unsigned dummy_region;
     unsigned nregion;
     poly_file>>nregion;
     std::cerr << "Regions: "<< nregion << std::endl;
     getchar();

     triangulate_io.numberofregions = nregion;
     triangulate_io.regionlist =
     (double *) malloc(triangulate_io.numberofregions * 4 * sizeof(double));

     // Check for using regions
     if (nregion > 0)
     {use_attributes=true;}
   
     // Loop over the regions to get coords and store value onto the
     // TriangulateIO object
     for(unsigned i=0;i<nregion;i++)
      {
       poly_file>>dummy_region;
       poly_file>>triangulate_io.regionlist[4*i];
       poly_file>>triangulate_io.regionlist[4*i+1];
       poly_file>>triangulate_io.regionlist[4*i+2];
       triangulate_io.regionlist[4*i+3] = 0.0;
      }
    }

  }

#endif
 
#ifdef OOMPH_HAS_TRIANGLE_LIB
#ifdef OOMPH_HAS_MPI
 
 //======================================================================
 /// Used to dump info. related with distributed triangle meshes
 //======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::
 dump_distributed_info_for_restart(std::ostream &dump_file)
 {
  // First check that the mesh is distributed
  if (this->is_mesh_distributed())
   {
    // Save the original number of boundaries
    const unsigned nboundary = this->nboundary();
    dump_file << nboundary
              << " # number of original boundaries" << std::endl;
    
    // Save the number of shared boundaries
    const unsigned nshared_boundaries = this->nshared_boundaries();
    dump_file << nshared_boundaries
              << " # number of shared boundaries" << std::endl;
    
    // Save the initial and final shared boundaries ids
    const unsigned init_shd_bnd_id = this->initial_shared_boundary_id();
    dump_file << init_shd_bnd_id
              << " # initial shared boundaries id" << std::endl;
    
    const unsigned final_shd_bnd_id = this->final_shared_boundary_id();
    dump_file << final_shd_bnd_id
              << " # final shared boundaries id" << std::endl;
        
    // Save the number of processors
    const unsigned nprocs = this->shared_boundaries_ids().size();
    dump_file << nprocs << " # number of processors" << std::endl;
    
    // Now save the processors ids and the shared boundary created
    // by them
    for (unsigned ip = 0; ip < nprocs; ip++)
     {
      for (unsigned jp = 0; jp < nprocs; jp++)
       {
        if (ip != jp)
         {
          // Get the number of shared boundaries with it these two
          // processors
          const unsigned nshared_boundaries_iproc_jproc = 
           this->shared_boundaries_ids(ip, jp).size();
          
          // Save the number of shared boundaries with in these two
          // processors
          dump_file << nshared_boundaries_iproc_jproc
                    << " # number of shared boundaries with in two "
                    << "processors" << std::endl;
          for (unsigned is = 0; is < nshared_boundaries_iproc_jproc; is++)
           {
            const unsigned shared_boundary_id = 
             this->shared_boundaries_ids(ip, jp, is);
            dump_file << ip << " " << jp << " " << shared_boundary_id
                      << " # ip jp shared_boundary of processors ip and jp" 
                      << std::endl;
            
           } // for (is < nshared_boundaries_iproc_jproc)
         }
       } // for (jp < nprocs)
     } // for (ip < nprocs)
    
    // Now save the info. that states which shared boundary overlaps
    // an internal boundary
    
    // First check if there are shared boundaries overlapping internal
    // boundaries
    const unsigned nshared_boundaries_overlap_internal_boundaries = 
     this->nshared_boundary_overlaps_internal_boundary();
    dump_file << nshared_boundaries_overlap_internal_boundaries
              << " # number of shared boundaries that overlap internal "
              << "boundaries" << std::endl;
    
    if (nshared_boundaries_overlap_internal_boundaries > 0)
     {
      for (unsigned isb = init_shd_bnd_id; isb < final_shd_bnd_id; isb++)
       {
        // Check if the current shared boundary overlaps an internal
        // boundary
        if (this->shared_boundary_overlaps_internal_boundary(isb))
         {
          // Which internal boundary is overlapped by the shared
          // boundary
          const unsigned overlapped_internal_boundary = 
           shared_boundary_overlapping_internal_boundary(isb);
          // Save the shared boundary that overlaps the internal boundary
          dump_file << isb << " " << overlapped_internal_boundary
                    << " # the shared boundary overlaps the internal "
                    << "boundary " << std::endl;
          
         } // if (this->shared_boundary_overlaps_internal_boundary(isb))
       } // for (isb < final_shd_bnd_id)
     } // if (nshared_boundaries_overlap_internal_boundaries > 0)
    
    // Now save the info. related with the initial and final
    // boundary coordinates for each original boundary
    
    // Go through all the (original) boundaries to update the initial
    // and final boundary coordinates
    for (unsigned b = 0; b < nboundary; b++)
     {      
      // Check if the boundary zeta coordinates for this boundary have
      // been already assigned, if that is the case then state the
      // flag to know that info. should be read
      if (Assigned_segments_initial_zeta_values[b])
       {
        // The boundary coordinates have been computed then state
        // the flag and save the info.
        dump_file << "1 # assigned boundary coordinates initial zeta values"
                  << std::endl;
        
        // Save the initial and final boundary coordinates, same as
        // the initial and final zeta values for each boundary
        
        // First the vertices coordinates
        Vector<double> initial_coordinates=this->boundary_initial_coordinate(b);
        
        Vector<double> final_coordinates=this->boundary_final_coordinate(b);
        
        dump_file << std::setprecision(14) 
                  << initial_coordinates[0] << " " << initial_coordinates[1]
                  << " # initial coordinates for the current boundary"
                  << std::endl;
        
        dump_file << std::setprecision(14) 
                  << final_coordinates[0] << " " << final_coordinates[1]
                  << " # final coordinates for the current boundary"
                  << std::endl;
        
        // ... then the zeta values
        
#ifdef PARANOID
        // Get the number of zeta coordinates (should be one)
        const unsigned zeta_size = 
         this->boundary_initial_zeta_coordinate(b).size();
        
        if (zeta_size != 1)
         {
          std::ostringstream error_message;
          error_message 
           <<"The dimension for the zeta values container is different\n"
           << "from 1, the current implementation only supports\n"
           << "one-dimensioned zeta containers\n\n";
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::dump_distributed_info_for_restart()",
                              OOMPH_EXCEPTION_LOCATION);
         }
#endif
      
        Vector<double> zeta_initial = this->boundary_initial_zeta_coordinate(b);
        Vector<double> zeta_final = this->boundary_final_zeta_coordinate(b);
      
        dump_file << std::setprecision(14) 
                  << zeta_initial[0] 
                  << " # initial zeta value for the current boundary" 
                  << std::endl;

        dump_file << std::setprecision(14) 
                  << zeta_final[0] 
                  << " # final zeta value for the current boundary" 
                  << std::endl;
        
        // Get the number of segments of the current boundary
        const unsigned nsegments = this->nboundary_segment(b);
        // Save the number of segments of the current boundary
        dump_file << b << " " << nsegments 
                  << " # of segments for the current boundary" 
                  << std::endl;
        
        // ... and then save that info for each segments
        for (unsigned is = 0; is < nsegments; is++)
         {
          // First the vertices coordinates
          Vector<double> initial_segment_coordinates = 
           this->boundary_segment_initial_coordinate(b)[is];
          Vector<double> final_segment_coordinates = 
           this->boundary_segment_final_coordinate(b)[is];
        
          dump_file << std::setprecision(14) 
                    << initial_segment_coordinates[0] << " " 
                    << initial_segment_coordinates[1]
                    << " # initial segment coordinates for the current boundary"
                    << std::endl;
                
          dump_file << std::setprecision(14) 
                    << final_segment_coordinates[0] << " " 
                    << final_segment_coordinates[1]
                    << " # final segment coordinates for the current boundary"
                    << std::endl;
                
          // ... then the zeta values
        
          if (this->boundary_geom_object_pt(b)!=0)
           {
            const double zeta_segment_initial = 
             this->boundary_segment_initial_zeta(b)[is];
            const double zeta_segment_final =
             this->boundary_segment_final_zeta(b)[is];
          
            dump_file << std::setprecision(14) 
                      << zeta_segment_initial
                      << " # initial segment zeta value for the current boundary"
                      << std::endl;
          
            dump_file << std::setprecision(14) 
                      << zeta_segment_final
                      << " # final segment zeta value for the current boundary" 
                      << std::endl;
           }
          else
           {
            const double arclength_segment_initial = 
             this->boundary_segment_initial_arclength(b)[is];
            const double arclength_segment_final =
             this->boundary_segment_final_arclength(b)[is];
            
            dump_file << std::setprecision(14) 
                      << arclength_segment_initial
                      << " # initial segment arclength for the current boundary"
                      << std::endl;
            
            dump_file << std::setprecision(14) 
                      << arclength_segment_final
                      << " # final segment arclength for the current boundary" 
                      << std::endl;
            
           } // else if (this->boundary_geom_object_pt(b)!=0)
          
         } // for (is < nsegments)
        
       } // if (Assigned_segments_initial_zeta_values[b])
      else
       {
        // The boundary coordinates have NOT been computed then state
        // the flag and save the info.
        dump_file << "0 # assigned boundary coordinates initial zeta values"
                  << std::endl;
       }
      
     } // for (b < nboundary)
    
   } // if (this->is_mesh_distributed())
  
 }
 
 //======================================================================
 /// Used to read info. related with distributed triangle meshes
 //======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::
 read_distributed_info_for_restart(std::istream &restart_file)
 {
  // First check that the mesh is distributed
  if (this->is_mesh_distributed())
   {
    // Read the number of original boundaries
    const unsigned n_boundary = read_unsigned_line_helper(restart_file);
    
#ifdef PARANOID
    if (n_boundary != this->nboundary())
     {
      std::ostringstream error_message;
      error_message
       << "The number of boundaries (" << n_boundary << ") on the "
       << "file used for restarting is different\nfrom the number of "
       << "boundaries ("<< this->nboundary() << ") on the current "
       << "mesh!!!\n\n\n";
      throw OomphLibError(error_message.str(),
                          "TriangleMesh::read_distributed_info_for_restart()",
                          OOMPH_EXCEPTION_LOCATION);
     }
#endif
    
    // Read the number of shared boundaries
    unsigned n_shared_boundaries = 
     read_unsigned_line_helper(restart_file);
    // We need to read the data because it comes in the file (add and
    // substract to avoid compilation warning)
    n_shared_boundaries++;
    n_shared_boundaries--;
    
    // Read the initial and final shared boundaries ids
    unsigned init_shd_bnd_id = read_unsigned_line_helper(restart_file);
    // We need to read the data because it comes in the file (add and
    // substract to avoid compilation warning)
    init_shd_bnd_id++;
    init_shd_bnd_id--;
    // Add and substract to avoid compilation warning
    unsigned final_shd_bnd_id = read_unsigned_line_helper(restart_file);
    // We need to read the data because it comes in the file (add and
    // substract to avoid compilation warning)
    final_shd_bnd_id++;
    final_shd_bnd_id--;
    
    // Read the number of processors involved in the generation of
    // mesh before restart
    const unsigned n_procs = read_unsigned_line_helper(restart_file);
    
#ifdef PARANOID
    if (static_cast<int>(n_procs) != this->communicator_pt()->nproc())
     {
      std::ostringstream error_message;
      error_message
       << "The number of previously used processors ("<< n_procs 
       << ") (read from the restart file) is different\nfrom the "
       << "number of current used processors (" 
       << this->communicator_pt()->nproc() << ")\n\n";
      throw OomphLibError(error_message.str(),
                          "TriangleMesh::read_distributed_info_for_restart()",
                          OOMPH_EXCEPTION_LOCATION);
     }
#endif
      
    // Clear all previuos info. related with shared boundaries
    this->shared_boundaries_ids().clear();
    this->shared_boundary_from_processors().clear();
    this->shared_boundary_overlaps_internal_boundary().clear();

    // Create the storage for the shared boundaries ids related with
    // the processors
    this->shared_boundaries_ids().resize(n_procs);

    // Now read the processors ids and the shared boundary created
    // by them
    for (unsigned ip = 0; ip < n_procs; ip++)
     {
      // Create the storage for the shared boundaries ids related with
      // the processors
      this->shared_boundaries_ids(ip).resize(n_procs);
      for (unsigned jp = 0; jp < n_procs; jp++)
       {
        if (ip != jp)
         {
          // Read the number of shared boundaries with in these two
          // processors
          const unsigned nshared_boundaries_iproc_jproc = 
           read_unsigned_line_helper(restart_file);
          for (unsigned is = 0; is < nshared_boundaries_iproc_jproc; is++)
           {
            // Get the processors
            unsigned tmp_ip;
            restart_file >> tmp_ip;
            unsigned tmp_jp;
            restart_file >> tmp_jp;
            
            // Get the shared boundary id created by these two
            // processors
            const unsigned shared_boundary_id = 
             read_unsigned_line_helper(restart_file);
            
            // Update the info. of the processors that give rise to
            // the shared boundaries
            this->shared_boundaries_ids(ip, jp).
             push_back(shared_boundary_id);

            // Update the structure that states the processors that
            // gave rise to the shared boundary
            Vector<unsigned> processors(2);
            processors[0] = ip;
            processors[1] = jp;
            this->shared_boundary_from_processors()[shared_boundary_id] = 
             processors;

           } // for (is < nshared_boundaries_iproc_jproc)
         }
       } // for (jp < n_procs)
     } // for (ip < n_procs)

    // Now read the info. that states which shared boundary overlaps
    // an internal boundary
      
    // First check if there are shared boundaries overlapping internal
    // boundaries
    const unsigned nshared_boundaries_overlap_internal_boundaries = 
     read_unsigned_line_helper(restart_file);
    
    for (unsigned isb = 0; 
         isb < nshared_boundaries_overlap_internal_boundaries;
         isb++)
     {
      // Read the shared boundary that overlaps an internal boundary
      unsigned shared_boundary_overlapping;
      restart_file >> shared_boundary_overlapping;
      // ... and read the internal boundary that overlaps
      const unsigned overlapped_internal_boundary =  
       read_unsigned_line_helper(restart_file);
      
      // Re-establish the info. of the shared boundaries overlapped
      // by internal boundaries
      this->shared_boundary_overlaps_internal_boundary()
       [shared_boundary_overlapping] = overlapped_internal_boundary;
     } // for (isb < nshared_boundaries_overlap_internal_boundaries)
    
    // Now read the info. related with the initial and final
    // boundary coordinates for each original boundary
    
    // Go through all the (original) boundaries to update the initial
    // and final boundary coordinates
    for (unsigned b = 0; b < n_boundary; b++)
     {
      // For each boundary check if the boundary coordinates initial
      // and final zeta vales were assigned in the restart file
      const unsigned boundary_coordinates_initial_zeta_values_assigned = 
       read_unsigned_line_helper(restart_file);
      
      if (boundary_coordinates_initial_zeta_values_assigned)
       {
        // Clear any previous stored info. There should not be
        // info. already stored but better clear the info. for the
        // boundary
        Boundary_initial_coordinate[b].clear();
        Boundary_final_coordinate[b].clear();
        
        Boundary_initial_zeta_coordinate[b].clear();
        Boundary_final_zeta_coordinate[b].clear();
        
        // The info. for the segments
        Boundary_segment_inverted[b].clear();
        Boundary_segment_initial_coordinate[b].clear();
        Boundary_segment_final_coordinate[b].clear();
        
        Boundary_segment_initial_zeta[b].clear();
        Boundary_segment_final_zeta[b].clear();
        
        Boundary_segment_initial_arclength[b].clear();
        Boundary_segment_final_arclength[b].clear();
      
        // Read the initial and final boundary coordinates, same as
        // the initial and final zeta values for each boundary
      
        // First the vertices coordinates
        Vector<double> initial_coordinates(2);
      
        // Read the initial coordinates
        restart_file >> initial_coordinates[0] >> initial_coordinates[1];
      
        // Ignore rest of line
        restart_file.ignore(80,'\n');
      
        Vector<double> final_coordinates(2);
      
        // Read the final coordinates
        restart_file >> final_coordinates[0] >> final_coordinates[1];
      
        // Ignore rest of line
        restart_file.ignore(80,'\n');
      
        // Set the values in the containers
        

        this->boundary_initial_coordinate(b)=initial_coordinates;
        this->boundary_final_coordinate(b)=final_coordinates;
      
        // ... now read the zeta values
        Vector<double> zeta_initial(1);
        restart_file >> zeta_initial[0];
      
        // Ignore rest of line
        restart_file.ignore(80,'\n');
      
        Vector<double> zeta_final(1);
        restart_file >> zeta_final[0];
      
        // Ignore rest of line
        restart_file.ignore(80,'\n');
      
        // Set the values in the containers
        this->boundary_initial_zeta_coordinate(b) = zeta_initial;
        this->boundary_final_zeta_coordinate(b) = zeta_final;
        
        // Get the curent boundary id from the restart file
        unsigned current_boundary;
        restart_file >> current_boundary;

#ifdef PARANOID
        if (current_boundary != b)
         {
          std::ostringstream error_message;
          error_message
           << "The current boundary id from the restart file (" 
           << current_boundary << ") is different from\nthe boundary id "
           << b << "currently used to re-establish the initial and\nfinal "
           << "segment's zeta values\n\n";
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::read_distributed_info_for_restart()",
                              OOMPH_EXCEPTION_LOCATION);
         }
#endif
        
        // ... and its number of segments
        unsigned nsegments;
        restart_file >> nsegments;
        
        // Ignore rest of line
        restart_file.ignore(80,'\n');
      
        // Now read all the segments info.
      
        // ... and then save that info for each segments
        for (unsigned is = 0; is < nsegments; is++)
         {
          // First the vertices coordinates
          Vector<double> initial_segment_coordinates(2);
        
          // Read the initial coordinates
          restart_file >> initial_segment_coordinates[0] 
                       >> initial_segment_coordinates[1];
        
          // Ignore rest of line
          restart_file.ignore(80,'\n');
        
          Vector<double> final_segment_coordinates(2);
        
          // Read the final coordinates
          restart_file >> final_segment_coordinates[0] 
                       >> final_segment_coordinates[1];
        
          // Ignore rest of line
          restart_file.ignore(80,'\n');
        
          // Set the values in the containers
          this->boundary_segment_initial_coordinate(b).push_back(
           initial_segment_coordinates);
          this->boundary_segment_final_coordinate(b).push_back(
           final_segment_coordinates);
        
          // ... then the zeta values for the segment
          if (this->boundary_geom_object_pt(b)!=0)
           {
            Vector<double> zeta_segment_initial(1);
            restart_file >> zeta_segment_initial[0];

            // Ignore rest of line
            restart_file.ignore(80,'\n');
          
            Vector<double> zeta_segment_final(1);
            restart_file >> zeta_segment_final[0];
          
            // Ignore rest of line
            restart_file.ignore(80,'\n');
          
            // Set the values in the containers for the segment
            this->boundary_segment_initial_zeta(b).push_back(
             zeta_segment_initial[0]);
            this->boundary_segment_final_zeta(b).push_back(
             zeta_segment_final[0]);
           }
          else
           {
            Vector<double> arclength_segment_initial(1);
            restart_file >> arclength_segment_initial[0];

            // Ignore rest of line
            restart_file.ignore(80,'\n');
          
            Vector<double> arclength_segment_final(1);
            restart_file >> arclength_segment_final[0];

            // Ignore rest of line
            restart_file.ignore(80,'\n');

            // Set the values in the containers for the segment
            this->boundary_segment_initial_arclength(b).push_back(
             arclength_segment_initial[0]);
            this->boundary_segment_final_arclength(b).push_back(
             arclength_segment_final[0]);
           } // else if (this->boundary_geom_object_pt(b)!=0)
        
         } // for (is < nsegments)
        
       } // if (boundary_coordinates_initial_zeta_values_assigned)
      
     } // for (b < n_boundary)
    
   } // if (this->is_mesh_distributed())
  
 }
  
#endif // #ifdef OOMPH_HAS_MPI
#endif // #ifdef OOMPH_HAS_TRIANGLE_LIB
 
 //===================================================================
 // Output the nodes on the boundaries and their / respective boundary
 // coordinates(into separate tecplot / zones)
 //===================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::output_boundary_coordinates(const unsigned &b, 
                                                         std::ostream &outfile)
 {
  // First get all the elements adjacent to the given boundary, then
  // the face elements and extract the nodes on the boundaries using
  // the face elements. We can not use the data structure
  // Boundary_node_pt since the multi_domain functions add nodes there
  // without assigning the required boundary coordinate
  
  // Store the nodes in a set so we do not have repeated nodes
  std::set<Node*> boundary_nodes_pt;
  const unsigned n_boundary_ele = this->nboundary_element(b);
  for (unsigned e = 0; e < n_boundary_ele; e++)
   {
    // Get the boundary bulk element
    FiniteElement* bulk_ele_pt = this->boundary_element_pt(b, e);
#ifdef OOMPH_HAS_MPI
    // Only work with nonhalo elements if the mesh is distributed
    if (!bulk_ele_pt->is_halo())
     {
#endif
      // Get the face index
      int face_index = this->face_index_at_boundary(b, e);
      // Create the face element
      FiniteElement* face_ele_pt = new DummyFaceElement<ELEMENT> (
       bulk_ele_pt, face_index);
      
      // Get the number of nodes on the face element
      const unsigned n_nodes = face_ele_pt->nnode();
      for (unsigned i = 0; i < n_nodes; i++)
       {
        // Get the nodes in the face elements
        Node* tmp_node_pt = face_ele_pt->node_pt(i);
        // Add the nodes to the set of boundary nodes
        boundary_nodes_pt.insert(tmp_node_pt);
       } // for (i < n_nodes)
      
      // Free the memory allocated for the face element
      delete face_ele_pt;
      face_ele_pt = 0;
#ifdef OOMPH_HAS_MPI
     } // if (!bulk_ele_pt->is_halo())
#endif
    
   } // for (e < n_boundary_ele)
  
  outfile << "ZONE T=\"Boundary nodes" << b << "\"\n";
  // Set to store the boundary nodes in order
  std::set<Vector<double> > set_node_coord;
  // Loop over the nodes on the boundary and store them in the set
  for (std::set<Node*>::iterator it = boundary_nodes_pt.begin();
       it != boundary_nodes_pt.end(); it++)
   {
    Node *inode_pt = (*it);
    
    // Get the node coordinates
    const unsigned n_dim = inode_pt->ndim();
    Vector<double> node_coord(n_dim+1);
    
    // Get the boundary coordinate
    Vector<double> zeta(1);
    inode_pt->get_coordinates_on_boundary(b, zeta);
    node_coord[0] = zeta[0];
    for (unsigned j = 0; j < n_dim; j++)
     {
      node_coord[j+1] = inode_pt->x(j);
     }
    set_node_coord.insert(node_coord);
   }
  
  for (std::set<Vector<double> >::iterator it = set_node_coord.begin();
       it != set_node_coord.end(); it++)
   {
    // Get the node coordinates
    Vector<double> node_coord = (*it);
    
    // Output the node coordinates
    const unsigned n_dim = node_coord.size()-1;
    for (unsigned j = 0; j < n_dim; j++)
     {
      outfile << node_coord[j+1] << " ";
     }
    // ... add an extra coordinate to avoid error with tecplot
    outfile << "0.0" << std::endl;
   }
  
  // ... loop again to plot the bound coordinates
  outfile << "ZONE T=\"Boundary coordinates " << b << "\"\n";
  for (std::set<Vector<double> >::iterator it = set_node_coord.begin();
       it != set_node_coord.end(); it++)
   {
    // Get the node coordinates
    Vector<double> node_coord = (*it);
    
    // Output the node coordinates
    const unsigned n_dim = node_coord.size()-1;
    for (unsigned j = 0; j < n_dim; j++)
     {
      outfile << node_coord[j+1] << " ";
     }
    
    // Output the boundary coordinate
    outfile << node_coord[0] << std::endl;
   }
    
 }

#ifdef OOMPH_HAS_MPI
 //====================================================================
 // \short Creates the distributed domain representation. Joins the
 // original boundaires, shared boundaries and creates connections among
 // them to create the new polygons that represent the distributed
 // domain
 //====================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::create_distributed_domain_representation(
  Vector<TriangleMeshPolygon *> &polygons_pt,
  Vector<TriangleMeshOpenCurve*> &open_curves_pt)
 {  
  // Get the outer polygons, internal polygons, internal open curves
  // and join them with the shared polylines to create the distributed
  // domain representation (the new outer, internal polygons, and new
  // internal open curves)
  
  // Get the rank of the current processor
  const unsigned my_rank = this->communicator_pt()->my_rank();
  
  // *********************************************************************
  // Step (2) Get the outer, internal and shared boundaries to create the
  //          new polygons
  // *********************************************************************
  
  // *********************************************************************
  // Step (2.1) Get the outer boundaries and check if it is necessary to use
  // a new representation (for example when the boundary was splitted in
  // the distribution process)
  // *********************************************************************

  // Storage for new created polylines, non sorted
  Vector<TriangleMeshPolyLine *> unsorted_outer_polyline_pt;
  
  // Storing for the polylines on the boundaries
  // The first index is for a set of connected polylines
  // The second index is for a polyline on a set of connected polylines
  Vector<Vector<TriangleMeshPolyLine *> > sorted_outer_curves_pt;
  
  // Copy the outer boundaries to the vector of polylines
  const unsigned nouter=this->Outer_boundary_pt.size();
  for (unsigned i = 0; i < nouter; i++)
   {
    const unsigned npolylines = this->Outer_boundary_pt[i]->npolyline();
    for (unsigned p = 0; p < npolylines; p++)
     {
      // Pointer to the current polyline
      TriangleMeshPolyLine *tmp_polyline_pt = 
       this->Outer_boundary_pt[i]->polyline_pt(p);
      const unsigned nvertex = tmp_polyline_pt->nvertex();
      if (nvertex > 0)
       {
        // Get the boundary id of the polyline and check if that boundary
        // needs a new representation (for example when the boundary was
        // splitted in the distribution process)
        const unsigned bound_id = tmp_polyline_pt->boundary_id();
        if (!boundary_was_splitted(bound_id))
         {
          unsorted_outer_polyline_pt.push_back(tmp_polyline_pt);
         } // if (!boundary_was_splitted(bound_id))
        else
         {
          // Get the polylines that will represent this boundary
          Vector<TriangleMeshPolyLine*> tmp_vector_polylines =
           boundary_subpolylines(bound_id);
          const unsigned nsub_poly = tmp_vector_polylines.size();
#ifdef PARANOID
          if (nsub_poly <= 1)
           {
            std::ostringstream error_message;
            error_message
             <<"The boundary ("<<bound_id<<") was marked to be splitted but\n"
             <<"there are only ("<<nsub_poly<<") polylines to represent it.\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
           }
#endif
          // Add the new representation of the polylines (sub-polylines)
          // to represent this boundary
          for (unsigned isub = 0; isub < nsub_poly; isub++)
           {
            unsorted_outer_polyline_pt.push_back(tmp_vector_polylines[isub]);
#ifdef PARANOID
            const unsigned nsvertex = tmp_vector_polylines[isub]->nvertex();
            if (nsvertex == 0)
             {
              std::ostringstream error_message;
              error_message
               << "The current chunk ("<< isub <<") of the polyline with\n"
               << "boundary id (" << bound_id << ") has no vertices\n";
              throw OomphLibError(error_message.str(),
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
             } // if (nsvertex == 0)
#endif // #ifdef PARANOID
           } // for (isub < nsub_poly)
         } // else if (!boundary_was_splitted(bound_id))
       } // if (nvertex > 0)
     } // for (p < npolylines)
   } // for (i < nouter)
  
  // Get the number of unsorted polylines
  unsigned nunsorted_outer_polyline = unsorted_outer_polyline_pt.size();  
  if (nunsorted_outer_polyline > 0)
   {
    
    // Now that we have all the new unsorted polylines it is time to sort them
    // so they be all contiguous
    sort_polylines_helper(unsorted_outer_polyline_pt, sorted_outer_curves_pt);
    
   } // if (nunsorted_outer_polyline > 0)
  
  // *********************************************************************
  // Step (2.2) Get the internal closed boundaries and check if it is
  // necessary to use a new representation (for example when the boundary
  // was splitted in the distribution process)
  // *********************************************************************

  // Storage for new created polylines, non sorted
  Vector<TriangleMeshPolyLine *> unsorted_internal_closed_polyline_pt;
  
  // Storing for the polylines on the boundaries
  // The first index is for a set of connected polylines
  // The second index is for a polyline on a set of connected polylines
  Vector<Vector<TriangleMeshPolyLine *> > sorted_internal_closed_curves_pt;
  
  // Copy the internal closed boundaries to the vector of polylines
  const unsigned ninternal_closed=this->Internal_polygon_pt.size();
  for (unsigned i = 0; i < ninternal_closed; i++)
   {
    const unsigned npolylines = this->Internal_polygon_pt[i]->npolyline();
    for (unsigned p = 0; p < npolylines; p++)
     {
      // Pointer to the current polyline
      TriangleMeshPolyLine *tmp_polyline_pt = 
       this->Internal_polygon_pt[i]->polyline_pt(p);
      const unsigned nvertex = tmp_polyline_pt->nvertex();
      if (nvertex > 0)
       {
        // Get the boundary id of the polyline and check if that boundary
        // needs a new representation (for example when the boundary was
        // splitted in the distribution process)
        const unsigned bound_id = tmp_polyline_pt->boundary_id();
        if (!boundary_was_splitted(bound_id))
         {
          unsorted_internal_closed_polyline_pt.push_back(tmp_polyline_pt);
         } // if (!boundary_was_splitted(bound_id))
        else
         {
          // Get the polylines that will represent this boundary
          Vector<TriangleMeshPolyLine*> tmp_vector_polylines =
           boundary_subpolylines(bound_id);
          const unsigned nsub_poly = tmp_vector_polylines.size();
#ifdef PARANOID
          if (nsub_poly <= 1)
           {
            std::ostringstream error_message;
            error_message
             <<"The boundary ("<<bound_id<<") was marked to be splitted but\n"
             <<"there are only ("<<nsub_poly<<") polylines to represent it.\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
           }
#endif
          // Add the new representation of the polylines (sub-polylines)
          // to represent this boundary
          for (unsigned isub = 0; isub < nsub_poly; isub++)
           {
            unsorted_internal_closed_polyline_pt.push_back(tmp_vector_polylines[isub]);
#ifdef PARANOID
            const unsigned nsvertex = tmp_vector_polylines[isub]->nvertex();
            if (nsvertex == 0)
             {
              std::ostringstream error_message;
              error_message
               << "The current chunk ("<< isub <<") of the polyline with\n"
               << "boundary id (" << bound_id << ") has no vertices\n";
              throw OomphLibError(error_message.str(),
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
             } // if (nsvertex == 0)
#endif // #ifdef PARANOID
           } // for (isub < nsub_poly)
         } // else if (!boundary_was_splitted(bound_id))
       } // if (nvertex > 0)
     } // for (p < npolylines)
   } // for (i < ninternal_closed)
  
  const unsigned nunsorted_internal_closed_polyline = 
   unsorted_internal_closed_polyline_pt.size();
  
  if (nunsorted_internal_closed_polyline > 0)
   {
    // Now that we have all the new unsorted polylines it is time to sort them
    // so they be all contiguous
    sort_polylines_helper(unsorted_internal_closed_polyline_pt,
                          sorted_internal_closed_curves_pt);
   }
  
  // *********************************************************************
  // Step (2.3) Get the internal open boundaries and check if it is
  // necessary to use a new representation (for example when the boundary
  // was splitted in the distribution process)
  // *********************************************************************

  // Storage for new created polylines, non sorted
  Vector<TriangleMeshPolyLine *> unsorted_internal_open_polyline_pt;
  
  // Storing for the polylines on the boundaries
  // The first index is for a set of connected polylines
  // The second index is for a polyline on a set of connected polylines
  Vector<Vector<TriangleMeshPolyLine *> > sorted_internal_open_curves_pt;
  
  // Copy the internal open boundaries to the vector of polylines
  const unsigned ninternal_open = this->Internal_open_curve_pt.size();
  for (unsigned i = 0; i < ninternal_open; i++)
   {
    const unsigned ncurve_section = 
     this->Internal_open_curve_pt[i]->ncurve_section();
    for (unsigned p = 0; p < ncurve_section; p++)
     {
      // Pointer to the current polyline
      TriangleMeshPolyLine *tmp_polyline_pt = 
       this->Internal_open_curve_pt[i]->polyline_pt(p);
      const unsigned nvertex = tmp_polyline_pt->nvertex();
      if (nvertex > 0)
       {
        // Get the boundary id of the polyline and check if that boundary
        // needs a new representation (for example when the boundary was
        // splitted in the distribution process)
        const unsigned bound_id = tmp_polyline_pt->boundary_id();
        if (!boundary_was_splitted(bound_id))
         {
          // Only include as internal boundaries those not marked as
          // shared boundaries
          if (!boundary_marked_as_shared_boundary(bound_id, 0))
           {
            unsorted_internal_open_polyline_pt.push_back(tmp_polyline_pt);
           }
         } // if (!boundary_was_splitted(bound_id))
        else
         {
          // Get the polylines that will represent this boundary
          Vector<TriangleMeshPolyLine*> tmp_vector_polylines =
           boundary_subpolylines(bound_id);
          const unsigned nsub_poly = tmp_vector_polylines.size();
#ifdef PARANOID
          if (nsub_poly <= 1)
           {
            std::ostringstream error_message;
            error_message
             <<"The boundary ("<<bound_id<<") was marked to be splitted but\n"
             <<"there are only ("<<nsub_poly<<") polylines to represent it.\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
           }
#endif
          // Add the new representation of the polylines (sub-polylines)
          // to represent this boundary
          for (unsigned isub = 0; isub < nsub_poly; isub++)
           {
            // Only include as internal boundaries those not marked as
            // shared boundaries
            if (!boundary_marked_as_shared_boundary(bound_id, isub))
             {
              unsorted_internal_open_polyline_pt.push_back(tmp_vector_polylines[isub]);
             }
#ifdef PARANOID
            const unsigned nsvertex = tmp_vector_polylines[isub]->nvertex();
            if (nsvertex == 0)
             {
              std::ostringstream error_message;
              error_message
               << "The current chunk ("<< isub <<") of the polyline with\n"
               << "boundary id (" << bound_id << ") has no vertices\n";
              throw OomphLibError(error_message.str(),
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
             } // if (nsvertex == 0)
#endif // #ifdef PARANOID
           } // for (isub < nsub_poly)
         } // else if (!boundary_was_splitted(bound_id))
       } // if (nvertex > 0)
     } // for (p < npolylines)
   } // for (i < ninternal_open)
  
  const unsigned nunsorted_internal_open_polyline = 
   unsorted_internal_open_polyline_pt.size();
  
  if (nunsorted_internal_open_polyline > 0)
   {
    // Now that we have all the new unsorted polylines it is time to sort them
    // so they be all contiguous
    sort_polylines_helper(unsorted_internal_open_polyline_pt,
                          sorted_internal_open_curves_pt);
   }
  
  // ********************************************************************
  // Step (2.4) Sort the polylines on the shared boundaries
  // ********************************************************************
  
  // Storage for new created polylines, non sorted
  Vector<TriangleMeshPolyLine *> unsorted_shared_polyline_pt;
  
  // Special storage for the shared polylines that will be also used
  // to connect with the internal boundaries
  Vector<TriangleMeshPolyLine *> unsorted_shared_to_internal_polyline_pt;
  
  // Storing for the polylines on the shared boundaries
  // The first index is for a set of connected polylines
  // The second index is for a polyline on a set of connected polylines
  Vector<Vector<TriangleMeshPolyLine *> > sorted_shared_curves_pt;

  // Copy the shared boudaries to the vector of polylines
  const unsigned ncurves = nshared_boundary_curves(my_rank);
  for (unsigned i = 0; i < ncurves; i++)
   {
    const unsigned npolylines = nshared_boundary_polyline(my_rank, i);
    for (unsigned p = 0; p < npolylines; p++)
     {
      const unsigned nvertex = 
       shared_boundary_polyline_pt(my_rank, i, p)->nvertex();
      if (nvertex > 0)
       {
        TriangleMeshPolyLine *tmp_shared_poly_pt = 
         shared_boundary_polyline_pt(my_rank, i, p);
        
        // First check if there are shared boundaries overlapping
        // internal boundaries
        if (this->nshared_boundary_overlaps_internal_boundary() > 0)
         {
          // Get the boundary id of the shared polyline
          const unsigned shd_bnd_id = tmp_shared_poly_pt->boundary_id();
          // If the shared polyline is marked as internal boundary
          // then include it in the special storage to look for
          // connection with internal boundaries
          if (this->shared_boundary_overlaps_internal_boundary(shd_bnd_id))
           {
            unsorted_shared_to_internal_polyline_pt.push_back(
             tmp_shared_poly_pt);
           }
         }
        unsorted_shared_polyline_pt.push_back(tmp_shared_poly_pt);
       }
     }
   }
    
  // Get the total number of shared polylines
  const unsigned nunsorted_shared_polyline = 
   unsorted_shared_polyline_pt.size();

  if (nunsorted_shared_polyline > 0)
   {
    // Now that we have all the new unsorted polylines it is time to
    // sort them so they be all contiguous
    sort_polylines_helper(unsorted_shared_polyline_pt, sorted_shared_curves_pt);
   }
  
  // ********************************************************************
  // Step (3) Join the boundaries (shared, internal and outer to
  // create the new polygons)
  // ********************************************************************
  
  // Create the set of curves that will be used to create the new polygons
  // Get the total number of curves
  const unsigned nouter_curves = sorted_outer_curves_pt.size();
  const unsigned ninternal_closed_curves = 
   sorted_internal_closed_curves_pt.size();
  const unsigned nshared_curves = sorted_shared_curves_pt.size();
  const unsigned ntotal_curves = nouter_curves + 
                                 ninternal_closed_curves + 
                                 nshared_curves;
  
  // Add all the polylines to a container
  unsigned counter = 0;
  Vector<Vector<TriangleMeshPolyLine *> > all_curves_pt(ntotal_curves);
  
  // Add the shared curves first, this ensure the generation of
  // internal polygons defined by the shared boundaries
  for (unsigned i = 0; i < nshared_curves; i++,counter++)
   {
    all_curves_pt[counter] = sorted_shared_curves_pt[i];
   }
  
  // Add the internal polygons (if any)
  for (unsigned i = 0; i < ninternal_closed_curves; i++,counter++)
   {
    all_curves_pt[counter] = sorted_internal_closed_curves_pt[i];
   }
  
  // Add the outer polygons
  for (unsigned i = 0; i < nouter_curves; i++,counter++)
   {
    all_curves_pt[counter] = sorted_outer_curves_pt[i];
   }

  // Create the temporary version of the domain by joining the new
  // polylines
  this->create_tmp_polygons_helper(all_curves_pt,polygons_pt);
  // Create the new open curves
  this->create_tmp_open_curves_helper(sorted_internal_open_curves_pt,
                                      unsorted_shared_to_internal_polyline_pt,
                                      open_curves_pt);
  
  // ********************************************************************
  // Step (4) Create connections among the outer boundaries
  // (intersections with themselves)
  // ********************************************************************

  // After creating the new boundaries representation (polylines)
  // establish the connections of the shared boundaries (with
  // themselves or with the original boundaries). This avoids the
  // multiple definition of vertices in the domain which cause
  // problems when calling Triangle
  
  this->create_shared_polylines_connections();
  
  // ------------------------------------------------------------------
  // Compute the new holes information. Those from the
  // extra_holes_coordinates container, and those from the original
  // closed boundaries. Add the holes created by the halo elements
  // adjacent to the shared boundaries
  
  // The storage for the new holes, get those from the
  // extra_holes_coordinates container and those from the internal
  // closed boundaries that are defined as holes
  Vector<Vector<double> > new_holes_coordinates;
  
  // Copy the holes (those defined by the original internal closed
  // boundaries and those in the extra holes container)
  
  // The holes defined by the original internal closed boundaries
  const unsigned n_holes = this->Internal_polygon_pt.size();
  for (unsigned h = 0; h < n_holes; h++)
   {
    Vector<double> hole_coordinates = 
     this->Internal_polygon_pt[h]->internal_point();
    // If the closed boundary is a hole, then copy its hole
    if (!hole_coordinates.empty())
     {
      new_holes_coordinates.push_back(hole_coordinates);
     }
   } // for (h < n_holes)
  
  // Is this the first time we are going to copy the extra holes
  // coordinates
  if (First_time_compute_holes_left_by_halo_elements)
   {
    // The holes in the extra holes container
    const unsigned n_extra_holes = Extra_holes_coordinates.size();
    for (unsigned h = 0; h < n_extra_holes; h++)
     {
      Vector<double> hole_coordinates = Extra_holes_coordinates[h];
      new_holes_coordinates.push_back(hole_coordinates);
     } // for (h < n_extra_holes)
    
    // Copy the extra holes coordinates
    Original_extra_holes_coordinates = Extra_holes_coordinates;
    
    // Set the flag to false
    First_time_compute_holes_left_by_halo_elements = false;
    
   } // if (First_time_compute_holes_left_by_halo_elements)
  else
   {
    // Not the first time, then only copy the original extra holes
    // coordinates
    const unsigned n_original_extra_holes = 
     Original_extra_holes_coordinates.size();
    for (unsigned h = 0; h < n_original_extra_holes; h++)
     {
      Vector<double> hole_coordinates = Original_extra_holes_coordinates[h];
      new_holes_coordinates.push_back(hole_coordinates);
     } // for (h < n_original_extra_holes)
   }
  
  // Add the holes created by the halo elements adjacent to the shared
  // boundaries
  compute_holes_left_by_halo_elements_helper(new_holes_coordinates);
  
  // Update the holes information, only use the coordinate inside the
  // poylgons that define the new domain
  update_holes_information_helper(polygons_pt, new_holes_coordinates);
  
  // tachidok Clear the storage by now
  //new_holes_coordinates.clear();
  
  // Now copy the info. in the extra holes coordinates container
  Extra_holes_coordinates = new_holes_coordinates;
  
  // Do not delete halo(ed) info., this will be "deleted"
  // automatically by not passing that information to the new adapted
  // mesh. Once the transfer of target areas is performed the halo(ed)
  // information is no longer required
  
 }

 //======================================================================
 // \short Take the polylines from the shared boundaries and the boundaries
 // to create polygons
 //======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::
 create_tmp_polygons_helper(Vector<Vector<TriangleMeshPolyLine *> > 
                            &polylines_pt,
                            Vector<TriangleMeshPolygon *> &polygons_pt)
 {
  // Each vector of polylines (curve) is already sorted, it means that
  // all the polylines on the vector polylines_pt[i] point to the same
  // direction
  
  // --- Using this fact we should compare the first and last points from
  //     these arrays of polylines (curves) and compare with the others
  //     vectors of polylines (curves) end points
  // --- Once created a closed curve create a polygon
  
  // The number of curves
  const unsigned ncurves = polylines_pt.size();
  
  // The number of non sorted curves
  const unsigned nunsorted_curves = ncurves;
  // The number of sorted curves
  unsigned nsorted_curves = 0;

  // Vector to know which ncurve is already done
  std::vector<bool> done_curve(ncurves);

  do
   {
    // The list where to add the curves so that they be contiguous
    std::list<Vector<TriangleMeshPolyLine*> > list_building_polygon_pt;
#ifdef PARANOID
    // Flag to indicate that a root curve was found
    bool root_curve_found = false;
#endif
    
    // The index for the root_curve (we use it in further iterations as the
    // starting index so we dont need to search in already done curves)
    unsigned root_curve_idx = 0;

    // Get the root curve
    for (unsigned ic = 0; ic < ncurves; ic++)
     {
      if (!done_curve[ic])
       {
        root_curve_idx = ic;
        nsorted_curves++;
#ifdef PARANOID
        root_curve_found = true;
#endif
        done_curve[ic] = true;
        // ... break the loop
        break;
       }
     }

#ifdef PARANOID
    if (!root_curve_found)
     {
      std::stringstream err;
      err <<"The root curve to create a polygon from the shared and "
          <<"original boundaries was not found!!!\n";
      throw OomphLibError(err.str(),
                          "TriangleMesh::create_tmp_polygons_helper()",
                          OOMPH_EXCEPTION_LOCATION);
     }
#endif

    // Get the root curve
    Vector<TriangleMeshPolyLine*> root_curve_pt=polylines_pt[root_curve_idx];

    // Add the root curve to the list
    list_building_polygon_pt.push_back(root_curve_pt);

    // Get the initial and final vertices from the root curve
    Vector<double> root_curve_initial_vertex(2);
    Vector<double> root_curve_final_vertex(2);
    
    // We need to get the number of polylines that compose the root curve
    const unsigned nroot_curve_polyline = root_curve_pt.size();
    // ... and now get the initial and final vertex
    root_curve_pt[0]->initial_vertex_coordinate(root_curve_initial_vertex);
    root_curve_pt[nroot_curve_polyline-1]->
     final_vertex_coordinate(root_curve_final_vertex);
    
    // First check if it already create a polygon
    double diff = 
     ((root_curve_initial_vertex[0] - root_curve_final_vertex[0])*
      (root_curve_initial_vertex[0] - root_curve_final_vertex[0]))
     +
     ((root_curve_initial_vertex[1] - root_curve_final_vertex[1])*
      (root_curve_initial_vertex[1] - root_curve_final_vertex[1]));
    diff = sqrt(diff);
    if (diff < ToleranceForVertexMismatchInPolygons::Tolerable_error)
     {
      // The polyline already create a Polygon, then create it!!!
      // Create the curve section representation of the current root curve
      Vector<TriangleMeshCurveSection*> 
       curve_section_pt(nroot_curve_polyline);
      
      // Copy the polylines into its curve section representation
      for (unsigned i = 0; i < nroot_curve_polyline; i++)
       {curve_section_pt[i] = root_curve_pt[i];}
      
      // ... and create the Polygon
      TriangleMeshPolygon *new_polygon_pt = 
       new TriangleMeshPolygon(curve_section_pt);
      
      // Mark the polygon for deletion (in the destructor)
      this->Free_polygon_pt.insert(new_polygon_pt);
      
      // Add the polygon to the output polygons
      polygons_pt.push_back(new_polygon_pt);
     } // (diff < ToleranceForVertexMismatchInPolygons::Tolerable_error)
       // when the curve creates a Polygon by itself
    else
     {
      // Flag to continue iterating while curves be added to the left
      // or right of the list of curves
      bool added_curve = false;
#ifdef PARANOID
      // Flag to know if the "loop" finish because a polygon was
      // created or because no more curves can be added to the left or
      // right
      bool polygon_created = false;
#endif
      do
       {
        added_curve = false;
        // If the root curve does not create a closed polygon then add curves
        // to the left or right until the curves create a closed polygon
        for (unsigned ic = root_curve_idx+1; ic < ncurves; ic++)
         {
          if (!done_curve[ic])
           {
            // Get the current curve
            Vector<TriangleMeshPolyLine*> current_curve_pt = 
             polylines_pt[ic];
        
            // We need to get the number of polylines that compose the
            // current curve
            const unsigned ncurrent_curve_polyline = current_curve_pt.size();
          
            // ... and get the initial and final coordinates for the current
            // curve
            Vector<double> current_curve_initial_vertex(2);
            Vector<double> current_curve_final_vertex(2);

            current_curve_pt[0]->
             initial_vertex_coordinate(current_curve_initial_vertex);
            current_curve_pt[ncurrent_curve_polyline-1]->
             final_vertex_coordinate(current_curve_final_vertex);
            
            // ---------------------------------------------------------------
            // Start adding curves to the left or right
            // ---------------------------------------------------------------
            diff = 
             ((current_curve_final_vertex[0] - root_curve_initial_vertex[0])*
              (current_curve_final_vertex[0] - root_curve_initial_vertex[0]))
             +
             ((current_curve_final_vertex[1] - root_curve_initial_vertex[1])*
              (current_curve_final_vertex[1] - root_curve_initial_vertex[1]));
            diff = sqrt(diff);
            // CURRENT curve to the LEFT of the ROOT curve
            if (diff < ToleranceForVertexMismatchInPolygons::Tolerable_error)
             {
              // Add the current curve to the left
              list_building_polygon_pt.push_front(current_curve_pt);
              // Mark the curve as done
              done_curve[ic] = true;
              // Update the initial vertex values
              root_curve_initial_vertex[0] = current_curve_initial_vertex[0];
              root_curve_initial_vertex[1] = current_curve_initial_vertex[1];
              // Increase the number of sorted curves
              nsorted_curves++;
              // Set the flag to indicate that a curve was added to the list
              added_curve = true;
              break;
             }

            diff = 
             ((current_curve_initial_vertex[0] - root_curve_initial_vertex[0])*
              (current_curve_initial_vertex[0] - root_curve_initial_vertex[0]))
             +
             ((current_curve_initial_vertex[1] - root_curve_initial_vertex[1])*
              (current_curve_initial_vertex[1] - root_curve_initial_vertex[1]));
            diff = sqrt(diff);
            // CURRENT curve to the LEFT of the ROOT curve but INVERTED
            if (diff < ToleranceForVertexMismatchInPolygons::Tolerable_error)
             {
              Vector<TriangleMeshPolyLine*> 
               tmp_curve_pt(ncurrent_curve_polyline);
              // Reverse each polyline and back them up
              for (unsigned it = 0; it < ncurrent_curve_polyline; it++)
               {
                current_curve_pt[it]->reverse();
                tmp_curve_pt[it] = current_curve_pt[it];
               }
              // Now copy them back but in reverse order
              unsigned count = 0;
              for (int i = ncurrent_curve_polyline - 1; i >= 0; i--,count++)
               {current_curve_pt[count] = tmp_curve_pt[i];}
              // Add the current curve to the left
              list_building_polygon_pt.push_front(current_curve_pt);
              // Mark the curve as done
              done_curve[ic] = true;
              // Update the initial vertex values
              root_curve_initial_vertex[0] = current_curve_final_vertex[0];
              root_curve_initial_vertex[1] = current_curve_final_vertex[1];
              // Increase the number of sorted curves
              nsorted_curves++;
              // Set the flag to indicate that a curve was added to the list
              added_curve = true;
              break;
             }
            
            diff = 
             ((current_curve_initial_vertex[0] - root_curve_final_vertex[0])*
              (current_curve_initial_vertex[0] - root_curve_final_vertex[0]))
             +
             ((current_curve_initial_vertex[1] - root_curve_final_vertex[1])*
              (current_curve_initial_vertex[1] - root_curve_final_vertex[1]));
            diff = sqrt(diff);
            // CURRENT curve to the RIGHT of the ROOT curve
            if (diff < ToleranceForVertexMismatchInPolygons::Tolerable_error)
             {
              // Add the current curve to the right
              list_building_polygon_pt.push_back(current_curve_pt);
              // Mark the curve as done
              done_curve[ic] = true;
              // Update the initial vertex values
              root_curve_final_vertex[0] = current_curve_final_vertex[0];
              root_curve_final_vertex[1] = current_curve_final_vertex[1];
              // Increase the number of sorted curves
              nsorted_curves++;
              // Set the flag to indicate that a curve was added to the list
              added_curve = true;
              break;
             }

            diff = 
             ((current_curve_final_vertex[0] - root_curve_final_vertex[0])*
              (current_curve_final_vertex[0] - root_curve_final_vertex[0]))
             +
             ((current_curve_final_vertex[1] - root_curve_final_vertex[1])*
              (current_curve_final_vertex[1] - root_curve_final_vertex[1]));
            diff = sqrt(diff);
            // CURRENT curve to the RIGHT of the ROOT curve but INVERTED
            if (diff < ToleranceForVertexMismatchInPolygons::Tolerable_error)
             {
              Vector<TriangleMeshPolyLine*> 
               tmp_curve_pt(ncurrent_curve_polyline);
              // Reverse each polyline and back them up
              for (unsigned it = 0; it < ncurrent_curve_polyline; it++)
               {
                current_curve_pt[it]->reverse();
                tmp_curve_pt[it] = current_curve_pt[it];
               }
              // Now copy them back but in reverse order
              unsigned count = 0;
              for (int i = ncurrent_curve_polyline - 1; i >= 0; i--,count++)
               {current_curve_pt[count] = tmp_curve_pt[i];}
              // Add the current curve to the right
              list_building_polygon_pt.push_back(current_curve_pt);
              // Mark the curve as done
              done_curve[ic] = true;
              // Update the initial vertex values
              root_curve_final_vertex[0] = current_curve_initial_vertex[0];
              root_curve_final_vertex[1] = current_curve_initial_vertex[1];
              // Increase the number of sorted curves
              nsorted_curves++;
              // Set the flag to indicate that a curve was added to the list
              added_curve = true;
              break;
             }

           } // if (!done_curve[ic])
      
         } // for (ic < ncurves)
        
        // After adding a curve check if it is possible to create a polygon
        double diff = 
         ((root_curve_initial_vertex[0] - root_curve_final_vertex[0])*
          (root_curve_initial_vertex[0] - root_curve_final_vertex[0]))
         +
         ((root_curve_initial_vertex[1] - root_curve_final_vertex[1])*
          (root_curve_initial_vertex[1] - root_curve_final_vertex[1]));
        diff = sqrt(diff);
        if (diff < ToleranceForVertexMismatchInPolygons::Tolerable_error)
         {
          // If the curves already create a Polygon then go out of the
          // loop and create the Polygon
          added_curve = false;
#ifdef PARANOID
          // Set the flag to indicate that a Polygon has been created
          polygon_created = true;
#endif
         } // (diff <
           // ToleranceForVertexMismatchInPolygons::Tolerable_error)
           // when the curve creates a Polygon by itself
        
       }while(added_curve);
      
#ifdef PARANOID
      if (!polygon_created)
       {
        std::stringstream error_message;
        error_message 
         << "It was no possible to create a TriangleMeshPolygon with "
         << "the input set of curves\n"
         << "These are the initial and final vertices in the current "
         << "sorted list of\nTriangleMeshPolyLines\n\n";
        Vector<double> init_vertex(2);
        Vector<double> final_vertex(2);
        unsigned icurve = 0;
        for (std::list<Vector<TriangleMeshPolyLine*> >::iterator it 
              = list_building_polygon_pt.begin();
             it != list_building_polygon_pt.end(); it++, icurve++)
         {
          const unsigned ncurrent_curve_polyline = (*it).size();
          error_message
           << "TriangleMeshCurve #" << icurve << "\n"
           << "-----------------------------------\n";
          for (unsigned ip = 0; ip < ncurrent_curve_polyline; ip++)
           {
            Vector<double> init_vertex(2);
            Vector<double> final_vertex(2);
            (*it)[ip]->initial_vertex_coordinate(init_vertex);
            (*it)[ip]->final_vertex_coordinate(final_vertex);
            error_message
             <<"TriangleMeshPolyLine #" << ip << "\n"
             <<"Initial vertex: ("<<init_vertex[0]<<","<<init_vertex[1]<<")\n"
             <<"Final vertex: ("<<final_vertex[0]<<","<<final_vertex[1]<<")\n";
           } // for (ip < ncurrent_curve_polyline)
         } // for (it != list_building_polygon_pt.end())
        
        throw OomphLibError(error_message.str(), 
                            "TriangleMesh::create_tmp_polygons_helper()",
                            OOMPH_EXCEPTION_LOCATION);
        
       } // if (!polygon_created)
#endif
      
      // Create the polygon after joining the curves
      unsigned ntotal_polylines = 0;
      // Get the total number of polylines
      for (std::list<Vector<TriangleMeshPolyLine*> >::iterator it 
            = list_building_polygon_pt.begin();
           it != list_building_polygon_pt.end(); it++)
       {
        ntotal_polylines+=(*it).size();
       }
      
      // Create the curve section representation of the curves on the list
      Vector<TriangleMeshCurveSection*> curve_section_pt(ntotal_polylines);
      
      // Copy the polylines into its curve section representation
      unsigned counter = 0;
      for (std::list<Vector<TriangleMeshPolyLine*> >::iterator it 
            = list_building_polygon_pt.begin();
           it != list_building_polygon_pt.end(); it++)
       {
        const  unsigned ncurrent_curve_polyline = (*it).size();
        for (unsigned ip = 0; ip < ncurrent_curve_polyline; ip++,counter++)
         {
          curve_section_pt[counter] = (*it)[ip];
         } // for (ip < ncurrent_curve_polyline)
       } // Loop over the list of polylines
      
      // ... and create the Polygon
      TriangleMeshPolygon *new_polygon_pt = 
       new TriangleMeshPolygon(curve_section_pt);
      
      // Mark the polygon for deletion (in the destructor)
      this->Free_polygon_pt.insert(new_polygon_pt);
      
      // Add the polygon to the output polygons
      polygons_pt.push_back(new_polygon_pt);

     } // else 
       // (diff < ToleranceForVertexMismatchInPolygons::Tolerable_error)
    
   }while(nsorted_curves < nunsorted_curves);
  
 }

 //======================================================================
 //\short Take the polylines from the original open curves and created
 //new temporaly representations of open curves with the bits of
 //original curves not overlapped by shared boundaries
 //======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::create_tmp_open_curves_helper(
  Vector<Vector<TriangleMeshPolyLine *> > &sorted_open_curves_pt,
  Vector<TriangleMeshPolyLine*> &unsorted_shared_to_internal_poly_pt,
  Vector<TriangleMeshOpenCurve *> &open_curves_pt)
 {
  // Here search for the connections of the open curves remaining as
  // open curves with the shared boundaries markes as internal
  const unsigned ninternal_open_curves = sorted_open_curves_pt.size();
  
  // Once identified the connections created with the new internal
  // boundaries representations add them to the open curves container
  for (unsigned i = 0; i < ninternal_open_curves; i++)
   {
    // Create the curve section representation of the polylines
    const unsigned npoly = sorted_open_curves_pt[i].size();
    Vector<TriangleMeshCurveSection*> tmp_curve_section(npoly);
    for (unsigned j = 0; j < npoly; j++)
     {
      tmp_curve_section[j] = sorted_open_curves_pt[i][j];
     }
    // ... and create the Open Curve
    TriangleMeshOpenCurve *new_open_curve_pt = 
     new TriangleMeshOpenCurve(tmp_curve_section);
    
    // Mark the open curve for deletion (in the destructor)
    this->Free_open_curve_pt.insert(new_open_curve_pt);
    
    // Add the open curve to the output open curves
    open_curves_pt.push_back(new_open_curve_pt);
    
   } // (i < ninternal_open_curves)
  
 }
 
 //======================================================================
 //\short Check for any possible connections that the array of sorted
 //nodes have with original boundary nodes, previous shared polyline
 //nodes or with itself polyline nodes. In case that there is a
 //connection, get the boundary id to which connects
 //======================================================================
 template<class ELEMENT>
 const int TriangleMesh<ELEMENT>::check_connections_of_polyline_nodes(
  std::set<FiniteElement*> &element_in_processor_pt,
  const int &root_edge_bnd_id,
  std::map<std::pair<Node*,Node*>, bool> &overlapped_face,
  std::map<unsigned, std::map<Node*, bool> > 
  &node_on_bnd_not_overlapped_by_shd_bnd,
  std::list<Node*> &current_polyline_nodes,
  std::map<unsigned, std::list<Node*> > 
  &shared_bnd_id_to_sorted_list_node_pt, 
  const unsigned &node_degree,
  Node* &new_node_pt, 
  const bool called_from_load_balance)
 {
  // Initialize the flag to return
  int flag_to_return = -1;
  
  // --------------------------------------------------------------------
  // First try to find a connection with any original boundary (keep
  // in mind the case when internal boundaries may be overlapped by
  // shared boundaries)
  // --------------------------------------------------------------------
  
  // Check if the shared boundary is overlapping an internal boundary
  bool overlapping_internal_boundary = false;
  // The boundary id overlapped by the current shared boundary
  unsigned internal_overlaping_bnd_id = 0;
  if (root_edge_bnd_id != -1)
   {
    // Set the flat to true
    overlapping_internal_boundary = true;
    // Set the bnd id of the overlapped internal boundary
    internal_overlaping_bnd_id = static_cast<unsigned>(root_edge_bnd_id);
   } // if (root_edge_bnd_id != -1)
  
  // ---------------------------------------------------------------
  // Check if the connection is with an original boundary by checking
  // if the new node is a boundary node, and it lives in an element
  // that is part of the domain
  // ---------------------------------------------------------------
  if (new_node_pt->is_on_boundary())
   {
    // Flag to indicate if the node lives in a non overlapped boundary
    bool is_node_living_in_non_overlapped_boundary = false;

    // If the node is a boundary node then check in which boundary it
    // is
    const unsigned noriginal_bnd = this->initial_shared_boundary_id();
    for (unsigned bb=0;bb<noriginal_bnd;bb++)
     {
      // If the shared boundary overlaps an internal boundary it will
      // be indicated by (root_edge_bnd_id != -1), the original
      // internal boundary that overlaps is given by the
      // root_edge_bnd_id value. We skip that original internal
      // boundary because the new node will be obviously ON the
      // internal boundary
      if (overlapping_internal_boundary)
       {
        // Is the node on boundary bb?
        if (new_node_pt->is_on_boundary(bb))
         {          
          // If overlaping then check that the boundary is different
          // from the one that is being overlapped, or if overlapped
          // then check that the node is on an edge on the bb
          // boundary not overlapped by a shared boundary
          const bool on_bnd_edge_not_overlapped_by_shd_bnd = 
           node_on_bnd_not_overlapped_by_shd_bnd[bb][new_node_pt];
          if (bb != internal_overlaping_bnd_id || 
              ((bb == internal_overlaping_bnd_id) && 
               (on_bnd_edge_not_overlapped_by_shd_bnd)))
           {
            // Is the node living in a non overlapped boundary
            if (bb != internal_overlaping_bnd_id)
             {
              is_node_living_in_non_overlapped_boundary = true;
             }
            
            // Now we need to check that the node lies on a boundary
            // that still exist (the elements associated to the
            // boundary may have been removed at the mesh distribution
            // stage). The node may be still marked as a boundary node
            // but the boundary may not have elements associated.
            
            // Get the number of elements in the boundary
            const unsigned n_bound_ele = this->nboundary_element(bb);
            if (n_bound_ele > 0)
             {
              // Check that node lies on a nonhalo element, those are
              // the elements used to update the domain representation
              for (unsigned e = 0; e < n_bound_ele; e++)
               {
                // Get the boundary bulk element
                FiniteElement* bulk_ele_pt = this->boundary_element_pt(bb, e);
                // Check if the element will be retained, it means it
                // is a nonhalo element
                std::set<FiniteElement*>::iterator it = 
                 element_in_processor_pt.find(bulk_ele_pt);
                // If found then check if the node live in the element
                if (it!=element_in_processor_pt.end())
                 {
                  // Found the node in the nonhalo face element
                  bool found_node = false;
                  // Get the face index
                  int face_index = this->face_index_at_boundary(bb, e);
                  // Create the face element
                  FiniteElement* face_ele_pt = 
                   new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);
                  // Get the number of nodes in the face element
                  const unsigned n_node_face = face_ele_pt->nnode();
                  // Get the first and last node of the face element
                  Node* first_node_pt = face_ele_pt->node_pt(0);
                  Node* last_node_pt = face_ele_pt->node_pt(n_node_face-1);
                  // Create the edge with the pair of nodes
                  std::pair<Node*, Node*> tmp_edge = 
                   std::make_pair(first_node_pt, last_node_pt);
                  // Check if the face element edge is overlapped by a
                  // shared boundary
                  // Is the face not overlapped?
                  if (!overlapped_face[tmp_edge])
                   {
                    // Look for the node in the current face element
                    for (unsigned n = 0; n < n_node_face; n++)
                     {
                      // Check for every individual node
                      if (face_ele_pt->node_pt(n) == new_node_pt)
                       {
                        found_node = true;
                        break;
                       } // if (face_ele_pt->node_pt(n) == new_node_pt)
                     } // for (n < n_node_face)
                   } // if (!overlapped_face[tmp_edge])
                  // Free the memory of the face element
                  delete face_ele_pt;
                  if (found_node)
                   {
                    // return the first original boundary id found,
                    // does not matter if the node lies on more than
                    // one original boundary (with boundary
                    // elements). This is the original boundary id
                    // that will be used to create the connection
                    flag_to_return = bb;
                    return flag_to_return;
                   } // if (found_node)
                  
                 } // if (it!=element_in_processor_pt.end())
                
               } // for (e < n_bound_ele)
              
             } // if (n_bound_ele > 0)
            
           } // if (bb != internal_overlaping_bnd_id || 
             //     ((bb == internal_overlaping_bnd_id) && 
             //      (on_bnd_edge_not_overlapped_by_shd_bnd)))
          
         } // if (nod_pt->is_on_boundary(bb))
        
       } // if (overlapping_internal_boundary)
      else
       {
        // Is the node on boundary bb?
        if (new_node_pt->is_on_boundary(bb))
         {
          // Now we need to check that the node lies on a boundary
          // that still exist (the elements associated to the boundary
          // may have been removed at the mesh distribution
          // stage). The node may be still marked as a boundary node
          // but the boundary may not have elements associated.
          
          // Get the number of elements in the boundary
          const unsigned n_bound_ele = this->nboundary_element(bb);
          if (n_bound_ele > 0)
           {
            // Check that node lies on a nonhalo element, those are
            // the elements used to update the domain representation
            for (unsigned e = 0; e < n_bound_ele; e++)
             {
              // Get the boundary bulk element
              FiniteElement* bulk_ele_pt = this->boundary_element_pt(bb, e);
              // Check if the element will be retained, it means it is
              // a nonhalo element
              std::set<FiniteElement*>::iterator it = 
               element_in_processor_pt.find(bulk_ele_pt);
              // If found then check if the node live in the element
              if (it!=element_in_processor_pt.end())
               {
                // Found the node in the nonhalo face element
                bool found_node = false;
                // Get the face index
                int face_index = this->face_index_at_boundary(bb, e);
                // Create the face element
                FiniteElement* face_ele_pt = 
                 new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);
                // Get the number of nodes in the face element
                const unsigned n_node_face = face_ele_pt->nnode();
                // Get the first and last node of the face element
                Node* first_node_pt = face_ele_pt->node_pt(0);
                Node* last_node_pt = face_ele_pt->node_pt(n_node_face-1);
                // Create the edge with the pair of nodes
                std::pair<Node*, Node*> tmp_edge = 
                 std::make_pair(first_node_pt, last_node_pt);
                // Check if the face element edge is overlapped by a
                // shared boundary
                // Is the face not overlapped?
                if (!overlapped_face[tmp_edge])
                 {
                  // Look for the node in the current face element
                  for (unsigned n = 0; n < n_node_face; n++)
                   {
                    // Check for every individual node
                    if (face_ele_pt->node_pt(n) == new_node_pt)
                     {
                      found_node = true;
                      break;
                     } // if (face_ele_pt->node_pt(n) == new_node_pt)
                   } // for (n < n_node_face)
                 } // if (!overlapped_face[tmp_edge])
                // Free the memory of the face element
                delete face_ele_pt;
                if (found_node)
                 {
                  // return the first original boundary id found, does
                  // not matter if the node lies on more than one
                  // original boundary (with boundary elements). This
                  // is the original boundary id that will be used to
                  // create the connection
                  flag_to_return = bb;
                  return flag_to_return;
                 } // if (found_node)
                
               } // if (it!=element_in_processor_pt.end())
              
             } // for (e < n_bound_ele)
            
           } // if (n_bound_ele > 0)
          
         } // if (nod_pt->is_on_boundary(bb))
       } // else if (overlapping_internal_boundary)
     } // for (bb < noriginal_bnd)
    
    // We will only reach this stage when the node was found to be
    // connected to an original boundary but the element(s) on that
    // boundary where the node should live are not part of the domain.
    // Think in a corner of a triangle which touches the boundary
    // which elements will not be part of the domain
    
    // We need to break the currently forming polyline
    //flag_to_return = -3;
    
    // We need to break the currently forming polyline if and only if
    // the boundary(ies) in which the node is living is(are) not an
    // overlapped boundary
    if (!overlapping_internal_boundary)
     {
      // If the boundary(ies) in which the node is living is(are) an
      // overlapped boundary then break the break the formation of the
      // polyline
      flag_to_return = -3;
     }
    else
     {
      // The boundary is overlapped, if the node lives in a non
      // overlapped boundary then we can break the formation of the
      // polyline
      if (is_node_living_in_non_overlapped_boundary)
       {
        flag_to_return = -3;
       } // if (is_node_living_in_non_overlapped_boundar)y
      
     } // if (!overlapping_internal_boundary)

   } // if (new_node_pt->is_on_boundary())
  
  // Return inmediately if the connection is with an original boundary
  // whose elements are still part of the domain
  if (flag_to_return >= 0)
   {
    return flag_to_return;
   }
  
  // ----------------------------------------------------------------------
  // Secondly, if there is not a connection with any original
  // boundary, or if there is connection but with an original boundary
  // whose elements are not part of the domain, then check for
  // connections with previously created shared polylines
  // ----------------------------------------------------------------------
  // Store all the previous shared polylines to which the current
  // found is found to be connected
  Vector<unsigned> candidate_shared_bnd_to_connect;
  // Check for all the previous polylines except the current one
  for (std::map<unsigned, std::list<Node*> >::iterator it = 
        shared_bnd_id_to_sorted_list_node_pt.begin(); 
       it != shared_bnd_id_to_sorted_list_node_pt.end();
       it++)
   {
    // Get the boundary id of the list of nodes that created the
    // polyline (the shared boundary id associated with the list of
    // nodes)
    const unsigned i_bnd_id = (*it).first;
    // Get an iterator pointer to the list of nodes of the shared
    // polyline
    std::list<Node*>::iterator it_list = (*it).second.begin();
    // Get the total number of nodes associated to the boundary
    const unsigned n_nodes = (*it).second.size();
    // Search for connections in the list of nodes
    for (unsigned i = 0; i < n_nodes; i++, it_list++)
     {
      // Is the node already part of any other shared boundary
      if ((*it_list) == new_node_pt)
       {
        // Include the i-th boundary id in the list of candidate
        // shared boundaries to connect
        candidate_shared_bnd_to_connect.push_back(i_bnd_id);
        // Break the look with the i-th shared boundary, check with
        // the others shared boundaries
        break;
       } // if ((*it_list) == new_node_pt)
      
     } // for (i < nnodes)
    
   } // Loop over the shared boundaries and associated nodes
  
  // Get the number of candidate shared boundaries to connect
  const unsigned n_candidate_shared_bnd_to_connect = 
   candidate_shared_bnd_to_connect.size();
  
  // Is there a connection with any previous shared polyline
  if (n_candidate_shared_bnd_to_connect > 0)
   {
    // If called from load balance we do not need to check if the
    // shared boundary is part of the processor since it certanily is,
    // only the shared boundaries that are pare of the processor are
    // used to created connection when creating the new shared
    // boundaries in the load balance rutine
    if (called_from_load_balance)
     {
       return candidate_shared_bnd_to_connect[0];
     }
    
    // We need to ensure that the shared boundary to which we are
    // connecting is part of the current processor, if none of the
    // found shared bundaries is in the current processor then return
    // the flag for "connection with boundary not in the current
    // processor"
    
    // Store the shared boundaries associated with the current processor
    Vector<unsigned> shared_bound_in_this_proc;
    
    // Get the shared boundaries associated with the current processor
    shared_boundaries_in_this_processor(shared_bound_in_this_proc);
    
    // If any of the candidate shared boundaries to connect is in the
    // current processor then return that shared boundary id
    
    // The number of shared boundaries in the current processor
    const unsigned n_shared_bound_in_this_proc = 
     shared_bound_in_this_proc.size();
    
    // Loop over the candidate shared boundaries to connect
    for (unsigned i = 0; i < n_candidate_shared_bnd_to_connect; i++)
     {
      // Get the i-th candidate shared boundary to connect
      const unsigned i_candidate_shared_bnd = 
       candidate_shared_bnd_to_connect[i];
      
      // Loop over the shared boundaries in the current processor
      for (unsigned j = 0; j < n_shared_bound_in_this_proc; j++)
       {
        // Is the candidate boundary a shared boundary in this processor?
        if (i_candidate_shared_bnd == shared_bound_in_this_proc[j])
         {
          // Return the candidate shared boundary
          flag_to_return = i_candidate_shared_bnd;
          return flag_to_return;
         } // The candidate shared boundary is a boundary in the
           // current processor
        
       } // for (j < n_shared_bound_in_this_proc)
      
     } // for (i < n_candidate_shared_bnd_to_connect)
    
    // If non of the candidate shared boundaries to connect is in the
    // current processor the mark that we need to stop the addition of
    // vertices at this side of the polyline
    flag_to_return = -3;
    
   } // if (n_candidate_shared_bnd_to_connect > 0)
  
  // Return inmediately if the connection is with a previuos shared
  // boundary
  if (flag_to_return >= 0)
   {
    return flag_to_return;
   }
  
  // ------------------------------------------------------------------
  // Finally,check for connections with the same polyline (the shared
  // boundary that is being constructed). We are trying to avoid loops
  // or connections with the same shared boundary that is why this is
  // checked at the end
  // ------------------------------------------------------------------
  unsigned nrepeated = 0;
  for (std::list<Node*>::iterator it_list = current_polyline_nodes.begin();
       it_list != current_polyline_nodes.end();
       it_list++)
   {
    // There must be at least one repeated node (the one that we have
    // just added, and it should be the first or last node)
    if ((*it_list) == new_node_pt) {nrepeated++;}
   }
  // If the number of repeated nodes is greater than one then the
  // polyline has a connection with itself
  if (nrepeated > 1)
   {
    // Return the flag value to indicate connection with itself, we
    // can not return the boundary id of the current polyline since it
    // has not been already assigned
    flag_to_return = -2;
   }
  
  // If there is no connection at all check the degree of the node, if
  // it is greater than 2 then return the flag to stop adding nodes
  // after this one
  if (node_degree > 2)
   {
    flag_to_return = -3;
   }
  
  // Return the flag
  return flag_to_return;
  
 }
 
 //======================================================================
 // \short Establish the connections of the polylines previously
 // marked as having connections. This connections were created in the
 // function TriangleMesh::create_polylines_from_halo_elements_helper().
 // In case of doing load balancing the connections were created by the
 // function RefineableTriangleMesh::create_new_shared_boundaries()
 // ======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::create_shared_polylines_connections()
 {
  // Get the rank of the current processor
  const unsigned my_rank = this->communicator_pt()->my_rank();
  
  // Get the shared curves associated with this processor
  Vector<Vector<TriangleMeshPolyLine*> > shared_curves_pt = 
   this->Shared_boundary_polyline_pt[my_rank];
  
  // Loop through the shared boundaries on the current processor and
  // check if they are marked to create a connection
  const unsigned ncurves = shared_curves_pt.size();
  for (unsigned icurve = 0; icurve < ncurves; icurve++)
   {
    // Get the number of polylines in the current shared curve
    const unsigned npoly = shared_curves_pt[icurve].size();
    for (unsigned ipoly = 0; ipoly < npoly; ipoly++)
     {
      // Get the polyline representation of the shared boundary
      TriangleMeshPolyLine *shd_poly_pt = shared_curves_pt[icurve][ipoly];
      
      // Get the boundary id of the current polyline
      const unsigned bound_id = shd_poly_pt->boundary_id();
      
      // Is the left vertex connected
      const bool is_connected_to_the_left = 
       shd_poly_pt->is_initial_vertex_connected();
      
      // Is the right vertex connected
      const bool is_connected_to_the_right = 
       shd_poly_pt->is_final_vertex_connected();
      
      // -----------------------------------------------------------------
      // If there is a connection at one of the ends we need to
      // establish that connection
      if (is_connected_to_the_left || is_connected_to_the_right)
       {        
        // Now get the new left and right vertices of the shared
        // polyline
        const unsigned n_vertex = shd_poly_pt->nvertex();
        
        // Now get the polylines to where the current shared boundary is
        // connected and create the connections
        
        // --------------------------------------------------------------
        // Connection to the left
        if (is_connected_to_the_left)
         {
          // Get the unsigned version of the bound id to connect to
          // the left
          const unsigned uconnection_to_the_left = 
           shd_poly_pt->initial_vertex_connected_bnd_id();
          
          // The pointer to the boundary to connect
          TriangleMeshPolyLine *poly_to_connect_pt = 0;
          
          // Flag to indicate we are trying to connect to an split
          // boundary
          bool connecting_to_an_split_boundary = false;
          
          // Flag to indicate we are trying to connecto to an internal
          // boundary that is overlaped by a shared boundary
          bool connecting_to_an_overlaped_boundary = false;
          
          // Check if the connection is with itself
          if (uconnection_to_the_left == bound_id)
           {
            // Set the pointer to the polyline to connect
            poly_to_connect_pt = shd_poly_pt;
           }
          else
           {
            // Get the initial shared boundary ids
            const unsigned initial_shd_bnd_id = initial_shared_boundary_id();
            // Check if the boundary to connect is a shared polyline
            if (uconnection_to_the_left >= initial_shd_bnd_id)
             {
              // Get the polyline pointer representing the destination
              // boundary
              poly_to_connect_pt = 
               boundary_polyline_pt(uconnection_to_the_left);
             } // if (uconnection_to_the_left >= initial_shd_bnd_id)
            else
             {
              // If we are going to connect to an original boundary
              // verify if the boundary was splitted during the
              // distribution process to consider all the chunks
              // (sub-polylines) of the boundary
              if (boundary_was_splitted(uconnection_to_the_left))
               {
                connecting_to_an_split_boundary = true;
               } // if (boundary_was_splitted(uconnection_to_the_left))
              
              // If we are going to connect to an original boundary
              // verify if the boundary, or any of its chunks is
              // marked to be overlapped by a shared boundary, if that
              // is the case we first check for connections in the
              // shared boundary that overlaps the internal boundary,
              // or the chunks, and then check for connections in the
              // original boundary
              if (connecting_to_an_split_boundary)
               {
                // Get the number of chucks that represent the
                // destination boundary
                const unsigned n_sub_poly = 
                 nboundary_subpolylines(uconnection_to_the_left);
                // Now loop over the chunks of the destination
                // boundary and if any of them is marked to be
                // overlaped by a shared boundary then set the flag
                // and break the loop
                for (unsigned ii =0; ii < n_sub_poly; ii++)
                 {
                  if (boundary_marked_as_shared_boundary(
                       uconnection_to_the_left, ii))
                   {
                    // Mark the boundary as being overlaped by a
                    // shared boundary
                    connecting_to_an_overlaped_boundary = true;
                    // Break, no need to look for more overlapings
                    break;
                   } // if (boundary_marked_as_shared_boundary(...))
                 } // for (ii < n_sub_poly)
               } // if (connecting_to_an_split_boundary)
              else
               {
                // If not connecting to an split boundary then check
                // if the whole destination boundary is overlaped by
                // an internal boundary
                if (boundary_marked_as_shared_boundary(
                     uconnection_to_the_left, 0))
                 {
                  // Mark the boundary as being overlaped by a shared
                  // boundary
                  connecting_to_an_overlaped_boundary = true;
                 } // if (boundary_marked_as_shared_boundary(...))
               } // else if (connecting_to_an_split_boundary)
              
              // If we are connecting neither to an split boundary nor
              // an overlaped boundary then get the pointer to the
              // original boundary
              if (!(connecting_to_an_split_boundary || 
                    connecting_to_an_overlaped_boundary))
               {
                // Get the polyline pointer representing the
                // destination boundary
                poly_to_connect_pt = 
                 boundary_polyline_pt(uconnection_to_the_left);
               } // else if (NOT split, NOT overlaped)
             } // else if (uconnection_to_the_left >= initial_shd_bnd_id)
            
           } // else if (uconnection_to_the_left == bound_id)
          
#ifdef PARANOID
          // If we are not connecting to an original boundary
          // (connecting to the same shared boundary or to another
          // shared boundary) then the boundary should not be marked
          // as split
          if (!connecting_to_an_split_boundary)
           {
            if (boundary_was_splitted(uconnection_to_the_left))
             {
              std::stringstream error;
              error 
               << "The current shared boundary (" << bound_id << ") was "
               << "marked to have a connection\nto the left with the "
               << "boundary (" << uconnection_to_the_left << ").\n"
               << "The problem is that the destination boundary (possibly\n"
               << "another shared boundary) is marked to be split\n"
               << "There should not be split shared boundaries\n\n";
              throw OomphLibError(
               error.str(),
               "TriangleMesh::create_shared_polylines_connections()",
               OOMPH_EXCEPTION_LOCATION);
             }
           } // if (!connecting_to_an_split_boundary)
#endif
          
          // Now look for the vertex number on the destination
          // boundary(ies) -- in case that the boundary was split ---
          
          // Do not check for same orientation, that was previously
          // worked by interchanging the connections boundaries (if
          // necessary)
          
          // Get the left vertex in the shared boundary
          Vector<double> shd_bnd_left_vertex = 
           shd_poly_pt->vertex_coordinate(0);
          
          // If the boundary was not split then ...
          if (!connecting_to_an_split_boundary)
           {
            // ... check if the boundary is marked to be overlaped by
            // a shared boundary
            if (!connecting_to_an_overlaped_boundary)
             {
              // If that is not the case then we can safely look for
              // the vertex number on the destination boundar
              unsigned vertex_index = 0;
              
              const bool found_vertex_index = 
               get_connected_vertex_number_on_destination_polyline(
                poly_to_connect_pt, shd_bnd_left_vertex, vertex_index);
              
              // If we could not find the vertex index to connect then
              // we are in trouble
              if (!found_vertex_index)
               {
                std::stringstream error;
                error 
                 << "The current shared boundary (" << bound_id << ") was "
                 << "marked to have a connection\nto the left with the "
                 << "boundary (" << uconnection_to_the_left << ").\n"
                 << "The problem is that the left vertex of the current\n"
                 << "shared boundary is not in the list of vertices of the\n"
                 << "boundary to connect.\n\n"
                 << "This is the left vertex of the current shared boundary\n"
                 << "Left vertex: (" << shd_bnd_left_vertex[0] << ", " 
                 << shd_bnd_left_vertex[1] << ")\n\n"
                 << "This is the list of vertices on the destination "
                 << "boundary\n";
                const unsigned n_v = poly_to_connect_pt->nvertex();
                for (unsigned i = 0; i < n_v; i++)
                 {
                  Vector<double> cvertex =
                   poly_to_connect_pt->vertex_coordinate(i);
                  error 
                   <<"Vertex #"<<i<<": ("<<cvertex[0]<<", "<<cvertex[1]<<")\n";
                 }
                throw OomphLibError(
                 error.str(),
                 "TriangleMesh::create_shared_polylines_connections()",
                 OOMPH_EXCEPTION_LOCATION);
               } // if (!found_vertex_index)
              
              // Create the connection, the left vertex of the current
              // shared boundary is connected with the vertex_index-th
              // vertex on the destination boundary
              shd_poly_pt->connect_initial_vertex_to_polyline(
               poly_to_connect_pt, vertex_index);
              
             } // if (!connecting_to_an_overlaped_boundary)
            else
             {
              // If the boundary is marked to be overlaped by a shared
              // boundary then get that shared boundary and look for
              // the connection in that boundary
              
              // The vertex where to store the index to connect
              unsigned vertex_index = 0;
              // A flag to indicate if the connection was found
              bool found_vertex_index = false;
              
              // Get the shared boundary id that is overlaping the
              // internal boundary
              Vector<unsigned> dst_shd_bnd_ids;
              get_shared_boundaries_overlapping_internal_boundary(
               uconnection_to_the_left, dst_shd_bnd_ids);
              
              // Get the number of shared polylines that were found to
              // overlap the internal boundary
              const unsigned n_shd_bnd_overlap_int_bnd = 
               dst_shd_bnd_ids.size();
              
              // Loop over the shared boundaries that overlap the
              // internal boundary and look for the vertex to connect
              for (unsigned ss = 0; ss < n_shd_bnd_overlap_int_bnd; ss++)
               {
                // Get the shared polyline
                const unsigned new_connection_to_the_left = 
                 dst_shd_bnd_ids[ss];
                
                // Get the shared polyline that is overlaping the
                // internal boundary
                poly_to_connect_pt = 
                 boundary_polyline_pt(new_connection_to_the_left);
                
                if (poly_to_connect_pt!=0)
                 {
                  // Look for the vertex number in the destination
                  // shared polyline
                  found_vertex_index = 
                   get_connected_vertex_number_on_destination_polyline(
                    poly_to_connect_pt, shd_bnd_left_vertex, vertex_index);
                 } // if (poly_to_connect_pt!=0)
                
                // If we have found the vertex to connect then
                // break the loop
                if (found_vertex_index)
                 {
                  break;
                 } // if (found_vertex_index)
                
               } // for (ss < n_shd_bnd_overlaping_int_bnd)
              
#ifdef PARANOID
              // If we could not find the vertex index to connect then
              // we are in trouble
              if (!found_vertex_index)
               {
                std::stringstream error;
                error 
                 << "The current shared boundary (" << bound_id << ") was "
                 << "marked to have a connection\nto the left with the "
                 << "boundary (" << uconnection_to_the_left << ").\n"
                 << "This last boundary is marked to be overlaped by "
                 << "shared boundaries\n"
                 << "The problem is that the left vertex of the current\n"
                 << "shared boundary is not in the list of vertices of the\n"
                 << "boundary to connect.\n\n"
                 << "This is the left vertex of the current shared boundary\n"
                 << "Left vertex: (" << shd_bnd_left_vertex[0] << ", " 
                 << shd_bnd_left_vertex[1] << ")\n\n"
                 << "This is the list of vertices on the destination "
                 << "boundary\n";
                Vector<unsigned> dst_shd_bnd_ids;
                get_shared_boundaries_overlapping_internal_boundary(
                 uconnection_to_the_left, dst_shd_bnd_ids);
                const unsigned n_shd_bnd_overlap_int_bnd = 
                 dst_shd_bnd_ids.size();
                for (unsigned ss = 0; ss < n_shd_bnd_overlap_int_bnd; ss++)
                 {
                  const unsigned new_connection_to_the_left = 
                   dst_shd_bnd_ids[ss];
                  poly_to_connect_pt = 
                   boundary_polyline_pt(new_connection_to_the_left);
                  if (poly_to_connect_pt != 0)
                   {
                    const unsigned shd_bnd_id_overlap = 
                     poly_to_connect_pt->boundary_id();
                    error << "Shared boundary id(" 
                          << shd_bnd_id_overlap << ")\n";
                    const unsigned n_v = poly_to_connect_pt->nvertex();
                    for (unsigned i = 0; i < n_v; i++)
                     {
                      Vector<double> cvertex =
                       poly_to_connect_pt->vertex_coordinate(i);
                      error 
                       <<"Vertex #"<<i<<": ("<<cvertex[0]<<", "
                       <<cvertex[1]<<")\n";
                     }
                   } // if (poly_to_connect_pt != 0)
                 } // for (ss < n_shd_bnd_overlap_int_bnd)
                
                throw OomphLibError(
                 error.str(),
                 "TriangleMesh::create_shared_polylines_connections()",
                 OOMPH_EXCEPTION_LOCATION);
                
               } // if (!found_vertex_index)
#endif
              
              // Create the connection, the left vertex of the current
              // shared boundary is connected with the vertex_index-th
              // vertex on the destination boundary
              shd_poly_pt->connect_initial_vertex_to_polyline(
               poly_to_connect_pt, vertex_index);
              
             } // else if (!connecting_to_an_overlaped_boundary)
            
           } // if (!connecting_to_an_split_boundary)
          else
           {
            // If the boundary was split then we need to look for the
            // vertex in the sub-polylines
            
            // Get the sub-polylines vector
            Vector<TriangleMeshPolyLine*> tmp_vector_subpolylines =
             boundary_subpolylines(uconnection_to_the_left);
            
            // Get the number of sub-polylines
            const unsigned nsub_poly = tmp_vector_subpolylines.size();
#ifdef PARANOID
            if (nsub_poly <= 1)
             {
              std::ostringstream error_message;
              error_message
               <<"The boundary (" << uconnection_to_the_left << ") was "
               << "marked to be splitted but\n"
               << "there are only ("<<nsub_poly<<") polylines to "
               << "represent it.\n";
              throw OomphLibError(
               error_message.str(),
               "TriangleMesh::create_shared_polylines_connections()",
               OOMPH_EXCEPTION_LOCATION);
             } // if (nsub_poly <= 1)
#endif
            // We need to check if the boundary is marked to be
            // overlaped by an internal boundary, if that is the case
            // we need to check for each indivual subpolyline, and for
            // those overlaped by a shared polyline look for the
            // vertex in the shared polyline representation instead of
            // the original subpolyline
            
            // ... check if the boundary is marked to be overlaped by
            // a shared boundary
            if (!connecting_to_an_overlaped_boundary)
             {
              // We can work without checking the subpolylines
              // individually
              
              // The vertex where to store the index to connect
              unsigned vertex_index = 0;
              // The subpoly number to connect
              unsigned sub_poly_to_connect = 0;
              // A flag to indicate if the connection was found
              bool found_vertex_index = false;
              
              // Look for the vertex number to connect on each of the
              // subpolyines
              for (unsigned isub = 0; isub < nsub_poly; isub++)
               {
                // Assign the pointer to the sub-polyline
                poly_to_connect_pt = tmp_vector_subpolylines[isub];
                // Search for the vertex in the current sub-polyline
                found_vertex_index = 
                 get_connected_vertex_number_on_destination_polyline(
                  poly_to_connect_pt, shd_bnd_left_vertex, vertex_index);
                // If we have found the vertex to connect then break the
                // loop
                if (found_vertex_index)
                 {
                  // But first save the subpoly number (chunk), that
                  // will be used to perform the connection
                  sub_poly_to_connect = isub;
                  break;
                 } // if (found_vertex_index)
               } // for (isub < nsub_poly)
              
#ifdef PARANOID
              // If we could not find the vertex index to connect then
              // we are in trouble
              if (!found_vertex_index)
               {
                std::stringstream error;
                error 
                 << "The current shared boundary (" << bound_id << ") was "
                 << "marked to have a connection\nto the left with the "
                 << "boundary (" << uconnection_to_the_left << ").\n"
                 << "The problem is that the left vertex of the current\n"
                 << "shared boundary is not in the list of vertices of any\n"
                 << "of the sub polylines that represent the boundary to\n"
                 << "connect.\n\n"
                 << "This is the left vertex of the current shared boundary\n"
                 << "Left vertex: (" << shd_bnd_left_vertex[0] << ", " 
                 << shd_bnd_left_vertex[1] << ")\n\n"
                 << "This is the list of vertices on the destination "
                 << "boundary\n";
                for (unsigned p = 0; p < nsub_poly; p++)
                 {
                  error << "Subpolyline #("<< p << ")\n";
                  poly_to_connect_pt = tmp_vector_subpolylines[p];
                  const unsigned n_v = poly_to_connect_pt->nvertex();
                  for (unsigned i = 0; i < n_v; i++)
                   {
                    Vector<double> cvertex =
                     poly_to_connect_pt->vertex_coordinate(i);
                    error 
                     <<"Vertex #"<<i<<": ("<<cvertex[0]<<", "
                     <<cvertex[1]<<")\n";
                   }
                 } // for (p < nsub_poly)
                throw OomphLibError(
                 error.str(),
                 "TriangleMesh::create_shared_polylines_connections()",
                 OOMPH_EXCEPTION_LOCATION);
               } // if (!found_vertex_index)
#endif
              
              // Create the connection, the left vertex of the current
              // shared boundary is connected with the vertex_index-th
              // vertex of sub_poly_to_connect-th subpolyline of the
              // destination boundary
              shd_poly_pt->connect_initial_vertex_to_polyline(
               poly_to_connect_pt, vertex_index, sub_poly_to_connect);
              
             } // if (!connecting_to_an_overlaped_boundary)
            else
             {
              // We first look on the shared boundaries that overlap
              // the internal boundaries and the look for the
              // sub-polylines that are not marked as being overlaped
              // by shared boundaries
              
              // The vertex where to store the index to connect
              unsigned vertex_index = 0;
              // The subpoly number to connect
              unsigned sub_poly_to_connect = 0;
              // A flag to indicate if the connection was found
              bool found_vertex_index = false;
              
              // Get the shared boundaries id that are overlaping the
              // internal boundary
              Vector<unsigned> dst_shd_bnd_ids;
              get_shared_boundaries_overlapping_internal_boundary(
               uconnection_to_the_left, dst_shd_bnd_ids);
              
              // Get the number of shared polylines that were found to
              // overlap the internal boundary
              const unsigned n_shd_bnd_overlap_int_bnd = 
               dst_shd_bnd_ids.size();
              
              // Loop over the shared boundaries that overlap the
              // internal boundary and look for the vertex to connect
              for (unsigned ss = 0; ss < n_shd_bnd_overlap_int_bnd; ss++)
               {
                // Get the shared polyline
                const unsigned new_connection_to_the_left = 
                 dst_shd_bnd_ids[ss];
                
                // Make sure that the destination polyline is not the
                // same as the current shared polyline
                if (bound_id != new_connection_to_the_left)
                 {                  
                  // Get the shared polyline that is overlaping the
                  // internal boundary
                  poly_to_connect_pt = 
                   boundary_polyline_pt(new_connection_to_the_left);
                  
                  if (poly_to_connect_pt != 0)
                   {
                    // Look for the vertex number in the destination
                    // shared polyline
                    found_vertex_index = 
                     get_connected_vertex_number_on_destination_polyline(
                      poly_to_connect_pt, shd_bnd_left_vertex, vertex_index);
                   } // if (poly_to_connect_pt != 0)
                  
                  // If we have found the vertex to connect then
                  // break the loop
                  if (found_vertex_index)
                   {
                    break;
                   } // if (found_vertex_index)
                  
                 } // if (bound_id != new_connection_to_the_left)
                
               } // for (ss < n_shd_bnd_overlaping_int_bnd)
              
              // If we have not yet found the vertex then look for it
              // in the sub-polylines that are not overlaped by shared
              // boundaries
              if (!found_vertex_index)
               {
                // Look for the vertex number to connect on each of
                // the subpolyines
                for (unsigned isub = 0; isub < nsub_poly; isub++)
                 {
                  // Only work with those sub-polylines that are not
                  // overlaped by shared boundaries
                  if (!boundary_marked_as_shared_boundary(
                       uconnection_to_the_left, isub))
                   {
                    // Assign the pointer to the sub-polyline
                    poly_to_connect_pt = tmp_vector_subpolylines[isub];
                    // Search for the vertex in the current sub-polyline
                    found_vertex_index = 
                     get_connected_vertex_number_on_destination_polyline(
                      poly_to_connect_pt, shd_bnd_left_vertex, vertex_index);
                    // If we have found the vertex to connect then break the
                    // loop
                    if (found_vertex_index)
                     {
                      // But first save the subpoly number (chunk), that
                      // will be used to perform the connection
                      sub_poly_to_connect = isub;
                      break;
                     } // if (found_vertex_index)
                    
                   } // if (not overlaped by shared boundary)
                  
                 } // for (isub < nsub_poly)
                  
               } // if (!found_vertex_index)
              
#ifdef PARANOID
              // If we could not find the vertex index to connect then
              // we are in trouble
              if (!found_vertex_index)
               {
                std::stringstream error;
                error 
                 << "The current shared boundary (" << bound_id << ") was "
                 << "marked to have a connection\nto the left with the "
                 << "boundary (" << uconnection_to_the_left << ").\n"
                 << "This last boundary is marked to be overlaped by "
                 << "shared boundaries\n"
                 << "The problem is that the left vertex of the current\n"
                 << "shared boundary is not in the list of vertices of "
                 << "the\nboundary to connect.\n\n"
                 << "This is the left vertex of the current shared "
                 << "boundary\n"
                 << "Left vertex: (" << shd_bnd_left_vertex[0] << ", " 
                 << shd_bnd_left_vertex[1] << ")\n\n"
                 << "This is the list of vertices on the destination "
                 << "boundary (only those subpolylines not marked as "
                 << "overlaped by\nshared boundaries)\n";
                for (unsigned p = 0; p < nsub_poly; p++)
                 {
                  if (!boundary_marked_as_shared_boundary(
                       uconnection_to_the_left, p))
                   {
                    error << "Subpolyline #("<< p << ")\n";
                    poly_to_connect_pt = tmp_vector_subpolylines[p];
                    const unsigned n_v = poly_to_connect_pt->nvertex();
                    for (unsigned i = 0; i < n_v; i++)
                     {
                      Vector<double> cvertex =
                       poly_to_connect_pt->vertex_coordinate(i);
                      error 
                       <<"Vertex #"<<i<<": ("<<cvertex[0]<<", "
                       <<cvertex[1]<<")\n";
                     }
                   } // Not marked as overlaped
                 } // for (p < nsub_poly)
                error << "\nThis is the list of vertices of the shared "
                      << "polylines that overlap\nthe internal "
                      << "boundary\n";
                Vector<unsigned> dst_shd_bnd_ids;
                get_shared_boundaries_overlapping_internal_boundary(
                 uconnection_to_the_left, dst_shd_bnd_ids);
                const unsigned n_shd_bnd_overlap_int_bnd = 
                 dst_shd_bnd_ids.size();
                for (unsigned ss = 0; ss < n_shd_bnd_overlap_int_bnd; ss++)
                 {
                  const unsigned new_connection_to_the_left = 
                   dst_shd_bnd_ids[ss];
                  poly_to_connect_pt = 
                   boundary_polyline_pt(new_connection_to_the_left);
                  if (poly_to_connect_pt != 0)
                   {
                    const unsigned shd_bnd_id_overlap = 
                     poly_to_connect_pt->boundary_id();
                    error << "Shared boundary id(" 
                          << shd_bnd_id_overlap << ")\n";
                    const unsigned n_v = poly_to_connect_pt->nvertex();
                    for (unsigned i = 0; i < n_v; i++)
                     {
                      Vector<double> cvertex =
                       poly_to_connect_pt->vertex_coordinate(i);
                      error 
                       <<"Vertex #"<<i<<": ("<<cvertex[0]<<", "
                       <<cvertex[1]<<")\n";
                     }
                   } // if (poly_to_connect_pt != 0)
                 } // for (ss < n_shd_bnd_overlap_int_bnd)
                
                throw OomphLibError(
                 error.str(),
                 "TriangleMesh::create_shared_polylines_connections()",
                 OOMPH_EXCEPTION_LOCATION);
               } // if (!found_vertex_index)
#endif
              
              // Create the connection, the left vertex of the current
              // shared boundary is connected with the vertex_index-th
              // vertex of sub_poly_to_connect-th subpolyline of the
              // destination boundary
              shd_poly_pt->connect_initial_vertex_to_polyline(
               poly_to_connect_pt, vertex_index, sub_poly_to_connect);
              
             } // else if (!connecting_to_an_overlaped_boundary)
            
           } // else if (!connecting_to_an_split_boundary)
          
         } // if (connection_to_the_left != -1)
        
        // --------------------------------------------------------------
        // Connection to the right
        if (is_connected_to_the_right)
         {
          // Get the unsigned version of the bound id to connect to
          // the right
          const unsigned uconnection_to_the_right = 
           shd_poly_pt->final_vertex_connected_bnd_id();
          
          // The pointer to the boundary to connect
          TriangleMeshPolyLine *poly_to_connect_pt = 0;
          
          // Flag to indicate we are trying to connect to an split
          // boundary
          bool connecting_to_an_split_boundary = false;
          
          // Flag to indicate we are trying to connecto to an internal
          // boundary that is overlaped by a shared boundary
          bool connecting_to_an_overlaped_boundary = false;          
          
          // Check if the connection is with itself
          if (uconnection_to_the_right == bound_id)
           {
            // Set the pointer to the polyline to connect
            poly_to_connect_pt = shd_poly_pt;
           }
          else
           {
            // Get the initial shared boundary ids
            const unsigned initial_shd_bnd_id = initial_shared_boundary_id();
            // Check if the boundary to connect is a shared polyline
            if (uconnection_to_the_right >= initial_shd_bnd_id)
             {
              // Get the polyline pointer representing the destination
              // boundary
              poly_to_connect_pt = 
               boundary_polyline_pt(uconnection_to_the_right);
             } // if (uconnection_to_the_left >= initial_shd_bnd_id)
            else
             {
              // If we are going to connect to an original boundary
              // verify if the boundary was splitted during the
              // distribution process to consider all the chunks
              // (sub-polylines) of the boundary
              if (boundary_was_splitted(uconnection_to_the_right))
               {
                connecting_to_an_split_boundary = true;
               } // if (boundary_was_splitted(uconnection_to_the_right))
              
              // If we are going to connect to an original boundary
              // verify if the boundary, or any of its chunks is
              // marked to be overlapped by a shared boundary, if that
              // is the case we first check for connections in the
              // shared boundary that overlaps the internal boundary,
              // or the chunks, and then check for connections in the
              // original boundary
              if (connecting_to_an_split_boundary)
               {
                // Get the number of chucks that represent the
                // destination boundary
                const unsigned n_sub_poly = 
                 nboundary_subpolylines(uconnection_to_the_right);
                // Now loop over the chunks of the destination
                // boundary and if any of them is marked to be
                // overlaped by a shared boundary then set the flag
                // and break the loop
                for (unsigned ii =0; ii < n_sub_poly; ii++)
                 {
                  if (boundary_marked_as_shared_boundary(
                       uconnection_to_the_right, ii))
                   {
                    // Mark the boundary as being overlaped by a
                    // shared boundary
                    connecting_to_an_overlaped_boundary = true;
                    // Break, no need to look for more overlapings
                    break;
                   } // if (boundary_marked_as_shared_boundary(...))
                 } // for (ii < n_sub_poly)
               } // if (connecting_to_an_split_boundary)
              else
               {
                // If not connecting to an split boundary then check
                // if the whole destination boundary is overlaped by
                // an internal boundary
                if (boundary_marked_as_shared_boundary(
                     uconnection_to_the_right, 0))
                 {
                  // Mark the boundary as being overlaped by a shared
                  // boundary
                  connecting_to_an_overlaped_boundary = true;
                 } // if (boundary_marked_as_shared_boundary(...))
               } // else if (connecting_to_an_split_boundary)
              
              // If we are connecting neither to an split boundary nor
              // an overlaped boundary then get the pointer to the
              // original boundary
              if (!(connecting_to_an_split_boundary || 
                    connecting_to_an_overlaped_boundary))
               {
                // Get the polyline pointer representing the
                // destination boundary
                poly_to_connect_pt = 
                 boundary_polyline_pt(uconnection_to_the_right);
               } // else if (NOT split, NOT overlaped)
             } // else if (uconnection_to_the_right >= initial_shd_bnd_id)
            
           } // else if (uconnection_to_the_right == bound_id)
          
#ifdef PARANOID
          // If we are not connecting to an original boundary
          // (connecting to the same shared boundary or to another
          // shared boundary) then the boundary should not be marked
          // as split
          if (!connecting_to_an_split_boundary)
           {
            if (boundary_was_splitted(uconnection_to_the_right))
             {
              std::stringstream error;
              error 
               << "The current shared boundary (" << bound_id << ") was "
               << "marked to have a connection\nto the right with the "
               << "boundary (" << uconnection_to_the_right << ").\n"
               << "The problem is that the destination boundary (possibly\n"
               << "another shared boundary) is marked to be split\n"
               << "There should not be split shared boundaries\n\n";
              throw OomphLibError(
               error.str(),
               "TriangleMesh::create_shared_polylines_connections()",
               OOMPH_EXCEPTION_LOCATION);
             }
           } // if (!connecting_to_an_split_boundary)
#endif
          
          // Now look for the vertex number on the destination
          // boundary(ies) -- in case that the boundary was split ---
          
          // Do not check for same orientation, that was previously
          // worked by interchanging the connections boundaries (if
          // necessary)
          
          // Get the right vertex in the shared boundary
          Vector<double> shd_bnd_right_vertex = 
           shd_poly_pt->vertex_coordinate(n_vertex-1);
          
          // If the boundary was not split then inmediately look for
          // the vertex index in the destination boundary
          if (!connecting_to_an_split_boundary)
           {
            // ... check if the boundary is marked to be overlaped by
            // a shared boundary
            if (!connecting_to_an_overlaped_boundary)
             {
              // If that is not the case then we can safely look for
              // the vertex number on the destination boundar
              
              unsigned vertex_index = 0;
              const bool found_vertex_index = 
               get_connected_vertex_number_on_destination_polyline(
                poly_to_connect_pt, shd_bnd_right_vertex, vertex_index);
              
              // If we could not find the vertex index to connect then
              // we are in trouble
              if (!found_vertex_index)
               {
                std::stringstream error;
                error 
                 << "The current shared boundary (" << bound_id << ") was "
                 << "marked to have a connection\nto the right with the "
                 << "boundary (" << uconnection_to_the_right << ").\n"
                 << "The problem is that the right vertex of the current\n"
                 << "shared boundary is not in the list of vertices of the\n"
                 << "boundary to connect.\n\n"
                 << "This is the right vertex of the current shared boundary\n"
                 << "Right vertex: (" << shd_bnd_right_vertex[0] << ", " 
                 << shd_bnd_right_vertex[1] << ")\n\n"
                 << "This is the list of vertices on the destination boundary\n";
                const unsigned n_v = poly_to_connect_pt->nvertex();
                for (unsigned i = 0; i < n_v; i++)
                 {
                  Vector<double> cvertex =
                   poly_to_connect_pt->vertex_coordinate(i);
                  error 
                   <<"Vertex #"<<i<<": ("<<cvertex[0]<<", "<<cvertex[1]<<")\n";
                 }
                throw OomphLibError(
                 error.str(),
                 "TriangleMesh::create_shared_polylines_connections()",
                 OOMPH_EXCEPTION_LOCATION);
               } // if (!found_vertex_index)
              
              // Create the connection, the right vertex of the current
              // shared boundary is connected with the vertex_index-th
              // vertex on the destination boundary
              shd_poly_pt->connect_final_vertex_to_polyline(
               poly_to_connect_pt, vertex_index);
              
             } // if (!connecting_to_an_overlaped_boundary)
            else
             {
              // If the boundary is marked to be overlaped by a shared
              // boundary then get that shared boundary and look for
              // the connection in that boundary
              
              // The vertex where to store the index to connect
              unsigned vertex_index = 0;
              // A flag to indicate if the connection was found
              bool found_vertex_index = false;
              
              // Get the shared boundary id that is overlaping the
              // internal boundary
              Vector<unsigned> dst_shd_bnd_ids;
              get_shared_boundaries_overlapping_internal_boundary(
               uconnection_to_the_right, dst_shd_bnd_ids);
              
              // Get the number of shared polylines that were found to
              // overlap the internal boundary
              const unsigned n_shd_bnd_overlap_int_bnd = 
               dst_shd_bnd_ids.size();
              
              // Loop over the shared boundaries that overlap the
              // internal boundary and look for the vertex to connect
              for (unsigned ss = 0; ss < n_shd_bnd_overlap_int_bnd; ss++)
               {
                // Get the shared polyline
                const unsigned new_connection_to_the_right = 
                 dst_shd_bnd_ids[ss];
                
                // Get the shared polyline that is overlaping the
                // internal boundary
                poly_to_connect_pt = 
                 boundary_polyline_pt(new_connection_to_the_right);
                
                if (poly_to_connect_pt!=0)
                 {
                  // Look for the vertex number in the destination
                  // shared polyline
                  found_vertex_index = 
                   get_connected_vertex_number_on_destination_polyline(
                    poly_to_connect_pt, shd_bnd_right_vertex, vertex_index);
                 } // if (poly_to_connect_pt!=0)
                
                // If we have found the vertex to connect then
                // break the loop
                if (found_vertex_index)
                 {
                  break;
                 } // if (found_vertex_index)
                
               } // for (ss < n_shd_bnd_overlaping_int_bnd)
              
#ifdef PARANOID
              // If we could not find the vertex index to connect then
              // we are in trouble
              if (!found_vertex_index)
               {
                std::stringstream error;
                error 
                 << "The current shared boundary (" << bound_id << ") was "
                 << "marked to have a connection\nto the right with the "
                 << "boundary (" << uconnection_to_the_right << ").\n"
                 << "This last boundary is marked to be overlaped by "
                 << "shared boundaries\n"
                 << "The problem is that the right vertex of the current\n"
                 << "shared boundary is not in the list of vertices of the\n"
                 << "boundary to connect.\n\n"
                 << "This is the right vertex of the current shared boundary\n"
                 << "Right vertex: (" << shd_bnd_right_vertex[0] << ", " 
                 << shd_bnd_right_vertex[1] << ")\n\n"
                 << "This is the list of vertices on the destination "
                 << "boundary\n";
                Vector<unsigned> dst_shd_bnd_ids;
                get_shared_boundaries_overlapping_internal_boundary(
                 uconnection_to_the_right, dst_shd_bnd_ids);
                const unsigned n_shd_bnd_overlap_int_bnd = 
                 dst_shd_bnd_ids.size();
                for (unsigned ss = 0; ss < n_shd_bnd_overlap_int_bnd; ss++)
                 {
                  const unsigned new_connection_to_the_right = 
                   dst_shd_bnd_ids[ss];
                  poly_to_connect_pt = 
                   boundary_polyline_pt(new_connection_to_the_right);
                  if (poly_to_connect_pt != 0)
                   {
                    const unsigned shd_bnd_id_overlap = 
                     poly_to_connect_pt->boundary_id();
                    error << "Shared boundary id(" 
                          << shd_bnd_id_overlap << ")\n";
                    const unsigned n_v = poly_to_connect_pt->nvertex();
                    for (unsigned i = 0; i < n_v; i++)
                     {
                      Vector<double> cvertex =
                       poly_to_connect_pt->vertex_coordinate(i);
                      error 
                       <<"Vertex #"<<i<<": ("<<cvertex[0]<<", "
                       <<cvertex[1]<<")\n";
                     }
                   } // if (poly_to_connect_pt != 0)
                 } // for (ss < n_shd_bnd_overlap_int_bnd)
                
                throw OomphLibError(
                 error.str(),
                 "TriangleMesh::create_shared_polylines_connections()",
                 OOMPH_EXCEPTION_LOCATION);
                
               } // if (!found_vertex_index)
#endif
              
              // Create the connection, the right vertex of the
              // current shared boundary is connected with the
              // vertex_index-th vertex on the destination boundary
              shd_poly_pt->connect_final_vertex_to_polyline(
               poly_to_connect_pt, vertex_index);
              
             } // else if (!connecting_to_an_overlaped_boundary)
            
           } // if (!connecting_to_an_split_boundary)
          else
           {
            // If the boundary was split then we need to look for the
            // vertex in the sub-polylines
            
            // Get the sub-polylines vector
            Vector<TriangleMeshPolyLine*> tmp_vector_subpolylines =
             boundary_subpolylines(uconnection_to_the_right);
            
            // Get the number of sub-polylines
            const unsigned nsub_poly = tmp_vector_subpolylines.size();
#ifdef PARANOID
            if (nsub_poly <= 1)
             {
              std::ostringstream error_message;
              error_message
               <<"The boundary (" << uconnection_to_the_right << ") was "
               << "marked to be splitted but\n"
               << "there are only ("<<nsub_poly<<") polylines to "
               << "represent it.\n";
              throw OomphLibError(
               error_message.str(),
               "TriangleMesh::create_shared_polylines_connections()",
               OOMPH_EXCEPTION_LOCATION);
             } // if (nsub_poly <= 1)
#endif
            
            // We need to check if the boundary is marked to be
            // overlaped by an internal boundary, if that is the case
            // we need to check for each indivual subpolyline, and for
            // those overlaped by a shared polyline look for the
            // vertex in the shared polyline representation instead of
            // the original subpolyline
            
            // ... check if the boundary is marked to be overlaped by
            // a shared boundary
            if (!connecting_to_an_overlaped_boundary)
             {
              // We can work without checking the subpolylines
              // individually

              // The vertex where to store the index to connect
              unsigned vertex_index = 0;
              // The subpoly number to connect
              unsigned sub_poly_to_connect = 0;
              // A flag to indicate if the connection was found
              bool found_vertex_index = false;
            
              // Look for the vertex number to connect on each of the
              // subpolyines
              for (unsigned isub = 0; isub < nsub_poly; isub++)
               {
                // Assign the pointer to the sub-polyline
                poly_to_connect_pt = tmp_vector_subpolylines[isub];
                // Search for the vertex in the current sub-polyline
                found_vertex_index = 
                 get_connected_vertex_number_on_destination_polyline(
                  poly_to_connect_pt, shd_bnd_right_vertex, vertex_index);
                // If we have found the vertex to connect then break the
                // loop
                if (found_vertex_index)
                 {
                  // But first save the subpoly number (chunk), that
                  // will be used to perform the connection
                  sub_poly_to_connect = isub;
                  break;
                 } // if (found_vertex_index)
               } // for (isub < nsub_poly)
            
#ifdef PARANOID
              // If we could not find the vertex index to connect then
              // we are in trouble
              if (!found_vertex_index)
               {
                std::stringstream error;
                error 
                 << "The current shared boundary (" << bound_id << ") was "
                 << "marked to have a connection\nto the right with the "
                 << "boundary (" << uconnection_to_the_right << ").\n"
                 << "The problem is that the right vertex of the current\n"
                 << "shared boundary is not in the list of vertices of any\n"
                 << "of the sub polylines that represent the boundary to\n"
                 << "connect.\n\n"
                 << "This is the right vertex of the current shared boundary\n"
                 << "Right vertex: (" << shd_bnd_right_vertex[0] << ", " 
                 << shd_bnd_right_vertex[1] << ")\n\n"
                 << "This is the list of vertices on the destination "
                 << "boundary\n";
                for (unsigned p = 0; p < nsub_poly; p++)
                 {
                  error << "Subpolyline #("<< p << ")\n";
                  poly_to_connect_pt = tmp_vector_subpolylines[p];
                  const unsigned n_v = poly_to_connect_pt->nvertex();
                  for (unsigned i = 0; i < n_v; i++)
                   {
                    Vector<double> cvertex =
                     poly_to_connect_pt->vertex_coordinate(i);
                    error 
                     <<"Vertex #"<<i<<": ("<<cvertex[0]
                     <<", "<<cvertex[1]<<")\n";
                   }
                 } // for (p < nsub_poly)
                throw OomphLibError(
                 error.str(),
                 "TriangleMesh::create_shared_polylines_connections()",
                 OOMPH_EXCEPTION_LOCATION);
               } // if (!found_vertex_index)
#endif
            
              // Create the connection, the right vertex of the current
              // shared boundary is connected with the vertex_index-th
              // vertex of sub_poly_to_connect-th subpolyline of the
              // destination boundary
              shd_poly_pt->connect_final_vertex_to_polyline(
               poly_to_connect_pt, vertex_index, sub_poly_to_connect);
            
             } // if (!connecting_to_an_overlaped_boundary)
            else
             {
              // We first look on the shared boundaries that overlap
              // the internal boundaries and the look for the
              // sub-polylines that are not marked as being overlaped
              // by shared boundaries
              
              // The vertex where to store the index to connect
              unsigned vertex_index = 0;
              // The subpoly number to connect
              unsigned sub_poly_to_connect = 0;
              // A flag to indicate if the connection was found
              bool found_vertex_index = false;
              
              // Get the shared boundaries id that are overlaping the
              // internal boundary
              Vector<unsigned> dst_shd_bnd_ids;
              get_shared_boundaries_overlapping_internal_boundary(
               uconnection_to_the_right, dst_shd_bnd_ids);
              
              // Get the number of shared polylines that were found to
              // overlap the internal boundary
              const unsigned n_shd_bnd_overlap_int_bnd = 
               dst_shd_bnd_ids.size();
              
              // Loop over the shared boundaries that overlap the
              // internal boundary and look for the vertex to connect
              for (unsigned ss = 0; ss < n_shd_bnd_overlap_int_bnd; ss++)
               {
                // Get the shared polyline
                const unsigned new_connection_to_the_right = 
                 dst_shd_bnd_ids[ss];
                
                // Make sure that the destination polyline is not the
                // same as the current shared polyline
                if (bound_id != new_connection_to_the_right)
                 {
                  // Get the shared polyline that is overlaping the
                  // internal boundary
                  poly_to_connect_pt = 
                   boundary_polyline_pt(new_connection_to_the_right);
                  
                  if (poly_to_connect_pt != 0)
                   {
                    // Look for the vertex number in the destination
                    // shared polyline
                    found_vertex_index = 
                     get_connected_vertex_number_on_destination_polyline(
                      poly_to_connect_pt, shd_bnd_right_vertex, vertex_index);
                   } // if (poly_to_connect_pt != 0)
                  
                  // If we have found the vertex to connect then
                  // break the loop
                  if (found_vertex_index)
                   {
                    break;
                   } // if (found_vertex_index)
                  
                 } // if (bound_id != new_connection_to_the_right)
                
               } // for (ss < n_shd_bnd_overlaping_int_bnd)
              
              // If we have not yet found the vertex then look for it
              // in the sub-polylines that are not overlaped by shared
              // boundaries
              if (!found_vertex_index)
               {
                // Look for the vertex number to connect on each of
                // the subpolyines
                for (unsigned isub = 0; isub < nsub_poly; isub++)
                 {
                  // Only work with those sub-polylines that are not
                  // overlaped by shared boundaries
                  if (!boundary_marked_as_shared_boundary(
                       uconnection_to_the_right, isub))
                   {
                    // Assign the pointer to the sub-polyline
                    poly_to_connect_pt = tmp_vector_subpolylines[isub];
                    // Search for the vertex in the current sub-polyline
                    found_vertex_index = 
                     get_connected_vertex_number_on_destination_polyline(
                      poly_to_connect_pt, shd_bnd_right_vertex, vertex_index);
                    // If we have found the vertex to connect then break the
                    // loop
                    if (found_vertex_index)
                     {
                      // But first save the subpoly number (chunk), that
                      // will be used to perform the connection
                      sub_poly_to_connect = isub;
                      break;
                     } // if (found_vertex_index)
                    
                   } // if (not overlaped by shared boundary)
                  
                 } // for (isub < nsub_poly)
                  
               } // if (!found_vertex_index)
              
#ifdef PARANOID
              // If we could not find the vertex index to connect then
              // we are in trouble
              if (!found_vertex_index)
               {
                std::stringstream error;
                error 
                 << "The current shared boundary (" << bound_id << ") was "
                 << "marked to have a connection\nto the right with the "
                 << "boundary (" << uconnection_to_the_right << ").\n"
                 << "This last boundary is marked to be overlaped by "
                 << "shared boundaries\n"
                 << "The problem is that the right vertex of the current\n"
                 << "shared boundary is not in the list of vertices of "
                 << "the\nboundary to connect.\n\n"
                 << "This is the right vertex of the current shared "
                 << "boundary\n"
                 << "Right vertex: (" << shd_bnd_right_vertex[0] << ", " 
                 << shd_bnd_right_vertex[1] << ")\n\n"
                 << "This is the list of vertices on the destination "
                 << "boundary (only those subpolylines not marked as "
                 << "overlaped by\nshared boundaries)\n";
                for (unsigned p = 0; p < nsub_poly; p++)
                 {
                  if (!boundary_marked_as_shared_boundary(
                       uconnection_to_the_right, p))
                   {
                    error << "Subpolyline #("<< p << ")\n";
                    poly_to_connect_pt = tmp_vector_subpolylines[p];
                    const unsigned n_v = poly_to_connect_pt->nvertex();
                    for (unsigned i = 0; i < n_v; i++)
                     {
                      Vector<double> cvertex =
                       poly_to_connect_pt->vertex_coordinate(i);
                      error 
                       <<"Vertex #"<<i<<": ("<<cvertex[0]<<", "
                       <<cvertex[1]<<")\n";
                     }
                   } // Not marked as overlaped
                 } // for (p < nsub_poly)
                error << "\nThis is the list of vertices of the shared "
                      << "polylines that overlap\nthe internal "
                      << "boundary\n";
                Vector<unsigned> dst_shd_bnd_ids;
                get_shared_boundaries_overlapping_internal_boundary(
                 uconnection_to_the_right, dst_shd_bnd_ids);
                const unsigned n_shd_bnd_overlap_int_bnd = 
                 dst_shd_bnd_ids.size();
                for (unsigned ss = 0; ss < n_shd_bnd_overlap_int_bnd; ss++)
                 {
                  const unsigned new_connection_to_the_right = 
                   dst_shd_bnd_ids[ss];
                  poly_to_connect_pt = 
                   boundary_polyline_pt(new_connection_to_the_right);
                  if (poly_to_connect_pt != 0)
                   {
                    const unsigned shd_bnd_id_overlap = 
                     poly_to_connect_pt->boundary_id();
                    error << "Shared boundary id(" 
                          << shd_bnd_id_overlap << ")\n";
                    const unsigned n_v = poly_to_connect_pt->nvertex();
                    for (unsigned i = 0; i < n_v; i++)
                     {
                      Vector<double> cvertex =
                       poly_to_connect_pt->vertex_coordinate(i);
                      error 
                       <<"Vertex #"<<i<<": ("<<cvertex[0]<<", "
                       <<cvertex[1]<<")\n";
                     }
                   } // if (poly_to_connect_pt != 0)
                 } // for (ss < n_shd_bnd_overlap_int_bnd)
                
                throw OomphLibError(
                 error.str(),
                 "TriangleMesh::create_shared_polylines_connections()",
                 OOMPH_EXCEPTION_LOCATION);
               } // if (!found_vertex_index)
#endif
              
              // Create the connection, the left vertex of the current
              // shared boundary is connected with the vertex_index-th
              // vertex of sub_poly_to_connect-th subpolyline of the
              // destination boundary
              shd_poly_pt->connect_final_vertex_to_polyline(
               poly_to_connect_pt, vertex_index, sub_poly_to_connect);
              
             } // else if (!connecting_to_an_overlaped_boundary)

           } // else if (!connecting_to_an_split_boundary)
          
         } // if (connection_to_the_right != -1)
        
       } // if (connection_to_the_left != -1 || connection_to_the_right != -1)
      
     } // for (ipoly < npoly)

   } // for (icurve < ncurves)
  
 }
 
 //=======================================================================
 // \short Compute the holes left by the halo elements, those adjacent
 // to the shared boundaries
 //=======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::compute_holes_left_by_halo_elements_helper(
  Vector<Vector<double> > &output_holes_coordinates)
 {
  // Storage for number of processors and current processor
  const unsigned n_proc = this->communicator_pt()->nproc();
  const unsigned my_rank = this->communicator_pt()->my_rank();
  
  // Mark those done elements, so we do not repeat any coordinate left
  // by repeated halo elements
  std::map<FiniteElement*, bool> done_ele;
  
  // Loop over the processors and get the shared boundaries ids that
  // the current processor has with the other processors
  for (unsigned iproc = 0; iproc < n_proc; iproc++)
   {
    // There are shared boundaries only with the other processors
    if (iproc != my_rank)
     {
      // Get the number of shared boundaries with the iproc
      const unsigned n_shd_bnd_iproc = nshared_boundaries(my_rank, iproc);
      
#ifdef PARANOID
      // Get the number of shared boundaries with the iproc, but
      // reversing the indexes
      const unsigned n_shd_bnd_iproc_rev = nshared_boundaries(iproc, my_rank);
      if (n_shd_bnd_iproc != n_shd_bnd_iproc_rev)
       {
        std::ostringstream error_stream;
        error_stream
         << "The number of shared boundaries of processor ("
         << my_rank << ") with processor(" << iproc << "): (" 
         << n_shd_bnd_iproc << ")\n"
         << "is different from the number of shared boundaries of "
         << "processor (" << iproc << ")\nwith processor ("
         << my_rank << "): (" << n_shd_bnd_iproc << ")\n\n";
        throw OomphLibError(error_stream.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
        
       } // if (n_shd_bnd_iproc != n_shd_bnd_iproc_rev)
#endif
      
      // Loop over the shared boundaries ids
      for (unsigned i = 0; i < n_shd_bnd_iproc; i++)
       {
        // Get the shared boundary id
        const unsigned shd_bnd_id = shared_boundaries_ids(my_rank, iproc, i);
        
        // Get the number of shared boundary elements
        const unsigned n_shd_bnd_ele = nshared_boundary_element(shd_bnd_id);
        
        // Loop over the shared boundary elements
        for (unsigned e = 0; e < n_shd_bnd_ele; e++)
         {
          // Get the shared boundary element
          FiniteElement* ele_pt = shared_boundary_element_pt(shd_bnd_id, e);
          
          // Only work with halo elements
          if (ele_pt->is_halo())
           {
            // If the element has not been visited
            if (!done_ele[ele_pt])
             {
              // Get the number of nodes
              const unsigned n_nodes = ele_pt->nnode();
              
              // Compute the centroid of the element
              Vector<double> element_centroid(2, 0.0);
              // Loop over the nodes
              for (unsigned k = 0; k < n_nodes; k++)
               {
                Node* tmp_node_pt = ele_pt->node_pt(k);
                // Loop over the dimension
                for (unsigned d = 0; d < 2; d++)
                 {
                  element_centroid[d]+=tmp_node_pt->x(d);
                 } // for (d < 2)
               } // for (k < n_nodes)
              
              // Average the data
              for (unsigned d = 0; d < 2; d++)
               {
                element_centroid[d] = 
                 element_centroid[d] / (double)n_nodes;
               } // for (d < 2)
              
              // Add the centroid to the output holes
              output_holes_coordinates.push_back(element_centroid);
              
             } // if (!done_ele[ele_pt])
            
           } // if (ele_pt->is_halo())
          
         } // for1 (e < n_shd_bnd_ele)
        
       } // for (i < n_shd_bnd_iproc)
      
     } // if (iproc != my_rank)
    
   } // for (iproc < n_proc)
  
 }
 
 //======================================================================
 // \short Keeps those vertices that define a hole, those that are
 // inside closed internal boundaries in the new polygons that define
 // the domain. Delete those outside/inside the outer polygons (this
 // is required since Triangle can not deal with vertices that define
 // holes outside the new outer polygons of the domain)
 //======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::update_holes_information_helper(
  Vector<TriangleMeshPolygon *> &polygons_pt,
  Vector<Vector<double> > &output_holes_coordinates)
 {
  // General strategy 
  
  // 1) Identify the inner closed boundaries
  
  // 2) Separate the vertices in three groups
  
  // --- 2.1) The vertices inside the inner closed boundaries, these
  //          are not deleted because they define holes
  
  // --- 2.2) The vertices outside the outer boundaries, these are
  //          deleted only if they are outside the convex hull defined
  //          by all the polygons
  
  // --- 2.3) Any other vertex is deleted
  
  // Get the number of input holes
  const unsigned n_input_holes = output_holes_coordinates.size();
  
  // Only do something if there are holes
  if (n_input_holes == 0)
   {
    return;
   }
  
  // Get the number of input polygons
  const unsigned n_polygons = polygons_pt.size();
  
  // Store the vertices of all the input polygons
  // vertices_polygons[x][ ][ ]: Polygon number
  // vertices_polygons[ ][x][ ]: Vertex number
  // vertices_polygons[ ][ ][x]: Vertex coordinate
  Vector<Vector<Vector<double> > > vertices_polygons(n_polygons);
  
  // Loop over all the polygons and get the vertices
  for (unsigned p = 0; p < n_polygons; p++)
   {
    // Get the number of polylines associated to the polygon
    const unsigned n_polylines = polygons_pt[p]->npolyline();
    // Loop over the polylines and get the vertices
    for (unsigned pp = 0; pp < n_polylines; pp++)
     {
      // Get the polyline
      const TriangleMeshPolyLine* tmp_poly_pt = 
       polygons_pt[p]->polyline_pt(pp);
      // Get the number of vertices in the polyline
      const unsigned n_vertices = tmp_poly_pt->nvertex();
      // Loop over the vertices but only add (n_vertices-1) vertices,
      // the last vertex of polyline (pp) is the first vertex of
      // polyline (pp+1)
      for (unsigned v = 0; v < n_vertices-1; v++)
       {
        // Get the current vertex
        Vector<double> current_vertex = tmp_poly_pt->vertex_coordinate(v);
        vertices_polygons[p].push_back(current_vertex);
       } // for (v < nvertex)
     } // for (p < nouter_polylines)
   } // for (p < n_polygons)
  
  // -------------------------------------------------------------------
  // 1) Identify the inner closed boundaries
  // -------------------------------------------------------------------
  
  // A container that indicates if a given polygon should be
  // considered as an outer or as an inner polygon. By default all the
  // polygons are considered as outer polygons
  std::vector<bool> is_outer_polygon(n_polygons, true);
  
  // We only check for innner polygons if there are more than one
  // polygon
  if (n_polygons > 1)
   {
    // Propose an inner polygon, if one of the middle points of its
    // edges lies inside any other polygon then the proposed inner
    // polygon is marked as an internal polygon
    
    // Pre-compute the middle points of the edges in the polygons
    Vector<Vector<Vector<double> > > polygon_edge_middle_vertex(n_polygons);
  
    for (unsigned p = 0; p < n_polygons; p++)
     {
      // Temporary store the vertices of the proposed inner polygon
      Vector<Vector<double> > tmp_inner_polygon = vertices_polygons[p];
    
      // Get the number of vertices in the current proposed inner polygon
      const unsigned n_vertices = tmp_inner_polygon.size();
    
      // Resize with the number of edges in the polygon
      polygon_edge_middle_vertex[p].resize(n_vertices-1);
    
      // Loop over the vertices and compute the middle point in the edge
      // that joins each pair of contiguous vertices
      for (unsigned e = 0; e < n_vertices - 1; e++)
       {
        // The dimension
        const unsigned dim = 2;
        polygon_edge_middle_vertex[p][e].resize(dim);
        for (unsigned d = 0; d < dim; d++)
         {
          polygon_edge_middle_vertex[p][e][d] = 
           (tmp_inner_polygon[e][d] + tmp_inner_polygon[e+1][d]) / 2.0;
         } // for (d < 2)
      
       } // for (e < n_vertices - 1)
    
     } // for (p < n_polygons)
  
    // Loop over the polygons and for every loop propose a different
    // inner polygon
    for (unsigned idx_inner = 0; idx_inner < n_polygons; idx_inner++)
     {
      // Flag to indicate that ONE of the middle edge vertices of the
      // proposed inner polygon is inside another polygon, this will
      // set the proposed inner polygon as an actual inner polygon
      bool is_inner_polygon = false;
    
      // Loop over all the polygons, except the proposed one and check
      // if all the middle edges of its edges are inside any other
      // polygon
      for (unsigned i = 0; i < n_polygons; i++)
       {
        // Do not check with the polygon itself
        if (i != idx_inner)
         {
          // Get the number of edges of the proposed inner polygon
          const unsigned n_edges = 
           polygon_edge_middle_vertex[idx_inner].size();
          // Loop over the middle points in the edges of the current
          // proposed inner polygon
          for (unsigned e = 0; e < n_edges; e++)
           {
            // Get the vertex in the current proposed inner polygon
            Vector<double> current_vertex = 
             polygon_edge_middle_vertex[idx_inner][e];
            // Check if the current vertex is inside the current i-th
            // polygon
            const bool is_point_inside = 
             is_point_inside_polygon_helper(vertices_polygons[i], 
                                            current_vertex);
          
            // If one point is inside then the polygon is inside the
            // i-th polygon
            if (is_point_inside)
             {
              // The polygon is an inner polygon
              is_inner_polygon = true;
              // Break the loop
              break;
             } // if (is_point_inside)
          
           } // for (e < n_edges)
        
         } // if (i != idx_inner)
      
        // Are all the vertices of the current proposed inner polygon
        // inside the i-th polygon
        if (is_inner_polygon)
         {
          // The current proposed inner polygon is an actual inner
          // polygon, and is inside the i-th polygon
          break;
         }
        
       } // for (i < n_polygons)
      
      // Is the current proposed inner polygon an actual inner polygon
      if (is_inner_polygon)
       {
        // The current proposed inner polygon is a real inner polygon
        is_outer_polygon[idx_inner] = false;
       }
      else
       {
        // The current proposed inner polygon IS NOT a real inner
        // polygon
        is_outer_polygon[idx_inner] = true;
       }
      
     } // for (idx_outer < npolygons)
    
   } // if (n_polygons > 1)
  
  // Count the number of outer closed boundaries and inner closed
  // boundaries
  unsigned n_outer_polygons = 0;
  unsigned n_inner_polygons = 0;
  // Also get the indexes of the inner polygons
  Vector<unsigned> index_inner_polygon;
  // Loop over the polygons
  for (unsigned i = 0; i < n_polygons; i++)
   {
    if (is_outer_polygon[i])
     {
      // Increase the counter for outer polygons
      n_outer_polygons++;
     }
    else
     {
      // Increase the counter for inner polygons
      n_inner_polygons++;
      // Store the index of the inner polygon
      index_inner_polygon.push_back(i);
     }
   } // for (i < n_polygons)
  
  // -------------------------------------------------------------------
  // 2) Separate the vertices in three groups
  
  // --- 2.1) The vertices inside the inner closed boundaries, these are
  //          not deleted because they define holes
  
  // --- 2.2) The vertices outside the outer boundaries, these are
  //          deleted only if they are outside the convex hull defined
  //          by all the polygons
  
  // --- 2.3) Any other vertex is deleted
  // -------------------------------------------------------------------
  
  // Keep track of the vertices inside the inner closed boundaries (by
  // default all vertices not inside the inner polygons)
  std::vector<bool> is_inside_an_inner_polygon(n_input_holes, false);
  
  // Keep track of the vertices outside the outer closed boundaries
  // (by default all the vertices are outside the outer polygons)
  std::vector<bool> is_outside_the_outer_polygons(n_input_holes, true);
  
  // Keep track of the vertices inside the convex hull (by default
  // all the vertices are not inside the convex hull)
  std::vector<bool> is_inside_the_convex_hull(n_input_holes, false);
  
  // Mark the vertices inside the inner closed boundaries
  Vector<Vector<Vector<double> > > 
   vertex_inside_inner_polygon(n_inner_polygons);
  
  // -------------------------------------------------------------------
  // Loop over the inner polygons and find all the vertices inside
  // each one
  for (unsigned i = 0; i < n_inner_polygons; i++)
   {
    // Get the vertex of the inner polygon
    const unsigned ii = index_inner_polygon[i];
    // Loop over the vertices defining holes, mark and store those
    // inside the inner polygon
    for (unsigned h = 0; h < n_input_holes; h++)
     {
      // Check if the vertex has not been already marked as inside
      // another polygon
      if (!is_inside_an_inner_polygon[h])
       {
        // Check if the hole is inside the current inner polygon
        const bool is_inside_polygon = 
         is_point_inside_polygon_helper(vertices_polygons[ii], 
                                        output_holes_coordinates[h]);
        
        // If the vertex is inside the current inner polygon then mark
        // it and associate the vertices to the current inner polygon
        if (is_inside_polygon)
         {
          // Set as inside an inner polygon
          is_inside_an_inner_polygon[h] = true;
          // Associate the vertex to the current inner polygon
          vertex_inside_inner_polygon[i].
           push_back(output_holes_coordinates[h]);
         } // if (is_inside_polygon)
        
       } // if (!is_inside_an_inner_polygon[h])
      
     } // for (h < n_input_holes)
    
   } // for (i < n_polygons)
  
  // -------------------------------------------------------------------
  // Loop over the vertices defining holes and mark those as outside the
  // outer polygons
  for (unsigned h = 0; h < n_input_holes; h++)
   {
    // Check if the vertex has not been already marked as inside
    // another polygon
    if (!is_inside_an_inner_polygon[h])
     {
      // Loop over the polygons and check if the vertex is outside ALL
      // the outer polygons
      for (unsigned i = 0; i < n_polygons; i++)
       {
        // Only work with outer polygons
        if (is_outer_polygon[i])
         {          
          // Check if the hole is inside the current outer polygon
          const bool is_inside_polygon = 
           is_point_inside_polygon_helper(vertices_polygons[i], 
                                          output_holes_coordinates[h]);
          
          // If the vertex is inside the current outer polygon then
          // mark it and break the loop (it is not outside ALL the
          // polygons)
          if (is_inside_polygon)
           {
            // Set as inside an outer polygon
            is_outside_the_outer_polygons[h] = false;
            // Break the loop
            break;
           } // if (is_inside_polygon)
          
         } // if (is_outer_polygon[i])
        
       } // for (i < n_polygons)
      
     } // if (!is_inside_an_inner_polygon[h])
    else
     {
      // If the vertex is inside an inner polygon then it is inside an
      // outer polygon
      is_outside_the_outer_polygons[h] = false;
     } // else if (!is_inside_an_inner_polygon[h])
    
   } // for (h < n_input_holes)  
  
  // -------------------------------------------------------------------
  // Compute the convex hull Create the data structure
  std::vector<Point> input_vertices_convex_hull;
  // Copy ALL the vertices of the polygons
  // Loop over the polygons
  for (unsigned p = 0; p < n_polygons; p++)
   {
    // Get the number of vertices
    const unsigned n_vertices = vertices_polygons[p].size();
    // Loop over the vertices in the polygon
    for (unsigned v = 0; v < n_vertices; v++)
     {
      // Create a new "Point" to store in the input vertices
      Point point;
      // Assign the values to the "Point"
      point.x = vertices_polygons[p][v][0];
      point.y = vertices_polygons[p][v][1];
      // Add the "Point" to the input vertices
      input_vertices_convex_hull.push_back(point);
     } // for (v < n_vertices)
   } // for (p < n_polygons)
  
  // Compute the convex hull
  std::vector<Point> output_vertices_convex_hull =
   convex_hull(input_vertices_convex_hull);
  
  // Get the number of vertices in the convex hull
  const unsigned n_vertices_convex_hull = output_vertices_convex_hull.size();
  
  // Copy the output to the used data structures
  Vector<Vector<double> > vertices_convex_hull(n_vertices_convex_hull);
  for (unsigned i = 0; i < n_vertices_convex_hull; i++)
   {
    // Resize the data structure
    vertices_convex_hull[i].resize(2);
    // Copy the data
    vertices_convex_hull[i][0] = output_vertices_convex_hull[i].x;
    vertices_convex_hull[i][1] = output_vertices_convex_hull[i].y;
   } // for (i < n_vertices_convex_hull)
  
  // Loop over the vertices defining holes, work only with those
  // outside ALL the outer boundaries and mark those inside the convex
  // hull
  for (unsigned h = 0; h < n_input_holes; h++)
   {
    // Only work with those outside ALL the outer polygons
    if (is_outside_the_outer_polygons[h])
     {
      // Check if the hole is inside the convex hull
      const bool is_inside_convex_hull = 
       is_point_inside_polygon_helper(vertices_convex_hull, 
                                      output_holes_coordinates[h]);
      
      // If the vertex is inside the convex hull then mark it
      if (is_inside_convex_hull)
       {
        // Set as inside the convex hull
        is_inside_the_convex_hull[h] = true;
       } // if (is_inside_convex_hull)
      
     } // if (is_outside_the_outer_polygons[h])
    else
     {
      // Any vertex inside any outer polygon is inside the convex hull
      is_inside_the_convex_hull[h] = true;
     } // else if (is_outside_the_outer_polygons[h])
    
   } // for (h < n_input_holes)
  
  // Store the output holes, only (those inside an inner polygon) OR
  // (those outside ALL the polygons AND inside the convex hull)
  Vector<Vector<double> > hole_kept;
  for (unsigned h = 0; h < n_input_holes; h++)
   {
    // Check if the hole should be kept
    if ((is_inside_an_inner_polygon[h]) || 
        (is_outside_the_outer_polygons[h] && is_inside_the_convex_hull[h]))
     {
      // Copy the hole information
      hole_kept.push_back(output_holes_coordinates[h]);
     } // if (keep_hole[h])
   } // for (h < n_input_holes)
  
  // Clear the previous storage
  output_holes_coordinates.clear();
  // Set the output holes
  output_holes_coordinates = hole_kept;
  
 }
 
 //======================================================================
 // \short Sorts the polylines so they be contiguous and then we can
 // create a closed or open curve from them
 //======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::
 sort_polylines_helper(Vector<TriangleMeshPolyLine *> 
                       &unsorted_polylines_pt,
                       Vector<Vector<TriangleMeshPolyLine *> > 
                       &sorted_polylines_pt)
 {
  unsigned n_unsorted_polylines = unsorted_polylines_pt.size();
  unsigned n_sorted_polylines = 0;
  unsigned curves_index = 0;

  // Map to know which polyline has been already sorted
  std::map<TriangleMeshPolyLine*, bool> done_polyline;
  
  do 
   {
    // Create the list that stores the polylines and allows to introduce
    // polylines to the left and to the right
    std::list<TriangleMeshPolyLine*> sorted_polyline_list_pt;
    bool changes = false;

    // Create pointers to the left and right "side" of the sorted list of
    // new created TriangleMeshPolyLines
    TriangleMeshPolyLine* left_pt = 0;
    TriangleMeshPolyLine* right_pt = 0;

    // 1) Take the first non done polyline on the unsorted list of polylines
    unsigned pp = 0;
    bool found_root_polyline = false;
    while (pp < n_unsorted_polylines && !found_root_polyline)
     {
      if (!done_polyline[unsorted_polylines_pt[pp]])
       {found_root_polyline = true;}
      else
       {pp++;}
     }

    // Check if there are polylines to be sorted
    if (pp < n_unsorted_polylines)
     {
      // 2) Mark the polyline as done
      left_pt = right_pt = unsorted_polylines_pt[pp];
      done_polyline[left_pt] = true;
      // Increment the number of sorted polylines
      n_sorted_polylines++;
    
      // 3) Add this polyline to the sorted list and use it as root
      // to sort the other polylines
      sorted_polyline_list_pt.push_back(left_pt);

      do {

       changes = false;

       Vector<double> left_vertex(2);
       Vector<double> right_vertex(2);

       left_pt->initial_vertex_coordinate(left_vertex);
       right_pt->final_vertex_coordinate(right_vertex);
       
       for (unsigned i = pp+1; i < n_unsorted_polylines; i++)
        {
         TriangleMeshPolyLine *current_polyline_pt = 
          unsorted_polylines_pt[i];
         if (!done_polyline[current_polyline_pt])
          {
           Vector<double> initial_vertex(2);
           Vector<double> final_vertex(2);
           current_polyline_pt->initial_vertex_coordinate(initial_vertex);
           current_polyline_pt->final_vertex_coordinate(final_vertex);
           
           // Compare if the current polyline should go to the left or
           // to the right on the sorted polyline list
           
           // Go to the left
           if (left_vertex == final_vertex)
            {
             left_pt = current_polyline_pt;
             sorted_polyline_list_pt.push_front(left_pt);
             done_polyline[left_pt] = true;
             n_sorted_polylines++;

             // We have added one more polyline, go for another round
             changes = true;
            }
           // Go to the right
           else if (right_vertex == initial_vertex)
            {
             right_pt = current_polyline_pt;
             sorted_polyline_list_pt.push_back(right_pt);
             done_polyline[right_pt] = true;
             n_sorted_polylines++;

             // We have added one more polyline, go for another round
             changes = true;
            }
           // Go to the left but it is reversed
           else if (left_vertex == initial_vertex)
            {
             current_polyline_pt->reverse();
             left_pt = current_polyline_pt;
             sorted_polyline_list_pt.push_front(left_pt);
             done_polyline[left_pt] = true;
             n_sorted_polylines++;

             // We have added one more polyline, go for another round
             changes = true;
            }
           // Go to the right but it is reversed
           else if (right_vertex == final_vertex)
            {
             current_polyline_pt->reverse();
             right_pt = current_polyline_pt;
             sorted_polyline_list_pt.push_back(right_pt);
             done_polyline[right_pt] = true;
             n_sorted_polylines++;

             // We have added one more polyline, go for another round
             changes = true;
            }
          } // if (!done_polyline[current_polyline_pt])
         if (changes) {break;}
        } // for (i < n_unsorted_polylines)
      }while(changes);

     } // if (pp < n_unsorted_polylines)
    else
     {
      // All the polylines are now on the sorted list of polylines
#ifdef PARANOID
      // This case comes when it was not possible to find a root polyline
      // since all of them are marked as done but the number of sorted and
      // unsorted polylines is not the same
      if (!found_root_polyline)
       {
        std::stringstream err;
        err << "It was not possible to find a root polyline to sort the "
            << "others around it.\nThe number of unsorted and sorted "
            << "polylines is different, it means that\nnot all the "
            << "polylines have been sorted.\n"
            << "Found root polyline: ("<<found_root_polyline<<")\n"
            << "Sorted polylines: ("<<n_sorted_polylines<<")\n"
            << "Unsorted polylines: ("<<n_unsorted_polylines<<")\n";
        throw OomphLibError(err.str(),"TriangleMesh::sort_polylines_helper()", 
                            OOMPH_EXCEPTION_LOCATION);
       }
#endif
     }

    // Create the storage for the new sorted polylines and copy them on the
    // vector structure for sorted polylines
    unsigned n_sorted_polyline_on_list = sorted_polyline_list_pt.size();
    
    // Create the temporal vector that stores the sorted polylines
    Vector<TriangleMeshPolyLine *> 
     tmp_sorted_polylines(n_sorted_polyline_on_list);
    unsigned counter = 0;
  
    std::list<TriangleMeshPolyLine*>::iterator it_polyline;
    for (it_polyline = sorted_polyline_list_pt.begin();
         it_polyline != sorted_polyline_list_pt.end();
         it_polyline++)
     {
      tmp_sorted_polylines[counter] = *it_polyline;
      counter++;
     }

    sorted_polylines_pt.push_back(tmp_sorted_polylines);
    
    ++curves_index;

   }while(n_sorted_polylines < n_unsorted_polylines);
  
#ifdef PARANOID
  // Verify that the number of polylines on the sorted list is the same
 // as the number of polylines on the unsorted list
  if (n_sorted_polylines != n_unsorted_polylines)
   {
    std::stringstream err;
    err << "The number of polylines on the unsorted and sorted vectors"
        << " is different,\n"
        << "it means that not all the polylines have been sorted.\n"
        << "Sorted polylines: "<<n_sorted_polylines
        << "\nUnsorted polylines: "<<n_unsorted_polylines;
    throw OomphLibError(err.str(),  "TriangleMesh::sort_polylines_helper()", 
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
 }

 //======================================================================
 // \short Creates the shared boundaries
 //======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::create_shared_boundaries(
  OomphCommunicator* comm_pt, 
  const Vector<unsigned> &element_domain,
  const Vector<GeneralisedElement*> &backed_up_el_pt,
  const Vector<FiniteElement*> &backed_up_f_el_pt,
  std::map<Data*,std::set<unsigned> > &processors_associated_with_data,
  const bool& overrule_keep_as_halo_element_status)
 {
  // Storage for number of processors and current processor
  const unsigned nproc = comm_pt->nproc();
  const unsigned my_rank = comm_pt->my_rank();
  
  // Storage for all the halo elements on all processors
  // halo_element[iproc][jproc][ele_number]
  // Stores the "ele_number"-th halo element of processor "iproc" with
  // processor "jproc"
  Vector<Vector<Vector<GeneralisedElement*> > > halo_element_pt(nproc);
  // Create complete storage for the halo_element_pt container
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {halo_element_pt[iproc].resize(nproc);}
  
  // Store the global index of the element, used to check for possible
  // misclassification of halo elements in the above container
  // (halo_element_pt)
  std::map<GeneralisedElement*, unsigned> element_to_global_index;
  
  // Get the halo elements on all processors
  this->get_halo_elements_on_all_procs(nproc, element_domain,
                                       backed_up_el_pt,
                                       processors_associated_with_data,
                                       overrule_keep_as_halo_element_status,
                                       element_to_global_index,
                                       halo_element_pt);
  
  // Resize the shared polylines container
  flush_shared_boundary_polyline_pt();
  Shared_boundary_polyline_pt.resize(nproc);
  
  // Create a set that store only the elements that will be kept in
  // the processor as nonhalo element, those whose element_domains is
  // equal to my_rank. This set is used when creating the shared
  // polylines and identify the connections to the original boundaries
  std::set<FiniteElement*> element_in_processor_pt;
  const unsigned n_ele = backed_up_f_el_pt.size();
  for (unsigned e = 0; e < n_ele; e++)
   {
    if (element_domain[e] == my_rank)
     {
      element_in_processor_pt.insert(backed_up_f_el_pt[e]);
     } // if (element_domain[e] == my_rank)
   } // for (e < n_elex)
  
  // Look for elements edges that may lie on internal boundaries
  // If that is the case then relate the face with the boundary on
  // which it lies
  std::map<std::pair<Node*,Node*>, unsigned> elements_edges_on_boundary;
  this->get_element_edges_on_boundary(elements_edges_on_boundary);
  
  // Now we have all the halo elements on all processors. Use the
  // edges shared by the halo elements to create the shared boundaries.
  this->create_polylines_from_halo_elements_helper(element_domain,
                                                   element_to_global_index,
                                                   element_in_processor_pt,
                                                   halo_element_pt,
                                                   elements_edges_on_boundary,
                                                   Shared_boundary_polyline_pt);
  
 }

 //======================================================================
 /// \short Creates the halo elements on all processors
 /// Gets the halo elements on all processors, these elements are then used
 /// on the function that computes the shared boundaries among the processors
 //======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::get_halo_elements_on_all_procs(
  const unsigned &nproc, const Vector<unsigned> &element_domain,
  const Vector<GeneralisedElement*> &backed_up_el_pt,
  std::map<Data*,std::set<unsigned> > &processors_associated_with_data,
  const bool&overrule_keep_as_halo_element_status,
  std::map<GeneralisedElement*, unsigned> &element_to_global_index,
  Vector<Vector<Vector<GeneralisedElement*> > > &output_halo_elements_pt)
  {
   const unsigned n_ele = backed_up_el_pt.size();
   
   // Loop over all the processors
   for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
     // Boolean to know which elements has been already added to the
     // halo scheme on "iproc" processor
     Vector<std::map<GeneralisedElement*, bool> > already_added(nproc);
     
     // Loop over all backed up elements
     for (unsigned e=0;e<n_ele;e++)
      {
       // Get element and its domain
       GeneralisedElement* el_pt=backed_up_el_pt[e];
       unsigned el_domain=element_domain[e];
       
       // If element is NOT located on "iproc" processor then check if it is
       // halo with "el_domain" processor
       if (el_domain!=iproc)
        {
         // If this current mesh has been told to keep all elements as halos,
         // OR the element itself knows that it must be kept then
         // keep it
         if ((this->Keep_all_elements_as_halos) || 
             (el_pt->must_be_kept_as_halo()))
          {
           if (!overrule_keep_as_halo_element_status)
            {
             // Add as halo element whose non-halo counterpart is
             // located on processor "el_domain"
             if (!already_added[el_domain][el_pt])
              {
               output_halo_elements_pt[iproc][el_domain].push_back(el_pt);
               already_added[el_domain][el_pt] = true;
               element_to_global_index[el_pt] = e;
              }
            }
          }
         // Otherwise: Is one of the nodes associated with other processor?
         else
          {
           //Can only have nodes if this is a finite element
           FiniteElement* finite_el_pt = dynamic_cast<FiniteElement*>(el_pt);
           if(finite_el_pt!=0)
            {
             unsigned n_node = finite_el_pt->nnode();
             for (unsigned n=0;n<n_node;n++)
              {
               Node* nod_pt=finite_el_pt->node_pt(n);

               // Keep element?
               std::set<unsigned>::iterator it = 
                processors_associated_with_data[nod_pt].find(iproc);
               if (it!=processors_associated_with_data[nod_pt].end())
                {
                 // Add as root halo element whose non-halo counterpart is
                 // located on processor "el_domain"
                 if (!already_added[el_domain][el_pt])
                  {
                   output_halo_elements_pt[iproc][el_domain].push_back(el_pt);
                   already_added[el_domain][el_pt] = true;
                   element_to_global_index[el_pt] = e;
                  }
                 // Now break out of loop over nodes
                 break;
                } // if (it!=processors_associated_with_data[nod_pt].end())
              } // for (n < n_node)
            } // if (finite_el_pt!=0)
          } // else (this->Keep_all_elements_as_halos)
        } // if (el_domain!=iproc)
      } // for (e < nele)
    } // for (iproc < nproc)

  }

 //====================================================================
 // \short Get the element edges (pair of nodes, edges) that lie
 // on a boundary (used to mark shared boundaries that lie on
 // internal boundaries)
 //====================================================================
 template <class ELEMENT>
 void TriangleMesh<ELEMENT>::get_element_edges_on_boundary(
  std::map<std::pair<Node*,Node*>, unsigned> &element_edges_on_boundary)
 {
  // The number of original boundaries
  const unsigned nbound = this->nboundary();
  // Loop over the boundaries
  for (unsigned b = 0; b < nbound; b++)
   {
    // Keep track of the pair of nodes done
    std::map<std::pair<Node*, Node*>, bool> edge_done;
    // Get the number of elements on the boundary
    const unsigned nbound_ele = this->nboundary_element(b);
    for (unsigned e = 0; e < nbound_ele; e++)
     {
      // Get the boundary bulk element
      FiniteElement* bulk_ele_pt = this->boundary_element_pt(b, e);
      // Get the face index
      int face_index = this->face_index_at_boundary(b, e);
      // Create the face element
      FiniteElement* face_ele_pt = 
       new DummyFaceElement<ELEMENT> (bulk_ele_pt, face_index);
      // Get the number of nodes on the face element
      const unsigned nnodes = face_ele_pt->nnode();
      // Get the first and last node
      Node* first_node_pt = face_ele_pt->node_pt(0);
      Node* last_node_pt = face_ele_pt->node_pt(nnodes-1);
      
      // Create the pair to store the nodes
      std::pair<Node*,Node*> edge = 
       std::make_pair(first_node_pt, last_node_pt);
      
      // Has the edge been included
      if (!edge_done[edge])
       {
        // Mark the edge as done
        edge_done[edge] = true;
        
        // Create the reversed version and mark it as done too
        std::pair<Node*,Node*> inv_edge = 
         std::make_pair(last_node_pt, first_node_pt);
        
        // Mark the reversed edge as done
        edge_done[inv_edge] = true;
        
        // Mark the edge to belong to boundary b
        element_edges_on_boundary[edge] = b;
       } // if (!edge_done[edge])
      
      // Free the memory allocated for the face element
      delete face_ele_pt;
      face_ele_pt = 0;
      
     } // for (e < nbound_ele)
    
   } // for (b < nbound)
  
 }
 
 // ======================================================================
 // \short Creates polylines from the intersection of halo elements on
 // all processors. The new polylines define the shared boundaries in
 // the domain This method computes the polylines on ALL processors,
 // that is why the three dimensions in the structure
 // output_polylines_pt[iproc][ncurve][npolyline]
 // ======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::create_polylines_from_halo_elements_helper(
  const Vector<unsigned> &element_domain,
  std::map<GeneralisedElement*, unsigned> &element_to_global_index,
  std::set<FiniteElement*> &element_in_processor_pt,
  Vector<Vector<Vector<GeneralisedElement*> > > &input_halo_elements,
  std::map<std::pair<Node*,Node*>, unsigned> &elements_edges_on_boundary,
  Vector<Vector<Vector<TriangleMeshPolyLine *> > > &output_polylines_pt)
  {
   const unsigned nproc = this->communicator_pt()->nproc();
   const unsigned my_rank = this->communicator_pt()->my_rank();
   
   // ---------------------------------------------------------------
   // Get the edges shared between each pair of processors
   // ---------------------------------------------------------------
   
   // Storage for the edges (pair of nodes) shared between a pair of
   // processors
   Vector<Vector<Vector<std::pair<Node*,Node*> > > > edges(nproc);
   
   // Each edge is associated to two elements, a haloi (halo element
   // in processors i) and a haloj (halo element in processors j)
   Vector<Vector<Vector<Vector<FiniteElement*> > > > edge_element_pt(nproc);
   
   // Each edge is associated to two elements, a haloi and a haloj,
   // the edge was created from a given face from each element, the
   // haloi face is stored at [0], the haloj face is stored at [1]
   Vector<Vector<Vector<Vector<int> > > > edge_element_face(nproc);
   
   // Store the possible internal boundary id associated to each edge
   // (-1 if there is no association). Some edges may overlap an
   // internal boundary (and only internal boundaries)
   Vector<Vector<Vector<int> > > edge_boundary(nproc);
   
   // Mark those edges (pair of nodes overlapped by a shared boundary)
   std::map<std::pair<Node*,Node*>, bool> overlapped_edge;
   
   // Resize the containers, they store info. for each pair of
   // processors
   
   // First resize the global container
   Shared_boundaries_ids.resize(nproc);
   for (unsigned j = 0 ; j < nproc; j++)
    {
     edges[j].resize(nproc);
     edge_element_pt[j].resize(nproc);
     edge_element_face[j].resize(nproc);
     edge_boundary[j].resize(nproc);
     
     // Resize the global container for shared boundaries ids
     Shared_boundaries_ids[j].resize(nproc);
     
    } // for (j < nproc)
      
   // Take the halo elements of processor "iproc" and compare their
   // edges with halo elements of other processors (except itself)
   for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
     // Take the halo elements of processor iproc and compare with
     // other processors
     // Start from the iproc + 1, 
     // 1) To avoid comparing with itself,
     // 2) To avoid generation of repeated boundaries
     for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
      {
       // **************************************************************
       // FIRST PART
       // 1) Get the halo elements of processor "iproc" with processor
       //    "jproc"
       // 2) Get the halo elements of processor "jproc" with processor
       //    "iproc"
       // 3) Compare their edges and those that match are the ones that
       //    define the shared boundaries
       // **************************************************************
       
       // Storage for halo elements
       Vector<GeneralisedElement*> halo_elements_iproc_with_jproc;
       Vector<GeneralisedElement*> halo_elements_jproc_with_iproc;
       
       // Get the halo elements of "iproc" with "jproc"
       halo_elements_iproc_with_jproc = input_halo_elements[iproc][jproc];
       
       // If there are halo elements then there are shared boundaries
       const unsigned nhalo_elements_iproc_with_jproc = 
        halo_elements_iproc_with_jproc.size();
//       DEBP(nhalo_elements_iproc_with_jproc);
       if (nhalo_elements_iproc_with_jproc > 0)
        {
         // Get the halo elements of "jproc" with "iproc"
         halo_elements_jproc_with_iproc = input_halo_elements[jproc][iproc];

         // If there are halo elements then there are shared
         // boundaries
         const unsigned nhalo_elements_jproc_with_iproc = 
          halo_elements_jproc_with_iproc.size();
//         DEBP(nhalo_elements_jproc_with_iproc);
#ifdef PARANOID
         if (nhalo_elements_jproc_with_iproc == 0)
          {
           // If there are halo elements of iproc with jproc there
           // MUST be halo elements on the other way round, not
           // necessary the same but at least one
           std::stringstream err;
           err <<"There are no halo elements from processor ("<<jproc<<") "
               <<"with processor ("<<iproc<<").\n"
               <<"This is strange since there are halo elements from "
               <<"processor ("<<iproc<<") with processor ("<<jproc<<").\n"
               <<"Number of halo elements from ("<<iproc<<") to ("
               <<jproc<<") : ("<< nhalo_elements_iproc_with_jproc<<")\n"
               <<"Number of halo elements from ("<<jproc<<") to ("
               <<iproc<<") : ("<< nhalo_elements_jproc_with_iproc<<")\n";
            throw OomphLibError(err.str(),
             "TriangleMesh::create_polylines_from_halo_elements_helper()",
             OOMPH_EXCEPTION_LOCATION);
          }
#endif
         // The edges are defined as pair of nodes
         Vector<Node*> halo_edges_iproc;
         unsigned halo_edges_counter_iproc = 0;
         Vector<Node*> halo_edges_jproc;
         unsigned halo_edges_counter_jproc = 0;
                  
         // Map to associate the edge with the element used to create it
         std::map<std::pair<Node*,Node*>,FiniteElement*> edgesi_to_element_pt;
         
         // Map to associated the edge with the face number of the
         // element that created it
         std::map<std::pair<std::pair<Node*,Node*>, FiniteElement*>, int>
          edgesi_element_pt_to_face_index;
         
         // Map to associate the edge with the element used to create it
         std::map<std::pair<Node*,Node*>,FiniteElement*> edgesj_to_element_pt;
         
         // Map to associated the edge with the face number of the
         // element that created it
         std::map<std::pair<std::pair<Node*,Node*>, FiniteElement*>, int>
          edgesj_element_pt_to_face_index;
         
         // **************************************************************
         // 1.1) Store the edges of the "iproc" halo elements
         // **************************************************************
         // Go throught halo elements on "iproc" processor
         for (unsigned ih = 0; ih < nhalo_elements_iproc_with_jproc; ih++)
          {
#ifdef PARANOID
           unsigned e = 
            element_to_global_index[halo_elements_iproc_with_jproc[ih]];
           // Only work with halo elements inside the "jproc" processor
           if (element_domain[e] != jproc)
            {
             // There was a problem on the ihalo-jhalo classification
             std::stringstream err;
             err << "There was a problem on the ihalo-jhalo classification.\n"
                 << "One of the elements, (the one with the ("<<e<<")-th "
                 << "index ) is not on the ("<<jproc<<")-th processor\n"
                 << "but it was stored as a halo element of processor ("
                 << iproc<<") with processor ("<<jproc<<").\n";
             throw OomphLibError(
              err.str(),
              "TriangleMesh::create_polylines_from_halo_elements_helper()",
              OOMPH_EXCEPTION_LOCATION);
            }
#endif
           
           FiniteElement* el_pt = 
            dynamic_cast<FiniteElement*>(halo_elements_iproc_with_jproc[ih]);
           
           if (el_pt==0)
            {
             std::stringstream err;
             err << "The halo element ("<<ih<<") could not be casted to the "
                 << "FiniteElement type.\n";
             throw OomphLibError(
              err.str(),
              "TriangleMesh::create_polylines_from_halo_elements_helper()",
              OOMPH_EXCEPTION_LOCATION);
            }
           
#ifdef PARANOID
           // Number of nodes on this element
           const unsigned n_nodes = el_pt->nnode();
           
           // The number of nodes on every element should be at least
           // three since we are going to work with the cornes nodes,
           // the ones with index 0, 1 and 2
           if (n_nodes<3)
            {
             std::stringstream err;
             err << "The number of nodes of the "<<ih<<"-th halo element is"
                 << " ("<< n_nodes << ").\nWe can not work with triangle "
                 << "elements with less than three nodes\n";
             throw OomphLibError(err.str(),
                                 "TriangleMesh::create_polylines_from_halo_elements_helper()",
                                 OOMPH_EXCEPTION_LOCATION);
            }
#endif
           
           // Get the corner nodes, the first three nodes
           Node *first_node_pt = el_pt->node_pt(0);
           Node *second_node_pt = el_pt->node_pt(1);
           Node *third_node_pt = el_pt->node_pt(2);
           
           // Store the edges 
           halo_edges_iproc.push_back(first_node_pt);
           halo_edges_iproc.push_back(second_node_pt);
           halo_edges_counter_jproc++;

           halo_edges_iproc.push_back(second_node_pt);
           halo_edges_iproc.push_back(third_node_pt);
           halo_edges_counter_jproc++;
           
           halo_edges_iproc.push_back(third_node_pt);
           halo_edges_iproc.push_back(first_node_pt);
           halo_edges_counter_jproc++;
           
           // Store the info. of the element used to create these edges
           std::pair<Node*, Node*> edge1 = 
            std::make_pair(first_node_pt, second_node_pt);
           edgesi_to_element_pt[edge1] = el_pt;
           
           std::pair<Node*, Node*> edge2 = 
            std::make_pair(second_node_pt, third_node_pt);
           edgesi_to_element_pt[edge2] = el_pt;
           
           std::pair<Node*, Node*> edge3 = 
            std::make_pair(third_node_pt, first_node_pt);
           edgesi_to_element_pt[edge3] = el_pt;
           
           // Store the face index of the edge in the element
           std::pair<std::pair<Node*, Node*>, FiniteElement*> edge_ele1 = 
            std::make_pair(edge1, el_pt);
           edgesi_element_pt_to_face_index[edge_ele1] = 2;
           
           std::pair<std::pair<Node*, Node*>, FiniteElement*> edge_ele2 = 
            std::make_pair(edge2, el_pt);
           edgesi_element_pt_to_face_index[edge_ele2] = 0;
           
           std::pair<std::pair<Node*, Node*>, FiniteElement*> edge_ele3 = 
            std::make_pair(edge3, el_pt);
           edgesi_element_pt_to_face_index[edge_ele3] = 1;
           
          } // for (ih < nhalo_elements_iproc_with_jproc)
         
         // **************************************************************
         // 1.2) Store the edges of the "jproc" halo elements
         // **************************************************************
         // Go throught halo elements on "jproc" processor
         for (unsigned jh = 0; jh < nhalo_elements_jproc_with_iproc; jh++)
          {
#ifdef PARANOID
           unsigned e = 
            element_to_global_index[halo_elements_jproc_with_iproc[jh]];
           // Only work with halo elements inside the "jproc" processor
           if (element_domain[e] != iproc)
            {
             // There was a problem on the jhalo-ihalo classification
             std::stringstream err;
             err << "There was a problem on the jhalo-ihalo classification.\n"
                 << "One of the elements, (the one with the ("<<e<<")-th "
                 << "index ) is not on the ("<<iproc<<")-th processor\n"
                 << "but it was stored as a halo element of processor ("
                 << jproc<<") with processor ("<<iproc<<").\n";
             throw OomphLibError(
              err.str(),
              "TriangleMesh::create_polylines_from_halo_elements_helper()",
              OOMPH_EXCEPTION_LOCATION);
            }
#endif
           
           FiniteElement* el_pt = 
            dynamic_cast<FiniteElement*>(halo_elements_jproc_with_iproc[jh]);
           if (el_pt==0)
            {
             std::stringstream err;
             err << "The halo element ("<<jh<<") could not be casted to the "
                 << "FiniteElement type.\n";
             throw OomphLibError(
              err.str(),
              "TriangleMesh::create_polylines_from_halo_elements_helper()",
              OOMPH_EXCEPTION_LOCATION);
            }
           
#ifdef PARANOID
           // Number of nodes on this element
           const unsigned n_nodes = el_pt->nnode();
           
           // The number of nodes on every element should be at least
           // three since we are going to work with the cornes nodes,
           // the ones with index 0, 1 and 2
           if (n_nodes<3)
            {
             std::stringstream err;
             err << "The number of nodes of the "<<jh<<"-th halo element is"
                 << " ("<< n_nodes << ").\nWe can not work with triangle "
                 << "elements with less than three nodes\n";
             throw OomphLibError(err.str(),
                                 "TriangleMesh::create_polylines_from_halo_elements_helper()",
                                 OOMPH_EXCEPTION_LOCATION);
            }
#endif
           
           // Get the nodes pointers
           Node *first_node_pt = el_pt->node_pt(0);
           Node *second_node_pt = el_pt->node_pt(1);
           Node *third_node_pt = el_pt->node_pt(2);

           // Store the edges 
           halo_edges_jproc.push_back(first_node_pt);
           halo_edges_jproc.push_back(second_node_pt);
           halo_edges_counter_iproc++;

           halo_edges_jproc.push_back(second_node_pt);
           halo_edges_jproc.push_back(third_node_pt);
           halo_edges_counter_iproc++;

           halo_edges_jproc.push_back(third_node_pt);
           halo_edges_jproc.push_back(first_node_pt);
           halo_edges_counter_iproc++;

           // Store the info. of the element used to create these edges
           std::pair<Node*, Node*> edge1 = 
            std::make_pair(first_node_pt, second_node_pt);
           edgesj_to_element_pt[edge1] = el_pt;
 
           std::pair<Node*, Node*> edge2 = 
            std::make_pair(second_node_pt, third_node_pt);
           edgesj_to_element_pt[edge2] = el_pt;
             
           std::pair<Node*, Node*> edge3 = 
            std::make_pair(third_node_pt, first_node_pt);
           edgesj_to_element_pt[edge3] = el_pt;
           
           // Store the face index of the edge in the element
           std::pair<std::pair<Node*, Node*>, FiniteElement*> edge_ele1 = 
            std::make_pair(edge1, el_pt);
           edgesj_element_pt_to_face_index[edge_ele1] = 2;
           
           std::pair<std::pair<Node*, Node*>, FiniteElement*> edge_ele2 = 
            std::make_pair(edge2, el_pt);
           edgesj_element_pt_to_face_index[edge_ele2] = 0;
           
           std::pair<std::pair<Node*, Node*>, FiniteElement*> edge_ele3 = 
            std::make_pair(edge3, el_pt);
           edgesj_element_pt_to_face_index[edge_ele3] = 1;
           
          } // for (jh < nhalo_elements_jproc_with_iproc)
         
         // ***************************************************************
         // SECOND PART
         // 1) We already have the information of the edges on the iproc
         //    halo and jproc halo elements
         // 2) Identify the shared edges to create the shared boundaries
         //    (Only store the information but do not create the polyline)
         // ***************************************************************
                  
         // Get the number of edges from each processor
         unsigned nhalo_iedges = halo_edges_iproc.size();
         unsigned nhalo_jedges = halo_edges_jproc.size();
         
         // Start comparing the edges to check which of those are
         // shared between the "ihalo_edge" and the "jhalo_edge"
         for (unsigned ihe = 0; ihe < nhalo_iedges; ihe+=2)
          {
           // Get the ihe-th edge (pair of nodes)
           Vector<Node*> ihalo_edge(2);
           ihalo_edge[0] = halo_edges_iproc[ihe];
           ihalo_edge[1] = halo_edges_iproc[ihe+1];
           
           // Create the pair that defines the edge
           std::pair<Node*,Node*> tmp_edge = std::make_pair(ihalo_edge[0],
                                                            ihalo_edge[1]);
           
           // Check if the edge lies on a boundary (default values is
           // -1 for no association with an internal boundary)
           int edge_boundary_id = -1;
           {
            std::map<std::pair<Node*,Node*>,unsigned >::iterator it;
            it = elements_edges_on_boundary.find(tmp_edge);
            // If the edges lie on a boundary then get the boundary id
            // on which the edges lie
            if (it != elements_edges_on_boundary.end())
             {
              // Assign the internal boundary id associated with the
              // edge
              edge_boundary_id = (*it).second;
             }
            else
             {
              // Look for the reversed version of the edge (the nodes
              // inverted)
              std::pair<Node*,Node*> rtmp_edge = std::make_pair(ihalo_edge[1],
                                                                ihalo_edge[0]);
              it = elements_edges_on_boundary.find(rtmp_edge);
              if (it != elements_edges_on_boundary.end())
               {
                // Assign the internal boundary id associated with the
                // edge
                edge_boundary_id = (*it).second;
               }
             }
           }
           
           // Go through the jhalo_edge and compare with the
           // ihalo_edge
           for (unsigned jhe = 0; jhe < nhalo_jedges; jhe+=2)
            {
             // Get the jhe-th edge (pair of nodes)
             Vector<Node*> jhalo_edge(2);
             jhalo_edge[0] = halo_edges_jproc[jhe];
             jhalo_edge[1] = halo_edges_jproc[jhe+1];
             
             // Comparing pointer of nodes
             if (ihalo_edge[0] == jhalo_edge[0] && 
                 ihalo_edge[1] == jhalo_edge[1])
              {
               // Create the edge (both nodes that make the edge)
               std::pair<Node*, Node*> new_edge = 
                std::make_pair(ihalo_edge[0], ihalo_edge[1]);
               
               // Get the elements involved in the creation of the
               // edge to check that there are elements associated to
               // the edge
               FiniteElement* haloi_ele_pt = 0;
               haloi_ele_pt = edgesi_to_element_pt[new_edge];
               FiniteElement* haloj_ele_pt = 0;
               haloj_ele_pt = edgesj_to_element_pt[new_edge];
               
               // Verify that there is an element associated with it
               if (haloi_ele_pt == 0 || haloj_ele_pt == 0)
                {
                 std::stringstream err;
                 err << "There is no associated elements with the new "
                     << "shared boundary. This is an storing problem,\n"
                     << "possibly related with a memory leak problem!!!\n"
                     << "The nodes that compound the edge are these:\n"
                     << "On processor ("<<iproc<<"):\n"
                     << "("<<ihalo_edge[0]->x(0)<<", "<<ihalo_edge[0]->x(1)
                     <<") and ("<<ihalo_edge[1]->x(0)<<", "
                     <<ihalo_edge[1]->x(1)<<")\n\n"
                     << "On processor ("<<jproc<<"):\n"
                     << "("<<jhalo_edge[0]->x(0)<<", "<<jhalo_edge[0]->x(1)
                     <<") and ("<<jhalo_edge[1]->x(0)<<", "
                     <<jhalo_edge[1]->x(1)<<")\n\n"
                     << "The nodes coordinates should be the same!!!\n";
                 throw OomphLibError(err.str(),
                                     "TriangleMesh::create_polylines_from_halo_elements_helper()",
                                     OOMPH_EXCEPTION_LOCATION);
                }
               
               // Store the edge
               edges[iproc][jproc].push_back(new_edge);
               
               // Is the edge overlapped by a shared boundary
               if (edge_boundary_id >= 0)
                {
                 // Mark the edge as overlapped
                 overlapped_edge[new_edge] = true;
                 
                 // Also mark the reversed edge
                 std::pair<Node*, Node*> rev_new_edge = 
                  std::make_pair(ihalo_edge[1], ihalo_edge[0]);
                 
                 // Mark the edge as overlapped
                 overlapped_edge[rev_new_edge] = true;
                 
                } // if (edge_boundary_id >= 0)

               // Store the internal boundary id (default -1)
               // associated to the edge
               edge_boundary[iproc][jproc].push_back(edge_boundary_id);
               
               // Store the two elements associated with the edge
               Vector<FiniteElement*> tmp_elements_pt;
               tmp_elements_pt.push_back(haloi_ele_pt);
               tmp_elements_pt.push_back(haloj_ele_pt);
               
               // Associate the edge with the elements that gave rise to it
               edge_element_pt[iproc][jproc].push_back(tmp_elements_pt);
               
               // Get the face index on each element that gave rise to
               // the edge
               
               // .. first create the pair (edge, finite_element)
               std::pair<std::pair<Node*,Node*>, FiniteElement*> 
                edge_elementi_pair = make_pair(new_edge, haloi_ele_pt);
               
               std::pair<std::pair<Node*,Node*>, FiniteElement*> 
                edge_elementj_pair = make_pair(new_edge, haloj_ele_pt);
               
               // Set default values to later check if values were
               // read from the map structure
               int face_index_haloi_ele = -1;
               face_index_haloi_ele = 
                edgesi_element_pt_to_face_index[edge_elementi_pair];
               int face_index_haloj_ele = -1;
               face_index_haloj_ele = 
                edgesj_element_pt_to_face_index[edge_elementj_pair];
               // Verify that there is an element associated with it
               if (face_index_haloi_ele == -1 || face_index_haloj_ele == -1)
                {
                 std::stringstream err;
                 err << "There is no associated face indexes to the"
                     << "elements that gave\nrise to the shared edge\n"
                     << "The nodes that compound the edge are these:\n"
                     << "On processor ("<<iproc<<"):\n"
                     << "("<<ihalo_edge[0]->x(0)<<", "<<ihalo_edge[0]->x(1)
                     <<") and ("<<ihalo_edge[1]->x(0)<<", "
                     <<ihalo_edge[1]->x(1)<<")\n\n"
                     << "On processor ("<<jproc<<"):\n"
                     << "("<<jhalo_edge[0]->x(0)<<", "<<jhalo_edge[0]->x(1)
                     <<") and ("<<jhalo_edge[1]->x(0)<<", "
                     <<jhalo_edge[1]->x(1)<<")\n\n"
                     << "The nodes coordinates should be the same!!!\n";
                 throw OomphLibError(err.str(),
                                     "TriangleMesh::create_polylines_from_halo_elements_helper()",
                                     OOMPH_EXCEPTION_LOCATION);
                } // if (face_index_haloi_ele == -1 || 
                  //     face_index_haloj_ele == -1)
               
               // Get the face indexes from the map structure
               Vector<int> tmp_edge_element_face_index;
               tmp_edge_element_face_index.push_back(face_index_haloi_ele);
               tmp_edge_element_face_index.push_back(face_index_haloj_ele);
               // Store the face indexes
               edge_element_face[iproc][jproc].
                push_back(tmp_edge_element_face_index);
               
               break; // break for (jhe < nhalo_jedges) since edge
                      // found
               
              } // if (ihalo_edge[0] == jhalo_edge[0] && 
                //     ihalo_edge[1] == jhalo_edge[1])
             // Comparing nodes pointers
             else if (ihalo_edge[0] == jhalo_edge[1] && 
                      ihalo_edge[1] == jhalo_edge[0])
              {
               // Create the edge (both nodes that make the edge)
               std::pair<Node*, Node*> new_edge = 
                std::make_pair(ihalo_edge[0], ihalo_edge[1]);
               
               // Get the elements involved in the creation of the
               // edge
               FiniteElement* haloi_ele_pt = 0;
               haloi_ele_pt = edgesi_to_element_pt[new_edge];
               
               FiniteElement* haloj_ele_pt = 0;
               // Create the edge (reversed, that is how it was
               // originally stored)
               std::pair<Node*, Node*> new_edge_reversed = 
                std::make_pair(jhalo_edge[0], jhalo_edge[1]);
               haloj_ele_pt = edgesj_to_element_pt[new_edge_reversed];
               
               // Verify that there is an element associated with it
               if (haloi_ele_pt == 0 || haloj_ele_pt == 0)
                {
                 std::stringstream err;
                 err << "There is no associated elements with the new "
                     << "shared boundary (reversed version). This is an "
                     << "storing problem, possibly related with a memory "
                     << "leak problem!!!\n"
                     << "The nodes that compound the edge are these:\n"
                     << "On processor ("<<iproc<<"):\n"
                     << "("<<ihalo_edge[0]->x(0)<<", "<<ihalo_edge[0]->x(1)
                     <<") and ("<<ihalo_edge[1]->x(0)<<", "
                     <<ihalo_edge[1]->x(1)<<")\n\n"
                     << "On processor ("<<jproc<<"):\n"
                     << "("<<jhalo_edge[0]->x(0)<<", "<<jhalo_edge[0]->x(1)
                     <<") and ("<<jhalo_edge[1]->x(0)<<", "
                     <<jhalo_edge[1]->x(1)<<")\n\n"
                     << "The nodes coordinates should be the same!!!\n";
                 throw OomphLibError(err.str(),
                                     "TriangleMesh::create_polylines_from_halo_elements_helper()",
                                     OOMPH_EXCEPTION_LOCATION);
                }
               
               // Store the edge
               edges[iproc][jproc].push_back(new_edge);
               
               // Is the edge overlapped by a shared boundary
               if (edge_boundary_id >= 0)
                {
                 // Mark the edge as overlapped
                 overlapped_edge[new_edge] = true;
                 
                 // Also mark the reversed edge
                 std::pair<Node*, Node*> rev_new_edge = 
                  std::make_pair(ihalo_edge[1], ihalo_edge[0]);
                 
                 // Mark the edge as overlapped
                 overlapped_edge[rev_new_edge] = true;
                } // if (edge_boundary_id >= 0)

               // Store the internal boundary id (default -1)
               // associated to the edge
               edge_boundary[iproc][jproc].push_back(edge_boundary_id);
               
               // Store the two elements associated with the edge
               Vector<FiniteElement*> tmp_elements_pt;
               tmp_elements_pt.push_back(haloi_ele_pt);
               tmp_elements_pt.push_back(haloj_ele_pt);
               
               // Associate the edge with the elements that gave rise to it
               edge_element_pt[iproc][jproc].push_back(tmp_elements_pt);
               
               // Get the face index on each element that gave rise to
               // the edge
               
               // .. first create the pair (edge, finite_element)
               std::pair<std::pair<Node*,Node*>, FiniteElement*> 
                edge_elementi_pair = make_pair(new_edge, haloi_ele_pt);
               
               std::pair<std::pair<Node*,Node*>, FiniteElement*> 
                edge_elementj_pair = make_pair(new_edge_reversed, 
                                               haloj_ele_pt);
               
               // Set default values to later check if values were
               // read from the map structure
               int face_index_haloi_ele = -1;
               face_index_haloi_ele = 
                edgesi_element_pt_to_face_index[edge_elementi_pair];
               int face_index_haloj_ele = -1;
               face_index_haloj_ele = 
                edgesj_element_pt_to_face_index[edge_elementj_pair];
               // Verify that there is an element associated with it
               if (face_index_haloi_ele == -1 || face_index_haloj_ele == -1)
                {
                 std::stringstream err;
                 err << "There is no associated face indexes to the"
                     << "elements that gave\nrise to the shared edge\n"
                     << "The nodes that compound the edge are these:\n"
                     << "On processor ("<<iproc<<"):\n"
                     << "("<<ihalo_edge[0]->x(0)<<", "<<ihalo_edge[0]->x(1)
                     <<") and ("<<ihalo_edge[1]->x(0)<<", "
                     <<ihalo_edge[1]->x(1)<<")\n\n"
                     << "On processor ("<<jproc<<"):\n"
                     << "("<<jhalo_edge[0]->x(0)<<", "<<jhalo_edge[0]->x(1)
                     <<") and ("<<jhalo_edge[1]->x(0)<<", "
                     <<jhalo_edge[1]->x(1)<<")\n\n"
                     << "The nodes coordinates should be the same!!!\n";
                 throw OomphLibError(err.str(),
                                     "TriangleMesh::create_polylines_from_halo_elements_helper()",
                                     OOMPH_EXCEPTION_LOCATION);
                } // if (face_index_haloi_ele == -1 || 
                  //     face_index_haloj_ele == -1)
               
               // Get the face indexes from the map structure
               Vector<int> tmp_edge_element_face_index;
               tmp_edge_element_face_index.push_back(face_index_haloi_ele);
               tmp_edge_element_face_index.push_back(face_index_haloj_ele);
               // Store the face indexes
               edge_element_face[iproc][jproc].
                push_back(tmp_edge_element_face_index);
                              
               break;  // break for (jhe < nhalo_jedges) since edge found
               
              } // else if (ihalo_edge[0] == jhalo_edge[1] && 
                //          ihalo_edge[1] == jhalo_edge[0])
             
            } // for (jhe < nhaloj_edges)
           
          } // for (ihe < nhaloi_edges)

        } // if (nhalo_elements_iproc_with_jproc > 0)
       
      } // for (jproc < nproc)
     
    } // for (iproc < nproc)
   
   // ------------------------------------------------------------------
   // Compute the degree of each node in the shared edges
   // ------------------------------------------------------------------
   
   // Visit all the shared edges between each pair of processors,
   // visit the nodes of each edge and compute the degree of each node
   
   // Store the degree (valency) of each node
   std::map<Node*, unsigned> global_shared_node_degree;
   
#ifdef PARANOID
   // Map to check if an edge has been already visited
   std::map<std::pair<Node*, Node*>,bool> edge_done;
#endif // #ifdef PARANOID
   // Map to check if a node has been already visited
   std::map<Node*,bool> node_done;
   
   // Loop over the processors and get the shared edged between each
   // pair of processors
   for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
     // Start from iproc + 1 to avoid checking with itself (there is
     // no shared edges between the same processor), and to avoid
     // double counting the edges and nodes (the shared edges between
     // processor (iproc, jproc) are the same as those between
     // processor jproc, iproc)
     for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
      {
       // Get the number of edges shared between the pair of processors
       const unsigned nshd_edges = edges[iproc][jproc].size();
#ifdef PARANOID
       // There must be the same number of information on each of the
       // containers
        
       // Get the number of edge elements
       const unsigned nedge_element = edge_element_pt[iproc][jproc].size();
       if (nshd_edges != nedge_element)
        {
         std::stringstream error_message;
         error_message
          << "The number of shared edges between processor iproc and jproc\n"
          << "is different form the number of edge elements between the\n"
          << "pair of processors\n"
          << "iproc: (" << iproc << ")\n"
          << "jproc: (" << jproc << ")\n"
          << "# of shared edges: (" << nshd_edges << ")\n"
          << "# of edge elements: (" << nedge_element << ")\n\n";
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::create_polylines_from_halo_elements_helper()",
                              OOMPH_EXCEPTION_LOCATION);
        }
       
       // Get the number of edge element faces
       const unsigned nedge_element_face = 
        edge_element_face[iproc][jproc].size();
       if (nshd_edges != nedge_element_face)
        {
         std::stringstream error_message;
         error_message
          << "The number of shared edges between processor iproc and jproc\n"
          << "is different form the number of edge element faces between the\n"
          << "pair of processors\n"
          << "iproc: (" << iproc << ")\n"
          << "jproc: (" << jproc << ")\n"
          << "# of shared edges: (" << nshd_edges << ")\n"
          << "# of edge element faces: (" << nedge_element_face << ")\n\n";
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::create_polylines_from_halo_elements_helper()",
                              OOMPH_EXCEPTION_LOCATION);
        }
       
       // Get the number of edge boundaries
       const unsigned nedge_boundary = edge_boundary[iproc][jproc].size();
       if (nshd_edges != nedge_boundary)
        {
         std::stringstream error_message;
         error_message
          << "The number of shared edges between processor iproc and jproc\n"
          << "is different form the number of edge boundaries ids between the\n"
          << "pair of processors\n"
          << "iproc: (" << iproc << ")\n"
          << "jproc: (" << jproc << ")\n"
          << "# of shared edges: (" << nshd_edges << ")\n"
          << "# of edge boundaries ids: (" << nedge_boundary << ")\n\n";
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::create_polylines_from_halo_elements_helper()",
                              OOMPH_EXCEPTION_LOCATION);
        }
       
#endif // #ifdef PARANOID
       
       // Loop over the shared edges between (iproc, jproc) processors
       for (unsigned se = 0; se < nshd_edges; se++)
        {
         // Get the edge
         std::pair<Node*, Node*> edge = edges[iproc][jproc][se];
#ifdef PARANOID
         // Check that the edge has not been previously visited
         if (edge_done[edge])
          {
           std::stringstream error_message;
           error_message
            << "The shared edge between processor iproc and processor\n"
            << "jproc has been already visited, this is weird since the\n"
            << "edge should not be shared by other pair of processors\n"
            << "iproc: (" << iproc << ")\n"
            << "jproc: (" << jproc << ")\n"
            << "First node of edge: (" << edge.first->x(0) << ", " 
            << edge.first->x(1) << ")\n"
            << "Second node of edge: (" << edge.second->x(0) << ", " 
            << edge.second->x(1) << ")\n"
            << "Associated edge boundary id: (" 
            << edge_boundary[iproc][jproc][se] << ")\n\n";
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::create_polylines_from_halo_elements_helper()",
                              OOMPH_EXCEPTION_LOCATION);
          }
         
         // Mark the edge as done
         edge_done[edge] = true;
         // Create the reversed version and include it too
         std::pair<Node*, Node*> rev_edge = 
          std::make_pair(edge.second, edge.first);
         // Mark reversed edge as done
         edge_done[rev_edge] = true;
#endif // #ifdef PARANOID
         
         // Get each of the nodes that conform the edge
         Node* left_node_pt = edge.first;
         Node* right_node_pt = edge.second;
         
         // Check if the left node has been already done
         if (!node_done[left_node_pt])
          {
           // Set the degree of the node to once since this is the
           // first time it has been found
           global_shared_node_degree[left_node_pt] = 1;
           
          } // if (!done_node[left_node_pt])
         else
          {
           // Increase the degree of the node
           global_shared_node_degree[left_node_pt]++;
          }
         
         // Check if the right node has been already done
         if (!node_done[right_node_pt])
          {
           // Set the degree of the node to once since this is the
           // first time it has been found
           global_shared_node_degree[right_node_pt] = 1;
          } // if (!done_node[right_node_pt])
         else
          {
           // Increase the degree of the node
           global_shared_node_degree[right_node_pt]++;
          }
         
        } // for (se < nshd_edges)
       
      } // for (jproc < nproc)
     
    } // for (iproc < nproc)
   
   // -----------------------------------------------------------------
   // Identify those nodes living on edges of original boundaries not
   // overlapped by a shared boundary
   
   // Mark the nodes on original boundaries not overlapped by shared
   // boundaries
   std::map<unsigned, std::map<Node*, bool> > 
    node_on_bnd_not_overlapped_by_shd_bnd;
   
   // Loop over the edges of the original boundaries
   for (std::map<std::pair<Node*,Node*>, unsigned>::iterator it_map =
         elements_edges_on_boundary.begin(); 
        it_map != elements_edges_on_boundary.end(); it_map++)
    {
     // Get the edge
     std::pair<Node*,Node*> edge_pair = (*it_map).first;
     
     // Is the edge overlaped by a shared boundary
     if (!overlapped_edge[edge_pair])
      {
       // Mark the nodes of the edge as being on an edge not overlaped
       // by a shared boundary on the boundary the edge is
       unsigned b = (*it_map).second;
       
       // Get the left node
       Node* left_node_pt = edge_pair.first;
       node_on_bnd_not_overlapped_by_shd_bnd[b][left_node_pt] = true;
       
       // Get the right node
       Node* right_node_pt = edge_pair.second;
       node_on_bnd_not_overlapped_by_shd_bnd[b][right_node_pt] = true;
       
      } // if (!overlapped_edge[edge_pair])
     
    } // Loop over edges to mark those nodes on overlaped edge by
      // shared boundaries
   
   // ------------------------------------------------------------------
   // Now create the shared polylines but including the degree of the
   // nodes as a nw stop condition for adding more edges to the side
   // or a root edge
   // ------------------------------------------------------------------
   
   // Storage for new created polylines with "each processor", non
   // sorted (shared polylines of the current processor only)
   Vector<Vector<TriangleMeshPolyLine *> > unsorted_polylines_pt(nproc);
   
   // Map that associates the shared boundary id with the list of
   // nodes that create it (shared boundary of the current processor
   // only)
   std::map<unsigned, std::list<Node*> > shared_bnd_id_to_sorted_list_node_pt;
   
   // Get maximum user boundary id and set the initial shared boundary
   // id
   unsigned shared_boundary_id_start = this->nboundary();
   Initial_shared_boundary_id = shared_boundary_id_start;    
   
   // Aqui
   
   // Loop over the processors and get the shared edged between each
   // pair of processors
   for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
     // Start from iproc + 1 to avoid checking with itself (there is
     // no shared edges between the same processor), and to avoid
     // double counting the edges and nodes (the shared edges between
     // processor (iproc, jproc) are the same as those between
     // processor jproc, iproc)
     for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
      {
       // *************************************************************
       // THIRD PART 
       // 1) Sort the edges (make them contiguous) so that they can
       // be used as the vertex coordinates that define a shared
       // boundary (polyline)
       // *************************************************************
       unsigned npolylines_counter = 0;
       const unsigned nedges = edges[iproc][jproc].size();
       
       // -----------------------------------------------------------
       // Compute all the SHARED POLYLINES
       // -----------------------------------------------------------
       // The number of sorted edges
       unsigned nsorted_edges = 0;
       
       // Keep track of the already done edges
       std::map<std::pair<Node*,Node*>, bool> edge_done;
       
       // Loop over all the edges to create all the polylines with
       // the current processors involved
       while(nsorted_edges < nedges)
        {
         // Temporaly storage for the elements associated to the
         // sorted edges
         std::list<FiniteElement*> tmp_boundary_element_pt;
         // Temporly storage for the face indexes on the element
         // that created the given edge
         std::list<int> tmp_face_index_element;
         // Get an initial pair of nodes to create an edge
         std::pair<Node*,Node*> edge;
#ifdef PARANOID
         bool found_initial_edge = false;
#endif
         int root_edge_bound_id = -1;
         unsigned iedge = 0;
         for (iedge = 0; iedge < nedges; iedge++)
          {
           edge = edges[iproc][jproc][iedge];
           // If not done then take it as initial edge
           if (!edge_done[edge])
            {
             // Get the boundary id that the edge may be overlapping
             root_edge_bound_id = edge_boundary[iproc][jproc][iedge];
#ifdef PARANOID
             found_initial_edge = true;
#endif
             nsorted_edges++;
             iedge++;
             break;
            } // if (!edge_done[edge])
          } // for (iedge < nedges)
           
#ifdef PARANOID
         if (!found_initial_edge)
          {
           std::ostringstream error_message;
           error_message
            << "All the edge are already done, but the number of done\n"
            << "edges ("<<nsorted_edges<<") is still less than the total\n"
            << "number of edges (" << nedges << ").\n";
           // << "----- Possible memory leak -----\n";
           throw OomphLibError(error_message.str(),
                               "TriangleMesh::create_polylines_from_halo_elements_helper()",
                               OOMPH_EXCEPTION_LOCATION);
          }
#endif
           
         // Storing for the sorting nodes extracted from the
         // edges. The sorted nodes are used to create a polyline
         std::list<Node*> sorted_nodes;
         sorted_nodes.clear();
           
         // The initial and final nodes of the list
         Node *first_node_pt = edge.first;
         Node *last_node_pt = edge.second;
           
         // Push back on the list the new edge (nodes)
         sorted_nodes.push_back(first_node_pt);
         sorted_nodes.push_back(last_node_pt);
           
         // Get the elements associated to the edge and store them
         // in the temporaly boundary elements storage
         tmp_boundary_element_pt.
          push_back(edge_element_pt[iproc][jproc][iedge-1][0]);
         tmp_boundary_element_pt.
          push_back(edge_element_pt[iproc][jproc][iedge-1][1]);
           
         // ... then get the face index of the element from where
         // the edge came from
         tmp_face_index_element.
          push_back(edge_element_face[iproc][jproc][iedge-1][0]);
         tmp_face_index_element.
          push_back(edge_element_face[iproc][jproc][iedge-1][1]);
           
         // Mark edge as done
         edge_done[edge] = true;
           
         // Continue iterating if a new node (that creates a new
         // edge) is added to the list, we have just added two nodes
         // (the first and last of the root edge)
         bool node_added = true;
           
         // Flags to indicate at which end the node was added (left
         // or right)
         bool node_added_to_the_left = true;
         bool node_added_to_the_right = true;
           
         // The nodes that create a shared boundary are obtained by
         // connecting the edges shared by the halo and haloed
         // elements. These edges are connected to left or right of
         // the shared boundary. Every time a new edge is added to
         // the left (or right), the most left (or right) node is
         // searched in the list of nodes of previous shared
         // boundaries, if the node is found then it is said to be
         // shared with another boundary and a connection to that
         // boundary needs to be specified. We stop adding edges
         // (and nodes) to the side where that nodes was found to be
         // shared. Note that the intersection (shared node) may be
         // with the same shared boundary
           
         // Flag to indicate a node was found to be shared with
         // another boundary at the left end (most left node) of the
         // shared boundary
         bool connection_to_the_left = false;
           
         // Flag to indicate a node was found to be shared with
         // another boundary at the right end (most right node) of
         // the shared boundary
         bool connection_to_the_right = false;
           
         // Flag to stop the adding of edges (and nodes) to the
         // current shared boundary
         bool current_polyline_has_connections_at_both_ends = false;
           
         // Store the boundary ids of the polylines to connect (only
         // used when the polyline was found to have a connection)
         // -1: Indicates no connection
         // -2: Indicates connection with itself
         // Any other value: Boundary id to connect
         int bound_id_connection_to_the_left = -1;
         int bound_id_connection_to_the_right = -1;
         
         // Get the degree of the first node
         const unsigned first_node_degree = 
          global_shared_node_degree[first_node_pt];
         
         // Check if the nodes of the root edge have connections
         // ... to the left
         bound_id_connection_to_the_left = 
          check_connections_of_polyline_nodes(
           element_in_processor_pt,
           root_edge_bound_id,
           overlapped_edge,
           node_on_bnd_not_overlapped_by_shd_bnd,
           sorted_nodes, 
           shared_bnd_id_to_sorted_list_node_pt, 
           first_node_degree,
           first_node_pt);
           
         // If there is a connection then set the
         // corresponding flag                     
         // (-1): No connection
         // (-2): Connection with itself
         // (-3): No connection, stop adding nodes
         // (other value): Boundary id
         if (bound_id_connection_to_the_left != -1)
          {
           connection_to_the_left = true;
          } // if (bound_id_connection_to_the_left != -1)
           
         // Get the degree of the last node
         const unsigned last_node_degree = 
          global_shared_node_degree[last_node_pt];
         
         // Check if the nodes of the root edge have connections
         // ... to the right
         bound_id_connection_to_the_right = 
          check_connections_of_polyline_nodes(
           element_in_processor_pt,
           root_edge_bound_id,
           overlapped_edge,
           node_on_bnd_not_overlapped_by_shd_bnd,
           sorted_nodes,
           shared_bnd_id_to_sorted_list_node_pt, 
           last_node_degree,
           last_node_pt);
           
         // If there is a connection then set the
         // corresponding flag
         // (-1): No connection
         // (-2): Connection with itself
         // (other value): Boundary id
         if (bound_id_connection_to_the_right != -1)
          {
           connection_to_the_right = true;
          } // if (bound_id_connection_to_the_right != -1)
           
         // If the current shared boundary has connections at both
         // ends then stop the adding of nodes
         if (connection_to_the_left && connection_to_the_right)
          {current_polyline_has_connections_at_both_ends = true;}
           
         // Continue searching for more edges if 
         // 1) A new node was added at the left or right of the list
         // 2) There are more edges to possible add
         // 3) The added node is not part of any other previous
         //    shared polyline
         while(node_added && (nsorted_edges < nedges)
               && !current_polyline_has_connections_at_both_ends)
          {
           // Start from the next edge since we have already added
           // the previous one as the initial edge (any previous
           // edge had to be added to previous polylines)
           for (unsigned iiedge = iedge; iiedge < nedges; iiedge++)
            {
             // Reset the flags for added nodes, to the left and right
             node_added = false;
             node_added_to_the_left = false;
             node_added_to_the_right = false;
             // Get the current edge
             edge = edges[iproc][jproc][iiedge];
             const int edge_bound_id = edge_boundary[iproc][jproc][iiedge];
               
             // We need to ensure to connect with edges that share
             // the same bound id or with those that has no boundary
             // id associated (the default -1 value), may apply
             // exclusively to internal boundaries
             if (!edge_done[edge] && 
                 (edge_bound_id == root_edge_bound_id))
              {
               // Get each individual node
               Node* left_node_pt = edge.first;
               Node* right_node_pt = edge.second;
                 
               // Pointer to the new added node
               Node* new_added_node_pt = 0;
                 
               // Is the node to be added to the left?
               if (left_node_pt == first_node_pt && 
                   !connection_to_the_left)
                {
                 // Push front the new node
                 sorted_nodes.push_front(right_node_pt);
                 // Update the new added node and the first node
                 new_added_node_pt = first_node_pt = right_node_pt;
                 // Set the node added flag to true
                 node_added = true;
                 // Indicate the node was added to the left
                 node_added_to_the_left = true;
                }
               // Is the node to be added to the right?
               else if (left_node_pt == last_node_pt &&
                        !connection_to_the_right)
                {
                 // Push back the new node
                 sorted_nodes.push_back(right_node_pt);
                 // Update the new added node and the last node
                 new_added_node_pt = last_node_pt = right_node_pt;
                 // Set the node added flag to true
                 node_added = true;
                 // Indicate the node was added to the right
                 node_added_to_the_right = true;
                }
               // Is the node to be added to the left?
               else if (right_node_pt == first_node_pt &&
                        !connection_to_the_left)
                {
                 // Push front the new node
                 sorted_nodes.push_front(left_node_pt);
                 // Update the new added node and the first node
                 new_added_node_pt = first_node_pt = left_node_pt;
                 // Set the node added flag to true
                 node_added = true;
                 // Indicate the node was added to the left
                 node_added_to_the_left = true;
                }
               // Is the node to be added to the right?
               else if (right_node_pt == last_node_pt &&
                        !connection_to_the_right)
                {
                 // Push back the new node
                 sorted_nodes.push_back(left_node_pt);
                 // Update the new added node and the last node
                 new_added_node_pt = last_node_pt = left_node_pt;
                 // Set the node added flag to true
                 node_added = true;
                 // Indicate the node was added to the right
                 node_added_to_the_right = true;
                }
                 
               // If we added a new node then we need to check if
               // that node has been already added in other shared
               // boundaries (which may define a connection)
               if (node_added)
                {
                 // Mark as done only if one of its nodes has been
                 // added to the list
                 edge_done[edge] = true;
                 nsorted_edges++;
                 
                 // Get the degree of the added node
                 const unsigned added_node_degree = 
                  global_shared_node_degree[new_added_node_pt];
                 
                 if (node_added_to_the_left)
                  {
                   // Add the bulk elements
                   tmp_boundary_element_pt.push_front(
                    edge_element_pt[iproc][jproc][iiedge][1]);
                   tmp_boundary_element_pt.push_front(
                    edge_element_pt[iproc][jproc][iiedge][0]);
                   // Add the face elements
                   tmp_face_index_element.push_front(
                    edge_element_face[iproc][jproc][iiedge][1]);
                   tmp_face_index_element.push_front(
                    edge_element_face[iproc][jproc][iiedge][0]);
                  }
                   
                 if (node_added_to_the_right)
                  {
                   // Add the bulk elements
                   tmp_boundary_element_pt.push_back(
                    edge_element_pt[iproc][jproc][iiedge][0]);
                   tmp_boundary_element_pt.push_back(
                    edge_element_pt[iproc][jproc][iiedge][1]);
                   // Add the face elements
                   tmp_face_index_element.push_back(
                    edge_element_face[iproc][jproc][iiedge][0]);
                   tmp_face_index_element.push_back(
                    edge_element_face[iproc][jproc][iiedge][1]);
                  }
                   
                 // Based on which side the node was added, look for
                 // connections on that side
                   
                 // Verify for connections to the left (we need to
                 // check for the connection variable too, since
                 // after a connection has been done we no longer
                 // need to verify for this condition)
                 if (node_added_to_the_left && !connection_to_the_left)
                  {
                   // Check for connection
                   bound_id_connection_to_the_left = 
                    check_connections_of_polyline_nodes(
                     element_in_processor_pt,
                     root_edge_bound_id,
                     overlapped_edge,
                     node_on_bnd_not_overlapped_by_shd_bnd,
                     sorted_nodes, 
                     shared_bnd_id_to_sorted_list_node_pt, 
                     added_node_degree,
                     new_added_node_pt);
                     
                   // If there is a connection then set the
                   // corresponding flag                     
                   // (-1): No connection
                   // (-2): Connection with itself
                   // (other value): Boundary id
                   if (bound_id_connection_to_the_left != -1)
                    {
                     connection_to_the_left = true;
                    } // if (bound_id_connection_to_the_left != -1)
                     
                  } // if (node_added_to_the_left &&
                 //     !connection_to_the_left)
                   
                 // Verify for connections to the right (we need to
                 // check for the connection variable too, since
                 // after a connection has been done we no longer
                 // need to verify for this condition)
                 if (node_added_to_the_right && !connection_to_the_right)
                  {
                   // Check for connection
                   bound_id_connection_to_the_right = 
                    check_connections_of_polyline_nodes(
                     element_in_processor_pt,
                     root_edge_bound_id,
                     overlapped_edge,
                     node_on_bnd_not_overlapped_by_shd_bnd,
                     sorted_nodes,
                     shared_bnd_id_to_sorted_list_node_pt, 
                     added_node_degree,
                     new_added_node_pt);
                     
                   // If there is a connection then set the
                   // corresponding flag
                   // (-1): No connection
                   // (-2): Connection with itself
                   // (other value): Boundary id
                   if (bound_id_connection_to_the_right != -1)
                    {
                     connection_to_the_right = true;
                    } // if (bound_id_connection_to_the_right != -1)
                     
                  } // if (node_added_to_the_right && 
                 //     !connection_to_the_right)
                   
                 // If the current shared boundary has connections
                 // at both ends then stop the adding of nodes
                 if (connection_to_the_left && connection_to_the_right)
                  {current_polyline_has_connections_at_both_ends = true;}
                   
                 // Break the for and re-start to look more edges to
                 // the left or right
                 break;
                   
                } // if (node_added)
                 
              } // if (!edge_done[edge])
            } // for (iiedge < nedges)
             
          } // while(node_added && (nsorted_edges < nedges)
         //       && !current_polyline_has_connections_at_both_ends)
           
         // ------------------------------------------------------------
         // If the sorted nodes of the shared polyline create a loop
         // it is necessary to break it by creating as many
         // polylines as required
           
         // Change the list to a vector representation of the
         // boundary elements and the face indexes
           
         // Get the number of boundary elements
         const unsigned n_bnd_ele = tmp_boundary_element_pt.size();
           
         // Storage for the boundary elements and face indexes
         Vector<FiniteElement*> tmp_bnd_ele_pt(n_bnd_ele);
         Vector<int> tmp_face_idx_ele(n_bnd_ele);
         // Helper counter
         unsigned help_counter = 0;
         // Fill the data structures
         for (std::list<FiniteElement*>::iterator it_bnd_ele = 
               tmp_boundary_element_pt.begin();
              it_bnd_ele != tmp_boundary_element_pt.end();
              it_bnd_ele++)
          {
           tmp_bnd_ele_pt[help_counter++] = (*it_bnd_ele);
          }
           
         // Restart counter
         help_counter = 0;
         for (std::list<int>::iterator it_face_idx = 
               tmp_face_index_element.begin();
              it_face_idx != tmp_face_index_element.end();
              it_face_idx++)
          {
           tmp_face_idx_ele[help_counter++] = (*it_face_idx);
          }
           
         // Store the nodes for the new shared polylines without
         // loops
         Vector<std::list<Node*> > final_sorted_nodes_pt;
         // Store the boundary elements of the shared polyline
         // without loops
         Vector<Vector<FiniteElement*> > final_boundary_element_pt;
         // Face indexes of the boundary elements without loops
         Vector<Vector<int> > final_face_index_element;
         // Connection flags (to the left) of the shared boundaries
         // without loops
         Vector<int> final_bound_id_connection_to_the_left;
         // Connection flags (to the right) of the shared boundaries
         // without loops
         Vector<int> final_bound_id_connection_to_the_right;
           
         // Break any possible loop created by the shared polyline
         break_loops_on_shared_polyline_helper(
          shared_boundary_id_start, 
          sorted_nodes,
          tmp_bnd_ele_pt, tmp_face_idx_ele,
          bound_id_connection_to_the_left, bound_id_connection_to_the_right,
          final_sorted_nodes_pt, 
          final_boundary_element_pt, final_face_index_element,
          final_bound_id_connection_to_the_left,
          final_bound_id_connection_to_the_right);
           
         // Get the number of final sorted nodes
         const unsigned n_final_sorted_nodes = 
          final_sorted_nodes_pt.size();
           
         // Loop over the list of final sorted nodes
         for (unsigned i = 0; i < n_final_sorted_nodes; i++)
          {
           // --------------------------------------------------------
           // Associate the list of sorted nodes with the boundary id
           // of the shared boundary that is going to be crated
           shared_bnd_id_to_sorted_list_node_pt[shared_boundary_id_start] = 
            final_sorted_nodes_pt[i];
             
           // Create the shared polyline and fill the data
           // structured associated to it
           create_shared_polyline(my_rank, shared_boundary_id_start,
                                  iproc, jproc, final_sorted_nodes_pt[i],
                                  root_edge_bound_id,
                                  final_boundary_element_pt[i],
                                  final_face_index_element[i],
                                  unsorted_polylines_pt,
                                  final_bound_id_connection_to_the_left[i],
                                  final_bound_id_connection_to_the_right[i]);
             
           // Increase the register for the number of created shared
           // polylines
           npolylines_counter++;
             
           // Increase the boundary id (the one that will be used by
           // the next shared boundary)
           shared_boundary_id_start++;
             
          } // for (i < n_final_sorted_nodes)
           
        } // while(nsorted_edges < nedges);
       
      } // for (jproc < nproc)
     
     // We already have all the shared polylines (shared boundaries)
     // of processor iproc with processor jproc. Now we sort them so
     // that they be contiguous and can create polygons.
     
     // If there are polylines to be sorted then sort them
     if (unsorted_polylines_pt[iproc].size() > 0)
      {
       // Now that we have all the new unsorted polylines on "iproc"
       // processor it is time to sort them so they be all contiguous
       sort_polylines_helper(unsorted_polylines_pt[iproc], 
                             output_polylines_pt[iproc]);
      }
     
#ifdef PARANOID
     const unsigned nunsorted_polylines_iproc = 
      unsorted_polylines_pt[iproc].size();
     
     // Verify that all the polylines have been sorted
     unsigned tmp_ntotal_polylines = 0;
     // Count the total number of sorted polylines
     for (unsigned ii = 0 ; ii < output_polylines_pt[iproc].size(); ii++)
      {tmp_ntotal_polylines+= output_polylines_pt[iproc][ii].size();}
     if (tmp_ntotal_polylines != nunsorted_polylines_iproc)
      {
       std::ostringstream error_message;
       error_message
        <<" The total number of unsorted polylines (" 
        << nunsorted_polylines_iproc << ") in common with\nprocessor (" 
        << iproc<< ") is different from the total number of sorted "
        << "polylines (" << tmp_ntotal_polylines << ") with\nthe same "
        << "proessor\n";
       throw OomphLibError(error_message.str(),
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
      } // if (tmp_ntotal_polylines != nunsorted_polylines_iproc)
#endif
     
    } // for (iproc < nproc)
   
   // Establish the last used boundary id
   this->Final_shared_boundary_id = shared_boundary_id_start;
   
  }
 
 // ======================================================================
 // \short Break any possible loop created by the sorted list of nodes
 // that is used to create a new shared polyline
 // ======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::break_loops_on_shared_polyline_helper(
  const unsigned &initial_shd_bnd_id,
  std::list<Node*> &input_nodes,
  Vector<FiniteElement*> &input_boundary_element_pt,
  Vector<int> &input_face_index_element,
  const int &input_connect_to_the_left,
  const int &input_connect_to_the_right,
  Vector<std::list<Node*> > &output_sorted_nodes_pt,
  Vector<Vector<FiniteElement*> > &output_boundary_element_pt,
  Vector<Vector<int> > &output_face_index_element,
  Vector<int> &output_connect_to_the_left,
  Vector<int> &output_connect_to_the_right)
 {
  // Get the left and right node of the current list of sorted nodes
  Node* left_node_pt = input_nodes.front();
  Node* right_node_pt = input_nodes.back();
  
  // Temporary storage for list of nodes, boundary elements and face
  // element's indexes
  Vector<std::list<Node*> > tmp_sub_nodes;
  Vector<Vector<FiniteElement*> > tmp_sub_bnd_ele_pt;
  Vector<Vector<int> > tmp_sub_face_idx_ele;
  
  // Iterator for the list of input nodes
  std::list<Node*>::iterator it = input_nodes.begin();
  
  // Counter
  unsigned counter = 0;
  
  // Loop while not all nodes have been done
  while(it != input_nodes.end())
   {
   // Check if the current node is the final one
    it++;
    // Is the current node the final node?
    if (it == input_nodes.end())
     {
      // Break, add no more nodes
      break;
     }
    else
     {
      // Restore the iterator
      it--;
     }
    
    // Get a list of nonrepeated nodes
    std::list<Node*> sub_nodes;
    // The temporary vector of boundary elements associated with the
    // nodes 
    Vector<FiniteElement*> sub_bnd_ele_pt;
    // The temporary vector of face indexes associated with the
    // boundary elements
    Vector<int> sub_face_idx_ele;
    
    // Add the current node to the list
    sub_nodes.push_back(*it);
    
    // Add nodes until found a repeated node (the left or right
    // node) or until reaching the end of the list of nodes
    do
     {
      // Go to the next node
      ++it;
      
      // Add the new node
      sub_nodes.push_back((*it));
      
      // Add the boundary elements
      sub_bnd_ele_pt.push_back(input_boundary_element_pt[counter]);
      sub_bnd_ele_pt.push_back(input_boundary_element_pt[counter+1]);
      
      // Add the face indexes
      sub_face_idx_ele.push_back(input_face_index_element[counter]);
      sub_face_idx_ele.push_back(input_face_index_element[counter+1]);
      
      // Increase the counter
      counter+=2;
      
      // Continue adding until reaching a repeated node or the end
      // of the list of nodes
     }while((*it) != left_node_pt && 
            (*it) != right_node_pt && 
            it != input_nodes.end());
    
    // Add the sub-set of nodes to the temporary storage
    tmp_sub_nodes.push_back(sub_nodes);
    // Add the face elements to the temporary storage
    tmp_sub_bnd_ele_pt.push_back(sub_bnd_ele_pt);
    // Add the face indexes to the temporary storage
    tmp_sub_face_idx_ele.push_back(sub_face_idx_ele);
    
   } // while((*it) != input_nodes.end())
    
  // --------------------------------------------------
  // Now create as many shared boundaries as required
  
  // Get the number of sub-list of nodes created
  const unsigned n_sub_list = tmp_sub_nodes.size();
  
#ifdef PARANOID
  if (n_sub_list > 3)
   {
    std::stringstream error_message;
    error_message
     << "The number of sub-list of nodes created from the shared\n"
     << "polyline with loops was (" << n_sub_list << ").\n"
     << "We can only handle up to three sub-list of nodes\n";
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
  // If there is only one list it may be because there are no loops or
  // there is only one loop (a circle)
  if (n_sub_list == 1 && (left_node_pt != right_node_pt))
   {
    // There are no loops, return just after filling the data
    // structures
    
    // This is the base case used most of the times
    
    // Set the vector of lists of nodes
    output_sorted_nodes_pt = tmp_sub_nodes;
    // Set the vector of boundary elements
    output_boundary_element_pt = tmp_sub_bnd_ele_pt;
    // Set the vector of face indexes
    output_face_index_element = tmp_sub_face_idx_ele;
    
    // Set the connection flags, change them by the proper connection
    // flag
    
#ifdef PARANOID
    if (input_connect_to_the_left == -2)
     {
      std::stringstream error_message;
      error_message
       << "The connection flag to the left (" 
       << input_connect_to_the_left << ") indicates a connection\n"
       << "with the same polyline.\n However, only one sub-polyline was "
       << "found and no loop\nwas identified\n\n";
       throw OomphLibError(error_message.str(),
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
     }
#endif
     
    // The left connection flag
    if (input_connect_to_the_left == -3)
     {
      output_connect_to_the_left.push_back(-1);
     }
    else
     {
      output_connect_to_the_left.push_back(input_connect_to_the_left);
     }
    
#ifdef PARANOID
    if (input_connect_to_the_right == -2)
     {
      std::stringstream error_message;
      error_message
       << "The connection flag to the right (" 
       << input_connect_to_the_right << ") indicates a connection\n"
       << "with the same polyline.\n However, only one sub-polyline was "
       << "found and no loop\nwas identified\n\n";
       throw OomphLibError(error_message.str(),
                           "TriangleMesh::break_loops_on_shared_polyline_helper()",
                           OOMPH_EXCEPTION_LOCATION);
     }
#endif
    
    // The right connection flag
    if (input_connect_to_the_right == -3)
     {
      output_connect_to_the_right.push_back(-1);
     }
    else
     {
      output_connect_to_the_right.push_back(input_connect_to_the_right);
     }
    
    // Return inmediately
    return;
   }
  
  // The temporary storage for the shared boundary id
  unsigned tmp_shd_bnd_id = initial_shd_bnd_id;
  
  // -----------------------------------------------------------------
  // Check all the sub-list of nodes and create two shared boundaries
  // from those that make a loop (circle)
  
  // -----------------------------------------------------------
  // Get the left and right node of the first sub-list of nodes
  Node* left_sub_node_pt = tmp_sub_nodes[0].front();
  Node* right_sub_node_pt = tmp_sub_nodes[0].back();
  
  // Check if the sub-list of nodes creates a loop (circle)
  if (left_sub_node_pt == right_sub_node_pt)
   {
    // We need to create two shared polylines and therefore increase
    // the shared boundary id by two
    
    // The first and second half of nodes
    std::list<Node*> first_half_node_pt;
    std::list<Node*> second_half_node_pt;
    // The first and second half of boundary elements
    Vector<FiniteElement*> first_half_ele_pt;
    Vector<FiniteElement*> second_half_ele_pt;
    // The first and second half of face indexes
    Vector<int> first_half_face_idx;
    Vector<int> second_half_face_idx;
    
    // Get the number of sub-nodes in the sub-list of nodes
    const unsigned n_sub_nodes = tmp_sub_nodes[0].size();
    
    // The number of sub-nodes for the first half of the shared
    // boundary
    const unsigned n_sub_nodes_half = static_cast<unsigned>(n_sub_nodes / 2.0);
    
    // Copy as many sub-nodes for the first half of the sub-polyline
    
    // Iterator to loop over the nodes
    std::list<Node*>::iterator it_sub = tmp_sub_nodes[0].begin();
    
    // Add the first node
    first_half_node_pt.push_back(*it_sub);
    
    // Skip the first node
    it_sub++;
    
    // Counter
    unsigned counter_nodes = 0;
    unsigned counter2 = 0;
    
    // Loop to copy the nodes
    for (;it_sub != tmp_sub_nodes[0].end(); it_sub++)
     {
      // Add the sub-node to the first half
      first_half_node_pt.push_back(*it_sub);
      
      // Add the boundary elements of the first half
      first_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[0][counter2]);
      first_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[0][counter2+1]);
      // Add the face indexes of the first half
      first_half_face_idx.push_back(tmp_sub_face_idx_ele[0][counter2]);
      first_half_face_idx.push_back(tmp_sub_face_idx_ele[0][counter2+1]);
      
      // Increase the counter of added nodes
      counter_nodes++;
      
      // Increase the other counter
      counter2+=2;
      
      if (counter_nodes == n_sub_nodes_half)
       {
        // Stop adding to the first half of nodes
        break;
       }
      
     } // Copy the first half of nodes
    
    // The second half
    
    // Add the first node of the second half
    second_half_node_pt.push_back(*it_sub);
    
    // Skip the first node of the second half
    it_sub++;
    
    // Loop to copy the nodes
    for (;it_sub != tmp_sub_nodes[0].end(); it_sub++)
     {
      // Add the sub-node to the first half
      second_half_node_pt.push_back(*it_sub);
      
      // Add the boundary elements of the first half
      second_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[0][counter2]);
      second_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[0][counter2+1]);
      // Add the face indexes of the first half
      second_half_face_idx.push_back(tmp_sub_face_idx_ele[0][counter2]);
      second_half_face_idx.push_back(tmp_sub_face_idx_ele[0][counter2+1]);
      
      // Increase the other counter
      counter2+=2;
      
     } // Copy the second half of nodes
    
    // Add the sub-list of nodes to the vector of lists of nodes
    output_sorted_nodes_pt.push_back(first_half_node_pt);
    output_sorted_nodes_pt.push_back(second_half_node_pt);
    // Add the sub-vector of elements to the vector of boundary
    // elements
    output_boundary_element_pt.push_back(first_half_ele_pt);
    output_boundary_element_pt.push_back(second_half_ele_pt);
    // Add the sub-vector of face indexes to the vector of face
    // indexes
    output_face_index_element.push_back(first_half_face_idx);
    output_face_index_element.push_back(second_half_face_idx);
    
    // Set the connection flags, change them by the proper connection
    // flag
    
    // ----------------------------------------------------------------
    // Connections flags for the first half
    
    // The left connection flag
    
    // Connected with nothing but required to stop adding nodes
    if (input_connect_to_the_left == -3)
     {
      // Set connected to nothing
      output_connect_to_the_left.push_back(-1);
     }
    // Connected with itself
    else if (input_connect_to_the_left == -2)
     {
      // Set connected to nothing, this is the base node
      output_connect_to_the_left.push_back(-1);
     }
    else
     {
      // Any other value keep it
      output_connect_to_the_left.push_back(input_connect_to_the_left);
     }
    
    // The right connection flag
    
    // Set connected to nothing, this is the base node
    output_connect_to_the_right.push_back(-1);
    
    // Increase the shared boundary id
    tmp_shd_bnd_id++;
    
    // ----------------------------------------------------------------
    // Connections flags for the second half
    
    // The left connection flag
    
    // Set connected to the previous boundary
    output_connect_to_the_left.push_back(tmp_shd_bnd_id-1);
    
    // The right connection flag
    
    // Are we in the last sub-list of nodes, if that is the case we
    // need to respect the flag assigned to the right
    if (n_sub_list == 1)
     {
      if (input_connect_to_the_right == -3)
       {
        // Set connected to the previous shared boundary id
        output_connect_to_the_right.push_back(tmp_shd_bnd_id-1);
       }
      else if (input_connect_to_the_right == -2)
       {
        // Set connected to the previous shared boundary id
        output_connect_to_the_right.push_back(tmp_shd_bnd_id-1);
       }
      else if (input_connect_to_the_right == -1)
       {
        // Set connected to the previous shared boundary id
        output_connect_to_the_right.push_back(tmp_shd_bnd_id-1);
       }
      else
       {
        // Any other value keep it
        output_connect_to_the_right.push_back(input_connect_to_the_right);
       }
     } // if (n_sub_list == 1)
    else
     {
      // Set connected to the previous shared boundary id
      output_connect_to_the_right.push_back(tmp_shd_bnd_id-1);
     }
    
    // Increase the shared boundary id
    tmp_shd_bnd_id++;
    
   } // if (left_sub_node_pt == right_sub_node_pt)
  else
   {
    // No need to create two boundaries, create only one with the
    // sub-list of nodes
    
    // Add the sub-list of nodes to the vector of lists of nodes
    output_sorted_nodes_pt.push_back(tmp_sub_nodes[0]);
    // Add the sub-vector of elements to the vector of boundary
    // elements
    output_boundary_element_pt.push_back(tmp_sub_bnd_ele_pt[0]);
    // Add the sub-vector of face indexes to the vector of face
    // indexes
    output_face_index_element.push_back(tmp_sub_face_idx_ele[0]);
    
    // Set the connection flags, change them by the proper connection
    // flag
    
    // The left connection flag
    
    // Connected with nothing but required to stop adding nodes
    if (input_connect_to_the_left == -3)
     {
      // Set to connected to nothing
      output_connect_to_the_left.push_back(-1);
     }
    // Connected with itself
    else if (input_connect_to_the_left == -2)
     {
      // Set connected to the next shared polyline id
      output_connect_to_the_left.push_back(tmp_shd_bnd_id+1);
     }
    else
     {
      // Any other value keep it
      output_connect_to_the_left.push_back(input_connect_to_the_left);
     }
    
    // The right connection flag
    
    // Set connected to the next shared polyline id
    output_connect_to_the_right.push_back(tmp_shd_bnd_id+1);
    
    // Increase the shared boundary id by one
    tmp_shd_bnd_id++;
    
   } // else if (left_sub_node_pt == right_sub_node_pt)
  
  // At least two sub-list of nodes were created
  if (n_sub_list > 1)
   {
    // ------------------------------------------------------------
    // Get the left and right node of the second sub-list of nodes
    left_sub_node_pt = tmp_sub_nodes[1].front();
    right_sub_node_pt = tmp_sub_nodes[1].back();
  
    // Check if the sub-list of nodes creates a loop (circle)
    if (left_sub_node_pt == right_sub_node_pt)
     {
      // We need to create two shared polylines and therefore increase
      // the shared boundary id by two
      
      // The first and second half of nodes
      std::list<Node*> first_half_node_pt;
      std::list<Node*> second_half_node_pt;
      // The first and second half of boundary elements
      Vector<FiniteElement*> first_half_ele_pt;
      Vector<FiniteElement*> second_half_ele_pt;
      // The first and second half of face indexes
      Vector<int> first_half_face_idx;
      Vector<int> second_half_face_idx;
      
      // Get the number of sub-nodes in the sub-list of nodes
      const unsigned n_sub_nodes = tmp_sub_nodes[1].size();
      
      // The number of sub-nodes for the first half of the shared
      // boundary
      const unsigned n_sub_nodes_half = static_cast<unsigned>(n_sub_nodes / 2.0);
      
      // Copy as many sub-nodes for the first half of the sub-polyline
      
      // Iterator to loop over the nodes
      std::list<Node*>::iterator it_sub = tmp_sub_nodes[1].begin();
      
      // Add the first node
      first_half_node_pt.push_back(*it_sub);
      
      // Skip the first node
      it_sub++;
      
      // Counter
      unsigned counter_nodes = 0;
      unsigned counter2 = 0;
      
      // Loop to copy the nodes
      for (;it_sub != tmp_sub_nodes[1].end(); it_sub++)
       {
        // Add the sub-node to the first half
        first_half_node_pt.push_back(*it_sub);
        // Add the boundary elements of the first half
        first_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[1][counter2]);
        first_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[1][counter2+1]);
        // Add the face indexes of the first half
        first_half_face_idx.push_back(tmp_sub_face_idx_ele[1][counter2]);
        first_half_face_idx.push_back(tmp_sub_face_idx_ele[1][counter2+1]);
        
        // Increase the counter of added nodes
        counter_nodes++;
        
        // Increase the other counter
        counter2+=2;
      
        if (counter_nodes == n_sub_nodes_half)
         {
          // Stop adding to the first half of nodes
          break;
         }
        
       } // Copy the first half of nodes
      
      // The second half
      
      // Add the first node of the second half
      second_half_node_pt.push_back(*it_sub);
      
      // Skip the first node of the second half
      it_sub++;
      
      // Loop to copy the nodes
      for (;it_sub != tmp_sub_nodes[1].end(); it_sub++)
       {
        // Add the sub-node to the first half
        second_half_node_pt.push_back(*it_sub);
        // Add the boundary elements of the first half
        second_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[1][counter2]);
        second_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[1][counter2+1]);
        // Add the face indexes of the first half
        second_half_face_idx.push_back(tmp_sub_face_idx_ele[1][counter2]);
        second_half_face_idx.push_back(tmp_sub_face_idx_ele[1][counter2+1]);
        
        // Increase the other counter
        counter2+=2;
        
       } // Copy the second half of nodes
      
      // Add the sub-list of nodes to the vector of lists of nodes
      output_sorted_nodes_pt.push_back(first_half_node_pt);
      output_sorted_nodes_pt.push_back(second_half_node_pt);
      // Add the sub-vector of elements to the vector of boundary
      // elements
      output_boundary_element_pt.push_back(first_half_ele_pt);
      output_boundary_element_pt.push_back(second_half_ele_pt);
      // Add the sub-vector of face indexes to the vector of face
      // indexes
      output_face_index_element.push_back(first_half_face_idx);
      output_face_index_element.push_back(second_half_face_idx);
      
      // Set the connection flags, change them by the proper
      // connection flag
      
      // --------------------------------------
      // Connections flags for the first half
      
      // The left connection flag
      
      // Connected to the previous boundary
      output_connect_to_the_left.push_back(tmp_shd_bnd_id-1);
      
      // The right connection flag
      
      // Set connected to nothing, this is the base node
      output_connect_to_the_right.push_back(-1);
      
      // Increase the shared boundary id
      tmp_shd_bnd_id++;
      
      // --------------------------------------
      // Connections flags for the second half
      
      // The left connection flag
      
      // Set connected to the previous boundary
      output_connect_to_the_left.push_back(tmp_shd_bnd_id-1);
      
      // The right connection flag
      
      // Are we in the last sub-list of nodes, if that is the case we
      // need to respect the flag assigned to the right
      if (n_sub_list == 2)
       {
        // Connected with nothing
        if (input_connect_to_the_right == -1)
         {
          // Set connected to the previous shared boundary
          output_connect_to_the_right.push_back(tmp_shd_bnd_id-1);
         }
        // Connected with the same boundary
        else if (input_connect_to_the_right == -2)
         {
          // Set connected to the previous shared boundary
          output_connect_to_the_right.push_back(tmp_shd_bnd_id-1);
         }
        // Connetted with nothing but stop adding nodes
        else if (input_connect_to_the_right == -3)
         {
          // Set connected to the previous shared boundary
          output_connect_to_the_right.push_back(tmp_shd_bnd_id-1);
         }
        else
         {
          // Any other value keep it
          output_connect_to_the_right.push_back(input_connect_to_the_right);
         }
        
        // Increase the shared boundary id
        tmp_shd_bnd_id++;
        
       } // if (n_sub_list == 2)
#ifdef PARANOID
      else
       {
        std::stringstream error_message;
        error_message
         << "The second sub-list of nodes creates a loop but this is not\n"
         << "the last list of sub-nodes.\n"
         << "This configuration is not supported\n";
         throw OomphLibError(error_message.str(),
                             "TriangleMesh::break_loops_on_shared_polyline_helper()",
                             OOMPH_EXCEPTION_LOCATION);
       }
#endif
      
     } // if (left_sub_node_pt == right_sub_node_pt)
    else
     {
      // No need to create two boundaries, create only one with the
      // sub-list of nodes
    
      // Add the sub-list of nodes to the vector of lists of nodes
      output_sorted_nodes_pt.push_back(tmp_sub_nodes[1]);
      // Add the sub-vector of elements to the vector of boundary
      // elements
      output_boundary_element_pt.push_back(tmp_sub_bnd_ele_pt[1]);
      // Add the sub-vector of face indexes to the vector of face
      // indexes
      output_face_index_element.push_back(tmp_sub_face_idx_ele[1]);
    
      // Set the connection flags, change them by the proper connection
      // flag
      
      // The left connection flag
    
      // Set connected to the previous shared boundary id
      output_connect_to_the_left.push_back(tmp_shd_bnd_id-1);
    
      // The right connection flag
    
      // Are we in the last sub-list of nodes, if that is the case we
      // need to respect the flag assigned to the right
      if (n_sub_list == 2)
       {
        // Connected with nothing but required to stop adding nodes
        if (input_connect_to_the_right == -3)
         {
          // Set to connected to nothing
          output_connect_to_the_right.push_back(-1);
         }
#ifdef PARANOID
        // Connected with itself
        else if (input_connect_to_the_right == -2)
         {
          std::stringstream error_message;
          error_message
           << "The connection flag to the right (" 
           << input_connect_to_the_right << ") indicates a connection\n"
           << "with the same polyline.\n However, the second sub-list of\n"
           << "nodes was found not making a loop so no connection with\n"
           << "itself should be marked\n\n";
           throw OomphLibError(error_message.str(),
                               "TriangleMesh::break_loops_on_shared_polyline_helper()",
                               OOMPH_EXCEPTION_LOCATION);
         }
#endif
        else
         {
          // Any other value keep it
          output_connect_to_the_right.push_back(input_connect_to_the_right);
         }
       } // if (n_sub_list == 2)
      else
       {
        // Set connected to the next shared boundary id
        output_connect_to_the_right.push_back(tmp_shd_bnd_id+1);
       } // else if (n_sub_list == 2)
    
      // Increase the shared boundary id by one
      tmp_shd_bnd_id++;
    
     } // if (left_sub_node_pt == right_sub_node_pt)
    
   } // if (n_sub_list > 1)
  
  // Three sub-list of nodes were created
  if (n_sub_list > 2)
   {
    // ------------------------------------------------------------
    // Get the left and right node of the third sub-list of nodes
    left_sub_node_pt = tmp_sub_nodes[2].front();
    right_sub_node_pt = tmp_sub_nodes[2].back();
    
    // Check if the sub-list of nodes creates a loop (circle)
    if (left_sub_node_pt == right_sub_node_pt)
     {
      // We need to create two shared polylines and therefore increase
      // the shared boundary id by two
      
      // The first and second half of nodes
      std::list<Node*> first_half_node_pt;
      std::list<Node*> second_half_node_pt;
      // The first and second half of boundary elements
      Vector<FiniteElement*> first_half_ele_pt;
      Vector<FiniteElement*> second_half_ele_pt;
      // The first and second half of face indexes
      Vector<int> first_half_face_idx;
      Vector<int> second_half_face_idx;
      
      // Get the number of sub-nodes in the sub-list of nodes
      const unsigned n_sub_nodes = tmp_sub_nodes[2].size();
      
      // The number of sub-nodes for the first half of the shared
      // boundary
      const unsigned n_sub_nodes_half = static_cast<unsigned>(n_sub_nodes / 2.0);
      
      // Copy as many sub-nodes for the first half of the sub-polyline
      
      // Iterator to loop over the nodes
      std::list<Node*>::iterator it_sub = tmp_sub_nodes[2].begin();
      
      // Add the first node
      first_half_node_pt.push_back(*it_sub);
      
      // Skip the first node
      it_sub++;
      
      // Counter
      unsigned counter_nodes = 0;
      unsigned counter2 = 0;
      
      // Loop to copy the nodes
      for (;it_sub != tmp_sub_nodes[2].end(); it_sub++)
       {
        // Add the sub-node to the first half
        first_half_node_pt.push_back(*it_sub);
        // Add the boundary elements of the first half
        first_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[2][counter2]);
        first_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[2][counter2+1]);
        // Add the face indexes of the first half
        first_half_face_idx.push_back(tmp_sub_face_idx_ele[2][counter2]);
        first_half_face_idx.push_back(tmp_sub_face_idx_ele[2][counter2+1]);
        
        // Increase the counter of added nodes
        counter_nodes++;
        
        // Increase the other counter
        counter2+=2;
        
        if (counter_nodes == n_sub_nodes_half)
         {
          // Stop adding to the first half of nodes
          break;
         }
        
       } // Copy the first half of nodes
      
      // The second half
      
      // Add the first node of the second half
      second_half_node_pt.push_back(*it_sub);
      
      // Skip the first node of the second half
      it_sub++;
      
      // Loop to copy the nodes
      for (;it_sub != tmp_sub_nodes[2].end(); it_sub++)
       {
        // Add the sub-node to the first half
        second_half_node_pt.push_back(*it_sub);
        // Add the boundary elements of the first half
        second_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[2][counter2]);
        second_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[2][counter2+1]);
        // Add the face indexes of the first half
        second_half_face_idx.push_back(tmp_sub_face_idx_ele[2][counter2]);
        second_half_face_idx.push_back(tmp_sub_face_idx_ele[2][counter2+1]);
        
        // Increase the other counter
        counter2+=2;
        
       } // Copy the second half of nodes
      
      // Add the sub-list of nodes to the vector of lists of nodes
      output_sorted_nodes_pt.push_back(first_half_node_pt);
      output_sorted_nodes_pt.push_back(second_half_node_pt);
      // Add the sub-vector of elements to the vector of boundary
      // elements
      output_boundary_element_pt.push_back(first_half_ele_pt);
      output_boundary_element_pt.push_back(second_half_ele_pt);
      // Add the sub-vector of face indexes to the vector of face
      // indexes
      output_face_index_element.push_back(first_half_face_idx);
      output_face_index_element.push_back(second_half_face_idx);
      
      // --------------------------------------
      // Connections flags for the first half
      
      // The left connection flag

      // Connected to the previous shared boundary
      output_connect_to_the_left.push_back(tmp_shd_bnd_id-1);
      
      // The right connection flag
      
      // Set connected to nothing, this is the base node
      output_connect_to_the_right.push_back(-1);
      
      // Increase the shared boundary id
      tmp_shd_bnd_id++;
      
      // --------------------------------------
      // Connections flags for the second half
      
      // The left connection flag
      
      // Set connected to the previous boundary
      output_connect_to_the_left.push_back(tmp_shd_bnd_id-1);
      
      // The right connection flag
      
      if (input_connect_to_the_right == -3)
       {
        // Set connected to the previous shared boundary id
        output_connect_to_the_right.push_back(tmp_shd_bnd_id-1);
       }
      else if (input_connect_to_the_right == -2)
       {
        // Set connected to the previous shared boundary id
        output_connect_to_the_right.push_back(tmp_shd_bnd_id-1);
       }
      else if (input_connect_to_the_right == -1)
       {
        // Set connected to the previous shared boundary id
        output_connect_to_the_right.push_back(tmp_shd_bnd_id-1);
       }
      else
       {
        // Any other value keep it
        output_connect_to_the_right.push_back(input_connect_to_the_right);
       }
      
      // Increase the shared boundary id
      tmp_shd_bnd_id++;
      
     } // if (left_sub_node_pt == right_sub_node_pt)
    else
     {
      // No need to create two boundaries, create only one with the
      // sub-list of nodes
      
      // Add the sub-list of nodes to the vector of lists of nodes
      output_sorted_nodes_pt.push_back(tmp_sub_nodes[2]);
      // Add the sub-vector of elements to the vector of boundary
      // elements
      output_boundary_element_pt.push_back(tmp_sub_bnd_ele_pt[2]);
      // Add the sub-vector of face indexes to the vector of face
      // indexes
      output_face_index_element.push_back(tmp_sub_face_idx_ele[2]);
      
      // Set the connection flags, change them by the proper
      // connection flag
      
      // The left connection flag
      
      // Set connected to the previous shared boundary id
      output_connect_to_the_left.push_back(tmp_shd_bnd_id-1);
      
      // The right connection flag
      
      // Connected with nothing but required to stop adding nodes
      if (input_connect_to_the_right == -3)
       {
        std::stringstream error_message;
        error_message
         << "The connection flag to the right (" 
         << input_connect_to_the_right << ") indicates 'no connection and\n"
         << "stop adding nodes'.\n However, the thrid sub-list of\n"
         << "nodes must have a connection to the right with the same\n"
         << "shared polyline or with any other polyline\n\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::break_loops_on_shared_polyline_helper()",
                            OOMPH_EXCEPTION_LOCATION);
       }
      else if (input_connect_to_the_right == -1)
       {
        std::stringstream error_message;
        error_message
         << "The connection flag to the right (" 
         << input_connect_to_the_right << ") indicates 'no connection.\n"
         << "However, the thrid sub-list of nodes must have a connection\n"
         << "to the right with the same shared polyline or with any other\n"
         << "polyline\n\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::break_loops_on_shared_polyline_helper()",
                            OOMPH_EXCEPTION_LOCATION);
       }
      // Connected with itself
      else if (input_connect_to_the_right == -2)
       {
        // Set connected to the previous shared boundary id
        output_connect_to_the_right.push_back(tmp_shd_bnd_id-1);
       }
      else
       {
        // Any other value keep it
        output_connect_to_the_right.push_back(input_connect_to_the_right);
       }
      
      // Increase the shared boundary id by one
      tmp_shd_bnd_id++;
      
     } // if (left_sub_node_pt == right_sub_node_pt)
    
   } // if (n_sub_list > 2)
  
 }

 // ======================================================================
 // \short Break any possible loop created by the sorted list of nodes
 // that is used to create a new shared polyline
 // ======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::
 break_loops_on_shared_polyline_load_balance_helper(
  const unsigned &initial_shd_bnd_id,
  std::list<Node*> &input_nodes,
  Vector<FiniteElement*> &input_boundary_element_pt,
  Vector<FiniteElement*> &input_boundary_face_element_pt,
  Vector<int> &input_face_index_element,
  const int &input_connect_to_the_left,
  const int &input_connect_to_the_right,
  Vector<std::list<Node*> > &output_sorted_nodes_pt,
  Vector<Vector<FiniteElement*> > &output_boundary_element_pt,
  Vector<Vector<FiniteElement*> > &output_boundary_face_element_pt,
  Vector<Vector<int> > &output_face_index_element,
  Vector<int> &output_connect_to_the_left,
  Vector<int> &output_connect_to_the_right)
 {
  // Get the left and right node of the current list of sorted nodes
  Node* left_node_pt = input_nodes.front();
  Node* right_node_pt = input_nodes.back();
  
  // Temporary storage for list of nodes, boundary elements, boundary
  // face elements and face element's indexes
  Vector<std::list<Node*> > tmp_sub_nodes;
  Vector<Vector<FiniteElement*> > tmp_sub_bnd_ele_pt;
  Vector<Vector<FiniteElement*> > tmp_sub_bnd_face_ele_pt;
  Vector<Vector<int> > tmp_sub_face_idx_ele;
  
  // Iterator for the list of input nodes
  std::list<Node*>::iterator it = input_nodes.begin();
  
  // Counter
  unsigned counter = 0;
  
  // Loop while not all nodes have been done
  while(it != input_nodes.end())
   {
   // Check if the current node is the final one
    it++;
    // Is the current node the final node?
    if (it == input_nodes.end())
     {
      // Break, add no more nodes
      break;
     }
    else
     {
      // Restore the iterator
      it--;
     }
    
    // Get a list of nonrepeated nodes
    std::list<Node*> sub_nodes;
    // The temporary vector of boundary elements associated with the
    // nodes 
    Vector<FiniteElement*> sub_bnd_ele_pt;
    // The temporary vector of boundary face elements associated with
    // the nodes
    Vector<FiniteElement*> sub_bnd_face_ele_pt;
    // The temporary vector of face indexes associated with the
    // boundary elements
    Vector<int> sub_face_idx_ele;
    
    // Add the current node to the list
    sub_nodes.push_back(*it);
    
    // Add nodes until found a repeated node (the left or right
    // node) or until reaching the end of the list of nodes
    do
     {
      // Go to the next node
      ++it;
      
      // Add the new node
      sub_nodes.push_back((*it));
      
      // Add the boundary elements
      sub_bnd_ele_pt.push_back(input_boundary_element_pt[counter]);
      
      // Add the boundary face elements
      sub_bnd_face_ele_pt.push_back(input_boundary_face_element_pt[counter]);
      
      // Add the face indexes
      sub_face_idx_ele.push_back(input_face_index_element[counter]);
      
      // Increase the counter
      counter++;
      
      // Continue adding until reaching a repeated node or the end
      // of the list of nodes
     }while((*it) != left_node_pt && 
            (*it) != right_node_pt && 
            it != input_nodes.end());
    
    // Add the sub-set of nodes to the temporary storage
    tmp_sub_nodes.push_back(sub_nodes);
    
    // Add the boundary elements to the temporary storage
    tmp_sub_bnd_ele_pt.push_back(sub_bnd_ele_pt);
    // Add the boundary face elements to the temporary storage
    tmp_sub_bnd_face_ele_pt.push_back(sub_bnd_face_ele_pt);
    // Add the face indexes to the temporary storage
    tmp_sub_face_idx_ele.push_back(sub_face_idx_ele);
    
   } // while((*it) != input_nodes.end())
  
  // --------------------------------------------------
  // Now create as many shared boundaries as required
  
  // Get the number of sub-list of nodes created
  const unsigned n_sub_list = tmp_sub_nodes.size();
  
#ifdef PARANOID
  if (n_sub_list > 1)
   {
    std::stringstream error_message;
    error_message
     << "The number of sub-list of nodes created from the shared\n"
     << "polyline with loops was (" << n_sub_list << ").\n"
     << "We can only handle one list which may still contain loops\n"
     << "(or repeated nodes)\n";
    throw OomphLibError(error_message.str(),
                        "TriangleMesh::break_loops_on_shared_polyline_load_balance_helper()",
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
  // If there is only one list it may be because there are no loops or
  // there is only one loop (a circle)
  if (n_sub_list == 1 && (left_node_pt != right_node_pt))
   {
    // There are no loops, return just after filling the data
    // structures
    
    // This is the base case used most of the times
    
    // Set the vector of lists of nodes
    output_sorted_nodes_pt = tmp_sub_nodes;
    // Set the vector of boundary elements
    output_boundary_element_pt = tmp_sub_bnd_ele_pt;
    // Set the vector of boundary face elements
    output_boundary_face_element_pt = tmp_sub_bnd_face_ele_pt;
    // Set the vector of face indexes
    output_face_index_element = tmp_sub_face_idx_ele;
    
    // Set the connection flags, change them by the proper connection
    // flag
    
#ifdef PARANOID
    if (input_connect_to_the_left == -2)
     {
      std::stringstream error_message;
      error_message
       << "The connection flag to the left (" 
       << input_connect_to_the_left << ") indicates a connection\n"
       << "with the same polyline.\n However, only one sub-polyline was "
       << "found and no loops\nwere identified\n\n";
       throw OomphLibError(error_message.str(),
                           "TriangleMesh::break_loops_on_shared_polyline_load_balance_helper()",
                           OOMPH_EXCEPTION_LOCATION);
     }
#endif
    
    // The left connection flag
    if (input_connect_to_the_left == -3)
     {
      output_connect_to_the_left.push_back(-1);
     }
    else
     {
      output_connect_to_the_left.push_back(input_connect_to_the_left);
     }
    
#ifdef PARANOID
    if (input_connect_to_the_right == -2)
     {
      std::stringstream error_message;
      error_message
       << "The connection flag to the right (" 
       << input_connect_to_the_right << ") indicates a connection\n"
       << "with the same polyline.\n However, only one sub-polyline was "
       << "found and no loops\nwere identified\n\n";
       throw OomphLibError(error_message.str(),
                           "TriangleMesh::break_loops_on_shared_polyline_load_balance_helper()",
                           OOMPH_EXCEPTION_LOCATION);
     }
#endif
    
    // The right connection flag
    if (input_connect_to_the_right == -3)
     {
      output_connect_to_the_right.push_back(-1);
     }
    else
     {
      output_connect_to_the_right.push_back(input_connect_to_the_right);
     }
    
    // Return immediately
    return;
   }
  
  // The temporary storage for the shared boundary id
  unsigned tmp_shd_bnd_id = initial_shd_bnd_id;
  
  // -----------------------------------------------------------------
  // Check all the sub-list of nodes and create two shared boundaries
  // from those that make a loop (circle)
  
  // -----------------------------------------------------------
  // Get the left and right node of the first sub-list of nodes
  Node* left_sub_node_pt = tmp_sub_nodes[0].front();
  Node* right_sub_node_pt = tmp_sub_nodes[0].back();
  
  // Check if the sub-list of nodes creates a loop (circle)
  if (left_sub_node_pt == right_sub_node_pt)
   {
    // We need to create two shared polylines and therefore increase
    // the shared boundary id by two
    
    // The first and second half of nodes
    std::list<Node*> first_half_node_pt;
    std::list<Node*> second_half_node_pt;
    // The first and second half of boundary elements
    Vector<FiniteElement*> first_half_ele_pt;
    Vector<FiniteElement*> second_half_ele_pt;
    // The first and second half of boundary face elements
    Vector<FiniteElement*> first_half_ele_face_pt;
    Vector<FiniteElement*> second_half_ele_face_pt;
    // The first and second half of face indexes
    Vector<int> first_half_face_idx;
    Vector<int> second_half_face_idx;
    
    // Get the number of sub-nodes in the sub-list of nodes
    const unsigned n_sub_nodes = tmp_sub_nodes[0].size();
    
    // The number of sub-nodes for the first half of the shared
    // boundary
    const unsigned n_sub_nodes_half = static_cast<unsigned>(n_sub_nodes / 2.0);
    
    // Copy as many sub-nodes for the first half of the sub-polyline
    
    // Iterator to loop over the nodes
    std::list<Node*>::iterator it_sub = tmp_sub_nodes[0].begin();
    
    // Add the first node
    first_half_node_pt.push_back(*it_sub);
    
    // Skip the first node
    it_sub++;
    
    // Counter
    unsigned counter_nodes = 0;
    unsigned counter2 = 0;
    
    // Loop to copy the nodes
    for (;it_sub != tmp_sub_nodes[0].end(); it_sub++)
     {
      // Add the sub-node to the first half
      first_half_node_pt.push_back(*it_sub);
      
      // Add the boundary elements of the first half
      first_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[0][counter2]);
      // Add the boundary face elements of the first half
      first_half_ele_face_pt.push_back(tmp_sub_bnd_face_ele_pt[0][counter2]);
      // Add the face indexes of the first half
      first_half_face_idx.push_back(tmp_sub_face_idx_ele[0][counter2]);
      
      // Increase the counter of added nodes
      counter_nodes++;
      
      // Increase the other counter (of the elements/face)
      counter2++;
      
      if (counter_nodes == n_sub_nodes_half)
       {
        // Stop adding to the first half of nodes
        break;
       }
      
     } // Copy the first half of nodes
    
    // The second half
    
    // Add the first node of the second half
    second_half_node_pt.push_back(*it_sub);
    
    // Skip the first node of the second half
    it_sub++;
    
    // Loop to copy the nodes
    for (;it_sub != tmp_sub_nodes[0].end(); it_sub++)
     {
      // Add the sub-node to the first half
      second_half_node_pt.push_back(*it_sub);
      
      // Add the boundary elements of the first half
      second_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[0][counter2]);
      // Add the boundary face elements of the first half
      second_half_ele_face_pt.push_back(tmp_sub_bnd_face_ele_pt[0][counter2]);
      // Add the face indexes of the first half
      second_half_face_idx.push_back(tmp_sub_face_idx_ele[0][counter2]);
      
      // Increase the other counter
      counter2++;
      
     } // Copy the second half of nodes
    
    // Add the sub-list of nodes to the vector of lists of nodes
    output_sorted_nodes_pt.push_back(first_half_node_pt);
    output_sorted_nodes_pt.push_back(second_half_node_pt);
    // Add the sub-vector of elements to the vector of boundary
    // elements
    output_boundary_element_pt.push_back(first_half_ele_pt);
    output_boundary_element_pt.push_back(second_half_ele_pt);
    // Add the sub-vector of face elements to the vector of boundary
    // elements
    output_boundary_face_element_pt.push_back(first_half_ele_face_pt);
    output_boundary_face_element_pt.push_back(second_half_ele_face_pt);
    // Add the sub-vector of face indexes to the vector of face
    // indexes
    output_face_index_element.push_back(first_half_face_idx);
    output_face_index_element.push_back(second_half_face_idx);
    
    // Set the connection flags, change them by the proper connection
    // flag
    
    // ----------------------------------------------------------------
    // Connections flags for the first half
    
    // The left connection flag
    
    // Connected with nothing but required to stop adding nodes
    if (input_connect_to_the_left == -3)
     {
      // Set connected to nothing
      output_connect_to_the_left.push_back(-1);
     }
    // Connected with itself
    else if (input_connect_to_the_left == -2)
     {
      // Set connected to nothing, this is the base node
      output_connect_to_the_left.push_back(-1);
     }
    else
     {
      // Any other value keep it
      output_connect_to_the_left.push_back(input_connect_to_the_left);
     }
    
    // The right connection flag
    
    // Set connected to nothing, this is the base node
    output_connect_to_the_right.push_back(-1);
    
    // Increase the shared boundary id
    tmp_shd_bnd_id++;
    
    // ----------------------------------------------------------------
    // Connections flags for the second half
    
    // The left connection flag
    
    // Set connected to the previous boundary
    output_connect_to_the_left.push_back(tmp_shd_bnd_id-1);
    
    // The right connection flag
    
    // Are we in the last sub-list of nodes, if that is the case we
    // need to respect the flag assigned to the right
    if (n_sub_list == 1)
     {
      if (input_connect_to_the_right == -3)
       {
        // Set connected to the previous shared boundary id
        output_connect_to_the_right.push_back(tmp_shd_bnd_id-1);
       }
      else if (input_connect_to_the_right == -2)
       {
        // Set connected to the previous shared boundary id
        output_connect_to_the_right.push_back(tmp_shd_bnd_id-1);
       }
      else if (input_connect_to_the_right == -1)
       {
        // Set connected to the previous shared boundary id
        output_connect_to_the_right.push_back(tmp_shd_bnd_id-1);
       }
      else
       {
        // Any other value keep it
        output_connect_to_the_right.push_back(input_connect_to_the_right);
       }
     } // if (n_sub_list == 1)
    else
     {
      // Set connected to the previous shared boundary id
      output_connect_to_the_right.push_back(tmp_shd_bnd_id-1);
     }
    
    // Increase the shared boundary id
    tmp_shd_bnd_id++;
    
   } // if (left_sub_node_pt == right_sub_node_pt)
#ifdef PARANOID
  else
   {
    std::stringstream error_message;
    error_message
     << "The initial and final node in the current shared polyline are not\n"
     << "the same and the number of sublists is ("<< n_sub_list << ").\n"
     << "We can not handle more than one sublist in the method to break\n"
     << "loops at the load balance stage\n\n";
     throw OomphLibError(error_message.str(),
                         "TriangleMesh::break_loops_on_shared_polyline_load_balance_helper()",
                         OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
 }

 // ======================================================================
 // \short Create the shared polyline and fill the data structured
 // that keep all the information associated with the creationg of the
 // shared boundary
 // ======================================================================
 template<class ELEMENT>
 void TriangleMesh<ELEMENT>::
 create_shared_polyline(const unsigned &my_rank,
                        const unsigned &shd_bnd_id,
                        const unsigned &iproc,
                        const unsigned &jproc,
                        std::list<Node*> &sorted_nodes,
                        const int &root_edge_bnd_id,
                        Vector<FiniteElement*> &bulk_bnd_ele_pt,
                        Vector<int> &face_index_ele,
                        Vector<Vector<TriangleMeshPolyLine *> > 
                        &unsorted_polylines_pt,
                        const int &connect_to_the_left_flag,
                        const int &connect_to_the_right_flag)
 {
  // ----------------------------------------------------------------
  // Associate the shared boundary with the respective processors
  // ----------------------------------------------------------------
  
  // Setup the global look-up scheme, where all processors know the
  // associations of others processors and the shared boundaries they
  // created
  
   // Set up the boundary shared by "iproc" with "jproc" processor
  Shared_boundaries_ids[iproc][jproc].push_back(shd_bnd_id);
  
  // Set up the boundary shared by "jproc" with "iproc" processor
  Shared_boundaries_ids[jproc][iproc].push_back(shd_bnd_id);
  
  // Specify the processors involved on the creation of the shared
  // boundary
  Vector<unsigned> processors(2);
  processors[0] = iproc;
  processors[1] = jproc;
  Shared_boundary_from_processors[shd_bnd_id] = processors;
  
  // ----------------------------------------------------------------
  // If one of the processor associated with the shared boundary is
  // the current processor then it needs to create a polyline from the
  // input sorted nodes, other processors can skip this part
  if (iproc == my_rank || jproc == my_rank)
   {
    // ------------------------------------------------------------
    // Create a vertices representation from the sorted nodes list
    // ------------------------------------------------------------
    
    // Get the number of nodes on the list
    const unsigned n_nodes = sorted_nodes.size();
    // The vector to store the vertices (assign space)
    Vector<Vector<double> > vertices(n_nodes);
    
    // Copy the vertices from the nodes
    unsigned counter = 0;
    
    for (std::list<Node*>::iterator it = sorted_nodes.begin(); 
         it != sorted_nodes.end(); it++)
     {
      vertices[counter].resize(2);
      vertices[counter][0] = (*it)->x(0);
      vertices[counter][1] = (*it)->x(1);
      counter++;
     }
    
    // ---------------------------------------------
    // Create the polyline from the input vertices
    // ---------------------------------------------
    TriangleMeshPolyLine *polyline_pt = 
     new TriangleMeshPolyLine(vertices, shd_bnd_id);
    
    // ---------------------------------------------
    // Establish the internal boundary information
    // ---------------------------------------------
    
    // Check if the shared boundary is overlapping (or is part) of an
    // internal boundary
    if (root_edge_bnd_id != -1)
     {
      // If the shared boundary is part of an internal boundary then
      // mark the shared boundary
      Shared_boundary_overlaps_internal_boundary[shd_bnd_id] = 
       static_cast<unsigned>(root_edge_bnd_id);
     } // if (root_edge_bnd_id != -1)
    
    // ---------------------------------------------
    // Store the boundary elements and face indexes
    // ---------------------------------------------
    
    // Store the shared boundary elements
    const unsigned n_shared_boundary_elements = bulk_bnd_ele_pt.size();
#ifdef PARANOID
    // Check that the number of shared boundy elements is the same as
    // the number of face indexes
    const unsigned n_face_index = face_index_ele.size();
    if (n_shared_boundary_elements != n_face_index)
     {
      std::ostringstream error_message;
      error_message
       << "The number of shared boundary elements is different from the\n"
       << "number of face indexes associated to the shared boundary\n"
       << "elements\n"
       << "Number of shared boundary elements: ("
       << n_shared_boundary_elements << ")\n"
       << "Number of face indexes: (" << n_face_index << ")\n\n";
      throw OomphLibError(error_message.str(),
                          "TriangleMesh::create_shared_polyline()",
                          OOMPH_EXCEPTION_LOCATION);
     } // if (n_shared_boundary_elements != n_face_index)
#endif
    
    // Add the shared boundary elements and their respective face
    // indexes to their permanent containers
    for (unsigned i = 0 ; i < n_shared_boundary_elements; i++)
     {
      add_shared_boundary_element(shd_bnd_id, bulk_bnd_ele_pt[i]);
      add_face_index_at_shared_boundary(shd_bnd_id, face_index_ele[i]);
     } // for (i < nshared_boundary_elements)
    
    // Store the shared boundary nodes
    for (std::list<Node*>::iterator it = sorted_nodes.begin();
         it != sorted_nodes.end(); it++)
     {
      add_shared_boundary_node(shd_bnd_id, (*it));
     } // for (it != sorted_nodes.end())
    
    // ----------------------------------------------------------
    // Create additional look-up schemes for the shared boundary
    // ----------------------------------------------------------
    
    // Updates bnd_id <---> curve section map
    this->Boundary_curve_section_pt[shd_bnd_id] = polyline_pt;
    
    // Check the size of the unsorted_polylines_pt structure. This
    // will have n_procs = 1 when it was called from the
    // create_new_shared_boundaries() methods
    const unsigned n_procs = unsorted_polylines_pt.size();
    if (n_procs > 1)
     {
      // Add the new created polyline to the list of unsorted
      // polylines
      unsorted_polylines_pt[iproc].push_back(polyline_pt);
      
      // ... do this on both processors involved in the creation of
      // the shared boundary
      unsorted_polylines_pt[jproc].push_back(polyline_pt);
     }
    else
     {
      // Add the new created polyline to the list of unsorted
      // polylines
      unsorted_polylines_pt[0].push_back(polyline_pt);
     }
      
    // Mark the polyline for deletion (when calling destructor)
    this->Free_curve_section_pt.insert(polyline_pt);
    
    // ----------------------------
    // Set connection information
    // ----------------------------
    
    // Check that the flags are correct, no connection or the boundary
    // id of the boundary to connect
#ifdef PARANOID
    // Is the shared polyline not connected to the left
    if (connect_to_the_left_flag < 0)
     {
      // If not connected then should be specified by -1
      if (connect_to_the_left_flag != -1)
       {
        std::ostringstream error_message;
        error_message
         << "The only accepted values for the connection flags are:\n"
         << "POSITIVE values or -1, any other value is rejected, please\n"
         << "check that you previously called the methods to deal with\n"
         << "other flag values\n"
         << "The current flag value for connection to the left is: ("
         << connect_to_the_left_flag<<")\n\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::create_shared_polyline()",
                            OOMPH_EXCEPTION_LOCATION);
       } // if (connect_to_the_left_flag != -1)
     } // if (connect_to_the_left_flag < 0)
    
    // Is the shared polyline not connected to the right
    if (connect_to_the_right_flag < 0)
     {
      // If not connected then should be specified by -1
      if (connect_to_the_right_flag != -1)
       {
        std::ostringstream error_message;
        error_message
         << "The only accepted values for the connection flags are:\n"
         << "POSITIVE values or -1, any other value is rejected, please\n"
         << "check that you previously called the methods to deal with\n"
         << "other flag values\n"
         << "The current flag value for connection to the right is: ("
         << connect_to_the_right_flag<<")\n\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::create_shared_polyline()",
                            OOMPH_EXCEPTION_LOCATION);
       } // if (connect_to_the_right_flag != -1)
     } // if (connect_to_the_right_flag < 0)
#endif
    
    // Set the connection to the left
    if (connect_to_the_left_flag != -1)
     {
      // Get the unsigned version of the boundary id to the left
      const unsigned bnd_id_connection_to_the_left = 
       static_cast<unsigned>(connect_to_the_left_flag);
      // Set the initial vertex as connected
      polyline_pt->set_initial_vertex_connected();
      // Set the initial vertex connected boundary id
      polyline_pt->initial_vertex_connected_bnd_id() = 
       bnd_id_connection_to_the_left;
      // Set the chunk number to zero
      polyline_pt->initial_vertex_connected_n_chunk() = 0;
      
     } // if (connect_to_the_left_flag != -1)
    
    // Set the connection to the right
    if (connect_to_the_right_flag != -1)
     {
      // Get the unsigned version of the boundary id to the right
      const unsigned bnd_id_connection_to_the_right = 
       static_cast<unsigned>(connect_to_the_right_flag);
      // Set the final vertex as connected
      polyline_pt->set_final_vertex_connected();
      // Set the final vertex connected boundary id
      polyline_pt->final_vertex_connected_bnd_id() = 
       bnd_id_connection_to_the_right;
      // Set the chunk number to zero
      polyline_pt->final_vertex_connected_n_chunk() = 0;
      
     } // if (connect_to_the_right_flag != -1)
    
   } // if (iproc == my_rank || jproc == my_rank)
  
 }
 
 //======================================================================
 /// \short Reset the boundary elements info. after load balance have
 /// taken place
 //======================================================================
 template <class ELEMENT>
 void TriangleMesh<ELEMENT>::
 reset_boundary_element_info(Vector<unsigned> &ntmp_boundary_elements,
                             Vector<Vector<unsigned> > 
                             &ntmp_boundary_elements_in_region,
                             Vector<FiniteElement*> &deleted_elements)
 {
  // Get the number of boundaries
  const unsigned nbound = this->nboundary();
  
  // Are there regions?
  const unsigned n_regions = this->nregion();
  
  // Loop over the boundaries
  for (unsigned b = 0; b < nbound; b++)
   {
    // Get the boundary elements and back them up
    // -----------------------------------------------------------------
    // Get the number of boundary elements (mixed with the old and new)
    const unsigned nbound_ele = this->nboundary_element(b);
    // Back-up the boundary elements
    Vector<FiniteElement*> backed_up_boundary_element_pt(nbound_ele);
    Vector<int> backed_up_face_index_at_boundary(nbound_ele);
    for (unsigned e = 0; e < nbound_ele; e++)
     {
      // Get the old boundary element
      backed_up_boundary_element_pt[e] = this->boundary_element_pt(b, e);
      // Get the old face index
      backed_up_face_index_at_boundary[e] = 
       this->face_index_at_boundary(b, e);
     } // for (n < nold_boundary_elements)
    
    // Back up the elements in boundary for each region
    Vector<Vector<FiniteElement*> > 
     backed_up_boundary_region_element_pt(n_regions);
    Vector<Vector<int> > backed_up_face_index_at_boundary_region(n_regions);
    
    // Loop over the regions and back up the boundary elements in
    // regions
    for (unsigned ir = 0; ir < n_regions; ir++)
     {
      // Get the region id
      const unsigned region_id = 
       static_cast<unsigned>(this->region_attribute(ir));
      // Get the number of boundary region elements (mixed old and new)
      const unsigned nbnd_region_ele = 
       this->nboundary_element_in_region(b, region_id);
      
      // Loop over the elements in the region
      for (unsigned e = 0; e < nbnd_region_ele; e++)
       {
        // Get the old boundary region element
        backed_up_boundary_region_element_pt[ir][e] = 
         this->boundary_element_in_region_pt(b, region_id, e);
        
        // Get the old face index
        backed_up_face_index_at_boundary_region[ir][e] = 
         this->face_index_at_boundary_in_region(b, region_id, e);
       } // for (e < nbnd_region_ele)
      
     } // for (ir < n_regions)
    
    // Clean all previous storages
    this->Boundary_element_pt[b].clear();
    this->Face_index_at_boundary[b].clear();
    if (n_regions > 0)
     {
      this->Boundary_region_element_pt[b].clear();
      this->Face_index_region_at_boundary[b].clear();
     }
    
    // -------------------------------------------------------------------
    // Now copy only the elements that are still alive, from those before
    // the re-establishment of halo and haloed elements
    // -------------------------------------------------------------------
    // Start with the boundary elements
    // Get the old number of boundary elements
    const unsigned nold_bnd_ele = ntmp_boundary_elements[b];
    // Loop over the boundary elements and check those still alive
    for (unsigned e = 0; e < nold_bnd_ele; e++)
     {
      FiniteElement* tmp_ele_pt = backed_up_boundary_element_pt[e];
      // Include only those elements still alive
      Vector<FiniteElement*>::iterator it = 
       std::find(deleted_elements.begin(),
                 deleted_elements.end(),
                 tmp_ele_pt);
      // Only copy thoes elements not found on the deleted elements
      // container
      if (it == deleted_elements.end())
       {
        FiniteElement* add_ele_pt = backed_up_boundary_element_pt[e];
        this->Boundary_element_pt[b].push_back(add_ele_pt);
        const int face_index = backed_up_face_index_at_boundary[e];
        this->Face_index_at_boundary[b].push_back(face_index);
       } // if (tmp_ele_pt != 0)
      
     } // for (n < nold_bnd_ele)
    
    // ... continue with the boundary elements in specific regions
    
    // Loop over the regions
    for (unsigned ir = 0; ir < n_regions; ir++)
     {
      // Get the region id
      const unsigned region_id = 
       static_cast<unsigned>(this->region_attribute(ir));
      
      // Get the old number of boundary elements in region
      const unsigned nold_bnd_region_ele = 
       ntmp_boundary_elements_in_region[b][ir];
      
      // Loop over the boundary region elements and check those still
      // alive
      for (unsigned e = 0; e < nold_bnd_region_ele; e++)
       {
        // Get the element
        FiniteElement* tmp_ele_pt = 
         backed_up_boundary_region_element_pt[ir][e];
        // Include only those elements still alive
        Vector<FiniteElement*>::iterator it = 
         std::find(deleted_elements.begin(),
                   deleted_elements.end(),
                   tmp_ele_pt);
        // Only copy those elements not found on the deleted elements
        // container
        if (it == deleted_elements.end())
         {
          FiniteElement* add_ele_pt = 
           backed_up_boundary_region_element_pt[ir][e];
          this->Boundary_region_element_pt[b][region_id].push_back(add_ele_pt);
          const int face_index = backed_up_face_index_at_boundary_region[ir][e];
          this->Face_index_region_at_boundary[b][region_id].
           push_back(face_index);
         } // if (tmp_ele_pt != 0)
        
       } // for (n < nbound_ele)
      
     } // for (ir < n_regions)
    
    // ----------------------------------------------------------------
    // Now copy all those elements created after the re-establishment
    // of halo and haloed elements
    // ----------------------------------------------------------------
    // Loop over the boundary elements
    for (unsigned e = nold_bnd_ele; e < nbound_ele; e++)
     {
      FiniteElement* add_ele_pt = backed_up_boundary_element_pt[e];
      this->Boundary_element_pt[b].push_back(add_ele_pt);
      const int face_index = backed_up_face_index_at_boundary[e];
      this->Face_index_at_boundary[b].push_back(face_index);
     } // for (e < nbound_ele)
    
    // Now add the boundary elements in regions
    
    // Loop over the regions
    for (unsigned ir = 0; ir < n_regions; ir++)
     {
      // Get the region id
      const unsigned region_id = 
       static_cast<unsigned>(this->region_attribute(ir));
      
      // Get the old number of boundary elements in region
      const unsigned nold_bnd_region_ele = 
       ntmp_boundary_elements_in_region[b][ir];
      
      // Get the new number of boundary elements in region
      const unsigned nbnd_region_ele = 
       this->nboundary_element_in_region(b, region_id);
      
      // Loop over the boundary region elements and check those still
      // alive
      for (unsigned e = nold_bnd_region_ele; e < nbnd_region_ele; e++)
       {
        FiniteElement* add_ele_pt = backed_up_boundary_region_element_pt[ir][e];
        this->Boundary_region_element_pt[b][region_id].push_back(add_ele_pt);
        const int face_index = backed_up_face_index_at_boundary_region[ir][e];
        this->Face_index_region_at_boundary[b][region_id].push_back(face_index);
       } // for (e < nbnd_region_ele)
      
     } // for (ir < n_regions)
      
   } // for (b < nbound)
    
  // Lookup scheme has now been setup yet
  Lookup_for_elements_next_boundary_is_setup=true;
  
 }

#endif // OOMPH_HAS_MPI

#ifdef OOMPH_HAS_TRIANGLE_LIB

//========================================================================
/// Build a new TriangulateIO object based on target areas specified
//========================================================================
template <class ELEMENT>
void RefineableTriangleMesh<ELEMENT>::refine_triangulateio(
  TriangulateIO& triangulate_io,
  const Vector<double>& target_area,
  struct TriangulateIO& triangle_refine)
 {

  //  Initialize
  TriangleHelper::initialise_triangulateio(triangle_refine);

  // Store the global number of vertices and segments
  // in the list
  unsigned n_points = triangulate_io.numberofpoints;
  triangle_refine.numberofpoints=n_points;

  unsigned n_segments=triangulate_io.numberofsegments;
  triangle_refine.numberofsegments=n_segments;

  // Initialization of the TriangulateIO objects to store the values
  triangle_refine.pointlist =
  (double *) malloc(triangulate_io.numberofpoints * 2 * sizeof(double));
  triangle_refine.pointmarkerlist =
  (int *) malloc(triangulate_io.numberofpoints * sizeof(int));
  triangle_refine.segmentlist =
  (int *) malloc(triangulate_io.numberofsegments * 2 * sizeof(int));
  triangle_refine.segmentmarkerlist =
  (int *) malloc(triangulate_io.numberofsegments * sizeof(int));

  // Storing the point's coordinates in the list
  // and in two vectors with x and y coordinates
  Vector<double> x_coord (n_points);
  Vector<double> y_coord (n_points);

  for(unsigned count_point=0;count_point<n_points*2;count_point++)
   {
    triangle_refine.pointlist[count_point]=
    triangulate_io.pointlist[count_point];

    // Even vaules represent the x coordinate
    // Odd values represent the y coordinate
    if (count_point%2==0)
     {
      x_coord[count_point/2] = triangulate_io.pointlist[count_point];
     }
    else
     {
      y_coord[(count_point-1)/2] = triangulate_io.pointlist[count_point];
     }
   }

  // Store the point's markers in the list
  for(unsigned count_marker=0;count_marker<n_points;count_marker++)
   {
    triangle_refine.pointmarkerlist[count_marker]=
    triangulate_io.pointmarkerlist[count_marker];
   }

  // Storing the segment's edges in the list
  for(unsigned count_seg=0;count_seg<n_segments*2;count_seg++)
   {
    triangle_refine.segmentlist[count_seg]=
    triangulate_io.segmentlist[count_seg];
   }

  // Store the segment's markers in the list
  for(unsigned count_markers=0;count_markers<n_segments;count_markers++)
   {
    triangle_refine.segmentmarkerlist[count_markers]=
    triangulate_io.segmentmarkerlist[count_markers];
   }

  // Store the hole's center coordinates
  unsigned n_holes = triangulate_io.numberofholes;
  triangle_refine.numberofholes = n_holes;

  triangle_refine.holelist =
  (double*) malloc(triangulate_io.numberofholes * 2 * sizeof(double));

  // Loop over the holes to get centre coords
  for(unsigned count_hole=0;count_hole<n_holes*2;count_hole++)
   {
    triangle_refine.holelist[count_hole] = triangulate_io.holelist[count_hole];
   }

  // Store the triangles values
  unsigned n_triangles = triangulate_io.numberoftriangles;
  triangle_refine.numberoftriangles = n_triangles;

#ifdef PARANOID
  if (n_triangles!=target_area.size())
   {
    std::stringstream err;
    err << "Number of triangles in triangulate_io="
    << n_triangles << " doesn't match\n"
    << "size of target area vector ("
    << target_area.size() << ")\n";
    throw OomphLibError(
      err.str(),
      OOMPH_CURRENT_FUNCTION,
      OOMPH_EXCEPTION_LOCATION);
   }
#endif

  unsigned n_corners = triangulate_io.numberofcorners;
  triangle_refine.numberofcorners = n_corners;

  triangle_refine.trianglelist =
  (int *) malloc(triangulate_io.numberoftriangles * 3 * sizeof(int));

  // Store the triangle's corners in the list and get element sizes
  for(unsigned count_tri=0;count_tri<n_triangles*3;count_tri++)
   {
    triangle_refine.trianglelist[count_tri]=
    triangulate_io.trianglelist[count_tri];
   }

  // Store the triangle's area in the list
  triangle_refine.trianglearealist =
  (double *) malloc(triangulate_io.numberoftriangles * sizeof(double));
  for(unsigned count_area=0;count_area<n_triangles;count_area++)
   {
    triangle_refine.trianglearealist[count_area]=target_area[count_area];
   }

  // Store the triangles attributes in the list
  triangle_refine.numberoftriangleattributes =
  triangulate_io.numberoftriangleattributes;

  triangle_refine.triangleattributelist =
  (double *) malloc(
    triangulate_io.numberoftriangles *
    triangulate_io.numberoftriangleattributes * sizeof(double));
  for(unsigned count_attribute=0;
    count_attribute<(n_triangles*triangulate_io.numberoftriangleattributes);
    count_attribute++)
   {
    triangle_refine.triangleattributelist[count_attribute] =
    triangulate_io.triangleattributelist[count_attribute];
   }

 }

#ifdef OOMPH_HAS_MPI
  
 // ===================================================================
 // The comparison class for the map that sorts the nodes on the
 // shared boundary (using a lexicographic order)
 // ===================================================================
 struct classcomp
 {

  // Tolerance for lower-left comparison
  static double Tol;


  // Comparison operator for "lower left" ordering
  bool operator() (const std::pair<double, double> &lhs, 
                   const std::pair<double, double> &rhs) const
   {
    double diff_y=lhs.second-rhs.second;
    if (diff_y<-Tol)    // (lhs.second < rhs.second)
     {
      return true;
     }
    else 
     {
      // Are they "equal" with 1.0e-14 tolerance?
      if (diff_y<Tol) // (lhs.second == rhs.second)
       {
#ifdef PARANOID
        double diff_x=lhs.first-rhs.first;
        if (fabs(diff_x)<Tol)
         { 
          std::ostringstream warning_message;
          warning_message
           << "Dodgy \"lower left\" (lexicographic) comparison "
           << "of points with cooordinates: "
           << " lhs = ( " << lhs.first << " , " << lhs.second << " ) \n"
           << " rhs = ( " << rhs.first << " , " << rhs.second << " ) \n"
           << "x and y coordinates differ by less than tolerance!\n"
           << "diff_x = " << diff_x << "\n"
           << "diff_y = " << diff_y << "\n"
           << "Tol    = " << Tol << "\n";
           OomphLibError(warning_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
         }
#endif
        if (lhs.first < rhs.first)
         {
          return true;
         }
        else
         {
          return false;
         }
       }
      else
       {
        return false;
       }
     }
    
    
   
    // if (lhs.second < rhs.second)
    //  {
    //   return true;
    //  }
    // else 
    //  {
    //   // // Are "equal" with 1.0e-14 tolerance
    //   // if (lhs.second - rhs.second < 1.0e-14)
    //   // Are equal?
    //   if (lhs.second == rhs.second)
    //    {
    //     if (lhs.first < rhs.first)
    //      {
    //       return true;
    //      }
    //     else
    //      {
    //       return false;
    //      }
    //    }
    //   else
    //    {
    //     return false;
    //    }
    //  }
    
    
   }
  
 } Bottom_left_sorter; // struct classcomp
 

 // Assign value for tolerance
 double classcomp::Tol=1.0e-14;


 //======================================================================
 // Sort the nodes on shared boundaries so that the processors that share
 // a boundary agree with the order of the nodes on the boundary
 //======================================================================
 template <class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::sort_nodes_on_shared_boundaries()
 {
  // Get the shared boundaries in this processor
  Vector<unsigned> my_rank_shared_boundaries_ids;
  this->shared_boundaries_in_this_processor(my_rank_shared_boundaries_ids);
  
  // Get the number of shared boundaries
  const unsigned nmy_rank_shd_bnd = my_rank_shared_boundaries_ids.size();

  // Loop over the shared boundaries
  for (unsigned i = 0; i < nmy_rank_shd_bnd; i++)
   {
    // A map is used to sort the nodes using their coordinates as the key
    // of the map
    //std::map<std::pair<double, double>, Node*> sorted_nodes_pt;
    std::map<std::pair<double, double>, Node*, classcomp> sorted_nodes_pt;
    

#ifdef PARANOID

    // Check min distance between nodes; had better be less than the
    // tolerance used for the bottom left sorting
    double min_distance_squared=DBL_MAX;

#endif

    // Get the boundary id
    const unsigned b = my_rank_shared_boundaries_ids[i];
    
    // Get the number of nodes on the current boundary
    const unsigned nbnd_node = this->nshared_boundary_node(b);
    
    // Go through all the nodes on the boundary and temporarily store
    // them on the map container
    for (unsigned i_node = 0; i_node < nbnd_node; i_node++)
     {
      Node* node_pt = this->shared_boundary_node_pt(b, i_node);
      std::pair<double, double> vertex = std::make_pair(node_pt->x(0),
                                                          node_pt->x(1));
      sorted_nodes_pt[vertex] = node_pt;



#ifdef PARANOID

      // Check for minimum distance
      for (unsigned j_node = 0; j_node < nbnd_node; j_node++)
       {
        if (i_node!=j_node)
         {
          Node* node2_pt = this->shared_boundary_node_pt(b, j_node);
          
          // Squared distance
          double squared_distance=0.0;
          for (unsigned ii=0;ii<2;ii++)
           {
            squared_distance+=
             (node_pt->x(ii)-node2_pt->x(ii))*
             (node_pt->x(ii)-node2_pt->x(ii));
           }
          if (squared_distance<min_distance_squared)
           {
            min_distance_squared=squared_distance;
           }
         }
       }
      
      if (sqrt(min_distance_squared)<Bottom_left_sorter.Tol)
       {        
        std::ostringstream warning_message;
        warning_message
         << "Minimum distance between nodes on boundary " << b << "\n"
         << "is " << sqrt(min_distance_squared) << " which is less than "
         << "Bottom_left_sorter.Tol = " << Bottom_left_sorter.Tol << "\n"
         << "This may screw up the ordering of the nodes on shared boundaries\n";
        OomphLibWarning(warning_message.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
       }
     
#endif

     }
    
    unsigned counter = 0;
    // Resize the sorted shared boundary node vector
    this->Sorted_shared_boundary_node_pt[b].resize(nbnd_node);
    
    // Now go through the map container, get the elements and store their
    // members on the Sorted_shared_boundary_node_pt container
    // The map has already sorted the nodes, now they keep the same sorting
    // on all processors
    for (std::map<std::pair<double, double>, Node*>::iterator it_map
          = sorted_nodes_pt.begin(); it_map != sorted_nodes_pt.end(); it_map++)
     {
      // Store the pointer to the node
      this->Sorted_shared_boundary_node_pt[b][counter++] = (*it_map).second;
     }

   } // for (i < nmy_rank_shd_bnd)
  
 }

 //========================================================================
 // Re-establish the shared boundary elements after the adaptation
 // process (the updating of shared nodes is optional and performed by
 // default)
 //========================================================================
 template <class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 reset_shared_boundary_elements_and_nodes(const bool flush_elements,
                                          const bool update_elements,
                                          const bool flush_nodes,
                                          const bool update_nodes)
 {  
  // Get the rank of the current processor
  const unsigned my_rank = this->communicator_pt()->my_rank();
  
  // Go through the boundaries know as shared boundaries and copy the
  // elements to the corresponding storage
  
  // Get the initial shared boundary id
  const unsigned initial_id = this->initial_shared_boundary_id();
  
  // Get the final shared boundary id
  const unsigned final_id = this->final_shared_boundary_id();
  
  if (flush_elements)
   {
    // Flush the shared boundaries storage for elements
    this->flush_shared_boundary_element();
    // .. and also flush the face indexes associated with the element
    this->flush_face_index_at_shared_boundary();
   } // if (flush_elements)
  
  if (flush_nodes)
   {
    // Flush the shared boundaries storage for nodes
    this->flush_shared_boundary_node();
   } // if (flush_nodes)
  
  for (unsigned b = initial_id; b < final_id; b++)
   {
    // Check if the boundary is on the current processor
    Vector<unsigned> procs_from_shrd_bnd;
    procs_from_shrd_bnd = this->shared_boundary_from_processors(b);
    bool current_processor_has_b_boundary = false;
    const unsigned n_procs_from_shrd_bnd = procs_from_shrd_bnd.size();
    for (unsigned p = 0; p < n_procs_from_shrd_bnd; p++)
     {
      if (procs_from_shrd_bnd[p] == my_rank)
       {
        current_processor_has_b_boundary = true;
        break; // break for (p < n_procs_from_shrd_bnd)
       }
     } // for (p < n_procs_from_shrd_bnd)
    
    if (current_processor_has_b_boundary)
     {
      if (update_elements)
       {
        const unsigned nboundary_ele = this->nboundary_element(b);
        for (unsigned e = 0; e < nboundary_ele; e++)
         {
          // Get the boundary element and add it to the shared
          // boundary elements structure
          FiniteElement* bnd_ele_pt = this->boundary_element_pt(b, e);
          this->add_shared_boundary_element(b, bnd_ele_pt);
          // ... do the same with the face index information
          int face_index = this->face_index_at_boundary(b, e);
          this->add_face_index_at_shared_boundary(b, face_index);
         } // for (e < nboundary_element)
       } // if (update_elements)
      
      if (update_nodes)
       {


        const unsigned nboundary_node = this->nboundary_node(b);
        for (unsigned n = 0; n < nboundary_node; n++)
         {
          Node* bnd_node_pt = this->boundary_node_pt(b, n);
          this->add_shared_boundary_node(b, bnd_node_pt);
         } // for (n < nboundary_node)
       } // if (update_nodes)
      
     } // if (current_processor_has_b_boundary)
   } // for (b < final_id)
  
 }
 
 //======================================================================
 // Sort the nodes on shared boundaries so that the processors that share
 // a boundary agree with the order of the nodes on the boundary
 //======================================================================
 template <class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::reset_halo_haloed_scheme()
 {
  // Get the number of processors
  unsigned nproc = this->communicator_pt()->nproc();
  // Get the rank of the current processor
  unsigned my_rank = this->communicator_pt()->my_rank();
  
  // Get some timings
  double tt_start = 0.0;
  double tt_end=0.0;
  if (Global_timings::Doc_comprehensive_timings)
    {
      tt_start=TimingHelpers::timer();
    }
  
  // -------------------------------------------------------------------
  // BEGIN: Get the node names and the shared nodes
  // -------------------------------------------------------------------
  
  // Container where to store the nodes on shared boundaries no
  // associated with the processor that receives the elements/nodes
  // other_proc_shd_bnd_node_pt[iproc][jproc][shd_bnd_id][index]
  Vector<Vector<Vector<std::map<unsigned, Node*> > > >
   other_proc_shd_bnd_node_pt(nproc);
  // Resize the container
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // Resize the container
    other_proc_shd_bnd_node_pt[iproc].resize(nproc);
    for (unsigned jproc = 0; jproc < nproc; jproc++)
     {
      // Get the number of shared boundaries
      const unsigned initial_shd_bnd_id = this->initial_shared_boundary_id();
      const unsigned final_shd_bnd_id = this->final_shared_boundary_id();
      const unsigned nshared_bound = final_shd_bnd_id - initial_shd_bnd_id;
      other_proc_shd_bnd_node_pt[iproc][jproc].resize(nshared_bound);
     } // for (jproc < nproc)
    
   } // for (iproc < nproc)
  
  // Store the global node names
  // global_node_name[x][ ][ ] Global node number
  // global_node_name[ ][x][ ] Global node names
  // global_node_name[ ][ ][x] Global node info.
  Vector<Vector<Vector<unsigned> > > global_node_names;
  
  // Creates a map between the node name and the index of the global
  // node so we can access all its node names
  std::map<Vector<unsigned>, unsigned> node_name_to_global_index;
  
  // Store the global shared nodes pointers
  Vector<Node*> global_shared_node_pt;
  
  // Get the time for computation of global nodes names and shared
  // nodes
  double t_start_global_node_names_and_shared_nodes = 
    TimingHelpers::timer();
  
  // Compute all the names of the nodes and fill in the
  // "other_proc_shd_bnd_node_pt" structure with the nodes that live
  // on this processor (my_rank) by looking over all their names
  compute_global_node_names_and_shared_nodes(other_proc_shd_bnd_node_pt, 
                                             global_node_names,
                                             node_name_to_global_index,
                                             global_shared_node_pt);
  
  // Compute the number of elements before adding new ones
  const unsigned n_ele = this->nelement();
  
  if (Print_timings_level_adaptation>1)
    {
      // The total time for computation of global nodes names and
      // shared nodes
      double t_final_global_node_names_and_shared_nodes = 
        TimingHelpers::timer() - t_start_global_node_names_and_shared_nodes;
      oomph_info << "CPU for computing global node names and shared nodes "
                 << "[n_ele="<< n_ele << "]: " 
                 << t_final_global_node_names_and_shared_nodes << std::endl;
    }
  
  // -------------------------------------------------------------------
  // END: Get the node names and the shared nodes
  // -------------------------------------------------------------------
  
  // -------------------------------------------------------------------
  // BEGIN: Using the global node names each processor sends info. of
  // the nodes shared with other processors regarding whether they are
  // on an original boundary or not. This is required so that at the
  // re-generation of halo(ed) elements stage they have the updated
  // information
  // -------------------------------------------------------------------
  
  // Get the time for sending info. of shared nodes on original
  // boundaries
  double t_start_send_info_shd_nodes_on_original_bnds = 
    TimingHelpers::timer();

  // Send the boundary node info. of nodes on shared boundaries across
  // processors
  send_boundary_node_info_of_shared_nodes(global_node_names,
                                          node_name_to_global_index,
                                          global_shared_node_pt);
  
  if (Print_timings_level_adaptation>1)
   {
    // The total time for sending info. of shared nodes lying on
    // original boundaries
    oomph_info
      <<"CPU for sending info. of shared nodes on original boundaries: "
      <<TimingHelpers::timer()-t_start_send_info_shd_nodes_on_original_bnds
      <<std::endl;
   }
  
  // -------------------------------------------------------------------
  // END: Using the global node names each processor sends info. of
  // the nodes shared with other processors regarding whether they are
  // on an original boundary or not. This is required so that at the
  // re-generation of halo(ed) elements stage they have the updated
  // information
  // -------------------------------------------------------------------
  
  // -------------------------------------------------------------------
  // BEGIN: Identify the elements of the mesh that have nodes on the
  // shared boundaries
  // -------------------------------------------------------------------
  
  // Store the elements that have a node on a shared boundary with
  // other processors
  // ele_with_node_on_shd_bnd_pt[x][ ][ ]: iproc
  // ele_with_node_on_shd_bnd_pt[ ][x][ ]: ishd boundary with iproc
  // ele_with_node_on_shd_bnd_pt[ ][ ][x]: element with node on shared
  //                                       boundary with iproc
  Vector<Vector<Vector<FiniteElement*> > > ele_with_node_on_shd_bnd_pt(nproc);
  // Resize the container with the number of shared boundaries within
  // each processor
  
  // loop over the processors
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    const unsigned n_shd_bnd_iproc = this->nshared_boundaries(my_rank, iproc);
    ele_with_node_on_shd_bnd_pt[iproc].resize(n_shd_bnd_iproc);    
   } // for (iproc < nproc)
  
  // Go through all the elements and check whether any of their nodes
  // lies on any of the shared boundaries
  
  // loop over the elements
  for (unsigned e = 0; e < n_ele; e++)
   {
    // Get the element
    FiniteElement* ele_pt = this->finite_element_pt(e);
    // Get the number of nodes
    const unsigned n_nodes = ele_pt->nnode();
    // loop over the nodes and check whether any of them lies on a
    // shared boundary
    for (unsigned n = 0; n < n_nodes; n++)
     {
      // Get the node
      Node* node_pt = ele_pt->node_pt(n);
      
      // Now check whether the current node lies on a shared boundary
      // within any other processor
      
      // loop over the processors
      for (unsigned iproc = 0; iproc < nproc; iproc++)
       {
        // The number of boundaries shared with the current processor
        // (if iproc==my_rank then there are no shared boundaries
        // between them)
        const unsigned n_shd_bnd_iproc =
         this->nshared_boundaries(my_rank, iproc);
        
        // There are no info. with myself
        if (iproc != my_rank && n_shd_bnd_iproc > 0)
         {
          // Get the boundaries ids of the shared boundaries with
          // iproc processor
          Vector<unsigned> shd_bnd_ids = 
           this->shared_boundaries_ids(my_rank, iproc);
          
          // Loop over shd bnds with processor "iproc"
          for (unsigned isb = 0; isb < n_shd_bnd_iproc; isb++)
           {
            const unsigned shd_bnd_id = shd_bnd_ids[isb];
            const unsigned n_ele_shd_bnd = 
             this->nshared_boundary_element(shd_bnd_id);
            
            // Check if the node is on this boundary only if there are
            // elements on it
            if (n_ele_shd_bnd > 0 && 
              this->is_node_on_shared_boundary(shd_bnd_id, node_pt))
             {
              // Add the element into those that have a
              // node on the current shared boundary
              ele_with_node_on_shd_bnd_pt[iproc][isb].push_back(ele_pt);
              
             } // Are there elements on the boundary and the node lies
               // on this boundary
            
           } // for (isb < n_shd_bnd_iproc)
          
         } // if (iproc != my_rank && n_shd_bnd_iproc > 0)
        
       } // for (iproc < nproc)
      
     } // for (n < n_nodes)
    
   } // for (e < n_ele)
  
  // -------------------------------------------------------------------
  // END: Identify the elements of the mesh that have nodes on the
  // shared boundaries
  // -------------------------------------------------------------------
            
  // -------------------------------------------------------------------
  // BEGIN: Create the halo(ed) elements. Loop over the processors and
  // the shared boundaries within each processor. Get the elements on
  // the shared boundaries, mark them as haloed in this processor and
  // as halo on the element that will receive the info.
  // -------------------------------------------------------------------
  
  // ********************************************************************
  // General strategy:
  // 1) Go through all the elements on the shared boundaries, mark these
  //    elements as haloed, same as their nodes.
  // 2) Package the info. of the nodes and the elements.
  // 3) Send and receive the info across processors
  // 4) Unpackage it and create halo elements and nodes as indicated by
  // the received info.
  // ********************************************************************
  
  // Keep track of the currently created nodes within each
  // processor. We need to keep track of these nodes so they can be
  // referred at a second stage.
  Vector<Vector<Node*> > iproc_currently_created_nodes_pt(nproc);
  
  // Get the time to re-generate halo(ed) elements/nodes (first stage)
  double t_start_regenerate_halo_ed_elements_nodes_first_stage = 
    TimingHelpers::timer();
  
  // Go through all processors
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // Send and receive info. to/from other processors
    if (iproc != my_rank)
     {
      // Get the number of boundaries shared with the send proc (iproc)
      const unsigned nshared_boundaries_with_iproc = 
       this->nshared_boundaries(my_rank, iproc);
      
      if (nshared_boundaries_with_iproc > 0)
       {
        // ******************************************************************
        // Stage 1
        // ******************************************************************
        // Step (1) Mark the elements adjacent to the shared boundaries as
        //          haloed, mark the nodes on these elements as haloed nodes
        // Step (2) Create packages of information indicating the generation
        //          of halo elements and nodes
        // ******************************************************************
        
        // Clean send and receive buffers
        Flat_packed_unsigneds.clear();
        Flat_packed_doubles.clear();
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        Flat_packed_unsigneds_string.clear();
#endif
        
        // Get the boundaries ids shared with "iproc"
        Vector<unsigned> bound_shared_with_iproc;
        bound_shared_with_iproc = this->shared_boundaries_ids(my_rank, iproc);
	
        // Loop over shared boundaries with processor "iproc"
        for (unsigned bs = 0; bs < nshared_boundaries_with_iproc; bs++)
         {
          const unsigned bnd_id = bound_shared_with_iproc[bs];
//          DEBP(bnd_id);
          const unsigned nel_bnd = this->nshared_boundary_element(bnd_id);
//          DEBP(nel_bnd);
          
          // Container to store the elements marked as haloed
          Vector<FiniteElement*> haloed_element;
          
          // All the elements adjacent to the boundary should be
          // marked as haloed elements
          if (nel_bnd > 0)
           {
            // Map to know which element have been already added
            std::map<FiniteElement*,bool> already_added;
            
            // Loop over the elements adjacent to boundary "bnd_id"
            for (unsigned e = 0; e < nel_bnd; e++)
             {
              // Get pointer to the element adjacent to boundary bnd_id
              FiniteElement* ele_pt = 
               this->shared_boundary_element_pt(bnd_id, e);
              
              // Check if the element has been already added. Elemets
              // are repeated if they have two faces on the shared
              // boundary
              if (!already_added[ele_pt])
               {
                // Add the element to the container of haloed elements
                haloed_element.push_back(ele_pt);
                // Mark the element as already added
                already_added[ele_pt] = true;
               }
              
             } // for (e < nel_bnd)
            
            // In addition to the elements on the boundary we also
            // need to mark (as haloed) any element on the mesh with a
            // node on the shared boundary
            
            // Get the number of elements with a node on the current
            // shared boundary
            const unsigned n_ele_with_node_on_shd_bnd = 
             ele_with_node_on_shd_bnd_pt[iproc][bs].size();
            // loop and add the elements that have a node on the
            // current shared boundary with the current processor
            for (unsigned iele = 0; iele < n_ele_with_node_on_shd_bnd; iele++)
             {
              // Get the element
              FiniteElement* ele_pt = 
               ele_with_node_on_shd_bnd_pt[iproc][bs][iele];
              // Check if it has not been already added
              if (!already_added[ele_pt])
               {
                // Add it!!
                haloed_element.push_back(ele_pt);
                // Mark it as done
                already_added[ele_pt] = true;
               } // if (!already_added[ele_pt])
              
             } // for (iele < n_ele_with_node_on_shd_bnd)
            
           } // if (nel_bnd > 0)
          
          // Get the total number of haloed elements
          const unsigned nhaloed_ele = haloed_element.size();
          // DEBP(nhaloed_ele);
          // DEBP(my_rank);
          // DEBP(iproc);
          // The very first data of the flat packed is the number of haloed
          // elements, this will be the number of halo element to create on
          // the receiver processor
          Flat_packed_unsigneds.push_back(nhaloed_ele);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
          std::stringstream junk;
          junk << "Number of haloed elements " << nhaloed_ele;
          Flat_packed_unsigneds_string.push_back(junk.str());
#endif
          
          // Loop over the marked haloed elements
          for (unsigned e = 0; e < nhaloed_ele; e++)
           {
            // Get pointer to the marked haloed element
            FiniteElement* ele_pt = haloed_element[e];
            const unsigned nroot_haloed_ele = 
             this->nroot_haloed_element(iproc);
            
            // Check if the element has been already added to the
            // halo(ed) scheme
            GeneralisedElement *gen_ele_pt = ele_pt;
            const unsigned haloed_ele_index =
             this->try_to_add_root_haloed_element_pt(iproc, gen_ele_pt);
            
            // Was the element added or only returned the index of the
            // element
            if (nroot_haloed_ele == haloed_ele_index)
             {
              Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
              Flat_packed_unsigneds_string.push_back("Haloed element needs to be constructed");
#endif
              
              // Get additional info. related with the haloed element
              get_required_elemental_information_helper(iproc, ele_pt);
              
              // Get the nodes on the element
              const unsigned nnodes = ele_pt->nnode();
              for (unsigned j = 0; j < nnodes; j++)
               {
                Node* node_pt = ele_pt->node_pt(j);
                
                // Package the info. of the nodes
                // The destination processor goes in the arguments
                add_haloed_node_helper(iproc, node_pt);
                
               } // for (j < nnodes)
             } // add the element and send its nodes
            else // The haloed element already exists
             {
              Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
              Flat_packed_unsigneds_string.push_back("Haloed element already exists");
#endif
              Flat_packed_unsigneds.push_back(haloed_ele_index);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
              Flat_packed_unsigneds_string.push_back("Index of existing haloed element");
#endif
             } // else (next_haloed_ele == external_haloed_ele_index)
           } // for (e < nel_bnd)
          
         } // for (bs < nshared_boundaries_with_iproc)
        
        // *******************************************************************
        // Stage (2) 
        // *******************************************************************
        // Step (1) Send and receive the data to create halo elements and
        //          nodes
        // *******************************************************************
        // The processor to which send the elements
        int send_proc = static_cast<int>(iproc);
        // The processor from which receive the elements
        int recv_proc = static_cast<int>(iproc);
        send_and_receive_elements_nodes_info(send_proc, recv_proc);
        
        // *******************************************************************
        // Stage (3)
        // *******************************************************************
        // Step (1) Unpackage the info and create the halo elements and nodes
        // *******************************************************************
        
        // Reset the counters
        Counter_for_flat_packed_doubles=0;
        Counter_for_flat_packed_unsigneds=0;
        
        // Loop over shared boundaries with processor "iproc"
        for (unsigned bs = 0; bs < nshared_boundaries_with_iproc; bs++)
         {
          // Get the number of halo element to be created
          const unsigned nhaloed_ele = 
           Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
          
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
          oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                     << " Number of elements need to be constructed " 
                     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                     << std::endl;
#endif
          
          // Loop over boundaries shared with processor "urecv_proc"
          for (unsigned e = 0; e < nhaloed_ele; e++)
            {
              // Create halo element from received info. of "iproc"
              // processor on the current processor
              create_halo_element(iproc,
                                  iproc_currently_created_nodes_pt[iproc],
                                  other_proc_shd_bnd_node_pt,
                                  global_node_names,
                                  node_name_to_global_index,
                                  global_shared_node_pt);
              
            } // for (e < nhaloed_ele)
          
         } // for (bs < nshared_boundaries_with_iproc)
        
       } // if (nshared_bound_recv_proc > 0)
      
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc) (general loop to send and receive info.)
  
  if (Print_timings_level_adaptation>1)
   {
    // Get the time to re-generate halo(ed) elements/nodes (first stage)
    double t_final_regenerate_halo_ed_elements_nodes_first_stage = 
     TimingHelpers::timer() - t_start_regenerate_halo_ed_elements_nodes_first_stage;
    
    oomph_info << "CPU for re-generating halo(ed) elements/nodes "
               << "(first stage) [n_ele="<< n_ele << "]: " 
               << t_final_regenerate_halo_ed_elements_nodes_first_stage
               << std::endl;
   }
  
  // -------------------------------------------------------------------
  // END: Create the halo(ed) elements. Loop over the processors and
  // the shared boundaries within each processor. Get the elements on
  // the shared boundaries, mark them as haloed in this processor and
  // as halo on the element that will receive the info.
  // -------------------------------------------------------------------
  
  // -------------------------------------------------------------------
  // BEGIN: Create any additional haloed element, those that dont lie
  // on a shared boundary but that shared a node with other processor
  // -------------------------------------------------------------------
  
  // Get the time to re-generate halo(ed) elements/nodes (second stage)
  double t_start_regenerate_halo_ed_elements_nodes_second_stage = 
   TimingHelpers::timer();
  
  // Create any additional halo(ed) elements between processors that
  // have no shared boundaries but that have shared nodes
  reset_halo_haloed_scheme_helper(other_proc_shd_bnd_node_pt,
                                  iproc_currently_created_nodes_pt,
                                  global_node_names,
                                  node_name_to_global_index,
                                  global_shared_node_pt);
  
  if (Print_timings_level_adaptation>1)
   {
    // Get the time to re-generate halo(ed) elements/nodes (second stage)
    double t_final_regenerate_halo_ed_elements_nodes_second_stage = 
     TimingHelpers::timer() - t_start_regenerate_halo_ed_elements_nodes_second_stage;
    
    oomph_info << "CPU for re-generating halo(ed) elements/nodes "
               << "(second stage) [n_ele="<< n_ele << "]: " 
               << t_final_regenerate_halo_ed_elements_nodes_second_stage
               << std::endl;
   }
  
  // -------------------------------------------------------------------
  // END: Create any additional haloed element, those that dont lie on
  // a shared boundary but that shared a node with other processor
  // -------------------------------------------------------------------
  
  // Clean send and receive buffers
  Flat_packed_unsigneds.clear();
  Flat_packed_doubles.clear();
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
  Flat_packed_unsigneds_string.clear();
#endif
    
  // Document the timings for reseting halo and haloed scheme (without
  // classification of halo and haloed nodes)
  if (Print_timings_level_adaptation>1)
   {
    tt_end = TimingHelpers::timer();
    oomph_info
      << "CPU for resetting halo-haloed scheme (without classification of halo and haloed nodes): "
      << tt_end-tt_start << std::endl;
   }
  
  // ------------------------------------------------------------------
  // BEGIN: Classify halo(ed) elements and nodes
  // ------------------------------------------------------------------
  const bool report_stats = true;
  DocInfo tmp_doc_info;
  tmp_doc_info.disable_doc();
  
  // Classify nodes 
  this->classify_halo_and_haloed_nodes(tmp_doc_info,report_stats);
  
  // Document the timings for reseting halo and haloed scheme (with
  // classification of halo and haloed nodes)
  if (Print_timings_level_adaptation>1)
   {
    tt_end = TimingHelpers::timer();
    oomph_info
      << "CPU for resetting halo-haloed scheme (with classification of halo and haloed nodes): "
      << tt_end-tt_start << std::endl;
   }
  
  // ------------------------------------------------------------------
  // END: Classify halo(ed) elements and nodes
  // ------------------------------------------------------------------
  
 }
  
//======================================================================
// \short Compute the alias of the nodes on shared boundaries in this
// (my_rank) processor with other processors. Also compute the alias
// of nodes on shared boundaries of other processors with other
// processors (useful when there is an element that requires to be
// sent to this (my_rank) processor because there is a shared node
// between this (my_rank) and other processors BUT there is not a
// shared boundary between this and the other processor
// ======================================================================
template <class ELEMENT>
void RefineableTriangleMesh<ELEMENT>::
  compute_global_node_names_and_shared_nodes(
   Vector<Vector<Vector<std::map<unsigned, Node*> > > > 
   &other_proc_shd_bnd_node_pt,
   Vector<Vector<Vector<unsigned> > > &global_node_names,
   std::map<Vector<unsigned>, unsigned> &node_name_to_global_index,
   Vector<Node*> &global_shared_node_pt)
{
    // Get the number of processors
    const unsigned nproc = this->communicator_pt()->nproc();
    // Get the rank of the current processor
    const unsigned my_rank = this->communicator_pt()->my_rank();
    // Get the communicator of the mesh
    OomphCommunicator* comm_pt = this->communicator_pt();
    
    // ---------------------------------------------------------------
    // BEGIN: Get the elements adjacent to shared boundaries and give
    // a unique node number to the nodes on the shared boundaries in
    // this processor
    // ---------------------------------------------------------------
    
    // Counter for the nodes on shared boundaries in this (my_rank)
    // processor
    unsigned counter_nodes = 0;
    // Keep track of visited nodes
    std::map<Node*, bool> done_node;
    // ... and its local node number
    std::map<Node*, unsigned> local_node_number;
    // ... and the inverted relation from local node number to node_pt
    Vector<Node*> local_node_pt;
    
    // Stores the j-th node name associated with the i-th local node
    // on shared boundaries in this processor (my_rank)
    // local_node_names[i][j][0] = my_rank (this processor)
    // local_node_names[i][j][1] = iproc (the processor with which there
    //                             is a shared boundary)
    // local_node_names[i][j][2] = the shared boundary id between this
    //                             (my_rank) processor and iproc
    //                             processor
    // local_node_names[i][j][3] = the node index on the shared boundary
    // local_node_names[i][j][4] = the local node index (i). This may
    //                             be unnecessary since we alread know the
    //                             index but we also send this info. to
    //                             the root processor that is why we store
    //                             them here
    Vector<Vector<Vector<unsigned> > > local_node_names;
    
    // loop over the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
     {
      // There are not shared boundaries with myself
      if (iproc != my_rank)
       {
        // Get the number of shared boundaries with iproc
        const unsigned n_shd_bnds_with_iproc = 
         this->nshared_boundaries(my_rank, iproc);
        
        // Get the boundaries ids shared with iproc
        Vector<unsigned> bnd_shd_with_iproc =
         this->shared_boundaries_ids(my_rank, iproc);
        
        // Loop over the shared boundaries with processor iproc
        for (unsigned ishd = 0; ishd < n_shd_bnds_with_iproc; ishd++)
         {
          // Keep track of visited nodes with this shared boundary
          std::map<Node*,bool> done_node_shd_bnd;
          // The boundary id
          unsigned shd_bnd_id = bnd_shd_with_iproc[ishd];
          // Get the number of element on the shared boundary
          const unsigned n_shd_bnd_ele = 
           this->nshared_boundary_element(shd_bnd_id);
          
          // loop over the elements adjacent to the shared boundary
          for (unsigned e = 0; e < n_shd_bnd_ele; e++)
           {
            // Get the element
            FiniteElement* ele_pt = 
             this->shared_boundary_element_pt(shd_bnd_id, e);
            
            // Get the number of nodes on the element
            const unsigned n_nodes = ele_pt->nnode();
            
            // loop over the nodes of the current element
            for (unsigned n = 0; n < n_nodes; n++)
             {
              // Get the node
              Node* node_pt = ele_pt->node_pt(n);
              
              // Has the node been visited with this shared boundary?
              // And, is this a node on the shd_bnd_id shared boundary
              // with processor iproc?
              if (!done_node_shd_bnd[node_pt] &&
               this->is_node_on_shared_boundary(shd_bnd_id, 
                                                node_pt))
               {
                // Mark the done as done with this shared boundary
                done_node_shd_bnd[node_pt] = true;
                
                // Get the index of the node on the shared boundary
                // -------------------------------------------------
                // Get the number of nodes on the shared boundary
                const unsigned n_nodes_shd_bnd = 
                  nsorted_shared_boundary_node(shd_bnd_id);
                
                // The index
                unsigned index = 0;
                
#ifdef PARANOID
                // Flag to know if the node has been found
                bool found_node_on_shared_boundary = false;
#endif
                // Loop over the nodes on the shared boundary to find
                // the node
                for (unsigned k = 0; k < n_nodes_shd_bnd; k++)
                 {
                  // Get the k-th node on the shared boundary
                  Node* shd_bnd_node_pt = 
                   sorted_shared_boundary_node_pt(shd_bnd_id, k);
                  
                  // Is the same node?
                  if (shd_bnd_node_pt == node_pt)
                   {
                    // This is the index
                    index = k;
#ifdef PARANOID
                    // Mark as found
                    found_node_on_shared_boundary = true;
#endif
                    break; // break
                    
                   } // if (shd_bnd_node_pt == node_pt)
                  
                 } // for (k < n_nodes_shd_bnd)
                            
#ifdef PARANOID
                if (!found_node_on_shared_boundary)
                 {
                  std::ostringstream error_message;
                  error_message
                    <<"The index of the node on boundary ("<<shd_bnd_id
                    <<") was not found.\n"
                    <<"These are the node coordinates\n"
                    <<"("<<node_pt->x(0)<<","<<node_pt->x(1)<<").\n";
                  throw OomphLibError(error_message.str(),
                                      OOMPH_CURRENT_FUNCTION,
                                      OOMPH_EXCEPTION_LOCATION);
                 }
#endif
                
                // Create the node name
                Vector<unsigned> node_name(5);
                node_name[0] = my_rank;
                node_name[1] = iproc;
                node_name[2] = shd_bnd_id;
                node_name[3] = index;
                // The node number is filled in the following if/else
                //node_name[4] = ?;
                
                // Has the node already been visited?
                if (!done_node[node_pt])
                 {
                  // If not ...
                   
                  // Add the node to the local nodes
                  local_node_pt.push_back(node_pt);
                  
                  // Assign a local node number to the node
                  local_node_number[node_pt] = counter_nodes;
                  // Store the local node number
                  node_name[4] = counter_nodes;
                  // Increase the counter of nodes
                  counter_nodes++;
                  // ... and mark it as visited
                  done_node[node_pt] = true;
                  
                  // Push back the node name (the first
                  // one found for this node)
                  Vector<Vector<unsigned> > first_node_name(1);
                  first_node_name[0] = node_name;
                  local_node_names.push_back(first_node_name);                  
                 }
                else
                 {
                  // If yes ...
                   
                  // Get the local node number
                  unsigned node_number = local_node_number[node_pt];
                  
                  // Store the local node number
                  node_name[4] = node_number;
                  
                  // Push back the node name for the
                  // node number
                  local_node_names[node_number].push_back(node_name);
                  
                 }
                
               } // Is on shared boundary?
              
             } // for (n < nnodes)
            
           } // for (e < n_shd_bnd_ele)
          
         } // for (ishd < n_shd_bnds_with_iproc)
        
       } // if (iproc != my_rank)
      
     } // for (iproc < nproc)
    
    // ---------------------------------------------------------------
    // END: Get the elements adjacent to shared boundaries and give
    // a unique node number to the nodes on the shared boundaries in
    // this processor
    // ---------------------------------------------------------------
    
    // ---------------------------------------------------------------
    // BEGIN: Package the names of the local nodes
    // ---------------------------------------------------------------
    // Counter for the number of names of the nodes
    unsigned n_total_local_names = 0;
    // Get the number of local nodes
    const unsigned n_local_nodes = local_node_names.size();
    // loop over the number of local nodes and get the number of names
    // of each node
    for (unsigned i = 0; i < n_local_nodes; i++)
     {
      // Get the number of names of the i-th local node
      const unsigned n_inode_names = local_node_names[i].size();
      // ... and add them to the total number of local names
      n_total_local_names+=n_inode_names;
     } // for (i < n_local_nodes)
    
    // We store five data per node name (my_rank,iproc,shd_bnd_id,idx,node#)
    // where node# is the node number on this processor (my_rank)
    const unsigned n_info_per_node_name = 5;
    // Storage for the flat package
    Vector<unsigned> flat_packed_send_udata(n_total_local_names*n_info_per_node_name);
    // A counter
    unsigned counter = 0;
    // loop over the local nodes
    for (unsigned i = 0; i < n_local_nodes; i++)
     {
      // Get the number of names of the i-th local node
      const unsigned n_inode_names = local_node_names[i].size();
      // loop over the names of the i-th local node
      for (unsigned j = 0 ; j < n_inode_names; j++)
       {
        // Store this processor id (my_rank)
        flat_packed_send_udata[counter++]=local_node_names[i][j][0];
        // Store the processor with which the shared boundary exist
        flat_packed_send_udata[counter++]=local_node_names[i][j][1];
        // Store the shared boundary id
        flat_packed_send_udata[counter++]=local_node_names[i][j][2];
        // Store the index of the node on the shared boundary
        flat_packed_send_udata[counter++]=local_node_names[i][j][3];
        // Store the local node number on this processor (my_rank)
        flat_packed_send_udata[counter++]=local_node_names[i][j][4];
       } // for (j < n_inode_names)
      
     } // for (i < n_local_nodes)
    
    // Reset the counter
    counter = 0;
    
    // The number of data that will be sent to root from this
    // (my_rank) processor
    const unsigned n_udata_send_to_root = flat_packed_send_udata.size();
    
    // ---------------------------------------------------------------
    // END: Package the names of the local nodes
    // ---------------------------------------------------------------    
    // ---------------------------------------------------------------
    // BEGIN: Send the data to the root processor
    // ---------------------------------------------------------------
    
    // The root processor is in charge of computing all the node names
    // of the nodes on the shared boundaries
    
    // Choose the root processor
    const unsigned root_processor = 0;
    
    // The vector where the root processor receives how many names
    // will receive from the other processors
    Vector<unsigned> root_n_names_per_processor(nproc);
    
    // Send the number of names that the root processor will receive
    // from each processor
    MPI_Gather(&n_total_local_names, 1, MPI_UNSIGNED, 
               &root_n_names_per_processor[0], 1, MPI_UNSIGNED,
               root_processor, comm_pt->mpi_comm());
    
    // Get the total number of data to receive from all processor in
    // root
    unsigned root_n_total_udata_receive = 0;
    Vector<int> root_n_udata_to_receive(nproc,0);
    for (unsigned iproc = 0; iproc < nproc; iproc++)
      {
        root_n_udata_to_receive[iproc]=
          root_n_names_per_processor[iproc]*n_info_per_node_name;
        root_n_total_udata_receive+=root_n_udata_to_receive[iproc];
      }
    
    // Stores and compute the offsets (in root) for the data received
    // from each processor
    Vector<int> root_uoffsets_receive(nproc,0);
    root_uoffsets_receive[0] = 0;
    for (unsigned iproc = 1; iproc < nproc; iproc++)
      {
        // Compute the offset to obtain the data from each processor
        root_uoffsets_receive[iproc] = 
          root_uoffsets_receive[iproc-1] + root_n_udata_to_receive[iproc-1];
        
      }
    
    // Create at least one entry so we don't get a seg fault below
    if (flat_packed_send_udata.size()==0)
      {
        flat_packed_send_udata.resize(1);
      }
    
    // Vector where to receive the info on root from all processors
    Vector<unsigned> root_flat_packed_receive_udata(root_n_total_udata_receive);
    // Only root receive data, the others dont, then resize the
    // container to have at least one entry
    if (my_rank!=root_processor)
      {
        // Create at least one entry so we don't get a seg fault below
        if (root_flat_packed_receive_udata.size()==0)
          {
            root_flat_packed_receive_udata.resize(1);
          }
      } // if (my_rank!=root_processor)
    
    // Send the info. to the root processor
    MPI_Gatherv(&flat_packed_send_udata[0], // Flat package to send
                                            // info. from each
                                            // processor
                n_udata_send_to_root, // Total number of data send
                                      // from each processor to root
                MPI_UNSIGNED,
                &root_flat_packed_receive_udata[0], // Container where
                                                    // to receive the
                                                    // info. from all
                                                    // processors
                &root_n_udata_to_receive[0], // Number of data to
                                             // receive from each
                                             // processor
                &root_uoffsets_receive[0], // The offset to store the
                                           // info. from each
                                           // processor
                MPI_UNSIGNED,
                root_processor, //The processor that receives all the
                                //info.
                comm_pt->mpi_comm());
    
    // Clear and resize the flat package to send
    flat_packed_send_udata.clear();
    flat_packed_send_udata.resize(0);
    // ---------------------------------------------------------------
    // END: Send the data to the root processor
    // ---------------------------------------------------------------
    
    // Container where root stores the info. that will be sent to all
    // processors. This includes the number of global nodes, the
    // number of names for each global node and the names
    Vector<unsigned> flat_packed_root_send_receive_udata;
    
    // ---------------------------------------------------------------
    // BEGIN: Unpackage the info. received on root. Compute the alias
    //        of the nodes
    // ---------------------------------------------------------------
    if (my_rank == root_processor)
      {
        // Compute all the names of a node
        // root_global_node_name[x][ ][ ] Global node number
        // root_global_node_name[ ][x][ ] Global node names
        // root_global_node_name[ ][ ][x] Global node info.
        Vector<Vector<Vector<unsigned> > > root_global_node_names;
        
        // Store the info. extracted from the flat package sent to
        // root
        // root_local_node_names[x][ ] Node name
        // root_local_node_names[ ][x] Node info
        Vector<Vector<unsigned> > root_local_node_names;
        
        // Extract all the node names
        unsigned rcounter = 0;        
        // loop over the processors
        for (unsigned iproc = 0; iproc < nproc; iproc++)
          {
            // Get the number of node names received from iproc
            const unsigned n_local_names_iproc = 
              root_n_names_per_processor[iproc];
            for (unsigned i = 0; i < n_local_names_iproc; i++)
              {
                // Get the i-thnode name from iproc
                Vector<unsigned> node_name(n_info_per_node_name);
                for (unsigned j = 0; j < n_info_per_node_name; j++)
                  {node_name[j] = root_flat_packed_receive_udata[rcounter++];}
                
                // Add the i-th node name
                root_local_node_names.push_back(node_name);
                
              } // for (i < n_local_names_iproc)
            
          } // for (iproc < nproc)
        
        // Get the number of node names received
        const unsigned n_root_local_node_names = 
          root_local_node_names.size();
        
        // For each name of the node identify the position of its
        // counter-part
        
        // Given a node name on the iproc, 
        // (iproc, jproc, ishd_bnd, idx, local_node_number1)
        // its counter part must live in jproc, so we look for the 
        // node name 
        // (jproc, iproc, ishd_bnd, idx, local_node_number2)
        
        // Store the index of the node name counter-part
        Vector<unsigned> node_name_counter_part(n_root_local_node_names);
        
        // Keep track of the names of nodes already done
        std::map<Vector<unsigned>, bool> done_name;
        
        // loop over the names of the nodes received from all
        // processors
        for (unsigned i = 0; i < n_root_local_node_names; i++)
          {
            // Get the i-th node name
            Vector<unsigned> node_name = root_local_node_names[i];
            
            // Check if this name node has been already done
            if (!done_name[node_name])
              {
                // Mark it as done
                done_name[node_name] = true;
#ifdef PARANOID                
                // Flag to indicate the counter-part name node was
                // found
                bool found_both_names_node = false;
#endif
                // Find the counter-part name node (start from j+1
                // since all previous have been found, otherwise we
                // would not be here)
                for (unsigned j = i+1; j < n_root_local_node_names; j++)
                  {
                    Vector<unsigned> node_name_r = root_local_node_names[j];
                    
                    // Check if this name node has been already done
                    if (!done_name[node_name_r])
                      {
                        // Check whether this node is the
                        // counter-part of the current name node
                        if (node_name[0] == node_name_r[1] &&
                            node_name[1] == node_name_r[0] &&
                            node_name[2] == node_name_r[2] &&
                            node_name[3] == node_name_r[3])
                          {
                            // Mark the name as node
                            done_name[node_name_r] = true;
                            // Store the index of the counter-part of
                            // the current node name
                            node_name_counter_part[i] = j;
                            // ... and indicate the current node name
                            // as the index of the counter-part
                            node_name_counter_part[j] = i;
#ifdef PARANOID
                            // The node has been found
                            found_both_names_node = true;
#endif
                            // Break the loop to find the
                            // counter-part
                            break;
                          }
                        
                      } // if (!done_name[node_name_r])
                    
                  } // for (j < n_root_local_node_names)
#ifdef PARANOID
                // Check whether the node counter-part was found
                if (!found_both_names_node)
                  {
                    std::ostringstream error_message;
                    error_message
                      <<"The counter-part of the current name node was "
                      <<"not found,\nthe current node name is:\n"
                      <<"iproc:("<<node_name[0]<<")\n"
                      <<"jproc:("<<node_name[1]<<")\n"
                      <<"ishd_bnd:("<<node_name[2]<<")\n"
                      <<"index:("<<node_name[3]<<")\n";
                    throw OomphLibError(error_message.str(),
                                        OOMPH_CURRENT_FUNCTION,
                                        OOMPH_EXCEPTION_LOCATION);
                  } // if (!found_both_names_node)
#endif
                
              } // if (!done_name[node_name])
            
          } // for (i < n_root_local_node_names)
        
        // -----------------------------------------------------------
        // Look for all the names of each node received and store them
        // in the "global node names" container
        
        // Keep track of the names of nodes already done
        done_name.clear();
        // loop over the names of the nodes received from all
        // processors
        for (unsigned i = 0; i < n_root_local_node_names; i++)
         {            
          // Get the i-th node name
          Vector<unsigned> node_name = root_local_node_names[i];
          
          // Check if this name node has been already done
          if (!done_name[node_name])
           {
            // Store all the names of the current node
            Vector<Vector<unsigned> > all_node_names;
            
            // Add the name of the node as the initial node name
            all_node_names.push_back(node_name);
            
            // Get the index of the counter-part
            unsigned idx_c = node_name_counter_part[i];
            // Get the counter-part of the node name
            Vector<unsigned> node_name_r = root_local_node_names[idx_c];
            
            // Add the name of the counter-part of the node
            all_node_names.push_back(node_name_r);
            // We do not mark it as done since we are interested in
            // the names that the counter-part may generate
            
            // Get the number of names for the current node (two at
            // the first time)
            unsigned n_current_names = all_node_names.size();
            // Counter to ensure to visit all the names of the current
            // node
            unsigned icounter = 0;
            
            // Visit all the names of the current node
            while(icounter < n_current_names)
             {
              // Get the current node name
              Vector<unsigned> current_node_name = all_node_names[icounter];
              
              // Search for other names for the current name of the
              // node, but first check if this has been already
              // visited
              if (!done_name[current_node_name])
               {
                // Mark it as done
                done_name[current_node_name] = true;
                
                // loop over the names of the nodes (start from the
                // j+1 position, all previous node names have all
                // their names already assigned)
                for (unsigned j=i+1;j<n_root_local_node_names;j++)
                 {
                  // Get the j-th node name
                  Vector<unsigned> other_node_name = root_local_node_names[j];
                  
                  // Is this name node already done
                  if (!done_name[other_node_name])
                   {
                    // Is this another name for the current name node?
                    if ((current_node_name[0] == other_node_name[0]) &&
                        (current_node_name[4] == other_node_name[4]))
                     {
                      // Mark it as done. If we search again using the
                      // "other_node_name" as the current node name we
                      // are not going to find new nodes to add
                      done_name[other_node_name] = true;
                      // Before adding it check that it is not already
                      // part of the names of the node
                      Vector<Vector<unsigned> >::iterator it
                        = std::find(all_node_names.begin(),
                                    all_node_names.end(),
                                    other_node_name);
                      if (it==all_node_names.end())
                       {
                        all_node_names.push_back(other_node_name);
                        // Get the index of the counter-part
                        unsigned k = node_name_counter_part[j];
                        // Get the counter-part of the node name
                        Vector<unsigned> other_node_name_r = 
                         root_local_node_names[k];
                        // Add the name of the counter-part of the
                        // node only if it has not been previously
                        // done
                        if (!done_name[other_node_name_r])
                         {
                          all_node_names.push_back(other_node_name_r);
                         }
                        
                       }
                      
                     } // // Is this another name for the current name
                       // node?
                    
                   } // if (!done_name[other_node_name])
                  
                 } // for (j < n_root_local_node_names)
                
               } // if (!done_name[current_node_name])
              
              // Get the number of names
              n_current_names = all_node_names.size();
              // Increase the icounter to indicate we have visited the
              // current name of the node
              icounter++;
              
             } // while(icounter < n_current_names)
            
            // We now have all the names for the i-th global node
            root_global_node_names.push_back(all_node_names);
            
           } // if (!done_name[node_name])
          
         } // for (i < n_root_local_node_names)
        
        // -------------------------------------------------------------
        // Prepare the info to be sent to all processors. The number
        // of global nodes, the number of names for each global node,
        // and their respective names
        // -------------------------------------------------------------
        
        // Clear the container
        flat_packed_root_send_receive_udata.clear();
        // Get the number of global nodes
        const unsigned n_global_nodes = root_global_node_names.size();
        // ... and store this info. to be sent from root to all
        // processors
        flat_packed_root_send_receive_udata.push_back(n_global_nodes);
        
        // loop over the nodes
        for (unsigned i = 0; i < n_global_nodes; i++)
         {
          // Get the names of the i-th global node
          Vector<Vector<unsigned> > global_inode_names = 
           root_global_node_names[i];
          // Get the number of names for the i-th global node
          const unsigned n_names_global_inode = global_inode_names.size();
          // ... and store this info. to be sent from root to all
          // processors
          flat_packed_root_send_receive_udata.push_back(n_names_global_inode);
          // loop over the names of the global i-th node
          for (unsigned j = 0; j < n_names_global_inode; j++)
           {
            // loop over the info. associated with each name
            for (unsigned k = 0; k < n_info_per_node_name; k++)
             {
              // Store the name info. of the current name in the
              // container to be sent from root to all processors
              flat_packed_root_send_receive_udata.
               push_back(global_inode_names[j][k]);
             } // for (k < n_info_per_node_name)
            
           } // for (j < n_names_inode)
          
         } // for (i < n_global_nodes)
        
      } // if (my_rank == root_processor)
    
    // ----------------------------------------------------------------
    //  END: Unpackage the info. received on root. Compute the alias
    //       of the nodes and prepare the info. to be sent back from
    //       root to all processors
    // ----------------------------------------------------------------
    
    // ---------------------------------------------------------------
    // BEGIN: Send the info. back to all processors, unpackage the
    //        info. and create the map from node name to global node
    //        index
    // ---------------------------------------------------------------    
    // The number of data that root send to other processors.
    unsigned root_n_udata_sent_to_all_proc = 
      flat_packed_root_send_receive_udata.size();
        
    MPI_Bcast(&root_n_udata_sent_to_all_proc, // Data to send and
                                              // receive
              1, MPI_UNSIGNED, root_processor, 
              comm_pt->mpi_comm());
    
    // Resize the container if this is a processor that receives data
    if (my_rank != root_processor)
      {
        flat_packed_root_send_receive_udata.
          resize(root_n_udata_sent_to_all_proc);
      }
    
    // Send the info. from root and receive it on all processors
    MPI_Bcast(&flat_packed_root_send_receive_udata[0], // Info. sent
                                                       // from root to
                                                       // all
                                                       // processors
              root_n_udata_sent_to_all_proc, // Number of data sent
                                             // from root to each
                                             // procesor
              MPI_UNSIGNED,
              root_processor, // The processor that sends all the info.
              comm_pt->mpi_comm());
    
    // Counter to extract the info.
    counter = 0;
    // Read the number of global nodes
    const unsigned n_global_nodes = 
      flat_packed_root_send_receive_udata[counter++];
    // Store the global names of the nodes
    // global_node_name[x][ ][ ] Global node number
    // global_node_name[ ][x][ ] Global node names
    // global_node_name[ ][ ][x] Global node info.
    //Vector<Vector<Vector<unsigned> > > global_node_names(n_global_nodes);
    // Resize the input vector
    global_node_names.resize(n_global_nodes);
    // Now loop until all global nodes info. has been read
    unsigned n_read_global_nodes = 0;
    while (n_read_global_nodes < n_global_nodes)
      {
        // Read the number of names for the current global node
        const unsigned n_names_global_inode = 
          flat_packed_root_send_receive_udata[counter++];
        // Counter for the global node
        const unsigned i = n_read_global_nodes;
        // Resize the container
        global_node_names[i].resize(n_names_global_inode);
        // loop over the names of the global inode
        for (unsigned j = 0; j < n_names_global_inode; j++)
          {
            // Resize the container
            global_node_names[i][j].resize(n_info_per_node_name);
            // loop over the info. of the j-th node name of the i-th
            // global node
            for (unsigned k = 0; k < n_info_per_node_name; k++)
              {
                // Read the k-th node info. from the j-th node name of
                // the i-th global node
                global_node_names[i][j][k] = 
                  flat_packed_root_send_receive_udata[counter++];
                
              } // for (k < n_info_per_node_name)
            
            // Create the map from the node name to the global node
            // index
            Vector<unsigned> node_name(n_info_per_node_name-1);
            node_name[0] = global_node_names[i][j][0];
            node_name[1] = global_node_names[i][j][1];
            node_name[2] = global_node_names[i][j][2];
            node_name[3] = global_node_names[i][j][3];
            // Do not add the local index since it will not longer be
            // used. Additionally, we will not know the local node
            // index outside this method
            // node_name[4] = global_node_names[i][j][4];
            node_name_to_global_index[node_name] = i;
            
          } // for (j < n_names_global_inode)
        
        // Increase the counter for read global nodes
        n_read_global_nodes++;
        
      } // while (n_read_global_nodes < n_global_nodes)
    
#ifdef PARANOID
    // Check we have read all the info.
    if (counter != root_n_udata_sent_to_all_proc)
      {
        std::ostringstream error_stream;
        error_stream
          <<"The info. received from root regarding the global names of "
          <<"the nodes\nwas not completely read.\n"
          << "The number of data sent/received from root is: ("
          <<root_n_udata_sent_to_all_proc<<")\n"
          <<"The number of data read from the received info. is: ("
          <<counter<<")\n\n";
        throw OomphLibError(error_stream.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      } // if (counter != root_n_udata_sent_to_all_proc)
#endif
    
    // ---------------------------------------------------------------
    // END: Send the info. back to all processors, unpackage the info.
    //      and create the map from node name to global node index
    // ---------------------------------------------------------------
    
    // ---------------------------------------------------------------
    // BEGIN: Add the info. from the global node names into the
    //        info. of the local node names. We do this because the
    //        local node names have pointers to the nodes.
    //        Additionally, create a map from the node name to the
    //        index of its global node
    // ---------------------------------------------------------------
    
    // Resize the global shared node pointers container
    global_shared_node_pt.resize(n_global_nodes, 0);
    
    // loop over the number of global nodes
    for (unsigned i = 0; i < n_global_nodes; i++)
     {
      // Flag to indicate that the iglobal node is part of the nodes
      // on the current processor
      bool is_this_a_local_node_name = false;
      unsigned local_node_number;
      // Get the number of names of the i-th global node
      const unsigned n_names_global_inode = global_node_names[i].size();
      // loop over the names of the i-th global node
      for (unsigned j = 0; j < n_names_global_inode; j++)
       {
        // Get the node name info.
        const unsigned iproc = global_node_names[i][j][0];
        local_node_number = global_node_names[i][j][4];
        
        // Check if this node name lives on this processor
        if (my_rank == iproc)
         {
          // The node is part of the local node names
          is_this_a_local_node_name = true;
          // Break
          break;
         } // if (my_rank == iproc)
        
       } // for (j < n_names_global_inode)
      
      // If the node is part of the local nodes then add the
      // additional names of the node in the local container
      if (is_this_a_local_node_name)
       {
#ifdef PARANOID
        // Check that the global node include at least all the names
        // of the node on this processor
        const unsigned n_names_local_node = 
         local_node_names[local_node_number].size();
        unsigned n_names_found_on_global_name_node = 0;
#endif
        
        // Add the pointer of the node into the global shared node
        // pointers container
        global_shared_node_pt[i] = local_node_pt[local_node_number];
        
        // Add all the global names of the node onto the local node
        // names
        
        // loop again over the names of the i-th global node
        for (unsigned j = 0; j < n_names_global_inode; j++)
         {
          // Get the node name info.
          const unsigned iproc = global_node_names[i][j][0];
          
          // Is this a node name on this processor?
          if (iproc != my_rank)
           {
            // Add the name
            local_node_names[local_node_number].
             push_back(global_node_names[i][j]);
           }
#ifdef PARANOID
          else
           {
            const unsigned jproc = global_node_names[i][j][1];
            const unsigned ishd_bnd = global_node_names[i][j][2];
            const unsigned idx = global_node_names[i][j][3];
            const unsigned n_local_node = global_node_names[i][j][4];
            // loop over the names of the local node
            for (unsigned k = 0; k < n_names_local_node; k++)
             {
              if ((local_node_names[local_node_number][k][0] == iproc) &&
                  (local_node_names[local_node_number][k][1] == jproc) &&
                  (local_node_names[local_node_number][k][2] == ishd_bnd) &&
                  (local_node_names[local_node_number][k][3] == idx) &&
                  (local_node_names[local_node_number][k][4] == n_local_node))
               {
                // Increase the number of local nodes found on the
                // global nodes
                n_names_found_on_global_name_node++;
               } // found global node on local nodes
              
             } // for (k < n_names_local_node)
            
           } // if (iproc != my_rank)
#endif
          
         } // for (j < n_names_global_inode)
        
#ifdef PARANOID
        // The number of local nodes names must be the same as the the
        // number of global nodes names associated with this processor
        // (my_rank, that start with iproc = my_rank)
        if (n_names_local_node != n_names_found_on_global_name_node)
         {
          std::ostringstream error_stream;
          error_stream
            <<"The local node names corresponding to the local "
            <<"node ("<< local_node_number << ") were\n"
            <<"not found on the global node names.\n\n"
            << "These are the names of the local node\n"
            << "Name k: iproc, jproc, ishd_bnd, idx. #node\n";
          for (unsigned k = 0; k < n_names_local_node; k++)
           {
            error_stream<<"Name("<<k<<"): "
                        <<local_node_names[local_node_number][k][0]
                        <<", "<<local_node_names[local_node_number][k][1]
                        <<", "<<local_node_names[local_node_number][k][2]
                        <<", "<<local_node_names[local_node_number][k][3]
                        <<", "<<local_node_names[local_node_number][k][4]
                        <<"\n";
           }
          
          error_stream
            << "\n\nThese are the names of the global node\n"
            << "Name k: iproc, jproc, ishd_bnd, idx. #node\n";
          for (unsigned k = 0; k < n_names_global_inode; k++)
           {
            error_stream<<"Name("<<k<<"): "
                        <<global_node_names[i][k][0] <<", "
                        <<global_node_names[i][k][1] <<", "
                        <<global_node_names[i][k][2] <<", "
                        <<global_node_names[i][k][3] <<", "
                        <<global_node_names[i][k][4] <<"\n";
           }
          
          throw OomphLibError(error_stream.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
         }
#endif
        
       } // if (is_this_a_local_node_name)
      
     } // for (i < n_global_nodes)
    
    // ---------------------------------------------------------------
    // END: Add the info. from the global node names into the info.
    //      of the local node names. We do this because the local
    //      node names have pointers to the nodes
    // ---------------------------------------------------------------
    
    // ---------------------------------------------------------------
    // BEGIN: Fill the data structure other_proc_shd_bnd_node_pt with
    //        the local nodes.
    // ---------------------------------------------------------------
    
    // Loop over the local nodes and fill the
    // other_proc_shd_bnd_node_pt container with the corresponding
    // info. NOTE: We are using the old size of the local node names,
    // before adding the names of the global nodes so we only loop
    // over the local nodes and not global.
    
    // Compute the local shared boudary id
    const unsigned initial_shd_bnd_id = this->initial_shared_boundary_id();
    
    // loop over the local nodes names
    for (unsigned i = 0 ; i < n_local_nodes; i++)
     {
      // Get the number of names for the i-th local node
      const unsigned n_names = local_node_names[i].size();
      // Get a pointer to the first name of the node found on this
      // processor (this ensures that the node lives on this
      // processor)
      Node* node_pt = local_node_pt[i];
      // loop over the names of the i-th local node and add an entry
      // to the other_proc_shd_bnd_node_pt structure
      for (unsigned j = 0; j < n_names; j++)
       {
        // Get the node name info.
        const unsigned iproc = local_node_names[i][j][0];
        const unsigned jproc = local_node_names[i][j][1];
        const unsigned ishd_bnd = 
         local_node_names[i][j][2] - initial_shd_bnd_id;
        const unsigned index = local_node_names[i][j][3];
        // We can ignore the last entry, it was just used to compute
        // the global node number by the root processor
        
        // Get the smallest processor number
        if (iproc < jproc)
         {
          other_proc_shd_bnd_node_pt[iproc][jproc][ishd_bnd][index]=node_pt;
         }
        else
         {
          other_proc_shd_bnd_node_pt[jproc][iproc][ishd_bnd][index]=node_pt;
         }
        
       } // for (j < n_names)
      
     } // for (i < n_local_node_names)
        
    // ---------------------------------------------------------------
    // END: Fill the data structure other_proc_shd_bnd_node_pt with
    //      the local nodes.
    // ---------------------------------------------------------------
    
}
 
 //======================================================================
 // \short Get the original boundaries to which is associated each
 // shared node, and send the info. to the related processors. We
 // need to do this so that at the reset of halo(ed) info. stage,
 // the info. is updated
template <class ELEMENT>
void RefineableTriangleMesh<ELEMENT>::
 send_boundary_node_info_of_shared_nodes(
  Vector<Vector<Vector<unsigned> > > &global_node_names,
  std::map<Vector<unsigned>, unsigned> &node_name_to_global_index,
  Vector<Node*> &global_shared_node_pt)
{
  // Get the rank and number of processors
  const unsigned nproc = this->communicator_pt()->nproc();
  const unsigned my_rank = this->communicator_pt()->my_rank();
  
  // The number of nodes on shared boundaries
  const unsigned n_nodes_on_shd_bnds = global_node_names.size();
  // ---------------------------------------------------------
  // BEGIN: Get the shared nodes between each of processors
  // ---------------------------------------------------------
  
  // Store the nodes on shared boundaries in this processor with other
  // processors
  Vector<std::set<Node*> > node_on_shd_bnd_pt(nproc);
  
  // A map to get access to the global shared node number from the
  // node pointer
  std::map<Node*, unsigned> node_pt_to_global_shd_bnd_index;
    
  // loop over the global nodes names and get only those in this
  // processor
  for (unsigned i = 0; i < n_nodes_on_shd_bnds; i++)
   {
    // Get the number of names of the current node on shared
    // boundaries
    const unsigned n_names = global_node_names[i].size();
    // loop over the names
    for (unsigned j = 0; j < n_names; j++)
     {
      // Store the node name
      Vector<unsigned> node_name(4);
      node_name[0] = global_node_names[i][j][0];
      node_name[1] = global_node_names[i][j][1];
      node_name[2] = global_node_names[i][j][2];
      node_name[3] = global_node_names[i][j][3];
      
      // Check whether the node is in the current processor
      if (node_name[0]==my_rank)
       {
        // Check with which processor the node is shared
        const unsigned jproc = node_name[1];
        
#ifdef PARANOID
        std::map<Vector<unsigned>, unsigned>::iterator it =
          node_name_to_global_index.find(node_name);
        if (it!=node_name_to_global_index.end())
         {
           // Check whether the global node index correspond with that
           // of the current global node name
           if (i!=(*it).second)
            {
             std::ostringstream error_message;
             error_message
              <<"The global node number "<<(*it).second
              <<") obtained from the current node\n"
              <<"name is not the same as the current node number ("
              <<i<<").\n\n"
              <<"Node name:\n"
              <<"iproc:"<<node_name[0]<<"\n"
              <<"jproc:"<<node_name[1]<<"\n"
              <<"shd_bnd_id:"<<node_name[2]<<"\n"
              <<"index:"<<node_name[3]<<"\n\n";
             throw OomphLibError(error_message.str(),
                                 OOMPH_CURRENT_FUNCTION,
                                 OOMPH_EXCEPTION_LOCATION);
            }
           
         }
        else
         {
          std::ostringstream error_message;
          error_message
           <<"The node name is not registerd as living in this processor.\n"
           <<"Node name:\n"
           <<"iproc:"<<node_name[0]<<"\n"
           <<"jproc:"<<node_name[1]<<"\n"
           <<"shd_bnd_id:"<<node_name[2]<<"\n"
           <<"index:"<<node_name[3]<<"\n\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
         }
        
#endif // #ifdef PARANOID
        
        // Get the node pointer
        Node* node_pt = global_shared_node_pt[i];
        
#ifdef PARANOID
        if (node_pt == 0)
         {
          std::ostringstream error_message;
          error_message
            <<"There is not global shared node within this\n"
            <<"global node number ("<<i<<"). The global shared\n"
            <<"node pointer is null\n\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);              
         }
#endif // #ifdef PARANOID
        
        // Add the node to the nodes on shared boundaries in this
        // processor
        node_on_shd_bnd_pt[jproc].insert(node_pt);
        
        // And store the global node index
        node_pt_to_global_shd_bnd_index[node_pt] = i;
        
       } // if (node_name[0]==my_rank)
      else if (node_name[1]==my_rank)
       {
        // Check with which processor the node is shared
        const unsigned jproc = node_name[0];
      
#ifdef PARANOID
        std::map<Vector<unsigned>, unsigned>::iterator it =
          node_name_to_global_index.find(node_name);
        if (it!=node_name_to_global_index.end())
         {
           // Check whether the global node index correspond with that
           // of the current global node name
           if (i!=(*it).second)
            {
             std::ostringstream error_message;
             error_message
              <<"The global node number "<<(*it).second
              <<") obtained from the current node\n"
              <<"name is not the same as the current node number ("
              <<i<<").\n\n"
              <<"Node name:\n"
              <<"iproc:"<<node_name[0]<<"\n"
              <<"jproc:"<<node_name[1]<<"\n"
              <<"shd_bnd_id:"<<node_name[2]<<"\n"
              <<"index:"<<node_name[3]<<"\n\n";
             throw OomphLibError(error_message.str(),
                                 OOMPH_CURRENT_FUNCTION,
                                 OOMPH_EXCEPTION_LOCATION);
            }
           
         }
        else
         {
          std::ostringstream error_message;
          error_message
           <<"The node name is not registerd as living in this processor.\n"
           <<"Node name:\n"
           <<"iproc:"<<node_name[0]<<"\n"
           <<"jproc:"<<node_name[1]<<"\n"
           <<"shd_bnd_id:"<<node_name[2]<<"\n"
           <<"index:"<<node_name[3]<<"\n\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
         }
        
#endif // #ifdef PARANOID
      
        // Get the node pointer
        Node* node_pt = global_shared_node_pt[i];
        
#ifdef PARANOID
        if (node_pt == 0)
         {
          std::ostringstream error_message;
          error_message
            <<"There is not global shared node within this\n"
            <<"global node number ("<<i<<"). The global shared\n"
            <<"node pointer is null\n\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
         }
#endif // #ifdef PARANOID
        
        // Add the node to the nodes on shared boundaries in this
        // processor
        node_on_shd_bnd_pt[jproc].insert(node_pt);
        
        // And store the global node index
        node_pt_to_global_shd_bnd_index[node_pt] = i;
        
       }
      
     } // for (j < n_names)
    
   } // for (i < n_nodes_on_shd_bnds)
  
  // ---------------------------------------------------------
  // END: Get the shared nodes between each of processors
  // ---------------------------------------------------------
  
  // ---------------------------------------------------------
  // BEGIN: Get the original boundaries associated to each
  //        node on a shared boundary
  // ---------------------------------------------------------
  
  // Store the global shared node number
  Vector<Vector<unsigned> > global_node_on_shared_bound(nproc);
  // Store the boundaries associated with the global shared node
  // number
  Vector<Vector<Vector<unsigned> > > global_node_original_boundaries(nproc);
  // Store the zeta boundary coordinate of the nodes on original
  // boundaries
  Vector<Vector<Vector<double> > > global_node_zeta_coordinate(nproc);
  
  // loop over the processors
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // Get the nodes added to be shared with the iproc processor
    std::set<Node*> nodes_shared_pt = node_on_shd_bnd_pt[iproc];
    
    // loop over the nodes  
    for (std::set<Node*>::iterator it = nodes_shared_pt.begin();
         it!=nodes_shared_pt.end(); it++)
     {
      // Get the node
      Node* node_pt = (*it);
      // Store the boundaries on which it is stored
      Vector<unsigned> on_original_boundaries;
      // For each boundary get the corresponding z value of the node
      // on the boundary
      Vector<double> zeta_coordinate;
      // Get the number of boudandaries
      const unsigned n_bnd=this->initial_shared_boundary_id();
      // loop over the boundaries and register the boundaries to which
      // it is associated
      for (unsigned bb = 0; bb < n_bnd; bb++)
       {
        // Is the node on original boundary bb?
        if (node_pt->is_on_boundary(bb))
         {
          // Then save it as being on boundary bb
          on_original_boundaries.push_back(bb);
          // Get the boundary coordinate
          Vector<double> zeta(1);
          node_pt->get_coordinates_on_boundary(bb, zeta);
          // Save the boundary coordinate
          zeta_coordinate.push_back(zeta[0]);
         }
        
       } // for (bb < n_bnd)
      
      // Is the node on an original boundary
      if (on_original_boundaries.size()>0)
       {
        // Get the global shared node number
        std::map<Node*,unsigned>::iterator it_index = 
         node_pt_to_global_shd_bnd_index.find(node_pt);
#ifdef PARANOID
        if (it_index==node_pt_to_global_shd_bnd_index.end())
         {
          std::ostringstream error_message;
          error_message
            <<"We could not find the global shared node index associated\n"
            <<"with the node pointer with vertices coordinates:\n"
            <<"("<<node_pt->x(0)<<", "<<node_pt->x(1)<<")\n\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);           
         }
#endif
        // The global shared node index
        const unsigned global_shared_node_number = (*it_index).second;
        // Store the global shared node number
        global_node_on_shared_bound[iproc].push_back(global_shared_node_number);
        // And store the original boundaries to which it is associated
        global_node_original_boundaries[iproc].
         push_back(on_original_boundaries);
        // and the corresponding zeta coordinate
        global_node_zeta_coordinate[iproc].push_back(zeta_coordinate);
       }
      
     } // loop over nodes on shared boundaries with iproc
    
   } // for (iproc < nproc)
  
  // ---------------------------------------------------------
  // END: Get the original boundaries associated to each
  //      node on a shared boundary
  // ---------------------------------------------------------
  
  // ---------------------------------------------------------
  // BEGIN: Send the info. to the corresponding processors,
  //        package the info, send it and receive it in the
  //        corresponding processor, unpackage and set the
  //        boundaries associated with the received nodes
  // ---------------------------------------------------------
  
  // Get the communicator of the mesh
  OomphCommunicator* comm_pt = this->communicator_pt();
  
  // Set MPI info
  MPI_Status status;
  MPI_Request request;
  
  // loop over the processors
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // The number of nodes shared between the pair of processors
    const unsigned n_shd_nodes_my_rank_iproc =
     node_on_shd_bnd_pt[iproc].size();
    
    // Are there shared nodes between these pair of processors
    // (my_rank, iproc)? Also ensure not to send info. within myself
    if (n_shd_nodes_my_rank_iproc > 0 && iproc != my_rank)
     {
      // The flat package to send the info, to the iproc processor
      Vector<unsigned> flat_package_unsigned_send;
      // The very first entry is the number of nodes shared by the
      // pair of processors (my_rank, iproc)
      flat_package_unsigned_send.push_back(n_shd_nodes_my_rank_iproc);
      
      // Get the number of shared nodes on original boundaries
      const unsigned n_global_shared_node_on_original_boundary = 
       global_node_on_shared_bound[iproc].size();
      
      // The second data is the number of shared nodes on original
      // boundaries
      flat_package_unsigned_send.
       push_back(n_global_shared_node_on_original_boundary);
      
      // ... also send the zeta coordinates associated with the
      // original boundaries
      Vector<double> flat_package_double_send;
      
      // loop over the nodes shared between this pair of processors
      for (unsigned i = 0; i < n_global_shared_node_on_original_boundary; i++)
       {
        // Get the global shared node index
        const unsigned global_shared_node_index = 
         global_node_on_shared_bound[iproc][i];
        
        // Put in the package the shared node index of the current
        // node
        flat_package_unsigned_send.push_back(global_shared_node_index);
        
        // Get the original boundaries to which the node is associated
        Vector<unsigned> on_original_boundaries = 
         global_node_original_boundaries[iproc][i];
        
        // Get the associated zeta boundary coordinates
        Vector<double> zeta_coordinate = 
         global_node_zeta_coordinate[iproc][i];
        
        // Get the number of original boundaries to which the node is
        // associated
        const unsigned n_original_boundaries = 
         on_original_boundaries.size();
        
        // Put in the package the number of original boundaries the
        // node is associated
        flat_package_unsigned_send.push_back(n_original_boundaries);
        
        // loop over the original boundaries ids and include them in
        // the package
        for (unsigned j = 0; j < n_original_boundaries; j++)
         {
          // Put in the package each of the original boundaries to
          // which it is associated
          flat_package_unsigned_send.push_back(on_original_boundaries[j]);
          // The zeta coordinate on the boundary
          flat_package_double_send.push_back(zeta_coordinate[j]);
         } // for (j < n_original_boundaries)
        
       } // for (i < n_global_shared_node_on_original_boundary)
      
      // Send data UNSIGNED -----------------------------------------
      // Get the size of the package to communicate to the iproc
      // processor
      const unsigned n_udata_send = flat_package_unsigned_send.size();
      int n_udata_send_int = n_udata_send;
      
      // Send/receive data to/from iproc processor
      MPI_Isend(&n_udata_send_int,1,MPI_UNSIGNED,
                iproc,1,comm_pt->mpi_comm(), &request);
      
      int n_udata_received_int = 0;
      MPI_Recv(&n_udata_received_int,1,MPI_UNSIGNED,
               iproc,1,comm_pt->mpi_comm(),&status);
      MPI_Wait(&request,MPI_STATUS_IGNORE);
      
      if (n_udata_send!=0)
       {
        MPI_Isend(&flat_package_unsigned_send[0],
                  n_udata_send,MPI_UNSIGNED,
                  iproc,2,comm_pt->mpi_comm(),&request);
       }
      
      const unsigned n_udata_received = 
       static_cast<unsigned>(n_udata_received_int);
      
      // Where to receive the data from the iproc processor
      Vector<unsigned> flat_package_unsigned_receive(n_udata_received);
      
      if (n_udata_received!=0)
       {
        MPI_Recv(&flat_package_unsigned_receive[0],
                 n_udata_received,MPI_UNSIGNED,
                 iproc,2,comm_pt->mpi_comm(),&status);
       }
      
      if (n_udata_send!=0)
       {
        MPI_Wait(&request,MPI_STATUS_IGNORE);
       }
      
      // Send data DOUBLE -----------------------------------------
      // Get the size of the package to communicate to the iproc
      // processor
      const unsigned n_ddata_send = flat_package_double_send.size();
      int n_ddata_send_int = n_ddata_send;
      
      // Send/receive data to/from iproc processor
      MPI_Isend(&n_ddata_send_int,1,MPI_UNSIGNED,
                iproc,1,comm_pt->mpi_comm(), &request);
      
      int n_ddata_received_int = 0;
      MPI_Recv(&n_ddata_received_int,1,MPI_UNSIGNED,
               iproc,1,comm_pt->mpi_comm(),&status);
      MPI_Wait(&request,MPI_STATUS_IGNORE);
      
      if (n_ddata_send!=0)
       {
        MPI_Isend(&flat_package_double_send[0],
                  n_ddata_send,MPI_DOUBLE,
                  iproc,2,comm_pt->mpi_comm(),&request);
       }
      
      const unsigned n_ddata_received = 
       static_cast<unsigned>(n_ddata_received_int);
      
      // Where to receive the data from the iproc processor
      Vector<double> flat_package_double_receive(n_ddata_received);
      
      if (n_ddata_received!=0)
       {
        MPI_Recv(&flat_package_double_receive[0],
                 n_ddata_received,MPI_DOUBLE,
                 iproc,2,comm_pt->mpi_comm(),&status);
       }
      
      if (n_ddata_send!=0)
       {
        MPI_Wait(&request,MPI_STATUS_IGNORE);
       }
      
      // Unpackage -------------------------------------------------
      // ... and associate the nodes to the corresponding original
      // boundaries
      
      // The number of nodes to be received
      unsigned n_shared_nodes_received = flat_package_unsigned_receive[0];
      
      // Increase and decrease the number of received shared nodes to
      // avoid the warning when compiling without PARANOID
      n_shared_nodes_received++;
      n_shared_nodes_received--;
      
#ifdef PARANOID
      if (n_shd_nodes_my_rank_iproc != n_shared_nodes_received)
       {
        std::ostringstream error_message;
        error_message
          <<"The number of shared nodes between the pair of processors is\n"
          <<"not the same\n"
          <<"N.shared nodes proc ("<<my_rank<<") with proc ("<<iproc<<"): ("
          <<n_shd_nodes_my_rank_iproc<<"\n"
          <<"N.shared nodes proc ("<<iproc<<") with proc ("<<my_rank<<"): ("
          <<n_shared_nodes_received<<"\n\n"
          <<"You should have got the same error in proc: ("<<iproc<<")\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
       } // if (n_shd_nodes_my_rank_iproc != n_shared_nodes_received)
#endif
      
      // Skip the number of nodes on shared boundaries on original
      // boundaries received (that is why next lines are commented)
      
      // The number of nodes on shared boundaries on original
      // boundaries
      //const unsigned n_shared_nodes_on_original_boundaries_received = 
      // flat_package_unsigned_receive[1];
      
      // loop over the received info.
      unsigned current_index_data = 2;
      unsigned current_index_ddata = 0;
      while(current_index_data < n_udata_received)
       {
        // The global shared node number
        const unsigned global_shared_node_index = 
         flat_package_unsigned_receive[current_index_data++];
        
        // The pointer to the node
        Node* node_pt = 0;
        
        // The number of original boundaries the node is associated
        // with
        const unsigned n_original_boundaries = 
         flat_package_unsigned_receive[current_index_data++];
        
        // Get the node pointer
        node_pt = global_shared_node_pt[global_shared_node_index];
#ifdef PARANOID
        if (node_pt == 0)
         {
          std::ostringstream error_message;
          error_message
            <<"The global shared node ("<<global_shared_node_index<<") "
            <<"could not be found in this processor!!!\n"
            <<"However, it was found in processor ("<<iproc<<"). The "
            <<"data may be no synchronised,\ntherefore "
            <<"we may be looking for a global shared node number that "
            <<"do not\ncorrespond with the one that was sent by "
            <<"processor ("<<iproc<<")\n\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);             
         }
#endif // #ifdef PARANOID
        
        // loop over the number of original boundaries and associate
        // the node to each of those boundaries
        for (unsigned i = 0; i < n_original_boundaries; i++)
         {
          // Get the original boundary to which the node is associated
          // with
          const unsigned original_bound_id = 
           flat_package_unsigned_receive[current_index_data++];
          
          // Associate the node with the boundary
          this->add_boundary_node(original_bound_id, node_pt);
          
          // Get the zeta boundary coordinate
          Vector<double> zeta(1);
          zeta[0] = flat_package_double_receive[current_index_ddata++];
          node_pt->set_coordinates_on_boundary(original_bound_id, zeta);
         }
        
       } // while(current_data < n_data_received)
      
     } // if ((node_on_shd_bnd_pt(iproc) > 0) && iproc!=my_rank)
    
   } // for (iproc < nproc)
  
  // ---------------------------------------------------------
  // END: Send the info. to the corresponding processors,
  //      package the info, send it and receive it in the
  //      corresponding processor, unpackage and set the
  //      boundaries associated with the received nodes
  // ---------------------------------------------------------
    
}
 
 //======================================================================
 // \short In charge of creating additional halo(ed) elements on those
 // processors that have no shared boundaries in common but have
 // shared nodes
 // ======================================================================
template <class ELEMENT>
void RefineableTriangleMesh<ELEMENT>::reset_halo_haloed_scheme_helper(
  Vector<Vector<Vector<std::map<unsigned, Node*> > > >
  &other_proc_shd_bnd_node_pt,
  Vector<Vector<Node *> > &iproc_currently_created_nodes_pt,
  Vector<Vector<Vector<unsigned> > > &global_node_names,
  std::map<Vector<unsigned>, unsigned> &node_name_to_global_index,
  Vector<Node*> &global_shared_node_pt)
 {
   // Get the rank and number of processors
   const unsigned nproc = this->communicator_pt()->nproc();
   const unsigned my_rank = this->communicator_pt()->my_rank();
   
   // ---------------------------------------------------------------
   // BEGIN: Create a map to check whether a node is on the global
   //        shared nodes. Also set a map to obtain the global
   //        shared node index (this index is the same as the global
   //        node name)
   // ---------------------------------------------------------------
   std::map<Node*, bool> is_global_shared_node;
   std::map<Node*, unsigned> global_shared_node_index;
   
   // Get the number of global shared nodes
   const unsigned n_global_shared_nodes = global_shared_node_pt.size();
   // loop over the global shared nodes
   for (unsigned i = 0; i < n_global_shared_nodes; i++)
     {
       // Get the node
       Node* node_pt = global_shared_node_pt[i];
       // Indicate this is a shared global node
       is_global_shared_node[node_pt] = true;
       // Set the map to obtain the index of the global shared node
       global_shared_node_index[node_pt] = i;
       
     } // for (i < n_global_shared_nodes)
   
   // ---------------------------------------------------------------
   // END: Create a map to check whether a node is on the global
   //      shared nodes. Also set a map to obtain the global
   //      shared node index (this index is the same as the global
   //      node name)
   // ---------------------------------------------------------------
   
   // ---------------------------------------------------------------
   // BEGIN: Loop over the haloed elements and check whether the nodes
   //        on the haloed elements are part of the global shared
   //        nodes. If that is the case then check whether the
   //        element should be sent to the processors with which the
   //        node is shared
   // ---------------------------------------------------------------
   
   // Elements that may be sent to other processors
   Vector<std::set<GeneralisedElement*> > additional_elements_pt(nproc);
   
   // loop over the processors
   for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
     if (iproc!=my_rank)
      {
       // Get the haloed element with iproc
       Vector<GeneralisedElement*> haloed_ele_pt = 
         this->root_haloed_element_pt(iproc);
       
       // Get the number of haloed elements
       const unsigned n_haloed_ele = 
        this->nroot_haloed_element(iproc);
       
       // loop over the haloed elements with iproc
       for (unsigned ihd = 0; ihd < n_haloed_ele; ihd++)
        {
         // A pointer to the generalised element
         GeneralisedElement* gele_pt = haloed_ele_pt[ihd];
         // Get the finite element representation of the element
         FiniteElement* ele_pt = dynamic_cast<FiniteElement*>(gele_pt);
         // Get the number of nodes
         const unsigned n_nodes = ele_pt->nnode();
         // loop over the nodes of the element
         for (unsigned n = 0; n < n_nodes; n++)
          {
           // Get the node
           Node* node_pt = ele_pt->node_pt(n);
           // Is the node a global shared node?
           if (is_global_shared_node[node_pt])
            {
             // Get the index of the global shared node
             const unsigned global_index = global_shared_node_index[node_pt];
             // Get the global names of the node
             Vector<Vector<unsigned> > iglobal_names = 
              global_node_names[global_index];
             
             // Get the number of names
             const unsigned n_names = iglobal_names.size();
             // loop over the names and check which processors share
             // this node (the processors to which the element may be
             // sent
             for (unsigned j = 0; j < n_names; j++)
              {
               // Get the processors to which the element should be
               // sent
               const unsigned proc1 = iglobal_names[j][0];
               const unsigned proc2 = iglobal_names[j][1];
               // Add the element to the set of additional elements to
               // sent from proc1 to proc2
               additional_elements_pt[proc1].insert(gele_pt);
               additional_elements_pt[proc2].insert(gele_pt);
               
              } // for (j < n_names)
             
            } // if (is_global_shared_node[node_pt])
           
          } // for (n < n_nodes)
         
        } // for (ihd < n_haloed_ele)
       
      } // if (iproc!=my_rank)
     
    } // for (iproc < nproc)
   
   // ---------------------------------------------------------------
   // Now check whether the element should really be sent to the
   // indicated processors
   
   // The elements from this (my_rank) processor that will be sent to
   // other processors
   Vector<Vector<FiniteElement*> > send_haloed_ele_pt(nproc);
   
   // loop over the processors
   for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
     if (iproc!=my_rank)
      {
       // Get the set of element that may be sent to the iproc
       // processor
       std::set<GeneralisedElement*> iproc_ele_pt = 
        additional_elements_pt[iproc];
       // loop over the element that may be sent to the iproc
       // processor
       for (std::set<GeneralisedElement*>::iterator it = 
              iproc_ele_pt.begin(); it!=iproc_ele_pt.end(); it++)
        {
         // Get a pointer to the element
         GeneralisedElement* gele_pt = (*it);
         
         // Get the haloed element with iproc
         Vector<GeneralisedElement*> haloed_ele_pt = 
          this->root_haloed_element_pt(iproc);
         
         // Get the number of haloed elements
         const unsigned n_haloed_ele = this->nroot_haloed_element(iproc);
         
         // Flag to indicate whether the element has been already sent
         // to the iproc processor
         bool send_ele_to_iproc_processor = true;
         // loop over the haloed elements with iproc and check whether
         // the element has been already sent to iproc (if it is
         // already a haloed element with iproc then it has been
         // already sent)
         for (unsigned ihd = 0; ihd < n_haloed_ele; ihd++)
          {
           // A pointer to the generalised element
           GeneralisedElement* ghd_ele_pt = haloed_ele_pt[ihd];
           if (gele_pt == ghd_ele_pt)
            {
             // Mark the element as not required to be sent
             send_ele_to_iproc_processor = false;
             // Break the loop that searchs for the element on the
             // haloed elements with iproc
             break;
            }
           
          } // for (ihd < n_haloed_ele)
         
         // Do we need to sent the element?
         if (send_ele_to_iproc_processor)
          {
            // Get the finite element representation of the element
            FiniteElement* ele_pt = dynamic_cast<FiniteElement*>(gele_pt);
            // Add the element to those that will be sent to the iproc
            // processor
            send_haloed_ele_pt[iproc].push_back(ele_pt);
          }
         
        } // loop over the elements that may be sent to the iproc
          // processor
       
      } // if (iproc!=my_rank)
     
    } // for (iproc < nproc)
   
   // ---------------------------------------------------------------
   // END: Loop over the haloed element and check whether the nodes
   //      on the haloed elements are part of the global shared
   //      nodes. If that is the case then check whether the element
   //      should be sent to the processors with which the node is
   //      shared
   // ---------------------------------------------------------------
   
  // ============================================================
  // Now send the additional elements
  // ============================================================
  // Loop over the processors to send data
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // There are no elements to send with myself
    if (iproc != my_rank)
     {
      // Get the number of additional haloed elements to send
      const unsigned n_additional_haloed_ele = 
       send_haloed_ele_pt[iproc].size();
      
      // Clear send and receive buffers
      Flat_packed_unsigneds.clear();
      Flat_packed_doubles.clear();
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.clear();
#endif
      
      // The very first data of the flat packed is the number of
      // additional haloed elements, this will be the number of
      // additional halo elements to create on the receiver processor
      Flat_packed_unsigneds.push_back(n_additional_haloed_ele);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk;
      junk << "Number of haloed elements " << nhaloed_ele;
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif
      
      // Loop over the additioanl haloed elements
      for (unsigned e = 0; e < n_additional_haloed_ele; e++)
       {
        // Get pointer to the additional haloed element
        FiniteElement* ele_pt = send_haloed_ele_pt[iproc][e];
        const unsigned nroot_haloed_ele = 
         this->nroot_haloed_element(iproc);
          
        // Check if the element has been already added to the
        // halo(ed) scheme
          
        // Get the generalised version of the element
        GeneralisedElement *gen_ele_pt = ele_pt;
        // Try to add the haloed element
        const unsigned haloed_ele_index =
         this->try_to_add_root_haloed_element_pt(iproc, gen_ele_pt);
          
        // Was the element added or only returned the index of the
        // element
        if (nroot_haloed_ele == haloed_ele_index)
         {
          Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
          Flat_packed_unsigneds_string.push_back("Haloed element needs to be constructed");
#endif
          
          // Get additional info. related with the haloed element
          get_required_elemental_information_helper(iproc, ele_pt);
          
          // Get the nodes on the element
          const unsigned nnodes = ele_pt->nnode();
          for (unsigned j = 0; j < nnodes; j++)
           {
            Node* node_pt = ele_pt->node_pt(j);
            
            // Package the info. of the nodes
            // The destination processor goes in the arguments
            add_haloed_node_helper(iproc, node_pt);
            
           } // for (j < nnodes)
            
         } // add the element and send its nodes
        else // The haloed element already exists
         {
          Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
          Flat_packed_unsigneds_string.push_back("Haloed element already exists");
#endif
          Flat_packed_unsigneds.push_back(haloed_ele_index);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
          Flat_packed_unsigneds_string.push_back("Index of existing haloed element");
#endif
         } // else (next_haloed_ele == external_haloed_ele_index)
          
       } // for (e < n_additional_haloed_ele)
      
      // Send and received the additional haloed elements (all
      // processors send and receive)
      
      // The processor to which send the elements
      int send_proc = static_cast<int>(iproc);
      // The processor from which receive the elements
      int recv_proc = static_cast<int>(iproc);
      send_and_receive_elements_nodes_info(send_proc, recv_proc);
      
      // Reset the counters
      Counter_for_flat_packed_doubles=0;
      Counter_for_flat_packed_unsigneds=0;
      
      // Get the number of additional halo element to be created
      const unsigned n_additional_halo_ele = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << " Number of elements need to be constructed " 
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      
      // Create the additional halo elements
      for (unsigned e = 0; e < n_additional_halo_ele; e++)
       {
        // Create halo element from received info. of "iproc"
        // processor on the current processor
         create_halo_element(iproc,
                             iproc_currently_created_nodes_pt[iproc],
                             other_proc_shd_bnd_node_pt,
                             global_node_names,
                             node_name_to_global_index,
                             global_shared_node_pt);
        
       } // for (e < n_additional_halo_ele)
      
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc)
    
 }
  
 // *********************************************************************
 // Start communication functions
 // *********************************************************************
 
 //========start of get_required_elemental_information_helper==============
 /// \short Helper function to get the required elemental information from
 /// an haloed element. This info. involves the association of the element
 /// to a boundary or region.
 //========================================================================
 template<class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 get_required_elemental_information_helper(unsigned& iproc,
                                           FiniteElement* ele_pt)
 {
  // Check if the element is associated with the original boundaries
  const unsigned nbound = this->initial_shared_boundary_id();
  
  // ------------------------------------------------------------------
  // Stores the information regarding the boundaries associated to the
  // element (it that is the case)
  Vector<unsigned> associated_boundaries;
  Vector<unsigned> face_index_on_boundary;
  
  unsigned counter_face_indexes = 0;
  
  for (unsigned b = 0; b < nbound; b++)
   {
    // Get the number of elements associated to boundary i
    const unsigned nboundary_ele = nboundary_element(b);
    for (unsigned e = 0; e < nboundary_ele; e++)
     {
      if (ele_pt == this->boundary_element_pt(b,e))
       {
        // Keep track of the boundaries associated to the element
        associated_boundaries.push_back(b);
        // Get the face index
        face_index_on_boundary.push_back(face_index_at_boundary(b,e));
        counter_face_indexes++;
#ifdef PARANOID
        if (counter_face_indexes > 2)
         {
          std::stringstream error_message;
          error_message
           << "A triangular element can not have more than two of its faces "
           << "on a boundary!!!\n\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
         }
#else
        // Already found 2 face indexes on the same boundary?
        if (counter_face_indexes==2) {break;}
#endif // #ifdef PARANOID
        
       } // if (ele_pt == this->boundary_element_pt(b,e))
      
     } // (e < nboundary_ele)
    
   }   // (b < nbound)
  
  // If the element is associated to any boundary then package all the
  // relevant info
  const unsigned nassociated_boundaries = associated_boundaries.size();
  if (nassociated_boundaries > 0)
   {
    Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    Flat_packed_unsigneds_string.push_back("The element is a boundary element");
#endif
    Flat_packed_unsigneds.push_back(nassociated_boundaries);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    std::stringstream junk;
    junk << "The elements is associated to " << nassociated_boundaries << " boundaries";
    Flat_packed_unsigneds_string.push_back(junk.str());
#endif
    
    // Package the ids of the associated boundaries and the
    // corresponding face index for each boundary (if the element is a
    // corner element, it will have two faces associated to the
    // boundary)
    for (unsigned i = 0; i < nassociated_boundaries; i++)
     {
      unsigned b = associated_boundaries[i];
      Flat_packed_unsigneds.push_back(b);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk;
      junk << "Element associated to boundary " << b << " of " << nassociated_boundaries << " total associated boundaries";
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif
      unsigned f = face_index_on_boundary[i];
      Flat_packed_unsigneds.push_back(f);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk2;
      junk2 << "Face index " << f << " for associated boundary " << b;
      Flat_packed_unsigneds_string.push_back(junk2.str());
#endif
     }
    
    // If the element is associated to any boundary then we should
    // check if the mesh has regions, if that is the case then we need
    // to check to which region the boundary element does belong
    
    // If the mesh has regions we should look for the element
    // associated to a boundary and a specified region
    Vector<Vector<unsigned> > associated_boundaries_and_regions;
    Vector<unsigned> face_index_on_boundary_and_region;
    
    // Now check for the case when we have regions in the mesh
    const unsigned n_regions = this->nregion();
    if (n_regions >  1)
     {
      // Used to count the number of faces associated with
      // boundary-regions
      unsigned counter_face_indexes_in_regions = 0;
      // Loop over the boundaries
      for (unsigned b = 0; b < nbound; b++)
       {
        // Go through each region by getting the region id
        for (unsigned i_reg = 0 ; i_reg < n_regions; i_reg++)
         {
          // Get thre region id associated with the (i_reg)-th region
          const unsigned region_id = 
           static_cast<unsigned>(this->Region_attribute[i_reg]);
        
          // Loop over all elements associated with the current boundary
          // and the i_reg-th region and check if the element is part of
          // any region
          const unsigned nele_in_region = 
           this->nboundary_element_in_region(b, region_id);
          for (unsigned ee = 0; ee < nele_in_region; ee++)
           {
            // Check if the boundary-region element is the same as the
            // element
            if (ele_pt == 
                this->boundary_element_in_region_pt(b, region_id, ee))
             {
              // Storage for the boundary and region associated to the
              // element
              Vector<unsigned> bound_and_region(2);
            
              // Keep track of the boundaries associated to the element
              bound_and_region[0] = b;
              // Keep track of the regions associated to the element
              bound_and_region[1] = region_id;
              // Add the boundaries and regions in the storage to be
              // sent to other processors
              associated_boundaries_and_regions.push_back(bound_and_region);
              // Get the face index and keep track of it
              face_index_on_boundary_and_region.push_back(
               this->face_index_at_boundary_in_region(b,region_id,ee));
            
              // Increase the number of faces of the element associated
              // to boundary-regions
              counter_face_indexes_in_regions++;
            
#ifdef PARANOID
              if (counter_face_indexes_in_regions > 2)
               {
                std::stringstream error_message;
                error_message
                 << "A triangular element can not have more than two of its\n"
                 << "faces on a boundary!!!\n\n";
                throw OomphLibError(error_message.str(),
                                    OOMPH_CURRENT_FUNCTION,
                                    OOMPH_EXCEPTION_LOCATION);
               } // if (counter_face_indexes_in_regions > 2)
#endif
              
             } // The element is a boundary-region element
            
           } // for (ee < nele_in_region)
          
         } // for (i_reg < n_regions)
        
       } // for (b < nbound)
      
     } // if (n_regions >  1)
    
    // Now package the info. to be sent to other processors
    const unsigned nassociated_boundaries_and_regions = 
     associated_boundaries_and_regions.size();
    if (nassociated_boundaries_and_regions > 0)
     {
      Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.push_back("The element is associated to boundaries and regions");
#endif
      
      Flat_packed_unsigneds.push_back(nassociated_boundaries_and_regions);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk;
      junk << "The element is associated to " << nassociated_boundaries_and_regions << " boundaries-regions";
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif
      
      // Package the ids of the associated boundaries, regions and the
      // corresponding face index for each boundary-region (if the
      // element is a corner element, it will have two faces
      // associated to the boundary-region)
      for (unsigned i = 0; i < nassociated_boundaries_and_regions; i++)
       {
        const unsigned b = associated_boundaries_and_regions[i][0];
        Flat_packed_unsigneds.push_back(b);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        std::stringstream junk;
        junk << "Element associated to boundary " << b << " of " << nassociated_boundaries_and_regions << " total associated boundaries-regions";
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif
        
        const unsigned r = associated_boundaries_and_regions[i][1];
        Flat_packed_unsigneds.push_back(r);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        std::stringstream junk2;
        junk2 << "Element associated to region " << r << " of " << nassociated_boundaries_and_regions << " total associated boundaries-regions";
        Flat_packed_unsigneds_string.push_back(junk2.str());
#endif
        
        const unsigned f = face_index_on_boundary_and_region[i];
        Flat_packed_unsigneds.push_back(f);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        std::stringstream junk3;
        junk3 << "Face index " << f << " for associated boundary-region (" << b << "-" << r << ")";
        Flat_packed_unsigneds_string.push_back(junk3.str());
#endif
       } // for (i < nassociated_boundaries_and_regions)
     } // if (nassociated_boundaries_and_regions > 0)
    else
     {
      Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.push_back("The element is NOT associated to boundaries and regions");
#endif
     } // else if (nassociated_boundaries_and_regions > 0)
    
   }
  else
   {
    Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    Flat_packed_unsigneds_string.push_back("The element is not associated to any original boundary");
#endif
   }
  
  // ------------------------------------------------------------
  // Now review if the element is associated to a shared boundary
  
  // Store the shared boundaries, and therefore the face indexes
  // associated to the element
  Vector<unsigned> associated_shared_boundaries;
  Vector<unsigned> face_index_on_shared_boundary;
  
  // Get the shared boundaries in this processor
  Vector<unsigned> my_rank_shared_boundaries_ids;
  this->shared_boundaries_in_this_processor(my_rank_shared_boundaries_ids);
  
  // Get the number of shared boundaries
  const unsigned nmy_rank_shd_bnd = my_rank_shared_boundaries_ids.size();
  // Loop over the shared boundaries
  for (unsigned i = 0; i < nmy_rank_shd_bnd; i++)
   {
    // Get the boundary id
    const unsigned sb = my_rank_shared_boundaries_ids[i];
      
    // Get the number of elements associated to shared boundary sb
    const unsigned nboundary_ele = this->nshared_boundary_element(sb);
    for (unsigned e = 0; e < nboundary_ele; e++)
     {
      if (ele_pt == this->shared_boundary_element_pt(sb,e))
       {
        // Keep track of the boundaries associated to the element
        associated_shared_boundaries.push_back(sb);
        // Get the face index
        face_index_on_shared_boundary.push_back(
         this->face_index_at_shared_boundary(sb, e));
       }
     } // (e < nboundary_ele)
   } // (i < nmy_rank_shd_bnd)
  
  // If the element is associated to a shared boundary then package
  // all the relevant info
  const unsigned nassociated_shared_boundaries = 
   associated_shared_boundaries.size();
  if (nassociated_shared_boundaries > 0)
   {
    Flat_packed_unsigneds.push_back(3);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    Flat_packed_unsigneds_string.push_back("The element is a shared boundary element");
#endif
    Flat_packed_unsigneds.push_back(nassociated_shared_boundaries);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    std::stringstream junk;
    junk << "The elements is associated to " << nassociated_shared_boundaries << "shared boundaries";
    Flat_packed_unsigneds_string.push_back(junk.str());
#endif
      
    // Package the ids of the associated boundaries
    for (unsigned i = 0; i < nassociated_shared_boundaries; i++)
     {
      const unsigned b = associated_shared_boundaries[i];
      Flat_packed_unsigneds.push_back(b);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk;
      junk << "Element associated to shared boundary " << b << " of " << nassociated_shared_boundaries << " total associated boundaries";
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif
        
      const unsigned f = face_index_on_shared_boundary[i];
      Flat_packed_unsigneds.push_back(f);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk2;
      junk2 << "Face index " << f << " for associated shared boundary " << b;
      Flat_packed_unsigneds_string.push_back(junk2.str());
#endif
     }
   }
  else
   {
    Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    Flat_packed_unsigneds_string.push_back("The element is not associated to any shared boundary");
#endif
   }
  
 }
 
 //========start of get_required_nodal_information_helper==================
 /// Helper function to get the required nodal information from an
 /// haloed node so that a fully-functional halo node (and therefore element)
 /// can be created on the receiving process
 //========================================================================
 template<class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 get_required_nodal_information_helper(unsigned& iproc, 
                                       Node* nod_pt)
 {
  unsigned my_rank = this->communicator_pt()->my_rank();
  const unsigned nproc = this->communicator_pt()->nproc();
  
  // Tell the halo copy of this node how many values there are
  // [NB this may be different for nodes within the same element, e.g.
  //  when using Lagrange multipliers]
  unsigned n_val=nod_pt->nvalue();
  Flat_packed_unsigneds.push_back(n_val);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
  Flat_packed_unsigneds_string.push_back("Number of values");
#endif
  
  unsigned n_dim=nod_pt->ndim();
  
  // Default number of previous values to 1
  unsigned n_prev=1;
  if (this->Time_stepper_pt!=0)
   {
    // Add number of history values to n_prev
    n_prev=this->Time_stepper_pt->ntstorage();
   }
  
  // -----------------------------------------------------
  // Is the node on an original boundary?
  // Store the original boundaries where the node may be
  Vector<unsigned> original_boundaries;
  // Loop over the original boundaries of the mesh and check if live
  // on one of them
  const unsigned n_bnd = this->initial_shared_boundary_id();
  for (unsigned bb=0;bb<n_bnd;bb++)
   {
    // Which boundaries (could be more than one) is it on?
    if (nod_pt->is_on_boundary(bb))
     {
      original_boundaries.push_back(bb);
     }
    
   }
  
  const unsigned n_original_boundaries = original_boundaries.size();
  // Is the node on any original boundary?
  if (n_original_boundaries > 0)
   {
    // Indicate that the node is on an original boundary
    Flat_packed_unsigneds.push_back(2);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    Flat_packed_unsigneds_string.push_back("Node is on the original boundaries");
#endif
    
    Flat_packed_unsigneds.push_back(n_original_boundaries);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    std::stringstream junk;
    junk << "Node is on "<< n_original_boundaries << " original boundaries";
    Flat_packed_unsigneds_string.push_back(junk.str());
#endif
    
    // Loop over the original boundaries the node is on
    for (unsigned i=0;i<n_original_boundaries;i++)
     {
      Flat_packed_unsigneds.push_back(original_boundaries[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk;
      junk<<"Node is on boundary "<<original_boundaries[i]<<" of "<< nb;
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif
      // Get the boundary coordinate of the node
      Vector<double> zeta(1);
      nod_pt->get_coordinates_on_boundary(original_boundaries[i],zeta);
      Flat_packed_doubles.push_back(zeta[0]);
     }
   }
  else
   {
    // Indicate that the node is NOT on an original boundary
    Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    Flat_packed_unsigneds_string.push_back("Node is on any original boundary");
#endif
   }
  
  // -------------------------------------------------------
  // Is the node on shared boundaries?
  bool node_on_shared_boundary = false;
  // Loop over the shared boundaries with the iproc processors and
  // check if live on one of them
  const unsigned n_shd_bnd = this->nshared_boundaries(my_rank, iproc);
  for (unsigned bb=0;bb<n_shd_bnd;bb++)
   {
    // Get the boundary id
    unsigned i_bnd = this->shared_boundaries_ids(my_rank, iproc, bb);
    // Which boundaries (could be more than one) is it on?
    if (this->is_node_on_shared_boundary(i_bnd, nod_pt))
     {
      node_on_shared_boundary = true;
      break;
     }
   }
  
  // If the node live on any of the shared boundaries with the iproc
  // processor then just get the node number according to the
  // sorted_shared_boundary_node_pt() scheme and send it accross
  if (node_on_shared_boundary)
   {
    Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    Flat_packed_unsigneds_string.push_back("Node is on shared boundary");
#endif
    
    // Store the shared boundaries where the node is on
    Vector<unsigned> shd_boundaries;
    // Loop over the shared boundaries with the iproc processor
    for (unsigned bb = 0; bb < n_shd_bnd; bb++)
     {
      // Get the boundary id
      const unsigned i_bnd = 
       this->shared_boundaries_ids(my_rank, iproc, bb);
      // Which boundaries (could be more than one) is it on?
      if (this->is_node_on_shared_boundary(i_bnd, nod_pt))
       {
        shd_boundaries.push_back(i_bnd);
       }
     }
    
    // Get the number of shared boundaries the node is on
    const unsigned n_shd_bnd_is_on = shd_boundaries.size();
    // Send the number of shared boundaries the node is on
    Flat_packed_unsigneds.push_back(n_shd_bnd_is_on);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    std::stringstream junk;
    junk << "Node is on "<< n_shd_bnd_is_on << " shared boundaries";
    Flat_packed_unsigneds_string.push_back(junk.str());
#endif
    
    // Loop over the shared boundaries to send their ids
    for (unsigned i=0;i<n_shd_bnd_is_on;i++)
     {
      Flat_packed_unsigneds.push_back(shd_boundaries[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk;
      junk << "Node is on boundary " << shd_boundaries[i] << " of " << nb;
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif
     }
    
    // Given that the node is on at least one boundary get the index
    // of the node in one of the boundaries and send this index
    unsigned shared_boundary_id = shd_boundaries[0];
    // Get the number of nodes on the given shared boundary
    const unsigned n_nodes_on_shared_boundary = 
     nsorted_shared_boundary_node(shared_boundary_id);
    // Store the index of the node on the shared boundary
    unsigned index_node_on_shared_boundary;
#ifdef PARANOID
    // Flag to know if the node has been found
    bool found_index_node_on_shared_boundary = false;
#endif
    // Loop over the nodes on the shared boundary to find the node
    for (unsigned i = 0; i < n_nodes_on_shared_boundary; i++)
     {
      // Get the i-th node on the shared boundary
      Node* shared_node_pt = 
       sorted_shared_boundary_node_pt(shared_boundary_id, i);
      // Is the node we are looking for
      if (shared_node_pt == nod_pt)
       {
        // Store the index
        index_node_on_shared_boundary = i;
#ifdef PARANOID
        // Mark as found
        found_index_node_on_shared_boundary = true;
#endif
        break; // break
       }
      
     } // for (i < nnodes_on_shared_boundary)
    
#ifdef PARANOID
    if (!found_index_node_on_shared_boundary)
     {
      std::ostringstream error_message;
      error_message
       <<"The index of the node on boundary ("
       <<shared_boundary_id<<") was not found.\n"
       <<"The node coordinates are ("<<nod_pt->x(0)<<","
       <<nod_pt->x(1)<<").\n";
      throw OomphLibError(
       error_message.str(),
       "RefineableTriangleMesh::get_required_nodal_information_helper()",
       OOMPH_EXCEPTION_LOCATION);
     }
#endif 
    // Send the index of the node on the shared boundary
    Flat_packed_unsigneds.push_back(index_node_on_shared_boundary);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    std::stringstream junk2;
    junk2 << "Node index on boundary "<<boundaries[0]<<" is "
          <<index_node_on_shared_boundary;
    Flat_packed_unsigneds_string.push_back(junk2.str());
#endif
    
   } // if (node_on_shared_boundary)
  else
   {
    // The node is not on a shared boundary
    Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    Flat_packed_unsigneds_string.push_back("Node is not on a shared boundary");
#endif
   }
  
  // ----------------------------------------------------------------
  // Is the node on any shared boundary where the receiver processor
  // is not involved? 

  // Now check if the node is on a shared boundary created by the
  // current processor (my_rank) and other processor different that
  // the iproc processor. This info. will help to complete the sending
  // of halo(ed) information between processors
  
  // Flag to know if the node is on a shared boundary with other
  // processor
  bool node_on_shared_boundary_with_other_processors = false;
  // Count the number of other shared boundaries it could be on
  unsigned nshared_boundaries_with_other_processors_have_node = 0;
  
  // Loop over the shared boundaries of the sent processor (my_rank)
  // and other processors (jproc)
  for (unsigned jproc = 0; jproc < nproc; jproc++)
   {
    // Do not search with the iproc processor , that was done before
    // above because we are sending info to that processor
    if (jproc != iproc)
     {
      // Get the number of shared boundaries with the jproc processor
      const unsigned n_jshd_bnd = 
       this->nshared_boundaries(my_rank, jproc);
      // Loop over the shared boundaries
      for (unsigned bb=0;bb<n_jshd_bnd;bb++)
       {
        // Get the boundary id
        const unsigned j_shd_bnd = 
         this->shared_boundaries_ids(my_rank, jproc, bb);
        // Is the node part of this boundary?
        if (this->is_node_on_shared_boundary(j_shd_bnd, nod_pt))
         {
//           DEBP("Sending to");
//           DEBP(iproc);
//           DEBP("Pair of procs where other shared");
//           DEBP(my_rank);
//           DEBP(jproc);
//           DEBP(i_bnd);
          node_on_shared_boundary_with_other_processors = true;
          // Increase the counter for the number of shared boundaries
          // with other processors the node is on
          nshared_boundaries_with_other_processors_have_node++;
         } // if (this->is_node_on_shared_boundary(j_shd_bnd, nod_pt)
        
       } // for (bb<n_jshd_bnd)
      
     } // if (jproc != iproc)
    
   } // for (jproc < nproc)
  
  // If the node is on a shared boundary with another processor
  // (my_rank, jproc), then send the flag and look for the info.
  if (node_on_shared_boundary_with_other_processors)
   {
    Flat_packed_unsigneds.push_back(4);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    Flat_packed_unsigneds_string.push_back("Node is on shared boundary no related with the received processor: 4");
#endif
    
    // The number of packages of information that will be sent to the
    // "iproc" processor. This helps to know how many packages of data
    // read from the received processor
    Flat_packed_unsigneds.push_back(nshared_boundaries_with_other_processors_have_node);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    std::stringstream junk;
    junk << "Number of other shared boundaries that the node is on: " 
         << nshared_boundaries_with_other_processors_have_node;
    Flat_packed_unsigneds_string.push_back(junk.str());
#endif
    
    // Counter to ensure that the correct number of data has been sent
    unsigned counter_shd_bnd_with_other_procs_have_node = 0;
    // Loop over the shared boundaries with other processors and get:
    // 1) The processors defining the shared boundary
    // 2) The shared boundary id
    // 3) The index of the node on the shared boundary
    Vector<unsigned> other_processor_1;
    Vector<unsigned> other_processor_2;
    Vector<unsigned> shd_bnd_ids;
    Vector<unsigned> indexes;
    // Loop over the processors again
    for (unsigned jproc = 0; jproc < nproc; jproc++)
     {
      // Do not search with the iproc processor, that was done before
      // above
      if (jproc != iproc)
       {
        // Get the number of shared boundaries with the jproc
        // processor
        const unsigned n_jshd_bnd = 
         this->nshared_boundaries(my_rank, jproc);
        for (unsigned bb = 0; bb < n_jshd_bnd; bb++)
         {
          // Get the boundary id
          const unsigned j_shd_bnd = 
           this->shared_boundaries_ids(my_rank, jproc, bb);
          // Is the node part of this boundary?
          if (this->is_node_on_shared_boundary(j_shd_bnd, nod_pt))
           {
            // Include the first processor
            other_processor_1.push_back(my_rank);
            // Include the second processor
            other_processor_2.push_back(jproc);
            // Include the shared boundary id
            shd_bnd_ids.push_back(j_shd_bnd);
            // Increase the counter for found shared boundaries with
            // other processors
            counter_shd_bnd_with_other_procs_have_node++;
           }
          
         } // for (bb < nshared_bnd)
        
       } // if (jproc != iproc)
      
     } // for (jproc < nproc)
    
    // Get the indexes of the node on all the shared boundaries where
    // it was found
    const unsigned n_other_processors = other_processor_1.size();
    // Loop over the processors where the node was found
    for (unsigned i = 0; i < n_other_processors; i++)
     {
      // Get the shared boundary id
      unsigned shd_bnd_id = shd_bnd_ids[i];
      // Get the number of nodes on that shared boundary
      const unsigned n_nodes_on_shd_bnd = 
       nsorted_shared_boundary_node(shd_bnd_id);
      
#ifdef PARANOID
      bool found_index_node_on_shared_boundary = false;
#endif
      for (unsigned i = 0; i < n_nodes_on_shd_bnd; i++)
       {
        // Get the i-th shared boundary node
        Node* shared_node_pt = 
         sorted_shared_boundary_node_pt(shd_bnd_id, i);
        // Is the same node?
        if (shared_node_pt == nod_pt)
         {
//             DEBP(i_node);
//             DEBP(nod_pt->x(0));
//             DEBP(nod_pt->x(1));
          // Include the index of the node
          indexes.push_back(i);
#ifdef PARANOID
          // Mark as found the node
          found_index_node_on_shared_boundary = true;
#endif
          break;  
         } // if (shared_node_pt == nod_pt)
        
       } // for (i < n_nodes_on_shd_bnd)
      
#ifdef PARANOID
      if (!found_index_node_on_shared_boundary)
       {
        std::ostringstream error_message;
        error_message
         <<"The index of the node on boundary ("
         <<shd_bnd_id<<"), shared by other processors\nwas not found.\n"
         <<"The node coordinates are ("<<nod_pt->x(0)<<","
         <<nod_pt->x(1)<<").\n";
        throw OomphLibError(
         error_message.str(),
         "RefineableTriangleMesh::get_required_nodal_information_helper()",
         OOMPH_EXCEPTION_LOCATION);
       }
#endif
     } // for (i < n_other_processors)
    
    // Now send the info. but first check that the number of found
    // nodes be the same that the previously found shared boundaries
    // with the node
#ifdef PARANOID
    if (counter_shd_bnd_with_other_procs_have_node !=
        nshared_boundaries_with_other_processors_have_node)
     {
      std::ostringstream error_message;
      error_message
       <<"The number of shared boundaries where the node is on "
       <<"is different:\n"
       << "nshared_boundaries_with_other_processors_have_node: ("
       << nshared_boundaries_with_other_processors_have_node
       << ")\n"
       << "counter_shd_bnd_with_other_procs_have_node: ("
       << counter_shd_bnd_with_other_procs_have_node
       << ")\n";
      throw OomphLibError(
       error_message.str(),
       "RefineableTriangleMesh::get_required_nodal_information_helper()",
       OOMPH_EXCEPTION_LOCATION);
     } // if (counter_shd_bnd_with_other_procs_have_node !=
       // nshared_boundaries_with_other_processors_have_node)
#endif
    
    // Loop over the info. to send it
    for (unsigned i = 0; i < n_other_processors; i++)
     {
      Flat_packed_unsigneds.push_back(other_processor_1[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk1;
      junk1 << "Processor where the other shared boundary "
            << "has the node: " << other_processor_1[i];
      Flat_packed_unsigneds_string.push_back(junk1.str());
#endif
        
      Flat_packed_unsigneds.push_back(other_processor_2[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk2;
      junk2 << "Processor where the other shared boundary "
            << "has the node: " << other_processor_2[i];
      Flat_packed_unsigneds_string.push_back(junk2.str());
#endif
        
      Flat_packed_unsigneds.push_back(shd_bnd_ids[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk3;
      junk3 << "Other shared boundary id where the node is on" 
            << boundaries[i];
      Flat_packed_unsigneds_string.push_back(junk3.str());
#endif
        
      Flat_packed_unsigneds.push_back(indexes[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk4;
      junk4 << "Node index on other shared boundary " 
            <<boundaries[i] << " is "
            << indexes[i];
      Flat_packed_unsigneds_string.push_back(junk4.str());
#endif
        
     } // for (i < n_other_processors)
    
   } // if (node_on_shared_boundary_with_other_processors)
  else
   {
    Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    Flat_packed_unsigneds_string.push_back("Node is on any shared boundary with other processors");
#endif
   } // else if (node_on_shared_boundary_with_other_processors)
  
  // Now check if it is required to send the info. of the node. If the
  // node is not on a shared boundary with the iproc processor then we
  // need to send the info.
  
  if (!node_on_shared_boundary)
   {
    // Send all the info. to create it
    
    // Is the Node algebraic?  If so, send its ref values and
    // an indication of its geometric objects if they are stored
    // in the algebraic mesh
    AlgebraicNode* alg_nod_pt=dynamic_cast<AlgebraicNode*>(nod_pt);
    if (alg_nod_pt!=0)
     {
      // The external mesh should be algebraic
      AlgebraicMesh* alg_mesh_pt=dynamic_cast<AlgebraicMesh*>(this);

      // Get default node update function ID
      unsigned update_id=alg_nod_pt->node_update_fct_id();
      Flat_packed_unsigneds.push_back(update_id);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.push_back("Alg Node update id");
#endif

      // Get reference values at default...
      unsigned n_ref_val=alg_nod_pt->nref_value();
      Flat_packed_unsigneds.push_back(n_ref_val);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.push_back("Alg Node n ref values");
#endif
      for (unsigned i_ref_val=0;i_ref_val<n_ref_val;i_ref_val++)
       {
        Flat_packed_doubles.push_back(alg_nod_pt->ref_value(i_ref_val));
       }

      // Access geometric objects at default...
      unsigned n_geom_obj=alg_nod_pt->ngeom_object();
      Flat_packed_unsigneds.push_back(n_geom_obj);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.push_back("Alg Node n geom objects");
#endif
      for (unsigned i_geom=0;i_geom<n_geom_obj;i_geom++)
       {
        GeomObject* geom_obj_pt=alg_nod_pt->geom_object_pt(i_geom);

        // Check this against the stored geometric objects in mesh
        unsigned n_geom_list=alg_mesh_pt->ngeom_object_list_pt();

        // Default found index to zero
        unsigned found_geom_object=0;
        for (unsigned i_list=0;i_list<n_geom_list;i_list++)
         {
          if (geom_obj_pt==alg_mesh_pt->geom_object_list_pt(i_list))
           {
            found_geom_object=i_list;
           }
         }
        Flat_packed_unsigneds.push_back(found_geom_object);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        Flat_packed_unsigneds_string.push_back("Found geom object");
#endif
       }
     } // (if alg_nod_pt!=0)

    // Is it a SolidNode?
    SolidNode* solid_nod_pt=dynamic_cast<SolidNode*>(nod_pt);
    if (solid_nod_pt!=0)
     {
      unsigned n_solid_val=solid_nod_pt->variable_position_pt()->nvalue();
      for (unsigned i_val=0;i_val<n_solid_val;i_val++)
       {
        for (unsigned t=0;t<n_prev;t++)
         {
          Flat_packed_doubles.push_back(solid_nod_pt->variable_position_pt()->
                                        value(t,i_val));
         }
       }
      
      Vector<double> values_solid_node;
      solid_nod_pt->add_values_to_vector(values_solid_node);
      const unsigned nvalues_solid_node = values_solid_node.size();
      Flat_packed_unsigneds.push_back(nvalues_solid_node);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk;
      junk << "Number of values solid node: "
           << nvalues_solid_node;
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif
      for (unsigned i = 0; i < nvalues_solid_node; i++)
       {
        Flat_packed_doubles.push_back(values_solid_node[i]);
       }
     }
    
    // Finally copy info required for all node types
    for (unsigned i_val=0;i_val<n_val;i_val++)
     {
      for (unsigned t=0;t<n_prev;t++)
       {
        Flat_packed_doubles.push_back(nod_pt->value(t,i_val));
       }
     }

    // Now do positions
    for (unsigned idim=0;idim<n_dim;idim++)
     {
      for (unsigned t=0;t<n_prev;t++)
       {
        Flat_packed_doubles.push_back(nod_pt->x(t,idim));
       }
     }
    
   } // if (!node_on_shared_boundary)
  
 }

 //==========start of add_haloed_node_helper===============================
 /// Helper to add external haloed node that is not a master
 //========================================================================
 template<class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 add_haloed_node_helper(unsigned& iproc, Node* nod_pt)
 {
  // Attempt to add this node as a haloed node
  const unsigned n_haloed_nod = this->nhaloed_node(iproc);
  const unsigned haloed_node_index = 
   this->try_to_add_haloed_node_pt(iproc,nod_pt);

  // If it was added then the new index should match the size of the storage
  if (haloed_node_index==n_haloed_nod)
   {
    Flat_packed_unsigneds.push_back(1);

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    std::stringstream junk;
    junk << "Node needs to be constructed [size=" 
         << Flat_packed_unsigneds.size() << "]; last entry: "
         << Flat_packed_unsigneds[Flat_packed_unsigneds.size()-1];
    Flat_packed_unsigneds_string.push_back(junk.str());
#endif

    // This helper function gets all the required information for the 
    // specified node and stores it into MPI-sendable information
    // so that a halo copy can be made on the receiving process
    get_required_nodal_information_helper(iproc, nod_pt);
   }
  else // It was already added
   {
    Flat_packed_unsigneds.push_back(0); 
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    std::stringstream junk;
    junk << "Node was already added [size=" 
         << Flat_packed_unsigneds.size() << "]; last entry: "
         << Flat_packed_unsigneds[Flat_packed_unsigneds.size()-1];

    Flat_packed_unsigneds_string.push_back(junk.str());
#endif
    
    // This node is already a haloed node, so tell
    // the other process its index in the equivalent halo storage
    Flat_packed_unsigneds.push_back(haloed_node_index);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    Flat_packed_unsigneds_string.push_back("haloed node index");
#endif
   }

 }

 //================= send_and_receive_haloed_info =======================
 /// Send the information of the elements that will be created on the other
 /// processor
 //======================================================================
 template<class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 send_and_receive_elements_nodes_info(int &send_proc, int &recv_proc)
 {
  // Get the communicator of the mesh
  OomphCommunicator* comm_pt = this->communicator_pt();
  
  // Set MPI info
  MPI_Status status;
  MPI_Request request;
  
  // Prepare vectors to receive information
  Vector<double> received_double_values;
  Vector<unsigned> received_unsigned_values;
  
  // Send the double values associated with halo(ed) elements and nodes
  //-------------------------------------------------------------------
  unsigned send_count_double_values=Flat_packed_doubles.size(); 
  MPI_Isend(&send_count_double_values,1,MPI_UNSIGNED,
            send_proc,1,comm_pt->mpi_comm(),&request);

  int receive_count_double_values=0;
  MPI_Recv(&receive_count_double_values,1,MPI_INT,
           recv_proc,1,comm_pt->mpi_comm(),&status);
  MPI_Wait(&request,MPI_STATUS_IGNORE);
  
  if (send_count_double_values!=0)
   {
    MPI_Isend(&Flat_packed_doubles[0],send_count_double_values,MPI_DOUBLE,
              send_proc,2,comm_pt->mpi_comm(),&request);
   }
  if (receive_count_double_values!=0)
   {
    received_double_values.resize(receive_count_double_values);
    MPI_Recv(&received_double_values[0],receive_count_double_values,
             MPI_DOUBLE,recv_proc,2,comm_pt->mpi_comm(),&status);
   }
  if (send_count_double_values!=0)
   {
    MPI_Wait(&request,MPI_STATUS_IGNORE);
   }
  
  // Now send unsigned values associated with halo(ed) elements and nodes
  //---------------------------------------------------------------------
  unsigned send_count_unsigned_values=Flat_packed_unsigneds.size();
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
  unsigned send_count_unsigned_string=Flat_packed_unsigneds_string.size();
#ifdef PARANOID
  if (send_count_unsigned_string != send_count_unsigned_values)
   {
    std::ostringstream error_message;
    error_message
     << "The number of unsigned values to send to processor ("
     << send_proc << ") is different from the\nnumber of annotated strings "
     << "for the communication\n\n";
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
   }
#endif // #ifdef PARANOID
#endif
  MPI_Isend(&send_count_unsigned_values,1,MPI_UNSIGNED,
            send_proc,14,comm_pt->mpi_comm(),&request);
  
  int receive_count_unsigned_values=0;
  MPI_Recv(&receive_count_unsigned_values,1,MPI_INT,recv_proc,14,
           comm_pt->mpi_comm(),&status);
  
  MPI_Wait(&request,MPI_STATUS_IGNORE);

  if (send_count_unsigned_values!=0)
   {     
    MPI_Isend(&Flat_packed_unsigneds[0],send_count_unsigned_values,
              MPI_UNSIGNED,send_proc,15,comm_pt->mpi_comm(),&request);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    for (unsigned i=0;i<send_count_unsigned_values;i++)
     {
      oomph_info << "Sent:" << i << " to orig_proc:" << send_proc
                 << " " << Flat_packed_unsigneds_string[i] 
                 << ": " << Flat_packed_unsigneds[i] << std::endl;
     }
#endif
   }
  if (receive_count_unsigned_values!=0)
   {
    received_unsigned_values.resize(receive_count_unsigned_values);
    MPI_Recv(&received_unsigned_values[0],receive_count_unsigned_values,
             MPI_UNSIGNED,recv_proc,15,comm_pt->mpi_comm(),&status);
   }
  
  if (send_count_unsigned_values!=0)
   {
    MPI_Wait(&request,MPI_STATUS_IGNORE);
   }
  
  // Copy across into original containers -- these can now
  //------------------------------------------------------
  // be processed by create_external_halo_elements() to generate
  //------------------------------------------------------------
  // external halo elements
  //------------------------
  Flat_packed_doubles.resize(receive_count_double_values);
  for (int ii=0;ii<receive_count_double_values;ii++)
   {
    Flat_packed_doubles[ii]=received_double_values[ii];
   }
  Flat_packed_unsigneds.resize(receive_count_unsigned_values);
  for (int ii=0;ii<receive_count_unsigned_values;ii++)
   {
    Flat_packed_unsigneds[ii]=received_unsigned_values[ii];     
   }
  
 }
 
 //=====================================================================
 /// Creates (halo) element on the loop process based on the
 /// information received from each processor
 //=====================================================================
 template<class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
  create_halo_element(unsigned& iproc,
                      Vector<Node*> &new_nodes_on_domain,
                      Vector<Vector<Vector<std::map<unsigned, Node*> > > > 
                      &other_proc_shd_bnd_node_pt,
                      Vector<Vector<Vector<unsigned> > > 
                      &global_node_names,
                      std::map<Vector<unsigned>, unsigned> 
                      &node_name_to_global_index,
                      Vector<Node*> &global_shared_node_pt)
 {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
  oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
             << " Bool: New element needs to be constructed " 
             << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
             << std::endl;
#endif
  
  if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++]==1)
   {
    // Create a new element from the communicated values
    // and coords from the process that located zeta
    GeneralisedElement *new_el_pt= new ELEMENT;
    
    // Add the element, it is a new element in the mesh
    this->add_element_pt(new_el_pt);

    // Add halo element to this mesh
    this->add_root_halo_element_pt(iproc, new_el_pt);

    // Cast to the FE pointer
    FiniteElement* f_el_pt=dynamic_cast<FiniteElement*>(new_el_pt);

    // Check if new element is associated to any boundary
    this->add_halo_element_helper(iproc,f_el_pt);
    
    // Now we add nodes to the new element
    unsigned n_node=f_el_pt->nnode();
    
    for (unsigned j=0;j<n_node;j++)
     {
       Node* new_nod_pt=0;
       
       // Call the add halo node helper function
       add_halo_node_helper(new_nod_pt,
                            new_nodes_on_domain,
                            other_proc_shd_bnd_node_pt, 
                            iproc, j, f_el_pt,
                            global_node_names,
                            node_name_to_global_index,
                            global_shared_node_pt);
       
     } // for (j<n_nod)
    
   }
  else // the element already exists as halo
   {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info 
     << "Rec:" << Counter_for_flat_packed_unsigneds 
     << "  Index of existing halo element "
     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
     << std::endl;
#endif
    // The index itself is in Flat_packed_unsigneds[...]
    unsigned halo_ele_index=
     Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    
    // Use this index to get the element
    FiniteElement* f_el_pt=
     dynamic_cast<FiniteElement*>(this->root_halo_element_pt(iproc,
                                                             halo_ele_index));
    
    //If it's not a finite element die
    if(f_el_pt==0)
     {                 
      throw OomphLibError("Halo element is not a FiniteElement\n",
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     }
    
   } // else the element already exists as halo

 }

 //========start of add_halo_element_helper==============================
 /// \short Helper function to create (halo) elements on the loop 
 /// process based on the info received in send_and_received_located_info
 /// This function is in charge of verify if the element is associated to
 /// a boundary
 //======================================================================
 template<class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 add_halo_element_helper(unsigned& iproc, FiniteElement* ele_pt)
 {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
  oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
             << " Bool: Element is associated to an original boundary " 
             << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
             << std::endl;
#endif
  
  if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++]==1)
   {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info 
     << "Rec:" << Counter_for_flat_packed_unsigneds 
     << "  How many boundaries are associated with the element "
     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
     << std::endl;
#endif
    const unsigned nassociated_boundaries = 
     Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    
    for (unsigned b = 0; b < nassociated_boundaries; b++)
     {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info 
       << "Rec:" << Counter_for_flat_packed_unsigneds 
       << "  Boundary associated to the element "
       << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
       << std::endl;
#endif
      const unsigned bnd = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info 
       << "Rec:" << Counter_for_flat_packed_unsigneds 
       << "  Face index of the element "
       << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
       << std::endl;
#endif
      const unsigned face_index = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        
      // Associate the element with the boundary and establish as many
      // face indexes it has
      this->Boundary_element_pt[bnd].push_back(ele_pt);
      this->Face_index_at_boundary[bnd].push_back(face_index);
      
     } // (b < nassociated_boundaries)
    
    // Here read the info. regarding the boundary-region of the element
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
               << " Bool: Element is associated to a boundary-region " 
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    
    if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++]==1)
     {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info 
       << "Rec:" << Counter_for_flat_packed_unsigneds 
       << "  How many boundaries-regions are associated with the element "
       << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
       << std::endl;
#endif
      const unsigned nassociated_boundaries_and_regions = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
      for (unsigned br = 0; br < nassociated_boundaries_and_regions; br++)
       {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info 
         << "Rec:" << Counter_for_flat_packed_unsigneds 
         << "  Boundary associated to the element "
         << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
         << std::endl;
#endif
        const unsigned bnd = 
         Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info 
         << "Rec:" << Counter_for_flat_packed_unsigneds 
         << "  Region associated to the element "
         << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
         << std::endl;
#endif
        const unsigned region = 
         Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info 
         << "Rec:" << Counter_for_flat_packed_unsigneds 
         << "  Face index of the element in boundary-region "
         << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
         << std::endl;
#endif
        const unsigned face_index = 
         Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
        // Associate the element with the boundary-regions and establish
        // as many face indexes it has
        this->Boundary_region_element_pt[bnd][region].push_back(ele_pt);
        this->Face_index_region_at_boundary[bnd][region].push_back(face_index);
      
       } // for (br < nassociated_boundaries_and_regions)
    
     } // Is the element associated with a boundary-region?
    
   }
  
  // Now check if the element is associated to a shared boundary
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
  oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
             << " Bool: Element is associated to a shared boundary " 
             << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
             << std::endl;
#endif
  if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++]==3)
   {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info 
     << "Rec:" << Counter_for_flat_packed_unsigneds 
     << "  How many shared boundaries are associated with the element "
     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
     << std::endl;
#endif
    const unsigned nassociated_shared_boundaries = 
     Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    
    for (unsigned b = 0; b < nassociated_shared_boundaries; b++)
     {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info 
       << "Rec:" << Counter_for_flat_packed_unsigneds 
       << "  Shared boundary associated to the element "
       << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
       << std::endl;
#endif
      const unsigned bnd = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info 
       << "Rec:" << Counter_for_flat_packed_unsigneds 
       << "  Face index of the element associated to the shared boundary "
       << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
       << std::endl;
#endif
      
      const unsigned face_index = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
      this->add_shared_boundary_element(bnd, ele_pt);
      this->add_face_index_at_shared_boundary(bnd, face_index);
      
     } // (b < nassociated_shared_boundaries)
    
   } // The element is associted with a shared boundary
  
 }
 
 //========start of add_halo_node_helper==========================
 /// Helper function to add halo node
 //===============================================================
 template<class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::add_halo_node_helper
  (Node* &new_nod_pt,
   Vector<Node*> &new_nodes_on_domain,
   Vector<Vector<Vector<std::map<unsigned, Node*> > > > 
   &other_proc_shd_bnd_node_pt,
   unsigned& iproc, 
   unsigned& node_index,
   FiniteElement* const &new_el_pt,
   Vector<Vector<Vector<unsigned> > > &global_node_names,
   std::map<Vector<unsigned>, unsigned> &node_name_to_global_index,
   Vector<Node*> &global_shared_node_pt)
 {
  // Given the node, received information about them from process
  // iproc, construct them on the current process
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
  oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
             << " Bool: New node needs to be constructed " 
             << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
             << std::endl;
#endif
  if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++]==1)
   {
    // Construct a new node based upon sent information, or copy a node
    // from one of the shared boundaries
    construct_new_halo_node_helper(new_nod_pt, new_nodes_on_domain,
                                   other_proc_shd_bnd_node_pt,
                                   iproc, node_index, new_el_pt,
                                   global_node_names,
                                   node_name_to_global_index,
                                   global_shared_node_pt);
   }
  else
   {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
               << "  Index of existing halo node " 
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    
    // Copy node from received location
    new_nod_pt = new_nodes_on_domain[
     Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++]];
    
    new_el_pt->node_pt(node_index)=new_nod_pt;
        
   }
  
 }
 
 //========start of construct_new_halo_node_helper=================
 //Helper function which constructs a new external halo node (on new element)
 //with the required information sent from the haloed process
 //========================================================================
 template<class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::construct_new_halo_node_helper
 (Node* &new_nod_pt, 
  Vector<Node*> &new_nodes_on_domain,
  Vector<Vector<Vector<std::map<unsigned, Node*> > > > 
  &other_proc_shd_bnd_node_pt,
  unsigned& iproc, unsigned& node_index,
  FiniteElement* const &new_el_pt,
  Vector<Vector<Vector<unsigned> > > &global_node_names,
  std::map<Vector<unsigned>, unsigned> &node_name_to_global_index,
  Vector<Node*> &global_shared_node_pt)
 {
  //The first entry indicates the number of values at this new Node
  //(which may be different across the same element e.g. Lagrange multipliers)
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
  oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
             << "  Number of values of external halo node " 
             << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
             << std::endl;
#endif
  unsigned n_val=Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
  
  // Null TimeStepper for now
  TimeStepper* time_stepper_pt=this->Time_stepper_pt;
  // Default number of previous values to 1
  unsigned n_prev=time_stepper_pt->ntstorage();
  
  // ------------------------------------------------------
  // Check if the node is on an original boundary
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
  oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
             << "  Is the node on an original boundary " 
             << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
             << std::endl;
#endif
  
  // Flag to indicate if the node is on original boundaries
  const unsigned node_on_original_boundaries = 
   Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
  
  // Store the original boundaries where the node is on
  Vector<unsigned> original_boundaries_node_is_on;
  // Store the zeta coordinates of the node on the original boundaries
  Vector<double> zeta_coordinates;
  // Store the number of original boundaries the node is on
  unsigned n_original_boundaries_node_is_on = 0;
  
  if (node_on_original_boundaries==2)
   {
    // How many original boundaries does the node live on?
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
               << " Number of boundaries the node is on: " 
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    n_original_boundaries_node_is_on = 
     Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    
    // Resize the containers
    original_boundaries_node_is_on.resize(n_original_boundaries_node_is_on);
    zeta_coordinates.resize(n_original_boundaries_node_is_on);
    
    for (unsigned i=0;i<n_original_boundaries_node_is_on;i++)
     {
      // Boundary number
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Node is on boundary " 
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      original_boundaries_node_is_on[i] =
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      zeta_coordinates[i] = 
       Flat_packed_doubles[Counter_for_flat_packed_doubles++];
     }
    
   } // if (node_on_original_boundaries==2)
#ifdef PARANOID
  else
   {
    if (node_on_original_boundaries != 0)
     {
      std::ostringstream error_message;
      error_message
       <<"The current node is not on an original boundary, this should\n"
       <<"be indicated by a zero flag. However, the read value for\n"
       <<"that flag is ("<<node_on_original_boundaries<<").\n\n";
      throw OomphLibError(
       error_message.str(),
       "RefineableTriangleMesh::construct_new_halo_node_helper()",
       OOMPH_EXCEPTION_LOCATION);
     } // if (node_on_original_boundaries != 0)
   }
#endif
  
  // --------------------------------------------------------------
  // Check if the node was on a shared boundary with the iproc
  // processor
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
  oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
             << "  Is node on shared boundary? "
             << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
             << std::endl;
#endif
  const unsigned is_node_on_shared_boundary = 
   Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
  if (is_node_on_shared_boundary == 1)
   {
    // How many shared boundaries does the node live on?
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
               << " Number of boundaries the node is on: " 
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    const unsigned n_shd_bnd_node_is_on = 
     Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    Vector<unsigned> shd_bnds_node_is_on(n_shd_bnd_node_is_on);
    for (unsigned i=0;i<n_shd_bnd_node_is_on;i++)
     {
      // Shared boundary number
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Node is on boundary " 
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      shd_bnds_node_is_on[i] =
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
     }
    
    // Get the index of the node on the shared boundary
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
               << "  Index of node on boundary " 
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    // Get the node index of the node on the shared boundary
    unsigned node_index_on_shared_boundary =
     Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    
    // Get the pointer to the node with the received info.
    new_nod_pt = 
     this->sorted_shared_boundary_node_pt(shd_bnds_node_is_on[0],
                                          node_index_on_shared_boundary);
    
   } // if (is_node_on_shared_boundary == 1)
#ifdef PARANOID
  else
   {
    if (is_node_on_shared_boundary != 0)
     {
      std::ostringstream error_message;
      error_message
       <<"The current node is not on a shared boundary, this should\n"
       <<"be indicated by a zero flag. However, the read value for\n"
       <<"that flag is ("<<is_node_on_shared_boundary<<").\n\n";
      throw OomphLibError(
       error_message.str(),
       "RefineableTriangleMesh::construct_new_halo_node_helper()",
       OOMPH_EXCEPTION_LOCATION);
     } // if (node_on_shared_boundary != 0)
   }
#endif
  
  // ------------------------------------------------------------
  // Is the node on a shared boundary with other processor?
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
  oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
             << "  Is the node on shared boundaries with other processors "
             << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
             << std::endl;
#endif
  
  // Is the node in shared boundaries no associated with the
  // receiver processor
  const unsigned is_the_node_in_shared_boundaries_with_other_processors = 
   Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
  
  // The containers where to store the info.
  Vector<unsigned> other_processor_1;
  Vector<unsigned> other_processor_2;
  Vector<unsigned> other_shared_boundaries;
  Vector<unsigned> other_indexes;
  
  // How many shared bounaries with other processors the node lives on
  unsigned n_shd_bnd_with_other_procs_have_node = 0;
  
  // Is the node on shared boundaries with other processors
  if (is_the_node_in_shared_boundaries_with_other_processors == 4)
   {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
               << "  In how many shared boundaries with other "
               << "processors is the node "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    
    // How many nodes on other shared boundaries were found
    n_shd_bnd_with_other_procs_have_node = 
     Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    
    // Resize the containers
    other_processor_1.resize(n_shd_bnd_with_other_procs_have_node);
    other_processor_2.resize(n_shd_bnd_with_other_procs_have_node);
    other_shared_boundaries.resize(n_shd_bnd_with_other_procs_have_node);
    other_indexes.resize(n_shd_bnd_with_other_procs_have_node);
    
    for (unsigned i = 0; i < n_shd_bnd_with_other_procs_have_node; i++)
     {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Processor where the other shared boundary"
                 << "has the node"
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      // Read the other processor 1
      other_processor_1[i] = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Processor where the other shared boundary"
                 << "has the node"
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      // Read the other processor 2
      other_processor_2[i] = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Other shared boundary id where the node is on: "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      
      // Read the other shared boundary id
      other_shared_boundaries[i] = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Node index on the other shared boundary "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      
      // Read the node index on the other shared boundary
      other_indexes[i] = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
     } // for (i < n_shd_bnd_with_other_procs_have_node)
    
   } // if (is_the_node_in_shared_boundaries_with_other_processors == 4)
#ifdef PARANOID
  else
   {
    if (is_the_node_in_shared_boundaries_with_other_processors != 0)
     {
      std::ostringstream error_message;
      error_message
       <<"The current node is not on a shared boundary with\n"
       <<"other processors, this should be indicated by a zero flag.\n"
       <<"However, the read value for that flag is ("
       <<is_the_node_in_shared_boundaries_with_other_processors<<").\n\n";
      throw OomphLibError(
       error_message.str(),
       "RefineableTriangleMesh::construct_new_halo_node_helper()",
       OOMPH_EXCEPTION_LOCATION);
     }
   }
#endif
  
  // Now we have all the info. to decide whether the node should be
  // created or not
  
  // First check if the node is a shared boundary node
  if (is_node_on_shared_boundary == 1)
   {
    // We already have the node, we do not need to create it
    
    // Only check if we need to add boundary info. to the node
    if (node_on_original_boundaries==2)
     {
      // The node is a boundary node, add the boundary info. before
      // adding it to the domain
      
      // Associate the node to the given boundaries
      for (unsigned i = 0; i < n_original_boundaries_node_is_on; i++)
       {
        add_boundary_node(original_boundaries_node_is_on[i], new_nod_pt);
        // Establish the boundary coordinates for the node
        Vector<double> zeta(1);
        zeta[0] = zeta_coordinates[i];
        new_nod_pt->set_coordinates_on_boundary(
         original_boundaries_node_is_on[i],zeta);
       }
      
     } // if (node_on_original_boundaries==2)
    
    // Add the node to the domain
    new_nodes_on_domain.push_back(new_nod_pt);
    
    // Add the node to the element
    new_el_pt->node_pt(node_index) = new_nod_pt;
    
   } // if (is_node_on_shared_boundary == 1)
  
  // Now check if the node is on a shared boundary with another
  // processor, if that is the case try to find the node that may have
  // been already sent by the other processors
  
  // This flags indicates if the node was found, and then decide if it
  // is required to create the node
  bool found_node_in_other_shared_boundaries = false;
  // Flag to indicate whether the node should be created as a boundary
  // node or not. If the node lies on a shared boundary with other
  // processor the we create it as a boundary node. The processor from
  // which we are receiving info. (iproc) may not know that the node
  // lies on an original boundary. If the node lies on an original
  // boundary then its info. will be sent by another processor, then
  // we can set its boundary info. since the node was constructed as a
  // boundary node
  bool build_node_as_boundary_node = false;
  
  if (is_the_node_in_shared_boundaries_with_other_processors == 4)
   {
     // Build the node as a boundary node
     build_node_as_boundary_node = true;

    // Try to get the node pointer in case that the node has been
    // already sent by the other processors
    
    // Get the number of initial shared boundaries to correct the
    // index of the shared boundary
    const unsigned initial_shd_bnd_id = this->initial_shared_boundary_id();
    
    // Add the found nodes in the container
    Vector<Node*> found_node_pt;
    
    // Now try to find the node in any of the other shared boundaries
    for (unsigned i = 0; i < n_shd_bnd_with_other_procs_have_node; i++)
      {
        // We always check with the lower processor number. The
        // info. is only stored in one direction. More importantly,
        // this is done with the hope that the info. has been already
        // received from the other processor given that its info. was
        // processed before the current processor (iproc). NOTE that
        // it is not always the case that this info. has been received
        // from the other processors since it may have not require to
        // send the elements (and nodes) on the shared boundary with
        // the current processor (iproc).
        unsigned oproc1 = other_processor_1[i];
        unsigned oproc2 = other_processor_2[i];
        if (other_processor_1[i] > other_processor_2[i])
          {
            oproc1 = other_processor_2[i];
            oproc2 = other_processor_1[i];
          } // if (other_processor_1[i] > other_processor_2[i])
        
        // Re-compute the shared boundary id between the other
        // processors
        const unsigned shd_bnd_id = 
          other_shared_boundaries[i] - initial_shd_bnd_id;
        
        // Read the index
        const unsigned index = other_indexes[i];
        
        // Check if there are nodes received from the other processor
        // and with the given shared boundary
        const unsigned n_nodes_on_other_processor = 
          other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id].size();
        
        if (n_nodes_on_other_processor > 0)
          {
            // Check if we can find the index of the node in that
            // other processor and shared boundary id
            std::map<unsigned, Node*>::iterator it = 
              other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id].
              find(index);
            
            // If the index exist then get the node pointer
            if (it!=
                other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id].end())
              {
                // Mark the node as found
                found_node_in_other_shared_boundaries = true;
                // Get the node pointer
                Node* tmp_node_pt = (*it).second;
                
                // Push back the node pointer
                found_node_pt.push_back(tmp_node_pt);
                
              } // if (it!=
                // other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id].end())
            
          } // if (n_nodes_on_other_processor > 0)
        
     } // for (i < n_shd_bnd_with_other_procs_have_node)
    
    // If the node was found, then all their instances should be the
    // same but better check
    if (found_node_in_other_shared_boundaries)
      {
#ifdef PARANOID
       const unsigned n_times_node_found = found_node_pt.size();
       for (unsigned j = 1; j < n_times_node_found; j++)
        {
         if (found_node_pt[j-1] != found_node_pt[j])
          {
           std::ostringstream error_message;
           error_message
             <<"The instances of the node that was found on\n"
             <<"shared boundaries with other processors (but not\n"
             <<"on shared boundaries with this processor) are not\n"
             <<"the same.\n"
             <<"These are the coordinates of the instances of the\n"
             <<"nodes:\n"
             <<"(" << found_node_pt[j-1]->x(0) << ", "
             << found_node_pt[j-1]->x(1) << ")\n"
             <<"(" << found_node_pt[j]->x(0) << ", "
             << found_node_pt[j]->x(1) << ")\n"
             <<"Dont be surprised if they are the same since the "
             << "node is\nrepeated.\n";
           throw OomphLibError(error_message.str(),
                               OOMPH_CURRENT_FUNCTION,
                               OOMPH_EXCEPTION_LOCATION);
           
          } // if (found_node_pt[j-1] != found_node_pt[j])
         
        } // for (j < ntimes_node_found)
#endif // #ifdef PARANOID
       
        // Check if the node is a shared boundary node from the
        // current processor and the iproc processor, if that is the
        // case, and the node is also on a shared boundary with other
        // processor, then the pointer should be the same!!!
        if (is_node_on_shared_boundary == 1)
          {
            //const unsigned n_times_node_found = found_node_pt.size();
            // The pointer to the node is already assigned, it was
            // assigned when the node was found to be on a shared
            // boundary with the sending processor (iproc). Check that
            // any previous instances of the node have been copied
            // from the shared boundary, if that is not the case then
            // there is a problem
            if (found_node_pt[0] != new_nod_pt)
              {
                std::ostringstream error_message;
                error_message
                  <<"The pointer of the node that was found to be on a\n"
                  <<"shared boundary with other processor(s) and the pointer\n"
                  <<"of the node on shared boundary with the receiver\n"
                  <<"processor (iproc) are not the same. This means we have a\n"
                  << "repeated node)\n"
                  <<"The coordinates for the nodes are:\n"
                  <<"(" << found_node_pt[0]->x(0) << ", "
                  << found_node_pt[0]->x(1) << ")\n"
                  <<"(" << new_nod_pt->x(0) << ", "
                  << new_nod_pt->x(1) << ")\n"
                  <<"Dont be surprised if they are the same since the "
                  << "node is\nrepeated.\n";
                throw OomphLibError(error_message.str(),
                                    OOMPH_CURRENT_FUNCTION,
                                    OOMPH_EXCEPTION_LOCATION);
                
              } // if (found_node_pt[i] != new_nod_pt)
            
          } // if (is_node_on_shared_boundary == 1)
        else
          {
            // Take the first instance of the node in case that it was
            // found and is not on a shared boundary with the iproc
            // processor (the processor from which we are receiving
            // the info.)
            new_nod_pt = found_node_pt[0];
            
          }
        
      } // if (found_node_in_other_shared_boundaries)
    
   } // if (is_the_node_in_shared_boundaries_with_other_processors == 4)
  
  // -----------------------------------------------------------------
  // Create the node or read the received info if the node is not on a
  // shared boundary with the iproc processor
  if (is_node_on_shared_boundary != 1)
   {
    // If the node is on a shared boundary with other processor we
    // need to read all the info. since the processor that sent the
    // info. did not know that the node is part of another shared
    // boundary
    
    // If the node is not on a shared boundary (with any processor),
    // or if this is the first time that the info. of the node is
    // received from any of the processors with which it has a shared
    // boundary, then we create the node
     
    // Is the node a boundary node or should it be build as a boundary
    // node because it is on a shared boundary with other processors
    if (node_on_original_boundaries==2 || build_node_as_boundary_node)
     {
      // Check if necessary to create the node, or if it has been
      // already found in shared boundaries with other processors
      if (!found_node_in_other_shared_boundaries)
       {
        // Construct a boundary node
        if (time_stepper_pt!=0)
         {
          new_nod_pt=new_el_pt->construct_boundary_node(node_index,
                                                        time_stepper_pt);
         }
        else
         {
          new_nod_pt=new_el_pt->construct_boundary_node(node_index);
         }
        
       } // if (!found_node_in_other_shared_boundaries)
      else
        {
          // If the node was found then assign the node to the element
          new_el_pt->node_pt(node_index) = new_nod_pt;
          
        } // else if (!found_node_in_other_shared_boundaries)
      
      // Associate the node to the given boundaries
      for (unsigned i = 0; i < n_original_boundaries_node_is_on; i++)
        {
          add_boundary_node(original_boundaries_node_is_on[i], new_nod_pt);
          // Establish the boundary coordinates for the node
          Vector<double> zeta(1);
          zeta[0] = zeta_coordinates[i];
          new_nod_pt->set_coordinates_on_boundary(
           original_boundaries_node_is_on[i],zeta);
        }
      
     } // if (node is on an original boundary)
    else
     {
      // Check if necessary to create the node, or if it has been
      // already found in shared boundaries with other processors
      if (!found_node_in_other_shared_boundaries)
       {
        // Construct an ordinary (non-boundary) node
        if (time_stepper_pt!=0)
         {
          new_nod_pt=new_el_pt->construct_node(node_index, time_stepper_pt);
         }
        else
         {
          new_nod_pt=new_el_pt->construct_node(node_index);
         }
       } // if (!found_node_in_other_shared_boundaries)
      else
       {
        // If the node was found then assign the node to the element
        new_el_pt->node_pt(node_index) = new_nod_pt;
       } // else if (!found_node_in_other_shared_boundaries)
      
     } // else (the node is not a boundary node)
    
    // ... and gather all its information
    
    // If the node was found or not in other shared boundaries, this
    // is the first time the node is received from this processor
    // (iproc), therefore it is added to the vector of nodes received
    // from this processor (iproc)
    new_nodes_on_domain.push_back(new_nod_pt);
    
    // Check if necessary to state all the info. to the node if it has
    // been already found in shared boundaries with other processors
    if (!found_node_in_other_shared_boundaries)
      {
        // Add the node to the general node storage
        this->add_node_pt(new_nod_pt);
      } // if (!found_node_in_other_shared_boundaries)
    
    // Is the new constructed node Algebraic?
    AlgebraicNode* new_alg_nod_pt=dynamic_cast<AlgebraicNode*>
     (new_nod_pt);

    // If it is algebraic, its node update functions will
    // not yet have been set up properly
    if (new_alg_nod_pt!=0)
     {
      // The AlgebraicMesh is the external mesh
      AlgebraicMesh* alg_mesh_pt=dynamic_cast<AlgebraicMesh*>(this);
      
      /// The first entry of All_alg_nodal_info contains
      /// the default node update id
      /// e.g. for the quarter circle there are 
      /// "Upper_left_box", "Lower right box" etc...
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Alg node update id "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      
      unsigned update_id=Flat_packed_unsigneds
       [Counter_for_flat_packed_unsigneds++];
      
      Vector<double> ref_value;
      
      // The size of this vector is in the next entry
      // of All_alg_nodal_info
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Alg node # of ref values "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      unsigned n_ref_val=Flat_packed_unsigneds
       [Counter_for_flat_packed_unsigneds++];
      
      // The reference values themselves are in
      // All_alg_ref_value
      ref_value.resize(n_ref_val);
      for (unsigned i_ref=0;i_ref<n_ref_val;i_ref++)
       {
        ref_value[i_ref]=Flat_packed_doubles
         [Counter_for_flat_packed_doubles++];
       }
      
      Vector<GeomObject*> geom_object_pt;
      /// again we need the size of this vector as it varies
      /// between meshes; we also need some indication
      /// as to which geometric object should be used...
      
      // The size of this vector is in the next entry
      // of All_alg_nodal_info
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Alg node # of geom objects "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      unsigned n_geom_obj=Flat_packed_unsigneds
       [Counter_for_flat_packed_unsigneds++];
      
      // The remaining indices are in the rest of 
      // All_alg_nodal_info
      geom_object_pt.resize(n_geom_obj);
      for (unsigned i_geom=0;i_geom<n_geom_obj;i_geom++)
       {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                   << "  Alg node: geom object index "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        unsigned geom_index=Flat_packed_unsigneds
         [Counter_for_flat_packed_unsigneds++];
        // This index indicates which of the AlgebraicMesh's
        // stored geometric objects should be used
        // (0 is a null pointer; everything else should have
        //  been filled in by the specific Mesh).  If it
        // hasn't been filled in then the update_node_update
        // call should fix it
        geom_object_pt[i_geom]=alg_mesh_pt->
         geom_object_list_pt(geom_index);
       }
      
      // Check if necessary to state all the info. to the node if it has
      // been already found in shared boundaries with other processors
      if (!found_node_in_other_shared_boundaries)
       {
        /// For the received update_id, ref_value, geom_object
        /// call add_node_update_info
        new_alg_nod_pt->add_node_update_info
         (update_id,alg_mesh_pt,geom_object_pt,ref_value);
        
        /// Now call update_node_update
        alg_mesh_pt->update_node_update(new_alg_nod_pt);
        
       } // if (!found_node_in_other_shared_boundaries)
      
     } // if (new_alg_nod_pt!=0)
    
    // Check if necessary to state all the info. to the node if it has
    // been already found in shared boundaries with other processors
    if (!found_node_in_other_shared_boundaries)
     {
      // Is the node a MacroElementNodeUpdateNode?
      MacroElementNodeUpdateNode* macro_nod_pt=
       dynamic_cast<MacroElementNodeUpdateNode*>(new_nod_pt);
    
      if (macro_nod_pt!=0)
       {
        // Need to call set_node_update_info; this requires
        // a Vector<GeomObject*> (taken from the mesh)
        Vector<GeomObject*> geom_object_vector_pt;
      
        // Access the required geom objects from the
        // MacroElementNodeUpdateMesh
        MacroElementNodeUpdateMesh* macro_mesh_pt=
         dynamic_cast<MacroElementNodeUpdateMesh*>(this);
        geom_object_vector_pt=
         macro_mesh_pt->geom_object_vector_pt();
      
        // Get local coordinate of node in new element
        Vector<double> s_in_macro_node_update_element;
        new_el_pt->local_coordinate_of_node
         (node_index,s_in_macro_node_update_element);
      
        // Set node update info for this node
        macro_nod_pt->set_node_update_info
         (new_el_pt,s_in_macro_node_update_element,
          geom_object_vector_pt);
       }
      
     } // if (!found_node_in_other_shared_boundaries)
    
    // If there are additional values, resize the node
    unsigned n_new_val=new_nod_pt->nvalue();
    
    // Check if necessary to state all the info. to the node if it has
    // been already found in shared boundaries with other processors
    if (!found_node_in_other_shared_boundaries)
     {
      if (n_val>n_new_val)
       {        
        // If it has been necessary to resize then it may be becuse
        // the node is on a FSI boundary, if that is the case we need
        // to set a map for these external values
        
        // Cast to a boundary node
        BoundaryNodeBase *bnod_pt = 
         dynamic_cast<BoundaryNodeBase*>(new_nod_pt);
        
        // Create storage, if it doesn't already exist, for the map 
        // that will contain the position of the first entry of 
        // this face element's additional values, 
        if(bnod_pt->index_of_first_value_assigned_by_face_element_pt()==0)
         {
          bnod_pt->index_of_first_value_assigned_by_face_element_pt()= 
           new std::map<unsigned, unsigned>; 
         }
        
        // Get pointer to the map
        std::map<unsigned, unsigned>* map_pt=
         bnod_pt->index_of_first_value_assigned_by_face_element_pt();
        
        // The id of the face to which this node belong in the bulk
        // element
        const unsigned id_face = 0;
        // We only resize the node values Vector if we haven't done it yet
        std::map<unsigned, unsigned>::const_iterator p=map_pt->find(id_face);
        
        // If this node hasn't been resized for current id
        if(p==map_pt->end())
         {
          // assign the face element id and the position of the 
          //first entry to the boundary node
          (*map_pt)[id_face] = n_new_val;
          
          // resize the node vector of values
          new_nod_pt->resize(n_val);
         }
        
       } // if (n_val>n_new_val)
      
     } // if (!found_node_in_other_shared_boundaries)
    
    // Is the new node a SolidNode? 
    SolidNode* solid_nod_pt=dynamic_cast<SolidNode*>(new_nod_pt);
    if (solid_nod_pt!=0)
     {
      unsigned n_solid_val=solid_nod_pt->variable_position_pt()->nvalue();
      for (unsigned i_val=0;i_val<n_solid_val;i_val++)
       {
        for (unsigned t=0;t<n_prev;t++)
         {
          double read_data = 
           Flat_packed_doubles[Counter_for_flat_packed_doubles++];

          // Check if necessary to state all the info. to the node if it has
          // been already found in shared boundaries with other processors
          if (!found_node_in_other_shared_boundaries)
           {
            solid_nod_pt->variable_position_pt()->
             set_value(t, i_val, read_data);
           } // if (!found_node_in_other_shared_boundaries)
          
         }
        
       }
      
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Number of values solid node: "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      const unsigned nvalues_solid_node = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      Vector<double> values_solid_node(nvalues_solid_node);
      for (unsigned i = 0; i < nvalues_solid_node; i++)
       {
        values_solid_node[i] = 
         Flat_packed_doubles[Counter_for_flat_packed_doubles++];
       }
      
      // Check if necessary to state all the info. to the node if it has
      // been already found in shared boundaries with other processors
      if (!found_node_in_other_shared_boundaries)
       {
        unsigned index = 0;
        solid_nod_pt->read_values_from_vector(values_solid_node, index);
       }
      
     }
    
    // Get copied history values
    //  unsigned n_val=new_nod_pt->nvalue();
    for (unsigned i_val=0;i_val<n_val;i_val++)
     {
      for (unsigned t=0;t<n_prev;t++)
       {
        double read_data = 
         Flat_packed_doubles[Counter_for_flat_packed_doubles++];
        
        // Check if necessary to state all the info. to the node if it
        // has been already found in shared boundaries with other
        // processors
        if (!found_node_in_other_shared_boundaries)
         {
          new_nod_pt->set_value(t, i_val, read_data);
         } // if (!found_node_in_other_shared_boundaries)
        
       }
      
     }
    
    // Get copied history values for positions
    unsigned n_dim=new_nod_pt->ndim();
    for (unsigned idim=0;idim<n_dim;idim++)
     {
      for (unsigned t=0;t<n_prev;t++)
       {
        double read_data = 
         Flat_packed_doubles[Counter_for_flat_packed_doubles++];
        
        // Check if necessary to state all the info. to the node if it
        // has been already found in shared boundaries with other
        // processors
        if (!found_node_in_other_shared_boundaries)
         {
          // Copy to coordinate
          new_nod_pt->x(t,idim) = read_data;
          
         } // if (!found_node_in_other_shared_boundaries)
       }
     }
    
   } // if (is_node_on_shared_boundary != 1)
  
  // If the node was not found in other shared boundaries (possibly
  // because it is the first time the node has been sent) then copy
  // the node to the shared boundaries where it should be, use the
  // special container for this cases
  if (n_shd_bnd_with_other_procs_have_node > 0 && // The node is on
                                                  // shared
                                                  // boundaries with
                                                  // other processors
      !found_node_in_other_shared_boundaries)    // The node has not
                                                  // been previously
                                                  // set as 
                                                  // shared with
                                                  // other processors
                                                  // (first time)
   {
     // Update the node pointer in all the (references) of the node
     this->update_other_proc_shd_bnd_node_helper(new_nod_pt,
                                                 other_proc_shd_bnd_node_pt,
                                                 other_processor_1,
                                                 other_processor_2,
                                                 other_shared_boundaries,
                                                 other_indexes,
                                                 global_node_names,
                                                 node_name_to_global_index,
                                                 global_shared_node_pt);
     
   } // if (!found_node_in_other_shared_boundaries)
  
 }

//========start of update_other_proc_shd_bnd_node_helper=================
//Helper function that assigns/updates the references to the node so
//that it can be found with any other reference
//========================================================================
template<class ELEMENT>
void RefineableTriangleMesh<ELEMENT>::
update_other_proc_shd_bnd_node_helper
(Node* &new_node_pt, 
 Vector<Vector<Vector<std::map<unsigned, Node*> > > > 
 &other_proc_shd_bnd_node_pt,
 Vector<unsigned> &other_processor_1,
 Vector<unsigned> &other_processor_2,
 Vector<unsigned> &other_shared_boundaries,
 Vector<unsigned> &other_indexes,
 Vector<Vector<Vector<unsigned> > > &global_node_names,
 std::map<Vector<unsigned>, unsigned> &node_name_to_global_index,
 Vector<Node*> &global_shared_node_pt)
{
  // Get the number of initial shared boundaries to correct the index
  // of the shared boundary
  const unsigned initial_shd_bnd_id = this->initial_shared_boundary_id();

#ifdef PARANOID  
  // Get the number of instances of the node on other shared
  // boundaries with other processors
  const unsigned n_data = other_processor_1.size();
#endif // #ifdef PARANOID
  
  // Create the first node name
  Vector<unsigned> node_name(4);
  node_name[0] = other_processor_1[0];
  node_name[1] = other_processor_2[0];
  node_name[2] = other_shared_boundaries[0];
  node_name[3] = other_indexes[0];
  
#ifdef PARANOID
  // Get the global node index, and all the names of the node
  std::map<Vector<unsigned>, unsigned>::iterator it = 
    node_name_to_global_index.find(node_name);
  if (it==node_name_to_global_index.end())
    {
      std::ostringstream error_stream;
      error_stream
        <<"The node name does not exist in the global node names\n"
        <<"This is the name of the node\n"
        << "Name: iproc, jproc, ishd_bnd, idx\n"
        <<"Name: " << node_name[0] <<", " << node_name[1] <<", " 
        << node_name[2] <<", " << node_name[3] <<"\n";
      throw OomphLibError(error_stream.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
    } // if (it!=node_name_to_global_index.end())
#endif // #ifdef PARANOID
  
  // Get the global node index
  const unsigned iglobal_node = node_name_to_global_index[node_name];
  // Add the node to the global shared node container
  global_shared_node_pt[iglobal_node] = new_node_pt;
  // Get the names
  Vector<Vector<unsigned> > inode_names = global_node_names[iglobal_node];
  // Get the number of names of the node
  const unsigned n_names = inode_names.size();
  
#ifdef PARANOID
  // Check that the received names of the node are part of the global
  // node names
  unsigned n_found_node_names_on_global_node_name = 0;
  // loop over the input node names
  for (unsigned j = 0; j < n_data; j++)
    {
      // loop over the inode_names
      for (unsigned k = 0; k < n_names; k++)
        {
          // Is this input name part of the global node names?
          if (inode_names[k][0] == other_processor_1[j] &&
              inode_names[k][1] == other_processor_2[j] &&
              inode_names[k][2] == other_shared_boundaries[j] &&
              inode_names[k][3] == other_indexes[j])
            {
              // Increase the number of found input node names in the
              // global node names
              n_found_node_names_on_global_node_name++;
            }
          
        } // for (k < n_names)
      
    } // for (j < n_data)
  
  // Were all the input node names found on the global node names?
  if (n_found_node_names_on_global_node_name != n_data)
    {
      std::ostringstream error_stream;
      error_stream
        <<"Not all the node names of the current node were found on the\n"
        <<"global node names. This happened when adding the node pointer\n"
        <<"to the data structure that keeps tracks of nodes on shared\n"
        <<"boundaries with other processors\n\n"
        << "These are the names of the current node\n"
        << "Name k: iproc, jproc, ishd_bnd, idx\n";
      for (unsigned j = 0; j < n_data; j++)
        {
          error_stream<<"Name("<<j<<"): "
                      <<other_processor_1[j] <<", "
                      <<other_processor_2[j] <<", "
                      <<other_shared_boundaries[j] <<", "
                      <<other_indexes[j] <<"\n";
        }
      
      error_stream
        << "\n\nThese are the names of the global node\n"
        << "Name k: iproc, jproc, ishd_bnd, idx\n";
      for (unsigned k = 0; k < n_names; k++)
        {
          error_stream<<"Name("<<k<<"): "
                      <<inode_names[k][0] <<", "
                      <<inode_names[k][1] <<", "
                      <<inode_names[k][2] <<", "
                      <<inode_names[k][3] <<"\n";
        }
      
      throw OomphLibError(error_stream.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
    }
#endif // #ifdef PARANOID
  
  // Set the node pointer in all of its names
  for (unsigned j = 0; j < n_names; j++)
    {
      // Get the j-th node name
      const unsigned iproc = inode_names[j][0];
      const unsigned jproc = inode_names[j][1];
      const unsigned ishd_bnd = inode_names[j][2] - initial_shd_bnd_id;
      const unsigned index = inode_names[j][3];
      
      // The info. is stored only in one direction
      // Get the smallest processor number
      if (iproc < jproc)
        {          
          other_proc_shd_bnd_node_pt[iproc][jproc][ishd_bnd][index]
            = new_node_pt;
        }
      else
        {          
          other_proc_shd_bnd_node_pt[jproc][iproc][ishd_bnd][index]
            = new_node_pt;
        }
      
     } // for (j < n_names)
  
}
  
 // *********************************************************************
 // End communication functions
 // *********************************************************************
 
 // *********************************************************************
 // BEGIN: Methods to perform load balance
 // *********************************************************************
 
 //======================================================================
 /// \short Performs the load balancing for unstructured meshes, the
 /// load balancing strategy is based on mesh migration
 //======================================================================
 template <class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 load_balance(const Vector<unsigned>& 
              target_domain_for_local_non_halo_element)
 {
   oomph_info << "Load balance (unstructured mesh) [BEGIN]" << std::endl;
   
  // This method can only be called when the mesh has been already
  // distributed
  if (!this->is_mesh_distributed())
   {
    std::ostringstream warning_message;
    warning_message
     << "\n===============================================================\n"
     << "The load balancing can only be performed in distributed meshes,\n"
     << "your mesh has not been distributed.\n"
     << "===============================================================\n\n";
    OomphLibWarning(warning_message.str(),
                    OOMPH_CURRENT_FUNCTION,
                    OOMPH_EXCEPTION_LOCATION);
    // Return
    return;
   }
    
  // Get the number of processors
  const unsigned nproc = this->communicator_pt()->nproc();
  // Get the rank of the current processors
  const unsigned my_rank = this->communicator_pt()->my_rank();
  
  // Check that there are at least two processors
  if (nproc == 1)
   {
    std::ostringstream warning_message;
    warning_message
     << "\n===============================================================\n"
     << "The load balancing can only be performed when there are at least\n"
     << "two procesors, the current number of processors is one.\n"
     << "===============================================================\n\n";
    OomphLibWarning(warning_message.str(),
                    OOMPH_CURRENT_FUNCTION,
                    OOMPH_EXCEPTION_LOCATION);
    // Return
    return;
   }
  
  // Get the time before load balance
  double t_start_overall_load_balance=0.0;
  if (Print_timings_level_load_balance>1)
    {
      t_start_overall_load_balance=TimingHelpers::timer();
    }
  
  // Get the number of elements in the mesh before load balance
  const unsigned nelement_before_load_balance = this->nelement();
  
#ifdef PARANOID
  // The number of elements in the mesh and the number of target
  // domains for the local non halo elements in the mesh should match
  if (nnon_halo_element() != 
      target_domain_for_local_non_halo_element.size())
   {
    std::ostringstream error_message;
    error_message
     << "The number of non halo elements in the current mesh (" 
     << nnon_halo_element() << ") and the number\n"
     << "of target areas for the local non halo elements (" 
     << target_domain_for_local_non_halo_element.size() 
     << ") is different\n\n";
    throw OomphLibError(error_message.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
  // Backup pointers to elements in this mesh
  Vector<FiniteElement*> backed_up_ele_pt(nelement_before_load_balance);
  for (unsigned e = 0; e < nelement_before_load_balance; e++)
   {
    backed_up_ele_pt[e] = this->finite_element_pt(e);
   }
  
  // =====================================================================
  // BEGIN: GET THE DOMAINS FOR THE HALO ELEMENTS
  // =====================================================================
  
  // Get the time to get the domains of halo elements
  double tt_start_get_domains_halo_elements=0.0;
  if (Print_timings_level_load_balance>1)
    {
      tt_start_get_domains_halo_elements=TimingHelpers::timer();
    }
  
  // Get the new domains for the halo elements
  
  // Send the new domains for the current haloed elements, and receive
  // the new domains for the current halo elements
  // -- 1) On the current processor get the new domains for the
  //       haloed elements
  // -- 2) Then send this info. to all the processor that have a
  //       halo copy of the element
  
  // The storing for the new domains of the haloed elements (sent to
  // other processors)
  Vector<Vector<unsigned> > new_domains_haloed_elements(nproc);
  // The storing for the new domains of the halo elements (received
  // from other processors)
  Vector<Vector<unsigned> > new_domains_halo_elements(nproc);
  
  // First resize the containers by getting the current number of
  // halo/haloed elements within each processor
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // There are no halo/haloed elements with myself (my_rank
    // processor)
    if (iproc != my_rank)
     {
      // Get the number of halo elements with iproc processor
      const unsigned n_halo_iproc = this->nroot_halo_element(iproc);
      // Resize the container
      new_domains_halo_elements[iproc].resize(n_halo_iproc);
      
      // Get the number of haloed elements with iproc processor
      const unsigned n_haloed_iproc = this->nroot_haloed_element(iproc);
      // Resize the container
      new_domains_haloed_elements[iproc].resize(n_haloed_iproc);
     } // if (iproc != my_rank)
   } // for (iproc < nproc)
  
#ifdef PARANOID
  // Count the number of found haloed elements
  Vector<unsigned> counter_for_found_haloed_elements(nproc, 0);
#endif
  
  // Go through all the haloed elements and find their new domain
  
  // Get the haloed elements with in each processor and check if the
  // element is haloed with the processor
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // There are no halo/haloed elements with myself (my_rank
    // processor)
    if (iproc != my_rank)
     {
      // Get the number of haloed elements with iproc processor
      const unsigned n_haloed_iproc = this->nroot_haloed_element(iproc);
      
      // Loop over the haloed elements
      for (unsigned ihd = 0; ihd < n_haloed_iproc; ihd++)
       {
        // Get the ihd-th haloed element with "iproc" processor
        GeneralisedElement* haloed_ele_pt = 
         this->root_haloed_element_pt(iproc, ihd);
        
        // The counter for the nonhalo elements
        unsigned nh_count4 = 0;
        // Find the element in the general elements container
        for (unsigned e = 0; e < nelement_before_load_balance; e++)
         {
          // Get the e-th element
          GeneralisedElement* ele_pt = this->element_pt(e);
          // Check if the element is a nonhalo element
          if (!ele_pt->is_halo())
           {
            // Increase the counter for nonhalo elements, in case the
            // haloed element is found get the (nh_count4-1) position
            // in the target domains vector
            nh_count4++;
            
            if (ele_pt == haloed_ele_pt)
             {
              // Get the new domain for this element
              const unsigned element_domain = 
               target_domain_for_local_non_halo_element[nh_count4-1];
              // Here decrease the counter ---------------------^
              
              // Set the new domain for the haloed element in the
              // special container
              new_domains_haloed_elements[iproc][ihd] = element_domain;
#ifdef PARANOID
              // Increase the counter
              counter_for_found_haloed_elements[iproc]++;
#endif
              // ... and break the "for" with the general
              // elements. Continue with the next haloed element
              break;
              
             } // if (ele_pt == haloed_ele_pt))
            
           } // if (!ele_pt->is_halo())
          
         } // for (e < nelement_before_load_balance)
        
       } // for (ihd < n_haloed_iproc)
      
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc)
  
#ifdef PARANOID
  // Check that all the haloed elements with all processors have been
  // found
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // There are no halo/haloed elements with myself (my_rank
    // processor)
    if (iproc != my_rank)
     {
      // Get the number of haloed elements with "iproc" processor
      const unsigned n_haloed_iproc = this->nroot_haloed_element(iproc);
    
      // Compare the number of found haloed elements with the current
      // number of haloed elements
      if (n_haloed_iproc != counter_for_found_haloed_elements[iproc])
       {
        std::ostringstream error_message;
        error_message
         << "The independent counting of found haloed elements ("
         << counter_for_found_haloed_elements[iproc] << ") with processor ("
         << iproc << ") is not equal to the number of haloed elements ("
         << n_haloed_iproc << ") with processor (" << iproc << ")\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
       } // if (nhaloed_iproc == counter_for_found_haloed_elements[iproc])
    
     } // if (iproc != my_rank)

   } // for (iproc < nproc)
#endif
  
  // Now we have the new domains for the haloed elements
  
  // Send this info. to the processor with a halo copy of the haloed
  // elements and set the new domains in the halo copies
  
  // First put all the info. in a flat package array
  Vector<unsigned> new_domains_haloed_flat_unsigned;
  // Put in a vector the number of haloed elements within each
  // processor
  Vector<int> nhaloed_elements_with_iproc(nproc);
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // There are no halo/haloed elements with myself (my_rank
    // processor)
    if (iproc != my_rank)
     {
      // Get the number of haloed elements with "iproc" processor
      const unsigned n_haloed_ele_iproc = this->nroot_haloed_element(iproc);
      // Copy the number of haloed elements with "iproc" processor
      nhaloed_elements_with_iproc[iproc] = n_haloed_ele_iproc;
      // Copy the new domains of the haloed elements in the flat
      // package
      for (unsigned i = 0; i < n_haloed_ele_iproc; i++)
       {
        new_domains_haloed_flat_unsigned.push_back(
         new_domains_haloed_elements[iproc][i]);
       } // for (i < n_haloed_ele_iproc)
      
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc)
  
  // The offsets of the flat package within each processor
  Vector<int> offset_haloed_elements_with_iproc(nproc);
  offset_haloed_elements_with_iproc[0] = 0;
  for (unsigned ip = 1; ip < nproc; ip++)
   {
    // Compute the offset to send the values to each processor
    offset_haloed_elements_with_iproc[ip] = 
     offset_haloed_elements_with_iproc[ip-1] +
     nhaloed_elements_with_iproc[ip-1];
   } // for (ip < nproc)
  
  // Prepare to receive the data
  
  // Compute the number of data (halo elements) to receive from each
  // processor and the displacements within each processor
  
  // Counter for the total number of halo elements within all processors
  unsigned counter_halo_ele_with_all_procs = 0;
  
  // Put in a vector the number of halo elements expected to receive
  // from each processor
  Vector<int> nhalo_elements_with_iproc(nproc);
  // Compute the number of total halo elements of (my_rank) this
  // processor with all other processors
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // There are no halo/haloed elements with myself (my_rank
    // processor)
    if (iproc != my_rank)
     {
      // Get the number of halo elements with "iproc" processor
      const unsigned n_halo_ele_iproc = this->nroot_halo_element(iproc);
      // Copy the number of halo elements with "iproc" processor
      nhalo_elements_with_iproc[iproc] = n_halo_ele_iproc;
      // Add the number of elements with this processor
      counter_halo_ele_with_all_procs+= n_halo_ele_iproc;
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc)
  
  // The offsets of the flat package within each processor
  Vector<int> offset_halo_elements_with_iproc(nproc);
  offset_halo_elements_with_iproc[0] = 0;
  for (unsigned ip = 1; ip < nproc; ip++)
   {
    // Compute the offset to receive the values from each processor
    offset_halo_elements_with_iproc[ip] = 
     offset_halo_elements_with_iproc[ip-1] +
     nhalo_elements_with_iproc[ip-1];
   } // for (ip < nproc)
  
  // The flat container to receive the new domains of the halo
  // elements in the current processor
  
  // The flat package where all the info. will be gather from the
  // other processors (the halo flat package)
  Vector<unsigned> 
   new_domains_halo_flat_unsigned(counter_halo_ele_with_all_procs);
  
  // Perform the sending and receiving of information to and from all
  // processors
  MPI_Alltoallv(&new_domains_haloed_flat_unsigned[0], // void *sendbuf
                &nhaloed_elements_with_iproc[0], // int *sendcnts
                &offset_haloed_elements_with_iproc[0], // int *sdispls
                MPI_UNSIGNED, // MPI_Datatype sendtype
                &new_domains_halo_flat_unsigned[0], // void *recvbuf
                &nhalo_elements_with_iproc[0], // int *recvcnts
                &offset_halo_elements_with_iproc[0], // int *rdispls
                MPI_UNSIGNED, // MPI_Datatype recvtype
                this->communicator_pt()->mpi_comm()); // MPI_Comm comm
  
  // Once received the new domains for the halo elements, copy the
  // domains back to an easier to handle container (from the flat
  // package to the one with the different halo elements domains
  // within each processor)
  unsigned counter_new_domains_halo_ele = 0;
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // There are no halo/haloed elements with myself (my_rank
    // processor)
    if (iproc != my_rank)
     {
      // Get the number of halo elements with "iproc"
      const unsigned ntmp_halo_elements_with_iproc = 
       nhalo_elements_with_iproc[iproc];
      // Loop over the number of halo elements within "iproc" and copy
      // the elements from the flat package
      for (unsigned i = 0; i < ntmp_halo_elements_with_iproc; i++)
       {
        // Copy the new domain of the halo elements from the flat
        // package to an easier to use container
        new_domains_halo_elements[iproc][i] = 
         new_domains_halo_flat_unsigned[counter_new_domains_halo_ele++];
       }
     } // if (iproc != my_rank)
   } // for (iproc < nproc)
  
  // The time to get domains of halo elements
  if (Print_timings_level_load_balance>1)
    {
      oomph_info << "CPU for getting domains halo elements (load balance) [1]: "
                 <<TimingHelpers::timer()-tt_start_get_domains_halo_elements
                 << std::endl;
    }
  
  // =====================================================================
  // END: GET THE DOMAINS FOR THE HALO ELEMENTS
  // =====================================================================
  
  // =====================================================================
  // BEGIN: CREATE FINITE ELEMENT LOCAL VERSIONS OF THE HALO(ED)
  // ELEMENTS
  // =====================================================================
  
  // Get the time to get FiniteElement versions from Generalised
  // halo(ed) elements
  double tt_start_get_fe_version_from_ge_halo_ed=0.0;
  if (Print_timings_level_load_balance>1)
    {
      tt_start_get_fe_version_from_ge_halo_ed=TimingHelpers::timer();
    }
  
  // The finite element storage for the halo elements
  Vector<Vector<FiniteElement*> > f_halo_element_pt(nproc);
  // The finite element storage for the haloed elements
  Vector<Vector<FiniteElement*> > f_haloed_element_pt(nproc);
  // Loop over the processors
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // There are no halo(ed) elements with myself
    if (iproc != my_rank)
     {
      // Get the number of halo elements with the "iproc" processor
      const unsigned nhalo_ele_iproc = this->nroot_halo_element(iproc);
      // Get the halo elements with the "iproc" processor
      Vector<GeneralisedElement*> halo_element_pt_iproc = 
       this->root_halo_element_pt(iproc);
      // Resize the finite element container
      f_halo_element_pt[iproc].resize(nhalo_ele_iproc);
      // Loop over the halo elements
      for (unsigned ih = 0; ih < nhalo_ele_iproc; ih++)
       {        
        // Get the finite element
        FiniteElement* ele_pt = 
         dynamic_cast<FiniteElement*>(halo_element_pt_iproc[ih]);
        // Store the finite element version of the element
        f_halo_element_pt[iproc][ih] = ele_pt;
       } // for (ih < nhalo_ele_iproc)

      // Get the number of haloed elements with the "iproc" processor
      const unsigned nhaloed_ele_iproc = this->nroot_haloed_element(iproc);
      // Get the haloed elements with the "iproc" processor
      Vector<GeneralisedElement*> haloed_element_pt_iproc = 
       this->root_haloed_element_pt(iproc);
      // Resize the finite element container
      f_haloed_element_pt[iproc].resize(nhaloed_ele_iproc);
      // Loop over the haloed elements
      for (unsigned ihd = 0; ihd < nhaloed_ele_iproc; ihd++)
       {        
        // Get the finite element
        FiniteElement* ele_pt = 
         dynamic_cast<FiniteElement*>(haloed_element_pt_iproc[ihd]);
        // Store the finite element version of the element
        f_haloed_element_pt[iproc][ihd] = ele_pt;
       } // for (ih < nhaloed_ele_iproc)
      
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc)
  
  // The time to get FiniteElement versions from Generalised halo(ed)
  // elements
  if (Print_timings_level_load_balance>1)
    {
      oomph_info << "CPU for getting finite element versions from generalised halo(ed) elements (load balance) [2]: "
                 <<TimingHelpers::timer()-tt_start_get_fe_version_from_ge_halo_ed
                 << std::endl;
    }
  
  // =====================================================================
  // END: CREATE FINITE ELEMENT LOCAL VERSIONS OF THE HALO(ED)
  // ELEMENTS 
  // =====================================================================
  
  // =====================================================================
  // BEGIN: 1) PREPARE THE ELEMENTS THAT WILL BE SENT TO OTHER PROCESSORS
  //        ---- HALO ELEMENTS ARE NOT CONSIDERED FOR SENDING
  //        2) ASSOCIATE THE NODES WITH THE NEW DOMAIN OF THE ELEMENTS
  //        ---- THE SAME IS PERFORMED FOR NODES IN HALO ELEMENTS
  // =====================================================================
  
  // Get the time to prepare elements to send to other processors
  double tt_start_prepare_element_to_send=0.0;
  if (Print_timings_level_load_balance>1)
    {
      tt_start_prepare_element_to_send=TimingHelpers::timer();
    }
  
  // Store the elements that will be sent to other processors
  Vector<Vector<FiniteElement*> > elements_to_send_pt(nproc);
  
  // Associate the nodes of each element with the processor the
  // element will live on
  std::map<Data*,std::set<unsigned> > 
   processors_associated_with_data_before_load_balance;
  
  // Compute the elements that will be sent to other processor and
  // associate the nodes with the processor the element will live on
  unsigned nh_count3 = 0;
  for (unsigned e = 0; e < nelement_before_load_balance; e++)
   {
    // Get the element
    FiniteElement *ele_pt = this->finite_element_pt(e);
    // Only work with nonhalo elements
    if (!(ele_pt->is_halo()))
     {
      // Get the new domain for the elment
      const unsigned element_domain = 
       target_domain_for_local_non_halo_element[nh_count3++];
      
      // Include the element in the corresponding vector
      elements_to_send_pt[element_domain].push_back(ele_pt);
      
      // Get the number of nodes on the element
      const unsigned n_nodes = ele_pt->nnode();
      // Loop over the nodes
      for (unsigned j = 0; j < n_nodes; j++)
       {
        // Get each node of the element
        Node* node_pt = ele_pt->node_pt(j);
        // ... and associate it with element domains
        processors_associated_with_data_before_load_balance[node_pt].
         insert(element_domain);
        
       } // for (j < n_nodes)
      
     } // if (!(ele_pt->is_halo()))
    
   } // for (e < nelement_before_load_balance)
  
  // ... do the same for the halo elements (but do not add them to the
  // sending container since only the processor with the haloed
  // counterparts is in charge of that). Associate the nodes of the
  // halo elements with the processor they will live on
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // There is no halo elements with myself
    if (iproc != my_rank)
     {
      // Get the number of halo elements with the "iproc" processor
      const unsigned n_halo_ele_iproc = this->nroot_halo_element(iproc);
      // Get the halo elements with the "iproc" processor
      Vector<GeneralisedElement*> halo_element_pt_iproc = 
       this->root_halo_element_pt(iproc);
      // Loop over the halo elements with iproc
      for (unsigned ih = 0; ih < n_halo_ele_iproc; ih++)
       {
        // Get the new domain for the halo element
        const unsigned element_domain = 
         new_domains_halo_elements[iproc][ih];
        
        // Get the finite element
        FiniteElement* ele_pt = 
         dynamic_cast<FiniteElement*>(halo_element_pt_iproc[ih]);
        
        // Get the number of nodes on the halo element
        const unsigned n_nodes = ele_pt->nnode();
        // Loop over the nodes
        for (unsigned j = 0; j < n_nodes; j++)
         {
          // Get each node of the halo element
          Node* node_pt = ele_pt->node_pt(j);
          
          // ... and associate it with element domains
          processors_associated_with_data_before_load_balance[node_pt].
           insert(element_domain);
          
         } // for (j < n_nodes)
        
       } // for (ih < nhalo_ele_iproc)
      
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc)
  
  // The time to prepare elements to send to other processors
  if (Print_timings_level_load_balance>1)
    {
      oomph_info << "CPU for preparing elements to send to other processors (load balance) [3]: "
                 <<TimingHelpers::timer()-tt_start_prepare_element_to_send
                 << std::endl;
    }
  
  // Now all the nodes are associated with the processor where the
  // element will live on. This is performed for the nonhalo and halo
  // elements
  
  // =====================================================================
  // END: 1) PREPARE THE ELEMENTS THAT WILL BE SENT TO OTHER PROCESSORS
  //        ---- HALO ELEMENTS ARE NOT CONSIDERED FOR SENDING
  //        2) ASSOCIATE THE NODES WITH THE NEW DOMAIN OF THE ELEMENTS
  //        ---- THE SAME IS PERFORMED FOR NODES IN HALO ELEMENTS
  // =====================================================================
  
  // =====================================================================
  // BEGIN: COMPUTE THE NEW LOCAL HALO ELEMENTS OF ALL PROCESSORS IN THE
  //        CURRENT PROCESSOR
  //        ----- FOR NONHALO ELEMENTS AND FOR HALO ELEMENTS
  // =====================================================================
  
  // Get the time to compute new local halo elements within all
  // processors
  double tt_start_compute_new_local_halo_elements=0.0;
  if (Print_timings_level_load_balance>1)
    {
      tt_start_compute_new_local_halo_elements=TimingHelpers::timer();
    }
  
  // Before sending the elements across compute the new local
  // halo/haloed elements of each processor. Each processor could have
  // elements that will be part of the new halo/haloed elements of
  // another processors, then these processors need to compute the
  // relations that may happen among these other processors
  
  // Example:
  // Processor 1 may have elements that will be sent to processor 3
  // and 4. These processors need to know about the new halo elements
  // betweeen them but at this moment only processor 1 can compute that
  // info., since it is the only one that currently has that info.
  
  // Store the new local-halo elements of each processor, the HALOED
  // elements are also stored in the container, only needs to INVERT
  // the indexes. For example, the HALO elements of processor 2 with
  // processor 3 are stored in new_local_halo_element_pt[2][3], and
  // the HALOED elements of processor 2 with processor 3 are stored in
  // new_local_halo_element_pt[3][2]. Notice that these are also the
  // halo elements of processor 3 with 2
  
  // How to identify the new local halo/haloed element: 1) Loop over
  // the element; 2) Only work with nonhalo elements; 3) If the
  // element is not assigned to the current processor (iproc) then
  // check; 4) Is one of its nodes assiociated to the iproc processor?
  // 5) If yes the element is a halo in the iproc processor whose
  // nonhalo counter part (haloed) lives in the domain assigned to the
  // element
  Vector<Vector<Vector<FiniteElement*> > > new_local_halo_element_pt(nproc);
  
  // Loop over the processors
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // Resize the container
    new_local_halo_element_pt[iproc].resize(nproc);
    
    // Boolean to know which elements have been already added to the
    // new local halo scheme in "iproc"
    Vector<std::map<FiniteElement*,bool> > new_local_halo_already_added(nproc);
    
    // Go through all the elements and identify the new local halo
    // elements of "iproc"
    unsigned nh_count5 = 0;
    for (unsigned e = 0; e < nelement_before_load_balance; e++)
     {
      // Get the element
      FiniteElement *ele_pt = this->finite_element_pt(e);
      // Only work with nonhalo elements
      if (!(ele_pt->is_halo()))
       {
        // Get the domain to which the current element is associated
        const unsigned ele_domain = 
         target_domain_for_local_non_halo_element[nh_count5++];
        // If the current element is not associated to the "iproc"
        // processor then it could be a halo element
        if (ele_domain != iproc)
         {
          // Get the number of nodes
          const unsigned nnodes = ele_pt->nnode();
          // Loop over the nodes
          for (unsigned j = 0; j < nnodes; j++)
           {
            Node* node_pt = ele_pt->node_pt(j);
            // Check if the node is associated with the current
            // "iproc" processor
            std::set<unsigned>::iterator it = 
             processors_associated_with_data_before_load_balance[node_pt].
             find(iproc);
            // If it is found then the element is a halo-element
            if (it!=
                processors_associated_with_data_before_load_balance[node_pt].
                end())
             {
              // Add the element as new local-halo element with the
              // "ele_domain" processor. The non-halo counterpart will
              // be located on "ele_domain" processor after sending
              // elements across
              if (!new_local_halo_already_added[ele_domain][ele_pt])
               {
                // The element is a halo element on "iproc" with
                // "ele_domain"
                new_local_halo_element_pt[iproc][ele_domain].
                 push_back(ele_pt);
                // Mark as done
                new_local_halo_already_added[ele_domain][ele_pt] = true;
               } // if (!new_local_halo_already_added[ele_domain][ele_pt])
             } // One of the nodes lies on an element on the current
               // "iproc" processor
           } // for (j < nnodes)
         } // if (ele_domain != iproc)
       } // if (!(ele_pt->is_halo()))
     } // for (e < nelement_before_load_balance)
    
    // Now do the same with the halo elements, we need to find those
    // halo elements that continue being halo elements but possibly
    // with/on another processor. The pair of processors where a
    // possible shared boundary is created needs to be notified.
    
    // Example
    // 
    // ---------------*        *---------------
    // |             |*        *|             |
    // |             |*        *|             |
    // |  New domain |*        *|  New domain |       * Mark the position
    // |    proc 1   |*        *|    proc 3   |         of halo elements
    // |             |*        *|             |
    // |             |*        *|             |
    // ---------------*        *---------------
    //     Proc 1                  Proc 2
    
    // Processor 1: The halo elements on processor 1 continue being halo ON
    // PROCESSOR 1, but now WITH PROCESSOR 3
    
    // Processor 2: The halo elements on processor 2 continue being
    // halo BUT now ON PROCESSOR 3 WITH PROCESSOR 1
    
    // The current processor (my_rank) also needs to consider the halo
    // elements that will be halo elements of other processor with
    // another processor. The case of processor 2
    
    // Loop over all the halo elements in the current processor and
    // check if they will be halo with the "iproc" processor
    for (unsigned jproc = 0; jproc < nproc; jproc++)
     {
      // There are no halo elements with myself (the old halo elements
      // were halo in the "my_rank" processor)
      if (jproc != my_rank)
       {
        // Get the number of halo elements with the "jproc" processor
        const unsigned n_halo_ele_jproc = this->nroot_halo_element(jproc);
        // Get the halo elements with the "jproc" processor
        Vector<GeneralisedElement*> halo_element_pt_jproc = 
         this->root_halo_element_pt(jproc);
        // ... and check if any of those elements is a new halo
        // element with the "iproc" processor
        for (unsigned jh = 0; jh < n_halo_ele_jproc; jh++)
         {
          // Get the new domain for the halo element
          const unsigned ele_domain = new_domains_halo_elements[jproc][jh];
          
          // If the current element is not associated to the "iproc"
          // processor then it could be a halo element on "iproc" with
          // "ele_domain".
          
          // NOTE OUTDATE: Check if the halo element is going to be
          // sent to this processor (my_rank), if that is the case
          // then we don't need to add it to the set of new halo
          // elements with any other processor since any possible
          // shared boundary will be created when checking for the
          // intersection of the sent and received elements
          
          //if (ele_domain != iproc && ele_domain != my_rank)
          
          // NOTE UPDATE: Only check if the halo element is not going
          // to be part of the iproc processor, not required to avoid
          // those halo elements whose domain is the current rank
          // (my_rank). When the shared boundaries are computed, these
          // last elements can not create a shared boundary since no
          // haloed elements (that shared an edge) are found for
          // them. By considering also those halo elements whose new
          // domain is the current one (commenting "ele_domain !=
          // my_rank") the current processor can compute shared
          // boundaries with the iproc processor with help of its old
          // halo elements but that will become nonhalo elements, in
          // fact they will become haloed elements The halo element is
          // not sent to the "element_domain" processor and is not
          // passed to the array used to create the new shared
          // boundaries "new_shared_boundary_element_pt" because of
          // its halo condition
          if (ele_domain != iproc)
           {
            // Get the finite element
            FiniteElement* ele_pt = 
             dynamic_cast<FiniteElement*>(halo_element_pt_jproc[jh]);
            // Get the number of nodes on the halo element
            const unsigned nnodes = ele_pt->nnode();
            // Loop over the nodes
            for (unsigned j = 0; j < nnodes; j++)
             {
              // Get each node of the halo element
              Node* node_pt = ele_pt->node_pt(j);
                
              // Check if the node is associated with the "iproc"
              // processor
              std::set<unsigned>::iterator it = 
               processors_associated_with_data_before_load_balance[node_pt].
               find(iproc);
              // If it is found then the element is a halo-element
              if (it!=
                  processors_associated_with_data_before_load_balance[node_pt].end())
               {
                // Add the element as new local-halo element with
                // the "ele_domain" processor. The non-halo
                // counterpart will be located on "ele_domain"
                // processor. Because this is a old-halo element it
                // will not be sent to the "element_domain" processor
                if (!new_local_halo_already_added[ele_domain][ele_pt])
                 {
                  // The element is a halo element on "iproc" with
                  // "ele_domain"
                  new_local_halo_element_pt[iproc][ele_domain].
                   push_back(ele_pt);
                  new_local_halo_already_added[ele_domain][ele_pt] = true;
                  
                  // Break the for of the nodes, the element has been
                  // already added to the new_local_halo_element_pt
                  // structure
                  break;
                  
                 } // if (!new_local_halo_already_added[ele_domain][ele_pt])
                  
               } // One of the nodes lies on an element belonging to
                 // "iproc" processor
                
             } // for (j < nnodes)
              
           } // if (ele_domain != iproc)
            
         } // for (jh < n_halo_ele_jproc)
          
       } // if (jproc != my_rank) // The old halo elements are halo
         // with other processors except with "my_rank"
      
     } // for (jproc < nproc): This is the one that goes for the halo
       // elements in the current processor to find the new halo
       // elements    
    
   } // for (iproc < nproc)
  
  // Get the time to compute new local halo elements within all
  // processors
  if (Print_timings_level_load_balance>1)
    {
      oomph_info << "CPU for computing new local halo elements (load balance) [4]: "
                 <<TimingHelpers::timer()-tt_start_compute_new_local_halo_elements
                 << std::endl;
    }
  
  // =====================================================================
  // END: COMPUTE THE NEW LOCAL HALO ELEMENTS OF ALL PROCESSORS IN THE
  //      CURRENT PROCESSOR
  //      ----- FOR NONHALO ELEMENTS AND FOR HALO ELEMENTS
  // =====================================================================
  
  // =====================================================================
  // BEGIN: COMPUTE THE NEW LOCAL SHARED BOUNDARY ELEMENTS AND THE
  // FACE ELEMENTS. THE SUBSET OF THE ELEMENTS TO SENT THAT ARE PART
  // OF THE NEW LOCAL SHARED BOUNDARY ELEMENTS ARE IDENTIFIED TO BE
  // MARKED AS HALOED ELEMENTS AND BELONGING TO THE SHARED BOUNDARY
  // ELEMENTS IN THE RECEIVED PROCESSOR
  // =====================================================================
  
  // Get the time to compute new local shared boundary elements
  double tt_start_compute_new_local_shd_bnd_ele=0.0;
  if (Print_timings_level_load_balance>1)
    {
      tt_start_compute_new_local_shd_bnd_ele=TimingHelpers::timer();
    }

  // Store the new local-shared boundary elements and the face indexes
  // The halo elements and halo face indexes
  Vector<Vector<Vector<FiniteElement*> > >
   new_local_halo_shared_boundary_element_pt(nproc);
  Vector<Vector<Vector<unsigned> > >
   new_local_halo_shared_boundary_element_face_index(nproc);
  
  // Allocate enough memory for the containers
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    new_local_halo_shared_boundary_element_pt[iproc].resize(nproc);
    new_local_halo_shared_boundary_element_face_index[iproc].resize(nproc);
   } // for (iproc < nproc)
  
  // Get the elements that create the new local-halo-shared
  // boundaries, mark them and identify the face that lies on the
  // shared boundary. The new local-halo-shared boundary elements are
  // actually a sub-set of the halo elements of each processor with in
  // each processor
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // Star from jproc = iproc + 1 to avoid double creation of shared
    // boundary elements, any shared boundary element identified
    // between processor "iproc" and "jproc" is also established as
    // shared boundary element between processor "jproc" and "iproc"
    for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
     {
      this->get_shared_boundary_elements_and_face_indexes(
       new_local_halo_element_pt[iproc][jproc], 
       new_local_halo_element_pt[jproc][iproc],
       new_local_halo_shared_boundary_element_pt[iproc][jproc],
       new_local_halo_shared_boundary_element_face_index[iproc][jproc],
       new_local_halo_shared_boundary_element_pt[jproc][iproc],
       new_local_halo_shared_boundary_element_face_index[jproc][iproc]);
     } // for (jproc < nproc)
   } // for (iproc < nproc)
  
  // The time to compute new local shared boundary elements
  if (Print_timings_level_load_balance>1)
    {
      oomph_info << "CPU for computing new local shared boundary elements (load balance) [5]: "
                 <<TimingHelpers::timer()-tt_start_compute_new_local_shd_bnd_ele
                 << std::endl;
    }
  
  // =====================================================================
  // END: COMPUTE THE NEW LOCAL SHARED BOUNDARY ELEMENTS AND THE FACE
  // ELEMENTS. THE SUBSET OF THE ELEMENTS TO SENT THAT ARE PART OF THE
  // NEW LOCAL SHARED BOUNDARY ELEMENTS ARE IDENTIFIED TO BE MARKED AS
  // HALOED ELEMENTS AND BELONGING TO THE SHARED BOUNDARY ELEMENTS IN
  // THE RECEIVED PROCESSOR
  // =====================================================================
  
  // =====================================================================
  // BEGIN: SEND THE ELEMENTS AND IDENTIFY THOSE THAT ARE PART OF THE
  // SHARED BOUNDARIES AND HALOED WITH OTHER PROCESSORS
  // =====================================================================
  
  // Get the time to send the elements to their new processor in
  // charge
  double tt_start_send_elements_to_other_processors=0.0;
  if (Print_timings_level_load_balance>1)
    {
      tt_start_send_elements_to_other_processors=TimingHelpers::timer();
    }
  
  // Sort the nodes on shared boundaries so that they have the same
  // order on all the shared boundaries, this is required to know the
  // possible shared nodes among processors
  this->sort_nodes_on_shared_boundaries();
  
  // Store the received elements from each processor
  Vector<Vector<FiniteElement*> > received_elements_pt(nproc);
  
  // The haloed elements and haloed face indexes, these store the
  // haloed elements received from "iproc" but that are haloed with
  // "jproc". The elements are received from "iproc" which was the
  // processor that computed the haloed relation of the "my_rank"
  // processor with "jproc"
  Vector<Vector<Vector<FiniteElement*> > >
   new_received_haloed_shared_boundary_element_pt(nproc);
  Vector<Vector<Vector<unsigned> > >
   new_received_haloed_shared_boundary_element_face_index(nproc);
  
  // Container where to store the nodes on shared boundaries not
  // associated with the processor that receives the elements/nodes
  // other_proc_shd_bnd_node_pt[iproc][jproc][shd_bnd_id][index]
  Vector<Vector<Vector<std::map<unsigned, Node*> > > >
   other_proc_shd_bnd_node_pt(nproc);
  // Resize the container
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // Resize the container
    other_proc_shd_bnd_node_pt[iproc].resize(nproc);
    for (unsigned jproc = 0; jproc < nproc; jproc++)
     {
      // Get the number of shared boundaries (OLD shared boundaries)
      const unsigned initial_shd_bnd_id = this->initial_shared_boundary_id();
      const unsigned final_shd_bnd_id = this->final_shared_boundary_id();
      const unsigned n_shared_bound = final_shd_bnd_id - initial_shd_bnd_id;
      other_proc_shd_bnd_node_pt[iproc][jproc].resize(n_shared_bound);
     } // for (jproc < nproc)
    
   } // for (iproc < nproc)
  
  // Store the global node names
  // global_node_name[x][ ][ ] Global node number
  // global_node_name[ ][x][ ] Global node names
  // global_node_name[ ][ ][x] Global node info.
  Vector<Vector<Vector<unsigned> > > global_node_names;
  
  // Creates a map between the node name and the index of the global
  // node so we can access all its node names
  std::map<Vector<unsigned>, unsigned> node_name_to_global_index;
  
  // Store the global shared nodes pointers
  Vector<Node*> global_shared_node_pt;
  
  // Compute all the names of the nodes and fill in the
  // "other_proc_shd_bnd_node_pt" structure with the nodes that live
  // on this processor (my_rank) by looking over all their names
  compute_global_node_names_and_shared_nodes(other_proc_shd_bnd_node_pt, 
                                             global_node_names,
                                             node_name_to_global_index,
                                             global_shared_node_pt);
  
  // From the elements received from each processor, store the haloed
  // information of the element, it means, the processor with which it
  // is haloed and the haloed index with that processor
  Vector<Vector<std::map<unsigned,FiniteElement*> > > 
   received_old_haloed_element_pt(nproc);
  // [x][][] : The receiver processor (the original processor)
  // [][x][] : The processor with which the receiver processor has
  //           haloed elements
  // [][][x]: The haloed element number
  
  // Resize the container
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    received_old_haloed_element_pt[iproc].resize(nproc);
   } // for (iproc < nproc)
  
  // Go through all processors and send the corresponding elements to
  // each one
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    if (iproc != my_rank)
     {
      // -----------------------------------------------------------
      // Send (package) information of the elements
      // -----------------------------------------------------------
      
      // Keep track of the currently sent elements
      Vector<FiniteElement*> currently_sent_elements;
      // Keep track of the currently sent nodes to the iproc processor
      Vector<Node*> currently_sent_nodes;
      
      // Clear send and receive buffers
      Flat_packed_unsigneds.clear();
      Flat_packed_doubles.clear();
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.clear();
#endif
      
      // Get the number of elements to send to iproc processor
      const unsigned nelements_to_send = elements_to_send_pt[iproc].size();
      
      // The very first data of the flat package sent to processor
      // iproc is the number of elements that will be sent, this data
      // is used by the receiver processor to loop over the number of
      // expected elements to receive
      Flat_packed_unsigneds.push_back(nelements_to_send);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk;
      junk << "Number of elements to send from processor " << my_rank
           << " to processor " << iproc << ": (" 
           << nelements_to_send << ")";
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif
      
      // Loop over the elements to sent
      for (unsigned e = 0; e < nelements_to_send; e++)
       {
        // Get the element to send
        FiniteElement* send_ele_pt = elements_to_send_pt[iproc][e];
        
        // Get the current number of sent elements
        const unsigned ncurrently_sent_elements = 
         currently_sent_elements.size();
        
        // Try to add the element
        const unsigned index_ele = try_to_add_element_pt_load_balance(
         currently_sent_elements, send_ele_pt);
        
        // Element needs to be added
        if (index_ele == ncurrently_sent_elements)
         {
          Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
          Flat_packed_unsigneds_string.push_back("Element needs to be constructed");
#endif
          
          // Get required info. related with the element
          get_required_elemental_information_load_balance_helper(
           iproc,
           f_haloed_element_pt,
           send_ele_pt);
          
          // Get the number of nodes in the element
          const unsigned nnodes = send_ele_pt->nnode();
          
          // Loop over the nodes in the element
          for (unsigned j = 0; j < nnodes; j++)
           {
            Node* node_pt = send_ele_pt->node_pt(j);
            
            // Package the info. of the nodes
            add_node_load_balance_helper(iproc, // The destination process
                                         f_halo_element_pt,
                                         currently_sent_nodes, 
                                         node_pt);
            
           } // for (j < nnodes)
          
         } // if (index_ele == ncurrently_sent_elements)
        else
         {
          Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
          Flat_packed_unsigneds_string.push_back("Element already exists");
#endif
          Flat_packed_unsigneds.push_back(index_ele);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
          Flat_packed_unsigneds_string.push_back("Index of existing element");
#endif
         } // else if (index_ele == ncurrently_sent_elements)
        
       } // for (e < nelements_to_send)
      
      // After storing the info. of the elements identify the indexes
      // of the "new_local_halo_shared_boundary_elements" in the
      // "currently_send_elements" vector, these elements will be
      // identified as "new_received_haloed_shared_boundary_elements"
      // on the "receiver" processor
      
      // Each processor has information of every other processor so we
      // need to send all the corresponding info. to the other
      // processors. Processor 1 may have information of the relation
      // (halo elements) between processor 3 and 4 say, so processor 1
      // needs to let know processor 3 and 4 what this relation is
      // (which are the shared-elements among these processors)
      
      for (unsigned jproc = 0; jproc < nproc; jproc++)
       {
        // Get the number of new local-halo shared boundary elements
        // between processor "jproc" and "iproc" (we invert the index
        // since we really want the haloed elements, those elements
        // that we have just sent)
        const unsigned njproc_iproc_new_local_halo_shared_boundary_ele = 
         new_local_halo_shared_boundary_element_pt[jproc][iproc].size();
        
        // The vector with the info. of the indexes
        Vector<unsigned> new_local_halo_shared_boundary_ele_index;
        
        // The number of found shared boundary elements in the sent
        // container (only consider the nonhalo elements)
        unsigned nfound_new_local_halo_shared_bound_ele_index = 0;
        // The number of nonhalo elements in the new local halo shared
        // boundary elements
        unsigned nnon_halo_new_local_halo_shared_bound_ele = 0;
        
        // Loop over the local halo shared boundary elements between
        // processor jproc and iproc
        for (unsigned e = 0; 
             e < njproc_iproc_new_local_halo_shared_boundary_ele; e++)
         {
          // Get the shared boundary element
          FiniteElement* shared_ele_pt = 
           new_local_halo_shared_boundary_element_pt[jproc][iproc][e];
          
          // Only consider the nonhalo elements since the halo
          // elements were no considered for sending
          if (!shared_ele_pt->is_halo())
           {
            nnon_halo_new_local_halo_shared_bound_ele++;
            
            // Now find the index on the currently sent elements
            
            // Get the current number of sent elements
            const unsigned ncurrently_sent_elements = 
             currently_sent_elements.size();
            // Loop over the sent elements
            for (unsigned ics = 0; ics < ncurrently_sent_elements; ics++)
             {
              FiniteElement* currently_sent_ele_pt = 
               currently_sent_elements[ics];
              
              // Is this the element?
              if (currently_sent_ele_pt == shared_ele_pt)
               {
                // Store the index on the sent elements of the local
                // halo shared boundary element
                new_local_halo_shared_boundary_ele_index.push_back(ics);
                // Increase the number of found new local halo shared
                // bound element index
                nfound_new_local_halo_shared_bound_ele_index++;
                // We have found it, no need to further search
                break;
               } // if (currently_sent_ele_pt == shared_ele_pt)
              
             } // for (ics < ncurrently_sent_elements)
            
           } // if (!shared_ele_pt->is_halo())
          
         } // for (e < niproc_new_local_halo_shared_boundary_ele)
        
#ifdef PARANOID
        if (nfound_new_local_halo_shared_bound_ele_index != 
            nnon_halo_new_local_halo_shared_bound_ele)
         {
          std::ostringstream error_message;
          error_message
           << "Was only possible to identify (" 
           << nfound_new_local_halo_shared_bound_ele_index << ") of (" 
           << nnon_halo_new_local_halo_shared_bound_ele << ") shared "
           << "elements between\nprocessor ("<<iproc<<") and ("<<jproc<<") "
           << "when sending elements to processor ("<<iproc<<")\n\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
         }
#endif
        
        // Send a flag for synchronisation issues
        Flat_packed_unsigneds.push_back(9999);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk;
        junk << "Flag for synchronisation 9999";
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif
        
        // Send the number of nonhalo new local-shared boundary
        // elements of processor "iproc" with processor "jproc"
        Flat_packed_unsigneds.push_back(nnon_halo_new_local_halo_shared_bound_ele);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk2;
        junk2 << "Number of new local halo shared boundary elements "
             << nnon_halo_new_local_halo_shared_bound_ele;
        Flat_packed_unsigneds_string.push_back(junk2.str());
#endif
        
        // Send the indexes and the face indexes of the shared
        // boundary elements
        unsigned counter_nonhalo_sent = 0;
        // Loop over the local halo shared boundary elements between
        // processor jproc and iproc
        for (unsigned e = 0; 
             e < njproc_iproc_new_local_halo_shared_boundary_ele; e++)
         {
          // Get the shared boundary element
          FiniteElement* shared_ele_pt = 
           new_local_halo_shared_boundary_element_pt[jproc][iproc][e];
          
          // Only consider the nonhalo elements since the halo
          // elements were no considered for sending
          if (!shared_ele_pt->is_halo())
           {
            // Get the index on the sent elements of the current
            // nonhalo shared boundary element
            const unsigned ele_index = 
             new_local_halo_shared_boundary_ele_index[counter_nonhalo_sent++];
            // ... and get the face index
            const unsigned face_index = 
             new_local_halo_shared_boundary_element_face_index[jproc][iproc][e];
            
            // Send the index on the sent elements of the new local
            // halo shared boundary element
            Flat_packed_unsigneds.push_back(ele_index);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
            std::stringstream junk;
            junk << "The index of the halo shared boundary element " 
                 << ele_index;
            Flat_packed_unsigneds_string.push_back(junk.str());
#endif
            
            // Send the face index of the new local halo shared boundary
            // element
            Flat_packed_unsigneds.push_back(face_index);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
            std::stringstream junk2;
            junk2 << "The face index of the halo shared boundary element " 
                 << face_index;
            Flat_packed_unsigneds_string.push_back(junk2.str());
#endif
            
           } // if (!shared_ele_pt->is_halo())
          
         } // for (e < niproc_new_local_halo_shared_boundary_ele)
        
       } // for (jproc < nproc)
      
      // ----------------------------------------------------------
      // Send the info. perform the communications
      // ----------------------------------------------------------
      // Processor to which send the info.
      int send_proc = static_cast<int>(iproc);
      // Processor from which receive the info.
      int recv_proc = static_cast<int>(iproc);
      send_and_receive_elements_nodes_info(send_proc, recv_proc);
      
      // ----------------------------------------------------------
      // Receive (unpackage) the info of the elements
      // ----------------------------------------------------------
      
      // Keep track of the currently created elements
      Vector<FiniteElement*> currently_created_elements;
      // Keep track of the currently created nodes
      Vector<Node*> currently_created_nodes;
      
      // Reset the counters
      Counter_for_flat_packed_doubles=0;
      Counter_for_flat_packed_unsigneds=0;
      
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << " Number of elements need to be constructed " 
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      
      // Read the number of elements that need to be created
      const unsigned nelements_to_create = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
      for (unsigned e = 0; e < nelements_to_create; e++)
       {
        // Create the element from received info. of "iproc"
        // processor on the current processor
        create_element_load_balance_helper(iproc, 
                                           f_haloed_element_pt,
                                           received_old_haloed_element_pt,
                                           currently_created_elements, 
                                           currently_created_nodes,
                                           other_proc_shd_bnd_node_pt,
                                           global_node_names,
                                           node_name_to_global_index,
                                           global_shared_node_pt);
       }
      
      // Copy the received elements from "iproc" processor
      
      // Number of received elements
      const unsigned nreceived_elements = currently_created_elements.size();
      received_elements_pt[iproc].resize(nreceived_elements);
      for (unsigned e = 0; e < nreceived_elements; e++)
       {received_elements_pt[iproc][e] = currently_created_elements[e];}
      
      // Go for the haloed elements received from processor "iproc"
      // but haloed with "jproc"
      
      // Allocate memory for the containers
      new_received_haloed_shared_boundary_element_pt[iproc].resize(nproc);
      new_received_haloed_shared_boundary_element_face_index[iproc].resize(nproc);
      
      // Loop over the processors
      for (unsigned jproc = 0; jproc < nproc; jproc++)
       {
        // Read the synchronisation flag
        const unsigned synchronisation_flag = 
         Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        
        if (synchronisation_flag != 9999)
         {
          std::ostringstream error_message;
          error_message
           << "The synchronisation flag was not read, the\n"
           << "information sent between processor (" << my_rank << ") "
           << "and ("<< iproc << ")\nis no longer synchronised\n\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
         }
        
        // Read the number of elements that will be part of the new
        // received haloed shared boundary elements received from "iproc"
        // and haloed with "jproc"
        const unsigned niproc_jproc_new_received_haloed_shared_boundary_ele = 
         Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        
        // Loop over the new received haloed shared boundary elements
        for (unsigned e = 0; 
             e < niproc_jproc_new_received_haloed_shared_boundary_ele; e++)
         {
          // Read the index of the new received haloed shared boundary
          // ele with "jproc"
          const unsigned ele_index = 
           Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
          // Read the face index for the new received haloed shared
          // boundary element
          const unsigned face_index = 
           Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
          
          // Get the element
          FiniteElement* shared_ele_pt = 
           currently_created_elements[ele_index];
          
          // Add the element to the new received-haloed shared
          // boundary elements. Received from "iproc" but haloed with
          // "jproc" processor
          new_received_haloed_shared_boundary_element_pt[iproc][jproc].
           push_back(shared_ele_pt);
          // Store the face index
          new_received_haloed_shared_boundary_element_face_index[iproc][jproc].
           push_back(face_index);
          
         } // for (e < niproc_jproc_read_new_local_shared_boundary_ele)
        
       } // for (jproc < nproc)
      
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc)
  
  // The time to send the elements to their new processor in charge
  if (Print_timings_level_load_balance>1)
    {
      oomph_info << "CPU for sending elements to their new processors (load balance) [6]: "
                 <<TimingHelpers::timer()-tt_start_send_elements_to_other_processors
                 << std::endl;
    }
  
  // =====================================================================
  // END: SEND THE ELEMENTS AND IDENTIFY THOSE THAT ARE PART OF THE
  // SHARED BOUNDARIES AND HALOED WITH OTHER PROCESSORS
  // =====================================================================
  
  // =====================================================================
  // BEGIN: GET ANY ADDITIONAL SHARED BOUNDARY BY THE INTERSECTION OF
  // THE ELEMENTS SENT TO PROCESSOR "IPROC" AND THE ELEMENTS RECEIVED
  // FROM PROCESSOR "IPROC". IF ANY NEW SHARED BOUNDARY IS FOUND, IT
  // IS CREATED BY THE OLD HALO ELEMENTS (RECEIVED ELEMENTS) THAT HAVE
  // NOW BECOME PART OF THE DOMAIN AND THE OLD HALOED ELEMENTS (SENT
  // ELEMENTS) 
  // =====================================================================
    
  // Get the time to compute any additional shared boundary
  double tt_start_compute_additional_shared_boundaries=0.0;
  if (Print_timings_level_load_balance>1)
    {
      tt_start_compute_additional_shared_boundaries=TimingHelpers::timer();
    }
  
  // Store any additional elements that may create a shared boundary,
  // after sending elements from one to other processor check for any
  // new possible shared boundaries
  Vector<Vector<FiniteElement*> > 
   tmp_group1_shared_boundary_element_pt(nproc);
  Vector<Vector<unsigned> > 
   tmp_group1_shared_boundary_element_face_index(nproc);
  Vector<Vector<FiniteElement*> > 
   tmp_group2_shared_boundary_element_pt(nproc);
  Vector<Vector<unsigned> > 
   tmp_group2_shared_boundary_element_face_index(nproc);
  
  // Compute any additional shared boundaries by checking the
  // intersection between the received elements from each processor
  // and the elements just sent to that processor, the lowest
  // processors number loops over its received elements and the
  // highest loops over its sent elements (halo elements that have
  // become part of the domain now can create shared boundaries with
  // other processor)
  
  // Note: These additional shared boundaries may be created by the
  // elements that previously were halo but now have become part of
  // the processor (the received elements), and the elements that were
  // previously part of the processor but now have become halo (a
  // subset of the sent-elements)
  
  // Then these new shared boundaries come from the intersection of
  // the new-haloed elements (received elements) and the new-halo
  // elements (sent elements). These could be computed previously (in
  // the computing of the local new-halo and local new-haloed elements
  // usign the info. of the new domains for the old halo elements),
  // however, it was decided to perform the computation here in order to
  // avoid the identification of the old halo element that was part of a 
  // shared boundary in the set of just received elements
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    if (my_rank < iproc)
     {
      // Lowest processor loops over the received elements
      this->get_shared_boundary_elements_and_face_indexes(
       received_elements_pt[iproc], elements_to_send_pt[iproc],
       tmp_group1_shared_boundary_element_pt[iproc],
       tmp_group1_shared_boundary_element_face_index[iproc],
       tmp_group2_shared_boundary_element_pt[iproc],
       tmp_group2_shared_boundary_element_face_index[iproc]);
      
     } // if (my_rank < iproc)
    else if (my_rank > iproc)
     {
      // Highest processor loops over the sent elements
      this->get_shared_boundary_elements_and_face_indexes(
       elements_to_send_pt[iproc], received_elements_pt[iproc],
       tmp_group1_shared_boundary_element_pt[iproc],
       tmp_group1_shared_boundary_element_face_index[iproc],
       tmp_group2_shared_boundary_element_pt[iproc],
       tmp_group2_shared_boundary_element_face_index[iproc]);
      
     } //  else if (my_rank > iproc)
    
   } // for (iproc < nproc)
  
  // The time to compute any additional shared boundary
  if (Print_timings_level_load_balance>1)
    {
      oomph_info << "CPU for computing additional shared boundaries (load balance) [7]: "
                 <<TimingHelpers::timer()-tt_start_compute_additional_shared_boundaries
                 << std::endl;
    }
  
  // =====================================================================
  // END: GET ANY ADDITIONAL SHARED BOUNDARY BY THE INTERSECTION OF
  // THE ELEMENTS SENT TO PROCESSOR "IPROC" AND THE ELEMENTS RECEIVED
  // FROM PROCESSOR "IPROC". IF ANY NEW SHARED BOUNDARY IS FOUND, IT
  // IS CREATED BY THE OLD HALO ELEMENTS (RECEIVED ELEMENTS) THAT HAVE
  // NOW BECOME PART OF THE DOMAIN AND THE OLD HALOED ELEMENTS (SENT
  // ELEMENTS)
  // =====================================================================
  
  // =====================================================================
  // BEGIN: SORT THE SHARED BOUNDARIES SO THAT THEY ARE CREATED IN THE
  // SAME ORDER IN THE INVOLVED PROCESSORS (A PAIR OF PROCESSORS)
  // =====================================================================
  
  // Get the time to sort shared boundaries
  double tt_start_sort_shared_boundaries=0.0;
  if (Print_timings_level_load_balance>1)
    {
      tt_start_sort_shared_boundaries=TimingHelpers::timer();
    }
  
  // Once computed the elements that create the shared boundaries,
  // sort them so that the shared boundaries are created at the same
  // order in both processors that define the shared boundary
  
  // The order is like this
  
  // Lowest processors
  // 1) Shared boundary elements received from processors (local in
  // other processors)
  // 2) Local shared boundary elements (do not include halo elements)
  // 3) Shared boundary elements by intersection (already sorted)
  
  // Highest processors
  // 1) Local shared boundary elements (do not include halo elements)
  // 2) Shared boundary elements received from processors (local in
  // other processors)
  // 3) Shared boundary elements by intersection (already sorted)
  
  Vector<Vector<FiniteElement*> > new_shared_boundary_element_pt(nproc);
  Vector<Vector<unsigned> > new_shared_boundary_element_face_index(nproc);
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // Lower processor
    if (my_rank < iproc)
     {
      // Copy the elements received from processor "jproc" but that
      // are haloed with "iproc" processor
      for (unsigned jproc = 0; jproc < nproc; jproc++)
       {
        // Can not receive elements from itself
        if (jproc != my_rank)
         {
          // Get the number of elements to copy from received processors
          const unsigned nrecvd_haloed_shared_bound_ele_jproc_iproc = 
           new_received_haloed_shared_boundary_element_pt[jproc][iproc].size();
          for (unsigned e = 0; 
               e < nrecvd_haloed_shared_bound_ele_jproc_iproc; e++)
           {
            // Get the element
            FiniteElement* ele_pt = 
             new_received_haloed_shared_boundary_element_pt[jproc][iproc][e];
            // Get the face index
            const unsigned face_index = 
             new_received_haloed_shared_boundary_element_face_index[jproc][iproc][e];
            
            // Add the elements to the containers
            new_shared_boundary_element_pt[iproc].push_back(ele_pt);
            new_shared_boundary_element_face_index[iproc].push_back(face_index);
            
           } // for (e < nrecvd_haloed_shared_bound_ele_iproc_jproc)
          
         } // if (jproc != my_rank)
        
       } // for (jproc < nproc)

      // Then the local shared haloed (invert the indexes to get the
      // haloed elements)
      const unsigned nlocal_haloed_shared_bound_ele_iproc_my_rank = 
       new_local_halo_shared_boundary_element_pt[iproc][my_rank].size();
      for (unsigned e = 0; 
           e < nlocal_haloed_shared_bound_ele_iproc_my_rank; e++)
       {
        // Get the element
        FiniteElement* ele_pt = 
         new_local_halo_shared_boundary_element_pt[iproc][my_rank][e];
        // Get the face index
        const unsigned face_index = 
         new_local_halo_shared_boundary_element_face_index[iproc][my_rank][e];
        
        // Only include the element if it is nonhalo (this may be an
        // old halo element that helped to indentify a shared boundary
        // with iproc)
        if (!ele_pt->is_halo())
         {
          // Add the elements to the containers
          new_shared_boundary_element_pt[iproc].push_back(ele_pt);
          new_shared_boundary_element_face_index[iproc].push_back(face_index);
         } // if (!ele_pt->is_halo())
        
       } // for (e < nlocal_haloed_shared_bound_ele_iproc_my_rank)
      
      // ... and finally any additional shared boundary elements from
      // tmp_group1
      const unsigned ntmp_group1_shared_bound_ele_iproc = 
       tmp_group1_shared_boundary_element_pt[iproc].size();
      for (unsigned e = 0; e < ntmp_group1_shared_bound_ele_iproc; e++)
       {
        // Get the element
        FiniteElement* ele_pt = 
         tmp_group1_shared_boundary_element_pt[iproc][e];
        // Get the face index
        const unsigned face_index = 
         tmp_group1_shared_boundary_element_face_index[iproc][e];
        
        // Add the elements to the containers
        new_shared_boundary_element_pt[iproc].push_back(ele_pt);
        new_shared_boundary_element_face_index[iproc].push_back(face_index);
        
       } // for (e < ntmp_group1_shared_bound_ele_iproc)
      
     } // if (my_rank < iproc)
    // Highest processor
    else if (my_rank > iproc)
     {
      // Get the haloed elements first and then the elements received
      // from processor "jproc" but that are haloed with "iproc"
      // processor

      // Get the number of elements to copy from local elements
      // (invert the indexes to get the haloed elements)
      const unsigned nlocal_haloed_shared_bound_ele_iproc_my_rank = 
       new_local_halo_shared_boundary_element_pt[iproc][my_rank].size();
      for (unsigned e = 0; 
           e < nlocal_haloed_shared_bound_ele_iproc_my_rank; e++)
       {
        // Get the element
        FiniteElement* ele_pt = 
         new_local_halo_shared_boundary_element_pt[iproc][my_rank][e];
        // Get the face index
        const unsigned face_index = 
         new_local_halo_shared_boundary_element_face_index[iproc][my_rank][e];
        
        // Only include the element if it is nonhalo (this may be an
        // old halo element that helped to indentify a shared boundary
        // with iproc)
        if (!ele_pt->is_halo())
         {
          // Add the elements to the containers
          new_shared_boundary_element_pt[iproc].push_back(ele_pt);
          new_shared_boundary_element_face_index[iproc].push_back(face_index);
         } // if (!ele_pt->is_halo())
        
       } // for (e < nlocal_haloed_shared_bound_ele_iproc_my_rank)
      
      for (unsigned jproc = 0; jproc < nproc; jproc++)
       {        
        // Can not receive elements from itself
        if (jproc != my_rank)
         {
          // Then the received shared elements from "jproc" but haloed
          // with "iproc"
          const unsigned nrecvd_haloed_shared_bound_ele_jproc_iproc = 
           new_received_haloed_shared_boundary_element_pt[jproc][iproc].size();
          for (unsigned e = 0; 
               e < nrecvd_haloed_shared_bound_ele_jproc_iproc; e++)
           {
            // Get the element
            FiniteElement* ele_pt = 
             new_received_haloed_shared_boundary_element_pt[jproc][iproc][e];
            // Get the face index
            const unsigned face_index = 
             new_received_haloed_shared_boundary_element_face_index[jproc][iproc][e];
            
            // Add the elements to the containers
            new_shared_boundary_element_pt[iproc].push_back(ele_pt);
            new_shared_boundary_element_face_index[iproc].push_back(face_index);
            
           } // for (e < nrecvd_haloed_shared_bound_ele_iproc)
          
         } // if (jproc != my_rank)
        
       } // for (jproc < nproc)
      
      // ... and finally any additional shared boundary elements from
      // tmp_group2
      const unsigned ntmp_group2_shared_bound_ele_iproc = 
       tmp_group2_shared_boundary_element_pt[iproc].size();
      for (unsigned e = 0; e < ntmp_group2_shared_bound_ele_iproc; e++)
       {
        // Get the element
        FiniteElement* ele_pt = 
         tmp_group2_shared_boundary_element_pt[iproc][e];
        // Get the face index
        const unsigned face_index = 
         tmp_group2_shared_boundary_element_face_index[iproc][e];
        
        // Add the elements to the containers
        new_shared_boundary_element_pt[iproc].push_back(ele_pt);
        new_shared_boundary_element_face_index[iproc].push_back(face_index);
        
       } // for (e < ntmp_group2_shared_bound_ele_iproc)
      
     } // else if (my_rank > iproc)
    
   } // for (iproc < nproc)
  
  // The time to sort shared boundaries
  if (Print_timings_level_load_balance>1)
    {
      oomph_info << "CPU for sorting shared boundaries (load balance) [8]: "
                 <<TimingHelpers::timer()-tt_start_sort_shared_boundaries
                 << std::endl;
    }
  
  // =====================================================================
  // END: SORT THE SHARED BOUNDARIES SO THAT THEY ARE CREATED IN THE
  // SAME ORDER IN THE INVOLVED PROCESSORS (A PAIR OF PROCESSORS)
  // =====================================================================
  
  // =====================================================================
  // BEGIN: CREATE THE NEW SHARED BOUNDARIES. BEFORE THE GENERATION OF
  // THE SHARED BOUNDARIES PUT IN A CONTAINER THOSE NONHALO ELEMENTS
  // THAT WILL REMAIN IN THE CURRENT PROCESSOR (BECAUSE THEIR RANK IS
  // THE SAME AS THE CURRENT PROCESSOR), AND THOSE ELEMENTS RECEIVED
  // FROM OTHER PROCESSORS. THESE SET OF ELEMENTS WILL BE USED TO
  // CHECK FOR POSSIBLE CONNECTIONS OF THE NEW SHARED BOUNDARIES WITH
  // THE ORIGINAL BOUNDARIES
  // =====================================================================
  // Finally, create the new shared boundaries
  
  // Get the time to create the new shared boundaries
  double tt_start_create_new_shared_boundaries=0.0;
  if (Print_timings_level_load_balance>1)
    {
      tt_start_create_new_shared_boundaries=TimingHelpers::timer();
    }
  
  // Compute the elements that will remain after deletion in the
  // curent processor. This is required to check if the new shared
  // boundaries crete a connection with any node of the elements in
  // the boundaries
  
  // Try to use as much information as possible
  
  // Storage for the elements in the processor
  std::set<FiniteElement*> element_in_processor_pt;
  
  // Loop over the old elements, those before sending/received
  // elements to/from other processors
  unsigned nh_count6 = 0;
  for (unsigned e = 0; e < nelement_before_load_balance; e++)
   {
    // Get the element
    FiniteElement* ele_pt = backed_up_ele_pt[e];
    // Only work with nonhalo elements
    if (!(ele_pt->is_halo()))
     {
      // Is the element part of the new domain
      if (target_domain_for_local_non_halo_element[nh_count6++] == my_rank)
       {
        // Add the element to the set of elements in the processor
        element_in_processor_pt.insert(ele_pt);
        
       }
      
     } // if (!(ele_pt->is_halo()))
    
   } // for (e < nelement_before_load_balance)
  
  // Now include the received elements from the other processors
  // Loop over the processors
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // No elements received from myself
    if (iproc != my_rank)
     {
      // Get the number of received elements with the "iproc"
      // processor
      const unsigned n_received_ele = received_elements_pt[iproc].size();
      for (unsigned ie = 0; ie < n_received_ele; ie++)
       {
        // Get the ie-th received element from processor iproc
        FiniteElement* ele_pt = received_elements_pt[iproc][ie];
        
        // Include it in the set of elements in the processor
        element_in_processor_pt.insert(ele_pt);
        
       } // for (ie < nreceived_ele)
      
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc)
  
  // Now create the shared boundaries
  create_new_shared_boundaries(element_in_processor_pt,
                               new_shared_boundary_element_pt,
                               new_shared_boundary_element_face_index);
  
  // The time to create the new shared boundaries
  if (Print_timings_level_load_balance>1)
    {
      oomph_info << "CPU for creating new shared boundaries (load balance) [9]: "
                 <<TimingHelpers::timer()-tt_start_create_new_shared_boundaries
                 << std::endl;
    }
  
  // =====================================================================
  // END: CREATE THE NEW SHARED BOUNDARIES. BEFORE THE GENERATION OF
  // THE SHARED BOUNDARIES PUT IN A CONTAINER THOSE NONHALO ELEMENTS
  // THAT WILL REMAIN IN THE CURRENT PROCESSOR (BECAUSE THEIR RANK IS
  // THE SAME AS THE CURRENT PROCESSOR), AND THOSE ELEMENTS RECEIVED
  // FROM OTHER PROCESSORS. THESE SET OF ELEMENTS WILL BE USED TO
  // CHECK FOR POSSIBLE CONNECTIONS OF THE NEW SHARED BOUNDARIES WITH
  // THE ORIGINAL BOUNDARIES
  // =====================================================================
  
  // =====================================================================
  // BEGIN: DELETE THE ELEMENTS NO LONGER BELONGING TO THE DOMAIN,
  // INCLUDING HALO ELEMENTS. ADD THE KEPT ELEMENTS TO THE MESH AND
  // THE RECEIVED ELEMENTS FROM OTHER PROCESSORS
  // =====================================================================
  
  // Get the time to delete elements no longer belonging to the
  // processor
  double tt_start_delete_elements=0.0;
  if (Print_timings_level_load_balance>1)
    {
      tt_start_delete_elements=TimingHelpers::timer();
    }
  
  // Once computed the new shared boundaries delete the elements that
  // no longer belong to the processor (including the old halo
  // elements)
  
  // The procedure is similar to the one performed at the distribution
  // stage (src/generic/mesh.cc -- distribute() method)
  
  // Clean the storage for halo(ed) elements/nodes
  this->Halo_node_pt.clear();
  this->Root_halo_element_pt.clear();
  
  this->Haloed_node_pt.clear();
  this->Root_haloed_element_pt.clear();
  
  // Mark all the nodes as obsolete
  const unsigned nnodes = this->nnode();
  for (unsigned j = 0; j < nnodes; j++)
   {
    this->node_pt(j)->set_obsolete();
   }
  
  // Flush the mesh storage
  this->flush_element_storage();
  
  // Delete any storage of external elements and nodes
  this->delete_all_external_storage();
  
  // Clear external storage
  this->External_halo_node_pt.clear();
  this->External_halo_element_pt.clear();
  
  this->External_haloed_node_pt.clear();
  this->External_haloed_element_pt.clear();
  
  // Keep track of the deleted elements
  Vector<FiniteElement*> deleted_elements;
  
  // Delete the elements that no longer belong to the processor
  unsigned nh_count7 = 0;
  for (unsigned e = 0; e < nelement_before_load_balance; e++)
   {
    FiniteElement* ele_pt = backed_up_ele_pt[e];
    // Only work with nonhalo elements
    if (!(ele_pt->is_halo()))
     {
      if (target_domain_for_local_non_halo_element[nh_count7++] == my_rank)
       {
        // Add the element to the mesh
        this->add_element_pt(ele_pt);
        // Get the number of nodes on the element
        const unsigned nele_nodes = ele_pt->nnode();
        // Loop over the nodes of the element
        for (unsigned j = 0; j < nele_nodes; j++)
         {
          // Mark the node as non-obsolete
          ele_pt->node_pt(j)->set_non_obsolete();
         } // for (j < nele_nodes)
        
       } // The element belongs to the domain
      else
       {
        // Delete the element, but keep track of it
        deleted_elements.push_back(ele_pt);
        // Delete and point to null
        delete ele_pt;
        ele_pt = 0;
       }
      
     } // if (!(ele_pt->is_halo()))
    else
     {
      // If the element is halo, delete if but keep track of it
      deleted_elements.push_back(ele_pt);
      // Delete and point to null
      delete ele_pt;
      ele_pt = 0;
     }
    
   } // for (e < nelement_before_load_balance)
  
  // Now add the received elements from each processor
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    if (iproc != my_rank)
     {
      // Get the number of received elements with the "iproc"
      // processor
      const unsigned nreceived_ele = received_elements_pt[iproc].size();
      for (unsigned ie = 0; ie < nreceived_ele; ie++)
       {
        // Get the element and add it to the mesh
        FiniteElement* ele_pt = received_elements_pt[iproc][ie];
        // Add the element to the mesh
        this->add_element_pt(ele_pt);
        // Get the number of nodes on the element
        const unsigned nele_nodes = ele_pt->nnode();
        // Loop over the nodes of the element
        for (unsigned j = 0; j < nele_nodes; j++)
         {
          // Mark the node as non-obsolete
          ele_pt->node_pt(j)->set_non_obsolete();
         } // for (j < nele_nodes)
        
       } // for (ie < nreceived_ele)
      
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc)
  
  // Now remove the obsolete nodes
  this->prune_dead_nodes();
  
  // The time to delete elements no longer belonging to the processor
  if (Print_timings_level_load_balance>1)
    {
      oomph_info << "CPU for deleting elements no longer belonging to this processor (load balance) [10]: "
                 <<TimingHelpers::timer()-tt_start_delete_elements
                 << std::endl;
    }
  
  // =====================================================================
  // END: DELETE THE ELEMENTS NO LONGER BELONGING TO THE DOMAIN,
  // INCLUDING HALO ELEMENTS. ADD THE KEPT ELEMENTS TO THE MESH AND
  // THE RECEIVED ELEMENTS FROM OTHER PROCESSORS
  // =====================================================================

  // =====================================================================
  // BEGIN: REESTABLISH THE HALO(ED) SCHEME, ATTACH HALO ELEMENTS
  // (HALO NODES INCLUDED) TO THE NEW MESH (AFTER LOAD BALANCING)
  // RESTORE THE BOUNDARY ELEMENTS SCHEME AND THE NUMBER OF SEGMENTS
  // ON EACH BOUNDARY
  // =====================================================================
  
  // Get the time to re-establish the halo(ed) information
  double tt_start_re_etablish_halo_ed_info=0.0;
  if (Print_timings_level_load_balance>1)
    {
      tt_start_re_etablish_halo_ed_info=TimingHelpers::timer();
    }
  
  // Prepare the data to re-establish the halo(ed) scheme
  
  // Sort the nodes on the new shared boundaries so that they have the
  // same order on all processors
  this->sort_nodes_on_shared_boundaries();
  
  // Before re-establish the halo and haloed elements save the number
  // of current elements in the boundaries, this will be useful to
  // re-establish the boundary elements. Notice that there may be
  // boundary elements with null pointers, since the element may no
  // longer belong to the current processor
  const unsigned tmp_nboundary = this->nboundary();
  Vector<unsigned> ntmp_boundary_elements(tmp_nboundary);

  // If there are regions, save the number of boundary-region elements
  Vector<Vector<unsigned> > ntmp_boundary_elements_in_region(tmp_nboundary);
  // Are there regions?
  const unsigned n_regions = this->nregion();
  
  // Loop over the boundaries
  for (unsigned ib = 0; ib < tmp_nboundary; ib++)
   {
    // Get the number of boundary elements
    ntmp_boundary_elements[ib] = this->nboundary_element(ib);
    
    // Resize the container
    ntmp_boundary_elements_in_region[ib].resize(n_regions);
    
    // Loop over the regions
    for (unsigned rr = 0 ; rr < n_regions; rr++)
     {
      // Get the region id
      const unsigned region_id = 
       static_cast<unsigned>(this->region_attribute(rr));
       
      // Store the number of element in the region (notice we are
      // using the region index not the region id to refer to the
      // region)
      ntmp_boundary_elements_in_region[ib][rr] = 
       this->nboundary_element_in_region(ib, region_id);
      
     } // for (rr < n_regions)
    
   } // for (ib < tmp_nboundary)
  
  // Re-establish the halo(ed) scheme
  this->reset_halo_haloed_scheme();
  
  // Get the number of elements in the mesh after load balance
  const unsigned nelement_after_load_balance = this->nelement();  
  
  // We need to reset boundary elements because we need to get rid of
  // the old boundary elements and stay only with the new ones
  this->reset_boundary_element_info(ntmp_boundary_elements,
                                    ntmp_boundary_elements_in_region,
                                    deleted_elements);
  
  // There is no need to re-set boundary coordinates since the
  // load-balanced mesh already has the correct information (the
  // boundary coordinate for each node was sent with the node
  // information)
  
  // We need to re-compute the number of segments on each boundary
  // after load balance. It may be possible that the boundary is now
  // split in more segments, or that previous gaps between the
  // segments have now dissapeared because the received elements
  // filled those gaps
  
  // In order to re-set the number of segments it is required to get
  // the face elements, attach them to create a contiguous
  // representation of the boundary (in segments possibly) and then
  // counter the number of segments. This can only be done after
  // restoring the boundary elements scheme (which has been done
  // above)
  
  // Set the number of segments for the boundaries with geom objects
  // associated. The correct value is not on the original mesh since
  // it is computed only when calling then
  // setup_boundary_coordinates() method (called only for those
  // boundaries with no geom object associated)
  for (unsigned b = 0; b < tmp_nboundary; b++)
   {
    if (this->boundary_geom_object_pt(b)!=0)
     {
      // Clear the boundary segment nodes storage
      this->flush_boundary_segment_node(b);
      
      // Dummy vector of nodes on segments
      Vector<Vector<Node*> > dummy_segment_node_pt;
      
      // Compute the new number of segments in the boundary
      get_boundary_segment_nodes_helper(b, dummy_segment_node_pt);
      
      // Get the number of segments from the vector of nodes
      const unsigned nsegments = dummy_segment_node_pt.size();
      
      // Set the number of segments for the storing of the nodes
      // associated to the segments
      this->set_nboundary_segment_node(b, nsegments);
     } // if (this->boundary_geom_object_pt(b)!=0)
    
   } // for (b < n_boundary)
  
  // The time to re-establish the halo(ed) information
  if (Print_timings_level_load_balance>1)
    {
      oomph_info << "CPU for re-establishing halo(ed) information (load balance) [11]: "
                 <<TimingHelpers::timer()-tt_start_re_etablish_halo_ed_info
                 << std::endl;
    }

  // =====================================================================
  // END: REESTABLISH THE HALO(ED) SCHEME, ATTACH HALO ELEMENTS (HALO
  // NODES INCLUDED) TO THE NEW MESH (AFTER LOAD BALANCING) RESTORE
  // THE BOUNDARY ELEMENTS SCHEME AND THE NUMBER OF SEGMENTS ON EACH
  // BOUNDARY
  // =====================================================================
  
  if (Print_timings_level_load_balance>1)
    {
      oomph_info <<"CPU for load balance [n_ele_before="
                 <<nelement_before_load_balance<<", n_ele_after="
                 <<nelement_after_load_balance<<"]: "
                 <<TimingHelpers::timer()-t_start_overall_load_balance 
                 << std::endl;
    }
  
  oomph_info << "Load balance (unstructured mesh) [END]" << std::endl;

 }
  
 //======================================================================
 /// Use the first and second group of elements to find the
 /// intersection between them to get the shared boundary
 /// elements from the first and second group
 //======================================================================
 template <class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 get_shared_boundary_elements_and_face_indexes(
  const Vector<FiniteElement*> &first_element_pt,
  const Vector<FiniteElement*> &second_element_pt,
  Vector<FiniteElement*> &first_shared_boundary_element_pt,
  Vector<unsigned> &first_shared_boundary_element_face_index,
  Vector<FiniteElement*> &second_shared_boundary_element_pt,
  Vector<unsigned> &second_shared_boundary_element_face_index)
 {
  // 1) Compare their faces (nodes) and if they match then they are
  //    part of a shared boundary 
  // 2) Save the first and second group of elements that give rise to
  //    the shared boundary, also include the face index
  
  // Get the number of elements on the first group
  const unsigned nfirst_element = first_element_pt.size();
  // Loop over the elements in the first group
  for (unsigned ef = 0; ef < nfirst_element; ef++)
   {
    // Get the element
    FiniteElement* fele_pt = first_element_pt[ef];
    // Check if the element is halo
    bool first_ele_is_halo = false;
    if (fele_pt->is_halo())
     {
      first_ele_is_halo = true;
     }
    // Get each of the faces
    for (unsigned ifface = 0; ifface < 3; ifface++)
     {
      Vector<Node*> first_face(2);
      if (ifface == 0)
       {
        first_face[0] = fele_pt->node_pt(1);
        first_face[1] = fele_pt->node_pt(2);
       }
      else if (ifface == 1)
       {
        first_face[0] = fele_pt->node_pt(2);
        first_face[1] = fele_pt->node_pt(0);
       }
      else if (ifface == 2)
       {
        first_face[0] = fele_pt->node_pt(0);
        first_face[1] = fele_pt->node_pt(1);
       }
      
      // Now check each of the faces with the faces on the second
      // elements
      
      // Get the number of elements on the second group
      const unsigned nsecond_element = second_element_pt.size();
      // Loop over the elements in the second group
      for (unsigned es = 0; es < nsecond_element; es++)
       {
        // Get the element
        FiniteElement* sele_pt = second_element_pt[es];
        // Check if the element is halo
        bool second_ele_is_halo = false;
        if (sele_pt->is_halo())
         {
          second_ele_is_halo = true;
         }
        // Now check whether both elements are halo, if that is the
        // case then we go for the next elements. We can not look for
        // shared boundaries between halo elements since other
        // processors, those with the nonhalo counterpart of the
        // elements, are in charge of creating those shared boundaries
        if (!(first_ele_is_halo && second_ele_is_halo))
         {
          // Get each of the faces
          for (unsigned isface = 0; isface < 3; isface++)
           {
            Vector<Node*> second_face(2);
            if (isface == 0)
             {
              second_face[0] = sele_pt->node_pt(1);
              second_face[1] = sele_pt->node_pt(2);
             }
            else if (isface == 1)
             {
              second_face[0] = sele_pt->node_pt(2);
              second_face[1] = sele_pt->node_pt(0);
             }
            else if (isface == 2)
             {
              second_face[0] = sele_pt->node_pt(0);
              second_face[1] = sele_pt->node_pt(1);
             }
          
            // Now check for any intersection among first and second
            // faces
            if (first_face[0] == second_face[0] && 
                first_face[1] == second_face[1])
             {
              // Save the elements on the corresponding containers
              first_shared_boundary_element_pt.push_back(fele_pt);
              // .. and the face index
              first_shared_boundary_element_face_index.push_back(ifface);
            
              // Save the elements on the corresponding containers
              second_shared_boundary_element_pt.push_back(sele_pt);
              // .. and the face index
              second_shared_boundary_element_face_index.push_back(isface);
            
              // Break the loop over the faces of the first elements
              // and the first elements, we need to continue looking
              // on the next face of the first elements
            
              // Increase the indexes to force breaking the loop
              isface = 3;
              es = nsecond_element;
            
             }
            // Check for intersection with the reversed case too
            else if (first_face[0] == second_face[1] && 
                     first_face[1] == second_face[0])
             {
              // Save the elements on the corresponding containers
              first_shared_boundary_element_pt.push_back(fele_pt);
              // .. and the face index
              first_shared_boundary_element_face_index.push_back(ifface);
            
              // Save the elements on the corresponding containers
              second_shared_boundary_element_pt.push_back(sele_pt);
              // .. and the face index
              second_shared_boundary_element_face_index.push_back(isface);
            
              // Break the loop over the faces of the first elements
              // and the first elements, we need to continue looking
              // on the next face of the first elements
            
              // Increase the indexes to force breaking the loop
              isface = 3;
              es = nsecond_element;
             }
          
           } // for (isface < 3)

         } // if (!(first_ele_is_halo && second_ele_is_halo))
        
       } // for (es < nsecond_element)
      
     } // for (ifface < 3)
    
   } // for (ef < nfirst_element)
  
 }
 
 //======================================================================
 /// \short Creates the new shared boundaries, this method is also in
 /// charge of computing the shared boundaries ids of each processor 
 /// and send that info. to all the processors
 //======================================================================
 template <class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 create_new_shared_boundaries(std::set<FiniteElement*> 
                              &element_in_processor_pt,
                              Vector<Vector<FiniteElement*> >
                              &new_shared_boundary_element_pt,
                              Vector<Vector<unsigned> > 
                              &new_shared_boundary_element_face_index)
 {
  // Get the number of processors
  const unsigned nproc = this->communicator_pt()->nproc();
  // Get the rank of the current processor
  const unsigned my_rank = this->communicator_pt()->my_rank();
  
  // ================================================================
  // BEGIN: GET THE SHARED BOUNDARY FACE ELEMENTS FROM THE SHARED
  // BOUNDARY ELEMENTS, AND ASSIGN A ROOT EDGE TO EACH FACE
  // ELEMENT. AVOID THE CREATION OF FACE ELEMENTS THAT REPRESENT THE
  // SAME EDGE (INTERNAL BOUNDARIES)
  // ================================================================
  
  // Get the time to get edges from shared boundary face elements
  double tt_start_get_edges_from_shd_bnd_face_ele=0.0;
  if (Print_timings_level_load_balance>2)
    {
      tt_start_get_edges_from_shd_bnd_face_ele=TimingHelpers::timer();
    }
  
  // Face elements that create the shared boundaries (unsorted)
  Vector<Vector<FiniteElement*> > tmp_unsorted_face_ele_pt(nproc);
  // The elements from where the face element was created
  Vector<Vector<FiniteElement*> > tmp_unsorted_ele_pt(nproc);
  // The face index of the bulk element from where was created the
  // face element
  Vector<Vector<int> > tmp_unsorted_face_index_ele(nproc);
  
  // Store the current edges lying on boundaries (this will help for
  // any edge of a shared boundary lying on an internal boundary)
  std::map<std::pair<Node*, Node*>, unsigned> elements_edges_on_boundary;
  
  // Compute the edges on the other boundaries
  this->get_element_edges_on_boundary(elements_edges_on_boundary);
  
  // Mark those edges (pair of nodes overlapped by a shared boundary)
  std::map<std::pair<Node*,Node*>, bool> overlapped_edge;

  // Associate every found edge (face element) on the shared boundary
  // with an original boundary only if the edge (face element) lies
  // (overlaps) on an original boundary, it may happen only for
  // internal boundaries
  Vector<Vector<int> > tmp_edge_boundary(nproc);
  
  // Get the face elements from the shared boundary elements with in
  // each processor
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // There are no shared boundary elements with myself
    if (iproc != my_rank)
     {
      // Get the number of shared boundary elements with in "iproc"
      // processor
      const unsigned n_shared_bound_ele = 
       new_shared_boundary_element_pt[iproc].size();
      
      // Avoid to create repeated face elements, compare the nodes on
      // the edges of the face elements
      Vector<std::pair<Node*, Node*> > done_faces;
      
      // Count the number of repeated faces
      unsigned nrepeated_faces = 0;
      
      // Loop over the shared boundary elements with the iproc
      // processor
      for (unsigned iele = 0; iele < n_shared_bound_ele; iele++)
       {
        // Get the bulk element
        FiniteElement* bulk_ele_pt = 
         new_shared_boundary_element_pt[iproc][iele];
        
        // Get the face index
        int face_index = 
         static_cast<int>(new_shared_boundary_element_face_index[iproc][iele]);
        
        // Create the face element
        FiniteElement* tmp_ele_pt = 
         new DummyFaceElement<ELEMENT> (bulk_ele_pt, face_index);
        
        // Before adding the face element to the vector check that is
        // not has been previously created
        bool done_face = false;
        
        // Get the number of nodes on the face element and get the first
        // and last node
        const unsigned nnode_face_ele = tmp_ele_pt->nnode();
        Node* first_face_node_pt = tmp_ele_pt->node_pt(0);
        Node* last_face_node_pt = tmp_ele_pt->node_pt(nnode_face_ele - 1);
        
        // Get the number of already done face elements
        const unsigned ndone_faces = done_faces.size();
        // Loop over the already visited face elements
        for (unsigned n = 0; n < ndone_faces; n++)
         {
          Node* first_done_face_node_pt = done_faces[n].first;
          Node* second_done_face_node_pt = done_faces[n].second;
          if (first_face_node_pt == first_done_face_node_pt &&
              last_face_node_pt == second_done_face_node_pt)
           {
            done_face = true;
            nrepeated_faces++;
            break;
           }
          // Check for the reversed case
          else if (first_face_node_pt == second_done_face_node_pt &&
                   last_face_node_pt == first_done_face_node_pt)
           {
            done_face = true;
            nrepeated_faces++;
            break;
           }
          
         } // for (n < ndone_faces)
        
        // Only include the faces that are not repeated
        if (!done_face)
         {
          // Add the face element in the vector
          tmp_unsorted_face_ele_pt[iproc].push_back(tmp_ele_pt);
          // Add the bulk element to the vector
          tmp_unsorted_ele_pt[iproc].push_back(bulk_ele_pt);
          // Add the face index to the vector
          tmp_unsorted_face_index_ele[iproc].push_back(face_index);
          // Include the nodes in the done nodes vector
          std::pair<Node*, Node*> tmp_edge = 
           std::make_pair(first_face_node_pt, last_face_node_pt);
          // Push the edge
          done_faces.push_back(tmp_edge);
          
          // Associate the face element with a boundary (if that is
          // the case)
          int edge_boundary_id = -1;
          std::map<std::pair<Node*,Node*>, unsigned >::iterator it;
          it = elements_edges_on_boundary.find(tmp_edge);
          // If the edges lie on a boundary then get the boundary id
          // on which the edges lie
          if (it != elements_edges_on_boundary.end())
           {
            // Assign the internal boundary id associated with the
            // edge
            edge_boundary_id = (*it).second;
            // Mark the edge as overlapped
            overlapped_edge[tmp_edge] = true;
            // Also include the reversed version of the edge
            std::pair<Node*, Node*> rev_tmp_edge = 
             std::make_pair(last_face_node_pt, first_face_node_pt);
            // Mark the reversed version of the edge as overlapped
            overlapped_edge[rev_tmp_edge] = true;
           }
          else
           {
            // Look for the reversed version
            std::pair<Node*,Node*> rtmp_edge = 
             std::make_pair(last_face_node_pt, first_face_node_pt);
            it = elements_edges_on_boundary.find(rtmp_edge);
            if (it != elements_edges_on_boundary.end())
             {
              // Assign the internal boundary id associated with the
              // edge
              edge_boundary_id = (*it).second;
              // Mark the edge as overlapped
              overlapped_edge[rtmp_edge] = true;
              // Mark the reversed version (normal) of the edge as
              // overlapped
              overlapped_edge[tmp_edge] = true;
             }
           }
          // Associate the edge with a boundary
          tmp_edge_boundary[iproc].push_back(edge_boundary_id);
         } // if (!done_face)
        else
         {
          // Delete the repeated face elements
          delete tmp_ele_pt;
          tmp_ele_pt = 0;
         }
        
       } // for (iele < n_shared_bound_ele)
      
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc)
  
  // The time to get edges from shared boundary face elements
  if (Print_timings_level_load_balance>2)
    {
      oomph_info << "CPU for getting edges from shared boundary face elements (load balance) [9.1]: "
                 <<TimingHelpers::timer()-tt_start_get_edges_from_shd_bnd_face_ele
                 << std::endl;
    }
  
  // ================================================================
  // END: GET THE SHARED BOUNDARY FACE ELEMENTS FROM THE SHARED
  // BOUNDARY ELEMENTS, AND ASSIGN A ROOT EDGE TO EACH FACE
  // ELEMENT. AVOID THE CREATION OF FACE ELEMENTS THAT REPRESENT THE
  // SAME EDGE (INTERNAL BOUNDARIES)
  // ================================================================
  
  // ================================================================
  // BEGIN: BEFORE SORTING THE SHARED FACE ELEMENTS AND ITS ASSOCIATED
  // DATA, WE NEED TO ENSURE THAT THEY APPEAR (OR ARE STORED) IN THE
  // SAME ORDER IN BOTH OF THE PROCESSORS THAT CREATED THEM. WE USE
  // THE BOTTOM-LEFT NODE OF EACH FACE ELEMENT TO STORE THEM IN THE
  // SAME ORDER IN BOTH PROCESSORS. ALSO ENSURE THAT THE FACE ELEMENTS
  // AGREE WITH THE FIRST AND LAST NODE IN ALL PROCESSORS
  // ================================================================
  
  // Get the time to sort shared face elements
  double tt_start_sort_shared_face_elements=0.0;
  if (Print_timings_level_load_balance>2)
    {
      tt_start_sort_shared_face_elements=TimingHelpers::timer();
    }
  
  // -----------------------------------------------------------------
  // Before continuing we need to ensured that the face elements are
  // stored in the same order in all processors. Sort them starting
  // from the face element with the bottom-left node coordinate
  
  // Face elements that create the shared boundaries (unsorted)
  Vector<Vector<FiniteElement*> > unsorted_face_ele_pt(nproc);
  // The elements from where the face element was created
  Vector<Vector<FiniteElement*> > unsorted_ele_pt(nproc);
  // The face index of the bulk element from where was created the
  // face element
  Vector<Vector<int> > unsorted_face_index_ele(nproc);
  // Associate every found edge on the shared boundary with an
  // original boundary only if the edge lies on an original boundary,
  // it may happen only for internal boundaries
  Vector<Vector<int> > edge_boundary(nproc);
  
  // For each face element, mark if the element should be considered
  // in its inverted way to fullfill with the bottom-left node to be
  // the first (left) node. First get the status of each element and
  // when they get sorted copy the values across
  std::vector<std::vector<bool> > tmp_treat_as_inverted(nproc);
  // Vector to store the status of the sorted face elements based on
  // the bottom-left condition
  std::vector<std::vector<bool> > treat_as_inverted(nproc);

  // Get the bottom-left node of each face element and sort them
  // starting from the face element with the bottom-left node
  
  // Loop over the processors
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // There are no shared face elements with myself
    if (iproc != my_rank)
     {
      // Get the number of unsorted face elements
      const unsigned n_face_ele = tmp_unsorted_face_ele_pt[iproc].size();
      // Store the centroid of the face element. Perform the sorting
      // based on the bottom-left centroid of each face element
      Vector<Vector<double> > centroid_vertices(n_face_ele);
      
      // Resize the storage for the treating as inverted face element
      // storage
      tmp_treat_as_inverted[iproc].resize(n_face_ele);

      // Loop over the face elements associated with the iproc
      // processor
      for (unsigned e = 0; e < n_face_ele; e++)
       {
        // Get the face element
        FiniteElement* face_ele_pt = tmp_unsorted_face_ele_pt[iproc][e];
        // Get the number of nodes of the face element
        const unsigned n_node = face_ele_pt->nnode();
        Vector<double> bottom_left(2);
        // Assign as the bottom-left node the first node
        // Get the node
        Node* node_pt = face_ele_pt->node_pt(0);
        bottom_left[0] = node_pt->x(0);
        bottom_left[1] = node_pt->x(1);
        // Set as not treat as inverted element
        tmp_treat_as_inverted[iproc][e] = false;
        // Loop over the nodes to get the bottom-left vertex of all
        // the nodes
        for (unsigned n = 1; n < n_node; n++)
         {
          // Get the node
          Node* node_pt = face_ele_pt->node_pt(n);
          if (node_pt->x(1) < bottom_left[1])
           {
            bottom_left[0] = node_pt->x(0);
            bottom_left[1] = node_pt->x(1);
            // The first node is no longer the bottom-left node, we
            // need to treat the element as inverted
            tmp_treat_as_inverted[iproc][e] = true;
           } // if (node_pt->x(1) < bottom_left[1])
          else if (node_pt->x(1) == bottom_left[1])
           {
            if (node_pt->x(0) < bottom_left[0])
             {
              bottom_left[0] = node_pt->x(0);
              bottom_left[1] = node_pt->x(1);
              // The first node is no longer the bottom-left node, we
              // need to treat the element as inverted
              tmp_treat_as_inverted[iproc][e] = true;
             } // if (node_pt->x(0) < bottom_left[0])
           } // else if (node_pt->x(1) == bottom_left[1])
          
         } // for (n < n_node
        
        // Resize the container
        centroid_vertices[e].resize(2);
        // Add the centroid of the face element
        centroid_vertices[e][0] = 
          (face_ele_pt->node_pt(0)->x(0) + 
           face_ele_pt->node_pt(n_node-1)->x(0))*0.5;
        centroid_vertices[e][1] = 
          (face_ele_pt->node_pt(0)->x(1) + 
           face_ele_pt->node_pt(n_node-1)->x(1))*0.5;
        
       } // for (e < n_face_ele)
      
      // Sort the face elements based on their bottom-left node
      unsigned n_sorted_bottom_left = 0;
      // Keep track of the already sorted face elements
      std::vector<bool> done_face(n_face_ele, false);
      
      // Loop until all face elements have been sorted
      while (n_sorted_bottom_left < n_face_ele)
       {
        // The index of the next bottom-left face element
        unsigned index = 0;
        Vector<double> current_bottom_left(2);
        for (unsigned e = 0; e < n_face_ele; e++)
         {
          // Get the first not done face element
          if (!done_face[e])
           {
            // Store the first not done
            current_bottom_left[0] = centroid_vertices[e][0];
            current_bottom_left[1] = centroid_vertices[e][1];
            // Set the index
            index = e;
            // Break
            break;
           } // if (!done_face[e])
          
         } // for (e < n_face_ele)
        
        // Loop over all the other nondone face elements
        for (unsigned e = index + 1; e < n_face_ele; e++)
         {
          // Get the first not done face element
          if (!done_face[e])
           {
            if (centroid_vertices[e][1] < current_bottom_left[1])
             {
              // Re-set the current bottom left vertex
              current_bottom_left[0] = centroid_vertices[e][0];
              current_bottom_left[1] = centroid_vertices[e][1];
              // Re-assign the index
              index = e;
             } // if (centroid_vertices[e][1] < current_bottom_left[1])
            else if (centroid_vertices[e][1] == current_bottom_left[1])
             {
              if (centroid_vertices[e][0] < current_bottom_left[0])
               {
                // Re-set the current bottom left vertex
                current_bottom_left[0] = centroid_vertices[e][0];
                current_bottom_left[1] = centroid_vertices[e][1];
                // Re-assign the index
                index = e;
               } // if (centroid_vertices[e][0] < current_bottom_left[0])
              
             } // else if (centroid_vertices[e][1] == current_bottom_left[1])
            
           } // if (!done_face[e])
          
         } // for (e < n_face_ele)
        
        // The face element
        unsorted_face_ele_pt[iproc].
         push_back(tmp_unsorted_face_ele_pt[iproc][index]);
        // The boundary element
        unsorted_ele_pt[iproc].
         push_back(tmp_unsorted_ele_pt[iproc][index]);
        // The face index
        unsorted_face_index_ele[iproc].
         push_back(tmp_unsorted_face_index_ele[iproc][index]);
        // The edge boundary associated to the face element
        edge_boundary[iproc].
         push_back(tmp_edge_boundary[iproc][index]);
        // The treat as inverted condition
        treat_as_inverted[iproc].
         push_back(tmp_treat_as_inverted[iproc][index]);
        
        // Mark the face element as sorted (done or visited)
        done_face[index] = true;
        
        // Increase the number of sorted bottom-left face elements
        n_sorted_bottom_left++;
        
       } // while (n_sorted_bottom_left < n_face_ele)
      
#ifdef PARANOID
      // Get the number of face elements sorted with the bottom-left
      // condition
      const unsigned tmp_n_face_ele = unsorted_face_ele_pt[iproc].size();
      
      if (tmp_n_face_ele != n_face_ele)
       {
        std::ostringstream error_stream;
        error_stream
         << "The number of face elements before sorting them starting\n"
         << "from their bottom-left vertex is different from the number\n"
         << "of face elements after the sorting\n"
         << "N. ele before sorting: (" << n_face_ele << ")\n"
         << "N. ele after sorting: (" << tmp_n_face_ele << ")\n";
         throw OomphLibError(error_stream.str(),
                             "RefineableTriangleMesh::create_new_shared_boundaries()",
                             OOMPH_EXCEPTION_LOCATION);
       }
#endif      
      
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc)
  
  // The time to sort shared face elements
  if (Print_timings_level_load_balance>2)
    {
      oomph_info << "CPU for sorting shared boundary face elements (load balance) [9.2]: "
                 <<TimingHelpers::timer()-tt_start_sort_shared_face_elements
                 << std::endl;
    }
  
  // ================================================================
  // END: SORTING THE SHARED FACE ELEMENTS AND ITS ASSOCIATED DATA, WE
  // NEED TO ENSURE THAT THEY APPEAR (OR ARE STORED) IN THE SAME ORDER
  // IN BOTH OF THE PROCESSORS THAT CREATED THEM. WE USE THE
  // BOTTOM-LEFT NODE OF EACH FACE ELEMENT TO STORE THEM IN THE SAME
  // ORDER IN BOTH PROCESSORS. ALSO ENSURE THAT THE FACE ELEMENTS
  // AGREE WITH THE FIRST AND LAST NODE IN ALL PROCESSORS
  // ================================================================
  
  // ================================================================
  // BEGIN: COMPUTE THE GLOBAL DEGREE (VALENCY OF EACH NODE). THE
  // DEGREE OF THE NODES IN THE CURRENT SHARED BOUNDARIES IS COMPUTED
  // FIRST, THEN THIS INFO. IS SENT TO A ROOT PROCESSOR WHICH IS IN
  // CHARGE OF IDENTIFY AND RE-ASSIGN THE DEGREE OF THE NODES (IF THAT
  // IS THE CASE)
  // ================================================================
  
  // Get the time to compute the valency of each node
  double tt_start_compute_valency_of_nodes=0.0;
  if (Print_timings_level_load_balance>2)
    {
      tt_start_compute_valency_of_nodes=TimingHelpers::timer();
    }
  
  // Stores the global-degree of each node
  std::map<Node*, unsigned> global_node_degree;
  
  // Get the global degree (valency) of each node
  compute_shared_node_degree_helper(unsorted_face_ele_pt,
                                    global_node_degree);
  
  // The time to compute the valency of each node
  if (Print_timings_level_load_balance>2)
    {
      oomph_info << "CPU for computing the valency of nodes (load balance) [9.3]: "
                 <<TimingHelpers::timer()-tt_start_compute_valency_of_nodes
                 << std::endl;
    }
  
  // ================================================================
  // END: COMPUTE THE GLOBAL DEGREE (VALENCY OF EACH NODE). THE
  // DEGREE OF THE NODES IN THE CURRENT SHARED BOUNDARIES IS COMPUTED
  // FIRST, THEN THIS INFO. IS SENT TO A ROOT PROCESSOR WHICH IS IN
  // CHARGE OF IDENTIFY AND RE-ASSIGN THE DEGREE OF THE NODES (IF THAT
  // IS THE CASE)
  // ================================================================
  
  // ================================================================
  // BEGIN: IDENTIFY THE NODES LYING ON EDGES NOT OVERLAPED BY SHARED
  // BOUNDARIES, IDENTIFY THE BOUNDARY TO WHICH THE EDGE CORRESPOND
  // ================================================================
  
  // Get the time to compute nodes on non overlapped shared boundaries
  double tt_start_nodes_on_non_overlapped_shd_bnd=0.0;
  if (Print_timings_level_load_balance>2)
    {
      tt_start_nodes_on_non_overlapped_shd_bnd=TimingHelpers::timer();
    }
  
  // Mark the nodes on original boundaries not overlapped by shared
  // boundaries
  std::map<unsigned, std::map<Node*, bool> > 
   node_on_bnd_not_overlapped_by_shd_bnd;
  
  // Loop over the edges of the original boundaries
  for (std::map<std::pair<Node*,Node*>, unsigned>::iterator it_map =
        elements_edges_on_boundary.begin(); 
       it_map != elements_edges_on_boundary.end(); it_map++)
   {
    // Get the edge
    std::pair<Node*,Node*> edge_pair = (*it_map).first;
    // Is the edge overlaped by a shared boundary
    if (!overlapped_edge[edge_pair])
     {
      // Mark the nodes of the edge as being on an edge not overlaped
      // by a shared boundary on the boundary the edge is
      unsigned b = (*it_map).second;
      
      // Get the left node
      Node* left_node_pt = edge_pair.first;
      node_on_bnd_not_overlapped_by_shd_bnd[b][left_node_pt] = true;
      
      // Get the right node
      Node* right_node_pt = edge_pair.second;
      node_on_bnd_not_overlapped_by_shd_bnd[b][right_node_pt] = true;
      
     } // if (!overlapped_edge[edge_pair])
    
   } // Loop over edges to mark those nodes on overlaped edge by
      // shared boundaries
  
  // The time to compute nodes on non overlapped shared boundaries
  if (Print_timings_level_load_balance>2)
    {
      oomph_info << "CPU for computing nodes on non overlapped shared boundaries (load balance) [9.4]: "
                 <<TimingHelpers::timer()-tt_start_nodes_on_non_overlapped_shd_bnd
                 << std::endl;
    }
  
  // ================================================================
  // END: IDENTIFY THE NODES LYING ON EDGES NOT OVERLAPED BY SHARED
  // BOUNDARIES, IDENTIFY THE BOUNDARY TO WHICH THE EDGE CORRESPOND
  // ================================================================
  
  // ==================================================================
  // BEGIN: SORT THE SHARED BOUNDARY FACE ELEMENTS, ADD FACE ELEMENTS
  // TO THE LEFT OR RIGHT OF THE ROOT FACE ELEMENT. STOP ADDING WHEN
  // THE MOST LEFT OR MOST RIGHT ELEMENT (NODE) IS ALREADY PART OF
  // ANOTHER BOUNDARY (THIS MEANS THAT THE SHARED BOUNDARY THAT IS
  // BEING CREATED HAS A CONNECTION). ALSO REMEMBER TO CHECK FOR THE
  // CASE WHEN THE MOST LEFT OR MOST RIGHT NODE IS A BOUNDARY NODE OF
  // A BOUNDARY THAT NO LONGER EXIST IN THE DOMAIN. AT THE END OF THIS
  // SECTION WE WILL HAVE THE NUMBER OF SHARED BOUNDARIES OF THIS
  // PROCESSOR WITH OTHERS BUT NOT THE GLOBAL SHARED BOUNDARY ID
  // ==================================================================
  
  // Get the time to sort shared boundaries face elements to create a
  // continuous representation of the boundary
  double tt_start_join_shd_bnd_face_ele=0.0;
  if (Print_timings_level_load_balance>2)
    {
      tt_start_join_shd_bnd_face_ele=TimingHelpers::timer();
    }
  
  // Face elements that create the shared boundaries (sorted)
  Vector<Vector<Vector<FiniteElement*> > > sorted_face_ele_pt(nproc);
  
  // Bulk elements that create the shared boundaries (sorted)
  Vector<Vector<Vector<FiniteElement*> > > sorted_ele_pt(nproc);
  
  // Face indexes of the bulk elements that create the shared
  // boundaries (sorted)
  Vector<Vector<Vector<int> > > sorted_face_index_ele(nproc);
  
  // Store the edge boundary id associated with a shared boundary (if
  // any, this apply for shared boundaries lying on internal
  // boundaries, then the shared boundary is marked as overlaping an
  // internal boundary)
  Vector<Vector<int> > edge_boundary_id(nproc);
  
  // Store the connection information obtained when joining the face
  // elements (used for connection purposes only)
  Vector<Vector<Vector<int> > > sorted_connection_info(nproc);
  
  // Store the local shared boundary id associated to the elements
  // that will give rise to the shared boundaries (used to compute the
  // global shared boundary id from the local shared boundary id)
  Vector<Vector<unsigned> > proc_local_shared_boundary_id(nproc);
  
  // Map that associates the local shared boundary id with the list of
  // nodes that create it
  std::map<unsigned, std::list<Node*> > 
   local_shd_bnd_id_to_sorted_list_node_pt;
  
  // Local shared bouonday id (used to locally identify the lists of
  // nodes that create shared boundaries, it is also useful to
  // identify connections with shared boundaries)
  unsigned local_shd_bnd_id = this->Initial_shared_boundary_id;
  
  // Sort the face elements, using the nodes at its ends
  
  // Mark the done elements
  std::map<FiniteElement*, bool> done_ele;
  
  // Mark the inverted elements
  std::map<FiniteElement*, bool> is_inverted;
  
  // Sort the face elements to get the number of shared boundaries
  // with in each processor
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // No face elements with myself
    if (iproc != my_rank)
     {
      // Get the number of unsorted face elements with the iproc
      // processor
      const unsigned nunsorted_face_ele = 
       unsorted_face_ele_pt[iproc].size();
      // Count the number of sorted face elements
      unsigned nsorted_face_ele = 0;
      
      // Iterate until all the face elements have been sorted
      while (nsorted_face_ele < nunsorted_face_ele)
       {
        // Take the first nonsorted element an use it as root element,
        // add elements to the left and right until no more elements
        // left or until a stop condition is reached (connection,
        // boundary node)
        
#ifdef PARANOID
        // Flag to indicate if a root element was found
        bool found_root_element = false;
#endif
        
        // Index of the found root element
        unsigned root_index = 0;
        
        // List that contains the sorted face elements
        std::list<FiniteElement*> tmp_sorted_face_ele_pt;
        
        // List that contains the sorted elements
        std::list<FiniteElement*> tmp_sorted_ele_pt;
        
        // List that contains the sorted face indexes of the bulk
        // elements
        std::list<int> tmp_sorted_face_index_ele;
        
        // Storing for the sorting nodes extracted from the face
        // elements. The sorted nodes are used to identify connections
        // among new shared boundaries or original boundaries
        std::list<Node*> tmp_sorted_nodes_pt;
        // Clear the storage (just in case)
        tmp_sorted_nodes_pt.clear();
        
        // The initial and final nodes
        Node* initial_node_pt = 0;
        Node* final_node_pt = 0;
        
        // Store the original boundary id related with the root face
        // element (if there is one)
        int root_edge_bound_id = -1;
        
        // Loop over the unsorted face elements until a root element
        // is found
        for (unsigned e = 0; e < nunsorted_face_ele; e++)
         {
          // Get a root element
          FiniteElement* root_ele_pt = unsorted_face_ele_pt[iproc][e];
          // Is the element already done?
          if (!done_ele[root_ele_pt])
           {
            // Get the edge boundary id associated with the edge (if
            // there is one)
            root_edge_bound_id = edge_boundary[iproc][e];
            // Add the face element to the list of sorted face
            // elements
            tmp_sorted_face_ele_pt.push_back(root_ele_pt);
            // Add the bulk element to the list of sorted elements
            tmp_sorted_ele_pt.push_back(unsorted_ele_pt[iproc][e]);
            // Add the face index to the list of sorted face index
            // elements
            tmp_sorted_face_index_ele.push_back(
             unsorted_face_index_ele[iproc][e]);
            
            // Get the nodes and state them as initial and final
            const unsigned nnodes = root_ele_pt->nnode();
            // Check if the face element should be treated as inverted
            if (!treat_as_inverted[iproc][e])
             {
              initial_node_pt = root_ele_pt->node_pt(0);
              final_node_pt = root_ele_pt->node_pt(nnodes-1);
             }
            else
             {
              initial_node_pt = root_ele_pt->node_pt(nnodes-1);
              final_node_pt = root_ele_pt->node_pt(0);
             }
            // Add both nodes to the list of sorted nodes
            tmp_sorted_nodes_pt.push_back(initial_node_pt);
            tmp_sorted_nodes_pt.push_back(final_node_pt);
            
            // Mark the element as done
            done_ele[root_ele_pt] = true;
            // Check if the face element should be treated as inverted
            if (!treat_as_inverted[iproc][e])
             {
              // Mark the element as not inverted
              is_inverted[root_ele_pt] = false;
             }
            else
             {
              // Mark the element as inverted
              is_inverted[root_ele_pt] = true;
             }
            // Increase the counter for sorted face elements
            nsorted_face_ele++;
            // Set the root index
            root_index = e;
#ifdef PARANOID
            // Set the flag of found root element
            found_root_element = true;
#endif
            // Break the loop
            break;
            
           } // if (!done_ele[root_ele_pt])
          
         } // for (e < nunsorted_face_ele)
        
#ifdef PARANOID
        if (!found_root_element)
         {
          std::ostringstream error_stream;
          error_stream
           << "It was not possible the found the root element\n\n";
           throw OomphLibError(error_stream.str(),
                               OOMPH_CURRENT_FUNCTION,
                               OOMPH_EXCEPTION_LOCATION);
         }
#endif
        
        // New element added. Continue adding elements -- or nodes --
        // to the list of shared boundary elements while a new element
        // has been added to the list (we have just added the root
        // element)
        bool new_element_added = true;
        
        // Similarly that in the
        // "create_polylines_from_halo_elements_helper() method, we
        // extract the nodes (in order) that will create the shared
        // polyline, and also check for connections with the just
        // added face elements (nodes)
        
        // Flags to indicate at which end (of the sorted list of
        // boundary elements) the element was added (left or right)
        bool element_added_to_the_left = false;
        bool element_added_to_the_right = false;
        
        // Flag to indicate that the "left" node of the element added
        // to the left was found to be shared with another boundary
        bool connection_to_the_left = false;
        
        // Flag to indicate that the "right" node of the element added
        // to the right was found to be shared with another boundary
        bool connection_to_the_right = false;
        
        // Flag to stop the adding of elements (and nodes) to the
        // current shared boundary (because there are connections at
        // both ends)
        bool current_polyline_has_connections_at_both_ends = false;
        
        // Store the boundary ids of the polylines to connect (only
        // used when the polyline was found to have a connection)
        // -1: Indicates no connection
        // -2: Indicates connection with itself
        // -3: Indicates no connection BUT STOP adding elements
        // -because the node is a boundary node whose boundary is no
        // -currently part of the domain. Think in one of the corner
        // -nodes of a triangle touchin a boundary that does no longer
        // -exist
        // Any other value: Boundary id to connect
        int bound_id_connection_to_the_left = -1;
        int bound_id_connection_to_the_right = -1;
        
        // Get the global degree of the node (notice the local degree
        // has been updated to global degree)
        const unsigned initial_node_degree = 
         global_node_degree[initial_node_pt];
        
        // Flag to indicate we are calling the method from a load
        // balance sub-rutine
        const bool called_for_load_balance=true;
        
        // Check if the nodes of the root element have connections 
        // ... to the left
        bound_id_connection_to_the_left = 
         this->check_connections_of_polyline_nodes(
          element_in_processor_pt,
          root_edge_bound_id,
          overlapped_edge,
          node_on_bnd_not_overlapped_by_shd_bnd,
          tmp_sorted_nodes_pt, 
          local_shd_bnd_id_to_sorted_list_node_pt, 
          initial_node_degree,
          initial_node_pt, 
          called_for_load_balance);
        
        // If there is a stop condition then set the corresponding
        // flag
        if (bound_id_connection_to_the_left != -1)
         {
          connection_to_the_left = true;
         } // if (bound_id_connection_to_the_left != -1)
        
        // Get the global degree of the node (notice the local degree
        // has been updated to global degree)
        const unsigned final_node_degree = 
         global_node_degree[final_node_pt];
        
        // ... and to the right
        bound_id_connection_to_the_right = 
         this->check_connections_of_polyline_nodes(
          element_in_processor_pt,
          root_edge_bound_id,
          overlapped_edge,
          node_on_bnd_not_overlapped_by_shd_bnd,
          tmp_sorted_nodes_pt, 
          local_shd_bnd_id_to_sorted_list_node_pt, 
          final_node_degree,
          final_node_pt,
          called_for_load_balance);
        
        // If there is a stop condition then set the corresponding
        // flag
        if (bound_id_connection_to_the_right != -1)
         {
          connection_to_the_right = true;
         } // if (bound_id_connection_to_the_right != -1)
        
        // If the current shared boundary has connections at both ends
        // then stop the adding of elements (and nodes)
        if (connection_to_the_left && connection_to_the_right)
         {current_polyline_has_connections_at_both_ends = true;}
        
        // Continue searching for more elements to add if 
        // 1) A new element was added at the left or right of the list
        // 2) There are more possible elements to add
        // 3) The nodes at the edges of the added element (left or
        //    right) are not part of any other previous shared
        //    boundary
        while(new_element_added && 
              (nsorted_face_ele < nunsorted_face_ele)
              && !current_polyline_has_connections_at_both_ends)
         {
          // Loop over the remaining elements and try to create a
          // contiguous set of face elements, start looking from the
          // root index. Any previous element should have been already
          // visited
          for (unsigned e = root_index; e < nunsorted_face_ele; e++)
           {
            // Reset the flags for added elements, to the left and right
            new_element_added = false;
            element_added_to_the_left = false;
            element_added_to_the_right = false;
            
            // Get the "e"-th element on the vector
            FiniteElement* tmp_ele_pt = unsorted_face_ele_pt[iproc][e];
            // Get the boundary id associated with the edge (if any)
            const int edge_bound_id = edge_boundary[iproc][e];
            // Check if the element has been already sorted and the
            // related edge bound id is the same as the root edge (if
            // any)
            if (!done_ele[tmp_ele_pt] 
                && (edge_bound_id == root_edge_bound_id))
             {
              // Get the number of nodes on the current element
              const unsigned nnodes = tmp_ele_pt->nnode();
              // Get the first and last node of the element
              // Check if the face element should be treated as inverted
              Node* first_node_pt = 0;
              Node* last_node_pt = 0;
              if (!treat_as_inverted[iproc][e])
               {
                first_node_pt = tmp_ele_pt->node_pt(0);
                last_node_pt = tmp_ele_pt->node_pt(nnodes-1);
               }
              else
               {
                first_node_pt = tmp_ele_pt->node_pt(nnodes-1);
                last_node_pt = tmp_ele_pt->node_pt(0);
               }
              
              // A pointer to the node at the left or right of the
              // just added element, the most left or the most right
              // node
              Node* new_added_node_pt = 0;
              
              // Check if the element goes to the left
              if (initial_node_pt == last_node_pt &&
                  !connection_to_the_left)
               {
                // Update the initial node and the just added node
                new_added_node_pt = initial_node_pt = first_node_pt;
                // Add the most left node
                tmp_sorted_nodes_pt.push_front(first_node_pt);
                // Add the face element to the list of sorted face
                // elements
                tmp_sorted_face_ele_pt.push_front(tmp_ele_pt);
                // Add the bulk element to the list of sorted elements
                tmp_sorted_ele_pt.push_front(unsorted_ele_pt[iproc][e]);
                // Add the face index to the list of sorted face index
                // elements
                tmp_sorted_face_index_ele.push_front(
                 unsorted_face_index_ele[iproc][e]);
                if (!treat_as_inverted[iproc][e])
                 {
                  // Mark the element as not inverted
                  is_inverted[tmp_ele_pt] = false;
                 }
                else
                 {
                  // Mark the element as inverted
                  is_inverted[tmp_ele_pt] = true;
                 }
                // Set the flag to indicate a new element was added
                new_element_added = true;
                // Set the flag to indicate the element was added to
                // the left
                element_added_to_the_left = true;
               }
              // Check if the element goes to the left (but inverted)
              else if (initial_node_pt == first_node_pt && 
                       !connection_to_the_left)
               {
                // Update the initial node and the just added node
                new_added_node_pt = initial_node_pt = last_node_pt;
                // Add the most left node
                tmp_sorted_nodes_pt.push_front(last_node_pt);
                // Add the face element to the list of sorted face
                // elements
                tmp_sorted_face_ele_pt.push_front(tmp_ele_pt);
                // Add the bulk element to the list of sorted elements
                tmp_sorted_ele_pt.push_front(unsorted_ele_pt[iproc][e]);
                // Add the face index to the list of sorted face index
                // elements
                tmp_sorted_face_index_ele.push_front(
                 unsorted_face_index_ele[iproc][e]);
                if (!treat_as_inverted[iproc][e])
                 {
                  // Mark the element as inverted
                  is_inverted[tmp_ele_pt] = true;
                 }
                else
                 {
                  // Mark the element as not inverted
                  is_inverted[tmp_ele_pt] = false;
                 }
                // Set the flag to indicate a new element was added
                new_element_added = true;
                // Set the flag to indicate the element was added to
                // the left
                element_added_to_the_left = true;
               }
              // Check if the elements goes to the right
              else if (final_node_pt == first_node_pt 
                       && !connection_to_the_right)
               {
                // Update the final node and the just added node
                new_added_node_pt = final_node_pt = last_node_pt;
                // Add the most right node
                tmp_sorted_nodes_pt.push_back(last_node_pt);
                // Add the face element to the list of sorted face
                // elements
                tmp_sorted_face_ele_pt.push_back(tmp_ele_pt);
                // Add the bulk element to the list of sorted elements
                tmp_sorted_ele_pt.push_back(unsorted_ele_pt[iproc][e]);
                // Add the face index to the list of sorted face index
                // elements
                tmp_sorted_face_index_ele.push_back(
                 unsorted_face_index_ele[iproc][e]);
                if (!treat_as_inverted[iproc][e])
                 {
                  // Mark the element as not inverted
                  is_inverted[tmp_ele_pt] = false;
                 }
                else
                 {
                  // Mark the element as inverted
                  is_inverted[tmp_ele_pt] = true;
                 }
                // Set the flag to indicate a new element was added
                new_element_added = true;
                // Set the flag to indicate the element was added to
                // the right
                element_added_to_the_right = true;
               }
              // Check if the elements goes to the right (but inverted)
              else if (final_node_pt == last_node_pt && 
                       !connection_to_the_right)
               {
                // Update the final node and the just added node
                new_added_node_pt = final_node_pt = first_node_pt;
                // Add the most right node
                tmp_sorted_nodes_pt.push_back(first_node_pt);
                // Add the face element to the list of sorted face
                // elements
                tmp_sorted_face_ele_pt.push_back(tmp_ele_pt);
                // Add the bulk element to the list of sorted elements
                tmp_sorted_ele_pt.push_back(unsorted_ele_pt[iproc][e]);
                // Add the face index to the list of sorted face index
                // elements
                tmp_sorted_face_index_ele.push_back(
                 unsorted_face_index_ele[iproc][e]);
                if (!treat_as_inverted[iproc][e])
                 {
                  // Mark the element as inverted
                  is_inverted[tmp_ele_pt] = true;
                 }
                else
                 {
                  // Mark the element as not inverted
                  is_inverted[tmp_ele_pt] = false;
                 }
                // Set the flag to indicate a new elements was added
                new_element_added = true;
                // Set the flag to indicate the element was added to
                // the right
                element_added_to_the_right = true;
               }
              
              // Do additional stuff if the element was added
              if (new_element_added)
               {
                // Mark the element as done
                done_ele[tmp_ele_pt] = true;
                // Increase the counter for sorted face elements
                nsorted_face_ele++;
                
                // Get the global degree of the node (notice the
                // local degree has been updated to global degree)
                const unsigned new_added_node_degree = 
                 global_node_degree[new_added_node_pt];
                
                // Based on which side the element was added, look for
                // connections on that side
                
                // Verify for connections to the left (we need to
                // check for the connection variable too, since
                // after a connection has been done we no longer
                // need to verify for this condition)
                if (element_added_to_the_left && !connection_to_the_left)
                 {                   
                  // Check for connection
                  bound_id_connection_to_the_left = 
                   this->check_connections_of_polyline_nodes(
                    element_in_processor_pt,
                    root_edge_bound_id,
                    overlapped_edge,
                    node_on_bnd_not_overlapped_by_shd_bnd,
                    tmp_sorted_nodes_pt, 
                    local_shd_bnd_id_to_sorted_list_node_pt, 
                    new_added_node_degree,
                    new_added_node_pt,
                    called_for_load_balance);
                  
                  // If there is a stop condition then set the
                  // corresponding flag
                  if (bound_id_connection_to_the_left != -1)
                   {
                    connection_to_the_left = true;
                   } // if (bound_id_connection_to_the_left != -1)
                  
                 } // if (node_added_to_the_left &&
                   //     !connection_to_the_left)
                
                // Verify for connections to the right (we need to
                // check for the connection variable too, since
                // after a connection has been done we no longer
                // need to verify for this condition)
                if (element_added_to_the_right && !connection_to_the_right)
                 {                   
                  // Check for connection
                  bound_id_connection_to_the_right = 
                   this->check_connections_of_polyline_nodes(
                    element_in_processor_pt,
                    root_edge_bound_id,
                    overlapped_edge,
                    node_on_bnd_not_overlapped_by_shd_bnd,
                    tmp_sorted_nodes_pt,
                    local_shd_bnd_id_to_sorted_list_node_pt, 
                    new_added_node_degree,
                    new_added_node_pt,
                    called_for_load_balance);
                  
                  // If there is a stop condition then set the
                  // corresponding flag
                  if (bound_id_connection_to_the_right != -1)
                   {
                    connection_to_the_right = true;
                   } // if (bound_id_connection_to_the_right != -1)
                  
                 } // if (node_added_to_the_right && 
                   //     !connection_to_the_right)
                
                // If the current shared boundary has connections at
                // both ends then stop the adding of elements (and
                // nodes)
                if (connection_to_the_left && connection_to_the_right)
                 {current_polyline_has_connections_at_both_ends = true;}
                
                // Break the for (looping over unsorted face
                // elements) and re-start looking for more elements
                // that fit to the left or right
                break;
                
               } // if (new_element_added)
              
             } // if (!done_ele[tmp_ele_pt])
            
           } // for (e < nunsorted_face_ele)
          
         } // while(new_element_added && 
           // (nsorted_face_ele < nunsorted_face_ele)
           //  && !current_polyline_has_connections_at_both_ends)
        
        // ------------------------------------------------------------
        // Before assigning a local shared boundary id to the list of
        // nodes and boundary elements, check for any loop that the
        // shared boundary may be creating
        
        // The vector of the elements
        Vector<FiniteElement*> tmp_vector_sorted_ele_pt;
        // Store the list of elements on a vector of elements
        for (std::list<FiniteElement*>::iterator it = 
              tmp_sorted_ele_pt.begin(); it != tmp_sorted_ele_pt.end(); it++)
         {
          tmp_vector_sorted_ele_pt.push_back((*it));
         }
        
        // The vector of the face elements
        Vector<FiniteElement*> tmp_vector_sorted_face_ele_pt;
        // Store the list of face elements on a vector of face
        // elements
        for (std::list<FiniteElement*>::iterator it = 
              tmp_sorted_face_ele_pt.begin();
             it != tmp_sorted_face_ele_pt.end(); it++)
         {
          tmp_vector_sorted_face_ele_pt.push_back((*it));
         }
        
        // The vector of the face indexes
        Vector<int> tmp_vector_sorted_face_index_ele;
        // Store the list of elements on a vector of elements
        for (std::list<int>::iterator it = 
              tmp_sorted_face_index_ele.begin(); 
             it != tmp_sorted_face_index_ele.end(); it++)
         {
          tmp_vector_sorted_face_index_ele.push_back((*it));
         }
        
        // Store the nodes for the new shared polylines without loops
        Vector<std::list<Node*> > final_sorted_nodes_pt;
        // Store the boundary elements of the shared polyline without
        // loops
        Vector<Vector<FiniteElement*> > final_boundary_element_pt;
        // Store the boundary face elements of the shared polyline
        // without loops
        Vector<Vector<FiniteElement*> > final_boundary_face_element_pt;
        // Face indexes of the boundary elements without loops
        Vector<Vector<int> > final_face_index_element;
        // Connection flags (to the left) of the shared boundaries
        // without loops
        Vector<int> final_bound_id_connection_to_the_left;
        // Connection flags (to the right) of the shared boundaries
        // without loops
        Vector<int> final_bound_id_connection_to_the_right;
        
        // Break any possible loop created by the shared polyline
        this->break_loops_on_shared_polyline_load_balance_helper(
         local_shd_bnd_id,
         tmp_sorted_nodes_pt,
         tmp_vector_sorted_ele_pt, 
         tmp_vector_sorted_face_ele_pt, tmp_vector_sorted_face_index_ele,
         bound_id_connection_to_the_left, bound_id_connection_to_the_right,
         final_sorted_nodes_pt,
         final_boundary_element_pt,
         final_boundary_face_element_pt, final_face_index_element,
         final_bound_id_connection_to_the_left,
         final_bound_id_connection_to_the_right);
        
        // Get the number of final sorted nodes
        const unsigned n_final_sorted_nodes = final_sorted_nodes_pt.size();
        
        // Loop over the list of final sorted nodes
        for (unsigned i = 0; i < n_final_sorted_nodes; i++)
         {
          // Store the list of nodes that gave rise to the shared
          // boundary
          local_shd_bnd_id_to_sorted_list_node_pt[local_shd_bnd_id] = 
           final_sorted_nodes_pt[i];
          
          // Store the local shared boundary id assigned to the
          // elements that will create the shared boundary
          proc_local_shared_boundary_id[iproc].push_back(local_shd_bnd_id);
          
          // Increase the shared boundary id (note that this is only
          // used to keep track of the list of nodes that create the
          // shared boundaries in the current processor)
          local_shd_bnd_id++;
          
          // Include the vector of elements to the sorted vector
          sorted_ele_pt[iproc].push_back(final_boundary_element_pt[i]);
          
          // Include the vector of face elements to the sorted vector
          sorted_face_ele_pt[iproc].
           push_back(final_boundary_face_element_pt[i]);
          
          // Include the vector of elements to the sorted vector
          sorted_face_index_ele[iproc].push_back(final_face_index_element[i]);
          
          // Include the possible associated boundary id to the vector
          edge_boundary_id[iproc].push_back(root_edge_bound_id);
          
          // Include the connection information associated with the
          // current set of face elements (that will give rise to a
          // shared polyline
          // The temporal storage for the boundary connections ids
          Vector<int> bnd_connections_ids(2);
          bnd_connections_ids[0] = final_bound_id_connection_to_the_left[i];
          bnd_connections_ids[1] = final_bound_id_connection_to_the_right[i];
          sorted_connection_info[iproc].push_back(bnd_connections_ids);
          
         } // for (i < n_final_sorted_nodes)
        
       } // while (nsorted_face_ele < nunsorted_face_ele)
      
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc)
  
  // The time to sort shared boundaries face elements to create a
  // continuous representation of the boundary
  if (Print_timings_level_load_balance>2)
    {
      oomph_info << "CPU for joining shared boundary face elements (load balance) [9.5]: "
                 <<TimingHelpers::timer()-tt_start_join_shd_bnd_face_ele
                 << std::endl;
    }
  
  // ==================================================================
  // END: SORT THE SHARED BOUNDARY FACE ELEMENTS, ADD FACE ELEMENTS TO
  // THE LEFT OR RIGHT OF THE ROOT FACE ELEMENT. STOP ADDING WHEN THE
  // MOST LEFT OR MOST RIGHT ELEMENT (NODE) IS ALREADY PART OF ANOTHER
  // BOUNDARY (THIS MEANS THAT THE SHARED BOUNDARY THAT IS BEING
  // CREATED HAS A CONNECTION). ALSO REMEMBER TO CHECK FOR THE CASE
  // WHEN THE MOST LEFT OR MOST RIGHT NODE IS A BOUNDARY NODE OF A
  // BOUNDARY THAT NO LONGER EXIST IN THE DOMAIN. AT THE END OF THIS
  // SECTION WE WILL HAVE THE NUMBER OF SHARED BOUNDARIES OF THIS
  // PROCESSOR WITH OTHERS BUT NOT THE GLOBAL SHARED BOUNDARY ID
  // ==================================================================
  
  // ==================================================================
  // BEGIN: COMPUTE THE GLOBAL SHARED BOUNDARIES IDS. GATHER THE
  // NUMBER OF SHARED BOUNDARIES OF EACH PROCESSOR, THEN A ROOT
  // PROCESSOR IS IN CHARGE OF VERIFYING THAT THE SAME NUMBER OF
  // SHARED BOUNDARIES HAVE BEEN CREATED BY A PAIR OF PROCESSORS. THE
  // ROOT PROCESSOR COMPUTES THE INITIAL GLOBAL SHARED BOUNDARY ID
  // BETWEEN EACH PAIR OR PROCESSORS AND SENDS THESE INFO. TO ALL
  // PROCESSORS. THE GLOBAL INITIAL AND FINAL SHARED BOUNDARY ID ARE
  // ALSO COMPUTED
  // ==================================================================
  
  // Get the time to compute new shared boundaries ids
  double tt_start_get_new_shared_boundaries_ids=0.0;
  if (Print_timings_level_load_balance>2)
    {
      tt_start_get_new_shared_boundaries_ids=TimingHelpers::timer();
    }
  
  // Get the number of shared boundaries with in each processor
  Vector<unsigned> nshared_boundaries_with_processor(nproc);
  // Loop over the processors
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // No shared boundaries with myself
    if (iproc != my_rank)
     {
      // Store the number of shared boundaries of the current
      // processor (my_rank) with the iproc processor
      nshared_boundaries_with_processor[iproc] = 
       sorted_face_ele_pt[iproc].size();
      
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc)
  
  // Each processor sends the number of shared boundaries that it has
  // with in each other processor to the "root_processor" which will
  // be in charge of checking and computing the global shared
  // boundaries ids
  const unsigned root_processor = 0;
  
  // Get the communicator of the mesh
  OomphCommunicator* comm_pt = this->communicator_pt();
  
  // Container where to store the info. received from other processor
  // in root. It receives from all processors the number of shared
  // boundaries that each one has with any other processor
  Vector<unsigned> flat_unsigned_root_received_data(nproc*nproc);
  
  // Gather the info. in the "root_processor"
  MPI_Gather(&nshared_boundaries_with_processor[0], // Info. sent from
                                                    // each processor
             nproc, // Total number of data to send from each
                    // processor
             MPI_UNSIGNED,
             &flat_unsigned_root_received_data[0], // Container where
                                                   // to receive the
                                                   // info. from all
                                                   // the processors
              nproc, // Number of data to receive from each processor
              MPI_UNSIGNED,
              root_processor, // The processor that receives all the
                              // info.
              comm_pt->mpi_comm());
  
  // Container where root store the info. that will be sent back to
  // all processor, because root performs a Broadcast operation then
  // the info. is received in the same container
  Vector<unsigned> flat_unsigned_root_send_receive_data;
  
  // Compute the new initial and final shared boundary id (they are
  // based on the global number of shared boundaries)
  unsigned new_initial_shared_boundary_id = 0;
  unsigned new_final_shared_boundary_id = 0;
  
  // Compute the boundaries ids for the shared boundaries
  if (my_rank == root_processor)
   {
    // Change the representation of the data received from all
    // processors to a matrix representation for ease access
    Vector<Vector<unsigned> > root_nshared_bound_proc_with_proc(nproc);
    // Loop over the processors and get the number of shared
    // boundaries of processor iproc with jproc
    for (unsigned iproc = 0; iproc < nproc; iproc++)
     {
      // Resize the vector to store the data
      root_nshared_bound_proc_with_proc[iproc].resize(nproc);
      // Loop over the processors and get the number of shared
      // boundaries of processor iproc with jproc
      for (unsigned jproc = 0; jproc < nproc; jproc++)
       {
        root_nshared_bound_proc_with_proc[iproc][jproc] = 
         flat_unsigned_root_received_data[(iproc * nproc) + jproc];
        
       } // for (jproc < nproc)
      
     } // for (iproc < nproc)
    
#ifdef PARANOID
    // Check that the same number of boundaries are shared by two
    // specific processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
     {
      for (unsigned jproc = 0; jproc < iproc; jproc++)
       {
        if (root_nshared_bound_proc_with_proc[iproc][jproc] !=
            root_nshared_bound_proc_with_proc[jproc][iproc])
         {
          std::ostringstream error_stream;
          error_stream
           << "ROOT PROCESSOR ERROR\n\n"
           << "The number of shared boundaries between processor (" 
           << iproc << ") and (" << jproc << ") is not the same:\n"
           << "Shared boundaries of processor (" << iproc 
           << ") with processor (" << jproc << "): (" 
           << root_nshared_bound_proc_with_proc[iproc][jproc] << ")\n"
           << "Shared boundaries of processor (" << jproc 
           << ") with processor (" << iproc << "): (" 
           << root_nshared_bound_proc_with_proc[jproc][iproc] << ")\n\n";
          throw OomphLibError(error_stream.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
          
         } // The number of shared boundaries between processors
           // "iproc" and "jproc" is not the same
        
       } // for (jproc < iproc)
      
     } // for (iproc < nproc)
#endif
    
    // The enumeration of the shared boundaries starts from the lowest
    // processor number to the highest processor number
    
    // Two processors share the same boundaries ids, the lowest
    // processor number is the one in charge of computing the shared
    // boundaries ids
    Vector<Vector<unsigned> > start_shared_bound_id_proc_with_proc(nproc);
    // Resize the vector, we can not do it when storing the
    // info. because of the strategy to save the info.
    for (unsigned iproc = 0; iproc < nproc; iproc++)
     {start_shared_bound_id_proc_with_proc[iproc].resize(nproc);}
    
    // The shared boundaries ids start from the current number of
    // original boundaries
    unsigned shared_bound_id = this->nboundary();
    
    // Set the new initial shared boundary id
    new_initial_shared_boundary_id = shared_bound_id;
    
    // Assign the global shared boundary id for the shared boundaries
    for (unsigned iproc = 0; iproc < nproc; iproc++)
     {
      for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
       {
        // Are there shared boundaries between the pair of processors
        if (root_nshared_bound_proc_with_proc[iproc][jproc] > 0)
         {
          // Set the start boundary id of processor "iproc" with
          // processor "jproc" and viceversa
          start_shared_bound_id_proc_with_proc[iproc][jproc] = shared_bound_id;
          start_shared_bound_id_proc_with_proc[jproc][iproc] = shared_bound_id;
          // Increase the shared boundary id counter with as many
          // shared boundaries there are between the iproc and jproc
          // processor
          shared_bound_id+= root_nshared_bound_proc_with_proc[iproc][jproc];
         } // if (root_nshared_bound_proc_with_proc[iproc][jproc] > 0)
        
       } // for (jproc < iproc)
      
     } // for (iproc < nproc)
    
    // Set the new final shared boundary id
    new_final_shared_boundary_id = shared_bound_id;
    
    // Prepare the info. to send back to each processor
    Vector<unsigned> send_start_shared_bound_id_proc_with_proc(nproc*nproc);
    
    // Copy the info. to the storage to send the info. back to other
    // processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
     {
      for (unsigned jproc = 0; jproc < nproc; jproc++)
       {
        // Get the initial shared boundary id between each pair of
        // processors (iproc, jproc)
        const unsigned initial_shd_bnd_id = 
         start_shared_bound_id_proc_with_proc[iproc][jproc];
        flat_unsigned_root_send_receive_data.push_back(initial_shd_bnd_id);
        
        // .. then copy the number of shared boundaries that there are
        // between processor iproc and jproc
        const unsigned nshared_bnd_iproc_jproc = 
         root_nshared_bound_proc_with_proc[iproc][jproc];
        flat_unsigned_root_send_receive_data.push_back(nshared_bnd_iproc_jproc);
        
       } // for (jproc < nproc)
      
     } // for (iproc < nproc)
    
    // .. at the end of the data to send include the global initial
    // shared boundary id
    flat_unsigned_root_send_receive_data.
     push_back(new_initial_shared_boundary_id);
    
    // ... and the global final shared boundary id
    flat_unsigned_root_send_receive_data.
     push_back(new_final_shared_boundary_id);
    
   } // if (my_rank == root_processor)
  
  // Send the initial shared boundaries ids and the number of shared
  // boundaries between all procesors to all processors. All
  // processors need to know this info.
  
  // The number of data that will be sent by root to other processors
  // and the number of data that other processors receive from root,
  // it is the same because it is performed via a Broadcast
  unsigned root_ndata_sent_to_all_proc = 
   flat_unsigned_root_send_receive_data.size();
  
  MPI_Bcast(&root_ndata_sent_to_all_proc, // Data to send
            1, MPI_UNSIGNED, root_processor, 
            comm_pt->mpi_comm());
  
  // Resize the container if this is a processor that receives data
  if (my_rank != root_processor)
   {
    flat_unsigned_root_send_receive_data.resize(root_ndata_sent_to_all_proc);
   }
  
  // Send back the start boundaries ids for the shared boundaries
  // Scatter the info. from the "root_processor"
  MPI_Bcast(&flat_unsigned_root_send_receive_data[0], // Info. sent to
                                                      // each
                                                      // processor
            root_ndata_sent_to_all_proc, // Total number of data to
                                         // send to each processor
            MPI_UNSIGNED,
            root_processor, // The processor that sends all the info.
            comm_pt->mpi_comm());
  
  // The container to store the initial shared boundaries ids between
  // each pair of processors
  Vector<Vector<unsigned> > initial_shared_bound_id_proc_with_proc(nproc);
  
  // All processors need to know how many shared boundaries there are
  // between each pair of processors
  
  // The number of shared boundaries between each pair of processors
  Vector<Vector<unsigned> > nshared_bound_proc_with_proc(nproc);
  
  unsigned iflat_counter = 0;
  // Fill the containers with the received info. from root processor
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // Resize the containers
    initial_shared_bound_id_proc_with_proc[iproc].resize(nproc);
    nshared_bound_proc_with_proc[iproc].resize(nproc);
    
    // Loop over the processors
    for (unsigned jproc = 0; jproc < nproc; jproc++)
     {
      // Get the initial shared boundary id between each pair of
      // processors (iproc, jproc)
      initial_shared_bound_id_proc_with_proc[iproc][jproc] = 
       flat_unsigned_root_send_receive_data[iflat_counter++];
      
      // .. and copy the number of shared boundaries that there are
      // between processor iproc and jproc
      nshared_bound_proc_with_proc[iproc][jproc] = 
       flat_unsigned_root_send_receive_data[iflat_counter++];
      
     } // for (jproc < nproc)
    
   } // for (iproc < nproc)
  
  // Read the new initial shared boundary id
  new_initial_shared_boundary_id = 
   flat_unsigned_root_send_receive_data[root_ndata_sent_to_all_proc-2];
  
  // Read the new final shared boundary id
  new_final_shared_boundary_id = 
   flat_unsigned_root_send_receive_data[root_ndata_sent_to_all_proc-1];
  
  // The time to compute new shared boundaries ids
  if (Print_timings_level_load_balance>2)
    {
      oomph_info << "CPU for computing new shared boundaries ids (load balance) [9.6]: "
                 <<TimingHelpers::timer()-tt_start_get_new_shared_boundaries_ids
                 << std::endl;
    }
  
  // ==================================================================
  // END: COMPUTE THE GLOBAL SHARED BOUNDARIES IDS. GATHER THE NUMBER
  // OF SHARED BOUNDARIES OF EACH PROCESSOR, THEN A ROOT PROCESSOR IS
  // IN CHARGE OF VERIFYING THAT THE SAME NUMBER OF SHARED BOUNDARIES
  // HAVE BEEN CREATED BY A PAIR OF PROCESSORS. THE ROOT PROCESSOR
  // COMPUTES THE INITIAL GLOBAL SHARED BOUNDARY ID BETWEEN EACH PAIR
  // OR PROCESSORS AND SENDS THESE INFO. TO ALL PROCESSORS. THE GLOBAL
  // INITIAL AND FINAL SHARED BOUNDARY ID ARE ALSO COMPUTED
  // ==================================================================
  
  // ==================================================================
  // BEGIN: CREATE THE NEW SHARED BOUNDARIES. DELETE THE OLD SHARED
  // BOUNDARIES INFORMATION. FILL THE DATA STRUCTURES WITH THE NEW
  // SHARED BOUNDARIES INFO.
  // ==================================================================
  
  // Get the time to create new shared boundaries representations
  double tt_start_create_new_shared_boundaries_polylines=0.0;
  if (Print_timings_level_load_balance>2)
    {
      tt_start_create_new_shared_boundaries_polylines=TimingHelpers::timer();
    }
  
  // Create the shared boundaries and establish all the related info.
  // - Create Polylines
  // - Store shared boundary elements
  // - Fill data structures to know which shared boundaries belong to
  //   which processor
  
  // Resize the shared polylines container
  this->flush_shared_boundary_polyline_pt();
  this->Shared_boundary_polyline_pt.resize(nproc);
  
  // Resize for the boundaries ids shared with all processors
  this->Shared_boundaries_ids.clear();
  this->Shared_boundaries_ids.resize(nproc);
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    this->Shared_boundaries_ids[iproc].clear();
    this->Shared_boundaries_ids[iproc].resize(nproc);
   } // for (iproc < nproc)
    
  // Clear data
  this->Shared_boundary_from_processors.clear();
  this->Shared_boundary_overlaps_internal_boundary.clear();
  this->Boundary_was_splitted.clear();
  this->Boundary_subpolylines.clear();
  this->Boundary_marked_as_shared_boundary.clear();
  
  // Flush data
  this->flush_shared_boundary_element();
  this->flush_face_index_at_shared_boundary();
  this->flush_shared_boundary_node();
  this->flush_sorted_shared_boundary_node();
  
  // Store the old local inital shared boundary id (used to map from
  // local shared boundary id to global shared boundary id)
  const unsigned old_local_shd_bnd_id = this->Initial_shared_boundary_id;
  
  // Update the initial and final shared boundary id
  this->Initial_shared_boundary_id = new_initial_shared_boundary_id;
  this->Final_shared_boundary_id = new_final_shared_boundary_id;
  
  // Storage for the new created polylines between the current
  // processor (my_rank) and the other processors, unsorted polylines
  Vector<TriangleMeshPolyLine *> unsorted_polylines_pt;
  
  // Map to get the global shared boundary id from the local shared
  // boundary id. Note that this is only used to get the global shared
  // boundary id when the shared boundary that is being created has
  // connections
  std::map<unsigned, unsigned> local_to_global_shd_bnd_id;
  
  // Each processor knows the boundaries ids for each of the shared
  // boundaries it has, establish that info. in the proper containers
  // Additionally, store the shared boundaries of ALL processors with
  // ALL processors, but only create the shared boundaries (and their
  // respective polylines) of the current processor (my_rank)
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // Avoid creating double shared boundaries, the shared boundaries
    // created between processor "iproc" and processor "jproc" are the
    // same than those created between processor "jproc" and processor
    // "iproc"
    for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
     {
      // If we are working with the current processor (my_rank) then
      // create the shared boundaries, if that is not the case then
      // only fill the info. on the proper containers
      if (iproc == my_rank || jproc == my_rank)
       {        
        // Check the condition that made it get here
        unsigned ref_proc = 0;
        if (iproc == my_rank)
         {ref_proc = jproc;}
        else if (jproc == my_rank)
         {ref_proc = iproc;}
        
        // Get the number of shared boundaries between processor iproc
        // and processor jproc
        const unsigned nshared_bound_iproc_jproc = 
         nshared_bound_proc_with_proc[iproc][jproc];
        
        // Loop over the number of shared boundaries
        for (unsigned counter = 0; 
             counter < nshared_bound_iproc_jproc;
             counter++)
         {
          // Compute the shared boundary id for the shared boundary
          const unsigned shd_bnd_id = 
           initial_shared_bound_id_proc_with_proc[iproc][jproc] + counter;
          // Set up the shared boundaries between "iproc" (my_rank)
          // and "jproc"
          this->Shared_boundaries_ids[iproc][jproc].push_back(shd_bnd_id);
          this->Shared_boundaries_ids[jproc][iproc].push_back(shd_bnd_id);
          
          // Specify the processors involved for the creation of the
          // shared boundary
          Vector<unsigned> processors(2);
          processors[0] = iproc;
          processors[1] = jproc;
          this->Shared_boundary_from_processors[shd_bnd_id] = processors;
          
          // Get the possible root edge id associated to the shared
          // boundary (useful when the shared boundary overlaps an
          // original boundary)
          int root_edge_bound_id = edge_boundary_id[ref_proc][counter];
          // Check if the shared boundary is overlapping (or is part)
          // of an internal boundary
          if (root_edge_bound_id != -1)
           {
            // If the shared boundary is part of an internal boundary then
            // mark the shared boundary
            this->Shared_boundary_overlaps_internal_boundary[shd_bnd_id] = 
             static_cast<unsigned>(root_edge_bound_id);
           } // if (root_edge_bound_id != -1)
          
          // Storing for the nodes of the polyline (these are different
          // from the nodes on the face elements -- it is actually a
          // sub-set -- since the polyline is created from the first and
          // last nodes on the face elements)
          Vector<Node*> node_pt_to_create_shared_polyline;
          
          // Add the first node for the very first face element. In
          // the loop we will only add the last node of the face
          // element
          FiniteElement* first_face_ele_pt = 
           sorted_face_ele_pt[ref_proc][counter][0];
          
          // Get the number of nodes on the first face element
          const unsigned first_face_ele_nnodes = first_face_ele_pt->nnode();
          if (!is_inverted[first_face_ele_pt])
           {
            // Get the first node
            Node* first_node_pt = first_face_ele_pt->node_pt(0);
            // Add the node to create the polyline
            node_pt_to_create_shared_polyline.push_back(first_node_pt);
            // Add the first node to the shared boundary
            this->add_shared_boundary_node(shd_bnd_id, first_node_pt);
           }
          else
           {
            // Get the first node in the inverted face element
            Node* first_node_pt = 
             first_face_ele_pt->node_pt(first_face_ele_nnodes - 1);
            // Add the node to create the polyline
            node_pt_to_create_shared_polyline.push_back(first_node_pt);
            // Add the first node to the shared boundary
            this->add_shared_boundary_node(shd_bnd_id, first_node_pt);
           }
                    
          // ... and extract only the last nodes of the face elements
          // in the next loop and add them in the vector of nodes to
          // create polylines (node_pt_to_create_shared_polyline)
          
          // Get the number of elements
          const unsigned nshared_boundary_elements = 
           sorted_face_ele_pt[ref_proc][counter].size();
          
          // Store the shared boundary elements, nodes and get the
          // sorted nodes to create the polyline
          for (unsigned ie = 0 ; ie < nshared_boundary_elements; ie++)
           {
            // Get the bulk element version of the face element
            FiniteElement* bulk_ele_pt = sorted_ele_pt[ref_proc][counter][ie];
            
            // Add the shared boundary element and associate it to the
            // "shd_bnd_id"
            this->add_shared_boundary_element(shd_bnd_id, 
                                              bulk_ele_pt);
            
            // Get the face index from which the face element was
            // created from the bulk element
            const int face_index = 
             sorted_face_index_ele[ref_proc][counter][ie];
            
            // Add the face index to the face indexes of the shared
            // boundary
            this->add_face_index_at_shared_boundary(shd_bnd_id,
                                                    face_index);
            
            // Get the face element to obtain the last node
            FiniteElement* face_ele_pt = 
             sorted_face_ele_pt[ref_proc][counter][ie];
            
            // Get the number of nodes
            const unsigned nnodes = face_ele_pt->nnode();
            if (!is_inverted[face_ele_pt])
             {
              // We have already added the first node, then start from
              // the second one
              for (unsigned n = 1; n < nnodes; n++)
               {
                // Get the node to be added
                Node* node_pt = face_ele_pt->node_pt(n);
                // Add the node and associate it to the shared boundary
                this->add_shared_boundary_node(shd_bnd_id, node_pt);
               } // for (n < nnodes)
              
              // Add the last node of the face element to the vector of
              // nodes to create the polyline
              // Get the last node
              Node* last_node_pt = face_ele_pt->node_pt(nnodes - 1);
              node_pt_to_create_shared_polyline.push_back(last_node_pt);
             } // if (!is_inverted[face_ele_pt])
            else
             {
              // We have already added the first node, then start from
              // the second one (in reverse order)
              for (int n = nnodes-2; n >= 0; n--)
               {
                // Get the node to be added
                Node* node_pt = face_ele_pt->node_pt(n);
                // Add the node and associate it to the shared boundary
                this->add_shared_boundary_node(shd_bnd_id, node_pt);
               } // for (n < nnodes)
              
              // Add the last node of the face element to the vector of
              // nodes to create the polyline
              // Get the last node
              Node* last_node_pt = face_ele_pt->node_pt(0);
              node_pt_to_create_shared_polyline.push_back(last_node_pt);
              
             } // else if (!is_inverted[face_ele_pt])
            
           } // for (ie < nshared_boundary_elements)
          
          // The number of nodes for the shared boundary polyline
          const unsigned nnodes_to_create_shared_boundary = 
           node_pt_to_create_shared_polyline.size();
          
          // Get the vertices that create the shared boundary polyline
          Vector<Vector<double> > vertices(nnodes_to_create_shared_boundary);
          for (unsigned n = 0; n < nnodes_to_create_shared_boundary; n++)
           {
            vertices[n].resize(2);
            // Get the node
            Node* tmp_node_pt = node_pt_to_create_shared_polyline[n];
            // Get the vertices
            vertices[n][0] = tmp_node_pt->x(0);
            vertices[n][1] = tmp_node_pt->x(1);
           } // for (n < nnodes_to_create_shared_boundary)
          
          // Create the polyline
          TriangleMeshPolyLine *polyline_pt = 
           new TriangleMeshPolyLine(vertices, shd_bnd_id);
          
          // Updates bnd_id<--->curve section map
          this->Boundary_curve_section_pt[shd_bnd_id] = polyline_pt;
          
          // Add the new created polyline to the list of unsorted
          // polylines
          unsorted_polylines_pt.push_back(polyline_pt);
          
          // Mark the polyline for deletion (when calling destructor)
          this->Free_curve_section_pt.insert(polyline_pt);
          
          // Now assign the connection information
          // ---------------------------------------------------------
          // Get the local shared boundary id associated to the
          // elements that gave rise to this shared boundary
          const unsigned local_shd_bnd_id = 
           proc_local_shared_boundary_id[ref_proc][counter];
          
          // Associate the local shared boundary to the global shared
          // boundary
          local_to_global_shd_bnd_id[local_shd_bnd_id] = shd_bnd_id;
          
          // Get the correct shared boundaries ids, from the local
          // shared boundaries ids established at the identification
          // of the conections
          
          // Get the local bnd id for the connection to the left
          int tmp_bnd_id_connection_to_the_left = 
           sorted_connection_info[ref_proc][counter][0];
          // Get the local bnd id for the connection to the right
          int tmp_bnd_id_connection_to_the_right = 
           sorted_connection_info[ref_proc][counter][1];
          
          // The global shared boundaries ids for connections to the
          // left or right
          int bnd_id_connection_to_the_left = -1;
          int bnd_id_connection_to_the_right = -1;
          
          // To the left
          // --------------
          
          // If the connection is with the same shared boundary then
          // set the current boundary id
          if (tmp_bnd_id_connection_to_the_left == -2)
           {
            // Set the current shared boundary id
            bnd_id_connection_to_the_left = shd_bnd_id;
           } // if (tmp_bnd_id_connection_to_the_left == -2)
          
          // Check if the connection was a stop adding nodes condition
          if (tmp_bnd_id_connection_to_the_left == -3)
           {
            // Set as no connected
            bnd_id_connection_to_the_left = -1;
           } // if (tmp_bnd_id_connection_to_the_left == -3)
          
          // There is a connection with another boundary, check if it
          // is a shared boundary or an original boundary
          if (tmp_bnd_id_connection_to_the_left >= 
              static_cast<int>(old_local_shd_bnd_id))
           {
            // The connection is with a shared boundary, get the
            // global shared boundary id and set the connection
#ifdef PARANOID
            std::map<unsigned, unsigned>::iterator it = 
             local_to_global_shd_bnd_id.find(
              static_cast<unsigned>(tmp_bnd_id_connection_to_the_left));
            // If the global shared boundary id was not found we
            // are in trouble
            if (it==local_to_global_shd_bnd_id.end())
             {
              std::stringstream error_message;
              error_message
               << "The global shared boundary id was not found for\n"
               << "the local shared boundary shared with processor ("
               << ref_proc <<").\n"
               << "This processor: (" << my_rank << ")\n"
               << "Boundary shared with processor: (" << ref_proc << ")\n"
               << "Local shared boundary: (" 
               << tmp_bnd_id_connection_to_the_left << ")\n";
              throw OomphLibError(error_message.str(),
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
             } // if (it==local_to_global_shd_bnd_id.end())
#endif
            
            // Get the global shared boundary id
            bnd_id_connection_to_the_left = 
             local_to_global_shd_bnd_id[
              static_cast<unsigned>(tmp_bnd_id_connection_to_the_left)];
            
           }
          else
           {
            // The connection is with an original boundary, copy
            // the boundary id
            bnd_id_connection_to_the_left = 
             tmp_bnd_id_connection_to_the_left;
            
           } // else (connection with a shared boundary)
          
          // To the right
          // --------------
          
          // If the connection is with the same shared boundary then
          // set the current boundary id
          if (tmp_bnd_id_connection_to_the_right == -2)
           {
            // Set the current shared boundary id
            bnd_id_connection_to_the_right = shd_bnd_id;
           } // if (tmp_bnd_id_connection_to_the_right == -2)
          
          // Check if the connection was a stop adding nodes condition
          if (tmp_bnd_id_connection_to_the_right == -3)
           {
            // Set as no connected
            bnd_id_connection_to_the_right = -1;
           } // if (tmp_bnd_id_connection_to_the_right == -3)
          
          // There is a connection with another boundary, check if it
          // is a shared boundary or an original boundary
          if (tmp_bnd_id_connection_to_the_right >= 
              static_cast<int>(old_local_shd_bnd_id))
           {
            // The connection is with a shared boundary, get the
            // global shared boundary id and set the connection
#ifdef PARANOID
            std::map<unsigned, unsigned>::iterator it = 
             local_to_global_shd_bnd_id.find(
              static_cast<unsigned>(tmp_bnd_id_connection_to_the_right));
            // If the global shared boundary id was not found we
            // are in trouble
            if (it==local_to_global_shd_bnd_id.end())
             {
              std::stringstream error_message;
              error_message
               << "The global shared boundary id was not found for\n"
               << "the local shared boundary shared with processor ("
               << ref_proc <<").\n"
               << "This processor: (" << my_rank << ")\n"
               << "Boundary shared with processor: (" << ref_proc << ")\n"
               << "Local shared boundary: (" 
               << tmp_bnd_id_connection_to_the_right << ")\n";
              throw OomphLibError(error_message.str(),
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
             } // if (it==local_to_global_shd_bnd_id.end())
#endif
            // Get the global shared boundary id
            bnd_id_connection_to_the_right = 
             local_to_global_shd_bnd_id[
              static_cast<unsigned>(tmp_bnd_id_connection_to_the_right)];
            
           }
          else
           {
            // The connection is with an original boundary, copy the
            // boundary id
            bnd_id_connection_to_the_right = 
             tmp_bnd_id_connection_to_the_right;
            
           } // else (connection with a shared boundary)
          
          // --------------------------------
          // Set the connection to the left
          if (bnd_id_connection_to_the_left != -1)
           {
            // Get the unsigned version of the boundary id to the left
            const unsigned ubnd_id_connection_to_the_left = 
             static_cast<unsigned>(bnd_id_connection_to_the_left);
            // Set the initial vertex as connected
            polyline_pt->set_initial_vertex_connected();
            // Set the initial vertex connected boundary id
            polyline_pt->initial_vertex_connected_bnd_id() = 
             ubnd_id_connection_to_the_left;
            // Set the chunk number to zero
            polyline_pt->initial_vertex_connected_n_chunk() = 0;
            
           } // if (bnd_id_connection_to_the_left != -1)
          
          // ---------------------------------
          // Set the connection to the right
          if (bnd_id_connection_to_the_right != -1)
           {
            // Get the unsigned version of the boundary id to the
            // right
            const unsigned ubnd_id_connection_to_the_right = 
             static_cast<unsigned>(bnd_id_connection_to_the_right);
            // Set the final vertex as connected
            polyline_pt->set_final_vertex_connected();
            // Set the final vertex connected boundary id
            polyline_pt->final_vertex_connected_bnd_id() = 
             ubnd_id_connection_to_the_right;
            // Set the chunk number to zero
            polyline_pt->final_vertex_connected_n_chunk() = 0;
            
           } // if (bnd_id_connection_to_the_right != -1)
          
         } // for (counter < nshared_bound_iproc_jproc)
        
       } // if (iproc  == my_rank || jproc == my_rank)
      else
       {
        // We are not working with the current processor, then we only
        // need to fill the containers
         
        // Get the number of shared boundaries between processor iproc
        // and processor jproc
        const unsigned nshared_bound_iproc_jproc = 
         nshared_bound_proc_with_proc[iproc][jproc];
        // Loop over the number of shared boundaries
        for (unsigned counter = 0; 
             counter < nshared_bound_iproc_jproc;
             counter++)
         {
          // Compute the shared boundary id for the shared boundary
          const unsigned shd_bnd_id = 
           initial_shared_bound_id_proc_with_proc[iproc][jproc] + counter;
          
          // Set up the shared boundaries between "iproc" and "jproc"
          this->Shared_boundaries_ids[iproc][jproc].push_back(shd_bnd_id);
          this->Shared_boundaries_ids[jproc][iproc].push_back(shd_bnd_id);
          
          // Specify the processors involved for the creation of the
          // shared boundary
          Vector<unsigned> processors(2);
          processors[0] = iproc;
          processors[1] = jproc;
          this->Shared_boundary_from_processors[shd_bnd_id] = processors;
          
         } // for (counter < nshared_bound_iproc_jproc)
        
       } // else if (iproc  == my_rank || jproc == my_rank)
      
     } // for (jproc < nproc)
    
   } // for (iproc < nproc)
  
  // Get the time to create new shared boundaries representations
  if (Print_timings_level_load_balance>2)
    {
      oomph_info << "CPU for creating new shared boundaries representations (load balance) [9.7]: "
                 <<TimingHelpers::timer()-tt_start_create_new_shared_boundaries_polylines
                 << std::endl;
    }
  
  // ==================================================================
  // END: CREATE THE NEW SHARED BOUNDARIES. DELETE THE OLD SHARED
  // BOUNDARIES INFORMATION. FILL THE DATA STRUCTURES WITH THE NEW
  // SHARED BOUNDARIES INFO.
  // ==================================================================
  
  // ==================================================================
  // BEGIN: SORT THE SHARED BOUNDARIES AND CREATE SHARED CURVES (A SET
  // OF CONTIGUOUS SHARED POLYLINES). STORE THEM IN THE GLOBAL
  // CONTAINER FOR SHARED BOUNDARIES. FREE MEMORY BY DELETING FACE
  // ELEMENTS
  // ==================================================================
  
  // Get the time to create the new shared curves
  double tt_start_create_new_shared_curves=0.0;
  if (Print_timings_level_load_balance>2)
    {
      tt_start_create_new_shared_curves=TimingHelpers::timer();
    }
  
  // Sort the polylines and find if they create a contiguous open
  // curve
  if (unsorted_polylines_pt.size() > 0)
   {
    // Now that we have all the new unsorted polylines on "my_rank"x
    // processor it is time to sort them so they be all contiguous
     this->sort_polylines_helper(unsorted_polylines_pt, 
				 this->Shared_boundary_polyline_pt[my_rank]);
   }
  
  // Free the memory allocated for the face elements
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    const unsigned nface_ele = unsorted_face_ele_pt[iproc].size();
    for (unsigned e = 0; e < nface_ele; e++)
     {
      delete unsorted_face_ele_pt[iproc][e];
      unsorted_face_ele_pt[iproc][e] = 0;
     } // for (e < nface_ele)
    
   } // for (iproc < nproc)
  
  // The time to create the new shared curves
  if (Print_timings_level_load_balance>2)
    {
      oomph_info << "CPU for creating the new shared curves (load balance) [9.8]: "
                 <<TimingHelpers::timer()-tt_start_create_new_shared_curves
                 << std::endl;
    }
  
  // ==================================================================
  // END: SORT THE SHARED BOUNDARIES AND CREATE SHARED CURVES (A SET
  // OF CONTIGUOUS SHARED POLYLINES). STORE THEM IN THE GLOBAL
  // CONTAINER FOR SHARED BOUNDARIES. FREE MEMORY BY DELETING FACE
  // ELEMENTS
  // ==================================================================
  
 }
 
 //======================================================================
 // Computes the degree of the nodes on the shared boundaries, the
 // degree of the node is computed from the global graph created by the
 // shared boundaries of all processors
 //======================================================================
 template <class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 compute_shared_node_degree_helper(Vector<Vector<FiniteElement*> >
                                   &unsorted_face_ele_pt,
                                   std::map<Node*, unsigned> 
                                   &global_node_degree)
 {
  // Get the rank and number of processors
  const unsigned nproc = this->communicator_pt()->nproc();
  const unsigned my_rank = this->communicator_pt()->my_rank();
  
  // Store a temporary sorting of the nodes, starting from the
  // lower-left position
  Vector<Vector<Node*> > tmp_sorted_shared_node_pt(nproc);
  
  // Store the alias of the node, it may be shared by more than two
  // processors, they should know that the node is the same
  // [0] iproc, processor with which the current processor shared the node
  // [1] node #, number of node in the number of nodes shared with iproc
  //     processor
  std::map<Node*, Vector<Vector<unsigned> > > node_alias;
  
  // Stores the local adjacency matrix
  // (nproc*n_shared_nodes*n_shared_nodes)
  Vector<Vector<Vector<unsigned> > > local_adjacency_matrix(nproc);
  
  // Sort the nodes and create the adjacency matrix of each sub-graph
  // created by the shared edges
  create_adjacency_matrix_new_shared_edges_helper(unsorted_face_ele_pt,
                                                  tmp_sorted_shared_node_pt,
                                                  node_alias,
                                                  local_adjacency_matrix);
  
  // Prepare the info. to be sent to the root processor, which will be
  // in charge of updating the nodes degree by combining the info. of
  // all the processors
  
  // The flat package with the info. to send to root
  Vector<unsigned> package_unsigned_send_data_to_root;
  
  // Encode the info. that will be sent to the root processor
  
  // Loop over the temporary sorted nodes between each pair of
  // processors
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // Send the processor index
    package_unsigned_send_data_to_root.push_back(iproc);
    
    // Get the number of nodes shared between the processors
    const unsigned n_nodes = tmp_sorted_shared_node_pt[iproc].size();
    
    // Send the number of nodes shared with the iproc processor
    package_unsigned_send_data_to_root.push_back(n_nodes);
    
    // Loop over the nodes
    for (unsigned ishd = 0; ishd < n_nodes; ishd++)
     {
      // Get the node
      Node* shd_node_pt = tmp_sorted_shared_node_pt[iproc][ishd];
      
      // Get the alias info.
      Vector<Vector<unsigned> > alias_node_info = node_alias[shd_node_pt];
      
       // Get the number of alias for the node
      const unsigned n_alias = alias_node_info.size();
      
      // Send the number of alias assigned to the node
      package_unsigned_send_data_to_root.push_back(n_alias);
      
      // Loop over the alias to include them in the package
      for (unsigned i = 0; i < n_alias; i++)
       {
        // Send the alias info.
        // The current processor
        package_unsigned_send_data_to_root.push_back(alias_node_info[i][0]);
        // The prociesso with which is shared
        package_unsigned_send_data_to_root.push_back(alias_node_info[i][1]);
        // The index of the node
        package_unsigned_send_data_to_root.push_back(alias_node_info[i][2]);
       } // for (i < n_alias)
      
     } // for (ishd < n_nodes)
    
    // Now send the adjacency matrix
    for (unsigned i = 0; i < n_nodes; i++)
     {
      for (unsigned j = 0; j < n_nodes; j++)
       {
        // Package the adjacency matrix
        package_unsigned_send_data_to_root.
         push_back(local_adjacency_matrix[iproc][i][j]);
        
       } // for (j < n_nodes)
      
     } // for (i < n_nodes)
    
   } // for (iproc < nproc)
  
  // Define the root processor
  const unsigned root_processor = 0;
  
  // Get the communicator of the mesh
  OomphCommunicator* comm_pt = this->communicator_pt();
  
  // Number of data send. from this processor to root processor
  unsigned n_unsigned_data_send_to_root = 
   package_unsigned_send_data_to_root.size();
  
  // Store the number of data to receive from each processor in root
  Vector<int> n_unsigned_data_received_in_root(nproc, 0);
  
  // Send the number of data that each processor will send to root
  // Gather the info. in the "root_processor"
  MPI_Gather(&n_unsigned_data_send_to_root, // Info. sent from
                                                // each processor
             1, // Total number of data to send from each processor
             MPI_UNSIGNED,
             &n_unsigned_data_received_in_root[0], // Container where
                                                  // to receive the
                                                  // info. from all
                                                  // the processors
             1, // Number of data to receive from each processor
             MPI_UNSIGNED,
             root_processor, // The processor that receives all the
                             // info.
             comm_pt->mpi_comm());
  
  // Compute the total number of data to receive from all processors
  unsigned n_unsigned_total_data_receive_in_root = 0;
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // Add the number of data to receive from each processor
    n_unsigned_total_data_receive_in_root+=
     n_unsigned_data_received_in_root[iproc];
   }
  
  // Compute the offsets from each processor
  Vector<int> root_unsigned_offsets_receive(nproc,0);
  root_unsigned_offsets_receive[0] = 0;
  for (unsigned iproc = 1; iproc < nproc; iproc++)
   {
    // Compute the offset to store the values received from each
    // processor
    root_unsigned_offsets_receive[iproc] = 
     root_unsigned_offsets_receive[iproc-1] + 
     n_unsigned_data_received_in_root[iproc-1];
   }
  
  // Create at least one entry so we don't get a seg fault below
  if (package_unsigned_send_data_to_root.size()==0)
   {
    package_unsigned_send_data_to_root.resize(1);
   }
  
  // Vector where to receive the data sent from each processor
  Vector<unsigned> 
   package_unsigned_data_received_root(n_unsigned_total_data_receive_in_root);
  if (my_rank!=root_processor)
   {
    // Create at least one entry so we don't get a seg fault below
    if (package_unsigned_data_received_root.size()==0)
     {
      package_unsigned_data_received_root.resize(1);
     }
   } // if (my_rank!=root_processor)
  
  // Gather the info. from all processors
  MPI_Gatherv(&package_unsigned_send_data_to_root[0], // Flat package
                                                      // to send
                                                      // info. from
                                                      // each
                                                      // processor
              n_unsigned_data_send_to_root, // Total number of data to
                                            // send from each
                                            // processor
              MPI_UNSIGNED,
              &package_unsigned_data_received_root[0], // Container
                                                       // where to
                                                       // receive the
                                                       // info. from
                                                       // all the
                                                       // processors
              &n_unsigned_data_received_in_root[0], // Number of data
                                                    // to receive from
                                                    // each processor
              &root_unsigned_offsets_receive[0], // The offset to
                                                 // store the
                                                 // info. from each
                                                 // processor
              MPI_UNSIGNED,
              root_processor, //The processor that receives all the
                              //info.
              comm_pt->mpi_comm());
  
  // Store the info. to be sent by root to other processors
  Vector<unsigned> package_unsigned_data_sent_from_root;
  // Total data sent to each processor from root
  Vector<int> n_unsigned_data_sent_from_root(nproc, 0);
  
  // The root processor now has all the info. regarding the shared
  // nodes and the adjacency matrix of each pair of processors
  if (my_rank == root_processor)
   {
    // Decode the info. received from all processors
    // Counter to decode the info.
    unsigned decode_counter = 0;
    
    // Store the local alias of the nodes in each processor
    // [x][][][][] iproc
    // [][x][][][] jproc
    // [][][x][][] inode
    // [][][][x][] ialias
    // [][][][][x] alias_data
    Vector<Vector<Vector<Vector<Vector<unsigned> > > > > 
     local_node_alias(nproc);
    // Store the local adjacency matrix of each processor
    Vector<Vector<Vector<Vector<unsigned> > > > local_adjacency_matrix(nproc);
    
    // Loop over all the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
     {
      local_node_alias[iproc].resize(nproc);
      
      // Resize the local adjacency matrix to store the info. sent
      // from all processors
      local_adjacency_matrix[iproc].resize(nproc);
      
      if (n_unsigned_data_received_in_root[iproc] > 0)
       {
        // Loop over all the processors to decode the info. received
        // from each one
        for (unsigned jproc = 0; jproc < nproc; jproc++)
         {
          // Read the processor number to which the info. correspond
          const unsigned read_jproc = 
           package_unsigned_data_received_root[decode_counter++];
          
          // The read processor must be the same as the jproc, if that
          // is not the case then there is a synchronisation issue
          if (read_jproc != jproc)
           {
            std::ostringstream error_stream;
            error_stream
             << "The read processor is different from the jproc, this is\n"
             << "a synchronisation issue. The data are not read in the\n"
             << "sameorder as the were packaged\n"
             << "Read processor: (" << read_jproc << ")\n"
             << "Current jproc: (" << jproc << ")\n\n";
             throw OomphLibError(error_stream.str(),
                                 "RefineableTriangleMesh::compute_shared_node_degree_helper()",
                                 OOMPH_EXCEPTION_LOCATION);
           }
          
          // Read the number of nodes in the shared boundaries between
          // iproc and jproc
          const unsigned read_n_shd_nodes_iproc_jproc = 
           package_unsigned_data_received_root[decode_counter++];
          
          // Resize the container
          local_node_alias[iproc][jproc].resize(read_n_shd_nodes_iproc_jproc);
          
          // Loop over the number of nodes shared between iproc and
          // jproc
          for (unsigned ishd = 0; ishd < read_n_shd_nodes_iproc_jproc; ishd++)
           {
            // Read the number of alias of the current ishd node
            const unsigned read_n_alias_node_iproc_jproc = 
             package_unsigned_data_received_root[decode_counter++];
            
            // Resize the container
            local_node_alias[iproc][jproc][ishd].
             resize(read_n_alias_node_iproc_jproc);
            
            for (unsigned ialias = 0; 
                 ialias < read_n_alias_node_iproc_jproc; ialias++)
             {
              // Resize the container, we know there are three data to
              // define the alias of a node
              local_node_alias[iproc][jproc][ishd][ialias].resize(3);
              
              // The 1st processor with which is shared
              local_node_alias[iproc][jproc][ishd][ialias][0] = 
               package_unsigned_data_received_root[decode_counter++];

              // The 2nd processor with which is shared
              local_node_alias[iproc][jproc][ishd][ialias][1] = 
               package_unsigned_data_received_root[decode_counter++];
              
              // The index of the node in the interaction iproc-jproc
              local_node_alias[iproc][jproc][ishd][ialias][2] = 
               package_unsigned_data_received_root[decode_counter++];
              
             } // for (ialias < read_n_alias_node_iproc_jproc)
            
           } // for (ishd < read_n_shd_nodes_iproc_jproc)
          
          // Resize the local adjacency matrix
          local_adjacency_matrix[iproc][jproc].
           resize(read_n_shd_nodes_iproc_jproc);
          // Read the adjacency matrix sent to root processor
          for (unsigned i = 0; i < read_n_shd_nodes_iproc_jproc; i++)
           {
            // Resize the local adjacency matrix
            local_adjacency_matrix[iproc][jproc][i].
             resize(read_n_shd_nodes_iproc_jproc);
            for (unsigned j = 0; j < read_n_shd_nodes_iproc_jproc; j++)
             {
              // Read the adjacency matrix entry
              local_adjacency_matrix[iproc][jproc][i][j] = 
               package_unsigned_data_received_root[decode_counter++];
             } // for (j < read_n_shd_nodes_iproc_jproc)
            
           } // for (i < read_n_shd_nodes_iproc_jproc)
          
         } // for (jproc < nproc)
        
       } // for (iproc < nproc)
      
     } // for (iproc < nproc)
    
#ifdef PARANOID
    if (decode_counter != n_unsigned_total_data_receive_in_root)
     {
      std::ostringstream error_stream;
      error_stream
       << "The number of data decoded in root received from others\n"
       << "processors is different from the total number of data received\n"
       << "Data decoded: (" << decode_counter << ")\n"
       << "Data received: ("<<n_unsigned_total_data_receive_in_root<<")\n\n"
       << "This is a synchronisation issue so you are probably sending\n"
       << "more or less info. than the one that is being decoded\n\n";
      throw OomphLibError(error_stream.str(),
                          "RefineableTriangleMesh::compute_shared_node_degree_helper()",
                          OOMPH_EXCEPTION_LOCATION);
     }
#endif
    
    // Assign a unique id to the nodes (uses the alias information to
    // identify the repetition of a node in other processors). The
    // global node id is given by the position (index) in the global
    // node alias
    
    // Keep track of those alias already assigned a unique id
    std::map<Vector<unsigned>, bool> alias_done;
    
    // Store all the alias associated to each node
    Vector<Vector<Vector<unsigned> > > global_node_alias;
    
    // Loop over all the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
     {
      for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
       {
        // Read the number of nodes shared between the processors
        const unsigned n_shd_nodes_iproc_jproc = 
         local_node_alias[iproc][jproc].size();
#ifdef PARANOID
        // Read the number of nodes shared in the other direction
        const unsigned n_shd_nodes_jproc_iproc = 
         local_node_alias[jproc][iproc].size();
        
        if (n_shd_nodes_iproc_jproc != n_shd_nodes_jproc_iproc)
         {
          std::ostringstream error_stream;
          error_stream
           << "The number of nodes shared between iproc and jproc is\n"
           << "different from the number of nodes shared between jproc\n"
           << "and iproc\n"
           << "Nodes shared between processor (" << iproc << ") and "
           << "processor ("<<jproc<<"): ("<<n_shd_nodes_iproc_jproc<<")\n"
           << "Nodes shared between processor (" << jproc << ") and "
           << "processor ("<<iproc<<"): ("<<n_shd_nodes_jproc_iproc<<")\n\n";
          throw OomphLibError(error_stream.str(),
                              "RefineableTriangleMesh::compute_shared_node_degree_helper()",
                              OOMPH_EXCEPTION_LOCATION);
         } // if (n_shd_nodes_iproc_jproc != n_shd_nodes_jproc_iproc)
#endif
        
        // Loop over the nodes shared between the processors
        for (unsigned ishd = 0; ishd < n_shd_nodes_iproc_jproc; ishd++)
         {
          // Get the number of alias associated to the node on each
          // processor
          const unsigned n_alias_iproc_jproc = 
           local_node_alias[iproc][jproc][ishd].size();
          const unsigned n_alias_jproc_iproc = 
           local_node_alias[jproc][iproc][ishd].size();
          
          // Store all the found alias to the node
          Vector<Vector<unsigned> > node_alias;
          
          // Flag to indicate if a new alias has been added
          bool new_alias_added = false;
          
          // Start by adding the "direct" alias of the node
          for (unsigned ialias = 0; ialias < n_alias_iproc_jproc; ialias++)
           {
            // Get the alias of the node
            Vector<unsigned> current_alias = 
             local_node_alias[iproc][jproc][ishd][ialias];
            // Check if already done
            if (!alias_done[current_alias])
             {
              // Add the alias of the node
              node_alias.push_back(current_alias);
              // Set the flag to indicate a new alias has been added
              new_alias_added = true;
              // Mark the alias as done
              alias_done[current_alias] = true;
             } // if (!alias_done[i_alias])
            
           } // for (ialias < n_alias_iproc_jproc)
          
          // Start by adding the "direct" alias of the node
          for (unsigned ialias = 0; ialias < n_alias_jproc_iproc; ialias++)
           {
            // Get the alias of the node
            Vector<unsigned> current_alias = 
             local_node_alias[jproc][iproc][ishd][ialias];
            
            // Check if already done
            if (!alias_done[current_alias])
             {
              // Add the alias of the node
              node_alias.push_back(current_alias);
              // Set the flag to indicate a new alias has been added
              new_alias_added = true;
              // Mark the alias as done
              alias_done[current_alias] = true;
             } // if (!alias_done[i_alias])
            
           } // for (ialias < n_alias_jproc_iproc)
          
          unsigned counter_alias = 0;
          // Visit the alias of the node and add any new found
          // alias, end until all its alias have been included
          
          unsigned n_current_alias = node_alias.size();
          while(new_alias_added || counter_alias < n_current_alias)
            //while(new_alias_added) // we need to check all the alias, including those added during the process
           {
            new_alias_added = false;
            // Store the current visited alias
            Vector<unsigned> current_alias = node_alias[counter_alias];
            
            // Get the alias associated with the current alias
            Vector<Vector<unsigned> > alias_of_current_alias = 
             local_node_alias[current_alias[0]]
                             [current_alias[1]]
                             [current_alias[2]];
            
            // Get all the alias associated with the alias of the
            // current alias
            const unsigned n_alias = alias_of_current_alias.size();
            
            // Loop over the new alias and check if require to add
            // them
            for (unsigned k = 0; k < n_alias; k++)
             {
              // Get the alias of the node
              Vector<unsigned> add_alias = 
               alias_of_current_alias[k];
              
              // Check if already done
              if (!alias_done[add_alias])
               {
                // Add the alias of the node
                node_alias.push_back(add_alias);
                // Set the flag to indicate a new alias has been
                // added
                new_alias_added = true;
                // Mark the alias ad done
                alias_done[add_alias] = true;
               } // if (!alias_done[i_alias])
              
             } // for (k < n_alias)
            
            // Get the alias associated with the current alias (in the
            // other direction)
            Vector<Vector<unsigned> > alias_of_current_alias2 = 
             local_node_alias[current_alias[1]]
                             [current_alias[0]]
                             [current_alias[2]];
            
            // Get all the alias associated with the current alias
            // (in the other direction)
            const unsigned n_alias2 = alias_of_current_alias2.size();
            
            // Loop over the new alias and check if require to add
            // them
            for (unsigned k = 0; k < n_alias2; k++)
             {
              // Get the alias of the node
              Vector<unsigned> add_alias = 
               alias_of_current_alias2[k];
              
              // Check if already done
              if (!alias_done[add_alias])
               {
                // Add the alias of the node
                node_alias.push_back(add_alias);
                // Set the flag to indicate a new alias has been
                // added
                new_alias_added = true;
                // Mark the alias ad done
                alias_done[add_alias] = true;
               } // if (!alias_done[i_alias])
              
             } // for (k < n_alias)
            
            // Go for the next alias
            counter_alias++;
            
            // Update the number of alias so that the while stops when
            // all the alias have been visited and no new alias was
            // added
            n_current_alias = node_alias.size();
            
           } // while(new_alias_added || counter_alias < n_current_alias)
          
          // If the node has not been previously added, then include
          // all its alias
          if (node_alias.size() > 0)
           {
            // Add all the found alias of the node to the global alias
            // storage
            global_node_alias.push_back(node_alias);
           }
          
         } // for (ishd < n_shd_nodes_iproc_jproc)
        
       } // for (jproc < nproc)
      
     } // for (iproc < nproc)
    
    // We now have the global number of nodes, each with its own id
    // (the index in the global_node_alias vector)
    
    // Get the number of global shared nodes
    const unsigned n_global_shared_nodes = global_node_alias.size();
    
    // Create matrix from local to global shared node id
    Vector<Vector<Vector<int> > > local_to_global_shared_node(nproc);
    
    // Loop over all the processors to resize
    for (unsigned iproc = 0; iproc < nproc; iproc++)
     {
      // Resize the map matrix
      local_to_global_shared_node[iproc].resize(nproc);
     } // for (iproc < nproc)
    
    // Loop over all the processors to resize (the third direction,
    // required if we want to loop over the half of the matrix only)
    for (unsigned iproc = 0; iproc < nproc; iproc++)
     {
      // Loop over the half of the matrix to resize
      for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
       {
        // Read the number of nodes shared between the processors
        const unsigned n_shd_nodes = 
         local_node_alias[iproc][jproc].size();
        
        // Resize the map matrix
        local_to_global_shared_node[iproc][jproc].resize(n_shd_nodes,-1);
        
        // ... and resize the other half map matrix
        local_to_global_shared_node[jproc][iproc].resize(n_shd_nodes,-1);
        
       } // for (jproc < nproc)
      
     } // for (iproc < nproc)
    
    // Fill the matrix for mapping from local to global node id
    
    // Loop over the global nodes, and for each alias assign the
    // corresponding global node id
    for (unsigned k = 0 ; k < n_global_shared_nodes; k++)
     {
      // Get the number of alias associated to the current global node
      const unsigned n_alias_global_node = global_node_alias[k].size();
      // Loop over the alias and assign the global node id
      for (unsigned l = 0; l < n_alias_global_node; l++)
       {
        // Get the 1st processor
        const unsigned iproc = global_node_alias[k][l][0];
        // Get the 2nd processor
        const unsigned jproc = global_node_alias[k][l][1];
        // Get the node number
        const unsigned ishd = global_node_alias[k][l][2];
        // Assign the global node id
        local_to_global_shared_node[iproc][jproc][ishd] = k;
        
       } // for (l < n_alias_global_node)
      
     } // for (k < n_global_shared_nodes)
    
    // Create the global adjacency matrix
    Vector<Vector<unsigned> > global_adjacency_matrix(n_global_shared_nodes);
    // Resize the global adjacency matrix
    for (unsigned k = 0; k < n_global_shared_nodes; k++)
     {
      // Resize
      global_adjacency_matrix[k].resize(n_global_shared_nodes,0);
     } // for (k < n_global_shared_nodes)
    
    // Add the entries to the global adjacency matrix and compute the
    // degree of each node
    
    // Store the degree of the global nodes
    Vector<unsigned> global_node_degree(n_global_shared_nodes, 0);
    
    // Loop over the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
     {
      // Loop over the half of the matrix to resize
      for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
       {
        // Get the number of nodes shared between the processors
        const unsigned n_shd_nodes = 
         local_node_alias[iproc][jproc].size();
        
        // Search for entries in the local adjacency matrix that set a
        // connection among the nodes
        
        // Loop over the shared nodes in the current pair of
        // processors
        for (unsigned ishd = 0; ishd < n_shd_nodes; ishd++)
         {
          for (unsigned jshd = ishd + 1; jshd < n_shd_nodes; jshd++)
           {
            // Are the nodes associated
            if (local_adjacency_matrix[iproc][jproc][ishd][jshd] > 0)
             {
              // Get the global nodes id
              
              // Get the "left-node" global id
              const int global_shd_node_left = 
               local_to_global_shared_node[iproc][jproc][ishd];
               
              // Get the "right-node" global id
              const int global_shd_node_right = 
               local_to_global_shared_node[iproc][jproc][jshd];
              
#ifdef PARANOID
              // Check if the local nodes have a global node
              // associated
              if (global_shd_node_left == -1)
               {
                std::ostringstream error_stream;
                error_stream
                 << "The local node in processors iproc and jproc has no\n"
                 << "global node assigned\n"
                 << "iproc processor: (" << iproc << ")\n"
                 << "jproc processor: ("<<jproc<<")\n"
                 << "Local node: (" << ishd << ")\n\n";
                throw OomphLibError(error_stream.str(),
                                    "RefineableTriangleMesh::compute_shared_node_degree_helper()",
                                    OOMPH_EXCEPTION_LOCATION);  
               }
              
              // Check if the local nodes have a global node
              // associated
              if (global_shd_node_right == -1)
               {
                std::ostringstream error_stream;
                error_stream
                 << "The local node in processors iproc and jproc has no\n"
                 << "global node assigned\n"
                 << "iproc processor: (" << iproc << ")\n"
                 << "jproc processor: ("<<jproc<<")\n"
                 << "Local node: (" << jshd << ")\n\n";
                throw OomphLibError(error_stream.str(),
                                    "RefineableTriangleMesh::compute_shared_node_degree_helper()",
                                    OOMPH_EXCEPTION_LOCATION);  
               }
#endif
              // Get the unsigned version of the indexes
              const unsigned uleft = 
               static_cast<unsigned>(global_shd_node_left);
              const unsigned uright = 
               static_cast<unsigned>(global_shd_node_right);
              
              // Add the entry in the global adjacency matrix
              global_adjacency_matrix[uleft][uright]++;
              
              // ... and in the other direction too
              global_adjacency_matrix[uright][uleft]++;
              
              // Add on to the degree of the left node
              global_node_degree[uleft]++;
              
              // Add on to the degree of the right node
              global_node_degree[uright]++;
              
             } // if (local_adjacency_matrix[iproc][jproc][ishd][jshd] > 0)
            
           } // // for (jshd < n_shd_nodes)
          
         } // for (ishd < n_shd_nodes)
        
       } // for (jproc < nproc)
      
     } // for (iproc < nproc)
    
    // Assign the global degree to the shared nodes between each pair
    // of processors
    Vector<Vector<Vector<unsigned> > > root_local_node_degree(nproc);
    // Resize the container
    for (unsigned iproc = 0; iproc < nproc; iproc++)
     {
      root_local_node_degree[iproc].resize(nproc);
     }
    
    // Loop over the processors and visited their shared nodes
    for (unsigned iproc = 0; iproc < nproc; iproc++)
     {
      // Only visit the half of the data
      for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
       {
        // Get the number of shared nodes between this pair of
        // processors (iproc, jproc)
        const unsigned n_shd_nodes = local_node_alias[iproc][jproc].size();
        
        // Resize the container to store the local degree of the nodes
        root_local_node_degree[iproc][jproc].resize(n_shd_nodes);
        // ... and in the other way too
        root_local_node_degree[jproc][iproc].resize(n_shd_nodes);
        
        // Loop over the number of nodes shared between the pair of
        // processors
        for (unsigned ishd = 0; ishd < n_shd_nodes; ishd++)
         {
          // Get the global node id for the current shared node
          const int global_shd_node_id = 
           local_to_global_shared_node[iproc][jproc][ishd];
          
#ifdef PARANOID    
          // Check if the local nodes have a global node associated
          if (global_shd_node_id == -1)
           {
            std::ostringstream error_stream;
            error_stream
             << "The local node in processors iproc and jproc has no\n"
             << "global node assigned\n"
             << "iproc processor: (" << iproc << ")\n"
             << "jproc processor: ("<<jproc<<")\n"
             << "Local node: (" << ishd << ")\n\n";
            throw OomphLibError(error_stream.str(),
                                "RefineableTriangleMesh::compute_shared_node_degree_helper()",
                                OOMPH_EXCEPTION_LOCATION);
           }
#endif
          
          // Get the unsigned version of the global index
          const unsigned uglobal_shd_node_id = 
           static_cast<unsigned>(global_shd_node_id);
          
          // Get the degree of the node
          const unsigned node_degree = 
           global_node_degree[uglobal_shd_node_id];
          
          // Set the degree in the container for the degree of the
          // nodes in the local interaction between processors
          root_local_node_degree[iproc][jproc][ishd] = node_degree;
          // ... and in the other way too
          root_local_node_degree[jproc][iproc][ishd] = node_degree;
          
         } // for (ishd < n_shd_nodes)
        
       } // for (jproc < nproc)
      
     } // for (iproc < nproc)
    
    // Clear the container where the info. will be sent back to each
    // processor
    package_unsigned_data_sent_from_root.clear();
    
    // Prepare the data to sent it back to each processor (encode the
    // info. to sent to all processors)
    for (unsigned iproc = 0; iproc < nproc; iproc++)
     {
      // Count the number of data sent to iproc processor
      unsigned count_n_data_sent_to_iproc = 0;
      for (unsigned jproc = 0; jproc < nproc; jproc++)
       {
        // No shared nodes between the same processor
        if (iproc != jproc)
         {
          // Get the number of nodes shared between the processors
          const unsigned n_shd_nodes = 
           root_local_node_degree[iproc][jproc].size();
          
          // Add the number of data sent to iproc processor
          count_n_data_sent_to_iproc+=n_shd_nodes;
          
          // Loop over the nodes shared between the pair of processors
          for (unsigned ishd = 0; ishd < n_shd_nodes; ishd++)
           {
            package_unsigned_data_sent_from_root.
             push_back(root_local_node_degree[iproc][jproc][ishd]);
           } // for (ishd < n_shd_nodes)
          
         } // if (iproc != jproc)
        
       } // for (jproc < nproc)
      
      // Set the number of data sent to iproc processor
      n_unsigned_data_sent_from_root[iproc] = count_n_data_sent_to_iproc;
      
     } // for (iproc < nproc)
    
   } // if (my_rank == root_processor)
  
  // Total data received from root to this processor
  int n_unsigned_data_received_from_root = 0;
  
  // Get the number of data that each processor receives from root
  MPI_Scatter(&n_unsigned_data_sent_from_root[0], // Info. sent from
                                                  // root to each
                                                  // processor
              1, // The number of data sent from root to each
                 // processor
              MPI_UNSIGNED,
              &n_unsigned_data_received_from_root, // Store the
                                                   // info. received
                                                   // from root
              1, // The number of data received from root
              MPI_UNSIGNED,
              root_processor, // The processor that sends the
                              // info.
              comm_pt->mpi_comm());
  
  // Receive the info. sent by root
  Vector<unsigned> 
   package_unsigned_data_received_from_root(n_unsigned_data_received_from_root);
  
  // Compute the offsets to each processor
  Vector<int> root_unsigned_offsets_sent(nproc,0);
  root_unsigned_offsets_sent[0] = 0;
  for (unsigned iproc = 1; iproc < nproc; iproc++)
   {
    // Compute the offset to send the values to each processor
    root_unsigned_offsets_sent[iproc] = 
     root_unsigned_offsets_sent[iproc-1] + 
     n_unsigned_data_sent_from_root[iproc-1];
   }
  
  if (my_rank!=root_processor)
   {
    // Create at least one entry so we don't get a seg fault below
    if (package_unsigned_data_sent_from_root.size()==0)
     {
      package_unsigned_data_sent_from_root.resize(1);
     }
   } // if (my_rank!=root_processor)  
  
  // Create at least one entry so we don't get a seg fault below
  if (package_unsigned_data_received_from_root.size()==0)
   {
    package_unsigned_data_received_from_root.resize(1);
   }
  
  // Get the data from root
  MPI_Scatterv(&package_unsigned_data_sent_from_root[0], // The
                                                         // info. sent
                                                         // from root
                                                         // to others
                                                         // processors
               &n_unsigned_data_sent_from_root[0], // The number of
                                                   // data sent from
                                                   // root to others
                                                   // processors
               &root_unsigned_offsets_sent[0], // The offsets to each
                                               // processors
               MPI_UNSIGNED,
               &package_unsigned_data_received_from_root[0], // The
                                                             // storage
                                                             // in the
                                                             // processor
                                                             // that
                                                             // receives
                                                             // the
                                                             // info.
               n_unsigned_data_received_from_root, // The number of
                                                   // data that the
                                                   // current
                                                   // processor
                                                   // receives from
                                                   // root
               MPI_UNSIGNED,
               root_processor, // The root processors
               comm_pt->mpi_comm());
  
  // Decode the info.
  
  // Keep track of the already nodes done
  std::map<Node*, bool> node_done;
  
  // Read the global degree assigned to the shared nodes between the
  // current processors and the other processors
  int decode_counter = 0;
  // Store the global degree of the local nodes
  Vector<Vector<unsigned> > local_node_degree(nproc);
  // Loop over the processors
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // There are no shared nodes with the current processor itself
    if (iproc != my_rank)
     {
      // Get the number of nodes shared with the iproc processor
      const unsigned n_nodes = tmp_sorted_shared_node_pt[iproc].size();
      
      // Read the global degree of the node
      package_unsigned_send_data_to_root.push_back(n_nodes);
      
      // Loop over the nodes
      for (unsigned ishd = 0; ishd < n_nodes; ishd++)
       {
        // Get the node degree assigned to the ishd node in between
        // the interaction of the iproc and the current processor
        const unsigned node_degree =
         package_unsigned_data_received_from_root[decode_counter++];
        
        // Get the node
        Node* shd_node_pt = 
         tmp_sorted_shared_node_pt[iproc][ishd];
        
        // Has the node been assigned a global degree
        if (!node_done[shd_node_pt])
         {
          // Assign the global degree to the node
          global_node_degree[shd_node_pt] = node_degree;
          // Mark the node as done
          node_done[shd_node_pt] = true;
         }
#ifdef PARANOID
        else
         {
          // The node has been already done, check that the node
          // degree is the same as the already assigned
          if (global_node_degree[shd_node_pt] != node_degree)
           {
            std::ostringstream error_stream;
            error_stream
             << "The local node has already assigned a global degree,\n"
             << "however, a different degree for the same node has been\n"
             << "read from the data sent from root processor\n"
             << "iproc processor: (" << iproc << ")\n"
             << "Local node: (" << ishd << ")\n"
             << "---------------------------------------------------------\n"
             << "Already assigned degree: (" 
             << global_node_degree[shd_node_pt] << ")\n"
             << "New found degree: (" << node_degree << ")\n"
             << "---------------------------------------------------------\n"
             << "Node coordinates: (" << shd_node_pt->x(0) << ", " 
             << shd_node_pt->x(1) << ")\n\n";
            throw OomphLibError(error_stream.str(),
                                "RefineableTriangleMesh::compute_shared_node_degree_helper()",
                                OOMPH_EXCEPTION_LOCATION);
           }
          
         } // else if (!node_done[shd_node_pt])
#endif // #ifdef PARANOID
        
       } // for (ishd < n_nodes)
      
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc) 
  
#ifdef PARANOID
  // Ensure that all the info. sent from root processor has been read
  if (decode_counter != n_unsigned_data_received_from_root)
     {
      std::ostringstream error_stream;
      error_stream
       << "The number of data decoded received from root processor is\n"
       << "different from the total number of data received from the root\n"
       << "processor\n"
       << "Data decoded: (" << decode_counter << ")\n"
       << "Data received: ("<<n_unsigned_data_received_from_root<<")\n\n"
       << "This is a synchronisation issue so you are probably sending\n"
       << "more or less info. than the one that is being decoded\n\n";
      throw OomphLibError(error_stream.str(),
                          "RefineableTriangleMesh::compute_shared_node_degree_helper()",
                          OOMPH_EXCEPTION_LOCATION);
     }
#endif
  
 }
 
 //======================================================================
 // Sort the nodes on the new shared boundaries (after load balancing),
 // computes the alias of the nodes and creates the adjacency matrix
 // that represent the graph created by the shared edges between each
 // pair of processors
 // ======================================================================
 template <class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 create_adjacency_matrix_new_shared_edges_helper(
  Vector<Vector<FiniteElement*> > &unsorted_face_ele_pt,
  Vector<Vector<Node*> > &tmp_sorted_shared_node_pt,
  std::map<Node*, Vector<Vector<unsigned> > > &node_alias,
  Vector<Vector<Vector<unsigned> > > &adjacency_matrix)
 {
  // Get the number of processors and the rank
  const unsigned nproc = this->communicator_pt()->nproc();
  const unsigned my_rank = this->communicator_pt()->my_rank();
  
  // Assign a unique id to each node shared between each pair of
  // processors, in this case the current processor and the iproc
  
  // ... also compute the alias of each node (processor and index of
  // the node in all processors where it appears)
  
  // Clear the alias info
  node_alias.clear();
  
  // Temporary storage for the index of the nodes
  Vector<std::map<Node*, unsigned> > tmp_node_index(nproc);
  
  // Loop over the processors
  for (unsigned iproc = 0; iproc < nproc; iproc++)
   {
    // There is no shared elements between the same processor
    if (iproc != my_rank)
     {
      // Map to mark those nodes already visited
      std::map<Node*, bool> done_node;
      
      // A map is used to sort the nodes using their coordinates as
      // the key of the map
      //std::map<std::pair<double, double>, Node*> sorted_nodes_pt;
      std::map<std::pair<double, double>, Node*, classcomp> sorted_nodes_pt;
      
      // Get the number of unsorted face elements
      const unsigned n_unsorted_face_ele = 
       unsorted_face_ele_pt[iproc].size();
      
      // Loop over the unsorted elements
      for (unsigned e = 0; e < n_unsorted_face_ele; e++)
       {
        // Get a root element
        FiniteElement* face_ele_pt = unsorted_face_ele_pt[iproc][e];
        // Get the left node of the face element
        Node* left_node_pt = face_ele_pt->node_pt(0);
        
        // Check if the node has been already sorted in the
        // interaction between the current processor and iproc
        // processor
        if (!done_node[left_node_pt])
         {
          std::pair<double, double> vertex = 
           std::make_pair(left_node_pt->x(0), left_node_pt->x(1));
          sorted_nodes_pt[vertex] = left_node_pt;
          // Mark the node as done
          done_node[left_node_pt] = true;
         }
        
        // Get the number of nodes of the face element
        const unsigned n_nodes = face_ele_pt->nnode();
        // Get the right node of the face element
        Node* right_node_pt = face_ele_pt->node_pt(n_nodes-1);
        
        // Check if the node has been already sorted in the
        // interaction between the current processor and iproc
        // processor
        if (!done_node[right_node_pt])
         {
          std::pair<double, double> vertex = 
           std::make_pair(right_node_pt->x(0), right_node_pt->x(1));
          sorted_nodes_pt[vertex] = right_node_pt;
          // Mark the node as done
          done_node[right_node_pt] = true;
         }
        
       } // for (e < nunsorted_face_ele)
      
      // The nodes are already sorted, we need to return them in the
      // proper container
      
      // The counter to enumerate the nodes
      unsigned counter = 0;
      
      // Go through the map container which already have the nodes
      // sorted they have the same sorting on all processors
      for (std::map<std::pair<double, double>, Node*>::iterator it
            = sorted_nodes_pt.begin(); it != sorted_nodes_pt.end(); it++)
       {
        // Get the node
        Node* node_pt = (*it).second;
        // Store the node at the corresponding index
        tmp_sorted_shared_node_pt[iproc].push_back(node_pt);
        
        // Create the temporary access to the node index
        tmp_node_index[iproc][node_pt] = counter;
        
        // Fill the info. for the node alias
        Vector<unsigned> alias(3);
        // The current processor
        alias[0] = my_rank;
        // The processor with which is shared
        alias[1] = iproc;
        // The index with that processor
        alias[2] = counter++;
        
        // Store the info. of the alias
        node_alias[node_pt].push_back(alias);
        
       } // Loop map
      
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc)
  
  // Loop over the processors to resize and initialize the adjacency
  // matrix
  for (unsigned iproc = 0 ; iproc < nproc; iproc++)
   {
    // Get the number of nodes shared with iproc
    const unsigned n_shd_nodes = tmp_sorted_shared_node_pt[iproc].size();
    // Resize the adjacency matrix
    adjacency_matrix[iproc].resize(n_shd_nodes);
    for (unsigned i = 0; i < n_shd_nodes; i++)
     {
      // Resize the adjacency matrix
      adjacency_matrix[iproc][i].resize(n_shd_nodes);
      
      // Initialize the 
      for (unsigned j = 0; j < n_shd_nodes; j++)
       {
        adjacency_matrix[iproc][i][j] = 0;
       } // for (j < n_shd_nodes)
      
     } // for (i < n_shd_nodes)
    
   } // for (iproc < nproc)
  
  // Loop over the processors to fill the adjacency matrix
  for (unsigned iproc = 0 ; iproc < nproc; iproc++)
   {
    // There is no shared elements between the same processor
    if (iproc != my_rank)
     {            
      // Get the number of unsorted face elements
      const unsigned n_unsorted_face_ele = 
       unsorted_face_ele_pt[iproc].size();
      
      // Loop over the unsorted elements
      for (unsigned e = 0; e < n_unsorted_face_ele; e++)
       {
        // Get a root element
        FiniteElement* face_ele_pt = unsorted_face_ele_pt[iproc][e];        
        // Get the left node of the face element
        Node* left_node_pt = face_ele_pt->node_pt(0);
        
        // Get the number of nodes of the face element
        const unsigned n_nodes = face_ele_pt->nnode();
        // Get the right node of the face element
        Node* right_node_pt = face_ele_pt->node_pt(n_nodes-1);
        
        // Get the index of each of the nodes
        const unsigned left_node_index = tmp_node_index[iproc][left_node_pt];
        const unsigned right_node_index = tmp_node_index[iproc][right_node_pt];
        
        // Add an entry to the adjacency matrix to indicate the
        // association of left and right node
        adjacency_matrix[iproc][left_node_index][right_node_index]++;
        // ... both directions
        adjacency_matrix[iproc][right_node_index][left_node_index]++;
        
       } // for (e < n_unsorted_face_ele)
      
     } // if (iproc != my_rank)
    
   } // for (iproc < nproc)
  
 }
 
 //======================================================================
 /// \short Get the nodes on the shared boundary (b), these are stored
 /// in the segment they belong
 //======================================================================
 template <class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 get_shared_boundary_segment_nodes_helper(
  const unsigned &shd_bnd_id, Vector<Vector<Node*> > &tmp_segment_nodes)
 {
  // Clear the data structure were to return the nodes
  tmp_segment_nodes.clear();
  
  // Get the face elements that created the shared boundary from the
  // bulk shared boundary elements
  
#ifdef PARANOID
  // The temporary storage for the halo face elements
  Vector<FiniteElement*> halo_shared_face_ele_pt;
#endif
  // The temporary storage for the nonhalo face elements
  Vector<FiniteElement*> nonhalo_shared_face_ele_pt;
  
  // Get the number of shared boundary elements associated with the
  // current shared boundary
  const unsigned nshared_bound_ele = 
   this->nshared_boundary_element(shd_bnd_id);
  
  // Loop over the elements in the shared boundary to create the face
  // elements
  for (unsigned e = 0; e < nshared_bound_ele; e++)
   {
    // Get the shared boundary element
    FiniteElement* bulk_ele_pt = 
     this->shared_boundary_element_pt(shd_bnd_id, e);
    
    // Get the face index
    int face_index = this->face_index_at_shared_boundary(shd_bnd_id, e);
    
    // Before adding the new element we need to ensure that the edge
    // that this element represents has not been already added
    FiniteElement* face_ele_pt = 
     new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);
    
    // Nonhalo element
    if (!bulk_ele_pt->is_halo())
     {
      // Add nonhalo shared face element to the container
      nonhalo_shared_face_ele_pt.push_back(face_ele_pt);
     }
#ifdef PARANOID
    else // halo element
     {
      // Add halo shared face element to the container
      halo_shared_face_ele_pt.push_back(face_ele_pt);
     }
#endif
    
   } // for (e < nshared_bound_ele)
  
  // Mark the face elements already used
  std::map<FiniteElement*, bool> shared_face_done;
  
  // Get the number of nonhalo face elements
  const unsigned nnonhalo_face_shared_ele = 
   nonhalo_shared_face_ele_pt.size();
  
  // If we are in PARANOID mode check that there is one halo element
  // for each nonhalo element
#ifdef PARANOID
  // Get the number of halo face elements
  const unsigned nhalo_face_shared_ele = 
   halo_shared_face_ele_pt.size();
  
  // The number of nonhalo shared face boundary elements must be the
  // half of the total number of shared boundary elements
  if (nshared_bound_ele / 2 != nnonhalo_face_shared_ele)
   {
    std::ostringstream error_message;
    error_message
     << "The number of shared boundary elements (" << nshared_bound_ele 
     << ") is not the double\nof the number of unsorted nonhalo shared "
     << "face boundary elements (" << nnonhalo_face_shared_ele 
     << ")\n for the current boundary ("<< shd_bnd_id << ")\n\n";
    throw OomphLibError(error_message.str(),
                        "RefineableTriangleMesh::get_shared_boundary_segment_nodes_helper()",
                        OOMPH_EXCEPTION_LOCATION);
   }
  
  // The number of halo shared face boundary elements must be the
  // half of the total number of shared boundary elements
  if (nshared_bound_ele / 2 != nhalo_face_shared_ele)
   {
    std::ostringstream error_message;
    error_message
     << "The number of shared boundary elements (" << nshared_bound_ele 
     << ") is not the double\nof the number of unsorted halo shared "
     << "face boundary elements (" << nhalo_face_shared_ele 
     << ")\n for the current boundary ("<< shd_bnd_id << ")\n\n";
    throw OomphLibError(error_message.str(),
                        "RefineableTriangleMesh::get_shared_boundary_segment_nodes_helper()",
                        OOMPH_EXCEPTION_LOCATION);
   }
  
  // ------------------------------------------------------------------
  // Loop over the nonhalo face elements and look for the halo face
  // element at the other side of the shared boundary
  for (unsigned inh = 0; inh < nnonhalo_face_shared_ele; inh++)
   {
    // Get the inh-th face element
    FiniteElement* nonhalo_face_ele_pt = nonhalo_shared_face_ele_pt[inh];
    
    // Get the number of nodes on the face element
    const unsigned nnodes_nh = nonhalo_face_ele_pt->nnode();
    // Get the first and last node on the element
    Node* nh_first_node_pt = nonhalo_face_ele_pt->node_pt(0);
    Node* nh_last_node_pt = nonhalo_face_ele_pt->node_pt(nnodes_nh-1);
    
    // Now find the (halo) face element at the other side of the
    // shared boundary
    for (unsigned ih = 0; ih < nhalo_face_shared_ele; ih++)
     {
      // Get the ih-th face element
      FiniteElement* halo_face_ele_pt = halo_shared_face_ele_pt[ih];
      
      // Check that the face element has not been done
      if (!shared_face_done[halo_face_ele_pt])
       {
        // Get the number of nodes on the face element
        const unsigned nnodes_h = halo_face_ele_pt->nnode();
        // Get the first and last node on the element
        Node* h_first_node_pt = halo_face_ele_pt->node_pt(0);
        Node* h_last_node_pt = halo_face_ele_pt->node_pt(nnodes_h-1);
        
        // If the nodes are the same then we have found the (halo)
        // face element at the other side of the shared boundary
        if (nh_first_node_pt == h_first_node_pt &&
            nh_last_node_pt == h_last_node_pt)
         {           
          // Mark the face elements as done
          shared_face_done[nonhalo_face_ele_pt] = true;
          shared_face_done[halo_face_ele_pt] = true;
          
          // Break the loop for (ih < nhalo_face_shared_ele)
          break;
         } // if (nh_first_node_pt == h_first_node_pt &&
           //     nh_last_node_pt == h_last_node_pt)
        else if (nh_first_node_pt == h_last_node_pt &&
                 nh_last_node_pt == h_first_node_pt)
         {           
          // Mark the face elements as done
          shared_face_done[nonhalo_face_ele_pt] = true;
          shared_face_done[halo_face_ele_pt] = true;
          
          // Break the loop for (ih < nhalo_face_shared_ele)
          break;
         } // else if (nh_first_node_pt == h_last_node_pt &&
           //          nh_last_node_pt == h_first_node_pt)
        
       } // if (face_done[halo_face_ele_pt])
      
     } // for (ih < nhalo_face_shared_ele)
    
   } // for (inh < nnonhalo_face_shared_ele)
  
  // The number of done shared face elements MUST be the same as the
  // sum of the nonhalo and halo shared boundary face elements
  if ((nnonhalo_face_shared_ele + nhalo_face_shared_ele) != 
      shared_face_done.size())
   {
    std::ostringstream error_message;
    error_message
     << "The number of DONE shared boundary face elements (" 
     << shared_face_done.size() << ") is not the same\n as the sum of"
     << "the nonhalo face shared boundary elements (" 
     << nnonhalo_face_shared_ele << ")\nand the halo face shared "
     << "boundary elements ("<< nhalo_face_shared_ele << ") for the\n/"
     << "current boundary (" << shd_bnd_id << ")\n\n";
    throw OomphLibError(error_message.str(),
                        "RefineableTriangleMesh::get_shared_boundary_segment_nodes_helper()",
                        OOMPH_EXCEPTION_LOCATION);       
   }
#endif // #ifdef PARANOID
  
  // -------------------------------------------------------------
  // Now sort the face elements
  // -------------------------------------------------------------
  
  // We already have the shared face elements that make the shared
  // boundary now sort them to create a contiguous boundary
  
  // Clear the already done face elements
  shared_face_done.clear();
  
  unsigned nsorted_face_ele = 0;
  
  // Storing for the sorting nodes extracted from the face elements
  std::list<Node*> sorted_nodes;
  
  // Get the root face element
  FiniteElement* root_face_ele_pt = nonhalo_shared_face_ele_pt[0];
  nsorted_face_ele++;
  
  // Mark face as done
  shared_face_done[root_face_ele_pt] = true;
  
  // The initial and final node on the list
  const unsigned nnodes_root = root_face_ele_pt->nnode();
  Node *first_node_pt = root_face_ele_pt->node_pt(0);
  Node *last_node_pt = root_face_ele_pt->node_pt(nnodes_root-1);
  
  // Push back on the list the new nodes
  sorted_nodes.push_back(first_node_pt);
  sorted_nodes.push_back(last_node_pt);
  
  // Sort the face elements
  while (nsorted_face_ele < nnonhalo_face_shared_ele)
   {
    // Flag to indicate when a node was added
    bool node_added = false;
    
    // Start from the next edge since we have already added the
    // previous one as the initial face element
    for (unsigned iface = 1; iface < nnonhalo_face_shared_ele; iface++)
     {
      FiniteElement* tmp_shared_face_ele_pt = 
       nonhalo_shared_face_ele_pt[iface];
      
      // If face has not been sorted
      if (!shared_face_done[tmp_shared_face_ele_pt])
       {
        // Get the number of nodes for the current face element
        const unsigned tmp_nnodes = tmp_shared_face_ele_pt->nnode();
        
        // Get each individual node
        Node* left_node_pt = tmp_shared_face_ele_pt->node_pt(0);
        Node* right_node_pt = tmp_shared_face_ele_pt->node_pt(tmp_nnodes-1);
        
        if (left_node_pt == first_node_pt)
         {
          // Push front the new node
          sorted_nodes.push_front(right_node_pt);
          first_node_pt = right_node_pt;
          node_added = true;
         }
        else if (left_node_pt == last_node_pt)
         {
          // Push back the new node
          sorted_nodes.push_back(right_node_pt);
          last_node_pt = right_node_pt;
          node_added = true;
         }
        else if (right_node_pt == first_node_pt)
         {
          // Push front the new node
          sorted_nodes.push_front(left_node_pt);
          first_node_pt = left_node_pt;
          node_added = true;
         }
        else if (right_node_pt == last_node_pt)
         {
          // Push back the new node
          sorted_nodes.push_back(left_node_pt);
          last_node_pt = left_node_pt;
          node_added = true;
         }
        
        if (node_added)
         {
          // Mark as done only if one of its nodes has been added to
          // the list
          shared_face_done[tmp_shared_face_ele_pt] = true;
          nsorted_face_ele++;
          
          // Break the for
          break;
         }
        
       } // if (!shared_face_done[tmp_shared_face_ele_pt])
      
     } // for (iface < nnonhalo_face_shared_ele)
    
   } // while (nsorted_face_ele < nnonhalo_face_shared_ele))
  
  // Here we can safely delete the face elements, they are no longer
  // required
  
  // First the nonhalo face elements
  for (unsigned inh = 0; inh < nnonhalo_face_shared_ele; inh++)
   {
    delete nonhalo_shared_face_ele_pt[inh];
    nonhalo_shared_face_ele_pt[inh] = 0;
   } // for (inh < nnonhalo_face_shared_ele)
  
#ifdef PARANOID
  // ... then the halo face elements
  for (unsigned ih = 0; ih < nhalo_face_shared_ele; ih++)
   {
    delete halo_shared_face_ele_pt[ih];
    halo_shared_face_ele_pt[ih] = 0;
   } // for (inh < nhalo_face_shared_ele)
#endif
  
  // ------------------------------------------------
  // Now copy the nodes to the output container
  // ------------------------------------------------
  // Get the number of nodes in the container
  const unsigned n_nodes = sorted_nodes.size();
  
  // First resize the container
  tmp_segment_nodes.resize(1);
  tmp_segment_nodes[0].resize(n_nodes);
  
  // Counter
  unsigned counter = 0;
  
  // Loop over the list of nodes and copy them in the output container
  for (std::list<Node*>::iterator it = sorted_nodes.begin();
       it != sorted_nodes.end(); it++)
   {
    tmp_segment_nodes[0][counter] = (*it);
    counter++;
   } // Loop over sorted nodes
  
 }

 //=====start of get_required_elemental_information_load_balance_helper====
 /// \short Helper function to get the required elemental information from
 /// the element that will be sent to iproc processor. 
 /// This info. involves the association of the element to a boundary or
 /// region.
 //========================================================================
 template<class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 get_required_elemental_information_load_balance_helper(
  unsigned& iproc,
  Vector<Vector<FiniteElement*> > &f_haloed_ele_pt,
  FiniteElement* ele_pt)
 {  
  // Check if the element is associated with the original boundaries
  const unsigned nbound = this->initial_shared_boundary_id();
  
  // Get the number of processors
  const unsigned nproc = this->communicator_pt()->nproc();
  
  // ------------------------------------------------------------------
  // Stores the information regarding the boundaries associated to the
  // element (it that is the case)
  Vector<unsigned> associated_boundaries;
  Vector<unsigned> face_index_on_boundary;
  
  unsigned counter_face_indexes = 0;
  
  for (unsigned b = 0; b < nbound; b++)
   {
    // Get the number of elements associated to boundary i
    const unsigned nboundary_ele = nboundary_element(b);
    for (unsigned e = 0; e < nboundary_ele; e++)
     {
      if (ele_pt == this->boundary_element_pt(b,e))
       {
        // Keep track of the boundaries associated to the element
        associated_boundaries.push_back(b);
        // Get the face index
        face_index_on_boundary.push_back(face_index_at_boundary(b,e));
        counter_face_indexes++;
#ifdef PARANOID
        if (counter_face_indexes > 2)
         {
          std::stringstream error_message;
          error_message
           << "A triangular element can not have more than two of its faces "
           << "on a boundary!!!\n\n";
          throw OomphLibError(error_message.str(),
                              "RefineableTriangleMesh::get_required_elemental_information_helper()",
                              OOMPH_EXCEPTION_LOCATION);
         }
#else
        // Already found 2 face indexes on the same boundary?
        if (counter_face_indexes==2) {break;}
#endif // #ifdef PARANOID
        
       } // if (ele_pt == this->boundary_element_pt(b,e))
      
     } // (e < nboundary_ele)
    
   }   // (b < nbound)
  
  // If the element is associated to any boundary then package all the
  // relevant info
  const unsigned nassociated_boundaries = associated_boundaries.size();
  if (nassociated_boundaries > 0)
   {
    Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    Flat_packed_unsigneds_string.push_back("The element is a boundary element");
#endif
    Flat_packed_unsigneds.push_back(nassociated_boundaries);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    std::stringstream junk;
    junk << "The elements is associated to " << nassociated_boundaries << " boundaries";
    Flat_packed_unsigneds_string.push_back(junk.str());
#endif
    
    // Package the ids of the associated boundaries and the
    // corresponding face index for each boundary (if the element is a
    // corner element, it will have two faces associated to the
    // boundary)
    for (unsigned i = 0; i < nassociated_boundaries; i++)
     {
      unsigned b = associated_boundaries[i];
      Flat_packed_unsigneds.push_back(b);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk;
      junk << "Element associated to boundary " << b << " of " << nassociated_boundaries << " total associated boundaries";
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif
      unsigned f = face_index_on_boundary[i];
      Flat_packed_unsigneds.push_back(f);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk2;
      junk2 << "Face index " << f << " for associated boundary " << b;
      Flat_packed_unsigneds_string.push_back(junk2.str());
#endif
     }
    
    // If the element is associated to any boundary then we should
    // check if the mesh has regions, if that is the case then we need
    // to check to which region the boundary element does belong
    
    // If the mesh has regions we should look for the element
    // associated to a boundary and a specified region
    Vector<Vector<unsigned> > associated_boundaries_and_regions;
    Vector<unsigned> face_index_on_boundary_and_region;
    
    // Now check for the case when we have regions in the mesh
    const unsigned n_regions = this->nregion();
    if (n_regions >  1)
     {
      // Used to count the number of faces associated with
      // boundary-regions
      unsigned counter_face_indexes_in_regions = 0;
      // Loop over the boundaries
      for (unsigned b = 0; b < nbound; b++)
       {
        // Go through each region by getting the region id
        for (unsigned i_reg = 0 ; i_reg < n_regions; i_reg++)
         {
          // Get thre region id associated with the (i_reg)-th region
          const unsigned region_id = 
           static_cast<unsigned>(this->Region_attribute[i_reg]);
        
          // Loop over all elements associated with the current boundary
          // and the i_reg-th region and check if the element is part of
          // any region
          const unsigned nele_in_region = 
           this->nboundary_element_in_region(b, region_id);
          for (unsigned ee = 0; ee < nele_in_region; ee++)
           {
            // Check if the boundary-region element is the same as the
            // element
            if (ele_pt == 
                this->boundary_element_in_region_pt(b, region_id, ee))
             {
              // Storage for the boundary and region associated to the
              // element
              Vector<unsigned> bound_and_region(2);
            
              // Keep track of the boundaries associated to the element
              bound_and_region[0] = b;
              // Keep track of the regions associated to the element
              bound_and_region[1] = region_id;
              // Add the boundaries and regions in the storage to be
              // sent to other processors
              associated_boundaries_and_regions.push_back(bound_and_region);
              // Get the face index and keep track of it
              face_index_on_boundary_and_region.push_back(
               this->face_index_at_boundary_in_region(b,region_id,ee));
            
              // Increase the number of faces of the element associated
              // to boundary-regions
              counter_face_indexes_in_regions++;
            
#ifdef PARANOID
              if (counter_face_indexes_in_regions > 2)
               {
                std::stringstream error_message;
                error_message
                 << "A triangular element can not have more than two of its\n"
                 << "faces on a boundary!!!\n\n";
                throw OomphLibError(error_message.str(),
                                    "RefineableTriangleMesh::get_required_elemental_information_helper()",
                                    OOMPH_EXCEPTION_LOCATION);
               } // if (counter_face_indexes_in_regions > 2)
#endif
              
             } // The element is a boundary-region element
            
           } // for (ee < nele_in_region)
          
         } // for (i_reg < n_regions)
        
       } // for (b < nbound)
      
     } // if (n_regions >  1)
    
    // Now package the info. to be sent to other processors
    const unsigned nassociated_boundaries_and_regions = 
     associated_boundaries_and_regions.size();
    if (nassociated_boundaries_and_regions > 0)
     {
      Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back("The element is associated to boundaries and regions");
#endif
      
      Flat_packed_unsigneds.push_back(nassociated_boundaries_and_regions);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk;
      junk << "The element is associated to " << nassociated_boundaries_and_regions << " boundaries-regions";
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif
      
      // Package the ids of the associated boundaries, regions and the
      // corresponding face index for each boundary-region (if the
      // element is a corner element, it will have two faces
      // associated to the boundary-region)
      for (unsigned i = 0; i < nassociated_boundaries_and_regions; i++)
       {
        const unsigned b = associated_boundaries_and_regions[i][0];
        Flat_packed_unsigneds.push_back(b);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk;
        junk << "Element associated to boundary " << b << " of " << nassociated_boundaries_and_regions << " total associated boundaries-regions";
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif
        
        const unsigned r = associated_boundaries_and_regions[i][1];
        Flat_packed_unsigneds.push_back(r);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk2;
        junk2 << "Element associated to region " << r << " of " << nassociated_boundaries_and_regions << " total associated boundaries-regions";
        Flat_packed_unsigneds_string.push_back(junk2.str());
#endif
        
        const unsigned f = face_index_on_boundary_and_region[i];
        Flat_packed_unsigneds.push_back(f);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk3;
        junk3 << "Face index " << f << " for associated boundary-region (" << b << "-" << r << ")";
        Flat_packed_unsigneds_string.push_back(junk3.str());
#endif
       } // for (i < nassociated_boundaries_and_regions)
     } // if (nassociated_boundaries_and_regions > 0)
    else
     {
      Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back("The element is NOT associated to boundaries and regions");
#endif
     } // else if (nassociated_boundaries_and_regions > 0)
    
   }
  else
   {
    Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    Flat_packed_unsigneds_string.push_back("The element is not associated to any original boundary");
#endif
   }
  
  // ------------------------------------------------------------
  // Now review if the element is associated to a shared boundary
  
  // Store the shared boundaries, and therefore the face indexes
  // associated to the element
  Vector<unsigned> associated_shared_boundaries;
  Vector<unsigned> face_index_on_shared_boundary;
  
  // Get the shared boundaries in this processor
  Vector<unsigned> my_rank_shared_boundaries_ids;
  this->shared_boundaries_in_this_processor(my_rank_shared_boundaries_ids);
  
  // Get the number of shared boundaries
  const unsigned nmy_rank_shd_bnd = my_rank_shared_boundaries_ids.size();
  // Loop over the shared boundaries
  for (unsigned i = 0; i < nmy_rank_shd_bnd; i++)
   {
    // Get the boundary id
    const unsigned sb = my_rank_shared_boundaries_ids[i];
      
    // Get the number of elements associated to shared boundary sb
    const unsigned nboundary_ele = this->nshared_boundary_element(sb);
    for (unsigned e = 0; e < nboundary_ele; e++)
     {
      if (ele_pt == this->shared_boundary_element_pt(sb,e))
       {
        // Keep track of the boundaries associated to the element
        associated_shared_boundaries.push_back(sb);
        // Get the face index
        face_index_on_shared_boundary.push_back(
         this->face_index_at_shared_boundary(sb, e));
       }
     } // (e < nboundary_ele)
   } // (i < nmy_rank_shd_bnd)
  
  // If the element is associated to a shared boundary then package
  // all the relevant info
  const unsigned nassociated_shared_boundaries = 
   associated_shared_boundaries.size();
  if (nassociated_shared_boundaries > 0)
   {
    Flat_packed_unsigneds.push_back(3);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    Flat_packed_unsigneds_string.push_back("The element is a shared boundary element");
#endif
    Flat_packed_unsigneds.push_back(nassociated_shared_boundaries);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    std::stringstream junk;
    junk << "The elements is associated to " << nassociated_shared_boundaries << "shared boundaries";
    Flat_packed_unsigneds_string.push_back(junk.str());
#endif
      
    // Package the ids of the associated boundaries
    for (unsigned i = 0; i < nassociated_shared_boundaries; i++)
     {
      const unsigned b = associated_shared_boundaries[i];
      Flat_packed_unsigneds.push_back(b);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk;
      junk << "Element associated to shared boundary " << b << " of " << nassociated_shared_boundaries << " total associated boundaries";
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif
        
      const unsigned f = face_index_on_shared_boundary[i];
      Flat_packed_unsigneds.push_back(f);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk2;
      junk2 << "Face index " << f << " for associated shared boundary " << b;
      Flat_packed_unsigneds_string.push_back(junk2.str());
#endif
     }
   }
  else
   {
    Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    Flat_packed_unsigneds_string.push_back("The element is not associated to any shared boundary");
#endif
   }
  
  // Now check if the element is haloed with any processor
  
  // Store the index of the haloed element with the jproc
  Vector<Vector<unsigned> > index_haloed(nproc);
  
  // Loop over the processors
  for (unsigned jproc = 0; jproc < nproc; jproc++)
   {
    // Get the number of haloed elements with jproc
    const unsigned n_haloed_jproc = f_haloed_ele_pt[jproc].size();
    // Loop over the haloed elements with jproc
    for (unsigned ihd =0; ihd < n_haloed_jproc; ihd++)
     {
      // Is a haloed element?
      if (ele_pt == f_haloed_ele_pt[jproc][ihd])
       {
        // Store the haloed index with the jproc processor
        index_haloed[jproc].push_back(ihd);
        // Break the searching with the jproc processor
        break;
       } // if (ele_pt == f_haloed_ele_pt[jproc][ihd])
      
     } // for (ihd < n_haloed_jproc)
    
   } // for (jproc < nproc)
  
  // Send the haloed info.
  // Loop over the processors
  for (unsigned jproc = 0; jproc < nproc; jproc++)
   {
    // Is the element haloed with the jproc processor
    const unsigned n_index_haloed_jproc = index_haloed[jproc].size();
    Flat_packed_unsigneds.push_back(n_index_haloed_jproc);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    Flat_packed_unsigneds_string.push_back("The number of haloed indexes the element is with processor jproc");
#endif
    for (unsigned ihd = 0; ihd < n_index_haloed_jproc; ihd++)
     {
      Flat_packed_unsigneds.push_back(index_haloed[jproc][ihd]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back("The haloed index of the element with jproc");
#endif
     } // for (ihd < n_index_haloed_jproc)
    
   } // for (jproc < nproc)
  
 }

 //======================================================================
 /// \short Helper function to add nodes on a new domain as a result of
 /// load balance
 //======================================================================
 template <class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 add_node_load_balance_helper(unsigned& iproc,
                              Vector<Vector<FiniteElement*> >&f_halo_ele_pt,
                              Vector<Node*> &new_nodes_on_domain,
                              Node* nod_pt)
 {
  // Attempt to add this node to the new domain
  const unsigned nnew_nodes_on_domain= new_nodes_on_domain.size();
  const unsigned new_added_node_index = 
   this->try_to_add_node_pt_load_balance(new_nodes_on_domain, nod_pt);
  
  // If it was added then the new index should match the size of the storage
  if (new_added_node_index == nnew_nodes_on_domain)
   {
    Flat_packed_unsigneds.push_back(1);
    
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    std::stringstream junk;
    junk << "Node needs to be constructed [size=" 
         << Flat_packed_unsigneds.size() << "]; last entry: "
         << Flat_packed_unsigneds[Flat_packed_unsigneds.size()-1];
    Flat_packed_unsigneds_string.push_back(junk.str());
#endif
    
    // This helper function gets all the required information for the 
    // specified node and stores it into MPI-sendable information
    // so that a new copy can be made on the receiving process
    get_required_nodal_information_load_balance_helper(f_halo_ele_pt,
                                                       iproc,
                                                       nod_pt);
   }
  else // It was already added
   {
    Flat_packed_unsigneds.push_back(0); 
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    std::stringstream junk;
    junk << "Node was already added [size=" 
         << Flat_packed_unsigneds.size() << "]; last entry: "
         << Flat_packed_unsigneds[Flat_packed_unsigneds.size()-1];

    Flat_packed_unsigneds_string.push_back(junk.str());
#endif
    
    // This node has been already added, so tell the other process
    // its index in the equivalent storage
    Flat_packed_unsigneds.push_back(new_added_node_index);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    Flat_packed_unsigneds_string.push_back("new added node index");
#endif
   }

 }
 
 //======start of get_required_nodal_information_load_balance_helper=======
 /// Helper function to get the required nodal information from an
 /// haloed node so that a fully-functional halo node (and therefore element)
 /// can be created on the receiving process
 //========================================================================
 template<class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 get_required_nodal_information_load_balance_helper(
  Vector<Vector<FiniteElement*> > &f_halo_ele_pt,
  unsigned& iproc, 
  Node* nod_pt)
 {
  unsigned my_rank = this->communicator_pt()->my_rank();
  const unsigned nproc = this->communicator_pt()->nproc();
  
  // Tell the halo copy of this node how many values there are
  // [NB this may be different for nodes within the same element, e.g.
  //  when using Lagrange multipliers]
  unsigned n_val=nod_pt->nvalue();
  Flat_packed_unsigneds.push_back(n_val);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
  Flat_packed_unsigneds_string.push_back("Number of values");
#endif
  
  unsigned n_dim=nod_pt->ndim();
  
  // Default number of previous values to 1
  unsigned n_prev=1;
  if (this->Time_stepper_pt!=0)
   {
    // Add number of history values to n_prev
    n_prev=this->Time_stepper_pt->ntstorage();
   }
  
  // -----------------------------------------------------
  // Is the node on an original boundary?
  // Store the original boundaries where the node may be
  Vector<unsigned> original_boundaries;
  // Loop over the original boundaries of the mesh and check if live
  // on one of them
  const unsigned n_bnd = this->initial_shared_boundary_id();
  for (unsigned bb=0;bb<n_bnd;bb++)
   {
    // Which boundaries (could be more than one) is it on?
    if (nod_pt->is_on_boundary(bb))
     {
      original_boundaries.push_back(bb);
     }
    
   }
  
  const unsigned n_original_boundaries = original_boundaries.size();
  // Is the node on any original boundary?
  if (n_original_boundaries > 0)
   {
    // Indicate that the node is on an original boundary
    Flat_packed_unsigneds.push_back(2);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    Flat_packed_unsigneds_string.push_back("Node is on the original boundaries");
#endif
    
    Flat_packed_unsigneds.push_back(n_original_boundaries);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    std::stringstream junk;
    junk << "Node is on "<< n_original_boundaries << " original boundaries";
    Flat_packed_unsigneds_string.push_back(junk.str());
#endif
    
    // Loop over the original boundaries the node is on
    for (unsigned i=0;i<n_original_boundaries;i++)
     {
      Flat_packed_unsigneds.push_back(original_boundaries[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk;
      junk<<"Node is on boundary "<<original_boundaries[i]<<" of "<< nb;
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif
      // Get the boundary coordinate of the node
      Vector<double> zeta(1);
      nod_pt->get_coordinates_on_boundary(original_boundaries[i],zeta);
      Flat_packed_doubles.push_back(zeta[0]);
     }
   }
  else
   {
    // Indicate that the node is NOT on an original boundary
    Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    Flat_packed_unsigneds_string.push_back("Node is on any original boundary");
#endif
   }
  
  // -------------------------------------------------------
  // Is the node on shared boundaries?
  bool node_on_shared_boundary = false;
  // Loop over the shared boundaries with the iproc processors and
  // check if live on one of them
  const unsigned n_shd_bnd = this->nshared_boundaries(my_rank, iproc);
  for (unsigned bb=0;bb<n_shd_bnd;bb++)
   {
    // Get the boundary id
    unsigned i_bnd = this->shared_boundaries_ids(my_rank, iproc, bb);
    // Which boundaries (could be more than one) is it on?
    if (this->is_node_on_shared_boundary(i_bnd, nod_pt))
     {
      node_on_shared_boundary = true;
      break;
     }
   }
  
  // If the node live on any of the shared boundaries with the iproc
  // processor then just get the node number according to the
  // sorted_shared_boundary_node_pt() scheme and send it accross
  if (node_on_shared_boundary)
   {
    Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    Flat_packed_unsigneds_string.push_back("Node is on shared boundary");
#endif
    
    // Store the shared boundaries where the node is on
    Vector<unsigned> shd_boundaries;
    // Loop over the shared boundaries with the iproc processor
    for (unsigned bb = 0; bb < n_shd_bnd; bb++)
     {
      // Get the boundary id
      const unsigned i_bnd = 
       this->shared_boundaries_ids(my_rank, iproc, bb);
      // Which boundaries (could be more than one) is it on?
      if (this->is_node_on_shared_boundary(i_bnd, nod_pt))
       {
        shd_boundaries.push_back(i_bnd);
       }
     }
    
    // Get the number of shared boundaries the node is on
    const unsigned n_shd_bnd_is_on = shd_boundaries.size();
    // Send the number of shared boundaries the node is on
    Flat_packed_unsigneds.push_back(n_shd_bnd_is_on);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    std::stringstream junk;
    junk << "Node is on "<< n_shd_bnd_is_on << " shared boundaries";
    Flat_packed_unsigneds_string.push_back(junk.str());
#endif
    
    // Loop over the shared boundaries to send their ids
    for (unsigned i=0;i<n_shd_bnd_is_on;i++)
     {
      Flat_packed_unsigneds.push_back(shd_boundaries[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk;
      junk << "Node is on boundary " << shd_boundaries[i] << " of " << nb;
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif
     }
    
    // Given that the node is on at least one boundary get the index
    // of the node in one of the boundaries and send this index
    unsigned shared_boundary_id = shd_boundaries[0];
    // Get the number of nodes on the given shared boundary
    const unsigned n_nodes_on_shared_boundary = 
     nsorted_shared_boundary_node(shared_boundary_id);
    // Store the index of the node on the shared boundary
    unsigned index_node_on_shared_boundary;
#ifdef PARANOID
    // Flag to know if the node has been found
    bool found_index_node_on_shared_boundary = false;
#endif
    // Loop over the nodes on the shared boundary to find the node
    for (unsigned i = 0; i < n_nodes_on_shared_boundary; i++)
     {
      // Get the i-th node on the shared boundary
      Node* shared_node_pt = 
       sorted_shared_boundary_node_pt(shared_boundary_id, i);
      // Is the node we are looking for
      if (shared_node_pt == nod_pt)
       {
        // Store the index
        index_node_on_shared_boundary = i;
#ifdef PARANOID
        // Mark as found
        found_index_node_on_shared_boundary = true;
#endif
        break; // break
       }
      
     } // for (i < nnodes_on_shared_boundary)
    
#ifdef PARANOID
    if (!found_index_node_on_shared_boundary)
     {
      std::ostringstream error_message;
      error_message
       <<"The index of the node on boundary ("
       <<shared_boundary_id<<") was not found.\n"
       <<"The node coordinates are ("<<nod_pt->x(0)<<","
       <<nod_pt->x(1)<<").\n";
      throw OomphLibError(
       error_message.str(),
       "RefineableTriangleMesh::get_required_nodal_information_helper()",
       OOMPH_EXCEPTION_LOCATION);
     }
#endif 
    // Send the index of the node on the shared boundary
    Flat_packed_unsigneds.push_back(index_node_on_shared_boundary);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    std::stringstream junk2;
    junk2 << "Node index on boundary "<<boundaries[0]<<" is "
          <<index_node_on_shared_boundary;
    Flat_packed_unsigneds_string.push_back(junk2.str());
#endif
    
   } // if (node_on_shared_boundary)
  else
   {
    // The node is not on a shared boundary
    Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    Flat_packed_unsigneds_string.push_back("Node is not on a shared boundary");
#endif
   }
  
  // ----------------------------------------------------------------
  // Is the node on any shared boundary where the receiver processor
  // is not involved? 

  // Now check if the node is on a shared boundary created by the
  // current processor (my_rank) and other processor different that
  // the iproc processor. This info. will help to complete the sending
  // of halo(ed) information between processors
  
  // Flag to know if the node is on a shared boundary with other
  // processor
  bool node_on_shared_boundary_with_other_processors = false;
  // Count the number of other shared boundaries it could be on
  unsigned nshared_boundaries_with_other_processors_have_node = 0;
  
  // Loop over the shared boundaries of the sent processor (my_rank)
  // and other processors (jproc)
  for (unsigned jproc = 0; jproc < nproc; jproc++)
   {
    // Do not search with the iproc processor, that was done before
    // above
    if (jproc != iproc)
     {
      // Get the number of shared boundaries with the jproc processor
      const unsigned n_jshd_bnd = 
       this->nshared_boundaries(my_rank, jproc);
      // Loop over the shared boundaries
      for (unsigned bb=0;bb<n_jshd_bnd;bb++)
       {
        // Get the boundary id
        const unsigned j_shd_bnd = 
         this->shared_boundaries_ids(my_rank, jproc, bb);
        // Is the node part of this boundary?
        if (this->is_node_on_shared_boundary(j_shd_bnd, nod_pt))
         {
//           DEBP("Sending to");
//           DEBP(iproc);
//           DEBP("Pair of procs where other shared");
//           DEBP(my_rank);
//           DEBP(jproc);
//           DEBP(i_bnd);
          node_on_shared_boundary_with_other_processors = true;
          // Increase the counter for the number of shared boundaries
          // with other processors the node is on
          nshared_boundaries_with_other_processors_have_node++;
         } // if (this->is_node_on_shared_boundary(j_shd_bnd, nod_pt)
        
       } // for (bb<n_jshd_bnd)
      
     } // if (jproc != iproc)
    
   } // for (jproc < nproc)
  
  // If the node is on a shared boundary with another processor
  // (my_rank, jproc), then send the flag and look for the info.
  if (node_on_shared_boundary_with_other_processors)
   {
    Flat_packed_unsigneds.push_back(4);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    Flat_packed_unsigneds_string.push_back("Node is on shared boundary no related with the received processor: 4");
#endif
    
    // The number of packages of information that will be sent to the
    // "iproc" processor. This helps to know how many packages of data
    // read from the received processor
    Flat_packed_unsigneds.push_back(nshared_boundaries_with_other_processors_have_node);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    std::stringstream junk;
    junk << "Number of other shared boundaries that the node is on: " 
         << nshared_boundaries_with_other_processors_have_node;
    Flat_packed_unsigneds_string.push_back(junk.str());
#endif
    
    // Counter to ensure that the correct number of data has been sent
    unsigned counter_shd_bnd_with_other_procs_have_node = 0;
    // Loop over the shared boundaries with other processors and get:
    // 1) The processors defining the shared boundary
    // 2) The shared boundary id
    // 3) The index of the node on the shared boundary
    Vector<unsigned> other_processor_1;
    Vector<unsigned> other_processor_2;
    Vector<unsigned> shd_bnd_ids;
    Vector<unsigned> indexes;
    // Loop over the processors again
    for (unsigned jproc = 0; jproc < nproc; jproc++)
     {
      // Do not search with the iproc processor, that was done before
      // above
      if (jproc != iproc)
       {
        // Get the number of shared boundaries with the jproc
        // processor
        const unsigned n_jshd_bnd = 
         this->nshared_boundaries(my_rank, jproc);
        for (unsigned bb = 0; bb < n_jshd_bnd; bb++)
         {
          // Get the boundary id
          const unsigned j_shd_bnd = 
           this->shared_boundaries_ids(my_rank, jproc, bb);
          // Is the node part of this boundary?
          if (this->is_node_on_shared_boundary(j_shd_bnd, nod_pt))
           {
            // Include the first processor
            other_processor_1.push_back(my_rank);
            // Include the second processor
            other_processor_2.push_back(jproc);
            // Include the shared boundary id
            shd_bnd_ids.push_back(j_shd_bnd);
            // Increase the counter for found shared boundaries with
            // other processors
            counter_shd_bnd_with_other_procs_have_node++;
           }
          
         } // for (bb < nshared_bnd)
        
       } // if (jproc != iproc)
      
     } // for (jproc < nproc)
    
    // Get the indexes of the node on all the shared boundaries where
    // it was found
    const unsigned n_other_processors = other_processor_1.size();
    // Loop over the processors where the node was found
    for (unsigned i = 0; i < n_other_processors; i++)
     {
      // Get the shared boundary id
      unsigned shd_bnd_id = shd_bnd_ids[i];
      // Get the number of nodes on that shared boundary
      const unsigned n_nodes_on_shd_bnd = 
       nsorted_shared_boundary_node(shd_bnd_id);
      
#ifdef PARANOID
      bool found_index_node_on_shared_boundary = false;
#endif
      for (unsigned i = 0; i < n_nodes_on_shd_bnd; i++)
       {
        // Get the i-th shared boundary node
        Node* shared_node_pt = 
         sorted_shared_boundary_node_pt(shd_bnd_id, i);
        // Is the same node?
        if (shared_node_pt == nod_pt)
         {
//             DEBP(i_node);
//             DEBP(nod_pt->x(0));
//             DEBP(nod_pt->x(1));
          // Include the index of the node
          indexes.push_back(i);
#ifdef PARANOID
          // Mark as found the node
          found_index_node_on_shared_boundary = true;
#endif
          break;  
         } // if (shared_node_pt == nod_pt)
        
       } // for (i < n_nodes_on_shd_bnd)
      
#ifdef PARANOID
      if (!found_index_node_on_shared_boundary)
       {
        std::ostringstream error_message;
        error_message
         <<"The index of the node on boundary ("
         <<shd_bnd_id<<"), shared by other processors\nwas not found.\n"
         <<"The node coordinates are ("<<nod_pt->x(0)<<","
         <<nod_pt->x(1)<<").\n";
        throw OomphLibError(
         error_message.str(),
         "RefineableTriangleMesh::get_required_nodal_information_helper()",
         OOMPH_EXCEPTION_LOCATION);
       }
#endif
     } // for (i < n_other_processors)
    
    // Now send the info. but first check that the number of found
    // nodes be the same that the previously found shared boundaries
    // with the node
#ifdef PARANOID
    if (counter_shd_bnd_with_other_procs_have_node !=
        nshared_boundaries_with_other_processors_have_node)
     {
      std::ostringstream error_message;
      error_message
       <<"The number of shared boundaries where the node is on "
       <<"is different:\n"
       << "nshared_boundaries_with_other_processors_have_node: ("
       << nshared_boundaries_with_other_processors_have_node
       << ")\n"
       << "counter_shd_bnd_with_other_procs_have_node: ("
       << counter_shd_bnd_with_other_procs_have_node
       << ")\n";
      throw OomphLibError(
       error_message.str(),
       "RefineableTriangleMesh::get_required_nodal_information_helper()",
       OOMPH_EXCEPTION_LOCATION);
     } // if (counter_shd_bnd_with_other_procs_have_node !=
       // nshared_boundaries_with_other_processors_have_node)
#endif
    
    // Loop over the info. to send it
    for (unsigned i = 0; i < n_other_processors; i++)
     {
      Flat_packed_unsigneds.push_back(other_processor_1[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk1;
      junk1 << "Processor where the other shared boundary "
            << "has the node: " << other_processor_1[i];
      Flat_packed_unsigneds_string.push_back(junk1.str());
#endif
        
      Flat_packed_unsigneds.push_back(other_processor_2[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk2;
      junk2 << "Processor where the other shared boundary "
            << "has the node: " << other_processor_2[i];
      Flat_packed_unsigneds_string.push_back(junk2.str());
#endif
        
      Flat_packed_unsigneds.push_back(shd_bnd_ids[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk3;
      junk3 << "Other shared boundary id where the node is on" 
            << boundaries[i];
      Flat_packed_unsigneds_string.push_back(junk3.str());
#endif
        
      Flat_packed_unsigneds.push_back(indexes[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk4;
      junk4 << "Node index on other shared boundary " 
            <<boundaries[i] << " is "
            << indexes[i];
      Flat_packed_unsigneds_string.push_back(junk4.str());
#endif
        
     } // for (i < n_other_processors)
    
   } // if (node_on_shared_boundary_with_other_processors)
  else
   {
    Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    Flat_packed_unsigneds_string.push_back("Node is on any shared boundary with other processors");
#endif
   } // else if (node_on_shared_boundary_with_other_processors)
  
  // It may still be possible that the node be shared with the
  // processor that receives the info. but it is neither on shared
  // boundary with the receiver processor nor on a shared boundary
  // with others processors. Think in the next case:
  
  // |-----|-----|   - The elements in processor 3 need to be sent to
  // |  4  |  3  |     processor 1, and that is all
  // |-----*-----|   - When processor 1 receives the data from node (*)
  // |  1  |  2  |     it just RE-CREATES it becasuse it is does not know
  // |-----|-----|     that the node is also on the shared boundary that
  //                   processor 1 and 2 or processor 1 and 4 share.
  
  // This problem become even worse if there would be more processors
  // between processor 3 and 2, or/and processor 3 and 4. Think in
  // triangles sharing the node (*)
  
  // To solve this check if the node that we are trying to send is
  // part of the halo elements of the curreent processor (my_rank)
  // with any other processor (we need to check with all the
  // processors and not just with the processors to which we will send
  // to cover more cases)
  
  // Store the halo element number with jproc where the node was found
  Vector<Vector<unsigned> > halo_element_number(nproc);
  // Store the node number on the halo element where the node was found
  Vector<Vector<unsigned> > halo_node_number_in_halo_element(nproc);
  
  // Loop over the processor
  for (unsigned jproc = 0; jproc < nproc; jproc++)
   {
    // Get the number of halo elements with the jproc processor
    const unsigned n_halo_jproc = f_halo_ele_pt[jproc].size();
     // Loop over the halo elements
     for (unsigned jh = 0; jh < n_halo_jproc; jh++)
      {
       FiniteElement* halo_ele_pt = f_halo_ele_pt[jproc][jh];
       // Get the number of nodes of the halo element
       const unsigned n_node = halo_ele_pt->nnode();
       // Loop over the nodes
       for (unsigned n = 0; n < n_node; n++)
        {
         // Is the node part of the ih-th halo element with jproc
         if (nod_pt == halo_ele_pt->node_pt(n))
          {
           halo_element_number[jproc].push_back(jh);
           halo_node_number_in_halo_element[jproc].push_back(n);
           // break with the nodes, no need to look for more nodes in
           // the element
           break;
          } // if (nod_pt == halo_ele_pt->node_pt(n))
         
        } // for (n < n_node)
       
      } // for (jh < n_halo_jproc)
    
   } // for (jproc < nproc)
  
  // Send the info. related with if the node is on halo elements with
  // any processor
  
  // Loop over the processors
  for (unsigned jproc = 0; jproc < nproc; jproc++)
   {
    // Get the number of halo elements with jproc processor where the
    // node is
    const unsigned n_jproc_halo_ele_node_is_on = 
     halo_element_number[jproc].size();
    // Send the number of halo elements with jproc where the node is
    Flat_packed_unsigneds.push_back(n_jproc_halo_ele_node_is_on);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    std::stringstream junk5;
    junk5 << "Node is on " << n_jproc_halo_ele_node_is_on << " halo "
          << "elements with " << jproc << "-th processor";
    Flat_packed_unsigneds_string.push_back(junk5.str());
#endif
    // Send the halo elements indexes (which will be haloed elements
    // indexes in the receiver processor), and the indexes of the
    // nodes in each halo element
    for (unsigned i = 0; i < n_jproc_halo_ele_node_is_on; i++)
     {
      // The halo element index
      const unsigned halo_element_index = halo_element_number[jproc][i];
      Flat_packed_unsigneds.push_back(halo_element_index);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk6;
      junk6 << "Halo element index is ("<<halo_element_index
            <<") with processor ("<<jproc<<")";
      Flat_packed_unsigneds_string.push_back(junk6.str());
#endif
      // The node index on the halo element
      const unsigned node_index = halo_node_number_in_halo_element[jproc][i];
      Flat_packed_unsigneds.push_back(node_index);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk7;
      junk7 << "The node index on the halo element index is (" 
            << node_index;
      Flat_packed_unsigneds_string.push_back(junk7.str());
#endif
      
     } // for (i < n_jproc_halo_ele_node_is_on)
    
   } // for (jproc < nproc)
  
  // Now check if it is required to send the info. of the node. If the
  // node is not on a shared boundary with the iproc processor then we
  // need to send the info.
  
  // Flag to indicate if it is on a halo element with the iproc
  // processor. If this flag is true then there is no need to send the
  // info. to create the node, in the receiver processor the info is
  // copied from the indicated haloed element-node
  bool on_halo_element_with_iproc_processor = false;
  if (halo_element_number[iproc].size() > 0)
   {
    on_halo_element_with_iproc_processor = true;
   } // if (halo_element_number[iproc].size() > 0)
  
  // if (!node_on_shared_boundary)
  if (!node_on_shared_boundary && !on_halo_element_with_iproc_processor)
   {
    // Send all the info. to create it
    
    // Is the Node algebraic?  If so, send its ref values and
    // an indication of its geometric objects if they are stored
    // in the algebraic mesh
    AlgebraicNode* alg_nod_pt=dynamic_cast<AlgebraicNode*>(nod_pt);
    if (alg_nod_pt!=0)
     {
      // The external mesh should be algebraic
      AlgebraicMesh* alg_mesh_pt=dynamic_cast<AlgebraicMesh*>(this);

      // Get default node update function ID
      unsigned update_id=alg_nod_pt->node_update_fct_id();
      Flat_packed_unsigneds.push_back(update_id);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back("Alg Node update id");
#endif

      // Get reference values at default...
      unsigned n_ref_val=alg_nod_pt->nref_value();
      Flat_packed_unsigneds.push_back(n_ref_val);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back("Alg Node n ref values");
#endif
      for (unsigned i_ref_val=0;i_ref_val<n_ref_val;i_ref_val++)
       {
        Flat_packed_doubles.push_back(alg_nod_pt->ref_value(i_ref_val));
       }

      // Access geometric objects at default...
      unsigned n_geom_obj=alg_nod_pt->ngeom_object();
      Flat_packed_unsigneds.push_back(n_geom_obj);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back("Alg Node n geom objects");
#endif
      for (unsigned i_geom=0;i_geom<n_geom_obj;i_geom++)
       {
        GeomObject* geom_obj_pt=alg_nod_pt->geom_object_pt(i_geom);

        // Check this against the stored geometric objects in mesh
        unsigned n_geom_list=alg_mesh_pt->ngeom_object_list_pt();

        // Default found index to zero
        unsigned found_geom_object=0;
        for (unsigned i_list=0;i_list<n_geom_list;i_list++)
         {
          if (geom_obj_pt==alg_mesh_pt->geom_object_list_pt(i_list))
           {
            found_geom_object=i_list;
           }
         }
        Flat_packed_unsigneds.push_back(found_geom_object);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        Flat_packed_unsigneds_string.push_back("Found geom object");
#endif
       }
     } // (if alg_nod_pt!=0)

    // Is it a SolidNode?
    SolidNode* solid_nod_pt=dynamic_cast<SolidNode*>(nod_pt);
    if (solid_nod_pt!=0)
     {
      unsigned n_solid_val=solid_nod_pt->variable_position_pt()->nvalue();
      for (unsigned i_val=0;i_val<n_solid_val;i_val++)
       {
        for (unsigned t=0;t<n_prev;t++)
         {
          Flat_packed_doubles.push_back(solid_nod_pt->variable_position_pt()->
                                        value(t,i_val));
         }
       }
      
      Vector<double> values_solid_node;
      solid_nod_pt->add_values_to_vector(values_solid_node);
      const unsigned nvalues_solid_node = values_solid_node.size();
      Flat_packed_unsigneds.push_back(nvalues_solid_node);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk;
      junk << "Number of values solid node: "
           << nvalues_solid_node;
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif
      for (unsigned i = 0; i < nvalues_solid_node; i++)
       {
        Flat_packed_doubles.push_back(values_solid_node[i]);
       }
     }
    
    // Finally copy info required for all node types
    for (unsigned i_val=0;i_val<n_val;i_val++)
     {
      for (unsigned t=0;t<n_prev;t++)
       {
        Flat_packed_doubles.push_back(nod_pt->value(t,i_val));
       }
     }

    // Now do positions
    for (unsigned idim=0;idim<n_dim;idim++)
     {
      for (unsigned t=0;t<n_prev;t++)
       {
        Flat_packed_doubles.push_back(nod_pt->x(t,idim));
//         DEBP(nod_pt->x(t,idim));
       }
     }
    
   } // if (!node_on_shared_boundary && !on_halo_element_with_iproc_processor)
  
 }

 //======================================================================
 /// \short Helper function to create elements on the loop 
 /// process based on the info received in 
 /// send_and_received_elements_nodes_info
 //======================================================================
 template <class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::create_element_load_balance_helper(
  unsigned& iproc, 
  Vector<Vector<FiniteElement*> > &f_haloed_ele_pt,
  Vector<Vector<std::map<unsigned,FiniteElement*> > > 
  &received_old_haloed_element_pt,
  Vector<FiniteElement*> &new_elements_on_domain,
  Vector<Node*> &new_nodes_on_domain,
  Vector<Vector<Vector<std::map<unsigned, Node*> > > > 
  &other_proc_shd_bnd_node_pt,
  Vector<Vector<Vector<unsigned> > > &global_node_names,
  std::map<Vector<unsigned>, unsigned> &node_name_to_global_index,
  Vector<Node*> &global_shared_node_pt)
 {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
  oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
             << " Bool: New element needs to be constructed " 
             << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
             << std::endl;
#endif
  
  if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++]==1)
   {
    // Create a new element from the communicated values
    // and coords from the process that located zeta
    GeneralisedElement *new_el_pt= new ELEMENT;
    
    // Add the new element to the mesh - Do not add the element yet
    // since no retained elements still need to be deleted
    // this->add_element_pt(new_el_pt);
    
    // Cast to the FE pointer
    FiniteElement* f_el_pt=dynamic_cast<FiniteElement*>(new_el_pt);
    
    // Add the element to the new elements in the domain container
    new_elements_on_domain.push_back(f_el_pt);
    
    // Set any additional information for the element
    this->add_element_load_balance_helper(iproc,
                                          received_old_haloed_element_pt,
                                          f_el_pt);
    
    // Add nodes to the new element
    unsigned n_node=f_el_pt->nnode();
    for (unsigned j=0;j<n_node;j++)
     {
      Node* new_nod_pt=0;
      
      // Call the add halo node helper function
      add_received_node_load_balance_helper(new_nod_pt, 
                                            f_haloed_ele_pt,
                                            received_old_haloed_element_pt,
                                            new_nodes_on_domain,
                                            other_proc_shd_bnd_node_pt,
                                            iproc, j, f_el_pt,
                                            global_node_names,
                                            node_name_to_global_index,
                                            global_shared_node_pt);
     }
   }
  else // the element already exists
   {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info 
     << "Rec:" << Counter_for_flat_packed_unsigneds 
     << "  Index of existing element "
     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
     << std::endl;
#endif
    
    // Incrase the index, we do anything else with the element
    Counter_for_flat_packed_unsigneds++;
    
   } // else the element already exists
  
 }
 
 //========start of add_element_load_balance_helper=====================
 /// \short Helper function to create elements on the loop 
 /// process based on the info received in 
 /// send_and_received_elements_nodes_info
 /// This function is in charge of verify if the element is associated
 /// to a boundary and associate to it if that is the case
 //======================================================================
 template<class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 add_element_load_balance_helper(const unsigned &iproc,
                                 Vector<Vector<std::map<
                                 unsigned,FiniteElement*> > > 
                                 &received_old_haloed_element_pt,
                                 FiniteElement* ele_pt)
 {
  // Get the number of processors
  const unsigned nproc = this->communicator_pt()->nproc();
  
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
  oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
             << " Bool: Element is associated to a boundary " 
             << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
             << std::endl;
#endif
  
  // Is on an original boundary?
  const unsigned is_on_original_boundary = 
   Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
  if (is_on_original_boundary == 1)
   {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info 
     << "Rec:" << Counter_for_flat_packed_unsigneds 
     << "  How many boundaries are associated with the element "
     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
     << std::endl;
#endif
    // Number of boundaries the element is associated with
    const unsigned nassociated_boundaries = 
     Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    
    // Loop over the associated boundaries
    for (unsigned b = 0; b < nassociated_boundaries; b++)
     {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info 
       << "Rec:" << Counter_for_flat_packed_unsigneds 
       << "  Boundary associated to the element "
       << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
       << std::endl;
#endif
      
      // The boundary id
      const unsigned bnd = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info 
       << "Rec:" << Counter_for_flat_packed_unsigneds 
       << "  Face index of the element "
       << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
       << std::endl;
#endif
      
      // The face index
      const unsigned face_index = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
      // Associate the element with the boundary and establish as many
      // face indexes it has
      this->Boundary_element_pt[bnd].push_back(ele_pt);
      this->Face_index_at_boundary[bnd].push_back(face_index);
      
     } // (b < nassociated_boundaries)
    
    // Here read the info. regarding the boundary-region of the element
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
               << " Bool: Element is associated to a boundary-region " 
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    
    // Is the element associated to a boundary-region?
    if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++]==1)
     {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info 
       << "Rec:" << Counter_for_flat_packed_unsigneds 
       << "  How many boundaries-regions are associated with the element "
       << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
       << std::endl;
#endif
      // Number of boundary-regions the element is associated
      const unsigned nassociated_boundaries_and_regions = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
      for (unsigned br = 0; br < nassociated_boundaries_and_regions; br++)
       {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info 
         << "Rec:" << Counter_for_flat_packed_unsigneds 
         << "  Boundary associated to the element "
         << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
         << std::endl;
#endif
        // The boundary id
        const unsigned bnd = 
         Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info 
         << "Rec:" << Counter_for_flat_packed_unsigneds 
         << "  Region associated to the element "
         << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
         << std::endl;
#endif
        // The region id
        const unsigned region = 
         Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info 
         << "Rec:" << Counter_for_flat_packed_unsigneds 
         << "  Face index of the element in boundary-region "
         << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
         << std::endl;
#endif
        const unsigned face_index = 
         Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        
        // Associate the element with the boundary-regions and establish
        // as many face indexes it has
        this->Boundary_region_element_pt[bnd][region].push_back(ele_pt);
        this->Face_index_region_at_boundary[bnd][region].push_back(face_index);
        
       } // for (br < nassociated_boundaries_and_regions)
      
     } // Is the element associated with a boundary-region?
    
   } // The element is associated with an original boundary
#ifdef PARANOID
  else
   {
    if (is_on_original_boundary != 0)
     {
      std::ostringstream error_message;
      error_message
       <<"The current element is not on an original boundary, this should\n"
       <<"be indicated by a zero flag. However, the read value for\n"
       <<"that flag is ("<<is_on_original_boundary<<").\n\n";
      throw OomphLibError(
       error_message.str(),
       "RefineableTriangleMesh::add_element_load_balance_helper()",
       OOMPH_EXCEPTION_LOCATION);
     } // if (is_on_shared_boundary != 0)
   }
#endif
  
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
  oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
             << " Bool: Element is associated to a shared boundary " 
             << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
             << std::endl;
#endif
  
  // Is the element a shared boundary element?
  const unsigned is_on_shared_boundary = 
   Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
  if (is_on_shared_boundary == 3)
   {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info 
     << "Rec:" << Counter_for_flat_packed_unsigneds 
     << "  How many shared boundaries are associated with the element "
     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
     << std::endl;
#endif
    
    // The number of shared boundaries the element is associated
    const unsigned nassociated_shared_boundaries = 
     Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    
    // Loop over the associated shared boundaries
    for (unsigned b = 0; b < nassociated_shared_boundaries; b++)
     {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info 
       << "Rec:" << Counter_for_flat_packed_unsigneds 
       << "  Shared boundary associated to the element "
       << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
       << std::endl;
#endif
      const unsigned bnd = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info 
       << "Rec:" << Counter_for_flat_packed_unsigneds 
       << "  Face index of the element associated to the shared boundary "
       << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
       << std::endl;
#endif
      
      const unsigned face_index = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
      this->add_shared_boundary_element(bnd, ele_pt);
      this->add_face_index_at_shared_boundary(bnd, face_index);
      
     } // (b < nassociated_shared_boundaries)
    
   } // The element is associted with a shared boundary
#ifdef PARANOID
  else
   {
    if (is_on_shared_boundary != 0)
     {
      std::ostringstream error_message;
      error_message
       <<"The current element is not on a shared boundary, this should\n"
       <<"be indicated by a zero flag. However, the read value for\n"
       <<"that flag is ("<<is_on_shared_boundary<<").\n\n";
      throw OomphLibError(
       error_message.str(),
       "RefineableTriangleMesh::add_element_load_balance_helper()",
       OOMPH_EXCEPTION_LOCATION);
     } // if (is_on_shared_boundary != 0)
   }
#endif
  
  // Now check if the element is a haloed element in the sender
  // processor with any other processor
  
  // Loop over the processors
  for (unsigned jproc = 0; jproc < nproc; jproc++)
   {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
               << " Bool: Number of haloed indexes of the element with the "
               << jproc << " processor: "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    // Is the element haloed with the jproc processor
    const unsigned n_index_haloed_jproc = 
     Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    // Loop over the number of haloed indexes
    for (unsigned ihd = 0; ihd < n_index_haloed_jproc; ihd++)
     {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << " Bool: The haloed element index with the " 
                 << jproc << " processor: "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      const unsigned haloed_index = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
      // Set the halod element in the proper storage  
      received_old_haloed_element_pt[iproc][jproc][haloed_index] = ele_pt;
      
     } // for (ihd < n_index_haloed_jproc)
    
   } // for (jproc < nproc)

 }
 
 //======================================================================
 /// \short Helper function to add a new node from load balance
 //======================================================================
 template <class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 add_received_node_load_balance_helper(Node* &new_nod_pt,
                                       Vector<Vector<FiniteElement*> > 
                                       &f_haloed_ele_pt,
                                       Vector<Vector<std::map<
                                       unsigned,FiniteElement*> > > 
                                       &received_old_haloed_element_pt,
                                       Vector<Node*> &new_nodes_on_domain,
                                       Vector<Vector<Vector<
                                       std::map<unsigned, Node*> > > >
                                       &other_proc_shd_bnd_node_pt,
                                       unsigned& iproc,
                                       unsigned& node_index,
                                       FiniteElement* const &new_el_pt,
                                       Vector<Vector<Vector<unsigned> > >
                                       &global_node_names,
                                       std::map<Vector<unsigned>, unsigned>
                                       &node_name_to_global_index,
                                       Vector<Node*> &global_shared_node_pt)
 {
  // Given the node, received information about it from processor
  // iproc, construct it on the current process
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
  oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
             << " Bool: New node needs to be constructed " 
             << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
             << std::endl;
#endif
  if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++]==1)
   {
    // Construct a new node based upon sent information, or copy a node
    // from one of the shared boundaries
    construct_new_node_load_balance_helper(new_nod_pt,
                                           f_haloed_ele_pt,
                                           received_old_haloed_element_pt,
                                           new_nodes_on_domain,
                                           other_proc_shd_bnd_node_pt,
                                           iproc,
                                           node_index,
                                           new_el_pt,
                                           global_node_names,
                                           node_name_to_global_index,
                                           global_shared_node_pt);
   }
  else
   {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
               << "  Index of existing halo node " 
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    // The node already exist, copy it from the indicated position
    
    // Get the node's index, and copy it
    new_nod_pt = new_nodes_on_domain[
      Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++]];
    
    // Set the node in the current element
    new_el_pt->node_pt(node_index) = new_nod_pt;
    
   }
  
 }
 
 //============start_of_construct_new_node_load_balance_helper()=========
 /// \short Helper function which constructs a new node (on an
 /// element) with the information sent from the load balance
 /// process
 //======================================================================
 template<class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 construct_new_node_load_balance_helper(
  Node* &new_nod_pt, 
  Vector<Vector<FiniteElement*> > &f_haloed_ele_pt,
  Vector<Vector<std::map<unsigned,FiniteElement*> > > 
  &received_old_haloed_element_pt,
  Vector<Node*> &new_nodes_on_domain,
  Vector<Vector<Vector<std::map<unsigned, Node*> > > > 
  &other_proc_shd_bnd_node_pt,
  unsigned& iproc, unsigned& node_index,
  FiniteElement* const &new_el_pt,
  Vector<Vector<Vector<unsigned> > > &global_node_names,
  std::map<Vector<unsigned>, unsigned> &node_name_to_global_index,
  Vector<Node*> &global_shared_node_pt)
 {
  // Get the number of processors
  const unsigned nproc = this->communicator_pt()->nproc();
  // Get the rank of the current processor
  const unsigned my_rank = this->communicator_pt()->my_rank();

  //The first entry indicates the number of values at this new Node
  //(which may be different across the same element e.g. Lagrange multipliers)
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
  oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
             << "  Number of values of external halo node " 
             << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
             << std::endl;
#endif
  unsigned n_val=Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
  
  // Null TimeStepper for now
  TimeStepper* time_stepper_pt=this->Time_stepper_pt;
  // Default number of previous values to 1
  unsigned n_prev=time_stepper_pt->ntstorage();
  
  // ------------------------------------------------------
  // Check if the node is on an original boundary
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
  oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
             << "  Is the node on an original boundary " 
             << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
             << std::endl;
#endif
  
  // Flag to indicate if the node is on original boundaries
  const unsigned node_on_original_boundaries = 
   Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
  
  // Store the original boundaries where the node is on
  Vector<unsigned> original_boundaries_node_is_on;
  // Store the zeta coordinates of the node on the original boundaries
  Vector<double> zeta_coordinates;
  // Store the number of original boundaries the node is on
  unsigned n_original_boundaries_node_is_on = 0;
  
  if (node_on_original_boundaries==2)
   {
    // How many original boundaries does the node live on?
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
               << " Number of boundaries the node is on: " 
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    n_original_boundaries_node_is_on = 
     Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    
    // Resize the containers
    original_boundaries_node_is_on.resize(n_original_boundaries_node_is_on);
    zeta_coordinates.resize(n_original_boundaries_node_is_on);
    
    for (unsigned i=0;i<n_original_boundaries_node_is_on;i++)
     {
      // Boundary number
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Node is on boundary " 
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      original_boundaries_node_is_on[i] =
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      zeta_coordinates[i] = 
       Flat_packed_doubles[Counter_for_flat_packed_doubles++];
     }
    
   } // if (node_on_original_boundaries==2)
#ifdef PARANOID
  else
   {
    if (node_on_original_boundaries != 0)
     {
      std::ostringstream error_message;
      error_message
       <<"The current node is not on an original boundary, this should\n"
       <<"be indicated by a zero flag. However, the read value for\n"
       <<"that flag is ("<<node_on_original_boundaries<<").\n\n";
      throw OomphLibError(
       error_message.str(),
       "RefineableTriangleMesh::construct_new_halo_node_helper()",
       OOMPH_EXCEPTION_LOCATION);
     } // if (node_on_original_boundaries != 0)
   }
#endif
  
  // --------------------------------------------------------------
  // Check if the node was on a shared boundary with the iproc
  // processor
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
  oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
             << "  Is node on shared boundary? "
             << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
             << std::endl;
#endif
  const unsigned is_node_on_shared_boundary = 
   Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
  if (is_node_on_shared_boundary == 1)
   {
    // How many shared boundaries does the node live on?
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
               << " Number of boundaries the node is on: " 
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    const unsigned n_shd_bnd_node_is_on = 
     Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    Vector<unsigned> shd_bnds_node_is_on(n_shd_bnd_node_is_on);
    for (unsigned i=0;i<n_shd_bnd_node_is_on;i++)
     {
      // Shared boundary number
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Node is on boundary " 
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      shd_bnds_node_is_on[i] =
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
     }
    
    // Get the index of the node on the shared boundary
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
               << "  Index of node on boundary " 
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    // Get the node index of the node on the shared boundary
    unsigned node_index_on_shared_boundary =
     Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    
    // Get the pointer to the node with the received info.
    new_nod_pt = 
     this->sorted_shared_boundary_node_pt(shd_bnds_node_is_on[0],
                                          node_index_on_shared_boundary);
    
   } // if (is_node_on_shared_boundary == 1)
#ifdef PARANOID
  else
   {
    if (is_node_on_shared_boundary != 0)
     {
      std::ostringstream error_message;
      error_message
       <<"The current node is not on a shared boundary, this should\n"
       <<"be indicated by a zero flag. However, the read value for\n"
       <<"that flag is ("<<is_node_on_shared_boundary<<").\n\n";
      throw OomphLibError(
       error_message.str(),
       "RefineableTriangleMesh::construct_new_halo_node_helper()",
       OOMPH_EXCEPTION_LOCATION);
     } // if (node_on_shared_boundary != 0)
   }
#endif
  
  // ------------------------------------------------------------
  // Is the node on a shared boundary with other processor?
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
  oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
             << "  Is the node on shared boundaries with other processors "
             << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
             << std::endl;
#endif
  
  // Is the node in shared boundaries no associated with the
  // receiver processor
  const unsigned is_the_node_in_shared_boundaries_with_other_processors = 
   Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
  
  // The containers where to store the info.
  Vector<unsigned> other_processor_1;
  Vector<unsigned> other_processor_2;
  Vector<unsigned> other_shared_boundaries;
  Vector<unsigned> other_indexes;
  
  // How many shared bounaries with other processors the node lives on
  unsigned n_shd_bnd_with_other_procs_have_node = 0;
  
  // Is the node on shared boundaries with other processors
  if (is_the_node_in_shared_boundaries_with_other_processors == 4)
   {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
               << "  In how many shared boundaries with other "
               << "processors is the node "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    
    // How many nodes on other shared boundaries were found
    n_shd_bnd_with_other_procs_have_node = 
     Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    
    // Resize the containers
    other_processor_1.resize(n_shd_bnd_with_other_procs_have_node);
    other_processor_2.resize(n_shd_bnd_with_other_procs_have_node);
    other_shared_boundaries.resize(n_shd_bnd_with_other_procs_have_node);
    other_indexes.resize(n_shd_bnd_with_other_procs_have_node);
    
    for (unsigned i = 0; i < n_shd_bnd_with_other_procs_have_node; i++)
     {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Processor where the other shared boundary"
                 << "has the node"
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      // Read the other processor 1
      other_processor_1[i] = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Processor where the other shared boundary"
                 << "has the node"
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      // Read the other processor 2
      other_processor_2[i] = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Other shared boundary id where the node is on: "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      
      // Read the other shared boundary id
      other_shared_boundaries[i] = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Node index on the other shared boundary "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      
      // Read the node index on the other shared boundary
      other_indexes[i] = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
     } // for (i < n_shd_bnd_with_other_procs_have_node)
    
   } // if (is_the_node_in_shared_boundaries_with_other_processors == 4)
#ifdef PARANOID
  else
   {
    if (is_the_node_in_shared_boundaries_with_other_processors != 0)
     {
      std::ostringstream error_message;
      error_message
       <<"The current node is not on a shared boundary with\n"
       <<"other processors, this should be indicated by a zero flag.\n"
       <<"However, the read value for that flag is ("
       <<is_the_node_in_shared_boundaries_with_other_processors<<").\n\n";
      throw OomphLibError(
       error_message.str(),
       "RefineableTriangleMesh::construct_new_node_load_balance_helper()",
       OOMPH_EXCEPTION_LOCATION);
     }
   }
#endif
  
  // ------------------------------------------------------------
  // Receive the info. to check if the node is on a haloed element
  // with any processor
  
  // Store the halo element number with jproc where the node was found
  Vector<Vector<unsigned> > halo_element_number(nproc);
  // Store the node number on the halo element where the node was found
  Vector<Vector<unsigned> > halo_node_number_in_halo_element(nproc);
  
  // Loop over the processors
  for (unsigned jproc = 0; jproc < nproc; jproc++)
   {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  The node is on " 
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << " halo elements with " << jproc << " processor"
                 << std::endl;
#endif
    // Get the number of halo elements with jproc processor where the
    // node was found
    const unsigned n_jproc_halo_ele_node_is_on = 
     Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    
    // Resize the containers
    halo_element_number[jproc].resize(n_jproc_halo_ele_node_is_on);
    halo_node_number_in_halo_element[jproc].resize(n_jproc_halo_ele_node_is_on);
    
    // Read halo elements indexes (which are indexes of the halo
    // elements of the sender processor (iproc) with other processors
    // (included my_rank)
    for (unsigned i = 0; i < n_jproc_halo_ele_node_is_on; i++)
     {
      // Get the halo element index in the jproc processor
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  The halo element index where the node is on "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      // Get the node index on the halo element
      const unsigned halo_ele_index = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  The node index on the halo element where the node "
                 << "is on "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      const unsigned node_index_on_halo_ele = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      
      // Store the halo element number
      halo_element_number[jproc][i] = halo_ele_index;
      // Store the index of on the haloed element
      halo_node_number_in_halo_element[jproc][i] = node_index_on_halo_ele;
      
     } // for (i < n_jproc_halo_ele_node_is_on)
    
   } // for (jproc < nproc)
  
  // Store the node pointers obtained from the indicated halo elements
  // (use a set to check for the case when the node pointer is
  // different)
  std::set<Node*> set_haloed_node_pt;
  
  // Store the node pointer obtained from the haloed elements
  Node* haloed_node_pt = 0;
  
  // Flag to indicate if it is on a haloed element of the current
  // processor with the iproc processor. If this flag is true then
  // there is no need to read the info. to create the node, only copy
  // the node from the indicated haloed element-node
  bool on_haloed_element_with_iproc_processor = false;
  if (halo_element_number[my_rank].size() > 0)
   {
    // The node is part of the haloed element in the current processor
    // (my_rank) with the receiver processor
    on_haloed_element_with_iproc_processor = true;
    
    // Get the number of haloed elements in the current processor
    const unsigned n_haloed_indexes = halo_element_number[my_rank].size();
    // Loop over the different haloed indexes, and get the nodes
    // instances from all the indicated haloed elements (all of them
    // should be the same)
    for (unsigned i = 0; i < n_haloed_indexes; i++)
     {
      // Get the haloed element numbers where the node is on
      const unsigned haloed_index = halo_element_number[my_rank][i];
      // Get the node index on the haloed element
      const unsigned haloed_node_index = 
       halo_node_number_in_halo_element[my_rank][i];
      
      // Get the haloed element (with iproc)
      FiniteElement* tmp_haloed_ele_pt = f_haloed_ele_pt[iproc][haloed_index];
      // Get the node on the indicated node number
      Node* tmp_haloed_node_pt = tmp_haloed_ele_pt->node_pt(haloed_node_index);
      
      // Set the pointer for the obtained haloed node
      haloed_node_pt = tmp_haloed_node_pt;
      
      // Add the node to the set of node pointers
      set_haloed_node_pt.insert(tmp_haloed_node_pt);
      
#ifdef PARANOID
      if (set_haloed_node_pt.size() > 1)
       {
        std::ostringstream error_message;
        error_message
         <<"When adding the " << haloed_node_index << " node of the " 
         << haloed_index << "-th haloed element\n"
         << "in the currrent processor with the " << iproc << " processor"
         << "it was found that\nthe node pointer is different from the other"
         << "instances of the node.\nIt means we have a repeated node."
         << "This are the node coordinates of the previous node instances\n"
         << "The last entry is for the just added node with a different node\n"
         << "pointer\n";
        for (std::set<Node*>::iterator it = set_haloed_node_pt.begin();
             it != set_haloed_node_pt.end(); it++)
         {
          error_message
           << "Node: ("<< (*it)->x(0)<<", "<<(*it)->x(1)<<")\n";
         }
        error_message << "\n";
        throw OomphLibError(
         error_message.str(),
         "RefineableTriangleMesh::construct_new_node_load_balance_helper()",
         OOMPH_EXCEPTION_LOCATION);
       }
#endif
      
     } // for (i < n_haloed_indexes)
    
   } // if (halo_element_number[iproc].size() > 0)
  
  // Flag to indicate if the node has been found on a haloed element
  // of other processor with the iproc processor
  bool found_on_haloed_element_with_other_processor = false;
  // Loop over the processors (only until the iproc since no info. of
  // higher processors has been received)
  for (unsigned jproc = 0; jproc < iproc; jproc++)
   {
    // Is the node on a halo element with the jproc processor
    if (halo_element_number[jproc].size() > 0)
     {
      // Get the number of halo elements with the jproc processor
      const unsigned n_halo_indexes = halo_element_number[jproc].size();
      // Loop over the different halo indexes, and get the nodes
      // instances from all the indicated halo elements (all of them
      // should be the same)
      for (unsigned i = 0; i < n_halo_indexes; i++)
       {
        // Get the haloed element numbers where the node is on
        const unsigned haloed_index = halo_element_number[jproc][i];
        // Get the node index on the haloed element
        const unsigned haloed_node_index = 
         halo_node_number_in_halo_element[jproc][i];
        
        // Have we received the indicated element? (Get the haloed
        // element on jproc with the iproc processor)
        std::map<unsigned,FiniteElement*>::iterator it_map =
         received_old_haloed_element_pt[jproc][iproc].find(haloed_index);
        // Have we received the indicated element?
        if (it_map != received_old_haloed_element_pt[jproc][iproc].end())
         {
          // Set the flag of found element in other processors haloed
          // element, in this case in haloed elements of processor
          // jproc wiht iproc processor
          found_on_haloed_element_with_other_processor = true;
          
          // Get the element
          FiniteElement* tmp_haloed_ele_pt = (*it_map).second;
          // Get the node on the indicated node number
          Node* tmp_haloed_node_pt = 
           tmp_haloed_ele_pt->node_pt(haloed_node_index);
          
          // Set the pointer for the obtained haloed node
          haloed_node_pt = tmp_haloed_node_pt;
          
          // Add the node to the set of node pointers
          set_haloed_node_pt.insert(tmp_haloed_node_pt);
          
#ifdef PARANOID
          if (set_haloed_node_pt.size() > 1)
           {
            std::ostringstream error_message;
            error_message
             <<"When adding the " << haloed_node_index << " node of the " 
             << haloed_index << "-th haloed element "
             << "of the " << jproc << " processor\nwith the " 
             << iproc << " processor, it was found that\n"
             << "the node pointer is different from the other\n"
             << "instances of the node.\nThis means we have a repeated node.\n"
             << "These are the node coordinates of the previous node "
             << "instances\n"
             << "The last entry is for the just added node with a different\n"
             << "node pointer\n";
            for (std::set<Node*>::iterator it = set_haloed_node_pt.begin();
                 it != set_haloed_node_pt.end(); it++)
             {
              error_message
               << "Node: ("<< (*it)->x(0)<<", "<<(*it)->x(1)<<")\n";
             }
            error_message << "\n";
            throw OomphLibError(
             error_message.str(),
             "RefineableTriangleMesh::construct_new_node_load_balance_helper()",
             OOMPH_EXCEPTION_LOCATION);
           }
#endif
          
         } // if (it_map != received_old_haloed_element_pt[jproc][iproc].end())
           // Have we received the element?
        
       } // for (i < n_haloed_indexes)
      
     } // if (halo_element_number[iproc].size() > 0)
    
   } // for (jproc < nproc)
  
  // If the node was found in the haloed elements of the current
  // processor with the iproc processor, or in the haloed elements of
  // any other processor with the iproc processor then copy the node
  // pointer (no problem if we overwrite the node info. it should be
  // the same node pointer)
  if (on_haloed_element_with_iproc_processor || 
      found_on_haloed_element_with_other_processor)
   {
    // Set the node pointer
    new_nod_pt = haloed_node_pt;
   }

  // Now we have all the info. to decide if the node should be created
  // or not
  
  // First check if the node is a shared boundary node, or if it has
  // been found on haloed elements
  if (is_node_on_shared_boundary == 1 || 
      (on_haloed_element_with_iproc_processor))
   {
    // We already have the node, we do not need to create it
    
    // Only check if we need to add boundary info. to the node
    if (node_on_original_boundaries==2)
     {
      // The node is a boundary node, add the boundary info. before
      // adding it to the domain
      
      // Associate the node to the given boundaries
      for (unsigned i = 0; i < n_original_boundaries_node_is_on; i++)
       {
        add_boundary_node(original_boundaries_node_is_on[i], new_nod_pt);
        // Establish the boundary coordinates for the node
        Vector<double> zeta(1);
        zeta[0] = zeta_coordinates[i];
        new_nod_pt->set_coordinates_on_boundary(
         original_boundaries_node_is_on[i],zeta);
       }
      
     } // if (node_on_original_boundaries==2)
    
    // Add the node to the domain
    new_nodes_on_domain.push_back(new_nod_pt);
    
    // Add the node to the element
    new_el_pt->node_pt(node_index) = new_nod_pt;
    
   } // if (is_node_on_shared_boundary == 1)
  
  // Now check if the node is on a shared boundary with another
  // processor, if that is the case try to find the node that may have
  // been already sent by the other processors
  
  // This flags indicates if the node was found, and then decide if it
  // is required to create the node
  bool found_node_in_other_shared_boundaries = false;
  // Flag to indicate whether the node should be created as a boundary
  // node or not. If the node lies on a shared boundary with other
  // processor the we create it as a boundary node. The processor from
  // which we are receiving info. (iproc) may not know that the node
  // lies on an original boundary. If the node lies on an original
  // boundary then its info. will be sent by another processor, then
  // we can set its boundary info. since the node was constructed as a
  // boundary node
  bool build_node_as_boundary_node = false;
  
  if (is_the_node_in_shared_boundaries_with_other_processors == 4)
   {
     // Build the node as a boundary node
     build_node_as_boundary_node = true;
     
    // Try to get the node pointer in case that the node has been
    // already sent by the other processors
    
    // Get the number of initial shared boundaries to correct the
    // index of the shared boundary
    const unsigned initial_shd_bnd_id = this->initial_shared_boundary_id();
    
    // Add the found nodes in the container, should be the same but
    // better check
    Vector<Node*> found_node_pt;
    
    // Now try to find the node in any of the other shared boundaries
    for (unsigned i = 0; i < n_shd_bnd_with_other_procs_have_node; i++)
     {
      unsigned oproc1 = other_processor_1[i];
      unsigned oproc2 = other_processor_2[i];
      
      // Check that we always check with the lower processors number
      // first
      if (oproc1 > oproc2)
       {
        oproc2 = oproc1;
        oproc1 = other_processor_2[i];
       } // if (oproc1 > oproc2)
      
      // Re-compute the shared boundary id between the other
      // processors
      const unsigned shd_bnd_id = 
       other_shared_boundaries[i] - initial_shd_bnd_id;
      // Read the index
      const unsigned index = other_indexes[i];
      
      // Check if there are nodes received from the other processor
      // and with the given shared boundary
      const unsigned n_nodes_on_other_processor = 
       other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id].size();
      
      if (n_nodes_on_other_processor > 0)
       {
        // Check if we can find the index of the node in that other
        // processor and shared boundary id
        std::map<unsigned, Node*>::iterator it = 
         other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id].
         find(index);
        
        // If the index exist then get the node pointer
        if (it!=
            other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id].end())
         {
          // Mark the node as found
          found_node_in_other_shared_boundaries = true;
          // Get the node pointer
          Node* tmp_node_pt = 
           other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id][index];
          found_node_pt.push_back(tmp_node_pt);
         } // if (it!=
           // other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id].end())
        
       } // if (n_nodes_on_other_processor > 0)
      
     } // for (i < n_shd_bnd_with_other_procs_have_node)
    
    // If the node was found, then all their instances should be the
    // same but better check
    if (found_node_in_other_shared_boundaries)
     {
#ifdef PARANOID
      const unsigned ntimes_node_found = found_node_pt.size();
      for (unsigned j = 1; j < ntimes_node_found; j++)
       {
        if (found_node_pt[j-1] != found_node_pt[j])
         {
          std::ostringstream error_message;
          error_message
           <<"The instances of the node that was found to be on a\n"
           <<"shared boundary with other processors are not the same,\n"
           <<"the coordinates for the nodes are these:\n"
           <<"(" << found_node_pt[j-1]->x(0) << ", "
           << found_node_pt[j-1]->x(1) << ")\n"
           <<"(" << found_node_pt[j]->x(0) << ", "
           << found_node_pt[j]->x(1) << ")\n"
           <<"Not be surprised if they are the same since the node is\n"
           <<"repeated!!!\n";
          throw OomphLibError(
           error_message.str(),
           "RefineableTriangleMesh::construct_new_halo_node_helper()",
           OOMPH_EXCEPTION_LOCATION);
          
         } // if (found_node_pt[j-1] != found_node_pt[j])
        
       } // for (j < ntimes_node_found)
#endif
      
      // Check if the node is a shared boundary node from the current
      // processor and the iproc processor, if that is the case, and
      // the node is also on a shared boundary with other processor,
      // then the pointer should be the same!!!
      if (is_node_on_shared_boundary == 1)
       {
        // The pointer to the node is already assigned, it was
        // assigned when thenode was found to be on a shared boundary
        // with the iproc processor
        if (found_node_pt[0] != new_nod_pt)
         {
          std::ostringstream error_message;
          error_message
           <<"The pointer of the node that was found to be on a\n"
           <<"shared boundary with other processor(s) and the pointer\n"
           <<"of the node on shared boundary with the receiver\n"
           <<"processor (iproc) are not the same. This means we have a\n"
           << "repeated node)\n"
           <<"The coordinates for the nodes are:\n"
           <<"(" << found_node_pt[0]->x(0) << ", "
           << found_node_pt[0]->x(1) << ")\n"
           <<"(" << new_nod_pt->x(0) << ", "
           << new_nod_pt->x(1) << ")\n"
           <<"Not to be surprised if they are the same since the node is\n"
           <<"repeated!!!\n";
          throw OomphLibError(
           error_message.str(),
           "RefineableTriangleMesh::construct_new_halo_node_helper()",
           OOMPH_EXCEPTION_LOCATION);
         } // if (found_node_pt[0] != new_nod_pt)
        
       } // if (is_node_on_shared_boundary == 1)
      else
       {
        // Take the first instance of the node in case that it was
        // found and is not on a shared boundary with the iproc
        // processor
        new_nod_pt = found_node_pt[0];
       }
      
     } // if (found_node_in_other_shared_boundaries)
    
   } // if (is_the_node_in_shared_boundaries_with_other_processors == 4)
  
  // -----------------------------------------------------------------
  // Create the node or read the received info if the node is not on a
  // shared boundary with the iproc processor and if the node is not
  // part of the haloed elements with the iproc processor in the
  // current processors
  if (is_node_on_shared_boundary != 1 && 
      !on_haloed_element_with_iproc_processor)
   {
    // If the node is on a shared boundary with other processor we
    // need to read all the info. since the processor that sent the
    // info. did not know that the node is part of another shared
    // boundary
     
    // If the node is not a shared boundary (with any processor), or
    // if this is the first time that the info. of the node is
    // received from any of the processors with which is has a shared
    // boundary, then we create the node
     
    // Is the node a boundary node or should it be build as a boundary
    // node because it is on a shared boundary with other processors
    if (node_on_original_boundaries==2 || build_node_as_boundary_node)
     {
      // Check if necessary to create the node, or if it has been
      // already found in shared boundaries with other processors or
      // in the haloed elements with of other processors with the
      // iproc processor
      if (!found_node_in_other_shared_boundaries ||
          !found_on_haloed_element_with_other_processor)
       {
        // Construct a boundary node
        if (time_stepper_pt!=0)
         {
          new_nod_pt=new_el_pt->construct_boundary_node(node_index,
                                                        time_stepper_pt);
         }
        else
         {
          new_nod_pt=new_el_pt->construct_boundary_node(node_index);
         }
        
       } // if (!found_node_in_other_shared_boundaries ||
         //     !found_on_haloed_element_with_other_processor)
      else
       {
        // If the node was found then assign the node to the element
        new_el_pt->node_pt(node_index) = new_nod_pt;
       } // else if (!found_node_in_other_shared_boundaries ||
         //      !found_on_haloed_element_with_other_processor)
      
      // Associate the node to the given boundaries
      for (unsigned i = 0; i < n_original_boundaries_node_is_on; i++)
        {
          add_boundary_node(original_boundaries_node_is_on[i], new_nod_pt);
          // Establish the boundary coordinates for the node
          Vector<double> zeta(1);
          zeta[0] = zeta_coordinates[i];
          new_nod_pt->set_coordinates_on_boundary(
           original_boundaries_node_is_on[i],zeta);
        }
      
     } // if (node is on an original boundary)
    else
     {
      // Check if necessary to create the node, or if it has been
      // already found in shared boundaries with other processors or
      // in the haloed elements with of other processors with the
      // iproc processor
      if (!found_node_in_other_shared_boundaries ||
          !found_on_haloed_element_with_other_processor)
       {
        // Construct an ordinary (non-boundary) node
        if (time_stepper_pt!=0)
         {
          new_nod_pt=new_el_pt->construct_node(node_index, time_stepper_pt);
         }
        else
         {
          new_nod_pt=new_el_pt->construct_node(node_index);
         }
       } // if (!found_node_in_other_shared_boundaries ||
         //     !found_on_haloed_element_with_other_processor)
      else
       {
        // If the node was found then assign the node to the element
        new_el_pt->node_pt(node_index) = new_nod_pt;
       } // else // if (!found_node_in_other_shared_boundaries ||
         //             !found_on_haloed_element_with_other_processor)
      
     } // else (the node is not a boundary node)
    
    // ... and gather all its information
    
    // If the node was found or not in other shared boundaries, this
    // is the first time the node is received from this processor
    // (iproc), therefore it is added to the vector of nodes received
    // from this processor (iproc)
    new_nodes_on_domain.push_back(new_nod_pt);
    
    // Check if necessary to state all the info. to the node if it has
    // been already found in shared boundaries with other processors
    // or in the haloed elements with of other processors with the
    // iproc processor
    if (!found_node_in_other_shared_boundaries ||
        !found_on_haloed_element_with_other_processor)
     {
      // Add the node to the general node storage
      this->add_node_pt(new_nod_pt);
     } // if (!found_node_in_other_shared_boundaries ||
       //     !found_on_haloed_element_with_other_processor)
    
    // Is the new constructed node Algebraic?
    AlgebraicNode* new_alg_nod_pt=dynamic_cast<AlgebraicNode*>
     (new_nod_pt);

    // If it is algebraic, its node update functions will
    // not yet have been set up properly
    if (new_alg_nod_pt!=0)
     {
      // The AlgebraicMesh is the external mesh
      AlgebraicMesh* alg_mesh_pt=dynamic_cast<AlgebraicMesh*>(this);
      
      /// The first entry of All_alg_nodal_info contains
      /// the default node update id
      /// e.g. for the quarter circle there are 
      /// "Upper_left_box", "Lower right box" etc...
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Alg node update id "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      
      unsigned update_id=Flat_packed_unsigneds
       [Counter_for_flat_packed_unsigneds++];
      
      Vector<double> ref_value;
      
      // The size of this vector is in the next entry
      // of All_alg_nodal_info
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Alg node # of ref values "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      unsigned n_ref_val=Flat_packed_unsigneds
       [Counter_for_flat_packed_unsigneds++];
      
      // The reference values themselves are in
      // All_alg_ref_value
      ref_value.resize(n_ref_val);
      for (unsigned i_ref=0;i_ref<n_ref_val;i_ref++)
       {
        ref_value[i_ref]=Flat_packed_doubles
         [Counter_for_flat_packed_doubles++];
       }
      
      Vector<GeomObject*> geom_object_pt;
      /// again we need the size of this vector as it varies
      /// between meshes; we also need some indication
      /// as to which geometric object should be used...
      
      // The size of this vector is in the next entry
      // of All_alg_nodal_info
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Alg node # of geom objects "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      unsigned n_geom_obj=Flat_packed_unsigneds
       [Counter_for_flat_packed_unsigneds++];
      
      // The remaining indices are in the rest of 
      // All_alg_nodal_info
      geom_object_pt.resize(n_geom_obj);
      for (unsigned i_geom=0;i_geom<n_geom_obj;i_geom++)
       {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                   << "  Alg node: geom object index "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        unsigned geom_index=Flat_packed_unsigneds
         [Counter_for_flat_packed_unsigneds++];
        // This index indicates which of the AlgebraicMesh's
        // stored geometric objects should be used
        // (0 is a null pointer; everything else should have
        //  been filled in by the specific Mesh).  If it
        // hasn't been filled in then the update_node_update
        // call should fix it
        geom_object_pt[i_geom]=alg_mesh_pt->
         geom_object_list_pt(geom_index);
       }
      
      // Check if necessary to state all the info. to the node if it
      // has been already found in shared boundaries with other
      // processors or in the haloed elements with of other processors
      // with the iproc processor
      if (!found_node_in_other_shared_boundaries ||
          !found_on_haloed_element_with_other_processor)
       {
        /// For the received update_id, ref_value, geom_object
        /// call add_node_update_info
        new_alg_nod_pt->add_node_update_info
         (update_id,alg_mesh_pt,geom_object_pt,ref_value);
        
        /// Now call update_node_update
        alg_mesh_pt->update_node_update(new_alg_nod_pt);
        
       } // if (!found_node_in_other_shared_boundaries ||
         //     !found_on_haloed_element_with_other_processor)
      
     } // if (new_alg_nod_pt!=0)
    
    // Check if necessary to state all the info. to the node if it has
    // been already found in shared boundaries with other processors
    // or in the haloed elements with of other processors with the
    // iproc processor
    if (!found_node_in_other_shared_boundaries ||
        !found_on_haloed_element_with_other_processor)
     {
      // Is the node a MacroElementNodeUpdateNode?
      MacroElementNodeUpdateNode* macro_nod_pt=
       dynamic_cast<MacroElementNodeUpdateNode*>(new_nod_pt);
    
      if (macro_nod_pt!=0)
       {
        // Need to call set_node_update_info; this requires
        // a Vector<GeomObject*> (taken from the mesh)
        Vector<GeomObject*> geom_object_vector_pt;
      
        // Access the required geom objects from the
        // MacroElementNodeUpdateMesh
        MacroElementNodeUpdateMesh* macro_mesh_pt=
         dynamic_cast<MacroElementNodeUpdateMesh*>(this);
        geom_object_vector_pt=
         macro_mesh_pt->geom_object_vector_pt();
      
        // Get local coordinate of node in new element
        Vector<double> s_in_macro_node_update_element;
        new_el_pt->local_coordinate_of_node
         (node_index,s_in_macro_node_update_element);
      
        // Set node update info for this node
        macro_nod_pt->set_node_update_info
         (new_el_pt,s_in_macro_node_update_element,
          geom_object_vector_pt);
       }
      
     } // if (!found_node_in_other_shared_boundaries ||
       //     !found_on_haloed_element_with_other_processor)
    
    // If there are additional values, resize the node
    unsigned n_new_val=new_nod_pt->nvalue();
    
    // Check if necessary to state all the info. to the node if it has
    // been already found in shared boundaries with other processors
    // or in the haloed elements with of other processors with the
    // iproc processor
    if (!found_node_in_other_shared_boundaries ||
        !found_on_haloed_element_with_other_processor)
     {
      if (n_val>n_new_val)
       {        
        // If it has been necessary to resize then it may be becuse
        // the node is on a FSI boundary, if that is the case we need
        // to set a map for these external values
        
        // Cast to a boundary node
        BoundaryNodeBase *bnod_pt = 
         dynamic_cast<BoundaryNodeBase*>(new_nod_pt);
        
        // Create storage, if it doesn't already exist, for the map 
        // that will contain the position of the first entry of 
        // this face element's additional values, 
        if(bnod_pt->index_of_first_value_assigned_by_face_element_pt()==0)
         {
          bnod_pt->index_of_first_value_assigned_by_face_element_pt()= 
           new std::map<unsigned, unsigned>; 
         }
        
        // Get pointer to the map
        std::map<unsigned, unsigned>* map_pt=
         bnod_pt->index_of_first_value_assigned_by_face_element_pt();
        
        // The id of the face to which this node belong in the bulk
        // element
        const unsigned id_face = 0;
        // We only resize the node values Vector if we haven't done it yet
        std::map<unsigned, unsigned>::const_iterator p=map_pt->find(id_face);
        
        // If this node hasn't been resized for current id
        if(p==map_pt->end())
         {
          // assign the face element id and the position of the 
          //first entry to the boundary node
          (*map_pt)[id_face] = n_new_val;
          
          // resize the node vector of values
          new_nod_pt->resize(n_val);
         }
        
       } // if (n_val>n_new_val)
      
     } // if (!found_node_in_other_shared_boundaries ||
       //     !found_on_haloed_element_with_other_processor)
    
    // Is the new node a SolidNode? 
    SolidNode* solid_nod_pt=dynamic_cast<SolidNode*>(new_nod_pt);
    if (solid_nod_pt!=0)
     {
      unsigned n_solid_val=solid_nod_pt->variable_position_pt()->nvalue();
      for (unsigned i_val=0;i_val<n_solid_val;i_val++)
       {
        for (unsigned t=0;t<n_prev;t++)
         {
          double read_data = 
           Flat_packed_doubles[Counter_for_flat_packed_doubles++];

          // Check if necessary to state all the info. to the node if
          // it has been already found in shared boundaries with other
          // processors or in the haloed elements with of other
          // processors with the iproc processor
          if (!found_node_in_other_shared_boundaries ||
              !found_on_haloed_element_with_other_processor)
           {
            solid_nod_pt->variable_position_pt()->
             set_value(t, i_val, read_data);
           } // if (!found_node_in_other_shared_boundaries ||
             //     !found_on_haloed_element_with_other_processor)
          
         }
        
       }
      
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds 
                 << "  Number of values solid node: "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      const unsigned nvalues_solid_node = 
       Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      Vector<double> values_solid_node(nvalues_solid_node);
      for (unsigned i = 0; i < nvalues_solid_node; i++)
       {
        values_solid_node[i] = 
         Flat_packed_doubles[Counter_for_flat_packed_doubles++];
       }
      
      // Check if necessary to state all the info. to the node if it
      // has been already found in shared boundaries with other
      // processors or in the haloed elements with of other processors
      // with the iproc processor
      if (!found_node_in_other_shared_boundaries ||
          !found_on_haloed_element_with_other_processor)
       {
        unsigned index = 0;
        solid_nod_pt->read_values_from_vector(values_solid_node, index);
       } // if (!found_node_in_other_shared_boundaries ||
         //     !found_on_haloed_element_with_other_processor)
      
     }
    
    // Get copied history values
    //  unsigned n_val=new_nod_pt->nvalue();
    for (unsigned i_val=0;i_val<n_val;i_val++)
     {
      for (unsigned t=0;t<n_prev;t++)
       {
        double read_data = 
         Flat_packed_doubles[Counter_for_flat_packed_doubles++];
        
        // Check if necessary to state all the info. to the node if it
        // has been already found in shared boundaries with other
        // processors or in the haloed elements with of other
        // processors with the iproc processor
        if (!found_node_in_other_shared_boundaries ||
            !found_on_haloed_element_with_other_processor)
         {
          new_nod_pt->set_value(t, i_val, read_data);
         } // if (!found_node_in_other_shared_boundaries ||
           //     !found_on_haloed_element_with_other_processor)
        
       }
      
     }
    
    // Get copied history values for positions
    unsigned n_dim=new_nod_pt->ndim();
    for (unsigned idim=0;idim<n_dim;idim++)
     {
      for (unsigned t=0;t<n_prev;t++)
       {
        double read_data = 
         Flat_packed_doubles[Counter_for_flat_packed_doubles++];
        
        // Check if necessary to state all the info. to the node if it
        // has been already found in shared boundaries with other
        // processors or in the haloed elements with of other
        // processors with the iproc processor
        if (!found_node_in_other_shared_boundaries ||
            !found_on_haloed_element_with_other_processor)
         {
          // Copy to coordinate
          new_nod_pt->x(t,idim) = read_data;
//          DEBP(new_nod_pt->x(t,idim));
         } // if (!found_node_in_other_shared_boundaries ||
           //     !found_on_haloed_element_with_other_processor)
       }
     }
    
   } // if (is_node_on_shared_boundary != 1)
  
  // If the node was not found in other shared boundaries (possibly
  // because it is the first time the node has been sent) then copy
  // the node to the shared boundaries where it should be, use the
  // special container for this cases
  if (n_shd_bnd_with_other_procs_have_node > 0 && // The node is on
                                                  // shared
                                                  // boundaries with
                                                  // other processors
      !found_node_in_other_shared_boundaries)    // The node has not
                                                  // been previously
                                                  // set as with
                                                  // shared with
                                                  // other processors
                                                  // (first time)
   {
     
     // Update the node pointer in all the references of the node
     this->update_other_proc_shd_bnd_node_helper(new_nod_pt,
                                                 other_proc_shd_bnd_node_pt,
                                                 other_processor_1,
                                                 other_processor_2,
                                                 other_shared_boundaries,
                                                 other_indexes,
                                                 global_node_names,
                                                 node_name_to_global_index,
                                                 global_shared_node_pt);
     
   } // if (!found_node_in_other_shared_boundaries)
  
 }
  
#endif // #ifdef OOMPH_HAS_MPI

 //======================================================================
 /// \short Get the nodes on the boundary (b), these are stored in the
 /// segment they belong (also used by the load balance method to
 /// re-set the number of segments per boundary after load balance has
 /// taken place)
 //======================================================================
 template <class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::get_boundary_segment_nodes_helper(
  const unsigned &b, Vector<Vector<Node*> > &tmp_segment_nodes)
 {
  // Clear the data structure were to return the nodes
  tmp_segment_nodes.clear();
  
  // Temporary storage for face elements
  Vector<FiniteElement*> face_el_pt;
  
  // Temporary storage for number of elements adjacent to the boundary
  unsigned nel = 0;
  
  // Temporary storage for elements adjacent to the boundary that have
  // a common edge (related with internal boundaries)
  unsigned n_repeated_ele = 0;
  
  // Get the number of regions
  const unsigned n_regions = this->nregion();
  
  // Temporary storage for already visited pair of nodes (edges)
  Vector < std::pair<Node*, Node *> > done_nodes_pt;
  
  // Are there more than one region?
  if (n_regions > 1)
   {
    for (unsigned rr = 0 ; rr < n_regions; rr++)
     {
      const unsigned region_id = 
       static_cast<unsigned>(this->Region_attribute[rr]);
      
      // Loop over all elements on boundaries in region rr
      const unsigned nel_in_region = 
       this->nboundary_element_in_region(b, region_id);
      
      // Number of repeated element in region
      unsigned nel_repeated_in_region = 0;
      
      // Only bother to do anything else, if there are elements
      // associated with the boundary and the current region
      if (nel_in_region > 0)
       {
        // Flag that activates when a repeated face element is found,
        // possibly because we are dealing with an internal boundary
        bool repeated = false;
        
        // Loop over the bulk elements adjacent to boundary b
        for (unsigned e = 0; e < nel_in_region; e++)
         {
          // Get pointer to the bulk element that is adjacent to boundary b
          FiniteElement* bulk_elem_pt =
           this->boundary_element_in_region_pt(b, region_id, e);
          
#ifdef OOMPH_HAS_MPI
          // In a distributed mesh only work with nonhalo elements
          if (this->is_mesh_distributed() && bulk_elem_pt->is_halo())
           {
            // Increase the number of repeated elements
            n_repeated_ele++;
            // Go for the next element
            continue;
           }
#endif
          
          //Find the index of the face of element e along boundary b
          int face_index = 
           this->face_index_at_boundary_in_region(b, region_id, e);
          
          // Before adding the new element we need to be sure that the
          // edge that this element represents has not been already
          // added
          FiniteElement* tmp_ele_pt = new DummyFaceElement<ELEMENT> (
           bulk_elem_pt, face_index);
      
          // Number of nodes in the face element
          const unsigned n_nodes = tmp_ele_pt->nnode();
          
          std::pair<Node*, Node*> tmp_pair = 
           std::make_pair(tmp_ele_pt->node_pt(0),
                          tmp_ele_pt->node_pt(n_nodes - 1));
          
          std::pair<Node*, Node*> tmp_pair_inverse = 
           std::make_pair(tmp_ele_pt->node_pt(n_nodes - 1),
                          tmp_ele_pt->node_pt(0));
          
          // Search for repeated nodes
          unsigned n_done_nodes = done_nodes_pt.size();
          for (unsigned l = 0; l < n_done_nodes; l++)
           {
            if (tmp_pair == done_nodes_pt[l] || tmp_pair_inverse
                == done_nodes_pt[l])
             {
              nel_repeated_in_region++;
              repeated = true;
              break;
             }
            
           } // for (l < n_done_nodes)
          
          // Create new face element?
          if (!repeated)
           {
            // Add the pair of nodes (edge) to the node dones
            done_nodes_pt.push_back(tmp_pair);
            // Add the face element to the storage
            face_el_pt.push_back(tmp_ele_pt);
           }
          else
           {
            // Clean up
            delete tmp_ele_pt;
            tmp_ele_pt = 0;
           }
          
          // Re-start
          repeated = false;
          
         } // for (e < nel_in_region)
        
        // Add on the number of elements in the boundary with the
        // current region
        nel += nel_in_region;
        
        // Add on the number of repeated elements
        n_repeated_ele += nel_repeated_in_region;
        
       } // if (nel_in_region > 0)
      
     } // for (rr < n_regions)
    
   } // if (n_regions > 1)
  //Otherwise it's just the normal boundary functions
  else
   {
    // Assign the number of boundary elements
    nel = this->nboundary_element(b);
    
    //Only bother to do anything else, if there are elements
    if (nel > 0)
     {
      // Flag that activates when a repeated face element is found,
      // possibly because we are dealing with an internal boundary
      bool repeated = false;
      
      // Loop over the bulk elements adjacent to boundary b
      for (unsigned e = 0; e < nel; e++)
       {
        // Get pointer to the bulk element that is adjacent to boundary b
        FiniteElement* bulk_elem_pt = this->boundary_element_pt(b, e);
        
#ifdef OOMPH_HAS_MPI
        // In a distributed mesh only work with nonhalo elements
        if (this->is_mesh_distributed() && bulk_elem_pt->is_halo())
         {
          // Increase the number of repeated elements
          n_repeated_ele++;
          // Go for the next element
          continue;
         }
#endif
        
        //Find the index of the face of element e along boundary b
        int face_index = this->face_index_at_boundary(b, e);
        
        // Before adding the new element we need to be sure that the
        // edge that this element represent has not been already added
        FiniteElement* tmp_ele_pt = new DummyFaceElement<ELEMENT> (
         bulk_elem_pt, face_index);
        
        // Number of nodes in the face element
        const unsigned n_nodes = tmp_ele_pt->nnode();
        
        std::pair<Node*, Node*> tmp_pair = 
         std::make_pair(tmp_ele_pt->node_pt(0),
                        tmp_ele_pt->node_pt(n_nodes - 1));
        
        std::pair<Node*, Node*> tmp_pair_inverse = 
         std::make_pair(tmp_ele_pt->node_pt(n_nodes - 1),
                        tmp_ele_pt->node_pt(0));
        
        // Search for repeated nodes
        unsigned n_done_nodes = done_nodes_pt.size();
        for (unsigned l = 0; l < n_done_nodes; l++)
         {
          if (tmp_pair == done_nodes_pt[l] || tmp_pair_inverse
              == done_nodes_pt[l])
           {
            n_repeated_ele++;
            repeated = true;
            break;
           }
          
         } // for (l < n_done_nodes)
        
        // Create new face element
        if (!repeated)
         {
          // Add the pair of nodes (edge) to the node dones
          done_nodes_pt.push_back(tmp_pair);
          // Add the face element to the storage
          face_el_pt.push_back(tmp_ele_pt);
         }
        else
         {
          // Free the repeated bulk element!!
          delete tmp_ele_pt;
          tmp_ele_pt = 0;
         }
        
        // Re-start
        repeated = false;
        
       } // for (e < nel)
      
     } // if (nel > 0)
    
   } // else if (n_regions > 1)
  
  // Substract the repeated elements
  nel -= n_repeated_ele;
  
#ifdef PARANOID
  if (nel!=face_el_pt.size())
   {
     std::ostringstream error_message;
     error_message
      << "The independet counting of face elements ("<<nel<<") for "
      << "boundary ("<<b<<") is different\n"
      << "from the real number of face elements in the container ("
      << face_el_pt.size() <<")\n";
     throw OomphLibError(error_message.str(),
                         "RefineableTriangleMesh::get_boundary_segment_nodes_helper()",
                         OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
  //Only bother to do anything else, if there are elements
  if (nel > 0)
   {
    // Assign the number of nonhalo face elements
    const unsigned nnon_halo_face_elements = nel;
    
    // The vector of list to store the "segments" that compound the
    // boundary (segments may appear only in a distributed mesh)
    Vector<std::list<FiniteElement*> > segment_sorted_ele_pt;
    
    // Number of already sorted face elements (only nonhalo face
    // elements for a distributed mesh)
    unsigned nsorted_face_elements = 0;
     
    // Keep track of who's done (in a distributed mesh this apply to
    // nonhalo only)
    std::map<FiniteElement*, bool> done_ele;
    
    // Keep track of which element is inverted (in distributed mesh
    // the elements may be inverted with respect to the segment they
    // belong)
    std::map<FiniteElement*, bool> is_inverted;
    
    // Iterate until all possible segments have been created. In a non
    // distributed mesh there is only one segment which defines the
    // complete boundary
    while(nsorted_face_elements < nnon_halo_face_elements)
     {
      // The ordered list of face elements (in a distributed mesh a
      // collection of continuous face elements define a segment)
      std::list<FiniteElement*> sorted_el_pt;
      
#ifdef PARANOID
      // Select an initial element for the segment
      bool found_initial_face_element = false;
#endif
      
      FiniteElement* ele_face_pt = 0;
      
      unsigned iface = 0;
#ifdef OOMPH_HAS_MPI
      if (this->is_mesh_distributed())
       {
        for (iface = 0; iface < nel; iface++)
         {
          ele_face_pt = face_el_pt[iface];
          // If not done then take it as initial face element
          if (!done_ele[ele_face_pt])
           {
#ifdef PARANOID
            // Set the flag to indicate the initial element was
            // found
            found_initial_face_element = true;
#endif
            // Increase the number of sorted face elements
            nsorted_face_elements++;
            // Set the index to the next face element
            iface++;
            // Add the face element in the container
            sorted_el_pt.push_back(ele_face_pt);
            // Mark as done
            done_ele[ele_face_pt] = true;
            break;
           } // if (!done_el[ele_face_pt])
         } // for (iface < nel)
       } // if (this->is_mesh_distributed())
      else
       {
#endif // #ifdef OOMPH_HAS_MPI
        
        // When the mesh is not distributed just take the first
        // element and put it in the ordered list
        ele_face_pt = face_el_pt[0];
#ifdef PARANOID
        // Set the flag to indicate the initial element was found
        found_initial_face_element = true;
#endif
        // Increase the number of sorted face elements
        nsorted_face_elements++;
        // Set the index to the next face element
        iface = 1;
        // Add the face element in the container
        sorted_el_pt.push_back(ele_face_pt);
        // Mark as done
        done_ele[ele_face_pt] = true;
#ifdef OOMPH_HAS_MPI
       } // else if (this->is_mesh_distributed())
#endif
       
#ifdef PARANOID
      if (!found_initial_face_element)
       {
        std::ostringstream error_message;
        error_message
         <<"Could not find an initial face element for the current segment\n";
        throw OomphLibError(error_message.str(),
                            "RefineableTriangleMesh::get_boundary_segment_nodes_helper()",
                            OOMPH_EXCEPTION_LOCATION);
       }
#endif
      
      // Number of nodes in the face element
      const unsigned nnod = ele_face_pt->nnode();
      
      // Left and rightmost nodes (the left and right nodes of the
      // current face element)
      Node* left_node_pt = ele_face_pt->node_pt(0);
      Node* right_node_pt = ele_face_pt->node_pt(nnod - 1);
      
      // Continue iterating if a new face element has been added to
      // the list
      bool face_element_added = false;
      
      // While a new face element has been added to the set of sorted
      // face elements continue iterating
      do
       {
        // Start from the next face element since we have already
        // added the previous one as the initial face element (any
        // previous face element had to be added on previous
        // iterations)
        for (unsigned iiface=iface;iiface<nel;iiface++)
         {
          // Re-start flag
          face_element_added = false;
          
          // Get the candidate element
          ele_face_pt = face_el_pt[iiface];
          
          // Check that the candidate element has not been done and is
          // not a halo element
          if (!done_ele[ele_face_pt])
           {
            // Get the left and right nodes of the current element
            Node* local_left_node_pt = ele_face_pt->node_pt(0);
            Node* local_right_node_pt = ele_face_pt->node_pt(nnod - 1);
            
            // New element fits at the left of segment and is not inverted
            if (left_node_pt == local_right_node_pt)
             {
              left_node_pt = local_left_node_pt;
              sorted_el_pt.push_front(ele_face_pt);
              is_inverted[ele_face_pt] = false;
              face_element_added = true;
             }
            // New element fits at the left of segment and is inverted
            else if (left_node_pt == local_left_node_pt)
             {
              left_node_pt = local_right_node_pt;
              sorted_el_pt.push_front(ele_face_pt);
              is_inverted[ele_face_pt] = true;
              face_element_added = true;
             }
            // New element fits on the right of segment and is not inverted
            else if (right_node_pt == local_left_node_pt)
             {
              right_node_pt = local_right_node_pt;
              sorted_el_pt.push_back(ele_face_pt);
              is_inverted[ele_face_pt] = false;
              face_element_added = true;
             }
            // New element fits on the right of segment and is inverted
            else if (right_node_pt == local_right_node_pt)
             {
              right_node_pt = local_left_node_pt;
              sorted_el_pt.push_back(ele_face_pt);
              is_inverted[ele_face_pt] = true;
              face_element_added = true;
             }
            
            if (face_element_added)
             {
              // Mark the face element as done
              done_ele[ele_face_pt] = true;
              nsorted_face_elements++;
              break;
             }
            
           } // if (!done_el[ele_face_pt])
          
         } // for (iiface<nnon_halo_face_element)
        
       }while(face_element_added &&
              (nsorted_face_elements < nnon_halo_face_elements));
      
      // Store the created segment in the vector of segments
      segment_sorted_ele_pt.push_back(sorted_el_pt);
      
     } // while(nsorted_face_elements < nnon_halo_face_elements);
    
    // The number of boundary segments in this processor
    const unsigned nsegments = segment_sorted_ele_pt.size();
    
#ifdef PARANOID
    if (nnon_halo_face_elements > 0 && nsegments == 0)
     {
      std::ostringstream error_message;
      error_message
       << "The number of segments is zero, but the number of nonhalo\n"
       << "elements is: (" << nnon_halo_face_elements << ")\n";
      throw OomphLibError(error_message.str(),
                          "RefineableTriangleMesh::get_boundary_segment_nodes_helper()",
                          OOMPH_EXCEPTION_LOCATION);
     } // if (nnon_halo_face_elements > 0 && nsegments == 0)
#endif
    
    // Go through all the segments, visit each face element in order
    // and get the nodes based that represent the boundary segment
    
    // Resize the container to store the nodes with the required
    // number of segments
    tmp_segment_nodes.resize(nsegments);
    
    for (unsigned is = 0; is < nsegments; is++)
     {
#ifdef PARANOID
      if (segment_sorted_ele_pt[is].size() == 0)
       {
        std::ostringstream error_message;
        error_message
         << "The (" << is << ")-th segment has no elements\n";
        throw OomphLibError(error_message.str(),
                            "RefineableTriangleMesh::get_boundary_segment_nodes_helper()",
                            OOMPH_EXCEPTION_LOCATION);
       } // if (segment_sorted_ele_pt[is].size() == 0)
#endif
      
      // Get access to the first element on the segment
      FiniteElement* first_ele_pt = segment_sorted_ele_pt[is].front();
      
      // Number of nodes
      const unsigned nnod = first_ele_pt->nnode();
      
      // Get the first node of the current segment
      Node *first_node_pt = first_ele_pt->node_pt(0);
      if (is_inverted[first_ele_pt])
       {
        first_node_pt = first_ele_pt->node_pt(nnod-1);
       }
      
      // Add the node to the corresponding segment
      tmp_segment_nodes[is].push_back(first_node_pt);
      
      // Now loop over face elements in order to get the nodes
      for (std::list<FiniteElement*>::iterator it = 
            segment_sorted_ele_pt[is].begin();
           it != segment_sorted_ele_pt[is].end(); it++)
       {
        // Get element
        FiniteElement* ele_pt = *it;
        
        // The last node pointer
        Node* last_node_pt = 0;
        
        // Get the last node
        if (!is_inverted[ele_pt])
         {
          last_node_pt = ele_pt->node_pt(nnod-1);
         }
        else
         {
          last_node_pt = ele_pt->node_pt(0);
         }
        
        // Add the node to the corresponding segment
        tmp_segment_nodes[is].push_back(last_node_pt);
        
       } // iterator over the elements in the segment
      
     } // for (is < nsegments)
    
   } // for (if (nel > 0))
  
  // Free memory allocation
  for (unsigned e = 0; e < nel; e++)
   {
    delete face_el_pt[e];
    face_el_pt[e] = 0;
   } // for (e < nel)
  
 }

//======================================================================
/// Adapt problem based on specified elemental error estimates
/// This function implement serial and parallel mesh adaptation, the
/// sections for parallel mesh adaptation are clearly identified by
/// checking whether the mesh is distributed or not
//======================================================================
 template <class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::adapt(
  const Vector<double>& elem_error)
 {
  double t_start_overall=TimingHelpers::timer();
  
  // ==============================================================
  // BEGIN: Compute target areas
  // ==============================================================
  
  // Get refinement targets
  Vector<double> target_area(elem_error.size());
  double min_angle=compute_area_target(elem_error,
                                       target_area);
  
  // Post-process to allow only quantised target areas
  // in an attempt to more closely mimick the structured
  // case and limit the diffusion of small elements.
  bool quantised_areas=true;
  if (quantised_areas)
   {
    unsigned n=target_area.size();
    double total_area=0;
    // If the mesh is distributed then we need to get the contribution
    // of all processors to compute the total areas
    // ------------------------------------------
    // DISTRIBUTED MESH: BEGIN
    // ------------------------------------------
#ifdef OOMPH_HAS_MPI
    if (this->is_mesh_distributed())
     {
      // When working in parallel we get the total area from the sum
      // of the the sub-areas of all the meshes
      double sub_area = 0.0;
      
      // Only add the area of nonhalo elements
      for (unsigned e=0;e<n;e++)
       {
        // Get the pointer to the element
        FiniteElement* ele_pt = this->finite_element_pt(e);
        if (!ele_pt->is_halo())
         {
          sub_area+=ele_pt->size();
         }
       } // for (e<n)
      
      // Get the communicator of the mesh
      OomphCommunicator* comm_pt = this->communicator_pt();
      
      // Get the total area
      MPI_Allreduce(&sub_area, &total_area, 1, MPI_DOUBLE, MPI_SUM, 
                    comm_pt->mpi_comm());        
     }
    else
     {
      for (unsigned e=0;e<n;e++)
       {
        total_area+=this->finite_element_pt(e)->size();
       }  
     }
    // ------------------------------------------
    // DISTRIBUTED MESH: END
    // ------------------------------------------
#else // #ifdef OOMPH_HAS_MPI
    for (unsigned e=0;e<n;e++)
     {
      total_area+=this->finite_element_pt(e)->size();
     }
#endif // #ifdef OOMPH_HAS_MPI
    
    for (unsigned e=0;e<n;e++)
     {
      unsigned level=
       unsigned(ceil(log(target_area[e]/total_area)/log(1.0/3.0)))-1;
      double new_target_area=total_area*pow(1.0/3.0,int(level));
      target_area[e]=new_target_area;
     }
    
   }
  
  // std::ofstream tmp;
  // tmp.open((Global_string_for_annotation:: String[0]+"overall_target_areas"+
  //               StringConversion::to_string(Global_unsigned::Number)+".dat").c_str());
  
  // Get maximum target area
  unsigned n=target_area.size();
  double max_area=0.0;
  double min_area=DBL_MAX;
  for (unsigned e=0;e<n;e++)
   {
    if (target_area[e]>max_area) max_area=target_area[e];
    if (target_area[e]<min_area) min_area=target_area[e];
    
    // tmp << (finite_element_pt(e)->node_pt(0)->x(0)+
    //            finite_element_pt(e)->node_pt(1)->x(0)+
    //           finite_element_pt(e)->node_pt(2)->x(0))/3.0 << " "
    //        << (finite_element_pt(e)->node_pt(0)->x(1)+
    //            finite_element_pt(e)->node_pt(1)->x(1)+
    //            finite_element_pt(e)->node_pt(2)->x(1))/3.0 << " "
    //        << target_area[e] << " " 
    //        << finite_element_pt(e)->size() << " "
    //        << elem_error[e]  << " " << std::endl;
   }
  
  //tmp.close();
  
  oomph_info << "Maximum target area: " << max_area << std::endl;
  oomph_info << "Minimum target area: " << min_area << std::endl;
  oomph_info << "Number of elements to be refined: "
             << this->Nrefined << std::endl;
  oomph_info << "Number of elements to be unrefined: "
             << this->Nunrefined << std::endl;
  oomph_info << "Min. angle: " << min_angle << std::endl;

  double orig_max_area, orig_min_area;
  this->max_and_min_element_size(orig_max_area, orig_min_area);
  oomph_info << "Max./min. element size in original mesh: "
             << orig_max_area << " "
             << orig_min_area << std::endl;
  
  // ==============================================================
  // END: Compute target areas
  // ==============================================================
  
  // Check if boundaries need to be updated (regardless of
  // requirements of bulk error estimator) but don't do anything!
  bool check_only=true;
  bool outer_boundary_update_necessary= false;
  bool inner_boundary_update_necessary= false;
  bool inner_open_boundary_update_necessary=false;
  
  // Get the number of outer boundaries and check if they require
  // update
  const unsigned nouter=this->Outer_boundary_pt.size();
  
  if (this->is_automatic_creation_of_vertices_on_boundaries_allowed())
   {
    // loop over the outer boundaries
    for (unsigned i_outer = 0; i_outer < nouter; i_outer++)
     {
      outer_boundary_update_necessary=
       this->update_polygon_using_face_mesh(this->Outer_boundary_pt[i_outer], 
                                            check_only);
      // Break the loop if at least one needs updating
      if (outer_boundary_update_necessary) break;
     }
    
    // Do not waste time if we already know that it is necessary an update
    // on the boundary representation
    if (!outer_boundary_update_necessary)
     {
      // Check if we need to generate a new 1D mesh representation of
      // the inner hole boundaries
      const unsigned nhole=this->Internal_polygon_pt.size();
      Vector<Vector<double> > internal_point_coord(nhole);
      inner_boundary_update_necessary=
       this->surface_remesh_for_inner_hole_boundaries(internal_point_coord,
                                                      check_only);
      
      // If there was not necessary a change even on the internal closed
      // curve then finally check for the open curves as well
      if (!inner_boundary_update_necessary)
	{
        const unsigned n_open_polyline = 
	  this->Internal_open_curve_pt.size();
	// loop over the open polylines
        for (unsigned i = 0; i < n_open_polyline; i++)
         {
          inner_open_boundary_update_necessary=
           this->update_open_curve_using_face_mesh(
            this->Internal_open_curve_pt[i], check_only);
          // If at least one needs modification then break the for loop
          if (inner_open_boundary_update_necessary) break;
         }
       }
     }
   }
  
  // Flag to indicate whether we need to adapt or not (for parallel
  // mesh adaptation only)
  int adapt_all = 0;
  // ------------------------------------------
  // DISTRIBUTED MESH: BEGIN
  // ------------------------------------------
#ifdef OOMPH_HAS_MPI
  // When working in distributed meshes we need to ensure that all the
  // processors take part on the adaptation process. If at least one
  // of the processors requires adaptation then all processor take
  // part on the adaptation process.
  int adapt_this_processor = 0;
  if (this->is_mesh_distributed())
   {
    // Do this processor requires adaptation?
    if ( (Nrefined > 0) || (Nunrefined > max_keep_unrefined()) ||
         (min_angle < min_permitted_angle())
         || (outer_boundary_update_necessary)
         || (inner_boundary_update_necessary)
         || (inner_open_boundary_update_necessary) )
     {adapt_this_processor = 1;}
    
    // Get the communicator of the mesh
    OomphCommunicator* comm_pt = this->communicator_pt();
    
    // Verify if at least one processor needs mesh adaptation
    MPI_Allreduce(&adapt_this_processor, &adapt_all, 1, MPI_INT, MPI_SUM, 
                  comm_pt->mpi_comm());
   }
#endif
  // ------------------------------------------
  // DISTRIBUTED MESH: END
  // ------------------------------------------
  
  // Should we bother to adapt?
  if ( (Nrefined > 0) || (Nunrefined > max_keep_unrefined()) ||
       (min_angle < min_permitted_angle()) || (outer_boundary_update_necessary)
       || (inner_boundary_update_necessary)
       || (inner_open_boundary_update_necessary) || (adapt_all) )
   {
    if (! ( (Nrefined > 0) || (Nunrefined > max_keep_unrefined()) ) )
     {

      if ( (outer_boundary_update_necessary)
           || (inner_boundary_update_necessary)
           || (inner_open_boundary_update_necessary) )
       {
        oomph_info
         << "Mesh regeneration triggered by inaccurate interface/surface\n"
         << "representation; setting Nrefined to number of elements.\n"
         << "outer_boundary_update_necessary     : " 
         << outer_boundary_update_necessary << "\n"
         << "inner_boundary_update_necessary     : "
         << inner_boundary_update_necessary << "\n"
         << "inner_open_boundary_update_necessary: "
         << inner_open_boundary_update_necessary << "\n"; 
        Nrefined=nelement();
       }
      else
       {
        oomph_info
         << "Mesh regeneration triggered by min angle criterion;\n"
         << "setting Nrefined to number of elements.\n";
        Nrefined=nelement();
       }
     }
    
    // ------------------------------------------
    // DISTRIBUTED MESH: BEGIN
    // ------------------------------------------
#ifdef OOMPH_HAS_MPI
    else if (this->is_mesh_distributed() && 
             adapt_this_processor == 0 && adapt_all > 0)
     {
      oomph_info
       << "Mesh regeneration triggered by (" << adapt_all << ") processor(s) "
       << "that require(s)\n adaptation\n";
     }
#endif
    // ------------------------------------------
    // DISTRIBUTED MESH: END
    // ------------------------------------------
    
    // ==============================================================
    // BEGIN: Updating of boundaries representation (unrefinement and
    // refinement of polylines)
    // ==============================================================
    
    // Add the initial and final vertices of the polylines that
    // present connections to a list of non-delete-able vertices. The
    // vertices where the connections are performed cannot be deleted
    add_vertices_for_non_deletion();
    
    // ------------------------------------------
    // DISTRIBUTED MESH: BEGIN
    // ------------------------------------------
#ifdef OOMPH_HAS_MPI
    // Synchronise connections for shared boundaries among
    // processors. This is required since one of the processor may noy
    // know that some of its shared boundaries have connections, thus
    // the vertices receiving the connections cannot be deleted
    if (this->is_mesh_distributed())
     {
      synchronize_shared_boundary_connections();
     }
#endif // #ifdef OOMPH_HAS_MPI
    // ------------------------------------------
    // DISTRIBUTED MESH: END
    // ------------------------------------------
    
    // Are we allowing automatic insertion of vertices on boundaries?
    // If YES then Triangle automatically insert points along
    // boundaries, if NOT, then points are inserted along the
    // boundaries based on the target areas of boundary elements. When
    // the mesh is distributed the automatic insertion of vertices by
    // Triangle along the boundaries is not allowed
    if (this->is_automatic_creation_of_vertices_on_boundaries_allowed())
     {
      //Generate a new 1D mesh representation of the inner hole boundaries
      unsigned nhole=this->Internal_polygon_pt.size();
      Vector<Vector<double> > internal_point_coord(nhole);
      this->surface_remesh_for_inner_hole_boundaries(internal_point_coord);
      
      //Update the representation of the outer boundary
      for (unsigned i_outer = 0; i_outer < nouter; i_outer++)
       {
        this->update_polygon_using_face_mesh(
         this->Outer_boundary_pt[i_outer]);
       }
      
      // After updating outer and internal closed boundaries it is also
      // necessary to update internal boundaries.
      unsigned n_open_polyline = this->Internal_open_curve_pt.size();
      for (unsigned i = 0; i < n_open_polyline; i++)
       {
        this->update_open_curve_using_face_mesh(
         this->Internal_open_curve_pt[i]);
       }
      
     }
    else
     {      
      // Update the representation of the internal boundaries using
      // the element's target area
       
      // Get the number of interal polygons
      const unsigned ninternal=this->Internal_polygon_pt.size();
      for (unsigned i_internal = 0; i_internal < ninternal; i_internal++)
       {
        this->update_polygon_using_elements_area(
         this->Internal_polygon_pt[i_internal], target_area);
       }
      
      // Update the representation of the outer boundaries using the
      // element's target area
      for (unsigned i_outer = 0; i_outer < nouter; i_outer++)
       {
        this->update_polygon_using_elements_area(
         this->Outer_boundary_pt[i_outer], target_area);
       }
      
      // Update the representation of the internal open boundaries
      // using the element's target areas
      const unsigned n_open_polyline = this->Internal_open_curve_pt.size();
      for (unsigned i = 0; i < n_open_polyline; i++)
       {
        this->update_open_curve_using_elements_area(
         this->Internal_open_curve_pt[i], target_area);
       }
      
      // ------------------------------------------
      // DISTRIBUTED MESH: BEGIN
      // ------------------------------------------
      
      // When working with a distributed mesh we require to update the
      // boundary representation of the shared boundaries, this is
      // based on the target areas of the elements adjaced to the
      // shared boundaries
#ifdef OOMPH_HAS_MPI
      // Update shared boundaries if the mesh is distributed
      if (this->is_mesh_distributed())
       {
        // Get the rank of the current processor
        const unsigned my_rank = this->communicator_pt()->my_rank();
        
        // Get the number of shared curves
        const unsigned n_curves = this->nshared_boundary_curves(my_rank);
        // Loop over the shared curves in the current processor
        for (unsigned nc = 0; nc < n_curves; nc ++)
         {
          // Update the shared polyline
          this->update_shared_curve_using_elements_area(
           this->Shared_boundary_polyline_pt[my_rank][nc],//shared_curve,
           target_area);
         }
        
       } // if (this->is_mesh_distributed())
#endif
      
      // ------------------------------------------
      // DISTRIBUTED MESH: END
      // ------------------------------------------
      
     } // else if (this->is_automatic_creation_of_vertices_on_boundaries_allowed())
    
    // ==============================================================
    // END: Updating of boundaries representation (unrefinement and
    // refinement of polylines)
    // ==============================================================
    
    // ==============================================================
    // BEGIN: Reset boundary coordinates for boundaries with no
    // associated GeomObject
    // ==============================================================
    
    //If there is not a geometric object associated with the boundary
    //then reset the boundary coordinates so that the lengths are
    //consistent in the new mesh and the old mesh.
    const unsigned n_boundary = this->nboundary();
    
    const double t_start_first_stage_segments_connectivity = 
     TimingHelpers::timer();
    
    // ------------------------------------------
    // DISTRIBUTED MESH: BEGIN
    // ------------------------------------------
#ifdef OOMPH_HAS_MPI
    // Clear storage for assignment of initial zeta values for
    // boundaries
    if (this->is_mesh_distributed())
     {
      this->Assigned_segments_initial_zeta_values.clear();
     }
#endif // #ifdef OOMPH_HAS_MPI
    // ------------------------------------------
    // DISTRIBUTED MESH: END
    // ------------------------------------------
    
    // Loop over the boundaries to assign boundary coordinates
    for(unsigned b=0;b<n_boundary;++b)
     {
      // ------------------------------------------
      // DISTRIBUTED MESH: BEGIN
      // ------------------------------------------
#ifdef OOMPH_HAS_MPI
      if (this->is_mesh_distributed())
       {
        // In a distributed mesh, the boundaries may have been split
        // across processors during the distribution process, thus we
        // need to compute the connectivity among the segments of the
        // boundary to correctly assign its boundary coordinates
        this->
         compute_boundary_segments_connectivity_and_initial_zeta_values(b);
       }
#endif
      // ------------------------------------------
      // DISTRIBUTED MESH: END
      // ------------------------------------------
      
      // Does the boundary has an associated GeomObject
      if(this->boundary_geom_object_pt(b)==0)
       {
        this->template setup_boundary_coordinates<ELEMENT>(b);
       }
      
      // ------------------------------------------
      // DISTRIBUTED MESH: BEGIN
      // ------------------------------------------
#ifdef OOMPH_HAS_MPI
      if (this->is_mesh_distributed())
       {
        // Synchronise boundary coordinates for internal open curves,
        // also establish the boundary coordinates for the nodes on
        // the corners of elements not on the boundary
        this->synchronize_boundary_coordinates(b);
       }
#endif
      // ------------------------------------------
      // DISTRIBUTED MESH: END
      // ------------------------------------------
      
     } // for (b<n_boundary)
    
    const double t_total_first_stage_segments_connectivity = 
     TimingHelpers::timer() - t_start_first_stage_segments_connectivity;
    
    // ==============================================================
    // END: Reset boundary coordinates for boundaries with no
    // associated GeomObject
    // ==============================================================
    
    // ------------------------------------------
    // DISTRIBUTED MESH: BEGIN
    // ------------------------------------------
#ifdef OOMPH_HAS_MPI
    // ==============================================================
    // BEGIN: Create the new representation of the domain by joining
    // the original boundaries and the shared boundaries.
    // ==============================================================
    
    // Storage for the new temporary polygons "closed" by the shared
    // boundaries
    Vector<TriangleMeshPolygon *> tmp_outer_polygons_pt;
    
    // Storage for the new temporary open curves, could be the
    // original open curves or "chunks" of the original open curves
    // not overlapped by shared boundaries
    Vector<TriangleMeshOpenCurve *> tmp_open_curves_pt;
    
    if (this->is_mesh_distributed())
     {
      // Create the new polygons and open curves with help of the
      // original polylines and shared polylines
      this->create_distributed_domain_representation(tmp_outer_polygons_pt,
                                                     tmp_open_curves_pt);
      
      // Create the connections of the temporary domain representations
      this->create_temporary_boundary_connections(tmp_outer_polygons_pt,
                                                  tmp_open_curves_pt);
     }
    // ==============================================================
    // END: Create the new representation of the domain by joining
    // the original boundaries and the shared boundaries.
    // ==============================================================
#endif
    // ------------------------------------------
    // DISTRIBUTED MESH: END
    // ------------------------------------------
    
    // Re-establish polylines' connections. The boundary
    // representation has changed (new polylines), therefore we need
    // to update the connection information
    Vector<TriangleMeshPolyLine*> resume_initial_connection_polyline_pt;
    Vector<TriangleMeshPolyLine*> resume_final_connection_polyline_pt;
    restore_boundary_connections(resume_initial_connection_polyline_pt,
                                 resume_final_connection_polyline_pt);
    
    // Update the region information by setting the coordinates from the
    // centroid of the first element in each region (which should allow
    // automatic updates when the regions deform)
    {
     unsigned n_region = this->nregion();
     if(n_region > 1)
      {
       for(std::map<unsigned, Vector<double> >::iterator it =
            this->Regions_coordinates.begin();
           it!=this->Regions_coordinates.end(); ++it)
        {
         //Storage for the approximate centroid
         Vector<double> centroid(2,0.0);

         //Get the region id
         unsigned region_id = it->first;

         //Report information
         oomph_info << "Region " << region_id << ": "
                    << it->second[0] << " " << it->second[1] << " ";
         
         //Check that there is at least one element in the region
         unsigned n_region_element = this->nregion_element(region_id);
         if(n_region_element > 0)
          {
           //Cache pointer to the first element
           FiniteElement* const elem_pt = this->region_element_pt(region_id,0);

           //Loop over the corners of the triangle and average
           for(unsigned n=0;n<3;n++)
            {
             Node* const nod_pt = elem_pt->node_pt(n);
             for(unsigned i=0;i<2;i++) {centroid[i] += nod_pt->x(i);}
            }
           for(unsigned i=0;i<2;i++) {centroid[i] /= 3;} 
           //Now we have the centroid set it
           it->second = centroid;

           oomph_info << "   ,    " << 
            it->second[0] << " " << it->second[1] << std::endl;
          } //end of case when there is at least one element
	 
        } // loop over regions coordinates
       
      } // if(n_region > 1)
     
    } // Updating region info.
    
    // ==============================================================
    // BEGIN: Create background mesh
    // ==============================================================
    
    // Are we dealing with a solid mesh?
    SolidMesh* solid_mesh_pt=dynamic_cast<SolidMesh*>(this);
    
    // Build temporary uniform background mesh
    //----------------------------------------
    // with area set by maximum required area
    //---------------------------------------
    RefineableTriangleMesh<ELEMENT>* tmp_new_mesh_pt=0;
    
    // The storage for the new temporary boundaries representation to
    // create the background mesh
    Vector<TriangleMeshClosedCurve*> closed_curve_pt;
    Vector<TriangleMeshClosedCurve*> hole_pt;
    Vector<TriangleMeshOpenCurve*> open_curves_pt;
    
#ifdef OOMPH_HAS_MPI
    if (!this->is_mesh_distributed())
#endif
     {
      // Copy the outer boundaries
      closed_curve_pt.resize(nouter);
      for (unsigned i = 0; i < nouter; i++)
       {
        closed_curve_pt[i] = this->Outer_boundary_pt[i];
       }
      
      // Copy the internal closed boundaries (may be holes)
      const unsigned n_holes = this->Internal_polygon_pt.size();
      hole_pt.resize(n_holes);
      for (unsigned i = 0; i < n_holes; i++)
       {
        hole_pt[i] = this->Internal_polygon_pt[i];
       }
      
      // Copy the internal open curves
      const unsigned n_open_curves = this->Internal_open_curve_pt.size();
      open_curves_pt.resize(n_open_curves);
      for (unsigned i = 0; i < n_open_curves; i++)
       {
        open_curves_pt[i] = this->Internal_open_curve_pt[i];
       }
     }
    // ------------------------------------------
    // DISTRIBUTED MESH: BEGIN
    // ------------------------------------------
#ifdef OOMPH_HAS_MPI
    else
     {
      // Copy the new representation of the outer/internal closed
      // boundaries
      const unsigned n_tmp_outer = tmp_outer_polygons_pt.size();
      closed_curve_pt.resize(n_tmp_outer);
      for (unsigned i = 0; i < n_tmp_outer; i++)
       {
        closed_curve_pt[i] = tmp_outer_polygons_pt[i];
       }
      
      // Copy the new representation of the internal open curves
      const unsigned n_open_curves = tmp_open_curves_pt.size();
      open_curves_pt.resize(n_open_curves);
      for (unsigned i = 0; i < n_open_curves; i++)
       {
        open_curves_pt[i] = tmp_open_curves_pt[i];
       }
      
     }
#endif
    // ------------------------------------------
    // DISTRIBUTED MESH: END
    // ------------------------------------------
    
    // ----------------------------------------------------------------
    // Gather all the information and use the TriangleMeshParameters
    // object which help us on the manage of all TriangleMesh object's
    // information
    
    // Create the TriangleMeshParameters objects with the outer boundary
    // as the only one parameter
    TriangleMeshParameters triangle_mesh_parameters(closed_curve_pt);
    
    // Pass information about the holes
    triangle_mesh_parameters.internal_closed_curve_pt() = hole_pt;
    
    // Pass information about the internal open boundaries
    triangle_mesh_parameters.internal_open_curves_pt() = open_curves_pt;
    
    // Set the element area
    triangle_mesh_parameters.element_area() = max_area;
    
    // Pass information about the extra holes (not defined with closed
    // boundaries)
    triangle_mesh_parameters.extra_holes_coordinates() =
     this->Extra_holes_coordinates;
    
    //Pass information about regions
    triangle_mesh_parameters.regions_coordinates() = 
     this->Regions_coordinates;
    
    //Pass information about the using of regions
    if (this->Use_attributes)
     {
      triangle_mesh_parameters.enable_use_attributes();
     }
    
    //Pass information about allowing the creation of new points
    if (!this->is_automatic_creation_of_vertices_on_boundaries_allowed())
     {
      triangle_mesh_parameters.disable_automatic_creation_of_vertices_on_boundaries();
     }
    
    // When the mesh is distributed we need to create a distributed
    // background mesh
#ifdef OOMPH_HAS_MPI
    if (this->is_mesh_distributed())
     {
      // Mark the mesh to be created as distributed by passing a
      // pointer to the communicator
      triangle_mesh_parameters.set_communicator_pt(this->communicator_pt());
     }
#endif
    
    // ----------------------------------------------------------
    // Build the background mesh using Triangle
    // ----------------------------------------------------------
    const double t_start_building_background_mesh = 
      TimingHelpers::timer();
    
    if (solid_mesh_pt!=0)
     {
      tmp_new_mesh_pt=new RefineableSolidTriangleMesh<ELEMENT>
       (triangle_mesh_parameters, this->Time_stepper_pt);
     }
    else
     {
      tmp_new_mesh_pt=new RefineableTriangleMesh<ELEMENT>
       (triangle_mesh_parameters, this->Time_stepper_pt);
     }
    
    if (Print_timings_level_adaptation>2)
      {
        oomph_info << "CPU for building background mesh: "
                   <<TimingHelpers::timer()-t_start_building_background_mesh
                   << std::endl;
      }
    
    // Pass the info. regarding the maximum and minimum element size
    // from the old mesh to the background mesh
    const double this_max_element_size = this->max_element_size();
    const double this_min_element_size = this->min_element_size();
    tmp_new_mesh_pt->max_element_size() = this_max_element_size;
    tmp_new_mesh_pt->min_element_size() = this_min_element_size;
    
    // ... also copy the minimum permitted angle
    const double this_min_permitted_angle = this->min_permitted_angle();
    tmp_new_mesh_pt->min_permitted_angle() = this_min_permitted_angle;
    
    // ------------------------------------------
    // DISTRIBUTED MESH: BEGIN
    // ------------------------------------------
#ifdef OOMPH_HAS_MPI
    // If the mesh is distributed we need to pass and set the
    // information of internal boundaries overlaped by shared
    // boundaries
    if (this->is_mesh_distributed())
     {
      // Check if necessary to fill boundary elements for those
      // internal boundaries that overlap shared boundaries
      if (this->nshared_boundary_overlaps_internal_boundary() > 0)
       {
        // Copy the data structures that indicates which shared
        // boundaries are part of an internal boundary
        tmp_new_mesh_pt->shared_boundary_overlaps_internal_boundary() = 
         this->shared_boundary_overlaps_internal_boundary();
        
        // Copy the data structure that indicates which are the shared
        // boundaries in each processor
        tmp_new_mesh_pt->shared_boundaries_ids() = 
         this->shared_boundaries_ids();
        
        // Fill the structures for the boundary elements and face indexes
        // of the boundary elements
        tmp_new_mesh_pt->
         fill_boundary_elements_and_nodes_for_internal_boundaries();
        
       } // if (this->nshared_boundary_overlaps_internal_boundary() > 0)
      
     } // if (this->is_mesh_distributed())
#endif // #ifdef OOMPH_HAS_MPI
    // ------------------------------------------
    // DISTRIBUTED MESH: END
    // ------------------------------------------    
    
    // Snap to curvilinear boundaries (some code duplication as this
    // is repeated below but helper function would take so many
    // arguments that it's nearly as messy...
    
    //Pass the boundary geometric objects to the new mesh
    tmp_new_mesh_pt->boundary_geom_object_pt() =
     this->boundary_geom_object_pt();
    
    //Reset the boundary coordinates if there is
    //a geometric object associated with the boundary
    tmp_new_mesh_pt->boundary_coordinate_limits() =
     this->boundary_coordinate_limits();
    
    const double t_start_second_stage_segments_connectivity = 
      TimingHelpers::timer();
    
    for (unsigned b=0;b<n_boundary;b++)
     {
      // ------------------------------------------
      // DISTRIBUTED MESH: BEGIN
      // ------------------------------------------
#ifdef OOMPH_HAS_MPI
      if (this->is_mesh_distributed())
       {
        // Identify the segments of the new mesh with the ones of the
        // original mesh
        tmp_new_mesh_pt->
         identify_boundary_segments_and_assign_initial_zeta_values(b,this);
       }
#endif
      // ------------------------------------------
      // DISTRIBUTED MESH: END
      // ------------------------------------------
      
      // Setup boundary coordinates for boundaries with GeomObject
      // associated
      if(tmp_new_mesh_pt->boundary_geom_object_pt(b)!=0)
       {
        tmp_new_mesh_pt->template setup_boundary_coordinates<ELEMENT>(b);
       }
      
     }
    
    const double t_total_second_stage_segments_connectivity = 
      TimingHelpers::timer() - t_start_second_stage_segments_connectivity;
    
    const double t_start_snap_nodes_bg_mesh=TimingHelpers::timer();
    //Move the nodes on the new boundary onto the old curvilinear
    //boundary. If the boundary is straight this will do precisely
    //nothing but will be somewhat inefficient
    for(unsigned b=0;b<n_boundary;b++)
     {
      this->snap_nodes_onto_boundary(tmp_new_mesh_pt,b);
     }
    
    const double t_total_snap_nodes_bg_mesh=
      TimingHelpers::timer()-t_start_snap_nodes_bg_mesh;
    
    if (Print_timings_level_adaptation>2)
      {
        oomph_info<< "CPU for snapping nodes onto boundaries "
                  << "(background mesh): "
		  << t_total_snap_nodes_bg_mesh << std::endl;
      }
    
    // Update mesh further?
    if(Mesh_update_fct_pt!=0)
     {
      Mesh_update_fct_pt(tmp_new_mesh_pt);
     }
    
    //If we have a continuation problem 
    //any problem in which the timestepper is a "generalisedtimestepper",
    //which will have been set by the problem, then ensure
    //all data in the new mesh has the appropriate timestepper
    /*if(dynamic_cast<GeneralisedTimeStepper*>(this->Time_stepper_pt))
      {
      tmp_new_mesh_pt->set_nodal_and_elemental_time_stepper(
      this->Time_stepper_pt);
      tmp_new_mesh_pt->set_mesh_level_time_stepper(this->Time_stepper_pt);
      }*/
    
    
    //tmp_new_mesh_pt->output("mesh_nodes_snapped_0.dat"); 
    //this->output("existing_mesh.dat"); 
    
    // ==============================================================
    // END: Create background mesh
    // ==============================================================
    
    // ==============================================================
    // BEGIN: Transferring of target areas and creation of new mesh
    // ==============================================================
    
    // Get the TriangulateIO object associated with that mesh
     TriangulateIO tmp_new_triangulateio =
      tmp_new_mesh_pt->triangulateio_representation();
     RefineableTriangleMesh<ELEMENT>* new_mesh_pt = 0;

     // If the mesh is a solid mesh then do the mapping based on the
     // Eulerian coordinates
     bool use_eulerian_coords=false;
     if (solid_mesh_pt!=0)
      {
       use_eulerian_coords=true;
      }


#ifdef OOMPH_HAS_CGAL

     // Make cgal-based bin
     CGALSamplePointContainerParameters cgal_params(this);
     if (use_eulerian_coords)
      {
       cgal_params.enable_use_eulerian_coordinates_during_setup();
      }
     MeshAsGeomObject* mesh_geom_obj_pt=new MeshAsGeomObject(&cgal_params);
     
#else

     // Make nonrefineable bin
     NonRefineableBinArrayParameters params(this); 
     if (use_eulerian_coords)
      {
       params.enable_use_eulerian_coordinates_during_setup();
      }
     Vector<unsigned> bin_dim(2);
     bin_dim[0]=Nbin_x_for_area_transfer;
     bin_dim[1]=Nbin_y_for_area_transfer;
     params.dimensions_of_bin_array()=bin_dim;
     MeshAsGeomObject* mesh_geom_obj_pt=new MeshAsGeomObject(&params);
     
#endif

    // Set up a map from pointer to element to its number
    // in the mesh
    std::map<GeneralisedElement*,unsigned> element_number;
    unsigned nelem=this->nelement();
    for (unsigned e=0;e<nelem;e++)
     {
      element_number[this->element_pt(e)]=e;
     }

#ifndef OOMPH_HAS_CGAL

    // Create a vector to store the min target area of each bin (at
    // this stage the number of bins should not be that large, so it
    // should be safe to build a vector for the total number of bins)
    Vector<double> bin_min_target_area;
    
    // Get pointer to sample point container
    NonRefineableBinArray* bin_array_pt=
     dynamic_cast<NonRefineableBinArray*>(mesh_geom_obj_pt->
                                          sample_point_container_pt());
    if (bin_array_pt==0)
     {
      throw OomphLibError(
       "Sample point container has to be NonRefineableBinArray",
       OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
     }

    {
     unsigned n_bin=0;
     unsigned max_n_entry=0;
     unsigned min_n_entry=UINT_MAX;
     unsigned tot_n_entry=0;
     unsigned n_empty=0;
     bin_array_pt->get_fill_stats(n_bin,max_n_entry,min_n_entry,
                                  tot_n_entry,n_empty);
     
     oomph_info << "Before bin diffusion:"
                << " nbin:("<<n_bin<<")"
                << " nempty:("<<n_empty<<")"
                << " min:("<<min_n_entry<<")"
                << " max:("<<max_n_entry<<")"
                << " average entries:("
                << double(tot_n_entry)/double(n_bin)<<")"
                << std::endl;
    }
    
    // Fill bin by diffusion
    double t0_bin_diff=TimingHelpers::timer();
    oomph_info << "Going into diffusion bit...\n";
    bin_array_pt->fill_bin_by_diffusion();
    oomph_info << "Back from diffusion bit...\n";
    oomph_info << "Time for bin diffusion: "
               << TimingHelpers::timer()-t0_bin_diff
               << std::endl;
    
    // Do some stats
    {
     unsigned n_bin=0;
     unsigned max_n_entry=0;
     unsigned min_n_entry=UINT_MAX;
     unsigned tot_n_entry=0;
     unsigned n_empty=0;
     bin_array_pt->get_fill_stats(n_bin,max_n_entry,min_n_entry,
                                  tot_n_entry,n_empty);
     
     oomph_info << "After bin diffusion:"
                << " nbin:("<<n_bin<<")"
                << " nempty:("<<n_empty<<")"
                << " min:("<<min_n_entry<<")"
                << " max:("<<max_n_entry<<")"
                << " average entries:("
                << double(tot_n_entry)/double(n_bin)<<")"
                << std::endl;
    }
    
    
    // For each bin, compute the minimum of the target areas in the bin
    
    // Timing for map
    double t_total_map=0.0;
    
    // Counter for map
    unsigned counter_map = 0;
    
    // Get access to the bins (we need access to the content of the
    // bins to compute the minimum of the target areas of the elements
    // in each bin)
    const std::map<unsigned,Vector<std::pair<FiniteElement*,
                                             Vector<double> > > >*
     bins_pt=bin_array_pt->get_all_bins_content();
    
    // Get the number of bins
    const unsigned n_bin=bins_pt->size();
    
    // Create a vector to store the min target area of each bin (at
    // this stage the number of bins should not be that large, so it
    // should be safe to build a vector for the total number of bins)
    bin_min_target_area.resize(n_bin);
    for (unsigned u=0;u<n_bin;u++)
     {
      bin_min_target_area[u]=0.0;
     }
    // loop over the bins, get their elements and compute the minimum
    // target area of all of them
    typedef std::map<unsigned,
                     Vector<std::pair<FiniteElement*,
                                      Vector<double> > > >::const_iterator IT;
    for (IT it=bins_pt->begin();it!=bins_pt->end();it++)
     {
      // The bin number
      unsigned ib=(*it).first;
      
      // Get the number of elements in the bin
      const unsigned n_ele_bin = (*it).second.size();
      
      // loop over the elements in the bin
      for (unsigned ee=0;ee<n_ele_bin;ee++)
       {
        // Get ee-th element (in currrent mesh) in ib-th bin
        GeneralisedElement* ele_pt=(*it).second[ee].first;
        double t_map=TimingHelpers::timer();
        const unsigned ele_number = element_number[ele_pt];
        t_total_map+=TimingHelpers::timer()-t_map;
        
        // Increase the number of calls to map
        counter_map++;
        
        // Go for smallest target area of any element in this bin to
        // force "one level" of refinement (the one-level-ness is
        // enforced below by limiting the actual reduction in area
        if (bin_min_target_area[ib]!=0)
         {
          bin_min_target_area[ib]=
           std::min(bin_min_target_area[ib], target_area[ele_number]);
         }
        else
         {
          bin_min_target_area[ib]=target_area[ele_number];
         }
        
       } // for (ee<n_ele_bin)
      
     } // for (it!=bins.end())
    
    oomph_info << "CPU for map[counter="<<counter_map<<"]: "
               << t_total_map << std::endl;
    
    
    // Optional output for debugging (keep it around!)
    const bool output_bins=false;
    if (output_bins)
     {
      unsigned length=bin_min_target_area.size();
      for (unsigned u = 0;u<length;u++)
       {
        oomph_info << "Bin n" << u << ",target area: "
                   << bin_min_target_area[u]<<std::endl;
       }
     }
    
#endif


    // Now start iterating to refine mesh recursively
    //-----------------------------------------------
    bool done=false;
    unsigned iter=0;
#ifdef OOMPH_HAS_MPI
    // The number of elements that require (un)refinement
    unsigned n_ele_need_refinement = 0;
#endif
    
    // The timing for the third stage of segments connectivity
    double t_total_third_stage_segments_connectivity = 0.0;
    
    // The timing for the transfering target areas
    double t_total_transfer_target_areas = 0.0;
    
    // The timing for the copying of target areas
    double t_total_limit_target_areas = 0.0;
    
    // The timing to create the new mesh
    double t_total_create_new_adapted_mesh = 0.0;

    // The timing for the snapping of the nodes on the new meshes
    double t_total_snap_nodes = 0.0;
    
    // The timing to check whether other processors need to adapt
    double t_total_wait_other_processors = 0.0;
    double t_iter=TimingHelpers::timer();
    while (!done)
    {
     // Accept by default but overwrite if things go wrong below
     done=true;
     
     double t_start_transfer_target_areas=TimingHelpers::timer();
     double t0_loop_int_pts=TimingHelpers::timer();
     
     // Loop over elements in new (tmp) mesh and visit all
     // its integration points. Check where it's located in the bin
     // structure of the current mesh and pass the target area
     // to the new element
     nelem=tmp_new_mesh_pt->nelement();

     // Store the target areas for elements in the temporary
     // TriangulateIO mesh
     Vector<double> new_transferred_target_area(nelem,0.0);
     for (unsigned e=0;e<nelem;e++)
      { // start loop el
       ELEMENT* el_pt=dynamic_cast<ELEMENT*>(tmp_new_mesh_pt->element_pt(e));
       unsigned nint=el_pt->integral_pt()->nweight();
       for (unsigned ipt=0;ipt<nint;ipt++)
        {
         // Get the coordinate of current point
         Vector<double> s(2);
         for(unsigned i=0;i<2;i++)
          {
           s[i] = el_pt->integral_pt()->knot(ipt,i);
          }
         
         Vector<double> x(2);
         el_pt->interpolated_x(s,x);
         
#if OOMPH_HAS_CGAL

         // Try the five nearest sample points for Newton search
         // then just settle on the nearest one
         GeomObject* geom_obj_pt=0;
         unsigned max_sample_points=
          Max_sample_points_for_limited_locate_zeta_during_target_area_transfer;
         dynamic_cast<CGALSamplePointContainer*>(mesh_geom_obj_pt->
                                                 sample_point_container_pt())->
          limited_locate_zeta(x,max_sample_points,
                              geom_obj_pt,s);
#ifdef PARANOID
         if (geom_obj_pt==0)
          {
           std::stringstream error_message;
           error_message
            << "Limited locate zeta failed for zeta = [ "
            << x[0] << " " << x[1] << " ]. Makes no sense!\n";
           throw OomphLibError(error_message.str(),
                               OOMPH_CURRENT_FUNCTION,
                               OOMPH_EXCEPTION_LOCATION);
          }
         else
          {
#endif
           FiniteElement* fe_pt=dynamic_cast<FiniteElement*>(geom_obj_pt);
#ifdef PARANOID
           if (fe_pt==0)
            {
             std::stringstream error_message;
             error_message
              << "Cast to FE for GeomObject returned by limited locate zeta failed for zeta = [ "
              << x[0] << " " << x[1] << " ]. Makes no sense!\n";
             throw OomphLibError(error_message.str(),
                                 OOMPH_CURRENT_FUNCTION,
                                 OOMPH_EXCEPTION_LOCATION);
            }
           else
            {
#endif
             // What's the target area of the element that contains this point
             double tg_area=target_area[element_number[fe_pt]];

             // Go for smallest target area over all integration 
             // points in new element
             // to force "one level" of refinement (the one-level-ness
             // is enforced below by limiting the actual reduction in
             // area
             if (new_transferred_target_area[e]!=0)
              {
               new_transferred_target_area[e]=
                std::min(new_transferred_target_area[e], 
                         tg_area);
              }
             else
              {
               new_transferred_target_area[e]=tg_area;
              }
#ifdef PARANOID
            }
          }
#endif

#else

         // Find the bin that contains that point and its contents
         int bin_number=0;
         bin_array_pt->get_bin(x,bin_number);
         
         // Did we find it?
         if (bin_number<0)
          {
           // Not even within bin boundaries... odd
           std::stringstream error_message;
           error_message
            << "Very odd -- we're looking for a point[ "
            << x[0] << " " << x[1] << " ] that's not even \n"
            << "located within the bin boundaries.\n";
           throw OomphLibError(error_message.str(),
                               "RefineableTriangleMesh::adapt()",
                               OOMPH_EXCEPTION_LOCATION);
          } // if (bin_number<0)
         else
          {            
           // Go for smallest target area of any element in this bin
           // to force "one level" of refinement (the one-level-ness
           // is enforced below by limiting the actual reduction in
           // area
           if (new_transferred_target_area[e]!=0)
            {
             new_transferred_target_area[e]=
              std::min(new_transferred_target_area[e], 
                       bin_min_target_area[bin_number]);
            }
           else
            {
             new_transferred_target_area[e]=bin_min_target_area[bin_number];
            }
           
          }
        
#endif

        } // for (ipt<nint)
       
      } // for (e<nelem)

          
     // do some output (keep it alive!)
     const bool output_target_areas=false;
     if (output_target_areas)
      {
       unsigned length=new_transferred_target_area.size();
       for (unsigned u = 0; u < length;u++)
        {
         oomph_info << "Element" << u << ",target area: "
                    << new_transferred_target_area[u] << std::endl;
        }
      }
     oomph_info << "Time for loop over integration points in new mesh: "
                << TimingHelpers::timer()-t0_loop_int_pts  
                << std::endl;
     
    
      // {
      // tmp.open((Global_string_for_annotation:: String[0]+"binned_target_areas"+
      //               StringConversion::to_string(Global_unsigned::Number)+".dat").c_str());
  
      // Vector<Vector<std::pair<FiniteElement*,Vector<double> > > > bin_content=
      //  mesh_geom_obj_pt->bin_content();
      // unsigned nbin=bin_content.size();
      // for (unsigned b=0;b<nbin;b++)
      //  {
      //   unsigned nentry=bin_content[b].size();
      //   for (unsigned entry=0;entry<nentry;entry++)
      //    {
      //     FiniteElement* el_pt=bin_content[b][entry].first;
      //     GeneralisedElement* gen_el_pt=bin_content[b][entry].first;
      //     Vector<double> s=bin_content[b][entry].second;
      //     Vector<double> x(2);
      //     el_pt->interpolated_x(s,x);
      //     unsigned e_current=element_number[gen_el_pt];
      //     tmp << x[0] << " " << x[1] << " " 
      //             << target_area[e_current] << " " 
      //             << el_pt->size() << " " 
      //             << std::endl;
      //    }
      //  }
      // tmp.close();
      // }
      
      const double t_sub_total_transfer_target_areas = 
        TimingHelpers::timer()-t_start_transfer_target_areas;
      
      if (Print_timings_level_adaptation>2)
        {
          // Get the number of elements in the old mesh (this)
          const unsigned n_element = this->nelement();
          // Get the number of elements in the background mesh
          const unsigned n_element_background = tmp_new_mesh_pt->nelement();
          
          oomph_info << "CPU for transfer of target areas "
                     << "[n_ele_old_mesh="
                     << n_element <<", n_ele_background_mesh="
                     << n_element_background<<"] (iter "<< iter << "): "
                     << t_sub_total_transfer_target_areas<< std::endl;
        }
      
      // Add the timing for tranfer of target areas
      t_total_transfer_target_areas+=t_sub_total_transfer_target_areas;
      
      // // Output mesh
      // tmp_new_mesh_pt->output(("intermediate_mesh"+
      //                         StringConversion::to_string(iter)+".dat").c_str()); 
      
      // tmp.open((Global_string_for_annotation:: String[0]+"target_areas_intermediate_mesh_iter"+
      //               StringConversion::to_string(iter)+"_"+
      //               StringConversion::to_string(Global_unsigned::Number)+".dat").c_str());
      
      const double t_start_limit_target_areas = TimingHelpers::timer();
      
      // Now copy into target area for temporary mesh but limit to
      // the equivalent of one sub-division per iteration
#ifdef OOMPH_HAS_MPI
      unsigned n_ele_need_refinement_iter = 0;
#endif 


      // Don't delete! Keep these around for debugging
      // ofstream tmp_mesh_file;
      // tmp_mesh_file.open("tmp_mesh_file.dat");
      // tmp_new_mesh_pt->output(tmp_mesh_file);
      // tmp_mesh_file.close();
      // ofstream target_areas_file;
      // target_areas_file.open("target_areas_file.dat");

      const unsigned nel_new=tmp_new_mesh_pt->nelement();
      Vector<double> new_target_area(nel_new);   
      for (unsigned e=0;e<nel_new;e++)
       {
        // The finite element
        FiniteElement* f_ele_pt = tmp_new_mesh_pt->finite_element_pt(e);

        // Transferred target area
        const double new_area=new_transferred_target_area[e];
        if (new_area<=0.0)
         {
          std::ostringstream error_stream;
          error_stream << "This shouldn't happen! Element whose centroid is at "
                       <<  (f_ele_pt->node_pt(0)->x(0)+
                            f_ele_pt->node_pt(1)->x(0)+
                            f_ele_pt->node_pt(2)->x(0))/3.0 << " "
                       << (f_ele_pt->node_pt(0)->x(1)+
                           f_ele_pt->node_pt(1)->x(1)+
                           f_ele_pt->node_pt(2)->x(1))/3.0 << " "
                       << " has no target area assigned\n";
          throw OomphLibError(error_stream.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
         }
        else
         {


          // Limit target area to the equivalent of uniform refinement
          // during this stage of the iteration
          new_target_area[e]=new_area;
          if (new_target_area[e]<f_ele_pt->size()/3.0)
           {
            new_target_area[e]=f_ele_pt->size()/3.0;
	    
            // We'll need to give it another go later
            done=false;
            
           } 
          
          // Don't delete! Keep around for debugging
          // target_areas_file 
          //  <<  (f_ele_pt->node_pt(0)->x(0)+
          //       f_ele_pt->node_pt(1)->x(0)+
          //       f_ele_pt->node_pt(2)->x(0))/3.0 << " "
          //  << (f_ele_pt->node_pt(0)->x(1)+
          //      f_ele_pt->node_pt(1)->x(1)+
          //      f_ele_pt->node_pt(2)->x(1))/3.0 << " "
          //  << new_area << " " 
          //  << new_target_area[e] << std::endl;



#ifdef OOMPH_HAS_MPI
          // Keep track of the elements that require (un)refinement
          n_ele_need_refinement_iter++;
#endif
          
         } // else if (new_area <= 0.0)
                
       } // for (e < nel_new)


      // Don't delete! Keep around for debugging
      // target_areas_file.close();   

      const double t_sub_total_limit_target_areas = 
        TimingHelpers::timer() - t_start_limit_target_areas;
      
      // Add the timing for copying target areas
      t_total_limit_target_areas+=t_sub_total_limit_target_areas;
      
      if (Print_timings_level_adaptation>2)
        {
          // Get the number of elements in the old mesh (this)
          const unsigned n_element = this->nelement();
          // Get the number of elements in the background mesh
          const unsigned n_element_background = tmp_new_mesh_pt->nelement();
          
          oomph_info << "CPU for limiting target areas "
                     << "[n_ele_old_mesh="
                     << n_element <<", n_ele_background_mesh="
                     << n_element_background<<"] (iter "<< iter << "): "
                     << t_sub_total_limit_target_areas<< std::endl;
        }
      
      if (done) 
       {
        oomph_info 
         << "All area adjustments accommodated by max. permitted area"
         << " reduction \n";
       }
      else
       {
         oomph_info 
          << "NOT all area adjustments accommodated by max. "
          << "permitted area reduction \n";
       }
      
      //tmp.close();
      //pause("doced binned_target_areas.dat and intermediate mesh targets");
      
      // Now create the new mesh from TriangulateIO structure
      //-----------------------------------------------------
      // associated with uniform background mesh and the
      //------------------------------------------------
      // associated target element sizes.
      //---------------------------------
      
      const double t_start_create_new_adapted_mesh = 
        TimingHelpers::timer();
      
      // Solid mesh?
      if (solid_mesh_pt!=0)
       {
        new_mesh_pt=new RefineableSolidTriangleMesh<ELEMENT>
	  (new_target_area,
	   tmp_new_triangulateio,
	   this->Time_stepper_pt,
	   this->Use_attributes,
	   this->Allow_automatic_creation_of_vertices_on_boundaries,
	   this->communicator_pt());
       }
      // No solid mesh
      else
       {
        new_mesh_pt=new RefineableTriangleMesh<ELEMENT>
         (new_target_area,
          tmp_new_triangulateio,
          this->Time_stepper_pt,
          this->Use_attributes,
          this->Allow_automatic_creation_of_vertices_on_boundaries,
          this->communicator_pt());
       }
      
      // Sub-total to create new adapted mesh
      const double t_sub_total_create_new_adapted_mesh = 
        TimingHelpers::timer() - t_start_create_new_adapted_mesh;
      
      // Add the time to the total snap nodes time
      t_total_create_new_adapted_mesh+=t_sub_total_create_new_adapted_mesh;
      
      if (Print_timings_level_adaptation>2)
        {
          // Get the number of elements of the new adapted mesh
          const unsigned n_element_new_adapted_mesh = new_mesh_pt->nelement();
          
          oomph_info << "CPU for creation of new adapted mesh "
                     << t_sub_total_create_new_adapted_mesh
                     << "[nele="<<n_element_new_adapted_mesh
                     << "] (iter "<< iter << "): "
                     << t_sub_total_create_new_adapted_mesh << std::endl;
        }
      
#ifdef OOMPH_HAS_MPI
      // ------------------------------------------
      // DISTRIBUTED MESH: BEGIN
      // ------------------------------------------
      
      // This section is only required if we are dealing with
      // distributed meshes, otherwise there are not shared boundaries
      // overlapping internal boundaries
      
      // Check if necessary to fill boundary elements for those internal
      // boundaries that overlap shared boundaries
      if (this->nshared_boundary_overlaps_internal_boundary() > 0)
       {
        // Copy the data structures that indicate which shared
        // boundaries are part of an internal boundary
        new_mesh_pt->shared_boundary_overlaps_internal_boundary() = 
         this->shared_boundary_overlaps_internal_boundary();
	
        // Copy the data structure that indicates which are the shared 
        // boundaries in each processor
        new_mesh_pt->shared_boundaries_ids() = 
         this->shared_boundaries_ids();
        
        // Fill the structures for the boundary elements and face indexes
        // of the boundary elements
        new_mesh_pt->
         fill_boundary_elements_and_nodes_for_internal_boundaries();
       }
      // ------------------------------------------
      // DISTRIBUTED MESH: END
      // ------------------------------------------
#endif // #ifdef OOMPH_HAS_MPI      

      // Snap to curvilinear boundaries (some code duplication as this
      // is repeated below but helper function would take so many
      // arguments that it's nearly as messy...
      
      //Pass the boundary geometric objects to the new mesh 
      new_mesh_pt->boundary_geom_object_pt() = 
       this->boundary_geom_object_pt();
      
      // Reset the boundary coordinates if there is
      // a geometric object associated with the boundary
      new_mesh_pt->boundary_coordinate_limits() =
       this->boundary_coordinate_limits();
      
      const double t_start_third_stage_segments_connectivity = 
       TimingHelpers::timer();
      
      for (unsigned b=0;b<n_boundary;b++)
       {
        // ------------------------------------------
        // DISTRIBUTED MESH: BEGIN
        // ------------------------------------------
         
        // Before setting up boundary coordinates for the new mesh we
        // require to identify the segments with the old mesh to
        // assign initial zeta values
#ifdef OOMPH_HAS_MPI        
        if (this->is_mesh_distributed())
         {
          // Identify the segments of the new mesh with the ones of
          // the original mesh
          new_mesh_pt->
           identify_boundary_segments_and_assign_initial_zeta_values(b,this);
         }
#endif
        // ------------------------------------------
        // DISTRIBUTED MESH: END
        // ------------------------------------------
        
        // Setup boundary coordinates for boundaries with GeomObject
        // associated
        if(new_mesh_pt->boundary_geom_object_pt(b)!=0)
         {
          new_mesh_pt->template setup_boundary_coordinates<ELEMENT>(b);
         }
        
       }
      
      t_total_third_stage_segments_connectivity+=
        TimingHelpers::timer() - t_start_third_stage_segments_connectivity;
      
      const double t_start_snap_nodes_new_mesh=TimingHelpers::timer();
      //Move the nodes on the new boundary onto the old curvilinear
      //boundary. If the boundary is straight this will do precisely
      //nothing but will be somewhat inefficient
      for(unsigned b=0;b<n_boundary;b++)
       {
        this->snap_nodes_onto_boundary(new_mesh_pt,b);
       }
      
      const double t_sub_total_snap_nodes_new_mesh = 
        TimingHelpers::timer() - t_start_snap_nodes_new_mesh;
      
      // Add the time to the total snap nodes time
      t_total_snap_nodes+=t_sub_total_snap_nodes_new_mesh;
      
      if (Print_timings_level_adaptation>2)
        {
          oomph_info << "CPU for snapping nodes onto boundaries (new mesh) "
                     << "(iter "<<iter<<"): "
                     << t_sub_total_snap_nodes_new_mesh<< std::endl;
        }
      
      // Update mesh further?
      if (Mesh_update_fct_pt!=0)
       {
        Mesh_update_fct_pt(new_mesh_pt);
       }
      
      //If we have a continuation problem 
      //any problem in which the timestepper is a "generalisedtimestepper",
      //which will have been set by the problem, then ensure
      //all data in the new mesh has the appropriate timestepper
      if(dynamic_cast<GeneralisedTimeStepper*>(this->Time_stepper_pt))
       {
        new_mesh_pt->set_nodal_and_elemental_time_stepper(
         this->Time_stepper_pt,false);
        new_mesh_pt->set_mesh_level_time_stepper(this->Time_stepper_pt,false);
       }
      
      // Not done: get ready for another iteration
      iter++;
      delete tmp_new_mesh_pt;
      
#ifdef OOMPH_HAS_MPI
      // Check whether the number of elements that need (un)refinement
      // from the previous iteration is the same, if that is the case
      // then we mark this processor as done
      if (n_ele_need_refinement_iter == n_ele_need_refinement)
       {done = true;}
      // Update the number of elements that require further
      // (un)refinement
      n_ele_need_refinement = n_ele_need_refinement_iter;
#endif // #ifdef OOMPH_HAS_MPI
      
      // ------------------------------------------
      // DISTRIBUTED MESH: BEGIN
      // ------------------------------------------
      
      // We can only finish the iteration adaptation process if ALL
      // the involved processor are marked as done, otherwise, ALL
      // processor need to go for another iteration
#ifdef OOMPH_HAS_MPI
      if (this->is_mesh_distributed())
       {
        // Time to check whether other processors have finish to adapt
        const double t_start_wait_other_processors = TimingHelpers::timer();
        
        // In case that the mesh is distributed it is necessary to
        // verify that no processor requires further refinement. If at
        // least one processor needs more refinement then all
        // processors need to go for another iteration to participate
        // in the communications
        unsigned this_processor_requires_another_iteration = 1;
        
        // Is this processor done?
        if (done){this_processor_requires_another_iteration = 0;}
        int nproc_not_done = this_processor_requires_another_iteration;
        // Get the communicator of the mesh
        OomphCommunicator* comm_pt = this->communicator_pt();
        // Communicate with all procesoors to check whether we need to
        // re-iterate
        MPI_Allreduce(&this_processor_requires_another_iteration,
                      &nproc_not_done,1,
                      MPI_UNSIGNED,MPI_SUM,comm_pt->mpi_comm());
        // Are all processors done?
        if (nproc_not_done > 0)
         {
          oomph_info << "At least one processors requires further refinement. "
		     << "Go for another iteration." << std::endl;
          done = false;
         }
        
        // Total to check whether other processors have finish to
        // adapt
        const double t_sub_total_wait_other_processors = 
         TimingHelpers::timer() - t_start_wait_other_processors;
        
        // Add to the total timings to check whether other processors
        // need to adapt
        t_total_wait_other_processors+=t_sub_total_wait_other_processors;
        
        if (Print_timings_level_adaptation>2)
         {
          oomph_info << "CPU for waiting other processors "
                     << "(iter "<<iter<<"): "
                     << t_sub_total_wait_other_processors 
                     << std::endl;
         }
        
       } // if (this->is_mesh_distributed())
#endif
      // ------------------------------------------
      // DISTRIBUTED MESH: END
      // ------------------------------------------
      
      if (!done)
       {
        oomph_info << "Going for another iteration. Current iteration ("
		   << iter << ")" << std::endl;

        // Use the new mesh as the tmp mesh
        tmp_new_mesh_pt=new_mesh_pt;
        tmp_new_triangulateio=new_mesh_pt->triangulateio_representation();
       }
      
     } // end of iteration (while (!done))

    //Delete the temporary geometric object representation of the
    //current mesh
    delete mesh_geom_obj_pt;
    
    oomph_info << "CPU for iterative generation of new mesh (TOTAL): " 
               << TimingHelpers::timer()-t_iter
               << std::endl;
    
    if (Print_timings_level_adaptation>1)
      {
        oomph_info << "-- CPU for creating new adapted meshes (TOTAL): "
                   << t_total_create_new_adapted_mesh << std::endl;
        
        oomph_info << "-- CPU for limiting target areas (TOTAL): "
                   << t_total_limit_target_areas << std::endl;
        
        oomph_info << "-- CPU for transferring target areas (TOTAL): "
                   << t_total_transfer_target_areas << std::endl;
        
        oomph_info << "-- CPU for waiting other processors (TOTAL): "
                   << t_total_wait_other_processors << std::endl;
      }
    
    // ==============================================================
    // END: Transferring of target areas and creation of new mesh
    // ==============================================================
    
    // ==============================================================
    // BEGIN: Project solution from the old to the new mesh
    // ==============================================================
    
    // Check that the projection step is not disabled
    if (!Disable_projection)
     {
      // Take the time for the projection step
      double tt_start_projection=TimingHelpers::timer();
      
      // Print info. for tranfering target areas
      if (Print_timings_projection)
       {
        // Switch timings and stats on
        Multi_domain_functions::Doc_timings=true;
        Multi_domain_functions::Doc_stats=true;
        Multi_domain_functions::Doc_full_stats=true;
       }
      
      double t_proj=TimingHelpers::timer();
      oomph_info << "About to begin projection.\n";
      
      // Project current solution onto new mesh
      //---------------------------------------
      ProjectionProblem<ELEMENT>* project_problem_pt=
       new ProjectionProblem<ELEMENT>;
      
      // Projection requires to be enabled as distributed if working
      // with a distributed mesh
#ifdef OOMPH_HAS_MPI
      if (this->is_mesh_distributed())
       {
        // ------------------------------------------
        // DISTRIBUTED MESH: BEGIN
        // ------------------------------------------
         
        // We need to back up the time stepper object since the
        // projection class creates a new one
        Time* backed_up_time_pt = this->Time_stepper_pt->time_pt();
        
        // Set the projection problem as distributed
        project_problem_pt->enable_problem_distributed();
        
        // Pass the time stepper to the projection problem (used when
        // setting multi_domain_interation)
        project_problem_pt->add_time_stepper_pt(this->Time_stepper_pt);
        
        // Set the mesh used for the projection object
        project_problem_pt->mesh_pt()=new_mesh_pt;
        //project_problem_pt->disable_suppress_output_during_projection();
        
        // Use iterative solver for projection? By default, an iterative
        // solver is used for the projection stage
        if(!this->use_iterative_solver_for_projection())
         {
          project_problem_pt->disable_use_iterative_solver_for_projection();
         }
        
        // Do the projection
        project_problem_pt->project(this);
        
        // Reset the time stepper object (only affects distributed meshes)
        this->Time_stepper_pt->time_pt() = backed_up_time_pt;
        
        // ------------------------------------------
        // DISTRIBUTED MESH: END
        // ------------------------------------------
        
       } // if (this->is_mesh_distributed())
      else
#endif // #ifdef OOMPH_HAS_MPI
       {
        // Set the mesh used for the projection object
        project_problem_pt->mesh_pt()=new_mesh_pt;
        
        // project_problem_pt->disable_suppress_output_during_projection();
        
        // Use iterative solver for projection? By default, an iterative
        // solver is used for the projection stage
        if(!this->use_iterative_solver_for_projection())
         {
          project_problem_pt->disable_use_iterative_solver_for_projection();
         }
        
        // Do the projection
        project_problem_pt->project(this);
       }
      
      // Reset printing info. for projection
      if (Print_timings_projection)
       {
        // Switch timings and stats off
        Multi_domain_functions::Doc_timings=false;
        Multi_domain_functions::Doc_stats=false;
        Multi_domain_functions::Doc_full_stats=false;
       }
      
      // Get the total time for projection
      const double tt_projection = TimingHelpers::timer()-tt_start_projection;
      
      if (Print_timings_level_adaptation>1)
       {
        // Get the number of elements in the old mesh (this)
        const unsigned n_element = this->nelement();
        // Get the number of elements in the new mesh
        const unsigned n_element_new = new_mesh_pt->nelement();
        oomph_info << "CPU for projection (in mesh adaptation) "
                   << "[n_ele_old_mesh="<< n_element 
                   <<", n_ele_new_mesh="<< n_element_new<<"]: " 
                   << tt_projection << std::endl;
        
        // ------------------------------------------
        // DISTRIBUTED MESH: BEGIN
        // ------------------------------------------
#ifdef OOMPH_HAS_MPI
        if (this->is_mesh_distributed())
         {
          // The maximum number of elements in the mesh (over all
          // processors)
          unsigned n_this_element_new = n_element_new;
          unsigned n_max_element_new_global = 0;
          // Get the maximum number of elements over all processors
          MPI_Reduce(&n_this_element_new, &n_max_element_new_global,
                     1, MPI_UNSIGNED, MPI_MAX, 0,
                     this->communicator_pt()->mpi_comm());
          
          // The time for projection for this processor
          double tt_this_projection = tt_projection;
          double tt_global_min_projection = 0.0;
          double tt_global_max_projection = 0.0;
          
          // Get the minimum and maximum time for projection
          MPI_Reduce(&tt_this_projection, &tt_global_min_projection,
                     1, MPI_DOUBLE, MPI_MIN, 0,
                     this->communicator_pt()->mpi_comm());
          MPI_Reduce(&tt_this_projection, &tt_global_max_projection,
                     1, MPI_DOUBLE, MPI_MAX, 0,
                     this->communicator_pt()->mpi_comm());
          
          if (this->communicator_pt()->my_rank() == 0)
           {
            oomph_info << "CPU for projection global (MIN): "
                       << tt_global_min_projection << std::endl;
            oomph_info << "CPU for projection global (MAX) "
                       << "[n_max_ele_new_global="
                       << n_max_element_new_global<<"]: "
                       << tt_global_max_projection << std::endl;
            
            std::cerr << "CPU for projection global (MIN): "
                      << tt_global_min_projection << std::endl;
            std::cerr << "CPU for projection global (MAX): "
                      << "[n_max_ele_new_global="
                      << n_max_element_new_global<<"]: "
                      << tt_global_max_projection << std::endl;
            
           }
          
         }
#endif // #ifdef OOMPH_HAS_MPI
        // ------------------------------------------
        // DISTRIBUTED MESH: END
        // ------------------------------------------
        
       } // if (Print_timings_level_adaptation>1)
            
      oomph_info << "CPU for projection of solution onto new mesh: " 
                 << TimingHelpers::timer()-t_proj
                 << std::endl;

      // Delete the projection problem
      delete project_problem_pt;
      
     } // if (!Disable_projection)
    else
     {
      oomph_info << "Projection disabled! The new mesh will contain zeros"
                 << std::endl;
     }
    
    // ==============================================================
    // END: Project solution from the old to the new mesh
    // ==============================================================
    
    double t_rest=TimingHelpers::timer();
    
    //Flush the old mesh 
    unsigned nnod=nnode();
    for(unsigned j=nnod;j>0;j--)
     {
      delete Node_pt[j-1];
      Node_pt[j-1] = 0;
     }
    unsigned nel=nelement();
    for(unsigned e=nel;e>0;e--)
     {
      delete Element_pt[e-1];
      Element_pt[e-1] = 0;
     }
    
    // Now copy back to current mesh
    //------------------------------
    nnod=new_mesh_pt->nnode();
    Node_pt.resize(nnod);
    nel=new_mesh_pt->nelement();
    Element_pt.resize(nel);
    for(unsigned j=0;j<nnod;j++)
     {
      Node_pt[j] = new_mesh_pt->node_pt(j);
     }
    for(unsigned e=0;e<nel;e++)
     {
      Element_pt[e] = new_mesh_pt->element_pt(e);
     }
    
    // Copy the boundary elements information from the new mesh to the
    // original mesh
    unsigned nbound = 0;
    
#ifdef OOMPH_HAS_MPI
    // If working with a distributed mesh we need to change the number
    // of boundaries so that shared boundaries information is also
    // copied from the old to the new mesh
    if (this->is_mesh_distributed())
     {
      // The boundaries to be copied include those new ones in the new
      // mesh (shared boundaries). This info. is required to
      // re-establish the halo/haloed scheme
      nbound = new_mesh_pt->nboundary();
      // After halo and haloed scheme has been re-established the
      // number of boundaries is changed to the original number of
      // boundaries
     }
    else
#endif
     {
      // The original number of boundaries
      nbound = n_boundary;
     }
    
    Boundary_element_pt.resize(nbound);
    Face_index_at_boundary.resize(nbound);
    Boundary_node_pt.resize(nbound);
    for (unsigned b=0;b<nbound;b++)
     {
      unsigned nel=new_mesh_pt->nboundary_element(b);
      Boundary_element_pt[b].resize(nel);
      Face_index_at_boundary[b].resize(nel);
      for (unsigned e=0;e<nel;e++)
       {
        Boundary_element_pt[b][e]=new_mesh_pt->boundary_element_pt(b,e);
        Face_index_at_boundary[b][e]=new_mesh_pt->face_index_at_boundary(b,e);
       }
      unsigned nnod=new_mesh_pt->nboundary_node(b);
      Boundary_node_pt[b].resize(nnod);
      for (unsigned j=0;j<nnod;j++)
       {
        Boundary_node_pt[b][j]=new_mesh_pt->boundary_node_pt(b,j);
       }
     }
    
    //Also copy over the new boundary and region information
    unsigned n_region = new_mesh_pt->nregion();
    // Only bother if we have regions
    if(n_region > 1)
     {
      //Deal with the region information first
      this->Region_attribute.resize(n_region);
      for(unsigned r=0;r<n_region;r++)
       {
        this->Region_attribute[r] = new_mesh_pt->region_attribute(r);
        // Get the region id
        unsigned r_id = static_cast<unsigned>(this->Region_attribute[r]);
        //Find the number of elements in the region
        unsigned n_region_element = new_mesh_pt->nregion_element(r_id);
        this->Region_element_pt[r_id].resize(n_region_element);
        for(unsigned e=0;e<n_region_element;e++)
         {
          this->Region_element_pt[r_id][e] = 
           new_mesh_pt->region_element_pt(r_id,e);
         }
       }

      //Now the boundary region information
      this->Boundary_region_element_pt.resize(nbound);
      this->Face_index_region_at_boundary.resize(nbound);

      //Now loop over the boundaries
      for(unsigned b=0;b<nbound;++b)
       {
        for (unsigned rr = 0 ; rr < n_region; rr++)
         {
          // The region id
          unsigned r = static_cast<unsigned>(this->Region_attribute[rr]);
          
          unsigned n_boundary_el_in_region =
           new_mesh_pt->nboundary_element_in_region(b,r);

          if(n_boundary_el_in_region > 0)
           {
            //Allocate storage in the map
            this->Boundary_region_element_pt[b][r].
             resize(n_boundary_el_in_region);
            this->Face_index_region_at_boundary[b][r].
             resize(n_boundary_el_in_region);

            //Copy over the information
            for(unsigned e=0;e<n_boundary_el_in_region;++e)
             {
              this->Boundary_region_element_pt[b][r][e]
               = new_mesh_pt->boundary_element_in_region_pt(b,r,e);
              this->Face_index_region_at_boundary[b][r][e]
               = new_mesh_pt->face_index_at_boundary_in_region(b,r,e);
             }
           }
         }
       } //End of loop over boundaries

     } //End of case when more than one region
    
    // ------------------------------------------
    // DISTRIBUTED MESH: BEGIN
    // ------------------------------------------
    
    // Re-generate halo(ed) information (only for distributed meshes)
#ifdef OOMPH_HAS_MPI
    if (this->is_mesh_distributed())
     {      
      // Delete halo(ed) information in the original mesh, the new
      // halo(ed) information is generated usign the info. of the new
      // mesh
      if (this->is_mesh_distributed())
       {
        this->Halo_node_pt.clear();
        this->Root_halo_element_pt.clear();
      
        this->Haloed_node_pt.clear();
        this->Root_haloed_element_pt.clear();
      
        this->External_halo_node_pt.clear();
        this->External_halo_element_pt.clear();
      
        this->External_haloed_node_pt.clear();
        this->External_haloed_element_pt.clear();
       }
      
      // Re-establish the shared boundary elements and nodes scheme
      // before re-establish halo(ed) information
      this->reset_shared_boundary_elements_and_nodes();
      
      // -------------------------------------------------------------
      // Remove shared boundary elements and nodes from original
      // boundary elements and boundary nodes containers. Shared
      // boundary elements and nodes are stored in a special
      // container.
      
      // Get the shared boundaries in this processor with any other
      // processor
      Vector<unsigned> my_rank_shared_boundaries_ids;
      this->shared_boundaries_in_this_processor(my_rank_shared_boundaries_ids);
      
      // Get the number of shared boundaries
      const unsigned nmy_rank_shd_bnd = my_rank_shared_boundaries_ids.size();
      // Loop over the shared boundaries marked as original boundaries
      // in tmp_new_mesh
      for (unsigned i = 0; i < nmy_rank_shd_bnd; i++)
       {
        // Get the boundary id
        const unsigned shd_bnd_id = my_rank_shared_boundaries_ids[i];
        // Flush any previous relation of shared boundary elements
        // marked as original boundary elements in tmp_new_mesh
        this->Boundary_element_pt[shd_bnd_id].clear();
        
        // Get the number of nodes associated with the original
        // boundary in tmp_new_mesh that is a shared boundary
        const unsigned tmp_nnodes = 
         this->nshared_boundary_node(shd_bnd_id);
        for (unsigned n = 0; n < tmp_nnodes; n++)
         {
          Node* tmp_node_pt = this->boundary_node_pt(shd_bnd_id, n);
          tmp_node_pt->remove_from_boundary(shd_bnd_id);
         } // for (n < nnodes)
        
       } // for (shd_bnd_id < nmy_rank_shd_bnd)
      
      // Re-set the number of boundaries to the original one
      this->set_nboundary(n_boundary);
      
      // Sort the nodes on the boundaries so that they have the same
      // order on all the boundaries
      this->sort_nodes_on_shared_boundaries();
      
      // Re-set the halo(ed) scheme
      this->reset_halo_haloed_scheme();
      
      // Set the correct number of segments for the boundaries with
      // geom objects associated
      for (unsigned b = 0; b < n_boundary; b++)
       {
        if (this->boundary_geom_object_pt(b)!=0)
         {
          const unsigned nsegments = new_mesh_pt->nboundary_segment(b);
          this->set_nboundary_segment_node(b, nsegments);
         }
       }
      
      // Resume the connections in boundaries were it was suspended
      resume_boundary_connections(resume_initial_connection_polyline_pt,
                                  resume_final_connection_polyline_pt);

     } // if (this->is_mesh_distributed())
    
#endif // #ifdef OOMPH_HAS_MPI
    
    // ------------------------------------------
    // DISTRIBUTED MESH: END
    // ------------------------------------------
    
    //Snap the newly created nodes onto any geometric objects
    this->snap_nodes_onto_geometric_objects();
    
    // Copy the IDs of the vertex nodes
    this->Oomph_vertex_nodes_id=new_mesh_pt->oomph_vertex_nodes_id();
    
    // Copy TriangulateIO representation
    TriangleHelper::clear_triangulateio(this->Triangulateio);
    bool quiet=true;
    this->Triangulateio=
     TriangleHelper::deep_copy_of_triangulateio_representation(
      new_mesh_pt->triangulateio_representation(),quiet);
    
    // Flush the mesh
    new_mesh_pt->flush_element_and_node_storage();
    
    // Delete the mesh
    delete new_mesh_pt;
    
    // Resume of timings
    if (Print_timings_level_adaptation>2)
     {
      // Report timings related with setting boundary coordinates of
      // nodes on segments
      oomph_info << "CPU for segments connectivity (first stage) [sec]: "
                 << t_total_first_stage_segments_connectivity << std::endl;
      oomph_info << "CPU for segments connectivity (second stage) [sec]: "
                 << t_total_second_stage_segments_connectivity << std::endl;
      oomph_info << "CPU for segments connectivity (third stage) [sec]: "
                 << t_total_third_stage_segments_connectivity << std::endl;
     }        
    
    if (Print_timings_level_adaptation>1)
     {
      const double t_total_segments_connectivity = 
       t_total_first_stage_segments_connectivity +
       t_total_second_stage_segments_connectivity +
       t_total_third_stage_segments_connectivity;
      
      oomph_info << "CPU for segments connectivity (TOTAL) [sec]: "
                 << t_total_segments_connectivity << std::endl;
      
      if (Print_timings_level_adaptation>2)
       {
        // Report timings for snapping of nodes onto boundaries
        oomph_info << "CPU for snapping nodes onto boundaries "
                   << "(new mesh): "
                   << t_total_snap_nodes << std::endl;
       }
      
      t_total_snap_nodes+=t_total_snap_nodes_bg_mesh;
      oomph_info << "CPU for snapping nodes onto boundaries (TOTAL): "
                 << t_total_snap_nodes << std::endl;
     }
    
    double max_area=0.0;
    double min_area=0.0;
    
    this->max_and_min_element_size(max_area, min_area);
    oomph_info << "Max/min element size in adapted mesh: "
               << max_area << " "
               << min_area << std::endl;
    
    oomph_info << "CPU time for final bits [sec]: " 
               << TimingHelpers::timer()-t_rest
               << std::endl;
   }
  else
   {
    oomph_info << "Not enough benefit in adaptation.\n";
    Nrefined=0;
    Nunrefined=0;
   }
  
  double CPU_for_adaptation = TimingHelpers::timer()-t_start_overall;
  oomph_info <<"CPU time for adaptation [sec]: "
	     << CPU_for_adaptation << std::endl;
  
  // ------------------------------------------
  // DISTRIBUTED MESH: BEGIN
  // ------------------------------------------  
#ifdef OOMPH_HAS_MPI
  if (this->is_mesh_distributed())
   {
    // Get the communicator
    OomphCommunicator* comm_pt = this->communicator_pt();
    // Get the total number of processors to compute the average
    const unsigned n_proc = comm_pt->nproc();
    if (Print_timings_level_adaptation>1 && n_proc>1)
     {
      double global_min_CPU_for_adaptation = 0.0;
      double global_max_CPU_for_adaptation = 0.0;
      double global_average_CPU_for_adaptation = 0.0;
      
      // Get the maximum and minimum of the adaptation times
      MPI_Reduce(&CPU_for_adaptation, &global_min_CPU_for_adaptation,
                 1, MPI_DOUBLE, MPI_MIN, 0, comm_pt->mpi_comm());
      MPI_Reduce(&CPU_for_adaptation, &global_max_CPU_for_adaptation,
                 1, MPI_DOUBLE, MPI_MAX, 0, comm_pt->mpi_comm());
      MPI_Reduce(&CPU_for_adaptation, &global_average_CPU_for_adaptation,
                 1, MPI_DOUBLE, MPI_SUM, 0, comm_pt->mpi_comm());
      
      // Get the rank of the processor
      const unsigned my_rank = comm_pt->my_rank();
      if (my_rank==0)
       {
        oomph_info << "CPU for adaptation (MIN): "
                   << global_min_CPU_for_adaptation << std::endl;
        oomph_info << "CPU for adaptation (MAX): "
                   << global_max_CPU_for_adaptation << std::endl;
        oomph_info << "CPU for adaptation (AVERAGE): "
                   << global_average_CPU_for_adaptation/n_proc << std::endl;
       } // if (my_rank==0)
      
     } // if (Print_timings_level_adaptation>1&&n_proc>1)
    
   } // if (this->is_mesh_distributed())
  
  // ------------------------------------------
  // DISTRIBUTED MESH: END
  // ------------------------------------------
  
#endif // #ifdef OOMPH_HAS_MPI
 


 }

//=========================================================================
 /// \ short Mark the vertices that are not allowed for deletion by
 /// the unrefienment/refinement polyline methods. In charge of
 /// filling the Boundary_connections_pt structure
 //=========================================================================
 template<class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::add_vertices_for_non_deletion()
 {
   // Clear any previous information
   //Boundary_chunk_connections_pt.clear();
   Boundary_connections_pt.clear();
   
   // Loop over the boundaries in the domain (outer, internal -- closed
  // and open ---, and shared) and get the boundaries ids with
  // connections (have or receive)
  
  // Store the boundaries ids that have or receive connection
  std::set<unsigned> boundary_id_with_connections;
  
  // ------------------------------------------------------------------
  // Outer boundaries
  // ------------------------------------------------------------------
  
  // Get the number of outer boundaries (closed boundaries)
  const unsigned n_outer_boundaries = this->Outer_boundary_pt.size();
  
  // Loop over the outer boundaries
  for (unsigned i = 0; i < n_outer_boundaries; i++)
   {
    // Get a temporary polygon representation
    TriangleMeshPolygon* tmp_polygon_pt = this->Outer_boundary_pt[i];
    // Get the number of polylines associated to the current outer
    // boundary
    const unsigned n_polyline = tmp_polygon_pt->npolyline();
    // Loop over the polylines
    for (unsigned p = 0; p < n_polyline; p++)
     {
      // Get a temporary representation of the polyline
      TriangleMeshPolyLine* tmp_polyline_pt = 
       tmp_polygon_pt->polyline_pt(p);
      
      // Is the initial vertex connected?
      if (tmp_polyline_pt->is_initial_vertex_connected())
       {
        // Get the boundary id of the current polyline
        const unsigned bnd_id = tmp_polyline_pt->boundary_id();
        
        // Include the boundary id to the set of boundaries with
        // connections
        boundary_id_with_connections.insert(bnd_id);
        
        // Boundary id to which the curve is connecte
        const unsigned dst_bnd_id = 
         tmp_polyline_pt->initial_vertex_connected_bnd_id();
        
        // Include the destination boundary id to the set of
        // boundaries with connections
        boundary_id_with_connections.insert(dst_bnd_id);        
        
       } // if (tmp_polyline_pt->is_initial_vertex_connected())
      
      // Is the final vertex connected? 
      if (tmp_polyline_pt->is_final_vertex_connected())
       {
        // Get the boundary id of the current polyline
        const unsigned bnd_id = tmp_polyline_pt->boundary_id();
        
        // Include the boundary id to the set of boundaries with
        // connections
        boundary_id_with_connections.insert(bnd_id);
        
        // Boundary id to which the curve is connected
        const unsigned dst_bnd_id = 
         tmp_polyline_pt->final_vertex_connected_bnd_id();
        
        // Include the destination boundary id to the set of
        // boundaries with connections
        boundary_id_with_connections.insert(dst_bnd_id);
        
       } // if (tmp_polyline_pt->is_final_vertex_connected())
      
     } // for (p < n_polyline)
    
   } // for (i < n_outer_boundaries)
  
  // ------------------------------------------------------------------
  // Internal boundaries
  // ------------------------------------------------------------------
  
  // Get the number of internal boundaries (closed boundaries)
  const unsigned n_internal_boundaries = this->Internal_polygon_pt.size();
  
  // Loop over the internal boundaries
  for (unsigned i = 0; i < n_internal_boundaries; i++)
   {
    // Get a temporary polygon representation
    TriangleMeshPolygon* tmp_polygon_pt = this->Internal_polygon_pt[i];
    // Get the number of polylines associated to the current internal
    // boundary
    const unsigned n_polyline = tmp_polygon_pt->npolyline();
    // Loop over the polylines
    for (unsigned p = 0; p < n_polyline; p++)
     {
      // Get a temporary representation of the polyline
      TriangleMeshPolyLine* tmp_polyline_pt = 
       tmp_polygon_pt->polyline_pt(p);
      
      // Is the initial vertex connected?
      if (tmp_polyline_pt->is_initial_vertex_connected())
       {
        // Get the boundary id of the current polyline
        const unsigned bnd_id = tmp_polyline_pt->boundary_id();
        
        // Include the boundary id to the set of boundaries with
        // connections
        boundary_id_with_connections.insert(bnd_id);
        
        // Boundary id to which the curve is connecte
        const unsigned dst_bnd_id = 
         tmp_polyline_pt->initial_vertex_connected_bnd_id();
        
        // Include the destination boundary id to the set of
        // boundaries with connections
        boundary_id_with_connections.insert(dst_bnd_id);        
        
       } // if (tmp_polyline_pt->is_initial_vertex_connected())
      
      // Is the final vertex connected? 
      if (tmp_polyline_pt->is_final_vertex_connected())
       {
        // Get the boundary id of the current polyline
        const unsigned bnd_id = tmp_polyline_pt->boundary_id();
        
        // Include the boundary id to the set of boundaries with
        // connections
        boundary_id_with_connections.insert(bnd_id);
        
        // Boundary id to which the curve is connected
        const unsigned dst_bnd_id = 
         tmp_polyline_pt->final_vertex_connected_bnd_id();
        
        // Include the destination boundary id to the set of
        // boundaries with connections
        boundary_id_with_connections.insert(dst_bnd_id);
        
       } // if (tmp_polyline_pt->is_final_vertex_connected())
      
     } // for (p < n_polyline)
    
   } // for (i < n_internal_boundaries)
  
  // ------------------------------------------------------------------
  // Open boundaries (nonclosed internal boundaries)
  // ------------------------------------------------------------------
  
  // Get the number of internal boundaries (open boundaries)
  const unsigned n_open_boundaries = this->Internal_open_curve_pt.size();
  
  // Loop over the internal open boundaries
  for (unsigned i = 0; i < n_open_boundaries; i++)
   {
    // Get a temporary representation for the open curve
    TriangleMeshOpenCurve* tmp_open_curve_pt = 
     this->Internal_open_curve_pt[i];
    
    // Get the number of curve sections associated to the current
    // internal open boundary
    const unsigned n_curve_section = tmp_open_curve_pt->ncurve_section();
    
    // Loop over the curve section
    for (unsigned p = 0; p < n_curve_section; p++)
     {
      // Get a temporary representation of the curve section
      // (polyline)
      TriangleMeshPolyLine* tmp_polyline_pt = 
       tmp_open_curve_pt->polyline_pt(p);
      
      // Is the initial vertex connected?
      if (tmp_polyline_pt->is_initial_vertex_connected())
       {
        // Get the boundary id of the current polyline
        const unsigned bnd_id = tmp_polyline_pt->boundary_id();
        
        // Include the boundary id to the set of boundaries with
        // connections
        boundary_id_with_connections.insert(bnd_id);
        
        // Boundary id to which the curve is connecte
        const unsigned dst_bnd_id = 
         tmp_polyline_pt->initial_vertex_connected_bnd_id();
        
        // Include the destination boundary id to the set of
        // boundaries with connections
        boundary_id_with_connections.insert(dst_bnd_id);        
        
       } // if (tmp_polyline_pt->is_initial_vertex_connected())
      
      // Is the final vertex connected? 
      if (tmp_polyline_pt->is_final_vertex_connected())
       {
        // Get the boundary id of the current polyline
        const unsigned bnd_id = tmp_polyline_pt->boundary_id();
        
        // Include the boundary id to the set of boundaries with
        // connections
        boundary_id_with_connections.insert(bnd_id);
        
        // Boundary id to which the curve is connected
        const unsigned dst_bnd_id = 
         tmp_polyline_pt->final_vertex_connected_bnd_id();
        
        // Include the destination boundary id to the set of
        // boundaries with connections
        boundary_id_with_connections.insert(dst_bnd_id);
        
       } // if (tmp_polyline_pt->is_final_vertex_connected())
      
     } // for (p < n_curve_section)
    
   } // for (i < n_open_boundaries)
  
#ifdef OOMPH_HAS_MPI
  // ------------------------------------------------------------------
  // Shared boundaries (only for distributed meshes)
  // ------------------------------------------------------------------
  
  // Check if we need to include any information associated with
  // shared boundaries
  if (this->is_mesh_distributed())
   {
    // Get the rank of the current processor
    const unsigned my_rank = this->communicator_pt()->my_rank();
    
    // Get the number of shared curves in the current processor
    const unsigned n_shared_curves = 
     this->nshared_boundary_curves(my_rank);
    
    // Loop over the shared curves
    for (unsigned i = 0; i < n_shared_curves; i ++)
     {
      // Get the number of polylines associated to the current shared
      // curve
      const unsigned n_polyline = 
       this->nshared_boundary_polyline(my_rank, i);
      
      // Loop over the polylines associated to the current shared
      // curve
      for (unsigned p = 0; p < n_polyline; p++)
       {
        // Get a temporary representation of the shared polyline
        TriangleMeshPolyLine* tmp_polyline_pt = 
         this->shared_boundary_polyline_pt(my_rank, i, p);
        
        // Is the initial vertex connected?
        if (tmp_polyline_pt->is_initial_vertex_connected())
         {
          // Get the boundary id of the current polyline
          const unsigned bnd_id = tmp_polyline_pt->boundary_id();
        
          // Include the boundary id to the set of boundaries with
          // connections
          boundary_id_with_connections.insert(bnd_id);
        
          // Boundary id to which the curve is connecte
          const unsigned dst_bnd_id = 
           tmp_polyline_pt->initial_vertex_connected_bnd_id();
          
          // Include the destination boundary id to the set of
          // boundaries with connections
          boundary_id_with_connections.insert(dst_bnd_id);        
        
         } // if (tmp_polyline_pt->is_initial_vertex_connected())
      
        // Is the final vertex connected? 
        if (tmp_polyline_pt->is_final_vertex_connected())
         {
          // Get the boundary id of the current polyline
          const unsigned bnd_id = tmp_polyline_pt->boundary_id();
        
          // Include the boundary id to the set of boundaries with
          // connections
          boundary_id_with_connections.insert(bnd_id);
        
          // Boundary id to which the curve is connected
          const unsigned dst_bnd_id = 
           tmp_polyline_pt->final_vertex_connected_bnd_id();
        
          // Include the destination boundary id to the set of
          // boundaries with connections
          boundary_id_with_connections.insert(dst_bnd_id);
        
         } // if (tmp_polyline_pt->is_final_vertex_connected())
        
       } // for (p < n_polyline)
      
     } // for (i < n_shared_curves)
    
   } // if (this->is_mesh_distributed())
  
#endif // #ifdef OOMPH_HAS_MPI
  
  // ---------------------------------------------------------------
  // Get the nodes sorted by segments of the boundaries with
  // connections
  
  // Store the sorted nodes by segments of the boundaries with
  // connections
  std::map<unsigned, Vector<Vector<Node*> > > bnd_sorted_segment_node_pt;
  
  // Loop over the boundaries with connections
  for (std::set<unsigned>::iterator it = 
        boundary_id_with_connections.begin(); 
       it != boundary_id_with_connections.end(); it++)
   {
    // Get the boundary id
    const unsigned bnd_id = (*it);
#ifdef OOMPH_HAS_MPI
    // Working with a distributed mesh
    if (this->is_mesh_distributed())
     {
      // Get the initial shared boundary id
      const unsigned init_shd_bnd_id = this->initial_shared_boundary_id();
      // Is an original or shared boundary
      if (bnd_id >= init_shd_bnd_id)
       {
        // Is a shared boundary
        
        // Temporary storage for the nodes on the shared boundary
        Vector<Vector<Node*> > tmp_shared_nodes_pt;
        
        // Get the nodes associated to the shared boundary
        get_shared_boundary_segment_nodes_helper(bnd_id, 
                                                 tmp_shared_nodes_pt);
        
        // Store the nodes associated to the shared boundary
        bnd_sorted_segment_node_pt[bnd_id] = tmp_shared_nodes_pt;
        
       } // if (bnd_id >= init_shd_bnd_id)
      else
       {
        // Is an original boundary
        
        // Temporary storage for the nodes on the original boundary
        Vector<Vector<Node*> > tmp_boundary_nodes_pt;
        
        // Get the nodes associated to the shared boundary
        get_boundary_segment_nodes_helper(bnd_id, 
                                          tmp_boundary_nodes_pt);
        
        // Store the nodes associated to the shared boundary
        bnd_sorted_segment_node_pt[bnd_id] = tmp_boundary_nodes_pt;
        
       } // if (bnd_id >= init_shd_bnd_id)      
      
     } // if (this->is_mesh_distributed())
    else
#endif // #ifdef OOMPH_HAS_MPI
     {
      // Is an original boundary
      
      // Temporary storage for the nodes on the original boundary
      Vector<Vector<Node*> > tmp_boundary_nodes_pt;
      
      // Get the nodes associated to the shared boundary
      get_boundary_segment_nodes_helper(bnd_id, 
                                        tmp_boundary_nodes_pt);
      
      // Store the nodes associated to the shared boundary
      bnd_sorted_segment_node_pt[bnd_id] = tmp_boundary_nodes_pt;
      
     } // if (this->is_mesh_distributed())
    
   } // Loop over boundaries with connections
  
  // -----------------------------------------------------------------
  // Loop again over the boundaries (original and shared) and search
  // for the repeated nodes in those boundaries with connections
  
  // ------------------------------------------------------------------
  // Outer boundaries
  // ------------------------------------------------------------------  
  // Loop over the outer boundaries
  for (unsigned i = 0; i < n_outer_boundaries; i++)
   {
    // Get a temporary polygon representation
    TriangleMeshPolygon* tmp_polygon_pt = this->Outer_boundary_pt[i];
    // Get the number of polylines associated to the current outer
    // boundary
    const unsigned n_polyline = tmp_polygon_pt->npolyline();
    // Loop over the polylines
    for (unsigned p = 0; p < n_polyline; p++)
     {
      // Get a temporary representation of the polyline
      TriangleMeshPolyLine* tmp_polyline_pt = 
       tmp_polygon_pt->polyline_pt(p);
      
      // Is the initial vertex connected?
      if (tmp_polyline_pt->is_initial_vertex_connected())
       {
        // Get the boundary id of the current polyline
        const unsigned bnd_id = tmp_polyline_pt->boundary_id();
        
        // Boundary id to which the curve is connected
        const unsigned dst_bnd_id = 
         tmp_polyline_pt->initial_vertex_connected_bnd_id();
        
        // Boundary chunk to which the curve is connected
        const unsigned dst_chunk = 
         tmp_polyline_pt->initial_vertex_connected_n_chunk();
        
        // Get the nodes representation of the current boundary
        Vector<Vector<Node*> > src_bnd_node_pt = 
         bnd_sorted_segment_node_pt[bnd_id];
        
        // Get the nodes representation of the boundary to connect
        Vector<Vector<Node*> > dst_bnd_node_pt = 
         bnd_sorted_segment_node_pt[dst_bnd_id];
        
        // Add the repeated node to the list of non delete-able
        // vertices
        add_non_delete_vertices_from_boundary_helper(
         src_bnd_node_pt, dst_bnd_node_pt, dst_bnd_id, dst_chunk);
        
       } // if (tmp_polyline_pt->is_initial_vertex_connected())
      
      // Is the final vertex connected? 
      if (tmp_polyline_pt->is_final_vertex_connected())
       {
        // Get the boundary id of the current polyline
        const unsigned bnd_id = tmp_polyline_pt->boundary_id();
        
        // Boundary id to which the curve is connected
        const unsigned dst_bnd_id = 
         tmp_polyline_pt->final_vertex_connected_bnd_id();
        
        // Boundary chunk to which the curve is connected
        const unsigned dst_chunk = 
         tmp_polyline_pt->final_vertex_connected_n_chunk();
        
        // Get the nodes representation of the current boundary
        Vector<Vector<Node*> > src_bnd_node_pt = 
         bnd_sorted_segment_node_pt[bnd_id];
        
        // Get the nodes representation of the boundary to connect
        Vector<Vector<Node*> > dst_bnd_node_pt = 
         bnd_sorted_segment_node_pt[dst_bnd_id];
        
        // Add the repeated node to the list of non delete-able
        // vertices
        add_non_delete_vertices_from_boundary_helper(
         src_bnd_node_pt, dst_bnd_node_pt, dst_bnd_id, dst_chunk);
        
       } // if (tmp_polyline_pt->is_final_vertex_connected())
      
     } // for (p < n_polyline)
    
   } // for (i < n_outer_boundaries)
  
  // ------------------------------------------------------------------
  // Internal boundaries
  // ------------------------------------------------------------------  
  // Loop over the internal boundaries
  for (unsigned i = 0; i < n_internal_boundaries; i++)
   {
    // Get a temporary polygon representation
    TriangleMeshPolygon* tmp_polygon_pt = this->Internal_polygon_pt[i];
    // Get the number of polylines associated to the current internal
    // boundary
    const unsigned n_polyline = tmp_polygon_pt->npolyline();
    // Loop over the polylines
    for (unsigned p = 0; p < n_polyline; p++)
     {
      // Get a temporary representation of the polyline
      TriangleMeshPolyLine* tmp_polyline_pt = 
       tmp_polygon_pt->polyline_pt(p);
      
      // Is the initial vertex connected?
      if (tmp_polyline_pt->is_initial_vertex_connected())
       {
        // Get the boundary id of the current polyline
        const unsigned bnd_id = tmp_polyline_pt->boundary_id();
        
        // Boundary id to which the curve is connected
        const unsigned dst_bnd_id = 
         tmp_polyline_pt->initial_vertex_connected_bnd_id();
        
        // Boundary chunk to which the curve is connected
        const unsigned dst_chunk = 
         tmp_polyline_pt->initial_vertex_connected_n_chunk();
        
        // Get the nodes representation of the current boundary
        Vector<Vector<Node*> > src_bnd_node_pt = 
         bnd_sorted_segment_node_pt[bnd_id];
        
        // Get the nodes representation of the boundary to connect
        Vector<Vector<Node*> > dst_bnd_node_pt = 
         bnd_sorted_segment_node_pt[dst_bnd_id];
        
        // Add the repeated node to the list of non delete-able
        // vertices
        add_non_delete_vertices_from_boundary_helper(
         src_bnd_node_pt, dst_bnd_node_pt, dst_bnd_id, dst_chunk);
        
       } // if (tmp_polyline_pt->is_initial_vertex_connected())
      
      // Is the final vertex connected? 
      if (tmp_polyline_pt->is_final_vertex_connected())
       {
        // Get the boundary id of the current polyline
        const unsigned bnd_id = tmp_polyline_pt->boundary_id();
        
        // Boundary id to which the curve is connected
        const unsigned dst_bnd_id = 
         tmp_polyline_pt->final_vertex_connected_bnd_id();
        
        // Boundary chunk to which the curve is connected
        const unsigned dst_chunk = 
         tmp_polyline_pt->final_vertex_connected_n_chunk();
        
        // Get the nodes representation of the current boundary
        Vector<Vector<Node*> > src_bnd_node_pt = 
         bnd_sorted_segment_node_pt[bnd_id];
        
        // Get the nodes representation of the boundary to connect
        Vector<Vector<Node*> > dst_bnd_node_pt = 
         bnd_sorted_segment_node_pt[dst_bnd_id];
        
        // Add the repeated node to the list of non delete-able
        // vertices
        add_non_delete_vertices_from_boundary_helper(
         src_bnd_node_pt, dst_bnd_node_pt, dst_bnd_id, dst_chunk);
        
       } // if (tmp_polyline_pt->is_final_vertex_connected())
      
     } // for (p < n_polyline)
    
   } // for (i < n_internal_boundaries)
  
  // ------------------------------------------------------------------
  // Open boundaries (nonclosed internal boundaries)
  // ------------------------------------------------------------------  
  // Loop over the internal open boundaries
  for (unsigned i = 0; i < n_open_boundaries; i++)
   {
    // Get a temporary representation for the open curve
    TriangleMeshOpenCurve* tmp_open_curve_pt = 
     this->Internal_open_curve_pt[i];
    
    // Get the number of curve sections associated to the current
    // internal open boundary
    const unsigned n_curve_section = tmp_open_curve_pt->ncurve_section();
    
    // Loop over the curve section
    for (unsigned p = 0; p < n_curve_section; p++)
     {
      // Get a temporary representation of the curve section
      // (polyline)
      TriangleMeshPolyLine* tmp_polyline_pt = 
       tmp_open_curve_pt->polyline_pt(p);
      
      // Is the initial vertex connected?
      if (tmp_polyline_pt->is_initial_vertex_connected())
       {
        // Get the boundary id of the current polyline
        const unsigned bnd_id = tmp_polyline_pt->boundary_id();
        
        // Boundary id to which the curve is connected
        const unsigned dst_bnd_id = 
         tmp_polyline_pt->initial_vertex_connected_bnd_id();
        
        // Boundary chunk to which the curve is connected
        const unsigned dst_chunk = 
         tmp_polyline_pt->initial_vertex_connected_n_chunk();
        
        // Get the nodes representation of the current boundary
        Vector<Vector<Node*> > src_bnd_node_pt = 
         bnd_sorted_segment_node_pt[bnd_id];
        
        // Get the nodes representation of the boundary to connect
        Vector<Vector<Node*> > dst_bnd_node_pt = 
         bnd_sorted_segment_node_pt[dst_bnd_id];
        
        // Add the repeated node to the list of non delete-able
        // vertices
        add_non_delete_vertices_from_boundary_helper(
         src_bnd_node_pt, dst_bnd_node_pt, dst_bnd_id, dst_chunk);
        
       } // if (tmp_polyline_pt->is_initial_vertex_connected())
      
      // Is the final vertex connected? 
      if (tmp_polyline_pt->is_final_vertex_connected())
       {
        // Get the boundary id of the current polyline
        const unsigned bnd_id = tmp_polyline_pt->boundary_id();
        
        // Boundary id to which the curve is connected
        const unsigned dst_bnd_id = 
         tmp_polyline_pt->final_vertex_connected_bnd_id();
        
        // Boundary chunk to which the curve is connected
        const unsigned dst_chunk = 
         tmp_polyline_pt->final_vertex_connected_n_chunk();
        
        // Get the nodes representation of the current boundary
        Vector<Vector<Node*> > src_bnd_node_pt = 
         bnd_sorted_segment_node_pt[bnd_id];
        
        // Get the nodes representation of the boundary to connect
        Vector<Vector<Node*> > dst_bnd_node_pt = 
         bnd_sorted_segment_node_pt[dst_bnd_id];
        
        // Add the repeated node to the list of non delete-able
        // vertices
        add_non_delete_vertices_from_boundary_helper(
         src_bnd_node_pt, dst_bnd_node_pt, dst_bnd_id, dst_chunk);
        
       } // if (tmp_polyline_pt->is_final_vertex_connected())
      
     } // for (p < n_curve_section)
    
   } // for (i < n_open_boundaries)
  
#ifdef OOMPH_HAS_MPI
  // ------------------------------------------------------------------
  // Shared boundaries (only for distributed meshes)
  // ------------------------------------------------------------------
  
  // Check if we need to include any information associated with
  // shared boundaries
  if (this->is_mesh_distributed())
   {
    // Get the rank of the current processor
    const unsigned my_rank = this->communicator_pt()->my_rank();
    
    // Get the number of shared curves in the current processor
    const unsigned n_shared_curves = 
     this->nshared_boundary_curves(my_rank);
    
    // Loop over the shared curves
    for (unsigned i = 0; i < n_shared_curves; i ++)
     {
      // Get the number of polylines associated to the current shared
      // curve
      const unsigned n_polyline = 
       this->nshared_boundary_polyline(my_rank, i);
      
      // Loop over the polylines associated to the current shared
      // curve
      for (unsigned p = 0; p < n_polyline; p++)
       {
        // Get a temporary representation of the shared polyline
        TriangleMeshPolyLine* tmp_polyline_pt = 
         this->shared_boundary_polyline_pt(my_rank, i, p);
        
        // Is the initial vertex connected?
        if (tmp_polyline_pt->is_initial_vertex_connected())
         {
          // Get the boundary id of the current polyline
          const unsigned bnd_id = tmp_polyline_pt->boundary_id();
        
          // Boundary id to which the curve is connected
          const unsigned dst_bnd_id = 
           tmp_polyline_pt->initial_vertex_connected_bnd_id();
        
          // Boundary chunk to which the curve is connected
          const unsigned dst_chunk = 
           tmp_polyline_pt->initial_vertex_connected_n_chunk();
        
          // Get the nodes representation of the current boundary
          Vector<Vector<Node*> > src_bnd_node_pt = 
           bnd_sorted_segment_node_pt[bnd_id];
        
          // Get the nodes representation of the boundary to connect
          Vector<Vector<Node*> > dst_bnd_node_pt = 
           bnd_sorted_segment_node_pt[dst_bnd_id];
        
          // Add the repeated node to the list of non delete-able
          // vertices
          add_non_delete_vertices_from_boundary_helper(
           src_bnd_node_pt, dst_bnd_node_pt, dst_bnd_id, dst_chunk);
          
         } // if (tmp_polyline_pt->is_initial_vertex_connected())
        
        // Is the final vertex connected? 
        if (tmp_polyline_pt->is_final_vertex_connected())
         {
          // Get the boundary id of the current polyline
          const unsigned bnd_id = tmp_polyline_pt->boundary_id();
        
          // Boundary id to which the curve is connected
          const unsigned dst_bnd_id = 
           tmp_polyline_pt->final_vertex_connected_bnd_id();
        
          // Boundary chunk to which the curve is connected
          const unsigned dst_chunk = 
           tmp_polyline_pt->final_vertex_connected_n_chunk();
        
          // Get the nodes representation of the current boundary
          Vector<Vector<Node*> > src_bnd_node_pt = 
           bnd_sorted_segment_node_pt[bnd_id];
        
          // Get the nodes representation of the boundary to connect
          Vector<Vector<Node*> > dst_bnd_node_pt = 
           bnd_sorted_segment_node_pt[dst_bnd_id];
        
          // Add the repeated node to the list of non delete-able
          // vertices
          add_non_delete_vertices_from_boundary_helper(
           src_bnd_node_pt, dst_bnd_node_pt, dst_bnd_id, dst_chunk);
        
         } // if (tmp_polyline_pt->is_final_vertex_connected())
        
       } // for (p < n_polyline)
      
     } // for (i < n_shared_curves)
    
   } // if (this->is_mesh_distributed())
  
#endif // #ifdef OOMPH_HAS_MPI
  
 }
 
 //=========================================================================
 /// \short Adds the vertices from the sources boundary that are
 /// repeated in the destination boundary to the list of non
 /// delete-able vertices in the destination boundary
 //=========================================================================
 template<class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 add_non_delete_vertices_from_boundary_helper(
  Vector<Vector<Node*> > src_bound_segment_node_pt,
  Vector<Vector<Node*> > dst_bound_segment_node_pt,
  const unsigned &dst_bnd_id, const unsigned &dst_bnd_chunk)
 {
  // Get the number of segments in the source boundary
  const unsigned n_seg = src_bound_segment_node_pt.size();
  // Loop over the segments in the source boundary
  for (unsigned iseg = 0; iseg < n_seg; iseg++)
   {
    // Get the number of nodes in the current segment
    const unsigned nnode = src_bound_segment_node_pt[iseg].size();
    // Get the left and right node of the current segment
    Node* left_node_pt = src_bound_segment_node_pt[iseg][0];
    Node* right_node_pt = src_bound_segment_node_pt[iseg][nnode-1];
    
    // Get the number of segments in the destination boundary
    const unsigned n_dst_seg = dst_bound_segment_node_pt.size();
    // Loop over the segments in the destination boundary
    for (unsigned jseg = 0; jseg < n_dst_seg; jseg++)
     {
      // Get the number of nodes on the current destination segment
      const unsigned n_dst_node = dst_bound_segment_node_pt[jseg].size();
      // Loop over the nodes until the node has been found or we have
      // visited all the nodes
      for (unsigned jnode = 0; jnode < n_dst_node; jnode++)
       {
        // Get a pointer to the jnode in the destination segment
        // boundary 
        Node* tmp_node_pt = dst_bound_segment_node_pt[jseg][jnode];
        // Is the node the same as the left or right node if
        // the source segment boundary
        if (tmp_node_pt == left_node_pt)
         {
          // We have foud the node to connect, get the vertex of the node
          Vector<double> vertex(2);
          vertex[0] = tmp_node_pt->x(0);
          vertex[1] = tmp_node_pt->x(1);
          
          // Establish the vertex coordinate as untouchable in the
          // destination boundary during the adaptation process. It
          // means that unrefinement can not take off the vertices
          // that receive connections in the destination boundary
          Boundary_connections_pt[dst_bnd_id].insert(vertex);
          //Boundary_chunk_connections_pt[dst_bnd_id][dst_bnd_chunk].
          // insert(vertex);
          
          // return 
          return;
          
         } // if (tmp_node_pt == left_node_pt)
        else if (tmp_node_pt == right_node_pt)
         {
          // We have foud the node to connect, get the vertex of the node
          Vector<double> vertex(2);
          vertex[0] = tmp_node_pt->x(0);
          vertex[1] = tmp_node_pt->x(1);
          
          // Establish the vertex coordinate as untouchable in the
          // destination boundary during the adaptation process. It
          // means that unrefinement can not take off the vertices
          // that receive connections in the destination boundary
          //Boundary_chunk_connections_pt[dst_bnd_id][dst_bnd_chunk].
          // insert(vertex);
          Boundary_connections_pt[dst_bnd_id].insert(vertex);
          
          // return 
          return;
          
         } // else if (tmp_node_pt == right_node_pt)
        
       } // for (jnode < n_dst_node)
      
     } // for (jseg < n_dst_seg)
    
   } // for (iseg < n_seg)
  
 }
  
#ifdef OOMPH_HAS_MPI
 //=========================================================================
 /// \short Synchronise the vertices that are marked for non deletion
 //  on the shared boundaries. Unrefinement of shared boundaries is
 //  performed only if the candidate node is not marked for non deletion
 //=========================================================================
 template<class ELEMENT>
 const void RefineableTriangleMesh<ELEMENT>::
 synchronize_shared_boundary_connections()
  {
   // Get the number of processors
   const unsigned nproc = this->communicator_pt()->nproc();
   // Get my rank
   const unsigned my_rank = this->communicator_pt()->my_rank();
   
   // loop over the processors
   for (unsigned jproc = 0; jproc < nproc; jproc++)
     {
       // The number of boundaries shared with the current processor
       // (if jproc==my_rank then there are no shared boundaries
       // between them)
       const unsigned n_shd_bnd_jproc = 
         this->nshared_boundaries(my_rank, jproc);
       
       // Are there shared boundaries with the jproc processor?
       // There are no info. with myself
       if (jproc != my_rank && n_shd_bnd_jproc > 0)
         {
           // Storage for the boundaries ids with vertices for non
           // deletion
           Vector<unsigned> shd_bnd_id_for_non_deletion;
           
           // Storage for chunk numbers of boundaries with vertices
           // for non deletion
           Vector<unsigned> chunk_for_non_deletion;
           
           // The number of vertices for nondeletion in the shared
           // boundaries
           Vector<unsigned> number_vertices_non_deletion;
           
           // Vertices marked for nondeletion in shared boundaries
           Vector<Vector<Vector<double> > > vertices_for_non_deletion;
           
           // Get the boundary ids of the shared boundaries with jproc
           // processor
           Vector<unsigned> shd_bnd_ids = 
             this->shared_boundaries_ids(my_rank, jproc);
           
           // Get the number of shared boundaries with jproc
           const unsigned n_shd_bnd_jproc = shd_bnd_ids.size();
           // loop over the shared boundaries with jproc
           for (unsigned ishd_bnd=0;ishd_bnd<n_shd_bnd_jproc;ishd_bnd++)
             {
               // Get the shared boudary id
               const unsigned shd_bnd_id = shd_bnd_ids[ishd_bnd];
               // Get the associated polyline
               TriangleMeshPolyLine *shd_polyline_pt = 
                 this->boundary_polyline_pt(shd_bnd_id);
               // Get the chunk number
               const unsigned chunk = shd_polyline_pt->boundary_chunk();
               
               // Store the vertices not allowed for deletion
               std::set<Vector<double> > no_delete_vertex;
               
               // Does the boundary has vertives for nondeleteion?
               const bool boundary_receive_connections = 
                 this->boundary_connections(shd_bnd_id, chunk,
                                            no_delete_vertex);
               
               // Get the number of vertices for nondeletion
               const unsigned n_non_delete_vertex = no_delete_vertex.size();
               
               // Are there vertices for nondeletion?
               if (boundary_receive_connections && n_non_delete_vertex > 0)
                 {
                   // Add the shared boundary id
                   shd_bnd_id_for_non_deletion.push_back(shd_bnd_id);
                   // Add the chunk number
                   chunk_for_non_deletion.push_back(chunk);
                   // Add the number of vertices for non deletion
                   number_vertices_non_deletion.push_back(n_non_delete_vertex);
                   
                   // The list of vertices to add
                   Vector<Vector<double> > tmp_vertices;
                   
                   // Add the vertices for non deletion
                   for (std::set<Vector<double> >::iterator it = 
                          no_delete_vertex.begin();
                        it != no_delete_vertex.end(); it++)
                     {
                       // Get the vertex coordinate
                       Vector<double> vertex = (*it);
                       tmp_vertices.push_back(vertex);
                     }
                   
                   // Add the vertices coordinates to a vector storage
                   vertices_for_non_deletion.push_back(tmp_vertices);
                   
                 } // if (boundary_receive_connections && n_non_delete_vertex > 0)
               
             } // for (ishd_bnd<n_shd_bnd_jproc)
           
           // ----------------------------------------------------------
           // ----------------------------------------------------------
           // ----------------------------------------------------------
           // Now send the info. to the other processor (jproc)
           // ----------------------------------------------------------
           // ----------------------------------------------------------
           // ----------------------------------------------------------
           // Get the communicator of the mesh
           OomphCommunicator* comm_pt = this->communicator_pt();
           
           // Set MPI info
           MPI_Status status;
           MPI_Request request;
           
           // -----------------------------------------------------------
           // Prepare the data
           // Get the number of shared boundaires with vertices marked
           // for non deletion
           const unsigned n_shd_bnd_with_non_delete_vertices = 
             shd_bnd_id_for_non_deletion.size();
           
           // Size of the package
           const unsigned size_package = 3;
           // Ndata to send
           const unsigned n_unsigned_data_to_send = 
             n_shd_bnd_with_non_delete_vertices*size_package;
           // The flat package to send the info.
           Vector<unsigned> flat_package_unsigned_send(n_unsigned_data_to_send);
           Vector<double> flat_package_double_send;
           
           Vector<unsigned> flat_package_unsigned_recv;
           Vector<double> flat_package_double_recv;
           
           // Prepare the data to be sent
           unsigned j=0;
           for (unsigned i=0;i<n_shd_bnd_with_non_delete_vertices;i++)
             {
               // The  shared boundary id
               flat_package_unsigned_send[j++] = 
                 shd_bnd_id_for_non_deletion[i];
               // The chunk number
               flat_package_unsigned_send[j++] = 
                 chunk_for_non_deletion[i];
               // The number of vertices for nondeletion
               flat_package_unsigned_send[j++] = 
                 number_vertices_non_deletion[i];
               // Also package the vertices
               const unsigned n_vertices_non_deletion = 
                 number_vertices_non_deletion[i];
               // Loop over the vertices and store them in the flat
               // package to be sent
               for (unsigned h=0;h<n_vertices_non_deletion;h++)
                 {
                   flat_package_double_send.push_back(
                     vertices_for_non_deletion[i][h][0]);
                   flat_package_double_send.push_back(
                     vertices_for_non_deletion[i][h][1]);
                 } // for (h<n_vertices_non_deletion)
               
             } // for (i<n_shd_bnd_with_non_delete_vertices)
           
           // ----------------------------------------------------------
           int send_proc = jproc;
           int recv_proc = jproc;
           unsigned send_count_unsigned_values = n_unsigned_data_to_send;
           unsigned send_count_double_values = flat_package_double_send.size();
           //-----------------------------------------------------------
           // Do the transfering of info.
           //-----------------------------------------------------------
           // Start with UNSIGNED info.
           MPI_Isend(&send_count_unsigned_values,1,MPI_UNSIGNED,
                     send_proc,1,comm_pt->mpi_comm(),&request);
           
           unsigned receive_count_unsigned_values=0;
           MPI_Recv(&receive_count_unsigned_values,1,MPI_UNSIGNED,
                    recv_proc,1,comm_pt->mpi_comm(),&status);
           
           MPI_Wait(&request,MPI_STATUS_IGNORE);
           
           // Send the actual data
           if (send_count_unsigned_values!=0)
             {
               MPI_Isend(&flat_package_unsigned_send[0],
                         send_count_unsigned_values,MPI_UNSIGNED,
                         send_proc,2,comm_pt->mpi_comm(),&request);
             }
           
           // Receive the actual data
           if (receive_count_unsigned_values!=0)
             {
               flat_package_unsigned_recv.resize(receive_count_unsigned_values);
               MPI_Recv(&flat_package_unsigned_recv[0],
                        receive_count_unsigned_values,
                        MPI_UNSIGNED,recv_proc,2,comm_pt->mpi_comm(),&status);
             }
           
           // Wait for sending the data and the other processor
           // receives
           if (send_count_unsigned_values!=0)
             {
               MPI_Wait(&request,MPI_STATUS_IGNORE);
             }
           
           //-----------------------------------------------------------
           // Then continue with DOUBLE info.
           MPI_Isend(&send_count_double_values,1,MPI_UNSIGNED,
                     send_proc,1,comm_pt->mpi_comm(),&request);
           
           unsigned receive_count_double_values=0;
           MPI_Recv(&receive_count_double_values,1,MPI_UNSIGNED,
                    recv_proc,1,comm_pt->mpi_comm(),&status);
           
           MPI_Wait(&request,MPI_STATUS_IGNORE);
           
           // Send the actual data
           if (send_count_double_values!=0)
             {
               MPI_Isend(&flat_package_double_send[0],
                         send_count_double_values,MPI_DOUBLE,
                         send_proc,2,comm_pt->mpi_comm(),&request);
             }
           
           // Receive the actual data
           if (receive_count_double_values!=0)
             {
               flat_package_double_recv.resize(receive_count_double_values);
               MPI_Recv(&flat_package_double_recv[0],
                        receive_count_double_values,
                        MPI_DOUBLE,recv_proc,2,comm_pt->mpi_comm(),&status);
             }
           
           // Wait for sending the data and the other processor
           // receives
           if (send_count_double_values!=0)
             {
               MPI_Wait(&request,MPI_STATUS_IGNORE);
             }
           
           // ------------------------------------------------------------
           // ------------------------------------------------------------
           // ------------------------------------------------------------
           // Now unpackage the data
           // ------------------------------------------------------------
           // ------------------------------------------------------------
           // ------------------------------------------------------------
           
           // Storage for the boundaries ids with vertices for non
           // deletion
           Vector<unsigned> recv_shd_bnd_id_for_non_deletion;
           
           // Storage for chunk numbers of boundaries with vertices
           // for non deletion
           Vector<unsigned> recv_chunk_for_non_deletion;
           
           // The number of vertices for nondeletion in the shared
           // boundaries
           Vector<unsigned> recv_number_vertices_non_deletion;
           
           // Vertices marked for nondeletion in shared boundaries
           Vector<Vector<Vector<double> > > recv_vertices_for_non_deletion;
           
           // Counter
           j = 0;
           for (unsigned i=0;i<receive_count_unsigned_values;i+=3)
             {
               // Get the shared boundary id
               const unsigned recv_shd_bnd_id = 
                 flat_package_unsigned_recv[i];
               recv_shd_bnd_id_for_non_deletion.push_back(recv_shd_bnd_id);
               // Get the chunk number
               const unsigned recv_chunk = 
                 flat_package_unsigned_recv[i+1];
               recv_chunk_for_non_deletion.push_back(recv_chunk);
               // Get the number of vertices for non deletion
               const unsigned recv_num_vertices = 
                 flat_package_unsigned_recv[i+2];
               recv_number_vertices_non_deletion.push_back(recv_num_vertices);
               
               // Create a temporal storage
               Vector<Vector<double> > temp_recv_vertices;
               // Now get the vertices
               for (unsigned h=0;h<recv_num_vertices;h++)
                 {
                   Vector<double> tmp_vertex(2);
                   tmp_vertex[0] = flat_package_double_recv[j++];
                   tmp_vertex[1] = flat_package_double_recv[j++];
                   // Add the vertex to the vector of vertices
                   temp_recv_vertices.push_back(tmp_vertex);
                 } // for (h<recv_num_vertices)
               
               // Add the vertices to the vector of vertices
               recv_vertices_for_non_deletion.push_back(temp_recv_vertices);
               
             } // for(i<receive_count_unsigned_values)
           
           // ---------------------------------------------------------
           // ---------------------------------------------------------
           // ---------------------------------------------------------
           // Now add the vertices to the data structures to mark them
           // as non delete-able
           // ---------------------------------------------------------
           // ---------------------------------------------------------
           // ---------------------------------------------------------

           // Get the number of shd boundaries that have vertices
           // marked for non deletion
           const unsigned n_recv_shd_bnd_id_for_non_deletion = 
             recv_shd_bnd_id_for_non_deletion.size();
           // loop over the shared boundaries and add the data for non
           // deletion
           for (unsigned i=0;i<n_recv_shd_bnd_id_for_non_deletion;i++)
             {
               // Get the shared boundary id.
               const unsigned shd_bnd_id = 
                 recv_shd_bnd_id_for_non_deletion[i];
               // Get the chunk number
               unsigned chunk = recv_chunk_for_non_deletion[i];
               // Increase and decrease the chunk number to avoid the
               // warning when compiling without PARANOID
               chunk++;
               chunk--;
               
               // Get the number of vertices marked for non deletion
               const unsigned n_vertices = 
                 recv_number_vertices_non_deletion[i];
               // Add all the vertices
               for (unsigned h=0;h<n_vertices;h++)
                 {
                   // Get the vertex
                   Vector<double> vertex(2);
                   vertex[0] = recv_vertices_for_non_deletion[i][h][0];
                   vertex[1] = recv_vertices_for_non_deletion[i][h][1];
                   // Add the vertex to the data structure for non
                   // deletion
                   //Boundary_chunk_connections_pt[shd_bnd_id][chunk].
                   //  insert(vertex);
                   Boundary_connections_pt[shd_bnd_id].insert(vertex);
                   
                 } // for (h<n_vertices)
               
             } // for (i<n_recv_shd_bnd_id_for_non_deletion)
           
         } // if (jproc != my_rank && n_shd_bnd_jproc > 0)
       
     } // for (jproc < nproc)
   
 }
#endif // #ifdef OOMPH_HAS_MPI
  
 //=========================================================================
 /// \short After unrefinement and refinement has taken place compute
 /// the new vertices numbers of the temporary representation of the
 //  boundaries to connect.
 //=========================================================================
 template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::create_temporary_boundary_connections(
    Vector<TriangleMeshPolygon *> &tmp_outer_polygons_pt,
    Vector<TriangleMeshOpenCurve *> &tmp_open_curves_pt)
 {
   // Dummy storages
   Vector<TriangleMeshPolyLine*> dummy_resume_initial_connection_polyline_pt;
   Vector<TriangleMeshPolyLine*> dummy_resume_final_connection_polyline_pt;
   
   // Clear the storage
   dummy_resume_initial_connection_polyline_pt.clear();
   dummy_resume_final_connection_polyline_pt.clear();
   
   // Get the initial shared boundary id (to check whether the
   // polylines represent original or shared boundaries)
   const unsigned init_shd_bnd_id = this->initial_shared_boundary_id();
   
   // ------------------------------------------------------------------
   // This seems unnecesary since the outer polygons does not create
   // connections with other boundaries (the original ones)
   // ------------------------------------------------------------------
   // Unnecessary?
   // ------------------------------------------------------------------
   
   // Loop over the temporary outer polygons create the connection
   // information of those boundaries marked to be connected at their
   // ends
   
   // ------------------------------------------------------------------
   // Temporary outer polygons
   // ------------------------------------------------------------------
   
   // Get the number of outer boundaries (closed boundaries)
   const unsigned n_outer_boundaries = tmp_outer_polygons_pt.size();
   
   // Loop over the outer boundaries
   for (unsigned i = 0; i < n_outer_boundaries; i++)
     {
       // Get a temporary polygon representation
       TriangleMeshPolygon* tmp_polygon_pt = tmp_outer_polygons_pt[i];
       // Get the number of polylines associated to the current outer
       // boundary
       const unsigned n_polyline = tmp_polygon_pt->npolyline();
       // Loop over the polylines
       for (unsigned p = 0; p < n_polyline; p++)
         {
           // Get a temporary representation of the polyline
           TriangleMeshPolyLine* tmp_polyline_pt = 
             tmp_polygon_pt->polyline_pt(p);

           // Get the boundary id
           const unsigned bnd_id = tmp_polyline_pt->boundary_id();
           
           // Is the boundary to connect a shared boundary
           if (bnd_id < init_shd_bnd_id)
             {
               // Restore the connections of the current polyline
               restore_polyline_connections_helper(
                tmp_polyline_pt,
                dummy_resume_initial_connection_polyline_pt,
                dummy_resume_final_connection_polyline_pt);
               
             } // if (bnd_id < init_shd_bnd_id)
           
         } // for (p < n_polyline)
       
     } // for (i < n_outer_boundaries)
   
   // ------------------------------------------------------------------
   // Unnecessary?
   // ------------------------------------------------------------------
   
   // ------------------------------------------------------------------
   // Temporary open boundaries (nonclosed internal boundaries)
   // ------------------------------------------------------------------
   
   // Get the number of internal boundaries (open boundaries)
   const unsigned n_open_boundaries = tmp_open_curves_pt.size();
   
   // Loop over the internal open boundaries
   for (unsigned i = 0; i < n_open_boundaries; i++)
     {
       // Get a temporary representation for the open curve
       TriangleMeshOpenCurve* tmp_open_curve_pt = tmp_open_curves_pt[i];
       
       // Get the number of curve sections associated to the current
       // internal open boundary
       const unsigned n_curve_section = tmp_open_curve_pt->ncurve_section();
       
       // Loop over the curve section
       for (unsigned p = 0; p < n_curve_section; p++)
         {
           // Get a temporary representation of the curve section
           // (polyline)
           TriangleMeshPolyLine* tmp_polyline_pt = 
             tmp_open_curve_pt->polyline_pt(p);
           
           // Get the boundary id
           const unsigned bnd_id = tmp_polyline_pt->boundary_id();
           
           // Is the boundary to connect a shared boundary
           if (bnd_id < init_shd_bnd_id)
             {
               // Restore the connections of the current polyline
               restore_polyline_connections_helper(
                tmp_polyline_pt,
                dummy_resume_initial_connection_polyline_pt,
                dummy_resume_final_connection_polyline_pt);
               
             } // if (bnd_id < init_shd_bnd_id)
           
         } // for (p < n_curve_section)
       
     } // for (i < n_open_boundaries)
   
 }

 //=========================================================================
 /// \short After unrefinement and refinement has taken place compute
 /// the new vertices numbers of the boundaries to connect (in a
 /// distributed scheme it may be possible that the destination
 /// boundary does no longer exist, therefore the connection is
 /// suspended. It is not permanently deleted because if load balance
 /// takes place it may be possible that the boundary to connect be
 /// part of the new domain representation, so the connection would
 /// exist)
 //=========================================================================
 template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::restore_boundary_connections(
  Vector<TriangleMeshPolyLine*> &resume_initial_connection_polyline_pt,
  Vector<TriangleMeshPolyLine*> &resume_final_connection_polyline_pt)
 {
  // Clear the storage
  resume_initial_connection_polyline_pt.clear();
  resume_final_connection_polyline_pt.clear();
  
  // Loop over the boundaries in the domain (outer, internal -- closed
  // and open) and restore the connection information of those
  // boundaries marked to be connected at their ends
  
  // ------------------------------------------------------------------
  // Outer boundaries
  // ------------------------------------------------------------------
  
  // Get the number of outer boundaries (closed boundaries)
  const unsigned n_outer_boundaries = this->Outer_boundary_pt.size();
  
  // Loop over the outer boundaries
  for (unsigned i = 0; i < n_outer_boundaries; i++)
   {
    // Get a temporary polygon representation
    TriangleMeshPolygon* tmp_polygon_pt = this->Outer_boundary_pt[i];
    // Get the number of polylines associated to the current outer
    // boundary
    const unsigned n_polyline = tmp_polygon_pt->npolyline();
    // Loop over the polylines
    for (unsigned p = 0; p < n_polyline; p++)
     {
      // Get a temporary representation of the polyline
      TriangleMeshPolyLine* tmp_polyline_pt = 
       tmp_polygon_pt->polyline_pt(p);
      
      // Restore the connections of the current polyline
      restore_polyline_connections_helper(
       tmp_polyline_pt,
       resume_initial_connection_polyline_pt,
       resume_final_connection_polyline_pt);
      
     } // for (p < n_polyline)
    
   } // for (i < n_outer_boundaries)
  
  // ------------------------------------------------------------------
  // Internal boundaries
  // ------------------------------------------------------------------
  
  // Get the number of internal boundaries (closed boundaries)
  const unsigned n_internal_boundaries = this->Internal_polygon_pt.size();

  // Loop over the internal boundaries
  for (unsigned i = 0; i < n_internal_boundaries; i++)
   {
    // Get a temporary polygon representation
    TriangleMeshPolygon* tmp_polygon_pt = this->Internal_polygon_pt[i];
    // Get the number of polylines associated to the current internal
    // boundary
    const unsigned n_polyline = tmp_polygon_pt->npolyline();
    // Loop over the polylines
    for (unsigned p = 0; p < n_polyline; p++)
     {
      // Get a temporary representation of the polyline
      TriangleMeshPolyLine* tmp_polyline_pt = 
       tmp_polygon_pt->polyline_pt(p);
      
      // Restore the connections of the current polyline
      restore_polyline_connections_helper(
       tmp_polyline_pt,
       resume_initial_connection_polyline_pt,
       resume_final_connection_polyline_pt);
    
     } // for (p < n_polyline)
    
   } // for (i < n_internal_boundaries)
  
  // ------------------------------------------------------------------
  // Open boundaries (nonclosed internal boundaries)
  // ------------------------------------------------------------------
  
  // Get the number of internal boundaries (open boundaries)
  const unsigned n_open_boundaries = this->Internal_open_curve_pt.size();
  
  // Loop over the internal open boundaries
  for (unsigned i = 0; i < n_open_boundaries; i++)
   {
    // Get a temporary representation for the open curve
    TriangleMeshOpenCurve* tmp_open_curve_pt = 
     this->Internal_open_curve_pt[i];
    
    // Get the number of curve sections associated to the current
    // internal open boundary
    const unsigned n_curve_section = tmp_open_curve_pt->ncurve_section();
    
    // Loop over the curve section
    for (unsigned p = 0; p < n_curve_section; p++)
     {
      // Get a temporary representation of the curve section
      // (polyline)
      TriangleMeshPolyLine* tmp_polyline_pt = 
       tmp_open_curve_pt->polyline_pt(p);
      
      // Restore the connections of the current polyline
      restore_polyline_connections_helper(
       tmp_polyline_pt,
       resume_initial_connection_polyline_pt,
       resume_final_connection_polyline_pt);
      
     } // for (p < n_curve_section)
    
   } // for (i < n_open_boundaries)
  
 }
  
 //=========================================================================
 /// \short Restore the connections of the specific polyline
 /// The vertices numbering on the destination boundaries may have
 /// change because of (un)refinement in the destination boundaries.
 /// Also deals with connection that do not longer exist because the
 /// destination boundary does no longer exist because of the distribution
 /// process
 //=========================================================================
 template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::
 restore_polyline_connections_helper(
  TriangleMeshPolyLine* polyline_pt,
  Vector<TriangleMeshPolyLine*> &resume_initial_connection_polyline_pt,
  Vector<TriangleMeshPolyLine*> &resume_final_connection_polyline_pt)
 {
  // If the polyline is connected at any of its ends compute the new
  // vertex number on the destination boundary
  
  // ------------------------------------------------------------------
  // Is the initial vertex connected?
  if (polyline_pt->is_initial_vertex_connected())
   {
    // The pointer to the boundary to connect
    TriangleMeshPolyLine *poly_to_connect_pt = 0;
    
    // Get the boundary id of the destination/connected boundary
    const unsigned dst_bnd_id_initial = 
     polyline_pt->initial_vertex_connected_bnd_id();
    
    // Get the initial vertex on the current boundary
    Vector<double> src_vertex_coordinates_initial =
     polyline_pt->vertex_coordinate(0);
    
#ifdef PARANOID
      // Is the mesh distributed?
#ifdef OOMPH_HAS_MPI
    if (this->is_mesh_distributed())
     {
      // Get the initial shared boundary id
      const unsigned init_shd_bnd_id = 
       this->initial_shared_boundary_id();
      // Is the boundary to connect a shared boundary
      if (dst_bnd_id_initial >= init_shd_bnd_id)
       {
        // Get the current polyline original boundary id
        const unsigned bnd_id = polyline_pt->boundary_id();
        std::ostringstream error_message;
        error_message 
         << "INITIAL VERTEX CONNECTION\n"
         << "The current original boundary is trying to connect to a\n"
         << "shared boundary, this is not allowed. In this case the\n"
         << "shared boundary should be the one that connects with the\n"
         << "original boundary\n"
         << "The current original boundary (" << bnd_id << ") is marked\n"
         << "to have a connection at the\nINITIAL vertex (" 
         << src_vertex_coordinates_initial[0] << ","
         << src_vertex_coordinates_initial[1] << ")\n"
         << "with the shared boundary ("<< dst_bnd_id_initial << ")\n"
         << "This is the list of vertices on the shared destination boundary\n";
        // Get the pointer to the associated polyline by using the
        // boundary id
        TriangleMeshPolyLine *dst_polyline = 
         this->boundary_polyline_pt(dst_bnd_id_initial);
        // The number of vertices on the destination boundary
        const unsigned n_vertex_dst_boundary = dst_polyline->nvertex();
        // Loop over the vertices print them
        for (unsigned i = 0; i < n_vertex_dst_boundary; i++)
         {
          Vector<double> current_vertex = dst_polyline->vertex_coordinate(i);
          error_message 
           << "Vertex#(i): ("
           << current_vertex[0] << ", " << current_vertex[1] << ")\n";
         }
        throw OomphLibError(
         error_message.str(),
         "RefineableTriangleMesh::restore_polyline_connections_helper()",
         OOMPH_EXCEPTION_LOCATION);
       } // if (dst_bnd_id_initial >= init_shd_bnd_id)
      
     } // if (this->is_mesh_distributed())
#endif // #ifdef OOMPH_HAS_MPI
    
#endif // #ifdef PARANOID
    
    // Flag to indicate if the vertex was found on the destination
    // boundary
    bool found_vertex_on_dst_boundary_initial = false;
    
    // Flag that stores the chunk number to connect (only used in
    // distributed meshes)
    unsigned sub_poly_to_connect = 0;
    
    // Store the vertex number on the destination boundary
    unsigned n_vertex_connection_initial = 0;
    
    // Flags only used in a distributed mesh
    // ----------------------------------------
    // Flag to indicate we are trying to connect to an split boundary
    bool connecting_to_an_split_boundary = false;
    
    // Flag to indicate we are trying to connecto to an internal
      // boundary that is overlaped by a shared boundary)
    bool connecting_to_an_overlaped_boundary = false;
    
#ifdef OOMPH_HAS_MPI
    if (this->is_mesh_distributed())
     {
      // We can only connect to an original boundary, check if the
      // boundary was splitted during the distribution process to
      // consider all the chunks (sub-polylines) of the boundary
      if (this->boundary_was_splitted(dst_bnd_id_initial))
       {
        connecting_to_an_split_boundary = true;
       } // if (this->boundary_was_splitted(dst_bnd_id_initial))
      
      // Check if the destination boundary, or any of its chunks is
      // marked to be overlapped by a shared boundary, if that is the
      // case we can only connect to the chunks that are not
      // overlapped by shared boundaries (the shared boundaries are in
      // charge of generating the connections with original boundaries
      // and with themselves)
      if (connecting_to_an_split_boundary)
       {
        // Get the number of chucks that represent the destination
        // boundary
        const unsigned n_sub_poly = 
         this->nboundary_subpolylines(dst_bnd_id_initial);
        // Now loop over the chunks of the destination boundary and if
        // any of them is marked to be overlaped by a shared boundary
        // then set the flag and break the loop
        for (unsigned ii =0; ii < n_sub_poly; ii++)
         {
          if (this->
              boundary_marked_as_shared_boundary(dst_bnd_id_initial, ii))
           {
            // Mark the boundary as being overlaped by a shared
            // boundary
            connecting_to_an_overlaped_boundary = true;
            // Break, no need to look for more overlapings
            break;
           } // if (boundary_marked_as_shared_boundary(...))
         } // for (ii < n_sub_poly)
       } // if (connecting_to_an_split_boundary)
      else
       {
        // If not connecting to an split boundary then check if the
        // whole destination boundary is overlaped by an internal
        // boundary
        if (this->
            boundary_marked_as_shared_boundary(dst_bnd_id_initial, 0))
         {
          // Mark the boundary as being overlaped by a shared boundary
          connecting_to_an_overlaped_boundary = true;
         } // if (boundary_marked_as_shared_boundary(...))
       } // else if (connecting_to_an_split_boundary)
      
     } // if (this->is_mesh_distributed())
    
#endif // #ifdef OOMPH_HAS_MPI
    
    // If we are connecting neither to an split boundary nor an
    // overlaped boundary then get the pointer to the original
    // boundary
    if (!(connecting_to_an_split_boundary || 
          connecting_to_an_overlaped_boundary))
     {
      // Get the polyline pointer representing the destination
      // boundary
      poly_to_connect_pt = this->boundary_polyline_pt(dst_bnd_id_initial);
     } // else if (NOT split, NOT overlaped)
    
    // Now look for the vertex number on the destination boundary(ies)
    // -- in case that the boundary was split ---
    
    // Do not check for same orientation, that was previously worked
    // by interchanging the connections boundaries (if necessary)
        
    // If the boundary was not split then ...
    if (!connecting_to_an_split_boundary)
     {
      // ... check if the boundary is marked to be overlaped by
      // a shared boundary
      if (!connecting_to_an_overlaped_boundary)
       {
        // If that is not the case then we can safely look for the
        // vertex number on the destination boundary
        found_vertex_on_dst_boundary_initial = 
         this->get_connected_vertex_number_on_destination_polyline(
          poly_to_connect_pt,
          src_vertex_coordinates_initial,
          n_vertex_connection_initial);
        
       } // if (!connecting_to_an_overlaped_boundary)
      else
       {
        // If the whole boundary is marked to be overlaped by a shared
        // boundary then do nothing, the shared boundaries are already
        // in charge of performing the connection (it will be required
        // to disabled the connection) with the original boundary
        
       } // else if (!connecting_to_an_overlaped_boundary)
      
     } // if (!connecting_to_an_split_boundary)
#ifdef OOMPH_HAS_MPI
    else
     {
      // If the boundary was split then we need to look for the vertex
      // in the sub-polylines
      
      // Get the sub-polylines vector
      Vector<TriangleMeshPolyLine*> tmp_vector_subpolylines =
       this->boundary_subpolylines(dst_bnd_id_initial);
      
      // Get the number of sub-polylines
      const unsigned nsub_poly = tmp_vector_subpolylines.size();
#ifdef PARANOID
      if (nsub_poly <= 1)
       {
        std::ostringstream error_message;
        error_message
         <<"The boundary (" << dst_bnd_id_initial << ") was "
         << "marked to be splitted but\n"
         << "there are only ("<<nsub_poly<<") polylines to "
         << "represent it.\n";
        throw OomphLibError(
         error_message.str(),
         "RefineableTriangleMesh::restore_polyline_connections_helper()",
         OOMPH_EXCEPTION_LOCATION);
       } // if (nsub_poly <= 1)
#endif
      // We need to check if the boundary is marked to be overlaped by
      // a shared boundary, if that is the case we need to check for
      // each indivual subpolyline, and for those overlaped by a
      // shared polyline do nothing, the shared polylines have already
      // deal with these connections
      
      // ... check if the boundary is marked to be overlaped by
      // a shared boundary
      if (!connecting_to_an_overlaped_boundary)
       {
        // The boundary is not overlapped by shared boundaries, we can
        // work without checking the subpolylines individually (non of
        // them are overlapped by a shared boundary)
        
        // Look for the vertex number to connect on each of the
        // subpolyines
        for (unsigned isub = 0; isub < nsub_poly; isub++)
         {
          // Assign the pointer to the sub-polyline
          poly_to_connect_pt = tmp_vector_subpolylines[isub];
          // Search for the vertex in the current sub-polyline
          found_vertex_on_dst_boundary_initial = 
           this->get_connected_vertex_number_on_destination_polyline(
            poly_to_connect_pt,
            src_vertex_coordinates_initial,
            n_vertex_connection_initial);
          
          // If we have found the vertex to connect then break the
          // loop
          if (found_vertex_on_dst_boundary_initial)
           {
            // But first save the subpoly number (chunk), that will be
            // used to perform the connection
            sub_poly_to_connect = isub;
            break;
           } // if (found_vertex_on_dst_boundary_initial)
          
         } // for (isub < nsub_poly)
        
       } // if (!connecting_to_an_overlaped_boundary)
      else
       {
        // If connecting to an overlapped boundary then we ignore the
        // subpolylines overlapped by shared boundaries and only look
        // on the sub-polylines that are not marked as being overlaped
        // by shared boundaries
        
        // Look for the vertex number to connect on each of the
        // subpolyines
        for (unsigned isub = 0; isub < nsub_poly; isub++)
         {
          // Only work with those sub-polylines that are not overlaped
          // by shared boundaries
          if (!this->
              boundary_marked_as_shared_boundary(dst_bnd_id_initial, isub))
           {
            // Assign the pointer to the sub-polyline
            poly_to_connect_pt = tmp_vector_subpolylines[isub];
            
            // Search for the vertex in the current sub-polyline
            found_vertex_on_dst_boundary_initial = 
             this->get_connected_vertex_number_on_destination_polyline(
              poly_to_connect_pt,
              src_vertex_coordinates_initial,
              n_vertex_connection_initial);
            
            // Was the vertex found?
            if (found_vertex_on_dst_boundary_initial)
             {
              // But first save the subpoly number (chunk), that will
              // be used to perform the connection
              sub_poly_to_connect = isub;
              break;
             } // if (found_vertex_on_dst_boundary_initial)
            
           } // if (not overlaped by shared boundary)
          
         } // for (isub < nsub_poly)
        
       } // else if (!connecting_to_an_overlaped_boundary)
      
     } // else if (!connecting_to_an_split_boundary)
#endif // #ifdef OOMPH_HAS_MPI
    
    // If not found it may be that the connection information is
    // inverted
    if (!found_vertex_on_dst_boundary_initial)
     {
      // Is the mesh distributed?
#ifdef OOMPH_HAS_MPI
      if (this->is_mesh_distributed())
       {
        // If the mesh is distributed and the vertex number was not
        // found, that means that the boundary (or vertex) to connect
        // in the destination boundary is not in the current
        // processor. In that case suspend the connection
        polyline_pt->suspend_initial_vertex_connected();
        // Add the polyline to the vector of polylines whose
        // connection will be resumed at the end of the adaptation
        // process
        resume_initial_connection_polyline_pt.push_back(polyline_pt);
        // The shared boundaries are marked to connect to the initial
        // vertex of the polyline (remember that a shared boundary
        // stops adding nodes when it finds a node on an original
        // boundary) -- The initial vertex is now a base node
       }
      else
#endif // #ifdef OOMPH_HAS_MPI
       {
#ifdef PARANOID
        // If not found then there is a problem with the vertices
        // Get the associated boundary id of the current polyline
        const unsigned bnd_id = polyline_pt->boundary_id();
        std::ostringstream error_message;
        error_message 
         << "INITIAL VERTEX CONNECTION\n"
         << "It was not possible to find the associated "
         << "vertex number on the destination boundary\n"
         << "The current boundary (" << bnd_id << ") is marked to have"
         << "a connection at the\nINITIAL vertex (" 
         << src_vertex_coordinates_initial[0] << ","
         << src_vertex_coordinates_initial[1] << ")\n"
         << "with boundary ("<< dst_bnd_id_initial << ")\n"
         << "This is the list of vertices on the destination boundary\n";
        // Get the pointer to the associated polyline by using the
        // boundary id
        TriangleMeshPolyLine *dst_polyline = 
         this->boundary_polyline_pt(dst_bnd_id_initial);
        // The number of vertices on the destination boundary
        const unsigned n_vertex_dst_boundary = dst_polyline->nvertex();
        // Loop over the vertices print them
        for (unsigned i = 0; i < n_vertex_dst_boundary; i++)
         {
          Vector<double> current_vertex = dst_polyline->vertex_coordinate(i);
          error_message 
           << "Vertex#(i): ("
           << current_vertex[0] << ", " << current_vertex[1] << ")\n";
         }
        throw OomphLibError(
         error_message.str(),
         "RefineableTriangleMesh::restore_polyline_connections_helper()",
         OOMPH_EXCEPTION_LOCATION);
#endif
        
       } // else if (this->is_mesh_distributed())
      
     } // if (!found_vertex_on_dst_boundary_initial)
    else
     {
      // Set the vertex number on the destination boundary
      polyline_pt->initial_vertex_connected_n_vertex() = 
       n_vertex_connection_initial;
      
      // Set the chunk number on the destination boundary
      polyline_pt->initial_vertex_connected_n_chunk() =
       sub_poly_to_connect;
      
     } // else if (!found_vertex_on_dst_boundary_initial)
    
   } // if (polyline_pt->is_initial_vertex_connected())
  
  // ------------------------------------------------------------------
  // Is the final vertex connected?
  if (polyline_pt->is_final_vertex_connected())
   {
    // The pointer to the boundary to connect
    TriangleMeshPolyLine *poly_to_connect_pt = 0;
    
    // Get the boundary id of the destination/connected boundary
    const unsigned dst_bnd_id_final = 
     polyline_pt->final_vertex_connected_bnd_id();
    
    // Get the final vertex on the current boundary
    const unsigned tmp_n_vertices = polyline_pt->nvertex();
    Vector<double> src_vertex_coordinates_final =
     polyline_pt->vertex_coordinate(tmp_n_vertices-1);
    

#ifdef PARANOID
      // Is the mesh distributed?
#ifdef OOMPH_HAS_MPI
    if (this->is_mesh_distributed())
     {
      // Get the initial shared boundary id
      const unsigned init_shd_bnd_id = 
       this->initial_shared_boundary_id();
      // Is the boundary to connect a shared boundary
      if (dst_bnd_id_final >= init_shd_bnd_id)
       {
        // Get the current polyline original boundary id
        const unsigned bnd_id = polyline_pt->boundary_id();
        std::ostringstream error_message;
        error_message 
         << "FINAL VERTEX CONNECTION\n"
         << "The current original boundary is trying to connect to a\n"
         << "shared boundary, this is not allowed. In this case the\n"
         << "shared boundary should be the one that connects with the\n"
         << "original boundary\n"
         << "The current boundary (" << bnd_id << ") is marked to have "
         << "a connection at the\nFINAL vertex (" 
         << src_vertex_coordinates_final[0] << ","
         << src_vertex_coordinates_final[1] << ")\n"
         << "with boundary ("<< dst_bnd_id_final << ")\n"
         << "This is the list of vertices on the destination boundary\n";
        // Get the pointer to the associated polyline by using the
        // boundary id
        TriangleMeshPolyLine *dst_polyline = 
         this->boundary_polyline_pt(dst_bnd_id_final);
        // The number of vertices on the destination boundary
        const unsigned n_vertex_dst_boundary = dst_polyline->nvertex();
        // Loop over the vertices print them
        for (unsigned i = 0; i < n_vertex_dst_boundary; i++)
         {
          Vector<double> current_vertex = dst_polyline->vertex_coordinate(i);
          error_message 
           << "Vertex#("<<i<<"): ("
           << current_vertex[0] << ", " << current_vertex[1] << ")\n";
         }
        throw OomphLibError(
         error_message.str(),
         "RefineableTriangleMesh::restore_polyline_connections_helper()",
         OOMPH_EXCEPTION_LOCATION);
       } // if (dst_bnd_id_initial >= init_shd_bnd_id)
      
     } // if (this->is_mesh_distributed())
#endif // #ifdef OOMPH_HAS_MPI
    
#endif // #ifdef PARANOID
    
    // Flag to indicate if the vertex was found on the destination
    // boundary
    bool found_vertex_on_dst_boundary_final = false;
    
    // Flag that stores the chunk number to connect (only used in
    // distributed meshes)
    unsigned sub_poly_to_connect = 0;
    
    // Store the vertex number on the destination boundary
    unsigned n_vertex_connection_final = 0;
    
    // Flags only used in a distributed mesh
    // ----------------------------------------
    // Flag to indicate we are trying to connect to an split boundary
    bool connecting_to_an_split_boundary = false;
    
    // Flag to indicate we are trying to connecto to an internal
      // boundary that is overlaped by a shared boundary)
    bool connecting_to_an_overlaped_boundary = false;
    
#ifdef OOMPH_HAS_MPI
    if (this->is_mesh_distributed())
     {
      // We can only connect to an original boundary, check if the
      // boundary was splitted during the distribution process to
      // consider all the chunks (sub-polylines) of the boundary
      if (this->boundary_was_splitted(dst_bnd_id_final))
       {
        connecting_to_an_split_boundary = true;
       } // if (this->boundary_was_splitted(dst_bnd_id_final))
      
      // Check if the destination boundary, or any of its chunks is
      // marked to be overlapped by a shared boundary, if that is the
      // case we can only connect to the chunks that are not
      // overlapped by shared boundaries (the shared boundaries are in
      // charge of generating the connections with original boundaries
      // and with themselves)
      if (connecting_to_an_split_boundary)
       {
        // Get the number of chucks that represent the destination
        // boundary
        const unsigned n_sub_poly = 
         this->nboundary_subpolylines(dst_bnd_id_final);
        // Now loop over the chunks of the destination boundary and if
        // any of them is marked to be overlaped by a shared boundary
        // then set the flag and break the loop
        for (unsigned ii =0; ii < n_sub_poly; ii++)
         {
          if (this->
              boundary_marked_as_shared_boundary(dst_bnd_id_final, ii))
           {
            // Mark the boundary as being overlaped by a shared
            // boundary
            connecting_to_an_overlaped_boundary = true;
            // Break, no need to look for more overlapings
            break;
           } // if (boundary_marked_as_shared_boundary(...))
         } // for (ii < n_sub_poly)
       } // if (connecting_to_an_split_boundary)
      else
       {
        // If not connecting to an split boundary then check if the
        // whole destination boundary is overlaped by an internal
        // boundary
        if (this->
            boundary_marked_as_shared_boundary(dst_bnd_id_final, 0))
         {
          // Mark the boundary as being overlaped by a shared boundary
          connecting_to_an_overlaped_boundary = true;
         } // if (boundary_marked_as_shared_boundary(...))
       } // else if (connecting_to_an_split_boundary)
      
     } // if (this->is_mesh_distributed())
    
#endif // #ifdef OOMPH_HAS_MPI
    
    // If we are connecting neither to an split boundary nor an
    // overlaped boundary then get the pointer to the original
    // boundary
    if (!(connecting_to_an_split_boundary || 
          connecting_to_an_overlaped_boundary))
     {
      // Get the polyline pointer representing the destination
      // boundary
      poly_to_connect_pt = this->boundary_polyline_pt(dst_bnd_id_final);
     } // else if (NOT split, NOT overlaped)
    
    // Now look for the vertex number on the destination boundary(ies)
    // -- in case that the boundary was split ---
    
    // Do not check for same orientation, that was previously worked
    // by interchanging the connections boundaries (if necessary)
    
    // If the boundary was not split then ...
    if (!connecting_to_an_split_boundary)
     {
      // ... check if the boundary is marked to be overlaped by
      // a shared boundary
      if (!connecting_to_an_overlaped_boundary)
       {
        // If that is not the case then we can safely look for the
        // vertex number on the destination boundary
        found_vertex_on_dst_boundary_final = 
         this->get_connected_vertex_number_on_destination_polyline(
          poly_to_connect_pt,
          src_vertex_coordinates_final,
          n_vertex_connection_final);
        
       } // if (!connecting_to_an_overlaped_boundary)
      else
       {
        // If the whole boundary is marked to be overlaped by a shared
        // boundary then do nothing, the shared boundaries are already
        // in charge of performing the connection (it will be required
        // to disabled the connection) with the original boundary
        
       } // else if (!connecting_to_an_overlaped_boundary)
      
     } // if (!connecting_to_an_split_boundary)
#ifdef OOMPH_HAS_MPI
    else
     {
      // If the boundary was split then we need to look for the vertex
      // in the sub-polylines
      
      // Get the sub-polylines vector
      Vector<TriangleMeshPolyLine*> tmp_vector_subpolylines =
       this->boundary_subpolylines(dst_bnd_id_final);
      
      // Get the number of sub-polylines
      const unsigned nsub_poly = tmp_vector_subpolylines.size();
#ifdef PARANOID
      if (nsub_poly <= 1)
       {
        std::ostringstream error_message;
        error_message
         <<"The boundary (" << dst_bnd_id_final << ") was "
         << "marked to be splitted but\n"
         << "there are only ("<<nsub_poly<<") polylines to "
         << "represent it.\n";
        throw OomphLibError(
         error_message.str(),
         "RefineableTriangleMesh::restore_polyline_connections_helper()",
         OOMPH_EXCEPTION_LOCATION);
       } // if (nsub_poly <= 1)
#endif
      // We need to check if the boundary is marked to be overlaped by
      // a shared boundary, if that is the case we need to check for
      // each indivual subpolyline, and for those overlaped by a
      // shared polyline do nothing, the shared polylines have already
      // deal with these connections
      
      // ... check if the boundary is marked to be overlaped by
      // a shared boundary
      if (!connecting_to_an_overlaped_boundary)
       {
        // The boundary is not overlapped by shared boundaries, we can
        // work without checking the subpolylines individually (non of
        // them are overlapped by a shared boundary)
        
        // Look for the vertex number to connect on each of the
        // subpolyines
        for (unsigned isub = 0; isub < nsub_poly; isub++)
         {
          // Assign the pointer to the sub-polyline
          poly_to_connect_pt = tmp_vector_subpolylines[isub];
          // Search for the vertex in the current sub-polyline
          found_vertex_on_dst_boundary_final = 
           this->get_connected_vertex_number_on_destination_polyline(
            poly_to_connect_pt,
            src_vertex_coordinates_final,
            n_vertex_connection_final);
          
          // If we have found the vertex to connect then break the
          // loop
          if (found_vertex_on_dst_boundary_final)
           {
            // But first save the subpoly number (chunk), that will be
            // used to perform the connection
            sub_poly_to_connect = isub;
            break;
           } // if (found_vertex_on_dst_boundary_initial)
          
         } // for (isub < nsub_poly)
        
       } // if (!connecting_to_an_overlaped_boundary)
      else
       {
        // If connecting to an overlapped boundary then we ignore the
        // subpolylines overlapped by shared boundaries and only look
        // on the sub-polylines that are not marked as being overlaped
        // by shared boundaries
        
        // Look for the vertex number to connect on each of the
        // subpolyines
        for (unsigned isub = 0; isub < nsub_poly; isub++)
         {
          // Only work with those sub-polylines that are not overlaped
          // by shared boundaries
          if (!this->
              boundary_marked_as_shared_boundary(dst_bnd_id_final, isub))
           {
            // Assign the pointer to the sub-polyline
            poly_to_connect_pt = tmp_vector_subpolylines[isub];
            
            // Search for the vertex in the current sub-polyline
            found_vertex_on_dst_boundary_final = 
             this->get_connected_vertex_number_on_destination_polyline(
              poly_to_connect_pt,
              src_vertex_coordinates_final,
              n_vertex_connection_final);
            
            // Was the vertex found?
            if (found_vertex_on_dst_boundary_final)
             {
              // But first save the subpoly number (chunk), that will
              // be used to perform the connection
              sub_poly_to_connect = isub;
              break;
             } // if (found_vertex_on_dst_boundary_final)
            
           } // if (not overlaped by shared boundary)
          
         } // for (isub < nsub_poly)
        
       } // else if (!connecting_to_an_overlaped_boundary)
      
     } // else if (!connecting_to_an_split_boundary)
#endif // #ifdef OOMPH_HAS_MPI
    
    // If not found it may be that the connection information is
    // inverted
    if (!found_vertex_on_dst_boundary_final)
     {
      // Is the mesh distributed?
#ifdef OOMPH_HAS_MPI
      if (this->is_mesh_distributed())
       {
        // If the mesh is distributed and the vertex number was not
        // found, that means that the boundary (or vertex) to connect
        // in the destination boundary is not in the current
        // processor. In that suspend the connection
        polyline_pt->suspend_final_vertex_connected();
        // Add the polyline to the vector of polylines whose
        // connection will be resumed at the end of the adaptation
        // process
        resume_final_connection_polyline_pt.push_back(polyline_pt);
        // The shared boundaries are marked to connect to the final
        // vertex of the polyline (remember that a shared boundary
        // stops adding nodes when it finds a node on an original
        // boundary) -- The final vertex is now a base node
       } // if (this->is_mesh_distributed())
      else
#endif // #ifdef OOMPH_HAS_MPI
       {
#ifdef PARANOID
        // If not found then there is a problem with the vertices
        // Get the associated boundary id of the current polyline
        const unsigned bnd_id = polyline_pt->boundary_id();
        std::ostringstream error_message;
        error_message 
         << "FINAL VERTEX CONNECTION\n"
         << "It was not possible to find the associated "
         << "vertex number on the destination boundary\n"
         << "The current boundary (" << bnd_id << ") is marked to have "
         << "a connection at the\nFINAL vertex (" 
         << src_vertex_coordinates_final[0] << ","
         << src_vertex_coordinates_final[1] << ")\n"
         << "with boundary ("<< dst_bnd_id_final << ")\n"
         << "This is the list of vertices on the destination boundary\n";
        // Get the pointer to the associated polyline by using the
        // boundary id
        TriangleMeshPolyLine *dst_polyline = 
         this->boundary_polyline_pt(dst_bnd_id_final);
        // The number of vertices on the destination boundary
        const unsigned n_vertex_dst_boundary = dst_polyline->nvertex();
        // Loop over the vertices print them
        for (unsigned i = 0; i < n_vertex_dst_boundary; i++)
         {
          Vector<double> current_vertex = dst_polyline->vertex_coordinate(i);
          error_message 
           << "Vertex#("<<i<<"): ("
           << current_vertex[0] << ", " << current_vertex[1] << ")\n";
         }
        throw OomphLibError(
         error_message.str(),
         "RefineableTriangleMesh::restore_polyline_connections_helper()",
         OOMPH_EXCEPTION_LOCATION);
#endif
       } // else if (this->is_mesh_distributed())
      
     } // if (!found_vertex_on_dst_boundary_final)
    else
     {
      // Set the vertex number on the destination boundary
      polyline_pt->final_vertex_connected_n_vertex() = 
       n_vertex_connection_final;
      
      // Set the chunk number on the destination boundary
      polyline_pt->final_vertex_connected_n_chunk() =
       sub_poly_to_connect;
      
     } // else if (!found_vertex_on_dst_boundary_final)
    
   } // if (polyline_pt->is_final_vertex_connected())
  
 }
 
 //=========================================================================
 /// \short Resume the boundary connections that may have been
 /// suspended because the destination boundary is no part of the
 /// domain. The connections are no permanently suspended because if
 /// load balance takes place the destination boundary may be part of
 /// the new domain representation therefore the connection would
 /// exist
 //=========================================================================
 template<class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::resume_boundary_connections(
  Vector<TriangleMeshPolyLine*> &resume_initial_connection_polyline_pt,
  Vector<TriangleMeshPolyLine*> &resume_final_connection_polyline_pt)
 {
  // Get the number of polylines that require to resume the connection
  // at the initial vertex
  const unsigned n_initial_poly = 
   resume_initial_connection_polyline_pt.size();
  // Loop over the polylines that require to resume the connection
  // at the initial vertex
  for (unsigned p = 0; p < n_initial_poly; p++)
   {
    // Get the polyline
    TriangleMeshPolyLine* tmp_poly_pt = 
     resume_initial_connection_polyline_pt[p];
    // Resume the connection with the initial vertex
    tmp_poly_pt->resume_initial_vertex_connected();
   } // for (p < n_initial_poly)
  
  // Get the number of polylines that require to resume the connection
  // at the final vertex
  const unsigned n_final_poly = 
   resume_final_connection_polyline_pt.size();
  // Loop over the polylines that require to resume the connection at
  // the final vertex
  for (unsigned p = 0; p < n_final_poly; p++)
   {
    // Get the polyline
    TriangleMeshPolyLine* tmp_poly_pt = 
     resume_final_connection_polyline_pt[p];
    // Resume the connection with the final vertex
    tmp_poly_pt->resume_final_vertex_connected();
   } // for (p < n_final_poly)
  
  // Clear the storage
  resume_initial_connection_polyline_pt.clear(); 
  resume_final_connection_polyline_pt.clear();
  
 }
 
//=========================================================================
/// \short Gets the associated vertex number according to the vertex
/// coordinates on the destination boundary
//=========================================================================
template<class ELEMENT>
bool RefineableTriangleMesh<ELEMENT>::
get_connected_vertex_number_on_dst_boundary(
  Vector<double> &vertex_coordinates,
  const unsigned &dst_bnd_id,
  unsigned &vertex_number)
 {

  bool found_associated_vertex_number = false;

  // Get the pointer to the associated polyline by using the boundary id
  TriangleMeshPolyLine *dst_polyline =
    this->boundary_polyline_pt(dst_bnd_id);

  const unsigned n_vertices = dst_polyline->nvertex();
  
  // Loop over the vertices and return the closest vertex
  // to the given vertex coordinates
  for (unsigned i = 0; i < n_vertices; i++)
   {

    Vector<double> current_vertex =
    dst_polyline->vertex_coordinate(i);

    double error =
    (vertex_coordinates[0] - current_vertex[0])*
    (vertex_coordinates[0] - current_vertex[0])
    +
    (vertex_coordinates[1] - current_vertex[1])*
    (vertex_coordinates[1] - current_vertex[1]);

    error = sqrt(error);

    if(error <
      ToleranceForVertexMismatchInPolygons::Tolerable_error)
     {
      vertex_number = i;
      found_associated_vertex_number = true;
      break;
     }

   }
  
  return found_associated_vertex_number;
  
 }

//=========================================================================
/// \short Helper function that updates the input polygon's PSLG
/// by using the end-points of elements from FaceMesh(es) that are
/// constructed for the boundaries associated with the segments of the
/// polygon. Optional boolean is used to run it as test only (if
/// true is specified as input) in which case polygon isn't actually
/// modified. Returned boolean indicates if polygon was (or would have
/// been -- if called with check_only=false) changed.
//=========================================================================
template<class ELEMENT>
bool RefineableTriangleMesh<ELEMENT>::
update_polygon_using_face_mesh(TriangleMeshPolygon* polygon_pt,
                               const bool& check_only)
  {
#ifdef PARANOID
   // If the mesh is marked as distributed this method can not be
   // called since there is no guarantee of creating (distributed)
   // meshes that match in the number and position of nodes at their
   // shared boundaries. The only exececption is when called with
   // check_only=true, since no boundary updating is performed
   if (this->is_mesh_distributed() && !check_only)
    {
     std::stringstream error_message;
     error_message
      << "The updating of polygons of a distributed mesh can ONLY be\n"
      << "performed using the element's area associated to the halo(ed)\n"
      << "elements.\n"
      << "1) Make sure you have enabled the parallel mesh adaptation\n"
      << "option if you are working with a distributed mesh, OR\n"
      << "2) Make sure to call the update_..._using_elements_area() methods\n"
      << "if the mesh is marked as distributed\n\n";
      throw OomphLibError(error_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
    } // if (this->is_mesh_distributed())
#endif
   
 // Boolean that indicates whether an actual update of the polygon
 // was performed or not
 bool unrefinement_was_performed=false;
 bool refinement_was_performed=false;
 bool max_length_applied = false;

 //Loop over the number of polylines
 const unsigned n_polyline = polygon_pt->npolyline();
 
 // Get face mesh representation of all polylines, possibly
 // with segments re-distributed to maintain an approximately
 // even sub-division of the polygon
 Vector<Mesh*> face_mesh_pt;
 get_face_mesh_representation(polygon_pt,face_mesh_pt);

 // Create vertices for the polylines by using the vertices
 // of the FaceElements
 Vector<double> vertex_coord(3); // zeta,x,y
 Vector<double> bound_left(1);
 Vector<double> bound_right(1);

 for(unsigned p=0;p<n_polyline;p++)
  {
   // Set of coordinates that will be placed on the boundary
   // Set entries are ordered on first  entry in vector which stores
   // the boundary coordinate so the vertices come out in order!
   std::set<Vector<double> > vertex_nodes;
   
   //Get the boundary id
   const unsigned bound = polygon_pt->curve_section_pt(p)->boundary_id();
   
   // Get the chunk number
   const unsigned chunk = polygon_pt->curve_section_pt(p)->boundary_chunk();
   
   // Loop over the face elements (ordered) and add their vertices
   unsigned n_face_element = face_mesh_pt[p]->nelement();
   for(unsigned e=0;e<n_face_element;++e)
    {
     FiniteElement* el_pt = face_mesh_pt[p]->finite_element_pt(e);
     
#ifdef OOMPH_HAS_MPI
     // Only work with non-halo elements if the mesh is distributed
     if (this->is_mesh_distributed() && el_pt->is_halo()) {continue;}
#endif
     
     unsigned n_node = el_pt->nnode();
         
     //Add the left-hand node to the set:
         
     // Boundary coordinate
     el_pt->node_pt(0)->get_coordinates_on_boundary(bound,bound_left);
     vertex_coord[0] = bound_left[0];
         
     // Actual coordinates
     for(unsigned i=0;i<2;i++)
      {
       vertex_coord[i+1] = el_pt->node_pt(0)->x(i);
      }
     vertex_nodes.insert(vertex_coord);
         
     //Add the right-hand nodes to the set:
         
     //Boundary coordinate
     el_pt->node_pt(n_node-1)->
      get_coordinates_on_boundary(bound,bound_right);
     vertex_coord[0] = bound_right[0];
         
     // Actual coordinates
     for(unsigned i=0;i<2;i++)
      {
       vertex_coord[i+1] = el_pt->node_pt(n_node-1)->x(i);
      }
     vertex_nodes.insert(vertex_coord);
     
    }

   // Now turn into vector for ease of handling...
   unsigned n_poly_vertex = vertex_nodes.size();
   Vector<Vector<double> > tmp_vector_vertex_node(n_poly_vertex);
   unsigned count=0;
   for(std::set<Vector<double> >::iterator it = vertex_nodes.begin();
     it!=vertex_nodes.end();++it)
    {
     tmp_vector_vertex_node[count].resize(3);
     tmp_vector_vertex_node[count][0] = (*it)[0];
     tmp_vector_vertex_node[count][1] = (*it)[1];
     tmp_vector_vertex_node[count][2] = (*it)[2];
     ++count;
    }

   // Size of the vector
   unsigned n_vertex=tmp_vector_vertex_node.size();

   // Tolerance below which the middle point can be deleted
   // (ratio of deflection to element length)
   double unrefinement_tolerance=
    polygon_pt->polyline_pt(p)->unrefinement_tolerance();

   //------------------------------------------------------
   // Unrefinement
   //------------------------------------------------------
   if (unrefinement_tolerance>0.0 && n_vertex>=3)
    {
     unrefinement_was_performed =
       unrefine_boundary(bound, chunk, tmp_vector_vertex_node,
			 unrefinement_tolerance, check_only);

     // In this case the "unrefinement_was_performed" variable
     // tell us if the update had been performed when calling
     // with check_oly=false
     if (check_only && unrefinement_was_performed)
      {
       // Cleanup (but only the elements -- the nodes still exist in
       // the bulk mesh!
       for(unsigned p=0;p<n_polyline;p++)
        {
         face_mesh_pt[p]->flush_node_storage();
         delete face_mesh_pt[p];
        }
       return true;
      }

    } // end of unrefinement

   // Do not perform refinement if there are no more than two vertices
   // New size of the vector
   n_vertex=tmp_vector_vertex_node.size();

   //------------------------------------------------
   // Refinement
   //------------------------------------------------
   double refinement_tolerance=
    polygon_pt->polyline_pt(p)->refinement_tolerance();
   if (refinement_tolerance>0.0 && n_vertex >= 2)
    {
     refinement_was_performed =
      refine_boundary(face_mesh_pt[p], tmp_vector_vertex_node,
                      refinement_tolerance, check_only);

     // In this case the "refinement_was_performed" variable
     // tell us if the update had been performed when calling
     // with check_only=false
     if (check_only && refinement_was_performed)
      {
       // Cleanup (but only the elements -- the nodes still exist in
       // the bulk mesh!
       for(unsigned p=0;p<n_polyline;p++)
        {
         face_mesh_pt[p]->flush_node_storage();
         delete face_mesh_pt[p];
        }
       return true;
      }

    } // end refinement

   // Do not perform maximum length constraint if there are no more than
   // two vertices
   // New size of the vector
   n_vertex=tmp_vector_vertex_node.size();

   //------------------------------------------------
   // Maximum length constrait
   //-----------------------------------------------
   double maximum_length = polygon_pt->polyline_pt(p)->maximum_length();
   if (maximum_length > 0.0 && n_vertex >= 2)
    {
     max_length_applied = 
      apply_max_length_constraint(face_mesh_pt[p], 
                                  tmp_vector_vertex_node,
                                  maximum_length);
     
     // In this case the max length criteria was applied, check if 
     // check_only=false
     if (check_only && max_length_applied)
      {
       // Cleanup (but only the elements -- the nodes still exist in
       // the bulk mesh!
       for(unsigned p=0;p<n_polyline;p++)
        {
         face_mesh_pt[p]->flush_node_storage();
         delete face_mesh_pt[p];
        }
       return true;
      }

    }

   // For further processing the three-dimensional vector
   // has to be reduced to a two-dimensional vector
   n_vertex=tmp_vector_vertex_node.size();
   Vector<Vector<double> > vector_vertex_node(n_vertex);

   for(unsigned i=0;i<n_vertex;i++)
    {
     vector_vertex_node[i].resize(2);
     vector_vertex_node[i][0]=tmp_vector_vertex_node[i][1];
     vector_vertex_node[i][1]=tmp_vector_vertex_node[i][2];
    }
   
#ifdef OOMPH_HAS_MPI
   // Only perform this checking if the mesh is not distributed. When
   // the mesh is distributed the polylines continuity is addressed in
   // the sort_polylines_helper() method
   if (!this->is_mesh_distributed())
#endif
    {
     if ( (p > 0) && !check_only )
      {
       //Final end point of previous line
       Vector<double> final_vertex_of_previous_segment;
       unsigned n_prev_vertex =
        polygon_pt->curve_section_pt(p-1)->nvertex();
       final_vertex_of_previous_segment =
        polygon_pt->polyline_pt(p-1)->
        vertex_coordinate(n_prev_vertex-1);

       unsigned prev_seg_boundary_id =
        polygon_pt->curve_section_pt(p-1)->boundary_id();

       //Find the error between the final vertex of the previous
       //line and the first vertex of the current line
       double error = 0.0;
       for(unsigned i=0;i<2;i++)
        {
         const double dist =
          final_vertex_of_previous_segment[i] -
          (*vector_vertex_node.begin())[i];
         error += dist*dist;
        }
       error = sqrt(error);

       //If the error is bigger than the tolerance then
       //we probably need to reverse, but better check
       if(error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
        {
         //Find the error between the final vertex of the previous
         //line and the last vertex of the current line
         double rev_error = 0.0;
         for(unsigned i=0;i<2;i++)
          {
           const double dist =
            final_vertex_of_previous_segment[i] -
            (*--vector_vertex_node.end())[i];
           rev_error += dist*dist;
          }
         rev_error = sqrt(rev_error);

         if(rev_error >
            ToleranceForVertexMismatchInPolygons::Tolerable_error)
          {
           // It could be possible that the first segment be reversed and we
           // did not notice it because this check does not apply for the
           // first segment. We can verify if the first segment is reversed
           // by using the vertex number 1
           if (p == 1)
            {

             //Initial end point of previous line
             Vector<double> initial_vertex_of_previous_segment;

             initial_vertex_of_previous_segment =
              polygon_pt->polyline_pt(p-1)->
              vertex_coordinate(0);

             unsigned prev_seg_boundary_id =
              polygon_pt->curve_section_pt(p-1)->boundary_id();

             //Find the error between the initial vertex of the previous
             //line and the first vertex of the current line
             double error = 0.0;
             for(unsigned i=0;i<2;i++)
              {
               const double dist =
                initial_vertex_of_previous_segment[i] -
                (*vector_vertex_node.begin())[i];
               error += dist*dist;
              }
             error = sqrt(error); // Reversed only the previous one

             //If the error is bigger than the tolerance then
             //we probably need to reverse, but better check
             if(error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
              {
               //Find the error between the final vertex of the previous
               //line and the last vertex of the current line
               double rev_error = 0.0;
               for(unsigned i=0;i<2;i++)
                {
                 const double dist =
                  initial_vertex_of_previous_segment[i] -
                  (*--vector_vertex_node.end())[i];
                 rev_error += dist*dist;
                }
               rev_error = sqrt(rev_error); // Reversed both the current one and
               // the previous one

               if (rev_error >
                   ToleranceForVertexMismatchInPolygons::Tolerable_error)
                {
                 std::ostringstream error_stream;
                 error_stream 
                  <<"The distance between the first node of the current\n"
                  <<"line segment (boundary " << bound << ") and either end of "
                  << "the previous line segment\n"
                  << "(boundary " << prev_seg_boundary_id << ") is bigger than "
                  << "the desired tolerance " <<
                  ToleranceForVertexMismatchInPolygons::Tolerable_error << ".\n"
                  << "This suggests that the polylines defining the polygonal\n"
                  << "representation are not properly ordered.\n"
                  << "Fail on last vertex of polyline: ("
                  << prev_seg_boundary_id<< ") and\nfirst vertex of polyline ("
                  << bound << ").\nThis should have failed when first trying to "
                  << "construct the\npolygon.\n";
                 throw OomphLibError(error_stream.str(),
                  OOMPH_CURRENT_FUNCTION,
                  OOMPH_EXCEPTION_LOCATION);

                }
               else
                {
                 // Reverse both
                 // Reverse the current vector to line up with the previous one
                 std::reverse(vector_vertex_node.begin(),
                              vector_vertex_node.end());

                 polygon_pt->polyline_pt(p-1)->reverse();
                }
              }
             else
              {
               // Reverse the previous one
               polygon_pt->polyline_pt(p-1)->reverse();
              }

            } // if p == 1
           else
            {
             std::ostringstream error_stream;
             error_stream
              <<"The distance between the first node of the current\n"
              <<"line segment (boundary " << bound << ") and either end of "
              << "the previous line segment\n"
              << "(boundary " << prev_seg_boundary_id << ") is bigger than the "
              << "desired tolerance " <<
              ToleranceForVertexMismatchInPolygons::Tolerable_error << ".\n"
              <<"This suggests that the polylines defining the polygonal\n"
              <<"representation are not properly ordered.\n"
              << "Fail on last vertex of polyline: (" << prev_seg_boundary_id
              << ") and\nfirst vertex of polyline (" << bound << ").\n"
              << "This should have failed when first trying to construct the\n"
              << "polygon.\n";
             throw OomphLibError(error_stream.str(),
                                 OOMPH_CURRENT_FUNCTION,
                                 OOMPH_EXCEPTION_LOCATION);
            }
          }
         else
          {
           //Reverse the current vector to line up with the previous one
           std::reverse(vector_vertex_node.begin(),vector_vertex_node.end());
          }

        } // first error
      } // p > 0
    } // is mesh not distributed?

   if(!check_only)
    {
     // Now update the polyline according to the new vertices
     // The new one representation
     TriangleMeshPolyLine *tmp_polyline_pt =
      new TriangleMeshPolyLine(vector_vertex_node,bound);
     
     // Create a temporal "curve section" version of the recently created
     // polyline
     TriangleMeshCurveSection *tmp_curve_section_pt = tmp_polyline_pt;

     // Establish refinement and unrefinement tolerance
     tmp_polyline_pt->set_unrefinement_tolerance(
      unrefinement_tolerance);
     tmp_polyline_pt->set_refinement_tolerance(
      refinement_tolerance);
     
     // Establish the maximum length constraint
     tmp_polyline_pt->set_maximum_length(maximum_length);
     
     // We pass the connection information from the old polyline to
     // the new one
     this->copy_connection_information(polygon_pt->polyline_pt(p), 
                                       tmp_curve_section_pt);
     
     //Now update the polyline according to the new vertices but
     //first check if the object is allowed to delete the representation
     //or if it should be done by other object
     bool delete_it_on_destructor = false;

     std::set<TriangleMeshCurveSection*>::iterator it =
       this->Free_curve_section_pt.find(polygon_pt->curve_section_pt(p));

     if (it!=this->Free_curve_section_pt.end())
      {
       this->Free_curve_section_pt.erase(it);
       delete polygon_pt->curve_section_pt(p);
       delete_it_on_destructor = true;
      }

     // ------------------------------------------------------------
     // Copying the new representation
     polygon_pt->curve_section_pt(p) = tmp_polyline_pt;
     
     // Update the Boundary - Polyline map
     this->Boundary_curve_section_pt[bound] = polygon_pt->curve_section_pt(p);
     
     if (delete_it_on_destructor)
      {
       this->Free_curve_section_pt.insert(polygon_pt->curve_section_pt(p));
      }

    } // if(!check_only)
   
  } // for (p < n_polyline)

 // Cleanup (but only the elements -- the nodes still exist in
 // the bulk mesh!
 for(unsigned p=0;p<n_polyline;p++)
  {
   face_mesh_pt[p]->flush_node_storage();
   delete face_mesh_pt[p];
  }

 if(check_only)
  {
   // if we end up all the way down here, no update of the internal boundaries
   // is necessary (in case we only check)
   return false;
  }
 else
  {
   // if we not only check, but actually perform the update and end up
   // all the way down here then we indicate whether an update was performed
   // or not
   return (unrefinement_was_performed || 
           refinement_was_performed || 
           max_length_applied);
  }

  }

//=========================================================================
/// \short Helper function that updates the input open curve by using
/// end-points of elements from FaceMesh(es) that are constructed for the
/// boundaries associated with the polylines. Optional boolean is used to
/// run it as test only (if true is specified as input) in which case the
/// polylines are not actually modified. Returned boolean indicates if
/// polylines were (or would have been -- if called with check_only=false)
/// changed.
//=========================================================================
template<class ELEMENT>
bool RefineableTriangleMesh<ELEMENT>::
update_open_curve_using_face_mesh(TriangleMeshOpenCurve* open_polyline_pt,
                                  const bool& check_only)
  {
#ifdef PARANOID
   // If the mesh is marked as distributed this method can not be
   // called since there is no guarantee of creating (distributed)
   // meshes that match in the number and position of nodes at their
   // shared boundaries. The only exececption is when called with
   // check_only=true, since no boundary updating is performed
   if (this->is_mesh_distributed() && !check_only)
    {
     std::stringstream error_message;
     error_message
      << "The updating of open curves of a distributed mesh can ONLY be\n"
      << "performed using the element's area associated to the halo(ed)\n"
      << "elements.\n"
      << "1) Make sure you have enabled the parallel mesh adaptation\n"
      << "option if you are working with a distributed mesh, OR\n"
      << "2) Make sure to call the update_..._using_elements_area() methods\n"
      << "if the mesh is marked as distributed\n\n";
      throw OomphLibError(error_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
    } // if (this->is_mesh_distributed())
#endif

  // Boolean that indicates whether an actual update of the polylines
  // were performed or not
  bool unrefinement_was_performed=false;
  bool refinement_was_performed=false;
  bool max_length_applied = false;

  //Loop over the number of polylines
  const unsigned n_polyline = open_polyline_pt->ncurve_section();

  // Get face mesh representation of all polylines, possibly
  // with segments re-distributed to maintain an approximately
  // even sub-division of the polygon
  Vector<Mesh*> face_mesh_pt;
  get_face_mesh_representation(open_polyline_pt, face_mesh_pt);

  // Create vertices for the polylines by using the vertices
  // of the FaceElements
  Vector<double> vertex_coord(3); // zeta,x,y
  Vector<double> bound_left(1);
  Vector<double> bound_right(1);

  for(unsigned p=0;p<n_polyline;p++)
   {
    // Set of coordinates that will be placed on the boundary
    // Set entries are ordered on first  entry in vector which stores
    // the boundary coordinate so the vertices come out in order!
    std::set<Vector<double> > vertex_nodes;

    //Get the boundary id
    const unsigned bound = 
     open_polyline_pt->curve_section_pt(p)->boundary_id();
    
    // Get the chunk number
    const unsigned chunk = 
     open_polyline_pt->curve_section_pt(p)->boundary_chunk();
    
    // Loop over the face elements (ordered) and add their vertices
    unsigned n_face_element = face_mesh_pt[p]->nelement();

    //n_count = 0;
    for(unsigned e=0;e<n_face_element;++e)
     {
      FiniteElement* el_pt = face_mesh_pt[p]->finite_element_pt(e);
      unsigned n_node = el_pt->nnode();

      //Add the left-hand node to the set:

      // Boundary coordinate
      el_pt->node_pt(0)->get_coordinates_on_boundary(bound,bound_left);
      vertex_coord[0] = bound_left[0];

      // Actual coordinates
      for(unsigned i=0;i<2;i++)
       {
        vertex_coord[i+1] = el_pt->node_pt(0)->x(i);
       }
      vertex_nodes.insert(vertex_coord);

      //Add the right-hand nodes to the set:

      //Boundary coordinate
      el_pt->node_pt(n_node-1)->get_coordinates_on_boundary(bound,bound_right);
      vertex_coord[0] = bound_right[0];

      // Actual coordinates
      for(unsigned i=0;i<2;i++)
       {
        vertex_coord[i+1] = el_pt->node_pt(n_node-1)->x(i);
       }
      vertex_nodes.insert(vertex_coord);

     }

    // Now turn into vector for ease of handling...
    unsigned n_poly_vertex = vertex_nodes.size();
    Vector<Vector<double> > tmp_vector_vertex_node(n_poly_vertex);
    unsigned count=0;
    for(std::set<Vector<double> >::iterator it = vertex_nodes.begin();
      it!=vertex_nodes.end();++it)
     {
      tmp_vector_vertex_node[count].resize(3);
      tmp_vector_vertex_node[count][0] = (*it)[0];
      tmp_vector_vertex_node[count][1] = (*it)[1];
      tmp_vector_vertex_node[count][2] = (*it)[2];
      ++count;
     }

    // Size of the vector
    unsigned n_vertex=tmp_vector_vertex_node.size();

    // Tolerance below which the middle point can be deleted
    // (ratio of deflection to element length)
    double unrefinement_tolerance=
      open_polyline_pt->polyline_pt(p)->unrefinement_tolerance();

    //------------------------------------------------------
    // Unrefinement
    //------------------------------------------------------
    if (unrefinement_tolerance>0.0 && n_vertex>=3)
     {
      unrefinement_was_performed =
        unrefine_boundary(bound, chunk, tmp_vector_vertex_node,
			  unrefinement_tolerance, check_only);

      // In this case the unrefinement_was_performed variable actually
      // tell us if the update had been performed when calling
      // with check_only=false
      if (check_only && unrefinement_was_performed)
       {
        // Cleanup (but only the elements -- the nodes still exist in
        // the bulk mesh!
        for(unsigned p=0;p<n_polyline;p++)
         {
          face_mesh_pt[p]->flush_node_storage();
          delete face_mesh_pt[p];
         }
        return true;
       }

     } // end of unrefinement

    // Do not perform refinement if there are no more than two vertices
    // (open curve version)
    // New size of the vector
    n_vertex=tmp_vector_vertex_node.size();
  
    //------------------------------------------------
    /// Refinement
    //------------------------------------------------
    double refinement_tolerance=
      open_polyline_pt->polyline_pt(p)->refinement_tolerance();
    if (refinement_tolerance>0.0 && n_vertex >= 2)
     {
      refinement_was_performed =
        refine_boundary(face_mesh_pt[p], tmp_vector_vertex_node,
          refinement_tolerance, check_only);

      // In this case the unrefinement_was_performed variable actually
      // tell us if the update had been performed when calling
      // with check_only=false
      if (check_only && refinement_was_performed)
       {
        // Cleanup (but only the elements -- the nodes still exist in
        // the bulk mesh!
        for(unsigned p=0;p<n_polyline;p++)
         {
          face_mesh_pt[p]->flush_node_storage();
          delete face_mesh_pt[p];
         }
        return true;
       }

     } // end refinement

    // Do not perform maximum length constraint if there are no more than
    // two vertices
    // New size of the vector
    n_vertex=tmp_vector_vertex_node.size();

    //------------------------------------------------
    // Maximum length constraint
    //-----------------------------------------------
    double maximum_length = open_polyline_pt->polyline_pt(p)->maximum_length();
    if (maximum_length > 0.0 && n_vertex >= 2)
      {
       bool max_length_applied = false;
       max_length_applied = 
        apply_max_length_constraint(face_mesh_pt[p], 
                                    tmp_vector_vertex_node,
                                    maximum_length);
       
       // In this case the max length criteria was applied, check if 
       // check_only=false
       if (check_only && max_length_applied)
        {
         // Cleanup (but only the elements -- the nodes still exist in
         // the bulk mesh!
         for(unsigned p=0;p<n_polyline;p++)
          {
           face_mesh_pt[p]->flush_node_storage();
           delete face_mesh_pt[p];
          }
         return true;
        }
       
      }
    
    // For further processing the three-dimensional vector
    // has to be reduced to a two-dimensional vector
    n_vertex=tmp_vector_vertex_node.size();
    Vector<Vector<double> > vector_vertex_node(n_vertex);

    for(unsigned i=0;i<n_vertex;i++)
     {
      vector_vertex_node[i].resize(2);
      vector_vertex_node[i][0]=tmp_vector_vertex_node[i][1];
      vector_vertex_node[i][1]=tmp_vector_vertex_node[i][2];
     }

#ifdef OOMPH_HAS_MPI
    // Only perform this checking if the mesh is not distributed. When
    // the mesh is distributed the polylines continuity is addressed
    // in the sort_polylines_helper() method
    if (!this->is_mesh_distributed())
#endif
     {
      //Check whether the segments are continguous (first vertex of this
      //segment is equal to last vertex of previous segment).
      //If not, we should reverse the order of the current segment.
      //This check only applies for segments other than the first.
      //We only bother with this check, if we actually perform an update
      //of the polyline, i.e. if it's not only a check
      if( (p > 0) && !check_only )
       {
        //Final end point of previous line
        Vector<double> final_vertex_of_previous_segment;
        open_polyline_pt->polyline_pt(p-1)->
         final_vertex_coordinate(final_vertex_of_previous_segment);
      
        unsigned prev_seg_boundary_id =
         open_polyline_pt->curve_section_pt(p-1)->boundary_id();
        
        //Find the error between the final vertex of the previous
        //line and the first vertex of the current line
        double error = 0.0;
        for(unsigned i=0;i<2;i++)
         {
          const double dist =
           final_vertex_of_previous_segment[i] -
           (*vector_vertex_node.begin())[i];
          error += dist*dist;
         }
        error = sqrt(error);
      
        //If the error is bigger than the tolerance then
        //we probably need to reverse, but better check
        if(error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
         {
          //Find the error between the final vertex of the previous
          //line and the first vertex of the current line
          error = 0.0;
          for(unsigned i=0;i<2;i++)
           {
            const double dist =
             final_vertex_of_previous_segment[i] -
             (*--vector_vertex_node.end())[i];
            error += dist*dist;
           }
          error = sqrt(error);
        
          if (error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
           {
            // It could be possible that the first segment be reversed
            // and we did not notice it because this check does not
            // apply for the first segment. We can verify if the first
            // segment is reversed by using the vertex number 1
            if (p == 1)
             {
              // If no found it is possible that the previous polyline
              // be reversed Check for that case Initial point of
              // previous line
              Vector<double> initial_vertex_of_previous_segment;
              open_polyline_pt->polyline_pt(p-1)->
               initial_vertex_coordinate(initial_vertex_of_previous_segment);
          
              //Find the error between the initial vertex of the previous
              //line and the first vertex of the current line
              error = 0.0;
              for(unsigned i=0;i<2;i++)
               {
                const double dist =
                 initial_vertex_of_previous_segment[i] -
                 (*vector_vertex_node.begin())[i];
                error += dist*dist;
               }
              error = sqrt(error);
          
              //If the error is bigger than the tolerance then
              //we probably need to reverse, but better check
              if(error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
               {
                //Find the error between the final vertex of the previous
                //line and the first vertex of the current line
                error = 0.0;
                for(unsigned i=0;i<2;i++)
                 {
                  const double dist =
                   initial_vertex_of_previous_segment[i] -
                   (*--vector_vertex_node.end())[i];
                  error += dist*dist;
                 }
                error = sqrt(error);
            
                if(error >
                   ToleranceForVertexMismatchInPolygons::Tolerable_error)
                 {
                  std::ostringstream error_stream;
                  error_stream 
                   <<"The distance between the first node of the current\n"
                   <<"line segment (boundary " << bound
                   <<") and either end of the previous line segment\n"
                   <<"(boundary " << prev_seg_boundary_id << ") is bigger than "
                   <<"the desired tolerance " <<
                   ToleranceForVertexMismatchInPolygons::Tolerable_error<<".\n"
                   <<"This suggests that the polylines defining the open "
                   << "curve\n"
                   <<"representation are not properly ordered.\n"
                   <<"Fail on last vertex of polyline: (" 
                   << prev_seg_boundary_id
                   <<") and\nfirst vertex of polyline (" << bound << ").\n"
                   <<"This should have failed when first trying to construct\n"
                   <<"the open curve.\n";
                  throw OomphLibError(error_stream.str(),
                                      OOMPH_CURRENT_FUNCTION,
                                      OOMPH_EXCEPTION_LOCATION);
                 }
                else // We have to reverse both
                 {
                  // First reverse the previous polyline
                  open_polyline_pt->polyline_pt(p-1)->reverse();
                  // Then reverse the current polyline
                  std::reverse(vector_vertex_node.begin(),
                               vector_vertex_node.end());
                 }
               }
              else
               {
                // Reverse the previous polyline only
                open_polyline_pt->polyline_pt(p-1)->reverse();
               }
             } // if (p == 1)
            else
             {
              std::ostringstream error_stream;
              error_stream 
               << "The distance between the first node of the current\n" 
               << "line segment (boundary " << bound << ") and either end of "
               << "the previous line segment\n"
               << "(boundary "<<prev_seg_boundary_id<<") is bigger than the "
               << "desired tolerance " <<
               ToleranceForVertexMismatchInPolygons::Tolerable_error << ".\n"
               <<"This suggests that the polylines defining the polygonal\n"
               <<"representation are not properly ordered.\n"
               << "Fail on last vertex of polyline: ("<<prev_seg_boundary_id
               << ") and\nfirst vertex of polyline ("<<bound<<").\n"
               << "This should have failed when first trying to construct the\n"
               << "polygon.\n";
              throw OomphLibError(error_stream.str(),
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
             }
           }
          else
           {
            //Reverse the current vector to line up with the previous one
            std::reverse(vector_vertex_node.begin(),vector_vertex_node.end());
           }
          
         }
        
       } // if p > 0
      
     } // is mesh not distributed?
    
    if(!check_only)
     {
      // Now update the polyline according to the new vertices The new
      // one representation
      TriangleMeshPolyLine *tmp_polyline =
        new TriangleMeshPolyLine(vector_vertex_node, bound);
      
      // Create a temporal "curve section" version of the recently
      // created polyline
      TriangleMeshCurveSection *tmp_curve_section = tmp_polyline;
      
      // Copy the unrefinement and refinement information
      tmp_polyline->set_unrefinement_tolerance(
       unrefinement_tolerance);
      tmp_polyline->set_refinement_tolerance(
       refinement_tolerance);
      
      // Establish the maximum length constraint
      tmp_polyline->set_maximum_length(maximum_length);
      
      // Pass the connection information from the old polyline to the
      // new one
      this->copy_connection_information(open_polyline_pt->polyline_pt(p), 
                                          tmp_curve_section);
      
      std::set<TriangleMeshCurveSection*>::iterator it =
       this->Free_curve_section_pt.find(open_polyline_pt->curve_section_pt(p));
      
      bool delete_it_on_destructor = false;

      if (it!=this->Free_curve_section_pt.end())
       {
        // Free previous representation only if you created
        this->Free_curve_section_pt.erase(it);
        delete open_polyline_pt->curve_section_pt(p);
        delete_it_on_destructor = true;
       }

      // *****************************************************************
      // Copying the new representation
      open_polyline_pt->curve_section_pt(p) = tmp_polyline;

      // Update the Boundary <--> PolyLine map
      this->Boundary_curve_section_pt[bound] =
        open_polyline_pt->curve_section_pt(p);

      if (delete_it_on_destructor)
       {
        this->Free_curve_section_pt.insert(
          open_polyline_pt->curve_section_pt(p));
       }

     } // if(!check_only)

   } // n_polylines

  // Cleanup (but only the elements -- the nodes still exist in
  // the bulk mesh!
  for(unsigned p=0;p<n_polyline;p++)
   {
    face_mesh_pt[p]->flush_node_storage();
    delete face_mesh_pt[p];
   }

  if(check_only)
   {
    // if we end up all the way down here, no update of the internal
    // boundaries is necessary (in case we only check)
    return false;
   }
  else
   {
    // if we not only check, but actually perform the update and end
    // up all the way down here then we indicate whether an update was
    // performed or not
    return (unrefinement_was_performed || 
            refinement_was_performed || 
            max_length_applied);
   }

  }

//=========================================================================
/// \short Helper function that performs the unrefinement process
/// on the specified boundary by using the provided vertices
/// representation. Optional boolean is used to run it as test only (if
/// true is specified as input) in which case vertex coordinates aren't
/// actually modified. Returned boolean indicates if polyline was (or
/// would have been -- if called with check_only=false) changed.
//=========================================================================
template<class ELEMENT>
bool RefineableTriangleMesh<ELEMENT>::
unrefine_boundary(const unsigned &b,
                  const unsigned &c,
                  Vector<Vector<double> > &vector_bnd_vertices,
                  double &unrefinement_tolerance,
                  const bool &check_only)
 {
  // Store the vertices not allowed for deletion
  std::set<Vector<double> > no_delete_vertex;
  
  // Does the boundary receives connections?
  const bool boundary_receive_connections = 
   this->boundary_connections(b, c, no_delete_vertex);
  
  // Boolean that indicates whether an actual update of the vertex
  // coordinates was performed or not
  bool unrefinement_was_performed=false;
  
  unsigned n_vertex = vector_bnd_vertices.size();

  // Initialise counter that indicates at which vertex we're currently
  // considering for deletion
  unsigned counter=1;

  // Loop over the nodes; start with the second one and increment by two
  // this way a "pack" of three nodes will be considered for calculation:
  // the middle-node (which is to be deleted or not) and the adjacent
  // nodes
  for(unsigned i=1;i<=n_vertex-2;i+=2)
   {
    // Maths from http://www.cgafaq.info/wiki/Circle_Through_Three_Points
    double a_x=vector_bnd_vertices[i-1][1];
    double a_y=vector_bnd_vertices[i-1][2];
    double b_x=vector_bnd_vertices[i][1];
    double b_y=vector_bnd_vertices[i][2];
    double c_x=vector_bnd_vertices[i+1][1];
    double c_y=vector_bnd_vertices[i+1][2];

    double a=b_x-a_x;
    double b=b_y-a_y;
    double c=c_x-a_x;
    double d=c_y-a_y;

    double e=a*(a_x+b_x)+b*(a_y+b_y);
    double f=c*(a_x+c_x)+d*(a_y+c_y);

    double g=2.0*(a*(c_y-b_y)-b*(c_x-b_x));

    bool do_it=false;
    if (std::fabs(g)<1.0e-14)
     {
      do_it=true;
      if(check_only) {return true;}
     }
    else
     {
      double p_x=(d*e-b*f)/g;
      double p_y=(a*f-c*e)/g;

      double r=sqrt(pow((a_x-p_x),2)+pow((a_y-p_y),2));

      double rhalfca_x=0.5*(a_x-c_x);
      double rhalfca_y=0.5*(a_y-c_y);

      double halfca_squared=pow(rhalfca_x,2)+pow(rhalfca_y,2);

      double sticky_out_bit=r-sqrt(std::fabs((r*r) - halfca_squared));

      // If sticky out bit divided by distance between end nodes
      // is less than tolerance the boundary is so flat that we
      // can safely kill the node
      if ((sticky_out_bit/(2.0*sqrt(halfca_squared)))<
        unrefinement_tolerance)
       {
        do_it=true;
        if(check_only) {return true;}
       }
     }
    
    // If the vertex was proposed for deletion check that it is
    // allowed for being deleted
    if (do_it && boundary_receive_connections)
     {
      // Is the vertex one of the non deletable vertices
      for (std::set<Vector<double> >::iterator it = no_delete_vertex.begin();
           it != no_delete_vertex.end(); it++)
       {
        // Compute the distance between the proposed node to delete
        // and the ones that should not be deleted
        const double x = (*it)[0];
        const double y = (*it)[1];
        double error = (b_x - x)*(b_x - x) + (b_y - y)*(b_y - y);
        error = sqrt(error);
        
        if(error<ToleranceForVertexMismatchInPolygons::Tolerable_error)
         {
          // Do not delete the vertex
          do_it = false;
          break;
         }

       }
      
     } // if (do_it && boundary_receive_connections)

    // Remove node?
    if (do_it)
     {
      vector_bnd_vertices[i].resize(0);
     }

    // Increase the counter, that indicates the number of the
    // next middle node
    counter+=2;
   }

  // coming out of here the value of counter is the index of the
  // last node on the polyline counter=n_vertex-1 (in case of an
  // even number of nodes) or counter has the value of the number
  // of nodes on the polyline counter=n_vertex (in case of an odd
  // number of nodes

  // Special treatment for the end of the polyline:
  // If the number of nodes is even, then the previous loop stopped
  // at the last but second node, i.e. the current value of counter
  // is the index of the last node. If that's the case, the last but
  // one node needs to be treated separately
  if( (counter)==(n_vertex-1) )
   {
    // Set the last but one node as middle node
    unsigned i=vector_bnd_vertices.size()-2;

    // Index of the current! last but second node (considering any
    // previous deletion)
    unsigned n=0;

    if(vector_bnd_vertices[counter-2].size()!=0)
     {
      // if the initial last but second node does still exist then
      // this one is obviously also the current last but second one
      n=counter-2;
     }
    else
     {
      // if the initial last but second node was deleted then the
      // initial last but third node is the current last but second
      // node
      n=counter-3;
     }

    // CODE DUPLICATION -- CAN'T BE BOTHERED TO WRITE A SEPARATE
    // FUNCTION FOR THIS; PROBABLY WORTH DOING IF/WHEN THERE'S
    // A MISTAKE IN ANY OF THIS AND IT NEEDS TO BE FIXED...

    // Maths from http://www.cgafaq.info/wiki/Circle_Through_Three_Points
    double a_x=vector_bnd_vertices[n][1];
    double a_y=vector_bnd_vertices[n][2];
    double b_x=vector_bnd_vertices[i][1];
    double b_y=vector_bnd_vertices[i][2];
    double c_x=vector_bnd_vertices[i+1][1];
    double c_y=vector_bnd_vertices[i+1][2];

    double a=b_x-a_x;
    double b=b_y-a_y;
    double c=c_x-a_x;
    double d=c_y-a_y;

    double e=a*(a_x+b_x)+b*(a_y+b_y);
    double f=c*(a_x+c_x)+d*(a_y+c_y);

    double g=2.0*(a*(c_y-b_y)-b*(c_x-b_x));

    bool do_it=false;
    if (std::fabs(g)<1.0e-14)
     {
      do_it=true;
      if(check_only) {return true;}
     }
    else
     {
      double p_x=(d*e-b*f)/g;
      double p_y=(a*f-c*e)/g;

      double r=sqrt(pow((a_x-p_x),2)+pow((a_y-p_y),2));

      double rhalfca_x=0.5*(a_x-c_x);
      double rhalfca_y=0.5*(a_y-c_y);

      double halfca_squared=pow(rhalfca_x,2)+pow(rhalfca_y,2);

      double sticky_out_bit=r-sqrt(std::fabs((r*r) - halfca_squared));

      // If sticky out bit divided by distance between end nodes
      // is less than tolerance the boundary is so flat that we
      // can safely kill the node
      if ((sticky_out_bit/(2.0*sqrt(halfca_squared)))<
        unrefinement_tolerance)
       {
        do_it=true;
        if(check_only) {return true;}
       }
     }

    // If the vertex was proposed for deletion check that it is
    // allowed for being deleted
    if (do_it && boundary_receive_connections)
     {
      // Is the vertex one of the non deletable vertices
      for (std::set<Vector<double> >::iterator it = no_delete_vertex.begin();
           it != no_delete_vertex.end(); it++)
       {
        // Compute the distance between the proposed node to delete
        // and the ones that should not be deleted
        const double x = (*it)[0];
        const double y = (*it)[1];
        double error = (b_x - x)*(b_x - x) + (b_y - y)*(b_y - y);
        error = sqrt(error);
        
        if(error <
           ToleranceForVertexMismatchInPolygons::Tolerable_error)
         {
          // Do not delete the vertex
          do_it = false;
          break;
         }

       }
      
     } // if (do_it && boundary_receive_connections)
    
    // Remove node?
    if (do_it)
     {
      vector_bnd_vertices[i].resize(0);
     }
   }
  
  // Create another vector, which will only contain entries of
  // nodes that still exist
  Vector<Vector<double> > compact_vector;
  compact_vector.reserve(n_vertex);
  for (unsigned i=0;i<n_vertex;i++)
   {
    // If the entry was not deleted include it in the new vector
    if (vector_bnd_vertices[i].size()!=0)
     {
      compact_vector.push_back(vector_bnd_vertices[i]);
     }
   }

  /// Get the size of the vector that now includes all remaining nodes
  n_vertex =compact_vector.size();

  // If the size of the vector containing the remaining nodes is
  // different from the size of the vector before the unrefinement
  // routine (with the original nodes)
  // then the polyline was obviously updated
  if( n_vertex != vector_bnd_vertices.size() )
   {
    unrefinement_was_performed=true;
   }

  /// Copy back
  vector_bnd_vertices.resize(n_vertex);
  for(unsigned i=0;i<n_vertex;i++)
   {
    vector_bnd_vertices[i].resize(3);
    vector_bnd_vertices[i][0]=compact_vector[i][0];
    vector_bnd_vertices[i][1]=compact_vector[i][1];
    vector_bnd_vertices[i][2]=compact_vector[i][2];
   }

  return unrefinement_was_performed;

 }

//=========================================================================
/// \short Helper function that performs the refinement process
/// on the specified boundary by using the provided vertices
/// representation. Optional boolean is used to run it as test only (if
/// true is specified as input) in which case vertex coordinates aren't
/// actually modified. Returned boolean indicates if polyline was (or
/// would have been -- if called with check_only=false) changed.
//=========================================================================
template<class ELEMENT>
bool RefineableTriangleMesh<ELEMENT>::
refine_boundary(Mesh* face_mesh_pt,
  Vector<Vector<double> > &vector_bnd_vertices,
  double &refinement_tolerance,
  const bool &check_only)
 {
  // Boolean that indicates whether an actual update of the vertex
  // coordinates was performed or not
  bool refinement_was_performed=false;

  // Create a geometric object from the mesh to represent
  //the curvilinear boundary
  MeshAsGeomObject* mesh_geom_obj_pt=new MeshAsGeomObject(face_mesh_pt);

  // Get the total number of current vertices
  unsigned n_vertex=vector_bnd_vertices.size();

  // Create a new (temporary) vector for the nodes, so
  // that new nodes can be stored
  Vector<Vector<double> > extended_vector;

  // Reserve memory space for twice the number of already
  // existing nodes (worst case)
  extended_vector.reserve(2*n_vertex);

  // Loop over the nodes until the last but one node
  for(unsigned inod=0;inod<n_vertex-1;inod++)
   {
    // Get local coordinate of "left" node
    double zeta_left=vector_bnd_vertices[inod][0];

    // Get position vector of "left" node
    Vector<double> R_left(2);
    for(unsigned i=0;i<2;i++)
     {
      R_left[i]=vector_bnd_vertices[inod][i+1];
     }

    // Get local coordinate of "right" node
    double zeta_right=vector_bnd_vertices[inod+1][0];

    // Get position vector of "right" node
    Vector<double> R_right(2);
    for(unsigned i=0;i<2;i++)
     {
      R_right[i]=vector_bnd_vertices[inod+1][i+1];
     }

    // Get the boundary coordinate of the midpoint
    Vector<double> zeta_mid(1);
    zeta_mid[0]=0.5*(zeta_left+zeta_right);

    // Get the position vector of the midpoint on the
    // curvilinear boundary
    Vector<double> R_mid(2);
    mesh_geom_obj_pt->position(zeta_mid,R_mid);

    // Get the position vector of the midpoint on the straight
    // line connecting "left" and "right" node
    Vector<double> R_mid_polygon(2);
    for(unsigned i=0;i<2;i++)
     {
      R_mid_polygon[i]=0.5*(R_right[i]+R_left[i]);
     }

    // Calculate the distance between the midpoint on the curvilinear
    // boundary and the midpoint on the straight line
    double distance=sqrt((R_mid[0]-R_mid_polygon[0])*
      (R_mid[0]-R_mid_polygon[0])+
      (R_mid[1]-R_mid_polygon[1])*
      (R_mid[1]-R_mid_polygon[1]));

    // Calculating the length of the straight line
    double length=sqrt((R_right[0]-R_left[0])*(R_right[0]-R_left[0])+
      (R_right[1]-R_left[1])*(R_right[1]-R_left[1]));

    // If the ratio of distance between the midpoints to the length
    // of the straight line is larger than the tolerance
    // specified for the criterion when points can be deleted,
    // create a new node and add it to the (temporary) vector
    if((distance/length) > refinement_tolerance)
     {

      if(check_only)
       {
        // Delete the allocated memory for the geometric object
        // that represents the curvilinear boundary
        delete mesh_geom_obj_pt;
        return true;
       }

      Vector<double> new_node(3);
      new_node[0]=zeta_mid[0];
      new_node[1]=R_mid[0];
      new_node[2]=R_mid[1];

      // Include the "left" node in the new "temporary" vector
      extended_vector.push_back(vector_bnd_vertices[inod]);

      // Include the new node as well
      extended_vector.push_back(new_node);

     }
    else
     {
      // Include the "left" node in the new "temporary" vector
      // and move on to the next node
      extended_vector.push_back(vector_bnd_vertices[inod]);
     }
   } // end of loop over nodes

  // Add the last node to the vector
  extended_vector.push_back(vector_bnd_vertices[n_vertex-1]);

  /// Get the size of the vector that now includes all added nodes
  n_vertex=extended_vector.size();

  // If the size of the vector including the added nodes is
  // different from the size of the vector before the refinement
  // routine then the polyline was obviously updated
  if( n_vertex != vector_bnd_vertices.size() )
   {
    refinement_was_performed=true;
   }

  // Copy across
  vector_bnd_vertices.resize(n_vertex);
  for(unsigned i=0;i<n_vertex;i++)
   {
    vector_bnd_vertices[i].resize(3);
    vector_bnd_vertices[i][0]=extended_vector[i][0];
    vector_bnd_vertices[i][1]=extended_vector[i][1];
    vector_bnd_vertices[i][2]=extended_vector[i][2];
   }

  // Delete the allocated memory for the geometric object
  // that represents the curvilinear boundary
  delete mesh_geom_obj_pt;

  return refinement_was_performed;

 }

 //=========================================================================
 // \short Helper function that applies the maximum length constraint
 // when it was specified. This will increase the number of points in
 // the current curve section in case that any segment on it does not
 // fulfils the requirement
 //=========================================================================
 template<class ELEMENT>
 bool RefineableTriangleMesh<ELEMENT>::
 apply_max_length_constraint(Mesh* face_mesh_pt,
                             Vector<Vector<double> > &vector_bnd_vertices,
                             double &max_length_constraint)
 {
  // Boolean that indicates whether an actual update of the vertex
  // coordinates was performed or not
  bool max_length_applied=false;

  // Create a geometric object from the mesh to represent
  //the curvilinear boundary
  MeshAsGeomObject* mesh_geom_obj_pt=new MeshAsGeomObject(face_mesh_pt);

  // Get the total number of current vertices
  unsigned n_vertex=vector_bnd_vertices.size();

  // Create a new (temporary) vector for the nodes, so
  // that new nodes can be stored
  Vector<Vector<double> > extended_vector;

  // Loop over the nodes until the last but one node
  for(unsigned inod=0;inod<n_vertex-1;inod++)
   {
    // Get local coordinate of "left" node
    double zeta_left=vector_bnd_vertices[inod][0];

    // Get position vector of "left" node
    Vector<double> R_left(2);
    for(unsigned i=0;i<2;i++)
     {
      R_left[i]=vector_bnd_vertices[inod][i+1];
     }

    // Get local coordinate of "right" node
    double zeta_right=vector_bnd_vertices[inod+1][0];

    // Get position vector of "right" node
    Vector<double> R_right(2);
    for(unsigned i=0;i<2;i++)
     {
      R_right[i]=vector_bnd_vertices[inod+1][i+1];
     }

    // Include the "left" node in the new "temporary" vector
    extended_vector.push_back(vector_bnd_vertices[inod]);

    // Check whether the current distance between the left and right node 
    // is longer than the specified constraint or not
    double length=std::fabs(zeta_right-zeta_left);

    // Do we need to introduce new nodes?
    if (length > max_length_constraint)
     {
      double n_pts = length/max_length_constraint;
      // We only want the integer part
      unsigned n_points = static_cast<unsigned>(n_pts);
      double zeta_increment = (zeta_right-zeta_left)/((double)n_points+1);
       
      Vector<double> zeta(1);
      // Create the n_points+1 points inside the segment
      for(unsigned s=1;s<n_points+1;s++)
       {
        // Get the coordinates
        zeta[0]= zeta_left + zeta_increment*double(s);
        Vector<double> vertex(2);
        mesh_geom_obj_pt->position(zeta, vertex);

        // Create the new node
        Vector<double> new_node(3);
        new_node[0]=zeta[0];
        new_node[1]=vertex[0];
        new_node[2]=vertex[1];

        // Include the new node
        extended_vector.push_back(new_node);
       }
     }
   }

  // Add the last node to the vector
  extended_vector.push_back(vector_bnd_vertices[n_vertex-1]);

  /// Get the size of the vector that now includes all added nodes
  n_vertex=extended_vector.size();

  // If the size of the vector including the added nodes is
  // different from the size of the vector before applying the maximum length
  // constraint then the polyline was obviously updated
  if( n_vertex != vector_bnd_vertices.size() )
   {
    max_length_applied = true;
   }

  // Copy across
  vector_bnd_vertices.resize(n_vertex);
  for(unsigned i=0;i<n_vertex;i++)
   {
    vector_bnd_vertices[i].resize(3);
    vector_bnd_vertices[i][0]=extended_vector[i][0];
    vector_bnd_vertices[i][1]=extended_vector[i][1];
    vector_bnd_vertices[i][2]=extended_vector[i][2];
   }

  // Delete the allocated memory for the geometric object
  // that represents the curvilinear boundary
  delete mesh_geom_obj_pt;

  return max_length_applied;

 }
 
//=========================================================================
/// \short Helper function
/// Creates an unsorted face mesh representation from the specified
/// boundary id. It means that the elements are not sorted along the
/// boundary
//=========================================================================
template<class ELEMENT>
void RefineableTriangleMesh<ELEMENT>::
create_unsorted_face_mesh_representation(
  const unsigned &boundary_id,
  Mesh* face_mesh_pt)
 {
  // Create a face mesh adjacent to specified boundary.
  // The face mesh consists of FaceElements that may also be
  // interpreted as GeomObjects

  // Build the face mesh
  this->template build_face_mesh<ELEMENT,FaceElementAsGeomObject>
   (boundary_id,face_mesh_pt);
  
  // Find the total number of added elements
  unsigned n_element = face_mesh_pt->nelement();
  // Loop over the elements
  for(unsigned e=0;e<n_element;e++)
   {

    //Cast the element pointer to the correct thing!
    FaceElementAsGeomObject<ELEMENT>* el_pt=
    dynamic_cast<FaceElementAsGeomObject<ELEMENT>*>
    (face_mesh_pt->element_pt(e));

    // Set bulk boundary number
    el_pt->set_boundary_number_in_bulk_mesh(boundary_id);

   }

 }

//=========================================================================
/// \short Helper function
/// Creates a sorted face mesh representation of the specified PolyLine
/// It means that the elements are sorted along the boundary
//=========================================================================
template<class ELEMENT>
void RefineableTriangleMesh<ELEMENT>::
create_sorted_face_mesh_representation(
  const unsigned &boundary_id,
  Mesh* face_mesh_pt,
  std::map<FiniteElement*, bool> &is_inverted,
  bool &inverted_face_mesh)
 {
  Mesh *tmp_unsorted_face_mesh_pt = new Mesh();

  // First step we get the unsorted version of the face mesh
  create_unsorted_face_mesh_representation(
    boundary_id, tmp_unsorted_face_mesh_pt);

  // Once with the unsorted version of the face mesh
  // only left to sort it out!!!

  // Put all face elements in order
  //-------------------------------

  // Put first element into ordered list
  // Temporal list for sorting the elements
  std::list<FiniteElement*> sorted_el_pt;
  FiniteElement* el_pt = tmp_unsorted_face_mesh_pt->finite_element_pt(0);
  sorted_el_pt.push_back(el_pt);

  // Number of nodes
  unsigned nnod=el_pt->nnode();

  // Count elements that have been done
  unsigned count_done=0;

  // How many face elements are there?
  unsigned n_face_element = tmp_unsorted_face_mesh_pt->nelement();

  // Keep track of who's done
  std::map<FiniteElement*,bool> done_el;

  is_inverted.clear();

  // Fit in the other elements in at most nel^2 loops
  for (unsigned ee=1;ee<n_face_element;ee++)
   {
    // Loop over all elements to check if they fit to the right
    // or the left of the current one
    for (unsigned e=1;e<n_face_element;e++)
     {
      // Candidate element
      el_pt=tmp_unsorted_face_mesh_pt->finite_element_pt(e);

      // Is it done yet?
      if (!done_el[el_pt])
       {
        // Left and rightmost elements
        FiniteElement* first_el_pt=(*sorted_el_pt.begin());
        std::list<FiniteElement*>::iterator it=sorted_el_pt.end();
        it--;
        FiniteElement* last_el_pt=*it;

        // Left and rightmost nodes
        Node* left_node_pt=first_el_pt->node_pt(0);
        if (is_inverted[first_el_pt])
         {
          left_node_pt=first_el_pt->node_pt(nnod-1);
         }
        Node* right_node_pt=last_el_pt->node_pt(nnod-1);
        if (is_inverted[last_el_pt])
         {
          right_node_pt=last_el_pt->node_pt(0);
         }

        // New element fits at the left of first element and is not inverted
        if (left_node_pt==el_pt->node_pt(nnod-1))
         {
          sorted_el_pt.push_front(el_pt);
          done_el[el_pt]=true;
          count_done++;
          is_inverted[el_pt]=false;
         }
        // New element fits at the left of first element and is inverted

        else if (left_node_pt==el_pt->node_pt(0))
         {
          sorted_el_pt.push_front(el_pt);
          done_el[el_pt]=true;
          count_done++;
          is_inverted[el_pt]=true;
         }
        // New element fits on the right of last element and is not inverted

        else if(right_node_pt==el_pt->node_pt(0))
         {
          sorted_el_pt.push_back(el_pt);
          done_el[el_pt]=true;
          count_done++;
          is_inverted[el_pt]=false;
         }
        // New element fits on the right of last element and is inverted

        else if (right_node_pt==el_pt->node_pt(nnod-1))
         {
          sorted_el_pt.push_back(el_pt);
          done_el[el_pt]=true;
          count_done++;
          is_inverted[el_pt]=true;
         }

        if (done_el[el_pt])
         {
          break;
         }
       }
     }
   }

  // Are we done?
  if (count_done!=(n_face_element-1))
   {
    std::ostringstream error_message;
    error_message
    << "When ordering FaceElements on  "
    << "boundary " << boundary_id << " only managed to order \n" << count_done
    << " of " << n_face_element << " face elements.\n"
    << std::endl;
    throw OomphLibError(
      error_message.str(),
      OOMPH_CURRENT_FUNCTION,
      OOMPH_EXCEPTION_LOCATION);
   }

  // Now make a mesh that contains the FaceElements in order
  // Remember that we currently have a list, not a mesh of sorted elements

  // Fill it
  for (std::list<FiniteElement*>::iterator it=sorted_el_pt.begin();
    it!=sorted_el_pt.end();it++)
   {
    // Get element
    FiniteElement* el_pt=*it;

    // add this face element to the order original mesh
    face_mesh_pt->add_element_pt(el_pt);
   }

  // Verify if face mesh representation is not inverted according to the
  // polyline specified by the user, it means that the initial and the
  // final vertex does really correspond to the first and last vertex
  // respectively, if not, state that the face mesh representation is
  // inverted

  // Get the associated polyline representation to the boundary
  TriangleMeshPolyLine *bnd_polyline =
  this->Boundary_curve_section_pt[boundary_id];

  // Get the really first vertex
  Vector<double> first_vertex =
  bnd_polyline->vertex_coordinate(0);

  // Now get the first node based on the face mesh representation
  // First get access to the first element
  FiniteElement* first_el_pt =
  face_mesh_pt->finite_element_pt(0);

  // Now get access to the first node
  unsigned n_node = first_el_pt->nnode();
  // Get the very first node (taking into account if it is
  // inverted or not!!)
  Node* first_node_pt = first_el_pt->node_pt(0);
  if (is_inverted[first_el_pt])
   {
    first_node_pt = first_el_pt->node_pt(n_node-1);
   }

  double error = (first_node_pt->x(0) - first_vertex[0])*
  (first_node_pt->x(0) - first_vertex[0]) +
  (first_node_pt->x(1) - first_vertex[1])*
  (first_node_pt->x(1) - first_vertex[1]);

  error = sqrt(error);

  if(error <
    ToleranceForVertexMismatchInPolygons::Tolerable_error)
   {
    inverted_face_mesh = false;
   }
  else
   {
    inverted_face_mesh = true;
   }

 }

//=========================================================================
/// Helper function to construct face mesh representation of all polylines,
/// possibly with segments re-distributed between polylines
/// to maintain an approximately even sub-division of the polygon
//=========================================================================
template<class ELEMENT>
void RefineableTriangleMesh<ELEMENT>::
get_face_mesh_representation(TriangleMeshPolygon* polygon_pt,
  Vector<Mesh*>& face_mesh_pt)
 {
  // Number of polylines
  unsigned n_polyline = polygon_pt->npolyline();
  face_mesh_pt.resize(n_polyline);

  // Are we eligible for re-distributing polyline segments between
  // polylines? We're not if any of the boundaries are associated
  // with a GeomObject because we're then tied to the start and
  // end coordinates along it.
  bool eligible_for_segment_redistribution=true;

  // Loop over constituent polylines
  for(unsigned p=0;p<n_polyline;p++)
   {

    //Get the boundary id of the polyline
    unsigned bound =
    polygon_pt->polyline_pt(p)->boundary_id();

    //If the boundary has a geometric object representation then
    //we can't redistribute
    GeomObject* const geom_object_pt =
    this->boundary_geom_object_pt(bound);
    if(geom_object_pt!=0)
     {
      eligible_for_segment_redistribution=false;
     }

    face_mesh_pt[p] = new Mesh();
    create_unsorted_face_mesh_representation(
      bound, face_mesh_pt[p]);

   }

  if (!polygon_pt->is_redistribution_of_segments_between_polylines_enabled())
   {
    return;
   }

  //If there is more than one region we have to think... Die for now.
  if(this->nregion() > 1)
   {
    std::ostringstream warn_message;
    warn_message
    << "Can't currently re-distribute segments between polylines if there\n"
    << "are multiple regions; returning..." << std::endl;
    OomphLibWarning(warn_message.str(),
      "RefineableTriangleMesh::get_face_mesh_representation()",
      OOMPH_EXCEPTION_LOCATION);
    return;
   }

  // Redistribution overruled
  if (!eligible_for_segment_redistribution)
   {
    std::ostringstream warn_message;
    warn_message
    << "Over-ruling re-distribution of segments between polylines\n"
    << "because at least one boundary is associated with a GeomObject."
    << "Returning..." << std::endl;
    OomphLibWarning(warn_message.str(),
      "RefineableTriangleMesh::get_face_mesh_representation()",
      OOMPH_EXCEPTION_LOCATION);
    return;
   }

  // Create a vector for ordered face mesh
  Vector<Mesh*> ordered_face_mesh_pt(n_polyline);

  // Storage for the total arclength of polygon
  double s_total=0.0;

  // Storage for first and last nodes on polylines so we can figure
  // out if they are inverted relative to each other
  Vector<Node*> first_polyline_node_pt(n_polyline);
  Vector<Node*> last_polyline_node_pt(n_polyline);
  std::vector<bool> is_reversed(n_polyline,false);

  // Loop over constituent polylines 
  for(unsigned p=0;p<n_polyline;p++)
   {

    // Put all face elements in order
    //-------------------------------

    // Put first element into ordered list
    std::list<FiniteElement*> ordered_el_pt;
    FiniteElement* el_pt=face_mesh_pt[p]->finite_element_pt(0);
    ordered_el_pt.push_back(el_pt);

    // Number of nodes
    unsigned nnod=el_pt->nnode();

    // Default for first and last node on polyline
    first_polyline_node_pt[p]=el_pt->node_pt(0);
    last_polyline_node_pt[p]=el_pt->node_pt(nnod-1);

    // Count elements that have been done
    unsigned count_done=0;

    // How many face elements are there?
    unsigned n_face_element = face_mesh_pt[p]->nelement();

    //Get the boundary id of the polyline
    unsigned bound =
    polygon_pt->polyline_pt(p)->boundary_id();

    // Keep track of who's done
    std::map<FiniteElement*,bool> done_el;

    // Keep track of which element is inverted
    std::map<FiniteElement*,bool> is_inverted;

    // Fit in the other elements in at most nel^2 loops
    for (unsigned ee=1;ee<n_face_element;ee++)
     {
      // Loop over all elements to check if they fit to the right
      // or the left of the current one
      for (unsigned e=1;e<n_face_element;e++)
       {
        // Candidate element
        el_pt=face_mesh_pt[p]->finite_element_pt(e);

        // Is it done yet?
        if (!done_el[el_pt])
         {
          // Left and rightmost elements 
          FiniteElement* first_el_pt=(*ordered_el_pt.begin());
          std::list<FiniteElement*>::iterator it=ordered_el_pt.end();
          it--;
          FiniteElement* last_el_pt=*it;

          // Left and rightmost nodes
          Node* left_node_pt=first_el_pt->node_pt(0);
          if (is_inverted[first_el_pt])
           {
            left_node_pt=first_el_pt->node_pt(nnod-1);
           }
          Node* right_node_pt=last_el_pt->node_pt(nnod-1);
          if (is_inverted[last_el_pt])
           {
            right_node_pt=last_el_pt->node_pt(0);
           }

          // New element fits at the left of first element and is not inverted
          if (left_node_pt==el_pt->node_pt(nnod-1))
           {
            ordered_el_pt.push_front(el_pt);
            done_el[el_pt]=true;
            count_done++;
            is_inverted[el_pt]=false;
            first_polyline_node_pt[p]=el_pt->node_pt(0);
           }
          // New element fits at the left of first element and is inverted

          else if (left_node_pt==el_pt->node_pt(0))
           {
            ordered_el_pt.push_front(el_pt);
            done_el[el_pt]=true;
            count_done++;
            is_inverted[el_pt]=true;
            first_polyline_node_pt[p]=el_pt->node_pt(nnod-1);
           }
          // New element fits on the right of last element and is not inverted

          else if(right_node_pt==el_pt->node_pt(0))
           {
            ordered_el_pt.push_back(el_pt);
            done_el[el_pt]=true;
            count_done++;
            is_inverted[el_pt]=false;
            last_polyline_node_pt[p]=el_pt->node_pt(nnod-1);
           }
          // New element fits on the right of last element and is inverted

          else if (right_node_pt==el_pt->node_pt(nnod-1))
           {
            ordered_el_pt.push_back(el_pt);
            done_el[el_pt]=true;
            count_done++;
            is_inverted[el_pt]=true;
            last_polyline_node_pt[p]=el_pt->node_pt(0);
           }

          if (done_el[el_pt])
           {
            break;
           }
         }
       }
     }

    // Are we done?
    if (count_done!=(n_face_element-1))
     {
      std::ostringstream error_message;
      error_message
      << "When ordering FaceElements on  "
      << "boundary " << bound << " only managed to order \n" << count_done
      << " of " << n_face_element << " face elements.\n"
      << std::endl;
      throw OomphLibError(
        error_message.str(),
        OOMPH_CURRENT_FUNCTION,
        OOMPH_EXCEPTION_LOCATION);
     }

    // Now make a mesh that contains the FaceElements in order
    ordered_face_mesh_pt[p] = new Mesh;

    // Fill it
    for (std::list<FiniteElement*>::iterator it=ordered_el_pt.begin();
      it!=ordered_el_pt.end();it++)
     {
      // Get element
      FiniteElement* el_pt=*it;

      // add this face element to the order original mesh
      ordered_face_mesh_pt[p]->add_element_pt(el_pt);
     }

    //Get the arclength along the polygon
    for(unsigned e=0;e<n_face_element;++e)
     {
      FiniteElement* el_pt=ordered_face_mesh_pt[p]->finite_element_pt(e);
      unsigned n_node=el_pt->nnode();
      double element_length_squared=0.0;
      for(unsigned i=0;i<2;i++)
       {
        element_length_squared += pow(el_pt->node_pt(n_node-1)->x(i)-
          el_pt->node_pt(0)->x(i),2);
       }

      // Determine element length
      double element_length=sqrt(element_length_squared);

      // Add this length to the total arclength
      s_total += element_length;
     }

    // Empty the original meshes
    face_mesh_pt[p]->flush_element_and_node_storage();
   }

  // Is first one reversed?
  if ((last_polyline_node_pt[0]==first_polyline_node_pt[1])||
    (last_polyline_node_pt[0]==last_polyline_node_pt[1]))
   {
    is_reversed[0]=false;
   }
  else if ((first_polyline_node_pt[0]==first_polyline_node_pt[1])||
    (first_polyline_node_pt[0]==last_polyline_node_pt[1]))
   {
    is_reversed[0]=true;
   }

  // Reorder the face meshes so that they are contiguous
  Vector<Mesh*> tmp_face_mesh_pt(n_polyline);
  std::vector<bool> mesh_done(n_polyline,false);
  Vector<unsigned> old_polyline_number(n_polyline);

  // Initial entry
  tmp_face_mesh_pt[0]=ordered_face_mesh_pt[0];
  unsigned current=0;
  old_polyline_number[0]=0;
  unsigned count_found=0;

  // Fill in the next entries
  for(unsigned p=1;p<n_polyline;p++)
   {
    Node* end_node_pt=last_polyline_node_pt[current];
    if (is_reversed[current])
     {
      end_node_pt=first_polyline_node_pt[current];
     }

    // Loop over all remaining face meshes to see which one fits
    for(unsigned pp=1;pp<n_polyline;pp++)
     {
      if (!mesh_done[pp])
       {
        // Current one is not reversed, candidate is not reversed
        if ((!is_reversed[current])&&
          (end_node_pt==first_polyline_node_pt[pp]))
         {
          tmp_face_mesh_pt[p]=ordered_face_mesh_pt[pp];
          mesh_done[pp]=true;
          is_reversed[pp]=false;
          old_polyline_number[p]=pp;
          current=pp;
          count_found++;
          break;
         }
        // Current one is not reversed, candidate is reversed

        else if ((!is_reversed[current])&&
          (end_node_pt==last_polyline_node_pt[pp]))
         {
          tmp_face_mesh_pt[p]=ordered_face_mesh_pt[pp];
          mesh_done[pp]=true;
          is_reversed[pp]=true;
          old_polyline_number[p]=pp;
          current=pp;
          count_found++;
          break;
         }
        // Current one is reversed, candidate is not reversed

        else if ((is_reversed[current])&&
          (end_node_pt==first_polyline_node_pt[pp]))
         {
          tmp_face_mesh_pt[p]=ordered_face_mesh_pt[pp];
          mesh_done[pp]=true;
          is_reversed[pp]=false;
          old_polyline_number[p]=pp;
          current=pp;
          count_found++;
          break;
         }
        // Current one is reversed, candidate is reversed

        else if ((is_reversed[current])&&
          (end_node_pt==last_polyline_node_pt[pp]))
         {
          tmp_face_mesh_pt[p]=ordered_face_mesh_pt[pp];
          mesh_done[pp]=true;
          is_reversed[pp]=true;
          old_polyline_number[p]=pp;
          current=pp;
          count_found++;
          break;
         }
       }
     }
   }

#ifdef PARANOID
  if (count_found!=n_polyline-1)
   {
    std::ostringstream error_message;
    error_message << "Only found " << count_found
    << " out of " << n_polyline-1
    << " polylines to be fitted in.\n";
    throw OomphLibError(
      error_message.str(),
      OOMPH_CURRENT_FUNCTION,
      OOMPH_EXCEPTION_LOCATION);
   }
#endif

  // Now overwrite the re-ordered data
  for (unsigned i=0;i<n_polyline;i++)
   {
    ordered_face_mesh_pt[i]=tmp_face_mesh_pt[i];
   }

  // Now do an approximate equidistribution of polylines
  //----------------------------------------------------
  double s=0.0;
  unsigned new_face_id=0;

  // Matrix map to indicate if node must not be removed from specified
  // boundary (!=0) or not (=0). Initialises itself to zero
  std::map<Node*,std::map<unsigned,unsigned> >
  node_must_not_be_removed_from_boundary_flag;

  // Loop over the old face mesh
  for(unsigned p=0;p<n_polyline;p++)
   {
    // Loop over the face elements
    unsigned n_face_element = ordered_face_mesh_pt[p]->nelement();
    for (unsigned e=0;e<n_face_element;e++)
     {
      unsigned el_number=e;
      if (is_reversed[p])
       {
        el_number=n_face_element-e-1;
       }

      FiniteElement* el_pt=
      ordered_face_mesh_pt[p]->finite_element_pt(el_number);
      unsigned n_node = el_pt->nnode();

      // Determine element length
      double element_length_squared=0.0;
      for(unsigned i=0;i<2;i++)
       {
        element_length_squared += pow(el_pt->node_pt(n_node-1)->x(i)-
          el_pt->node_pt(0)->x(i),2);
       }
      double element_length=sqrt(element_length_squared);

      // Add this length to the total arclength
      s += element_length;

      // Check if the current 'arclength' is less than the
      // whole 'arclength' divided by the number of polylines
      if(s < s_total/double(n_polyline)+1e-6)
       {
        // If so add this face element to the new face mesh
        face_mesh_pt[new_face_id]->add_element_pt(el_pt);

        unsigned bound_old =
        polygon_pt->polyline_pt(old_polyline_number[p])->boundary_id();

        unsigned bound_new =
        polygon_pt->polyline_pt(new_face_id)->boundary_id();

        // Loop over the nodes in the element
        for(unsigned i=0;i<n_node;i++)
         {
          // Get the pointer to the node
          Node* nod_pt=el_pt->node_pt(i);

          // If the two boundary id's are different, the face element's nodes
          // have to be added to the new boundary
          if(bound_new != bound_old)
           {
            // Add it to the new boundary
            add_boundary_node(bound_new,nod_pt);

            // We are happy for this node to be removed from the
            // old boundary? 
            node_must_not_be_removed_from_boundary_flag[nod_pt][bound_old]+=0;
           }

          // If the face element hasn't moved, its nodes MUST remain
          // on that boundary (incl. any nodes that ar shared by
          // FaceElements that have moved (see above)

          else
           {
            node_must_not_be_removed_from_boundary_flag[nod_pt][bound_old]+=1;
           }
         }
       }

      // If not, reset the current 'arclength' to zero,
      // increase the new face id by one and go one element
      // back by decreasing e by one to make sure the current
      // element gets added to the next face mesh      

      else
       {
        if(new_face_id!=n_polyline-1)
         {
          s=0.0;
          new_face_id++;
          --e;
         }
        else
         {
          s=0.0;
          --e;
         }
       }
     }
   } // end of loop over all polylines -- they are now re-distributed


  // Loop over all nodes on the boundaries of the polygon to remove
  // nodes from boundaries they are no longer on
  unsigned move_count=0;
  for (std::map<Node*,std::map<unsigned,unsigned> >::iterator
    it=node_must_not_be_removed_from_boundary_flag.begin();
    it!=node_must_not_be_removed_from_boundary_flag.end();it++)
   {
    // Get the node
    Node* nod_pt=(*it).first;

    // Now we loop over the boundaries that this node is on
    for (std::map<unsigned,unsigned>::iterator
      it_2=(*it).second.begin();it_2!=(*it).second.end();it_2++)
     {
      // Get the boundary id
      unsigned bound=(*it_2).first;

      // Remove it from that boundary?
      if((*it_2).second==0)
       {
        remove_boundary_node(bound,nod_pt);
        move_count++;
       }
     }
   }

  // Loop over the new face mesh to assign new boundary IDs
  for(unsigned p=0;p<n_polyline;p++)
   {
    //Get the boundary id of the polyline
    unsigned bound =
    polygon_pt->polyline_pt(p)->boundary_id();

    // Loop over the face elements
    unsigned n_face_element = face_mesh_pt[p]->nelement();
    for(unsigned e=0;e<n_face_element;e++)
     {
      //Cast the element pointer to the correct thing!
      FaceElementAsGeomObject<ELEMENT>* el_pt=
      dynamic_cast<FaceElementAsGeomObject<ELEMENT>*>
      (face_mesh_pt[p]->element_pt(e));

      // Set bulk boundary number
      el_pt->set_boundary_number_in_bulk_mesh(bound);
     }
   }

  // Update look-up for elements next to boundary
  setup_boundary_element_info();

  // Now re-create the boundary coordinates
  for(unsigned p=0;p<n_polyline;p++)
   {
    //Get the boundary id of the polyline
    unsigned bound =
    polygon_pt->polyline_pt(p)->boundary_id();

    // Do it
    this->template setup_boundary_coordinates<ELEMENT>(bound);
   }

  // Clean up
  for(unsigned p=0;p<n_polyline;p++)
   {
    // Flush the nodes from the face mesh to make sure we
    // don't delete them (the face mesh that we're returning from here
    // still needs them!)
    ordered_face_mesh_pt[p]->flush_element_and_node_storage();
    delete ordered_face_mesh_pt[p];
   }

 }

//=========================================================================
/// Helper function to construct face mesh representation of all polylines
//=========================================================================
template<class ELEMENT>
void RefineableTriangleMesh<ELEMENT>::
get_face_mesh_representation(
  TriangleMeshOpenCurve* open_polyline_pt,
  Vector<Mesh*>& face_mesh_pt)
{
 // Number of polylines
 unsigned n_polyline = open_polyline_pt->ncurve_section();
 face_mesh_pt.resize(n_polyline);

 // Loop over constituent polylines
 for(unsigned p=0;p<n_polyline;p++)
  {

   //Get the boundary id of the polyline
   unsigned bound =
    open_polyline_pt->curve_section_pt(p)->boundary_id();

   face_mesh_pt[p] = new Mesh();
   create_unsorted_face_mesh_representation(
    bound, face_mesh_pt[p]);

  }

}

//======================================================================
/// Update the PSLG that define the inner boundaries of the mesh.
///Optional boolean is used to run it as test only (if 
/// true is specified as input) in which case PSLG isn't actually
/// modified. Returned boolean indicates if PSLG was (or would have
/// been -- if called with check_only=false) changed.
//======================================================================
template <class ELEMENT>
bool RefineableTriangleMesh<ELEMENT>::
surface_remesh_for_inner_hole_boundaries(Vector<Vector<double> >
  &internal_point_coord,
  const bool& check_only)
 {
  //Boolean to indicate whether an actual update of the internal
  // holes was performed
  bool update_was_performed=false;
  //Loop over the number of internal boundaries
  unsigned n_hole = internal_point_coord.size();
  for(unsigned ihole=0;ihole<n_hole;ihole++)
   {
    //Cache the pointer to the polygon representation
    TriangleMeshPolygon* const poly_pt
    = this->Internal_polygon_pt[ihole];

    
    //Can the polygon update its own configuration, in which case this
    //is easy
    if(poly_pt->can_update_reference_configuration())
     {
      poly_pt->reset_reference_configuration();

      // Initialize Vector hole_coordinates
      internal_point_coord[ihole].resize(2);

      // Get the vector of hole coordinates
      internal_point_coord[ihole]=poly_pt->internal_point();
     }
    //Otherwise we have to work much harder

    else
     {
      //if we only want to check whether an update of the inner
      //hole is necessary
      if(check_only)
       {
        //is it necessary?
        bool update_necessary=
        this->update_polygon_using_face_mesh(poly_pt,check_only);

        //Yes?
        if(update_necessary)
         {
          //then we have to adaptand return 'true'
          return true;
         }
       }
      //if we not only want to check, then we actually perform
      //the update
      else
       {
        update_was_performed=
        this->update_polygon_using_face_mesh(poly_pt);
       }

      //Now we need to sort out the hole coordinates
      if (!poly_pt->internal_point().empty())
       {
        //If fixed don't update and simply
        //Read out the existing value
        if(poly_pt->is_internal_point_fixed())
         {
          // Get the vector of hole coordinates
          internal_point_coord[ihole]=poly_pt->internal_point();
         }
        //This is where the work starts and this could be made much
        //better than the current hack
        else
         {
          //If the user has set their own function then use that
          if(this->Internal_hole_point_update_fct_pt!=0)
           {
            this->Internal_hole_point_update_fct_pt(ihole,poly_pt);
           }
          //Otherwise use our clunky default
          else
           {
            //Now sort out the hole coordinates
            Vector<double> vertex_coord;
            unsigned n_polyline = poly_pt->npolyline();
            
            // Initialize Vector hole_coordinates
            vertex_coord.resize(2);
            internal_point_coord[ihole].resize(2);
            
            //Hole centre will be found by averaging the position of
            //all vertex nodes
            internal_point_coord[ihole][0] = 0.0;
            internal_point_coord[ihole][1] = 0.0;
            
            for(unsigned p=0;p<n_polyline;p++)
             {
              Vector<double> poly_ave(2,0.0);
              //How many vertices are there in the segment
              unsigned n_vertex = poly_pt->polyline_pt(p)->nvertex();
              for(unsigned v=0;v<n_vertex;v++)
               {
                vertex_coord = poly_pt->polyline_pt(p)->vertex_coordinate(v);
                for(unsigned i=0;i<2;i++)
                 {
                  poly_ave[i] += vertex_coord[i];
                 }
               }
              
              //Add the average polyline coordinate to the hole centre
              for(unsigned i=0;i<2;i++)
               {
                internal_point_coord[ihole][i] += poly_ave[i]/n_vertex;
               }
             }
            
            //Now average out the hole centre
            for(unsigned i=0;i<2;i++)
             {
              internal_point_coord[ihole][i] /= n_polyline;
             }
            
            //We have now found the hole centre stored in internal_point_coordinate[ihole][i]
            
            //Find polylines that intersect at y average value
            //Alice's version but this does not work if the end point of a
            //segment is the intersection point (i.e. at the y average value)
            /*Vector<double> vertex_coord2;
              unsigned n_intersect=0;
              double x_average=0.0;
              
              for(unsigned p=0;p<n_polyline;p++)
              {
              //How many vertices are there in the segment
              unsigned n_vertex = poly_pt->polyline_pt(p)->nvertex();
              for(unsigned v=0;v<n_vertex-1;v++)
              {
              vertex_coord =  poly_pt->polyline_pt(p)->vertex_coordinate(v);
              vertex_coord2 = poly_pt->polyline_pt(p)->vertex_coordinate(v+1);
              std::cout << vertex_coord[0] << " " << vertex_coord[1]
              << " " <<
              vertex_coord2[0] << " " <<
              
              vertex_coord2[1] << "\n";
              //Does the line between vertices intersect the vertical position
              if((vertex_coord[1] -internal_point_coord[ihole][1])*
              (vertex_coord2[1] - internal_point_coord[ihole][1]) < 0.0)
              {
              ++n_intersect; x_average += 0.5*(vertex_coord[0] + vertex_coord2[0]);
              }
              }
              }
              
              //Now just report the value if we have had intersections
              if(n_intersect != 0)
              {
              //Report
              std::cout << "I have computed a hole " << x_average << " " << n_intersect << " "
              << x_average/((double)n_intersect) << std::endl;
              internal_point_coord[ihole][0] = x_average/((double)n_intersect);
              }
            */
            
            //Set the new hole centre
            poly_pt->internal_point() = internal_point_coord[ihole];
            //std::cout << "I've had my centre updated to "
            //          << internal_point_coord[ihole][0]
            //          << " " << internal_point_coord[ihole][1] << "\n";
           }
         }
        
       }
     }
   } //End of the action (n_hole for)

  if(check_only)
   {
    // If we make it up to here and we only check then no update is required
    return false;
   }
  else
   {
    // otherwise indicate whether an actual update was performed
    return update_was_performed;
   }
  
 } //End of the loop of internal boundaries

 //======================================================================
 /// Create the polylines and fill associate data structures, used when
 /// creating from a mesh from polyfiles
 //======================================================================
 template<class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::
 create_polylines_from_polyfiles(const std::string& node_file_name,
                                 const std::string& poly_file_name)
 {
  // Get the nodes coordinates (the index of the nodes to build the
  // polylines is the one used in the node_file_name file)
  // Process node file
  // -----------------
  std::ifstream node_file(node_file_name.c_str(),std::ios_base::in);

  // Check that the file actually opened correctly
  if(!node_file.is_open())
   {
    std::string error_msg("Failed to open node file: ");
    error_msg += "\"" + node_file_name + "\".";
    throw OomphLibError(error_msg, OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }

  // Read number of nodes
  unsigned nnodes;
  node_file >> nnodes;
   
  // Spatial dimension of nodes
  unsigned dimension;
  node_file >> dimension;
  
#ifdef PARANOID
  if(dimension!=2)
   {
    throw OomphLibError("The dimension must be 2\n",
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif
   
  // Storage the nodes vertices
  Vector<double> x_node(nnodes);
  Vector<double> y_node(nnodes);

  // Number of attributes
  unsigned npoint_attributes;
  node_file >> npoint_attributes;;
  
  // Flag for boundary markers
  unsigned boundary_markers_flag=0;
  node_file >> boundary_markers_flag;

  // Dummy for node number
  unsigned dummy_node_number;
  // Dummy for node attribute
  unsigned dummy_node_attribute;
  // Dummy for node boundary
  unsigned dummy_node_boundary;
   
  // Load in nodal posititions, point attributes
  // and boundary markers
  for(unsigned i=0;i<nnodes;i++)
   {
    node_file>>dummy_node_number;
    node_file>>x_node[i];
    node_file>>y_node[i];
    for(unsigned j=0;j<npoint_attributes;++j)
     {
      node_file>>dummy_node_attribute;
     }
    if(boundary_markers_flag)
     {
      node_file>>dummy_node_boundary;
     }
   }
  node_file.close();
  
  // Get the segments information and use that info. to create the
  // polylines
  
  // A map to store the segments associated to a boundary, non sorted
  std::map<unsigned,Vector<std::pair<unsigned,unsigned> > > 
   unsorted_boundary_segments;
  
  // Independent storage for the boundaries ids found in the segments so that
  // the polylines, and therefore polygons be created in the order they appear
  // in the polyfile
  Vector<unsigned> sorted_boundaries_ids;
   
  // Process poly file to extract edges
  //-----------------------------------
   
  // Open poly file
  std::ifstream poly_file(poly_file_name.c_str(),std::ios_base::in);

  // Check that the file actually opened correctly
  if(!poly_file.is_open())
   {
    std::string error_msg("Failed to open poly file: ");
    error_msg += "\"" + poly_file_name + "\".";
    throw OomphLibError(error_msg, OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }

  // Number of nodes in poly file --- these will be ignore
  unsigned n_node_poly;
  poly_file >> n_node_poly;

  // Dimension
  poly_file >> dimension;

  // Attribute flag
  unsigned attribute_flag;
  poly_file >> attribute_flag;

  // Flag for boundary markers
  poly_file >> boundary_markers_flag;
  
  // Ignore node information: Note: No, we can't extract the
  // actual nodes themselves from here!
  unsigned dummy;
  for(unsigned i=0;i<n_node_poly;i++)
   {
    //Read in (and discard) node number and x and y coordinates
    poly_file>>dummy;
    poly_file>>dummy;
    poly_file>>dummy;
    //read in the attributes
    for(unsigned j=0;j<attribute_flag;++j)
     {
      poly_file >> dummy;
     }
    //read in the boundary marker
    if(boundary_markers_flag==1)
     {
      poly_file>>dummy;
     }
   }
  
  // Variable used to read the values from the input file
  unsigned read_value;
  
  // Number of segments
  poly_file >> read_value;
  const unsigned nglobal_segments = read_value;
  
  // Boundary marker flag
  poly_file >> boundary_markers_flag;
  
  // Global segment number
  unsigned global_segment_number;

  // Node identifier set (used to identify possible internal boundaries)
  std::set<unsigned> nodes_ids;

  // Extract information for each segment
  for(unsigned i=0;i<nglobal_segments;i++)
   {
    // Node id on the edge of the segment
    unsigned lnode_id=0; // left node
    unsigned rnode_id=0; // right node
    unsigned bnd_id=0;   // boundary id associated to the current segment
    poly_file >> global_segment_number;
    poly_file >> lnode_id;
    poly_file >> rnode_id;
    nodes_ids.insert(lnode_id);
    nodes_ids.insert(rnode_id);
    if(boundary_markers_flag)
     {
      poly_file >> bnd_id;
     }
    
    // Store the segments info. (use bnd_id - 1 because the nodes and
    // elements associated the bnd_id have been associated by external
    // methods to bnd_id - 1)
    unsorted_boundary_segments[bnd_id-1].push_back(
     std::make_pair(lnode_id, rnode_id));
    
    // Add the boundary id to the vector of boundaries ids only if it
    // has not been added, the polylines will be created using this
    // order
    
    // Get the number of boundaries ids currently sorted
    const unsigned nsorted_boundaries_ids = 
     sorted_boundaries_ids.size();
    // Flag to know if the boundary id was found
    bool boundary_id_found = false;
    for (unsigned ib = 0; ib < nsorted_boundaries_ids; ib++)
     {
      if (sorted_boundaries_ids[ib] == bnd_id - 1)
       {
        boundary_id_found = true;
        break;
       } // if (sorted_boundaries_ids[ib] == bnd_id - 1)
     } // for (ib < nsorted_boundaries_ids)
    
    // If th boundary id has not been added, then add it!!!
    if (!boundary_id_found)
     {
      sorted_boundaries_ids.push_back(bnd_id - 1);
     } // if (!boundary_id_found)
    
   }
  
  // Verify if there are internal boundaries defined, if that is the
  // case we can not continue since we are not yet supporting internal
  // boundaries defined in polyfiles to created a mesh that may be
  // adapted
#ifdef PARANOID
  if (nglobal_segments != nodes_ids.size())
   {
    std::ostringstream error_message;
    error_message
     << "The number of nodes (" << nodes_ids.size() << ") and segments (" 
     << nglobal_segments << ") is different.\nThis may mean that there  "
     << "are internal non-closed boundaries defined in\nthe polyfile. "
     << "If you need this feature please use the TriangleMeshPoyLine\n"
     << "and TriangleMeshCurviLine objects to define your domain.\n\n";
    throw OomphLibError(error_message.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
  // Now sort the segments associated to a boundary to create a contiguous
  // polyline, but first check that the number of found boundaries be the
  // same as the current number of boundaries in the mesh
  const unsigned nboundary = unsorted_boundary_segments.size();
  
#ifdef PARANOID
  if (nboundary != this->nboundary())
   {
    std::ostringstream error_message;
    error_message
     << "The number of boundaries on the mesh (" << this->nboundary() 
     << ") is different from the number of\nboundaries read from the "
     << "polyfiles (" << unsorted_boundary_segments.size() << ")!!!\n\n\n";
    throw OomphLibError(error_message.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
  // Get the number of sorted boundaries ids and check that it matches
  // with the total number of boundaries
  const unsigned nsorted_boundaries_ids = 
   sorted_boundaries_ids.size();
#ifdef PARANOID
  if (nsorted_boundaries_ids != this->nboundary())
   {
    std::ostringstream error_message;
    error_message
     << "The number of boundaries on the mesh (" << this->nboundary() 
     << ") is different from the number of\nsorted boundaries ids read "
     << "from the polyfiles (" << nsorted_boundaries_ids << ")!!!\n\n\n";
    throw OomphLibError(error_message.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
  // Sorted segments (to create a polyline -- boundary)
  std::map<unsigned, std::list<unsigned> > sorted_boundary_segments;
  
  // Go through all the found boundaries
  std::map<unsigned,Vector<std::pair<unsigned,unsigned> > >::iterator it;
  
  for (it = unsorted_boundary_segments.begin(); 
       it != unsorted_boundary_segments.end(); 
       it++)
   {
    // Get the current boundary id, only look for the segments
    // associated with this boundary
    const unsigned bnd_id = (*it).first;
    Vector<std::pair<unsigned, unsigned> > segments_edges = (*it).second;

    // Now sort the segments associated to this boundary
    std::map<std::pair<unsigned, unsigned>, bool> segment_done;
    const unsigned nsegments = segments_edges.size();
    
    // Sorted nodes for the current segment
    std::list<unsigned> sorted_segments;
    
    // Get the left and right node of the zero segment
    unsigned left_node_id = segments_edges[0].first;
    unsigned right_node_id = segments_edges[0].second;
    
    // ...  and add it to the sorted segments structure
    sorted_segments.push_back(left_node_id);
    sorted_segments.push_back(right_node_id);

    // Mark the current segment as done
    segment_done[segments_edges[0]] = true;

    // Set the number of sorted segments
    unsigned nsorted_segments = 1;

    while(nsorted_segments < nsegments)
     {
      for (unsigned i = 1; i < nsegments; i++)
       {
        // Check if the i-th segments has been done
        if (!segment_done[segments_edges[i]])
         {
          // Get the left and right node id
          unsigned current_left_node_id = segments_edges[i].first;
          unsigned current_right_node_id = segments_edges[i].second;
          
          // Now check if the current segment can be added to the left
          // or right side of the sorted segments
          if (current_left_node_id == right_node_id)
           {
            // Add the current_right_node_id to the right of the sorted
            // segments
            sorted_segments.push_back(current_right_node_id);
            // Increase the number of sorted segments
            nsorted_segments++;
            // Mark the segment as done
            segment_done[segments_edges[i]] = true;
            // Update the right most node
            right_node_id = current_right_node_id;
            // Break the for loop
            break;
           }
          else if (current_right_node_id == left_node_id)
           {
            // Add the current_left_node_id to the left of the sorted
            // segments
            sorted_segments.push_front(current_left_node_id);
            // Increase the number of sorted segments
            nsorted_segments++;
            // Mark the segment as done
            segment_done[segments_edges[i]] = true;
            // Update the left most node
            left_node_id = current_left_node_id;
            // Break the for loop
            break;
           }
          else if (current_left_node_id == left_node_id)
           {
            // Add the current_right_node_id to the left of the sorted
            // segments
            sorted_segments.push_front(current_right_node_id);
            // Increase the number of sorted segments
            nsorted_segments++;
            // Mark the segment as done
            segment_done[segments_edges[i]] = true;
            // Update the left most node
            left_node_id = current_right_node_id;
            // Break the for loop
            break;
           }
          else if (current_right_node_id == right_node_id)
           {
            // Add the current_left_node_id to the right of the sorted
            // segments
            sorted_segments.push_back(current_left_node_id);
            // Increase the number of sorted segments
            nsorted_segments++;
            // Mark the segment as done
            segment_done[segments_edges[i]] = true;
            // Update the left most node
            right_node_id = current_left_node_id;
            // Break the for loop
            break;
           }
         } // if (!segment_done[segments_edges[i]])
       } // for (i < nsegments)
     } // while(nsorted_segments < nsegments)
    
    sorted_boundary_segments[bnd_id] = sorted_segments;
    
   } // for (unsorted_boundary_segments.begin(); 
     //      unsorted_boundary_segments.end())

#ifdef PARANOID
  if (sorted_boundary_segments.size() != this->nboundary())
   {
    std::ostringstream error_message;
    error_message
     << "The number of boundaries on the mesh (" << this->nboundary() 
     << ") is different from the number\nof sorted boundaries to create the "
     << "polylines (" << sorted_boundary_segments.size() << ")\n\n";
    throw OomphLibError(error_message.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif

  // Now we have the sorted nodes, we can create the polylines by
  // getting the vertices of the nodes
  Vector<TriangleMeshPolyLine*> polylines_pt(nboundary);
  unsigned current_polyline = 0;
  
  // Go through the sorted boundaries using the sorted boundaries ids
  for (unsigned ib = 0; ib < nsorted_boundaries_ids; ib++)
   {
    // Get the boundary id from the vector of sorted boundaries ids
    const unsigned bnd_id = sorted_boundaries_ids[ib];
    
    // Create a vector representation for ease to use
    // Get the vertices of the nodes that create the boundary / polyline
    Vector<unsigned> nodes_ids;
    for (std::list<unsigned>::iterator it_list = 
          sorted_boundary_segments[bnd_id].begin();
         it_list != sorted_boundary_segments[bnd_id].end(); 
         it_list++)
     {nodes_ids.push_back((*it_list));}
    
    // Get the number of vertices for the polyline
    const unsigned nvertices = nodes_ids.size();

    // The storage for the vertices
    Vector<Vector<double> > vertices(nvertices);
    
    // Now get the vertices of the nodes of the current boundary
    for (unsigned i = 0; i < nvertices; i++)
     {
      // Get the vertices
      vertices[i].resize(2);
      vertices[i][0] = x_node[nodes_ids[i]-1];
      vertices[i][1] = y_node[nodes_ids[i]-1];
     }
    
    // Now create the polyline 
     
    // Note: The bnd_id is the real bnd_id (from the input file) - 1
    // since nodes and elements of the current boundary have been
    // associated to bnd_id - 1)
    polylines_pt[current_polyline] = 
     new TriangleMeshPolyLine(vertices, bnd_id);
    
    // Updates bnd_id<--->curve section map
    this->Boundary_curve_section_pt[bnd_id] = 
     dynamic_cast<TriangleMeshCurveSection*>(polylines_pt[current_polyline]);
    
    // Increase the index for the polyline storage
    current_polyline++;
    
   } // for (it_sorted = sorted_boundary_segments.begin();
     //      it_sorted != sorted_boundary_segments.end())
  
  // Now create the polygons or closed curves
  // Sort the polylines to create polygons
  unsigned nsorted_polylines = 0;

  // Number of created polygons
  unsigned npolygons = 0;

  // Storage for the polygons
  Vector<TriangleMeshPolygon*> polygons_pt;
  
  // Mark the already done polylines
  std::map<unsigned, bool> polyline_done;
  while(nsorted_polylines < nboundary)
   {
    // Storage for the curve sections that create a polygon
    std::list<TriangleMeshCurveSection*> sorted_curve_sections_pt;
    
    unsigned init_poly = 0;
#ifdef PARANOID
    bool found_root_polyline = false;
#endif
    // Get the left and right node of the current polyline
    for (unsigned i = 0; i < nboundary; i++)
     {
      if (!polyline_done[i])
       {
        init_poly = i;
        // Increase the number of sorted polylines
        nsorted_polylines++;
#ifdef PARANOID
        // Mark as found the root polyline
        found_root_polyline = true;
#endif
        // Mark the polyline as done
        polyline_done[i] = true;
        // Add the polyline to the curve sections storage
        sorted_curve_sections_pt.push_back(polylines_pt[i]);
        // Break the loop to set we have found a root polyline
        break;
       }
     }
    
#ifdef PARANOID
    if (!found_root_polyline)
     {
      std::ostringstream error_message;
      error_message
       << "Was not possible to found the root polyline to create polygons\n\n";
      throw OomphLibError(error_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     }
#endif
    
    // Get the associated boundary to the current polyline
    const unsigned bnd_id = polylines_pt[init_poly]->boundary_id();
    // Get the initial and final node id of the current polyline
    unsigned left_node_id = sorted_boundary_segments[bnd_id].front();
    unsigned right_node_id = sorted_boundary_segments[bnd_id].back();
    
    // Flag to know that we already have a closed polygon
    bool closed_polygon = false;
    
    do
     {
      // Go through all the polylines
      for (unsigned i = init_poly; i < nboundary; i++)
       {
        // Check that the polyline has not been currently done
        if (!polyline_done[i])
         {
          // Get the initial and final nodes id of the current polyline
          
          // Get the associated boundary to the current polyline
          const unsigned cbnd_id = polylines_pt[i]->boundary_id();
          // Get the initial and final node id of the current polyline
          unsigned cleft_node_id = sorted_boundary_segments[cbnd_id].front();
          unsigned cright_node_id = sorted_boundary_segments[cbnd_id].back();
          
          // Check if the polyline goes to the left or right of the
          // current sorted polylines
          if (cleft_node_id == right_node_id)
           {
            // Add the polyline to the curve section storage
            sorted_curve_sections_pt.push_back(polylines_pt[i]);
            // Mark the polyline as done
            polyline_done[i] = true;
            // Update the right node
            right_node_id = cright_node_id;
            // Increase the number of done polyines
            nsorted_polylines++;
            // Break the for loop
            break;
           }
          else if (cright_node_id == left_node_id)
           {
            // Add the polyline to the curve section storage
            sorted_curve_sections_pt.push_front(polylines_pt[i]);
            // Mark the polyline as done
            polyline_done[i] = true;
            // Update the right node
            left_node_id = cleft_node_id;
            // Increase the number of done polyines
            nsorted_polylines++;
            // Break the for loop
            break;
           }
          else if (cleft_node_id == left_node_id)
           {
            // First reverse the polyline
            polylines_pt[i]->reverse();
            // Add the polyline to the curve section storage
            sorted_curve_sections_pt.push_front(polylines_pt[i]);
            // Mark the polyline as done
            polyline_done[i] = true;
            // Update the right node
            left_node_id = cright_node_id;
            // Increase the number of done polyines
            nsorted_polylines++;
            // Break the for loop
            break;
           }
          else if (cright_node_id == right_node_id)
           {
            // First reverse the polyline
            polylines_pt[i]->reverse();
            // Add the polyline to the curve section storage
            sorted_curve_sections_pt.push_back(polylines_pt[i]);
            // Mark the polyline as done
            polyline_done[i] = true;
            // Update the right node
            right_node_id = cleft_node_id;
            // Increase the number of done polyines
            nsorted_polylines++;
            // Break the for loop
            break;
           }
         } // if (!polyline_done[i])
        
       } // for (i < nboundary)
      
      // We have created a polygon
      if (left_node_id == right_node_id)
       {
        // Set the flag as true
        closed_polygon = true;  
       }
      
     }while(nsorted_polylines < nboundary && !closed_polygon);
    
#ifdef PARANOID
    if (!closed_polygon)
     {
      std::ostringstream error_message;
      error_message
       << "It was not possible to create a closed curve, these are the "
       << "vertices of the already sorted polylines\n\n";
      unsigned cpolyline = 0;
      for (std::list<TriangleMeshCurveSection*>::iterator it_list = 
            sorted_curve_sections_pt.begin(); 
           it_list != sorted_curve_sections_pt.end(); 
           it_list++)
       {
        error_message << "Polyline (" << cpolyline << ")\n";
        TriangleMeshPolyLine *tmp_poly_pt =
         dynamic_cast<TriangleMeshPolyLine*>((*it_list));
        const unsigned nvertex = tmp_poly_pt->nvertex();
        for (unsigned v = 0; v < nvertex; v++)
         {
          error_message <<"("<<tmp_poly_pt->vertex_coordinate(v)[0] 
                        <<", "<<tmp_poly_pt->vertex_coordinate(v)[1]<<")\n";
         }
        error_message << "\n";
        cpolyline++;
       }
      throw OomphLibError(error_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     }
#endif
    
    // Create a vector version to create the polygon from the sorted
    // polyines
    Vector<TriangleMeshCurveSection*> tmp_sorted_curve_sections_pt;
    for (std::list<TriangleMeshCurveSection*>::iterator it_list = 
          sorted_curve_sections_pt.begin(); 
         it_list != sorted_curve_sections_pt.end();
         it_list++)
     {tmp_sorted_curve_sections_pt.push_back((*it_list));}
    
    // Create a new polygon by using the new created polylines
    TriangleMeshPolygon *polygon_pt =
     new TriangleMeshPolygon(tmp_sorted_curve_sections_pt);
    
    // Keep track of new created polygons that need to be deleted!!!
    this->Free_polygon_pt.insert(polygon_pt);
    
    // Store the polygon in the polygons storages
    polygons_pt.push_back(polygon_pt);
    
    npolygons++;
    
   } // while(nsorted_polylines < nboundary)
  
  // ------------------------------------------------------------------
  // Before filling the data structures we need to identify the outer
  // closed boundary and the inner closed boundaries.
  // If the nodes are not in order we throw a warning message
  
  // Index for the polygon that is currently considered as the outer
  // boundary
  unsigned index_outer = 0;
  
  for (unsigned idx_outer = 0; idx_outer < npolygons; idx_outer++)
   {
    // Get the vertices of the outer boundary
    Vector<Vector<double> > outer_vertex_coordinates;
    
    // Flag to know if ALL the inner closed boundaries are inside the
    // outer closed boundary
    bool all_inner_inside = true;
    
    // Number of polylines of the outer boundary
    const unsigned nouter_polylines = polygons_pt[idx_outer]->npolyline();
    for (unsigned p = 0; p < nouter_polylines; p++)
     {
      TriangleMeshPolyLine* tmp_poly_pt = 
       polygons_pt[idx_outer]->polyline_pt(p);
      const unsigned nvertex = tmp_poly_pt->nvertex();
      for (unsigned v = 0; v < nvertex; v++)
       {
        Vector<double> current_vertex = tmp_poly_pt->vertex_coordinate(v);
        outer_vertex_coordinates.push_back(current_vertex);
       } // for (v < nvertex)
     } // for (p < nouter_polylines)
    
    // Now get the vertices for the inner boundaries 
    
    // First get the number of inner closed boundaries (polygons size
    // minus one because one of the polygons is considered to be the
    // outer closed boundary
    const unsigned ninner_polygons = polygons_pt.size() - 1;
    
    // Store the vertices of the inner closed boundaries
    Vector<Vector<Vector<double> > > inner_vertex_coordinates(ninner_polygons);
    // Get all the vertices of the inner closed boundaries
    for (unsigned i = 0; i <= ninner_polygons; i++)
     {    
      if (i != idx_outer)
       {
        // Number of polylines of the current internal closed boundary
        const unsigned ninner_polylines = polygons_pt[i]->npolyline();
        for (unsigned p = 0; p < ninner_polylines; p++)
         {
          TriangleMeshPolyLine* tmp_poly_pt = polygons_pt[i]->polyline_pt(p);
          const unsigned nvertex = tmp_poly_pt->nvertex();
          for (unsigned v = 0; v < nvertex; v++)
           {
            Vector<double> current_vertex = tmp_poly_pt->vertex_coordinate(v);
            if (i < idx_outer)
             {
              inner_vertex_coordinates[i].push_back(current_vertex);
             }
            else if (i > idx_outer)
             {
              inner_vertex_coordinates[i-1].push_back(current_vertex);
             }
           } // for (v < nvertex)
          
         } // for (p < ninner_polylines)
        
       } // if (i != index_outer)
      
     } // for (i <= ninner_polygons)
    
    // Now check that ALL the vertices of ALL the internal closed
    // boundaries are inside the outer closed boundary
    for (unsigned i = 0; i < ninner_polygons; i++)
     {
      // Get the number of vertices in the current internal closed
      // boundary
      const unsigned nvertex_internal = inner_vertex_coordinates[i].size();
      for (unsigned v = 0; v < nvertex_internal; v++)
       {
        // Get a vertex in the current internal closed boundary
        Vector<double> current_point = inner_vertex_coordinates[i][v];
        all_inner_inside &= 
          this->is_point_inside_polygon_helper(outer_vertex_coordinates,
                                               current_point);
                                               
        // Check if we should continue checking for more points inside
        // the current proposed outer boundary
        if (!all_inner_inside)
         {
          // Break the "for" for the vertices
          break;
         }
        
       } // for (v < nvertex_internal)
      
      // Check if we should continue checking for more inner closed
      // boundaries inside the current proposed outer boundary
      if (!all_inner_inside)
       {
        // Break the "for" for the inner boundaries
        break;
       }
      
     } // for (i < ninner_polygons)
    
    // Check if all the vertices of all the polygones are inside the
    // current proposed outer boundary
    if (all_inner_inside)
     {
      index_outer = idx_outer;
      break;
     }
    
   } // for (idx_outer < npolygons)
  
#ifdef PARANOID
  // Check if the first nodes listed in the polyfiles correspond to
  // the outer boundary, if that is not the case then throw a warning
  // message
  if (index_outer != 0)
   {
    std::ostringstream warning_message;
    warning_message
     << "The first set of nodes listed in the input polyfiles does not\n"
     << "correspond to the outer closed boundary. This may lead to\n"
     << "problems at the adaptation stage if the holes coordinates\n"
     << "are no correctly associated to the inner closed boundaries.\n"
     << "You can check the generated mesh by calling the output() method\n"
     << "from the mesh object '(problem.mesh_pt()->output(string))'\n\n";
    OomphLibWarning(warning_message.str(),
                    OOMPH_CURRENT_FUNCTION,
                    OOMPH_EXCEPTION_LOCATION);
   } // if (index_outer != 0)
#endif
  
  // ------------------------------------------------------------------
  // Now fill the data structures
  
  // Store outer polygon
  // We are assuming there is only one outer polygon
  this->Outer_boundary_pt.resize(1);
  this->Outer_boundary_pt[0] = polygons_pt[index_outer];
  
  this->Internal_polygon_pt.resize(npolygons-1);
  for (unsigned i = 0; i < npolygons; i++)
   {
    if (i != index_outer)
     {
      if (i < index_outer)
       {
        // Store internal polygons by copy constructor
        this->Internal_polygon_pt[i] = polygons_pt[i];
       }
      else if (i > index_outer)
       {
        // Store internal polygons by copy constructor
        this->Internal_polygon_pt[i-1] = polygons_pt[i];
       }
     } // if (i != index_outer)
   } // for (i < npolygons)
  
  // Before assigning the hole vertex coordinate to the inner closed
  // boundaries check that the holes are listed in orderm if that is
  // not the case the associate each hole vertex coordinate to the
  // inner closed boundaries
  
  // Store the vertices of the inner closed boundaries
  Vector<Vector<Vector<double> > > inner_vertex_coordinates(npolygons-1);
  // Get all the vertices of the inner closed boundaries
  for (unsigned i = 0; i < npolygons-1; i++)
   {    
    // Number of polylines of the current internal closed boundary
    const unsigned ninner_polylines = 
     this->Internal_polygon_pt[i]->npolyline();
    for (unsigned p = 0; p < ninner_polylines; p++)
     {
      TriangleMeshPolyLine* tmp_poly_pt = 
       this->Internal_polygon_pt[i]->polyline_pt(p);
      // Number of vertices of the current polyline in the current
      // internal closed polygon
      const unsigned nvertex = tmp_poly_pt->nvertex();
      for (unsigned v = 0; v < nvertex; v++)
       {
        Vector<double> current_vertex = tmp_poly_pt->vertex_coordinate(v);
        inner_vertex_coordinates[i].push_back(current_vertex);
       } // for (v < nvertex)
      
     } // for (p < ninner_polylines)
    
   } // for (i <= ninner_polygons)
  
  // Holes information
  unsigned nholes;
  poly_file >> nholes;
  
#ifdef PARANOID
  if (npolygons > 1 && (npolygons - 1) != nholes)
   {
    std::ostringstream error_message;
    error_message
     << "The number of holes (" << nholes << ") does not correspond "
     << "with the number\nof internal polygons (" 
     << npolygons - 1 <<")\n\n"
     << "Using polyfiles as input does not currently allows the\n"
     << "definition of more than one outer polygon\n\n";
    throw OomphLibError(error_message.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
  // Storage for the holes
  Vector<Vector<double> > hole_coordinates(nholes);
  
  // Dummy for hole number
  unsigned dummy_hole;
  // Loop over the holes to get centre coords
  for(unsigned ihole=0;ihole<nholes;ihole++)
   {
    hole_coordinates[ihole].resize(2);
    // Read the centre value
    poly_file >> dummy_hole;
    poly_file >> hole_coordinates[ihole][0];
    poly_file >> hole_coordinates[ihole][1];
   }
  
  // Vector that store the index of the hole coordinate that
  // correspond to each internal closed polygon
  Vector<unsigned> index_hole_of_internal_polygon(npolygons-1);
  std::map<unsigned, bool> hole_done;
  
  // Now associate each hole vertex to a corresponding internal closed
  // polygon
  for (unsigned i = 0; i < npolygons-1; i++)
   {
    // Find which hole is associated to each internal closed boundary
    for (unsigned h = 0; h < nholes; h++)
     {
      // If the hole has not been previously associated
      if (!hole_done[h])
       {
        // Get the hole coordinate
        Vector<double> current_point = hole_coordinates[h];
        
        const bool hole_in_polygon =
         this->is_point_inside_polygon_helper(inner_vertex_coordinates[i],
                                              current_point);
        
        // If the hole is inside the polygon
        if (hole_in_polygon)
         {
          // Mark the hole as done
          hole_done[h] = true;
          // Associate the current hole with the current inner closed
          // boundary
          index_hole_of_internal_polygon[i] = h;
          // Break the search
          break;
         }
        
       } // if (!hole_done[h])
      
     } // for (h < nholes)
    
   } // for (i < npolygons-1)
  
#ifdef PARANOID
  if (hole_done.size() != npolygons-1)
   {
    std::ostringstream error_message;
    error_message
     << "Not all the holes were associated to an internal closed boundary\n"
     << "Only ("<<hole_done.size()<<") holes were assigned for a total of\n"
     << "(" << npolygons-1 << ") internal closed boundaries.\n"
     << "You can check the generated mesh by calling the output() method\n"
     << "from the mesh object '(problem.mesh_pt()->output(string))'\n\n";
    throw OomphLibError(error_message.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   } // if (index_hole != ihole)
#endif
  
  // Assign the holes coordinates to the internal polygons
  for (unsigned ihole = 0; ihole < nholes; ihole++)
   {
    // Get the index hole of the current internal closed polygon
    const unsigned index_hole = index_hole_of_internal_polygon[ihole];
#ifdef PARANOID
    // Check if the hole index is the same as the internal closed
    // boundary, it means that the holes were listed in the same order
    // as the nodes of the internal closed boundaries
    if (index_hole != ihole)
     {
      std::ostringstream error_message;
      error_message
       << "The hole vertices coordinates are not listed in the same order\n"
       << "as the nodes that define the internal closed boundaries.\n"
       << "This may lead to problems in case that the holes coordinates\n"
       << "were no properly assigned to the internal closed boundaries.\n"
       << "You can check the generated mesh by calling the output() method\n"
       << "from the mesh object '(problem.mesh_pt()->output(string))'\n\n";
      throw OomphLibError(error_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     } // if (index_hole != ihole)
#endif
    
    // Set the hole coordinate for the internal polygon
    this->Internal_polygon_pt[ihole]->internal_point() = 
     hole_coordinates[index_hole];
   }
  
  // Ignore the first line with structure description
  poly_file.ignore(80,'\n');
  
  // Regions information
  unsigned nregions;
  
  // Extract regions information
  // But first check if there are regions or not
  std::string regions_info_string;
  
  // Read line up to termination sign
  getline(poly_file, regions_info_string);
  
  // Check if the read string is a number or a comment wrote by triangle,
  // if it is a number then that is the number of regions 
  if (isdigit(regions_info_string.c_str()[0]))
   {
    nregions = std::atoi(regions_info_string.c_str());
   }
  else
   {
    nregions = 0;
   }
  
  // The regions coordinates
  std::map<unsigned, Vector<double> > regions_coordinates;

  // Dummy for regions number
  unsigned dummy_region;

  unsigned region_id;

  // Loop over the regions to get their coords
  for(unsigned iregion=0;iregion<nregions;iregion++)
   {
    Vector<double> tmp_region_coordinates(2);
    // Read the regions coordinates
    poly_file >> dummy_region;
    poly_file >> tmp_region_coordinates[0];
    poly_file >> tmp_region_coordinates[1];
    poly_file >> region_id;
    regions_coordinates[region_id].resize(2);
    regions_coordinates[region_id][0] = tmp_region_coordinates[0];
    regions_coordinates[region_id][1] = tmp_region_coordinates[1];
    
    // Ignore the first line with structure description
    poly_file.ignore(80,'\n');
    
    // Verify if not using the default region number (zero)
    if (region_id == 0) 
     {
      std::ostringstream error_message;
      error_message << "Please use another region id different from zero.\n"
                    << "It is internally used as the default region number.\n";
      throw OomphLibError(error_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     }
    
   }

  // Store the extra regions coordinates
  this->Regions_coordinates = regions_coordinates;

  poly_file.close();
  
 }

//======================================================================
/// \short Updates the polygon but using the elements area instead of
/// the default refinement and unrefinement methods
//======================================================================
template <class ELEMENT>
bool RefineableTriangleMesh<ELEMENT>::
update_polygon_using_elements_area(TriangleMeshPolygon* &polygon_pt,
                                   const Vector<double> &target_area)
{
 // Verify that there was a change on the polygon representation
 unsigned update_was_performed = false;
 
 const unsigned nele = this->nelement();
 
 // - Get the vertices along the boundaries and for each element identify
 //   its associated target error.
 //   - Get face mesh representation of each polyline.
 //   - Get the vertices with the help of face elements.
 //   - Find the global index in the mesh of the face element and use
 //     it to get its associated target area
 
 // Get the face mesh representation
 Vector<Mesh*> face_mesh_pt;
 get_face_mesh_representation(polygon_pt,face_mesh_pt);
 
 // Create vertices of the polylines by using the vertices of the
 // FaceElements
 Vector<double> vertex_coord(3); // zeta,x,y
 Vector<double> bound_left(1);
 Vector<double> bound_right(1);

 unsigned n_polyline = polygon_pt->npolyline();

 // Go for each polyline
 for(unsigned p = 0; p < n_polyline; p++)
  {
   // Get the MeshAsGeomObject representation just once per polyline,
   // this object is only used by the
   // refine_boundary_constrained_by_target_area() method. We get it
   // here to ensure that all processors (in a distributed context)
   // get this representation just once, and because an AllToAll MPI
   // communication is used in this calling
   MeshAsGeomObject* mesh_geom_obj_pt=new MeshAsGeomObject(face_mesh_pt[p]);
   
   // Set of coordinates on the boundary
   // Set entries are ordered on first entry in vector which stores
   // the boundary coordinate so the vertices come out in order!
   std::set<Vector<double> > vertex_nodes;

   // Vector to store the vertices, transfer the sorted vertices from the
   // set to this vector, --- including the z-value ---
   Vector<Vector<double> > tmp_vector_vertex_node;

   // Vector to store the coordinates of the polylines, same as the
   // tmp_vector_vertex_node vector (after adding more nodes) but
   // --- without the z-value ---, used to re-generate the polylines
   Vector<Vector<double> > vector_vertex_node;
   
#ifdef OOMPH_HAS_MPI
   // --------- Stuff to deal with splitted boundaries ---------- Begin -----
   // Set of coordinates that are on the boundary (splitted boundary version)
   // The first vector is used to allocate the points for each sub-boundary
   // Set entries are ordered on first entry in vector which stores
   // the boundary coordinate so the vertices come out in order!
   Vector<std::set<Vector<double> > >sub_vertex_nodes;

   // Vector to store the vertices, transfer the sorted vertices from the
   // set (sub_vertex_nodes) to this vector, --- including the z-value ---
   Vector<Vector<Vector<double> > >sub_tmp_vector_vertex_node;

   // Vector to store the coordinates of the polylines that will represent
   // the splitted boundary. Used to pass the info. from sub_vertex_nodes
   // but --- without the z-value ---, used to generate the sub-polylines
   Vector<Vector<Vector<double> > > sub_vector_vertex_node;
   // --------- Stuff to deal with splitted boundaries ----------- End ------
#endif

   //Get the boundary id
   const unsigned bound = polygon_pt->curve_section_pt(p)->boundary_id();
   
   // Get the chunk number
   const unsigned chunk = polygon_pt->curve_section_pt(p)->boundary_chunk();
   
   /// Use a vector of vector for vertices and target areas to deal
   /// with the cases when the boundaries are split by the
   /// distribution process
   
   // Loop over the face elements (ordered) and add their vertices
   const unsigned nface_element = face_mesh_pt[p]->nelement();
   
   // Store the non halo face elements, the ones from which we will
   // get the vertices
   Vector<FiniteElement*> non_halo_face_element_pt;
   
   // Map to store the index of the face element on a boundary
   std::map<FiniteElement*,unsigned> face_element_index_on_boundary;
   
   for(unsigned ef=0;ef<nface_element;++ef)
    {
     FiniteElement* ele_face_pt = face_mesh_pt[p]->finite_element_pt(ef);
#ifdef OOMPH_HAS_MPI
     // Skip the halo elements if working with a distributed mesh
     if (this->is_mesh_distributed() && ele_face_pt->is_halo())
      {continue;}
#endif
     // Add the face element to the vector
     non_halo_face_element_pt.push_back(ele_face_pt);
     face_element_index_on_boundary[ele_face_pt] = ef;
    }
   
   // Get the number of non halo face element
   const unsigned nnon_halo_face_element = non_halo_face_element_pt.size();
   
   // Map to know the already sorted face elements
   std::map<FiniteElement*,bool> face_element_done;
   
   // Number of done face elements
   unsigned nsorted_face_elements = 0;
   
#ifdef OOMPH_HAS_MPI
   // Counter for sub_boundaries
   unsigned nsub_boundaries = 0;
#endif // #ifdef OOMPH_HAS_MPI
   
   // Continue until all the face elements have been sorted
   // While to deal with split boundaries cases
   while(nsorted_face_elements < nnon_halo_face_element)
    {
     // Get and initial face element
     FiniteElement* ele_face_pt = 0;
#ifdef PARANOID
     bool found_initial_face_element = false;
#endif
     
     unsigned iface = 0;
     for (iface = 0; iface < nnon_halo_face_element; iface++)
      {
       ele_face_pt = non_halo_face_element_pt[iface];
       // If not done then take it as initial face element
       if (!face_element_done[ele_face_pt])
        {
#ifdef PARANOID
         found_initial_face_element = true;
#endif
         nsorted_face_elements++;
         iface++;
         break;
        }
      }
         
#ifdef PARANOID
     if (!found_initial_face_element)
      {
       std::ostringstream error_message;
       error_message
        <<"Could not find an initial face element for the current segment\n";
       // << "----- Possible memory leak -----\n";
       throw OomphLibError(error_message.str(),
        "RefineableTriangleMesh::update_polygon_using_elements_area()",
        OOMPH_EXCEPTION_LOCATION);
      }
#endif

     // Local set of coordinates that are on the boundary
     // Set entries are ordered on first entry in vector which stores
     // the boundary coordinate so the vertices come out in order!
     std::set<Vector<double> > local_vertex_nodes;
     
     // Vector to store the vertices, transfer the sorted vertices from the
     // set (local) to this vector (local), --- including the z-value ---
     Vector<Vector<double> > local_tmp_vector_vertex_node;

     // Vector to store the target areas, uses the same approach as the
     // set for the local_vertex_nodes, ordered on first entry
     std::set<Vector<double> > sorted_target_areas;
     
     // Vector to store the target areas, used to transfer the sorted target
     // areas from "local_sorted_target_areas" set
     Vector<double> tmp_sorted_target_areas;
     
     // -----------------------------------------------------------------
     // Add the vertices of the initial face element to the set of
     // local sorted vertices
     // -----------------------------------------------------------------
     unsigned nnode = ele_face_pt->nnode();
     // Add the left-hand node to the set:
     // Boundary coordinate
     ele_face_pt->node_pt(0)->get_coordinates_on_boundary(bound,bound_left);
     vertex_coord[0] = bound_left[0];

     // Actual coordinates
     for(unsigned i=0;i<2;i++)
      {
       vertex_coord[i+1] = ele_face_pt->node_pt(0)->x(i);
      }
     local_vertex_nodes.insert(vertex_coord);

     // Add the right-hand nodes to the set:
     // Boundary coordinate
     ele_face_pt->node_pt(nnode-1)->
      get_coordinates_on_boundary(bound,bound_right);
     vertex_coord[0] = bound_right[0];

     // Actual coordinates
     for(unsigned i=0;i<2;i++)
      {
       vertex_coord[i+1] = ele_face_pt->node_pt(nnode-1)->x(i);
      }
     local_vertex_nodes.insert(vertex_coord);

     // The initial and final node on the set
     Node *first_node_pt = ele_face_pt->node_pt(0);
     Node *last_node_pt = ele_face_pt->node_pt(nnode-1);

     // Mark the current face element as done
     face_element_done[ele_face_pt] = true;
     
     // -------------------------------------------------------
     // Find the global index in the mesh of the face element
     // and use it to get its associated target area
     // -------------------------------------------------------
     // Container to store the zeta value (used as index) and
     // the associated target area of the element
     Vector<double> zeta_target_area_values(2);
     
     // Use the minimum zeta value to sort the target areas
     // along the boundary
     zeta_target_area_values[0] = 
      std::min(bound_left[0], bound_right[0]);
     
     // Get the index of the face element on the current boundary
     unsigned ef = face_element_index_on_boundary[ele_face_pt];
     // Get the "ef"-th element on the boundary
     FiniteElement *el_pt = this->boundary_element_pt(bound, ef);
     
#ifdef PARANOID
     bool found_global_element_index = false;
#endif
     for (unsigned eg = 0 ; eg < nele; eg++)
      {
       // Get the "eg-th" element
       FiniteElement *el_compare_pt = this->finite_element_pt(eg);
       
       // Compare with the element on the boundary, if equal then
       // store the target area
       if (el_pt == el_compare_pt)
        {
         zeta_target_area_values[1]  = target_area[eg];
#ifdef PARANOID
         found_global_element_index = true;
#endif
         break; // break the for (e < nele) global element
        } // if element_pt == element_compare_pt
      } // for nele (on complete mesh)
     
#ifdef PARANOID
     if (!found_global_element_index)
      {
       std::ostringstream error_message;
       error_message
        << "The global index for the ("<< ef <<")-th face element "
        << "on\nthe ("<< bound <<")-th boundary was not found!!!";
       throw OomphLibError(error_message.str(),
        "RefineableTriangleMesh::update_polygon_using_elements_area()",
        OOMPH_EXCEPTION_LOCATION);
      }
#endif
     
     // Add the target areas to the sorted set
     sorted_target_areas.insert(zeta_target_area_values);
     // ------------------------------------------------------------------
     
     // Continue iterating if a new face element has been added to the
     // list
     bool face_element_added = false;
     
     // While a new face element has been added to the set of sorted
     // face elements then re-iterate
     do
      {
       // Start from the next face elements since we have already
       // added the previous one as the initial face element (any
       // previous face element had to be added on previous
       // iterations)
       for (unsigned iiface=iface;iiface<nnon_halo_face_element;iiface++)
        {
         face_element_added = false;
         ele_face_pt = non_halo_face_element_pt[iiface];
         if (!face_element_done[ele_face_pt])
          {
           // Get each individual node to check if they are contiguous
           nnode = ele_face_pt->nnode();
           Node* left_node_pt = ele_face_pt->node_pt(0);
           Node* right_node_pt = ele_face_pt->node_pt(nnode-1);
                 
           if (left_node_pt == first_node_pt)
            {
             first_node_pt = right_node_pt;
             face_element_added = true;
            }
           else if (left_node_pt == last_node_pt)
            {
             last_node_pt = right_node_pt;
             face_element_added = true;
            }
           else if (right_node_pt == first_node_pt)
            {
             first_node_pt = left_node_pt;
             face_element_added = true;
            }
           else if (right_node_pt == last_node_pt)
            {
             last_node_pt = left_node_pt;
             face_element_added = true;
            }
           
           if (face_element_added)
            {
             // Add the left-hand node to the set:
             // Boundary coordinate
             left_node_pt->get_coordinates_on_boundary(bound,bound_left);
             vertex_coord[0] = bound_left[0];

             // Actual coordinates
             for(unsigned i=0;i<2;i++)
              {
               vertex_coord[i+1] = left_node_pt->x(i);
              }
             local_vertex_nodes.insert(vertex_coord);
             
             // Add the right-hand nodes to the set:
             // Boundary coordinate
             right_node_pt->get_coordinates_on_boundary(bound,bound_right);
             vertex_coord[0] = bound_right[0];

             // Actual coordinates
             for(unsigned i=0;i<2;i++)
              {
               vertex_coord[i+1] = right_node_pt->x(i);
              }
             local_vertex_nodes.insert(vertex_coord);
             
             // Mark as done only if one of its nodes has been
             // added to the list
             face_element_done[ele_face_pt] = true;
             nsorted_face_elements++;
             
             // -----------------------------------------------------
             // Find the global index in the mesh of the face element
             // and use it to get its associated target area
             // -----------------------------------------------------
             // Use the minimum zeta value to sort the target areas
             // along the boundary
             zeta_target_area_values[0] = 
              std::min(bound_left[0], bound_right[0]);
             
             // Get the "ef"-th element on the boundary
             ef = face_element_index_on_boundary[ele_face_pt];
             FiniteElement *lel_pt = this->boundary_element_pt(bound, ef);
             
#ifdef PARANOID
             found_global_element_index = false;
#endif
             for (unsigned eg = 0 ; eg < nele; eg++)
              {
               // Get the "eg-th" element
               FiniteElement *lel_compare_pt = this->finite_element_pt(eg);
         
               // Compare with the element on the boundary, if equal then
               // store the target area
               if (lel_pt == lel_compare_pt)
                {
                 zeta_target_area_values[1]  = target_area[eg];
#ifdef PARANOID
                 found_global_element_index = true;
#endif
                 break; // break the for (e < nele) global element
                } // if element_pt == element_compare_pt
              } // for nele (on complete mesh)
       
#ifdef PARANOID
             if (!found_global_element_index)
              {
               std::ostringstream error_message;
               error_message
                << "The global index for the ("<< ef <<")-th face element "
                << "on\nthe ("<< bound <<")-th boundary was not found!!!";
               throw OomphLibError(error_message.str(),
               "RefineableTriangleMesh::update_polygon_using_elements_area()",
               OOMPH_EXCEPTION_LOCATION);
              }
#endif
             
             // Add the target areas to the sorted set
             sorted_target_areas.insert(zeta_target_area_values);

             break;
            }
           
          } // if (!edge_done[edge])
        } // for (iiedge < nedges)
      }while(face_element_added &&
             (nsorted_face_elements < nnon_halo_face_element));
     
     // -----------------------------------------------------------------
     // At this point we already have a sorted set of nodes and
     // can be used to peform the unrefinement and refinement procedures
     // -----------------------------------------------------------------
     
     // Get the number of nodes on the list
     const unsigned nlocal_nodes = local_vertex_nodes.size();
     // Change representation to vector for easy of handling ...
     local_tmp_vector_vertex_node.resize(nlocal_nodes);
     
     // Copy the vertices of the nodes
     unsigned counter = 0;
     std::set<Vector<double> >::iterator it_vertex;
     for (it_vertex = local_vertex_nodes.begin();
          it_vertex != local_vertex_nodes.end();
          it_vertex++)
      {
       local_tmp_vector_vertex_node[counter].resize(3);
       local_tmp_vector_vertex_node[counter][0] = (*it_vertex)[0];
       local_tmp_vector_vertex_node[counter][1] = (*it_vertex)[1];
       local_tmp_vector_vertex_node[counter][2] = (*it_vertex)[2];
       counter++;
      }
     
     // ... same for the info. related with the target areas (turn
     // into vector)
     const unsigned ntarget_areas = sorted_target_areas.size();
     tmp_sorted_target_areas.resize(ntarget_areas);
     counter = 0;
     std::set<Vector<double> >::iterator it_area;
     for(it_area = sorted_target_areas.begin();
         it_area != sorted_target_areas.end();
         ++it_area)
      {
       tmp_sorted_target_areas[counter] = (*it_area)[1];
       ++counter;
      }

#ifdef PARANOID
     if (nlocal_nodes > 0 && (ntarget_areas != nlocal_nodes - 1) )
      {
       std::ostringstream error_message;
       error_message
        << "The boundary (" << bound << ") was split during the "
        << "distribution process.\n"
        << "The problem is in the association of the target areas with the\n"
        << "elements that gave rise to the vertex coordinates.\n"
        << "The number of local nodes (" << nlocal_nodes 
        << "), on the 'sub-polyline', is not\n"
        << "according with the number of target "
        << "areas ("<< ntarget_areas << ")\nfor that number of nodes.\n"
        << "The target areas number MUST be equal to the number of\n"
        << "local nodes minus one\n\n";
       throw OomphLibError(error_message.str(),
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
      }
#endif
     
     // -------------------------------------------------------------------
     // Update the vertices along the boundary using the target area
     // to define the distance among them
     // -------------------------------------------------------------------
     
     // Tolerance below which the middle point can be deleted
     // (ratio of deflection to element length)
     double unrefinement_tolerance=
      polygon_pt->polyline_pt(p)->unrefinement_tolerance();
     
     // Apply unrefinement
     bool unrefinement_applied =
      unrefine_boundary_constrained_by_target_area(
       bound, chunk, local_tmp_vector_vertex_node,
       unrefinement_tolerance, tmp_sorted_target_areas);
     
     // Tolerance for refinement
     double refinement_tolerance=
      polygon_pt->polyline_pt(p)->refinement_tolerance();
     
     // Apply refinement
     bool refinement_applied = 
      refine_boundary_constrained_by_target_area(
       mesh_geom_obj_pt, local_tmp_vector_vertex_node,
       refinement_tolerance, tmp_sorted_target_areas);
     
     // Clear the local containter to recover the nodes ordered using the
     // zeta value
     local_vertex_nodes.clear();
     
     // At the end of each unrefinement/refinement step store the new nodes
     // on the set that will give rise to the vertices of the new polyline
     // representation
     unsigned nnew_nodes = local_tmp_vector_vertex_node.size();
     for (unsigned i = 0; i < nnew_nodes; i++)
      {
       vertex_coord[0] = local_tmp_vector_vertex_node[i][0];
       vertex_coord[1] = local_tmp_vector_vertex_node[i][1];
       vertex_coord[2] = local_tmp_vector_vertex_node[i][2];
       vertex_nodes.insert(vertex_coord); // Global container
       local_vertex_nodes.insert(vertex_coord);
      }
     
     // Update the flag to indicate whether an unrefinement or
     // refinement was applied
     update_was_performed = (unrefinement_applied || refinement_applied);

#ifdef OOMPH_HAS_MPI
     if (this->is_mesh_distributed())
      {
       // Add the set of vertices for the boundary, this will help to
       // detect if we need to deal with sub-boundaries
       sub_vertex_nodes.push_back(local_vertex_nodes);
       // Increase the counter for sub-boundaries
       nsub_boundaries++;
      }
#endif
     
    } // while(nsorted_face_elements < nnon_halo_face_element)
   
   // Now turn into vector for ease of handling...
   unsigned npoly_vertex = vertex_nodes.size();
   // This will store all the vertices whether the boundary was split
   // or not
   tmp_vector_vertex_node.resize(npoly_vertex);
   unsigned count = 0;
   for(std::set<Vector<double> >::iterator it = vertex_nodes.begin(); 
       it!=vertex_nodes.end(); ++it)
    {
     tmp_vector_vertex_node[count].resize(3);
     tmp_vector_vertex_node[count][0] = (*it)[0];
     tmp_vector_vertex_node[count][1] = (*it)[1];
     tmp_vector_vertex_node[count][2] = (*it)[2];
     ++count;
    }
   
#ifdef OOMPH_HAS_MPI
   // --------- Stuff for the sub_boundaries ----- Begin section ---------
#ifdef PARANOID
   unsigned nsub_boundaries_set = sub_vertex_nodes.size();
   if (nsub_boundaries_set != nsub_boundaries)
    {
     std::ostringstream error_message;
     error_message
      << "The number of found sub-boundaries and the number of counted\n"
      << "sub-boundaries are different:\n"
      << "Number of found sub-boundaries: ("<<nsub_boundaries_set<<")\n"
      << "Number of counted sub-boundaries: ("<<nsub_boundaries<<")\n";
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   
   // Are there sub-boundaries (only appear in distributed meshes)
   if (this->is_mesh_distributed() && nsub_boundaries > 1)
    {
     // Mark the boundary as been splitted in the partition process
     this->Boundary_was_splitted[bound] = true;
     // Resize the vector to store the info. of sub-boundaries
     sub_tmp_vector_vertex_node.resize(nsub_boundaries);
     for (unsigned isub = 0; isub < nsub_boundaries; isub++)
      {
       // Turn info. into vector for ease of handling...
       const unsigned nsubpoly_vertex = sub_vertex_nodes[isub].size();
       sub_tmp_vector_vertex_node[isub].resize(nsubpoly_vertex);
       unsigned subcount = 0;
       std::set<Vector<double> >::iterator subit;
       for(subit = sub_vertex_nodes[isub].begin();
           subit != sub_vertex_nodes[isub].end(); ++subit)
        {
         sub_tmp_vector_vertex_node[isub][subcount].resize(3);
         sub_tmp_vector_vertex_node[isub][subcount][0] = (*subit)[0];
         sub_tmp_vector_vertex_node[isub][subcount][1] = (*subit)[1];
         sub_tmp_vector_vertex_node[isub][subcount][2] = (*subit)[2];
         ++subcount;
        }
      }
    } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
   // --------- Stuff for the sub_boundaries ----- End section ------------
#endif // OOMPH_HAS_MPI
   
   // For further processing the three-dimensional vector has to be
   // reduced to a two-dimensional vector
   unsigned n_vertex=tmp_vector_vertex_node.size();
   
   // Resize the vector for vectices
   vector_vertex_node.resize(n_vertex);
   for(unsigned i=0;i<n_vertex;i++)
    {
     vector_vertex_node[i].resize(2);
     vector_vertex_node[i][0]=tmp_vector_vertex_node[i][1];
     vector_vertex_node[i][1]=tmp_vector_vertex_node[i][2];
    }
   
#ifdef OOMPH_HAS_MPI
   // --------- Stuff for the sub_boundaries ----- Begin section ----------
   // Verify if need to deal with sub_boundaries
   if (this->is_mesh_distributed() && nsub_boundaries > 1)
    {
     // For further processing the three-dimensional vector
     // has to be reduced to a two-dimensional vector
     // Resize the vector to store the info. of sub-boundaries
     sub_vector_vertex_node.resize(nsub_boundaries);
     for (unsigned isub = 0; isub < nsub_boundaries; isub++)
      {
       const unsigned subn_vertex = 
        sub_tmp_vector_vertex_node[isub].size();
       // Resize the vector for vectices
       sub_vector_vertex_node[isub].resize(subn_vertex);
       for(unsigned i=0;i<subn_vertex;i++)
        {
         sub_vector_vertex_node[isub][i].resize(2);
         sub_vector_vertex_node[isub][i][0]=
          sub_tmp_vector_vertex_node[isub][i][1];
         sub_vector_vertex_node[isub][i][1]=
          sub_tmp_vector_vertex_node[isub][i][2];
        }
      }
    } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
   
   // We already have the info. for the sub-boundaries (if necessary)
   // and then we can create the sub-boundaries representations to
   // ease the generation of the mesh by Triangle
   
   // --------- Stuff for the sub_boundaries ----- End section ------------
 #endif // OOMPH_HAS_MPI
   
   // --------------------------------------------------------------------
   // Check for contiguousness
   // --------------------------------------------------------------------
#ifdef OOMPH_HAS_MPI
   // Only perform this checking if the mesh is not distributed. When
   // the mesh is distributed the polylines continuity is addressed
   // by the sort_polylines_helper() method
   if (!this->is_mesh_distributed())
#endif
    {
     if ( p > 0 )
      {
       //Final end point of previous line
       Vector<double> final_vertex_of_previous_segment;
       unsigned n_prev_vertex =
        polygon_pt->curve_section_pt(p-1)->nvertex();
       final_vertex_of_previous_segment =
        polygon_pt->polyline_pt(p-1)->
        vertex_coordinate(n_prev_vertex-1);

       unsigned prev_seg_boundary_id =
        polygon_pt->curve_section_pt(p-1)->boundary_id();

       //Find the error between the final vertex of the previous
       //line and the first vertex of the current line
       double error = 0.0;
       for(unsigned i=0;i<2;i++)
        {
         const double dist =
          final_vertex_of_previous_segment[i] -
          (*vector_vertex_node.begin())[i];
         error += dist*dist;
        }
       error = sqrt(error);

       //If the error is bigger than the tolerance then
       //we probably need to reverse, but better check
       if(error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
        {
         //Find the error between the final vertex of the previous
         //line and the last vertex of the current line
         double rev_error = 0.0;
         for(unsigned i=0;i<2;i++)
          {
           const double dist =
            final_vertex_of_previous_segment[i] -
            (*--vector_vertex_node.end())[i];
           rev_error += dist*dist;
          }
         rev_error = sqrt(rev_error);

         if(rev_error >
            ToleranceForVertexMismatchInPolygons::Tolerable_error)
          {
           // It could be possible that the first segment be reversed
           // and we did not notice it because this check does not
           // apply for the first segment. We can verify if the first
           // segment is reversed by using the vertex number 1
           if (p == 1)
            {
             //Initial end point of previous line
             Vector<double> initial_vertex_of_previous_segment;

             initial_vertex_of_previous_segment =
              polygon_pt->polyline_pt(p-1)->
              vertex_coordinate(0);

             unsigned prev_seg_boundary_id =
              polygon_pt->curve_section_pt(p-1)->boundary_id();

             //Find the error between the initial vertex of the previous
             //line and the first vertex of the current line
             double error = 0.0;
             for(unsigned i=0;i<2;i++)
              {
               const double dist =
                initial_vertex_of_previous_segment[i] -
                (*vector_vertex_node.begin())[i];
               error += dist*dist;
              }
             error = sqrt(error); // Reversed only the previous one

             //If the error is bigger than the tolerance then
             //we probably need to reverse, but better check
             if(error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
              {
               //Find the error between the final vertex of the previous
               //line and the last vertex of the current line
               double rev_error = 0.0;
               for(unsigned i=0;i<2;i++)
                {
                 const double dist =
                  initial_vertex_of_previous_segment[i] -
                  (*--vector_vertex_node.end())[i];
                 rev_error += dist*dist;
                }
               rev_error = sqrt(rev_error); // Reversed both the current one and
               // the previous one

               if (rev_error >
                   ToleranceForVertexMismatchInPolygons::Tolerable_error)
                {
                 std::ostringstream error_stream;
                 error_stream
                  <<"The distance between the first node of the current\n"
                  <<"line segment (boundary "<<bound<<") and either end of "
                  << "the previous line segment\n"
                  << "(boundary "<<prev_seg_boundary_id<<") is bigger than "
                  << "the desired tolerance " 
                  << ToleranceForVertexMismatchInPolygons::Tolerable_error
                  << ".\n"
                  << "This suggests that the polylines defining the "
                  << "polygonal\n"
                  << "representation are not properly ordered.\n"
                  << "Fail on last vertex of polyline: ("
                  << prev_seg_boundary_id << ") and\n"
                  << "first vertex of polyline (" << bound << ").\n"
                  << "This should have failed when first trying to "
                  << "construct the\npolygon.\n";
                 throw OomphLibError(error_stream.str(),
                                     OOMPH_CURRENT_FUNCTION,
                                     OOMPH_EXCEPTION_LOCATION);
                }
               else
                {
                 // Reverse both
                 // Reverse the current vector to line up with the
                 // previous one
                 std::reverse(vector_vertex_node.begin(),
                              vector_vertex_node.end());
                 
                 polygon_pt->polyline_pt(p-1)->reverse();
                }
              }
             else
              {
               // Reverse the previous one
               polygon_pt->polyline_pt(p-1)->reverse();
              }
             
            } // if p == 1
           else
            {
             std::ostringstream error_stream;
             error_stream
              <<"The distance between the first node of the current\n"
              <<"line segment (boundary " << bound << ") and either end of "
              <<"the previous line segment\n"
              <<"(boundary "<<prev_seg_boundary_id<<") is bigger than the "
              <<"desired tolerance " <<
              ToleranceForVertexMismatchInPolygons::Tolerable_error << ".\n"
              <<"This suggests that the polylines defining the polygonal\n"
              <<"representation are not properly ordered.\n"
              << "Fail on last vertex of polyline: ("<<prev_seg_boundary_id
              << ") and\nfirst vertex of polyline ("<<bound << ").\n"
              << "This should have failed when first trying to construct"
              << " the polygon.\n";
             throw OomphLibError(error_stream.str(),
                                 OOMPH_CURRENT_FUNCTION,
                                 OOMPH_EXCEPTION_LOCATION);
            }
          }
         else
          {
           //Reverse the current vector to line up with the previous one
           std::reverse(vector_vertex_node.begin(),vector_vertex_node.end());
          }
        } // error
       
      } // if ( p > 0 )
     
    } // if (!this->is_mesh_distributed())
   
   // --------------------------------------------------------------------
   // Update the polylines representation
   // --------------------------------------------------------------------
   
   // Always update the polylines representation, in a distributed
   // mesh it is necessary to update the polyline representation since
   // it may no longer have vertices (the boundary may not be part of
   // the domain in the current processor)
   
   // The new nunber of vertices
   n_vertex = vector_vertex_node.size();
   
   // Now update the polyline according to the new vertices
   TriangleMeshPolyLine *tmp_polyline_pt =
    new TriangleMeshPolyLine(vector_vertex_node,bound);
   
   // Create a temporal "curve section" version of the recently
   // created polyline
   TriangleMeshCurveSection *tmp_curve_section_pt = tmp_polyline_pt;
   
   // Tolerance below which the middle point can be deleted (ratio of
   // deflection to element length)
   double unrefinement_tolerance=
    polygon_pt->polyline_pt(p)->unrefinement_tolerance();
   
   // Tolerance to add points
   double refinement_tolerance=
    polygon_pt->polyline_pt(p)->refinement_tolerance();
   
   // Establish refinement and unrefinement tolerance
   tmp_polyline_pt->set_unrefinement_tolerance(unrefinement_tolerance);
   tmp_polyline_pt->set_refinement_tolerance(refinement_tolerance);
   
   // Establish the maximum length constraint
   double maximum_length = polygon_pt->polyline_pt(p)->maximum_length();
   tmp_polyline_pt->set_maximum_length(maximum_length);
   
#ifdef OOMPH_HAS_MPI
   // If the mesh is distributed check that the polyline still has
   // vertices
   if (this->is_mesh_distributed())
    {
     if (n_vertex >= 2)
      {
       // Pass the connection information from the old polyline to the
       // new one
       this->copy_connection_information(polygon_pt->polyline_pt(p), 
                                         tmp_curve_section_pt);
      } // if (n_vertex >= 2)
    } // if (this->is_mesh_distributed())
   else
#endif
    {
     // Pass the connection information from the old polyline to the
     // new one
     this->copy_connection_information(polygon_pt->polyline_pt(p), 
                                       tmp_curve_section_pt);
    }
   
   // Now update the polyline according to the new vertices but first
   // check if the object is allowed to delete the representation or
   // if it should be done by other object
   bool delete_it_on_destructor = false;
   
   std::set<TriangleMeshCurveSection*>::iterator it =
    this->Free_curve_section_pt.find(polygon_pt->curve_section_pt(p));
   
   if (it!=this->Free_curve_section_pt.end())
    {
     this->Free_curve_section_pt.erase(it);
     delete polygon_pt->curve_section_pt(p);
     delete_it_on_destructor = true;
    }
   
   // -------------------------------------------------------
   // Copying the new representation
   polygon_pt->curve_section_pt(p) = tmp_polyline_pt;
   
   // Update the Boundary - Polyline map
   this->Boundary_curve_section_pt[bound] = polygon_pt->curve_section_pt(p);
   
   if (delete_it_on_destructor)
    {
     this->Free_curve_section_pt.insert(polygon_pt->curve_section_pt(p));
    }
   
#ifdef OOMPH_HAS_MPI
   // --------- Stuff for the sub_boundaries ----- Begin section --------
   // Verify if need to deal with sub_boundaries
   if (this->is_mesh_distributed() && nsub_boundaries > 1)
    {
     // Create temporary representations for the boundaries, only to
     // create the mesh when calling Triangle
     
     // Clear all previous stored data
     this->Boundary_subpolylines[bound].clear();
     
     // Create storage for the sub-boundaries
     this->Boundary_subpolylines[bound].resize(nsub_boundaries);
     for (unsigned isub = 0; isub < nsub_boundaries; isub++)
      {
       // Update the polyline according to the sub set of vertices,
       TriangleMeshPolyLine *sub_tmp_polyline_pt =
        new TriangleMeshPolyLine(sub_vector_vertex_node[isub], bound, isub);
       
       // Add the sub-polyline to the container to represent the
       // boundary in parts
       this->Boundary_subpolylines[bound][isub] = sub_tmp_polyline_pt;
       
       // No need to send the unrefinement/refinement and maximum
       // length constraints since these are only temporary
       // representations. These polylines can be deleted once the new
       // polygons that represent the distributed domain have been
       // created
       
      } // for (isub < nsub_boundaries)
     
    } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
   // --------- Stuff for the sub_boundaries ----- End section ---------
 #endif // OOMPH_HAS_MPI
   
   // Delete the allocated memory for the geometric object that
   // represents the boundary
   delete mesh_geom_obj_pt;
   
  } // for (p < n_polyline)
 
 // Cleanup the face mesh
 for(unsigned p=0;p<n_polyline;p++)
  {
   face_mesh_pt[p]->flush_node_storage();
   delete face_mesh_pt[p];
  }
 
 return update_was_performed;
 
}

//======================================================================
/// \short Updates the open curve but using the elements area instead
/// of the default refinement and unrefinement methods
//======================================================================
template <class ELEMENT>
bool RefineableTriangleMesh<ELEMENT>::
update_open_curve_using_elements_area(TriangleMeshOpenCurve* &open_curve_pt,
                                      const Vector<double> &target_area)
{
 // Verify if there was a change on the open curve representation
 unsigned update_was_performed = false;
 
 const unsigned nele = this->nelement();
 
 // - Get the vertices along the boundaries and for each element identify
 //   its associated target error.
 //   - Get face mesh representation of each polyline.
 //   - Get the vertices with the help of face elements.
 //   - Find the global index in the mesh of the face element
 //     and use it to get its associated target area.
 
 // Get the face mesh representation
 Vector<Mesh*> face_mesh_pt;
 get_face_mesh_representation(open_curve_pt,face_mesh_pt);
 
 // Create vertices of the polylines by using the vertices of the
 // FaceElements
 Vector<double> vertex_coord(3); // zeta,x,y
 Vector<double> bound_left(1);
 Vector<double> bound_right(1);
 
 const unsigned ncurve_section = open_curve_pt->ncurve_section();
 
 // Go for each curve section
 for(unsigned cs = 0; cs < ncurve_section; cs++)
  {
   // Get the MeshAsGeomObject representation just once per polyline,
   // this object is only used by the
   // refine_boundary_constrained_by_target_area() method. We get it
   // here to ensure that all processors (in a distributed context)
   // get this representation just once, and because an AllToAll MPI
   // communication is used in this calling
   MeshAsGeomObject* mesh_geom_obj_pt=new MeshAsGeomObject(face_mesh_pt[cs]);
   
   //Get the boundary id
   const unsigned bound = 
    open_curve_pt->curve_section_pt(cs)->boundary_id();
   
   // Get the chunk number
   const unsigned chunk = 
    open_curve_pt->curve_section_pt(cs)->boundary_chunk();
   
   /// Use a vector of vector for vertices and target areas to deal
   /// with the cases when the boundaries are split by the
   /// distribution process. Internal boundaries may be completely or
   /// partially overlapped by shared boundaries
   
   // Loop over the face elements and add their vertices (they are
   // automatically sorted because of the set)
   const unsigned nface_element = face_mesh_pt[cs]->nelement();
   
   // Store the non halo elements and the element at the other side of
   // the boundary (whatever it be halo or not), the first will be the
   // ones from which we will get the vertices (in even position)
   Vector<FiniteElement*> non_halo_doubled_face_element_pt;
   
   // Map to store the index of the face element on a boundary
   std::map<FiniteElement*,unsigned> face_element_index_on_boundary;
   
   // Map to know the already sorted face elements
   std::map<FiniteElement*,bool> face_element_done;
   
   for(unsigned ef = 0; ef < nface_element; ++ef)
    {
     FiniteElement* ele_face_pt = face_mesh_pt[cs]->finite_element_pt(ef);
     
     // Skip the halo elements (not used as base elements, only
     // include those elements whose element at the other side of the
     // boundary is non halo)
#ifdef OOMPH_HAS_MPI
     if (this->is_mesh_distributed())
      {
       // Only work with non-halo elements
       if (ele_face_pt->is_halo()) {continue;}
      }
#endif
     
     // Check if not already done
     if (!face_element_done[ele_face_pt])
      {
       // Add the element and look for the element at the other side
       // of the boundary to add it immediately after the new added
       // element
       non_halo_doubled_face_element_pt.push_back(ele_face_pt);
       // Create the map of the face element with the index
       face_element_index_on_boundary[ele_face_pt] = ef;
       // Mark the current element as done
       face_element_done[ele_face_pt] = true;
       // Get the number of nodes
       const unsigned nnodes = ele_face_pt->nnode();
       // Get the left and right node to look for the elements at the
       // other side of the boundary
       Node* left_node_pt = ele_face_pt->node_pt(0);
       Node* right_node_pt = ele_face_pt->node_pt(nnodes-1);
#ifdef PARANOID
       // Flag to know if the element at the other side of the
       // boundary was found
       bool found_other_side_face_ele = false;
#endif
       for (unsigned iface = 0; iface < nface_element; iface++)
        {
         // Get the candidate face element
         FiniteElement *cele_face_pt = 
          face_mesh_pt[cs]->finite_element_pt(iface);
         // Check if not already done
         if (!face_element_done[cele_face_pt])
          {
           Node* cleft_node_pt = cele_face_pt->node_pt(0);
           Node* cright_node_pt = cele_face_pt->node_pt(nnodes-1);
           // Check if the nodes are the same
           if ((left_node_pt == cleft_node_pt && 
                right_node_pt == cright_node_pt) ||
               (left_node_pt == cright_node_pt && 
                right_node_pt == cleft_node_pt))
            {
             // Add the element to the storage
             non_halo_doubled_face_element_pt.push_back(cele_face_pt);
             // ... and mark the element as done
             face_element_done[cele_face_pt] = true;
             // Create the map of the face element with the index
             face_element_index_on_boundary[cele_face_pt] = iface;
#ifdef PARANOID
             // Set the flag of found other side face element
             found_other_side_face_ele = true;
#endif
             break;
            }
          }
        } // (iface < nface_element)
       
#ifdef PARANOID
       if (!found_other_side_face_ele)
        {
         std::ostringstream error_message;
         error_message
          << "The face element at the other side of the boundary ("
          << bound << ") was not found!!\n"
          << "These are the nodes of the face element:\n"
          << "("<<left_node_pt->x(0)<<", "<<left_node_pt->x(1)<<") "
          << "and ("<<right_node_pt->x(0)<<","<<right_node_pt->x(1)<<")\n\n";
         throw OomphLibError(error_message.str(),
          "RefineableTriangleMesh::update_open_curve_using_elements_area()",
                             OOMPH_EXCEPTION_LOCATION);
        }
#endif
      } // if (!face_ele_done[ele_face_pt])
     
    } // (ef < nface_element)
   
   // Clear the map of the already done face elements
   // This will be used to help sorting the face elements
   face_element_done.clear();

   // Set of coordinates that are on the boundary
   // The entries are sorted on first entry in vector which stores
   // the boundary coordinate so the vertices come out in order!
   std::set<Vector<double> > vertex_nodes;

   // Vector to store the vertices, transfer the sorted vertices from the
   // set to this vector, --- including the z-value ---
   Vector<Vector<double> > tmp_vector_vertex_node;

   // Vector to store the coordinates of the polylines, same as the
   // tmp_vector_vertex_node vector (after adding more nodes) but
   // --- without the z-value ---, used to re-generate the polylines
   Vector<Vector<double> > vector_vertex_node;

#ifdef OOMPH_HAS_MPI
   // Indicates if the set of vertices give rise to a internal
   // boundary that will be used as shared boundary or as normal
   // internal boundary -- Only used to deal with internal boundaries
   // in a distributed scheme
   std::vector<bool> internal_to_shared_boundary;

   // --------- Stuff to deal with splitted boundaries ---------- Begin -----
   // Set of coordinates that are on the boundary (splitted boundary version)
   // The first vector is used to allocate the points for each sub-boundary
   // Set entries are ordered on first entry in vector which stores
   // the boundary coordinate so the vertices come out in order!
   Vector<std::set<Vector<double> > > sub_vertex_nodes;

   // Vector to store the vertices, transfer the sorted vertices from the
   // set (sub_vertex_nodes) to this vector, --- including the z-value ---
   Vector<Vector<Vector<double> > > sub_tmp_vector_vertex_node;

   // Vector to store the coordinates of the polylines that will represent
   // the splitted boundary. Used to pass the info. from sub_vertex_nodes
   // but --- without the z-value ---, used to generate the sub-polylines
   Vector<Vector<Vector<double> > > sub_vector_vertex_node;

   // --------- Stuff to deal with splitted boundaries ----------- End ------
   
#endif // #ifdef OOMPH_HAS_MPI

   // Sort the face element, those that have both elements (one at
   // each side of the boundary) marked as nonhalo, and those with one
   // nonhalo an the other as halo
   
   // Number of done face elements
   unsigned nsorted_face_elements = 0;

#ifdef OOMPH_HAS_MPI
   // Counter for sub_boundaries
   unsigned nsub_boundaries = 0;
#endif // #ifdef OOMPH_HAS_MPI

   // Total number of non halo double face element
   const unsigned nnon_halo_doubled_face_ele = 
    non_halo_doubled_face_element_pt.size();

   // Continue until all the face elements have been sorted
   // This while is to deal with the cases of splitted boundaries
   while(nsorted_face_elements < nnon_halo_doubled_face_ele)
    {
     // Get and initial face element
     FiniteElement* ele_face_pt = 0;
     FiniteElement* repeated_ele_face_pt = 0;
#ifdef PARANOID
     bool found_initial_face_element = false;
#endif

     // Flag to know if we are working with a face element which the
     // face element at the other side of the boundary is also non
     // halo
     bool both_root_face_elements_are_nonhalo = false;
     
     unsigned iface = 0;
     for (iface = 0; iface < nnon_halo_doubled_face_ele; iface+=2)
      {
       ele_face_pt = non_halo_doubled_face_element_pt[iface];
       // If not done then take it as initial face element
       if (!face_element_done[ele_face_pt])
        {
         // Mark it as done
         face_element_done[ele_face_pt] = true;
         // Get the other side boundary face element
         repeated_ele_face_pt = non_halo_doubled_face_element_pt[iface+1];
         // ... also mark as done the repeated face element
         face_element_done[repeated_ele_face_pt] = true;
         
#ifdef OOMPH_HAS_MPI
         if (!repeated_ele_face_pt->is_halo())
          {both_root_face_elements_are_nonhalo = true;}
#endif // #ifdef OOMPH_HAS_MPI
         
         // Plus two because internal boundaries have
         // two face elements per each edge
         nsorted_face_elements+=2;
         iface+=2;
#ifdef PARANOID
         // And set the flag to true
         found_initial_face_element = true;
#endif
         break;
        }
      }
     
#ifdef PARANOID
     if (!found_initial_face_element)
      {
       std::ostringstream error_message;
       error_message
        <<"Could not find an initial face element for the current segment\n";
       throw OomphLibError(error_message.str(),
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
      }
#endif

     // Local set of coordinates that are on the boundary Set entries
     // are ordered on first entry in vector which stores the boundary
     // coordinate so the vertices come out in order
     std::set<Vector<double> > local_vertex_nodes;
     
     // Vector to store the vertices, transfer the sorted vertices from the
     // set (local) to this vector (local), --- including the z-value ---
     Vector<Vector<double> > local_tmp_vector_vertex_node;

     // Vector to store the target areas, uses the same approach as the
     // set for the local_vertex_nodes, ordered on first entry
     std::set<Vector<double> > sorted_target_areas;
     
     // Vector to store the target areas, used to transfer the sorted target
     // areas from "sorted_target_areas" set
     Vector<double> tmp_sorted_target_areas;

     // ------------------------------------------------------------------
     // Add the vertices of the initial face element to the set of local 
     // sorted vertices
     // ------------------------------------------------------------------
     const unsigned nnode = ele_face_pt->nnode();
     // Add the left-hand node to the set:
     // Boundary coordinate
     ele_face_pt->node_pt(0)->get_coordinates_on_boundary(bound,bound_left);
     vertex_coord[0] = bound_left[0];
     
     // Actual coordinates
     for(unsigned i=0;i<2;i++)
      {
       vertex_coord[i+1] = ele_face_pt->node_pt(0)->x(i);
      }
     local_vertex_nodes.insert(vertex_coord);
     
     // Add the right-hand node to the set:
     // Boundary coordinate
     ele_face_pt->node_pt(nnode-1)->get_coordinates_on_boundary(bound,
                                                                bound_right);
     vertex_coord[0] = bound_right[0];
     
     // Actual coordinates
     for(unsigned i=0;i<2;i++)
      {
       vertex_coord[i+1] = ele_face_pt->node_pt(nnode-1)->x(i);
      }
     local_vertex_nodes.insert(vertex_coord);
     
     // The initial and final node on the set
     Node *first_node_pt = ele_face_pt->node_pt(0);
     Node *last_node_pt = ele_face_pt->node_pt(nnode-1);
     
     // -----------------------------------------------------
     // Find the global index in the mesh of the face element
     // and use it to get its associated target area
     // -----------------------------------------------------
     // Container to store the zeta value (used as index) and
     // the associated target area of the element
     Vector<double> zeta_target_area_values(2);
     
     // Use the minimum zeta value to sort the target areas
     // along the boundary
     zeta_target_area_values[0] = std::min(bound_left[0], bound_right[0]);
     
     // Get the index of the face element on the current boundary
     const unsigned ef = face_element_index_on_boundary[ele_face_pt];
     // Get the "ef"-th element on the boundary
     FiniteElement *el_pt = this->boundary_element_pt(bound, ef);
     double target_area_face_element = 0.0;
             
#ifdef PARANOID
     bool found_global_element_index = false;
#endif
     for (unsigned eg = 0 ; eg < nele; eg++)
      {
       // Get the "eg-th" element
       FiniteElement *el_compare_pt = this->finite_element_pt(eg);
       
       // Compare with the element on the boundary, if equal then
       // store the target area
       if (el_pt == el_compare_pt)
        {
         target_area_face_element = target_area[eg];
#ifdef PARANOID
         found_global_element_index = true;
#endif
         break; // break the for (eg < nele) global element
        } // if el_pt == el_compare_pt
      } // for nele (on complete mesh)
     
#ifdef PARANOID
     if (!found_global_element_index)
      {
       std::ostringstream error_message;
       error_message
        << "The global index for the ("<< ef <<")-th face element "
        << "on\nthe ("<< bound <<")-th boundary was not found!!!";
       throw OomphLibError(error_message.str(),
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
      }
#endif
     
     // Get the index of the repeated face element on the current boundary
     const unsigned ref = face_element_index_on_boundary[repeated_ele_face_pt];
     FiniteElement *rel_pt = this->boundary_element_pt(bound, ref);
     double target_area_repeated_face_element = 0.0;
     
#ifdef PARANOID
     bool found_global_repeated_element_index = false;
#endif
     for (unsigned eg = 0 ; eg < nele; eg++)
      {
       // Get the "eg-th" element
       FiniteElement *el_compare_pt = this->finite_element_pt(eg);
       
       // Compare with the element on the boundary, if equal then
       // store the target area
       if (rel_pt == el_compare_pt)
        {
         target_area_repeated_face_element = target_area[eg];
#ifdef PARANOID
         found_global_repeated_element_index = true;
#endif
         break; // break the for (eg < nele) global element
        } // if rel_pt == el_compare_pt
      } // for nele (on complete mesh)
     
#ifdef PARANOID
     if (!found_global_repeated_element_index)
      {
       std::ostringstream error_message;
       error_message
        << "The global index for the ("<< ref <<")-th face element "
        << "on\nthe ("<< bound <<")-th boundary was not found (repeated "
        << "face element)!!!";
       throw OomphLibError(error_message.str(),
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
      }
#endif
     
     // Choose the minimum target area from both elements, one at each side
     // of the edge on the boundary
     zeta_target_area_values[1]=std::min(target_area_face_element,
                                         target_area_repeated_face_element);

     // Add the target areas to the sorted set
     sorted_target_areas.insert(zeta_target_area_values);
     // ------------------------------------------------------------------

     // Continue iterating if a new face element has been added to the
     // list
     bool face_element_added = false;

     // While a new face element has been added to the set of sorted
     // face elements then re-iterate
     do
      {
       // Start from the next face elements since we have already
       // added the previous one as the initial face element (any
       // previous face element had to be added on previous
       // iterations)
       for (unsigned iiface=iface;
            iiface<nnon_halo_doubled_face_ele;iiface+=2)
        {
         face_element_added = false;
         ele_face_pt = non_halo_doubled_face_element_pt[iiface];
         
         // Check that the face element with which we are working has
         // the same conditions as the root face element (both faces
         // are nonhalo or one face is halo and the other nonhalo)
         
         // Get the face element at the other side of the boundary
         repeated_ele_face_pt = non_halo_doubled_face_element_pt[iiface+1];
         bool both_face_elements_are_nonhalo = false;
         
#ifdef OOMPH_HAS_MPI
         if (!repeated_ele_face_pt->is_halo())
          {both_face_elements_are_nonhalo = true;}
#endif // #ifdef OOMPH_HAS_MPI
         
         if (!face_element_done[ele_face_pt] && 
             (both_face_elements_are_nonhalo == 
              both_root_face_elements_are_nonhalo))
          {
           // Get each individual node to check if they are contiguous
           const unsigned nlnode = ele_face_pt->nnode();
           Node* left_node_pt = ele_face_pt->node_pt(0);
           Node* right_node_pt = ele_face_pt->node_pt(nlnode-1);
                 
           if (left_node_pt == first_node_pt)
            {
             first_node_pt = right_node_pt;
             face_element_added = true;
            }
           else if (left_node_pt == last_node_pt)
            {
             last_node_pt = right_node_pt;
             face_element_added = true;
            }
           else if (right_node_pt == first_node_pt)
            {
             first_node_pt = left_node_pt;
             face_element_added = true;
            }
           else if (right_node_pt == last_node_pt)
            {
             last_node_pt = left_node_pt;
             face_element_added = true;
            }
           
           if (face_element_added)
            {
             // Add the left-hand node to the set:
             // Boundary coordinate
             left_node_pt->get_coordinates_on_boundary(bound,bound_left);
             vertex_coord[0] = bound_left[0];

             // Actual coordinates
             for(unsigned i=0;i<2;i++)
              {
               vertex_coord[i+1] = left_node_pt->x(i);
              }
             local_vertex_nodes.insert(vertex_coord);

             // Add the right-hand nodes to the set:
             // Boundary coordinate
             right_node_pt->get_coordinates_on_boundary(bound,bound_right);
             vertex_coord[0] = bound_right[0];

             // Actual coordinates
             for(unsigned i=0;i<2;i++)
              {
               vertex_coord[i+1] = right_node_pt->x(i);
              }
             local_vertex_nodes.insert(vertex_coord);
             
             // Mark as done only if one of its nodes has been
             // added to the list
             face_element_done[ele_face_pt] = true;
             // .. also mark as done the face element at the othe side of
             // the boundary
             repeated_ele_face_pt = non_halo_doubled_face_element_pt[iiface+1];
             face_element_done[repeated_ele_face_pt] = true;
             // ... and increase the number of sorted face elements
             nsorted_face_elements+=2;
             
             // -----------------------------------------------------
             // Find the global index in the mesh of the face element
             // and use it to get its associated target area
             // -----------------------------------------------------
             // Use the minimum zeta value to sort the target areas
             // along the boundary
             zeta_target_area_values[0] = 
              std::min(bound_left[0], bound_right[0]);
             
             // Get the "ef"-th element on the boundary
             const unsigned lef = face_element_index_on_boundary[ele_face_pt];
             FiniteElement *lel_pt = this->boundary_element_pt(bound, lef);
             
#ifdef PARANOID
             found_global_element_index = false;
#endif
             for (unsigned eg = 0 ; eg < nele; eg++)
              {
               // Get the "eg-th" element
               FiniteElement *lel_compare_pt = this->finite_element_pt(eg);
         
               // Compare with the element on the boundary, if equal then
               // store the target area
               if (lel_pt == lel_compare_pt)
                {
                 target_area_face_element  = target_area[eg];
#ifdef PARANOID
                 found_global_element_index = true;
#endif
                 break; // break the for (eg < nele) global element
                } // if lel_pt == lel_compare_pt
              } // for nele (on complete mesh)
       
#ifdef PARANOID
             if (!found_global_element_index)
              {
               std::ostringstream error_message;
               error_message
                << "The global index for the ("<< lef <<")-th face element "
                << "on\nthe ("<< bound <<")-th boundary was not found!!!";
               throw OomphLibError(error_message.str(),
                                   OOMPH_CURRENT_FUNCTION,
                                   OOMPH_EXCEPTION_LOCATION);
              }
#endif
             
             // Get the index of the repeated face element on the boundary
             const unsigned rlef = 
              face_element_index_on_boundary[repeated_ele_face_pt];
             FiniteElement *rlel_pt = this->boundary_element_pt(bound, rlef);
             
#ifdef PARANOID
             found_global_repeated_element_index = false;
#endif
             for (unsigned eg = 0 ; eg < nele; eg++)
              {
               // Get the "eg-th" element
               FiniteElement *lel_compare_pt = this->finite_element_pt(eg);
       
               // Compare with the element on the boundary, if equal then
               // store the target area
               if (rlel_pt == lel_compare_pt)
                {
                 target_area_repeated_face_element = target_area[eg];
#ifdef PARANOID
                 found_global_repeated_element_index = true;
#endif
                 break; // break the for (eg < nele) global element
                } // if rlel_pt == el_compare_pt
              } // for nele (on complete mesh)
     
#ifdef PARANOID
             if (!found_global_repeated_element_index)
              {
               std::ostringstream error_message;
               error_message
                << "The global index for the ("<< rlef <<")-th face element "
                << "on\nthe ("<< bound <<")-th boundary was not found "
                << "(repeated face element)!!!";
               throw OomphLibError(error_message.str(),
                                   OOMPH_CURRENT_FUNCTION,
                                   OOMPH_EXCEPTION_LOCATION);
              }
#endif
     
             // Choose the minimum target area from both elements, one
             // at each side of the edge on the boundary
             zeta_target_area_values[1] = 
              std::min(target_area_face_element,
                       target_area_repeated_face_element);

             // Add the target areas to the sorted set
             sorted_target_areas.insert(zeta_target_area_values);

             break;
            }
           
          } // if (!face_element_done[[ele_face_pt])
        } // for (iiface<nnon_halo_doubled_face_ele)
      }while(face_element_added &&
             (nsorted_face_elements < nnon_halo_doubled_face_ele));
     
     // -------------------------------------------------------------
     // At this point we already have a sorted set of nodes and can
     // be used to peform the unrefinement and refinement procedures
     // -------------------------------------------------------------
     
     // Get the number of nodes on the list
     const unsigned nlocal_nodes = local_vertex_nodes.size();
     // Change representation to vector for easy of handling ...
     local_tmp_vector_vertex_node.resize(nlocal_nodes);
         
     // Copy the vertices of the nodes
     unsigned counter = 0;
     std::set<Vector<double> >::iterator it_vertex;
     for (it_vertex = local_vertex_nodes.begin();
          it_vertex != local_vertex_nodes.end();
          it_vertex++)
      {
       local_tmp_vector_vertex_node[counter].resize(3);
       local_tmp_vector_vertex_node[counter][0] = (*it_vertex)[0];
       local_tmp_vector_vertex_node[counter][1] = (*it_vertex)[1];
       local_tmp_vector_vertex_node[counter][2] = (*it_vertex)[2];
       counter++;
      }

     // ... same for the info. related with the target areas (turn
     // into vector)
     const unsigned ntarget_areas = sorted_target_areas.size();
     tmp_sorted_target_areas.resize(ntarget_areas);
     counter = 0;
     std::set<Vector<double> >::iterator it_area;
     for(it_area = sorted_target_areas.begin();
         it_area != sorted_target_areas.end();
         ++it_area)
      {
       tmp_sorted_target_areas[counter] = (*it_area)[1];
       ++counter;
      }

#ifdef PARANOID
     if (nlocal_nodes > 0 && (ntarget_areas != nlocal_nodes - 1) )
      {
       std::ostringstream error_message;
       error_message
        << "The boundary (" << bound << ") was split during the "
        << "distribution process.\n"
        << "The problem comes when associating the target areas with the "
        << "elements that gave\nrise to the vertex coordinates.\n"
        << "The number of local nodes on the 'sub-polyline' ("
        << nlocal_nodes << ") is not according with the number of target\n"
        << "areas ("<< ntarget_areas << ") for that number of nodes.\n"
        << "The target areas number must be equal to the number of nodes-1\n";
       throw OomphLibError(error_message.str(),
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
      }
#endif

     // The unrefinement and refinement process needs to be applied
     // from the bottom-left node since the internal open curve could
     // lie on the shared boundaries
     if (local_tmp_vector_vertex_node[nlocal_nodes-1][2] < 
         local_tmp_vector_vertex_node[0][2])
      {
       std::reverse(local_tmp_vector_vertex_node.begin(),
                    local_tmp_vector_vertex_node.end());
       std::reverse(tmp_sorted_target_areas.begin(),
                    tmp_sorted_target_areas.end());
      }
     else if (local_tmp_vector_vertex_node[nlocal_nodes-1][2] == 
              local_tmp_vector_vertex_node[0][2])
      {
       if (local_tmp_vector_vertex_node[nlocal_nodes-1][1] < 
           local_tmp_vector_vertex_node[0][1])
        {
         std::reverse(local_tmp_vector_vertex_node.begin(),
                      local_tmp_vector_vertex_node.end());
         std::reverse(tmp_sorted_target_areas.begin(),
                      tmp_sorted_target_areas.end());
        }
      }
     
     // ------------------------------------------------------------
     // Create the vertices along the boundary using the target
     // area to define the distance among them
     // ------------------------------------------------------------
     
     // Tolerance below which the middle point can be deleted
     // (ratio of deflection to element length)
     double unrefinement_tolerance=
      open_curve_pt->polyline_pt(cs)->unrefinement_tolerance();
     
     // Apply unrefinement
     bool unrefinement_applied =
      unrefine_boundary_constrained_by_target_area(
       bound, chunk, local_tmp_vector_vertex_node,
       unrefinement_tolerance, tmp_sorted_target_areas);
     
     // Tolerance for refinement
     double refinement_tolerance=
      open_curve_pt->polyline_pt(cs)->refinement_tolerance();
     
     // Apply refinement
     bool refinement_applied = 
      refine_boundary_constrained_by_target_area(
       mesh_geom_obj_pt, local_tmp_vector_vertex_node,
       refinement_tolerance, tmp_sorted_target_areas);
     
     // Clear the local containter to recover the nodes ordered using
     // the zeta value
     local_vertex_nodes.clear();

     // At the end of each unrefinement/refinement step store the new
     // nodes on the set that will give rise to the vertices of the
     // new polyline representation
     const unsigned nnew_nodes = local_tmp_vector_vertex_node.size();
     for (unsigned i = 0; i < nnew_nodes; i++)
      {
       vertex_coord[0] = local_tmp_vector_vertex_node[i][0];
       vertex_coord[1] = local_tmp_vector_vertex_node[i][1];
       vertex_coord[2] = local_tmp_vector_vertex_node[i][2];
       vertex_nodes.insert(vertex_coord); // Global container
       local_vertex_nodes.insert(vertex_coord);
      }
     
     // Update the flag to indicate whether an unrefinement or
     // refinement was applied
     update_was_performed = (unrefinement_applied || refinement_applied);
     
#ifdef OOMPH_HAS_MPI
     if (this->is_mesh_distributed())
      {
       // Add the set of vertices for the boundary, this will help to
       // detect if we need to deal with sub_boundaries and
       // sub_polylines representations
       sub_vertex_nodes.push_back(local_vertex_nodes);
       // Increase the counter for sub_boundaries
       nsub_boundaries++;
       
       // Mark if the polyline created by these vertices will be used
       // as a shared boundary or as an internal boundary
       if (both_root_face_elements_are_nonhalo)
        {internal_to_shared_boundary.push_back(false);}
       else
        {internal_to_shared_boundary.push_back(true);}
      }
#endif
     
    } // while(nsorted_face_elements < nnon_halo_doubled_face_ele)
      // This while is in charge of sorting all the face elements to
      // create the new representation of the polyline (also deals
      // with the sub-boundary cases)
   
   // Now turn into vector for ease of handling...
   const unsigned npoly_vertex = vertex_nodes.size();
   tmp_vector_vertex_node.resize(npoly_vertex);
   unsigned count = 0;
   for (std::set<Vector<double> >::iterator it = vertex_nodes.begin();
        it!=vertex_nodes.end(); ++it)
    {
     tmp_vector_vertex_node[count].resize(3);
     tmp_vector_vertex_node[count][0] = (*it)[0];
     tmp_vector_vertex_node[count][1] = (*it)[1];
     tmp_vector_vertex_node[count][2] = (*it)[2];
     ++count;
    }
   
#ifdef OOMPH_HAS_MPI
   // Check that the number of set of vertices marked to be part of a
   // shared boundary or of an internal boundaries be the same as the
   // total number of sub-boundaries
#ifdef PARANOID
   const unsigned nsub_boundaries_set = sub_vertex_nodes.size();
   const unsigned ninternal_to_shared_boundaries = 
    internal_to_shared_boundary.size();
   if (nsub_boundaries_set != ninternal_to_shared_boundaries)
    {
     std::ostringstream error_message;
     error_message
      << "The number of found sub-boundaries and the number of marked "
      << "internal\nboundaries are different\n"
      << "Number of found sub-boundaries: ("<<nsub_boundaries_set<<")\n"
      << "Number of marked internal boundaries: ("
      << ninternal_to_shared_boundaries << ")\n\n";
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   
   // --------- Stuff for the sub_boundaries ----- Begin section -------
#ifdef PARANOID
   if (nsub_boundaries_set != nsub_boundaries)
    {
     std::ostringstream error_message;
     error_message
      << "The number of found sub-boundaries and the number of counted\n"
      << "sub-boundaries are different:\n"
      << "Number of found sub-boundaries: ("<<nsub_boundaries_set<<")\n"
      << "Number of counted sub-boundaries: ("<<nsub_boundaries<<")\n\n";
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   
   // Verify if need to deal with sub_boundaries
   if (this->is_mesh_distributed() && nsub_boundaries > 1)
    {
     // Mark the boundary as been splitted in the partition process
     this->Boundary_was_splitted[bound] = true;
     
     // Resize the vector to store the info. of sub-boundaries
     sub_tmp_vector_vertex_node.resize(nsub_boundaries);
     // Loop over the sub-boundaries
     for (unsigned isub = 0; isub < nsub_boundaries; isub++)
      {
       // Turn info. into vector for ease of handling...
       const unsigned nsubpoly_vertex = sub_vertex_nodes[isub].size();
       sub_tmp_vector_vertex_node[isub].resize(nsubpoly_vertex);
       unsigned subcount = 0;
       std::set<Vector<double> >::iterator subit;
       for(subit = sub_vertex_nodes[isub].begin();
           subit != sub_vertex_nodes[isub].end(); ++subit)
        {
         sub_tmp_vector_vertex_node[isub][subcount].resize(3);
         sub_tmp_vector_vertex_node[isub][subcount][0] = (*subit)[0];
         sub_tmp_vector_vertex_node[isub][subcount][1] = (*subit)[1];
         sub_tmp_vector_vertex_node[isub][subcount][2] = (*subit)[2];
         ++subcount;
        }
      }
    } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
   // --------- Stuff for the sub_boundaries ----- End section ----------
#endif // OOMPH_HAS_MPI

   // For further processing the three-dimensional vector has to be
   // reduced to a two-dimensional vector
   unsigned n_vertex=tmp_vector_vertex_node.size();
   
   // Resize the vector for vectices
   vector_vertex_node.resize(n_vertex);
   for(unsigned i=0;i<n_vertex;i++)
    {
     vector_vertex_node[i].resize(2);
     vector_vertex_node[i][0]=tmp_vector_vertex_node[i][1];
     vector_vertex_node[i][1]=tmp_vector_vertex_node[i][2];
    }
   
#ifdef OOMPH_HAS_MPI
   // --------- Stuff for the sub_boundaries ----- Begin section -------
   // Verify if need to deal with sub_boundaries
   if (this->is_mesh_distributed() && nsub_boundaries > 1)
    {
     // For further processing the three-dimensional vector has to be
     // reduced to a two-dimensional vector
     // Resize the vector to store the info. of sub-boundaries
     sub_vector_vertex_node.resize(nsub_boundaries);
     for (unsigned isub = 0; isub < nsub_boundaries; isub++)
      {
       const unsigned subn_vertex = 
        sub_tmp_vector_vertex_node[isub].size();
       // Resize the vector for vectices
       sub_vector_vertex_node[isub].resize(subn_vertex);
       for(unsigned i=0;i<subn_vertex;i++)
        {
         sub_vector_vertex_node[isub][i].resize(2);
         sub_vector_vertex_node[isub][i][0]=
          sub_tmp_vector_vertex_node[isub][i][1];
         sub_vector_vertex_node[isub][i][1]=
          sub_tmp_vector_vertex_node[isub][i][2];
        }
      }
    } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
   
   // We already have the info. for the sub-boundaries (if necessary)
   // and then we can create the sub-boundaries representations to
   // ease the generation of the mesh by Triangle
   
   // --------- Stuff for the sub_boundaries ----- End section ---------
#endif // OOMPH_HAS_MPI
   
   // ------------------------------------------------------------------
   // Check for contiguousness
   // ------------------------------------------------------------------
#ifdef OOMPH_HAS_MPI
   // Only perform this checking if the mesh is not distributed When
   // the mesh is distributed the polylines continuity is addressed by
   // the sort_polylines_helper() method
   if (!this->is_mesh_distributed())
#endif
    {
     if ( cs > 0 )
      {
       //Final end point of previous line
       Vector<double> final_vertex_of_previous_segment;
       unsigned n_prev_vertex =
        open_curve_pt->curve_section_pt(cs-1)->nvertex();
       final_vertex_of_previous_segment =
        open_curve_pt->polyline_pt(cs-1)->
        vertex_coordinate(n_prev_vertex-1);

       unsigned prev_seg_boundary_id =
        open_curve_pt->curve_section_pt(cs-1)->boundary_id();
       
       //Find the error between the final vertex of the previous
       //line and the first vertex of the current line
       double error = 0.0;
       for(unsigned i=0;i<2;i++)
        {
         const double dist =
          final_vertex_of_previous_segment[i] -
          (*vector_vertex_node.begin())[i];
         error += dist*dist;
        }
       error = sqrt(error);
       
       //If the error is bigger than the tolerance then
       //we probably need to reverse, but better check
       if(error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
        {
         //Find the error between the final vertex of the previous
         //line and the last vertex of the current line
         double rev_error = 0.0;
         for(unsigned i=0;i<2;i++)
          {
           const double dist =
            final_vertex_of_previous_segment[i] -
            (*--vector_vertex_node.end())[i];
           rev_error += dist*dist;
          }
         rev_error = sqrt(rev_error);
         
         if(rev_error >
            ToleranceForVertexMismatchInPolygons::Tolerable_error)
          {
           // It could be possible that the first segment be reversed and we
           // did not notice it because this check does not apply for the
           // first segment. We can verify if the first segment is reversed
           // by using the vertex number 1
           if (cs == 1)
            {
             //Initial end point of previous line
             Vector<double> initial_vertex_of_previous_segment;
             
             initial_vertex_of_previous_segment =
              open_curve_pt->polyline_pt(cs-1)->vertex_coordinate(0);
             
             unsigned prev_seg_boundary_id =
              open_curve_pt->curve_section_pt(cs-1)->boundary_id();
             
             //Find the error between the initial vertex of the previous
             //line and the first vertex of the current line
             double error = 0.0;
             for(unsigned i=0;i<2;i++)
              {
               const double dist =
                initial_vertex_of_previous_segment[i] -
                (*vector_vertex_node.begin())[i];
               error += dist*dist;
              }
             error = sqrt(error); // Reversed only the previous one
             
             //If the error is bigger than the tolerance then
             //we probably need to reverse, but better check
             if(error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
              {
               //Find the error between the final vertex of the previous
               //line and the last vertex of the current line
               double rev_error = 0.0;
               for(unsigned i=0;i<2;i++)
                {
                 const double dist =
                  initial_vertex_of_previous_segment[i] -
                  (*--vector_vertex_node.end())[i];
                 rev_error += dist*dist;
                }
               rev_error = sqrt(rev_error); // Reversed both the current 
                                            // one and the previous one
               
               if (rev_error >
                   ToleranceForVertexMismatchInPolygons::Tolerable_error)
                {
                 std::ostringstream error_stream;
                 error_stream
                  <<"The distance between the first node of the current\n"
                  <<"line segment (boundary "<<bound<<") and either end of "
                  <<"the previous line segment\n"
                  <<"(boundary "<<prev_seg_boundary_id<<") is bigger than"
                  << " the desired tolerance " <<
                  ToleranceForVertexMismatchInPolygons::Tolerable_error<<".\n"
                  <<"This suggests that the polylines defining the polygonal\n"
                  <<"representation are not properly ordered.\n"
                  <<"Fail on last vertex of polyline: ("
                  <<prev_seg_boundary_id<<") and\nfirst vertex of polyline ("
                  <<bound<< ").\nThis should have failed when first trying to "
                  <<"construct the\npolygon.\n";
                 throw OomphLibError(error_stream.str(),
                                     OOMPH_CURRENT_FUNCTION,
                                     OOMPH_EXCEPTION_LOCATION);
                }
               else
                {
                 // Reverse both
                 // Reverse the current vector to line up with the previous one
                 std::reverse(vector_vertex_node.begin(),
                              vector_vertex_node.end());
                 open_curve_pt->polyline_pt(cs-1)->reverse();
                }
              }
             else
              {
               // Reverse the previous one
               open_curve_pt->polyline_pt(cs-1)->reverse();
              }
             
            } // if (cs == 1)
           else
            {
             std::ostringstream error_stream;
             error_stream
              <<"The distance between the first node of the current\n"
              <<"line segment (boundary " << bound << ") and either end of "
              <<"the previous line segment\n"
              <<"(boundary "<<prev_seg_boundary_id<<") is bigger than the "
              <<"desired tolerance " <<
              ToleranceForVertexMismatchInPolygons::Tolerable_error << ".\n"
              <<"This suggests that the polylines defining the polygonal\n"
              <<"representation are not properly ordered.\n"
              <<"Fail on last vertex of polyline: ("<<prev_seg_boundary_id
              <<") and\nfirst vertex of polyline (" <<bound << ").\n"
              <<"This should have failed when first trying to construct\n"
              << "the polygon.\n";
             throw OomphLibError(error_stream.str(),
                                 OOMPH_CURRENT_FUNCTION,
                                 OOMPH_EXCEPTION_LOCATION);
            }
          }
         else
          {
           //Reverse the current vector to line up with the previous one
           std::reverse(vector_vertex_node.begin(),vector_vertex_node.end());
          }
         
        }
       
      } // if (cs > 0)
     
    } // if (!this->is_mesh_distributed())
   
   // ---------------------------------------------------------------
   // Update the polylines representation
   // ---------------------------------------------------------------
   // Always update the polylines representation, in a distributed
   // mesh it is necessary to update the polyline representation since
   // it may no longer have vertices (the boundary may not be part of
   // the domain in the current processor)
   
   // The new number of vertices
   n_vertex = vector_vertex_node.size();
   
   // Update the polyline according to the new vertices
   TriangleMeshPolyLine *tmp_polyline_pt =
    new TriangleMeshPolyLine(vector_vertex_node,bound);
   
   // Create a temporal "curve section" version of the recently
   // created polyline
   TriangleMeshCurveSection *tmp_curve_section_pt = tmp_polyline_pt;
   
   // Tolerance below which the middle point can be deleted (ratio of
   // deflection to element length)
   double unrefinement_tolerance=
    open_curve_pt->polyline_pt(cs)->unrefinement_tolerance();
   
   // Tolerance to add points
   double refinement_tolerance=
    open_curve_pt->polyline_pt(cs)->refinement_tolerance();
   
   // Establish refinement and unrefinement tolerance
   tmp_polyline_pt->set_unrefinement_tolerance(unrefinement_tolerance);
   tmp_polyline_pt->set_refinement_tolerance(refinement_tolerance);
   
   // Establish the maximum length constraint
   double maximum_length = open_curve_pt->polyline_pt(cs)->maximum_length();
   tmp_polyline_pt->set_maximum_length(maximum_length);
   
#ifdef OOMPH_HAS_MPI
   // If the mesh is distributed check that the polyline still has
   // vertices
   if (this->is_mesh_distributed())
    {
     if (n_vertex >= 2)
      {
       // Pass the connection information from the old polyline to
       // the new one
       this->copy_connection_information(open_curve_pt->polyline_pt(cs), 
                                         tmp_curve_section_pt);
      } // if (n_vertex >= 2)
    } // if (this->is_mesh_distributed())
   else
#endif
    {
     // Pass the connection information from the old polyline to the
     // new one
     this->copy_connection_information(open_curve_pt->polyline_pt(cs), 
                                       tmp_curve_section_pt);
    }
   
   // Now update the polyline according to the new vertices but first
   // check if the object is allowed to delete the representation or
   // if it should be done by other object
   bool delete_it_on_destructor = false;
   
   std::set<TriangleMeshCurveSection*>::iterator it =
    this->Free_curve_section_pt.find(open_curve_pt->curve_section_pt(cs));
   
   if (it!=this->Free_curve_section_pt.end())
    {
     this->Free_curve_section_pt.erase(it);
     delete open_curve_pt->curve_section_pt(cs);
     delete_it_on_destructor = true;
    }
   
   // -------------------------------------------------------------
   // Copying the new representation
   open_curve_pt->curve_section_pt(cs) = tmp_polyline_pt;
   
   // Update the Boundary - Polyline map
   this->Boundary_curve_section_pt[bound] = 
    open_curve_pt->curve_section_pt(cs);
   
   if (delete_it_on_destructor)
    {
     this->Free_curve_section_pt.insert(open_curve_pt->curve_section_pt(cs));
    }
   
#ifdef OOMPH_HAS_MPI
   // If there are not sub-boundaries mark the boundary if need to be
   // trated as shared or as internal boundary
   if (this->is_mesh_distributed() && nsub_boundaries == 1)
    {
     // Clear all previous stored data
     this->Boundary_marked_as_shared_boundary[bound].clear();
     
     // .. and store the flag for the boundary
     this->Boundary_marked_as_shared_boundary[bound].push_back(
      internal_to_shared_boundary[0]);
    }
   // --------- Stuff for the sub_boundaries ----- Begin section --------
   // Verify if need to deal with sub_boundaries
   else if (this->is_mesh_distributed() && nsub_boundaries > 1)
    {
     // Create temporary representations for the boundaries, only to
     // create the mesh when calling Triangle
      
     // Clear all previous stored data
     this->Boundary_subpolylines[bound].clear();
     // Now create storage for the sub-boundaries
     this->Boundary_subpolylines[bound].resize(nsub_boundaries);
     
      // Clear all previous stored data
      this->Boundary_marked_as_shared_boundary[bound].clear();
      // Create storage to mark the internal boundaries as shared
      // boundaries
      this->Boundary_marked_as_shared_boundary[bound].resize(nsub_boundaries);
      for (unsigned isub = 0; isub < nsub_boundaries; isub++)
       {
        // Now update the polyline according to the sub set of
        // vertices, set the chunk number of the polyline
        TriangleMeshPolyLine *sub_tmp_polyline_pt =
         new TriangleMeshPolyLine(sub_vector_vertex_node[isub], bound, isub);
        
        // Add the sub-polyline to the container to represent the
        // boundary in parts
        this->Boundary_subpolylines[bound][isub] = sub_tmp_polyline_pt;
        
        // Copy the flag that mark the boundary as internal or as
        // shared bound
        this->Boundary_marked_as_shared_boundary[bound][isub] = 
         internal_to_shared_boundary[isub];
        
        // No need to send the unrefinement/refinement and maximum
        // length constraints since these are only temporary
        // representations
        
        // But we certanly we need to pass the connection information
        // to the sub-polylines
        // Get a curve section representation of the sub-polyline
        TriangleMeshCurveSection *tmp_sub_curve_section_pt = 
          sub_tmp_polyline_pt;
        this->copy_connection_information_to_sub_polylines(
            tmp_curve_section_pt, tmp_sub_curve_section_pt);
        
       } // for (isub < nsub_boundaries)
      
    } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
   // --------- Stuff for the sub_boundaries ----- End section ---------
#endif // OOMPH_HAS_MPI
   
   // Delete the allocated memory for the geometric object
   // that represents the curvilinear boundary
   delete mesh_geom_obj_pt;
   
  } // for (cs < ncurve_section)
 
 // Cleanup the face mesh
 for(unsigned p = 0; p < ncurve_section; p++)
  {
   face_mesh_pt[p]->flush_node_storage();
   delete face_mesh_pt[p];
  }
 
 return update_was_performed;
 
}

#ifdef OOMPH_HAS_MPI
//======================================================================
/// \short Updates the polylines using the elements area as 
/// constraint for the number of points along the boundaries
//======================================================================
template <class ELEMENT>
bool RefineableTriangleMesh<ELEMENT>::
update_shared_curve_using_elements_area(Vector<TriangleMeshPolyLine*> 
                                        &vector_polyline_pt,
                                        const Vector<double> &target_areas)
{
 // Flag to check if there were a change on the shared boundary
 // representation
 unsigned update_was_performed = false;
 
 // Go through all the shared boundaries/polylines
 const unsigned n_polylines = vector_polyline_pt.size();
 for (unsigned pp = 0; pp < n_polylines; pp++)
  {
   // Get the boundary id of the current polyline
   const unsigned shd_bnd_id = vector_polyline_pt[pp]->boundary_id();
   
   // Get the chunk number
   const unsigned chunk = vector_polyline_pt[pp]->boundary_chunk();
   
   // Get the face elements that created the shared boundary from the
   // bulk shared boundary elements
   
   // Compute the face elements from the shared boundary elements,
   // create an association from the face element with the "bulk"
   // elements
   std::map<FiniteElement*, FiniteElement*> face_ele_pt_to_bulk_element_pt;
   
   // The temporary storage for the halo face elements
   Vector<FiniteElement*> halo_shared_face_ele_pt;
   // The temporary storage for the nonhalo face elements
   Vector<FiniteElement*> nonhalo_shared_face_ele_pt;
   
   // Get the number of shared boundary elements associated with the
   // current shared boundary
   const unsigned nshared_bound_ele = 
    this->nshared_boundary_element(shd_bnd_id);
   
   // Loop over the elements in the shared boundary to create the face
   // elements
   for (unsigned e = 0; e < nshared_bound_ele; e++)
    {
     // Get the shared boundary element
     FiniteElement* bulk_ele_pt = 
      this->shared_boundary_element_pt(shd_bnd_id, e);
     
     // Get the face index
     int face_index = this->face_index_at_shared_boundary(shd_bnd_id, e);
     
     // Before adding the new element we need to ensure that the edge
     // that this element represents has not been already added
     FiniteElement* face_ele_pt = 
      new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);
     
     // Establish the association between the bulk element and the
     // face element
     face_ele_pt_to_bulk_element_pt[face_ele_pt] = bulk_ele_pt;
     
     // Nonhalo element
     if (!bulk_ele_pt->is_halo())
      {
       // Add nonhalo shared face element to the container
       nonhalo_shared_face_ele_pt.push_back(face_ele_pt);
      }
     else // halo element
      {
       // Add halo shared face element to the container
       halo_shared_face_ele_pt.push_back(face_ele_pt);
      }
     
    } // for (e < nshared_bound_ele)
   
   // Now we have the face elements, we need to ensure that the halo
   // and nonhalo bulk element are sorted one after the other
   Vector<Vector<FiniteElement*> > unsorted_shared_bulk_ele_pt;
   
   // Mark the face elements already used
   std::map<FiniteElement*, bool> shared_face_done;
   
   // Get the number of nonhalo face elements
   const unsigned nnonhalo_face_shared_ele = 
    nonhalo_shared_face_ele_pt.size();
   
   // Get the number of halo face elements
   const unsigned nhalo_face_shared_ele = 
    halo_shared_face_ele_pt.size();
   
#ifdef PARANOID
   // The number of nonhalo shared face boundary elements must be the
   // half of the total number of shared boundary elements
   if (nshared_bound_ele / 2 != nnonhalo_face_shared_ele)
    {
     std::ostringstream error_message;
     error_message
      << "The number of shared boundary elements (" << nshared_bound_ele 
      << ") is not the double\nof the number of unsorted NONHALO shared "
      << "face boundary elements (" << nnonhalo_face_shared_ele << ")\n"
      << "for the current boundary ("<< shd_bnd_id << ")\n\n";
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
   
   // The number of halo shared face boundary elements must be the
   // half of the total number of shared boundary elements
   if (nshared_bound_ele / 2 != nhalo_face_shared_ele)
    {
     std::ostringstream error_message;
     error_message
      << "The number of shared boundary elements (" << nshared_bound_ele 
      << ") is not the double\nof the number of unsorted HALO shared "
      << "face boundary elements (" << nhalo_face_shared_ele << ")\n"
      << "for the current boundary ("<< shd_bnd_id << ")\n\n";
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   
   // ------------------------------------------------------------------
   // Loop over the nonhalo face elements and look for the halo face
   // element at the other side of the shared boundary
   for (unsigned inh = 0; inh < nnonhalo_face_shared_ele; inh++)
    {
     // Get the inh-th face element
     FiniteElement* nonhalo_face_ele_pt = nonhalo_shared_face_ele_pt[inh];
     
     // Get the number of nodes on the face element
     const unsigned nnodes_nh = nonhalo_face_ele_pt->nnode();
     // Get the first and last node on the element
     Node* nh_first_node_pt = nonhalo_face_ele_pt->node_pt(0);
     Node* nh_last_node_pt = nonhalo_face_ele_pt->node_pt(nnodes_nh-1);
     
     // Now find the (halo) face element at the other side of the
     // shared boundary
     for (unsigned ih = 0; ih < nhalo_face_shared_ele; ih++)
      {
       // Get the ih-th face element
       FiniteElement* halo_face_ele_pt = halo_shared_face_ele_pt[ih];
       
       // Check that the face element has not been done
       if (!shared_face_done[halo_face_ele_pt])
        {
         // Get the number of nodes on the face element
         const unsigned nnodes_h = halo_face_ele_pt->nnode();
         // Get the first and last node on the element
         Node* h_first_node_pt = halo_face_ele_pt->node_pt(0);
         Node* h_last_node_pt = halo_face_ele_pt->node_pt(nnodes_h-1);
         
         // If the nodes are the same then we have found the (halo)
         // face element at the other side of the shared boundary
         if (nh_first_node_pt == h_first_node_pt &&
             nh_last_node_pt == h_last_node_pt)
          {
           // Get the BULK elements associated with the face elements
           Vector<FiniteElement*> tmp_bulk_element_pt;
           // Get the BULK elements associated to the face elements
           // (the nonhalo and the halo)
           FiniteElement* nonhalo_bulk_ele_pt = 
            face_ele_pt_to_bulk_element_pt[nonhalo_face_ele_pt];
           FiniteElement* halo_bulk_ele_pt = 
            face_ele_pt_to_bulk_element_pt[halo_face_ele_pt];
           
           // Add the BULK elements to the temporal storage
           tmp_bulk_element_pt.push_back(nonhalo_bulk_ele_pt);
           tmp_bulk_element_pt.push_back(halo_bulk_ele_pt);
           
           // Store the pair of elements associated to the "edge"
           unsorted_shared_bulk_ele_pt.push_back(tmp_bulk_element_pt);
           
           // Mark the face elements as done
           shared_face_done[nonhalo_face_ele_pt] = true;
           shared_face_done[halo_face_ele_pt] = true;
           
           // Break the loop for (ih < nhalo_face_shared_ele)
           break;
          } // if (nh_first_node_pt == h_first_node_pt &&
            //     nh_last_node_pt == h_last_node_pt)
         else if (nh_first_node_pt == h_last_node_pt &&
                  nh_last_node_pt == h_first_node_pt)
          {
           // Get the BULK elements associated with the face elements
           Vector<FiniteElement*> tmp_bulk_element_pt;
           // Get the BULK elements associated to the face elements
           // (the nonhalo and the halo)
           FiniteElement* nonhalo_bulk_ele_pt = 
            face_ele_pt_to_bulk_element_pt[nonhalo_face_ele_pt];
           FiniteElement* halo_bulk_ele_pt = 
            face_ele_pt_to_bulk_element_pt[halo_face_ele_pt];
           
           // Add the BULK elements to the temporal storage
           tmp_bulk_element_pt.push_back(nonhalo_bulk_ele_pt);
           tmp_bulk_element_pt.push_back(halo_bulk_ele_pt);
           
           // Store the pair of elements associated to the "edge"
           unsorted_shared_bulk_ele_pt.push_back(tmp_bulk_element_pt);
           
           // Mark the face elements as done
           shared_face_done[nonhalo_face_ele_pt] = true;
           shared_face_done[halo_face_ele_pt] = true;
           
           // Break the loop for (ih < nhalo_face_shared_ele)
           break;
          } // else if (nh_first_node_pt == h_last_node_pt &&
            //          nh_last_node_pt == h_first_node_pt)
         
        } // if (face_done[halo_face_ele_pt])
       
      } // for (ih < nhalo_face_shared_ele)
     
    } // for (inh < nnonhalo_face_shared_ele)
   
   // -------------------------------------------------------------
   // Now sort the face elements
   // -------------------------------------------------------------
   
   // We already have the shared face elements that make the shared
   // boundary (and the bulk elements), now sort them to create a
   // contiguous boundary
   
#ifdef PARANOID
   const unsigned nunsorted_shared_bulk_ele = 
    unsorted_shared_bulk_ele_pt.size();
   
   // The number of unsorted shared BULK elements MUST be the same
   // as the number of shared_boundary elements divided by two
   if (nshared_bound_ele / 2 != nunsorted_shared_bulk_ele)
    {
     std::ostringstream error_message;
     error_message
      << "The number of shared boundary elements (" << nshared_bound_ele 
      << ") is not the double\nof the number of unsorted shared bulk "
      << "boundary elements (" << nunsorted_shared_bulk_ele << ")\n"
      << "for the current boundary ("<< shd_bnd_id << ")\n\n";
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
   
   // The number of done shared face elements MUST be the same as the
   // sum of the nonhalo and halo shared boundary face elements
   if ((nnonhalo_face_shared_ele + nhalo_face_shared_ele) != 
       shared_face_done.size())
    {
     std::ostringstream error_message;
     error_message
      << "The number of DONE shared boundary face elements (" 
      << shared_face_done.size() << ") is not the same\n as the sum of"
      << "the nonhalo face shared boundary elements (" 
      << nnonhalo_face_shared_ele << ")\nand the halo face shared "
      << "boundary elements ("<< nhalo_face_shared_ele << ") for the\n/"
      << "current boundary (" << shd_bnd_id << ")\n\n";
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);       
    }
#endif   
   
   // Clear the already done face elements
   shared_face_done.clear();
   
   // The number of sorted face elements
   unsigned nsorted_face_ele = 0;
   
   // Storing for the sorting nodes extracted from the face
   // elements. This are also used to update the polyline
   std::list<Node*> sorted_nodes;
   
   // Storing for the sorted shared face elements
   std::list<FiniteElement*> sorted_shared_bound_elements_pt;
   
   // Get the root face element
   FiniteElement* root_face_ele_pt = nonhalo_shared_face_ele_pt[0];
   nsorted_face_ele++;
   
   // Mark face as done
   shared_face_done[root_face_ele_pt] = true;
   
   // The initial and final node on the list
   const unsigned nnodes_root = root_face_ele_pt->nnode();
   Node *first_node_pt = root_face_ele_pt->node_pt(0);
   Node *last_node_pt = root_face_ele_pt->node_pt(nnodes_root-1);
   
   // Push back on the list the new nodes
   sorted_nodes.push_back(first_node_pt);
   sorted_nodes.push_back(last_node_pt);
   
   // Store the bulk elements of the current face
   sorted_shared_bound_elements_pt.push_back(
    unsorted_shared_bulk_ele_pt[0][0]);
   sorted_shared_bound_elements_pt.push_back(
    unsorted_shared_bulk_ele_pt[0][1]);
   
   // Sort the face elements
   while (nsorted_face_ele < nnonhalo_face_shared_ele)
    {
     // Flag to indicate when a node was added
     bool node_added = false;
     
     // Start from the next edge since we have already added the
     // previous one as the initial face element
     for (unsigned iface = 1; iface < nnonhalo_face_shared_ele; iface++)
      {
       FiniteElement* tmp_shared_face_ele_pt = 
        nonhalo_shared_face_ele_pt[iface];
       
       // If face has not been sorted
       if (!shared_face_done[tmp_shared_face_ele_pt])
        {
         // Get the number of nodes for the current face element
         const unsigned tmp_nnodes = tmp_shared_face_ele_pt->nnode();
         
         // Get each individual node
         Node* left_node_pt = tmp_shared_face_ele_pt->node_pt(0);
         Node* right_node_pt = tmp_shared_face_ele_pt->node_pt(tmp_nnodes-1);
         
         if (left_node_pt == first_node_pt)
          {
           // Push front the new node
           sorted_nodes.push_front(right_node_pt);
           first_node_pt = right_node_pt;
           node_added = true;
           
           // Store the elements of the current face element
           sorted_shared_bound_elements_pt.push_front(
            unsorted_shared_bulk_ele_pt[iface][1]);
           sorted_shared_bound_elements_pt.push_front(
            unsorted_shared_bulk_ele_pt[iface][0]);
          }
         else if (left_node_pt == last_node_pt)
          {
           // Push back the new node
           sorted_nodes.push_back(right_node_pt);
           last_node_pt = right_node_pt;
           node_added = true;
           
           // Store the elements of the current face element
           sorted_shared_bound_elements_pt.push_back(
            unsorted_shared_bulk_ele_pt[iface][0]);
           sorted_shared_bound_elements_pt.push_back(
            unsorted_shared_bulk_ele_pt[iface][1]);
          }
         else if (right_node_pt == first_node_pt)
          {
           // Push front the new node
           sorted_nodes.push_front(left_node_pt);
           first_node_pt = left_node_pt;
           node_added = true;
           
           // Store the elements of the current face element
           sorted_shared_bound_elements_pt.push_front(
            unsorted_shared_bulk_ele_pt[iface][1]);
           sorted_shared_bound_elements_pt.push_front(
            unsorted_shared_bulk_ele_pt[iface][0]);
          }
         else if (right_node_pt == last_node_pt)
          {
           // Push back the new node
           sorted_nodes.push_back(left_node_pt);
           last_node_pt = left_node_pt;
           node_added = true;
           
           // Store the elements of the current face element
           sorted_shared_bound_elements_pt.push_back(
            unsorted_shared_bulk_ele_pt[iface][0]);
           sorted_shared_bound_elements_pt.push_back(
            unsorted_shared_bulk_ele_pt[iface][1]);
          }
         
         if (node_added)
          {
           // Mark as done if one of its nodes has been added to the
           // list
           shared_face_done[tmp_shared_face_ele_pt] = true;
           nsorted_face_ele++;
           
           // Break the for
           break;
          }
         
        } // if (!shared_face_done[tmp_shared_face_ele_pt])
       
      } // for (iface < nnonhalo_face_shared_ele)
     
    } // while (nsorted_face_ele < nnonhalo_face_shared_ele))
   
   // ----------------------------------------------------------------
   // Here we can safely delete the face elements, they are no longer
   // required
   
   // First the nonhalo face elements
   for (unsigned inh = 0; inh < nnonhalo_face_shared_ele; inh++)
    {
     delete nonhalo_shared_face_ele_pt[inh];
     nonhalo_shared_face_ele_pt[inh] = 0;
    } // for (inh < nnonhalo_face_shared_ele)
   
   // ... then the halo face elements
   for (unsigned ih = 0; ih < nhalo_face_shared_ele; ih++)
    {
     delete halo_shared_face_ele_pt[ih];
     halo_shared_face_ele_pt[ih] = 0;
    } // for (inh < nhalo_face_shared_ele)
   
   // ------------------------------------------------------------------
   // At this point we already have a sorted list of nodes, get the
   // vertices from them and store them in a vector container
   
   // Get the number of nodes on the list
   const unsigned n_nodes = sorted_nodes.size();
   
   // The vector to store the vertices
   Vector<Vector<double> > polyline_vertices(n_nodes);
   
   // Copy the vertices from the nodes
   unsigned counter = 0;
   for (std::list<Node*>::iterator it_nodes = sorted_nodes.begin();
        it_nodes != sorted_nodes.end();
        it_nodes++)
    {
     polyline_vertices[counter].resize(2);
     polyline_vertices[counter][0] = (*it_nodes)->x(0);
     polyline_vertices[counter][1] = (*it_nodes)->x(1);
     counter++;
    }
   
   // ------------------------------------------------------------------
   // Now get the target areas associated to the shared boundary
   // elements
   
   // Copy the sorted elements in a vector
   Vector<FiniteElement*> sorted_shared_ele_pt;
   for (std::list<FiniteElement*>::iterator it_ele = 
         sorted_shared_bound_elements_pt.begin();
        it_ele != sorted_shared_bound_elements_pt.end();
        it_ele++)
    {sorted_shared_ele_pt.push_back((*it_ele));}
   
   // Get the number of target areas
   const unsigned n_shared_target_areas = sorted_shared_ele_pt.size();
   Vector<double> sorted_shared_target_areas(n_shared_target_areas);
   
   // Mark those shared elements already found
   std::map<std::pair<GeneralisedElement*, unsigned>, bool> shared_ele_done;
   
   // Counter for the number of already done shared elements
   unsigned count_found_shared_element = 0;
   
   // Get the target area associated to the shared boundary elements
   const unsigned nele = this->nelement();
   
   // Loop over the elements to find the target areas associated to
   // the shared boundary elements
   for (unsigned e = 0; e < nele; e++)
    {
     GeneralisedElement* current_ele_pt = this->element_pt(e);
     // Now compare the current element with those in the sorted
     // shared element array
     for (unsigned s = 0; s < n_shared_target_areas; s++)
      {
       // Get the element
       GeneralisedElement* current_shared_ele_pt = sorted_shared_ele_pt[s];
       // Create the pair element-index to check if done
       std::pair<GeneralisedElement*, unsigned> pair_gen_ele_idx = 
        std::make_pair(current_shared_ele_pt, s);
       if (!shared_ele_done[pair_gen_ele_idx])
        {
         // Compare with the global element
         if (current_ele_pt == current_shared_ele_pt)
          {
           // Store the target area of the current shared element
           sorted_shared_target_areas[s] = target_areas[e];
           // Mark the shared element as done
           shared_ele_done[pair_gen_ele_idx] = true;
           // Increase the number of found elements
           count_found_shared_element++;
          } // if (current_ele_pt == current_shared_ele_pt)
        } // if (!shared_ele_done[current_shared_ele_pt])
      } // for (s < nshared_taget_areas)
     
     // Check if all shared elements have been found
     if (count_found_shared_element == n_shared_target_areas)
      {break;}
     
    } // for (e < nele)
   
#ifdef PARANOID
   // Check if the number of found target areas is the same as the
   // number of shared target areas
   if (count_found_shared_element != n_shared_target_areas)
    {
     std::ostringstream error_message;
     error_message
      << "The number of found target areas (" 
      << count_found_shared_element << ") is different from the "
      << "total number\nof target areas (" 
      << n_shared_target_areas << ") in shared boundary ("
      << shd_bnd_id <<")\n\n";
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   
   // The number of vertices
   const unsigned n_vertices = n_nodes;
   
   // Get the number of segments from the input vector_polyline_pt
   const unsigned n_segments = vector_polyline_pt[pp]->nsegment();
   // Get the number of segments from the input vector_polyline_pt to
   // ensure that the shared boundary corresponds to the one
   // represented by the shared face elements (this has sence when the
   // mesh was re-created from re-starting)
   
   // Check that the number of vertices correspond with the number of
   // segments
#ifdef PARANOID
   if (n_segments != n_vertices-1)
    {
     std::ostringstream error_message;
     error_message
      << "The number of segments from the current shared polyline "
      << "(" << n_segments << ") does not\ncorrespond with the number of "
      << "sorted vertices (" << n_vertices-1 << ") of the current shared\n"
      << "boundary\n\n";
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
   
   // Check that the number of target areas correspond with the number
   // of vertices
   if (n_segments != n_shared_target_areas/2)
    {
     std::ostringstream error_message;
     error_message
      << "The number of segments for the current sorting of edges "
      << "(" << n_segments << ") is different\nfrom the number of "
      << "target areas (" << n_shared_target_areas/2 << ")\n\n";
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   
   // ------------------------------------------------------------------
   // Get the target areas that are used to perform the unrefinement
   // and refinement operation. For each face element on a shared
   // polyline there are two bulk elements, a halo and a haloed
   // element, each with an associated target area. Review the
   // function
   // TriangleMesh::create_polylines_from_halo_elements_helper() to
   // check how the shared boundaries were created
   Vector<double> polyline_target_area(n_segments);
   // Loop over the segments in the shared polyline
   for (unsigned s = 0; s < n_segments; s++)
    {
     // Get the minimum of the associated target areas
     polyline_target_area[s] = std::min(sorted_shared_target_areas[s*2], 
                                        sorted_shared_target_areas[(s*2)+1]);
    }
   
   // Before going to the unrefinement or refinement process check
   // that in all processors where the shared boundary lives start
   // from the same vertex.
   // Start from the bottom left vertex
   if (polyline_vertices[n_vertices-1][1] < polyline_vertices[0][1])
    {
     std::reverse(polyline_vertices.begin(), polyline_vertices.end());
     std::reverse(polyline_target_area.begin(), polyline_target_area.end());
    }
   else if (polyline_vertices[n_vertices-1][1] == polyline_vertices[0][1])
    {
     if (polyline_vertices[n_vertices-1][0] < polyline_vertices[0][0])
      {
       std::reverse(polyline_vertices.begin(), polyline_vertices.end());
       std::reverse(polyline_target_area.begin(), polyline_target_area.end());
      }
    }
   
   // ------------------------------------------------------------------
   // Apply unrefinement
   bool unrefinement_applied = false;
   // Apply unefinement if there are more than three nodes at the
   // shared boundary
   if (n_vertices > 3)
    {
     unrefinement_applied = 
      unrefine_shared_boundary_constrained_by_target_area(
       shd_bnd_id, chunk, polyline_vertices, polyline_target_area);
    }
   
   // Apply refinement
   bool refinement_applied = 
    refine_shared_boundary_constrained_by_target_area(polyline_vertices,
                                                      polyline_target_area);
   
   // Was unrefinement/refinement applied
   update_was_performed |= (unrefinement_applied || refinement_applied);
   
   // ------------------------------------------------------------------
   // Update the polyline representation of the shared boundary
   
   // The new shared polyline representation
   TriangleMeshPolyLine *new_polyline_pt = 
    new TriangleMeshPolyLine(polyline_vertices, shd_bnd_id);
   
   // Get the curve section representation
   TriangleMeshCurveSection *curve_section_pt = vector_polyline_pt[pp];
   
   // Copy the connection information from the old shared polyline to
   // the new one
   this->copy_connection_information(curve_section_pt, new_polyline_pt);
   
   // Now update the polyline according to the new vertices but first
   // check if the object is allowed to delete the representation or
   // if it should be done by other object
   bool delete_it_on_destructor = false;
   
   // Establish the element as being deleted by the destructor of the
   // class
   std::set<TriangleMeshCurveSection*>::iterator it =
    this->Free_curve_section_pt.find(curve_section_pt);
   
   if (it!=this->Free_curve_section_pt.end())
    {
     this->Free_curve_section_pt.erase(it);
     delete curve_section_pt;
     delete_it_on_destructor = true;
    }
   
   // Copy the new representation to the output vector_polyline_pt
   vector_polyline_pt[pp] = new_polyline_pt;
   
   // Get the new curve section representation
   TriangleMeshCurveSection *new_curve_section_pt = vector_polyline_pt[pp];
   
   // Update the Boundary - Polyline map
   this->Boundary_curve_section_pt[shd_bnd_id] = new_curve_section_pt;
   
   if (delete_it_on_destructor)
    {
     this->Free_curve_section_pt.insert(new_curve_section_pt);
    }
   
  } // for (pp < npoly)
 
 return update_was_performed;
 
}
#endif // #ifdef OOMPH_HAS_MPI

 //=========================================================================
 /// \short Helper function that performs the unrefinement process
 /// on the specified boundary by using the provided vertices
 /// representation and the associated target area.
 //=========================================================================
 template<class ELEMENT>
 bool RefineableTriangleMesh<ELEMENT>::
 unrefine_boundary_constrained_by_target_area(const unsigned &b,
                                              const unsigned &c,
                                              Vector<Vector<double> > 
                                              &vector_bnd_vertices,
                                              double &unrefinement_tolerance,
                                              Vector<double> &area_constraint)
  {
   // Store the vertices not allowed for deletion
   std::set<Vector<double> > no_delete_vertex;
   
   // Does the boundary receives connections?
   const bool boundary_receive_connections = 
    this->boundary_connections(b, c, no_delete_vertex);
   
   // Boolean that indicates whether an actual update of the vertex
   // coordinates was performed
   bool unrefinement_applied = false;
   
   // Return inmedately
   if (!Do_boundary_unrefinement_constrained_by_target_areas)
     {
       return unrefinement_applied;
     }
   
  // Strategy to delete nodes: Consider the target area of the
  // elements (e_i and e_(i+1)) sharing the i-th node (middle node),
  // if the number of segments to be added is equal to zero for both
  // elements then compute the average of both target areas and check
  // if the number of segments is still zero, if that holds mark the
  // node to be deleted. Before delete the node check whether it is in
  // the non_delete_vertex list. Skip the i+1-th node and go for the
  // (i+2)-th one, it means, increase the counter for current node by
  // two.

  // Number of vertices on the boundary
  unsigned n_vertex = vector_bnd_vertices.size();
  
  // Compute a constant value
  const double constant_value = 4.0/sqrt(3.0);
  
  if (n_vertex > 2)
   {
    // Go through all the vertices and delete points when the target area
    // indicates zero points along the boundary
    for (unsigned i = 1; i < n_vertex-1; i+=2)
     {
      if (area_constraint[i-1] > 0 && area_constraint[i] > 0)
       {
        const double local_zeta_first = vector_bnd_vertices[i-1][0];
        const double local_zeta_last = vector_bnd_vertices[i+1][0];
        const double local_length_zeta = 
          std::fabs(local_zeta_last-local_zeta_first);
        
        const double x1 = vector_bnd_vertices[i-1][1];
        const double y1 = vector_bnd_vertices[i-1][2];
        const double x2 = vector_bnd_vertices[i+1][1];
        const double y2 = vector_bnd_vertices[i+1][2];
        const double local_length = 
         sqrt(((x1-x2)*(x1-x2)) + ((y1-y2)*(y1-y2)));
        
        const double x_m = vector_bnd_vertices[i][1];
        const double y_m = vector_bnd_vertices[i][2];
        
        const double average_area_constraint = 
         (area_constraint[i-1] + area_constraint[i]) / 2.0;
        
        // Compute the length of the the side of an equilateral
        // triangle
        const double length_side = 
          sqrt(constant_value*average_area_constraint);
        
        const double length_side_zeta = 
          (local_length_zeta * length_side) / local_length;
        
        // Is the new length greater that the old one
        if ((length_side_zeta / local_length_zeta) > 1.0)
         {
          // If the number of segments is zero then verify the condition for
          // deletion of nodes but using the condition in the default          
          // unrefine_boundary() method. If both conditions are true then
          // delete the node
          // Maths from http://www.cgafaq.info/wiki/Circle_Through_Three_Points
          double a_x=vector_bnd_vertices[i-1][1];
          double a_y=vector_bnd_vertices[i-1][2];
          double b_x=vector_bnd_vertices[i][1];
          double b_y=vector_bnd_vertices[i][2];
          double c_x=vector_bnd_vertices[i+1][1];
          double c_y=vector_bnd_vertices[i+1][2];
          
          double a=b_x-a_x;
          double b=b_y-a_y;
          double c=c_x-a_x;
          double d=c_y-a_y;
          
          double e=a*(a_x+b_x)+b*(a_y+b_y);
          double f=c*(a_x+c_x)+d*(a_y+c_y);
          
          double g=2.0*(a*(c_y-b_y)-b*(c_x-b_x));
          
          bool do_it=false;
          if (std::fabs(g)<1.0e-14)
           {
            do_it=true;
           }
          else
           {
            double p_x=(d*e-b*f)/g;
            double p_y=(a*f-c*e)/g;
            
            double r=sqrt(pow((a_x-p_x),2)+pow((a_y-p_y),2));
            
            double rhalfca_x=0.5*(a_x-c_x);
            double rhalfca_y=0.5*(a_y-c_y);
            
            double halfca_squared=pow(rhalfca_x,2)+pow(rhalfca_y,2);
            
            double sticky_out_bit=r-sqrt(std::fabs((r*r) - halfca_squared));
            
            // If sticky out bit divided by distance between end nodes
            // is less than tolerance the boundary is so flat that we
            // can safely kill the node
            if ((sticky_out_bit/(2.0*sqrt(halfca_squared)))<
                unrefinement_tolerance)
             {
              do_it=true;
             }
           }
          
          // If the vertex was proposed for deletion check if it is
          // allowed for being deleted
          if (do_it && boundary_receive_connections)
           {
            // Is the vertex one of the non deletable vertices
            for (std::set<Vector<double> >::iterator it = 
                  no_delete_vertex.begin();
                 it != no_delete_vertex.end(); it++)
             {
              // Compute the distance between the proposed node to
              // delete and the ones that should not be deleted
              const double x = (*it)[0];
              const double y = (*it)[1];
              double error = (x_m - x)*(x_m - x) + (y_m - y)*(y_m - y);
              error = sqrt(error);
              
              if(error <
                 ToleranceForVertexMismatchInPolygons::Tolerable_error)
               {
                // Do not delete the vertex
                do_it = false;
                break;
               }
              
             }
            
           } // if (do_it && boundary_receive_connections)
          
          // Remove node?
          if (do_it)
           {
            vector_bnd_vertices[i].resize(0);
           }
         } // if (n_seg == 0)
       } // if (area_constraint[i] >= 0)
     } // for (i < n_vertex-1)

    // Create a new (temporary) vector for the nodes, so that deleted nodes
    // are not stored
    Vector<Vector<double> > compact_vector;

    // Compact vector for target areas too
    Vector<double> compact_area_constraint;

    // Copy only the non deleted nodes
    for(unsigned i = 0; i < n_vertex; i++)
     {
      // If the entry was not deleted include it in the new vector
      if (vector_bnd_vertices[i].size()!=0)
       {
        compact_vector.push_back(vector_bnd_vertices[i]);
       }
     }

    // ------------------------------------------------------------------
    // Size of the target areas vector
    unsigned nsize_target = area_constraint.size();
    if (nsize_target == 1)
     {
      // No node was deleted, just copy the target area
      compact_area_constraint.push_back(area_constraint[0]);
     }
    
    // Copy the target areas
    for(unsigned i = 1; i < n_vertex; i+=2)
     {
      // If the entry was not deleted include the target areas of both
      // elements sharing the node
      if (vector_bnd_vertices[i].size()!=0)
       {
        compact_area_constraint.push_back(area_constraint[i-1]);
        // To catch the case when working with even number of vertex
        if (i < nsize_target)
         {
          compact_area_constraint.push_back(area_constraint[i]);
         }
       }
      else
       {
        // If the node was deleted then compute the new target area as the
        // average of the target area of the elements sharing the node
        double new_area_constraint = 
         (area_constraint[i-1] + area_constraint[i]) / 2.0;
         compact_area_constraint.push_back(new_area_constraint);
       }
     }
    
    // If the size of the compact vector is different from the size of the
    // vector before applying the area length constraint then the polyline
    // was updated
    if( n_vertex != compact_vector.size() )
     {
      unrefinement_applied = true;
     }

    // Copy back to the original vector
    n_vertex = compact_vector.size();
    vector_bnd_vertices.resize(n_vertex);
    for(unsigned i = 0; i < n_vertex; i++)
     {
      vector_bnd_vertices[i].resize(3);
      vector_bnd_vertices[i][0] = compact_vector[i][0];
      vector_bnd_vertices[i][1] = compact_vector[i][1];
      vector_bnd_vertices[i][2] = compact_vector[i][2];
     }

    // Copy back to the original vector of target areas
    unsigned ntarget_areas = compact_area_constraint.size();
    area_constraint.resize(ntarget_areas);
    for(unsigned i = 0; i < ntarget_areas; i++)
     {
      area_constraint[i] = compact_area_constraint[i];
     }

   } // if (n_vertex > 2)
  
  return unrefinement_applied;

 }
 
 //=========================================================================
 /// \short Helper function that performs the refinement process
 /// on the specified boundary by using the provided vertices
 /// representation and the associated elements target area.
 //=========================================================================
 template<class ELEMENT>
 bool RefineableTriangleMesh<ELEMENT>::
 refine_boundary_constrained_by_target_area(MeshAsGeomObject* 
                                            mesh_geom_obj_pt,
                                            Vector<Vector<double> >
                                            &vector_bnd_vertices,
                                            double &refinement_tolerance, 
                                            Vector<double> &area_constraint)
 {
   // Boolean that indicates whether an actual update of the vertex
   // coordinates was performed
   bool refinement_applied = false;
   
   // Return inmedately
   if (!Do_boundary_refinement_constrained_by_target_areas)
     {
      return refinement_applied;
     }
   
  // Get the total number of current vertices
  unsigned n_vertex=vector_bnd_vertices.size();
  
  // Compute a constant value
  const double constant_value = 4.0/sqrt(3.0);
  
  if (n_vertex > 1)
   {
    // Create a new (temporary) vector for the nodes, so that new
    // nodes can be stored
    Vector<Vector<double> > new_vector;

    // Go through all the vertices and create points according to the
    // specified element area
    for (unsigned i = 0; i < n_vertex-1; i++)
     {
      // Include the first node
      new_vector.push_back(vector_bnd_vertices[i]);

      if (area_constraint[i] > 0)
       {
        double local_zeta_first = vector_bnd_vertices[i][0];
        double local_zeta_last = vector_bnd_vertices[i+1][0];
        const double local_length_zeta = 
         std::fabs(local_zeta_last-local_zeta_first);
        
        // Check if need to interchange the zeta first and the zeta
        // last (to ensure the same order in zeta values in any two
        // processors)
        if (local_zeta_first > local_zeta_last)
         {
           const double tmp_zeta = local_zeta_first;
           local_zeta_first = local_zeta_last;
           local_zeta_last = tmp_zeta;
         }
        
        const double x1 = vector_bnd_vertices[i][1];
        const double y1 = vector_bnd_vertices[i][2];
        const double x2 = vector_bnd_vertices[i+1][1];
        const double y2 = vector_bnd_vertices[i+1][2];
        const double local_length = 
         sqrt(((x1-x2)*(x1-x2)) + ((y1-y2)*(y1-y2)));
        
        // Compute the length in zeta units
        const double length_side = sqrt(constant_value*area_constraint[i]);
        const double length_side_zeta = 
         (local_length_zeta * length_side) / local_length;
        
        // How many segments should be introduced
        const double n_seg_double = length_side_zeta/local_length_zeta;
        
        // One segment initialy (the original one)
        unsigned n_seg = 1;
        
        // How many more segments to introduce?
        n_seg+=static_cast<unsigned>(std::floor(1.0/n_seg_double));
        
        // Are there segments to introduce? There must be at least one
        // segment, the original one
        if (n_seg > 0)
         {
          // The zeta increment
          double zeta_increment = (local_length_zeta)/((double)n_seg);
          
          Vector<double> zeta(1);
          // Create the n_seg segmets between each pair of nodes
          for(unsigned s=1;s<n_seg;s++)
           {
            // Get the coordinates
            zeta[0]= local_zeta_first + zeta_increment*double(s);
            Vector<double> vertex(2);
            mesh_geom_obj_pt->position(zeta, vertex);
            
            // Create the new node
            Vector<double> new_node(3);
            new_node[0]=zeta[0];
            new_node[1]=vertex[0];
            new_node[2]=vertex[1];
          
            // Include the new node
            new_vector.push_back(new_node);
            
           } // for (s<=n_seg)
          
         } // if (n_seg > 0)
        
       } // if (area_constraint[i] >= 0)
      
     } // for (i < n_vertex-1)

    // Once finished all the vertices add the last node to the vector
    new_vector.push_back(vector_bnd_vertices[n_vertex-1]);

    // If the new size of the vector (including the added nodes) is
    // different from the size of the vector before applying the
    // area length constraint then the polyline was updated
    n_vertex=new_vector.size();
    if( n_vertex != vector_bnd_vertices.size() )
     {
      refinement_applied = true;
     }
    
    // Copy the new representation
    vector_bnd_vertices.resize(n_vertex);
    for(unsigned i=0;i<n_vertex;i++)
     {
      vector_bnd_vertices[i].resize(3);
      vector_bnd_vertices[i][0]=new_vector[i][0];
      vector_bnd_vertices[i][1]=new_vector[i][1];
      vector_bnd_vertices[i][2]=new_vector[i][2];
     }
    
   } // if (n_vertex > 1)
  
  return refinement_applied;
  
 }

 //======================================================================
 /// \short Helper function that performs the unrefinement process
 /// on the specified boundary by using the provided vertices
 /// representation and the associated target area.
 /// NOTE: This is the version that applies unrefinement to shared
 /// boundaries
 //======================================================================
 template <class ELEMENT>
 bool RefineableTriangleMesh<ELEMENT>::
 unrefine_shared_boundary_constrained_by_target_area(
  const unsigned &b, 
  const unsigned &c, 
  Vector<Vector<double> > &vector_bnd_vertices,
  Vector<double> &area_constraint)
 {
  // Store the vertices not allowed for deletion
  std::set<Vector<double> > no_delete_vertex;
  
  // Does the boundary receives connections?
  const bool boundary_receive_connections = 
   this->boundary_connections(b, c, no_delete_vertex);
  
  // Boolean that indicates whether an actual update of the vertex
  // coordinates was performed
  bool unrefinement_applied = false;
  
  // Return inmedately
  if (!Do_shared_boundary_unrefinement_constrained_by_target_areas)
    {
      return unrefinement_applied;
    }
  
  // Strategy to delete nodes: 
  
  // Strategy to delete nodes: Consider the target area of the
  // elements (e_i and e_(i+1)) sharing the i-th node (middle node),
  // if the number of segments to be added is equal to zero for both
  // elements then compute the average of both target areas and check
  // if the number of segments is still zero, if that holds mark the
  // node to be deleted. Before delete the node check whether it is in
  // the non_delete_vertex list. Skip the i+1-th node and go for the
  // (i+2)-th one, it means, increase the counter for current node by
  // two.
  
  // Number of vertices on the boundary
  unsigned n_vertex = vector_bnd_vertices.size();
  
  // Compute a constant value
  const double constant_value = 4.0/sqrt(3.0);
  
  if (n_vertex > 2)
   {
    // Go through all the vertices and delete points when the target
    // area indicates zero points along the boundary
    for (unsigned i = 1; i < n_vertex-1; i+=2)
     {
      // Is a target area assigned to the left and right element of
      // the i-th node
      if (area_constraint[i-1] > 0 && area_constraint[i] > 0)
       {        
        // Get the vertices to the left
        const double x1 = vector_bnd_vertices[i-1][0];
        const double y1 = vector_bnd_vertices[i-1][1];
        // ... and to the right of the i-th vertex
        const double x2 = vector_bnd_vertices[i+1][0];
        const double y2 = vector_bnd_vertices[i+1][1];
        
        // The distance
        const double local_length = 
         sqrt(((x1-x2)*(x1-x2)) + ((y1-y2)*(y1-y2)));
        
        // Get the middle vertex
        const double x_m = vector_bnd_vertices[i][0];
        const double y_m = vector_bnd_vertices[i][1];
        
        // The average area
        const double average_area_constraint = 
         (area_constraint[i-1] + area_constraint[i]) / 2.0;
        
        // Compute the base length of the triangle with
        // area_constraint area
        const double length_side = 
          sqrt(constant_value*average_area_constraint);
        
        // Is the new length greater than the old one
        if ((length_side / local_length) > 1.0)
         {          
          bool do_it=true;
          
          // If the vertex was proposed for deletion check that it is
          // allowed for being deleted
          if (do_it && boundary_receive_connections)
           {
            // Is the vertex one of the non deletable vertices
            for (std::set<Vector<double> >::iterator it = 
                  no_delete_vertex.begin();
                 it != no_delete_vertex.end(); it++)
             {
              // Compute the distance between the proposed node to delete
              // and the ones that should not be deleted
              const double x = (*it)[0];
              const double y = (*it)[1];
              double error = (x_m - x)*(x_m - x) + (y_m - y)*(y_m - y);
              error = sqrt(error);
              
              if(error <
                 ToleranceForVertexMismatchInPolygons::Tolerable_error)
               {
                // Do not delete the vertex
                do_it = false;
                break;
               }
              
             }
            
           } // if (do_it && boundary_receive_connections)
          
          // Remove node?
          if (do_it)
           {
            vector_bnd_vertices[i].resize(0);
           }
         } // if ((local_length / length_side) <= 1.3)

       } // if (area_constraint[i] >= 0)
      
     } // for (i < n_vertex-1)
    
    // Create a new (temporary) vector for the nodes, so that deleted nodes
    // are not stored
    Vector<Vector<double> > compact_vector;
    
    // Compact vector for target areas too
    Vector<double> compact_area_constraint;
    
    // Copy only the non deleted nodes
    for(unsigned i = 0; i < n_vertex; i++)
     {
      // If the entry was not deleted include it in the new vector
      if (vector_bnd_vertices[i].size()!=0)
       {
        compact_vector.push_back(vector_bnd_vertices[i]);
       }
     }
    
    // ------------------------------------------------------------------
    // The number of target areas
    unsigned n_area_constraint = area_constraint.size();
    if (n_area_constraint == 1)
     {
      // No node could be deleted then just copy the target area
      compact_area_constraint.push_back(area_constraint[0]);
     }
    
    // Copy the target areas
    for(unsigned i = 1; i < n_vertex; i+=2)
     {
      // If the entry was not deleted include the target areas of both
      // elements sharing the node
      if (vector_bnd_vertices[i].size()!=0)
       {
        compact_area_constraint.push_back(area_constraint[i-1]);
        // To catch the case when working with even number of vertices
        if (i < n_area_constraint)
         {
          compact_area_constraint.push_back(area_constraint[i]);
         }
       }
      else
       {
        // If the node was deleted then compute the new target area as the
        // average of the target area of the elements sharing the node
        const double new_area_constraint = 
         (area_constraint[i-1] + area_constraint[i]) / 2.0;
        compact_area_constraint.push_back(new_area_constraint);
       }
     } // for (i < n_vertex)
    
    // If the size of the compact vector is different from the size of
    // the vector before applying the area length constraint then the
    // polyline was updated
    if( n_vertex != compact_vector.size() )
     {
      unrefinement_applied = true;
     }
    
    // Copy back to the original vector
    n_vertex = compact_vector.size();
    vector_bnd_vertices.resize(n_vertex);
    for(unsigned i = 0; i < n_vertex; i++)
     {
      vector_bnd_vertices[i].resize(2);
      vector_bnd_vertices[i][0] = compact_vector[i][0];
      vector_bnd_vertices[i][1] = compact_vector[i][1];
     }
    
    // Copy back to the original vector of target areas
    unsigned ntarget_areas = compact_area_constraint.size();
    area_constraint.resize(ntarget_areas);
    for(unsigned i = 0; i < ntarget_areas; i++)
     {
      area_constraint[i] = compact_area_constraint[i];
     }
    
   } // if (n_vertex > 2)
  
  return unrefinement_applied;

 }

 //======================================================================
 /// \short Helper function that performs the refinement process
 /// on the specified boundary by using the provided vertices
 /// representation and the associated elements target area.
 /// NOTE: This is the version that applies refinement to shared
 /// boundaries
 //======================================================================
 template <class ELEMENT>
 bool RefineableTriangleMesh<ELEMENT>::
 refine_shared_boundary_constrained_by_target_area(
  Vector<Vector<double> > &vector_bnd_vertices,
  Vector<double> &area_constraint)
 {
  // Boolean that indicates whether an actual update of the vertex
  // coordinates was performed
  bool refinement_applied = false;
  
  // Return inmedately
  if (!Do_shared_boundary_refinement_constrained_by_target_areas)
    {
      return refinement_applied;
    }
  
  // Get the number of segments
  unsigned nsegments = vector_bnd_vertices.size() - 1;

  // Create a new (temporary) vector for the nodes, so that new nodes
  // can be stored
  Vector<Vector<double> > tmp_bnd_vertices;
  
  // Compute a constant value
  const double constant_value = 4.0/sqrt(3.0);
  
  for (unsigned s = 0; s < nsegments; s++)
   {
    Vector<double> left_vertex = vector_bnd_vertices[s];
    Vector<double> right_vertex = vector_bnd_vertices[s+1];

    // Initial and final point of the segment
    const double x1 = left_vertex[0];
    const double y1 = left_vertex[1];
    const double x2 = right_vertex[0];
    const double y2 = right_vertex[1];
    
    // Lenght of the segment
    const double segment_length = 
      sqrt(((x1-x2)*(x1-x2))+((y1-y2)*(y1-y2)));
    
    // Compute the distance for the new segments
    const double new_segment_length = 
      sqrt(constant_value*area_constraint[s]);
    
    // How many segments should be introduced
    const double n_seg_double = new_segment_length / segment_length;
    
    // One segment initialy (the original one)
    unsigned nseg = 1;
    // How many more segments to introduce?
    nseg+=static_cast<unsigned>(std::floor(1.0/n_seg_double));
    
    // The left vertex must be always included, even though no new vertex
    // be added
    tmp_bnd_vertices.push_back(left_vertex);
    
    // Are there segments to introduce? There must be at least one
    // segment, the original one
    if (nseg > 0)
     {       
      // Create intermediate vertices
      double incrementx = (right_vertex[0] - left_vertex[0])/(double)(nseg);
      double incrementy = (right_vertex[1] - left_vertex[1])/(double)(nseg);
      for (unsigned i = 1; i < nseg; i++)
       {
        Vector<double> tmp_vertex(2);
        tmp_vertex[0] = left_vertex[0] + incrementx*i;
        tmp_vertex[1] = left_vertex[1] + incrementy*i;
        tmp_bnd_vertices.push_back(tmp_vertex);
       } // for (i < nseg)
      
     } // if (nseg > 0)
    
   } // for (s < nsegments)

  // Add the last vertex
  tmp_bnd_vertices.push_back(vector_bnd_vertices[nsegments]);

  // If the new size of the vector (including the added nodes) is
  // different from the size of the vector before applying the
  // refinement then the polyline was updated
  nsegments = tmp_bnd_vertices.size() - 1;
  if( nsegments != vector_bnd_vertices.size() - 1 )
   {
    refinement_applied = true;

    // Copy across
    vector_bnd_vertices.resize(nsegments + 1);
    for(unsigned i = 0; i < nsegments + 1; i++)
     {
      vector_bnd_vertices[i].resize(2);
      vector_bnd_vertices[i][0] = tmp_bnd_vertices[i][0];
      vector_bnd_vertices[i][1] = tmp_bnd_vertices[i][1];
     }
   }
  
  return refinement_applied;
  
 }
  
//======================================================================
/// \short Updates the polylines representation after restart
//======================================================================
template <class ELEMENT>
void RefineableTriangleMesh<ELEMENT>::
update_polygon_after_restart(TriangleMeshPolygon* &polygon_pt)
{

 // **********************************************************************
 // 1) Collect the elements adjacet to the polyline boundary id and
 //    update the polyline
 // **********************************************************************
 
 // (1.1) Get the face mesh representation
 Vector<Mesh*> face_mesh_pt;
 get_face_mesh_representation(polygon_pt,face_mesh_pt);
 
 // (1.2) Create vertices of the polylines by using the vertices of the
 //       FaceElements
 Vector<double> vertex_coord(3); // zeta,x,y
 Vector<double> bound_left(1);
 Vector<double> bound_right(1);
 
 const unsigned n_polyline = polygon_pt->npolyline();
 
 // Go for each polyline
 for(unsigned p=0;p<n_polyline;p++)
  {
   // Get the MeshAsGeomObject representation just once per polyline,
   // this object is only used by the
   // refine_boundary_constrained_by_target_area() method. We get it here
   // to ensure that all processors (in a distributed context) get this
   // representation just once, and because an AllToAll MPI communication
   // is used in this calling
   MeshAsGeomObject* mesh_geom_obj_pt=new MeshAsGeomObject(face_mesh_pt[p]);

   // Set of coordinates that are on the boundary
   // Set entries are ordered on first entry in vector which stores
   // the boundary coordinate so the vertices come out in order!
   std::set<Vector<double> > vertex_nodes;

   // Vector to store the vertices, transfer the sorted vertices from the
   // set to this vector, --- including the z-value ---
   Vector<Vector<double> > tmp_vector_vertex_node;

   // Vector to store the coordinates of the polylines, same as the
   // tmp_vector_vertex_node vector (after adding more nodes) but
   // --- without the z-value ---, used to re-generate the polylines
   Vector<Vector<double> > vector_vertex_node;
   
#ifdef OOMPH_HAS_MPI
   // --------- Stuff to deal with splitted boundaries ---------- Begin -----
   // Set of coordinates that are on the boundary (splitted boundary version)
   // The first vector is used to allocate the points for each sub-boundary
   // Set entries are ordered on first entry in vector which stores
   // the boundary coordinate so the vertices come out in order!
   Vector<std::set<Vector<double> > >sub_vertex_nodes;

   // Vector to store the vertices, transfer the sorted vertices from the
   // set (sub_vertex_nodes) to this vector, --- including the z-value ---
   Vector<Vector<Vector<double> > >sub_tmp_vector_vertex_node;

   // Vector to store the coordinates of the polylines that will represent
   // the splitted boundary. Used to pass the info. from sub_vertex_nodes
   // but --- without the z-value ---, used to generate the sub-polylines
   Vector<Vector<Vector<double> > > sub_vector_vertex_node;
   // --------- Stuff to deal with splitted boundaries ----------- End ------
#endif
   
   //Get the boundary id
   unsigned bound=polygon_pt->curve_section_pt(p)->boundary_id();
   
   /// Use a vector of vector for vertices and target areas to
   /// deal with the cases when the boundaries are split by the
   /// distribution process
   
   // Loop over the face elements (ordered) and add their vertices
   const unsigned nface_element = face_mesh_pt[p]->nelement();

   // Store the non halo face elements, the ones from which we will
   // get the vertices
   Vector<FiniteElement*> non_halo_face_element_pt;
   // Map to store the index of the face element on a boundary
   std::map<FiniteElement*,unsigned> face_element_index_on_boundary;

   for(unsigned ef=0;ef<nface_element;++ef)
    {
     FiniteElement* ele_face_pt = face_mesh_pt[p]->finite_element_pt(ef);
     // Skip the halo elements
#ifdef OOMPH_HAS_MPI
     if (this->is_mesh_distributed())
      {
       // Only work with non-halo elements
       if (ele_face_pt->is_halo()) {continue;}
      }
#endif
     // Add the face element to the vector
     non_halo_face_element_pt.push_back(ele_face_pt);
     face_element_index_on_boundary[ele_face_pt] = ef;
    }
   
   // Get the number of non halo face element
   const unsigned nnon_halo_face_element = non_halo_face_element_pt.size();

   // Map to know the already sorted face elements
   std::map<FiniteElement*,bool> face_element_done;
   
   // Number of done face elements
   unsigned nsorted_face_elements = 0;

#ifdef OOMPH_HAS_MPI
   // Counter for sub_boundaries
   unsigned nsub_boundaries = 0;
#endif // #ifdef OOMPH_HAS_MPI
   
   // Continue until all the face elements have been sorted
   // This while is to deal with the cases of splitted boundaries
   while(nsorted_face_elements < nnon_halo_face_element)
    {
     // Get and initial face element
     FiniteElement* ele_face_pt = 0;
#ifdef PARANOID
     bool found_initial_face_element = false;
#endif
     
     unsigned iface = 0;
     for (iface = 0; iface < nnon_halo_face_element; iface++)
      {
       ele_face_pt = non_halo_face_element_pt[iface];
       // If not done then take it as initial face element
       if (!face_element_done[ele_face_pt])
        {
#ifdef PARANOID
         found_initial_face_element = true;
#endif
         nsorted_face_elements++;
         iface++;
         break;
        }
      }
         
#ifdef PARANOID
     if (!found_initial_face_element)
      {
       std::ostringstream error_message;
       error_message
        <<"Could not find an initial face element for the current segment\n";
       // << "----- Possible memory leak -----\n";
       throw OomphLibError(error_message.str(),
        "RefineableTriangleMesh::update_polygon_after_restart()",
        OOMPH_EXCEPTION_LOCATION);
      }
#endif

     // Local set of coordinates that are on the boundary
     // Set entries are ordered on first entry in vector which stores
     // the boundary coordinate so the vertices come out in order!
     std::set<Vector<double> > local_vertex_nodes;
     
     // Vector to store the vertices, transfer the sorted vertices from the
     // set (local) to this vector (local), --- including the z-value ---
     Vector<Vector<double> > local_tmp_vector_vertex_node;
     
     // ------------------------------------------------------------------
     // ------------------------------------------------------------------
     // -----------------------------------------------------------------
     // Add the vertices of the initial face element to the set of local 
     // sorted vertices
     // -----------------------------------------------------------------
     unsigned nnode = ele_face_pt->nnode();
     // Add the left-hand node to the set:
     // Boundary coordinate
     ele_face_pt->node_pt(0)->get_coordinates_on_boundary(bound,bound_left);
     vertex_coord[0] = bound_left[0];

     // Actual coordinates
     for(unsigned i=0;i<2;i++)
      {
       vertex_coord[i+1] = ele_face_pt->node_pt(0)->x(i);
      }
     local_vertex_nodes.insert(vertex_coord);

     // Add the right-hand nodes to the set:
     // Boundary coordinate
     ele_face_pt->node_pt(nnode-1)->
      get_coordinates_on_boundary(bound,bound_right);
     vertex_coord[0] = bound_right[0];

     // Actual coordinates
     for(unsigned i=0;i<2;i++)
      {
       vertex_coord[i+1] = ele_face_pt->node_pt(nnode-1)->x(i);
      }
     local_vertex_nodes.insert(vertex_coord);

     // The initial and final node on the set
     Node *first_node_pt = ele_face_pt->node_pt(0);
     Node *last_node_pt = ele_face_pt->node_pt(nnode-1);

     // Mark the current face element as done
     face_element_done[ele_face_pt] = true;
     
     // ------------------------------------------------------------------
     // ------------------------------------------------------------------
     // ------------------------------------------------------------------

     // Continue iterating if a new face element has been added to the
     // list
     bool face_element_added = false;

     // While a new face element has been added to the set of sorted
     // face elements then re-iterate
     do
      {
       // Start from the next face elements since we have already added
       // the previous one as the initial face element (any previous face
       // element had to be added on previous iterations)
       for (unsigned iiface=iface;iiface<nnon_halo_face_element;iiface++)
        {
         face_element_added = false;
         ele_face_pt = non_halo_face_element_pt[iiface];
         if (!face_element_done[ele_face_pt])
          {
           // Get each individual node to check if they are contiguous
           nnode = ele_face_pt->nnode();
           Node* left_node_pt = ele_face_pt->node_pt(0);
           Node* right_node_pt = ele_face_pt->node_pt(nnode-1);
                 
           if (left_node_pt == first_node_pt)
            {
             first_node_pt = right_node_pt;
             face_element_added = true;
            }
           else if (left_node_pt == last_node_pt)
            {
             last_node_pt = right_node_pt;
             face_element_added = true;
            }
           else if (right_node_pt == first_node_pt)
            {
             first_node_pt = left_node_pt;
             face_element_added = true;
            }
           else if (right_node_pt == last_node_pt)
            {
             last_node_pt = left_node_pt;
             face_element_added = true;
            }
           
           if (face_element_added)
            {
             // Add the left-hand node to the set:
             // Boundary coordinate
             left_node_pt->get_coordinates_on_boundary(bound,bound_left);
             vertex_coord[0] = bound_left[0];

             // Actual coordinates
             for(unsigned i=0;i<2;i++)
              {
               vertex_coord[i+1] = left_node_pt->x(i);
              }
             local_vertex_nodes.insert(vertex_coord);
             
             // Add the right-hand nodes to the set:
             // Boundary coordinate
             right_node_pt->get_coordinates_on_boundary(bound,bound_right);
             vertex_coord[0] = bound_right[0];

             // Actual coordinates
             for(unsigned i=0;i<2;i++)
              {
               vertex_coord[i+1] = right_node_pt->x(i);
              }
             local_vertex_nodes.insert(vertex_coord);
             
             // Mark as done only if one of its nodes has been
             // added to the list
             face_element_done[ele_face_pt] = true;
             nsorted_face_elements++;
             
             break;
            }
           
          } // if (!edge_done[edge])
        } // for (iiedge < nedges)
      }while(face_element_added &&
             (nsorted_face_elements < nnon_halo_face_element));
     
     // -----------------------------------------------------------------
     // At this point we already have a sorted set of nodes and
     // can be used to peform the unrefinement and refinement procedures
     // -----------------------------------------------------------------
     
     // Get the number of nodes on the list
     const unsigned nlocal_nodes = local_vertex_nodes.size();
     // Change representation to vector for easy of handling ...
     local_tmp_vector_vertex_node.resize(nlocal_nodes);
         
     // Copy the vertices of the nodes
     unsigned counter = 0;
     std::set<Vector<double> >::iterator it_vertex;
     for (it_vertex = local_vertex_nodes.begin();
          it_vertex != local_vertex_nodes.end();
          it_vertex++)
      {
       local_tmp_vector_vertex_node[counter].resize(3);
       local_tmp_vector_vertex_node[counter][0] = (*it_vertex)[0];
       local_tmp_vector_vertex_node[counter][1] = (*it_vertex)[1];
       local_tmp_vector_vertex_node[counter][2] = (*it_vertex)[2];
       counter++;
      }
     
     // *********************************************************************
     // 3) Create the vertices along the boundary using the target area to
     //    define the distance among them
     // *********************************************************************
     
     // Clear the local containter to recover the nodes ordered using the
     // zeta value
     local_vertex_nodes.clear();

     // At the end of each unrefinement/refinement step store the new nodes
     // on the set that will give rise to the vertices of the new polyline
     // representation
     unsigned nnew_nodes = local_tmp_vector_vertex_node.size();
     for (unsigned i = 0; i < nnew_nodes; i++)
      {
       vertex_coord[0] = local_tmp_vector_vertex_node[i][0];
       vertex_coord[1] = local_tmp_vector_vertex_node[i][1];
       vertex_coord[2] = local_tmp_vector_vertex_node[i][2];
       vertex_nodes.insert(vertex_coord); // Global container
       local_vertex_nodes.insert(vertex_coord);
      }
     
#ifdef OOMPH_HAS_MPI
      if (this->is_mesh_distributed())
       {
        // Add the set of vertices for the boundary, this will help to detect
        // if we need to deal with sub_boundaries and sub_polylines represen.
        sub_vertex_nodes.push_back(local_vertex_nodes);
        // Increase the counter for sub_boundaries
        nsub_boundaries++;
       }
#endif
      
    } // while(nsorted_face_elements < nnon_halo_face_element)
   
   // Now turn into vector for ease of handling...
   unsigned npoly_vertex = vertex_nodes.size();
   tmp_vector_vertex_node.resize(npoly_vertex);
   unsigned count = 0;
   std::set<Vector<double> >::iterator it;
   for(it = vertex_nodes.begin(); it!=vertex_nodes.end(); ++it)
    {
     tmp_vector_vertex_node[count].resize(3);
     tmp_vector_vertex_node[count][0] = (*it)[0];
     tmp_vector_vertex_node[count][1] = (*it)[1];
     tmp_vector_vertex_node[count][2] = (*it)[2];
     ++count;
    }
   
#ifdef OOMPH_HAS_MPI
   // --------- Stuff for the sub_boundaries ----- Begin section ---------
#ifdef PARANOID
   unsigned nsub_boundaries_set = sub_vertex_nodes.size();
   if (nsub_boundaries_set != nsub_boundaries)
     {
      std::ostringstream error_message;
      error_message
       << "The number of found sub-boundaries and the number of counted\n"
       << "sub-boundaries are different:\n"
       << "Number of found sub-boundaries: ("<<nsub_boundaries_set<<")\n"
       << "Number of counted sub-boundaries: ("<<nsub_boundaries<<")\n";
      throw OomphLibError(error_message.str(),
                          "RefineableTriangleMesh::update_polygon_after_restart()",
                          OOMPH_EXCEPTION_LOCATION);
     }
#endif
   
   // Verify if need to deal with sub_boundaries
   if (this->is_mesh_distributed() && nsub_boundaries > 1)
    {
     // Mark the boundary as been splitted in the partition process
     this->Boundary_was_splitted[bound] = true;
     // Resize the vector to store the info. of sub-boundaries
     sub_tmp_vector_vertex_node.resize(nsub_boundaries);
     for (unsigned isub = 0; isub < nsub_boundaries; isub++)
      {
       // Turn info. into vector for ease of handling...
       const unsigned nsubpoly_vertex = sub_vertex_nodes[isub].size();
       sub_tmp_vector_vertex_node[isub].resize(nsubpoly_vertex);
       unsigned subcount = 0;
       std::set<Vector<double> >::iterator subit;
       for(subit = sub_vertex_nodes[isub].begin();
           subit != sub_vertex_nodes[isub].end(); ++subit)
        {
         sub_tmp_vector_vertex_node[isub][subcount].resize(3);
         sub_tmp_vector_vertex_node[isub][subcount][0] = (*subit)[0];
         sub_tmp_vector_vertex_node[isub][subcount][1] = (*subit)[1];
         sub_tmp_vector_vertex_node[isub][subcount][2] = (*subit)[2];
         ++subcount;
        }
      }
    } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
   // --------- Stuff for the sub_boundaries ----- End section ------------
#endif // OOMPH_HAS_MPI
   
   
   // For further processing the three-dimensional vector
   // has to be reduced to a two-dimensional vector
   unsigned n_vertex=tmp_vector_vertex_node.size();

   // Resize the vector for vectices
   vector_vertex_node.resize(n_vertex);
   for(unsigned i=0;i<n_vertex;i++)
    {
     vector_vertex_node[i].resize(2);
     vector_vertex_node[i][0]=tmp_vector_vertex_node[i][1];
     vector_vertex_node[i][1]=tmp_vector_vertex_node[i][2];
    }
   
#ifdef OOMPH_HAS_MPI
   // --------- Stuff for the sub_boundaries ----- Begin section ----------
   // Verify if need to deal with sub_boundaries
   if (this->is_mesh_distributed() && nsub_boundaries > 1)
    {
     // For further processing the three-dimensional vector
     // has to be reduced to a two-dimensional vector
     // Resize the vector to store the info. of sub-boundaries
     sub_vector_vertex_node.resize(nsub_boundaries);
     for (unsigned isub = 0; isub < nsub_boundaries; isub++)
      {
       const unsigned subn_vertex = 
        sub_tmp_vector_vertex_node[isub].size();
       // Resize the vector for vectices
       sub_vector_vertex_node[isub].resize(subn_vertex);
       for(unsigned i=0;i<subn_vertex;i++)
        {
         sub_vector_vertex_node[isub][i].resize(2);
         sub_vector_vertex_node[isub][i][0]=
          sub_tmp_vector_vertex_node[isub][i][1];
         sub_vector_vertex_node[isub][i][1]=
          sub_tmp_vector_vertex_node[isub][i][2];
        }
      }
    } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
   
   // We already have the info. for the sub-boundaries (if necessary)
   // and then we can create the sub-boundaries representations to
   // ease the generation of the mesh by Triangle
   
   // --------- Stuff for the sub_boundaries ----- End section ------------
#endif // OOMPH_HAS_MPI
   
   // *********************************************************************
   // 4) Check for contiguousness
   // *********************************************************************
#ifdef OOMPH_HAS_MPI
   // Only perform this checking if the mesh is not distributed
   // When the mesh is distributed the polylines continuity is
   // addressed with the sort_polylines_helper() method
   if (!this->is_mesh_distributed())
#endif
    {
     if ( p > 0 )
      {
       //Final end point of previous line
       Vector<double> final_vertex_of_previous_segment;
       unsigned n_prev_vertex =
        polygon_pt->curve_section_pt(p-1)->nvertex();
       final_vertex_of_previous_segment =
        polygon_pt->polyline_pt(p-1)->
        vertex_coordinate(n_prev_vertex-1);

       unsigned prev_seg_boundary_id =
        polygon_pt->curve_section_pt(p-1)->boundary_id();

       //Find the error between the final vertex of the previous
       //line and the first vertex of the current line
       double error = 0.0;
       for(unsigned i=0;i<2;i++)
        {
         const double dist =
          final_vertex_of_previous_segment[i] -
          (*vector_vertex_node.begin())[i];
         error += dist*dist;
        }
       error = sqrt(error);

       //If the error is bigger than the tolerance then
       //we probably need to reverse, but better check
       if(error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
        {
         //Find the error between the final vertex of the previous
         //line and the last vertex of the current line
         double rev_error = 0.0;
         for(unsigned i=0;i<2;i++)
          {
           const double dist =
            final_vertex_of_previous_segment[i] -
            (*--vector_vertex_node.end())[i];
           rev_error += dist*dist;
          }
         rev_error = sqrt(rev_error);

         if(rev_error >
            ToleranceForVertexMismatchInPolygons::Tolerable_error)
          {
           // It could be possible that the first segment be reversed and we
           // did not notice it because this check does not apply for the
           // first segment. We can verify if the first segment is reversed
           // by using the vertex number 1
           if (p == 1)
            {
             //Initial end point of previous line
             Vector<double> initial_vertex_of_previous_segment;

             initial_vertex_of_previous_segment =
              polygon_pt->polyline_pt(p-1)->
              vertex_coordinate(0);

             unsigned prev_seg_boundary_id =
              polygon_pt->curve_section_pt(p-1)->boundary_id();

             //Find the error between the initial vertex of the previous
             //line and the first vertex of the current line
             double error = 0.0;
             for(unsigned i=0;i<2;i++)
              {
               const double dist =
                initial_vertex_of_previous_segment[i] -
                (*vector_vertex_node.begin())[i];
               error += dist*dist;
              }
             error = sqrt(error); // Reversed only the previous one

             //If the error is bigger than the tolerance then
             //we probably need to reverse, but better check
             if(error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
              {
               //Find the error between the final vertex of the previous
               //line and the last vertex of the current line
               double rev_error = 0.0;
               for(unsigned i=0;i<2;i++)
                {
                 const double dist =
                  initial_vertex_of_previous_segment[i] -
                  (*--vector_vertex_node.end())[i];
                 rev_error += dist*dist;
                }
               rev_error = sqrt(rev_error); // Reversed both the current one and
               // the previous one

               if (rev_error >
                   ToleranceForVertexMismatchInPolygons::Tolerable_error)
                {
                 std::ostringstream error_stream;
                 error_stream
                  <<"The distance between the first node of the current\n"
                  <<"line segment (boundary " << bound << ") and either end of "
                  << "the previous line segment\n"
                  << "(boundary " << prev_seg_boundary_id << ") is bigger than "
                  << "the desired tolerance " <<
                  ToleranceForVertexMismatchInPolygons::Tolerable_error << ".\n"
                  << "This suggests that the polylines defining the polygonal\n"
                  << "representation are not properly ordered.\n"
                  << "Fail on last vertex of polyline: ("
                  << prev_seg_boundary_id<< ") and\nfirst vertex of polyline ("
                  << bound << ").\nThis should have failed when first trying to"
                  << " construct the\npolygon.\n";
                 throw OomphLibError(error_stream.str(),
                                     "RefineableTriangleMesh::update_polygon_after_restart()",
                                     OOMPH_EXCEPTION_LOCATION);
                }
               else
                {
                 // Reverse both
                 // Reverse the current vector to line up with the previous one
                 std::reverse(vector_vertex_node.begin(),
                              vector_vertex_node.end());
                 polygon_pt->polyline_pt(p-1)->reverse();
                }
              }
             else
              {
               // Reverse the previous one
               polygon_pt->polyline_pt(p-1)->reverse();
              }

            } // if p == 1
           else
            {
             std::ostringstream error_stream;
             error_stream
              <<"The distance between the first node of the current\n"
              <<"line segment (boundary " << bound << ") and either end of "
              <<"the previous line segment\n"
              <<"(boundary " << prev_seg_boundary_id << ") is bigger than the "
              <<"desired tolerance " <<
              ToleranceForVertexMismatchInPolygons::Tolerable_error << ".\n"
              <<"This suggests that the polylines defining the polygonal\n"
              <<"representation are not properly ordered.\n"
              << "Fail on last vertex of polyline: (" << prev_seg_boundary_id
              << ") and\nfirst vertex of polyline (" << bound << ").\n"
              << "This should have failed when first trying to construct the\n"
              << "polygon.\n";
             throw OomphLibError(
              error_stream.str(),
              "RefineableTriangleMesh::update_polygon_after_restart()",
              OOMPH_EXCEPTION_LOCATION);
            }
          }
         else
          {
           //Reverse the current vector to line up with the previous one
           std::reverse(vector_vertex_node.begin(),vector_vertex_node.end());
          }
        } // error
      } // p > 0
    } // is mesh not distributed
   
   // *********************************************************************
   // 5) Update the polylines representation
   // *********************************************************************
   //   if (applied_area_length_constraint)
   // If only applied when there is a change then it keeps the
   // previous polyline representation, it means, it does not delete
   // the boundaries that are not part of the domain. We must update
   // the boundary representation
   {
    n_vertex = vector_vertex_node.size();
    
    // Now update the polyline according to the new vertices
    // The new one representation
    TriangleMeshPolyLine *tmp_polyline_pt =
     new TriangleMeshPolyLine(vector_vertex_node,bound);

    //    for (unsigned h = 0; h < vector_vertex_node.size(); h++)
    //     {
    //       DEBP(h);
    //       DEBP(vector_vertex_node[h][0]);
    //       DEBP(vector_vertex_node[h][1]);
    //     }

    // Create a temporal "curve section" version of the recently created
    // polyline
    TriangleMeshCurveSection *tmp_curve_section_pt = tmp_polyline_pt;

    // Tolerance below which the middle point can be deleted
    // (ratio of deflection to element length)
    double unrefinement_tolerance=
     polygon_pt->polyline_pt(p)->unrefinement_tolerance();

    // Tolerance to add points
    double refinement_tolerance=
     polygon_pt->polyline_pt(p)->refinement_tolerance();

    // Establish refinement and unrefinement tolerance
    tmp_polyline_pt->set_unrefinement_tolerance(
     unrefinement_tolerance);
    tmp_polyline_pt->set_refinement_tolerance(
     refinement_tolerance);

    // Establish the maximum length constraint
    double maximum_length = polygon_pt->polyline_pt(p)->maximum_length();
    tmp_polyline_pt->set_maximum_length(maximum_length);
    
    if (n_vertex >= 2)
     {
      // Pass the connection information from the old polyline to the
      // new one
      this->copy_connection_information(polygon_pt->polyline_pt(p), 
                                        tmp_curve_section_pt);
     }
    
    //Now update the polyline according to the new vertices but
    //first check if the object is allowed to delete the representation
    //or if it should be done by other object
    bool delete_it_on_destructor = false;

    std::set<TriangleMeshCurveSection*>::iterator it =
     this->Free_curve_section_pt.find(polygon_pt->curve_section_pt(p));

    if (it!=this->Free_curve_section_pt.end())
     {
      this->Free_curve_section_pt.erase(it);
      delete polygon_pt->curve_section_pt(p);
      delete_it_on_destructor = true;
     }

    // *****************************************************************
    // Copying the new representation
    polygon_pt->curve_section_pt(p) = tmp_polyline_pt;

    // Update the Boundary - Polyline map
    this->Boundary_curve_section_pt[bound] = polygon_pt->curve_section_pt(p);

    if (delete_it_on_destructor)
     {
      this->Free_curve_section_pt.insert(polygon_pt->curve_section_pt(p));
     }

#ifdef OOMPH_HAS_MPI
    // --------- Stuff for the sub_boundaries ----- Begin section --------
    // Verify if need to deal with sub_boundaries
    if (this->is_mesh_distributed() && nsub_boundaries > 1)
     {
      // Create temporary representations for the boundaries, only to
      // create the mesh when calling Triangle
      // Clear all previous stored data
      this->Boundary_subpolylines[bound].clear();
      // Now create storage for the sub-boundaries
      this->Boundary_subpolylines[bound].resize(nsub_boundaries);
      for (unsigned isub = 0; isub < nsub_boundaries; isub++)
       {
        // Now update the polyline according to the sub set of
        // vertices, set the chunk number of the polyline
        TriangleMeshPolyLine *sub_tmp_polyline_pt =
         new TriangleMeshPolyLine(sub_vector_vertex_node[isub], bound, isub);

        // Add the sub-polyline to the container to represent the boundary
        // in parts
        this->Boundary_subpolylines[bound][isub] = sub_tmp_polyline_pt;
        
        // No need to send the unrefinement/refinement and maximum
        // length constraints since these are only temporary
        // representations. These polylines can be deleted once the
        // new polygons that represent the distributed domain have
        // been created
        
       } // for (isub < nsub_boundaries)
      
     } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
    // --------- Stuff for the sub_boundaries ----- End section ---------
#endif // OOMPH_HAS_MPI

   } // update polyline representation
   
   // Delete the allocated memory for the geometric object that
   // represents the curvilinear boundary
   delete mesh_geom_obj_pt;
   
  } // npolyline
 
 // Cleanup the face mesh
 for(unsigned p=0;p<n_polyline;p++)
  {
   face_mesh_pt[p]->flush_node_storage();
   delete face_mesh_pt[p];
  }
  
}


//======================================================================
/// \short Updates the open curve representation after restart
//======================================================================
template <class ELEMENT>
void RefineableTriangleMesh<ELEMENT>::
update_open_curve_after_restart(TriangleMeshOpenCurve* &open_curve_pt)
{
 // **********************************************************************
 // 1) Get the vertices along the boundaries ids of the polylines and
 //    update them
 // **********************************************************************
 
 // (1.1) Get the face mesh representation
 Vector<Mesh*> face_mesh_pt;
 get_face_mesh_representation(open_curve_pt,face_mesh_pt);
 
 // (1.2) Create vertices of the polylines by using the vertices of the
 //       FaceElements
 Vector<double> vertex_coord(3); // zeta,x,y
 Vector<double> bound_left(1);
 Vector<double> bound_right(1);

 const unsigned ncurve_section = open_curve_pt->ncurve_section(); 
 // Go for each curve section
 for(unsigned cs = 0; cs < ncurve_section; cs++)
  {
   // Get the MeshAsGeomObject representation just once per polyline,
   // this object is only used by the
   // refine_boundary_constrained_by_target_area() method. We get it here
   // to ensure that all processors (in a distributed context) get this
   // representation just once, and because an AllToAll MPI communication
   // is used in this calling
   MeshAsGeomObject* mesh_geom_obj_pt=new MeshAsGeomObject(face_mesh_pt[cs]);

   //Get the boundary id
   const unsigned bound = open_curve_pt->curve_section_pt(cs)->boundary_id();
   
   /// Use a vector of vector for vertices and target areas to deal
   /// with the cases when the boundaries are split bn the
   /// distribution process. Internal boundaries may be completely or
   /// partially overlapped by shared boundaries

   // Loop over the face elements and add their vertices (they are
   // automatically sorted because of the set)
   const unsigned nface_element = face_mesh_pt[cs]->nelement();   
   // Store the non halo elements and the element at the other side of
   // the boundary (whatever it be halo or not), the first will be the
   // ones from which we will get the vertices (in even position)
   Vector<FiniteElement*> non_halo_doubled_face_element_pt;

   // Map to store the index of the face element on a boundary
   std::map<FiniteElement*,unsigned> face_element_index_on_boundary;

   // Map to know the already sorted face elements
   std::map<FiniteElement*,bool> face_element_done;

   for(unsigned ef = 0; ef < nface_element; ++ef)
    {
     FiniteElement* ele_face_pt = face_mesh_pt[cs]->finite_element_pt(ef);
     
     // Skip the halo elements (not used as base elements, only
     // include those elements which one of its counterparts -- at the
     // other side of the boundary -- is non halo)
#ifdef OOMPH_HAS_MPI
     if (this->is_mesh_distributed())
      {
       // Only work with non-halo elements
       if (ele_face_pt->is_halo()) {continue;}
      }
#endif

     // Check if not already done
     if (!face_element_done[ele_face_pt])
      {
       // Add the element and look for the element at the other side
       // of the boundary to add it immediately after the new added
       // element
       non_halo_doubled_face_element_pt.push_back(ele_face_pt);
       // Create the map of the face element with the index
       face_element_index_on_boundary[ele_face_pt] = ef;
       // Mark the current element as done
       face_element_done[ele_face_pt] = true;
       // Get the number of nodes
       const unsigned nnodes = ele_face_pt->nnode();
       // Get the left and right node to look for the elements at the
       // other side of the boundary
       Node* left_node_pt = ele_face_pt->node_pt(0);
       Node* right_node_pt = ele_face_pt->node_pt(nnodes-1);

#ifdef PARANOID
       // Flag to know if the element at the other side of the
       // boundary was found
       bool found_other_side_face_ele = false;
#endif
       for (unsigned iface = 0; iface < nface_element; iface++)
        {
         // Get the candidate face element
         FiniteElement *cele_face_pt = 
          face_mesh_pt[cs]->finite_element_pt(iface);
         // Check if not already done
         if (!face_element_done[cele_face_pt])
          {
           Node* cleft_node_pt = cele_face_pt->node_pt(0);
           Node* cright_node_pt = cele_face_pt->node_pt(nnodes-1);
           
           // Check if the nodes are the same
           if ((left_node_pt == cleft_node_pt && 
                right_node_pt == cright_node_pt) ||
               (left_node_pt == cright_node_pt && 
                right_node_pt == cleft_node_pt))
            {
             // Add the element to the storage
             non_halo_doubled_face_element_pt.push_back(cele_face_pt);
             // ... and mark the element as done
             face_element_done[cele_face_pt] = true;
             // Create the map of the face element with the index
             face_element_index_on_boundary[cele_face_pt] = iface;
#ifdef PARANOID
             // Set the flag of found other side face element
             found_other_side_face_ele = true;
#endif
             break;
            }
          }
        } // (iface < nface_element)

#ifdef PARANOID
       if (!found_other_side_face_ele)
        {
         std::ostringstream error_message;
         error_message
          << "The face element at the other side of the boundary ("
          << bound << ") was not found!!\n"
          << "These are the nodes of the face element:\n"
          << "("<<left_node_pt->x(0)<<", "<<left_node_pt->x(1)<<") "
          << "and ("<<right_node_pt->x(0)<<","<<right_node_pt->x(1)<<")\n\n";
         throw OomphLibError(error_message.str(),
          "RefineableTriangleMesh::update_open_curve_after_restart()",
                             OOMPH_EXCEPTION_LOCATION);
        }
#endif
      } // if (!face_ele_done[ele_face_pt])
     
    } // (ef < nface_element)
   
   // Clear the map of the already done face elements
   // This will now be used to sort the face elements
   face_element_done.clear();

   // Set of coordinates that are on the boundary
   // The entries are sorted on first entry in vector which stores
   // the boundary coordinate so the vertices come out in order!
   std::set<Vector<double> > vertex_nodes;

   // Vector to store the vertices, transfer the sorted vertices from the
   // set to this vector, --- including the z-value ---
   Vector<Vector<double> > tmp_vector_vertex_node;

   // Vector to store the coordinates of the polylines, same as the
   // tmp_vector_vertex_node vector (after adding more nodes) but
   // --- without the z-value ---, used to re-generate the polylines
   Vector<Vector<double> > vector_vertex_node;

#ifdef OOMPH_HAS_MPI
   // Indicates if the set of vertices give rise to a internal
   // boundary that will be used as shared boundary or as normal
   // internal boundary -- Only used to deal with internal boundaries
   // in a distributed scheme
   std::vector<bool> internal_to_shared_boundary;

   // --------- Stuff to deal with splitted boundaries ---------- Begin -----
   // Set of coordinates that are on the boundary (splitted boundary version)
   // The first vector is used to allocate the points for each sub-boundary
   // Set entries are ordered on first entry in vector which stores
   // the boundary coordinate so the vertices come out in order!
   Vector<std::set<Vector<double> > > sub_vertex_nodes;

   // Vector to store the vertices, transfer the sorted vertices from the
   // set (sub_vertex_nodes) to this vector, --- including the z-value ---
   Vector<Vector<Vector<double> > > sub_tmp_vector_vertex_node;

   // Vector to store the coordinates of the polylines that will represent
   // the splitted boundary. Used to pass the info. from sub_vertex_nodes
   // but --- without the z-value ---, used to generate the sub-polylines
   Vector<Vector<Vector<double> > > sub_vector_vertex_node;

   // --------- Stuff to deal with splitted boundaries ----------- End ------
#endif

   // Sort face elements, separate those with both nonhalo face
   // elements from those with one halo and one nonhalo face element
   
   // Number of done face elements
   unsigned nsorted_face_elements = 0;

#ifdef OOMPH_HAS_MPI
   // Counter for sub_boundaries
   unsigned nsub_boundaries = 0;
#endif // #ifdef OOMPH_HAS_MPI

   // Total number of non halo double face element
   const unsigned nnon_halo_doubled_face_ele = 
    non_halo_doubled_face_element_pt.size();

   // Continue until all the face elements have been sorted
   // This while is to deal with the cases of splitted boundaries
   while(nsorted_face_elements < nnon_halo_doubled_face_ele)
    {
     // Get and initial face element
     FiniteElement* ele_face_pt = 0;
     FiniteElement* repeated_ele_face_pt = 0;
#ifdef PARANOID
     bool found_initial_face_element = false;
#endif

     // Flag to know if we are working with a face element which the
     // face element at the other side of the boundary is also non
     // halo
     bool both_root_face_elements_are_nonhalo = false;
     
     unsigned iface = 0;
     for (iface = 0; iface < nnon_halo_doubled_face_ele; iface+=2)
      {
       ele_face_pt = non_halo_doubled_face_element_pt[iface];
       // If not done then take it as initial face element
       if (!face_element_done[ele_face_pt])
        {
         // Mark it as done
         face_element_done[ele_face_pt] = true;
         // Get the other side boundary face element
         repeated_ele_face_pt = non_halo_doubled_face_element_pt[iface+1];
         // ... also mark as done the repeated face element
         face_element_done[repeated_ele_face_pt] = true;
         
#ifdef OOMPH_HAS_MPI
         if (!repeated_ele_face_pt->is_halo())
          {both_root_face_elements_are_nonhalo = true;}
#endif // #ifdef OOMPH_HAS_MPI
         
         // Plus two because internal boundaries have
         // two face elements per each edge
         nsorted_face_elements+=2;
         iface+=2;
#ifdef PARANOID
         // And set the flag to true
         found_initial_face_element = true;
#endif
         break;
        }
      }
     
#ifdef PARANOID
     if (!found_initial_face_element)
      {
       std::ostringstream error_message;
       error_message
        <<"Could not find an initial face element for the current segment\n";
       // << "----- Possible memory leak -----\n";
       throw OomphLibError(error_message.str(),
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
      }
#endif

     // Local set of coordinates that are on the boundary Set entries
     // are ordered on first entry in vector which stores the boundary
     // coordinate so the vertices come out in order
     std::set<Vector<double> > local_vertex_nodes;
     
     // Vector to store the vertices, transfer the sorted vertices from the
     // set (local) to this vector (local), --- including the z-value ---
     Vector<Vector<double> > local_tmp_vector_vertex_node;
     
     // ------------------------------------------------------------------
     // ------------------------------------------------------------------
     // Add the vertices of the initial face element to the set of local 
     // sorted vertices
     // ------------------------------------------------------------------
     // ------------------------------------------------------------------
     const unsigned nnode = ele_face_pt->nnode();
     // Add the left-hand node to the set:
     // Boundary coordinate
     ele_face_pt->node_pt(0)->get_coordinates_on_boundary(bound,bound_left);
     vertex_coord[0] = bound_left[0];
     
     // Actual coordinates
     for(unsigned i=0;i<2;i++)
      {
       vertex_coord[i+1] = ele_face_pt->node_pt(0)->x(i);
      }
     local_vertex_nodes.insert(vertex_coord);
     
     // Add the right-hand node to the set:
     // Boundary coordinate
     ele_face_pt->node_pt(nnode-1)->get_coordinates_on_boundary(bound,
                                                                bound_right);
     vertex_coord[0] = bound_right[0];
     
     // Actual coordinates
     for(unsigned i=0;i<2;i++)
      {
       vertex_coord[i+1] = ele_face_pt->node_pt(nnode-1)->x(i);
      }
     local_vertex_nodes.insert(vertex_coord);
     
     // The initial and final node on the set
     Node *first_node_pt = ele_face_pt->node_pt(0);
     Node *last_node_pt = ele_face_pt->node_pt(nnode-1);
     
     // Continue iterating if a new face element has been added to the
     // list
     bool face_element_added = false;
     
     // While a new face element has been added to the set of sorted
     // face elements then re-iterate
     do
      {
       // Start from the next face elements since we have already
       // added the previous one as the initial face element (any
       // previous face element had to be added on previous
       // iterations)
       for (unsigned iiface=iface;
            iiface<nnon_halo_doubled_face_ele;iiface+=2)
        {
         face_element_added = false;
         ele_face_pt = non_halo_doubled_face_element_pt[iiface];
         
         // Check that the face element with which we are working has
         // the same conditions as the root face element (both faces
         // are nonhalo or one face is halo and the other nonhalo)
         
         // Get the face element at the other side of the boundary
         repeated_ele_face_pt = non_halo_doubled_face_element_pt[iiface+1];
         bool both_face_elements_are_nonhalo = false;
         
#ifdef OOMPH_HAS_MPI
         if (!repeated_ele_face_pt->is_halo())
          {both_face_elements_are_nonhalo = true;}
#endif // #ifdef OOMPH_HAS_MPI
         
         if (!face_element_done[ele_face_pt] && 
             (both_face_elements_are_nonhalo == 
              both_root_face_elements_are_nonhalo))
          {
           // Get each individual node to check if they are contiguous
           const unsigned nlnode = ele_face_pt->nnode();
           Node* left_node_pt = ele_face_pt->node_pt(0);
           Node* right_node_pt = ele_face_pt->node_pt(nlnode-1);
                 
           if (left_node_pt == first_node_pt)
            {
             first_node_pt = right_node_pt;
             face_element_added = true;
            }
           else if (left_node_pt == last_node_pt)
            {
             last_node_pt = right_node_pt;
             face_element_added = true;
            }
           else if (right_node_pt == first_node_pt)
            {
             first_node_pt = left_node_pt;
             face_element_added = true;
            }
           else if (right_node_pt == last_node_pt)
            {
             last_node_pt = left_node_pt;
             face_element_added = true;
            }
           
           if (face_element_added)
            {
             // Add the left-hand node to the set:
             // Boundary coordinate
             left_node_pt->get_coordinates_on_boundary(bound,bound_left);
             vertex_coord[0] = bound_left[0];

             // Actual coordinates
             for(unsigned i=0;i<2;i++)
              {
               vertex_coord[i+1] = left_node_pt->x(i);
              }
             local_vertex_nodes.insert(vertex_coord);

             // Add the right-hand nodes to the set:
             // Boundary coordinate
             right_node_pt->get_coordinates_on_boundary(bound,bound_right);
             vertex_coord[0] = bound_right[0];

             // Actual coordinates
             for(unsigned i=0;i<2;i++)
              {
               vertex_coord[i+1] = right_node_pt->x(i);
              }
             local_vertex_nodes.insert(vertex_coord);
             
             // Mark as done only if one of its nodes has been
             // added to the list
             face_element_done[ele_face_pt] = true;
             // .. also mark as done the face element at the othe side of
             // the boundary
             repeated_ele_face_pt = non_halo_doubled_face_element_pt[iiface+1];
             face_element_done[repeated_ele_face_pt] = true;
             // ... and increase the number of sorted face elements
             nsorted_face_elements+=2;
             
             break;
            }
           
          } // if (!face_element_done[[ele_face_pt])
        } // for (iiface<nnon_halo_doubled_face_ele)
      }while(face_element_added &&
             (nsorted_face_elements < nnon_halo_doubled_face_ele));
     
     // -------------------------------------------------------------
     // At this point we already have a sorted set of nodes and can
     // be used to peform the unrefinement and refinement procedures
     // -------------------------------------------------------------
     
     // Get the number of nodes on the list
     const unsigned nlocal_nodes = local_vertex_nodes.size();
     // Change representation to vector for easy of handling ...
     local_tmp_vector_vertex_node.resize(nlocal_nodes);
         
     // Copy the vertices of the nodes
     unsigned counter = 0;
     std::set<Vector<double> >::iterator it_vertex;
     for (it_vertex = local_vertex_nodes.begin();
          it_vertex != local_vertex_nodes.end();
          it_vertex++)
      {
       local_tmp_vector_vertex_node[counter].resize(3);
       local_tmp_vector_vertex_node[counter][0] = (*it_vertex)[0];
       local_tmp_vector_vertex_node[counter][1] = (*it_vertex)[1];
       local_tmp_vector_vertex_node[counter][2] = (*it_vertex)[2];
       counter++;
      }
     
     // The unrefinement and refinement process needs to be applied
     // from the bottom-left node since the internal open curve could
     // lie on the shared boundaries
     if (local_tmp_vector_vertex_node[nlocal_nodes-1][2] < 
         local_tmp_vector_vertex_node[0][2])
      {
       std::reverse(local_tmp_vector_vertex_node.begin(),
                    local_tmp_vector_vertex_node.end());
      }
     else if (local_tmp_vector_vertex_node[nlocal_nodes-1][2] == 
              local_tmp_vector_vertex_node[0][2])
      {
       if (local_tmp_vector_vertex_node[nlocal_nodes-1][1] < 
           local_tmp_vector_vertex_node[0][1])
        {
         std::reverse(local_tmp_vector_vertex_node.begin(),
                      local_tmp_vector_vertex_node.end());
        }
      }
     
     // ****************************************************************
     // 3) Create the vertices along the boundary using the target
     // area to define the distance among them
     // ****************************************************************
     
     // Clear the local containter to recover the nodes ordered using
     // the zeta value
     local_vertex_nodes.clear();

     // At the end of each unrefinement/refinement step store the new
     // nodes on the set that will give rise to the vertices of the
     // new polyline representation
     const unsigned nnew_nodes = local_tmp_vector_vertex_node.size();
     for (unsigned i = 0; i < nnew_nodes; i++)
      {
       vertex_coord[0] = local_tmp_vector_vertex_node[i][0];
       vertex_coord[1] = local_tmp_vector_vertex_node[i][1];
       vertex_coord[2] = local_tmp_vector_vertex_node[i][2];
       vertex_nodes.insert(vertex_coord); // Global container
       local_vertex_nodes.insert(vertex_coord);
      }
     
#ifdef OOMPH_HAS_MPI
     if (this->is_mesh_distributed())
      {
       // Add the set of vertices for the boundary, this will help to
       // detect if we need to deal with sub_boundaries and
       // sub_polylines representations
       sub_vertex_nodes.push_back(local_vertex_nodes);
       // Increase the counter for sub_boundaries
       nsub_boundaries++;
       
       // Mark if the polyline created by these vertices will be used
       // as a shared boundary or as an internal boundary
       if (both_root_face_elements_are_nonhalo)
        {internal_to_shared_boundary.push_back(false);}
       else
        {internal_to_shared_boundary.push_back(true);}
      }
#endif
     
    } // while(nsorted_face_elements < nnon_halo_doubled_face_ele)
      // This while is in charge of sorting all the face elements to
      // create the new representation of the polyline (also deals
      // with the sub-boundary cases)
   
   // Now turn into vector for ease of handling...
   const unsigned npoly_vertex = vertex_nodes.size();
   tmp_vector_vertex_node.resize(npoly_vertex);
   unsigned count = 0;
   std::set<Vector<double> >::iterator it;
   for (it = vertex_nodes.begin(); it!=vertex_nodes.end(); ++it)
    {
     tmp_vector_vertex_node[count].resize(3);
     tmp_vector_vertex_node[count][0] = (*it)[0];
     tmp_vector_vertex_node[count][1] = (*it)[1];
     tmp_vector_vertex_node[count][2] = (*it)[2];
     ++count;
    }
   
#ifdef OOMPH_HAS_MPI
   // Check that the number of set of vertices marked to be shared or
   // internal boundaries be the same as the total number of
   // sub-boundaries
#ifdef PARANOID
   const unsigned nsub_boundaries_set = sub_vertex_nodes.size();
   const unsigned ninternal_to_shared_boundaries = 
    internal_to_shared_boundary.size();
   if (nsub_boundaries_set != ninternal_to_shared_boundaries)
    {
     std::ostringstream error_message;
     error_message
      << "The number of found sub-boundaries and the number of marked "
      << "internal\nboundaries are different\n"
      << "Number of found sub-boundaries: ("<<nsub_boundaries_set<<")\n"
      << "Number of marked internal boundaries: ("
      << ninternal_to_shared_boundaries << ")\n\n";
     throw OomphLibError(error_message.str(),
       "RefineableTriangleMesh::update_open_curve_after_restart()",
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   
   // --------- Stuff for the sub_boundaries ----- Begin section -------
#ifdef PARANOID
   if (nsub_boundaries_set != nsub_boundaries)
    {
     std::ostringstream error_message;
     error_message
      << "The number of found sub-boundaries and the number of counted\n"
      << "sub-boundaries are different:\n"
      << "Number of found sub-boundaries: ("<<nsub_boundaries_set<<")\n"
      << "Number of counted sub-boundaries: ("<<nsub_boundaries<<")\n\n";
     throw OomphLibError(error_message.str(),
       "RefineableTriangleMesh::update_open_curve_after_restart()",
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   
   // Verify if need to deal with sub_boundaries
   if (this->is_mesh_distributed() && nsub_boundaries > 1)
    {
     // Mark the boundary as been splitted in the partition process
     this->Boundary_was_splitted[bound] = true;
     // Resize the vector to store the info. of sub-boundaries
     sub_tmp_vector_vertex_node.resize(nsub_boundaries);
     for (unsigned isub = 0; isub < nsub_boundaries; isub++)
      {
       // Turn info. into vector for ease of handling...
       const unsigned nsubpoly_vertex = sub_vertex_nodes[isub].size();
       sub_tmp_vector_vertex_node[isub].resize(nsubpoly_vertex);
       unsigned subcount = 0;
       std::set<Vector<double> >::iterator subit;
       for(subit = sub_vertex_nodes[isub].begin();
           subit != sub_vertex_nodes[isub].end(); ++subit)
        {
         sub_tmp_vector_vertex_node[isub][subcount].resize(3);
         sub_tmp_vector_vertex_node[isub][subcount][0] = (*subit)[0];
         sub_tmp_vector_vertex_node[isub][subcount][1] = (*subit)[1];
         sub_tmp_vector_vertex_node[isub][subcount][2] = (*subit)[2];
         ++subcount;
        }
      }
    } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
   // --------- Stuff for the sub_boundaries ----- End section ----------
#endif // OOMPH_HAS_MPI

   // For further processing the three-dimensional vector has to be
   // reduced to a two-dimensional vector
   unsigned n_vertex=tmp_vector_vertex_node.size();
   
   // Resize the vector for vectices
   vector_vertex_node.resize(n_vertex);
   for(unsigned i=0;i<n_vertex;i++)
    {
     vector_vertex_node[i].resize(2);
     vector_vertex_node[i][0]=tmp_vector_vertex_node[i][1];
     vector_vertex_node[i][1]=tmp_vector_vertex_node[i][2];
    }
   
#ifdef OOMPH_HAS_MPI
   // --------- Stuff for the sub_boundaries ----- Begin section ----------
   // Verify if need to deal with sub_boundaries
   if (this->is_mesh_distributed() && nsub_boundaries > 1)
    {
     // For further processing the three-dimensional vector
     // has to be reduced to a two-dimensional vector
     // Resize the vector to store the info. of sub-boundaries
     sub_vector_vertex_node.resize(nsub_boundaries);
     for (unsigned isub = 0; isub < nsub_boundaries; isub++)
      {
       const unsigned subn_vertex = 
        sub_tmp_vector_vertex_node[isub].size();
       // Resize the vector for vectices
       sub_vector_vertex_node[isub].resize(subn_vertex);
       for(unsigned i=0;i<subn_vertex;i++)
        {
         sub_vector_vertex_node[isub][i].resize(2);
         sub_vector_vertex_node[isub][i][0]=
          sub_tmp_vector_vertex_node[isub][i][1];
         sub_vector_vertex_node[isub][i][1]=
          sub_tmp_vector_vertex_node[isub][i][2];
        }
      }
    } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
   
   // We already have the info. for the sub-boundaries (if necessary) and
   // then we can create the sub-boundaries representations to ease the
   // generation of the mesh by Triangle
   
   // --------- Stuff for the sub_boundaries ----- End section ------------
#endif // OOMPH_HAS_MPI
   
   // *********************************************************************
   // 4) Check for contiguousness
   // *********************************************************************
#ifdef OOMPH_HAS_MPI
   // Only perform this checking if the mesh is not distributed
   // When the mesh is distributed the polylines continuity is
   // addressed with the sort_polylines_helper() method
   if (!this->is_mesh_distributed())
#endif
    {
     if ( cs > 0 )
      {
       //Final end point of previous line
       Vector<double> final_vertex_of_previous_segment;
       unsigned n_prev_vertex =
        open_curve_pt->curve_section_pt(cs-1)->nvertex();
       final_vertex_of_previous_segment =
        open_curve_pt->polyline_pt(cs-1)->
        vertex_coordinate(n_prev_vertex-1);

       unsigned prev_seg_boundary_id =
        open_curve_pt->curve_section_pt(cs-1)->boundary_id();
       
       //Find the error between the final vertex of the previous
       //line and the first vertex of the current line
       double error = 0.0;
       for(unsigned i=0;i<2;i++)
        {
         const double dist =
          final_vertex_of_previous_segment[i] -
          (*vector_vertex_node.begin())[i];
         error += dist*dist;
        }
       error = sqrt(error);
       
       //If the error is bigger than the tolerance then
       //we probably need to reverse, but better check
       if(error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
        {
         //Find the error between the final vertex of the previous
         //line and the last vertex of the current line
         double rev_error = 0.0;
         for(unsigned i=0;i<2;i++)
          {
           const double dist =
            final_vertex_of_previous_segment[i] -
            (*--vector_vertex_node.end())[i];
           rev_error += dist*dist;
          }
         rev_error = sqrt(rev_error);
         
         if(rev_error >
            ToleranceForVertexMismatchInPolygons::Tolerable_error)
          {
           // It could be possible that the first segment be reversed and we
           // did not notice it because this check does not apply for the
           // first segment. We can verify if the first segment is reversed
           // by using the vertex number 1
           if (cs == 1)
            {
             //Initial end point of previous line
             Vector<double> initial_vertex_of_previous_segment;
             
             initial_vertex_of_previous_segment =
              open_curve_pt->polyline_pt(cs-1)->vertex_coordinate(0);
             
             unsigned prev_seg_boundary_id =
              open_curve_pt->curve_section_pt(cs-1)->boundary_id();
             
             //Find the error between the initial vertex of the previous
             //line and the first vertex of the current line
             double error = 0.0;
             for(unsigned i=0;i<2;i++)
              {
               const double dist =
                initial_vertex_of_previous_segment[i] -
                (*vector_vertex_node.begin())[i];
               error += dist*dist;
              }
             error = sqrt(error); // Reversed only the previous one
             
             //If the error is bigger than the tolerance then
             //we probably need to reverse, but better check
             if(error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
              {
               //Find the error between the final vertex of the previous
               //line and the last vertex of the current line
               double rev_error = 0.0;
               for(unsigned i=0;i<2;i++)
                {
                 const double dist =
                  initial_vertex_of_previous_segment[i] -
                  (*--vector_vertex_node.end())[i];
                 rev_error += dist*dist;
                }
               rev_error = sqrt(rev_error); // Reversed both the current 
                                            // one and the previous one
               
               if (rev_error >
                   ToleranceForVertexMismatchInPolygons::Tolerable_error)
                {
                 std::ostringstream error_stream;
                 error_stream
                  <<"The distance between the first node of the current\n"
                  <<"line segment (boundary "<<bound<<") and either end of "
                  <<"the previous line segment\n"
                  <<"(boundary "<<prev_seg_boundary_id<<") is bigger than"
                  << " the desired tolerance " <<
                  ToleranceForVertexMismatchInPolygons::Tolerable_error<<".\n"
                  <<"This suggests that the polylines defining the polygonal\n"
                  <<"representation are not properly ordered.\n"
                  <<"Fail on last vertex of polyline: ("
                  <<prev_seg_boundary_id<<") and\nfirst vertex of polyline ("
                  <<bound<< ").\nThis should have failed when first trying to "
                  <<"construct the\npolygon.\n";
                 throw OomphLibError(error_stream.str(),
         "RefineableTriangleMesh::update_open_curve_after_restart()",
                                     OOMPH_EXCEPTION_LOCATION);
                }
               else
                {
                 // Reverse both
                 // Reverse the current vector to line up with the previous one
                 std::reverse(vector_vertex_node.begin(),
                              vector_vertex_node.end());
                 open_curve_pt->polyline_pt(cs-1)->reverse();
                }
              }
             else
              {
               // Reverse the previous one
               open_curve_pt->polyline_pt(cs-1)->reverse();
              }
             
            } // if (cs == 1)
           else
            {
             std::ostringstream error_stream;
             error_stream
              <<"The distance between the first node of the current\n"
              <<"line segment (boundary " << bound << ") and either end of "
              <<"the previous line segment\n"
              <<"(boundary " << prev_seg_boundary_id << ") is bigger than the "
              <<"desired tolerance " <<
              ToleranceForVertexMismatchInPolygons::Tolerable_error << ".\n"
              <<"This suggests that the polylines defining the polygonal\n"
              <<"representation are not properly ordered.\n"
              <<"Fail on last vertex of polyline: (" << prev_seg_boundary_id
              <<") and\nfirst vertex of polyline (" << bound << ").\n"
              <<"This should have failed when first trying to construct the\n"
              <<"polygon.\n";
             throw OomphLibError(
              error_stream.str(),
        "RefineableTriangleMesh::update_open_curve_after_restart()",
              OOMPH_EXCEPTION_LOCATION);
            }
          }
         else
          {
           //Reverse the current vector to line up with the previous one
           std::reverse(vector_vertex_node.begin(),vector_vertex_node.end());
          }
        } // error
      } // (cs > 0)
    } // is mesh not distributed
   
   //   DEBP(applied_area_length_constraint);
   //   DEBP(p);
   //   getchar();
   // *********************************************************************
   // 5) Update the polylines representation
   // *********************************************************************
   //   if (applied_area_length_constraint)
   // If only applied when there is a change then it keeps the
   // previous polyline representation, it means, it does not delete
   // the boundaries that are not part of the domain. We must update
   // the boundary representation
   {
    n_vertex = vector_vertex_node.size();
    
    // Now update the polyline according to the new vertices
    // The new one representation
    TriangleMeshPolyLine *tmp_polyline_pt =
     new TriangleMeshPolyLine(vector_vertex_node,bound);
    
    // Create a temporal "curve section" version of the recently created
    // polyline
    TriangleMeshCurveSection *tmp_curve_section_pt = tmp_polyline_pt;
    
    // Tolerance below which the middle point can be deleted
    // (ratio of deflection to element length)
    double unrefinement_tolerance=
     open_curve_pt->polyline_pt(cs)->unrefinement_tolerance();
    
    // Tolerance to add points
    double refinement_tolerance=
     open_curve_pt->polyline_pt(cs)->refinement_tolerance();
    
    // Establish refinement and unrefinement tolerance
    tmp_polyline_pt->set_unrefinement_tolerance(unrefinement_tolerance);
    tmp_polyline_pt->set_refinement_tolerance(refinement_tolerance);
    
    // Establish the maximum length constraint
    double maximum_length = open_curve_pt->polyline_pt(cs)->maximum_length();
    tmp_polyline_pt->set_maximum_length(maximum_length);
        
    if (n_vertex >= 2)
     {
      // Pass the connection information from the old polyline to the
      // new one
      this->copy_connection_information(open_curve_pt->polyline_pt(cs), 
                                        tmp_curve_section_pt);
     }
    
    //Now update the polyline according to the new vertices but first
    //check if the object is allowed to delete the representation or
    //if it should be done by other object
    bool delete_it_on_destructor = false;
    
    std::set<TriangleMeshCurveSection*>::iterator it =
     this->Free_curve_section_pt.find(open_curve_pt->curve_section_pt(cs));
    
    if (it!=this->Free_curve_section_pt.end())
     {
      this->Free_curve_section_pt.erase(it);
      delete open_curve_pt->curve_section_pt(cs);
      delete_it_on_destructor = true;
     }
    
    // *****************************************************************
    // Copying the new representation
    open_curve_pt->curve_section_pt(cs) = tmp_polyline_pt;
    
    // Update the Boundary - Polyline map
    this->Boundary_curve_section_pt[bound]=open_curve_pt->curve_section_pt(cs);
    
    if (delete_it_on_destructor)
     {
      this->Free_curve_section_pt.insert(open_curve_pt->curve_section_pt(cs));
     }
    
#ifdef OOMPH_HAS_MPI
    
    // If there are not sub-boundaries mark the boundary if need to be
    // trated as shared or as internal boundary
    if (this->is_mesh_distributed() && nsub_boundaries == 1)
     {
      // Clear all previous stored data
      this->Boundary_marked_as_shared_boundary[bound].clear();
      
      // .. and store the flag for the boundary
      this->Boundary_marked_as_shared_boundary[bound].push_back(
       internal_to_shared_boundary[0]);
     }
    // --------- Stuff for the sub_boundaries ----- Begin section --------
    // Verify if need to deal with sub_boundaries
    else if (this->is_mesh_distributed() && nsub_boundaries > 1)
     {
      // Create temporary representations for the boundaries, only to
      // create the mesh when calling Triangle
      // Clear all previous stored data
      this->Boundary_subpolylines[bound].clear();
      // Now create storage for the sub-boundaries
      this->Boundary_subpolylines[bound].resize(nsub_boundaries);
      
      // Clear all previous stored data
      this->Boundary_marked_as_shared_boundary[bound].clear();
      // Create storage to mark the internal boundaries as shared
      // boundaries
      this->Boundary_marked_as_shared_boundary[bound].resize(nsub_boundaries);
      for (unsigned isub = 0; isub < nsub_boundaries; isub++)
       {
        // Now update the polyline according to the sub set of
        // vertices, set the chunk number of the polyline
        TriangleMeshPolyLine *sub_tmp_polyline_pt =
         new TriangleMeshPolyLine(sub_vector_vertex_node[isub], bound, isub);
        
        // Add the sub-polyline to the container to represent the
        // boundary in parts
        this->Boundary_subpolylines[bound][isub] = sub_tmp_polyline_pt;
        
        // Copy the flag that mark the boundary as internal or as
        // shared bound
        this->Boundary_marked_as_shared_boundary[bound][isub] = 
         internal_to_shared_boundary[isub];
        
        // No need to send the unrefinement/refinement and maximum
        // length constraints since these are only temporary
        // representations
        
       }
      
     } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
    // --------- Stuff for the sub_boundaries ----- End section ---------
#endif // OOMPH_HAS_MPI
    
   } // update polyline representation
   
   // Delete the allocated memory for the geometric object
   // that represents the curvilinear boundary
   delete mesh_geom_obj_pt;
   
  } // npolyline

 // Cleanup the face mesh
 for(unsigned p = 0; p < ncurve_section; p++)
  {
   face_mesh_pt[p]->flush_node_storage();
   delete face_mesh_pt[p];
  }
 
}

#ifdef OOMPH_HAS_MPI
//======================================================================
/// \short Updates the shared polylines representation after restart
//======================================================================
template <class ELEMENT>
void RefineableTriangleMesh<ELEMENT>::
update_shared_curve_after_restart(Vector<TriangleMeshPolyLine*> 
                                  &vector_polyline_pt)
{ 
 // Go through all the shared boundaries/polylines
 const unsigned npolylines = vector_polyline_pt.size();
 for (unsigned pp = 0; pp < npolylines; pp++)
  {
   // Get the boundary of the current polyline
   const unsigned b = vector_polyline_pt[pp]->boundary_id();
      
   // Get the edges of the shared boundary elements that create the
   // shared boundary and store the shared boundary elements from where
   // were created
   std::map<std::pair<Node*, Node*>, FiniteElement*> halo_edge_element_pt;
   std::map<std::pair<Node*, Node*>, FiniteElement*> nonhalo_edge_element_pt;
   
   // Store the nodes that define the edges
   Vector<Node*> halo_edge_nodes_pt;
   Vector<Node*> nonhalo_edge_nodes_pt;
   
   // Go through the shared boundary elements and store their edges
   const unsigned nshared_bound_ele = this->nshared_boundary_element(b);   
   for (unsigned e = 0; e < nshared_bound_ele; e++)
    {
     // Get the shared boundary element
     FiniteElement* current_ele_pt = this->shared_boundary_element_pt(b, e);
     
     // Get the corner nodes, the first three nodes
     Node *first_node_pt = current_ele_pt->node_pt(0);
     Node *second_node_pt = current_ele_pt->node_pt(1);
     Node *third_node_pt = current_ele_pt->node_pt(2);
     
     // Check if the elements is halo
     if (!current_ele_pt->is_halo())
      {       
       // Store the edges
       nonhalo_edge_nodes_pt.push_back(first_node_pt);
       nonhalo_edge_nodes_pt.push_back(second_node_pt);
         
       nonhalo_edge_nodes_pt.push_back(second_node_pt);
       nonhalo_edge_nodes_pt.push_back(third_node_pt);
         
       nonhalo_edge_nodes_pt.push_back(third_node_pt);
       nonhalo_edge_nodes_pt.push_back(first_node_pt);
         
       // Store the info. of the element used to create these edges
       std::pair<Node*, Node*> edge1 = std::make_pair(first_node_pt, 
                                                      second_node_pt);
       nonhalo_edge_element_pt[edge1] = current_ele_pt;
         
       std::pair<Node*, Node*> edge2 = std::make_pair(second_node_pt, 
                                                      third_node_pt);
       nonhalo_edge_element_pt[edge2] = current_ele_pt;
         
       std::pair<Node*, Node*> edge3 = std::make_pair(third_node_pt, 
                                                      first_node_pt);
       nonhalo_edge_element_pt[edge3] = current_ele_pt;
      }
     else
      {
       // Store the edges
       halo_edge_nodes_pt.push_back(first_node_pt);
       halo_edge_nodes_pt.push_back(second_node_pt);
         
       halo_edge_nodes_pt.push_back(second_node_pt);
       halo_edge_nodes_pt.push_back(third_node_pt);
         
       halo_edge_nodes_pt.push_back(third_node_pt);
       halo_edge_nodes_pt.push_back(first_node_pt);
         
       // Store the info. of the element used to create these edges
       std::pair<Node*, Node*> edge1 = std::make_pair(first_node_pt, 
                                                      second_node_pt);
       halo_edge_element_pt[edge1] = current_ele_pt;
         
       std::pair<Node*, Node*> edge2 = std::make_pair(second_node_pt, 
                                                      third_node_pt);
       halo_edge_element_pt[edge2] = current_ele_pt;
         
       std::pair<Node*, Node*> edge3 = std::make_pair(third_node_pt, 
                                                      first_node_pt);
       halo_edge_element_pt[edge3] = current_ele_pt;
      }
     
    } // for (e < nshared_bound_ele)

     // Filter the edges that give rise to a shared boundary
     
     // Mark the done edges
     std::map<std::pair<Node*,Node*>, bool> edge_done;
     
     // Storage for the edges shared by the elements
     Vector<std::pair<Node*, Node*> > unsorted_edges;
     
     // Storage for the elements that created the unsorted edges (two
     // elements, one at each side of the shared boundary)
     Vector<Vector<FiniteElement*> > unsorted_edges_elements_pt;

     const unsigned nnonhalo_edge_nodes = nonhalo_edge_nodes_pt.size();
     for (unsigned i = 0; i < nnonhalo_edge_nodes; i+=2)
      {
       Vector<Node*> currenti_edge(2);
       currenti_edge[0] = nonhalo_edge_nodes_pt[i];
       currenti_edge[1] = nonhalo_edge_nodes_pt[i+1];
       
       // Create the edge (both nodes that make the edge)
       std::pair<Node*, Node*> new_edge = 
        std::make_pair(currenti_edge[0], currenti_edge[1]);
       
       if (!edge_done[new_edge])
        {
         const unsigned nhalo_edge_nodes = halo_edge_nodes_pt.size();
         for (unsigned j = 0; j < nhalo_edge_nodes; j+=2)
          {
           Vector<Node*> currentj_edge(2);
           currentj_edge[0] = halo_edge_nodes_pt[j];
           currentj_edge[1] = halo_edge_nodes_pt[j+1];
         
           // Comparing pointer of nodes
           if (currenti_edge[0] == currentj_edge[0] && 
               currenti_edge[1] == currentj_edge[1])
            {           
             // Store the edge in the proper container
             unsorted_edges.push_back(new_edge);
             
             // Get the elements associated with the edges
             Vector<FiniteElement*> tmp_edge_element_pt;
             
             FiniteElement* nonhalo_ele_pt = nonhalo_edge_element_pt[new_edge];
             FiniteElement* halo_ele_pt = halo_edge_element_pt[new_edge];
             
             tmp_edge_element_pt.push_back(nonhalo_ele_pt);
             tmp_edge_element_pt.push_back(halo_ele_pt);
             
             // Store the elements associated with the edge
             unsorted_edges_elements_pt.push_back(tmp_edge_element_pt);
             
             // Mark the edge as done
             edge_done[new_edge] = true;

             // Break the loop for (j < nedge_node)
             break;
             
            } // equal edge
           
           // Comparing pointer of nodes (reversed)
           else if (currenti_edge[0] == currentj_edge[1] && 
                    currenti_edge[1] == currentj_edge[0])
            {
             // Create the edge (both nodes that make the edge)
             std::pair<Node*, Node*> new_edge = 
              std::make_pair(currenti_edge[0], currenti_edge[1]);
             
             // Store the edge in the proper container
             unsorted_edges.push_back(new_edge);
             
             // Create the (reversed) edge (both nodes that make the edge)
             std::pair<Node*, Node*> rev_new_edge = 
              std::make_pair(currentj_edge[0], currentj_edge[1]);
                        
             // Get the elements associated with the edge
             Vector<FiniteElement*> tmp_edge_element_pt;
             
             FiniteElement* nonhalo_ele_pt = nonhalo_edge_element_pt[new_edge];
             FiniteElement* halo_ele_pt = halo_edge_element_pt[rev_new_edge];
             
             tmp_edge_element_pt.push_back(nonhalo_ele_pt);
             tmp_edge_element_pt.push_back(halo_ele_pt);
             
             // Store the elements associated with the edge
             unsorted_edges_elements_pt.push_back(tmp_edge_element_pt);
             
             // Mark the edge as done
             edge_done[new_edge] = true;
             
             // Break the loop for (j < nedge_node)
             break;
           
            } // if (equal edge)
           
          } // for (j < nhalo_edge_nodes)
         
        } // if (!edge_done[new_edge])
       
      } // for (i < nnonhalo_edge_nodes)
     
     // We already have the edges that make the shared boundary (and the 
     // elements)
     // Sort them to create a contiguous boundary
     
     // Mark the already sorted edges
     std::map<std::pair<Node*,Node*>, bool> edge_sorted;
     
     const unsigned nunsorted_edges = unsorted_edges.size();
     
#ifdef PARANOID
     // The number of unsorted edges must be the same as the number of
     // shared_boundary element / 2
     if (nshared_bound_ele / 2 != nunsorted_edges)
      {
       std::ostringstream error_message;
       error_message
        << "The number of shared boundary elements (" << nshared_bound_ele 
        << ") is not the double\nof the number of unsorted edges (" 
        << nunsorted_edges << ") for the current boundary ("<< b << ")\n\n";
       throw OomphLibError(error_message.str(),
                           "RefineableTriangleMesh::update_shared_curve_after_restart()",
                           OOMPH_EXCEPTION_LOCATION);
      }
#endif
     
     unsigned nsorted_edges = 0;
     
     // Storing for the sorting nodes extracted from the edges, and
     // then used to update the polyline
     std::list<Node*> sorted_nodes;
     
     // Storing for the edges elements
     std::list<FiniteElement*> sorted_edges_elements_pt;
     
     // Get the root edge
     std::pair<Node*,Node*> edge = unsorted_edges[0];
     nsorted_edges++;

     // Mark edge as done
     edge_sorted[edge] = true;
     
     // The initial and final node on the list
     Node *first_node_pt = edge.first;
     Node *last_node_pt = edge.second;
     
     // Push back on the list the new edge (nodes)
     sorted_nodes.push_back(first_node_pt);
     sorted_nodes.push_back(last_node_pt);
     
     // Store the elements for the current edge
     sorted_edges_elements_pt.push_back(unsorted_edges_elements_pt[0][0]);
     sorted_edges_elements_pt.push_back(unsorted_edges_elements_pt[0][1]);
        
     // Iterate while the number of sorted edges be less than the number of
     // unsorted edges
     while (nsorted_edges < nunsorted_edges)
      {
       // Flag to indicate when a node was added
       bool node_added = false;
       
       // Start from the next edge since we have already added the
       // previous one as the initial edge
       for (unsigned iedge = 1; iedge < nunsorted_edges; iedge++)
        {
         edge = unsorted_edges[iedge];
         
         // If edge not done
         if (!edge_sorted[edge])
          {
           // Get each individual node
           Node* left_node_pt = edge.first;
           Node* right_node_pt = edge.second;
           
           if (left_node_pt == first_node_pt)
            {
             // Push front the new node
             sorted_nodes.push_front(right_node_pt);
             first_node_pt = right_node_pt;
             node_added = true;
             
             // Store the elements for the current edge
             sorted_edges_elements_pt.push_front(
              unsorted_edges_elements_pt[iedge][1]);
             sorted_edges_elements_pt.push_front(
              unsorted_edges_elements_pt[iedge][0]);
            }
           else if (left_node_pt == last_node_pt)
            {
             // Push back the new node
             sorted_nodes.push_back(right_node_pt);
             last_node_pt = right_node_pt;
             node_added = true;

             // Store the elements for the current edge
             sorted_edges_elements_pt.push_back(
              unsorted_edges_elements_pt[iedge][0]);
             sorted_edges_elements_pt.push_back(
              unsorted_edges_elements_pt[iedge][1]);
            }
           else if (right_node_pt == first_node_pt)
            {
             // Push front the new node
             sorted_nodes.push_front(left_node_pt);
             first_node_pt = left_node_pt;
             node_added = true;
             
             // Store the elements for the current edge
             sorted_edges_elements_pt.push_front(
              unsorted_edges_elements_pt[iedge][1]);
             sorted_edges_elements_pt.push_front(
              unsorted_edges_elements_pt[iedge][0]);
            }
           else if (right_node_pt == last_node_pt)
            {
             // Push back the new node
             sorted_nodes.push_back(left_node_pt);
             last_node_pt = left_node_pt;
             node_added = true;
             
             // Store the elements for the current edge
             sorted_edges_elements_pt.push_back(
              unsorted_edges_elements_pt[iedge][0]);
             sorted_edges_elements_pt.push_back(
              unsorted_edges_elements_pt[iedge][1]);
            }
           
           if (node_added)
            {
             // Mark as done only if one of its nodes has been
             // added to the list
             edge_sorted[edge] = true;
             nsorted_edges++;
             
             // Break the for
             break;
            }
           
          } // if (!edge_done[edge])
        } // for (iedge < nunsorted_edges)
      } // while (nsorted_edges < nunsorted_edges)
     
     // At this point we already have a sorted list of nodes, get the
     // vertices from them and store them in a vector container
     
     // Get the number of nodes on the list
     unsigned nvertex = sorted_nodes.size();
     // The vector to store the vertices (assign space)
     Vector<Vector<double> > polyline_vertices(nvertex);
        
     // Copy the vertices of the nodes
     unsigned counter = 0;
     for (std::list<Node*>::iterator it_nodes = sorted_nodes.begin();
          it_nodes != sorted_nodes.end();
          it_nodes++)
      {
       polyline_vertices[counter].resize(2);
       polyline_vertices[counter][0] = (*it_nodes)->x(0);
       polyline_vertices[counter][1] = (*it_nodes)->x(1);
       counter++;
      }
     
     // Before going to the unrefinement or refinement process check that
     // all processors start from the same vertex. Start from the bottom
     // left vertex
     if (polyline_vertices[nvertex-1][1] < polyline_vertices[0][1])
      {
       std::reverse(polyline_vertices.begin(), polyline_vertices.end());
      }
     else if (polyline_vertices[nvertex-1][1] == polyline_vertices[0][1])
      {
       if (polyline_vertices[nvertex-1][0] < polyline_vertices[0][0])
        {
         std::reverse(polyline_vertices.begin(), polyline_vertices.end());
        }
      }
     
     // Create the polyline associated with this edge
     TriangleMeshPolyLine *new_polyline_pt = 
      new TriangleMeshPolyLine(polyline_vertices, b);
     
     // Get the curve section representation
     TriangleMeshCurveSection *curve_section_pt = vector_polyline_pt[pp];
     
     // Copy the connection information from the old shared polyline
     // to the new one
     this->copy_connection_information(curve_section_pt, new_polyline_pt);
          
     //Now update the polyline according to the new vertices but first
     //check if the object is allowed to delete the representation
     //or if it should be done by other object
     bool delete_it_on_destructor = false;
     
     // Establish the element as being deleted by the destructor of
     // the class
     std::set<TriangleMeshCurveSection*>::iterator it =
      this->Free_curve_section_pt.find(curve_section_pt);
     
     if (it!=this->Free_curve_section_pt.end())
      {
       this->Free_curve_section_pt.erase(it);
       delete curve_section_pt;
       delete_it_on_destructor = true;
      }
     
     // Copy the new representation
     vector_polyline_pt[pp] = new_polyline_pt;
     
     // Get the new curve section representation
     TriangleMeshCurveSection *new_curve_section_pt = vector_polyline_pt[pp];
     
     // Update the Boundary - Polyline map
     this->Boundary_curve_section_pt[b] = new_curve_section_pt;
     
     if (delete_it_on_destructor)
      {
       this->Free_curve_section_pt.insert(new_curve_section_pt);
      }
     
  } // for (pp < npoly)
 
}

//===================================================================
// \short Fill the boundary elements structures when dealing with
// shared boundaries that overlap internal boundaries. Document the
// number of elements on the shared boundaries that go to internal
// boundaries
//===================================================================
template <class ELEMENT>
void RefineableTriangleMesh<ELEMENT>::
fill_boundary_elements_and_nodes_for_internal_boundaries()
{
 // Dummy file
 std::ofstream some_file;
 fill_boundary_elements_and_nodes_for_internal_boundaries(some_file);
}

//===================================================================
// \short Fill the boundary elements structures when dealing with
// shared boundaries that overlap internal boundaries
//===================================================================
template <class ELEMENT>
void RefineableTriangleMesh<ELEMENT>::
fill_boundary_elements_and_nodes_for_internal_boundaries(
 std::ofstream& outfile)
{
 // Get the number of processors
 const unsigned nproc = this->communicator_pt()->nproc();
 // Get the rank of the current processor
 unsigned my_rank = this->communicator_pt()->my_rank();

 // Temporal name for the shared boundary overlaps structure
 std::map<unsigned, unsigned> shd_bnd_over_int_bnd = 
  this->Shared_boundary_overlaps_internal_boundary;
 
 // Register the internal boundary elements that where found to be
 // overlapped by shared boundaries
 std::set<unsigned> internal_boundary_overlaped;
 
 // Document the number of elements and nodes associated to the
 // boundaries before filling elements and nodes
 if (outfile.is_open())
  {     
   const unsigned nbound = this->nboundary();
   outfile << "Number of boundaries: " << nbound << "\n\n";
   outfile << "Number of elements and nodes associated to each "
           << "boundary before\nfilling elements and nodes\n\n";
   for (unsigned i = 0; i < nbound; i++)
    {
     outfile << "Boundary (" << i << ") Elements (" 
             << this->nboundary_element(i) << ") " << "Nodes (" 
             << this->nboundary_node(i) << ")\n";
    }
  }
 
 // Storage for the shared boundaries in this processor
 std::set<unsigned> shared_boundaries_in_this_processor;
 
 // Get the shared boundaries that this processor has with other
 // processors
 for (unsigned iproc = 0; iproc < nproc; iproc++)
  {
   // Work with other processors only
   if (iproc != my_rank)
    {
     // Get the number of boundaries shared with the "iproc"-th processor
     unsigned nshared_boundaries_with_iproc = 
      this->nshared_boundaries(my_rank, iproc);
     
     if (nshared_boundaries_with_iproc > 0)
      {
       // Get the boundaries ids shared with "iproc"-th processor
       Vector<unsigned> bound_shared_with_iproc;
       bound_shared_with_iproc = this->shared_boundaries_ids(my_rank, 
                                                             iproc);
       
       // Loop over shared boundaries with "iproc"-th processor
       for (unsigned bs = 0; bs < nshared_boundaries_with_iproc; bs++)
        {
         unsigned bnd_id = bound_shared_with_iproc[bs];
         shared_boundaries_in_this_processor.insert(bnd_id);
        }
      }
    }
  }
 
 // ------------------------------------------------------------------
 // Copy the boundary elements and nodes from the shared boundary to
 // the internal boundary it overlaps
 // ------------------------------------------------------------------
 // Go through the shared boundaries that overlap internal boundaries
 for (std::map<unsigned, unsigned>::iterator it = 
       shd_bnd_over_int_bnd.begin(); it != shd_bnd_over_int_bnd.end(); it++)
  {
   // The shared boundary id that overlaps with an internal boundary
   const unsigned shd_bnd_id = (*it).first;
   // The internal boundary overlapped by the shared boundary
   const unsigned int_bnd_id = (*it).second;
   
   // Check if the shared boundary exist in this processor
   std::set<unsigned>::iterator it_set = 
    shared_boundaries_in_this_processor.find(shd_bnd_id);
   if (it_set != shared_boundaries_in_this_processor.end())
    {
     internal_boundary_overlaped.insert(int_bnd_id);
   
     // -----------------------------------------------------------------
     // First work the nodes of the shared boundaries that should be
     // added to the internal boundaries
     const unsigned nbnd_node_shd_bnd = this->nboundary_node(shd_bnd_id);
     
     // Document the number of nodes that will be passed to the internal
     // boundary from the current shared boundary
     if (outfile.is_open())
      {
       outfile << "\nPass info. from shared (" << shd_bnd_id 
               << ") to internal (" << int_bnd_id << ")\n";
       outfile << "Number of shared boundary nodes: " 
               << nbnd_node_shd_bnd << "\n";
      }
     
     for (unsigned in = 0; in < nbnd_node_shd_bnd; in++)
      {
       // Get the boundary node
       Node* bnd_node_pt = this->boundary_node_pt(shd_bnd_id, in);
       // Add the node to the internal boundary
       this->add_boundary_node(int_bnd_id, bnd_node_pt);       
      }
     
     // -----------------------------------------------------------------
     // Second work the boundary elements
     // Get the number of boundary elements that should be copied to the
     // internal boundary
     const unsigned nbnd_ele_shd_bnd = this->nboundary_element(shd_bnd_id);
     
     // Document the number of elements that will be passed to the
     // internal boundary from the current shared boundary
     if (outfile.is_open())
      {
       outfile << "Number of shared boundary elements: " 
               << nbnd_ele_shd_bnd << "\n\n";
      }
   
     // Go through the boundary elements in the shrared boundary and add
     // them to the boundary elements of the internal boundary
     for (unsigned ie = 0; ie < nbnd_ele_shd_bnd; ie++)
      {
       // Get the boundary element
       FiniteElement* bnd_ele_pt = this->boundary_element_pt(shd_bnd_id, ie);
       // Add the element to the boundary elements storage of the
       // internal boundary
       Boundary_element_pt[int_bnd_id].push_back(bnd_ele_pt);
       // Get the face index of the boundary
       int face_index = this->face_index_at_boundary(shd_bnd_id, ie);
       // Add the face index to the storage of the boundary
       Face_index_at_boundary[int_bnd_id].push_back(face_index);
     
      } // for (ie < nbnd_ele_shd_bnd)
   
     // If there are regions we need to fill the storage for regions too
     const unsigned nregions = this->nregion();
     if (nregions > 1)
      {
       for (unsigned ir = 0 ; ir < nregions; ir++)
        {
         // Get the region attribute
         const unsigned region_id = 
          static_cast<unsigned>(this->Region_attribute[ir]);
       
         // Loop over all elements on boundaries in region ir
         const unsigned nele_ir = this->nboundary_element_in_region(shd_bnd_id, 
                                                                    region_id);
         for (unsigned ier = 0; ier < nele_ir; ier++)
          {
           // Get the boundary element in current region
           FiniteElement* bnd_ele_pt = 
            this->boundary_element_in_region_pt(shd_bnd_id, region_id, ier);
           // Add the boundary element to the internal boundary in the
           // region
           this->Boundary_region_element_pt[int_bnd_id][region_id].
            push_back(bnd_ele_pt);
         
           // Get the face index of the boundary
           int face_index = 
            this->face_index_at_boundary_in_region(shd_bnd_id, region_id, ier);
           // Add the face index to the storage of the boundary region
           this->Face_index_region_at_boundary[int_bnd_id][region_id].
            push_back(face_index);
         
          } // for (ier < nele_ir)
       
        } // for (ir < nregions)
     
      } // if (nregions > 1)
     
    } // if (the shared boundary appears in the current processor)
   
  } // for (loop over the shared bound that overlap an internal bound)
 
 // Document the number of elements and nodes associated to the
 // boundaries after filling elements and nodes
 if (outfile.is_open())
  {     
   const unsigned nbound = this->nboundary();
   outfile << "Number of boundaries: " << nbound << "\n\n";
   outfile << "Number of elements and nodes associated to each "
           << "boundary after\nfilling elements and nodes\n\n";
   for (unsigned i = 0; i < nbound; i++)
    {
     outfile << "Boundary (" << i << ") Elements (" 
             << this->nboundary_element(i) << ")" << " Nodes (" 
             << this->nboundary_node(i) << ")\n";
    }
  }

 // ------------------------------------------------------------------
 // Finally, re-setup the boundary coordinates for the new nodes on
 // the overlaped internal boundaries
 // ------------------------------------------------------------------
 for (std::set<unsigned>::iterator it = internal_boundary_overlaped.begin();
      it != internal_boundary_overlaped.end(); it++)
  {
   const unsigned overlaped_internal_bnd_id = (*it);
   
   // Re-setup boundary coordinates
   this->template setup_boundary_coordinates<ELEMENT>(overlaped_internal_bnd_id);
  }

}

#endif // #ifdef OOMPH_HAS_MPI

 //======================================================================
 /// Move the boundary nodes onto the boundary defined by the old mesh
 //======================================================================
 template <class ELEMENT>
 void RefineableTriangleMesh<ELEMENT>::snap_nodes_onto_boundary(
   RefineableTriangleMesh<ELEMENT>* &new_mesh_pt, const unsigned &b)
  {

   // Quick return
   if (!Boundary_coordinate_exists[b])
    {
     return;
    }

   //Firstly we set the boundary coordinates of the new nodes
   //In case the mapping between the geometric object's intrinsic coordinate
   //and the arc-length coordinate is nonlinear. This is only an approximation, 
   //but it will ensure that the nodes that were input to triangle will
   //retain exactly the same boundary coordinates and then linear interpolation
   //is used between those values for any newly created nodes.
   
   // We need to get the boundary nodes from the boundary face
   // elements since the "multi_domain" methods add nodes to the
   // "Boundary_node_pt" structure which have no boundary coordinates
   // assigned
   std::set<Node*> tmp_boundary_node_pt;
   const unsigned nboundary_ele = this->nboundary_element(b);
   for (unsigned e = 0; e < nboundary_ele; e++)
    {
     // Get the boundary bulk element
     FiniteElement* bulk_ele_pt = this->boundary_element_pt(b, e);
#ifdef OOMPH_HAS_MPI
     // Only work with nonhalo elements if the mesh is distributed
     if (!bulk_ele_pt->is_halo())
      {
#endif
       // Get the face index
       int face_index = this->face_index_at_boundary(b, e);
       // Create the face element
       FiniteElement* face_ele_pt = new DummyFaceElement<ELEMENT> (
        bulk_ele_pt, face_index);
       
       // Get the number of nodes on the face element
       const unsigned nnodes = face_ele_pt->nnode();
       for (unsigned i = 0; i < nnodes; i++)
        {
         // Get the nodes in the face elements
         Node* tmp_node_pt = face_ele_pt->node_pt(i);
         // Add the nodes to the set of boundary nodes
         tmp_boundary_node_pt.insert(tmp_node_pt);
        } // for (i < nnodes)
       
       // Free the memory allocated for the face element
       delete face_ele_pt;
       face_ele_pt = 0;
#ifdef OOMPH_HAS_MPI
      } // if (!bulk_ele_pt->is_halo())
#endif
     
    } // for (e < nboundary_ele)
   
   // Get the number of boundary nodes
   const unsigned long n_boundary_node = tmp_boundary_node_pt.size();
   
   // Quick return if there are no nodes
   if (n_boundary_node==0)
    {
#ifdef OOMPH_HAS_MPI
     // Check if we are working with a distributed mesh
     if (!this->is_mesh_distributed())
      {
#endif
       return;
#ifdef OOMPH_HAS_MPI
      }
     else // The mesh is distributed !!!
      {
       // Do not forget to participate in the communication
       Mesh* face_mesh_pt = new Mesh();
       create_unsorted_face_mesh_representation(b, face_mesh_pt);
       MeshAsGeomObject* mesh_geom_obj_pt = new MeshAsGeomObject(face_mesh_pt);
       
       //Delete the allocated memory for the geometric object and face mesh
       delete mesh_geom_obj_pt;

       // Flush the nodes from the face mesh to make sure we
       // don't delete them (the bulk mesh still needs them!)
       face_mesh_pt->flush_node_storage();
       delete face_mesh_pt;
       return;
      }
#endif
    } // if (n_boundary_node==0)
   
   //Create a vector of existing boundary nodes with their boundary
   //coordinate as the first entry so that we can use standard sort algorithms
   Vector<double> node_coord(3);
   Vector<double> b_coord(1);

   Vector<Vector<double> > old_boundary_node(n_boundary_node);
   unsigned tmp_counter = 0;
   for(std::set<Node*>::iterator it_node = tmp_boundary_node_pt.begin();
       it_node != tmp_boundary_node_pt.end(); it_node++, tmp_counter++)
    {
     Node* nod_pt = (*it_node);
     nod_pt->get_coordinates_on_boundary(b,b_coord);
     node_coord[0] = b_coord[0];
     node_coord[1] = nod_pt->x(0);
     node_coord[2] = nod_pt->x(1);
     old_boundary_node[tmp_counter] = node_coord;
    } // for (it_node != tmp_boundary_node_pt.end())
   
   //Sort the vector
   std::sort(old_boundary_node.begin(),old_boundary_node.end());
   
   //Set up an equivalent ordered vector for the new nodes, based on the
   //current coordinate which is the scaled arc-length.
   //Also provide storage for the original node index,
   //the mapped coordinate and a flag to indicate whether the mapped
   //coordinate has been assigned.
   //Get the nodes on the boundary but consider to which segment (which
   //may appear in a distributed mesh) they belong
   Vector<Vector<Node*> > segment_nodes_pt;
   
#ifdef OOMPH_HAS_MPI
   // Get the number of segments
   const unsigned nsegments = new_mesh_pt->nboundary_segment(b);
#else
   // The number of segments is one since the boundary is not split
   // over multiple processors
   const unsigned nsegments = 1;
#endif // #ifdef OOMPH_HAS_MPI
   
#ifdef OOMPH_HAS_MPI
   // Get the total number of nodes on the boundary
   const unsigned n_new_boundary_node = new_mesh_pt->nboundary_segment_node(b);
   
   // Check if we are working with a distributed mesh
   if (this->is_mesh_distributed())
    {
     // If that is the case we need to ensure that the new mesh has
     // nodes too, if that is not the case then return
     // Quick return if there are no nodes
     if (n_new_boundary_node==0)
      {
       // Do not forget to participate in the communication
       Mesh* face_mesh_pt = new Mesh();
       create_unsorted_face_mesh_representation(b, face_mesh_pt);
       MeshAsGeomObject* mesh_geom_obj_pt = new MeshAsGeomObject(face_mesh_pt);

       //Delete the allocated memory for the geometric object and face mesh
       delete mesh_geom_obj_pt;
       // Flush the nodes from the face mesh to make sure we
       // don't delete them (the bulk mesh still needs them!)
       face_mesh_pt->flush_node_storage();
       delete face_mesh_pt;
       return;
      }
    }
#endif // #ifdef OOMPH_HAS_MPI
    
   //Create a vector of boundary nodes that must be moved
   Vector<Vector<unsigned> > nodes_to_be_snapped(nsegments);
 
   // Go through all the segments to assign the snapped zeta coordinates
   // for the new nodes
   for (unsigned is = 0; is < nsegments; is++)
    {
#ifdef OOMPH_HAS_MPI
     const unsigned n_new_boundary_segment_node = 
      new_mesh_pt->nboundary_segment_node(b,is);
#else
     const unsigned n_new_boundary_segment_node = new_mesh_pt->nboundary_node(b);
#endif // #ifdef OOMPH_HAS_MPI
     
     Vector<Vector<double> > new_boundary_node(n_new_boundary_segment_node);
     //There will be six data associated with each node
     node_coord.resize(6,0.0);
     for(unsigned n = 0; n < n_new_boundary_segment_node; n++)
      {
#ifdef OOMPH_HAS_MPI
       Node* nod_pt = new_mesh_pt->boundary_segment_node_pt(b,is,n);
#else
       Node* nod_pt = new_mesh_pt->boundary_node_pt(b,n);
#endif // #ifdef OOMPH_HAS_MPI
       nod_pt->get_coordinates_on_boundary(b,b_coord);
       node_coord[0] = b_coord[0];
       node_coord[1] = nod_pt->x(0);
       node_coord[2] = nod_pt->x(1);
       node_coord[3] = n;
       new_boundary_node[n] = node_coord;
      } // for (n < n_new_boundary_segment_node)

     //Sort the new boundary nodes based on their arc-length coordinate
     std::sort(new_boundary_node.begin(),new_boundary_node.end());
     
     //We now have two sets of nodes ordered by a coordinate that acts in the
     //same direction and has the same limits.

     //Loop over the vector of new nodes and allocate exactly the same
     //coordinate as the old nodes at points of coincidence
     unsigned old_index = 0;
     for(unsigned n=0;n<n_new_boundary_segment_node;++n)
      {
       //Loop over the set of old nodes and if the x and y coordinates
       //coincide with the new node copy accross the new boundary coordinate
       for(unsigned m=old_index;m<n_boundary_node;++m)
        {
         if(
          (std::fabs(old_boundary_node[m][1]-new_boundary_node[n][1])<1.0e-14)
          &&
          (std::fabs(old_boundary_node[m][2]-new_boundary_node[n][2])<1.0e-14))
          {
           //Store the boundary coordinate from the old mesh
           new_boundary_node[n][4] = old_boundary_node[m][0];
           //Say that it has been stored
           new_boundary_node[n][5] = 1.0;
           //For efficiency, we can start the iteration from here next
           //time round because both vectors are ordered
           old_index = m;
           break;
          }
        }
      }

     //Check that the end-points have new boundary coordinates allocated
#ifdef PARANOID
     if((new_boundary_node[0][5]==0.0) ||
        (new_boundary_node[n_new_boundary_segment_node-1][5] == 0.0))
      {
       std::ostringstream error_stream;
       error_stream
        <<"New boundary coordinates not found for the first and/or last "
        <<"nodes\n"
        <<"on the boundary " << b << ". This should not happen because "
        <<"these\nlimits should have been setup in the constructor\n";
       error_stream 
        <<"The distance between the new and old nodes is probably outside\n"
        <<"our tolerance.\n";
       error_stream.precision(20);
       error_stream << "Old boundaries: \n";
       error_stream <<
        old_boundary_node[0][1] << " " << old_boundary_node[0][2]
                                << " : " <<
        old_boundary_node[n_boundary_node-1][1] << " " <<
        old_boundary_node[n_boundary_node-1][2] << "\n";
       error_stream << "New boundaries: \n" <<
        new_boundary_node[0][1] << " " << new_boundary_node[0][2] << " : " <<
        new_boundary_node[n_new_boundary_segment_node-1][1] << " " <<
        new_boundary_node[n_new_boundary_segment_node-1][2] << "\n";
       OomphLibWarning(error_stream.str(),
                       "RefineableTriangleMesh::snap_nodes_onto_boundary()",
                       OOMPH_EXCEPTION_LOCATION);
      }
#endif
     
     // This is only true if the boundary is not splitted among the
     // processors
     if (!this->is_mesh_distributed())
      {
       //The end points should always be present, so we
       //can (and must) always add them in exactly
       new_boundary_node[0][4] = new_boundary_node[0][0];
       
       /// Correct!? Because assigned again below
       new_boundary_node[n_new_boundary_segment_node-1][4] =
        new_boundary_node[0][5] = 1.0;
       
       new_boundary_node[n_new_boundary_segment_node-1][4] =
        new_boundary_node[n_new_boundary_segment_node-1][0];
       new_boundary_node[n_new_boundary_segment_node-1][5] = 1.0;
      }
     
     //Now loop over the interior nodes again and 
     //use linear interpolation to fill in any unassigned coordiantes
     for(unsigned n=1;n<n_new_boundary_segment_node-1;++n)
      {
       //If the new boundary coordinate has NOT been allocated
       if(new_boundary_node[n][5]==0.0)
        {
         //Add its (unsorted) node number to the list
         nodes_to_be_snapped[is].push_back(
          static_cast<unsigned>(new_boundary_node[n][3]));
         
         //We assume that the previous nodal value has been assigned
         //and read out the old and new boundary coordinates
         double zeta_old_low = new_boundary_node[n-1][0];
         double zeta_new_low = new_boundary_node[n-1][4];
         
         //Loop over the nodes above the current node until 
         //we find the next one that has been allocated
         for(unsigned m=n+1;m<n_new_boundary_segment_node;++m)
          {
           if(new_boundary_node[m][5]==1.0)
            {
             //Read out the old boundary coordinate
             double zeta_old_high = new_boundary_node[m][0];
             double zeta_new_high = new_boundary_node[m][4];
             //Use linear interpolation to assign the new boundary coordinate
             double frac = (new_boundary_node[n][0] - zeta_old_low)/
              (zeta_old_high - zeta_old_low);
             new_boundary_node[n][4] = zeta_new_low
              + frac*(zeta_new_high - zeta_new_low);
             new_boundary_node[n][5] = 1.0;
             break;
            }
          }
        }
      }
     
     //Loop over all the nodes and set the new boundary coordinate
     for(unsigned n=0;n<n_new_boundary_segment_node;++n)
      {
       if(new_boundary_node[n][5]==0)
        {
         throw OomphLibError(
          "New boundary coordinate not assigned\n",
          "RefineableTriangleMesh::snap_nodes_onto_boundary()",
          OOMPH_EXCEPTION_LOCATION);
        }
       
#ifdef OOMPH_HAS_MPI
       //get the old coordinate
       new_mesh_pt->boundary_segment_node_pt(
        b,is,static_cast<unsigned>(new_boundary_node[n][3]))
        ->get_coordinates_on_boundary(b,b_coord);
       //Set the new coordinate
       b_coord[0] = new_boundary_node[n][4];
       new_mesh_pt->boundary_segment_node_pt(
        b,is,static_cast<unsigned>(new_boundary_node[n][3]))
        ->set_coordinates_on_boundary(b,b_coord);
#else
       //get the old coordinate
       new_mesh_pt->boundary_node_pt(
        b,static_cast<unsigned>(new_boundary_node[n][3]))
        ->get_coordinates_on_boundary(b,b_coord);
       //Set the new coordinate
       b_coord[0] = new_boundary_node[n][4];
       new_mesh_pt->boundary_node_pt(
        b,static_cast<unsigned>(new_boundary_node[n][3]))
        ->set_coordinates_on_boundary(b,b_coord);
#endif // #ifdef OOMPH_HAS_MPI

      }
     
    } // for (is < nsegments)
   
   Mesh* face_mesh_pt = new Mesh();
   create_unsorted_face_mesh_representation(b, face_mesh_pt);
   
   //Now that the coordinates have been set up we can do the snapping
  MeshAsGeomObject* mesh_geom_obj_pt=new MeshAsGeomObject(face_mesh_pt);

  //Now assign the new nodes positions based on the old meshes
  //potentially curvilinear boundary (its geom object incarnation)
  Vector<double> new_x(2);
  
  //Loop over the nodes that need to be snapped
  for(unsigned is = 0; is < nsegments; is++)
   {
    const unsigned nnodes_to_snap = nodes_to_be_snapped[is].size();
    
    for (unsigned in = 0; in < nnodes_to_snap; in++)
     {
      //Read out the boundary node number
      unsigned n = nodes_to_be_snapped[is][in];
#ifdef OOMPH_HAS_MPI
      //Get the boundary coordinate of all new nodes
      Node* const nod_pt = new_mesh_pt->boundary_segment_node_pt(b,is,n);
#else
      //Get the boundary coordinate of all new nodes
      Node* const nod_pt = new_mesh_pt->boundary_node_pt(b,n);
#endif // #ifdef OOMPH_HAS_MPI
      
      nod_pt->get_coordinates_on_boundary(b,b_coord);
      //Let's find boundary coordinates of the new node
      mesh_geom_obj_pt->position(b_coord,new_x);
      
      //Now snap to the boundary
      for(unsigned i=0;i<2;i++)
       {
        nod_pt->x(i) = new_x[i];
       }
     }
   }

  //Delete the allocated memory for the geometric object and face mesh
  delete mesh_geom_obj_pt;
  // Flush the nodes from the face mesh to make sure we
  // don't delete them (the bulk mesh still needs them!)
  face_mesh_pt->flush_node_storage();
  delete face_mesh_pt;

  //Fix up the elements adjacent to the boundary

  // Dummy six node element for sorting out bubble node for
  // seven node enriched quadratic triangles
  TElement<2,3> dummy_six_node_element;
  for (unsigned j=0;j<6;j++)
   {
    dummy_six_node_element.construct_node(j);
   }

  //This should definitely become a triangular element member function
  //Loop over elements 
  unsigned n_bound_el = new_mesh_pt->nboundary_element(b);
  for(unsigned e=0;e<n_bound_el;e++)
   {
    FiniteElement* el_pt = new_mesh_pt->boundary_element_pt(b,e);

    // Deal with different numbers of nodes separately
    unsigned nnod=el_pt->nnode();

// #ifdef PARANOID
//     // Flag to indicate if we successully classified/dealt with the element
//     bool success=false;
// #endif

    // Simplex element: Nothing to be done other than error checking
    if (nnod==3)
     {
#ifdef PARANOID
      // Try to cast to a simplex element
      TElement<2,2>* t_el_pt=dynamic_cast<TElement<2,2>*>(el_pt);
      if (t_el_pt==0)
       {
        throw OomphLibError(
          "Have a three-noded element that's not a TElement<2,2>",
          OOMPH_CURRENT_FUNCTION,
          OOMPH_EXCEPTION_LOCATION);
       }
      // If I get there I must not have thrown :)
      //success=true;
#endif
     }
    // Quadratic element (or enriched quadratic)

    else if ((nnod==6)||(nnod==7))
     {

#ifdef PARANOID
      // Try to cast to a quadratic element
      TElement<2,3>* t_el_pt=dynamic_cast<TElement<2,3>*>(el_pt);
      if (t_el_pt==0)
       {
        if (nnod==6)
         {
          throw OomphLibError(
            "Have a six-noded element that's not a TElement<2,3>",
            OOMPH_CURRENT_FUNCTION,
            OOMPH_EXCEPTION_LOCATION);
         }
        else
         {
          throw OomphLibError(
            "Have a seven-noded element that's not a TElement<2,3>",
            OOMPH_CURRENT_FUNCTION,
            OOMPH_EXCEPTION_LOCATION);
         }
       }
      // If I get there I must not have thrown :)
      //success=true;
#endif  
      // Deal with six noded stuff for all (normal and enriched) elements 

      ///----------------------------------------------------------------
      ///         Repositioning of mid-side nodes
      ///----------------------------------------------------------------

      //Side between 0 and 1
      if(el_pt->node_pt(3)->is_on_boundary(b))
       {
        //Make sure that the node I'm about to move is NOT on
        //a boundary
        if(!el_pt->node_pt(5)->is_on_boundary())
         {
          //Reset the internal nodes
          for(unsigned i=0;i<2;i++)
           {
            el_pt->node_pt(5)->x(i) =
            0.5*(el_pt->node_pt(0)->x(i) + el_pt->node_pt(2)->x(i));
           }
         }
        //Make sure that the node I'm about to move is NOT on
        //a boundary
        if(!el_pt->node_pt(4)->is_on_boundary())
         {
          //Reset the internal nodes
          for(unsigned i=0;i<2;i++)
           {
            el_pt->node_pt(4)->x(i) =
            0.5*(el_pt->node_pt(1)->x(i) + el_pt->node_pt(2)->x(i));
           }
         }
       }

      //Side between 1 and 2
      if(el_pt->node_pt(4)->is_on_boundary(b))
       {
        //Make sure that the node I'm about to move is NOT on
        //a boundary
        if(!el_pt->node_pt(5)->is_on_boundary())
         {
          //Reset the internal nodes
          for(unsigned i=0;i<2;i++)
           {
            el_pt->node_pt(5)->x(i) =
            0.5*(el_pt->node_pt(0)->x(i) + el_pt->node_pt(2)->x(i));
           }
         }
        //Make sure that the node I'm about to move is NOT on
        //a boundary
        if(!el_pt->node_pt(3)->is_on_boundary())
         {
          //Reset the internal nodes
          for(unsigned i=0;i<2;i++)
           {
            el_pt->node_pt(3)->x(i) =
            0.5*(el_pt->node_pt(0)->x(i) + el_pt->node_pt(1)->x(i));
           }
         }
       }

      //Side between 0 and 2
      if(el_pt->node_pt(5)->is_on_boundary(b))
       {
        //Make sure that the node I'm about to move is NOT on
        //a boundary
        if(!el_pt->node_pt(4)->is_on_boundary())
         {
          //Reset the internal nodes
          for(unsigned i=0;i<2;i++)
           {
            el_pt->node_pt(4)->x(i) =
            0.5*(el_pt->node_pt(1)->x(i) + el_pt->node_pt(2)->x(i));
           }
         }
        //Make sure that the node I'm about to move is NOT on
        //a boundary
        if(!el_pt->node_pt(3)->is_on_boundary())
         {
          //Reset the internal nodes
          for(unsigned i=0;i<2;i++)
           {
            el_pt->node_pt(3)->x(i) =
            0.5*(el_pt->node_pt(0)->x(i) + el_pt->node_pt(1)->x(i));
           }
         }
       }

      // If it's seven noded it's likely to be an enriched one: Deal with
      // the central (bubble) node
      if (nnod==7)
       {
        // Try to cast to an enriched quadratic element
        TBubbleEnrichedElement<2,3>* t_el_pt=
        dynamic_cast<TBubbleEnrichedElement<2,3>*>(el_pt);
        if (t_el_pt==0)
         {
          throw OomphLibError(
            "Have seven-noded element that's not a TBubbleEnrichedElement<2,3>",
            OOMPH_CURRENT_FUNCTION,
            OOMPH_EXCEPTION_LOCATION);
         }

        // Assign the new non-bubble coordinates to the six noded dummy element
        for (unsigned j=0;j<6;j++)
         {
          for (unsigned i=0;i<2;i++)
           {
            dummy_six_node_element.node_pt(j)->x(i)=el_pt->node_pt(j)->x(i);
           }
         }

        // Local coordinate of enriched node
        unsigned j_enriched=6;
        Vector<double> s(2);
        el_pt->local_coordinate_of_node(j_enriched,s);

        // Get its position from non-enriched element
        Vector<double> x(2);
        dummy_six_node_element.interpolated_x(s,x);
        el_pt->node_pt(j_enriched)->x(0) = x[0];
        el_pt->node_pt(j_enriched)->x(1) = x[1];
       }
     }
    // Any other case cannot be dealt with at the moment

    else
     {
      std::ostringstream error_stream;
      error_stream
      << "Cannot deal with this particular " << nnod
      << "-noded element yet.\n"
      << "Please implement this yourself.\n";
      throw OomphLibError(error_stream.str(),
OOMPH_CURRENT_FUNCTION,
        OOMPH_EXCEPTION_LOCATION);
     }
   }

  // Cleanup
  for (unsigned j=0;j<6;j++)
   {
    delete dummy_six_node_element.node_pt(j);
   }

 }



#endif // #ifdef OOMPH_HAS_TRIANGLE_LIB

}

#endif
