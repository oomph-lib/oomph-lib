// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC// Copyright (C) 2006-2023 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
#ifndef OOMPH_TRIANGLE_MESH_TEMPLATE_CC
#define OOMPH_TRIANGLE_MESH_TEMPLATE_CC

#include <iostream>

#include "triangle_mesh.template.h"
#include "../generic/map_matrix.h"
#include "../generic/multi_domain.h"
#include "../generic/projection.h"
#include "../generic/face_element_as_geometric_object.h"

namespace oomph
{
  //======================================================================
  /// Build with the help of the scaffold mesh coming
  /// from the triangle mesh generator Triangle.
  //======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::build_from_scaffold(TimeStepper* time_stepper_pt,
                                                  const bool& use_attributes)
  {
    // Mesh can only be built with 2D Telements.
    MeshChecker::assert_geometric_element<TElementGeometricBase, ELEMENT>(2);

    // Create space for elements
    unsigned nelem = Tmp_mesh_pt->nelement();
    Element_pt.resize(nelem);

    // Create space for nodes
    unsigned nnode_scaffold = Tmp_mesh_pt->nnode();

    // Create a map storing the node_id of the mesh used to update the
    // node position in the update_triangulateio function
    std::map<Node*, unsigned> old_global_number;

    // Store the TriangulateIO node id
    for (unsigned inod = 0; inod < nnode_scaffold; inod++)
    {
      Node* old_node_pt = Tmp_mesh_pt->node_pt(inod);
      old_global_number[old_node_pt] = inod;
    }

    // Initialize the old node id vector
    Oomph_vertex_nodes_id.resize(nnode_scaffold);

    // Create space for nodes
    Node_pt.resize(nnode_scaffold, 0);

    // Set number of boundaries
    unsigned nbound = Tmp_mesh_pt->nboundary();

    // Resize the boundary information
    set_nboundary(nbound);
    Boundary_element_pt.resize(nbound);
    Face_index_at_boundary.resize(nbound);

    // If we have different regions, then resize the region
    // information
    if (use_attributes)
    {
      Boundary_region_element_pt.resize(nbound);
      Face_index_region_at_boundary.resize(nbound);
    }

    // Loop over elements in scaffold mesh, visit their nodes
    for (unsigned e = 0; e < nelem; e++)
    {
      Element_pt[e] = new ELEMENT;
    }

    // Number of nodes per element from the scaffold mesh
    unsigned nnod_el = Tmp_mesh_pt->finite_element_pt(0)->nnode();

    // Setup map to check the (pseudo-)global node number
    // Nodes whose number is zero haven't been copied across
    // into the mesh yet.
    std::map<Node*, unsigned> global_number;
    unsigned global_count = 0;

    // Map of Element attribute pairs
    std::map<double, Vector<FiniteElement*>> element_attribute_map;

    // If we're using attributes
    if (use_attributes)
    {
      // If we're using attributes then we need attribute 0 which will
      // be associated with region 0
      element_attribute_map[0].resize(0);
    }

    // Loop over elements in scaffold mesh, visit their nodes
    for (unsigned e = 0; e < nelem; e++)
    {
      // Loop over all nodes in element
      for (unsigned j = 0; j < nnod_el; j++)
      {
        // Pointer to node in the scaffold mesh
        Node* scaffold_node_pt = Tmp_mesh_pt->finite_element_pt(e)->node_pt(j);

        // Get the (pseudo-)global node number in scaffold mesh
        // (It's zero [=default] if not visited this one yet)
        unsigned j_global = global_number[scaffold_node_pt];

        // Haven't done this one yet
        if (j_global == 0)
        {
          // Find and store the node_id in the old nodes map
          Oomph_vertex_nodes_id[global_count] =
            old_global_number[scaffold_node_pt];

          // Get pointer to set of mesh boundaries that this
          // scaffold node occupies; NULL if the node is not on any boundary
          std::set<unsigned>* boundaries_pt;
          scaffold_node_pt->get_boundaries_pt(boundaries_pt);

          // Storage for the new node
          Node* new_node_pt = 0;

          // Is it on boundaries
          if (boundaries_pt != 0)
          {
            // Create new boundary node
            new_node_pt =
              finite_element_pt(e)->construct_boundary_node(j, time_stepper_pt);

            // Add to boundaries
            for (std::set<unsigned>::iterator it = boundaries_pt->begin();
                 it != boundaries_pt->end();
                 ++it)
            {
              add_boundary_node(*it, new_node_pt);
            }
          }
          // Build normal node
          else
          {
            // Create new normal node
            new_node_pt =
              finite_element_pt(e)->construct_node(j, time_stepper_pt);
          }

          // Give it a number (not necessarily the global node
          // number in the scaffold mesh -- we just need something
          // to keep track...)
          global_count++;
          global_number[scaffold_node_pt] = global_count;

          // Copy new node, created using the NEW element's construct_node
          // function into global storage, using the same global
          // node number that we've just associated with the
          // corresponding node in the scaffold mesh
          Node_pt[global_count - 1] = new_node_pt;

          // Assign coordinates
          for (unsigned i = 0; i < finite_element_pt(e)->dim(); i++)
          {
            new_node_pt->x(i) = scaffold_node_pt->x(i);
          }
        }
        // This one has already been done: Copy accross
        else
        {
          finite_element_pt(e)->node_pt(j) = Node_pt[j_global - 1];
        }
      }

      // If we're using attributes
      if (use_attributes)
      {
        element_attribute_map[Tmp_mesh_pt->element_attribute(e)].push_back(
          finite_element_pt(e));
      }
    }

    // Now let's construct lists
    // Find the number of attributes
    if (use_attributes)
    {
      unsigned n_attribute = element_attribute_map.size();

      // There are n_attribute different regions
      this->Region_attribute.resize(n_attribute);

      // Copy the vectors in the map over to our internal storage
      unsigned count = 0;
      for (std::map<double, Vector<FiniteElement*>>::iterator it =
             element_attribute_map.begin();
           it != element_attribute_map.end();
           ++it)
      {
        this->Region_attribute[count] = it->first;
        Region_element_pt[static_cast<unsigned>(Region_attribute[count])] =
          it->second;
        ++count;
      }
    }

    // At this point we've created all the elements and
    // created their vertex nodes. Now we need to create
    // the additional (midside and internal) nodes!

    unsigned boundary_id = 0;

    // Get number of nodes along element edge and dimension of element (2)
    // from first element
    unsigned n_node_1d = finite_element_pt(0)->nnode_1d();
    unsigned dim = finite_element_pt(0)->dim();

    // Storage for the local coordinate of the new node
    Vector<double> s(dim);

    // Get number of nodes in the element from first element
    unsigned n_node = finite_element_pt(0)->nnode();

    // Storage for each global edge of the mesh
    unsigned n_global_edge = Tmp_mesh_pt->nglobal_edge();
    Vector<Vector<Node*>> nodes_on_global_edge(n_global_edge);

    // Loop over elements
    for (unsigned e = 0; e < nelem; e++)
    {
      // Cache pointers to the elements
      FiniteElement* const elem_pt = finite_element_pt(e);
      FiniteElement* const tmp_elem_pt = Tmp_mesh_pt->finite_element_pt(e);

      // The number of edge nodes is  3*(nnode_1d-1)
      unsigned n_edge_node = 3 * (n_node_1d - 1);

      // If there are any more nodes, these are internal and can be
      // constructed and added directly to the mesh
      for (unsigned n = n_edge_node; n < n_node; ++n)
      {
        // Create new node (it can never be a boundary node)
        Node* new_node_pt = elem_pt->construct_node(n, time_stepper_pt);

        // What are the node's local coordinates?
        elem_pt->local_coordinate_of_node(n, s);

        // Find the coordinates of the new node from the existing
        // and fully-functional element in the scaffold mesh
        for (unsigned i = 0; i < dim; i++)
        {
          new_node_pt->x(i) = tmp_elem_pt->interpolated_x(s, i);
        }

        // Add the node to the mesh's global look-up scheme
        Node_pt.push_back(new_node_pt);
      }

      // Now loop over the mid-side edge nodes
      // Start from node number 3
      unsigned n = 3;

      // Loop over edges
      for (unsigned j = 0; j < 3; j++)
      {
        // Find the boundary id of the edge
        boundary_id = Tmp_mesh_pt->edge_boundary(e, j);

        // Find the global edge index
        unsigned edge_index = Tmp_mesh_pt->edge_index(e, j);

        // If the nodes on the edge have not been allocated, construct them
        if (nodes_on_global_edge[edge_index].size() == 0)
        {
          // Loop over the nodes on the edge excluding the ends
          for (unsigned j2 = 0; j2 < n_node_1d - 2; ++j2)
          {
            // Storage for the new node
            Node* new_node_pt = 0;

            // If the edge is on a boundary, construct a boundary node
            if (boundary_id > 0)
            {
              new_node_pt =
                elem_pt->construct_boundary_node(n, time_stepper_pt);
              // Add it to the boundary
              this->add_boundary_node(boundary_id - 1, new_node_pt);
            }
            // Otherwise construct a normal node
            else
            {
              new_node_pt = elem_pt->construct_node(n, time_stepper_pt);
            }

            // What are the node's local coordinates?
            elem_pt->local_coordinate_of_node(n, s);

            // Find the coordinates of the new node from the existing
            // and fully-functional element in the scaffold mesh
            for (unsigned i = 0; i < dim; i++)
            {
              new_node_pt->x(i) = tmp_elem_pt->interpolated_x(s, i);
            }

            // Add to the global node list
            Node_pt.push_back(new_node_pt);

            // Add to the edge index
            nodes_on_global_edge[edge_index].push_back(new_node_pt);
            // Increment the node number
            ++n;
          }
        }
        // Otherwise just set the pointers
        // using the fact that the next time the edge is visited
        // the nodes must be arranged in the other order because all
        // triangles have the same orientation
        else
        {
          // Loop over the nodes on the edge excluding the ends
          for (unsigned j2 = 0; j2 < n_node_1d - 2; ++j2)
          {
            // Set the local node from the edge but indexed the other
            // way around
            elem_pt->node_pt(n) =
              nodes_on_global_edge[edge_index][n_node_1d - 3 - j2];
            ++n;
          }
        }

        // Set the elements adjacent to the boundary from the
        // boundary id information
        if (boundary_id > 0)
        {
          Boundary_element_pt[boundary_id - 1].push_back(elem_pt);
          // Need to put a shift in here because of an inconsistent naming
          // convention between triangle and face elements
          Face_index_at_boundary[boundary_id - 1].push_back((j + 2) % 3);

          // If using regions set up the boundary information
          if (use_attributes)
          {
            unsigned tmp_region =
              static_cast<unsigned>(Tmp_mesh_pt->element_attribute(e));
            // Element adjacent to boundary
            Boundary_region_element_pt[boundary_id - 1][tmp_region].push_back(
              elem_pt);
            // Need to put a shift in here because of an inconsistent naming
            // convention between triangle and face elements
            Face_index_region_at_boundary[boundary_id - 1][tmp_region]
              .push_back((j + 2) % 3);
          }
        }

      } // end of loop over edges
    } // end of loop over elements


    // Lookup scheme has now been setup
    Lookup_for_elements_next_boundary_is_setup = true;
  }

#ifdef OOMPH_HAS_MPI

  //======================================================================
  /// Identify the segments from the old mesh (original mesh)
  /// in the new mesh (this) and assign initial and final boundary
  /// coordinates for the segments that create the boundary
  //======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::
    identify_boundary_segments_and_assign_initial_zeta_values(
      const unsigned& b, TriangleMesh<ELEMENT>* original_mesh_pt)
  {
    // ------------------------------------------------------------------
    // First: Get the face elements associated with the current boundary
    // (nonhalo elements only)
    // ------------------------------------------------------------------
    // Temporary storage for face elements
    Vector<FiniteElement*> face_el_pt;

    // Temporary storage for number of elements adjacent to the boundary
    unsigned nele = 0;

    // Temporary storage for elements adjacent to the boundary that have
    // a common edge (related with internal boundaries)
    unsigned n_repeated_ele = 0;

    const unsigned n_regions = this->nregion();

    // map to associate the face element to the bulk element, necessary
    // to attach halo face elements at both sides of each found segment
    std::map<FiniteElement*, FiniteElement*> face_to_bulk_element_pt;

    // Temporary storage for already done nodes
    Vector<std::pair<Node*, Node*>> done_nodes_pt;

    // If there is more than one region then only use boundary
    // coordinates from the bulk side (region 0)
    if (n_regions > 1)
    {
      for (unsigned rr = 0; rr < n_regions; rr++)
      {
        const unsigned region_id =
          static_cast<unsigned>(this->Region_attribute[rr]);

        // Loop over all elements on boundaries in region i_r
        const unsigned nel_in_region =
          this->nboundary_element_in_region(b, region_id);

        unsigned nel_repetead_in_region = 0;

        // Only bother to do anything else, if there are elements
        // associated with the boundary and the current region
        if (nel_in_region > 0)
        {
          // Flag that activates when a repeated face element is found,
          // possibly because we are dealing with an internal boundary
          bool repeated = false;

          // Loop over the bulk elements adjacent to boundary b
          for (unsigned e = 0; e < nel_in_region; e++)
          {
            // Get pointer to the bulk element that is adjacent to boundary b
            FiniteElement* bulk_elem_pt =
              this->boundary_element_in_region_pt(b, region_id, e);

#ifdef OOMPH_HAS_MPI
            // In a distributed mesh only work with nonhalo elements
            if (this->is_mesh_distributed() && bulk_elem_pt->is_halo())
            {
              // Increase the number of repeated elements
              n_repeated_ele++;
              // Go for the next element
              continue;
            }
#endif

            // Find the index of the face of element e along boundary b
            int face_index =
              this->face_index_at_boundary_in_region(b, region_id, e);

            // Before adding the new element we need to be sure that
            // the edge that this element represent has not been
            // already added
            FiniteElement* tmp_ele_pt =
              new DummyFaceElement<ELEMENT>(bulk_elem_pt, face_index);

            const unsigned n_nodes = tmp_ele_pt->nnode();

            std::pair<Node*, Node*> tmp_pair = std::make_pair(
              tmp_ele_pt->node_pt(0), tmp_ele_pt->node_pt(n_nodes - 1));

            std::pair<Node*, Node*> tmp_pair_inverse = std::make_pair(
              tmp_ele_pt->node_pt(n_nodes - 1), tmp_ele_pt->node_pt(0));

            // Search for repeated nodes
            const unsigned n_done_nodes = done_nodes_pt.size();
            for (unsigned l = 0; l < n_done_nodes; l++)
            {
              if (tmp_pair == done_nodes_pt[l] ||
                  tmp_pair_inverse == done_nodes_pt[l])
              {
                nel_repetead_in_region++;
                repeated = true;
                break;
              }
            }

            // Create new face element
            if (!repeated)
            {
              // Add the pair of nodes (edge) to the node dones
              done_nodes_pt.push_back(tmp_pair);
              // Create the map to know if the element is halo
              face_el_pt.push_back(tmp_ele_pt);
              // Add the element to the face elements
              face_to_bulk_element_pt[tmp_ele_pt] = bulk_elem_pt;
            }
            else
            {
              // Clean up
              delete tmp_ele_pt;
              tmp_ele_pt = 0;
            }

            // Re-start
            repeated = false;

          } // for (e < nel_in_region)

          nele += nel_in_region;

          n_repeated_ele += nel_repetead_in_region;

        } // if (nel_in_region > 0)
      } // for (rr < n_regions)
    } // if (n_regions > 1)
    // Otherwise it's just the normal boundary functions
    else
    {
      // Loop over all elements on boundaries
      nele = this->nboundary_element(b);

      // Only bother to do anything else, if there are elements
      if (nele > 0)
      {
        // Flag that activates when a repeated face element is found,
        // possibly because we are dealing with an internal boundary
        bool repeated = false;

        // Loop over the bulk elements adjacent to boundary b
        for (unsigned e = 0; e < nele; e++)
        {
          // Get pointer to the bulk element that is adjacent to boundary b
          FiniteElement* bulk_elem_pt = this->boundary_element_pt(b, e);

#ifdef OOMPH_HAS_MPI
          // In a distributed mesh only work with nonhalo elements
          if (this->is_mesh_distributed() && bulk_elem_pt->is_halo())
          {
            // Increase the number of repeated elements
            n_repeated_ele++;
            // Go for the next element
            continue;
          }
#endif

          // Find the index of the face of element e along boundary b
          int face_index = this->face_index_at_boundary(b, e);

          // Before adding the new element we need to be sure that
          // the edge that this element represents has not been
          // already added (only applies for internal boundaries)
          FiniteElement* tmp_ele_pt =
            new DummyFaceElement<ELEMENT>(bulk_elem_pt, face_index);

          const unsigned n_nodes = tmp_ele_pt->nnode();

          std::pair<Node*, Node*> tmp_pair = std::make_pair(
            tmp_ele_pt->node_pt(0), tmp_ele_pt->node_pt(n_nodes - 1));

          std::pair<Node*, Node*> tmp_pair_inverse = std::make_pair(
            tmp_ele_pt->node_pt(n_nodes - 1), tmp_ele_pt->node_pt(0));

          // Search for repeated nodes
          const unsigned n_done_nodes = done_nodes_pt.size();
          for (unsigned l = 0; l < n_done_nodes; l++)
          {
            if (tmp_pair == done_nodes_pt[l] ||
                tmp_pair_inverse == done_nodes_pt[l])
            {
              // Increase the number of repeated elements
              n_repeated_ele++;
              // Mark the element as repeated
              repeated = true;
              break;
            }
          }

          // Create new face element
          if (!repeated)
          {
            // Add the pair of nodes (edge) to the node dones
            done_nodes_pt.push_back(tmp_pair);
            // Add the element to the face elements
            face_el_pt.push_back(tmp_ele_pt);
            // Create the map to know if the element is halo
            face_to_bulk_element_pt[tmp_ele_pt] = bulk_elem_pt;
          }
          else
          {
            // Free the repeated bulk element!!
            delete tmp_ele_pt;
            tmp_ele_pt = 0;
          }

          // Re-start
          repeated = false;

        } // for (e < nel)
      } // if (nel > 0)

    } // else (n_regions > 1)

    // Do not consider the repeated elements
    nele -= n_repeated_ele;

#ifdef PARANOID
    if (nele != face_el_pt.size())
    {
      std::ostringstream error_message;
      error_message
        << "The independent counting of face elements (" << nele << ") for "
        << "boundary (" << b << ") is different\n"
        << "from the real number of face elements in the container ("
        << face_el_pt.size() << ")\n";
      throw OomphLibError(error_message.str(),
                          "TriangleMesh::identify_boundary_segments_and_assign_"
                          "initial_zeta_values()",
                          OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Continue even thought there are no elements, the processor needs
    // to participate in the communications

    // ----------------------------------------------------------------
    // Second: Sort the face elements, only consider nonhalo elements
    // ----------------------------------------------------------------

    // A flag vector to mark those face elements that are considered as
    // halo in the current processor
    std::vector<bool> is_halo_face_element(nele, false);

    // Count the total number of non halo face elements
    unsigned nnon_halo_face_elements = 0;

    // We will have halo face elements if the mesh is distributed
    for (unsigned ie = 0; ie < nele; ie++)
    {
      // Get the face element
      FiniteElement* face_ele_pt = face_el_pt[ie];
      // Get the bulk element
      FiniteElement* tmp_bulk_ele_pt = face_to_bulk_element_pt[face_ele_pt];
      // Check if the bulk element is halo
      if (!tmp_bulk_ele_pt->is_halo())
      {
        is_halo_face_element[ie] = false;
        nnon_halo_face_elements++;
      }
      else
      {
        // Mark the face element as halo
        is_halo_face_element[ie] = true;
      }
    } // for (ie < nele)

#ifdef PARANOID
    // Get the total number of halo face elements
    const unsigned nhalo_face_element = nele - nnon_halo_face_elements;
    if (nhalo_face_element > 0)
    {
      std::ostringstream error_message;
      error_message
        << "There should not be halo face elements since they were not "
        << "considered when computing the face elements\n\n"
        << "The number of found halo face elements is: " << nhalo_face_element
        << "\n\n";
      throw OomphLibError(error_message.str(),
                          "TriangleMesh::identify_boundary_segments_and_assign_"
                          "initial_zeta_values()",
                          OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // The vector of list to store the "segments" that compound the
    // boundary (segments may appear only in a distributed mesh)
    Vector<std::list<FiniteElement*>> segment_sorted_ele_pt;

    // Number of already sorted face elements (only nonhalo elements for
    // a distributed mesh)
    unsigned nsorted_face_elements = 0;

    // Keep track of who's done (this apply to nonhalo only, remember we
    // are only working with nonhalo elements)
    std::map<FiniteElement*, bool> done_el;

    // Keep track of which element is inverted (in distributed mesh the
    // elements may be inverted with respect to the segment they belong)
    std::map<FiniteElement*, bool> is_inverted;

    // Iterate until all possible segments have been created
    while (nsorted_face_elements < nnon_halo_face_elements)
    {
      // The ordered list of face elements (in a distributed mesh a
      // collection of contiguous face elements define a segment)
      std::list<FiniteElement*> sorted_el_pt;
      sorted_el_pt.clear();

#ifdef PARANOID
      // Select an initial element for the segment
      bool found_initial_face_element = false;
#endif

      FiniteElement* ele_face_pt = 0;

      unsigned iface = 0;
      for (iface = 0; iface < nele; iface++)
      {
        if (!is_halo_face_element[iface])
        {
          ele_face_pt = face_el_pt[iface];
          // If not done then take it as initial face element
          if (!done_el[ele_face_pt])
          {
#ifdef PARANOID
            found_initial_face_element = true;
#endif
            nsorted_face_elements++;
            iface++; // The next element number
            sorted_el_pt.push_back(ele_face_pt);
            // Mark as done
            done_el[ele_face_pt] = true;
            break;
          }
        }
      } // for (iface < nele)

#ifdef PARANOID
      if (!found_initial_face_element)
      {
        std::ostringstream error_message;
        error_message
          << "Could not find an initial face element for the current segment\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::identify_boundary_segments_and_"
                            "assign_initial_zeta_values()",
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Number of nodes
      const unsigned nnod = ele_face_pt->nnode();

      // Left and right most nodes (the left and right nodes of the
      // current face element)
      Node* left_node_pt = ele_face_pt->node_pt(0);
      Node* right_node_pt = ele_face_pt->node_pt(nnod - 1);

      // Continue iterating if a new face element has been added to the
      // list
      bool face_element_added = false;

      // While a new face element has been added to the set of sorted
      // face elements then re-iterate
      do
      {
        // Start from the next face element since we have already added
        // the previous one as the initial face element (any previous
        // face element had to be added on previous iterations)
        for (unsigned iiface = iface; iiface < nele; iiface++)
        {
          // Re-start flag
          face_element_added = false;

          // Get the candidate element
          ele_face_pt = face_el_pt[iiface];

          // Check that the candidate element has not been done and is
          // not a halo element
          if (!(done_el[ele_face_pt] || is_halo_face_element[iiface]))
          {
            // Get the left and right nodes of the current element
            Node* local_left_node_pt = ele_face_pt->node_pt(0);
            Node* local_right_node_pt = ele_face_pt->node_pt(nnod - 1);
            // New element fits at the left of segment and is not inverted
            if (left_node_pt == local_right_node_pt)
            {
              left_node_pt = local_left_node_pt;
              sorted_el_pt.push_front(ele_face_pt);
              is_inverted[ele_face_pt] = false;
              face_element_added = true;
            }
            // New element fits at the left of segment and is inverted
            else if (left_node_pt == local_left_node_pt)
            {
              left_node_pt = local_right_node_pt;
              sorted_el_pt.push_front(ele_face_pt);
              is_inverted[ele_face_pt] = true;
              face_element_added = true;
            }
            // New element fits on the right of segment and is not inverted
            else if (right_node_pt == local_left_node_pt)
            {
              right_node_pt = local_right_node_pt;
              sorted_el_pt.push_back(ele_face_pt);
              is_inverted[ele_face_pt] = false;
              face_element_added = true;
            }
            // New element fits on the right of segment and is inverted
            else if (right_node_pt == local_right_node_pt)
            {
              right_node_pt = local_left_node_pt;
              sorted_el_pt.push_back(ele_face_pt);
              is_inverted[ele_face_pt] = true;
              face_element_added = true;
            }

            if (face_element_added)
            {
              done_el[ele_face_pt] = true;
              nsorted_face_elements++;
              break;
            }

          } // if (!(done_el[ele_face_pt] || is_halo_face_element[iiface]))
        } // for (iiface<nnon_halo_face_element)
      } while (face_element_added &&
               (nsorted_face_elements < nnon_halo_face_elements));

      // Store the created segment in the vector of segments
      segment_sorted_ele_pt.push_back(sorted_el_pt);

    } // while(nsorted_face_elements < nnon_halo_face_elements);

    // The number of segments in this processor
    const unsigned nsegments = segment_sorted_ele_pt.size();

    // ------------------------------------------------------------------
    // Third: We have the face elements sorted (nonhalo only), now
    // assign boundary coordinates to the nodes in the segments. This is
    // the LOCAL boundary coordinate which is required if the zeta
    // values need to be inverted
    // ------------------------------------------------------------------
    // Necessary in case boundaries with no geom object associated need
    // to be inverted the zeta values (It is necessary to compute the
    // arclength but also to store the nodes in a container (set))
    // ------------------------------------------------------------------

    // Vector of sets that stores the nodes of each segment based on a
    // lexicographically order starting from the bottom left node of
    // each segment
    Vector<std::set<Node*>> segment_all_nodes_pt;

    // The arclength of each segment in the current processor
    Vector<double> segment_arclength(nsegments);

    // The number of vertices of each segment
    Vector<unsigned> nvertices_per_segment(nsegments);

    // The initial zeta for the segment
    Vector<double> initial_zeta_segment(nsegments);

    // The final zeta for the segment
    Vector<double> final_zeta_segment(nsegments);

#ifdef PARANOID
    if (nnon_halo_face_elements > 0 && nsegments == 0)
    {
      std::ostringstream error_message;
      error_message
        << "The number of segments is zero, but the number of nonhalo\n"
        << "elements is: (" << nnon_halo_face_elements << ")\n";
      throw OomphLibError(error_message.str(),
                          "TriangleMesh::identify_boundary_segments_and_assign_"
                          "initial_zeta_values()",
                          OOMPH_EXCEPTION_LOCATION);
    } // if (nnon_halo_face_elements > 0 && nsegments == 0)
#endif

    // Go through all the segments and compute the LOCAL boundary
    // coordinates
    for (unsigned is = 0; is < nsegments; is++)
    {
#ifdef PARANOID
      if (segment_sorted_ele_pt[is].size() == 0)
      {
        std::ostringstream error_message;
        error_message << "The (" << is << ")-th segment has no elements\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::identify_boundary_segments_and_"
                            "assign_initial_zeta_values()",
                            OOMPH_EXCEPTION_LOCATION);
      } // if (segment_sorted_ele_pt[is].size() == 0)
#endif

      // Get access to the first element on the segment
      FiniteElement* first_ele_pt = segment_sorted_ele_pt[is].front();

      // Number of nodes
      const unsigned nnod = first_ele_pt->nnode();

      // Get the first node of the current segment
      Node* first_node_pt = first_ele_pt->node_pt(0);
      if (is_inverted[first_ele_pt])
      {
        first_node_pt = first_ele_pt->node_pt(nnod - 1);
      }

      // Get access to the last element on the segment
      FiniteElement* last_ele_pt = segment_sorted_ele_pt[is].back();

      // Get the last node of the current segment
      Node* last_node_pt = last_ele_pt->node_pt(nnod - 1);
      if (is_inverted[last_ele_pt])
      {
        last_node_pt = last_ele_pt->node_pt(0);
      }

      // Coordinates of left node
      double x_left = first_node_pt->x(0);
      double y_left = first_node_pt->x(1);

      // Initialise boundary coordinate (local boundary coordinate for
      // boundaries with more than one segment)
      Vector<double> zeta(1, 0.0);

      // If the boundary has an associated GeomObject then it is not
      // necessary to compute the arclength, only read the values from
      // the nodes at the edges
      if (this->boundary_geom_object_pt(b) != 0)
      {
        first_node_pt->get_coordinates_on_boundary(b, zeta);
        initial_zeta_segment[is] = zeta[0];
        last_node_pt->get_coordinates_on_boundary(b, zeta);
        final_zeta_segment[is] = zeta[0];
      }

      // Lexicographically bottom left node
      std::set<Node*> local_nodes_pt;
      local_nodes_pt.insert(first_node_pt);

      // Now loop over nodes in order
      for (std::list<FiniteElement*>::iterator it =
             segment_sorted_ele_pt[is].begin();
           it != segment_sorted_ele_pt[is].end();
           it++)
      {
        // Get element
        FiniteElement* el_pt = *it;

        // Start node and increment
        unsigned k_nod = 1;
        int nod_diff = 1;
        if (is_inverted[el_pt])
        {
          k_nod = nnod - 2;
          nod_diff = -1;
        }

        // Loop over nodes
        for (unsigned j = 1; j < nnod; j++)
        {
          Node* nod_pt = el_pt->node_pt(k_nod);
          k_nod += nod_diff;

          // Coordinates of right node
          double x_right = nod_pt->x(0);
          double y_right = nod_pt->x(1);

          // Increment boundary coordinate (the arclength)
          zeta[0] += sqrt((x_right - x_left) * (x_right - x_left) +
                          (y_right - y_left) * (y_right - y_left));

          // // When we have a GeomObject associated to the boundary we already
          // // know the zeta values for the nodes, there is no need to compute
          // // the arclength
          // if (this->boundary_geom_object_pt(b)==0)
          //  {
          //   // Set boundary coordinate
          //   nod_pt->set_coordinates_on_boundary(b, zeta);
          //  }

          // Increment reference coordinate
          x_left = x_right;
          y_left = y_right;

          // Get lexicographically bottom left node but only
          // use vertex nodes as candidates
          local_nodes_pt.insert(nod_pt);
        } // for (j < nnod)

      } // iterator over the elements in the segment

      // Store the arclength of the segment
      segment_arclength[is] = zeta[0];

      // Store the number of vertices in the segment
      nvertices_per_segment[is] = local_nodes_pt.size();

      // Add the nodes for the corresponding segment in the container
      segment_all_nodes_pt.push_back(local_nodes_pt);

    } // for (is < nsegments)

    // Get the number of sets for nodes
#ifdef PARANOID
    if (segment_all_nodes_pt.size() != nsegments)
    {
      std::ostringstream error_message;
      error_message << "The number of segments (" << nsegments
                    << ") and the number of "
                    << "sets of nodes (" << segment_all_nodes_pt.size()
                    << ") representing\n"
                    << "the\nsegments is different!!!\n\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Store the initial arclength for each segment of boundary in the
    // current processor, initalise to zero in case we have a non
    // distributed boundary
    Vector<double> initial_segment_arclength(nsegments, 0.0);

    // Associated the index of the current segment to the segment index
    // in the original mesh (input mesh)
    Vector<unsigned> current_segment_to_original_segment_index(nsegments);

    // Each segment needs to know whether it has to be inverted or not
    // Store whether a segment needs to be inverted or not
    Vector<unsigned> segment_inverted(nsegments);

    // -----------------------------------------------------------------
    // Fourth: Identify the segments with the ones in the original mesh
    // (has sense only in the adaptation process)
    // -----------------------------------------------------------------

    // Now check if there are segments associated to this boundary
    if (nsegments > 0)
    {
#ifdef PARANOID
      // Double check that the same number of coordinates (nsegments)
      // have been established for the boundary
      const unsigned nsegments_initial_coordinates =
        original_mesh_pt->boundary_segment_initial_coordinate(b).size();

      const unsigned nsegments_final_coordinates =
        original_mesh_pt->boundary_segment_final_coordinate(b).size();

      if (nsegments_initial_coordinates != nsegments_final_coordinates)
      {
        std::stringstream error_message;
        error_message
          << "The number of segments that present initial coordinates "
          << nsegments_initial_coordinates << " is different from "
          << "the\nnumber of segments that present final coordinates "
          << nsegments_final_coordinates << "\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      } // if (nsegments_initial_coordinates!=nsegments_final_coordinates)

      // Also check that the number of segments found in the previous
      // mesh is the same as the number of segments found in this mesh
      if (nsegments_initial_coordinates != nsegments)
      {
        std::stringstream error_message;
        error_message << "Working with boundary (" << b
                      << ").\n The number of initial and "
                      << "final coordinates (" << nsegments_initial_coordinates
                      << ") is different from\n"
                      << "the number of found segments (" << nsegments
                      << ").\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      } // if (nsegments_initial_coordinates != nsegments)
#endif

      // Create a backup for the data from the original mesh
      // Backup for the coordinates
      Vector<Vector<double>> original_mesh_segment_initial_coordinate(
        nsegments);
      Vector<Vector<double>> original_mesh_segment_final_coordinate(nsegments);
      // Backup for the zeta values
      Vector<double> original_mesh_segment_initial_zeta(nsegments);
      Vector<double> original_mesh_segment_final_zeta(nsegments);
      // Backup for the arclengths
      Vector<double> original_mesh_segment_initial_arclength(nsegments);
      Vector<double> original_mesh_segment_final_arclength(nsegments);
      // Do the backup
      for (unsigned is = 0; is < nsegments; is++)
      {
        original_mesh_segment_initial_coordinate[is].resize(2);
        original_mesh_segment_final_coordinate[is].resize(2);
        for (unsigned k = 0; k < 2; k++)
        {
          original_mesh_segment_initial_coordinate[is][k] =
            original_mesh_pt->boundary_segment_initial_coordinate(b)[is][k];
          original_mesh_segment_final_coordinate[is][k] =
            original_mesh_pt->boundary_segment_final_coordinate(b)[is][k];
        }
        // Check if the boudary has an associated GeomObject
        if (this->boundary_geom_object_pt(b) != 0)
        {
          original_mesh_segment_initial_zeta[is] =
            original_mesh_pt->boundary_segment_initial_zeta(b)[is];
          original_mesh_segment_final_zeta[is] =
            original_mesh_pt->boundary_segment_final_zeta(b)[is];
        }
        else
        {
          original_mesh_segment_initial_arclength[is] =
            original_mesh_pt->boundary_segment_initial_arclength(b)[is];
          original_mesh_segment_final_arclength[is] =
            original_mesh_pt->boundary_segment_final_arclength(b)[is];
        }
      } // for (is < nsegments)

      // Clear all the storage
      Boundary_segment_inverted[b].clear();
      Boundary_segment_initial_coordinate[b].clear();
      Boundary_segment_final_coordinate[b].clear();

      Boundary_segment_initial_zeta[b].clear();
      Boundary_segment_final_zeta[b].clear();

      Boundary_segment_initial_arclength[b].clear();
      Boundary_segment_final_arclength[b].clear();

      // Identify each segment in the processor with the ones created
      // by the original mesh
      // -----------------------------------------------------------------
      // Keep track of the already identified segments
      std::map<unsigned, bool> segment_done;
      for (unsigned is = 0; is < nsegments; is++)
      {
#ifdef PARANOID
        // Flag to know if the segment was identified
        bool found_original_segment = false;
#endif

        // Get the initial and final coordinates of the current segment
        Vector<double> current_seg_initial_coord(2);
        Vector<double> current_seg_final_coord(2);

        // Get access to the initial element on the segment
        FiniteElement* current_seg_initial_ele_pt =
          segment_sorted_ele_pt[is].front();

        // Number of nodes
        const unsigned nnod = current_seg_initial_ele_pt->nnode();

        // Get the first node of the current segment
        Node* current_seg_first_node_pt =
          current_seg_initial_ele_pt->node_pt(0);
        if (is_inverted[current_seg_initial_ele_pt])
        {
          current_seg_first_node_pt =
            current_seg_initial_ele_pt->node_pt(nnod - 1);
        }

        // Get access to the last element on the segment
        FiniteElement* current_seg_last_ele_pt =
          segment_sorted_ele_pt[is].back();

        // Get the last node of the current segment
        Node* current_seg_last_node_pt =
          current_seg_last_ele_pt->node_pt(nnod - 1);
        if (is_inverted[current_seg_last_ele_pt])
        {
          current_seg_last_node_pt = current_seg_last_ele_pt->node_pt(0);
        }

        // Get the coordinates for the first and last seg node
        for (unsigned i = 0; i < 2; i++)
        {
          current_seg_initial_coord[i] = current_seg_first_node_pt->x(i);
          current_seg_final_coord[i] = current_seg_last_node_pt->x(i);
        }

        // We have got the initial and final coordinates of the current
        // segment, compare those with the initial and final coordinates
        // of the original mesh segments to identify which segments is
        // which
        for (unsigned orig_s = 0; orig_s < nsegments; orig_s++)
        {
          if (!segment_done[orig_s])
          {
            // Get the coordinates to compare
            Vector<double> initial_coordinate =
              original_mesh_segment_initial_coordinate[orig_s];
            Vector<double> final_coordinate =
              original_mesh_segment_final_coordinate[orig_s];

            // Compute the distance initial(current)-initial(original)
            // coordinates
            double dist =
              ((current_seg_initial_coord[0] - initial_coordinate[0]) *
               (current_seg_initial_coord[0] - initial_coordinate[0])) +
              ((current_seg_initial_coord[1] - initial_coordinate[1]) *
               (current_seg_initial_coord[1] - initial_coordinate[1]));
            dist = sqrt(dist);

            // If the initial node is the same, check for the last node
            if (dist < ToleranceForVertexMismatchInPolygons::Tolerable_error)
            {
              // Compute the distance final(current)-final(original)
              // coordinates
              dist = ((current_seg_final_coord[0] - final_coordinate[0]) *
                      (current_seg_final_coord[0] - final_coordinate[0])) +
                     ((current_seg_final_coord[1] - final_coordinate[1]) *
                      (current_seg_final_coord[1] - final_coordinate[1]));
              dist = sqrt(dist);

              // The final node is the same, we have identified the
              // segments
              if (dist < ToleranceForVertexMismatchInPolygons::Tolerable_error)
              {
                // Store the index that relates the previous index with the
                // current one
                current_segment_to_original_segment_index[is] = orig_s;

                // In this case the segment is not inverted
                Boundary_segment_inverted[b].push_back(0);

                // Copy the initial and final coordinates for each segment
                Boundary_segment_initial_coordinate[b].push_back(
                  initial_coordinate);
                Boundary_segment_final_coordinate[b].push_back(
                  final_coordinate);

                // Check if the boundary has an associated GeomObject
                if (this->boundary_geom_object_pt(b) != 0)
                {
                  // Copy the initial zeta value for the segment
                  Boundary_segment_initial_zeta[b].push_back(
                    original_mesh_segment_initial_zeta[orig_s]);
                  Boundary_segment_final_zeta[b].push_back(
                    original_mesh_segment_final_zeta[orig_s]);
                }
                else
                {
                  // Copy the initial and final arclength for each
                  // segment
                  Boundary_segment_initial_arclength[b].push_back(
                    original_mesh_segment_initial_arclength[orig_s]);
                  Boundary_segment_final_arclength[b].push_back(
                    original_mesh_segment_final_arclength[orig_s]);
                }
                // Mark the segment as done
                segment_done[orig_s] = true;
#ifdef PARANOID
                found_original_segment = true;
#endif
                break;
              } // The final(current) node matched with the
                // final(original) node
            } // The initial(current) node matched with the
              // initial(original) node
            else
            {
              // Check the inverted case Compute the distance
              // initial(current)-final(original) coordinates
              double dist_inv =
                ((current_seg_initial_coord[0] - final_coordinate[0]) *
                 (current_seg_initial_coord[0] - final_coordinate[0])) +
                ((current_seg_initial_coord[1] - final_coordinate[1]) *
                 (current_seg_initial_coord[1] - final_coordinate[1]));
              dist_inv = sqrt(dist_inv);

              // If the initial node is the same as the final node of
              // the segment, check for the last node
              if (dist_inv <
                  ToleranceForVertexMismatchInPolygons::Tolerable_error)
              {
                // Compute the distance final(current)-initial(original)
                // coordinates
                dist_inv =
                  ((current_seg_final_coord[0] - initial_coordinate[0]) *
                   (current_seg_final_coord[0] - initial_coordinate[0])) +
                  ((current_seg_final_coord[1] - initial_coordinate[1]) *
                   (current_seg_final_coord[1] - initial_coordinate[1]));
                dist_inv = sqrt(dist_inv);

                // The final node is the same as the initial node, we
                // have identified the segments
                if (dist_inv <
                    ToleranceForVertexMismatchInPolygons::Tolerable_error)
                {
                  // Store the index that related the previous index with the
                  // current one
                  current_segment_to_original_segment_index[is] = orig_s;

                  // In this case the segment is inverted
                  Boundary_segment_inverted[b].push_back(1);

                  // Copy the initial and final coordinates for each segment
                  Boundary_segment_initial_coordinate[b].push_back(
                    initial_coordinate);
                  Boundary_segment_final_coordinate[b].push_back(
                    final_coordinate);

                  // Check that the boudary has an associated GeomObject
                  if (this->boundary_geom_object_pt(b) != 0)
                  {
                    // Copy the initial zeta value for the segments
                    Boundary_segment_initial_zeta[b].push_back(
                      original_mesh_segment_initial_zeta[orig_s]);
                    Boundary_segment_final_zeta[b].push_back(
                      original_mesh_segment_final_zeta[orig_s]);
                  }
                  else
                  {
                    // Copy the initial and final arclength for each segment
                    Boundary_segment_initial_arclength[b].push_back(
                      original_mesh_segment_initial_arclength[orig_s]);
                    Boundary_segment_final_arclength[b].push_back(
                      original_mesh_segment_final_arclength[orig_s]);
                  }
                  // Mark the segment as done
                  segment_done[orig_s] = true;
#ifdef PARANOID
                  found_original_segment = true;
#endif
                  break;
                } // The final(current) node matched with the
                  // initial(original) node
              } // The initial(current) node matched with the
                // final(original) node
            } // else (the first(current) node did not matched with the
              // first(original) node. Else do the inverted case

          } // (!segment_done[orig_s])

        } // (orig_s < nsegments)

#ifdef PARANOID
        if (!found_original_segment)
        {
          std::stringstream error_message;
          error_message
            << "The (" << is << ")-th segment on the current segment was not\n"
            << "found when trying to identify it with the original mesh's\n"
            << "segment coordinates\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        } // if (!found_original_segment)
#endif
      } // for (is < nsegments)

    } // if (nsegments > 0)

    // -------------------------------------------------------------------
    // Fourth: The original mesh is different from the current mesh
    // (this). For boundaries with no geom object associated check if it
    // is required to reverse the zeta values. In order to reverse the
    // zeta values it is required to previously compute the arclength of
    // the segments and store the nodes in a container (set). NOTE that
    // the setup_boundary_coordinate() method is not called for
    // boundaries with NO GeomObject associated, so this is the LAST
    // CHANCE to do it
    // -------------------------------------------------------------------
    // The original mesh is the same as the current mesh (this). The
    // setup_boundary_method() will be called only for the boundaries
    // with NO GeomObject associated
    // -------------------------------------------------------------------
    if (this != original_mesh_pt)
    {
      // Get the boundary arclength

      // Get the initial and final zeta values for the boundary
      // (arclength) from the original mesh
      Vector<double> first_node_zeta_coordinate =
        original_mesh_pt->boundary_initial_zeta_coordinate(b);
      Vector<double> last_node_zeta_coordinate =
        original_mesh_pt->boundary_final_zeta_coordinate(b);

      // The boundary arclength is the maximum of the initial and final
      // zeta coordinate
      const double boundary_arclength =
        std::max(first_node_zeta_coordinate[0], last_node_zeta_coordinate[0]);

      for (unsigned is = 0; is < nsegments; is++)
      {
        // Here check if need to invert the elements and the boundary
        // coordinates for the segments in a boundary with no GeomObject
        // associated
        if (boundary_geom_object_pt(b) == 0)
        {
          // This case only applies for the initial and iterative mesh in
          // the adaptation process because the method
          // setup_boundary_coordinates() is called by the original mesh
          // for boundaries with no GeomObject associated

          // We are goind to check if it is necessary to invert the order
          // of the zeta values

          // Get the first and last node of the current segment and their
          // zeta values (arclength)

          // There is no need to check for nonhalo elements since the
          // container has only nonhalo face elements

          // Get access to the first element on the segment
          FiniteElement* first_ele_pt = segment_sorted_ele_pt[is].front();

          // Number of nodes
          const unsigned nnod = first_ele_pt->nnode();

          // Get the first node of the current segment
          Node* first_node_pt = first_ele_pt->node_pt(0);
          if (is_inverted[first_ele_pt])
          {
            first_node_pt = first_ele_pt->node_pt(nnod - 1);
          }

          // Get access to the last element on the segment
          FiniteElement* last_ele_pt = segment_sorted_ele_pt[is].back();

          // Get the last node of the current segment
          Node* last_node_pt = last_ele_pt->node_pt(nnod - 1);
          if (is_inverted[last_ele_pt])
          {
            last_node_pt = last_ele_pt->node_pt(0);
          }

          // Get the zeta coordinates for the first and last node
          Vector<double> current_segment_initial_arclen(1);
          Vector<double> current_segment_final_arclen(1);
          // Is the segment in the current mesh (this) inverted?
          if (!Boundary_segment_inverted[b][is]) // Not inverted
          {
            first_node_pt->get_coordinates_on_boundary(
              b, current_segment_initial_arclen);
            last_node_pt->get_coordinates_on_boundary(
              b, current_segment_final_arclen);
          }
          else // Inverted
          {
            first_node_pt->get_coordinates_on_boundary(
              b, current_segment_final_arclen);
            last_node_pt->get_coordinates_on_boundary(
              b, current_segment_initial_arclen);
          }

          // Once the zeta values have been obtained check if they are set
          // in increasing or decreasing order

          // Flag to state that the values in the segment are in increasing
          // order
          bool increasing_order = false;

          // If the initial zeta value is smaller than the final zeta
          // value then they are in increasing order
          if (current_segment_initial_arclen[0] <
              current_segment_final_arclen[0])
          {
            increasing_order = true;
          }
          // If the initial zeta value is greater than the initial zeta
          // value then they are in decreasing order
          else if (current_segment_initial_arclen[0] >
                   current_segment_final_arclen[0])
          {
            increasing_order = false;
          }
#ifdef PARANOID
          else
          {
            std::stringstream error_message;
            error_message
              << "It was not possible to identify if the zeta values on "
              << "boundary (" << b << ")\nand segment (" << is
              << ") should go in "
              << "increasing or decreasing order.\n--- New mesh ---\n"
              << "Current segment initial arclength: ("
              << current_segment_initial_arclen[0] << ")\n"
              << "First node coordinates: (" << first_node_pt->x(0) << ",  "
              << first_node_pt->x(1) << ")\n"
              << "Current segment final arclength: ("
              << current_segment_final_arclen[0] << ")\n"
              << "Last node coordinates: (" << last_node_pt->x(0) << ",  "
              << last_node_pt->x(1) << ")\n"
              << "Current segment arclength: (" << segment_arclength[is]
              << ")\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }
#endif

          // Now get the original initial and final arclengths and check
          // if they are in increasing or decreasing order
          const unsigned prev_s = current_segment_to_original_segment_index[is];
          const double original_segment_initial_arclength =
            original_mesh_pt->boundary_segment_initial_arclength(b)[prev_s];
          const double original_segment_final_arclength =
            original_mesh_pt->boundary_segment_final_arclength(b)[prev_s];

          // Flag to check if the values go in increasing or decreasing
          // order in the original mesh segment
          bool original_increasing_order = false;

          // Now check if the arclengths on the original mesh go in
          // increase or decrease order, this is also used to choose the
          // starting value to map the values in the current segment
          double starting_arclength = 0.0;
          if (original_segment_final_arclength >
              original_segment_initial_arclength)
          {
            // ... in increasing order in the original mesh ...
            original_increasing_order = true;
            // Select the starting arclength
            starting_arclength = original_segment_initial_arclength;
          }
          else if (original_segment_final_arclength <
                   original_segment_initial_arclength)
          {
            // ... in decreasing order in the original mesh ...
            original_increasing_order = false;
            // Select the starting arclength
            starting_arclength = original_segment_final_arclength;
          }
#ifdef PARANOID
          else
          {
            std::stringstream error_message;
            error_message
              << "It was not possible to identify if the zeta values on "
              << "boundary (" << b << ")\nand segment (" << is
              << ") should go in "
              << "increasing or decreasing order.\n--- Original mesh ---\n"
              << "Original segment initial arclength: ("
              << original_segment_initial_arclength << ")\n"
              << "Original segment final arclength: ("
              << original_segment_final_arclength << ")\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }
#endif

          // Now scale the zeta values based considering if the zeta
          // values from the current mesh (this) go in the same order as
          // in the original mesh
          if (increasing_order && original_increasing_order)
          {
            // Current seg
            // |------|
            // 0 ---- 1
            //
            // Is mapped to the new values
            // |------|
            // a ---- b
            // a = original_segment_initial_arclength
            // b = original_segment_final_arclength
            // s = starting_arclength
            // The mapping is given by
            // new_z = s + z_old * (b - a)

            // Get the nodes associated to the segment
            std::set<Node*> seg_nodes_pt = segment_all_nodes_pt[is];
            // Go through all the nodes in the segment an change their
            // zeta values
            for (std::set<Node*>::iterator it = seg_nodes_pt.begin();
                 it != seg_nodes_pt.end();
                 it++)
            {
              // Storing for the zeta value
              Vector<double> zeta(1);
              // Get each node
              Node* nod_pt = (*it);
              // Get the zeta value of the current node
              nod_pt->get_coordinates_on_boundary(b, zeta);
              // ... and re-assign it
              const double temp =
                starting_arclength + (zeta[0] * segment_arclength[is]);
              // The zeta value
              zeta[0] = temp / boundary_arclength;
              // Correct
              if (std::fabs(zeta[0] - 1.0) < 1.0e-14)
              {
                zeta[0] = 1.0;
              }
              else if (std::fabs(zeta[0]) < 1.0e-14)
              {
                zeta[0] = 0.0;
              }

              // Set the new value
              nod_pt->set_coordinates_on_boundary(b, zeta);
            } // Go through all the nodes
          } // if (increasing_order && original_increasing_order)
          else if (!increasing_order && original_increasing_order)
          {
            // Current seg
            // |------|
            // 1 ---- 0
            //
            // Is mapped to the new values
            // |------|
            // a ---- b
            // a = original_segment_initial_arclength
            // b = original_segment_final_arclength
            // s = starting_arclength
            // The mapping is given by
            // new_z = s + (1.0 - z_old) * (b - a)

            // Get the nodes associated to the segment
            std::set<Node*> seg_nodes_pt = segment_all_nodes_pt[is];
            // Go through all the nodes in the segment an change their
            // zeta values
            for (std::set<Node*>::iterator it = seg_nodes_pt.begin();
                 it != seg_nodes_pt.end();
                 it++)
            {
              // Storing for the zeta value
              Vector<double> zeta(1);
              // Get each node
              Node* nod_pt = (*it);
              // Get the zeta value of the current node
              nod_pt->get_coordinates_on_boundary(b, zeta);
              // ... and re-assign it
              const double temp =
                starting_arclength + ((1.0 - zeta[0]) * segment_arclength[is]);
              // The zeta value
              zeta[0] = temp / boundary_arclength;
              // Correct
              if (std::fabs(zeta[0] - 1.0) < 1.0e-14)
              {
                zeta[0] = 1.0;
              }
              else if (std::fabs(zeta[0]) < 1.0e-14)
              {
                zeta[0] = 0.0;
              }
              // Set the new value
              nod_pt->set_coordinates_on_boundary(b, zeta);
            } // Go through all the nodes
          } // else if (!increasing_order && original_increasing_order)
          else if (increasing_order && !original_increasing_order)
          {
            // Current seg
            // |------|
            // 0 ---- 1
            //
            // Is mapped to the new values
            // |------|
            // b ---- a
            // a = original_segment_initial_arclength
            // b = original_segment_final_arclength
            // s = starting_arclength
            // The mapping is given by
            // new_z = s + (1.0 - z_old) * |(b - a)|

            // Get the nodes associated to the segment
            std::set<Node*> seg_nodes_pt = segment_all_nodes_pt[is];
            // Go through all the nodes in the segment an change their
            // zeta values
            for (std::set<Node*>::iterator it = seg_nodes_pt.begin();
                 it != seg_nodes_pt.end();
                 it++)
            {
              // Storing for the zeta value
              Vector<double> zeta(1);
              // Get each node
              Node* nod_pt = (*it);
              // Get the zeta value of the current node
              nod_pt->get_coordinates_on_boundary(b, zeta);
              // ... and re-assign it
              const double temp =
                starting_arclength + ((1.0 - zeta[0]) * segment_arclength[is]);
              // The zeta value
              zeta[0] = temp / boundary_arclength;
              // Correct
              if (std::fabs(zeta[0] - 1.0) < 1.0e-14)
              {
                zeta[0] = 1.0;
              }
              else if (std::fabs(zeta[0]) < 1.0e-14)
              {
                zeta[0] = 0.0;
              }
              // Set the new value
              nod_pt->set_coordinates_on_boundary(b, zeta);
            } // Go through all the nodes
          } // else if (increasing_order && !original_increasing_order)
          else if (!increasing_order && !original_increasing_order)
          {
            // Current seg
            // |------|
            // 0 ---- 1
            //
            // Is mapped to the new values
            // |------|
            // a ---- b
            // a = original_segment_initial_arclength
            // b = original_segment_final_arclength
            // s = starting_arclength
            // The mapping is given by
            // new_z = s + z_old * |(b - a)|

            // Get the nodes associated to the segment
            std::set<Node*> seg_nodes_pt = segment_all_nodes_pt[is];
            // Go through all the nodes in the segment an change their
            // zeta values
            for (std::set<Node*>::iterator it = seg_nodes_pt.begin();
                 it != seg_nodes_pt.end();
                 it++)
            {
              // Storing for the zeta value
              Vector<double> zeta(1);
              // Get each node
              Node* nod_pt = (*it);
              // Get the zeta value of the current node
              nod_pt->get_coordinates_on_boundary(b, zeta);
              // ... and re-assign it
              const double temp =
                starting_arclength + (zeta[0] * segment_arclength[is]);
              // The zeta value
              zeta[0] = temp / boundary_arclength;
              // Correct
              if (std::fabs(zeta[0] - 1.0) < 1.0e-14)
              {
                zeta[0] = 1.0;
              }
              else if (std::fabs(zeta[0]) < 1.0e-14)
              {
                zeta[0] = 0.0;
              }
              // Set the new value
              nod_pt->set_coordinates_on_boundary(b, zeta);
            } // Go through all the nodes
          } // else if (!increasing_order && !original_increasing_order)

#ifdef PARANOID
          // Verify that the z values of the first and last node are not
          // out of the range [0,1]
          for (std::list<FiniteElement*>::iterator it_list =
                 segment_sorted_ele_pt[is].begin();
               it_list != segment_sorted_ele_pt[is].end();
               it_list++)
          {
            // Number of nodes in the segment
            const unsigned nnod = (*it_list)->nnode();

            // Get the first node of the current segment
            Node* first_node_pt = (*it_list)->node_pt(0);
            if (is_inverted[(*it_list)])
            {
              first_node_pt = (*it_list)->node_pt(nnod - 1);
            }

            // Get the last node of the current segment
            Node* last_node_pt = (*it_list)->node_pt(nnod - 1);
            if (is_inverted[(*it_list)])
            {
              last_node_pt = (*it_list)->node_pt(0);
            }

            // The z value for the first node
            Vector<double> zeta(1);
            first_node_pt->get_coordinates_on_boundary(b, zeta);
            if (zeta[0] < 0.0 || zeta[0] > 1.0)
            {
              std::ostringstream error_message;
              error_message
                << "The boundary coordinate of the first node on boundary ("
                << b << ")\nand segment (" << is << ") is out of the "
                << "allowed values [0,1]\n"
                << "The node boundary coordinate: (" << zeta[0] << ")\n"
                << "The vertex coordinates are: (" << first_node_pt->x(0)
                << ", " << first_node_pt->x(1) << ")\n";
              throw OomphLibError(error_message.str(),
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
            }

            // The z value for the last node
            last_node_pt->get_coordinates_on_boundary(b, zeta);
            if (zeta[0] < 0.0 || zeta[0] > 1.0)
            {
              std::ostringstream error_message;
              error_message
                << "The boundary coordinate of the last node on boundary (" << b
                << ")\nand segment (" << is << ") is out of the "
                << "allowed values [0,1]\n"
                << "The node boundary coordinate: (" << zeta[0] << ")\n"
                << "The vertex coordinates are: (" << last_node_pt->x(0) << ", "
                << last_node_pt->x(1) << ")\n";
              throw OomphLibError(error_message.str(),
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
            }
          }
#endif // #ifdef PARANOID

        } // if (boundary_geom_object_pt(b)==0)

      } //  for (is < nsegments)

    } // if (this != original_mesh_pt)

    // ------------------------------------------------------------------
    // Copy the corrected (possible reversed) info. to the containers of
    // the current mesh
    // ------------------------------------------------------------------
    // Check if there are segments of b boundary in this processor
    if (nsegments > 0)
    {
      // Copy the initial and final coordinates
      Boundary_initial_coordinate[b] =
        original_mesh_pt->boundary_initial_coordinate(b);

      Boundary_final_coordinate[b] =
        original_mesh_pt->boundary_final_coordinate(b);

      // The initial and final zeta coordinates (In case of a geometric
      // object those are the limits of the geom object)
      Boundary_initial_zeta_coordinate[b] =
        original_mesh_pt->boundary_initial_zeta_coordinate(b);

      Boundary_final_zeta_coordinate[b] =
        original_mesh_pt->boundary_final_zeta_coordinate(b);

    } // if (nsegments > 0)

    // Set the flag to indicate that the zeta values have been assigned
    // for the current boundary
    Assigned_segments_initial_zeta_values[b] = true;

    // Clean all the created face elements
    for (unsigned i = 0; i < nele; i++)
    {
      delete face_el_pt[i];
      face_el_pt[i] = 0;
    }
  }

  //======================================================================
  /// Compute the boundary segments connectivity for those
  /// boundaries that were splited during the distribution process
  /// and also the initial zeta values for each segment (the initial
  /// and final boundary nodes coordinates)
  //======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::
    compute_boundary_segments_connectivity_and_initial_zeta_values(
      const unsigned& b)
  {
    // ------------------------------------------------------------------
    // First: Get the face elements associated with the current boundary
    // ------------------------------------------------------------------

    // Get the communicator of the mesh
    OomphCommunicator* comm_pt = this->communicator_pt();

    // Get the number of processors
    const unsigned nproc = comm_pt->nproc();
    // Get the rank of the current processor
    const unsigned my_rank = comm_pt->my_rank();

    // Temporary storage for face elements
    Vector<FiniteElement*> all_face_ele_pt;

    // Flag to know whether we are working with an internal open curve
    // and then re-assign the initial and final zeta coordinates for
    // each segment (only used when the mesh is distributed)
    bool is_internal_boundary = false;

    // map to associate the face element to the bulk element, necessary
    // to attach halo face elements at both sides of each found segment
    std::map<FiniteElement*, FiniteElement*> face_to_bulk_element_pt;

    // Select the boundary face elements, using the criteria of highest
    // processor in charge and bottom-left element
    select_boundary_face_elements(
      all_face_ele_pt, b, is_internal_boundary, face_to_bulk_element_pt);

    // Get the number of face elements
    const unsigned n_all_face_ele = all_face_ele_pt.size();

    // ----------------------------------------------------------------
    // Second: Sort the face elements, only consider nonhalo elements
    // ----------------------------------------------------------------

    // A flag vector to mark those face elements that are considered as
    // halo in the current processor
    std::vector<bool> is_halo_face_element(n_all_face_ele, false);

    // Count the total number of non halo face elements
    unsigned nnon_halo_face_elements = 0;

    // Only mark the face elements as halo if the mesh is marked as
    // distributed
    for (unsigned ie = 0; ie < n_all_face_ele; ie++)
    {
      FiniteElement* face_ele_pt = all_face_ele_pt[ie];
      // Get the bulk element
      FiniteElement* tmp_bulk_ele_pt = face_to_bulk_element_pt[face_ele_pt];
      // Check if the bulk element is halo
      if (!tmp_bulk_ele_pt->is_halo())
      {
        // Set the flag for non halo element
        is_halo_face_element[ie] = false;
        // Increase the non halo elements counter
        nnon_halo_face_elements++;
      }
      else
      {
        // Mark the face element as halo
        is_halo_face_element[ie] = true;
      }

    } // for (ie < n_ele)

    // Get the total number of halo face elements
    const unsigned nhalo_face_element =
      n_all_face_ele - nnon_halo_face_elements;

    // The vector of list to store the "segments" that compound the
    // boundary (segments may appear only in a distributed mesh)
    Vector<std::list<FiniteElement*>> segment_sorted_ele_pt;

    // Number of already sorted face elements (only nonhalo elements for
    // a distributed mesh)
    unsigned nsorted_face_elements = 0;

    // Keep track of who's done (this apply to nonhalo only, remember we
    // are only working with halo elements)
    std::map<FiniteElement*, bool> done_el;

    // Keep track of which element is inverted (in distributed mesh the
    // elements may be inverted with respect to the segment they belong)
    std::map<FiniteElement*, bool> is_inverted;

    // Iterate until all possible segments have been created
    while (nsorted_face_elements < nnon_halo_face_elements)
    {
      // The ordered list of face elements (in a distributed mesh a
      // collection of contiguous face elements define a segment)
      std::list<FiniteElement*> sorted_el_pt;
      sorted_el_pt.clear();

#ifdef PARANOID
      // Select an initial element for the segment (the first not done
      // nonhalo element)
      bool found_initial_face_element = false;
#endif

      FiniteElement* ele_face_pt = 0;

      unsigned iface = 0;
      for (iface = 0; iface < n_all_face_ele; iface++)
      {
        if (!is_halo_face_element[iface])
        {
          ele_face_pt = all_face_ele_pt[iface];
          // If not done then take it as initial face element
          if (!done_el[ele_face_pt])
          {
#ifdef PARANOID
            found_initial_face_element = true;
#endif
            nsorted_face_elements++;
            iface++; // The next element number
            sorted_el_pt.push_back(ele_face_pt);
            // Mark as done
            done_el[ele_face_pt] = true;
            break;
          }
        }
      } // for (iface < nele)

#ifdef PARANOID
      if (!found_initial_face_element)
      {
        std::ostringstream error_message;
        error_message
          << "Could not find an initial face element for the current segment\n";
        // << "----- Possible memory leak -----\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Number of nodes
      const unsigned nnod = ele_face_pt->nnode();

      // Left and rightmost nodes (the left and right nodes of the
      // current face element)
      Node* left_node_pt = ele_face_pt->node_pt(0);
      Node* right_node_pt = ele_face_pt->node_pt(nnod - 1);

      // Continue iterating if a new face element has been added to the
      // list
      bool face_element_added = false;

      // While a new face element has been added to the set of sorted
      // face elements then re-iterate
      do
      {
        // Start from the next face element since we have already added
        // the previous one as the initial face element (any previous
        // face element had to be added on previous iterations)
        for (unsigned iiface = iface; iiface < n_all_face_ele; iiface++)
        {
          // Re-start flag
          face_element_added = false;

          // Get the candidate element
          ele_face_pt = all_face_ele_pt[iiface];

          // Check that the candidate element has not been done and is
          // not a halo element
          if (!(done_el[ele_face_pt] || is_halo_face_element[iiface]))
          {
            // Get the left and right nodes of the current element
            Node* local_left_node_pt = ele_face_pt->node_pt(0);
            Node* local_right_node_pt = ele_face_pt->node_pt(nnod - 1);

            // New element fits at the left of segment and is not inverted
            if (left_node_pt == local_right_node_pt)
            {
              left_node_pt = local_left_node_pt;
              sorted_el_pt.push_front(ele_face_pt);
              is_inverted[ele_face_pt] = false;
              face_element_added = true;
            }
            // New element fits at the left of segment and is inverted
            else if (left_node_pt == local_left_node_pt)
            {
              left_node_pt = local_right_node_pt;
              sorted_el_pt.push_front(ele_face_pt);
              is_inverted[ele_face_pt] = true;
              face_element_added = true;
            }
            // New element fits on the right of segment and is not inverted
            else if (right_node_pt == local_left_node_pt)
            {
              right_node_pt = local_right_node_pt;
              sorted_el_pt.push_back(ele_face_pt);
              is_inverted[ele_face_pt] = false;
              face_element_added = true;
            }
            // New element fits on the right of segment and is inverted
            else if (right_node_pt == local_right_node_pt)
            {
              right_node_pt = local_left_node_pt;
              sorted_el_pt.push_back(ele_face_pt);
              is_inverted[ele_face_pt] = true;
              face_element_added = true;
            }

            if (face_element_added)
            {
              done_el[ele_face_pt] = true;
              nsorted_face_elements++;
              break;
            }

          } // if (!(done_el[ele_face_pt] || is_halo_face_element[iiface]))
        } // for (iiface<nnon_halo_face_element)
      } while (face_element_added &&
               (nsorted_face_elements < nnon_halo_face_elements));

      // Store the created segment in the vector of segments
      segment_sorted_ele_pt.push_back(sorted_el_pt);

    } // while(nsorted_face_elements < nnon_halo_face_elements);

    // -----------------------------------------------------------------
    // Third: We have the face elements sorted (in segments), now assign
    // boundary coordinates to the nodes in the segments, this is the
    // LOCAL boundary coordinate and further communication is needed to
    // compute the GLOBAL boundary coordinates
    // -----------------------------------------------------------------

    // Vector of sets that stores the nodes of each segment based on a
    // lexicographically order starting from the bottom left node of
    // each segment
    Vector<std::set<Node*>> segment_all_nodes_pt;

    // The number of segments in this processor
    const unsigned nsegments = segment_sorted_ele_pt.size();
    //  DEBP(nsegments);

#ifdef PARANOID
    if (nnon_halo_face_elements > 0 && nsegments == 0)
    {
      std::ostringstream error_message;
      error_message
        << "The number of segments is zero, but the number of nonhalo\n"
        << "elements is: (" << nnon_halo_face_elements << ")\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    } // if (nnon_halo_face_elements > 0 && nsegments == 0)
#endif

    // The arclength of each segment in the current processor
    Vector<double> segment_arclength(nsegments);

    // The number of vertices of each segment
    Vector<unsigned> nvertices_per_segment(nsegments);

    // The initial zeta for the segment
    Vector<double> initial_zeta_segment(nsegments);

    // The final zeta for the segment
    Vector<double> final_zeta_segment(nsegments);

    // Go through all the segments and compute its ARCLENGTH (if the
    // boundary has a GeomObject associated then assign the initial and
    // final zeta values for the segment)
    for (unsigned is = 0; is < nsegments; is++)
    {
#ifdef PARANOID
      if (segment_sorted_ele_pt[is].size() == 0)
      {
        std::ostringstream error_message;
        error_message << "The (" << is << ")-th segment has no elements\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      } // if (segment_sorted_ele_pt[is].size() == 0)
#endif

      // Get access to the first element on the segment
      FiniteElement* first_ele_pt = segment_sorted_ele_pt[is].front();

      // Number of nodes
      const unsigned nnod = first_ele_pt->nnode();

      // Get the first node of the current segment
      Node* first_node_pt = first_ele_pt->node_pt(0);
      if (is_inverted[first_ele_pt])
      {
        first_node_pt = first_ele_pt->node_pt(nnod - 1);
      }

      // Coordinates of left node
      double x_left = first_node_pt->x(0);
      double y_left = first_node_pt->x(1);

      // Initialise boundary coordinate (local boundary coordinate for
      // boundaries with more than one segment)
      Vector<double> zeta(1, 0.0);

      // If we have associated a GeomObject then it is not necessary to
      // compute the arclength, only read the values from the nodes at
      // the edges and set the initial and final zeta segment values
      if (this->boundary_geom_object_pt(b) != 0)
      {
        // Get the initial node coordinate
        first_node_pt->get_coordinates_on_boundary(b, zeta);
        // Set the initial zeta segment value
        initial_zeta_segment[is] = zeta[0];

        // Get access to the last element on the segment
        FiniteElement* last_ele_pt = segment_sorted_ele_pt[is].back();

        // Get the last node of the current segment
        Node* last_node_pt = last_ele_pt->node_pt(nnod - 1);
        if (is_inverted[last_ele_pt])
        {
          last_node_pt = last_ele_pt->node_pt(0);
        }

        // Get the final node coordinate
        last_node_pt->get_coordinates_on_boundary(b, zeta);
        // Set the final zeta segment value
        final_zeta_segment[is] = zeta[0];
      }

      // Sort the nodes in the segment (lexicographically bottom left
      // node)
      std::set<Node*> local_nodes_pt;
      // Insert the first node
      local_nodes_pt.insert(first_node_pt);

      // Now loop over nodes in order and increase the ARCLENGTH
      for (std::list<FiniteElement*>::iterator it =
             segment_sorted_ele_pt[is].begin();
           it != segment_sorted_ele_pt[is].end();
           it++)
      {
        // Get the pointer to the element
        FiniteElement* el_pt = (*it);

        // Start node and increment
        unsigned k_nod = 1;
        int nod_diff = 1;
        // Access nodes in reverse?
        if (is_inverted[el_pt])
        {
          k_nod = nnod - 2;
          nod_diff = -1;
        }

        // Loop over nodes in the face element
        for (unsigned j = 1; j < nnod; j++)
        {
          Node* nod_pt = el_pt->node_pt(k_nod);
          k_nod += nod_diff;

          // Coordinates of right node
          double x_right = nod_pt->x(0);
          double y_right = nod_pt->x(1);

          // Increment boundary coordinate (the arclength)
          zeta[0] += sqrt((x_right - x_left) * (x_right - x_left) +
                          (y_right - y_left) * (y_right - y_left));

          // When we have a GeomObject associated to the boundary we already
          // know the zeta values for the nodes, there is no need to compute
          // the arclength
          //         if (this->boundary_geom_object_pt(b)==0)
          //          {
          //           // Set boundary coordinate
          // //           nod_pt->set_coordinates_on_boundary(b, zeta);
          //          }

          // Increment reference coordinate
          x_left = x_right;
          y_left = y_right;

          // Get lexicographically bottom left node but only
          // use vertex nodes as candidates
          local_nodes_pt.insert(nod_pt);

        } // for (j < nnod)

      } // iterator over the elements in the segment

      // Info. to be passed to other processors
      // The initial arclength for the segment that goes after this depends
      // on the current segment arclength
      segment_arclength[is] = zeta[0];

      // Info. to be passed to the other processors
      // The initial vertex number for the segment that goes after this
      // depends on the current segment vertices number
      nvertices_per_segment[is] = local_nodes_pt.size();

      // Add the nodes for the corresponding segment in the container
      segment_all_nodes_pt.push_back(local_nodes_pt);

      // The attaching of the halo elements at both sides of the segments is
      // performed only if segments connectivity needs to be computed

    } // for (is < nsegments)

    // Container to store the number of vertices before each segment,
    // initialise to zero in case we have a non distributed boundary
    Vector<unsigned> nvertices_before_segment(nsegments, 0);

    // Store the initial arclength for each segment of boundary in the
    // current processor, initalise to zero in case we have a non
    // distributed boundary
    Vector<double> initial_segment_arclength(nsegments, 0.0);

    // Info. to be passed to other processors
    // If the boundary is distributed we need to know which processors does
    // have the initial and final segments, this helps to get the first and
    // last nodes coordinates (info. used to scale the bound coordinates)

    // Processors with the initial and final segment
    unsigned proc_with_initial_seg = 0;
    unsigned proc_with_final_seg = 0;

    // ... and the index of those segments (only of interest in the
    // processors that have the initial and final segments)
    unsigned initial_segment = 0;
    unsigned final_segment = 0;

    // Each segment needs to know whether it has to be inverted or not
    // Store whether a segment needs to be inverted or not
    Vector<unsigned> segment_inverted(nsegments);

    // Before attaching the halo elements create a copy of the data
    // structure without halo elements
    Vector<std::list<FiniteElement*>> segment_sorted_nonhalo_ele_pt(nsegments);
    for (unsigned is = 0; is < nsegments; is++)
    {
      for (std::list<FiniteElement*>::iterator it_seg =
             segment_sorted_ele_pt[is].begin();
           it_seg != segment_sorted_ele_pt[is].end();
           it_seg++)
      {
        segment_sorted_nonhalo_ele_pt[is].push_back((*it_seg));
      }

    } // for (is < nsegments)

    // --------------------------------------------------------------
    // Attach the halo elements at both sides of the segments
    for (unsigned is = 0; is < nsegments; is++)
    {
      // Get access to the first element on the segment
      FiniteElement* first_ele_pt = segment_sorted_ele_pt[is].front();

      // Number of nodes
      const unsigned nnod = first_ele_pt->nnode();

      // Get the first node of the current segment
      Node* first_node_pt = first_ele_pt->node_pt(0);
      if (is_inverted[first_ele_pt])
      {
        first_node_pt = first_ele_pt->node_pt(nnod - 1);
      }

      // Get access to the last element on the segment
      FiniteElement* last_ele_pt = segment_sorted_ele_pt[is].back();

      // Get the last node of the current segment
      Node* last_node_pt = last_ele_pt->node_pt(nnod - 1);
      if (is_inverted[last_ele_pt])
      {
        last_node_pt = last_ele_pt->node_pt(0);
      }

      // -----------------------------------------------------------------
      // Fourth: Now attach the halo elements to the left and right side
      // of each segment
      // -----------------------------------------------------------------
      bool attached_left_halo = false;
      bool attached_right_halo = false;
      if (nhalo_face_element > 0)
      {
        for (unsigned iiface = 0; iiface < n_all_face_ele; iiface++)
        {
          // Get the candidate element
          FiniteElement* halo_face_ele_pt = all_face_ele_pt[iiface];

          // Check that the element is a halo face element, we do not check
          // if the element has been already done since the halo elements
          // may be connected to more than one segment (2 at most), to the
          // left and right of different segments
          //
          //      Segment k        Halo         Segment r
          //   |---|---|---|      |xxx|      |---|---|---|
          //
          //          Segment k    Halo  Segment r
          //          |---|---|---|xxx|---|---|---|
          //
          if (is_halo_face_element[iiface])
          {
            // Get its left and right nodes
            Node* left_node_pt = halo_face_ele_pt->node_pt(0);
            Node* right_node_pt = halo_face_ele_pt->node_pt(nnod - 1);
            // The halo element fits to the left of segment
            if (!attached_left_halo && (first_node_pt == right_node_pt ||
                                        first_node_pt == left_node_pt))
            {
              // Add the halo element to the left of the segment
              segment_sorted_ele_pt[is].push_front(halo_face_ele_pt);

              // Once a halo face element has been added to the left
              // mark as found halo to the left
              attached_left_halo = true;
            }
            // The halo element fits to the right of the segment
            else if (!attached_right_halo && (last_node_pt == left_node_pt ||
                                              last_node_pt == right_node_pt))
            {
              // Add the halo element to the right of the segment
              segment_sorted_ele_pt[is].push_back(halo_face_ele_pt);
              // Once a halo face element has been added to the right
              // mark as found halo to the right
              attached_right_halo = true;
            }
            // If we have already found elements to left and right then
            // break the loop
            if (attached_left_halo && attached_right_halo)
            {
              break;
            }

          } // if (is_halo_face_element[iiface])

        } // for (iiface < nel)

      } // if (nhalo_face_element > 0)

    } // for (is < nsegments)

    // The segments now have local coordinates assigned and halo
    // elements attached to them. Store that info. in the corresponding
    // data structures and be ready to send that info. to a root
    // processor. The root processor will be in charge of computing the
    // boundary coordinates for each segment of the boundary.

    // For each segment store the following information
    // --------------------------------------------------------------------
    // Stores the "rank" of the processor to the left of each segment,
    // zero if there is no processor to the left which states that the
    // segment is the first one on the boundary
    Vector<unsigned> left_processor_plus_one(nsegments);

    // Stores the "rank" of the processor to the right of each segment,
    // zero if there is no processor to the right which states that the
    // segment is the last one on the boundary
    Vector<unsigned> right_processor_plus_one(nsegments);

    // The id. of the halo element to the left of the segment, note that
    // this info. is not necessary if there is no processor to the left
    // of the segment
    Vector<unsigned> left_halo_element(nsegments);

    // The id. of the halo element to the right of the segment, note that
    // this info. is not necessary if there is no processor to the right
    // of the segment
    Vector<unsigned> right_halo_element(nsegments);

    // The id. of the haloed element to the left of the segment, note that
    // this info. is not necessary if there is no processor to the left
    // of the segment
    Vector<unsigned> left_haloed_element(nsegments);

    // The id. of the haloed element to the right of the segment, note
    // that this info. is not necessary if there is no processor to the
    // right of the segment
    Vector<unsigned> right_haloed_element(nsegments);

    // Go through all the segments and get the info.
    for (unsigned is = 0; is < nsegments; is++)
    {
      // Get access to the left most face element on the segment
      FiniteElement* left_face_ele_pt = segment_sorted_ele_pt[is].front();

      // Get the corresponding bulk element and check whether it is a halo
      // element or not
      FiniteElement* tmp_left_bulk_ele_pt =
        face_to_bulk_element_pt[left_face_ele_pt];

      // Check if the bulk element is halo
      if (tmp_left_bulk_ele_pt->is_halo())
      {
        // Then store the corresponding info.
        int left_proc = tmp_left_bulk_ele_pt->non_halo_proc_ID();
#ifdef PARANOID
        if (left_proc < 0)
        {
          std::ostringstream error_message;
          error_message
            << "The current bulk element (left) is marked as halo but "
            << "the processor holding\nthe non-halo counterpart is "
            << "negative!\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        }
#endif
        // The processor "rank" to the left
        unsigned left_processor = static_cast<unsigned>(left_proc);
        left_processor_plus_one[is] = left_processor + 1;

        // Now get the id of the halo element to the left
        GeneralisedElement* left_element_pt = tmp_left_bulk_ele_pt;

        // Get the halo elements with left processor
        Vector<GeneralisedElement*> left_halo_element_pt =
          this->halo_element_pt(left_processor);

#ifdef PARANOID
        // Flag to state that the halo element was found
        bool left_halo_element_found = false;
#endif

        const unsigned n_halo_left = left_halo_element_pt.size();
        for (unsigned lh = 0; lh < n_halo_left; lh++)
        {
          if (left_element_pt == left_halo_element_pt[lh])
          {
            left_halo_element[is] = lh;
#ifdef PARANOID
            left_halo_element_found = true;
#endif
            break;
          }
        } // for (lh < n_halo_left)

#ifdef PARANOID
        if (!left_halo_element_found)
        {
          std::ostringstream error_message;
          error_message
            << "The current bulk element (left) marked as halo was "
            << "not found in the vector of halo\nelements associated "
            << "with the (" << left_processor << ") processor.\n\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        } // if (!left_halo_element_found)
#endif

        // Get the left-most nonhalo element (use the backup list of
        // nonhalo elements)
        left_face_ele_pt = segment_sorted_nonhalo_ele_pt[is].front();

        // Get the corresponding bulk element
        tmp_left_bulk_ele_pt = face_to_bulk_element_pt[left_face_ele_pt];

#ifdef PARANOID
        // This element should not be marked as halo
        if (tmp_left_bulk_ele_pt->is_halo())
        {
          std::ostringstream error_message;
          error_message
            << "The bulk element represetation of the left-most nonhalo face\n"
            << "element of the current segment (" << is
            << ") is marked as halo,\n"
            << "but the face element created from it is nonhalo\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        } // if (tmp_left_bulk_ele_pt->is_halo())
#endif

        // Cast from "FiniteElement*" to "GeneralisedElement*" to be able
        // to search in the haloed vector
        left_element_pt = tmp_left_bulk_ele_pt;

#ifdef PARANOID
        // Flag to state that the haloed element was found
        bool left_haloed_element_found = false;
#endif

        // Now get the id for the haloed element to the left, get the
        // haloed elements from the processor to the left
        Vector<GeneralisedElement*> left_haloed_element_pt =
          this->haloed_element_pt(left_processor);

        const unsigned nhaloed_left = left_haloed_element_pt.size();
        for (unsigned lhd = 0; lhd < nhaloed_left; lhd++)
        {
          if (left_element_pt == left_haloed_element_pt[lhd])
          {
            left_haloed_element[is] = lhd;
#ifdef PARANOID
            left_haloed_element_found = true;
#endif
            break;
          }
        } // for (lhd < nhaloed_left)

#ifdef PARANOID
        if (!left_haloed_element_found)
        {
          std::ostringstream error_message;
          error_message
            << "The current bulk element (left) marked as haloed was "
            << "not found in the vector of haloed\nelements associated "
            << "with processor (" << left_processor << ").\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        }
#endif
      } // if (tmp_left_bulk_ele_pt->is_halo())
      else
      {
        // If not halo then state the info. to indicate that
        left_processor_plus_one[is] = 0;
        // Null this info.
        left_halo_element[is] = 0;
        // Null this info.
        left_haloed_element[is] = 0;
      }

      // Get access to the right most face element on the segment
      FiniteElement* right_face_ele_pt = segment_sorted_ele_pt[is].back();

      // Get the corresponding bulk element and check whether it is
      // a halo element or not
      FiniteElement* tmp_right_bulk_ele_pt =
        face_to_bulk_element_pt[right_face_ele_pt];

      // Check if the bulk element is halo
      if (tmp_right_bulk_ele_pt->is_halo())
      {
        // Then store the corresponding info.
        int right_proc = tmp_right_bulk_ele_pt->non_halo_proc_ID();
#ifdef PARANOID
        if (right_proc < 0)
        {
          std::ostringstream error_message;
          error_message
            << "The current bulk element (right) is marked as halo but "
            << "the processor holding\nthe non-halo counterpart is "
            << "negative!\n";
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::compute_boundary_segments_"
                              "connectivity_and_initial_zeta_values()",
                              OOMPH_EXCEPTION_LOCATION);
        }
#endif
        // The processor "rank" to the right
        unsigned right_processor = static_cast<unsigned>(right_proc);
        right_processor_plus_one[is] = right_processor + 1;

        // Now get the id of the halo element to the right
        GeneralisedElement* right_element_pt = tmp_right_bulk_ele_pt;

        // Get the halo elements with right processor
        Vector<GeneralisedElement*> right_halo_element_pt =
          this->halo_element_pt(right_processor);

#ifdef PARANOID
        // Flag to state that the halo element was found
        bool right_halo_element_found = false;
#endif

        const unsigned nhalo_right = right_halo_element_pt.size();
        for (unsigned rh = 0; rh < nhalo_right; rh++)
        {
          if (right_element_pt == right_halo_element_pt[rh])
          {
            right_halo_element[is] = rh;
#ifdef PARANOID
            right_halo_element_found = true;
#endif
            break;
          }
        } // for (rh < nhalo_right)
#ifdef PARANOID
        if (!right_halo_element_found)
        {
          std::ostringstream error_message;
          error_message
            << "The current bulk element (right) marked as halo was not "
            << "found in the vector of halo\nelements associated with "
            << "the (" << right_processor << ") processor.\n\n";
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::compute_boundary_segments_"
                              "connectivity_and_initial_zeta_values()",
                              OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // Get the right-most nonhalo element (use the backup list of
        // nonhalo elements)
        right_face_ele_pt = segment_sorted_nonhalo_ele_pt[is].back();

        // Get the corresponding bulk element
        tmp_right_bulk_ele_pt = face_to_bulk_element_pt[right_face_ele_pt];
#ifdef PARANOID
        // This element should not be marked as halo
        if (tmp_right_bulk_ele_pt->is_halo())
        {
          std::ostringstream error_message;
          error_message
            << "The bulk element represetation of the right-most nonhalo face\n"
            << "element of the current segment (" << is
            << ") is marked as halo,\n"
            << "but the face element created from it is nonhalo\n";
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::compute_boundary_segments_"
                              "connectivity_and_initial_zeta_values()",
                              OOMPH_EXCEPTION_LOCATION);
        } // if (tmp_right_bulk_ele_pt->is_halo())
#endif

        // Cast from "FiniteElement*" to "GeneralisedElement*" to be able
        // to search in the haloed vector
        right_element_pt = tmp_right_bulk_ele_pt;

#ifdef PARANOID
        // Flag to state that the haloed element was found
        bool right_haloed_element_found = false;
#endif

        // Now get the id for the haloed element to the right
        Vector<GeneralisedElement*> right_haloed_element_pt =
          this->haloed_element_pt(right_processor);

        const unsigned nhaloed_right = right_haloed_element_pt.size();
        for (unsigned rhd = 0; rhd < nhaloed_right; rhd++)
        {
          if (right_element_pt == right_haloed_element_pt[rhd])
          {
            right_haloed_element[is] = rhd;
#ifdef PARANOID
            right_haloed_element_found = true;
#endif
            break;
          }
        } // for (rhd < nhaloed_right)

#ifdef PARANOID
        if (!right_haloed_element_found)
        {
          std::ostringstream error_message;
          error_message
            << "The current bulk element (right) marked as haloed was not "
            << "found in the vector of haloed\nelements associated with "
            << "the (" << right_processor << ") processor.\n\n";
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::compute_boundary_segments_"
                              "connectivity_and_initial_zeta_values()",
                              OOMPH_EXCEPTION_LOCATION);
        }
#endif

      } // if (tmp_right_bulk_ele_pt->is_halo())
      else
      {
        // If not halo then state the info. to indicate that
        right_processor_plus_one[is] = 0;
        // Null this info.
        right_halo_element[is] = 0;
        // Null this info.
        right_haloed_element[is] = 0;
      }

    } // for (is < nsegments). Used to get the halo info. of the
      // segments

    // Now we have all the info. to be sent to the root processor and
    // compute the correct (global) boundary coordinates for the current
    // boundary

    // The root processor will be in charge of performing the computing
    // of the coordinate values along the boundary, all the other
    // processors only send their info. and wait for receiving the new
    // starting values for each of its segments

    // Choose the root processor
    const unsigned root_processor = 0;
    // ------------------------------------------------------------------
    // Starts the MPI stage

    // The root processor receives the number of segments of each
    // processor associated to the current boundary
    Vector<unsigned> root_nsegments_per_processor(nproc);
    unsigned nsegments_mpi = nsegments;
    MPI_Gather(&nsegments_mpi,
               1,
               MPI_UNSIGNED,
               &root_nsegments_per_processor[0],
               1,
               MPI_UNSIGNED,
               root_processor,
               comm_pt->mpi_comm());

    // Package the info. and prepare it to be sent
    // For the packaged info. we send 7 data per each segment, the indexes
    // are as follow; 0 left proc, 1 right proc, 2 left halo, 3 right
    // halo, 4 left haloed, 5 right haloed and 6 for nvertices per
    // segment
    // The size of the package (unsigned)
    const unsigned spu = 7;
    Vector<unsigned> flat_packed_unsigned_send_data(nsegments * spu);
    for (unsigned is = 0; is < nsegments; is++)
    {
      flat_packed_unsigned_send_data[(spu * is) + 0] =
        left_processor_plus_one[is];
      flat_packed_unsigned_send_data[(spu * is) + 1] =
        right_processor_plus_one[is];
      flat_packed_unsigned_send_data[(spu * is) + 2] = left_halo_element[is];
      flat_packed_unsigned_send_data[(spu * is) + 3] = right_halo_element[is];
      flat_packed_unsigned_send_data[(spu * is) + 4] = left_haloed_element[is];
      flat_packed_unsigned_send_data[(spu * is) + 5] = right_haloed_element[is];
      flat_packed_unsigned_send_data[(spu * is) + 6] =
        nvertices_per_segment[is];
    }

    // How many data will this processor send
    const unsigned nudata_to_send = flat_packed_unsigned_send_data.size();

    // How many data does the root processor will receive from each
    // processor
    Vector<int> root_nudata_to_receive(nproc, 0);
    // Total number of data to receive from all processors
    unsigned root_nutotal_data_receive = 0;
    for (unsigned ip = 0; ip < nproc; ip++)
    {
      // Compute the number of data the root processor will receive from
      // each processor
      root_nudata_to_receive[ip] = root_nsegments_per_processor[ip] * spu;
      // Add on the total number of data to receive
      root_nutotal_data_receive += root_nudata_to_receive[ip];
    }

    // Stores and compute the offsets (in root) for the data received
    // from each processor
    Vector<int> root_uoffsets_receive(nproc, 0);
    root_uoffsets_receive[0] = 0;
    for (unsigned ip = 1; ip < nproc; ip++)
    {
      // Compute the offset to store the values from each processor
      root_uoffsets_receive[ip] =
        root_uoffsets_receive[ip - 1] + root_nudata_to_receive[ip - 1];
    }

    // Create at least one entry so we don't get a seg fault below
    if (flat_packed_unsigned_send_data.size() == 0)
    {
      flat_packed_unsigned_send_data.resize(1);
    }

    // Vector where to receive the info.
    Vector<unsigned> flat_packed_unsigned_receive_data(
      root_nutotal_data_receive);
    if (my_rank != root_processor)
    {
      // Create at least one entry so we don't get a seg fault below
      if (flat_packed_unsigned_receive_data.size() == 0)
      {
        flat_packed_unsigned_receive_data.resize(1);
      }
    } // if (my_rank!=root_processor)

    MPI_Gatherv(&flat_packed_unsigned_send_data[0], // Flat package to
                                                    // send info. from
                                                    // each processor
                nudata_to_send, // Total number of data to send from
                                // each processor
                MPI_UNSIGNED,
                &flat_packed_unsigned_receive_data[0], // Container
                                                       // where to
                                                       // receive the
                                                       // info. from all
                                                       // the processors
                &root_nudata_to_receive[0], // Number of data to receive
                                            // from each processor
                &root_uoffsets_receive[0], // The offset to store the
                                           // info. from each processor
                MPI_UNSIGNED,
                root_processor, // The processor that receives all the
                                // info.
                comm_pt->mpi_comm());

    // Clear the flat package to send
    flat_packed_unsigned_send_data.clear();
    flat_packed_unsigned_send_data.resize(0);

    // Package the info. and prepare it to be sent
    // For the packaged info. we send 1 data per each segment which is
    // at the moment the arclength of each segment
    // The size of the package
    const unsigned spd = 1;
    Vector<double> flat_packed_double_send_data(nsegments * spd);
    for (unsigned is = 0; is < nsegments; is++)
    {
      flat_packed_double_send_data[(spd * is) + 0] = segment_arclength[is];
    }

    // How many data will this processor send
    const unsigned nddata_to_send = flat_packed_double_send_data.size();
    // How many data does the root processor will receive from each
    // processor
    Vector<int> root_nddata_to_receive(nproc, 0);
    // Total number of data to receive from all processors
    unsigned root_ndtotal_data_receive = 0;
    for (unsigned ip = 0; ip < nproc; ip++)
    {
      root_nddata_to_receive[ip] = root_nsegments_per_processor[ip] * spd;
      root_ndtotal_data_receive += root_nddata_to_receive[ip];
    }

    // Stores and compute the offsets for the data received from each
    // processor
    Vector<int> root_doffsets_receive(nproc, 0);
    root_doffsets_receive[0] = 0;
    for (unsigned ip = 1; ip < nproc; ip++)
    {
      // Compute the offset to store the values from each processor
      root_doffsets_receive[ip] =
        root_doffsets_receive[ip - 1] + root_nddata_to_receive[ip - 1];
    }

    // Create at least one entry so we don't get a seg fault below
    if (flat_packed_double_send_data.size() == 0)
    {
      flat_packed_double_send_data.resize(1);
    }

    // Vector where to receive the info.
    Vector<double> flat_packed_double_receive_data(root_ndtotal_data_receive);
    if (my_rank != root_processor)
    {
      // Create at least one entry so we don't get a seg fault below
      if (flat_packed_double_receive_data.size() == 0)
      {
        flat_packed_double_receive_data.resize(1);
      }
    }

    MPI_Gatherv(&flat_packed_double_send_data[0], // Flat package to
                                                  // send info. from
                                                  // each processor
                nddata_to_send, // Total number of data to send from
                                // each processor
                MPI_DOUBLE,
                &flat_packed_double_receive_data[0], // Container where
                                                     // to receive the
                                                     // info. from all
                                                     // the processors
                &root_nddata_to_receive[0], // Number of data to receive
                                            // from each processor
                &root_doffsets_receive[0], // The offset to store the
                                           // info. from each processor
                MPI_DOUBLE,
                root_processor, // The processor that receives all the
                                // info.
                comm_pt->mpi_comm());

    // Clear the flat package to send
    flat_packed_double_send_data.clear();
    flat_packed_double_send_data.resize(0);

    // The next three containers are only used by the root processor at
    // the end of its computations but it is necessary that all the
    // processors know them when calling back the info.

    // Container that state the initial arclength for each segments
    // of each processor
    Vector<Vector<double>> root_initial_segment_arclength(nproc);

    // Container that state the number of vertices before each segment
    // in a given processor
    Vector<Vector<unsigned>> root_nvertices_before_segment(nproc);

    // The root processor needs to tell the other processor if it was
    // necessary to reverse a segment. Each processor should therefore
    // invert the face elements that compose every segment that was
    // inverted by the root processor
    Vector<Vector<unsigned>> root_segment_inverted(nproc);

    // Used to store the accumulated arclength, used at the end of
    // communications to store the total arclength
    double root_accumulated_arclength = 0.0;

    // Store the accumulated number of vertices, it means the total number
    // of vertices before each segment (counter)
    unsigned root_accumulated_vertices_before_segment = 0;

    // The root processor is in charge of performing the connections
    // of the segments that define the complete boundary
    if (my_rank == root_processor)
    {
      // From the flat packaged received data re-create the data
      // structures storing the info. regarding the connectivity of the
      // segments, the number of vertices per segment and the local
      // arclength of each segment

      // Stores the "rank" of the processor to the left of each segment,
      // zero if there is no processor to the left which states that the
      // segment is the first one on the boundary
      Vector<Vector<unsigned>> root_left_processor_plus_one(nproc);

      // Stores the "rank" of the processor to the right of each segment,
      // zero if there is no processor to the right which states that the
      // segment is the last one on the boundary
      Vector<Vector<unsigned>> root_right_processor_plus_one(nproc);

      // The id. of the halo element to the left of the segment, note that
      // this info. is not necessary if there is no processor to the left
      // of the segment or if the processor has no info about the boundary
      Vector<Vector<unsigned>> root_left_halo_element(nproc);

      // The id. of the halo element to the right of the segment, note
      // that this info. is not necessary if there is no processor to
      // the right of the segment or if the processor has no info about
      // the boundary
      Vector<Vector<unsigned>> root_right_halo_element(nproc);

      // The id. of the haloed element to the left of the segment, note
      // that this info. is not necessary if there is no processor to
      // the left of the segment or if the processor has no info about
      // the boundary
      Vector<Vector<unsigned>> root_left_haloed_element(nproc);

      // The id. of the haloed element to the right of the segment, note
      // that this info. is not necessary if there is no processor to the
      // right of the segment or if the processor has no info about the
      // boundary
      Vector<Vector<unsigned>> root_right_haloed_element(nproc);

      // The number of vertices per segment in each processor
      Vector<Vector<unsigned>> root_nvertices_per_segment(nproc);

      // The arclength of each of the segments in the processors
      Vector<Vector<double>> root_segment_arclength(nproc);

      unsigned ucounter = 0;
      unsigned dcounter = 0;
      for (unsigned ip = 0; ip < nproc; ip++)
      {
        // Get the number of segments in the current processor
        const unsigned nsegs_iproc = root_nsegments_per_processor[ip];

        root_left_processor_plus_one[ip].resize(nsegs_iproc);
        root_right_processor_plus_one[ip].resize(nsegs_iproc);
        root_left_halo_element[ip].resize(nsegs_iproc);
        root_right_halo_element[ip].resize(nsegs_iproc);
        root_left_haloed_element[ip].resize(nsegs_iproc);
        root_right_haloed_element[ip].resize(nsegs_iproc);

        // Additional info.
        root_nvertices_per_segment[ip].resize(nsegs_iproc);
        root_segment_arclength[ip].resize(nsegs_iproc);
        root_segment_inverted[ip].resize(nsegs_iproc);

        // Extract the info. from the BIG package received from all
        // processors
        for (unsigned is = 0; is < nsegs_iproc; is++)
        {
          // ------ The flat unsigned package ------
          root_left_processor_plus_one[ip][is] =
            flat_packed_unsigned_receive_data[ucounter++];
          root_right_processor_plus_one[ip][is] =
            flat_packed_unsigned_receive_data[ucounter++];
          root_left_halo_element[ip][is] =
            flat_packed_unsigned_receive_data[ucounter++];
          root_right_halo_element[ip][is] =
            flat_packed_unsigned_receive_data[ucounter++];
          root_left_haloed_element[ip][is] =
            flat_packed_unsigned_receive_data[ucounter++];
          root_right_haloed_element[ip][is] =
            flat_packed_unsigned_receive_data[ucounter++];
          root_nvertices_per_segment[ip][is] =
            flat_packed_unsigned_receive_data[ucounter++];

          // ------ The flat double package ------
          root_segment_arclength[ip][is] =
            flat_packed_double_receive_data[dcounter++];
        } // for (is < nsegs_iproc)
      } // for (ip < nproc)

      // Now the root processor has all the info. to find out the
      // CONNECTIVITY of the segments in each processor

      // Container that stores the info. related with the connectivity
      // of the segments of each processor
      Vector<Vector<int>> left_connected_segment_plus_one(nproc);
      Vector<Vector<int>> right_connected_segment_plus_one(nproc);
      for (unsigned ip = 0; ip < nproc; ip++)
      {
        const unsigned nsegs_iproc = root_nsegments_per_processor[ip];
        left_connected_segment_plus_one[ip].resize(nsegs_iproc, -1);
        right_connected_segment_plus_one[ip].resize(nsegs_iproc, -1);
      } // for (ip < nprocs)

      // In charge of storing the connectivity of the segments, the pair
      // indicates the processor and the segment number
      std::list<std::pair<unsigned, unsigned>> proc_seg_connectivity;
      proc_seg_connectivity.clear();

      // Done segments on processor
      std::map<std::pair<unsigned, unsigned>, bool> done_segment;

      // Take the first segment of the first processor with segments and
      // add it to the list of segments
      unsigned left_proc = 0;
      unsigned right_proc = 0;
      unsigned left_seg = 0;
      unsigned right_seg = 0;
      for (unsigned ip = 0; ip < nproc; ip++)
      {
        const unsigned nsegs_iproc = root_nsegments_per_processor[ip];
        if (nsegs_iproc > 0)
        {
          right_proc = left_proc = ip;
          right_seg = left_seg = 0;
          break; // Break because it is the first processor with at
                 // least one segment
        }
      } // for (ip < nproc)

      // ... and add it to the list of segments
      std::pair<unsigned, unsigned> add_segment =
        std::make_pair(left_proc, left_seg);
      done_segment[add_segment] = true;
      proc_seg_connectivity.push_back(add_segment);

      // Flags to indicate when a segment was added to the left or right
      // of the current list of segments
      bool added_segment_to_the_left = false;
      bool added_segment_to_the_right = false;

      do // while(added_segment_to_the_left || added_segment_to_the_right)
      {
        // Read the left-most processor and segment in the list
        std::pair<unsigned, unsigned> left_pair = proc_seg_connectivity.front();
        left_proc = left_pair.first;
        left_seg = left_pair.second;

        // Get the processor number to the left of the left-most
        // segment in the list
        const unsigned new_left_proc =
          root_left_processor_plus_one[left_proc][left_seg];

        if (new_left_proc != 0)
        {
          // Initialise flag
          added_segment_to_the_left = false;
          // Get the left halo element id
          const unsigned left_halo_id =
            root_left_halo_element[left_proc][left_seg];

          // Get the left haloed element id
          const unsigned left_haloed_id =
            root_left_haloed_element[left_proc][left_seg];

          // Go through the segments on the new left processor and look
          // for the corresponding left_halo_id in the haloed_ids
          const unsigned nsegs_new_left_proc =
            root_nsegments_per_processor[new_left_proc - 1];

          for (unsigned ils = 0; ils < nsegs_new_left_proc; ils++)
          {
            std::pair<unsigned, unsigned> candidate_seg =
              std::make_pair(new_left_proc - 1, ils);

            // Check that the segment has not been already added
            if (!done_segment[candidate_seg])
            {
              // Only consider the segments on new left processor which
              // right processor is the current one (left_proc)
              const unsigned right_proc_of_new_left_proc =
                root_right_processor_plus_one[new_left_proc - 1][ils];
              // Also get the left_proc_of_new_left_proc (in case that it
              // be necessary to invert the segment)
              const unsigned left_proc_of_new_left_proc =
                root_left_processor_plus_one[new_left_proc - 1][ils];
              // Check the not inverted case (to the left and not
              // inverted)
              if (right_proc_of_new_left_proc != 0 &&
                  right_proc_of_new_left_proc - 1 == left_proc)
              {
                // Get the haloed/haloed element id of the current segment
                // in the new left processor and compare it to the
                // halo/haloed element id of the left_processor
                const unsigned right_halo_id =
                  root_right_halo_element[new_left_proc - 1][ils];
                const unsigned right_haloed_id =
                  root_right_haloed_element[new_left_proc - 1][ils];
                if (left_halo_id == right_haloed_id &&
                    left_haloed_id == right_halo_id)
                {
                  // We have a match of the segments (store the segment
                  // number plus one on the processor to the left)
                  left_connected_segment_plus_one[left_proc][left_seg] =
                    ils + 1;
                  // Add the pair to the connectivity list
                  proc_seg_connectivity.push_front(candidate_seg);
                  added_segment_to_the_left = true;
                  break;
                }
              } // if (right_proc_of_new_left_proc-1 == left_proc)

              // Check the inverted case (to the left and inverted)
              if (left_proc_of_new_left_proc != 0 &&
                  left_proc_of_new_left_proc - 1 == left_proc)
              {
                // Get the haloed element id of the current segment
                // (inverted version) in the new left processor and
                // compare it to the halo element id of the left_processor
                const unsigned inv_left_halo_id =
                  root_left_halo_element[new_left_proc - 1][ils];
                const unsigned inv_left_haloed_id =
                  root_left_haloed_element[new_left_proc - 1][ils];
                if (left_halo_id == inv_left_haloed_id &&
                    left_haloed_id == inv_left_halo_id)
                {
                  // We have a match of the segments (store the segment
                  // number plus one on the processor to the left)
                  left_connected_segment_plus_one[left_proc][left_seg] =
                    ils + 1;
                  // Add the pair to the connectivity list
                  proc_seg_connectivity.push_front(candidate_seg);

                  // In addition to the connectivity we need to invert the
                  // segment (the information)
                  const unsigned tmp_proc =
                    root_left_processor_plus_one[new_left_proc - 1][ils];
                  const unsigned tmp_halo =
                    root_left_halo_element[new_left_proc - 1][ils];
                  const unsigned tmp_haloed =
                    root_left_haloed_element[new_left_proc - 1][ils];

                  root_left_processor_plus_one[new_left_proc - 1][ils] =
                    root_right_processor_plus_one[new_left_proc - 1][ils];
                  root_left_halo_element[new_left_proc - 1][ils] =
                    root_right_halo_element[new_left_proc - 1][ils];
                  root_left_haloed_element[new_left_proc - 1][ils] =
                    root_right_haloed_element[new_left_proc - 1][ils];

                  root_right_processor_plus_one[new_left_proc - 1][ils] =
                    tmp_proc;
                  root_right_halo_element[new_left_proc - 1][ils] = tmp_halo;
                  root_right_haloed_element[new_left_proc - 1][ils] =
                    tmp_haloed;

                  // ... and mark the segment as inverted in the root
                  // processor to inform back to the owner processor
                  root_segment_inverted[new_left_proc - 1][ils] = 1;

                  added_segment_to_the_left = true;
                  break;
                }
              } // if (left_proc_of_new_left_proc-1 == left_proc)
            } // if (!done_segment[candidate_segment])
          } // for (ils < nsegs_new_left_proc)

#ifdef PARANOID
          if (!added_segment_to_the_left)
          {
            std::ostringstream error_message;
            error_message
              << "The corresponding processor and segment to the left of "
              << "the current left\nmost segment was not found\n";
            throw OomphLibError(error_message.str(),
                                "TriangleMesh::compute_boundary_segments_"
                                "connectivity_and_initial_zeta_values()",
                                OOMPH_EXCEPTION_LOCATION);
          }
#endif
        } // if (new_left_proc != 0)
        else
        {
          // No more segments to the left
          added_segment_to_the_left = false;
        }

        // Read the info. of the right processor and the right segment
        std::pair<unsigned, unsigned> right_pair = proc_seg_connectivity.back();
        right_proc = right_pair.first;
        right_seg = right_pair.second;

        // Get the processor number to the right of the right-most
        // segment in the list
        const unsigned new_right_proc =
          root_right_processor_plus_one[right_proc][right_seg];

        if (new_right_proc != 0)
        {
          // Initialise flag
          added_segment_to_the_right = false;
          // Get the right halo element id
          const unsigned right_halo_id =
            root_right_halo_element[right_proc][right_seg];

          // Get the right halo element id
          const unsigned right_haloed_id =
            root_right_haloed_element[right_proc][right_seg];

          // Go through the segments on the new right processor and look
          // for the corresponding right_halo_id in the haloed_ids
          const unsigned nsegs_new_right_proc =
            root_nsegments_per_processor[new_right_proc - 1];

          for (unsigned irs = 0; irs < nsegs_new_right_proc; irs++)
          {
            std::pair<unsigned, unsigned> candidate_seg =
              std::make_pair(new_right_proc - 1, irs);

            // Check that the segment has not been already added
            if (!done_segment[candidate_seg])
            {
              // Only consider the segments on new right processor which
              // left processor is the current one (right_proc)
              const unsigned left_proc_of_new_right_proc =
                root_left_processor_plus_one[new_right_proc - 1][irs];
              // Also get the right_proc_of_new_right_proc (in case
              // that it be necessary to invert the segment)
              const unsigned right_proc_of_new_right_proc =
                root_right_processor_plus_one[new_right_proc - 1][irs];
              // Check the not inverted case (to the right and not
              // inverted)
              if (left_proc_of_new_right_proc != 0 &&
                  left_proc_of_new_right_proc - 1 == right_proc)
              {
                // Get the haloed element id of the current segment in the
                // new right processor and compare it to the halo element
                // id of the right_processor
                const unsigned left_halo_id =
                  root_left_halo_element[new_right_proc - 1][irs];
                const unsigned left_haloed_id =
                  root_left_haloed_element[new_right_proc - 1][irs];

                if (right_halo_id == left_haloed_id &&
                    right_haloed_id == left_halo_id)
                {
                  // We have a match of the segments (store the segment
                  // number plus one on the processor to the right)
                  right_connected_segment_plus_one[right_proc][right_seg] =
                    irs + 1;
                  // Add the connectivity information to the list
                  proc_seg_connectivity.push_back(candidate_seg);
                  added_segment_to_the_right = true;
                  break;
                }
              } // if (left_proc_of_new_right_proc-1 == right_proc)

              // Check the inverted case (to the right and inverted)
              if (right_proc_of_new_right_proc != 0 &&
                  right_proc_of_new_right_proc - 1 == right_proc)
              {
                // Get the haloed element id of the current segment
                // (inverted version) in the new right processor and
                // compare it to the halo element id of the
                // right_processor
                const unsigned inv_right_halo_id =
                  root_right_halo_element[new_right_proc - 1][irs];
                const unsigned inv_right_haloed_id =
                  root_right_haloed_element[new_right_proc - 1][irs];
                if (right_halo_id == inv_right_haloed_id &&
                    right_haloed_id == inv_right_halo_id)
                {
                  // We have a match of the segments (store the segment
                  // number plus one on the processor to the right)
                  right_connected_segment_plus_one[right_proc][right_seg] =
                    irs + 1;
                  // Add the connectivity information to the list
                  proc_seg_connectivity.push_back(candidate_seg);
                  // In addition to the connectivity we need to invert the
                  // segment
                  const unsigned tmp_proc =
                    root_left_processor_plus_one[new_right_proc - 1][irs];
                  const unsigned tmp_halo =
                    root_left_halo_element[new_right_proc - 1][irs];
                  const unsigned tmp_haloed =
                    root_left_haloed_element[new_right_proc - 1][irs];

                  root_left_processor_plus_one[new_right_proc - 1][irs] =
                    root_right_processor_plus_one[new_right_proc - 1][irs];
                  root_left_halo_element[new_right_proc - 1][irs] =
                    root_right_halo_element[new_right_proc - 1][irs];
                  root_left_haloed_element[new_right_proc - 1][irs] =
                    root_right_haloed_element[new_right_proc - 1][irs];

                  root_right_processor_plus_one[new_right_proc - 1][irs] =
                    tmp_proc;
                  root_right_halo_element[new_right_proc - 1][irs] = tmp_halo;
                  root_right_haloed_element[new_right_proc - 1][irs] =
                    tmp_haloed;

                  // ... and mark the segment as inverted in the root
                  // processor to inform back to the owner processor
                  root_segment_inverted[new_right_proc - 1][irs] = 1;

                  added_segment_to_the_right = true;
                  break;
                }
              } // if (right_proc_of_new_right_proc-1 == right_proc)
            } // if (!done_segment[candidate_segment])
          } // for (irs < nsegs_new_left_proc)

#ifdef PARANOID
          if (!added_segment_to_the_right)
          {
            std::ostringstream error_message;
            error_message
              << "The corresponding processor and segment to the right of "
              << "the current right\nmost segment was not found\n";
            throw OomphLibError(error_message.str(),
                                "TriangleMesh::compute_boundary_segments_"
                                "connectivity_and_initial_zeta_values()",
                                OOMPH_EXCEPTION_LOCATION);
          }
#endif
        } // if (new_right_proc != 0)
        else
        {
          // No more segments to the left
          added_segment_to_the_right = false;
        }

      } while (added_segment_to_the_left || added_segment_to_the_right);

      // Once we have connected the segments then we can compute the
      // initial and final zeta values based on the arclength of each
      // individual segment

      // Get the total number of segments, which MUST be the same as the
      // total number of segments in all processors
      const unsigned ntotal_segments = proc_seg_connectivity.size();
#ifdef PARANOID
      unsigned tmp_total_segments = 0;
      for (unsigned ip = 0; ip < nproc; ip++)
      {
        tmp_total_segments += root_nsegments_per_processor[ip];
      }

      // Check that the total number of segments in all processors is
      // the same as the number of segments that form the boundary
      if (ntotal_segments != tmp_total_segments)
      {
        std::ostringstream error_message;
        error_message << "The number of sorted segments (" << ntotal_segments
                      << ") on "
                      << "boundary (" << b
                      << ")\nis different from the total number of "
                      << "segments (" << tmp_total_segments
                      << ") in all\nprocessors.\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      } // if (ntotal_segments!=tmp_total_segments)
#endif

      // Now that we know the connectivity of the segments we can
      // compute the initial arclength of each segment in the
      // processors. Additionally we also get the number of vertices
      // before each of the segments. Resize the containers considering
      // the number of segments in each processor
      for (unsigned ip = 0; ip < nproc; ip++)
      {
        const unsigned nsegs_iproc = root_nsegments_per_processor[ip];
        root_initial_segment_arclength[ip].resize(nsegs_iproc);
        root_nvertices_before_segment[ip].resize(nsegs_iproc);
      }

      Vector<double> aux_initial_segment_arclength(ntotal_segments);
      Vector<unsigned> aux_nvertices_before_segment(ntotal_segments);

      ucounter = 0;
      for (std::list<std::pair<unsigned, unsigned>>::iterator it_list =
             proc_seg_connectivity.begin();
           it_list != proc_seg_connectivity.end();
           it_list++)
      {
        const unsigned iproc = static_cast<unsigned>((*it_list).first);
        const unsigned iseg = static_cast<unsigned>((*it_list).second);
        const double iseg_arclength = root_segment_arclength[iproc][iseg];
        const unsigned iseg_nvertices = root_nvertices_per_segment[iproc][iseg];

        aux_initial_segment_arclength[ucounter] = root_accumulated_arclength;
        aux_nvertices_before_segment[ucounter] =
          root_accumulated_vertices_before_segment;

        // Set the initial zeta value for the segment
        root_initial_segment_arclength[iproc][iseg] =
          root_accumulated_arclength;
        // Set the number of vertices before the current segment
        root_nvertices_before_segment[iproc][iseg] =
          root_accumulated_vertices_before_segment;

        // Add the arclength of the segment to the global arclength
        root_accumulated_arclength += iseg_arclength;
        // Add the number of vertices to the global number of vertices
        root_accumulated_vertices_before_segment += iseg_nvertices - 1;

        // Increase the counter
        ucounter++;
      } // for (loop over the sorted segments to assigne initial
        // arlength and initial number of vertices)

      // Increase by one to get the total number of vertices on the
      // boundary
      root_accumulated_vertices_before_segment++;

      // Get the processors with the initial and final segment.
      proc_with_initial_seg = proc_seg_connectivity.front().first;
      proc_with_final_seg = proc_seg_connectivity.back().first;
      // Also get the corresponding initial and final segment indexes
      // (on the initial and final processors)
      initial_segment = proc_seg_connectivity.front().second;
      final_segment = proc_seg_connectivity.back().second;

    } // if (my_rank == root_processor)

    // Get the total number of segments
    unsigned root_ntotal_segments = 0;
    for (unsigned ip = 0; ip < nproc; ip++)
    {
      root_ntotal_segments += root_nsegments_per_processor[ip];
    }

    // Package the info. that will be sent to each processor. For the
    // unsigned package we send the number of vertices before each
    // segment in each processor and whether it was inverted or not
    // Package size
    const unsigned rspu = 2;
    flat_packed_unsigned_send_data.clear();
    flat_packed_unsigned_send_data.resize(root_ntotal_segments * rspu);
    unsigned ucounter = 0;
    // Collect the info. from all the segments in the processors
    for (unsigned ip = 0; ip < nproc; ip++)
    {
      const unsigned nsegs_iproc = root_nsegments_per_processor[ip];
      for (unsigned is = 0; is < nsegs_iproc; is++)
      {
        flat_packed_unsigned_send_data[ucounter++] =
          root_nvertices_before_segment[ip][is];
        flat_packed_unsigned_send_data[ucounter++] =
          root_segment_inverted[ip][is];
      } // for (is < nsegs_iproc)
    } // for (ip < nproc)

    // How many data does the root processor will send to each processor
    Vector<int> root_nudata_to_send(nproc, 0);
    for (unsigned ip = 0; ip < nproc; ip++)
    {
      // Get the number of data to send to ip processor
      root_nudata_to_send[ip] = root_nsegments_per_processor[ip] * rspu;
    }

    // Store and compute the offsets for the data sent to each processor
    Vector<int> root_uoffsets_send(nproc, 0);
    root_uoffsets_send[0] = 0;
    for (unsigned ip = 1; ip < nproc; ip++)
    {
      // Compute the offset to send the values to each processor
      root_uoffsets_send[ip] =
        root_uoffsets_send[ip - 1] + root_nudata_to_send[ip - 1];
    }

    // Number of data to receive from root
    unsigned nutotal_data_receive = nsegments * rspu;

    if (my_rank != root_processor)
    {
      // Create at least one entry so we don't get a seg fault below
      if (flat_packed_unsigned_send_data.size() == 0)
      {
        flat_packed_unsigned_send_data.resize(1);
      }
    }

    // Clear and resize the vector where to receive the info.
    flat_packed_unsigned_receive_data.clear();
    flat_packed_unsigned_receive_data.resize(nutotal_data_receive);
    // Create at least one entry so we don't get a seg fault below
    if (flat_packed_unsigned_receive_data.size() == 0)
    {
      flat_packed_unsigned_receive_data.resize(1);
    }

    MPI_Scatterv(&flat_packed_unsigned_send_data[0],
                 &root_nudata_to_send[0],
                 &root_uoffsets_send[0],
                 MPI_UNSIGNED,
                 &flat_packed_unsigned_receive_data[0],
                 nutotal_data_receive,
                 MPI_UNSIGNED,
                 root_processor,
                 comm_pt->mpi_comm());

    // Package the info. that will be sent to each processor, for the
    // double package we send (one data per segment) the initial
    // arclength for each segment
    const unsigned rspd = 1;
    flat_packed_double_send_data.clear();
    flat_packed_double_send_data.resize(root_ntotal_segments * rspd);
    unsigned dcounter = 0;
    // Collect the info. from all the segments in the processors
    for (unsigned ip = 0; ip < nproc; ip++)
    {
      const unsigned nsegs_iproc = root_nsegments_per_processor[ip];
      for (unsigned is = 0; is < nsegs_iproc; is++)
      {
        flat_packed_double_send_data[dcounter++] =
          root_initial_segment_arclength[ip][is];
      }
    }

    // How many data does the root processor will send to each processor
    Vector<int> root_nddata_to_send(nproc, 0);
    for (unsigned ip = 0; ip < nproc; ip++)
    {
      // Number of data send to ip processor
      root_nddata_to_send[ip] = root_nsegments_per_processor[ip] * rspd;
    }

    // Store and compute the offsets for the data sent to each processor
    Vector<int> root_doffsets_send(nproc, 0);
    root_doffsets_send[0] = 0;
    for (unsigned ip = 1; ip < nproc; ip++)
    {
      // Compute the offset to send the values to each processor
      root_doffsets_send[ip] =
        root_doffsets_send[ip - 1] + root_nddata_to_send[ip - 1];
    }

    // Number of double data to receive from root
    unsigned ndtotal_data_receive = nsegments * rspd;

    if (my_rank != root_processor)
    {
      // Create at least one entry so we don't get a seg fault below
      if (flat_packed_double_send_data.size() == 0)
      {
        flat_packed_double_send_data.resize(1);
      }
    }

    // Clear and resize the vector where to receive the info.
    flat_packed_double_receive_data.clear();
    flat_packed_double_receive_data.resize(ndtotal_data_receive);
    // Create at least one entry so we don't get a seg fault below
    if (flat_packed_double_receive_data.size() == 0)
    {
      flat_packed_double_receive_data.resize(1);
    }

    MPI_Scatterv(&flat_packed_double_send_data[0],
                 &root_nddata_to_send[0],
                 &root_doffsets_send[0],
                 MPI_DOUBLE,
                 &flat_packed_double_receive_data[0],
                 ndtotal_data_receive,
                 MPI_DOUBLE,
                 root_processor,
                 comm_pt->mpi_comm());

    // Read if the segments need to be inverted and read the initial
    // arclengths
    ucounter = 0;
    dcounter = 0;

    // Read the info. from the flat package and store it in their
    // corresponding containers
    for (unsigned is = 0; is < nsegments; is++)
    {
      // The flat unsigned package
      nvertices_before_segment[is] =
        flat_packed_unsigned_receive_data[ucounter++];
      // The segment inverted flag
      segment_inverted[is] = flat_packed_unsigned_receive_data[ucounter++];
      // The flat double package
      initial_segment_arclength[is] =
        flat_packed_double_receive_data[dcounter++];
    } // for (is < nsegments)

    // Perform two additional communications to get the total number of
    // vertices, the processors with the initial and final segments, the
    // corresponding initial and final segments ...
    const unsigned numore_info = 5;
    Vector<unsigned> flat_package_unsigned_more_info(numore_info);
    // Prepare the info ...
    flat_package_unsigned_more_info[0] =
      root_accumulated_vertices_before_segment;
    flat_package_unsigned_more_info[1] = proc_with_initial_seg;
    flat_package_unsigned_more_info[2] = proc_with_final_seg;
    flat_package_unsigned_more_info[3] = initial_segment;
    flat_package_unsigned_more_info[4] = final_segment;

    // Send the info. to all processors
    MPI_Bcast(&flat_package_unsigned_more_info[0],
              numore_info,
              MPI_UNSIGNED,
              root_processor,
              comm_pt->mpi_comm());

    // ... and store the info. in the proper containers
    root_accumulated_vertices_before_segment =
      flat_package_unsigned_more_info[0];
    proc_with_initial_seg = flat_package_unsigned_more_info[1];
    proc_with_final_seg = flat_package_unsigned_more_info[2];
    initial_segment = flat_package_unsigned_more_info[3];
    final_segment = flat_package_unsigned_more_info[4];

    // Do the same for the maximum zeta value
    MPI_Bcast(&root_accumulated_arclength,
              1,
              MPI_DOUBLE,
              root_processor,
              comm_pt->mpi_comm());

    // -----------------------------------------------------------------
    // Clear the storage to store the data that will be used by the
    // setup boundary coordinates method, if we do not perform the
    // cleaning then previous data from previous iterations will remain
    // there
    // -----------------------------------------------------------------
    // The info. for the boundary
    Boundary_initial_coordinate[b].clear();
    Boundary_final_coordinate[b].clear();

    Boundary_initial_zeta_coordinate[b].clear();
    Boundary_final_zeta_coordinate[b].clear();

    // The info. for the segments
    Boundary_segment_inverted[b].clear();
    Boundary_segment_initial_coordinate[b].clear();
    Boundary_segment_final_coordinate[b].clear();

    Boundary_segment_initial_zeta[b].clear();
    Boundary_segment_final_zeta[b].clear();

    Boundary_segment_initial_arclength[b].clear();
    Boundary_segment_final_arclength[b].clear();

    // Now copy all the info. to the containers to be sent to any other
    // mesh (in the adaptation method)
    for (unsigned is = 0; is < nsegments; is++)
    {
      // At this point we can get the initial and final coordinates for
      // each segment
      Vector<double> first_seg_coord(2);
      Vector<double> last_seg_coord(2);

      // In order to get the first and last coordinates of each segment we
      // first need to identify the first and last nonhalo element of each
      // segment, and then get the first and last node of the segment

      // Get the first nonhalo face element on the segment
      FiniteElement* first_seg_ele_pt =
        segment_sorted_nonhalo_ele_pt[is].front();

#ifdef PARANOID
      // Check if the face element is nonhalo, it shouldn't, but better
      // check
      if (first_seg_ele_pt->is_halo())
      {
        std::ostringstream error_message;
        error_message << "The first face element in the (" << is
                      << ")-th segment is halo\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::compute_boundary_segments_"
                            "connectivity_and_initial_zeta_values()",
                            OOMPH_EXCEPTION_LOCATION);
      } // if (tmp_first_bulk_ele_pt->is_halo())
#endif

      // Number of nodes
      const unsigned nnod = first_seg_ele_pt->nnode();

      // Get the first node of the current segment
      Node* first_seg_node_pt = first_seg_ele_pt->node_pt(0);
      if (is_inverted[first_seg_ele_pt])
      {
        first_seg_node_pt = first_seg_ele_pt->node_pt(nnod - 1);
      }

      // Get the last nonhalo face element on the segment
      FiniteElement* last_seg_ele_pt = segment_sorted_nonhalo_ele_pt[is].back();

#ifdef PARANOID
      // Check if the face element is nonhalo, it shouldn't, but better
      // check
      if (last_seg_ele_pt->is_halo())
      {
        std::ostringstream error_message;
        error_message << "The last face element in the (" << is
                      << ")-th segment is halo\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::compute_boundary_segments_"
                            "connectivity_and_initial_zeta_values()",
                            OOMPH_EXCEPTION_LOCATION);
      } // if (tmp_first_bulk_ele_pt->is_halo())
#endif

      // Get the last node of the current segment
      Node* last_seg_node_pt = last_seg_ele_pt->node_pt(nnod - 1);
      if (is_inverted[last_seg_ele_pt])
      {
        last_seg_node_pt = last_seg_ele_pt->node_pt(0);
      }

      // Get the coordinates for the first and last segment's node
      for (unsigned i = 0; i < 2; i++)
      {
        first_seg_coord[i] = first_seg_node_pt->x(i);
        last_seg_coord[i] = last_seg_node_pt->x(i);
      }

      // -----------------------------------------------------------------
      // Copy the info. if the segment is inverted
      Boundary_segment_inverted[b].push_back(segment_inverted[is]);

      // Check if the segment is inverted, if that is the case then invert
      // the first and last seg. coordinates
      if (!segment_inverted[is])
      {
        // Store the initial and final coordinates that will help to
        // identify the segments in the new meshes created from this one
        Boundary_segment_initial_coordinate[b].push_back(first_seg_coord);
        Boundary_segment_final_coordinate[b].push_back(last_seg_coord);
      }
      else
      {
        // Store the initial and final coordinates that will help to
        // identify the segments in the new meshes created from this one
        // Invert the initial and final coordinates
        Boundary_segment_initial_coordinate[b].push_back(last_seg_coord);
        Boundary_segment_final_coordinate[b].push_back(first_seg_coord);
      }

      // Now assign initial and final zeta boundary coordinates for each
      // segment
      // -----------------------------------------------------------------
      // If there is a geom object then
      if (boundary_geom_object_pt(b) != 0)
      {
        // Store the initial and final zeta for the current segments (we
        // got this when we assigned arclength to the segments in the
        // current processor)
        if (segment_inverted[is])
        {
          Boundary_segment_initial_zeta[b].push_back(final_zeta_segment[is]);
          Boundary_segment_final_zeta[b].push_back(initial_zeta_segment[is]);
        }
        else
        {
          Boundary_segment_initial_zeta[b].push_back(initial_zeta_segment[is]);
          Boundary_segment_final_zeta[b].push_back(final_zeta_segment[is]);
        }
      } // if (boundary_geom_object_pt(b)!=0)
      else
      {
        // Store the initial arclength and vertices number for the
        // current segment
        Boundary_segment_initial_arclength[b].push_back(
          initial_segment_arclength[is]);

        Boundary_segment_final_arclength[b].push_back(
          initial_segment_arclength[is] + segment_arclength[is]);

      } // else if (boundary_geom_object_pt(b)!=0)

    } // //  for (is < nsegments)

    // Get the number of segments from the sets of nodes
#ifdef PARANOID
    if (segment_all_nodes_pt.size() != nsegments)
    {
      std::ostringstream error_message;
      error_message << "The number of segments (" << nsegments
                    << ") and the number of "
                    << "set of nodes (" << segment_all_nodes_pt.size()
                    << ") representing\n"
                    << "the\nsegments is different!!!\n\n";
      throw OomphLibError(error_message.str(),
                          "TriangleMesh::compute_boundary_segments_"
                          "connectivity_and_initial_zeta_values()",
                          OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // The nodes have been assigned arc-length coordinates from one end
    // or the other of the connected segment.

    // -----------------------------------------------------------------
    // If mesh is distributed get the info. regarding the initial and
    // final nodes coordinates on the boundary, same as the zeta
    // boundary values for those nodes

    // Storage for the coordinates of the first and last nodes on the
    // boundary
    Vector<double> first_coordinate(2);
    Vector<double> last_coordinate(2);

    // Storage for the zeta coordinate of the first and last nodes on
    // the boundary
    Vector<double> first_node_zeta_coordinate(1, 0.0);
    Vector<double> last_node_zeta_coordinate(1, 0.0);

    // Send three data to all processors, the x[0], x[1] coordinate and
    // the zeta coordinate
    const unsigned ndtotal_data = 3;
    Vector<double> flat_packed_double_data_initial_seg(ndtotal_data);

    // If the mesh is distributed then check if this processor has the
    // initial segment
    if (my_rank == proc_with_initial_seg)
    {
      // Stores the firts element of the segment
      FiniteElement* first_ele_pt = 0;
      // Stores the first node of the boundary
      Node* first_node_pt = 0;
      // Check if the segment is inverted
      if (!segment_inverted[initial_segment])
      {
        // Get access to the first element on the segment marked as
        // initial
        first_ele_pt = segment_sorted_ele_pt[initial_segment].front();

        // Number of nodes
        const unsigned nnod = first_ele_pt->nnode();

        // Get the first node of the current segment
        first_node_pt = first_ele_pt->node_pt(0);
        if (is_inverted[first_ele_pt])
        {
          first_node_pt = first_ele_pt->node_pt(nnod - 1);
        }
      } // if (!segment_inverted[initial_segment])
      else
      {
        // Get access to the first element on the segment marked as
        // initial
        first_ele_pt = segment_sorted_ele_pt[initial_segment].back();

        // Number of nodes
        const unsigned nnod = first_ele_pt->nnode();

        // Get the first node of the current segment
        first_node_pt = first_ele_pt->node_pt(nnod - 1);
        if (is_inverted[first_ele_pt])
        {
          first_node_pt = first_ele_pt->node_pt(0);
        }
      } // else if (!segment_inverted[initial_segment])

      // Get the coordinates for the first node
      for (unsigned i = 0; i < 2; i++)
      {
        flat_packed_double_data_initial_seg[i] = first_node_pt->x(i);
      }

      // Get the zeta coordinates for the first node
      Vector<double> tmp_zeta(1);
      first_node_pt->get_coordinates_on_boundary(b, tmp_zeta);

      // If there is a geometric object associated to the boundary then
      // further process is necessary
      if (this->boundary_geom_object_pt(b) != 0)
      {
        // tmp_zeta[0] = this->boundary_coordinate_limits(b)[0];
      }
      else
      {
        // Check if the initial boundary coordinate is different from
        // zero, if that is the case then we need to set it to zero
        if (tmp_zeta[0] >= 1.0e-14)
        {
          tmp_zeta[0] = 0;
        }
      } // if (this->boundary_geom_object_pt(b)!=0)

      // Store the initial zeta value
      flat_packed_double_data_initial_seg[2] = tmp_zeta[0];

    } // if (my_rank == proc_with_initial_seg)

    // All processor receive the info. from the processor that has the
    // initial segment
    MPI_Bcast(&flat_packed_double_data_initial_seg[0],
              ndtotal_data,
              MPI_DOUBLE,
              proc_with_initial_seg,
              comm_pt->mpi_comm());

    // ... and all processor put that info. into the appropriate
    // storages
    for (unsigned i = 0; i < 2; i++)
    {
      first_coordinate[i] = flat_packed_double_data_initial_seg[i];
    }
    first_node_zeta_coordinate[0] = flat_packed_double_data_initial_seg[2];

    // -----------------------------------------------------------------
    // Send three data to all processors, the x[0], x[1] coordinate and
    // the zeta coordinate
    Vector<double> flat_packed_double_data_final_seg(ndtotal_data);

    // If the mesh is distributed then check if this processor has the
    // final segment
    if (my_rank == proc_with_final_seg)
    {
      // Get access to the last element on the segment
      FiniteElement* last_ele_pt = 0;

      // Get the last node of the current segment
      Node* last_node_pt = 0;

      // Check if the segment is inverted
      if (!segment_inverted[final_segment])
      {
        // Get access to the last element on the segment marked as
        // final
        last_ele_pt = segment_sorted_ele_pt[final_segment].back();

        // Number of nodes
        const unsigned nnod = last_ele_pt->nnode();

        // Get the last node of the current segment
        last_node_pt = last_ele_pt->node_pt(nnod - 1);
        if (is_inverted[last_ele_pt])
        {
          last_node_pt = last_ele_pt->node_pt(0);
        }
      } // if (!segment_inverted[final_segment])
      else
      {
        // Get access to the first element on the segment marked as
        // initial
        last_ele_pt = segment_sorted_ele_pt[final_segment].front();

        // Number of nodes
        const unsigned nnod = last_ele_pt->nnode();

        // Get the first node of the current segment
        last_node_pt = last_ele_pt->node_pt(0);
        if (is_inverted[last_ele_pt])
        {
          last_node_pt = last_ele_pt->node_pt(nnod - 1);
        }
      } // if (!segment_inverted[final_segment])

      // Get the coordinates for the last node
      for (unsigned i = 0; i < 2; i++)
      {
        flat_packed_double_data_final_seg[i] = last_node_pt->x(i);
      }

      // Get the zeta coordinates for the last node
      Vector<double> tmp_zeta(1);
      last_node_pt->get_coordinates_on_boundary(b, tmp_zeta);

      // If there is not a geometric object associated to the boundary
      // then further process is required
      if (this->boundary_geom_object_pt(b) != 0)
      {
        // Do nothing
      } // if (this->boundary_geom_object_pt(b)!=0)
      else
      {
        // Check if the final boundary coordinate is different from
        // the boundary arclength, if that is the case then we need
        // to set it to the accumulated arclength
        if (std::fabs(tmp_zeta[0] - root_accumulated_arclength) >= 1.0e-14)
        {
          tmp_zeta[0] = root_accumulated_arclength;
        }
      } // else if (this->boundary_geom_object_pt(b)!=0)

      // Store the final zeta value
      flat_packed_double_data_final_seg[2] = tmp_zeta[0];

    } // if (my_rank == proc_with_final_seg)

    // All processor receive the info. from the processor that has the
    // final segment
    MPI_Bcast(&flat_packed_double_data_final_seg[0],
              ndtotal_data,
              MPI_DOUBLE,
              proc_with_final_seg,
              comm_pt->mpi_comm());

    // All processor receive the info. from the processor that has the
    // final segment
    for (unsigned i = 0; i < 2; i++)
    {
      last_coordinate[i] = flat_packed_double_data_final_seg[i];
    }
    last_node_zeta_coordinate[0] = flat_packed_double_data_final_seg[2];

    // -----------------------------------------------------------------
    // Copy the values to the permanent storage
    Boundary_initial_coordinate[b] = first_coordinate;
    Boundary_final_coordinate[b] = last_coordinate;

    Boundary_initial_zeta_coordinate[b] = first_node_zeta_coordinate;
    Boundary_final_zeta_coordinate[b] = last_node_zeta_coordinate;

    // If we are dealing with an internal boundary then re-assign the
    // initial and final zeta values for the segments
    if (is_internal_boundary)
    {
      // Only re-assign zeta values if there are at least one nonhalo
      // segment, if all the possible segments are halo then the
      // synchronisation method will be in charge of assigning the
      // correct boundary coordinates
      if (nsegments > 0)
      {
        // Call the following method to re-construct the segments but
        // using only the nonhalo elements, therefore the boundary
        // coordinates need to be re-assigned
        re_assign_initial_zeta_values_for_internal_boundary(
          b, segment_sorted_nonhalo_ele_pt, is_inverted);
      }

    } // if (is_internal_boundary)

    // Now identify the boundary segments
    if (nsegments > 0)
    {
      // Identify the boundary segments in the current mesh
      // identify_boundary_segments_and_assign_initial_zeta_values(
      //  b, all_face_ele_pt, is_internal_boundary, face_to_bulk_element_pt);
      identify_boundary_segments_and_assign_initial_zeta_values(b, this);
    } // if (nsegments > 0)

    // Clean all the created face elements
    for (unsigned i = 0; i < n_all_face_ele; i++)
    {
      delete all_face_ele_pt[i];
      all_face_ele_pt[i] = 0;
    }
  }

  //======================================================================
  /// Re-assign the boundary segments initial zeta (arclength)
  /// for those internal boundaries that were splited during the
  /// distribution process. Those boundaries that have one face element
  /// at each side of the boundary. Here we create the segments only
  /// with the nonhalo elements, therefore the boundary coordinates
  /// need to be re-assigned to be passed to the new meshes
  //======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::
    re_assign_initial_zeta_values_for_internal_boundary(
      const unsigned& b,
      Vector<std::list<FiniteElement*>>& old_segment_sorted_ele_pt,
      std::map<FiniteElement*, bool>& old_is_inverted)
  {
    // ------------------------------------------------------------------
    // First: Get the face elements associated with the current boundary
    //        Only include nonhalo face elements
    // ------------------------------------------------------------------
    // Temporary storage for face elements
    Vector<FiniteElement*> face_el_pt;

    // Temporary storage for the number of elements adjacent to the
    // boundary
    unsigned nele = 0;

    // Temporary storage for elements adjacent to the boundary that have
    // a common edge (related with internal boundaries)
    unsigned n_repeated_ele = 0;

    const unsigned n_regions = this->nregion();

    // Temporary storage for already done nodes
    Vector<std::pair<Node*, Node*>> done_nodes_pt;

    // If there is more than one region then only use boundary
    // coordinates from the bulk side (region 0)
    if (n_regions > 1)
    {
      for (unsigned rr = 0; rr < n_regions; rr++)
      {
        const unsigned region_id =
          static_cast<unsigned>(this->Region_attribute[rr]);

        // Loop over all elements on boundaries in region i_r
        const unsigned nel_in_region =
          this->nboundary_element_in_region(b, region_id);

        unsigned nel_repetead_in_region = 0;

        // Only bother to do anything else, if there are elements
        // associated with the boundary and the current region
        if (nel_in_region > 0)
        {
          bool repeated = false;

          // Loop over the bulk elements adjacent to boundary b
          for (unsigned e = 0; e < nel_in_region; e++)
          {
            // Get pointer to the bulk element that is adjacent to
            // boundary b
            FiniteElement* bulk_elem_pt =
              this->boundary_element_in_region_pt(b, region_id, e);

            // Remember only work with non halo elements
            if (bulk_elem_pt->is_halo())
            {
              n_repeated_ele++;
              continue;
            }

            // Find the index of the face of element e along boundary b
            int face_index =
              this->face_index_at_boundary_in_region(b, region_id, e);

            // Before adding the new element we need to be sure that the
            // edge that this element represent has not been already
            // added
            FiniteElement* tmp_ele_pt =
              new DummyFaceElement<ELEMENT>(bulk_elem_pt, face_index);

            const unsigned n_nodes = tmp_ele_pt->nnode();

            std::pair<Node*, Node*> tmp_pair = std::make_pair(
              tmp_ele_pt->node_pt(0), tmp_ele_pt->node_pt(n_nodes - 1));

            std::pair<Node*, Node*> tmp_pair_inverse = std::make_pair(
              tmp_ele_pt->node_pt(n_nodes - 1), tmp_ele_pt->node_pt(0));

            // Search for repeated nodes
            const unsigned repeated_nodes_size = done_nodes_pt.size();
            for (unsigned l = 0; l < repeated_nodes_size; l++)
            {
              if (tmp_pair == done_nodes_pt[l] ||
                  tmp_pair_inverse == done_nodes_pt[l])
              {
                nel_repetead_in_region++;
                repeated = true;
                break;
              }
            }

            // Create new face element
            if (!repeated)
            {
              // Add the pair of nodes (edge) to the node dones
              done_nodes_pt.push_back(tmp_pair);
              // Add the element to the face elements
              face_el_pt.push_back(tmp_ele_pt);
            }
            else
            {
              // Clean up
              delete tmp_ele_pt;
              tmp_ele_pt = 0;
            }

            // Re-start
            repeated = false;

          } // for nel

          nele += nel_in_region;

          n_repeated_ele += nel_repetead_in_region;

        } // if (nel_in_region > 0)
      } // for (rr < n_regions)
    } // if (n_regions > 1)
    // Otherwise it's just the normal boundary functions
    else
    {
      // Loop over all elements on boundaries
      nele = this->nboundary_element(b);

      // Only bother to do anything else, if there are elements
      if (nele > 0)
      {
        // Check for repeated ones
        bool repeated = false;

        // Loop over the bulk elements adjacent to boundary b
        for (unsigned e = 0; e < nele; e++)
        {
          // Get pointer to the bulk element that is adjacent to
          // boundary b
          FiniteElement* bulk_elem_pt = this->boundary_element_pt(b, e);

          // Skip the halo elements, they are not included
          if (bulk_elem_pt->is_halo())
          {
            n_repeated_ele++;
            continue;
          }

          // Find the index of the face of element e along boundary b
          int face_index = this->face_index_at_boundary(b, e);

          // Before adding the new element we need to be sure that the
          // edge that this element represents has not been already
          // added (only applies for internal boundaries)
          FiniteElement* tmp_ele_pt =
            new DummyFaceElement<ELEMENT>(bulk_elem_pt, face_index);

          const unsigned n_nodes = tmp_ele_pt->nnode();

          std::pair<Node*, Node*> tmp_pair = std::make_pair(
            tmp_ele_pt->node_pt(0), tmp_ele_pt->node_pt(n_nodes - 1));

          std::pair<Node*, Node*> tmp_pair_inverse = std::make_pair(
            tmp_ele_pt->node_pt(n_nodes - 1), tmp_ele_pt->node_pt(0));

          // Search for repeated nodes
          const unsigned repeated_nodes_size = done_nodes_pt.size();
          for (unsigned l = 0; l < repeated_nodes_size; l++)
          {
            if (tmp_pair == done_nodes_pt[l] ||
                tmp_pair_inverse == done_nodes_pt[l])
            {
              // Increase the number of repeated elements
              n_repeated_ele++;
              // Mark the element as repeated
              repeated = true;
              break;
            }
          }

          // Create new face element
          if (!repeated)
          {
            // Add the pair of nodes (edge) to the node dones
            done_nodes_pt.push_back(tmp_pair);
            // Add the element to the face elements
            face_el_pt.push_back(tmp_ele_pt);
          }
          else
          {
            // Free the repeated bulk element!!
            delete tmp_ele_pt;
            tmp_ele_pt = 0;
          }

          // Re-start
          repeated = false;

        } // for (e < nel)
      } // if (nel > 0)

    } // else (n_regions > 1)

    // Do not consider the repeated elements
    nele -= n_repeated_ele;

#ifdef PARANOID
    if (nele != face_el_pt.size())
    {
      std::ostringstream error_message;
      error_message
        << "The independet counting of face elements (" << nele << ") for "
        << "boundary (" << b << ") is different\n"
        << "from the real number of face elements in the container ("
        << face_el_pt.size() << ")\n";
      //<< "Possible memory leak\n"
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // ----------------------------------------------------------------
    // Second: Sort the face elements, only consider nonhalo elements
    // ----------------------------------------------------------------

    // Get the total number of nonhalo face elements
    const unsigned nnon_halo_face_elements = face_el_pt.size();

    // The vector of list to store the "segments" that compound the
    // boundary (segments may appear only in a distributed mesh)
    Vector<std::list<FiniteElement*>> segment_sorted_ele_pt;

    // Number of already sorted face elements
    unsigned nsorted_face_elements = 0;

    // Keep track of who's done
    std::map<FiniteElement*, bool> done_el;

    // Keep track of which element is inverted
    std::map<FiniteElement*, bool> is_inverted;

    // Iterate until all possible segments have been created
    while (nsorted_face_elements < nnon_halo_face_elements)
    {
      // The ordered list of face elements (in a distributed mesh a
      // collection of contiguous face elements define a segment)
      std::list<FiniteElement*> sorted_el_pt;

#ifdef PARANOID
      // Select an initial element for the segment
      bool found_initial_face_element = false;
#endif

      FiniteElement* ele_face_pt = 0;

      unsigned iface = 0;
      for (iface = 0; iface < nele; iface++)
      {
        ele_face_pt = face_el_pt[iface];
        // If not done then take it as initial face element
        if (!done_el[ele_face_pt])
        {
#ifdef PARANOID
          // Mark as found the root face element
          found_initial_face_element = true;
#endif
          // Increase the number of sorted face elements
          nsorted_face_elements++;
          // Increase the counter to mark the position of the next
          // element number
          iface++;
          // Add the face element in the list of sorted face elements
          sorted_el_pt.push_back(ele_face_pt);
          // Mark as done
          done_el[ele_face_pt] = true;
          break;
        } // if (!done_el[ele_face_pt])
      } // for (iface < nele)

#ifdef PARANOID
      if (!found_initial_face_element)
      {
        std::ostringstream error_message;
        error_message
          << "Could not find an initial face element for the current segment\n";
        throw OomphLibError(
          error_message.str(),
          "TriangleMesh::re_assign_initial_zeta_values_for_internal_boundary()",
          OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Number of nodes
      const unsigned nnod = ele_face_pt->nnode();

      // Left and rightmost nodes (the left and right nodes of the
      // current face element)
      Node* left_node_pt = ele_face_pt->node_pt(0);
      Node* right_node_pt = ele_face_pt->node_pt(nnod - 1);

      // Continue iterating if a new face element has been added to the
      // list
      bool face_element_added = false;

      // While a new face element has been added to the set of sorted
      // face elements then re-iterate
      do
      {
        // Start from the next face element since we have already added
        // the previous one as the initial face element (any previous
        // face element had to be added on previous iterations)
        for (unsigned iiface = iface; iiface < nele; iiface++)
        {
          // Re-start flag
          face_element_added = false;

          // Get the candidate element
          ele_face_pt = face_el_pt[iiface];

          // Check that the candidate element has not been done and is
          // not a halo element
          if (!(done_el[ele_face_pt]))
          {
            // Get the left and right nodes of the current element
            Node* local_left_node_pt = ele_face_pt->node_pt(0);
            Node* local_right_node_pt = ele_face_pt->node_pt(nnod - 1);

            // New element fits at the left of segment and is not inverted
            if (left_node_pt == local_right_node_pt)
            {
              left_node_pt = local_left_node_pt;
              sorted_el_pt.push_front(ele_face_pt);
              is_inverted[ele_face_pt] = false;
              face_element_added = true;
            }
            // New element fits at the left of segment and is inverted
            else if (left_node_pt == local_left_node_pt)
            {
              left_node_pt = local_right_node_pt;
              sorted_el_pt.push_front(ele_face_pt);
              is_inverted[ele_face_pt] = true;
              face_element_added = true;
            }
            // New element fits on the right of segment and is not inverted
            else if (right_node_pt == local_left_node_pt)
            {
              right_node_pt = local_right_node_pt;
              sorted_el_pt.push_back(ele_face_pt);
              is_inverted[ele_face_pt] = false;
              face_element_added = true;
            }
            // New element fits on the right of segment and is inverted
            else if (right_node_pt == local_right_node_pt)
            {
              right_node_pt = local_left_node_pt;
              sorted_el_pt.push_back(ele_face_pt);
              is_inverted[ele_face_pt] = true;
              face_element_added = true;
            }

            if (face_element_added)
            {
              done_el[ele_face_pt] = true;
              nsorted_face_elements++;
              break;
            } // if (face_element_added)

          } // if (!(done_el[ele_face_pt]))

        } // for (iiface<nnon_halo_face_element)

      } while (face_element_added &&
               (nsorted_face_elements < nnon_halo_face_elements));

      // Store the created segment in the vector of segments
      segment_sorted_ele_pt.push_back(sorted_el_pt);

    } // while(nsorted_face_elements < nnon_halo_face_elements);

    // --------------------------------------------------------------
    // Third: We have the face elements sorted, now assign boundary
    // coordinates to the nodes in the segments and compute the
    // arclength of the segment.
    // --------------------------------------------------------------

    // The number of segments in this processor
    const unsigned nsegments = segment_sorted_ele_pt.size();

#ifdef PARANOID
    if (nnon_halo_face_elements > 0 && nsegments == 0)
    {
      std::ostringstream error_message;
      error_message
        << "The number of segments is zero, but the number of nonhalo\n"
        << "elements is: (" << nnon_halo_face_elements << ")\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    } // if (nnon_halo_face_elements > 0 && nsegments == 0)
#endif

    // Vector of sets that stores the nodes of each segment based on a
    // lexicographically order starting from the bottom left node of
    // each segment
    Vector<std::set<Node*>> segment_all_nodes_pt(nsegments);

    // Stores the nodes on each segment in the order they appear in the
    // face elements
    Vector<Vector<Node*>> sorted_segment_all_nodes_pt(nsegments);

    // Associate and arclength to each node on each segment of the
    // boundary, the nodes and therefore the arclength come in the same
    // order as the face elements
    Vector<Vector<double>> sorted_segment_node_arclength(nsegments);

    // The arclength of each segment in the current processor
    Vector<double> segment_arclength(nsegments);

    // The number of vertices of each segment
    Vector<unsigned> nvertices_per_segment(nsegments);

    // The initial zeta for the segment
    Vector<double> initial_zeta_segment(nsegments);

    // The final zeta for the segment
    Vector<double> final_zeta_segment(nsegments);

    // Go through all the segments and compute the LOCAL boundary
    // coordinates
    for (unsigned is = 0; is < nsegments; is++)
    {
#ifdef PARANOID
      if (segment_sorted_ele_pt[is].size() == 0)
      {
        std::ostringstream error_message;
        error_message << "The (" << is << ")-th segment has no elements\n";
        throw OomphLibError(
          error_message.str(),
          "TriangleMesh::re_assign_initial_zeta_values_for_internal_boundary()",
          OOMPH_EXCEPTION_LOCATION);
      } // if (segment_sorted_ele_pt[is].size() == 0)
#endif

      // Get access to the first element on the segment
      FiniteElement* first_ele_pt = segment_sorted_ele_pt[is].front();

      // Number of nodes
      const unsigned nnod = first_ele_pt->nnode();

      // Get the first node of the current segment
      Node* first_node_pt = first_ele_pt->node_pt(0);
      if (is_inverted[first_ele_pt])
      {
        first_node_pt = first_ele_pt->node_pt(nnod - 1);
      }

      // Coordinates of left node
      double x_left = first_node_pt->x(0);
      double y_left = first_node_pt->x(1);

      // Initialise boundary coordinate (local boundary coordinate for
      // boundaries with more than one segment)
      Vector<double> zeta(1, 0.0);

      // If we have associated a GeomObject then it is not necessary
      // to compute the arclength, only read the values from the nodes at
      // the edges
      if (this->boundary_geom_object_pt(b) != 0)
      {
        first_node_pt->get_coordinates_on_boundary(b, zeta);
        initial_zeta_segment[is] = zeta[0];

        // Get access to the last element on the segment
        FiniteElement* last_ele_pt = segment_sorted_ele_pt[is].back();

        // Get the last node of the current segment
        Node* last_node_pt = last_ele_pt->node_pt(nnod - 1);
        if (is_inverted[last_ele_pt])
        {
          last_node_pt = last_ele_pt->node_pt(0);
        }

        last_node_pt->get_coordinates_on_boundary(b, zeta);
        final_zeta_segment[is] = zeta[0];
      }

      // Sort the nodes in the segment (lexicographically bottom left
      // node)
      std::set<Node*> local_nodes_pt;
      local_nodes_pt.insert(first_node_pt);

      // Associate and arclength to the sorted nodes
      Vector<double> sorted_node_arclength;
      sorted_node_arclength.push_back(0.0);

      // Sorts the nodes in the segments according their sorting in the
      // face elements
      Vector<Node*> sorted_nodes_pt;
      sorted_nodes_pt.push_back(first_node_pt);

      // Now loop over nodes in order
      for (std::list<FiniteElement*>::iterator it =
             segment_sorted_ele_pt[is].begin();
           it != segment_sorted_ele_pt[is].end();
           it++)
      {
        // Get the face element
        FiniteElement* el_pt = *it;

        // Start node and increment
        unsigned k_nod = 1;
        int nod_diff = 1;
        if (is_inverted[el_pt])
        {
          k_nod = nnod - 2;
          nod_diff = -1;
        }

        // Loop over nodes
        for (unsigned j = 1; j < nnod; j++)
        {
          Node* nod_pt = el_pt->node_pt(k_nod);
          k_nod += nod_diff;

          // Coordinates of right node
          double x_right = nod_pt->x(0);
          double y_right = nod_pt->x(1);

          // Increment boundary coordinate
          zeta[0] += sqrt((x_right - x_left) * (x_right - x_left) +
                          (y_right - y_left) * (y_right - y_left));

          // When we have a GeomObject associated to the boundary we already
          // know the zeta values for the nodes, there is no need to compute
          // the arclength
          if (this->boundary_geom_object_pt(b) == 0)
          {
            // Set boundary coordinate
            //           nod_pt->set_coordinates_on_boundary(b, zeta);
          }

          // Increment reference coordinate
          x_left = x_right;
          y_left = y_right;

          // Get lexicographically bottom left node but only
          // use vertex nodes as candidates
          local_nodes_pt.insert(nod_pt);

          // Associate the arclength for the current node
          sorted_node_arclength.push_back(zeta[0]);

          // Store the node in the sorted nodes storage
          sorted_nodes_pt.push_back(nod_pt);

        } // for (j < nnod)

      } // iterator over the elements in the segment

      // Info. to be passed to the other processors
      // The initial arclength for the segment that goes after this depends
      // on the current segment arclength
      segment_arclength[is] = zeta[0];

      // Info. to be passed to the other processors
      // The initial vertex number for the segment that goes after this
      // depends on the current sement vertices number
      nvertices_per_segment[is] = local_nodes_pt.size();

      // Add the nodes for the corresponding segment in the container
      segment_all_nodes_pt[is] = local_nodes_pt;

      // Add the arclengths to the nodes in the segment
      sorted_segment_node_arclength[is] = sorted_node_arclength;

      // Add the sorted nodes to the storage
      sorted_segment_all_nodes_pt[is] = sorted_nodes_pt;

      // The attaching of the halo elements at both sides of the segments is
      // performed only if segments connectivity needs to be computed

    } // for (is < nsegments)

    // ------------------------------------------------------------------
    // Fourth: Now we have the segments sorted, with arclength and with
    // LOCAL boundary coordinates assigned to the nodes. Identify the
    // nodes on the segments with the input segments and re-assign all
    // the info. related with the identification of segments
    // ------------------------------------------------------------------

    // Get the number of segments for the old sorted segments
    const unsigned old_nsegments = old_segment_sorted_ele_pt.size();

    // ------------------------------------------------------------------
    // Copy the old info. in temporary storages
    Vector<unsigned> old_boundary_segment_inverted(old_nsegments);

    Vector<Vector<double>> old_boundary_segment_initial_coordinate(
      old_nsegments);
    Vector<Vector<double>> old_boundary_segment_final_coordinate(old_nsegments);

    Vector<double> old_boundary_segment_initial_zeta(old_nsegments);
    Vector<double> old_boundary_segment_final_zeta(old_nsegments);

    Vector<double> old_boundary_segment_initial_arclength(old_nsegments);
    Vector<double> old_boundary_segment_final_arclength(old_nsegments);

    // Back-up the information
    for (unsigned old_is = 0; old_is < old_nsegments; old_is++)
    {
      old_boundary_segment_inverted[old_is] =
        boundary_segment_inverted(b)[old_is];

      old_boundary_segment_initial_coordinate[old_is].resize(2);
      old_boundary_segment_final_coordinate[old_is].resize(2);
      for (unsigned i = 0; i < 2; i++)
      {
        old_boundary_segment_initial_coordinate[old_is][i] =
          boundary_segment_initial_coordinate(b)[old_is][i];

        old_boundary_segment_final_coordinate[old_is][i] =
          boundary_segment_final_coordinate(b)[old_is][i];
      }

      // Check if the boundary has an associated GeomObject
      if (this->boundary_geom_object_pt(b) != 0)
      {
        old_boundary_segment_initial_zeta[old_is] =
          boundary_segment_initial_zeta(b)[old_is];

        old_boundary_segment_final_zeta[old_is] =
          boundary_segment_final_zeta(b)[old_is];

      } // if (this->boundary_geom_object_pt(b)!=0)
      else
      {
        old_boundary_segment_initial_arclength[old_is] =
          boundary_segment_initial_arclength(b)[old_is];

        old_boundary_segment_final_arclength[old_is] =
          boundary_segment_final_arclength(b)[old_is];

      } // else if (this->boundary_geom_object_pt(b)!=0)

    } // for (old_is < old_nsegments)

    // ------------------------------------------------------------------
    // Now clear the original storages
    Boundary_segment_inverted[b].clear();
    Boundary_segment_initial_coordinate[b].clear();
    Boundary_segment_final_coordinate[b].clear();

    Boundary_segment_initial_zeta[b].clear();
    Boundary_segment_final_zeta[b].clear();

    Boundary_segment_initial_arclength[b].clear();
    Boundary_segment_final_arclength[b].clear();
    // ------------------------------------------------------------------
    // .. and resize the storages for the new number of segments
    Boundary_segment_inverted[b].resize(nsegments);
    Boundary_segment_initial_coordinate[b].resize(nsegments);
    Boundary_segment_final_coordinate[b].resize(nsegments);

    // Check if the boundary has an associated GeomObject
    if (this->boundary_geom_object_pt(b) != 0)
    {
      Boundary_segment_initial_zeta[b].resize(nsegments);
      Boundary_segment_final_zeta[b].resize(nsegments);
    }
    else
    {
      Boundary_segment_initial_arclength[b].resize(nsegments);
      Boundary_segment_final_arclength[b].resize(nsegments);
    }
    // ------------------------------------------------------------------
    // map to know if the new segment has been re-assigned the info.
    std::map<unsigned, bool> done_segment;

    // Count the number of re-assigned segments with the new values
    unsigned re_assigned_segments = 0;

    // Go through all the old segments (the input segments)
    for (unsigned old_is = 0; old_is < old_nsegments; old_is++)
    {
      // Get the first and last zeta values for the current segment
      const double old_initial_arclength =
        old_boundary_segment_initial_arclength[old_is];
      const double old_final_arclength =
        old_boundary_segment_final_arclength[old_is];
      // Get the "is inverted" segment information
      const unsigned old_inverted_segment =
        old_boundary_segment_inverted[old_is];

      // Check if the boundary coordinates in the segment go in
      // increasing or decreasing order
      bool old_increasing_order = false;
      if (old_initial_arclength < old_final_arclength)
      {
        old_increasing_order = true;
      }

      // Now get the first and last node of the current segment
      // Get the first element
      FiniteElement* first_old_seg_ele_pt =
        old_segment_sorted_ele_pt[old_is].front();

      // Number of nodes
      const unsigned nnod = first_old_seg_ele_pt->nnode();

      // Get the first node of the current segment
      Node* first_old_seg_node_pt = first_old_seg_ele_pt->node_pt(0);
      if (old_is_inverted[first_old_seg_ele_pt])
      {
        first_old_seg_node_pt = first_old_seg_ele_pt->node_pt(nnod - 1);
      }

      // Get access to the last element on the segment
      FiniteElement* last_old_seg_ele_pt =
        old_segment_sorted_ele_pt[old_is].back();

      // Get the last node of the current segment
      Node* last_old_seg_node_pt = last_old_seg_ele_pt->node_pt(nnod - 1);
      if (old_is_inverted[last_old_seg_ele_pt])
      {
        last_old_seg_node_pt = last_old_seg_ele_pt->node_pt(0);
      }
      // Check if the segment is inverted, if that is the case then
      // also invert the nodes
      if (old_inverted_segment)
      {
        Node* temp_node_pt = first_old_seg_node_pt;
        first_old_seg_node_pt = last_old_seg_node_pt;
        last_old_seg_node_pt = temp_node_pt;
      }

      // We have the first and last node of the old segment (input
      // segment), now identify in which segment, of those with only
      // nonhalo face elements, they are
      for (unsigned is = 0; is < nsegments; is++)
      {
        if (!done_segment[is])
        {
          // Go through the nodes of the current segment and try to find
          // the old nodes
          bool found_first_old_seg_node = false;
          bool found_last_old_seg_node = false;
          bool same_order = false;

          // Get the first node of the current segment
          FiniteElement* first_seg_ele_pt = segment_sorted_ele_pt[is].front();
          Node* first_seg_node_pt = first_seg_ele_pt->node_pt(0);
          if (is_inverted[first_seg_ele_pt])
          {
            first_seg_node_pt = first_seg_ele_pt->node_pt(nnod - 1);
          }

          // Get the arclength for the first node
          const double segment_first_node_zeta =
            sorted_segment_node_arclength[is][0];

          // Get the node coordinates for the first node
          Vector<double> first_node_coord(2);
          for (unsigned i = 0; i < 2; i++)
          {
            first_node_coord[i] = first_seg_node_pt->x(i);
          }

          // Get the last node of the current segment
          FiniteElement* last_seg_ele_pt = segment_sorted_ele_pt[is].back();
          Node* last_seg_node_pt = last_seg_ele_pt->node_pt(nnod - 1);
          if (is_inverted[last_seg_ele_pt])
          {
            last_seg_node_pt = last_seg_ele_pt->node_pt(0);
          }

          // Get the arclength for the last node
          const double segment_final_node_zeta = segment_arclength[is];

          // Get the node coordinates for the last node
          Vector<double> last_node_coord(2);
          for (unsigned i = 0; i < 2; i++)
          {
            last_node_coord[i] = last_seg_node_pt->x(i);
          }

          // Temporary storage for the nodes of the current segment
          Vector<Node*> segment_node_pt = sorted_segment_all_nodes_pt[is];
          // Get the number of nodes in the segment
          const unsigned nsegment_node = segment_node_pt.size();
          for (unsigned in = 0; in < nsegment_node; in++)
          {
            Node* current_node_pt = segment_node_pt[in];
            if (!found_first_old_seg_node &&
                first_old_seg_node_pt == current_node_pt)
            {
              // Get the arclength assigned to the node on the old
              // segment
              const double current_node_zeta =
                sorted_segment_node_arclength[is][in];

              // Now check if the new segment has the same orientation
              // as the old one
              if (!found_last_old_seg_node) // has the same orientation
              {
                // Re-assign the first node coordinates
                Boundary_segment_initial_coordinate[b][is] = first_node_coord;

                // Check if the boundary has an associated GeomObject
                if (this->boundary_geom_object_pt(b) != 0)
                {
                  // Assign the zeta values if the current segment has the
                  // nodes of the old one

                  // If we are in the same order then pass the values as
                  // they are
                  Boundary_segment_initial_zeta[b][is] =
                    initial_zeta_segment[is];

                } // if (this->boundary_geom_object_pt(b)!=0)
                else
                {
                  // Get the distance to the first node
                  const double distance =
                    std::fabs(current_node_zeta - segment_first_node_zeta);

                  double new_initial_arclength = old_initial_arclength;

                  // Now check if the zeta values are in increasing order
                  if (old_increasing_order)
                  {
                    // Substract the distance
                    new_initial_arclength -= distance;
                  }
                  else
                  {
                    // Add the distance
                    new_initial_arclength += distance;
                  }

                  // Re-assign the initial arclength for the current segment
                  Boundary_segment_initial_arclength[b][is] =
                    new_initial_arclength;

                } // else if (this->boundary_geom_object_pt(b)!=0)
              } // if (!found_last_old_seg_node)
              else // has different orientation
              {
                // Re-assign the first node coordinates
                Boundary_segment_initial_coordinate[b][is] = last_node_coord;

                // Check if the boundary has an associated GeomObject
                if (this->boundary_geom_object_pt(b) != 0)
                {
                  // Assign the zeta values if the current segment has the
                  // nodes of the old one

                  // Not the same order, we need to copy the zeta values
                  // from the other end, the inverted flag is changed at
                  // the end. Copy the value from the final end
                  Boundary_segment_initial_zeta[b][is] = final_zeta_segment[is];

                } // if (this->boundary_geom_object_pt(b)!=0)
                else
                {
                  // Get the distance to the final node
                  const double distance =
                    std::fabs(current_node_zeta - segment_final_node_zeta);

                  double new_initial_arclength = old_initial_arclength;

                  // Now check if the zeta values are in increasing order
                  if (old_increasing_order)
                  {
                    // Substract the distance
                    new_initial_arclength -= distance;
                  }
                  else
                  {
                    // Add the distance
                    new_initial_arclength += distance;
                  }

                  // Re-assign the initial arclength for the current segment
                  Boundary_segment_initial_arclength[b][is] =
                    new_initial_arclength;

                } // else if (this->boundary_geom_object_pt(b)!=0)
              } // else if (!found_last_old_seg_node)

              // Mark as found the first node
              found_first_old_seg_node = true;
            }
            // if (!found_first_old_seg_node &&
            //     first_old_seg_node_pt == current_node_pt)

            // If we found first the first node then the segments have
            // the same order
            if (found_first_old_seg_node && !found_last_old_seg_node)
            {
              same_order = true;
            }

            if (!found_last_old_seg_node &&
                last_old_seg_node_pt == current_node_pt)
            {
              // Get the boundary coordinates assigned to the node on
              // the old segment
              const double current_node_zeta =
                sorted_segment_node_arclength[is][in];

              // Now check if the new segment has the same orientation
              // as the old one
              if (found_first_old_seg_node) // has the same orientation
              {
                // Re-assign the last node coordinates
                Boundary_segment_final_coordinate[b][is] = last_node_coord;

                // Check if the boundary has an associated GeomObject
                if (this->boundary_geom_object_pt(b) != 0)
                {
                  // Assign the zeta values if the current segment has the
                  // nodes of the old one

                  // If we are in the same order then pass the values as
                  // they are
                  Boundary_segment_final_zeta[b][is] = final_zeta_segment[is];

                } // if (this->boundary_geom_object_pt(b)!=0)
                else
                {
                  // Get the distance to the last node
                  const double distance =
                    std::fabs(current_node_zeta - segment_final_node_zeta);

                  double new_final_arclength = old_final_arclength;

                  // Now check if the zeta values are in increasing order
                  if (old_increasing_order)
                  {
                    // Add the distance
                    new_final_arclength += distance;
                  }
                  else
                  {
                    // Substract the distance
                    new_final_arclength -= distance;
                  }

                  // Re-assign the final arclength for the current segment
                  Boundary_segment_final_arclength[b][is] = new_final_arclength;

                } // else if (this->boundary_geom_object_pt(b)!=0)
              } // if (found_first_old_seg_node)
              else
              {
                // Re-assign the last node coordinates
                Boundary_segment_final_coordinate[b][is] = first_node_coord;

                // Check if the boundary has an associated GeomObject
                if (this->boundary_geom_object_pt(b) != 0)
                {
                  // Assign the zeta values if the current segment has the
                  // nodes of the old one

                  // Not the same order, we need to copy the zeta values
                  // from the other end, the inverted flag is changed at
                  // the end. Copy the value from the initial end
                  Boundary_segment_final_zeta[b][is] = initial_zeta_segment[is];

                } // if (this->boundary_geom_object_pt(b)!=0)
                else
                {
                  // Get the distance to the last node
                  const double distance =
                    std::fabs(current_node_zeta - segment_first_node_zeta);

                  double new_final_arclength = old_final_arclength;

                  // Now check if the zeta values are in increasing order
                  if (old_increasing_order)
                  {
                    // Add the distance
                    new_final_arclength += distance;
                  }
                  else
                  {
                    // Substract the distance
                    new_final_arclength -= distance;
                  }

                  // Re-assign the final arclength for the current segment
                  Boundary_segment_final_arclength[b][is] = new_final_arclength;

                } // else if (this->boundary_geom_object_pt(b)!=0)
              } // if (found_first_old_seg_node)

              // Mark as found the last node
              found_last_old_seg_node = true;

            } // if (!found_last_old_seg_node &&
              //     last_old_seg_node_pt == current_node_pt)

            // If we found the last node first then the segments have
            // not the same order
            if (!found_first_old_seg_node && found_last_old_seg_node)
            {
              same_order = false;
            }

            if (found_first_old_seg_node && found_last_old_seg_node)
            {
              // Check if necessary to change the information that
              // states if a segment is inverted or not
              if (same_order)
              {
                Boundary_segment_inverted[b][is] = old_inverted_segment;
              }
              else
              {
                Boundary_segment_inverted[b][is] = !old_inverted_segment;
              }

              // Mark the segment as done
              done_segment[is] = true;

              // Increase the number of re-assigned segments
              re_assigned_segments++;

              // Break the for that look for the nodes in the segments
              break;
            }

          } // for (in < nsegment_node)

#ifdef PARANOID
          if ((found_first_old_seg_node && !found_last_old_seg_node) ||
              (!found_first_old_seg_node && found_last_old_seg_node))
          {
            std::stringstream error_message;
            error_message
              << "Working with boundary (" << b << ").\nOnly the first node or "
              << "the last node of the old segment (" << old_is << ") was\n"
              << "found. Both, first and last node should have been found in "
              << "the same segment!!!.\n"
              << "Found first seg node:" << found_first_old_seg_node << "\n"
              << "Found last seg node:" << found_last_old_seg_node << "\n\n";
            throw OomphLibError(error_message.str(),
                                "TriangleMesh::re_assign_initial_zeta_values_"
                                "for_internal_boundary()",
                                OOMPH_EXCEPTION_LOCATION);
          }
#endif

        } // if (!done_segment[is])
      } // for (is < nsegments)
    } // for (old_is < old_nsegments)

    // For those segments not identified set dummy values, the boundary
    // coordinates should be corrected at the synchronisation stage

    // loop over the new segments and check if there not identified
    // segments
    for (unsigned is = 0; is < nsegments; is++)
    {
      // Was the segment identified
      if (!done_segment[is])
      {
        // Get the first node of the current segment
        FiniteElement* first_seg_ele_pt = segment_sorted_ele_pt[is].front();
        // Number of nodes
        const unsigned nnod = first_seg_ele_pt->nnode();

        Node* first_seg_node_pt = first_seg_ele_pt->node_pt(0);
        if (is_inverted[first_seg_ele_pt])
        {
          first_seg_node_pt = first_seg_ele_pt->node_pt(nnod - 1);
        }

        // Get the arclength for the first node
        const double segment_first_node_zeta =
          sorted_segment_node_arclength[is][0];

        // Get the node coordinates for the first node
        Vector<double> first_node_coord(2);
        for (unsigned i = 0; i < 2; i++)
        {
          first_node_coord[i] = first_seg_node_pt->x(i);
        }

        // Get the last node of the current segment
        FiniteElement* last_seg_ele_pt = segment_sorted_ele_pt[is].back();
        Node* last_seg_node_pt = last_seg_ele_pt->node_pt(nnod - 1);
        if (is_inverted[last_seg_ele_pt])
        {
          last_seg_node_pt = last_seg_ele_pt->node_pt(0);
        }

        // Get the arclength for the last node
        const double segment_final_node_zeta = segment_arclength[is];

        // Get the node coordinates for the last node
        Vector<double> last_node_coord(2);
        for (unsigned i = 0; i < 2; i++)
        {
          last_node_coord[i] = last_seg_node_pt->x(i);
        }

        // Re-assign the initial node coordinates
        Boundary_segment_initial_coordinate[b][is] = first_node_coord;

        // Check if the boundary has an associated GeomObject
        if (this->boundary_geom_object_pt(b) != 0)
        {
          // Assign the zeta values if the current segment has the
          // nodes of the old one

          // If we are in the same order then pass the values as
          // they are
          Boundary_segment_initial_zeta[b][is] = initial_zeta_segment[is];

        } // if (this->boundary_geom_object_pt(b)!=0)
        else
        {
          // Re-assign the initial arclength for the current segment
          Boundary_segment_initial_arclength[b][is] = segment_first_node_zeta;

        } // else if (this->boundary_geom_object_pt(b)!=0)

        // Re-assign the initial node coordinates
        Boundary_segment_final_coordinate[b][is] = last_node_coord;

        // Check if the boundary has an associated GeomObject
        if (this->boundary_geom_object_pt(b) != 0)
        {
          // Assign the zeta values if the current segment has the
          // nodes of the old one

          // If we are in the same order then pass the values as
          // they are
          Boundary_segment_final_zeta[b][is] = final_zeta_segment[is];

        } // if (this->boundary_geom_object_pt(b)!=0)
        else
        {
          // Re-assign the final arclength for the current segment
          Boundary_segment_final_arclength[b][is] = segment_final_node_zeta;

        } // else if (this->boundary_geom_object_pt(b)!=0)

        Boundary_segment_inverted[b][is] = 0;

        // Mark the segment as done
        done_segment[is] = true;

        // Increase the number of re-assigned segments
        re_assigned_segments++;

      } // if (!done_segment[is])

    } // for (is < nsegments)

#ifdef PARANOID
    // Compare the number of new segments identified with the old segments
    if (re_assigned_segments != nsegments)
    {
      std::stringstream error_message;
      error_message << "Working with boundary (" << b
                    << ").\nThe number of re-assigned "
                    << "segments (" << re_assigned_segments
                    << ") is different from the number\nof segments ("
                    << nsegments << ")\n\n";
      throw OomphLibError(
        error_message.str(),
        "TriangleMesh::re_assign_initial_zeta_values_for_internal_boundary()",
        OOMPH_EXCEPTION_LOCATION);
    } // if (re_assigned_segments != nsegments)
#endif

    // Clean all the created face elements
    for (unsigned i = 0; i < nele; i++)
    {
      delete face_el_pt[i];
      face_el_pt[i] = 0;
    }
  }

  /// =====================================================================
  /// Select face elements from a given boundary. In case the we are
  /// dealing with an internal boundary we use a set of criterias to
  /// decide which of the two face elements should be used on represent
  /// the internal boundary. We return the face elements, halo or
  /// haloed on this processor that form the boundary. The caller method
  /// should be in charge of selecting nonhalo elements and deleting the face
  /// elements created by this method
  /// =====================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::select_boundary_face_elements(
    Vector<FiniteElement*>& face_ele_pt,
    const unsigned& b,
    bool& is_internal_boundary,
    std::map<FiniteElement*, FiniteElement*>& face_to_bulk_element_pt)
  {
    // Get the communicator of the mesh
    OomphCommunicator* comm_pt = this->communicator_pt();

    const unsigned my_rank = comm_pt->my_rank();

    // ------------------------------------------------------------------
    // 1) Get the face elements associated with the current boundary
    // ------------------------------------------------------------------

    // Temporary storage for face elements (do not take care of
    // repeated face elements)
    Vector<FiniteElement*> tmp_face_ele_pt;

    const unsigned nregions = this->nregion();

    // If there is more than one region then only use boundary
    // coordinates from the bulk side (region 0)
    if (nregions > 1)
    {
      for (unsigned ir = 0; ir < nregions; ir++)
      {
        const unsigned region_id =
          static_cast<unsigned>(this->Region_attribute[ir]);

        // Loop over all elements on boundaries in region -ir-
        const unsigned nele_in_region =
          this->nboundary_element_in_region(b, region_id);

        // Only bother to do anything else, if there are elements
        // associated with the boundary and the current region
        if (nele_in_region > 0)
        {
          // Loop over the bulk elements adjacent to boundary b
          for (unsigned e = 0; e < nele_in_region; e++)
          {
            // Get pointer to the bulk element that is adjacent
            // to boundary b
            FiniteElement* bulk_ele_pt =
              this->boundary_element_in_region_pt(b, region_id, e);

            // Get the index of the face of element e along
            // boundary b
            int face_index =
              this->face_index_at_boundary_in_region(b, region_id, e);

            // Create the face element
            FiniteElement* tmp_face_el_pt =
              new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);

            // Associated the face element with the bulk
            face_to_bulk_element_pt[tmp_face_el_pt] = bulk_ele_pt;

            // ... and add it to the tmp storage for all the
            // face elements, do not take care for repeated
            // ones (at the moment)
            tmp_face_ele_pt.push_back(tmp_face_el_pt);

          } // for (e < nele_in_region)

        } // if (nele_in_region > 0)

      } // for (ir < n_regions)

    } // if (n_regions > 1)

    // Otherwise it's just the normal boundary functions
    else
    {
      // Loop over all elements on boundaries
      const unsigned nbound_ele = this->nboundary_element(b);

      // Only bother to do anything else, if there are elements
      if (nbound_ele > 0)
      {
        // Loop over the bulk elements adjacent to boundary b
        for (unsigned e = 0; e < nbound_ele; e++)
        {
          // Get pointer to the bulk element that is adjacent to
          // boundary b
          FiniteElement* bulk_ele_pt = this->boundary_element_pt(b, e);

          // Get the index of the face of element e along
          // boundary b
          int face_index = this->face_index_at_boundary(b, e);

          // Create the face element
          FiniteElement* tmp_face_el_pt =
            new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);

          // Associated the face element with the bulk
          face_to_bulk_element_pt[tmp_face_el_pt] = bulk_ele_pt;

          // ... and add it to the tmp storage for all the face
          // elements, do not care for repeated ones (at the
          // moment)
          tmp_face_ele_pt.push_back(tmp_face_el_pt);

        } // (e < nbound_ele)

      } // (nbound_ele > 0)

    } // else (n_regions > 1)

    // map to know which face element has been already done
    std::map<FiniteElement*, bool> done_face;

    // Set the flag to indicate if we are working with an internal
    // boundary
    is_internal_boundary = false;

    // Free the memory of the elements in this container (only used
    // when working with internal boundaries)
    Vector<FiniteElement*> free_memory_face_ele_pt;

    // Get the number of face elements in the boundary (including
    // repeated)
    const unsigned n_tmp_face_ele = tmp_face_ele_pt.size();
    for (unsigned ie = 0; ie < n_tmp_face_ele; ie++)
    {
      // Get the possible main element
      FiniteElement* main_face_ele_pt = tmp_face_ele_pt[ie];
      if (!done_face[main_face_ele_pt])
      {
        // Mark the face element as done
        done_face[main_face_ele_pt] = true;
        // Get the number of nodes for the face element
        const unsigned nnodes = main_face_ele_pt->nnode();
        // Get the first and last node of the main face element
        Node* main_first_node_pt = main_face_ele_pt->node_pt(0);
        Node* main_last_node_pt = main_face_ele_pt->node_pt(nnodes - 1);
        // Look for the other side face element (we can start from
        // the next one, all previous face elements have been
        // already identified with its other side face)
        for (unsigned iie = ie + 1; iie < n_tmp_face_ele; iie++)
        {
          // Get the possible dependant element
          FiniteElement* dependant_face_ele_pt = tmp_face_ele_pt[iie];
          if (!done_face[dependant_face_ele_pt])
          {
            // Get the first and last node of the dependant
            // face element
            Node* dependant_first_node_pt = dependant_face_ele_pt->node_pt(0);
            Node* dependant_last_node_pt =
              dependant_face_ele_pt->node_pt(nnodes - 1);
            // Check if the nodes at the ends of both face
            // elements match (also check the reversed case)
            if (((dependant_first_node_pt == main_first_node_pt) &&
                 (dependant_last_node_pt == main_last_node_pt)) ||
                ((dependant_first_node_pt == main_last_node_pt) &&
                 (dependant_last_node_pt == main_first_node_pt)))
            {
              // Set the flag to indicate we are working with an
              // internal boundary
              is_internal_boundary = true;
              // Mark the face element as done
              done_face[dependant_face_ele_pt] = true;

              // Now choose which face element will be used
              // as the main element. We get the processor in
              // charge of the element and choose the one
              // with the highest processor in charge or the
              // bottom-left bulk element in case the both
              // faces are on the same processor

              // Get the bulk element for each face element
              // (the main and the dependant face element)
              FiniteElement* main_bulk_ele_pt =
                face_to_bulk_element_pt[main_face_ele_pt];
              FiniteElement* dependant_bulk_ele_pt =
                face_to_bulk_element_pt[dependant_face_ele_pt];

              // Get the processor in charge for each bulk
              // element
              int processor_in_charge_main_bulk_ele =
                main_bulk_ele_pt->non_halo_proc_ID();
              int processor_in_charge_dependant_bulk_ele =
                dependant_bulk_ele_pt->non_halo_proc_ID();

              // If the processor in charge is negative the
              // element is not halo, therefore the processor
              // in charge is the current one
              if (processor_in_charge_main_bulk_ele < 0)
              {
                processor_in_charge_main_bulk_ele = static_cast<int>(my_rank);
              }
              if (processor_in_charge_dependant_bulk_ele < 0)
              {
                processor_in_charge_dependant_bulk_ele =
                  static_cast<int>(my_rank);
              }

              // Flag to know if add the main or dependant
              // face element
              bool add_main_face_element = true;
              if (processor_in_charge_dependant_bulk_ele >
                  processor_in_charge_main_bulk_ele)
              {
                // Include the dependant element
                add_main_face_element = false;
              }
              else if (processor_in_charge_main_bulk_ele ==
                       processor_in_charge_dependant_bulk_ele)
              {
                // When the processor in charge for both
                // elements is the same then use the
                // bottom-left criteria on the bulk
                // elements to choose the main face element
                Vector<double> main_ele_coordinates(2);
                Vector<double> dependant_ele_coordinates(2);
                // Get the number of nodes on the bulk
                // elements
                const unsigned n_bulk_nodes = main_bulk_ele_pt->nnode();
                for (unsigned inode = 0; inode < n_bulk_nodes; inode++)
                {
                  for (unsigned idim = 0; idim < 2; idim++)
                  {
                    main_ele_coordinates[idim] +=
                      main_bulk_ele_pt->node_pt(inode)->x(idim);
                    dependant_ele_coordinates[idim] +=
                      dependant_bulk_ele_pt->node_pt(inode)->x(idim);
                  } // (idim < 2)

                } // (inode < n_bulk_nodes)

                // Get the average of the nodes coordinates
                for (unsigned idim = 0; idim < 2; idim++)
                {
                  main_ele_coordinates[idim] /= (double)n_bulk_nodes;
                  dependant_ele_coordinates[idim] /= (double)n_bulk_nodes;
                }

                // Once we know the average coordinates for
                // each element then we choose the one with
                // the bottom-left averaged coordinates
                if (dependant_ele_coordinates[1] < main_ele_coordinates[1])
                {
                  add_main_face_element = false;
                }
                else if (dependant_ele_coordinates[1] ==
                         main_ele_coordinates[1])
                {
                  // The left-most element
                  if (dependant_ele_coordinates[0] < main_ele_coordinates[0])
                  {
                    add_main_face_element = false;
                  }
                }
              } // else -- The processor in charge is the
                // same for both elements

              if (add_main_face_element)
              {
                // Add the main face element to the storage
                // so we get the halo and haloed nodes from
                // it
                face_ele_pt.push_back(main_face_ele_pt);
                // Mark the dependat face element to free
                // its memory
                free_memory_face_ele_pt.push_back(dependant_face_ele_pt);
              }
              else
              {
                // Add the dependant face element to the
                // storage so we get the halo and haloed
                // nodes from it
                face_ele_pt.push_back(dependant_face_ele_pt);
                // Mark the main face element to free its
                // memory
                free_memory_face_ele_pt.push_back(main_face_ele_pt);
              }

              // Break the for to look for the next face
              // element
              break;

            } // if -- matching of nodes from main ele and
              // dependant ele

          } // if (!done_face[dependant_face_ele_pt])

        } // for (iie < n_tmp_face_ele)

      } // if (!done_face[main_face_ele_pt])

    } // for (ie < n_tmp_face_ele)

    // Are there any face element to free its memory
    const unsigned n_free_face_ele = free_memory_face_ele_pt.size();
    if (n_free_face_ele == 0)
    {
      // If there is not face elements to free memory that means that
      // we are not working with an internal boundary, therefore copy
      // all the element from the tmp face elements into the face
      // elements container

      // Resize the container
      face_ele_pt.resize(n_tmp_face_ele);
      // loop over the elements and copy them
      for (unsigned i = 0; i < n_tmp_face_ele; i++)
      {
        face_ele_pt[i] = tmp_face_ele_pt[i];
      } // for (i < n_tmp_face_ele)

    } // if (n_free_face_ele == 0)
    else
    {
      // ... otherwise free the memory of the indicated elements
      // loop over the elements to free its memory
      for (unsigned i = 0; i < n_free_face_ele; i++)
      {
        delete free_memory_face_ele_pt[i];
        free_memory_face_ele_pt[i] = 0;
      } // for (i < n_free_face_ele)
    }
  }

  /// ========================================================================
  /// In charge of sinchronize the boundary coordinates for internal
  /// boundaries that were split as part of the distribution
  /// process. Called after setup_boundary_coordinates() for the
  /// original mesh only
  /// ========================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::synchronize_boundary_coordinates(
    const unsigned& b)
  {
    // ------------------------------------------------------------------
    // First: Get the face elements associated with the current boundary
    // ------------------------------------------------------------------

    // Get the communicator of the mesh
    OomphCommunicator* comm_pt = this->communicator_pt();

    const unsigned nproc = comm_pt->nproc();
    const unsigned my_rank = comm_pt->my_rank();

    // Temporary storage for face elements (do not take care of repeated
    // face elements)
    Vector<FiniteElement*> tmp_face_ele_pt;

    const unsigned nregions = this->nregion();

    // map to associate the face element to the bulk element, necessary
    // to get the processor in charge for the halo elements
    std::map<FiniteElement*, FiniteElement*> face_to_bulk_element_pt;

    // If there is more than one region then only use boundary
    // coordinates from the bulk side (region 0)
    if (nregions > 1)
    {
      for (unsigned ir = 0; ir < nregions; ir++)
      {
        const unsigned region_id =
          static_cast<unsigned>(this->Region_attribute[ir]);

        // Loop over all elements on boundaries in region -ir-
        const unsigned nele_in_region =
          this->nboundary_element_in_region(b, region_id);

        // Only bother to do anything else, if there are elements
        // associated with the boundary and the current region
        if (nele_in_region > 0)
        {
          // Loop over the bulk elements adjacent to boundary b
          for (unsigned e = 0; e < nele_in_region; e++)
          {
            // Get pointer to the bulk element that is adjacent to boundary b
            FiniteElement* bulk_ele_pt =
              this->boundary_element_in_region_pt(b, region_id, e);

            // Get the index of the face of element e along boundary b
            int face_index =
              this->face_index_at_boundary_in_region(b, region_id, e);

            // Create the face element
            FiniteElement* tmp_face_el_pt =
              new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);

            // ... and add it to the tmp storage for all the face
            // elements, do not take care for repeated ones (at the
            // moment)
            tmp_face_ele_pt.push_back(tmp_face_el_pt);
            // Create the map to know if the element is halo
            face_to_bulk_element_pt[tmp_face_el_pt] = bulk_ele_pt;

          } // for (e < nele_in_region)

        } // if (nele_in_region > 0)

      } // for (ir < n_regions)

    } // if (n_regions > 1)

    // Otherwise it's just the normal boundary functions
    else
    {
      // Loop over all elements on boundaries
      const unsigned nbound_ele = this->nboundary_element(b);

      // Only bother to do anything else, if there are elements
      if (nbound_ele > 0)
      {
        // Loop over the bulk elements adjacent to boundary b
        for (unsigned e = 0; e < nbound_ele; e++)
        {
          // Get pointer to the bulk element that is adjacent to boundary b
          FiniteElement* bulk_ele_pt = this->boundary_element_pt(b, e);

          // Get the index of the face of element e along boundary b
          int face_index = this->face_index_at_boundary(b, e);

          // Create the face element
          FiniteElement* tmp_face_el_pt =
            new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);

          // ... and add it to the tmp storage for all the face
          // elements, do not care for repeated ones (at the moment)
          tmp_face_ele_pt.push_back(tmp_face_el_pt);
          // Create the map to know if the element is halo
          face_to_bulk_element_pt[tmp_face_el_pt] = bulk_ele_pt;

        } // (e < nbound_ele)

      } // (nbound_ele > 0)

    } // else (n_regions > 1)

    // Temporary storage for one side face elements. In case we are
    // working with an internal boundary here we store only one of the
    // face elements that are at each side of the boundary
    Vector<FiniteElement*> face_ele_pt;

    // map to know which face element has been already done
    std::map<FiniteElement*, bool> done_face;

    // Flag to indicate if we are working with an internal boundary
    bool is_internal_boundary = false;

#ifdef PARANOID
    // Flag to indicate if we are working with an internal boundary (paranoid)
    bool is_internal_boundary_paranoid = false;

    // Count the number of other side face elements found in case we are
    // working with an internal boundary
    unsigned nfound_face_elements = 0;
#endif

    // Get the number of face elements in the boundary
    const unsigned nbound_ele = tmp_face_ele_pt.size();
    for (unsigned ie = 0; ie < nbound_ele; ie++)
    {
      // Get the possible main element
      FiniteElement* main_face_ele_pt = tmp_face_ele_pt[ie];
      if (!done_face[main_face_ele_pt])
      {
        // Mark the face element as done
        done_face[main_face_ele_pt] = true;
        // Get the number of nodes for the face element
        const unsigned nnodes = main_face_ele_pt->nnode();
        // Get the first and last node of the main face element
        Node* main_first_node_pt = main_face_ele_pt->node_pt(0);
        Node* main_last_node_pt = main_face_ele_pt->node_pt(nnodes - 1);
        // Look for the other side face element
        for (unsigned iie = ie + 1; iie < nbound_ele; iie++)
        {
          // Get the possible dependant element
          FiniteElement* dependant_face_ele_pt = tmp_face_ele_pt[iie];
          if (!done_face[dependant_face_ele_pt])
          {
            // Get the first and last node of the dependant face element
            Node* dependant_first_node_pt = dependant_face_ele_pt->node_pt(0);
            Node* dependant_last_node_pt =
              dependant_face_ele_pt->node_pt(nnodes - 1);
            // Check if the nodes at the ends of both face elements
            // match (also check the reversed case)
            if (((dependant_first_node_pt == main_first_node_pt) &&
                 (dependant_last_node_pt == main_last_node_pt)) ||
                ((dependant_first_node_pt == main_last_node_pt) &&
                 (dependant_last_node_pt == main_first_node_pt)))
            {
#ifdef PARANOID
              // Increase the number of found face elements
              nfound_face_elements += 2;
#endif
              // Set the flag to indicate we are working with an
              // internal boundary
              is_internal_boundary = true;
              // Mark the face element as done
              done_face[dependant_face_ele_pt] = true;

              // Now choose which face element will be used as the main
              // element. Use the same criteria as the compute segments
              // connectivity method (highest processor in charge or
              // bottom-left bulk element)

              // Get the bulk element for each face element (the main
              // and the dependant face element)
              FiniteElement* main_bulk_ele_pt =
                face_to_bulk_element_pt[main_face_ele_pt];
              FiniteElement* dependant_bulk_ele_pt =
                face_to_bulk_element_pt[dependant_face_ele_pt];

              // Get the processor in charge for each bulk element
              int processor_in_charge_main_bulk_ele =
                main_bulk_ele_pt->non_halo_proc_ID();
              int processor_in_charge_dependant_bulk_ele =
                dependant_bulk_ele_pt->non_halo_proc_ID();

              // If the processor in charge is negative the element is
              // not halo, therefore the processor in charge is the
              // current one
              if (processor_in_charge_main_bulk_ele < 0)
              {
                processor_in_charge_main_bulk_ele = static_cast<int>(my_rank);
              }
              if (processor_in_charge_dependant_bulk_ele < 0)
              {
                processor_in_charge_dependant_bulk_ele =
                  static_cast<int>(my_rank);
              }

              // Flag to know if add the main or dependant face element
              bool add_main_face_element = true;
              if (processor_in_charge_dependant_bulk_ele >
                  processor_in_charge_main_bulk_ele)
              {
                // Include the dependant element
                add_main_face_element = false;
              }
              else if (processor_in_charge_main_bulk_ele ==
                       processor_in_charge_dependant_bulk_ele)
              {
                // When the processor in charge for both elements is the same
                // then use the bottom-left criteria on the bulk elements to
                // choose the main face element
                Vector<double> main_ele_coordinates(2);
                Vector<double> dependant_ele_coordinates(2);
                // Get the number of nodes on the bulk elements
                const unsigned n_bulk_nodes = main_bulk_ele_pt->nnode();
                for (unsigned inode = 0; inode < n_bulk_nodes; inode++)
                {
                  for (unsigned idim = 0; idim < 2; idim++)
                  {
                    main_ele_coordinates[idim] +=
                      main_bulk_ele_pt->node_pt(inode)->x(idim);
                    dependant_ele_coordinates[idim] +=
                      dependant_bulk_ele_pt->node_pt(inode)->x(idim);
                  } // (idim < 2)
                } // (inode < n_bulk_nodes)

                // Get the average of the nodes coordinates
                for (unsigned idim = 0; idim < 2; idim++)
                {
                  main_ele_coordinates[idim] /= (double)n_bulk_nodes;
                  dependant_ele_coordinates[idim] /= (double)n_bulk_nodes;
                }

                // Once we know the average coordinates for each element
                // then we choose the one with the bottom-left averaged
                // coordinates
                if (dependant_ele_coordinates[1] < main_ele_coordinates[1])
                {
                  add_main_face_element = false;
                }
                else if (dependant_ele_coordinates[1] ==
                         main_ele_coordinates[1])
                {
                  // The left-most element
                  if (dependant_ele_coordinates[0] < main_ele_coordinates[0])
                  {
                    add_main_face_element = false;
                  }
                }
              } // else -- The processor in charge is the same for both
                //         elements

              if (add_main_face_element)
              {
                // Add the main face element to the storage so we get
                // the halo and haloed nodes from these face element
                face_ele_pt.push_back(main_face_ele_pt);
              }
              else
              {
                // Add the main face element to the storage so we get
                // the halo and haloed nodes from these face element
                face_ele_pt.push_back(dependant_face_ele_pt);
              }

              // Break the for to look for the next face element
              break;

            } // if -- matching of nodes from main ele and dependant ele
          } // if (!done_face[dependant_face_ele_pt])
        } // for (iie < nbound_ele)
      } // if (!done_face[main_face_ele_pt])
    } // for (ie < nbound_ele)

    // Get the number of face elements
    const unsigned nface_ele = face_ele_pt.size();

#ifdef PARANOID
    // Check if we are working with an internal open curve. First check
    // if there are elements, in a distributed approach they may be no
    // elements associated to the boundary
    if (nbound_ele > 0 && nfound_face_elements == nbound_ele)
    {
      is_internal_boundary_paranoid = true;
    }

    if (nbound_ele > 0 && is_internal_boundary_paranoid &&
        nbound_ele != nface_ele * 2)
    {
      std::ostringstream error_message;
      error_message
        << "The info. to perform the synchronisation of the boundary "
        << "coordinates was not completely established\n"
        << "In this case it was the number of non repeated boundary elements\n"
        << "Number of boundary elements: (" << nbound_ele << ")\n"
        << "Number of nonrepeated boundary elements: (" << nface_ele << ")\n";
      throw OomphLibError(error_message.str(),
                          "TriangleMesh::synchronize_boundary_coordinates()",
                          OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // ----------------------------------------------------------------
    // Second: Identify the halo face elements
    // ----------------------------------------------------------------

    // A flag vector to mark those face elements that are considered as
    // halo in the current processor
    std::vector<bool> is_halo_face_element(nface_ele, false);

    // Count the total number of non halo face elements
    unsigned nnon_halo_face_elements = 0;

    for (unsigned ie = 0; ie < nface_ele; ie++)
    {
      FiniteElement* face_el_pt = face_ele_pt[ie];
      // Get the bulk element
      FiniteElement* tmp_bulk_ele_pt = face_to_bulk_element_pt[face_el_pt];
      // Check if the bulk element is halo
      if (!tmp_bulk_ele_pt->is_halo())
      {
        is_halo_face_element[ie] = false;
        nnon_halo_face_elements++;
      }
      else
      {
        // Mark the face element as halo
        is_halo_face_element[ie] = true;
      }
    } // for (ie < nface_ele)

    // -----------------------------------------------------------------
    // Third: Go through the face elements and get the nodes from the
    // elements. The boundary coordinate from each node is sent to its
    // processor in charge, then that processor will be responsible to
    // send the bound coordinate to all the processors that have a halo
    // representation of the node
    // -----------------------------------------------------------------

    // A map to know which nodes are already done
    std::map<Node*, bool> done_node;

    // The storage for the halo nodes on face elements in this processor
    // with other processors
    Vector<Vector<Node*>> face_halo_node_pt(nproc);

    // The storage for the ids of the halo nodes on face elements in
    // this processor with other processors
    Vector<Vector<unsigned>> face_halo_node_id(nproc);

    // The storage for the haloed nodes on face elements in this
    // processor with other processors
    Vector<Vector<Node*>> face_haloed_node_pt(nproc);

    // The storage for the ids of the haloed nodes on face elements in
    // this processor with other processors
    Vector<Vector<unsigned>> face_haloed_node_id(nproc);

    // A map to know which nodes are face nodes and the processor in
    // charge is the current one
    std::map<Node*, bool> done_haloed_face_node;

    // Go through all the face elements
    for (unsigned iface = 0; iface < nface_ele; iface++)
    {
      // Only work with the non halo face elements
      if (!is_halo_face_element[iface])
      {
        // Get the face element
        FiniteElement* ele_face_pt = face_ele_pt[iface];
        // The number of nodes of the face elements
        const unsigned nnodes = ele_face_pt->nnode();
        // Go through all the nodes in the face element
        for (unsigned in = 0; in < nnodes; in++)
        {
          Node* face_node_pt = ele_face_pt->node_pt(in);
          // Check if node is done
          if (!done_node[face_node_pt])
          {
            // Mark the node as done
            done_node[face_node_pt] = true;
            // First check if the node is halo
            if (face_node_pt->is_halo())
            {
              // Get the processor in charge for the current node
              int int_nonhalo_ID = face_node_pt->non_halo_proc_ID();
#ifdef PARANOID
              if (int_nonhalo_ID < 0)
              {
                std::ostringstream error_message;
                error_message
                  << "The node was marked to be halo but the processor in "
                  << "charge was found to be -1\n\n";
                throw OomphLibError(
                  error_message.str(),
                  "TriangleMesh::synchronize_boundary_coordinates()",
                  OOMPH_EXCEPTION_LOCATION);
              }
#endif
              const unsigned ip = static_cast<unsigned>(int_nonhalo_ID);
              // Add the node to the structure that holds the halo
              // nodes, the current processor will need to send the
              // info. to the processor in charge.
              face_halo_node_pt[ip].push_back(face_node_pt);
              // ... finally look for the halo id with the processor in
              // charge
#ifdef PARANOID
              bool found_halo_node = false;
#endif
              const unsigned nhalo_iproc = this->nhalo_node(ip);
              for (unsigned ihn = 0; ihn < nhalo_iproc; ihn++)
              {
                Node* compare_face_node_pt = this->halo_node_pt(ip, ihn);
                if (compare_face_node_pt == face_node_pt)
                {
                  // Once found the id of the node with the processor
                  // store the id in the proper storage
                  face_halo_node_id[ip].push_back(ihn);
#ifdef PARANOID
                  // Set the flag to mark as found the halo node
                  found_halo_node = true;
#endif
                  // Break the loop
                  break;
                }
              } // for (ih < nhalo_iproc)
#ifdef PARANOID
              if (!found_halo_node)
              {
                std::ostringstream error_message;
                error_message
                  << "The halo id of the current node: (" << face_node_pt->x(0)
                  << ", " << face_node_pt->x(1) << ") with processor (" << ip
                  << ") was not found!!!\n\n";
                throw OomphLibError(
                  error_message.str(),
                  "TriangleMesh::synchronize_boundary_coordinates()",
                  OOMPH_EXCEPTION_LOCATION);
              }
#endif
            } // if (face_node_pt->is_halo())
            // If the node is not halo then it could be haloed. If that
            // is the case then store the processors at which the node
            // is haloed and its id. The info. of these nodes will be
            // sent to all the processors with a halo counterpart
            else
            {
              for (unsigned ip = 0; ip < nproc; ip++)
              {
                // Only work with processors different that the current one
                if (ip != my_rank)
                {
                  // If the node is found to be haloed with the "ip"
                  // processor then save the haloed id in the storage.
                  // The current processor needs to send info. to the
                  // other processors to establish the boundary
                  // coordinates

                  // Get the number of haloed nodes with processor ip
                  const unsigned nhaloed_iproc = this->nhaloed_node(ip);
                  for (unsigned ihdn = 0; ihdn < nhaloed_iproc; ihdn++)
                  {
                    Node* compare_face_node_pt = this->haloed_node_pt(ip, ihdn);
                    if (face_node_pt == compare_face_node_pt)
                    {
                      // Store the node on the haloed node vector for
                      // the corresponding processor
                      face_haloed_node_pt[ip].push_back(face_node_pt);
                      // Now store the halo id of the node with the
                      // current processor
                      face_haloed_node_id[ip].push_back(ihdn);
                      // Mark the node as haloed with other processors,
                      // so we know the processor in charge is the
                      // current one "my_rank".
                      done_haloed_face_node[face_node_pt] = true;
                      // Break looking in the current processor, look in
                      // the next one
                      break;
                    } // if (face_node_pt == compare_face_node_pt)
                  } // for (ihdn < nhaloed_node_iproc)
                } // if (ip != my_rank)
              } // for (ip < nproc)
            } // else (non halo node)
          } // if (!done_node[node_face_pt])
        } // for (in < nnodes)
      } // if (!is_halo_face_element[iface])
    } // for (iface < nface_ele)

    // -----------------------------------------------------------------
    // Fourth: Go through the halo nodes, package and send the
    // info. necessary to identify the face nodes in the processor in
    // charge. Identify the haloed nodes in the processor in charge and
    // establish the boundary coordinates, check if those nodes are
    // (already) marked as faced nodes, if that is the case then do not
    // establish the boundary coordinates but register them to send back
    // the info. to all the processors that have a halo representation
    // of the face node
    // -----------------------------------------------------------------

    // Go through all processors
    for (unsigned ip = 0; ip < nproc; ip++)
    {
      // Only work with processors different than the current one
      if (ip != my_rank)
      {
        const unsigned nhalo_face_nodes = face_halo_node_pt[ip].size();
#ifdef PARANOID
        if (nhalo_face_nodes != face_halo_node_id[ip].size())
        {
          std::ostringstream error_message;
          error_message
            << "The number of found halo face nodes (" << nhalo_face_nodes
            << ") is different from the number of\nfound halo face ids ("
            << face_halo_node_id[ip].size() << ")!!!\n\n";
          throw OomphLibError(
            error_message.str(),
            "TriangleMesh::synchronize_boundary_coordinates()",
            OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // Container to send the info. related with the halo nodes to be
        // identified in the processors in charge
        Vector<unsigned> flat_unsigned_send_packed_data;
        Vector<double> flat_double_send_packed_data;

        // Go through the halo face nodes in the "ip" processor
        for (unsigned ihfn = 0; ihfn < nhalo_face_nodes; ihfn++)
        {
          // Get the "ihfn"-th face node with the "ip" processor
          Node* halo_face_node_pt = face_halo_node_pt[ip][ihfn];
          // Get the halo id with the "ip" processor
          const unsigned halo_id = face_halo_node_id[ip][ihfn];
          // Get the boundary coordinate of the node
          Vector<double> zeta(1);
          halo_face_node_pt->get_coordinates_on_boundary(b, zeta);
          // Store the info. in the containers
          flat_unsigned_send_packed_data.push_back(halo_id);
          flat_double_send_packed_data.push_back(zeta[0]);
        }

        // Send the info.
        MPI_Status status;
        MPI_Request request;

        // Processor to which send the info
        int send_proc = static_cast<int>(ip);
        // Processor from which receive the info
        int receive_proc = static_cast<int>(ip);

        // Storage to receive the info.
        Vector<unsigned> flat_unsigned_receive_packed_data;
        Vector<double> flat_double_receive_packed_data;

        // --------------
        // Unsigned data
        unsigned nflat_unsigned_send = flat_unsigned_send_packed_data.size();
        MPI_Isend(&nflat_unsigned_send,
                  1,
                  MPI_UNSIGNED,
                  send_proc,
                  1,
                  comm_pt->mpi_comm(),
                  &request);

        unsigned nflat_unsigned_receive = 0;
        MPI_Recv(&nflat_unsigned_receive,
                 1,
                 MPI_UNSIGNED,
                 receive_proc,
                 1,
                 comm_pt->mpi_comm(),
                 &status);

        MPI_Wait(&request, MPI_STATUS_IGNORE);

        if (nflat_unsigned_send != 0)
        {
          MPI_Isend(&flat_unsigned_send_packed_data[0],
                    nflat_unsigned_send,
                    MPI_UNSIGNED,
                    send_proc,
                    2,
                    comm_pt->mpi_comm(),
                    &request);
        }

        if (nflat_unsigned_receive != 0)
        {
          flat_unsigned_receive_packed_data.resize(nflat_unsigned_receive);
          MPI_Recv(&flat_unsigned_receive_packed_data[0],
                   nflat_unsigned_receive,
                   MPI_UNSIGNED,
                   receive_proc,
                   2,
                   comm_pt->mpi_comm(),
                   &status);
        }

        if (nflat_unsigned_send != 0)
        {
          MPI_Wait(&request, MPI_STATUS_IGNORE);
        }

        // --------------
        // Double data
        unsigned nflat_double_send = flat_double_send_packed_data.size();
        MPI_Isend(&nflat_double_send,
                  1,
                  MPI_DOUBLE,
                  send_proc,
                  3,
                  comm_pt->mpi_comm(),
                  &request);

        unsigned nflat_double_receive = 0;
        MPI_Recv(&nflat_double_receive,
                 1,
                 MPI_DOUBLE,
                 receive_proc,
                 3,
                 comm_pt->mpi_comm(),
                 &status);

        MPI_Wait(&request, MPI_STATUS_IGNORE);

        if (nflat_double_send != 0)
        {
          MPI_Isend(&flat_double_send_packed_data[0],
                    nflat_double_send,
                    MPI_DOUBLE,
                    send_proc,
                    4,
                    comm_pt->mpi_comm(),
                    &request);
        }

        if (nflat_double_receive != 0)
        {
          flat_double_receive_packed_data.resize(nflat_double_receive);
          MPI_Recv(&flat_double_receive_packed_data[0],
                   nflat_double_receive,
                   MPI_DOUBLE,
                   receive_proc,
                   4,
                   comm_pt->mpi_comm(),
                   &status);
        }

        if (nflat_double_send != 0)
        {
          MPI_Wait(&request, MPI_STATUS_IGNORE);
        }
        // --------------

#ifdef PARANOID
        if (nflat_unsigned_receive != nflat_double_receive)
        {
          std::ostringstream error_message;
          error_message << "The number of unsigned received data ("
                        << nflat_unsigned_receive << ") is different from the "
                        << "number\nof double received data ("
                        << nflat_double_receive << ")!!!\n\n";
          throw OomphLibError(
            error_message.str(),
            "TriangleMesh::synchronize_boundary_coordinates()",
            OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // With the received info. establish the boundary coordinates
        // for the face nodes that this processor is in charge (haloed
        // nodes)
        for (unsigned iflat_packed = 0; iflat_packed < nflat_unsigned_receive;
             iflat_packed++)
        {
          // Get the haloed id for the node
          const unsigned haloed_id =
            flat_unsigned_receive_packed_data[iflat_packed];
          // Get the boundary coordinates
          Vector<double> zeta(1);
          zeta[0] = flat_double_receive_packed_data[iflat_packed];

          // Get the haloed node
          Node* haloed_face_node_pt = this->haloed_node_pt(ip, haloed_id);

          // If the node has already set the boundary coordinates then
          // do not establish it. This is the case for the nodes that
          // lie on the boundary, for those nodes not identified on the
          // boundary since no elements lie on the boundary but the node
          // is on the boundary (a corner of an element lies on the
          // boundary) set boundary coordinates and register them to
          // send their info. to the processors with a halo counterpart

          // If the node is not haloed face in the procesor in charge
          // then set the boundary coordinates and register the node to
          // send back the boundary coordinates to the processors with a
          // halo counterpart
          if (!done_haloed_face_node[haloed_face_node_pt])
          {
            // Establish the boundary coordinates
            haloed_face_node_pt->set_coordinates_on_boundary(b, zeta);

            // Look in all processors where the node could be halo
            for (unsigned iiproc = 0; iiproc < nproc; iiproc++)
            {
              // Only work with processors different than the current one
              if (iiproc != my_rank)
              {
                // Get the number of haloed nodes with processor iiproc
                const unsigned nhaloed_node_iiproc = this->nhaloed_node(iiproc);
                for (unsigned ihdn = 0; ihdn < nhaloed_node_iiproc; ihdn++)
                {
                  Node* compare_haloed_node_pt =
                    this->haloed_node_pt(iiproc, ihdn);
                  if (haloed_face_node_pt == compare_haloed_node_pt)
                  {
                    // Store the node on the haloed node vector for the
                    // corresponding processor
                    face_haloed_node_pt[iiproc].push_back(haloed_face_node_pt);
                    // Now store the halo id of the node with the current
                    // processor
                    face_haloed_node_id[iiproc].push_back(ihdn);
                    // Break searching in the current processor, search in
                    // the next one
                    break;
                  } // if (haloed_face_node_pt==compare_haloed_face_node_pt)
                } // for (ihdn < nhaloed_node_iproc)
              } // if (iiproc != my_rank)
            } // for (iiproc < nproc)
          } // if (!done_haloed_face_node[haloed_face_node_pt])
        } // for (iflat_packed < nflat_unsigned_receive)
      } // if (ip != my_rank)
    } // for (ip < nproc)

    // -----------------------------------------------------------------
    // Fifth: The boundary coordinates have been established in the
    // processors in charge of the nodes. Now each processor send back
    // the boundary coordinates to all the processors where there is a
    // halo representation of the node
    // -----------------------------------------------------------------

    // Go through all processors
    for (unsigned ip = 0; ip < nproc; ip++)
    {
      // Only work with processors different than the current one
      if (ip != my_rank)
      {
        // Container to send the info. of the haloed nodes to all the
        // processors
        Vector<unsigned> flat_unsigned_send_packed_data;
        Vector<double> flat_double_send_packed_data;

        // Get the total number of haloed face nodes with the "ip"
        // processor
        const unsigned nhaloed_face_nodes = face_haloed_node_pt[ip].size();
        // Go through the haloed face nodes in the "ip" processor
        for (unsigned ihdfn = 0; ihdfn < nhaloed_face_nodes; ihdfn++)
        {
          // Get the "ihdfn"-th face node with the "ip" processor
          Node* haloed_face_node_pt = face_haloed_node_pt[ip][ihdfn];
          // Get the haloed id with the "ip" processor
          const unsigned haloed_id = face_haloed_node_id[ip][ihdfn];
          // Get the boundary coordinate of the node
          Vector<double> zeta(1);
          haloed_face_node_pt->get_coordinates_on_boundary(b, zeta);
          // Store the info. in the containers
          flat_unsigned_send_packed_data.push_back(haloed_id);
          flat_double_send_packed_data.push_back(zeta[0]);
        }

        // Send the info.
        MPI_Status status;
        MPI_Request request;

        // Processor to which send the info
        int send_proc = static_cast<int>(ip);
        // Processor from which receive the info
        int receive_proc = static_cast<int>(ip);

        // Storage to receive the info.
        Vector<unsigned> flat_unsigned_receive_packed_data;
        Vector<double> flat_double_receive_packed_data;

        // --------------
        // Unsigned data
        unsigned nflat_unsigned_send = flat_unsigned_send_packed_data.size();
        MPI_Isend(&nflat_unsigned_send,
                  1,
                  MPI_UNSIGNED,
                  send_proc,
                  1,
                  comm_pt->mpi_comm(),
                  &request);

        unsigned nflat_unsigned_receive = 0;
        MPI_Recv(&nflat_unsigned_receive,
                 1,
                 MPI_UNSIGNED,
                 receive_proc,
                 1,
                 comm_pt->mpi_comm(),
                 &status);

        MPI_Wait(&request, MPI_STATUS_IGNORE);

        if (nflat_unsigned_send != 0)
        {
          MPI_Isend(&flat_unsigned_send_packed_data[0],
                    nflat_unsigned_send,
                    MPI_UNSIGNED,
                    send_proc,
                    2,
                    comm_pt->mpi_comm(),
                    &request);
        }

        if (nflat_unsigned_receive != 0)
        {
          flat_unsigned_receive_packed_data.resize(nflat_unsigned_receive);
          MPI_Recv(&flat_unsigned_receive_packed_data[0],
                   nflat_unsigned_receive,
                   MPI_UNSIGNED,
                   receive_proc,
                   2,
                   comm_pt->mpi_comm(),
                   &status);
        }

        if (nflat_unsigned_send != 0)
        {
          MPI_Wait(&request, MPI_STATUS_IGNORE);
        }

        // --------------
        // Double data
        unsigned nflat_double_send = flat_double_send_packed_data.size();
        MPI_Isend(&nflat_double_send,
                  1,
                  MPI_DOUBLE,
                  send_proc,
                  3,
                  comm_pt->mpi_comm(),
                  &request);

        unsigned nflat_double_receive = 0;
        MPI_Recv(&nflat_double_receive,
                 1,
                 MPI_DOUBLE,
                 receive_proc,
                 3,
                 comm_pt->mpi_comm(),
                 &status);

        MPI_Wait(&request, MPI_STATUS_IGNORE);

        if (nflat_double_send != 0)
        {
          MPI_Isend(&flat_double_send_packed_data[0],
                    nflat_double_send,
                    MPI_DOUBLE,
                    send_proc,
                    4,
                    comm_pt->mpi_comm(),
                    &request);
        }

        if (nflat_double_receive != 0)
        {
          flat_double_receive_packed_data.resize(nflat_double_receive);
          MPI_Recv(&flat_double_receive_packed_data[0],
                   nflat_double_receive,
                   MPI_DOUBLE,
                   receive_proc,
                   4,
                   comm_pt->mpi_comm(),
                   &status);
        }

        if (nflat_double_send != 0)
        {
          MPI_Wait(&request, MPI_STATUS_IGNORE);
        }
        // --------------

#ifdef PARANOID
        if (nflat_unsigned_receive != nflat_double_receive)
        {
          std::ostringstream error_message;
          error_message << "The number of unsigned received data ("
                        << nflat_unsigned_receive << ") is different from the "
                        << "number\nof double received data ("
                        << nflat_double_receive << ")!!!\n\n";
          throw OomphLibError(
            error_message.str(),
            "TriangleMesh::synchronize_boundary_coordinates()",
            OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // With the received info. establish the boundary coordinates
        // received for the face nodes that this processor is not in
        // charge (halo nodes)
        for (unsigned iflat_packed = 0; iflat_packed < nflat_unsigned_receive;
             iflat_packed++)
        {
          // Get the halo id for the node
          const unsigned halo_id =
            flat_unsigned_receive_packed_data[iflat_packed];
          // Get the boundary coordinates
          Vector<double> zeta(1);
          zeta[0] = flat_double_receive_packed_data[iflat_packed];

          // Get the halo node
          Node* halo_face_node_pt = this->halo_node_pt(ip, halo_id);

          // It could be possible that the node has been already
          // established boundary coordinates since it is a halo face
          // node. However, for those elements not on the boundary, but
          // having a corner node on the boundary this procedure will
          // establish boundary coordinates for those nodes

          // this->add_boundary_node(b, halo_face_node_pt);

          // Establish the boundary coordinates
          halo_face_node_pt->set_coordinates_on_boundary(b, zeta);
        } // for (iflat_packed < nflat_unsigned_receive)
      } // if (ip != my_rank)
    } // for (ip < nproc)

    // Clean all the created face elements
    for (unsigned ie = 0; ie < nbound_ele; ie++)
    {
      delete tmp_face_ele_pt[ie];
      tmp_face_ele_pt[ie] = 0;
    }

    // Now get a new face mesh representation and fill the data for those
    // processors with halo segments
    if (is_internal_boundary)
    {
      re_scale_re_assigned_initial_zeta_values_for_internal_boundary(b);
    }
  }

  //======================================================================
  /// Re-assign the boundary segments initial zeta (arclength)
  /// for those internal boundaries that were splited during the
  /// distribution process (only apply for internal boundaries that
  /// have one face element at each side of the boundary)
  //======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::
    re_scale_re_assigned_initial_zeta_values_for_internal_boundary(
      const unsigned& b)
  {
    // ------------------------------------------------------------------
    // First: Get the face elements associated with the current boundary
    //        Only include nonhalo face elements
    // ------------------------------------------------------------------
    // Temporary storage for face elements
    Vector<FiniteElement*> face_el_pt;

    // Temporary storage for the number of elements adjacent to the
    // boundary
    unsigned nele = 0;

    // Temporary storage for elements adjacent to the boundary that have
    // a common edge (related with internal boundaries)
    unsigned n_repeated_ele = 0;

    const unsigned n_regions = this->nregion();

    // Temporary storage for already done nodes
    Vector<std::pair<Node*, Node*>> done_nodes_pt;

    // If there is more than one region then only use boundary
    // coordinates from the bulk side (region 0)
    if (n_regions > 1)
    {
      for (unsigned rr = 0; rr < n_regions; rr++)
      {
        const unsigned region_id =
          static_cast<unsigned>(this->Region_attribute[rr]);

        // Loop over all elements on boundaries in region i_r
        const unsigned nel_in_region =
          this->nboundary_element_in_region(b, region_id);

        unsigned nel_repetead_in_region = 0;

        // Only bother to do anything else, if there are elements
        // associated with the boundary and the current region
        if (nel_in_region > 0)
        {
          bool repeated = false;

          // Loop over the bulk elements adjacent to boundary b
          for (unsigned e = 0; e < nel_in_region; e++)
          {
            // Get pointer to the bulk element that is adjacent to
            // boundary b
            FiniteElement* bulk_elem_pt =
              this->boundary_element_in_region_pt(b, region_id, e);

            // Remember only to work with nonhalo elements
            if (bulk_elem_pt->is_halo())
            {
              n_repeated_ele++;
              continue;
            }

            // Find the index of the face of element e along boundary b
            int face_index =
              this->face_index_at_boundary_in_region(b, region_id, e);

            // Before adding the new element we need to be sure that the
            // edge that this element represent has not been already
            // added
            FiniteElement* tmp_ele_pt =
              new DummyFaceElement<ELEMENT>(bulk_elem_pt, face_index);

            const unsigned n_nodes = tmp_ele_pt->nnode();

            std::pair<Node*, Node*> tmp_pair = std::make_pair(
              tmp_ele_pt->node_pt(0), tmp_ele_pt->node_pt(n_nodes - 1));

            std::pair<Node*, Node*> tmp_pair_inverse = std::make_pair(
              tmp_ele_pt->node_pt(n_nodes - 1), tmp_ele_pt->node_pt(0));

            // Search for repeated nodes
            const unsigned n_done_nodes = done_nodes_pt.size();
            for (unsigned l = 0; l < n_done_nodes; l++)
            {
              if (tmp_pair == done_nodes_pt[l] ||
                  tmp_pair_inverse == done_nodes_pt[l])
              {
                nel_repetead_in_region++;
                repeated = true;
                break;
              }
            }

            // Create new face element
            if (!repeated)
            {
              // Add the pair of nodes (edge) to the node dones
              done_nodes_pt.push_back(tmp_pair);
              // Add the element to the face elements
              face_el_pt.push_back(tmp_ele_pt);
            }
            else
            {
              // Clean up
              delete tmp_ele_pt;
              tmp_ele_pt = 0;
            }

            // Re-start
            repeated = false;

          } // for nel

          nele += nel_in_region;

          n_repeated_ele += nel_repetead_in_region;

        } // if (nel_in_region > 0)
      } // for (rr < n_regions)
    } // if (n_regions > 1)
    // Otherwise it's just the normal boundary functions
    else
    {
      // Loop over all elements on boundaries
      nele = this->nboundary_element(b);

      // Only bother to do anything else, if there are elements
      if (nele > 0)
      {
        // Check for repeated ones
        bool repeated = false;

        // Loop over the bulk elements adjacent to boundary b
        for (unsigned e = 0; e < nele; e++)
        {
          // Get pointer to the bulk element that is adjacent to
          // boundary b
          FiniteElement* bulk_elem_pt = this->boundary_element_pt(b, e);

          // Remember only to work with nonhalo elements
          if (bulk_elem_pt->is_halo())
          {
            n_repeated_ele++;
            // Skip the halo element
            continue;
          }

          // Find the index of the face of element e along boundary b
          int face_index = this->face_index_at_boundary(b, e);

          // Before adding the new element we need to be sure that the
          // edge that this element represents has not been already
          // added (only applies for internal boundaries)
          FiniteElement* tmp_ele_pt =
            new DummyFaceElement<ELEMENT>(bulk_elem_pt, face_index);

          const unsigned n_nodes = tmp_ele_pt->nnode();

          std::pair<Node*, Node*> tmp_pair = std::make_pair(
            tmp_ele_pt->node_pt(0), tmp_ele_pt->node_pt(n_nodes - 1));

          std::pair<Node*, Node*> tmp_pair_inverse = std::make_pair(
            tmp_ele_pt->node_pt(n_nodes - 1), tmp_ele_pt->node_pt(0));

          // Search for repeated nodes
          const unsigned n_done_nodes = done_nodes_pt.size();
          for (unsigned l = 0; l < n_done_nodes; l++)
          {
            if (tmp_pair == done_nodes_pt[l] ||
                tmp_pair_inverse == done_nodes_pt[l])
            {
              // Increase the number of repeated elements
              n_repeated_ele++;
              // Mark the element as repeated
              repeated = true;
              break;
            }
          }

          // Create new face element
          if (!repeated)
          {
            // Add the pair of nodes (edge) to the node dones
            done_nodes_pt.push_back(tmp_pair);
            // Add the element to the face elements
            face_el_pt.push_back(tmp_ele_pt);
          }
          else
          {
            // Free the repeated bulk element!!
            delete tmp_ele_pt;
            tmp_ele_pt = 0;
          }

          // Re-start
          repeated = false;

        } // for (e < nel)
      } // if (nel > 0)

    } // else (n_regions > 1)

    // Do not consider the repeated elements
    nele -= n_repeated_ele;

#ifdef PARANOID
    if (nele != face_el_pt.size())
    {
      std::ostringstream error_message;
      error_message
        << "The independet counting of face elements (" << nele << ") for "
        << "boundary (" << b << ") is different\n"
        << "from the real number of face elements in the container ("
        << face_el_pt.size() << ")\n";
      //<< "Possible memory leak\n"
      throw OomphLibError(error_message.str(),
                          "TriangleMesh::re_scale_re_assigned_initial_zeta_"
                          "values_for_internal_boundary()",
                          OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // ----------------------------------------------------------------
    // Second: Sort the face elements (to create segments), only
    // consider nonhalo elements
    // ----------------------------------------------------------------

    // Get the total number of nonhalo face elements
    const unsigned nnon_halo_face_elements = face_el_pt.size();

    // The vector of list to store the "segments" that compound the
    // boundary (segments may appear only in a distributed mesh)
    Vector<std::list<FiniteElement*>> segment_sorted_ele_pt;

    // Number of already sorted face elements
    unsigned nsorted_face_elements = 0;

    // Keep track of who's done
    std::map<FiniteElement*, bool> done_el;

    // Keep track of which element is inverted
    std::map<FiniteElement*, bool> is_inverted;

    // Iterate until all possible segments have been created
    while (nsorted_face_elements < nnon_halo_face_elements)
    {
      // The ordered list of face elements (in a distributed mesh a
      // collection of contiguous face elements define a segment)
      std::list<FiniteElement*> sorted_el_pt;

#ifdef PARANOID
      // Select an initial element for the segment
      bool found_initial_face_element = false;
#endif

      FiniteElement* ele_face_pt = 0;

      unsigned iface = 0;
      for (iface = 0; iface < nele; iface++)
      {
        ele_face_pt = face_el_pt[iface];
        // If not done then take it as initial face element
        if (!done_el[ele_face_pt])
        {
#ifdef PARANOID
          found_initial_face_element = true;
#endif
          nsorted_face_elements++;
          iface++; // The next element number
          sorted_el_pt.push_back(ele_face_pt);
          // Mark as done
          done_el[ele_face_pt] = true;
          break;
        }
      } // for (iface < nele)

#ifdef PARANOID
      if (!found_initial_face_element)
      {
        std::ostringstream error_message;
        error_message
          << "Could not find an initial face element for the current segment\n";
        // << "----- Possible memory leak -----\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::re_scale_re_assigned_initial_zeta_"
                            "values_for_internal_boundary()",
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Number of nodes
      const unsigned nnod = ele_face_pt->nnode();

      // Left and rightmost nodes (the left and right nodes of the
      // current face element)
      Node* left_node_pt = ele_face_pt->node_pt(0);
      Node* right_node_pt = ele_face_pt->node_pt(nnod - 1);

      // Continue iterating if a new face element has been added to the
      // list
      bool face_element_added = false;

      // While a new face element has been added to the set of sorted
      // face elements then re-iterate
      do
      {
        // Start from the next face element since we have already added
        // the previous one as the initial face element (any previous
        // face element had to be added on previous iterations)
        for (unsigned iiface = iface; iiface < nele; iiface++)
        {
          // Re-start flag
          face_element_added = false;

          // Get the candidate element
          ele_face_pt = face_el_pt[iiface];

          // Check that the candidate element has not been done
          if (!(done_el[ele_face_pt]))
          {
            // Get the left and right nodes of the current element
            Node* local_left_node_pt = ele_face_pt->node_pt(0);
            Node* local_right_node_pt = ele_face_pt->node_pt(nnod - 1);

            // New element fits at the left of segment and is not inverted
            if (left_node_pt == local_right_node_pt)
            {
              left_node_pt = local_left_node_pt;
              sorted_el_pt.push_front(ele_face_pt);
              is_inverted[ele_face_pt] = false;
              face_element_added = true;
            }
            // New element fits at the left of segment and is inverted
            else if (left_node_pt == local_left_node_pt)
            {
              left_node_pt = local_right_node_pt;
              sorted_el_pt.push_front(ele_face_pt);
              is_inverted[ele_face_pt] = true;
              face_element_added = true;
            }
            // New element fits on the right of segment and is not inverted
            else if (right_node_pt == local_left_node_pt)
            {
              right_node_pt = local_right_node_pt;
              sorted_el_pt.push_back(ele_face_pt);
              is_inverted[ele_face_pt] = false;
              face_element_added = true;
            }
            // New element fits on the right of segment and is inverted
            else if (right_node_pt == local_right_node_pt)
            {
              right_node_pt = local_left_node_pt;
              sorted_el_pt.push_back(ele_face_pt);
              is_inverted[ele_face_pt] = true;
              face_element_added = true;
            }

            if (face_element_added)
            {
              done_el[ele_face_pt] = true;
              nsorted_face_elements++;
              break;
            }

          } // if (!(done_el[ele_face_pt]))
        } // for (iiface<nnon_halo_face_element)
      } while (face_element_added &&
               (nsorted_face_elements < nnon_halo_face_elements));

      // Store the created segment in the vector of segments
      segment_sorted_ele_pt.push_back(sorted_el_pt);

    } // while(nsorted_face_elements < nnon_halo_face_elements);

    // --------------------------------------------------------------
    // Third: We have the face elements sorted, now assign boundary
    // coordinates to the nodes in the segments and compute the
    // arclength of the segment
    // --------------------------------------------------------------

    // Vector of sets that stores the nodes of each segment based on a
    // lexicographically order starting from the bottom left node of
    // each segment
    Vector<std::set<Node*>> segment_all_nodes_pt;

    // The number of segments in this processor
    const unsigned nsegments = segment_sorted_ele_pt.size();

#ifdef PARANOID
    if (nnon_halo_face_elements > 0 && nsegments == 0)
    {
      std::ostringstream error_message;
      error_message
        << "The number of segments is zero, but the number of nonhalo\n"
        << "elements is: (" << nnon_halo_face_elements << ")\n";
      throw OomphLibError(error_message.str(),
                          "TriangleMesh::re_scale_re_assigned_initial_zeta_"
                          "values_for_internal_boundary()",
                          OOMPH_EXCEPTION_LOCATION);
    } // if (nnon_halo_face_elements > 0 && nsegments == 0)
#endif

    // The arclength of each segment in the current processor
    Vector<double> segment_arclength(nsegments);

    // The initial zeta for the segment
    Vector<double> initial_zeta_segment(nsegments);

    // The final zeta for the segment
    Vector<double> final_zeta_segment(nsegments);

    // Go through all the segments and compute the LOCAL boundary
    // coordinates
    for (unsigned is = 0; is < nsegments; is++)
    {
#ifdef PARANOID
      if (segment_sorted_ele_pt[is].size() == 0)
      {
        std::ostringstream error_message;
        error_message << "The (" << is << ")-th segment has no elements\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::re_scale_re_assigned_initial_zeta_"
                            "values_for_internal_boundary()",
                            OOMPH_EXCEPTION_LOCATION);
      } // if (segment_sorted_ele_pt[is].size() == 0)
#endif

      // Get access to the first element on the segment
      FiniteElement* first_ele_pt = segment_sorted_ele_pt[is].front();

      // Number of nodes
      const unsigned nnod = first_ele_pt->nnode();

      // Get the first node of the current segment
      Node* first_node_pt = first_ele_pt->node_pt(0);
      if (is_inverted[first_ele_pt])
      {
        first_node_pt = first_ele_pt->node_pt(nnod - 1);
      }

      // Get access to the last element on the segment
      FiniteElement* last_ele_pt = segment_sorted_ele_pt[is].back();

      // Get the last node of the current segment
      Node* last_node_pt = last_ele_pt->node_pt(nnod - 1);
      if (is_inverted[last_ele_pt])
      {
        last_node_pt = last_ele_pt->node_pt(0);
      }

      // Coordinates of left node
      double x_left = first_node_pt->x(0);
      double y_left = first_node_pt->x(1);

      // Initialise boundary coordinate (local boundary coordinate for
      // boundaries with more than one segment)
      Vector<double> zeta(1, 0.0);

      // If we have associated a GeomObject then it is not necessary to
      // compute the arclength, only read the values from the nodes at
      // the edges
      if (this->boundary_geom_object_pt(b) != 0)
      {
        first_node_pt->get_coordinates_on_boundary(b, zeta);
        initial_zeta_segment[is] = zeta[0];
        last_node_pt->get_coordinates_on_boundary(b, zeta);
        final_zeta_segment[is] = zeta[0];
      }

      // Lexicographically bottom left node
      std::set<Node*> local_nodes_pt;
      local_nodes_pt.insert(first_node_pt);

      // Now loop over nodes in order
      for (std::list<FiniteElement*>::iterator it =
             segment_sorted_ele_pt[is].begin();
           it != segment_sorted_ele_pt[is].end();
           it++)
      {
        // Get element
        FiniteElement* el_pt = *it;

        // Start node and increment
        unsigned k_nod = 1;
        int nod_diff = 1;
        if (is_inverted[el_pt])
        {
          k_nod = nnod - 2;
          nod_diff = -1;
        }

        // Loop over nodes
        for (unsigned j = 1; j < nnod; j++)
        {
          Node* nod_pt = el_pt->node_pt(k_nod);
          k_nod += nod_diff;

          // Coordinates of right node
          double x_right = nod_pt->x(0);
          double y_right = nod_pt->x(1);

          // Increment boundary coordinate
          zeta[0] += sqrt((x_right - x_left) * (x_right - x_left) +
                          (y_right - y_left) * (y_right - y_left));

          // Increment reference coordinate
          x_left = x_right;
          y_left = y_right;

          // Get lexicographically bottom left node but only
          // use vertex nodes as candidates
          local_nodes_pt.insert(nod_pt);

        } // for (j < nnod)
      } // iterator over the elements in the segment

      // Store the arclength of the segment
      segment_arclength[is] = zeta[0];

      // Add the nodes for the corresponding segment in the container
      segment_all_nodes_pt.push_back(local_nodes_pt);

    } // for (is < nsegments)

    // ------------------------------------------------------------------
    // Fourth: Now we have the segments sorted, with arclength and with
    // LOCAL arclength assigned to the nodes. Procced to re-scale the
    // coordinates on the nodes based on the arclength
    // ------------------------------------------------------------------

    // ------------------------------------------------------------------
    // Clear the original storages
    Boundary_segment_inverted[b].clear();
    Boundary_segment_initial_coordinate[b].clear();
    Boundary_segment_final_coordinate[b].clear();

    Boundary_segment_initial_zeta[b].clear();
    Boundary_segment_final_zeta[b].clear();

    Boundary_segment_initial_arclength[b].clear();
    Boundary_segment_final_arclength[b].clear();

    // Get the zeta values for the first and last node in the boundary
    Vector<double> first_node_zeta_coordinate(1, 0.0);
    Vector<double> last_node_zeta_coordinate(1, 0.0);
    first_node_zeta_coordinate = boundary_initial_zeta_coordinate(b);
    last_node_zeta_coordinate = boundary_final_zeta_coordinate(b);

    // Get the boundary arclength
    const double boundary_arclength =
      std::max(first_node_zeta_coordinate[0], last_node_zeta_coordinate[0]);

    // Go through the segments and get the first and last node for each
    // segment
    for (unsigned is = 0; is < nsegments; is++)
    {
      // Get the first face element of the segment
      FiniteElement* first_face_ele_pt = segment_sorted_ele_pt[is].front();

      // The number of nodes
      const unsigned nnod = first_face_ele_pt->nnode();

      // ... and the first node of the segment
      Node* first_node_pt = first_face_ele_pt->node_pt(0);
      if (is_inverted[first_face_ele_pt])
      {
        first_node_pt = first_face_ele_pt->node_pt(nnod - 1);
      }

      // Get the bound coordinates of the node
      Vector<double> zeta_first(1);
      first_node_pt->get_coordinates_on_boundary(b, zeta_first);

      // Get the last face element of the segment
      FiniteElement* last_face_ele_pt = segment_sorted_ele_pt[is].back();

      // ... and the last node of the segment
      Node* last_node_pt = last_face_ele_pt->node_pt(nnod - 1);
      if (is_inverted[last_face_ele_pt])
      {
        last_node_pt = last_face_ele_pt->node_pt(0);
      }

      // Get the bound coordinates of the node
      Vector<double> zeta_last(1);
      last_node_pt->get_coordinates_on_boundary(b, zeta_last);

      // Now that we have the first and last node of the segment, get
      // the coordinates of the nodes
      Vector<double> first_node_coord(2);
      Vector<double> last_node_coord(2);
      for (unsigned i = 0; i < 2; i++)
      {
        first_node_coord[i] = first_node_pt->x(i);
        last_node_coord[i] = last_node_pt->x(i);
      }

      // Re-assign the values to identify the segments on the new mesh
      Boundary_segment_inverted[b].push_back(0);
      Boundary_segment_initial_coordinate[b].push_back(first_node_coord);
      Boundary_segment_final_coordinate[b].push_back(last_node_coord);

      // Check if the boudary has an associated GeomObject
      if (this->boundary_geom_object_pt(b) != 0)
      {
        Boundary_segment_initial_zeta[b].push_back(zeta_first[0]);
        Boundary_segment_final_zeta[b].push_back(zeta_last[0]);
      }
      else
      {
        // Re-assign the values and re-scale them
        Boundary_segment_initial_arclength[b].push_back(zeta_first[0] *
                                                        boundary_arclength);
        Boundary_segment_final_arclength[b].push_back(zeta_last[0] *
                                                      boundary_arclength);
      }

    } // for (is < nsegments)

    // Clean all the created face elements
    for (unsigned i = 0; i < nele; i++)
    {
      delete face_el_pt[i];
      face_el_pt[i] = 0;
    }
  }

#endif // OOMPH_HAS_MPI


#ifdef OOMPH_HAS_TRIANGLE_LIB

  //========================================================================
  /// Create TriangulateIO object via the .poly file
  //========================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::build_triangulateio(
    const std::string& poly_file_name,
    TriangulateIO& triangulate_io,
    bool& use_attributes)
  {
    // Process poly file
    // -----------------
    std::ifstream poly_file(poly_file_name.c_str(), std::ios_base::in);
    if (!poly_file)
    {
      throw OomphLibError("Error opening .poly file\n",
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
    }

    // Initialize triangulateio structure
    TriangleHelper::initialise_triangulateio(triangulate_io);

    // Ignore the first line with structure description
    poly_file.ignore(80, '\n');

    // Read and store number of nodes
    unsigned invertices;
    poly_file >> invertices;
    triangulate_io.numberofpoints = invertices;

    // Initialisation of the point list
    triangulate_io.pointlist =
      (double*)malloc(triangulate_io.numberofpoints * 2 * sizeof(double));

    // Read and store spatial dimension of nodes
    unsigned mesh_dim;
    poly_file >> mesh_dim;

    if (mesh_dim == 0)
    {
      mesh_dim = 2;
    }

#ifdef PARANOID
    if (mesh_dim != 2)
    {
      throw OomphLibError("The dimension must be 2\n",
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Read and check the flag for attributes
    unsigned nextras;
    poly_file >> nextras;

    triangulate_io.numberofpointattributes = 0;
    triangulate_io.pointattributelist = (double*)NULL;

    // Read and check the flag for boundary markers
    unsigned nodemarkers;
    poly_file >> nodemarkers;
    triangulate_io.pointmarkerlist = (int*)NULL;

#ifdef PARANOID
    // Reading the .poly with the oomph.lib we need
    // to set the point attribute and markers to 0
    if (nextras != 0 || nodemarkers != 0)
    {
      oomph_info << "===================================================="
                 << std::endl
                 << std::endl;
      oomph_info << "Reading the .poly file via oomph_lib \n"
                 << "point's attribute and point's markers \n"
                 << "are automatically set to 0" << std::endl;
      oomph_info << "===================================================="
                 << std::endl;
    }
#endif

    // Dummy for node number (and attribute or markers if included)
    unsigned dummy_value;
    unsigned count_point = 0;
    std::string test_string;

    // Skip line with commentary
    getline(poly_file, test_string, '#');
    poly_file.ignore(80, '\n');

    // Read and store all the nodes coordinates
    // (hole's vertices as well)
    for (unsigned count = 0; count < invertices; count++)
    {
      poly_file >> dummy_value;
      poly_file >> triangulate_io.pointlist[count_point];
      poly_file >> triangulate_io.pointlist[count_point + 1];
      if (nextras != 0 || nodemarkers != 0)
      {
        for (unsigned j = 0; j < nextras; j++)
        {
          poly_file >> dummy_value;
        }
      }
      else if (nextras != 0 && nodemarkers != 0)
      {
        for (unsigned j = 0; j < nextras; j++)
        {
          poly_file >> dummy_value;
          poly_file >> dummy_value;
        }
      }
      // Read the next line
      poly_file.ignore(80, '\n');

      // Skip line with commentary for internal box whether found
      if (poly_file.get() == '#')
      {
        poly_file.ignore(80, '\n');
      }
      // If read the char should be put back in the string

      else
      {
        poly_file.unget();
      }
      count_point += 2;
    }

    // The line with the segment's commentary has been skipped
    // by the command of the last loop

    // Read and store the number of segments
    unsigned dummy_seg;
    unsigned inelements;
    poly_file >> inelements;

    unsigned segment_markers;
    poly_file >> segment_markers;

    // Marker list should be provided by the user to assign
    // each segment to a boundary
#ifdef PARANOID
    if (segment_markers != 1)
    {
      std::ostringstream error_stream;
      error_stream << "The segment marker should be provided \n"
                   << "In order to assign each segment to a boundary \n "
                   << std::endl;

      throw OomphLibError(
        error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    triangulate_io.numberofsegments = inelements;
    triangulate_io.segmentlist =
      (int*)malloc(triangulate_io.numberofsegments * 2 * sizeof(int));
    triangulate_io.segmentmarkerlist =
      (int*)malloc(triangulate_io.numberofsegments * sizeof(int));

    // Read all the segments edges and markers
    for (unsigned i = 0; i < 2 * inelements; i += 2)
    {
      poly_file >> dummy_seg;
      poly_file >> triangulate_io.segmentlist[i];
      poly_file >> triangulate_io.segmentlist[i + 1];
      if (segment_markers != 0)
      {
        poly_file >> triangulate_io.segmentmarkerlist[i / 2];
      }

      // Skip line with commentary
      poly_file.ignore(80, '\n');
    }

    // Read and store the number of holes if given
    // Skip line with commentary
    if (getline(poly_file, test_string, '#'))
    {
      poly_file.ignore(80, '\n');

      unsigned dummy_hole;
      unsigned nhole;
      poly_file >> nhole;

      triangulate_io.numberofholes = nhole;
      triangulate_io.holelist =
        (double*)malloc(triangulate_io.numberofholes * 2 * sizeof(double));

      // Loop over the holes to get centre coords and store value onto the
      // TriangulateIO object
      for (unsigned i = 0; i < 2 * nhole; i += 2)
      {
        poly_file >> dummy_hole;
        poly_file >> triangulate_io.holelist[i];
        poly_file >> triangulate_io.holelist[i + 1];
      }
    }

    // Read and store the number of regions if given
    // Skip line with commentary
    if (getline(poly_file, test_string, '#'))
    {
      poly_file.ignore(80, '\n');

      unsigned dummy_region;
      unsigned nregion;
      poly_file >> nregion;
      std::cerr << "Regions: " << nregion << std::endl;
      getchar();

      triangulate_io.numberofregions = nregion;
      triangulate_io.regionlist =
        (double*)malloc(triangulate_io.numberofregions * 4 * sizeof(double));

      // Check for using regions
      if (nregion > 0)
      {
        use_attributes = true;
      }

      // Loop over the regions to get coords and store value onto the
      // TriangulateIO object
      for (unsigned i = 0; i < nregion; i++)
      {
        poly_file >> dummy_region;
        poly_file >> triangulate_io.regionlist[4 * i];
        poly_file >> triangulate_io.regionlist[4 * i + 1];
        poly_file >> triangulate_io.regionlist[4 * i + 2];
        triangulate_io.regionlist[4 * i + 3] = 0.0;
      }
    }
  }

#endif

#ifdef OOMPH_HAS_TRIANGLE_LIB
#ifdef OOMPH_HAS_MPI

  //======================================================================
  /// Used to dump info. related with distributed triangle meshes
  //======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::dump_distributed_info_for_restart(
    std::ostream& dump_file)
  {
    // First check that the mesh is distributed
    if (this->is_mesh_distributed())
    {
      // Save the original number of boundaries
      const unsigned nboundary = this->nboundary();
      dump_file << nboundary << " # number of original boundaries" << std::endl;

      // Save the number of shared boundaries
      const unsigned nshared_boundaries = this->nshared_boundaries();
      dump_file << nshared_boundaries << " # number of shared boundaries"
                << std::endl;

      // Save the initial and final shared boundaries ids
      const unsigned init_shd_bnd_id = this->initial_shared_boundary_id();
      dump_file << init_shd_bnd_id << " # initial shared boundaries id"
                << std::endl;

      const unsigned final_shd_bnd_id = this->final_shared_boundary_id();
      dump_file << final_shd_bnd_id << " # final shared boundaries id"
                << std::endl;

      // Save the number of processors
      const unsigned nprocs = this->shared_boundaries_ids().size();
      dump_file << nprocs << " # number of processors" << std::endl;

      // Now save the processors ids and the shared boundary created
      // by them
      for (unsigned ip = 0; ip < nprocs; ip++)
      {
        for (unsigned jp = 0; jp < nprocs; jp++)
        {
          if (ip != jp)
          {
            // Get the number of shared boundaries with it these two
            // processors
            const unsigned nshared_boundaries_iproc_jproc =
              this->shared_boundaries_ids(ip, jp).size();

            // Save the number of shared boundaries with in these two
            // processors
            dump_file << nshared_boundaries_iproc_jproc
                      << " # number of shared boundaries with in two "
                      << "processors" << std::endl;
            for (unsigned is = 0; is < nshared_boundaries_iproc_jproc; is++)
            {
              const unsigned shared_boundary_id =
                this->shared_boundaries_ids(ip, jp, is);
              dump_file << ip << " " << jp << " " << shared_boundary_id
                        << " # ip jp shared_boundary of processors ip and jp"
                        << std::endl;

            } // for (is < nshared_boundaries_iproc_jproc)
          }
        } // for (jp < nprocs)
      } // for (ip < nprocs)

      // Now save the info. that states which shared boundary overlaps
      // an internal boundary

      // First check if there are shared boundaries overlapping internal
      // boundaries
      const unsigned nshared_boundaries_overlap_internal_boundaries =
        this->nshared_boundary_overlaps_internal_boundary();
      dump_file << nshared_boundaries_overlap_internal_boundaries
                << " # number of shared boundaries that overlap internal "
                << "boundaries" << std::endl;

      if (nshared_boundaries_overlap_internal_boundaries > 0)
      {
        for (unsigned isb = init_shd_bnd_id; isb < final_shd_bnd_id; isb++)
        {
          // Check if the current shared boundary overlaps an internal
          // boundary
          if (this->shared_boundary_overlaps_internal_boundary(isb))
          {
            // Which internal boundary is overlapped by the shared
            // boundary
            const unsigned overlapped_internal_boundary =
              shared_boundary_overlapping_internal_boundary(isb);
            // Save the shared boundary that overlaps the internal boundary
            dump_file << isb << " " << overlapped_internal_boundary
                      << " # the shared boundary overlaps the internal "
                      << "boundary " << std::endl;

          } // if (this->shared_boundary_overlaps_internal_boundary(isb))
        } // for (isb < final_shd_bnd_id)
      } // if (nshared_boundaries_overlap_internal_boundaries > 0)

      // Now save the info. related with the initial and final
      // boundary coordinates for each original boundary

      // Go through all the (original) boundaries to update the initial
      // and final boundary coordinates
      for (unsigned b = 0; b < nboundary; b++)
      {
        // Check if the boundary zeta coordinates for this boundary have
        // been already assigned, if that is the case then state the
        // flag to know that info. should be read
        if (Assigned_segments_initial_zeta_values[b])
        {
          // The boundary coordinates have been computed then state
          // the flag and save the info.
          dump_file << "1 # assigned boundary coordinates initial zeta values"
                    << std::endl;

          // Save the initial and final boundary coordinates, same as
          // the initial and final zeta values for each boundary

          // First the vertices coordinates
          Vector<double> initial_coordinates =
            this->boundary_initial_coordinate(b);

          Vector<double> final_coordinates = this->boundary_final_coordinate(b);

          dump_file << std::setprecision(14) << initial_coordinates[0] << " "
                    << initial_coordinates[1]
                    << " # initial coordinates for the current boundary"
                    << std::endl;

          dump_file << std::setprecision(14) << final_coordinates[0] << " "
                    << final_coordinates[1]
                    << " # final coordinates for the current boundary"
                    << std::endl;

          // ... then the zeta values

#ifdef PARANOID
          // Get the number of zeta coordinates (should be one)
          const unsigned zeta_size =
            this->boundary_initial_zeta_coordinate(b).size();

          if (zeta_size != 1)
          {
            std::ostringstream error_message;
            error_message
              << "The dimension for the zeta values container is different\n"
              << "from 1, the current implementation only supports\n"
              << "one-dimensioned zeta containers\n\n";
            throw OomphLibError(
              error_message.str(),
              "TriangleMesh::dump_distributed_info_for_restart()",
              OOMPH_EXCEPTION_LOCATION);
          }
#endif

          Vector<double> zeta_initial =
            this->boundary_initial_zeta_coordinate(b);
          Vector<double> zeta_final = this->boundary_final_zeta_coordinate(b);

          dump_file << std::setprecision(14) << zeta_initial[0]
                    << " # initial zeta value for the current boundary"
                    << std::endl;

          dump_file << std::setprecision(14) << zeta_final[0]
                    << " # final zeta value for the current boundary"
                    << std::endl;

          // Get the number of segments of the current boundary
          const unsigned nsegments = this->nboundary_segment(b);
          // Save the number of segments of the current boundary
          dump_file << b << " " << nsegments
                    << " # of segments for the current boundary" << std::endl;

          // ... and then save that info for each segments
          for (unsigned is = 0; is < nsegments; is++)
          {
            // First the vertices coordinates
            Vector<double> initial_segment_coordinates =
              this->boundary_segment_initial_coordinate(b)[is];
            Vector<double> final_segment_coordinates =
              this->boundary_segment_final_coordinate(b)[is];

            dump_file
              << std::setprecision(14) << initial_segment_coordinates[0] << " "
              << initial_segment_coordinates[1]
              << " # initial segment coordinates for the current boundary"
              << std::endl;

            dump_file << std::setprecision(14) << final_segment_coordinates[0]
                      << " " << final_segment_coordinates[1]
                      << " # final segment coordinates for the current boundary"
                      << std::endl;

            // ... then the zeta values

            if (this->boundary_geom_object_pt(b) != 0)
            {
              const double zeta_segment_initial =
                this->boundary_segment_initial_zeta(b)[is];
              const double zeta_segment_final =
                this->boundary_segment_final_zeta(b)[is];

              dump_file
                << std::setprecision(14) << zeta_segment_initial
                << " # initial segment zeta value for the current boundary"
                << std::endl;

              dump_file
                << std::setprecision(14) << zeta_segment_final
                << " # final segment zeta value for the current boundary"
                << std::endl;
            }
            else
            {
              const double arclength_segment_initial =
                this->boundary_segment_initial_arclength(b)[is];
              const double arclength_segment_final =
                this->boundary_segment_final_arclength(b)[is];

              dump_file
                << std::setprecision(14) << arclength_segment_initial
                << " # initial segment arclength for the current boundary"
                << std::endl;

              dump_file << std::setprecision(14) << arclength_segment_final
                        << " # final segment arclength for the current boundary"
                        << std::endl;

            } // else if (this->boundary_geom_object_pt(b)!=0)

          } // for (is < nsegments)

        } // if (Assigned_segments_initial_zeta_values[b])
        else
        {
          // The boundary coordinates have NOT been computed then state
          // the flag and save the info.
          dump_file << "0 # assigned boundary coordinates initial zeta values"
                    << std::endl;
        }

      } // for (b < nboundary)

    } // if (this->is_mesh_distributed())
  }

  //======================================================================
  /// Used to read info. related with distributed triangle meshes
  //======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::read_distributed_info_for_restart(
    std::istream& restart_file)
  {
    // First check that the mesh is distributed
    if (this->is_mesh_distributed())
    {
      // Read the number of original boundaries
      const unsigned n_boundary = read_unsigned_line_helper(restart_file);

#ifdef PARANOID
      if (n_boundary != this->nboundary())
      {
        std::ostringstream error_message;
        error_message
          << "The number of boundaries (" << n_boundary << ") on the "
          << "file used for restarting is different\nfrom the number of "
          << "boundaries (" << this->nboundary() << ") on the current "
          << "mesh!!!\n\n\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::read_distributed_info_for_restart()",
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Read the number of shared boundaries
      unsigned n_shared_boundaries = read_unsigned_line_helper(restart_file);
      // We need to read the data because it comes in the file (add and
      // substract to avoid compilation warning)
      n_shared_boundaries++;
      n_shared_boundaries--;

      // Read the initial and final shared boundaries ids
      unsigned init_shd_bnd_id = read_unsigned_line_helper(restart_file);
      // We need to read the data because it comes in the file (add and
      // substract to avoid compilation warning)
      init_shd_bnd_id++;
      init_shd_bnd_id--;
      // Add and substract to avoid compilation warning
      unsigned final_shd_bnd_id = read_unsigned_line_helper(restart_file);
      // We need to read the data because it comes in the file (add and
      // substract to avoid compilation warning)
      final_shd_bnd_id++;
      final_shd_bnd_id--;

      // Read the number of processors involved in the generation of
      // mesh before restart
      const unsigned n_procs = read_unsigned_line_helper(restart_file);

#ifdef PARANOID
      if (static_cast<int>(n_procs) != this->communicator_pt()->nproc())
      {
        std::ostringstream error_message;
        error_message
          << "The number of previously used processors (" << n_procs
          << ") (read from the restart file) is different\nfrom the "
          << "number of current used processors ("
          << this->communicator_pt()->nproc() << ")\n\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::read_distributed_info_for_restart()",
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Clear all previuos info. related with shared boundaries
      this->shared_boundaries_ids().clear();
      this->shared_boundary_from_processors().clear();
      this->shared_boundary_overlaps_internal_boundary().clear();

      // Create the storage for the shared boundaries ids related with
      // the processors
      this->shared_boundaries_ids().resize(n_procs);

      // Now read the processors ids and the shared boundary created
      // by them
      for (unsigned ip = 0; ip < n_procs; ip++)
      {
        // Create the storage for the shared boundaries ids related with
        // the processors
        this->shared_boundaries_ids(ip).resize(n_procs);
        for (unsigned jp = 0; jp < n_procs; jp++)
        {
          if (ip != jp)
          {
            // Read the number of shared boundaries with in these two
            // processors
            const unsigned nshared_boundaries_iproc_jproc =
              read_unsigned_line_helper(restart_file);
            for (unsigned is = 0; is < nshared_boundaries_iproc_jproc; is++)
            {
              // Get the processors
              unsigned tmp_ip;
              restart_file >> tmp_ip;
              unsigned tmp_jp;
              restart_file >> tmp_jp;

              // Get the shared boundary id created by these two
              // processors
              const unsigned shared_boundary_id =
                read_unsigned_line_helper(restart_file);

              // Update the info. of the processors that give rise to
              // the shared boundaries
              this->shared_boundaries_ids(ip, jp).push_back(shared_boundary_id);

              // Update the structure that states the processors that
              // gave rise to the shared boundary
              Vector<unsigned> processors(2);
              processors[0] = ip;
              processors[1] = jp;
              this->shared_boundary_from_processors()[shared_boundary_id] =
                processors;

            } // for (is < nshared_boundaries_iproc_jproc)
          }
        } // for (jp < n_procs)
      } // for (ip < n_procs)

      // Now read the info. that states which shared boundary overlaps
      // an internal boundary

      // First check if there are shared boundaries overlapping internal
      // boundaries
      const unsigned nshared_boundaries_overlap_internal_boundaries =
        read_unsigned_line_helper(restart_file);

      for (unsigned isb = 0;
           isb < nshared_boundaries_overlap_internal_boundaries;
           isb++)
      {
        // Read the shared boundary that overlaps an internal boundary
        unsigned shared_boundary_overlapping;
        restart_file >> shared_boundary_overlapping;
        // ... and read the internal boundary that overlaps
        const unsigned overlapped_internal_boundary =
          read_unsigned_line_helper(restart_file);

        // Re-establish the info. of the shared boundaries overlapped
        // by internal boundaries
        this->shared_boundary_overlaps_internal_boundary()
          [shared_boundary_overlapping] = overlapped_internal_boundary;
      } // for (isb < nshared_boundaries_overlap_internal_boundaries)

      // Now read the info. related with the initial and final
      // boundary coordinates for each original boundary

      // Go through all the (original) boundaries to update the initial
      // and final boundary coordinates
      for (unsigned b = 0; b < n_boundary; b++)
      {
        // For each boundary check if the boundary coordinates initial
        // and final zeta vales were assigned in the restart file
        const unsigned boundary_coordinates_initial_zeta_values_assigned =
          read_unsigned_line_helper(restart_file);

        if (boundary_coordinates_initial_zeta_values_assigned)
        {
          // Clear any previous stored info. There should not be
          // info. already stored but better clear the info. for the
          // boundary
          Boundary_initial_coordinate[b].clear();
          Boundary_final_coordinate[b].clear();

          Boundary_initial_zeta_coordinate[b].clear();
          Boundary_final_zeta_coordinate[b].clear();

          // The info. for the segments
          Boundary_segment_inverted[b].clear();
          Boundary_segment_initial_coordinate[b].clear();
          Boundary_segment_final_coordinate[b].clear();

          Boundary_segment_initial_zeta[b].clear();
          Boundary_segment_final_zeta[b].clear();

          Boundary_segment_initial_arclength[b].clear();
          Boundary_segment_final_arclength[b].clear();

          // Read the initial and final boundary coordinates, same as
          // the initial and final zeta values for each boundary

          // First the vertices coordinates
          Vector<double> initial_coordinates(2);

          // Read the initial coordinates
          restart_file >> initial_coordinates[0] >> initial_coordinates[1];

          // Ignore rest of line
          restart_file.ignore(80, '\n');

          Vector<double> final_coordinates(2);

          // Read the final coordinates
          restart_file >> final_coordinates[0] >> final_coordinates[1];

          // Ignore rest of line
          restart_file.ignore(80, '\n');

          // Set the values in the containers


          this->boundary_initial_coordinate(b) = initial_coordinates;
          this->boundary_final_coordinate(b) = final_coordinates;

          // ... now read the zeta values
          Vector<double> zeta_initial(1);
          restart_file >> zeta_initial[0];

          // Ignore rest of line
          restart_file.ignore(80, '\n');

          Vector<double> zeta_final(1);
          restart_file >> zeta_final[0];

          // Ignore rest of line
          restart_file.ignore(80, '\n');

          // Set the values in the containers
          this->boundary_initial_zeta_coordinate(b) = zeta_initial;
          this->boundary_final_zeta_coordinate(b) = zeta_final;

          // Get the curent boundary id from the restart file
          unsigned current_boundary;
          restart_file >> current_boundary;

#ifdef PARANOID
          if (current_boundary != b)
          {
            std::ostringstream error_message;
            error_message
              << "The current boundary id from the restart file ("
              << current_boundary << ") is different from\nthe boundary id "
              << b << "currently used to re-establish the initial and\nfinal "
              << "segment's zeta values\n\n";
            throw OomphLibError(
              error_message.str(),
              "TriangleMesh::read_distributed_info_for_restart()",
              OOMPH_EXCEPTION_LOCATION);
          }
#endif

          // ... and its number of segments
          unsigned nsegments;
          restart_file >> nsegments;

          // Ignore rest of line
          restart_file.ignore(80, '\n');

          // Now read all the segments info.

          // ... and then save that info for each segments
          for (unsigned is = 0; is < nsegments; is++)
          {
            // First the vertices coordinates
            Vector<double> initial_segment_coordinates(2);

            // Read the initial coordinates
            restart_file >> initial_segment_coordinates[0] >>
              initial_segment_coordinates[1];

            // Ignore rest of line
            restart_file.ignore(80, '\n');

            Vector<double> final_segment_coordinates(2);

            // Read the final coordinates
            restart_file >> final_segment_coordinates[0] >>
              final_segment_coordinates[1];

            // Ignore rest of line
            restart_file.ignore(80, '\n');

            // Set the values in the containers
            this->boundary_segment_initial_coordinate(b).push_back(
              initial_segment_coordinates);
            this->boundary_segment_final_coordinate(b).push_back(
              final_segment_coordinates);

            // ... then the zeta values for the segment
            if (this->boundary_geom_object_pt(b) != 0)
            {
              Vector<double> zeta_segment_initial(1);
              restart_file >> zeta_segment_initial[0];

              // Ignore rest of line
              restart_file.ignore(80, '\n');

              Vector<double> zeta_segment_final(1);
              restart_file >> zeta_segment_final[0];

              // Ignore rest of line
              restart_file.ignore(80, '\n');

              // Set the values in the containers for the segment
              this->boundary_segment_initial_zeta(b).push_back(
                zeta_segment_initial[0]);
              this->boundary_segment_final_zeta(b).push_back(
                zeta_segment_final[0]);
            }
            else
            {
              Vector<double> arclength_segment_initial(1);
              restart_file >> arclength_segment_initial[0];

              // Ignore rest of line
              restart_file.ignore(80, '\n');

              Vector<double> arclength_segment_final(1);
              restart_file >> arclength_segment_final[0];

              // Ignore rest of line
              restart_file.ignore(80, '\n');

              // Set the values in the containers for the segment
              this->boundary_segment_initial_arclength(b).push_back(
                arclength_segment_initial[0]);
              this->boundary_segment_final_arclength(b).push_back(
                arclength_segment_final[0]);
            } // else if (this->boundary_geom_object_pt(b)!=0)

          } // for (is < nsegments)

        } // if (boundary_coordinates_initial_zeta_values_assigned)

      } // for (b < n_boundary)

    } // if (this->is_mesh_distributed())
  }

#endif // #ifdef OOMPH_HAS_MPI
#endif // #ifdef OOMPH_HAS_TRIANGLE_LIB

  //===================================================================
  // Output the nodes on the boundaries and their / respective boundary
  // coordinates(into separate tecplot / zones)
  //===================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::output_boundary_coordinates(const unsigned& b,
                                                          std::ostream& outfile)
  {
    // First get all the elements adjacent to the given boundary, then
    // the face elements and extract the nodes on the boundaries using
    // the face elements. We can not use the data structure
    // Boundary_node_pt since the multi_domain functions add nodes there
    // without assigning the required boundary coordinate

    // Store the nodes in a set so we do not have repeated nodes
    std::set<Node*> boundary_nodes_pt;
    const unsigned n_boundary_ele = this->nboundary_element(b);
    for (unsigned e = 0; e < n_boundary_ele; e++)
    {
      // Get the boundary bulk element
      FiniteElement* bulk_ele_pt = this->boundary_element_pt(b, e);
#ifdef OOMPH_HAS_MPI
      // Only work with nonhalo elements if the mesh is distributed
      if (!bulk_ele_pt->is_halo())
      {
#endif
        // Get the face index
        int face_index = this->face_index_at_boundary(b, e);
        // Create the face element
        FiniteElement* face_ele_pt =
          new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);

        // Get the number of nodes on the face element
        const unsigned n_nodes = face_ele_pt->nnode();
        for (unsigned i = 0; i < n_nodes; i++)
        {
          // Get the nodes in the face elements
          Node* tmp_node_pt = face_ele_pt->node_pt(i);
          // Add the nodes to the set of boundary nodes
          boundary_nodes_pt.insert(tmp_node_pt);
        } // for (i < n_nodes)

        // Free the memory allocated for the face element
        delete face_ele_pt;
        face_ele_pt = 0;
#ifdef OOMPH_HAS_MPI
      } // if (!bulk_ele_pt->is_halo())
#endif

    } // for (e < n_boundary_ele)

    outfile << "ZONE T=\"Boundary nodes" << b << "\"\n";
    // Set to store the boundary nodes in order
    std::set<Vector<double>> set_node_coord;
    // Loop over the nodes on the boundary and store them in the set
    for (std::set<Node*>::iterator it = boundary_nodes_pt.begin();
         it != boundary_nodes_pt.end();
         it++)
    {
      Node* inode_pt = (*it);

      // Get the node coordinates
      const unsigned n_dim = inode_pt->ndim();
      Vector<double> node_coord(n_dim + 1);

      // Get the boundary coordinate
      Vector<double> zeta(1);
      inode_pt->get_coordinates_on_boundary(b, zeta);
      node_coord[0] = zeta[0];
      for (unsigned j = 0; j < n_dim; j++)
      {
        node_coord[j + 1] = inode_pt->x(j);
      }
      set_node_coord.insert(node_coord);
    }

    for (std::set<Vector<double>>::iterator it = set_node_coord.begin();
         it != set_node_coord.end();
         it++)
    {
      // Get the node coordinates
      Vector<double> node_coord = (*it);

      // Output the node coordinates
      const unsigned n_dim = node_coord.size() - 1;
      for (unsigned j = 0; j < n_dim; j++)
      {
        outfile << node_coord[j + 1] << " ";
      }
      // ... add an extra coordinate to avoid error with tecplot
      outfile << "0.0" << std::endl;
    }

    // ... loop again to plot the bound coordinates
    outfile << "ZONE T=\"Boundary coordinates " << b << "\"\n";
    for (std::set<Vector<double>>::iterator it = set_node_coord.begin();
         it != set_node_coord.end();
         it++)
    {
      // Get the node coordinates
      Vector<double> node_coord = (*it);

      // Output the node coordinates
      const unsigned n_dim = node_coord.size() - 1;
      for (unsigned j = 0; j < n_dim; j++)
      {
        outfile << node_coord[j + 1] << " ";
      }

      // Output the boundary coordinate
      outfile << node_coord[0] << std::endl;
    }
  }

#ifdef OOMPH_HAS_MPI
  //====================================================================
  // Creates the distributed domain representation. Joins the
  // original boundaires, shared boundaries and creates connections among
  // them to create the new polygons that represent the distributed
  // domain
  //====================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::create_distributed_domain_representation(
    Vector<TriangleMeshPolygon*>& polygons_pt,
    Vector<TriangleMeshOpenCurve*>& open_curves_pt)
  {
    // Get the outer polygons, internal polygons, internal open curves
    // and join them with the shared polylines to create the distributed
    // domain representation (the new outer, internal polygons, and new
    // internal open curves)

    // Get the rank of the current processor
    const unsigned my_rank = this->communicator_pt()->my_rank();

    // *********************************************************************
    // Step (2) Get the outer, internal and shared boundaries to create the
    //          new polygons
    // *********************************************************************

    // *********************************************************************
    // Step (2.1) Get the outer boundaries and check if it is necessary to use
    // a new representation (for example when the boundary was splitted in
    // the distribution process)
    // *********************************************************************

    // Storage for new created polylines, non sorted
    Vector<TriangleMeshPolyLine*> unsorted_outer_polyline_pt;

    // Storing for the polylines on the boundaries
    // The first index is for a set of connected polylines
    // The second index is for a polyline on a set of connected polylines
    Vector<Vector<TriangleMeshPolyLine*>> sorted_outer_curves_pt;

    // Copy the outer boundaries to the vector of polylines
    const unsigned nouter = this->Outer_boundary_pt.size();
    for (unsigned i = 0; i < nouter; i++)
    {
      const unsigned npolylines = this->Outer_boundary_pt[i]->npolyline();
      for (unsigned p = 0; p < npolylines; p++)
      {
        // Pointer to the current polyline
        TriangleMeshPolyLine* tmp_polyline_pt =
          this->Outer_boundary_pt[i]->polyline_pt(p);
        const unsigned nvertex = tmp_polyline_pt->nvertex();
        if (nvertex > 0)
        {
          // Get the boundary id of the polyline and check if that boundary
          // needs a new representation (for example when the boundary was
          // splitted in the distribution process)
          const unsigned bound_id = tmp_polyline_pt->boundary_id();
          if (!boundary_was_splitted(bound_id))
          {
            unsorted_outer_polyline_pt.push_back(tmp_polyline_pt);
          } // if (!boundary_was_splitted(bound_id))
          else
          {
            // Get the polylines that will represent this boundary
            Vector<TriangleMeshPolyLine*> tmp_vector_polylines =
              boundary_subpolylines(bound_id);
            const unsigned nsub_poly = tmp_vector_polylines.size();
#ifdef PARANOID
            if (nsub_poly <= 1)
            {
              std::ostringstream error_message;
              error_message << "The boundary (" << bound_id
                            << ") was marked to be splitted but\n"
                            << "there are only (" << nsub_poly
                            << ") polylines to represent it.\n";
              throw OomphLibError(error_message.str(),
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
            }
#endif
            // Add the new representation of the polylines (sub-polylines)
            // to represent this boundary
            for (unsigned isub = 0; isub < nsub_poly; isub++)
            {
              unsorted_outer_polyline_pt.push_back(tmp_vector_polylines[isub]);
#ifdef PARANOID
              const unsigned nsvertex = tmp_vector_polylines[isub]->nvertex();
              if (nsvertex == 0)
              {
                std::ostringstream error_message;
                error_message
                  << "The current chunk (" << isub << ") of the polyline with\n"
                  << "boundary id (" << bound_id << ") has no vertices\n";
                throw OomphLibError(error_message.str(),
                                    OOMPH_CURRENT_FUNCTION,
                                    OOMPH_EXCEPTION_LOCATION);
              } // if (nsvertex == 0)
#endif // #ifdef PARANOID
            } // for (isub < nsub_poly)
          } // else if (!boundary_was_splitted(bound_id))
        } // if (nvertex > 0)
      } // for (p < npolylines)
    } // for (i < nouter)

    // Get the number of unsorted polylines
    unsigned nunsorted_outer_polyline = unsorted_outer_polyline_pt.size();
    if (nunsorted_outer_polyline > 0)
    {
      // Now that we have all the new unsorted polylines it is time to sort them
      // so they be all contiguous
      sort_polylines_helper(unsorted_outer_polyline_pt, sorted_outer_curves_pt);

    } // if (nunsorted_outer_polyline > 0)

    // *********************************************************************
    // Step (2.2) Get the internal closed boundaries and check if it is
    // necessary to use a new representation (for example when the boundary
    // was splitted in the distribution process)
    // *********************************************************************

    // Storage for new created polylines, non sorted
    Vector<TriangleMeshPolyLine*> unsorted_internal_closed_polyline_pt;

    // Storing for the polylines on the boundaries
    // The first index is for a set of connected polylines
    // The second index is for a polyline on a set of connected polylines
    Vector<Vector<TriangleMeshPolyLine*>> sorted_internal_closed_curves_pt;

    // Copy the internal closed boundaries to the vector of polylines
    const unsigned ninternal_closed = this->Internal_polygon_pt.size();
    for (unsigned i = 0; i < ninternal_closed; i++)
    {
      const unsigned npolylines = this->Internal_polygon_pt[i]->npolyline();
      for (unsigned p = 0; p < npolylines; p++)
      {
        // Pointer to the current polyline
        TriangleMeshPolyLine* tmp_polyline_pt =
          this->Internal_polygon_pt[i]->polyline_pt(p);
        const unsigned nvertex = tmp_polyline_pt->nvertex();
        if (nvertex > 0)
        {
          // Get the boundary id of the polyline and check if that boundary
          // needs a new representation (for example when the boundary was
          // splitted in the distribution process)
          const unsigned bound_id = tmp_polyline_pt->boundary_id();
          if (!boundary_was_splitted(bound_id))
          {
            unsorted_internal_closed_polyline_pt.push_back(tmp_polyline_pt);
          } // if (!boundary_was_splitted(bound_id))
          else
          {
            // Get the polylines that will represent this boundary
            Vector<TriangleMeshPolyLine*> tmp_vector_polylines =
              boundary_subpolylines(bound_id);
            const unsigned nsub_poly = tmp_vector_polylines.size();
#ifdef PARANOID
            if (nsub_poly <= 1)
            {
              std::ostringstream error_message;
              error_message << "The boundary (" << bound_id
                            << ") was marked to be splitted but\n"
                            << "there are only (" << nsub_poly
                            << ") polylines to represent it.\n";
              throw OomphLibError(error_message.str(),
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
            }
#endif
            // Add the new representation of the polylines (sub-polylines)
            // to represent this boundary
            for (unsigned isub = 0; isub < nsub_poly; isub++)
            {
              unsorted_internal_closed_polyline_pt.push_back(
                tmp_vector_polylines[isub]);
#ifdef PARANOID
              const unsigned nsvertex = tmp_vector_polylines[isub]->nvertex();
              if (nsvertex == 0)
              {
                std::ostringstream error_message;
                error_message
                  << "The current chunk (" << isub << ") of the polyline with\n"
                  << "boundary id (" << bound_id << ") has no vertices\n";
                throw OomphLibError(error_message.str(),
                                    OOMPH_CURRENT_FUNCTION,
                                    OOMPH_EXCEPTION_LOCATION);
              } // if (nsvertex == 0)
#endif // #ifdef PARANOID
            } // for (isub < nsub_poly)
          } // else if (!boundary_was_splitted(bound_id))
        } // if (nvertex > 0)
      } // for (p < npolylines)
    } // for (i < ninternal_closed)

    const unsigned nunsorted_internal_closed_polyline =
      unsorted_internal_closed_polyline_pt.size();

    if (nunsorted_internal_closed_polyline > 0)
    {
      // Now that we have all the new unsorted polylines it is time to sort them
      // so they be all contiguous
      sort_polylines_helper(unsorted_internal_closed_polyline_pt,
                            sorted_internal_closed_curves_pt);
    }

    // *********************************************************************
    // Step (2.3) Get the internal open boundaries and check if it is
    // necessary to use a new representation (for example when the boundary
    // was splitted in the distribution process)
    // *********************************************************************

    // Storage for new created polylines, non sorted
    Vector<TriangleMeshPolyLine*> unsorted_internal_open_polyline_pt;

    // Storing for the polylines on the boundaries
    // The first index is for a set of connected polylines
    // The second index is for a polyline on a set of connected polylines
    Vector<Vector<TriangleMeshPolyLine*>> sorted_internal_open_curves_pt;

    // Copy the internal open boundaries to the vector of polylines
    const unsigned ninternal_open = this->Internal_open_curve_pt.size();
    for (unsigned i = 0; i < ninternal_open; i++)
    {
      const unsigned ncurve_section =
        this->Internal_open_curve_pt[i]->ncurve_section();
      for (unsigned p = 0; p < ncurve_section; p++)
      {
        // Pointer to the current polyline
        TriangleMeshPolyLine* tmp_polyline_pt =
          this->Internal_open_curve_pt[i]->polyline_pt(p);
        const unsigned nvertex = tmp_polyline_pt->nvertex();
        if (nvertex > 0)
        {
          // Get the boundary id of the polyline and check if that boundary
          // needs a new representation (for example when the boundary was
          // splitted in the distribution process)
          const unsigned bound_id = tmp_polyline_pt->boundary_id();
          if (!boundary_was_splitted(bound_id))
          {
            // Only include as internal boundaries those not marked as
            // shared boundaries
            if (!boundary_marked_as_shared_boundary(bound_id, 0))
            {
              unsorted_internal_open_polyline_pt.push_back(tmp_polyline_pt);
            }
          } // if (!boundary_was_splitted(bound_id))
          else
          {
            // Get the polylines that will represent this boundary
            Vector<TriangleMeshPolyLine*> tmp_vector_polylines =
              boundary_subpolylines(bound_id);
            const unsigned nsub_poly = tmp_vector_polylines.size();
#ifdef PARANOID
            if (nsub_poly <= 1)
            {
              std::ostringstream error_message;
              error_message << "The boundary (" << bound_id
                            << ") was marked to be splitted but\n"
                            << "there are only (" << nsub_poly
                            << ") polylines to represent it.\n";
              throw OomphLibError(error_message.str(),
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
            }
#endif
            // Add the new representation of the polylines (sub-polylines)
            // to represent this boundary
            for (unsigned isub = 0; isub < nsub_poly; isub++)
            {
              // Only include as internal boundaries those not marked as
              // shared boundaries
              if (!boundary_marked_as_shared_boundary(bound_id, isub))
              {
                unsorted_internal_open_polyline_pt.push_back(
                  tmp_vector_polylines[isub]);
              }
#ifdef PARANOID
              const unsigned nsvertex = tmp_vector_polylines[isub]->nvertex();
              if (nsvertex == 0)
              {
                std::ostringstream error_message;
                error_message
                  << "The current chunk (" << isub << ") of the polyline with\n"
                  << "boundary id (" << bound_id << ") has no vertices\n";
                throw OomphLibError(error_message.str(),
                                    OOMPH_CURRENT_FUNCTION,
                                    OOMPH_EXCEPTION_LOCATION);
              } // if (nsvertex == 0)
#endif // #ifdef PARANOID
            } // for (isub < nsub_poly)
          } // else if (!boundary_was_splitted(bound_id))
        } // if (nvertex > 0)
      } // for (p < npolylines)
    } // for (i < ninternal_open)

    const unsigned nunsorted_internal_open_polyline =
      unsorted_internal_open_polyline_pt.size();

    if (nunsorted_internal_open_polyline > 0)
    {
      // Now that we have all the new unsorted polylines it is time to sort them
      // so they be all contiguous
      sort_polylines_helper(unsorted_internal_open_polyline_pt,
                            sorted_internal_open_curves_pt);
    }

    // ********************************************************************
    // Step (2.4) Sort the polylines on the shared boundaries
    // ********************************************************************

    // Storage for new created polylines, non sorted
    Vector<TriangleMeshPolyLine*> unsorted_shared_polyline_pt;

    // Special storage for the shared polylines that will be also used
    // to connect with the internal boundaries
    Vector<TriangleMeshPolyLine*> unsorted_shared_to_internal_polyline_pt;

    // Storing for the polylines on the shared boundaries
    // The first index is for a set of connected polylines
    // The second index is for a polyline on a set of connected polylines
    Vector<Vector<TriangleMeshPolyLine*>> sorted_shared_curves_pt;

    // Copy the shared boudaries to the vector of polylines
    const unsigned ncurves = nshared_boundary_curves(my_rank);
    for (unsigned i = 0; i < ncurves; i++)
    {
      const unsigned npolylines = nshared_boundary_polyline(my_rank, i);
      for (unsigned p = 0; p < npolylines; p++)
      {
        const unsigned nvertex =
          shared_boundary_polyline_pt(my_rank, i, p)->nvertex();
        if (nvertex > 0)
        {
          TriangleMeshPolyLine* tmp_shared_poly_pt =
            shared_boundary_polyline_pt(my_rank, i, p);

          // First check if there are shared boundaries overlapping
          // internal boundaries
          if (this->nshared_boundary_overlaps_internal_boundary() > 0)
          {
            // Get the boundary id of the shared polyline
            const unsigned shd_bnd_id = tmp_shared_poly_pt->boundary_id();
            // If the shared polyline is marked as internal boundary
            // then include it in the special storage to look for
            // connection with internal boundaries
            if (this->shared_boundary_overlaps_internal_boundary(shd_bnd_id))
            {
              unsorted_shared_to_internal_polyline_pt.push_back(
                tmp_shared_poly_pt);
            }
          }
          unsorted_shared_polyline_pt.push_back(tmp_shared_poly_pt);
        }
      }
    }

    // Get the total number of shared polylines
    const unsigned nunsorted_shared_polyline =
      unsorted_shared_polyline_pt.size();

    if (nunsorted_shared_polyline > 0)
    {
      // Now that we have all the new unsorted polylines it is time to
      // sort them so they be all contiguous
      sort_polylines_helper(unsorted_shared_polyline_pt,
                            sorted_shared_curves_pt);
    }

    // ********************************************************************
    // Step (3) Join the boundaries (shared, internal and outer to
    // create the new polygons)
    // ********************************************************************

    // Create the set of curves that will be used to create the new polygons
    // Get the total number of curves
    const unsigned nouter_curves = sorted_outer_curves_pt.size();
    const unsigned ninternal_closed_curves =
      sorted_internal_closed_curves_pt.size();
    const unsigned nshared_curves = sorted_shared_curves_pt.size();
    const unsigned ntotal_curves =
      nouter_curves + ninternal_closed_curves + nshared_curves;

    // Add all the polylines to a container
    unsigned counter = 0;
    Vector<Vector<TriangleMeshPolyLine*>> all_curves_pt(ntotal_curves);

    // Add the shared curves first, this ensure the generation of
    // internal polygons defined by the shared boundaries
    for (unsigned i = 0; i < nshared_curves; i++, counter++)
    {
      all_curves_pt[counter] = sorted_shared_curves_pt[i];
    }

    // Add the internal polygons (if any)
    for (unsigned i = 0; i < ninternal_closed_curves; i++, counter++)
    {
      all_curves_pt[counter] = sorted_internal_closed_curves_pt[i];
    }

    // Add the outer polygons
    for (unsigned i = 0; i < nouter_curves; i++, counter++)
    {
      all_curves_pt[counter] = sorted_outer_curves_pt[i];
    }

    // Create the temporary version of the domain by joining the new
    // polylines
    this->create_tmp_polygons_helper(all_curves_pt, polygons_pt);
    // Create the new open curves
    this->create_tmp_open_curves_helper(sorted_internal_open_curves_pt,
                                        unsorted_shared_to_internal_polyline_pt,
                                        open_curves_pt);

    // ********************************************************************
    // Step (4) Create connections among the outer boundaries
    // (intersections with themselves)
    // ********************************************************************

    // After creating the new boundaries representation (polylines)
    // establish the connections of the shared boundaries (with
    // themselves or with the original boundaries). This avoids the
    // multiple definition of vertices in the domain which cause
    // problems when calling Triangle

    this->create_shared_polylines_connections();

    // ------------------------------------------------------------------
    // Compute the new holes information. Those from the
    // extra_holes_coordinates container, and those from the original
    // closed boundaries. Add the holes created by the halo elements
    // adjacent to the shared boundaries

    // The storage for the new holes, get those from the
    // extra_holes_coordinates container and those from the internal
    // closed boundaries that are defined as holes
    Vector<Vector<double>> new_holes_coordinates;

    // Copy the holes (those defined by the original internal closed
    // boundaries and those in the extra holes container)

    // The holes defined by the original internal closed boundaries
    const unsigned n_holes = this->Internal_polygon_pt.size();
    for (unsigned h = 0; h < n_holes; h++)
    {
      Vector<double> hole_coordinates =
        this->Internal_polygon_pt[h]->internal_point();
      // If the closed boundary is a hole, then copy its hole
      if (!hole_coordinates.empty())
      {
        new_holes_coordinates.push_back(hole_coordinates);
      }
    } // for (h < n_holes)

    // Is this the first time we are going to copy the extra holes
    // coordinates
    if (First_time_compute_holes_left_by_halo_elements)
    {
      // The holes in the extra holes container
      const unsigned n_extra_holes = Extra_holes_coordinates.size();
      for (unsigned h = 0; h < n_extra_holes; h++)
      {
        Vector<double> hole_coordinates = Extra_holes_coordinates[h];
        new_holes_coordinates.push_back(hole_coordinates);
      } // for (h < n_extra_holes)

      // Copy the extra holes coordinates
      Original_extra_holes_coordinates = Extra_holes_coordinates;

      // Set the flag to false
      First_time_compute_holes_left_by_halo_elements = false;

    } // if (First_time_compute_holes_left_by_halo_elements)
    else
    {
      // Not the first time, then only copy the original extra holes
      // coordinates
      const unsigned n_original_extra_holes =
        Original_extra_holes_coordinates.size();
      for (unsigned h = 0; h < n_original_extra_holes; h++)
      {
        Vector<double> hole_coordinates = Original_extra_holes_coordinates[h];
        new_holes_coordinates.push_back(hole_coordinates);
      } // for (h < n_original_extra_holes)
    }

    // Add the holes created by the halo elements adjacent to the shared
    // boundaries
    compute_holes_left_by_halo_elements_helper(new_holes_coordinates);

    // Update the holes information, only use the coordinate inside the
    // poylgons that define the new domain
    update_holes_information_helper(polygons_pt, new_holes_coordinates);

    // tachidok Clear the storage by now
    // new_holes_coordinates.clear();

    // Now copy the info. in the extra holes coordinates container
    Extra_holes_coordinates = new_holes_coordinates;

    // Do not delete halo(ed) info., this will be "deleted"
    // automatically by not passing that information to the new adapted
    // mesh. Once the transfer of target areas is performed the halo(ed)
    // information is no longer required
  }

  //======================================================================
  // Take the polylines from the shared boundaries and the boundaries
  // to create polygons
  //======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::create_tmp_polygons_helper(
    Vector<Vector<TriangleMeshPolyLine*>>& polylines_pt,
    Vector<TriangleMeshPolygon*>& polygons_pt)
  {
    // Each vector of polylines (curve) is already sorted, it means that
    // all the polylines on the vector polylines_pt[i] point to the same
    // direction

    // --- Using this fact we should compare the first and last points from
    //     these arrays of polylines (curves) and compare with the others
    //     vectors of polylines (curves) end points
    // --- Once created a closed curve create a polygon

    // The number of curves
    const unsigned ncurves = polylines_pt.size();

    // The number of non sorted curves
    const unsigned nunsorted_curves = ncurves;
    // The number of sorted curves
    unsigned nsorted_curves = 0;

    // Vector to know which ncurve is already done
    std::vector<bool> done_curve(ncurves);

    do
    {
      // The list where to add the curves so that they be contiguous
      std::list<Vector<TriangleMeshPolyLine*>> list_building_polygon_pt;
#ifdef PARANOID
      // Flag to indicate that a root curve was found
      bool root_curve_found = false;
#endif

      // The index for the root_curve (we use it in further iterations as the
      // starting index so we dont need to search in already done curves)
      unsigned root_curve_idx = 0;

      // Get the root curve
      for (unsigned ic = 0; ic < ncurves; ic++)
      {
        if (!done_curve[ic])
        {
          root_curve_idx = ic;
          nsorted_curves++;
#ifdef PARANOID
          root_curve_found = true;
#endif
          done_curve[ic] = true;
          // ... break the loop
          break;
        }
      }

#ifdef PARANOID
      if (!root_curve_found)
      {
        std::stringstream err;
        err << "The root curve to create a polygon from the shared and "
            << "original boundaries was not found!!!\n";
        throw OomphLibError(err.str(),
                            "TriangleMesh::create_tmp_polygons_helper()",
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Get the root curve
      Vector<TriangleMeshPolyLine*> root_curve_pt =
        polylines_pt[root_curve_idx];

      // Add the root curve to the list
      list_building_polygon_pt.push_back(root_curve_pt);

      // Get the initial and final vertices from the root curve
      Vector<double> root_curve_initial_vertex(2);
      Vector<double> root_curve_final_vertex(2);

      // We need to get the number of polylines that compose the root curve
      const unsigned nroot_curve_polyline = root_curve_pt.size();
      // ... and now get the initial and final vertex
      root_curve_pt[0]->initial_vertex_coordinate(root_curve_initial_vertex);
      root_curve_pt[nroot_curve_polyline - 1]->final_vertex_coordinate(
        root_curve_final_vertex);

      // First check if it already create a polygon
      double diff =
        ((root_curve_initial_vertex[0] - root_curve_final_vertex[0]) *
         (root_curve_initial_vertex[0] - root_curve_final_vertex[0])) +
        ((root_curve_initial_vertex[1] - root_curve_final_vertex[1]) *
         (root_curve_initial_vertex[1] - root_curve_final_vertex[1]));
      diff = sqrt(diff);
      if (diff < ToleranceForVertexMismatchInPolygons::Tolerable_error)
      {
        // The polyline already create a Polygon, then create it!!!
        // Create the curve section representation of the current root curve
        Vector<TriangleMeshCurveSection*> curve_section_pt(
          nroot_curve_polyline);

        // Copy the polylines into its curve section representation
        for (unsigned i = 0; i < nroot_curve_polyline; i++)
        {
          curve_section_pt[i] = root_curve_pt[i];
        }

        // ... and create the Polygon
        TriangleMeshPolygon* new_polygon_pt =
          new TriangleMeshPolygon(curve_section_pt);

        // Mark the polygon for deletion (in the destructor)
        this->Free_polygon_pt.insert(new_polygon_pt);

        // Add the polygon to the output polygons
        polygons_pt.push_back(new_polygon_pt);
      } // (diff < ToleranceForVertexMismatchInPolygons::Tolerable_error)
        // when the curve creates a Polygon by itself
      else
      {
        // Flag to continue iterating while curves be added to the left
        // or right of the list of curves
        bool added_curve = false;
#ifdef PARANOID
        // Flag to know if the "loop" finish because a polygon was
        // created or because no more curves can be added to the left or
        // right
        bool polygon_created = false;
#endif
        do
        {
          added_curve = false;
          // If the root curve does not create a closed polygon then add curves
          // to the left or right until the curves create a closed polygon
          for (unsigned ic = root_curve_idx + 1; ic < ncurves; ic++)
          {
            if (!done_curve[ic])
            {
              // Get the current curve
              Vector<TriangleMeshPolyLine*> current_curve_pt = polylines_pt[ic];

              // We need to get the number of polylines that compose the
              // current curve
              const unsigned ncurrent_curve_polyline = current_curve_pt.size();

              // ... and get the initial and final coordinates for the current
              // curve
              Vector<double> current_curve_initial_vertex(2);
              Vector<double> current_curve_final_vertex(2);

              current_curve_pt[0]->initial_vertex_coordinate(
                current_curve_initial_vertex);
              current_curve_pt[ncurrent_curve_polyline - 1]
                ->final_vertex_coordinate(current_curve_final_vertex);

              // ---------------------------------------------------------------
              // Start adding curves to the left or right
              // ---------------------------------------------------------------
              diff = ((current_curve_final_vertex[0] -
                       root_curve_initial_vertex[0]) *
                      (current_curve_final_vertex[0] -
                       root_curve_initial_vertex[0])) +
                     ((current_curve_final_vertex[1] -
                       root_curve_initial_vertex[1]) *
                      (current_curve_final_vertex[1] -
                       root_curve_initial_vertex[1]));
              diff = sqrt(diff);
              // CURRENT curve to the LEFT of the ROOT curve
              if (diff < ToleranceForVertexMismatchInPolygons::Tolerable_error)
              {
                // Add the current curve to the left
                list_building_polygon_pt.push_front(current_curve_pt);
                // Mark the curve as done
                done_curve[ic] = true;
                // Update the initial vertex values
                root_curve_initial_vertex[0] = current_curve_initial_vertex[0];
                root_curve_initial_vertex[1] = current_curve_initial_vertex[1];
                // Increase the number of sorted curves
                nsorted_curves++;
                // Set the flag to indicate that a curve was added to the list
                added_curve = true;
                break;
              }

              diff = ((current_curve_initial_vertex[0] -
                       root_curve_initial_vertex[0]) *
                      (current_curve_initial_vertex[0] -
                       root_curve_initial_vertex[0])) +
                     ((current_curve_initial_vertex[1] -
                       root_curve_initial_vertex[1]) *
                      (current_curve_initial_vertex[1] -
                       root_curve_initial_vertex[1]));
              diff = sqrt(diff);
              // CURRENT curve to the LEFT of the ROOT curve but INVERTED
              if (diff < ToleranceForVertexMismatchInPolygons::Tolerable_error)
              {
                Vector<TriangleMeshPolyLine*> tmp_curve_pt(
                  ncurrent_curve_polyline);
                // Reverse each polyline and back them up
                for (unsigned it = 0; it < ncurrent_curve_polyline; it++)
                {
                  current_curve_pt[it]->reverse();
                  tmp_curve_pt[it] = current_curve_pt[it];
                }
                // Now copy them back but in reverse order
                unsigned count = 0;
                for (int i = ncurrent_curve_polyline - 1; i >= 0; i--, count++)
                {
                  current_curve_pt[count] = tmp_curve_pt[i];
                }
                // Add the current curve to the left
                list_building_polygon_pt.push_front(current_curve_pt);
                // Mark the curve as done
                done_curve[ic] = true;
                // Update the initial vertex values
                root_curve_initial_vertex[0] = current_curve_final_vertex[0];
                root_curve_initial_vertex[1] = current_curve_final_vertex[1];
                // Increase the number of sorted curves
                nsorted_curves++;
                // Set the flag to indicate that a curve was added to the list
                added_curve = true;
                break;
              }

              diff = ((current_curve_initial_vertex[0] -
                       root_curve_final_vertex[0]) *
                      (current_curve_initial_vertex[0] -
                       root_curve_final_vertex[0])) +
                     ((current_curve_initial_vertex[1] -
                       root_curve_final_vertex[1]) *
                      (current_curve_initial_vertex[1] -
                       root_curve_final_vertex[1]));
              diff = sqrt(diff);
              // CURRENT curve to the RIGHT of the ROOT curve
              if (diff < ToleranceForVertexMismatchInPolygons::Tolerable_error)
              {
                // Add the current curve to the right
                list_building_polygon_pt.push_back(current_curve_pt);
                // Mark the curve as done
                done_curve[ic] = true;
                // Update the initial vertex values
                root_curve_final_vertex[0] = current_curve_final_vertex[0];
                root_curve_final_vertex[1] = current_curve_final_vertex[1];
                // Increase the number of sorted curves
                nsorted_curves++;
                // Set the flag to indicate that a curve was added to the list
                added_curve = true;
                break;
              }

              diff =
                ((current_curve_final_vertex[0] - root_curve_final_vertex[0]) *
                 (current_curve_final_vertex[0] - root_curve_final_vertex[0])) +
                ((current_curve_final_vertex[1] - root_curve_final_vertex[1]) *
                 (current_curve_final_vertex[1] - root_curve_final_vertex[1]));
              diff = sqrt(diff);
              // CURRENT curve to the RIGHT of the ROOT curve but INVERTED
              if (diff < ToleranceForVertexMismatchInPolygons::Tolerable_error)
              {
                Vector<TriangleMeshPolyLine*> tmp_curve_pt(
                  ncurrent_curve_polyline);
                // Reverse each polyline and back them up
                for (unsigned it = 0; it < ncurrent_curve_polyline; it++)
                {
                  current_curve_pt[it]->reverse();
                  tmp_curve_pt[it] = current_curve_pt[it];
                }
                // Now copy them back but in reverse order
                unsigned count = 0;
                for (int i = ncurrent_curve_polyline - 1; i >= 0; i--, count++)
                {
                  current_curve_pt[count] = tmp_curve_pt[i];
                }
                // Add the current curve to the right
                list_building_polygon_pt.push_back(current_curve_pt);
                // Mark the curve as done
                done_curve[ic] = true;
                // Update the initial vertex values
                root_curve_final_vertex[0] = current_curve_initial_vertex[0];
                root_curve_final_vertex[1] = current_curve_initial_vertex[1];
                // Increase the number of sorted curves
                nsorted_curves++;
                // Set the flag to indicate that a curve was added to the list
                added_curve = true;
                break;
              }

            } // if (!done_curve[ic])

          } // for (ic < ncurves)

          // After adding a curve check if it is possible to create a polygon
          double diff =
            ((root_curve_initial_vertex[0] - root_curve_final_vertex[0]) *
             (root_curve_initial_vertex[0] - root_curve_final_vertex[0])) +
            ((root_curve_initial_vertex[1] - root_curve_final_vertex[1]) *
             (root_curve_initial_vertex[1] - root_curve_final_vertex[1]));
          diff = sqrt(diff);
          if (diff < ToleranceForVertexMismatchInPolygons::Tolerable_error)
          {
            // If the curves already create a Polygon then go out of the
            // loop and create the Polygon
            added_curve = false;
#ifdef PARANOID
            // Set the flag to indicate that a Polygon has been created
            polygon_created = true;
#endif
          } // (diff <
            // ToleranceForVertexMismatchInPolygons::Tolerable_error)
            // when the curve creates a Polygon by itself

        } while (added_curve);

#ifdef PARANOID
        if (!polygon_created)
        {
          std::stringstream error_message;
          error_message
            << "It was no possible to create a TriangleMeshPolygon with "
            << "the input set of curves\n"
            << "These are the initial and final vertices in the current "
            << "sorted list of\nTriangleMeshPolyLines\n\n";
          Vector<double> init_vertex(2);
          Vector<double> final_vertex(2);
          unsigned icurve = 0;
          for (std::list<Vector<TriangleMeshPolyLine*>>::iterator it =
                 list_building_polygon_pt.begin();
               it != list_building_polygon_pt.end();
               it++, icurve++)
          {
            const unsigned ncurrent_curve_polyline = (*it).size();
            error_message << "TriangleMeshCurve #" << icurve << "\n"
                          << "-----------------------------------\n";
            for (unsigned ip = 0; ip < ncurrent_curve_polyline; ip++)
            {
              Vector<double> init_vertex(2);
              Vector<double> final_vertex(2);
              (*it)[ip]->initial_vertex_coordinate(init_vertex);
              (*it)[ip]->final_vertex_coordinate(final_vertex);
              error_message << "TriangleMeshPolyLine #" << ip << "\n"
                            << "Initial vertex: (" << init_vertex[0] << ","
                            << init_vertex[1] << ")\n"
                            << "Final vertex: (" << final_vertex[0] << ","
                            << final_vertex[1] << ")\n";
            } // for (ip < ncurrent_curve_polyline)
          } // for (it != list_building_polygon_pt.end())

          throw OomphLibError(error_message.str(),
                              "TriangleMesh::create_tmp_polygons_helper()",
                              OOMPH_EXCEPTION_LOCATION);

        } // if (!polygon_created)
#endif

        // Create the polygon after joining the curves
        unsigned ntotal_polylines = 0;
        // Get the total number of polylines
        for (std::list<Vector<TriangleMeshPolyLine*>>::iterator it =
               list_building_polygon_pt.begin();
             it != list_building_polygon_pt.end();
             it++)
        {
          ntotal_polylines += (*it).size();
        }

        // Create the curve section representation of the curves on the list
        Vector<TriangleMeshCurveSection*> curve_section_pt(ntotal_polylines);

        // Copy the polylines into its curve section representation
        unsigned counter = 0;
        for (std::list<Vector<TriangleMeshPolyLine*>>::iterator it =
               list_building_polygon_pt.begin();
             it != list_building_polygon_pt.end();
             it++)
        {
          const unsigned ncurrent_curve_polyline = (*it).size();
          for (unsigned ip = 0; ip < ncurrent_curve_polyline; ip++, counter++)
          {
            curve_section_pt[counter] = (*it)[ip];
          } // for (ip < ncurrent_curve_polyline)
        } // Loop over the list of polylines

        // ... and create the Polygon
        TriangleMeshPolygon* new_polygon_pt =
          new TriangleMeshPolygon(curve_section_pt);

        // Mark the polygon for deletion (in the destructor)
        this->Free_polygon_pt.insert(new_polygon_pt);

        // Add the polygon to the output polygons
        polygons_pt.push_back(new_polygon_pt);

      } // else
        // (diff < ToleranceForVertexMismatchInPolygons::Tolerable_error)

    } while (nsorted_curves < nunsorted_curves);
  }

  //======================================================================
  // Take the polylines from the original open curves and created
  // new temporaly representations of open curves with the bits of
  // original curves not overlapped by shared boundaries
  //======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::create_tmp_open_curves_helper(
    Vector<Vector<TriangleMeshPolyLine*>>& sorted_open_curves_pt,
    Vector<TriangleMeshPolyLine*>& unsorted_shared_to_internal_poly_pt,
    Vector<TriangleMeshOpenCurve*>& open_curves_pt)
  {
    // Here search for the connections of the open curves remaining as
    // open curves with the shared boundaries markes as internal
    const unsigned ninternal_open_curves = sorted_open_curves_pt.size();

    // Once identified the connections created with the new internal
    // boundaries representations add them to the open curves container
    for (unsigned i = 0; i < ninternal_open_curves; i++)
    {
      // Create the curve section representation of the polylines
      const unsigned npoly = sorted_open_curves_pt[i].size();
      Vector<TriangleMeshCurveSection*> tmp_curve_section(npoly);
      for (unsigned j = 0; j < npoly; j++)
      {
        tmp_curve_section[j] = sorted_open_curves_pt[i][j];
      }
      // ... and create the Open Curve
      TriangleMeshOpenCurve* new_open_curve_pt =
        new TriangleMeshOpenCurve(tmp_curve_section);

      // Mark the open curve for deletion (in the destructor)
      this->Free_open_curve_pt.insert(new_open_curve_pt);

      // Add the open curve to the output open curves
      open_curves_pt.push_back(new_open_curve_pt);

    } // (i < ninternal_open_curves)
  }

  //======================================================================
  // Check for any possible connections that the array of sorted
  // nodes have with original boundary nodes, previous shared polyline
  // nodes or with itself polyline nodes. In case that there is a
  // connection, get the boundary id to which connects
  //======================================================================
  template<class ELEMENT>
  const int TriangleMesh<ELEMENT>::check_connections_of_polyline_nodes(
    std::set<FiniteElement*>& element_in_processor_pt,
    const int& root_edge_bnd_id,
    std::map<std::pair<Node*, Node*>, bool>& overlapped_face,
    std::map<unsigned, std::map<Node*, bool>>&
      node_on_bnd_not_overlapped_by_shd_bnd,
    std::list<Node*>& current_polyline_nodes,
    std::map<unsigned, std::list<Node*>>& shared_bnd_id_to_sorted_list_node_pt,
    const unsigned& node_degree,
    Node*& new_node_pt,
    const bool called_from_load_balance)
  {
    // Initialize the flag to return
    int flag_to_return = -1;

    // --------------------------------------------------------------------
    // First try to find a connection with any original boundary (keep
    // in mind the case when internal boundaries may be overlapped by
    // shared boundaries)
    // --------------------------------------------------------------------

    // Check if the shared boundary is overlapping an internal boundary
    bool overlapping_internal_boundary = false;
    // The boundary id overlapped by the current shared boundary
    unsigned internal_overlaping_bnd_id = 0;
    if (root_edge_bnd_id != -1)
    {
      // Set the flat to true
      overlapping_internal_boundary = true;
      // Set the bnd id of the overlapped internal boundary
      internal_overlaping_bnd_id = static_cast<unsigned>(root_edge_bnd_id);
    } // if (root_edge_bnd_id != -1)

    // ---------------------------------------------------------------
    // Check if the connection is with an original boundary by checking
    // if the new node is a boundary node, and it lives in an element
    // that is part of the domain
    // ---------------------------------------------------------------
    if (new_node_pt->is_on_boundary())
    {
      // Flag to indicate if the node lives in a non overlapped boundary
      bool is_node_living_in_non_overlapped_boundary = false;

      // If the node is a boundary node then check in which boundary it
      // is
      const unsigned noriginal_bnd = this->initial_shared_boundary_id();
      for (unsigned bb = 0; bb < noriginal_bnd; bb++)
      {
        // If the shared boundary overlaps an internal boundary it will
        // be indicated by (root_edge_bnd_id != -1), the original
        // internal boundary that overlaps is given by the
        // root_edge_bnd_id value. We skip that original internal
        // boundary because the new node will be obviously ON the
        // internal boundary
        if (overlapping_internal_boundary)
        {
          // Is the node on boundary bb?
          if (new_node_pt->is_on_boundary(bb))
          {
            // If overlaping then check that the boundary is different
            // from the one that is being overlapped, or if overlapped
            // then check that the node is on an edge on the bb
            // boundary not overlapped by a shared boundary
            const bool on_bnd_edge_not_overlapped_by_shd_bnd =
              node_on_bnd_not_overlapped_by_shd_bnd[bb][new_node_pt];
            if (bb != internal_overlaping_bnd_id ||
                ((bb == internal_overlaping_bnd_id) &&
                 (on_bnd_edge_not_overlapped_by_shd_bnd)))
            {
              // Is the node living in a non overlapped boundary
              if (bb != internal_overlaping_bnd_id)
              {
                is_node_living_in_non_overlapped_boundary = true;
              }

              // Now we need to check that the node lies on a boundary
              // that still exist (the elements associated to the
              // boundary may have been removed at the mesh distribution
              // stage). The node may be still marked as a boundary node
              // but the boundary may not have elements associated.

              // Get the number of elements in the boundary
              const unsigned n_bound_ele = this->nboundary_element(bb);
              if (n_bound_ele > 0)
              {
                // Check that node lies on a nonhalo element, those are
                // the elements used to update the domain representation
                for (unsigned e = 0; e < n_bound_ele; e++)
                {
                  // Get the boundary bulk element
                  FiniteElement* bulk_ele_pt = this->boundary_element_pt(bb, e);
                  // Check if the element will be retained, it means it
                  // is a nonhalo element
                  std::set<FiniteElement*>::iterator it =
                    element_in_processor_pt.find(bulk_ele_pt);
                  // If found then check if the node live in the element
                  if (it != element_in_processor_pt.end())
                  {
                    // Found the node in the nonhalo face element
                    bool found_node = false;
                    // Get the face index
                    int face_index = this->face_index_at_boundary(bb, e);
                    // Create the face element
                    FiniteElement* face_ele_pt =
                      new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);
                    // Get the number of nodes in the face element
                    const unsigned n_node_face = face_ele_pt->nnode();
                    // Get the first and last node of the face element
                    Node* first_node_pt = face_ele_pt->node_pt(0);
                    Node* last_node_pt = face_ele_pt->node_pt(n_node_face - 1);
                    // Create the edge with the pair of nodes
                    std::pair<Node*, Node*> tmp_edge =
                      std::make_pair(first_node_pt, last_node_pt);
                    // Check if the face element edge is overlapped by a
                    // shared boundary
                    // Is the face not overlapped?
                    if (!overlapped_face[tmp_edge])
                    {
                      // Look for the node in the current face element
                      for (unsigned n = 0; n < n_node_face; n++)
                      {
                        // Check for every individual node
                        if (face_ele_pt->node_pt(n) == new_node_pt)
                        {
                          found_node = true;
                          break;
                        } // if (face_ele_pt->node_pt(n) == new_node_pt)
                      } // for (n < n_node_face)
                    } // if (!overlapped_face[tmp_edge])
                    // Free the memory of the face element
                    delete face_ele_pt;
                    if (found_node)
                    {
                      // return the first original boundary id found,
                      // does not matter if the node lies on more than
                      // one original boundary (with boundary
                      // elements). This is the original boundary id
                      // that will be used to create the connection
                      flag_to_return = bb;
                      return flag_to_return;
                    } // if (found_node)

                  } // if (it!=element_in_processor_pt.end())

                } // for (e < n_bound_ele)

              } // if (n_bound_ele > 0)

            } // if (bb != internal_overlaping_bnd_id ||
              //     ((bb == internal_overlaping_bnd_id) &&
              //      (on_bnd_edge_not_overlapped_by_shd_bnd)))

          } // if (nod_pt->is_on_boundary(bb))

        } // if (overlapping_internal_boundary)
        else
        {
          // Is the node on boundary bb?
          if (new_node_pt->is_on_boundary(bb))
          {
            // Now we need to check that the node lies on a boundary
            // that still exist (the elements associated to the boundary
            // may have been removed at the mesh distribution
            // stage). The node may be still marked as a boundary node
            // but the boundary may not have elements associated.

            // Get the number of elements in the boundary
            const unsigned n_bound_ele = this->nboundary_element(bb);
            if (n_bound_ele > 0)
            {
              // Check that node lies on a nonhalo element, those are
              // the elements used to update the domain representation
              for (unsigned e = 0; e < n_bound_ele; e++)
              {
                // Get the boundary bulk element
                FiniteElement* bulk_ele_pt = this->boundary_element_pt(bb, e);
                // Check if the element will be retained, it means it is
                // a nonhalo element
                std::set<FiniteElement*>::iterator it =
                  element_in_processor_pt.find(bulk_ele_pt);
                // If found then check if the node live in the element
                if (it != element_in_processor_pt.end())
                {
                  // Found the node in the nonhalo face element
                  bool found_node = false;
                  // Get the face index
                  int face_index = this->face_index_at_boundary(bb, e);
                  // Create the face element
                  FiniteElement* face_ele_pt =
                    new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);
                  // Get the number of nodes in the face element
                  const unsigned n_node_face = face_ele_pt->nnode();
                  // Get the first and last node of the face element
                  Node* first_node_pt = face_ele_pt->node_pt(0);
                  Node* last_node_pt = face_ele_pt->node_pt(n_node_face - 1);
                  // Create the edge with the pair of nodes
                  std::pair<Node*, Node*> tmp_edge =
                    std::make_pair(first_node_pt, last_node_pt);
                  // Check if the face element edge is overlapped by a
                  // shared boundary
                  // Is the face not overlapped?
                  if (!overlapped_face[tmp_edge])
                  {
                    // Look for the node in the current face element
                    for (unsigned n = 0; n < n_node_face; n++)
                    {
                      // Check for every individual node
                      if (face_ele_pt->node_pt(n) == new_node_pt)
                      {
                        found_node = true;
                        break;
                      } // if (face_ele_pt->node_pt(n) == new_node_pt)
                    } // for (n < n_node_face)
                  } // if (!overlapped_face[tmp_edge])
                  // Free the memory of the face element
                  delete face_ele_pt;
                  if (found_node)
                  {
                    // return the first original boundary id found, does
                    // not matter if the node lies on more than one
                    // original boundary (with boundary elements). This
                    // is the original boundary id that will be used to
                    // create the connection
                    flag_to_return = bb;
                    return flag_to_return;
                  } // if (found_node)

                } // if (it!=element_in_processor_pt.end())

              } // for (e < n_bound_ele)

            } // if (n_bound_ele > 0)

          } // if (nod_pt->is_on_boundary(bb))
        } // else if (overlapping_internal_boundary)
      } // for (bb < noriginal_bnd)

      // We will only reach this stage when the node was found to be
      // connected to an original boundary but the element(s) on that
      // boundary where the node should live are not part of the domain.
      // Think in a corner of a triangle which touches the boundary
      // which elements will not be part of the domain

      // We need to break the currently forming polyline
      // flag_to_return = -3;

      // We need to break the currently forming polyline if and only if
      // the boundary(ies) in which the node is living is(are) not an
      // overlapped boundary
      if (!overlapping_internal_boundary)
      {
        // If the boundary(ies) in which the node is living is(are) an
        // overlapped boundary then break the break the formation of the
        // polyline
        flag_to_return = -3;
      }
      else
      {
        // The boundary is overlapped, if the node lives in a non
        // overlapped boundary then we can break the formation of the
        // polyline
        if (is_node_living_in_non_overlapped_boundary)
        {
          flag_to_return = -3;
        } // if (is_node_living_in_non_overlapped_boundar)y

      } // if (!overlapping_internal_boundary)

    } // if (new_node_pt->is_on_boundary())

    // Return inmediately if the connection is with an original boundary
    // whose elements are still part of the domain
    if (flag_to_return >= 0)
    {
      return flag_to_return;
    }

    // ----------------------------------------------------------------------
    // Secondly, if there is not a connection with any original
    // boundary, or if there is connection but with an original boundary
    // whose elements are not part of the domain, then check for
    // connections with previously created shared polylines
    // ----------------------------------------------------------------------
    // Store all the previous shared polylines to which the current
    // found is found to be connected
    Vector<unsigned> candidate_shared_bnd_to_connect;
    // Check for all the previous polylines except the current one
    for (std::map<unsigned, std::list<Node*>>::iterator it =
           shared_bnd_id_to_sorted_list_node_pt.begin();
         it != shared_bnd_id_to_sorted_list_node_pt.end();
         it++)
    {
      // Get the boundary id of the list of nodes that created the
      // polyline (the shared boundary id associated with the list of
      // nodes)
      const unsigned i_bnd_id = (*it).first;
      // Get an iterator pointer to the list of nodes of the shared
      // polyline
      std::list<Node*>::iterator it_list = (*it).second.begin();
      // Get the total number of nodes associated to the boundary
      const unsigned n_nodes = (*it).second.size();
      // Search for connections in the list of nodes
      for (unsigned i = 0; i < n_nodes; i++, it_list++)
      {
        // Is the node already part of any other shared boundary
        if ((*it_list) == new_node_pt)
        {
          // Include the i-th boundary id in the list of candidate
          // shared boundaries to connect
          candidate_shared_bnd_to_connect.push_back(i_bnd_id);
          // Break the look with the i-th shared boundary, check with
          // the others shared boundaries
          break;
        } // if ((*it_list) == new_node_pt)

      } // for (i < nnodes)

    } // Loop over the shared boundaries and associated nodes

    // Get the number of candidate shared boundaries to connect
    const unsigned n_candidate_shared_bnd_to_connect =
      candidate_shared_bnd_to_connect.size();

    // Is there a connection with any previous shared polyline
    if (n_candidate_shared_bnd_to_connect > 0)
    {
      // If called from load balance we do not need to check if the
      // shared boundary is part of the processor since it certanily is,
      // only the shared boundaries that are pare of the processor are
      // used to created connection when creating the new shared
      // boundaries in the load balance rutine
      if (called_from_load_balance)
      {
        return candidate_shared_bnd_to_connect[0];
      }

      // We need to ensure that the shared boundary to which we are
      // connecting is part of the current processor, if none of the
      // found shared bundaries is in the current processor then return
      // the flag for "connection with boundary not in the current
      // processor"

      // Store the shared boundaries associated with the current processor
      Vector<unsigned> shared_bound_in_this_proc;

      // Get the shared boundaries associated with the current processor
      shared_boundaries_in_this_processor(shared_bound_in_this_proc);

      // If any of the candidate shared boundaries to connect is in the
      // current processor then return that shared boundary id

      // The number of shared boundaries in the current processor
      const unsigned n_shared_bound_in_this_proc =
        shared_bound_in_this_proc.size();

      // Loop over the candidate shared boundaries to connect
      for (unsigned i = 0; i < n_candidate_shared_bnd_to_connect; i++)
      {
        // Get the i-th candidate shared boundary to connect
        const unsigned i_candidate_shared_bnd =
          candidate_shared_bnd_to_connect[i];

        // Loop over the shared boundaries in the current processor
        for (unsigned j = 0; j < n_shared_bound_in_this_proc; j++)
        {
          // Is the candidate boundary a shared boundary in this processor?
          if (i_candidate_shared_bnd == shared_bound_in_this_proc[j])
          {
            // Return the candidate shared boundary
            flag_to_return = i_candidate_shared_bnd;
            return flag_to_return;
          } // The candidate shared boundary is a boundary in the
            // current processor

        } // for (j < n_shared_bound_in_this_proc)

      } // for (i < n_candidate_shared_bnd_to_connect)

      // If non of the candidate shared boundaries to connect is in the
      // current processor the mark that we need to stop the addition of
      // vertices at this side of the polyline
      flag_to_return = -3;

    } // if (n_candidate_shared_bnd_to_connect > 0)

    // Return inmediately if the connection is with a previuos shared
    // boundary
    if (flag_to_return >= 0)
    {
      return flag_to_return;
    }

    // ------------------------------------------------------------------
    // Finally,check for connections with the same polyline (the shared
    // boundary that is being constructed). We are trying to avoid loops
    // or connections with the same shared boundary that is why this is
    // checked at the end
    // ------------------------------------------------------------------
    unsigned nrepeated = 0;
    for (std::list<Node*>::iterator it_list = current_polyline_nodes.begin();
         it_list != current_polyline_nodes.end();
         it_list++)
    {
      // There must be at least one repeated node (the one that we have
      // just added, and it should be the first or last node)
      if ((*it_list) == new_node_pt)
      {
        nrepeated++;
      }
    }
    // If the number of repeated nodes is greater than one then the
    // polyline has a connection with itself
    if (nrepeated > 1)
    {
      // Return the flag value to indicate connection with itself, we
      // can not return the boundary id of the current polyline since it
      // has not been already assigned
      flag_to_return = -2;
    }

    // If there is no connection at all check the degree of the node, if
    // it is greater than 2 then return the flag to stop adding nodes
    // after this one
    if (node_degree > 2)
    {
      flag_to_return = -3;
    }

    // Return the flag
    return flag_to_return;
  }

  //======================================================================
  // Establish the connections of the polylines previously
  // marked as having connections. This connections were created in the
  // function TriangleMesh::create_polylines_from_halo_elements_helper().
  // In case of doing load balancing the connections were created by the
  // function RefineableTriangleMesh::create_new_shared_boundaries()
  // ======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::create_shared_polylines_connections()
  {
    // Get the rank of the current processor
    const unsigned my_rank = this->communicator_pt()->my_rank();

    // Get the shared curves associated with this processor
    Vector<Vector<TriangleMeshPolyLine*>> shared_curves_pt =
      this->Shared_boundary_polyline_pt[my_rank];

    // Loop through the shared boundaries on the current processor and
    // check if they are marked to create a connection
    const unsigned ncurves = shared_curves_pt.size();
    for (unsigned icurve = 0; icurve < ncurves; icurve++)
    {
      // Get the number of polylines in the current shared curve
      const unsigned npoly = shared_curves_pt[icurve].size();
      for (unsigned ipoly = 0; ipoly < npoly; ipoly++)
      {
        // Get the polyline representation of the shared boundary
        TriangleMeshPolyLine* shd_poly_pt = shared_curves_pt[icurve][ipoly];

        // Get the boundary id of the current polyline
        const unsigned bound_id = shd_poly_pt->boundary_id();

        // Is the left vertex connected
        const bool is_connected_to_the_left =
          shd_poly_pt->is_initial_vertex_connected();

        // Is the right vertex connected
        const bool is_connected_to_the_right =
          shd_poly_pt->is_final_vertex_connected();

        // -----------------------------------------------------------------
        // If there is a connection at one of the ends we need to
        // establish that connection
        if (is_connected_to_the_left || is_connected_to_the_right)
        {
          // Now get the new left and right vertices of the shared
          // polyline
          const unsigned n_vertex = shd_poly_pt->nvertex();

          // Now get the polylines to where the current shared boundary is
          // connected and create the connections

          // --------------------------------------------------------------
          // Connection to the left
          if (is_connected_to_the_left)
          {
            // Get the unsigned version of the bound id to connect to
            // the left
            const unsigned uconnection_to_the_left =
              shd_poly_pt->initial_vertex_connected_bnd_id();

            // The pointer to the boundary to connect
            TriangleMeshPolyLine* poly_to_connect_pt = 0;

            // Flag to indicate we are trying to connect to an split
            // boundary
            bool connecting_to_an_split_boundary = false;

            // Flag to indicate we are trying to connecto to an internal
            // boundary that is overlaped by a shared boundary
            bool connecting_to_an_overlaped_boundary = false;

            // Check if the connection is with itself
            if (uconnection_to_the_left == bound_id)
            {
              // Set the pointer to the polyline to connect
              poly_to_connect_pt = shd_poly_pt;
            }
            else
            {
              // Get the initial shared boundary ids
              const unsigned initial_shd_bnd_id = initial_shared_boundary_id();
              // Check if the boundary to connect is a shared polyline
              if (uconnection_to_the_left >= initial_shd_bnd_id)
              {
                // Get the polyline pointer representing the destination
                // boundary
                poly_to_connect_pt =
                  boundary_polyline_pt(uconnection_to_the_left);
              } // if (uconnection_to_the_left >= initial_shd_bnd_id)
              else
              {
                // If we are going to connect to an original boundary
                // verify if the boundary was splitted during the
                // distribution process to consider all the chunks
                // (sub-polylines) of the boundary
                if (boundary_was_splitted(uconnection_to_the_left))
                {
                  connecting_to_an_split_boundary = true;
                } // if (boundary_was_splitted(uconnection_to_the_left))

                // If we are going to connect to an original boundary
                // verify if the boundary, or any of its chunks is
                // marked to be overlapped by a shared boundary, if that
                // is the case we first check for connections in the
                // shared boundary that overlaps the internal boundary,
                // or the chunks, and then check for connections in the
                // original boundary
                if (connecting_to_an_split_boundary)
                {
                  // Get the number of chucks that represent the
                  // destination boundary
                  const unsigned n_sub_poly =
                    nboundary_subpolylines(uconnection_to_the_left);
                  // Now loop over the chunks of the destination
                  // boundary and if any of them is marked to be
                  // overlaped by a shared boundary then set the flag
                  // and break the loop
                  for (unsigned ii = 0; ii < n_sub_poly; ii++)
                  {
                    if (boundary_marked_as_shared_boundary(
                          uconnection_to_the_left, ii))
                    {
                      // Mark the boundary as being overlaped by a
                      // shared boundary
                      connecting_to_an_overlaped_boundary = true;
                      // Break, no need to look for more overlapings
                      break;
                    } // if (boundary_marked_as_shared_boundary(...))
                  } // for (ii < n_sub_poly)
                } // if (connecting_to_an_split_boundary)
                else
                {
                  // If not connecting to an split boundary then check
                  // if the whole destination boundary is overlaped by
                  // an internal boundary
                  if (boundary_marked_as_shared_boundary(
                        uconnection_to_the_left, 0))
                  {
                    // Mark the boundary as being overlaped by a shared
                    // boundary
                    connecting_to_an_overlaped_boundary = true;
                  } // if (boundary_marked_as_shared_boundary(...))
                } // else if (connecting_to_an_split_boundary)

                // If we are connecting neither to an split boundary nor
                // an overlaped boundary then get the pointer to the
                // original boundary
                if (!(connecting_to_an_split_boundary ||
                      connecting_to_an_overlaped_boundary))
                {
                  // Get the polyline pointer representing the
                  // destination boundary
                  poly_to_connect_pt =
                    boundary_polyline_pt(uconnection_to_the_left);
                } // else if (NOT split, NOT overlaped)
              } // else if (uconnection_to_the_left >= initial_shd_bnd_id)

            } // else if (uconnection_to_the_left == bound_id)

#ifdef PARANOID
            // If we are not connecting to an original boundary
            // (connecting to the same shared boundary or to another
            // shared boundary) then the boundary should not be marked
            // as split
            if (!connecting_to_an_split_boundary)
            {
              if (boundary_was_splitted(uconnection_to_the_left))
              {
                std::stringstream error;
                error
                  << "The current shared boundary (" << bound_id << ") was "
                  << "marked to have a connection\nto the left with the "
                  << "boundary (" << uconnection_to_the_left << ").\n"
                  << "The problem is that the destination boundary (possibly\n"
                  << "another shared boundary) is marked to be split\n"
                  << "There should not be split shared boundaries\n\n";
                throw OomphLibError(
                  error.str(),
                  "TriangleMesh::create_shared_polylines_connections()",
                  OOMPH_EXCEPTION_LOCATION);
              }
            } // if (!connecting_to_an_split_boundary)
#endif

            // Now look for the vertex number on the destination
            // boundary(ies) -- in case that the boundary was split ---

            // Do not check for same orientation, that was previously
            // worked by interchanging the connections boundaries (if
            // necessary)

            // Get the left vertex in the shared boundary
            Vector<double> shd_bnd_left_vertex =
              shd_poly_pt->vertex_coordinate(0);

            // If the boundary was not split then ...
            if (!connecting_to_an_split_boundary)
            {
              // ... check if the boundary is marked to be overlaped by
              // a shared boundary
              if (!connecting_to_an_overlaped_boundary)
              {
                // If that is not the case then we can safely look for
                // the vertex number on the destination boundar
                unsigned vertex_index = 0;

                const bool found_vertex_index =
                  get_connected_vertex_number_on_destination_polyline(
                    poly_to_connect_pt, shd_bnd_left_vertex, vertex_index);

                // If we could not find the vertex index to connect then
                // we are in trouble
                if (!found_vertex_index)
                {
                  std::stringstream error;
                  error
                    << "The current shared boundary (" << bound_id << ") was "
                    << "marked to have a connection\nto the left with the "
                    << "boundary (" << uconnection_to_the_left << ").\n"
                    << "The problem is that the left vertex of the current\n"
                    << "shared boundary is not in the list of vertices of the\n"
                    << "boundary to connect.\n\n"
                    << "This is the left vertex of the current shared "
                       "boundary\n"
                    << "Left vertex: (" << shd_bnd_left_vertex[0] << ", "
                    << shd_bnd_left_vertex[1] << ")\n\n"
                    << "This is the list of vertices on the destination "
                    << "boundary\n";
                  const unsigned n_v = poly_to_connect_pt->nvertex();
                  for (unsigned i = 0; i < n_v; i++)
                  {
                    Vector<double> cvertex =
                      poly_to_connect_pt->vertex_coordinate(i);
                    error << "Vertex #" << i << ": (" << cvertex[0] << ", "
                          << cvertex[1] << ")\n";
                  }
                  throw OomphLibError(
                    error.str(),
                    "TriangleMesh::create_shared_polylines_connections()",
                    OOMPH_EXCEPTION_LOCATION);
                } // if (!found_vertex_index)

                // Create the connection, the left vertex of the current
                // shared boundary is connected with the vertex_index-th
                // vertex on the destination boundary
                shd_poly_pt->connect_initial_vertex_to_polyline(
                  poly_to_connect_pt, vertex_index);

              } // if (!connecting_to_an_overlaped_boundary)
              else
              {
                // If the boundary is marked to be overlaped by a shared
                // boundary then get that shared boundary and look for
                // the connection in that boundary

                // The vertex where to store the index to connect
                unsigned vertex_index = 0;
                // A flag to indicate if the connection was found
                bool found_vertex_index = false;

                // Get the shared boundary id that is overlaping the
                // internal boundary
                Vector<unsigned> dst_shd_bnd_ids;
                get_shared_boundaries_overlapping_internal_boundary(
                  uconnection_to_the_left, dst_shd_bnd_ids);

                // Get the number of shared polylines that were found to
                // overlap the internal boundary
                const unsigned n_shd_bnd_overlap_int_bnd =
                  dst_shd_bnd_ids.size();

                // Loop over the shared boundaries that overlap the
                // internal boundary and look for the vertex to connect
                for (unsigned ss = 0; ss < n_shd_bnd_overlap_int_bnd; ss++)
                {
                  // Get the shared polyline
                  const unsigned new_connection_to_the_left =
                    dst_shd_bnd_ids[ss];

                  // Get the shared polyline that is overlaping the
                  // internal boundary
                  poly_to_connect_pt =
                    boundary_polyline_pt(new_connection_to_the_left);

                  if (poly_to_connect_pt != 0)
                  {
                    // Look for the vertex number in the destination
                    // shared polyline
                    found_vertex_index =
                      get_connected_vertex_number_on_destination_polyline(
                        poly_to_connect_pt, shd_bnd_left_vertex, vertex_index);
                  } // if (poly_to_connect_pt!=0)

                  // If we have found the vertex to connect then
                  // break the loop
                  if (found_vertex_index)
                  {
                    break;
                  } // if (found_vertex_index)

                } // for (ss < n_shd_bnd_overlaping_int_bnd)

#ifdef PARANOID
                // If we could not find the vertex index to connect then
                // we are in trouble
                if (!found_vertex_index)
                {
                  std::stringstream error;
                  error
                    << "The current shared boundary (" << bound_id << ") was "
                    << "marked to have a connection\nto the left with the "
                    << "boundary (" << uconnection_to_the_left << ").\n"
                    << "This last boundary is marked to be overlaped by "
                    << "shared boundaries\n"
                    << "The problem is that the left vertex of the current\n"
                    << "shared boundary is not in the list of vertices of the\n"
                    << "boundary to connect.\n\n"
                    << "This is the left vertex of the current shared "
                       "boundary\n"
                    << "Left vertex: (" << shd_bnd_left_vertex[0] << ", "
                    << shd_bnd_left_vertex[1] << ")\n\n"
                    << "This is the list of vertices on the destination "
                    << "boundary\n";
                  Vector<unsigned> dst_shd_bnd_ids;
                  get_shared_boundaries_overlapping_internal_boundary(
                    uconnection_to_the_left, dst_shd_bnd_ids);
                  const unsigned n_shd_bnd_overlap_int_bnd =
                    dst_shd_bnd_ids.size();
                  for (unsigned ss = 0; ss < n_shd_bnd_overlap_int_bnd; ss++)
                  {
                    const unsigned new_connection_to_the_left =
                      dst_shd_bnd_ids[ss];
                    poly_to_connect_pt =
                      boundary_polyline_pt(new_connection_to_the_left);
                    if (poly_to_connect_pt != 0)
                    {
                      const unsigned shd_bnd_id_overlap =
                        poly_to_connect_pt->boundary_id();
                      error << "Shared boundary id(" << shd_bnd_id_overlap
                            << ")\n";
                      const unsigned n_v = poly_to_connect_pt->nvertex();
                      for (unsigned i = 0; i < n_v; i++)
                      {
                        Vector<double> cvertex =
                          poly_to_connect_pt->vertex_coordinate(i);
                        error << "Vertex #" << i << ": (" << cvertex[0] << ", "
                              << cvertex[1] << ")\n";
                      }
                    } // if (poly_to_connect_pt != 0)
                  } // for (ss < n_shd_bnd_overlap_int_bnd)

                  throw OomphLibError(
                    error.str(),
                    "TriangleMesh::create_shared_polylines_connections()",
                    OOMPH_EXCEPTION_LOCATION);

                } // if (!found_vertex_index)
#endif

                // Create the connection, the left vertex of the current
                // shared boundary is connected with the vertex_index-th
                // vertex on the destination boundary
                shd_poly_pt->connect_initial_vertex_to_polyline(
                  poly_to_connect_pt, vertex_index);

              } // else if (!connecting_to_an_overlaped_boundary)

            } // if (!connecting_to_an_split_boundary)
            else
            {
              // If the boundary was split then we need to look for the
              // vertex in the sub-polylines

              // Get the sub-polylines vector
              Vector<TriangleMeshPolyLine*> tmp_vector_subpolylines =
                boundary_subpolylines(uconnection_to_the_left);

              // Get the number of sub-polylines
              const unsigned nsub_poly = tmp_vector_subpolylines.size();
#ifdef PARANOID
              if (nsub_poly <= 1)
              {
                std::ostringstream error_message;
                error_message
                  << "The boundary (" << uconnection_to_the_left << ") was "
                  << "marked to be splitted but\n"
                  << "there are only (" << nsub_poly << ") polylines to "
                  << "represent it.\n";
                throw OomphLibError(
                  error_message.str(),
                  "TriangleMesh::create_shared_polylines_connections()",
                  OOMPH_EXCEPTION_LOCATION);
              } // if (nsub_poly <= 1)
#endif
              // We need to check if the boundary is marked to be
              // overlaped by an internal boundary, if that is the case
              // we need to check for each indivual subpolyline, and for
              // those overlaped by a shared polyline look for the
              // vertex in the shared polyline representation instead of
              // the original subpolyline

              // ... check if the boundary is marked to be overlaped by
              // a shared boundary
              if (!connecting_to_an_overlaped_boundary)
              {
                // We can work without checking the subpolylines
                // individually

                // The vertex where to store the index to connect
                unsigned vertex_index = 0;
                // The subpoly number to connect
                unsigned sub_poly_to_connect = 0;
                // A flag to indicate if the connection was found
                bool found_vertex_index = false;

                // Look for the vertex number to connect on each of the
                // subpolyines
                for (unsigned isub = 0; isub < nsub_poly; isub++)
                {
                  // Assign the pointer to the sub-polyline
                  poly_to_connect_pt = tmp_vector_subpolylines[isub];
                  // Search for the vertex in the current sub-polyline
                  found_vertex_index =
                    get_connected_vertex_number_on_destination_polyline(
                      poly_to_connect_pt, shd_bnd_left_vertex, vertex_index);
                  // If we have found the vertex to connect then break the
                  // loop
                  if (found_vertex_index)
                  {
                    // But first save the subpoly number (chunk), that
                    // will be used to perform the connection
                    sub_poly_to_connect = isub;
                    break;
                  } // if (found_vertex_index)
                } // for (isub < nsub_poly)

#ifdef PARANOID
                // If we could not find the vertex index to connect then
                // we are in trouble
                if (!found_vertex_index)
                {
                  std::stringstream error;
                  error
                    << "The current shared boundary (" << bound_id << ") was "
                    << "marked to have a connection\nto the left with the "
                    << "boundary (" << uconnection_to_the_left << ").\n"
                    << "The problem is that the left vertex of the current\n"
                    << "shared boundary is not in the list of vertices of any\n"
                    << "of the sub polylines that represent the boundary to\n"
                    << "connect.\n\n"
                    << "This is the left vertex of the current shared "
                       "boundary\n"
                    << "Left vertex: (" << shd_bnd_left_vertex[0] << ", "
                    << shd_bnd_left_vertex[1] << ")\n\n"
                    << "This is the list of vertices on the destination "
                    << "boundary\n";
                  for (unsigned p = 0; p < nsub_poly; p++)
                  {
                    error << "Subpolyline #(" << p << ")\n";
                    poly_to_connect_pt = tmp_vector_subpolylines[p];
                    const unsigned n_v = poly_to_connect_pt->nvertex();
                    for (unsigned i = 0; i < n_v; i++)
                    {
                      Vector<double> cvertex =
                        poly_to_connect_pt->vertex_coordinate(i);
                      error << "Vertex #" << i << ": (" << cvertex[0] << ", "
                            << cvertex[1] << ")\n";
                    }
                  } // for (p < nsub_poly)
                  throw OomphLibError(
                    error.str(),
                    "TriangleMesh::create_shared_polylines_connections()",
                    OOMPH_EXCEPTION_LOCATION);
                } // if (!found_vertex_index)
#endif

                // Create the connection, the left vertex of the current
                // shared boundary is connected with the vertex_index-th
                // vertex of sub_poly_to_connect-th subpolyline of the
                // destination boundary
                shd_poly_pt->connect_initial_vertex_to_polyline(
                  poly_to_connect_pt, vertex_index, sub_poly_to_connect);

              } // if (!connecting_to_an_overlaped_boundary)
              else
              {
                // We first look on the shared boundaries that overlap
                // the internal boundaries and the look for the
                // sub-polylines that are not marked as being overlaped
                // by shared boundaries

                // The vertex where to store the index to connect
                unsigned vertex_index = 0;
                // The subpoly number to connect
                unsigned sub_poly_to_connect = 0;
                // A flag to indicate if the connection was found
                bool found_vertex_index = false;

                // Get the shared boundaries id that are overlaping the
                // internal boundary
                Vector<unsigned> dst_shd_bnd_ids;
                get_shared_boundaries_overlapping_internal_boundary(
                  uconnection_to_the_left, dst_shd_bnd_ids);

                // Get the number of shared polylines that were found to
                // overlap the internal boundary
                const unsigned n_shd_bnd_overlap_int_bnd =
                  dst_shd_bnd_ids.size();

                // Loop over the shared boundaries that overlap the
                // internal boundary and look for the vertex to connect
                for (unsigned ss = 0; ss < n_shd_bnd_overlap_int_bnd; ss++)
                {
                  // Get the shared polyline
                  const unsigned new_connection_to_the_left =
                    dst_shd_bnd_ids[ss];

                  // Make sure that the destination polyline is not the
                  // same as the current shared polyline
                  if (bound_id != new_connection_to_the_left)
                  {
                    // Get the shared polyline that is overlaping the
                    // internal boundary
                    poly_to_connect_pt =
                      boundary_polyline_pt(new_connection_to_the_left);

                    if (poly_to_connect_pt != 0)
                    {
                      // Look for the vertex number in the destination
                      // shared polyline
                      found_vertex_index =
                        get_connected_vertex_number_on_destination_polyline(
                          poly_to_connect_pt,
                          shd_bnd_left_vertex,
                          vertex_index);
                    } // if (poly_to_connect_pt != 0)

                    // If we have found the vertex to connect then
                    // break the loop
                    if (found_vertex_index)
                    {
                      break;
                    } // if (found_vertex_index)

                  } // if (bound_id != new_connection_to_the_left)

                } // for (ss < n_shd_bnd_overlaping_int_bnd)

                // If we have not yet found the vertex then look for it
                // in the sub-polylines that are not overlaped by shared
                // boundaries
                if (!found_vertex_index)
                {
                  // Look for the vertex number to connect on each of
                  // the subpolyines
                  for (unsigned isub = 0; isub < nsub_poly; isub++)
                  {
                    // Only work with those sub-polylines that are not
                    // overlaped by shared boundaries
                    if (!boundary_marked_as_shared_boundary(
                          uconnection_to_the_left, isub))
                    {
                      // Assign the pointer to the sub-polyline
                      poly_to_connect_pt = tmp_vector_subpolylines[isub];
                      // Search for the vertex in the current sub-polyline
                      found_vertex_index =
                        get_connected_vertex_number_on_destination_polyline(
                          poly_to_connect_pt,
                          shd_bnd_left_vertex,
                          vertex_index);
                      // If we have found the vertex to connect then break the
                      // loop
                      if (found_vertex_index)
                      {
                        // But first save the subpoly number (chunk), that
                        // will be used to perform the connection
                        sub_poly_to_connect = isub;
                        break;
                      } // if (found_vertex_index)

                    } // if (not overlaped by shared boundary)

                  } // for (isub < nsub_poly)

                } // if (!found_vertex_index)

#ifdef PARANOID
                // If we could not find the vertex index to connect then
                // we are in trouble
                if (!found_vertex_index)
                {
                  std::stringstream error;
                  error
                    << "The current shared boundary (" << bound_id << ") was "
                    << "marked to have a connection\nto the left with the "
                    << "boundary (" << uconnection_to_the_left << ").\n"
                    << "This last boundary is marked to be overlaped by "
                    << "shared boundaries\n"
                    << "The problem is that the left vertex of the current\n"
                    << "shared boundary is not in the list of vertices of "
                    << "the\nboundary to connect.\n\n"
                    << "This is the left vertex of the current shared "
                    << "boundary\n"
                    << "Left vertex: (" << shd_bnd_left_vertex[0] << ", "
                    << shd_bnd_left_vertex[1] << ")\n\n"
                    << "This is the list of vertices on the destination "
                    << "boundary (only those subpolylines not marked as "
                    << "overlaped by\nshared boundaries)\n";
                  for (unsigned p = 0; p < nsub_poly; p++)
                  {
                    if (!boundary_marked_as_shared_boundary(
                          uconnection_to_the_left, p))
                    {
                      error << "Subpolyline #(" << p << ")\n";
                      poly_to_connect_pt = tmp_vector_subpolylines[p];
                      const unsigned n_v = poly_to_connect_pt->nvertex();
                      for (unsigned i = 0; i < n_v; i++)
                      {
                        Vector<double> cvertex =
                          poly_to_connect_pt->vertex_coordinate(i);
                        error << "Vertex #" << i << ": (" << cvertex[0] << ", "
                              << cvertex[1] << ")\n";
                      }
                    } // Not marked as overlaped
                  } // for (p < nsub_poly)
                  error << "\nThis is the list of vertices of the shared "
                        << "polylines that overlap\nthe internal "
                        << "boundary\n";
                  Vector<unsigned> dst_shd_bnd_ids;
                  get_shared_boundaries_overlapping_internal_boundary(
                    uconnection_to_the_left, dst_shd_bnd_ids);
                  const unsigned n_shd_bnd_overlap_int_bnd =
                    dst_shd_bnd_ids.size();
                  for (unsigned ss = 0; ss < n_shd_bnd_overlap_int_bnd; ss++)
                  {
                    const unsigned new_connection_to_the_left =
                      dst_shd_bnd_ids[ss];
                    poly_to_connect_pt =
                      boundary_polyline_pt(new_connection_to_the_left);
                    if (poly_to_connect_pt != 0)
                    {
                      const unsigned shd_bnd_id_overlap =
                        poly_to_connect_pt->boundary_id();
                      error << "Shared boundary id(" << shd_bnd_id_overlap
                            << ")\n";
                      const unsigned n_v = poly_to_connect_pt->nvertex();
                      for (unsigned i = 0; i < n_v; i++)
                      {
                        Vector<double> cvertex =
                          poly_to_connect_pt->vertex_coordinate(i);
                        error << "Vertex #" << i << ": (" << cvertex[0] << ", "
                              << cvertex[1] << ")\n";
                      }
                    } // if (poly_to_connect_pt != 0)
                  } // for (ss < n_shd_bnd_overlap_int_bnd)

                  throw OomphLibError(
                    error.str(),
                    "TriangleMesh::create_shared_polylines_connections()",
                    OOMPH_EXCEPTION_LOCATION);
                } // if (!found_vertex_index)
#endif

                // Create the connection, the left vertex of the current
                // shared boundary is connected with the vertex_index-th
                // vertex of sub_poly_to_connect-th subpolyline of the
                // destination boundary
                shd_poly_pt->connect_initial_vertex_to_polyline(
                  poly_to_connect_pt, vertex_index, sub_poly_to_connect);

              } // else if (!connecting_to_an_overlaped_boundary)

            } // else if (!connecting_to_an_split_boundary)

          } // if (connection_to_the_left != -1)

          // --------------------------------------------------------------
          // Connection to the right
          if (is_connected_to_the_right)
          {
            // Get the unsigned version of the bound id to connect to
            // the right
            const unsigned uconnection_to_the_right =
              shd_poly_pt->final_vertex_connected_bnd_id();

            // The pointer to the boundary to connect
            TriangleMeshPolyLine* poly_to_connect_pt = 0;

            // Flag to indicate we are trying to connect to an split
            // boundary
            bool connecting_to_an_split_boundary = false;

            // Flag to indicate we are trying to connecto to an internal
            // boundary that is overlaped by a shared boundary
            bool connecting_to_an_overlaped_boundary = false;

            // Check if the connection is with itself
            if (uconnection_to_the_right == bound_id)
            {
              // Set the pointer to the polyline to connect
              poly_to_connect_pt = shd_poly_pt;
            }
            else
            {
              // Get the initial shared boundary ids
              const unsigned initial_shd_bnd_id = initial_shared_boundary_id();
              // Check if the boundary to connect is a shared polyline
              if (uconnection_to_the_right >= initial_shd_bnd_id)
              {
                // Get the polyline pointer representing the destination
                // boundary
                poly_to_connect_pt =
                  boundary_polyline_pt(uconnection_to_the_right);
              } // if (uconnection_to_the_left >= initial_shd_bnd_id)
              else
              {
                // If we are going to connect to an original boundary
                // verify if the boundary was splitted during the
                // distribution process to consider all the chunks
                // (sub-polylines) of the boundary
                if (boundary_was_splitted(uconnection_to_the_right))
                {
                  connecting_to_an_split_boundary = true;
                } // if (boundary_was_splitted(uconnection_to_the_right))

                // If we are going to connect to an original boundary
                // verify if the boundary, or any of its chunks is
                // marked to be overlapped by a shared boundary, if that
                // is the case we first check for connections in the
                // shared boundary that overlaps the internal boundary,
                // or the chunks, and then check for connections in the
                // original boundary
                if (connecting_to_an_split_boundary)
                {
                  // Get the number of chucks that represent the
                  // destination boundary
                  const unsigned n_sub_poly =
                    nboundary_subpolylines(uconnection_to_the_right);
                  // Now loop over the chunks of the destination
                  // boundary and if any of them is marked to be
                  // overlaped by a shared boundary then set the flag
                  // and break the loop
                  for (unsigned ii = 0; ii < n_sub_poly; ii++)
                  {
                    if (boundary_marked_as_shared_boundary(
                          uconnection_to_the_right, ii))
                    {
                      // Mark the boundary as being overlaped by a
                      // shared boundary
                      connecting_to_an_overlaped_boundary = true;
                      // Break, no need to look for more overlapings
                      break;
                    } // if (boundary_marked_as_shared_boundary(...))
                  } // for (ii < n_sub_poly)
                } // if (connecting_to_an_split_boundary)
                else
                {
                  // If not connecting to an split boundary then check
                  // if the whole destination boundary is overlaped by
                  // an internal boundary
                  if (boundary_marked_as_shared_boundary(
                        uconnection_to_the_right, 0))
                  {
                    // Mark the boundary as being overlaped by a shared
                    // boundary
                    connecting_to_an_overlaped_boundary = true;
                  } // if (boundary_marked_as_shared_boundary(...))
                } // else if (connecting_to_an_split_boundary)

                // If we are connecting neither to an split boundary nor
                // an overlaped boundary then get the pointer to the
                // original boundary
                if (!(connecting_to_an_split_boundary ||
                      connecting_to_an_overlaped_boundary))
                {
                  // Get the polyline pointer representing the
                  // destination boundary
                  poly_to_connect_pt =
                    boundary_polyline_pt(uconnection_to_the_right);
                } // else if (NOT split, NOT overlaped)
              } // else if (uconnection_to_the_right >= initial_shd_bnd_id)

            } // else if (uconnection_to_the_right == bound_id)

#ifdef PARANOID
            // If we are not connecting to an original boundary
            // (connecting to the same shared boundary or to another
            // shared boundary) then the boundary should not be marked
            // as split
            if (!connecting_to_an_split_boundary)
            {
              if (boundary_was_splitted(uconnection_to_the_right))
              {
                std::stringstream error;
                error
                  << "The current shared boundary (" << bound_id << ") was "
                  << "marked to have a connection\nto the right with the "
                  << "boundary (" << uconnection_to_the_right << ").\n"
                  << "The problem is that the destination boundary (possibly\n"
                  << "another shared boundary) is marked to be split\n"
                  << "There should not be split shared boundaries\n\n";
                throw OomphLibError(
                  error.str(),
                  "TriangleMesh::create_shared_polylines_connections()",
                  OOMPH_EXCEPTION_LOCATION);
              }
            } // if (!connecting_to_an_split_boundary)
#endif

            // Now look for the vertex number on the destination
            // boundary(ies) -- in case that the boundary was split ---

            // Do not check for same orientation, that was previously
            // worked by interchanging the connections boundaries (if
            // necessary)

            // Get the right vertex in the shared boundary
            Vector<double> shd_bnd_right_vertex =
              shd_poly_pt->vertex_coordinate(n_vertex - 1);

            // If the boundary was not split then inmediately look for
            // the vertex index in the destination boundary
            if (!connecting_to_an_split_boundary)
            {
              // ... check if the boundary is marked to be overlaped by
              // a shared boundary
              if (!connecting_to_an_overlaped_boundary)
              {
                // If that is not the case then we can safely look for
                // the vertex number on the destination boundar

                unsigned vertex_index = 0;
                const bool found_vertex_index =
                  get_connected_vertex_number_on_destination_polyline(
                    poly_to_connect_pt, shd_bnd_right_vertex, vertex_index);

                // If we could not find the vertex index to connect then
                // we are in trouble
                if (!found_vertex_index)
                {
                  std::stringstream error;
                  error
                    << "The current shared boundary (" << bound_id << ") was "
                    << "marked to have a connection\nto the right with the "
                    << "boundary (" << uconnection_to_the_right << ").\n"
                    << "The problem is that the right vertex of the current\n"
                    << "shared boundary is not in the list of vertices of the\n"
                    << "boundary to connect.\n\n"
                    << "This is the right vertex of the current shared "
                       "boundary\n"
                    << "Right vertex: (" << shd_bnd_right_vertex[0] << ", "
                    << shd_bnd_right_vertex[1] << ")\n\n"
                    << "This is the list of vertices on the destination "
                       "boundary\n";
                  const unsigned n_v = poly_to_connect_pt->nvertex();
                  for (unsigned i = 0; i < n_v; i++)
                  {
                    Vector<double> cvertex =
                      poly_to_connect_pt->vertex_coordinate(i);
                    error << "Vertex #" << i << ": (" << cvertex[0] << ", "
                          << cvertex[1] << ")\n";
                  }
                  throw OomphLibError(
                    error.str(),
                    "TriangleMesh::create_shared_polylines_connections()",
                    OOMPH_EXCEPTION_LOCATION);
                } // if (!found_vertex_index)

                // Create the connection, the right vertex of the current
                // shared boundary is connected with the vertex_index-th
                // vertex on the destination boundary
                shd_poly_pt->connect_final_vertex_to_polyline(
                  poly_to_connect_pt, vertex_index);

              } // if (!connecting_to_an_overlaped_boundary)
              else
              {
                // If the boundary is marked to be overlaped by a shared
                // boundary then get that shared boundary and look for
                // the connection in that boundary

                // The vertex where to store the index to connect
                unsigned vertex_index = 0;
                // A flag to indicate if the connection was found
                bool found_vertex_index = false;

                // Get the shared boundary id that is overlaping the
                // internal boundary
                Vector<unsigned> dst_shd_bnd_ids;
                get_shared_boundaries_overlapping_internal_boundary(
                  uconnection_to_the_right, dst_shd_bnd_ids);

                // Get the number of shared polylines that were found to
                // overlap the internal boundary
                const unsigned n_shd_bnd_overlap_int_bnd =
                  dst_shd_bnd_ids.size();

                // Loop over the shared boundaries that overlap the
                // internal boundary and look for the vertex to connect
                for (unsigned ss = 0; ss < n_shd_bnd_overlap_int_bnd; ss++)
                {
                  // Get the shared polyline
                  const unsigned new_connection_to_the_right =
                    dst_shd_bnd_ids[ss];

                  // Get the shared polyline that is overlaping the
                  // internal boundary
                  poly_to_connect_pt =
                    boundary_polyline_pt(new_connection_to_the_right);

                  if (poly_to_connect_pt != 0)
                  {
                    // Look for the vertex number in the destination
                    // shared polyline
                    found_vertex_index =
                      get_connected_vertex_number_on_destination_polyline(
                        poly_to_connect_pt, shd_bnd_right_vertex, vertex_index);
                  } // if (poly_to_connect_pt!=0)

                  // If we have found the vertex to connect then
                  // break the loop
                  if (found_vertex_index)
                  {
                    break;
                  } // if (found_vertex_index)

                } // for (ss < n_shd_bnd_overlaping_int_bnd)

#ifdef PARANOID
                // If we could not find the vertex index to connect then
                // we are in trouble
                if (!found_vertex_index)
                {
                  std::stringstream error;
                  error
                    << "The current shared boundary (" << bound_id << ") was "
                    << "marked to have a connection\nto the right with the "
                    << "boundary (" << uconnection_to_the_right << ").\n"
                    << "This last boundary is marked to be overlaped by "
                    << "shared boundaries\n"
                    << "The problem is that the right vertex of the current\n"
                    << "shared boundary is not in the list of vertices of the\n"
                    << "boundary to connect.\n\n"
                    << "This is the right vertex of the current shared "
                       "boundary\n"
                    << "Right vertex: (" << shd_bnd_right_vertex[0] << ", "
                    << shd_bnd_right_vertex[1] << ")\n\n"
                    << "This is the list of vertices on the destination "
                    << "boundary\n";
                  Vector<unsigned> dst_shd_bnd_ids;
                  get_shared_boundaries_overlapping_internal_boundary(
                    uconnection_to_the_right, dst_shd_bnd_ids);
                  const unsigned n_shd_bnd_overlap_int_bnd =
                    dst_shd_bnd_ids.size();
                  for (unsigned ss = 0; ss < n_shd_bnd_overlap_int_bnd; ss++)
                  {
                    const unsigned new_connection_to_the_right =
                      dst_shd_bnd_ids[ss];
                    poly_to_connect_pt =
                      boundary_polyline_pt(new_connection_to_the_right);
                    if (poly_to_connect_pt != 0)
                    {
                      const unsigned shd_bnd_id_overlap =
                        poly_to_connect_pt->boundary_id();
                      error << "Shared boundary id(" << shd_bnd_id_overlap
                            << ")\n";
                      const unsigned n_v = poly_to_connect_pt->nvertex();
                      for (unsigned i = 0; i < n_v; i++)
                      {
                        Vector<double> cvertex =
                          poly_to_connect_pt->vertex_coordinate(i);
                        error << "Vertex #" << i << ": (" << cvertex[0] << ", "
                              << cvertex[1] << ")\n";
                      }
                    } // if (poly_to_connect_pt != 0)
                  } // for (ss < n_shd_bnd_overlap_int_bnd)

                  throw OomphLibError(
                    error.str(),
                    "TriangleMesh::create_shared_polylines_connections()",
                    OOMPH_EXCEPTION_LOCATION);

                } // if (!found_vertex_index)
#endif

                // Create the connection, the right vertex of the
                // current shared boundary is connected with the
                // vertex_index-th vertex on the destination boundary
                shd_poly_pt->connect_final_vertex_to_polyline(
                  poly_to_connect_pt, vertex_index);

              } // else if (!connecting_to_an_overlaped_boundary)

            } // if (!connecting_to_an_split_boundary)
            else
            {
              // If the boundary was split then we need to look for the
              // vertex in the sub-polylines

              // Get the sub-polylines vector
              Vector<TriangleMeshPolyLine*> tmp_vector_subpolylines =
                boundary_subpolylines(uconnection_to_the_right);

              // Get the number of sub-polylines
              const unsigned nsub_poly = tmp_vector_subpolylines.size();
#ifdef PARANOID
              if (nsub_poly <= 1)
              {
                std::ostringstream error_message;
                error_message
                  << "The boundary (" << uconnection_to_the_right << ") was "
                  << "marked to be splitted but\n"
                  << "there are only (" << nsub_poly << ") polylines to "
                  << "represent it.\n";
                throw OomphLibError(
                  error_message.str(),
                  "TriangleMesh::create_shared_polylines_connections()",
                  OOMPH_EXCEPTION_LOCATION);
              } // if (nsub_poly <= 1)
#endif

              // We need to check if the boundary is marked to be
              // overlaped by an internal boundary, if that is the case
              // we need to check for each indivual subpolyline, and for
              // those overlaped by a shared polyline look for the
              // vertex in the shared polyline representation instead of
              // the original subpolyline

              // ... check if the boundary is marked to be overlaped by
              // a shared boundary
              if (!connecting_to_an_overlaped_boundary)
              {
                // We can work without checking the subpolylines
                // individually

                // The vertex where to store the index to connect
                unsigned vertex_index = 0;
                // The subpoly number to connect
                unsigned sub_poly_to_connect = 0;
                // A flag to indicate if the connection was found
                bool found_vertex_index = false;

                // Look for the vertex number to connect on each of the
                // subpolyines
                for (unsigned isub = 0; isub < nsub_poly; isub++)
                {
                  // Assign the pointer to the sub-polyline
                  poly_to_connect_pt = tmp_vector_subpolylines[isub];
                  // Search for the vertex in the current sub-polyline
                  found_vertex_index =
                    get_connected_vertex_number_on_destination_polyline(
                      poly_to_connect_pt, shd_bnd_right_vertex, vertex_index);
                  // If we have found the vertex to connect then break the
                  // loop
                  if (found_vertex_index)
                  {
                    // But first save the subpoly number (chunk), that
                    // will be used to perform the connection
                    sub_poly_to_connect = isub;
                    break;
                  } // if (found_vertex_index)
                } // for (isub < nsub_poly)

#ifdef PARANOID
                // If we could not find the vertex index to connect then
                // we are in trouble
                if (!found_vertex_index)
                {
                  std::stringstream error;
                  error
                    << "The current shared boundary (" << bound_id << ") was "
                    << "marked to have a connection\nto the right with the "
                    << "boundary (" << uconnection_to_the_right << ").\n"
                    << "The problem is that the right vertex of the current\n"
                    << "shared boundary is not in the list of vertices of any\n"
                    << "of the sub polylines that represent the boundary to\n"
                    << "connect.\n\n"
                    << "This is the right vertex of the current shared "
                       "boundary\n"
                    << "Right vertex: (" << shd_bnd_right_vertex[0] << ", "
                    << shd_bnd_right_vertex[1] << ")\n\n"
                    << "This is the list of vertices on the destination "
                    << "boundary\n";
                  for (unsigned p = 0; p < nsub_poly; p++)
                  {
                    error << "Subpolyline #(" << p << ")\n";
                    poly_to_connect_pt = tmp_vector_subpolylines[p];
                    const unsigned n_v = poly_to_connect_pt->nvertex();
                    for (unsigned i = 0; i < n_v; i++)
                    {
                      Vector<double> cvertex =
                        poly_to_connect_pt->vertex_coordinate(i);
                      error << "Vertex #" << i << ": (" << cvertex[0] << ", "
                            << cvertex[1] << ")\n";
                    }
                  } // for (p < nsub_poly)
                  throw OomphLibError(
                    error.str(),
                    "TriangleMesh::create_shared_polylines_connections()",
                    OOMPH_EXCEPTION_LOCATION);
                } // if (!found_vertex_index)
#endif

                // Create the connection, the right vertex of the current
                // shared boundary is connected with the vertex_index-th
                // vertex of sub_poly_to_connect-th subpolyline of the
                // destination boundary
                shd_poly_pt->connect_final_vertex_to_polyline(
                  poly_to_connect_pt, vertex_index, sub_poly_to_connect);

              } // if (!connecting_to_an_overlaped_boundary)
              else
              {
                // We first look on the shared boundaries that overlap
                // the internal boundaries and the look for the
                // sub-polylines that are not marked as being overlaped
                // by shared boundaries

                // The vertex where to store the index to connect
                unsigned vertex_index = 0;
                // The subpoly number to connect
                unsigned sub_poly_to_connect = 0;
                // A flag to indicate if the connection was found
                bool found_vertex_index = false;

                // Get the shared boundaries id that are overlaping the
                // internal boundary
                Vector<unsigned> dst_shd_bnd_ids;
                get_shared_boundaries_overlapping_internal_boundary(
                  uconnection_to_the_right, dst_shd_bnd_ids);

                // Get the number of shared polylines that were found to
                // overlap the internal boundary
                const unsigned n_shd_bnd_overlap_int_bnd =
                  dst_shd_bnd_ids.size();

                // Loop over the shared boundaries that overlap the
                // internal boundary and look for the vertex to connect
                for (unsigned ss = 0; ss < n_shd_bnd_overlap_int_bnd; ss++)
                {
                  // Get the shared polyline
                  const unsigned new_connection_to_the_right =
                    dst_shd_bnd_ids[ss];

                  // Make sure that the destination polyline is not the
                  // same as the current shared polyline
                  if (bound_id != new_connection_to_the_right)
                  {
                    // Get the shared polyline that is overlaping the
                    // internal boundary
                    poly_to_connect_pt =
                      boundary_polyline_pt(new_connection_to_the_right);

                    if (poly_to_connect_pt != 0)
                    {
                      // Look for the vertex number in the destination
                      // shared polyline
                      found_vertex_index =
                        get_connected_vertex_number_on_destination_polyline(
                          poly_to_connect_pt,
                          shd_bnd_right_vertex,
                          vertex_index);
                    } // if (poly_to_connect_pt != 0)

                    // If we have found the vertex to connect then
                    // break the loop
                    if (found_vertex_index)
                    {
                      break;
                    } // if (found_vertex_index)

                  } // if (bound_id != new_connection_to_the_right)

                } // for (ss < n_shd_bnd_overlaping_int_bnd)

                // If we have not yet found the vertex then look for it
                // in the sub-polylines that are not overlaped by shared
                // boundaries
                if (!found_vertex_index)
                {
                  // Look for the vertex number to connect on each of
                  // the subpolyines
                  for (unsigned isub = 0; isub < nsub_poly; isub++)
                  {
                    // Only work with those sub-polylines that are not
                    // overlaped by shared boundaries
                    if (!boundary_marked_as_shared_boundary(
                          uconnection_to_the_right, isub))
                    {
                      // Assign the pointer to the sub-polyline
                      poly_to_connect_pt = tmp_vector_subpolylines[isub];
                      // Search for the vertex in the current sub-polyline
                      found_vertex_index =
                        get_connected_vertex_number_on_destination_polyline(
                          poly_to_connect_pt,
                          shd_bnd_right_vertex,
                          vertex_index);
                      // If we have found the vertex to connect then break the
                      // loop
                      if (found_vertex_index)
                      {
                        // But first save the subpoly number (chunk), that
                        // will be used to perform the connection
                        sub_poly_to_connect = isub;
                        break;
                      } // if (found_vertex_index)

                    } // if (not overlaped by shared boundary)

                  } // for (isub < nsub_poly)

                } // if (!found_vertex_index)

#ifdef PARANOID
                // If we could not find the vertex index to connect then
                // we are in trouble
                if (!found_vertex_index)
                {
                  std::stringstream error;
                  error
                    << "The current shared boundary (" << bound_id << ") was "
                    << "marked to have a connection\nto the right with the "
                    << "boundary (" << uconnection_to_the_right << ").\n"
                    << "This last boundary is marked to be overlaped by "
                    << "shared boundaries\n"
                    << "The problem is that the right vertex of the current\n"
                    << "shared boundary is not in the list of vertices of "
                    << "the\nboundary to connect.\n\n"
                    << "This is the right vertex of the current shared "
                    << "boundary\n"
                    << "Right vertex: (" << shd_bnd_right_vertex[0] << ", "
                    << shd_bnd_right_vertex[1] << ")\n\n"
                    << "This is the list of vertices on the destination "
                    << "boundary (only those subpolylines not marked as "
                    << "overlaped by\nshared boundaries)\n";
                  for (unsigned p = 0; p < nsub_poly; p++)
                  {
                    if (!boundary_marked_as_shared_boundary(
                          uconnection_to_the_right, p))
                    {
                      error << "Subpolyline #(" << p << ")\n";
                      poly_to_connect_pt = tmp_vector_subpolylines[p];
                      const unsigned n_v = poly_to_connect_pt->nvertex();
                      for (unsigned i = 0; i < n_v; i++)
                      {
                        Vector<double> cvertex =
                          poly_to_connect_pt->vertex_coordinate(i);
                        error << "Vertex #" << i << ": (" << cvertex[0] << ", "
                              << cvertex[1] << ")\n";
                      }
                    } // Not marked as overlaped
                  } // for (p < nsub_poly)
                  error << "\nThis is the list of vertices of the shared "
                        << "polylines that overlap\nthe internal "
                        << "boundary\n";
                  Vector<unsigned> dst_shd_bnd_ids;
                  get_shared_boundaries_overlapping_internal_boundary(
                    uconnection_to_the_right, dst_shd_bnd_ids);
                  const unsigned n_shd_bnd_overlap_int_bnd =
                    dst_shd_bnd_ids.size();
                  for (unsigned ss = 0; ss < n_shd_bnd_overlap_int_bnd; ss++)
                  {
                    const unsigned new_connection_to_the_right =
                      dst_shd_bnd_ids[ss];
                    poly_to_connect_pt =
                      boundary_polyline_pt(new_connection_to_the_right);
                    if (poly_to_connect_pt != 0)
                    {
                      const unsigned shd_bnd_id_overlap =
                        poly_to_connect_pt->boundary_id();
                      error << "Shared boundary id(" << shd_bnd_id_overlap
                            << ")\n";
                      const unsigned n_v = poly_to_connect_pt->nvertex();
                      for (unsigned i = 0; i < n_v; i++)
                      {
                        Vector<double> cvertex =
                          poly_to_connect_pt->vertex_coordinate(i);
                        error << "Vertex #" << i << ": (" << cvertex[0] << ", "
                              << cvertex[1] << ")\n";
                      }
                    } // if (poly_to_connect_pt != 0)
                  } // for (ss < n_shd_bnd_overlap_int_bnd)

                  throw OomphLibError(
                    error.str(),
                    "TriangleMesh::create_shared_polylines_connections()",
                    OOMPH_EXCEPTION_LOCATION);
                } // if (!found_vertex_index)
#endif

                // Create the connection, the left vertex of the current
                // shared boundary is connected with the vertex_index-th
                // vertex of sub_poly_to_connect-th subpolyline of the
                // destination boundary
                shd_poly_pt->connect_final_vertex_to_polyline(
                  poly_to_connect_pt, vertex_index, sub_poly_to_connect);

              } // else if (!connecting_to_an_overlaped_boundary)

            } // else if (!connecting_to_an_split_boundary)

          } // if (connection_to_the_right != -1)

        } // if (connection_to_the_left != -1 || connection_to_the_right != -1)

      } // for (ipoly < npoly)

    } // for (icurve < ncurves)
  }

  //=======================================================================
  // Compute the holes left by the halo elements, those adjacent
  // to the shared boundaries
  //=======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::compute_holes_left_by_halo_elements_helper(
    Vector<Vector<double>>& output_holes_coordinates)
  {
    // Storage for number of processors and current processor
    const unsigned n_proc = this->communicator_pt()->nproc();
    const unsigned my_rank = this->communicator_pt()->my_rank();

    // Mark those done elements, so we do not repeat any coordinate left
    // by repeated halo elements
    std::map<FiniteElement*, bool> done_ele;

    // Loop over the processors and get the shared boundaries ids that
    // the current processor has with the other processors
    for (unsigned iproc = 0; iproc < n_proc; iproc++)
    {
      // There are shared boundaries only with the other processors
      if (iproc != my_rank)
      {
        // Get the number of shared boundaries with the iproc
        const unsigned n_shd_bnd_iproc = nshared_boundaries(my_rank, iproc);

#ifdef PARANOID
        // Get the number of shared boundaries with the iproc, but
        // reversing the indexes
        const unsigned n_shd_bnd_iproc_rev = nshared_boundaries(iproc, my_rank);
        if (n_shd_bnd_iproc != n_shd_bnd_iproc_rev)
        {
          std::ostringstream error_stream;
          error_stream
            << "The number of shared boundaries of processor (" << my_rank
            << ") with processor(" << iproc << "): (" << n_shd_bnd_iproc
            << ")\n"
            << "is different from the number of shared boundaries of "
            << "processor (" << iproc << ")\nwith processor (" << my_rank
            << "): (" << n_shd_bnd_iproc << ")\n\n";
          throw OomphLibError(error_stream.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);

        } // if (n_shd_bnd_iproc != n_shd_bnd_iproc_rev)
#endif

        // Loop over the shared boundaries ids
        for (unsigned i = 0; i < n_shd_bnd_iproc; i++)
        {
          // Get the shared boundary id
          const unsigned shd_bnd_id = shared_boundaries_ids(my_rank, iproc, i);

          // Get the number of shared boundary elements
          const unsigned n_shd_bnd_ele = nshared_boundary_element(shd_bnd_id);

          // Loop over the shared boundary elements
          for (unsigned e = 0; e < n_shd_bnd_ele; e++)
          {
            // Get the shared boundary element
            FiniteElement* ele_pt = shared_boundary_element_pt(shd_bnd_id, e);

            // Only work with halo elements
            if (ele_pt->is_halo())
            {
              // If the element has not been visited
              if (!done_ele[ele_pt])
              {
                // Get the number of nodes
                const unsigned n_nodes = ele_pt->nnode();

                // Compute the centroid of the element
                Vector<double> element_centroid(2, 0.0);
                // Loop over the nodes
                for (unsigned k = 0; k < n_nodes; k++)
                {
                  Node* tmp_node_pt = ele_pt->node_pt(k);
                  // Loop over the dimension
                  for (unsigned d = 0; d < 2; d++)
                  {
                    element_centroid[d] += tmp_node_pt->x(d);
                  } // for (d < 2)
                } // for (k < n_nodes)

                // Average the data
                for (unsigned d = 0; d < 2; d++)
                {
                  element_centroid[d] = element_centroid[d] / (double)n_nodes;
                } // for (d < 2)

                // Add the centroid to the output holes
                output_holes_coordinates.push_back(element_centroid);

              } // if (!done_ele[ele_pt])

            } // if (ele_pt->is_halo())

          } // for1 (e < n_shd_bnd_ele)

        } // for (i < n_shd_bnd_iproc)

      } // if (iproc != my_rank)

    } // for (iproc < n_proc)
  }

  //======================================================================
  // Keeps those vertices that define a hole, those that are
  // inside closed internal boundaries in the new polygons that define
  // the domain. Delete those outside/inside the outer polygons (this
  // is required since Triangle can not deal with vertices that define
  // holes outside the new outer polygons of the domain)
  //======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::update_holes_information_helper(
    Vector<TriangleMeshPolygon*>& polygons_pt,
    Vector<Vector<double>>& output_holes_coordinates)
  {
    // General strategy

    // 1) Identify the inner closed boundaries

    // 2) Separate the vertices in three groups

    // --- 2.1) The vertices inside the inner closed boundaries, these
    //          are not deleted because they define holes

    // --- 2.2) The vertices outside the outer boundaries, these are
    //          deleted only if they are outside the convex hull defined
    //          by all the polygons

    // --- 2.3) Any other vertex is deleted

    // Get the number of input holes
    const unsigned n_input_holes = output_holes_coordinates.size();

    // Only do something if there are holes
    if (n_input_holes == 0)
    {
      return;
    }

    // Get the number of input polygons
    const unsigned n_polygons = polygons_pt.size();

    // Store the vertices of all the input polygons
    // vertices_polygons[x][ ][ ]: Polygon number
    // vertices_polygons[ ][x][ ]: Vertex number
    // vertices_polygons[ ][ ][x]: Vertex coordinate
    Vector<Vector<Vector<double>>> vertices_polygons(n_polygons);

    // Loop over all the polygons and get the vertices
    for (unsigned p = 0; p < n_polygons; p++)
    {
      // Get the number of polylines associated to the polygon
      const unsigned n_polylines = polygons_pt[p]->npolyline();
      // Loop over the polylines and get the vertices
      for (unsigned pp = 0; pp < n_polylines; pp++)
      {
        // Get the polyline
        const TriangleMeshPolyLine* tmp_poly_pt =
          polygons_pt[p]->polyline_pt(pp);
        // Get the number of vertices in the polyline
        const unsigned n_vertices = tmp_poly_pt->nvertex();
        // Loop over the vertices but only add (n_vertices-1) vertices,
        // the last vertex of polyline (pp) is the first vertex of
        // polyline (pp+1)
        for (unsigned v = 0; v < n_vertices - 1; v++)
        {
          // Get the current vertex
          Vector<double> current_vertex = tmp_poly_pt->vertex_coordinate(v);
          vertices_polygons[p].push_back(current_vertex);
        } // for (v < nvertex)
      } // for (p < nouter_polylines)
    } // for (p < n_polygons)

    // -------------------------------------------------------------------
    // 1) Identify the inner closed boundaries
    // -------------------------------------------------------------------

    // A container that indicates if a given polygon should be
    // considered as an outer or as an inner polygon. By default all the
    // polygons are considered as outer polygons
    std::vector<bool> is_outer_polygon(n_polygons, true);

    // We only check for innner polygons if there are more than one
    // polygon
    if (n_polygons > 1)
    {
      // Propose an inner polygon, if one of the middle points of its
      // edges lies inside any other polygon then the proposed inner
      // polygon is marked as an internal polygon

      // Pre-compute the middle points of the edges in the polygons
      Vector<Vector<Vector<double>>> polygon_edge_middle_vertex(n_polygons);

      for (unsigned p = 0; p < n_polygons; p++)
      {
        // Temporary store the vertices of the proposed inner polygon
        Vector<Vector<double>> tmp_inner_polygon = vertices_polygons[p];

        // Get the number of vertices in the current proposed inner polygon
        const unsigned n_vertices = tmp_inner_polygon.size();

        // Resize with the number of edges in the polygon
        polygon_edge_middle_vertex[p].resize(n_vertices - 1);

        // Loop over the vertices and compute the middle point in the edge
        // that joins each pair of contiguous vertices
        for (unsigned e = 0; e < n_vertices - 1; e++)
        {
          // The dimension
          const unsigned dim = 2;
          polygon_edge_middle_vertex[p][e].resize(dim);
          for (unsigned d = 0; d < dim; d++)
          {
            polygon_edge_middle_vertex[p][e][d] =
              (tmp_inner_polygon[e][d] + tmp_inner_polygon[e + 1][d]) / 2.0;
          } // for (d < 2)

        } // for (e < n_vertices - 1)

      } // for (p < n_polygons)

      // Loop over the polygons and for every loop propose a different
      // inner polygon
      for (unsigned idx_inner = 0; idx_inner < n_polygons; idx_inner++)
      {
        // Flag to indicate that ONE of the middle edge vertices of the
        // proposed inner polygon is inside another polygon, this will
        // set the proposed inner polygon as an actual inner polygon
        bool is_inner_polygon = false;

        // Loop over all the polygons, except the proposed one and check
        // if all the middle edges of its edges are inside any other
        // polygon
        for (unsigned i = 0; i < n_polygons; i++)
        {
          // Do not check with the polygon itself
          if (i != idx_inner)
          {
            // Get the number of edges of the proposed inner polygon
            const unsigned n_edges =
              polygon_edge_middle_vertex[idx_inner].size();
            // Loop over the middle points in the edges of the current
            // proposed inner polygon
            for (unsigned e = 0; e < n_edges; e++)
            {
              // Get the vertex in the current proposed inner polygon
              Vector<double> current_vertex =
                polygon_edge_middle_vertex[idx_inner][e];
              // Check if the current vertex is inside the current i-th
              // polygon
              const bool is_point_inside = is_point_inside_polygon_helper(
                vertices_polygons[i], current_vertex);

              // If one point is inside then the polygon is inside the
              // i-th polygon
              if (is_point_inside)
              {
                // The polygon is an inner polygon
                is_inner_polygon = true;
                // Break the loop
                break;
              } // if (is_point_inside)

            } // for (e < n_edges)

          } // if (i != idx_inner)

          // Are all the vertices of the current proposed inner polygon
          // inside the i-th polygon
          if (is_inner_polygon)
          {
            // The current proposed inner polygon is an actual inner
            // polygon, and is inside the i-th polygon
            break;
          }

        } // for (i < n_polygons)

        // Is the current proposed inner polygon an actual inner polygon
        if (is_inner_polygon)
        {
          // The current proposed inner polygon is a real inner polygon
          is_outer_polygon[idx_inner] = false;
        }
        else
        {
          // The current proposed inner polygon IS NOT a real inner
          // polygon
          is_outer_polygon[idx_inner] = true;
        }

      } // for (idx_outer < npolygons)

    } // if (n_polygons > 1)

    // Count the number of outer closed boundaries and inner closed
    // boundaries
    unsigned n_outer_polygons = 0;
    unsigned n_inner_polygons = 0;
    // Also get the indexes of the inner polygons
    Vector<unsigned> index_inner_polygon;
    // Loop over the polygons
    for (unsigned i = 0; i < n_polygons; i++)
    {
      if (is_outer_polygon[i])
      {
        // Increase the counter for outer polygons
        n_outer_polygons++;
      }
      else
      {
        // Increase the counter for inner polygons
        n_inner_polygons++;
        // Store the index of the inner polygon
        index_inner_polygon.push_back(i);
      }
    } // for (i < n_polygons)

    // -------------------------------------------------------------------
    // 2) Separate the vertices in three groups

    // --- 2.1) The vertices inside the inner closed boundaries, these are
    //          not deleted because they define holes

    // --- 2.2) The vertices outside the outer boundaries, these are
    //          deleted only if they are outside the convex hull defined
    //          by all the polygons

    // --- 2.3) Any other vertex is deleted
    // -------------------------------------------------------------------

    // Keep track of the vertices inside the inner closed boundaries (by
    // default all vertices not inside the inner polygons)
    std::vector<bool> is_inside_an_inner_polygon(n_input_holes, false);

    // Keep track of the vertices outside the outer closed boundaries
    // (by default all the vertices are outside the outer polygons)
    std::vector<bool> is_outside_the_outer_polygons(n_input_holes, true);

    // Keep track of the vertices inside the convex hull (by default
    // all the vertices are not inside the convex hull)
    std::vector<bool> is_inside_the_convex_hull(n_input_holes, false);

    // Mark the vertices inside the inner closed boundaries
    Vector<Vector<Vector<double>>> vertex_inside_inner_polygon(
      n_inner_polygons);

    // -------------------------------------------------------------------
    // Loop over the inner polygons and find all the vertices inside
    // each one
    for (unsigned i = 0; i < n_inner_polygons; i++)
    {
      // Get the vertex of the inner polygon
      const unsigned ii = index_inner_polygon[i];
      // Loop over the vertices defining holes, mark and store those
      // inside the inner polygon
      for (unsigned h = 0; h < n_input_holes; h++)
      {
        // Check if the vertex has not been already marked as inside
        // another polygon
        if (!is_inside_an_inner_polygon[h])
        {
          // Check if the hole is inside the current inner polygon
          const bool is_inside_polygon = is_point_inside_polygon_helper(
            vertices_polygons[ii], output_holes_coordinates[h]);

          // If the vertex is inside the current inner polygon then mark
          // it and associate the vertices to the current inner polygon
          if (is_inside_polygon)
          {
            // Set as inside an inner polygon
            is_inside_an_inner_polygon[h] = true;
            // Associate the vertex to the current inner polygon
            vertex_inside_inner_polygon[i].push_back(
              output_holes_coordinates[h]);
          } // if (is_inside_polygon)

        } // if (!is_inside_an_inner_polygon[h])

      } // for (h < n_input_holes)

    } // for (i < n_polygons)

    // -------------------------------------------------------------------
    // Loop over the vertices defining holes and mark those as outside the
    // outer polygons
    for (unsigned h = 0; h < n_input_holes; h++)
    {
      // Check if the vertex has not been already marked as inside
      // another polygon
      if (!is_inside_an_inner_polygon[h])
      {
        // Loop over the polygons and check if the vertex is outside ALL
        // the outer polygons
        for (unsigned i = 0; i < n_polygons; i++)
        {
          // Only work with outer polygons
          if (is_outer_polygon[i])
          {
            // Check if the hole is inside the current outer polygon
            const bool is_inside_polygon = is_point_inside_polygon_helper(
              vertices_polygons[i], output_holes_coordinates[h]);

            // If the vertex is inside the current outer polygon then
            // mark it and break the loop (it is not outside ALL the
            // polygons)
            if (is_inside_polygon)
            {
              // Set as inside an outer polygon
              is_outside_the_outer_polygons[h] = false;
              // Break the loop
              break;
            } // if (is_inside_polygon)

          } // if (is_outer_polygon[i])

        } // for (i < n_polygons)

      } // if (!is_inside_an_inner_polygon[h])
      else
      {
        // If the vertex is inside an inner polygon then it is inside an
        // outer polygon
        is_outside_the_outer_polygons[h] = false;
      } // else if (!is_inside_an_inner_polygon[h])

    } // for (h < n_input_holes)

    // -------------------------------------------------------------------
    // Compute the convex hull Create the data structure
    std::vector<Point> input_vertices_convex_hull;
    // Copy ALL the vertices of the polygons
    // Loop over the polygons
    for (unsigned p = 0; p < n_polygons; p++)
    {
      // Get the number of vertices
      const unsigned n_vertices = vertices_polygons[p].size();
      // Loop over the vertices in the polygon
      for (unsigned v = 0; v < n_vertices; v++)
      {
        // Create a new "Point" to store in the input vertices
        Point point;
        // Assign the values to the "Point"
        point.x = vertices_polygons[p][v][0];
        point.y = vertices_polygons[p][v][1];
        // Add the "Point" to the input vertices
        input_vertices_convex_hull.push_back(point);
      } // for (v < n_vertices)
    } // for (p < n_polygons)

    // Compute the convex hull
    std::vector<Point> output_vertices_convex_hull =
      convex_hull(input_vertices_convex_hull);

    // Get the number of vertices in the convex hull
    const unsigned n_vertices_convex_hull = output_vertices_convex_hull.size();

    // Copy the output to the used data structures
    Vector<Vector<double>> vertices_convex_hull(n_vertices_convex_hull);
    for (unsigned i = 0; i < n_vertices_convex_hull; i++)
    {
      // Resize the data structure
      vertices_convex_hull[i].resize(2);
      // Copy the data
      vertices_convex_hull[i][0] = output_vertices_convex_hull[i].x;
      vertices_convex_hull[i][1] = output_vertices_convex_hull[i].y;
    } // for (i < n_vertices_convex_hull)

    // Loop over the vertices defining holes, work only with those
    // outside ALL the outer boundaries and mark those inside the convex
    // hull
    for (unsigned h = 0; h < n_input_holes; h++)
    {
      // Only work with those outside ALL the outer polygons
      if (is_outside_the_outer_polygons[h])
      {
        // Check if the hole is inside the convex hull
        const bool is_inside_convex_hull = is_point_inside_polygon_helper(
          vertices_convex_hull, output_holes_coordinates[h]);

        // If the vertex is inside the convex hull then mark it
        if (is_inside_convex_hull)
        {
          // Set as inside the convex hull
          is_inside_the_convex_hull[h] = true;
        } // if (is_inside_convex_hull)

      } // if (is_outside_the_outer_polygons[h])
      else
      {
        // Any vertex inside any outer polygon is inside the convex hull
        is_inside_the_convex_hull[h] = true;
      } // else if (is_outside_the_outer_polygons[h])

    } // for (h < n_input_holes)

    // Store the output holes, only (those inside an inner polygon) OR
    // (those outside ALL the polygons AND inside the convex hull)
    Vector<Vector<double>> hole_kept;
    for (unsigned h = 0; h < n_input_holes; h++)
    {
      // Check if the hole should be kept
      if ((is_inside_an_inner_polygon[h]) ||
          (is_outside_the_outer_polygons[h] && is_inside_the_convex_hull[h]))
      {
        // Copy the hole information
        hole_kept.push_back(output_holes_coordinates[h]);
      } // if (keep_hole[h])
    } // for (h < n_input_holes)

    // Clear the previous storage
    output_holes_coordinates.clear();
    // Set the output holes
    output_holes_coordinates = hole_kept;
  }

  //======================================================================
  // Sorts the polylines so they be contiguous and then we can
  // create a closed or open curve from them
  //======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::sort_polylines_helper(
    Vector<TriangleMeshPolyLine*>& unsorted_polylines_pt,
    Vector<Vector<TriangleMeshPolyLine*>>& sorted_polylines_pt)
  {
    unsigned n_unsorted_polylines = unsorted_polylines_pt.size();
    unsigned n_sorted_polylines = 0;
    unsigned curves_index = 0;

    // Map to know which polyline has been already sorted
    std::map<TriangleMeshPolyLine*, bool> done_polyline;

    do
    {
      // Create the list that stores the polylines and allows to introduce
      // polylines to the left and to the right
      std::list<TriangleMeshPolyLine*> sorted_polyline_list_pt;
      bool changes = false;

      // Create pointers to the left and right "side" of the sorted list of
      // new created TriangleMeshPolyLines
      TriangleMeshPolyLine* left_pt = 0;
      TriangleMeshPolyLine* right_pt = 0;

      // 1) Take the first non done polyline on the unsorted list of polylines
      unsigned pp = 0;
      bool found_root_polyline = false;
      while (pp < n_unsorted_polylines && !found_root_polyline)
      {
        if (!done_polyline[unsorted_polylines_pt[pp]])
        {
          found_root_polyline = true;
        }
        else
        {
          pp++;
        }
      }

      // Check if there are polylines to be sorted
      if (pp < n_unsorted_polylines)
      {
        // 2) Mark the polyline as done
        left_pt = right_pt = unsorted_polylines_pt[pp];
        done_polyline[left_pt] = true;
        // Increment the number of sorted polylines
        n_sorted_polylines++;

        // 3) Add this polyline to the sorted list and use it as root
        // to sort the other polylines
        sorted_polyline_list_pt.push_back(left_pt);

        do
        {
          changes = false;

          Vector<double> left_vertex(2);
          Vector<double> right_vertex(2);

          left_pt->initial_vertex_coordinate(left_vertex);
          right_pt->final_vertex_coordinate(right_vertex);

          for (unsigned i = pp + 1; i < n_unsorted_polylines; i++)
          {
            TriangleMeshPolyLine* current_polyline_pt =
              unsorted_polylines_pt[i];
            if (!done_polyline[current_polyline_pt])
            {
              Vector<double> initial_vertex(2);
              Vector<double> final_vertex(2);
              current_polyline_pt->initial_vertex_coordinate(initial_vertex);
              current_polyline_pt->final_vertex_coordinate(final_vertex);

              // Compare if the current polyline should go to the left or
              // to the right on the sorted polyline list

              // Go to the left
              if (left_vertex == final_vertex)
              {
                left_pt = current_polyline_pt;
                sorted_polyline_list_pt.push_front(left_pt);
                done_polyline[left_pt] = true;
                n_sorted_polylines++;

                // We have added one more polyline, go for another round
                changes = true;
              }
              // Go to the right
              else if (right_vertex == initial_vertex)
              {
                right_pt = current_polyline_pt;
                sorted_polyline_list_pt.push_back(right_pt);
                done_polyline[right_pt] = true;
                n_sorted_polylines++;

                // We have added one more polyline, go for another round
                changes = true;
              }
              // Go to the left but it is reversed
              else if (left_vertex == initial_vertex)
              {
                current_polyline_pt->reverse();
                left_pt = current_polyline_pt;
                sorted_polyline_list_pt.push_front(left_pt);
                done_polyline[left_pt] = true;
                n_sorted_polylines++;

                // We have added one more polyline, go for another round
                changes = true;
              }
              // Go to the right but it is reversed
              else if (right_vertex == final_vertex)
              {
                current_polyline_pt->reverse();
                right_pt = current_polyline_pt;
                sorted_polyline_list_pt.push_back(right_pt);
                done_polyline[right_pt] = true;
                n_sorted_polylines++;

                // We have added one more polyline, go for another round
                changes = true;
              }
            } // if (!done_polyline[current_polyline_pt])
            if (changes)
            {
              break;
            }
          } // for (i < n_unsorted_polylines)
        } while (changes);

      } // if (pp < n_unsorted_polylines)
      else
      {
        // All the polylines are now on the sorted list of polylines
#ifdef PARANOID
        // This case comes when it was not possible to find a root polyline
        // since all of them are marked as done but the number of sorted and
        // unsorted polylines is not the same
        if (!found_root_polyline)
        {
          std::stringstream err;
          err << "It was not possible to find a root polyline to sort the "
              << "others around it.\nThe number of unsorted and sorted "
              << "polylines is different, it means that\nnot all the "
              << "polylines have been sorted.\n"
              << "Found root polyline: (" << found_root_polyline << ")\n"
              << "Sorted polylines: (" << n_sorted_polylines << ")\n"
              << "Unsorted polylines: (" << n_unsorted_polylines << ")\n";
          throw OomphLibError(err.str(),
                              "TriangleMesh::sort_polylines_helper()",
                              OOMPH_EXCEPTION_LOCATION);
        }
#endif
      }

      // Create the storage for the new sorted polylines and copy them on the
      // vector structure for sorted polylines
      unsigned n_sorted_polyline_on_list = sorted_polyline_list_pt.size();

      // Create the temporal vector that stores the sorted polylines
      Vector<TriangleMeshPolyLine*> tmp_sorted_polylines(
        n_sorted_polyline_on_list);
      unsigned counter = 0;

      std::list<TriangleMeshPolyLine*>::iterator it_polyline;
      for (it_polyline = sorted_polyline_list_pt.begin();
           it_polyline != sorted_polyline_list_pt.end();
           it_polyline++)
      {
        tmp_sorted_polylines[counter] = *it_polyline;
        counter++;
      }

      sorted_polylines_pt.push_back(tmp_sorted_polylines);

      ++curves_index;

    } while (n_sorted_polylines < n_unsorted_polylines);

#ifdef PARANOID
    // Verify that the number of polylines on the sorted list is the same
    // as the number of polylines on the unsorted list
    if (n_sorted_polylines != n_unsorted_polylines)
    {
      std::stringstream err;
      err << "The number of polylines on the unsorted and sorted vectors"
          << " is different,\n"
          << "it means that not all the polylines have been sorted.\n"
          << "Sorted polylines: " << n_sorted_polylines
          << "\nUnsorted polylines: " << n_unsorted_polylines;
      throw OomphLibError(err.str(),
                          "TriangleMesh::sort_polylines_helper()",
                          OOMPH_EXCEPTION_LOCATION);
    }
#endif
  }

  //======================================================================
  // Creates the shared boundaries
  //======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::create_shared_boundaries(
    OomphCommunicator* comm_pt,
    const Vector<unsigned>& element_domain,
    const Vector<GeneralisedElement*>& backed_up_el_pt,
    const Vector<FiniteElement*>& backed_up_f_el_pt,
    std::map<Data*, std::set<unsigned>>& processors_associated_with_data,
    const bool& overrule_keep_as_halo_element_status)
  {
    // Storage for number of processors and current processor
    const unsigned nproc = comm_pt->nproc();
    const unsigned my_rank = comm_pt->my_rank();

    // Storage for all the halo elements on all processors
    // halo_element[iproc][jproc][ele_number]
    // Stores the "ele_number"-th halo element of processor "iproc" with
    // processor "jproc"
    Vector<Vector<Vector<GeneralisedElement*>>> halo_element_pt(nproc);
    // Create complete storage for the halo_element_pt container
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      halo_element_pt[iproc].resize(nproc);
    }

    // Store the global index of the element, used to check for possible
    // misclassification of halo elements in the above container
    // (halo_element_pt)
    std::map<GeneralisedElement*, unsigned> element_to_global_index;

    // Get the halo elements on all processors
    this->get_halo_elements_on_all_procs(nproc,
                                         element_domain,
                                         backed_up_el_pt,
                                         processors_associated_with_data,
                                         overrule_keep_as_halo_element_status,
                                         element_to_global_index,
                                         halo_element_pt);

    // Resize the shared polylines container
    flush_shared_boundary_polyline_pt();
    Shared_boundary_polyline_pt.resize(nproc);

    // Create a set that store only the elements that will be kept in
    // the processor as nonhalo element, those whose element_domains is
    // equal to my_rank. This set is used when creating the shared
    // polylines and identify the connections to the original boundaries
    std::set<FiniteElement*> element_in_processor_pt;
    const unsigned n_ele = backed_up_f_el_pt.size();
    for (unsigned e = 0; e < n_ele; e++)
    {
      if (element_domain[e] == my_rank)
      {
        element_in_processor_pt.insert(backed_up_f_el_pt[e]);
      } // if (element_domain[e] == my_rank)
    } // for (e < n_elex)

    // Look for elements edges that may lie on internal boundaries
    // If that is the case then relate the face with the boundary on
    // which it lies
    std::map<std::pair<Node*, Node*>, unsigned> elements_edges_on_boundary;
    this->get_element_edges_on_boundary(elements_edges_on_boundary);

    // Now we have all the halo elements on all processors. Use the
    // edges shared by the halo elements to create the shared boundaries.
    this->create_polylines_from_halo_elements_helper(
      element_domain,
      element_to_global_index,
      element_in_processor_pt,
      halo_element_pt,
      elements_edges_on_boundary,
      Shared_boundary_polyline_pt);
  }

  //======================================================================
  /// Creates the halo elements on all processors
  /// Gets the halo elements on all processors, these elements are then used
  /// on the function that computes the shared boundaries among the processors
  //======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::get_halo_elements_on_all_procs(
    const unsigned& nproc,
    const Vector<unsigned>& element_domain,
    const Vector<GeneralisedElement*>& backed_up_el_pt,
    std::map<Data*, std::set<unsigned>>& processors_associated_with_data,
    const bool& overrule_keep_as_halo_element_status,
    std::map<GeneralisedElement*, unsigned>& element_to_global_index,
    Vector<Vector<Vector<GeneralisedElement*>>>& output_halo_elements_pt)
  {
    const unsigned n_ele = backed_up_el_pt.size();

    // Loop over all the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Boolean to know which elements has been already added to the
      // halo scheme on "iproc" processor
      Vector<std::map<GeneralisedElement*, bool>> already_added(nproc);

      // Loop over all backed up elements
      for (unsigned e = 0; e < n_ele; e++)
      {
        // Get element and its domain
        GeneralisedElement* el_pt = backed_up_el_pt[e];
        unsigned el_domain = element_domain[e];

        // If element is NOT located on "iproc" processor then check if it is
        // halo with "el_domain" processor
        if (el_domain != iproc)
        {
          // If this current mesh has been told to keep all elements as halos,
          // OR the element itself knows that it must be kept then
          // keep it
          if ((this->Keep_all_elements_as_halos) ||
              (el_pt->must_be_kept_as_halo()))
          {
            if (!overrule_keep_as_halo_element_status)
            {
              // Add as halo element whose non-halo counterpart is
              // located on processor "el_domain"
              if (!already_added[el_domain][el_pt])
              {
                output_halo_elements_pt[iproc][el_domain].push_back(el_pt);
                already_added[el_domain][el_pt] = true;
                element_to_global_index[el_pt] = e;
              }
            }
          }
          // Otherwise: Is one of the nodes associated with other processor?
          else
          {
            // Can only have nodes if this is a finite element
            FiniteElement* finite_el_pt = dynamic_cast<FiniteElement*>(el_pt);
            if (finite_el_pt != 0)
            {
              unsigned n_node = finite_el_pt->nnode();
              for (unsigned n = 0; n < n_node; n++)
              {
                Node* nod_pt = finite_el_pt->node_pt(n);

                // Keep element?
                std::set<unsigned>::iterator it =
                  processors_associated_with_data[nod_pt].find(iproc);
                if (it != processors_associated_with_data[nod_pt].end())
                {
                  // Add as root halo element whose non-halo counterpart is
                  // located on processor "el_domain"
                  if (!already_added[el_domain][el_pt])
                  {
                    output_halo_elements_pt[iproc][el_domain].push_back(el_pt);
                    already_added[el_domain][el_pt] = true;
                    element_to_global_index[el_pt] = e;
                  }
                  // Now break out of loop over nodes
                  break;
                } // if (it!=processors_associated_with_data[nod_pt].end())
              } // for (n < n_node)
            } // if (finite_el_pt!=0)
          } // else (this->Keep_all_elements_as_halos)
        } // if (el_domain!=iproc)
      } // for (e < nele)
    } // for (iproc < nproc)
  }

  //====================================================================
  // Get the element edges (pair of nodes, edges) that lie
  // on a boundary (used to mark shared boundaries that lie on
  // internal boundaries)
  //====================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::get_element_edges_on_boundary(
    std::map<std::pair<Node*, Node*>, unsigned>& element_edges_on_boundary)
  {
    // The number of original boundaries
    const unsigned nbound = this->nboundary();
    // Loop over the boundaries
    for (unsigned b = 0; b < nbound; b++)
    {
      // Keep track of the pair of nodes done
      std::map<std::pair<Node*, Node*>, bool> edge_done;
      // Get the number of elements on the boundary
      const unsigned nbound_ele = this->nboundary_element(b);
      for (unsigned e = 0; e < nbound_ele; e++)
      {
        // Get the boundary bulk element
        FiniteElement* bulk_ele_pt = this->boundary_element_pt(b, e);
        // Get the face index
        int face_index = this->face_index_at_boundary(b, e);
        // Create the face element
        FiniteElement* face_ele_pt =
          new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);
        // Get the number of nodes on the face element
        const unsigned nnodes = face_ele_pt->nnode();
        // Get the first and last node
        Node* first_node_pt = face_ele_pt->node_pt(0);
        Node* last_node_pt = face_ele_pt->node_pt(nnodes - 1);

        // Create the pair to store the nodes
        std::pair<Node*, Node*> edge =
          std::make_pair(first_node_pt, last_node_pt);

        // Has the edge been included
        if (!edge_done[edge])
        {
          // Mark the edge as done
          edge_done[edge] = true;

          // Create the reversed version and mark it as done too
          std::pair<Node*, Node*> inv_edge =
            std::make_pair(last_node_pt, first_node_pt);

          // Mark the reversed edge as done
          edge_done[inv_edge] = true;

          // Mark the edge to belong to boundary b
          element_edges_on_boundary[edge] = b;
        } // if (!edge_done[edge])

        // Free the memory allocated for the face element
        delete face_ele_pt;
        face_ele_pt = 0;

      } // for (e < nbound_ele)

    } // for (b < nbound)
  }

  // ======================================================================
  // Creates polylines from the intersection of halo elements on
  // all processors. The new polylines define the shared boundaries in
  // the domain This method computes the polylines on ALL processors,
  // that is why the three dimensions in the structure
  // output_polylines_pt[iproc][ncurve][npolyline]
  // ======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::create_polylines_from_halo_elements_helper(
    const Vector<unsigned>& element_domain,
    std::map<GeneralisedElement*, unsigned>& element_to_global_index,
    std::set<FiniteElement*>& element_in_processor_pt,
    Vector<Vector<Vector<GeneralisedElement*>>>& input_halo_elements,
    std::map<std::pair<Node*, Node*>, unsigned>& elements_edges_on_boundary,
    Vector<Vector<Vector<TriangleMeshPolyLine*>>>& output_polylines_pt)
  {
    const unsigned nproc = this->communicator_pt()->nproc();
    const unsigned my_rank = this->communicator_pt()->my_rank();

    // ---------------------------------------------------------------
    // Get the edges shared between each pair of processors
    // ---------------------------------------------------------------

    // Storage for the edges (pair of nodes) shared between a pair of
    // processors
    Vector<Vector<Vector<std::pair<Node*, Node*>>>> edges(nproc);

    // Each edge is associated to two elements, a haloi (halo element
    // in processors i) and a haloj (halo element in processors j)
    Vector<Vector<Vector<Vector<FiniteElement*>>>> edge_element_pt(nproc);

    // Each edge is associated to two elements, a haloi and a haloj,
    // the edge was created from a given face from each element, the
    // haloi face is stored at [0], the haloj face is stored at [1]
    Vector<Vector<Vector<Vector<int>>>> edge_element_face(nproc);

    // Store the possible internal boundary id associated to each edge
    // (-1 if there is no association). Some edges may overlap an
    // internal boundary (and only internal boundaries)
    Vector<Vector<Vector<int>>> edge_boundary(nproc);

    // Mark those edges (pair of nodes overlapped by a shared boundary)
    std::map<std::pair<Node*, Node*>, bool> overlapped_edge;

    // Resize the containers, they store info. for each pair of
    // processors

    // First resize the global container
    Shared_boundaries_ids.resize(nproc);
    for (unsigned j = 0; j < nproc; j++)
    {
      edges[j].resize(nproc);
      edge_element_pt[j].resize(nproc);
      edge_element_face[j].resize(nproc);
      edge_boundary[j].resize(nproc);

      // Resize the global container for shared boundaries ids
      Shared_boundaries_ids[j].resize(nproc);

    } // for (j < nproc)

    // Take the halo elements of processor "iproc" and compare their
    // edges with halo elements of other processors (except itself)
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Take the halo elements of processor iproc and compare with
      // other processors
      // Start from the iproc + 1,
      // 1) To avoid comparing with itself,
      // 2) To avoid generation of repeated boundaries
      for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
      {
        // **************************************************************
        // FIRST PART
        // 1) Get the halo elements of processor "iproc" with processor
        //    "jproc"
        // 2) Get the halo elements of processor "jproc" with processor
        //    "iproc"
        // 3) Compare their edges and those that match are the ones that
        //    define the shared boundaries
        // **************************************************************

        // Storage for halo elements
        Vector<GeneralisedElement*> halo_elements_iproc_with_jproc;
        Vector<GeneralisedElement*> halo_elements_jproc_with_iproc;

        // Get the halo elements of "iproc" with "jproc"
        halo_elements_iproc_with_jproc = input_halo_elements[iproc][jproc];

        // If there are halo elements then there are shared boundaries
        const unsigned nhalo_elements_iproc_with_jproc =
          halo_elements_iproc_with_jproc.size();
        //       DEBP(nhalo_elements_iproc_with_jproc);
        if (nhalo_elements_iproc_with_jproc > 0)
        {
          // Get the halo elements of "jproc" with "iproc"
          halo_elements_jproc_with_iproc = input_halo_elements[jproc][iproc];

          // If there are halo elements then there are shared
          // boundaries
          const unsigned nhalo_elements_jproc_with_iproc =
            halo_elements_jproc_with_iproc.size();
//         DEBP(nhalo_elements_jproc_with_iproc);
#ifdef PARANOID
          if (nhalo_elements_jproc_with_iproc == 0)
          {
            // If there are halo elements of iproc with jproc there
            // MUST be halo elements on the other way round, not
            // necessary the same but at least one
            std::stringstream err;
            err << "There are no halo elements from processor (" << jproc
                << ") "
                << "with processor (" << iproc << ").\n"
                << "This is strange since there are halo elements from "
                << "processor (" << iproc << ") with processor (" << jproc
                << ").\n"
                << "Number of halo elements from (" << iproc << ") to ("
                << jproc << ") : (" << nhalo_elements_iproc_with_jproc << ")\n"
                << "Number of halo elements from (" << jproc << ") to ("
                << iproc << ") : (" << nhalo_elements_jproc_with_iproc << ")\n";
            throw OomphLibError(
              err.str(),
              "TriangleMesh::create_polylines_from_halo_elements_helper()",
              OOMPH_EXCEPTION_LOCATION);
          }
#endif
          // The edges are defined as pair of nodes
          Vector<Node*> halo_edges_iproc;
          unsigned halo_edges_counter_iproc = 0;
          Vector<Node*> halo_edges_jproc;
          unsigned halo_edges_counter_jproc = 0;

          // Map to associate the edge with the element used to create it
          std::map<std::pair<Node*, Node*>, FiniteElement*>
            edgesi_to_element_pt;

          // Map to associated the edge with the face number of the
          // element that created it
          std::map<std::pair<std::pair<Node*, Node*>, FiniteElement*>, int>
            edgesi_element_pt_to_face_index;

          // Map to associate the edge with the element used to create it
          std::map<std::pair<Node*, Node*>, FiniteElement*>
            edgesj_to_element_pt;

          // Map to associated the edge with the face number of the
          // element that created it
          std::map<std::pair<std::pair<Node*, Node*>, FiniteElement*>, int>
            edgesj_element_pt_to_face_index;

          // **************************************************************
          // 1.1) Store the edges of the "iproc" halo elements
          // **************************************************************
          // Go throught halo elements on "iproc" processor
          for (unsigned ih = 0; ih < nhalo_elements_iproc_with_jproc; ih++)
          {
#ifdef PARANOID
            unsigned e =
              element_to_global_index[halo_elements_iproc_with_jproc[ih]];
            // Only work with halo elements inside the "jproc" processor
            if (element_domain[e] != jproc)
            {
              // There was a problem on the ihalo-jhalo classification
              std::stringstream err;
              err << "There was a problem on the ihalo-jhalo classification.\n"
                  << "One of the elements, (the one with the (" << e << ")-th "
                  << "index ) is not on the (" << jproc << ")-th processor\n"
                  << "but it was stored as a halo element of processor ("
                  << iproc << ") with processor (" << jproc << ").\n";
              throw OomphLibError(
                err.str(),
                "TriangleMesh::create_polylines_from_halo_elements_helper()",
                OOMPH_EXCEPTION_LOCATION);
            }
#endif

            FiniteElement* el_pt =
              dynamic_cast<FiniteElement*>(halo_elements_iproc_with_jproc[ih]);

            if (el_pt == 0)
            {
              std::stringstream err;
              err << "The halo element (" << ih
                  << ") could not be casted to the "
                  << "FiniteElement type.\n";
              throw OomphLibError(
                err.str(),
                "TriangleMesh::create_polylines_from_halo_elements_helper()",
                OOMPH_EXCEPTION_LOCATION);
            }

#ifdef PARANOID
            // Number of nodes on this element
            const unsigned n_nodes = el_pt->nnode();

            // The number of nodes on every element should be at least
            // three since we are going to work with the cornes nodes,
            // the ones with index 0, 1 and 2
            if (n_nodes < 3)
            {
              std::stringstream err;
              err << "The number of nodes of the " << ih
                  << "-th halo element is"
                  << " (" << n_nodes << ").\nWe can not work with triangle "
                  << "elements with less than three nodes\n";
              throw OomphLibError(
                err.str(),
                "TriangleMesh::create_polylines_from_halo_elements_helper()",
                OOMPH_EXCEPTION_LOCATION);
            }
#endif

            // Get the corner nodes, the first three nodes
            Node* first_node_pt = el_pt->node_pt(0);
            Node* second_node_pt = el_pt->node_pt(1);
            Node* third_node_pt = el_pt->node_pt(2);

            // Store the edges
            halo_edges_iproc.push_back(first_node_pt);
            halo_edges_iproc.push_back(second_node_pt);
            halo_edges_counter_jproc++;

            halo_edges_iproc.push_back(second_node_pt);
            halo_edges_iproc.push_back(third_node_pt);
            halo_edges_counter_jproc++;

            halo_edges_iproc.push_back(third_node_pt);
            halo_edges_iproc.push_back(first_node_pt);
            halo_edges_counter_jproc++;

            // Store the info. of the element used to create these edges
            std::pair<Node*, Node*> edge1 =
              std::make_pair(first_node_pt, second_node_pt);
            edgesi_to_element_pt[edge1] = el_pt;

            std::pair<Node*, Node*> edge2 =
              std::make_pair(second_node_pt, third_node_pt);
            edgesi_to_element_pt[edge2] = el_pt;

            std::pair<Node*, Node*> edge3 =
              std::make_pair(third_node_pt, first_node_pt);
            edgesi_to_element_pt[edge3] = el_pt;

            // Store the face index of the edge in the element
            std::pair<std::pair<Node*, Node*>, FiniteElement*> edge_ele1 =
              std::make_pair(edge1, el_pt);
            edgesi_element_pt_to_face_index[edge_ele1] = 2;

            std::pair<std::pair<Node*, Node*>, FiniteElement*> edge_ele2 =
              std::make_pair(edge2, el_pt);
            edgesi_element_pt_to_face_index[edge_ele2] = 0;

            std::pair<std::pair<Node*, Node*>, FiniteElement*> edge_ele3 =
              std::make_pair(edge3, el_pt);
            edgesi_element_pt_to_face_index[edge_ele3] = 1;

          } // for (ih < nhalo_elements_iproc_with_jproc)

          // **************************************************************
          // 1.2) Store the edges of the "jproc" halo elements
          // **************************************************************
          // Go throught halo elements on "jproc" processor
          for (unsigned jh = 0; jh < nhalo_elements_jproc_with_iproc; jh++)
          {
#ifdef PARANOID
            unsigned e =
              element_to_global_index[halo_elements_jproc_with_iproc[jh]];
            // Only work with halo elements inside the "jproc" processor
            if (element_domain[e] != iproc)
            {
              // There was a problem on the jhalo-ihalo classification
              std::stringstream err;
              err << "There was a problem on the jhalo-ihalo classification.\n"
                  << "One of the elements, (the one with the (" << e << ")-th "
                  << "index ) is not on the (" << iproc << ")-th processor\n"
                  << "but it was stored as a halo element of processor ("
                  << jproc << ") with processor (" << iproc << ").\n";
              throw OomphLibError(
                err.str(),
                "TriangleMesh::create_polylines_from_halo_elements_helper()",
                OOMPH_EXCEPTION_LOCATION);
            }
#endif

            FiniteElement* el_pt =
              dynamic_cast<FiniteElement*>(halo_elements_jproc_with_iproc[jh]);
            if (el_pt == 0)
            {
              std::stringstream err;
              err << "The halo element (" << jh
                  << ") could not be casted to the "
                  << "FiniteElement type.\n";
              throw OomphLibError(
                err.str(),
                "TriangleMesh::create_polylines_from_halo_elements_helper()",
                OOMPH_EXCEPTION_LOCATION);
            }

#ifdef PARANOID
            // Number of nodes on this element
            const unsigned n_nodes = el_pt->nnode();

            // The number of nodes on every element should be at least
            // three since we are going to work with the cornes nodes,
            // the ones with index 0, 1 and 2
            if (n_nodes < 3)
            {
              std::stringstream err;
              err << "The number of nodes of the " << jh
                  << "-th halo element is"
                  << " (" << n_nodes << ").\nWe can not work with triangle "
                  << "elements with less than three nodes\n";
              throw OomphLibError(
                err.str(),
                "TriangleMesh::create_polylines_from_halo_elements_helper()",
                OOMPH_EXCEPTION_LOCATION);
            }
#endif

            // Get the nodes pointers
            Node* first_node_pt = el_pt->node_pt(0);
            Node* second_node_pt = el_pt->node_pt(1);
            Node* third_node_pt = el_pt->node_pt(2);

            // Store the edges
            halo_edges_jproc.push_back(first_node_pt);
            halo_edges_jproc.push_back(second_node_pt);
            halo_edges_counter_iproc++;

            halo_edges_jproc.push_back(second_node_pt);
            halo_edges_jproc.push_back(third_node_pt);
            halo_edges_counter_iproc++;

            halo_edges_jproc.push_back(third_node_pt);
            halo_edges_jproc.push_back(first_node_pt);
            halo_edges_counter_iproc++;

            // Store the info. of the element used to create these edges
            std::pair<Node*, Node*> edge1 =
              std::make_pair(first_node_pt, second_node_pt);
            edgesj_to_element_pt[edge1] = el_pt;

            std::pair<Node*, Node*> edge2 =
              std::make_pair(second_node_pt, third_node_pt);
            edgesj_to_element_pt[edge2] = el_pt;

            std::pair<Node*, Node*> edge3 =
              std::make_pair(third_node_pt, first_node_pt);
            edgesj_to_element_pt[edge3] = el_pt;

            // Store the face index of the edge in the element
            std::pair<std::pair<Node*, Node*>, FiniteElement*> edge_ele1 =
              std::make_pair(edge1, el_pt);
            edgesj_element_pt_to_face_index[edge_ele1] = 2;

            std::pair<std::pair<Node*, Node*>, FiniteElement*> edge_ele2 =
              std::make_pair(edge2, el_pt);
            edgesj_element_pt_to_face_index[edge_ele2] = 0;

            std::pair<std::pair<Node*, Node*>, FiniteElement*> edge_ele3 =
              std::make_pair(edge3, el_pt);
            edgesj_element_pt_to_face_index[edge_ele3] = 1;

          } // for (jh < nhalo_elements_jproc_with_iproc)

          // ***************************************************************
          // SECOND PART
          // 1) We already have the information of the edges on the iproc
          //    halo and jproc halo elements
          // 2) Identify the shared edges to create the shared boundaries
          //    (Only store the information but do not create the polyline)
          // ***************************************************************

          // Get the number of edges from each processor
          unsigned nhalo_iedges = halo_edges_iproc.size();
          unsigned nhalo_jedges = halo_edges_jproc.size();

          // Start comparing the edges to check which of those are
          // shared between the "ihalo_edge" and the "jhalo_edge"
          for (unsigned ihe = 0; ihe < nhalo_iedges; ihe += 2)
          {
            // Get the ihe-th edge (pair of nodes)
            Vector<Node*> ihalo_edge(2);
            ihalo_edge[0] = halo_edges_iproc[ihe];
            ihalo_edge[1] = halo_edges_iproc[ihe + 1];

            // Create the pair that defines the edge
            std::pair<Node*, Node*> tmp_edge =
              std::make_pair(ihalo_edge[0], ihalo_edge[1]);

            // Check if the edge lies on a boundary (default values is
            // -1 for no association with an internal boundary)
            int edge_boundary_id = -1;
            {
              std::map<std::pair<Node*, Node*>, unsigned>::iterator it;
              it = elements_edges_on_boundary.find(tmp_edge);
              // If the edges lie on a boundary then get the boundary id
              // on which the edges lie
              if (it != elements_edges_on_boundary.end())
              {
                // Assign the internal boundary id associated with the
                // edge
                edge_boundary_id = (*it).second;
              }
              else
              {
                // Look for the reversed version of the edge (the nodes
                // inverted)
                std::pair<Node*, Node*> rtmp_edge =
                  std::make_pair(ihalo_edge[1], ihalo_edge[0]);
                it = elements_edges_on_boundary.find(rtmp_edge);
                if (it != elements_edges_on_boundary.end())
                {
                  // Assign the internal boundary id associated with the
                  // edge
                  edge_boundary_id = (*it).second;
                }
              }
            }

            // Go through the jhalo_edge and compare with the
            // ihalo_edge
            for (unsigned jhe = 0; jhe < nhalo_jedges; jhe += 2)
            {
              // Get the jhe-th edge (pair of nodes)
              Vector<Node*> jhalo_edge(2);
              jhalo_edge[0] = halo_edges_jproc[jhe];
              jhalo_edge[1] = halo_edges_jproc[jhe + 1];

              // Comparing pointer of nodes
              if (ihalo_edge[0] == jhalo_edge[0] &&
                  ihalo_edge[1] == jhalo_edge[1])
              {
                // Create the edge (both nodes that make the edge)
                std::pair<Node*, Node*> new_edge =
                  std::make_pair(ihalo_edge[0], ihalo_edge[1]);

                // Get the elements involved in the creation of the
                // edge to check that there are elements associated to
                // the edge
                FiniteElement* haloi_ele_pt = 0;
                haloi_ele_pt = edgesi_to_element_pt[new_edge];
                FiniteElement* haloj_ele_pt = 0;
                haloj_ele_pt = edgesj_to_element_pt[new_edge];

                // Verify that there is an element associated with it
                if (haloi_ele_pt == 0 || haloj_ele_pt == 0)
                {
                  std::stringstream err;
                  err << "There is no associated elements with the new "
                      << "shared boundary. This is an storing problem,\n"
                      << "possibly related with a memory leak problem!!!\n"
                      << "The nodes that compound the edge are these:\n"
                      << "On processor (" << iproc << "):\n"
                      << "(" << ihalo_edge[0]->x(0) << ", "
                      << ihalo_edge[0]->x(1) << ") and (" << ihalo_edge[1]->x(0)
                      << ", " << ihalo_edge[1]->x(1) << ")\n\n"
                      << "On processor (" << jproc << "):\n"
                      << "(" << jhalo_edge[0]->x(0) << ", "
                      << jhalo_edge[0]->x(1) << ") and (" << jhalo_edge[1]->x(0)
                      << ", " << jhalo_edge[1]->x(1) << ")\n\n"
                      << "The nodes coordinates should be the same!!!\n";
                  throw OomphLibError(err.str(),
                                      "TriangleMesh::create_polylines_from_"
                                      "halo_elements_helper()",
                                      OOMPH_EXCEPTION_LOCATION);
                }

                // Store the edge
                edges[iproc][jproc].push_back(new_edge);

                // Is the edge overlapped by a shared boundary
                if (edge_boundary_id >= 0)
                {
                  // Mark the edge as overlapped
                  overlapped_edge[new_edge] = true;

                  // Also mark the reversed edge
                  std::pair<Node*, Node*> rev_new_edge =
                    std::make_pair(ihalo_edge[1], ihalo_edge[0]);

                  // Mark the edge as overlapped
                  overlapped_edge[rev_new_edge] = true;

                } // if (edge_boundary_id >= 0)

                // Store the internal boundary id (default -1)
                // associated to the edge
                edge_boundary[iproc][jproc].push_back(edge_boundary_id);

                // Store the two elements associated with the edge
                Vector<FiniteElement*> tmp_elements_pt;
                tmp_elements_pt.push_back(haloi_ele_pt);
                tmp_elements_pt.push_back(haloj_ele_pt);

                // Associate the edge with the elements that gave rise to it
                edge_element_pt[iproc][jproc].push_back(tmp_elements_pt);

                // Get the face index on each element that gave rise to
                // the edge

                // .. first create the pair (edge, finite_element)
                std::pair<std::pair<Node*, Node*>, FiniteElement*>
                  edge_elementi_pair = make_pair(new_edge, haloi_ele_pt);

                std::pair<std::pair<Node*, Node*>, FiniteElement*>
                  edge_elementj_pair = make_pair(new_edge, haloj_ele_pt);

                // Set default values to later check if values were
                // read from the map structure
                int face_index_haloi_ele = -1;
                face_index_haloi_ele =
                  edgesi_element_pt_to_face_index[edge_elementi_pair];
                int face_index_haloj_ele = -1;
                face_index_haloj_ele =
                  edgesj_element_pt_to_face_index[edge_elementj_pair];
                // Verify that there is an element associated with it
                if (face_index_haloi_ele == -1 || face_index_haloj_ele == -1)
                {
                  std::stringstream err;
                  err << "There is no associated face indexes to the"
                      << "elements that gave\nrise to the shared edge\n"
                      << "The nodes that compound the edge are these:\n"
                      << "On processor (" << iproc << "):\n"
                      << "(" << ihalo_edge[0]->x(0) << ", "
                      << ihalo_edge[0]->x(1) << ") and (" << ihalo_edge[1]->x(0)
                      << ", " << ihalo_edge[1]->x(1) << ")\n\n"
                      << "On processor (" << jproc << "):\n"
                      << "(" << jhalo_edge[0]->x(0) << ", "
                      << jhalo_edge[0]->x(1) << ") and (" << jhalo_edge[1]->x(0)
                      << ", " << jhalo_edge[1]->x(1) << ")\n\n"
                      << "The nodes coordinates should be the same!!!\n";
                  throw OomphLibError(err.str(),
                                      "TriangleMesh::create_polylines_from_"
                                      "halo_elements_helper()",
                                      OOMPH_EXCEPTION_LOCATION);
                } // if (face_index_haloi_ele == -1 ||
                  //     face_index_haloj_ele == -1)

                // Get the face indexes from the map structure
                Vector<int> tmp_edge_element_face_index;
                tmp_edge_element_face_index.push_back(face_index_haloi_ele);
                tmp_edge_element_face_index.push_back(face_index_haloj_ele);
                // Store the face indexes
                edge_element_face[iproc][jproc].push_back(
                  tmp_edge_element_face_index);

                break; // break for (jhe < nhalo_jedges) since edge
                       // found

              } // if (ihalo_edge[0] == jhalo_edge[0] &&
                //     ihalo_edge[1] == jhalo_edge[1])
              // Comparing nodes pointers
              else if (ihalo_edge[0] == jhalo_edge[1] &&
                       ihalo_edge[1] == jhalo_edge[0])
              {
                // Create the edge (both nodes that make the edge)
                std::pair<Node*, Node*> new_edge =
                  std::make_pair(ihalo_edge[0], ihalo_edge[1]);

                // Get the elements involved in the creation of the
                // edge
                FiniteElement* haloi_ele_pt = 0;
                haloi_ele_pt = edgesi_to_element_pt[new_edge];

                FiniteElement* haloj_ele_pt = 0;
                // Create the edge (reversed, that is how it was
                // originally stored)
                std::pair<Node*, Node*> new_edge_reversed =
                  std::make_pair(jhalo_edge[0], jhalo_edge[1]);
                haloj_ele_pt = edgesj_to_element_pt[new_edge_reversed];

                // Verify that there is an element associated with it
                if (haloi_ele_pt == 0 || haloj_ele_pt == 0)
                {
                  std::stringstream err;
                  err << "There is no associated elements with the new "
                      << "shared boundary (reversed version). This is an "
                      << "storing problem, possibly related with a memory "
                      << "leak problem!!!\n"
                      << "The nodes that compound the edge are these:\n"
                      << "On processor (" << iproc << "):\n"
                      << "(" << ihalo_edge[0]->x(0) << ", "
                      << ihalo_edge[0]->x(1) << ") and (" << ihalo_edge[1]->x(0)
                      << ", " << ihalo_edge[1]->x(1) << ")\n\n"
                      << "On processor (" << jproc << "):\n"
                      << "(" << jhalo_edge[0]->x(0) << ", "
                      << jhalo_edge[0]->x(1) << ") and (" << jhalo_edge[1]->x(0)
                      << ", " << jhalo_edge[1]->x(1) << ")\n\n"
                      << "The nodes coordinates should be the same!!!\n";
                  throw OomphLibError(err.str(),
                                      "TriangleMesh::create_polylines_from_"
                                      "halo_elements_helper()",
                                      OOMPH_EXCEPTION_LOCATION);
                }

                // Store the edge
                edges[iproc][jproc].push_back(new_edge);

                // Is the edge overlapped by a shared boundary
                if (edge_boundary_id >= 0)
                {
                  // Mark the edge as overlapped
                  overlapped_edge[new_edge] = true;

                  // Also mark the reversed edge
                  std::pair<Node*, Node*> rev_new_edge =
                    std::make_pair(ihalo_edge[1], ihalo_edge[0]);

                  // Mark the edge as overlapped
                  overlapped_edge[rev_new_edge] = true;
                } // if (edge_boundary_id >= 0)

                // Store the internal boundary id (default -1)
                // associated to the edge
                edge_boundary[iproc][jproc].push_back(edge_boundary_id);

                // Store the two elements associated with the edge
                Vector<FiniteElement*> tmp_elements_pt;
                tmp_elements_pt.push_back(haloi_ele_pt);
                tmp_elements_pt.push_back(haloj_ele_pt);

                // Associate the edge with the elements that gave rise to it
                edge_element_pt[iproc][jproc].push_back(tmp_elements_pt);

                // Get the face index on each element that gave rise to
                // the edge

                // .. first create the pair (edge, finite_element)
                std::pair<std::pair<Node*, Node*>, FiniteElement*>
                  edge_elementi_pair = make_pair(new_edge, haloi_ele_pt);

                std::pair<std::pair<Node*, Node*>, FiniteElement*>
                  edge_elementj_pair =
                    make_pair(new_edge_reversed, haloj_ele_pt);

                // Set default values to later check if values were
                // read from the map structure
                int face_index_haloi_ele = -1;
                face_index_haloi_ele =
                  edgesi_element_pt_to_face_index[edge_elementi_pair];
                int face_index_haloj_ele = -1;
                face_index_haloj_ele =
                  edgesj_element_pt_to_face_index[edge_elementj_pair];
                // Verify that there is an element associated with it
                if (face_index_haloi_ele == -1 || face_index_haloj_ele == -1)
                {
                  std::stringstream err;
                  err << "There is no associated face indexes to the"
                      << "elements that gave\nrise to the shared edge\n"
                      << "The nodes that compound the edge are these:\n"
                      << "On processor (" << iproc << "):\n"
                      << "(" << ihalo_edge[0]->x(0) << ", "
                      << ihalo_edge[0]->x(1) << ") and (" << ihalo_edge[1]->x(0)
                      << ", " << ihalo_edge[1]->x(1) << ")\n\n"
                      << "On processor (" << jproc << "):\n"
                      << "(" << jhalo_edge[0]->x(0) << ", "
                      << jhalo_edge[0]->x(1) << ") and (" << jhalo_edge[1]->x(0)
                      << ", " << jhalo_edge[1]->x(1) << ")\n\n"
                      << "The nodes coordinates should be the same!!!\n";
                  throw OomphLibError(err.str(),
                                      "TriangleMesh::create_polylines_from_"
                                      "halo_elements_helper()",
                                      OOMPH_EXCEPTION_LOCATION);
                } // if (face_index_haloi_ele == -1 ||
                  //     face_index_haloj_ele == -1)

                // Get the face indexes from the map structure
                Vector<int> tmp_edge_element_face_index;
                tmp_edge_element_face_index.push_back(face_index_haloi_ele);
                tmp_edge_element_face_index.push_back(face_index_haloj_ele);
                // Store the face indexes
                edge_element_face[iproc][jproc].push_back(
                  tmp_edge_element_face_index);

                break; // break for (jhe < nhalo_jedges) since edge found

              } // else if (ihalo_edge[0] == jhalo_edge[1] &&
                //          ihalo_edge[1] == jhalo_edge[0])

            } // for (jhe < nhaloj_edges)

          } // for (ihe < nhaloi_edges)

        } // if (nhalo_elements_iproc_with_jproc > 0)

      } // for (jproc < nproc)

    } // for (iproc < nproc)

    // ------------------------------------------------------------------
    // Compute the degree of each node in the shared edges
    // ------------------------------------------------------------------

    // Visit all the shared edges between each pair of processors,
    // visit the nodes of each edge and compute the degree of each node

    // Store the degree (valency) of each node
    std::map<Node*, unsigned> global_shared_node_degree;

#ifdef PARANOID
    // Map to check if an edge has been already visited
    std::map<std::pair<Node*, Node*>, bool> edge_done;
#endif // #ifdef PARANOID
    // Map to check if a node has been already visited
    std::map<Node*, bool> node_done;

    // Loop over the processors and get the shared edged between each
    // pair of processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Start from iproc + 1 to avoid checking with itself (there is
      // no shared edges between the same processor), and to avoid
      // double counting the edges and nodes (the shared edges between
      // processor (iproc, jproc) are the same as those between
      // processor jproc, iproc)
      for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
      {
        // Get the number of edges shared between the pair of processors
        const unsigned nshd_edges = edges[iproc][jproc].size();
#ifdef PARANOID
        // There must be the same number of information on each of the
        // containers

        // Get the number of edge elements
        const unsigned nedge_element = edge_element_pt[iproc][jproc].size();
        if (nshd_edges != nedge_element)
        {
          std::stringstream error_message;
          error_message
            << "The number of shared edges between processor iproc and jproc\n"
            << "is different form the number of edge elements between the\n"
            << "pair of processors\n"
            << "iproc: (" << iproc << ")\n"
            << "jproc: (" << jproc << ")\n"
            << "# of shared edges: (" << nshd_edges << ")\n"
            << "# of edge elements: (" << nedge_element << ")\n\n";
          throw OomphLibError(
            error_message.str(),
            "TriangleMesh::create_polylines_from_halo_elements_helper()",
            OOMPH_EXCEPTION_LOCATION);
        }

        // Get the number of edge element faces
        const unsigned nedge_element_face =
          edge_element_face[iproc][jproc].size();
        if (nshd_edges != nedge_element_face)
        {
          std::stringstream error_message;
          error_message
            << "The number of shared edges between processor iproc and jproc\n"
            << "is different form the number of edge element faces between "
               "the\n"
            << "pair of processors\n"
            << "iproc: (" << iproc << ")\n"
            << "jproc: (" << jproc << ")\n"
            << "# of shared edges: (" << nshd_edges << ")\n"
            << "# of edge element faces: (" << nedge_element_face << ")\n\n";
          throw OomphLibError(
            error_message.str(),
            "TriangleMesh::create_polylines_from_halo_elements_helper()",
            OOMPH_EXCEPTION_LOCATION);
        }

        // Get the number of edge boundaries
        const unsigned nedge_boundary = edge_boundary[iproc][jproc].size();
        if (nshd_edges != nedge_boundary)
        {
          std::stringstream error_message;
          error_message
            << "The number of shared edges between processor iproc and jproc\n"
            << "is different form the number of edge boundaries ids between "
               "the\n"
            << "pair of processors\n"
            << "iproc: (" << iproc << ")\n"
            << "jproc: (" << jproc << ")\n"
            << "# of shared edges: (" << nshd_edges << ")\n"
            << "# of edge boundaries ids: (" << nedge_boundary << ")\n\n";
          throw OomphLibError(
            error_message.str(),
            "TriangleMesh::create_polylines_from_halo_elements_helper()",
            OOMPH_EXCEPTION_LOCATION);
        }

#endif // #ifdef PARANOID

        // Loop over the shared edges between (iproc, jproc) processors
        for (unsigned se = 0; se < nshd_edges; se++)
        {
          // Get the edge
          std::pair<Node*, Node*> edge = edges[iproc][jproc][se];
#ifdef PARANOID
          // Check that the edge has not been previously visited
          if (edge_done[edge])
          {
            std::stringstream error_message;
            error_message
              << "The shared edge between processor iproc and processor\n"
              << "jproc has been already visited, this is weird since the\n"
              << "edge should not be shared by other pair of processors\n"
              << "iproc: (" << iproc << ")\n"
              << "jproc: (" << jproc << ")\n"
              << "First node of edge: (" << edge.first->x(0) << ", "
              << edge.first->x(1) << ")\n"
              << "Second node of edge: (" << edge.second->x(0) << ", "
              << edge.second->x(1) << ")\n"
              << "Associated edge boundary id: ("
              << edge_boundary[iproc][jproc][se] << ")\n\n";
            throw OomphLibError(
              error_message.str(),
              "TriangleMesh::create_polylines_from_halo_elements_helper()",
              OOMPH_EXCEPTION_LOCATION);
          }

          // Mark the edge as done
          edge_done[edge] = true;
          // Create the reversed version and include it too
          std::pair<Node*, Node*> rev_edge =
            std::make_pair(edge.second, edge.first);
          // Mark reversed edge as done
          edge_done[rev_edge] = true;
#endif // #ifdef PARANOID

          // Get each of the nodes that conform the edge
          Node* left_node_pt = edge.first;
          Node* right_node_pt = edge.second;

          // Check if the left node has been already done
          if (!node_done[left_node_pt])
          {
            // Set the degree of the node to once since this is the
            // first time it has been found
            global_shared_node_degree[left_node_pt] = 1;

          } // if (!done_node[left_node_pt])
          else
          {
            // Increase the degree of the node
            global_shared_node_degree[left_node_pt]++;
          }

          // Check if the right node has been already done
          if (!node_done[right_node_pt])
          {
            // Set the degree of the node to once since this is the
            // first time it has been found
            global_shared_node_degree[right_node_pt] = 1;
          } // if (!done_node[right_node_pt])
          else
          {
            // Increase the degree of the node
            global_shared_node_degree[right_node_pt]++;
          }

        } // for (se < nshd_edges)

      } // for (jproc < nproc)

    } // for (iproc < nproc)

    // -----------------------------------------------------------------
    // Identify those nodes living on edges of original boundaries not
    // overlapped by a shared boundary

    // Mark the nodes on original boundaries not overlapped by shared
    // boundaries
    std::map<unsigned, std::map<Node*, bool>>
      node_on_bnd_not_overlapped_by_shd_bnd;

    // Loop over the edges of the original boundaries
    for (std::map<std::pair<Node*, Node*>, unsigned>::iterator it_map =
           elements_edges_on_boundary.begin();
         it_map != elements_edges_on_boundary.end();
         it_map++)
    {
      // Get the edge
      std::pair<Node*, Node*> edge_pair = (*it_map).first;

      // Is the edge overlaped by a shared boundary
      if (!overlapped_edge[edge_pair])
      {
        // Mark the nodes of the edge as being on an edge not overlaped
        // by a shared boundary on the boundary the edge is
        unsigned b = (*it_map).second;

        // Get the left node
        Node* left_node_pt = edge_pair.first;
        node_on_bnd_not_overlapped_by_shd_bnd[b][left_node_pt] = true;

        // Get the right node
        Node* right_node_pt = edge_pair.second;
        node_on_bnd_not_overlapped_by_shd_bnd[b][right_node_pt] = true;

      } // if (!overlapped_edge[edge_pair])

    } // Loop over edges to mark those nodes on overlaped edge by
      // shared boundaries

    // ------------------------------------------------------------------
    // Now create the shared polylines but including the degree of the
    // nodes as a nw stop condition for adding more edges to the side
    // or a root edge
    // ------------------------------------------------------------------

    // Storage for new created polylines with "each processor", non
    // sorted (shared polylines of the current processor only)
    Vector<Vector<TriangleMeshPolyLine*>> unsorted_polylines_pt(nproc);

    // Map that associates the shared boundary id with the list of
    // nodes that create it (shared boundary of the current processor
    // only)
    std::map<unsigned, std::list<Node*>> shared_bnd_id_to_sorted_list_node_pt;

    // Get maximum user boundary id and set the initial shared boundary
    // id
    unsigned shared_boundary_id_start = this->nboundary();
    Initial_shared_boundary_id = shared_boundary_id_start;

    // Aqui

    // Loop over the processors and get the shared edged between each
    // pair of processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Start from iproc + 1 to avoid checking with itself (there is
      // no shared edges between the same processor), and to avoid
      // double counting the edges and nodes (the shared edges between
      // processor (iproc, jproc) are the same as those between
      // processor jproc, iproc)
      for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
      {
        // *************************************************************
        // THIRD PART
        // 1) Sort the edges (make them contiguous) so that they can
        // be used as the vertex coordinates that define a shared
        // boundary (polyline)
        // *************************************************************
        unsigned npolylines_counter = 0;
        const unsigned nedges = edges[iproc][jproc].size();

        // -----------------------------------------------------------
        // Compute all the SHARED POLYLINES
        // -----------------------------------------------------------
        // The number of sorted edges
        unsigned nsorted_edges = 0;

        // Keep track of the already done edges
        std::map<std::pair<Node*, Node*>, bool> edge_done;

        // Loop over all the edges to create all the polylines with
        // the current processors involved
        while (nsorted_edges < nedges)
        {
          // Temporaly storage for the elements associated to the
          // sorted edges
          std::list<FiniteElement*> tmp_boundary_element_pt;
          // Temporly storage for the face indexes on the element
          // that created the given edge
          std::list<int> tmp_face_index_element;
          // Get an initial pair of nodes to create an edge
          std::pair<Node*, Node*> edge;
#ifdef PARANOID
          bool found_initial_edge = false;
#endif
          int root_edge_bound_id = -1;
          unsigned iedge = 0;
          for (iedge = 0; iedge < nedges; iedge++)
          {
            edge = edges[iproc][jproc][iedge];
            // If not done then take it as initial edge
            if (!edge_done[edge])
            {
              // Get the boundary id that the edge may be overlapping
              root_edge_bound_id = edge_boundary[iproc][jproc][iedge];
#ifdef PARANOID
              found_initial_edge = true;
#endif
              nsorted_edges++;
              iedge++;
              break;
            } // if (!edge_done[edge])
          } // for (iedge < nedges)

#ifdef PARANOID
          if (!found_initial_edge)
          {
            std::ostringstream error_message;
            error_message
              << "All the edge are already done, but the number of done\n"
              << "edges (" << nsorted_edges
              << ") is still less than the total\n"
              << "number of edges (" << nedges << ").\n";
            // << "----- Possible memory leak -----\n";
            throw OomphLibError(
              error_message.str(),
              "TriangleMesh::create_polylines_from_halo_elements_helper()",
              OOMPH_EXCEPTION_LOCATION);
          }
#endif

          // Storing for the sorting nodes extracted from the
          // edges. The sorted nodes are used to create a polyline
          std::list<Node*> sorted_nodes;
          sorted_nodes.clear();

          // The initial and final nodes of the list
          Node* first_node_pt = edge.first;
          Node* last_node_pt = edge.second;

          // Push back on the list the new edge (nodes)
          sorted_nodes.push_back(first_node_pt);
          sorted_nodes.push_back(last_node_pt);

          // Get the elements associated to the edge and store them
          // in the temporaly boundary elements storage
          tmp_boundary_element_pt.push_back(
            edge_element_pt[iproc][jproc][iedge - 1][0]);
          tmp_boundary_element_pt.push_back(
            edge_element_pt[iproc][jproc][iedge - 1][1]);

          // ... then get the face index of the element from where
          // the edge came from
          tmp_face_index_element.push_back(
            edge_element_face[iproc][jproc][iedge - 1][0]);
          tmp_face_index_element.push_back(
            edge_element_face[iproc][jproc][iedge - 1][1]);

          // Mark edge as done
          edge_done[edge] = true;

          // Continue iterating if a new node (that creates a new
          // edge) is added to the list, we have just added two nodes
          // (the first and last of the root edge)
          bool node_added = true;

          // Flags to indicate at which end the node was added (left
          // or right)
          bool node_added_to_the_left = true;
          bool node_added_to_the_right = true;

          // The nodes that create a shared boundary are obtained by
          // connecting the edges shared by the halo and haloed
          // elements. These edges are connected to left or right of
          // the shared boundary. Every time a new edge is added to
          // the left (or right), the most left (or right) node is
          // searched in the list of nodes of previous shared
          // boundaries, if the node is found then it is said to be
          // shared with another boundary and a connection to that
          // boundary needs to be specified. We stop adding edges
          // (and nodes) to the side where that nodes was found to be
          // shared. Note that the intersection (shared node) may be
          // with the same shared boundary

          // Flag to indicate a node was found to be shared with
          // another boundary at the left end (most left node) of the
          // shared boundary
          bool connection_to_the_left = false;

          // Flag to indicate a node was found to be shared with
          // another boundary at the right end (most right node) of
          // the shared boundary
          bool connection_to_the_right = false;

          // Flag to stop the adding of edges (and nodes) to the
          // current shared boundary
          bool current_polyline_has_connections_at_both_ends = false;

          // Store the boundary ids of the polylines to connect (only
          // used when the polyline was found to have a connection)
          // -1: Indicates no connection
          // -2: Indicates connection with itself
          // Any other value: Boundary id to connect
          int bound_id_connection_to_the_left = -1;
          int bound_id_connection_to_the_right = -1;

          // Get the degree of the first node
          const unsigned first_node_degree =
            global_shared_node_degree[first_node_pt];

          // Check if the nodes of the root edge have connections
          // ... to the left
          bound_id_connection_to_the_left = check_connections_of_polyline_nodes(
            element_in_processor_pt,
            root_edge_bound_id,
            overlapped_edge,
            node_on_bnd_not_overlapped_by_shd_bnd,
            sorted_nodes,
            shared_bnd_id_to_sorted_list_node_pt,
            first_node_degree,
            first_node_pt);

          // If there is a connection then set the
          // corresponding flag
          // (-1): No connection
          // (-2): Connection with itself
          // (-3): No connection, stop adding nodes
          // (other value): Boundary id
          if (bound_id_connection_to_the_left != -1)
          {
            connection_to_the_left = true;
          } // if (bound_id_connection_to_the_left != -1)

          // Get the degree of the last node
          const unsigned last_node_degree =
            global_shared_node_degree[last_node_pt];

          // Check if the nodes of the root edge have connections
          // ... to the right
          bound_id_connection_to_the_right =
            check_connections_of_polyline_nodes(
              element_in_processor_pt,
              root_edge_bound_id,
              overlapped_edge,
              node_on_bnd_not_overlapped_by_shd_bnd,
              sorted_nodes,
              shared_bnd_id_to_sorted_list_node_pt,
              last_node_degree,
              last_node_pt);

          // If there is a connection then set the
          // corresponding flag
          // (-1): No connection
          // (-2): Connection with itself
          // (other value): Boundary id
          if (bound_id_connection_to_the_right != -1)
          {
            connection_to_the_right = true;
          } // if (bound_id_connection_to_the_right != -1)

          // If the current shared boundary has connections at both
          // ends then stop the adding of nodes
          if (connection_to_the_left && connection_to_the_right)
          {
            current_polyline_has_connections_at_both_ends = true;
          }

          // Continue searching for more edges if
          // 1) A new node was added at the left or right of the list
          // 2) There are more edges to possible add
          // 3) The added node is not part of any other previous
          //    shared polyline
          while (node_added && (nsorted_edges < nedges) &&
                 !current_polyline_has_connections_at_both_ends)
          {
            // Start from the next edge since we have already added
            // the previous one as the initial edge (any previous
            // edge had to be added to previous polylines)
            for (unsigned iiedge = iedge; iiedge < nedges; iiedge++)
            {
              // Reset the flags for added nodes, to the left and right
              node_added = false;
              node_added_to_the_left = false;
              node_added_to_the_right = false;
              // Get the current edge
              edge = edges[iproc][jproc][iiedge];
              const int edge_bound_id = edge_boundary[iproc][jproc][iiedge];

              // We need to ensure to connect with edges that share
              // the same bound id or with those that has no boundary
              // id associated (the default -1 value), may apply
              // exclusively to internal boundaries
              if (!edge_done[edge] && (edge_bound_id == root_edge_bound_id))
              {
                // Get each individual node
                Node* left_node_pt = edge.first;
                Node* right_node_pt = edge.second;

                // Pointer to the new added node
                Node* new_added_node_pt = 0;

                // Is the node to be added to the left?
                if (left_node_pt == first_node_pt && !connection_to_the_left)
                {
                  // Push front the new node
                  sorted_nodes.push_front(right_node_pt);
                  // Update the new added node and the first node
                  new_added_node_pt = first_node_pt = right_node_pt;
                  // Set the node added flag to true
                  node_added = true;
                  // Indicate the node was added to the left
                  node_added_to_the_left = true;
                }
                // Is the node to be added to the right?
                else if (left_node_pt == last_node_pt &&
                         !connection_to_the_right)
                {
                  // Push back the new node
                  sorted_nodes.push_back(right_node_pt);
                  // Update the new added node and the last node
                  new_added_node_pt = last_node_pt = right_node_pt;
                  // Set the node added flag to true
                  node_added = true;
                  // Indicate the node was added to the right
                  node_added_to_the_right = true;
                }
                // Is the node to be added to the left?
                else if (right_node_pt == first_node_pt &&
                         !connection_to_the_left)
                {
                  // Push front the new node
                  sorted_nodes.push_front(left_node_pt);
                  // Update the new added node and the first node
                  new_added_node_pt = first_node_pt = left_node_pt;
                  // Set the node added flag to true
                  node_added = true;
                  // Indicate the node was added to the left
                  node_added_to_the_left = true;
                }
                // Is the node to be added to the right?
                else if (right_node_pt == last_node_pt &&
                         !connection_to_the_right)
                {
                  // Push back the new node
                  sorted_nodes.push_back(left_node_pt);
                  // Update the new added node and the last node
                  new_added_node_pt = last_node_pt = left_node_pt;
                  // Set the node added flag to true
                  node_added = true;
                  // Indicate the node was added to the right
                  node_added_to_the_right = true;
                }

                // If we added a new node then we need to check if
                // that node has been already added in other shared
                // boundaries (which may define a connection)
                if (node_added)
                {
                  // Mark as done only if one of its nodes has been
                  // added to the list
                  edge_done[edge] = true;
                  nsorted_edges++;

                  // Get the degree of the added node
                  const unsigned added_node_degree =
                    global_shared_node_degree[new_added_node_pt];

                  if (node_added_to_the_left)
                  {
                    // Add the bulk elements
                    tmp_boundary_element_pt.push_front(
                      edge_element_pt[iproc][jproc][iiedge][1]);
                    tmp_boundary_element_pt.push_front(
                      edge_element_pt[iproc][jproc][iiedge][0]);
                    // Add the face elements
                    tmp_face_index_element.push_front(
                      edge_element_face[iproc][jproc][iiedge][1]);
                    tmp_face_index_element.push_front(
                      edge_element_face[iproc][jproc][iiedge][0]);
                  }

                  if (node_added_to_the_right)
                  {
                    // Add the bulk elements
                    tmp_boundary_element_pt.push_back(
                      edge_element_pt[iproc][jproc][iiedge][0]);
                    tmp_boundary_element_pt.push_back(
                      edge_element_pt[iproc][jproc][iiedge][1]);
                    // Add the face elements
                    tmp_face_index_element.push_back(
                      edge_element_face[iproc][jproc][iiedge][0]);
                    tmp_face_index_element.push_back(
                      edge_element_face[iproc][jproc][iiedge][1]);
                  }

                  // Based on which side the node was added, look for
                  // connections on that side

                  // Verify for connections to the left (we need to
                  // check for the connection variable too, since
                  // after a connection has been done we no longer
                  // need to verify for this condition)
                  if (node_added_to_the_left && !connection_to_the_left)
                  {
                    // Check for connection
                    bound_id_connection_to_the_left =
                      check_connections_of_polyline_nodes(
                        element_in_processor_pt,
                        root_edge_bound_id,
                        overlapped_edge,
                        node_on_bnd_not_overlapped_by_shd_bnd,
                        sorted_nodes,
                        shared_bnd_id_to_sorted_list_node_pt,
                        added_node_degree,
                        new_added_node_pt);

                    // If there is a connection then set the
                    // corresponding flag
                    // (-1): No connection
                    // (-2): Connection with itself
                    // (other value): Boundary id
                    if (bound_id_connection_to_the_left != -1)
                    {
                      connection_to_the_left = true;
                    } // if (bound_id_connection_to_the_left != -1)

                  } // if (node_added_to_the_left &&
                  //     !connection_to_the_left)

                  // Verify for connections to the right (we need to
                  // check for the connection variable too, since
                  // after a connection has been done we no longer
                  // need to verify for this condition)
                  if (node_added_to_the_right && !connection_to_the_right)
                  {
                    // Check for connection
                    bound_id_connection_to_the_right =
                      check_connections_of_polyline_nodes(
                        element_in_processor_pt,
                        root_edge_bound_id,
                        overlapped_edge,
                        node_on_bnd_not_overlapped_by_shd_bnd,
                        sorted_nodes,
                        shared_bnd_id_to_sorted_list_node_pt,
                        added_node_degree,
                        new_added_node_pt);

                    // If there is a connection then set the
                    // corresponding flag
                    // (-1): No connection
                    // (-2): Connection with itself
                    // (other value): Boundary id
                    if (bound_id_connection_to_the_right != -1)
                    {
                      connection_to_the_right = true;
                    } // if (bound_id_connection_to_the_right != -1)

                  } // if (node_added_to_the_right &&
                  //     !connection_to_the_right)

                  // If the current shared boundary has connections
                  // at both ends then stop the adding of nodes
                  if (connection_to_the_left && connection_to_the_right)
                  {
                    current_polyline_has_connections_at_both_ends = true;
                  }

                  // Break the for and re-start to look more edges to
                  // the left or right
                  break;

                } // if (node_added)

              } // if (!edge_done[edge])
            } // for (iiedge < nedges)

          } // while(node_added && (nsorted_edges < nedges)
          //       && !current_polyline_has_connections_at_both_ends)

          // ------------------------------------------------------------
          // If the sorted nodes of the shared polyline create a loop
          // it is necessary to break it by creating as many
          // polylines as required

          // Change the list to a vector representation of the
          // boundary elements and the face indexes

          // Get the number of boundary elements
          const unsigned n_bnd_ele = tmp_boundary_element_pt.size();

          // Storage for the boundary elements and face indexes
          Vector<FiniteElement*> tmp_bnd_ele_pt(n_bnd_ele);
          Vector<int> tmp_face_idx_ele(n_bnd_ele);
          // Helper counter
          unsigned help_counter = 0;
          // Fill the data structures
          for (std::list<FiniteElement*>::iterator it_bnd_ele =
                 tmp_boundary_element_pt.begin();
               it_bnd_ele != tmp_boundary_element_pt.end();
               it_bnd_ele++)
          {
            tmp_bnd_ele_pt[help_counter++] = (*it_bnd_ele);
          }

          // Restart counter
          help_counter = 0;
          for (std::list<int>::iterator it_face_idx =
                 tmp_face_index_element.begin();
               it_face_idx != tmp_face_index_element.end();
               it_face_idx++)
          {
            tmp_face_idx_ele[help_counter++] = (*it_face_idx);
          }

          // Store the nodes for the new shared polylines without
          // loops
          Vector<std::list<Node*>> final_sorted_nodes_pt;
          // Store the boundary elements of the shared polyline
          // without loops
          Vector<Vector<FiniteElement*>> final_boundary_element_pt;
          // Face indexes of the boundary elements without loops
          Vector<Vector<int>> final_face_index_element;
          // Connection flags (to the left) of the shared boundaries
          // without loops
          Vector<int> final_bound_id_connection_to_the_left;
          // Connection flags (to the right) of the shared boundaries
          // without loops
          Vector<int> final_bound_id_connection_to_the_right;

          // Break any possible loop created by the shared polyline
          break_loops_on_shared_polyline_helper(
            shared_boundary_id_start,
            sorted_nodes,
            tmp_bnd_ele_pt,
            tmp_face_idx_ele,
            bound_id_connection_to_the_left,
            bound_id_connection_to_the_right,
            final_sorted_nodes_pt,
            final_boundary_element_pt,
            final_face_index_element,
            final_bound_id_connection_to_the_left,
            final_bound_id_connection_to_the_right);

          // Get the number of final sorted nodes
          const unsigned n_final_sorted_nodes = final_sorted_nodes_pt.size();

          // Loop over the list of final sorted nodes
          for (unsigned i = 0; i < n_final_sorted_nodes; i++)
          {
            // --------------------------------------------------------
            // Associate the list of sorted nodes with the boundary id
            // of the shared boundary that is going to be crated
            shared_bnd_id_to_sorted_list_node_pt[shared_boundary_id_start] =
              final_sorted_nodes_pt[i];

            // Create the shared polyline and fill the data
            // structured associated to it
            create_shared_polyline(my_rank,
                                   shared_boundary_id_start,
                                   iproc,
                                   jproc,
                                   final_sorted_nodes_pt[i],
                                   root_edge_bound_id,
                                   final_boundary_element_pt[i],
                                   final_face_index_element[i],
                                   unsorted_polylines_pt,
                                   final_bound_id_connection_to_the_left[i],
                                   final_bound_id_connection_to_the_right[i]);

            // Increase the register for the number of created shared
            // polylines
            npolylines_counter++;

            // Increase the boundary id (the one that will be used by
            // the next shared boundary)
            shared_boundary_id_start++;

          } // for (i < n_final_sorted_nodes)

        } // while(nsorted_edges < nedges);

      } // for (jproc < nproc)

      // We already have all the shared polylines (shared boundaries)
      // of processor iproc with processor jproc. Now we sort them so
      // that they be contiguous and can create polygons.

      // If there are polylines to be sorted then sort them
      if (unsorted_polylines_pt[iproc].size() > 0)
      {
        // Now that we have all the new unsorted polylines on "iproc"
        // processor it is time to sort them so they be all contiguous
        sort_polylines_helper(unsorted_polylines_pt[iproc],
                              output_polylines_pt[iproc]);
      }

#ifdef PARANOID
      const unsigned nunsorted_polylines_iproc =
        unsorted_polylines_pt[iproc].size();

      // Verify that all the polylines have been sorted
      unsigned tmp_ntotal_polylines = 0;
      // Count the total number of sorted polylines
      for (unsigned ii = 0; ii < output_polylines_pt[iproc].size(); ii++)
      {
        tmp_ntotal_polylines += output_polylines_pt[iproc][ii].size();
      }
      if (tmp_ntotal_polylines != nunsorted_polylines_iproc)
      {
        std::ostringstream error_message;
        error_message << " The total number of unsorted polylines ("
                      << nunsorted_polylines_iproc
                      << ") in common with\nprocessor (" << iproc
                      << ") is different from the total number of sorted "
                      << "polylines (" << tmp_ntotal_polylines
                      << ") with\nthe same "
                      << "proessor\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      } // if (tmp_ntotal_polylines != nunsorted_polylines_iproc)
#endif

    } // for (iproc < nproc)

    // Establish the last used boundary id
    this->Final_shared_boundary_id = shared_boundary_id_start;
  }

  // ======================================================================
  // Break any possible loop created by the sorted list of nodes
  // that is used to create a new shared polyline
  // ======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::break_loops_on_shared_polyline_helper(
    const unsigned& initial_shd_bnd_id,
    std::list<Node*>& input_nodes,
    Vector<FiniteElement*>& input_boundary_element_pt,
    Vector<int>& input_face_index_element,
    const int& input_connect_to_the_left,
    const int& input_connect_to_the_right,
    Vector<std::list<Node*>>& output_sorted_nodes_pt,
    Vector<Vector<FiniteElement*>>& output_boundary_element_pt,
    Vector<Vector<int>>& output_face_index_element,
    Vector<int>& output_connect_to_the_left,
    Vector<int>& output_connect_to_the_right)
  {
    // Get the left and right node of the current list of sorted nodes
    Node* left_node_pt = input_nodes.front();
    Node* right_node_pt = input_nodes.back();

    // Temporary storage for list of nodes, boundary elements and face
    // element's indexes
    Vector<std::list<Node*>> tmp_sub_nodes;
    Vector<Vector<FiniteElement*>> tmp_sub_bnd_ele_pt;
    Vector<Vector<int>> tmp_sub_face_idx_ele;

    // Iterator for the list of input nodes
    std::list<Node*>::iterator it = input_nodes.begin();

    // Counter
    unsigned counter = 0;

    // Loop while not all nodes have been done
    while (it != input_nodes.end())
    {
      // Check if the current node is the final one
      it++;
      // Is the current node the final node?
      if (it == input_nodes.end())
      {
        // Break, add no more nodes
        break;
      }
      else
      {
        // Restore the iterator
        it--;
      }

      // Get a list of nonrepeated nodes
      std::list<Node*> sub_nodes;
      // The temporary vector of boundary elements associated with the
      // nodes
      Vector<FiniteElement*> sub_bnd_ele_pt;
      // The temporary vector of face indexes associated with the
      // boundary elements
      Vector<int> sub_face_idx_ele;

      // Add the current node to the list
      sub_nodes.push_back(*it);

      // Add nodes until found a repeated node (the left or right
      // node) or until reaching the end of the list of nodes
      do
      {
        // Go to the next node
        ++it;

        // Add the new node
        sub_nodes.push_back((*it));

        // Add the boundary elements
        sub_bnd_ele_pt.push_back(input_boundary_element_pt[counter]);
        sub_bnd_ele_pt.push_back(input_boundary_element_pt[counter + 1]);

        // Add the face indexes
        sub_face_idx_ele.push_back(input_face_index_element[counter]);
        sub_face_idx_ele.push_back(input_face_index_element[counter + 1]);

        // Increase the counter
        counter += 2;

        // Continue adding until reaching a repeated node or the end
        // of the list of nodes
      } while ((*it) != left_node_pt && (*it) != right_node_pt &&
               it != input_nodes.end());

      // Add the sub-set of nodes to the temporary storage
      tmp_sub_nodes.push_back(sub_nodes);
      // Add the face elements to the temporary storage
      tmp_sub_bnd_ele_pt.push_back(sub_bnd_ele_pt);
      // Add the face indexes to the temporary storage
      tmp_sub_face_idx_ele.push_back(sub_face_idx_ele);

    } // while((*it) != input_nodes.end())

    // --------------------------------------------------
    // Now create as many shared boundaries as required

    // Get the number of sub-list of nodes created
    const unsigned n_sub_list = tmp_sub_nodes.size();

#ifdef PARANOID
    if (n_sub_list > 3)
    {
      std::stringstream error_message;
      error_message
        << "The number of sub-list of nodes created from the shared\n"
        << "polyline with loops was (" << n_sub_list << ").\n"
        << "We can only handle up to three sub-list of nodes\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // If there is only one list it may be because there are no loops or
    // there is only one loop (a circle)
    if (n_sub_list == 1 && (left_node_pt != right_node_pt))
    {
      // There are no loops, return just after filling the data
      // structures

      // This is the base case used most of the times

      // Set the vector of lists of nodes
      output_sorted_nodes_pt = tmp_sub_nodes;
      // Set the vector of boundary elements
      output_boundary_element_pt = tmp_sub_bnd_ele_pt;
      // Set the vector of face indexes
      output_face_index_element = tmp_sub_face_idx_ele;

      // Set the connection flags, change them by the proper connection
      // flag

#ifdef PARANOID
      if (input_connect_to_the_left == -2)
      {
        std::stringstream error_message;
        error_message
          << "The connection flag to the left (" << input_connect_to_the_left
          << ") indicates a connection\n"
          << "with the same polyline.\n However, only one sub-polyline was "
          << "found and no loop\nwas identified\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // The left connection flag
      if (input_connect_to_the_left == -3)
      {
        output_connect_to_the_left.push_back(-1);
      }
      else
      {
        output_connect_to_the_left.push_back(input_connect_to_the_left);
      }

#ifdef PARANOID
      if (input_connect_to_the_right == -2)
      {
        std::stringstream error_message;
        error_message
          << "The connection flag to the right (" << input_connect_to_the_right
          << ") indicates a connection\n"
          << "with the same polyline.\n However, only one sub-polyline was "
          << "found and no loop\nwas identified\n\n";
        throw OomphLibError(
          error_message.str(),
          "TriangleMesh::break_loops_on_shared_polyline_helper()",
          OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // The right connection flag
      if (input_connect_to_the_right == -3)
      {
        output_connect_to_the_right.push_back(-1);
      }
      else
      {
        output_connect_to_the_right.push_back(input_connect_to_the_right);
      }

      // Return inmediately
      return;
    }

    // The temporary storage for the shared boundary id
    unsigned tmp_shd_bnd_id = initial_shd_bnd_id;

    // -----------------------------------------------------------------
    // Check all the sub-list of nodes and create two shared boundaries
    // from those that make a loop (circle)

    // -----------------------------------------------------------
    // Get the left and right node of the first sub-list of nodes
    Node* left_sub_node_pt = tmp_sub_nodes[0].front();
    Node* right_sub_node_pt = tmp_sub_nodes[0].back();

    // Check if the sub-list of nodes creates a loop (circle)
    if (left_sub_node_pt == right_sub_node_pt)
    {
      // We need to create two shared polylines and therefore increase
      // the shared boundary id by two

      // The first and second half of nodes
      std::list<Node*> first_half_node_pt;
      std::list<Node*> second_half_node_pt;
      // The first and second half of boundary elements
      Vector<FiniteElement*> first_half_ele_pt;
      Vector<FiniteElement*> second_half_ele_pt;
      // The first and second half of face indexes
      Vector<int> first_half_face_idx;
      Vector<int> second_half_face_idx;

      // Get the number of sub-nodes in the sub-list of nodes
      const unsigned n_sub_nodes = tmp_sub_nodes[0].size();

      // The number of sub-nodes for the first half of the shared
      // boundary
      const unsigned n_sub_nodes_half =
        static_cast<unsigned>(n_sub_nodes / 2.0);

      // Copy as many sub-nodes for the first half of the sub-polyline

      // Iterator to loop over the nodes
      std::list<Node*>::iterator it_sub = tmp_sub_nodes[0].begin();

      // Add the first node
      first_half_node_pt.push_back(*it_sub);

      // Skip the first node
      it_sub++;

      // Counter
      unsigned counter_nodes = 0;
      unsigned counter2 = 0;

      // Loop to copy the nodes
      for (; it_sub != tmp_sub_nodes[0].end(); it_sub++)
      {
        // Add the sub-node to the first half
        first_half_node_pt.push_back(*it_sub);

        // Add the boundary elements of the first half
        first_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[0][counter2]);
        first_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[0][counter2 + 1]);
        // Add the face indexes of the first half
        first_half_face_idx.push_back(tmp_sub_face_idx_ele[0][counter2]);
        first_half_face_idx.push_back(tmp_sub_face_idx_ele[0][counter2 + 1]);

        // Increase the counter of added nodes
        counter_nodes++;

        // Increase the other counter
        counter2 += 2;

        if (counter_nodes == n_sub_nodes_half)
        {
          // Stop adding to the first half of nodes
          break;
        }

      } // Copy the first half of nodes

      // The second half

      // Add the first node of the second half
      second_half_node_pt.push_back(*it_sub);

      // Skip the first node of the second half
      it_sub++;

      // Loop to copy the nodes
      for (; it_sub != tmp_sub_nodes[0].end(); it_sub++)
      {
        // Add the sub-node to the first half
        second_half_node_pt.push_back(*it_sub);

        // Add the boundary elements of the first half
        second_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[0][counter2]);
        second_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[0][counter2 + 1]);
        // Add the face indexes of the first half
        second_half_face_idx.push_back(tmp_sub_face_idx_ele[0][counter2]);
        second_half_face_idx.push_back(tmp_sub_face_idx_ele[0][counter2 + 1]);

        // Increase the other counter
        counter2 += 2;

      } // Copy the second half of nodes

      // Add the sub-list of nodes to the vector of lists of nodes
      output_sorted_nodes_pt.push_back(first_half_node_pt);
      output_sorted_nodes_pt.push_back(second_half_node_pt);
      // Add the sub-vector of elements to the vector of boundary
      // elements
      output_boundary_element_pt.push_back(first_half_ele_pt);
      output_boundary_element_pt.push_back(second_half_ele_pt);
      // Add the sub-vector of face indexes to the vector of face
      // indexes
      output_face_index_element.push_back(first_half_face_idx);
      output_face_index_element.push_back(second_half_face_idx);

      // Set the connection flags, change them by the proper connection
      // flag

      // ----------------------------------------------------------------
      // Connections flags for the first half

      // The left connection flag

      // Connected with nothing but required to stop adding nodes
      if (input_connect_to_the_left == -3)
      {
        // Set connected to nothing
        output_connect_to_the_left.push_back(-1);
      }
      // Connected with itself
      else if (input_connect_to_the_left == -2)
      {
        // Set connected to nothing, this is the base node
        output_connect_to_the_left.push_back(-1);
      }
      else
      {
        // Any other value keep it
        output_connect_to_the_left.push_back(input_connect_to_the_left);
      }

      // The right connection flag

      // Set connected to nothing, this is the base node
      output_connect_to_the_right.push_back(-1);

      // Increase the shared boundary id
      tmp_shd_bnd_id++;

      // ----------------------------------------------------------------
      // Connections flags for the second half

      // The left connection flag

      // Set connected to the previous boundary
      output_connect_to_the_left.push_back(tmp_shd_bnd_id - 1);

      // The right connection flag

      // Are we in the last sub-list of nodes, if that is the case we
      // need to respect the flag assigned to the right
      if (n_sub_list == 1)
      {
        if (input_connect_to_the_right == -3)
        {
          // Set connected to the previous shared boundary id
          output_connect_to_the_right.push_back(tmp_shd_bnd_id - 1);
        }
        else if (input_connect_to_the_right == -2)
        {
          // Set connected to the previous shared boundary id
          output_connect_to_the_right.push_back(tmp_shd_bnd_id - 1);
        }
        else if (input_connect_to_the_right == -1)
        {
          // Set connected to the previous shared boundary id
          output_connect_to_the_right.push_back(tmp_shd_bnd_id - 1);
        }
        else
        {
          // Any other value keep it
          output_connect_to_the_right.push_back(input_connect_to_the_right);
        }
      } // if (n_sub_list == 1)
      else
      {
        // Set connected to the previous shared boundary id
        output_connect_to_the_right.push_back(tmp_shd_bnd_id - 1);
      }

      // Increase the shared boundary id
      tmp_shd_bnd_id++;

    } // if (left_sub_node_pt == right_sub_node_pt)
    else
    {
      // No need to create two boundaries, create only one with the
      // sub-list of nodes

      // Add the sub-list of nodes to the vector of lists of nodes
      output_sorted_nodes_pt.push_back(tmp_sub_nodes[0]);
      // Add the sub-vector of elements to the vector of boundary
      // elements
      output_boundary_element_pt.push_back(tmp_sub_bnd_ele_pt[0]);
      // Add the sub-vector of face indexes to the vector of face
      // indexes
      output_face_index_element.push_back(tmp_sub_face_idx_ele[0]);

      // Set the connection flags, change them by the proper connection
      // flag

      // The left connection flag

      // Connected with nothing but required to stop adding nodes
      if (input_connect_to_the_left == -3)
      {
        // Set to connected to nothing
        output_connect_to_the_left.push_back(-1);
      }
      // Connected with itself
      else if (input_connect_to_the_left == -2)
      {
        // Set connected to the next shared polyline id
        output_connect_to_the_left.push_back(tmp_shd_bnd_id + 1);
      }
      else
      {
        // Any other value keep it
        output_connect_to_the_left.push_back(input_connect_to_the_left);
      }

      // The right connection flag

      // Set connected to the next shared polyline id
      output_connect_to_the_right.push_back(tmp_shd_bnd_id + 1);

      // Increase the shared boundary id by one
      tmp_shd_bnd_id++;

    } // else if (left_sub_node_pt == right_sub_node_pt)

    // At least two sub-list of nodes were created
    if (n_sub_list > 1)
    {
      // ------------------------------------------------------------
      // Get the left and right node of the second sub-list of nodes
      left_sub_node_pt = tmp_sub_nodes[1].front();
      right_sub_node_pt = tmp_sub_nodes[1].back();

      // Check if the sub-list of nodes creates a loop (circle)
      if (left_sub_node_pt == right_sub_node_pt)
      {
        // We need to create two shared polylines and therefore increase
        // the shared boundary id by two

        // The first and second half of nodes
        std::list<Node*> first_half_node_pt;
        std::list<Node*> second_half_node_pt;
        // The first and second half of boundary elements
        Vector<FiniteElement*> first_half_ele_pt;
        Vector<FiniteElement*> second_half_ele_pt;
        // The first and second half of face indexes
        Vector<int> first_half_face_idx;
        Vector<int> second_half_face_idx;

        // Get the number of sub-nodes in the sub-list of nodes
        const unsigned n_sub_nodes = tmp_sub_nodes[1].size();

        // The number of sub-nodes for the first half of the shared
        // boundary
        const unsigned n_sub_nodes_half =
          static_cast<unsigned>(n_sub_nodes / 2.0);

        // Copy as many sub-nodes for the first half of the sub-polyline

        // Iterator to loop over the nodes
        std::list<Node*>::iterator it_sub = tmp_sub_nodes[1].begin();

        // Add the first node
        first_half_node_pt.push_back(*it_sub);

        // Skip the first node
        it_sub++;

        // Counter
        unsigned counter_nodes = 0;
        unsigned counter2 = 0;

        // Loop to copy the nodes
        for (; it_sub != tmp_sub_nodes[1].end(); it_sub++)
        {
          // Add the sub-node to the first half
          first_half_node_pt.push_back(*it_sub);
          // Add the boundary elements of the first half
          first_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[1][counter2]);
          first_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[1][counter2 + 1]);
          // Add the face indexes of the first half
          first_half_face_idx.push_back(tmp_sub_face_idx_ele[1][counter2]);
          first_half_face_idx.push_back(tmp_sub_face_idx_ele[1][counter2 + 1]);

          // Increase the counter of added nodes
          counter_nodes++;

          // Increase the other counter
          counter2 += 2;

          if (counter_nodes == n_sub_nodes_half)
          {
            // Stop adding to the first half of nodes
            break;
          }

        } // Copy the first half of nodes

        // The second half

        // Add the first node of the second half
        second_half_node_pt.push_back(*it_sub);

        // Skip the first node of the second half
        it_sub++;

        // Loop to copy the nodes
        for (; it_sub != tmp_sub_nodes[1].end(); it_sub++)
        {
          // Add the sub-node to the first half
          second_half_node_pt.push_back(*it_sub);
          // Add the boundary elements of the first half
          second_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[1][counter2]);
          second_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[1][counter2 + 1]);
          // Add the face indexes of the first half
          second_half_face_idx.push_back(tmp_sub_face_idx_ele[1][counter2]);
          second_half_face_idx.push_back(tmp_sub_face_idx_ele[1][counter2 + 1]);

          // Increase the other counter
          counter2 += 2;

        } // Copy the second half of nodes

        // Add the sub-list of nodes to the vector of lists of nodes
        output_sorted_nodes_pt.push_back(first_half_node_pt);
        output_sorted_nodes_pt.push_back(second_half_node_pt);
        // Add the sub-vector of elements to the vector of boundary
        // elements
        output_boundary_element_pt.push_back(first_half_ele_pt);
        output_boundary_element_pt.push_back(second_half_ele_pt);
        // Add the sub-vector of face indexes to the vector of face
        // indexes
        output_face_index_element.push_back(first_half_face_idx);
        output_face_index_element.push_back(second_half_face_idx);

        // Set the connection flags, change them by the proper
        // connection flag

        // --------------------------------------
        // Connections flags for the first half

        // The left connection flag

        // Connected to the previous boundary
        output_connect_to_the_left.push_back(tmp_shd_bnd_id - 1);

        // The right connection flag

        // Set connected to nothing, this is the base node
        output_connect_to_the_right.push_back(-1);

        // Increase the shared boundary id
        tmp_shd_bnd_id++;

        // --------------------------------------
        // Connections flags for the second half

        // The left connection flag

        // Set connected to the previous boundary
        output_connect_to_the_left.push_back(tmp_shd_bnd_id - 1);

        // The right connection flag

        // Are we in the last sub-list of nodes, if that is the case we
        // need to respect the flag assigned to the right
        if (n_sub_list == 2)
        {
          // Connected with nothing
          if (input_connect_to_the_right == -1)
          {
            // Set connected to the previous shared boundary
            output_connect_to_the_right.push_back(tmp_shd_bnd_id - 1);
          }
          // Connected with the same boundary
          else if (input_connect_to_the_right == -2)
          {
            // Set connected to the previous shared boundary
            output_connect_to_the_right.push_back(tmp_shd_bnd_id - 1);
          }
          // Connetted with nothing but stop adding nodes
          else if (input_connect_to_the_right == -3)
          {
            // Set connected to the previous shared boundary
            output_connect_to_the_right.push_back(tmp_shd_bnd_id - 1);
          }
          else
          {
            // Any other value keep it
            output_connect_to_the_right.push_back(input_connect_to_the_right);
          }

          // Increase the shared boundary id
          tmp_shd_bnd_id++;

        } // if (n_sub_list == 2)
#ifdef PARANOID
        else
        {
          std::stringstream error_message;
          error_message
            << "The second sub-list of nodes creates a loop but this is not\n"
            << "the last list of sub-nodes.\n"
            << "This configuration is not supported\n";
          throw OomphLibError(
            error_message.str(),
            "TriangleMesh::break_loops_on_shared_polyline_helper()",
            OOMPH_EXCEPTION_LOCATION);
        }
#endif

      } // if (left_sub_node_pt == right_sub_node_pt)
      else
      {
        // No need to create two boundaries, create only one with the
        // sub-list of nodes

        // Add the sub-list of nodes to the vector of lists of nodes
        output_sorted_nodes_pt.push_back(tmp_sub_nodes[1]);
        // Add the sub-vector of elements to the vector of boundary
        // elements
        output_boundary_element_pt.push_back(tmp_sub_bnd_ele_pt[1]);
        // Add the sub-vector of face indexes to the vector of face
        // indexes
        output_face_index_element.push_back(tmp_sub_face_idx_ele[1]);

        // Set the connection flags, change them by the proper connection
        // flag

        // The left connection flag

        // Set connected to the previous shared boundary id
        output_connect_to_the_left.push_back(tmp_shd_bnd_id - 1);

        // The right connection flag

        // Are we in the last sub-list of nodes, if that is the case we
        // need to respect the flag assigned to the right
        if (n_sub_list == 2)
        {
          // Connected with nothing but required to stop adding nodes
          if (input_connect_to_the_right == -3)
          {
            // Set to connected to nothing
            output_connect_to_the_right.push_back(-1);
          }
#ifdef PARANOID
          // Connected with itself
          else if (input_connect_to_the_right == -2)
          {
            std::stringstream error_message;
            error_message
              << "The connection flag to the right ("
              << input_connect_to_the_right << ") indicates a connection\n"
              << "with the same polyline.\n However, the second sub-list of\n"
              << "nodes was found not making a loop so no connection with\n"
              << "itself should be marked\n\n";
            throw OomphLibError(
              error_message.str(),
              "TriangleMesh::break_loops_on_shared_polyline_helper()",
              OOMPH_EXCEPTION_LOCATION);
          }
#endif
          else
          {
            // Any other value keep it
            output_connect_to_the_right.push_back(input_connect_to_the_right);
          }
        } // if (n_sub_list == 2)
        else
        {
          // Set connected to the next shared boundary id
          output_connect_to_the_right.push_back(tmp_shd_bnd_id + 1);
        } // else if (n_sub_list == 2)

        // Increase the shared boundary id by one
        tmp_shd_bnd_id++;

      } // if (left_sub_node_pt == right_sub_node_pt)

    } // if (n_sub_list > 1)

    // Three sub-list of nodes were created
    if (n_sub_list > 2)
    {
      // ------------------------------------------------------------
      // Get the left and right node of the third sub-list of nodes
      left_sub_node_pt = tmp_sub_nodes[2].front();
      right_sub_node_pt = tmp_sub_nodes[2].back();

      // Check if the sub-list of nodes creates a loop (circle)
      if (left_sub_node_pt == right_sub_node_pt)
      {
        // We need to create two shared polylines and therefore increase
        // the shared boundary id by two

        // The first and second half of nodes
        std::list<Node*> first_half_node_pt;
        std::list<Node*> second_half_node_pt;
        // The first and second half of boundary elements
        Vector<FiniteElement*> first_half_ele_pt;
        Vector<FiniteElement*> second_half_ele_pt;
        // The first and second half of face indexes
        Vector<int> first_half_face_idx;
        Vector<int> second_half_face_idx;

        // Get the number of sub-nodes in the sub-list of nodes
        const unsigned n_sub_nodes = tmp_sub_nodes[2].size();

        // The number of sub-nodes for the first half of the shared
        // boundary
        const unsigned n_sub_nodes_half =
          static_cast<unsigned>(n_sub_nodes / 2.0);

        // Copy as many sub-nodes for the first half of the sub-polyline

        // Iterator to loop over the nodes
        std::list<Node*>::iterator it_sub = tmp_sub_nodes[2].begin();

        // Add the first node
        first_half_node_pt.push_back(*it_sub);

        // Skip the first node
        it_sub++;

        // Counter
        unsigned counter_nodes = 0;
        unsigned counter2 = 0;

        // Loop to copy the nodes
        for (; it_sub != tmp_sub_nodes[2].end(); it_sub++)
        {
          // Add the sub-node to the first half
          first_half_node_pt.push_back(*it_sub);
          // Add the boundary elements of the first half
          first_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[2][counter2]);
          first_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[2][counter2 + 1]);
          // Add the face indexes of the first half
          first_half_face_idx.push_back(tmp_sub_face_idx_ele[2][counter2]);
          first_half_face_idx.push_back(tmp_sub_face_idx_ele[2][counter2 + 1]);

          // Increase the counter of added nodes
          counter_nodes++;

          // Increase the other counter
          counter2 += 2;

          if (counter_nodes == n_sub_nodes_half)
          {
            // Stop adding to the first half of nodes
            break;
          }

        } // Copy the first half of nodes

        // The second half

        // Add the first node of the second half
        second_half_node_pt.push_back(*it_sub);

        // Skip the first node of the second half
        it_sub++;

        // Loop to copy the nodes
        for (; it_sub != tmp_sub_nodes[2].end(); it_sub++)
        {
          // Add the sub-node to the first half
          second_half_node_pt.push_back(*it_sub);
          // Add the boundary elements of the first half
          second_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[2][counter2]);
          second_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[2][counter2 + 1]);
          // Add the face indexes of the first half
          second_half_face_idx.push_back(tmp_sub_face_idx_ele[2][counter2]);
          second_half_face_idx.push_back(tmp_sub_face_idx_ele[2][counter2 + 1]);

          // Increase the other counter
          counter2 += 2;

        } // Copy the second half of nodes

        // Add the sub-list of nodes to the vector of lists of nodes
        output_sorted_nodes_pt.push_back(first_half_node_pt);
        output_sorted_nodes_pt.push_back(second_half_node_pt);
        // Add the sub-vector of elements to the vector of boundary
        // elements
        output_boundary_element_pt.push_back(first_half_ele_pt);
        output_boundary_element_pt.push_back(second_half_ele_pt);
        // Add the sub-vector of face indexes to the vector of face
        // indexes
        output_face_index_element.push_back(first_half_face_idx);
        output_face_index_element.push_back(second_half_face_idx);

        // --------------------------------------
        // Connections flags for the first half

        // The left connection flag

        // Connected to the previous shared boundary
        output_connect_to_the_left.push_back(tmp_shd_bnd_id - 1);

        // The right connection flag

        // Set connected to nothing, this is the base node
        output_connect_to_the_right.push_back(-1);

        // Increase the shared boundary id
        tmp_shd_bnd_id++;

        // --------------------------------------
        // Connections flags for the second half

        // The left connection flag

        // Set connected to the previous boundary
        output_connect_to_the_left.push_back(tmp_shd_bnd_id - 1);

        // The right connection flag

        if (input_connect_to_the_right == -3)
        {
          // Set connected to the previous shared boundary id
          output_connect_to_the_right.push_back(tmp_shd_bnd_id - 1);
        }
        else if (input_connect_to_the_right == -2)
        {
          // Set connected to the previous shared boundary id
          output_connect_to_the_right.push_back(tmp_shd_bnd_id - 1);
        }
        else if (input_connect_to_the_right == -1)
        {
          // Set connected to the previous shared boundary id
          output_connect_to_the_right.push_back(tmp_shd_bnd_id - 1);
        }
        else
        {
          // Any other value keep it
          output_connect_to_the_right.push_back(input_connect_to_the_right);
        }

        // Increase the shared boundary id
        tmp_shd_bnd_id++;

      } // if (left_sub_node_pt == right_sub_node_pt)
      else
      {
        // No need to create two boundaries, create only one with the
        // sub-list of nodes

        // Add the sub-list of nodes to the vector of lists of nodes
        output_sorted_nodes_pt.push_back(tmp_sub_nodes[2]);
        // Add the sub-vector of elements to the vector of boundary
        // elements
        output_boundary_element_pt.push_back(tmp_sub_bnd_ele_pt[2]);
        // Add the sub-vector of face indexes to the vector of face
        // indexes
        output_face_index_element.push_back(tmp_sub_face_idx_ele[2]);

        // Set the connection flags, change them by the proper
        // connection flag

        // The left connection flag

        // Set connected to the previous shared boundary id
        output_connect_to_the_left.push_back(tmp_shd_bnd_id - 1);

        // The right connection flag

        // Connected with nothing but required to stop adding nodes
        if (input_connect_to_the_right == -3)
        {
          std::stringstream error_message;
          error_message
            << "The connection flag to the right ("
            << input_connect_to_the_right << ") indicates 'no connection and\n"
            << "stop adding nodes'.\n However, the thrid sub-list of\n"
            << "nodes must have a connection to the right with the same\n"
            << "shared polyline or with any other polyline\n\n";
          throw OomphLibError(
            error_message.str(),
            "TriangleMesh::break_loops_on_shared_polyline_helper()",
            OOMPH_EXCEPTION_LOCATION);
        }
        else if (input_connect_to_the_right == -1)
        {
          std::stringstream error_message;
          error_message
            << "The connection flag to the right ("
            << input_connect_to_the_right << ") indicates 'no connection.\n"
            << "However, the thrid sub-list of nodes must have a connection\n"
            << "to the right with the same shared polyline or with any other\n"
            << "polyline\n\n";
          throw OomphLibError(
            error_message.str(),
            "TriangleMesh::break_loops_on_shared_polyline_helper()",
            OOMPH_EXCEPTION_LOCATION);
        }
        // Connected with itself
        else if (input_connect_to_the_right == -2)
        {
          // Set connected to the previous shared boundary id
          output_connect_to_the_right.push_back(tmp_shd_bnd_id - 1);
        }
        else
        {
          // Any other value keep it
          output_connect_to_the_right.push_back(input_connect_to_the_right);
        }

        // Increase the shared boundary id by one
        tmp_shd_bnd_id++;

      } // if (left_sub_node_pt == right_sub_node_pt)

    } // if (n_sub_list > 2)
  }

  // ======================================================================
  // Break any possible loop created by the sorted list of nodes
  // that is used to create a new shared polyline
  // ======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::
    break_loops_on_shared_polyline_load_balance_helper(
      const unsigned& initial_shd_bnd_id,
      std::list<Node*>& input_nodes,
      Vector<FiniteElement*>& input_boundary_element_pt,
      Vector<FiniteElement*>& input_boundary_face_element_pt,
      Vector<int>& input_face_index_element,
      const int& input_connect_to_the_left,
      const int& input_connect_to_the_right,
      Vector<std::list<Node*>>& output_sorted_nodes_pt,
      Vector<Vector<FiniteElement*>>& output_boundary_element_pt,
      Vector<Vector<FiniteElement*>>& output_boundary_face_element_pt,
      Vector<Vector<int>>& output_face_index_element,
      Vector<int>& output_connect_to_the_left,
      Vector<int>& output_connect_to_the_right)
  {
    // Get the left and right node of the current list of sorted nodes
    Node* left_node_pt = input_nodes.front();
    Node* right_node_pt = input_nodes.back();

    // Temporary storage for list of nodes, boundary elements, boundary
    // face elements and face element's indexes
    Vector<std::list<Node*>> tmp_sub_nodes;
    Vector<Vector<FiniteElement*>> tmp_sub_bnd_ele_pt;
    Vector<Vector<FiniteElement*>> tmp_sub_bnd_face_ele_pt;
    Vector<Vector<int>> tmp_sub_face_idx_ele;

    // Iterator for the list of input nodes
    std::list<Node*>::iterator it = input_nodes.begin();

    // Counter
    unsigned counter = 0;

    // Loop while not all nodes have been done
    while (it != input_nodes.end())
    {
      // Check if the current node is the final one
      it++;
      // Is the current node the final node?
      if (it == input_nodes.end())
      {
        // Break, add no more nodes
        break;
      }
      else
      {
        // Restore the iterator
        it--;
      }

      // Get a list of nonrepeated nodes
      std::list<Node*> sub_nodes;
      // The temporary vector of boundary elements associated with the
      // nodes
      Vector<FiniteElement*> sub_bnd_ele_pt;
      // The temporary vector of boundary face elements associated with
      // the nodes
      Vector<FiniteElement*> sub_bnd_face_ele_pt;
      // The temporary vector of face indexes associated with the
      // boundary elements
      Vector<int> sub_face_idx_ele;

      // Add the current node to the list
      sub_nodes.push_back(*it);

      // Add nodes until found a repeated node (the left or right
      // node) or until reaching the end of the list of nodes
      do
      {
        // Go to the next node
        ++it;

        // Add the new node
        sub_nodes.push_back((*it));

        // Add the boundary elements
        sub_bnd_ele_pt.push_back(input_boundary_element_pt[counter]);

        // Add the boundary face elements
        sub_bnd_face_ele_pt.push_back(input_boundary_face_element_pt[counter]);

        // Add the face indexes
        sub_face_idx_ele.push_back(input_face_index_element[counter]);

        // Increase the counter
        counter++;

        // Continue adding until reaching a repeated node or the end
        // of the list of nodes
      } while ((*it) != left_node_pt && (*it) != right_node_pt &&
               it != input_nodes.end());

      // Add the sub-set of nodes to the temporary storage
      tmp_sub_nodes.push_back(sub_nodes);

      // Add the boundary elements to the temporary storage
      tmp_sub_bnd_ele_pt.push_back(sub_bnd_ele_pt);
      // Add the boundary face elements to the temporary storage
      tmp_sub_bnd_face_ele_pt.push_back(sub_bnd_face_ele_pt);
      // Add the face indexes to the temporary storage
      tmp_sub_face_idx_ele.push_back(sub_face_idx_ele);

    } // while((*it) != input_nodes.end())

    // --------------------------------------------------
    // Now create as many shared boundaries as required

    // Get the number of sub-list of nodes created
    const unsigned n_sub_list = tmp_sub_nodes.size();

#ifdef PARANOID
    if (n_sub_list > 1)
    {
      std::stringstream error_message;
      error_message
        << "The number of sub-list of nodes created from the shared\n"
        << "polyline with loops was (" << n_sub_list << ").\n"
        << "We can only handle one list which may still contain loops\n"
        << "(or repeated nodes)\n";
      throw OomphLibError(
        error_message.str(),
        "TriangleMesh::break_loops_on_shared_polyline_load_balance_helper()",
        OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // If there is only one list it may be because there are no loops or
    // there is only one loop (a circle)
    if (n_sub_list == 1 && (left_node_pt != right_node_pt))
    {
      // There are no loops, return just after filling the data
      // structures

      // This is the base case used most of the times

      // Set the vector of lists of nodes
      output_sorted_nodes_pt = tmp_sub_nodes;
      // Set the vector of boundary elements
      output_boundary_element_pt = tmp_sub_bnd_ele_pt;
      // Set the vector of boundary face elements
      output_boundary_face_element_pt = tmp_sub_bnd_face_ele_pt;
      // Set the vector of face indexes
      output_face_index_element = tmp_sub_face_idx_ele;

      // Set the connection flags, change them by the proper connection
      // flag

#ifdef PARANOID
      if (input_connect_to_the_left == -2)
      {
        std::stringstream error_message;
        error_message
          << "The connection flag to the left (" << input_connect_to_the_left
          << ") indicates a connection\n"
          << "with the same polyline.\n However, only one sub-polyline was "
          << "found and no loops\nwere identified\n\n";
        throw OomphLibError(
          error_message.str(),
          "TriangleMesh::break_loops_on_shared_polyline_load_balance_helper()",
          OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // The left connection flag
      if (input_connect_to_the_left == -3)
      {
        output_connect_to_the_left.push_back(-1);
      }
      else
      {
        output_connect_to_the_left.push_back(input_connect_to_the_left);
      }

#ifdef PARANOID
      if (input_connect_to_the_right == -2)
      {
        std::stringstream error_message;
        error_message
          << "The connection flag to the right (" << input_connect_to_the_right
          << ") indicates a connection\n"
          << "with the same polyline.\n However, only one sub-polyline was "
          << "found and no loops\nwere identified\n\n";
        throw OomphLibError(
          error_message.str(),
          "TriangleMesh::break_loops_on_shared_polyline_load_balance_helper()",
          OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // The right connection flag
      if (input_connect_to_the_right == -3)
      {
        output_connect_to_the_right.push_back(-1);
      }
      else
      {
        output_connect_to_the_right.push_back(input_connect_to_the_right);
      }

      // Return immediately
      return;
    }

    // The temporary storage for the shared boundary id
    unsigned tmp_shd_bnd_id = initial_shd_bnd_id;

    // -----------------------------------------------------------------
    // Check all the sub-list of nodes and create two shared boundaries
    // from those that make a loop (circle)

    // -----------------------------------------------------------
    // Get the left and right node of the first sub-list of nodes
    Node* left_sub_node_pt = tmp_sub_nodes[0].front();
    Node* right_sub_node_pt = tmp_sub_nodes[0].back();

    // Check if the sub-list of nodes creates a loop (circle)
    if (left_sub_node_pt == right_sub_node_pt)
    {
      // We need to create two shared polylines and therefore increase
      // the shared boundary id by two

      // The first and second half of nodes
      std::list<Node*> first_half_node_pt;
      std::list<Node*> second_half_node_pt;
      // The first and second half of boundary elements
      Vector<FiniteElement*> first_half_ele_pt;
      Vector<FiniteElement*> second_half_ele_pt;
      // The first and second half of boundary face elements
      Vector<FiniteElement*> first_half_ele_face_pt;
      Vector<FiniteElement*> second_half_ele_face_pt;
      // The first and second half of face indexes
      Vector<int> first_half_face_idx;
      Vector<int> second_half_face_idx;

      // Get the number of sub-nodes in the sub-list of nodes
      const unsigned n_sub_nodes = tmp_sub_nodes[0].size();

      // The number of sub-nodes for the first half of the shared
      // boundary
      const unsigned n_sub_nodes_half =
        static_cast<unsigned>(n_sub_nodes / 2.0);

      // Copy as many sub-nodes for the first half of the sub-polyline

      // Iterator to loop over the nodes
      std::list<Node*>::iterator it_sub = tmp_sub_nodes[0].begin();

      // Add the first node
      first_half_node_pt.push_back(*it_sub);

      // Skip the first node
      it_sub++;

      // Counter
      unsigned counter_nodes = 0;
      unsigned counter2 = 0;

      // Loop to copy the nodes
      for (; it_sub != tmp_sub_nodes[0].end(); it_sub++)
      {
        // Add the sub-node to the first half
        first_half_node_pt.push_back(*it_sub);

        // Add the boundary elements of the first half
        first_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[0][counter2]);
        // Add the boundary face elements of the first half
        first_half_ele_face_pt.push_back(tmp_sub_bnd_face_ele_pt[0][counter2]);
        // Add the face indexes of the first half
        first_half_face_idx.push_back(tmp_sub_face_idx_ele[0][counter2]);

        // Increase the counter of added nodes
        counter_nodes++;

        // Increase the other counter (of the elements/face)
        counter2++;

        if (counter_nodes == n_sub_nodes_half)
        {
          // Stop adding to the first half of nodes
          break;
        }

      } // Copy the first half of nodes

      // The second half

      // Add the first node of the second half
      second_half_node_pt.push_back(*it_sub);

      // Skip the first node of the second half
      it_sub++;

      // Loop to copy the nodes
      for (; it_sub != tmp_sub_nodes[0].end(); it_sub++)
      {
        // Add the sub-node to the first half
        second_half_node_pt.push_back(*it_sub);

        // Add the boundary elements of the first half
        second_half_ele_pt.push_back(tmp_sub_bnd_ele_pt[0][counter2]);
        // Add the boundary face elements of the first half
        second_half_ele_face_pt.push_back(tmp_sub_bnd_face_ele_pt[0][counter2]);
        // Add the face indexes of the first half
        second_half_face_idx.push_back(tmp_sub_face_idx_ele[0][counter2]);

        // Increase the other counter
        counter2++;

      } // Copy the second half of nodes

      // Add the sub-list of nodes to the vector of lists of nodes
      output_sorted_nodes_pt.push_back(first_half_node_pt);
      output_sorted_nodes_pt.push_back(second_half_node_pt);
      // Add the sub-vector of elements to the vector of boundary
      // elements
      output_boundary_element_pt.push_back(first_half_ele_pt);
      output_boundary_element_pt.push_back(second_half_ele_pt);
      // Add the sub-vector of face elements to the vector of boundary
      // elements
      output_boundary_face_element_pt.push_back(first_half_ele_face_pt);
      output_boundary_face_element_pt.push_back(second_half_ele_face_pt);
      // Add the sub-vector of face indexes to the vector of face
      // indexes
      output_face_index_element.push_back(first_half_face_idx);
      output_face_index_element.push_back(second_half_face_idx);

      // Set the connection flags, change them by the proper connection
      // flag

      // ----------------------------------------------------------------
      // Connections flags for the first half

      // The left connection flag

      // Connected with nothing but required to stop adding nodes
      if (input_connect_to_the_left == -3)
      {
        // Set connected to nothing
        output_connect_to_the_left.push_back(-1);
      }
      // Connected with itself
      else if (input_connect_to_the_left == -2)
      {
        // Set connected to nothing, this is the base node
        output_connect_to_the_left.push_back(-1);
      }
      else
      {
        // Any other value keep it
        output_connect_to_the_left.push_back(input_connect_to_the_left);
      }

      // The right connection flag

      // Set connected to nothing, this is the base node
      output_connect_to_the_right.push_back(-1);

      // Increase the shared boundary id
      tmp_shd_bnd_id++;

      // ----------------------------------------------------------------
      // Connections flags for the second half

      // The left connection flag

      // Set connected to the previous boundary
      output_connect_to_the_left.push_back(tmp_shd_bnd_id - 1);

      // The right connection flag

      // Are we in the last sub-list of nodes, if that is the case we
      // need to respect the flag assigned to the right
      if (n_sub_list == 1)
      {
        if (input_connect_to_the_right == -3)
        {
          // Set connected to the previous shared boundary id
          output_connect_to_the_right.push_back(tmp_shd_bnd_id - 1);
        }
        else if (input_connect_to_the_right == -2)
        {
          // Set connected to the previous shared boundary id
          output_connect_to_the_right.push_back(tmp_shd_bnd_id - 1);
        }
        else if (input_connect_to_the_right == -1)
        {
          // Set connected to the previous shared boundary id
          output_connect_to_the_right.push_back(tmp_shd_bnd_id - 1);
        }
        else
        {
          // Any other value keep it
          output_connect_to_the_right.push_back(input_connect_to_the_right);
        }
      } // if (n_sub_list == 1)
      else
      {
        // Set connected to the previous shared boundary id
        output_connect_to_the_right.push_back(tmp_shd_bnd_id - 1);
      }

      // Increase the shared boundary id
      tmp_shd_bnd_id++;

    } // if (left_sub_node_pt == right_sub_node_pt)
#ifdef PARANOID
    else
    {
      std::stringstream error_message;
      error_message
        << "The initial and final node in the current shared polyline are not\n"
        << "the same and the number of sublists is (" << n_sub_list << ").\n"
        << "We can not handle more than one sublist in the method to break\n"
        << "loops at the load balance stage\n\n";
      throw OomphLibError(
        error_message.str(),
        "TriangleMesh::break_loops_on_shared_polyline_load_balance_helper()",
        OOMPH_EXCEPTION_LOCATION);
    }
#endif
  }

  // ======================================================================
  // Create the shared polyline and fill the data structured
  // that keep all the information associated with the creationg of the
  // shared boundary
  // ======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::create_shared_polyline(
    const unsigned& my_rank,
    const unsigned& shd_bnd_id,
    const unsigned& iproc,
    const unsigned& jproc,
    std::list<Node*>& sorted_nodes,
    const int& root_edge_bnd_id,
    Vector<FiniteElement*>& bulk_bnd_ele_pt,
    Vector<int>& face_index_ele,
    Vector<Vector<TriangleMeshPolyLine*>>& unsorted_polylines_pt,
    const int& connect_to_the_left_flag,
    const int& connect_to_the_right_flag)
  {
    // ----------------------------------------------------------------
    // Associate the shared boundary with the respective processors
    // ----------------------------------------------------------------

    // Setup the global look-up scheme, where all processors know the
    // associations of others processors and the shared boundaries they
    // created

    // Set up the boundary shared by "iproc" with "jproc" processor
    Shared_boundaries_ids[iproc][jproc].push_back(shd_bnd_id);

    // Set up the boundary shared by "jproc" with "iproc" processor
    Shared_boundaries_ids[jproc][iproc].push_back(shd_bnd_id);

    // Specify the processors involved on the creation of the shared
    // boundary
    Vector<unsigned> processors(2);
    processors[0] = iproc;
    processors[1] = jproc;
    Shared_boundary_from_processors[shd_bnd_id] = processors;

    // ----------------------------------------------------------------
    // If one of the processor associated with the shared boundary is
    // the current processor then it needs to create a polyline from the
    // input sorted nodes, other processors can skip this part
    if (iproc == my_rank || jproc == my_rank)
    {
      // ------------------------------------------------------------
      // Create a vertices representation from the sorted nodes list
      // ------------------------------------------------------------

      // Get the number of nodes on the list
      const unsigned n_nodes = sorted_nodes.size();
      // The vector to store the vertices (assign space)
      Vector<Vector<double>> vertices(n_nodes);

      // Copy the vertices from the nodes
      unsigned counter = 0;

      for (std::list<Node*>::iterator it = sorted_nodes.begin();
           it != sorted_nodes.end();
           it++)
      {
        vertices[counter].resize(2);
        vertices[counter][0] = (*it)->x(0);
        vertices[counter][1] = (*it)->x(1);
        counter++;
      }

      // ---------------------------------------------
      // Create the polyline from the input vertices
      // ---------------------------------------------
      TriangleMeshPolyLine* polyline_pt =
        new TriangleMeshPolyLine(vertices, shd_bnd_id);

      // ---------------------------------------------
      // Establish the internal boundary information
      // ---------------------------------------------

      // Check if the shared boundary is overlapping (or is part) of an
      // internal boundary
      if (root_edge_bnd_id != -1)
      {
        // If the shared boundary is part of an internal boundary then
        // mark the shared boundary
        Shared_boundary_overlaps_internal_boundary[shd_bnd_id] =
          static_cast<unsigned>(root_edge_bnd_id);
      } // if (root_edge_bnd_id != -1)

      // ---------------------------------------------
      // Store the boundary elements and face indexes
      // ---------------------------------------------

      // Store the shared boundary elements
      const unsigned n_shared_boundary_elements = bulk_bnd_ele_pt.size();
#ifdef PARANOID
      // Check that the number of shared boundy elements is the same as
      // the number of face indexes
      const unsigned n_face_index = face_index_ele.size();
      if (n_shared_boundary_elements != n_face_index)
      {
        std::ostringstream error_message;
        error_message
          << "The number of shared boundary elements is different from the\n"
          << "number of face indexes associated to the shared boundary\n"
          << "elements\n"
          << "Number of shared boundary elements: ("
          << n_shared_boundary_elements << ")\n"
          << "Number of face indexes: (" << n_face_index << ")\n\n";
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::create_shared_polyline()",
                            OOMPH_EXCEPTION_LOCATION);
      } // if (n_shared_boundary_elements != n_face_index)
#endif

      // Add the shared boundary elements and their respective face
      // indexes to their permanent containers
      for (unsigned i = 0; i < n_shared_boundary_elements; i++)
      {
        add_shared_boundary_element(shd_bnd_id, bulk_bnd_ele_pt[i]);
        add_face_index_at_shared_boundary(shd_bnd_id, face_index_ele[i]);
      } // for (i < nshared_boundary_elements)

      // Store the shared boundary nodes
      for (std::list<Node*>::iterator it = sorted_nodes.begin();
           it != sorted_nodes.end();
           it++)
      {
        add_shared_boundary_node(shd_bnd_id, (*it));
      } // for (it != sorted_nodes.end())

      // ----------------------------------------------------------
      // Create additional look-up schemes for the shared boundary
      // ----------------------------------------------------------

      // Updates bnd_id <---> curve section map
      this->Boundary_curve_section_pt[shd_bnd_id] = polyline_pt;

      // Check the size of the unsorted_polylines_pt structure. This
      // will have n_procs = 1 when it was called from the
      // create_new_shared_boundaries() methods
      const unsigned n_procs = unsorted_polylines_pt.size();
      if (n_procs > 1)
      {
        // Add the new created polyline to the list of unsorted
        // polylines
        unsorted_polylines_pt[iproc].push_back(polyline_pt);

        // ... do this on both processors involved in the creation of
        // the shared boundary
        unsorted_polylines_pt[jproc].push_back(polyline_pt);
      }
      else
      {
        // Add the new created polyline to the list of unsorted
        // polylines
        unsorted_polylines_pt[0].push_back(polyline_pt);
      }

      // Mark the polyline for deletion (when calling destructor)
      this->Free_curve_section_pt.insert(polyline_pt);

      // ----------------------------
      // Set connection information
      // ----------------------------

      // Check that the flags are correct, no connection or the boundary
      // id of the boundary to connect
#ifdef PARANOID
      // Is the shared polyline not connected to the left
      if (connect_to_the_left_flag < 0)
      {
        // If not connected then should be specified by -1
        if (connect_to_the_left_flag != -1)
        {
          std::ostringstream error_message;
          error_message
            << "The only accepted values for the connection flags are:\n"
            << "POSITIVE values or -1, any other value is rejected, please\n"
            << "check that you previously called the methods to deal with\n"
            << "other flag values\n"
            << "The current flag value for connection to the left is: ("
            << connect_to_the_left_flag << ")\n\n";
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::create_shared_polyline()",
                              OOMPH_EXCEPTION_LOCATION);
        } // if (connect_to_the_left_flag != -1)
      } // if (connect_to_the_left_flag < 0)

      // Is the shared polyline not connected to the right
      if (connect_to_the_right_flag < 0)
      {
        // If not connected then should be specified by -1
        if (connect_to_the_right_flag != -1)
        {
          std::ostringstream error_message;
          error_message
            << "The only accepted values for the connection flags are:\n"
            << "POSITIVE values or -1, any other value is rejected, please\n"
            << "check that you previously called the methods to deal with\n"
            << "other flag values\n"
            << "The current flag value for connection to the right is: ("
            << connect_to_the_right_flag << ")\n\n";
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::create_shared_polyline()",
                              OOMPH_EXCEPTION_LOCATION);
        } // if (connect_to_the_right_flag != -1)
      } // if (connect_to_the_right_flag < 0)
#endif

      // Set the connection to the left
      if (connect_to_the_left_flag != -1)
      {
        // Get the unsigned version of the boundary id to the left
        const unsigned bnd_id_connection_to_the_left =
          static_cast<unsigned>(connect_to_the_left_flag);
        // Set the initial vertex as connected
        polyline_pt->set_initial_vertex_connected();
        // Set the initial vertex connected boundary id
        polyline_pt->initial_vertex_connected_bnd_id() =
          bnd_id_connection_to_the_left;
        // Set the chunk number to zero
        polyline_pt->initial_vertex_connected_n_chunk() = 0;

      } // if (connect_to_the_left_flag != -1)

      // Set the connection to the right
      if (connect_to_the_right_flag != -1)
      {
        // Get the unsigned version of the boundary id to the right
        const unsigned bnd_id_connection_to_the_right =
          static_cast<unsigned>(connect_to_the_right_flag);
        // Set the final vertex as connected
        polyline_pt->set_final_vertex_connected();
        // Set the final vertex connected boundary id
        polyline_pt->final_vertex_connected_bnd_id() =
          bnd_id_connection_to_the_right;
        // Set the chunk number to zero
        polyline_pt->final_vertex_connected_n_chunk() = 0;

      } // if (connect_to_the_right_flag != -1)

    } // if (iproc == my_rank || jproc == my_rank)
  }

  //======================================================================
  /// Reset the boundary elements info. after load balance have
  /// taken place
  //======================================================================
  template<class ELEMENT>
  void TriangleMesh<ELEMENT>::reset_boundary_element_info(
    Vector<unsigned>& ntmp_boundary_elements,
    Vector<Vector<unsigned>>& ntmp_boundary_elements_in_region,
    Vector<FiniteElement*>& deleted_elements)
  {
    // Get the number of boundaries
    const unsigned nbound = this->nboundary();

    // Are there regions?
    const unsigned n_regions = this->nregion();

    // Loop over the boundaries
    for (unsigned b = 0; b < nbound; b++)
    {
      // Get the boundary elements and back them up
      // -----------------------------------------------------------------
      // Get the number of boundary elements (mixed with the old and new)
      const unsigned nbound_ele = this->nboundary_element(b);
      // Back-up the boundary elements
      Vector<FiniteElement*> backed_up_boundary_element_pt(nbound_ele);
      Vector<int> backed_up_face_index_at_boundary(nbound_ele);
      for (unsigned e = 0; e < nbound_ele; e++)
      {
        // Get the old boundary element
        backed_up_boundary_element_pt[e] = this->boundary_element_pt(b, e);
        // Get the old face index
        backed_up_face_index_at_boundary[e] =
          this->face_index_at_boundary(b, e);
      } // for (n < nold_boundary_elements)

      // Back up the elements in boundary for each region
      Vector<Vector<FiniteElement*>> backed_up_boundary_region_element_pt(
        n_regions);
      Vector<Vector<int>> backed_up_face_index_at_boundary_region(n_regions);

      // Loop over the regions and back up the boundary elements in
      // regions
      for (unsigned ir = 0; ir < n_regions; ir++)
      {
        // Get the region id
        const unsigned region_id =
          static_cast<unsigned>(this->region_attribute(ir));
        // Get the number of boundary region elements (mixed old and new)
        const unsigned nbnd_region_ele =
          this->nboundary_element_in_region(b, region_id);

        // Loop over the elements in the region
        for (unsigned e = 0; e < nbnd_region_ele; e++)
        {
          // Get the old boundary region element
          backed_up_boundary_region_element_pt[ir][e] =
            this->boundary_element_in_region_pt(b, region_id, e);

          // Get the old face index
          backed_up_face_index_at_boundary_region[ir][e] =
            this->face_index_at_boundary_in_region(b, region_id, e);
        } // for (e < nbnd_region_ele)

      } // for (ir < n_regions)

      // Clean all previous storages
      this->Boundary_element_pt[b].clear();
      this->Face_index_at_boundary[b].clear();
      if (n_regions > 0)
      {
        this->Boundary_region_element_pt[b].clear();
        this->Face_index_region_at_boundary[b].clear();
      }

      // -------------------------------------------------------------------
      // Now copy only the elements that are still alive, from those before
      // the re-establishment of halo and haloed elements
      // -------------------------------------------------------------------
      // Start with the boundary elements
      // Get the old number of boundary elements
      const unsigned nold_bnd_ele = ntmp_boundary_elements[b];
      // Loop over the boundary elements and check those still alive
      for (unsigned e = 0; e < nold_bnd_ele; e++)
      {
        FiniteElement* tmp_ele_pt = backed_up_boundary_element_pt[e];
        // Include only those elements still alive
        Vector<FiniteElement*>::iterator it = std::find(
          deleted_elements.begin(), deleted_elements.end(), tmp_ele_pt);
        // Only copy thoes elements not found on the deleted elements
        // container
        if (it == deleted_elements.end())
        {
          FiniteElement* add_ele_pt = backed_up_boundary_element_pt[e];
          this->Boundary_element_pt[b].push_back(add_ele_pt);
          const int face_index = backed_up_face_index_at_boundary[e];
          this->Face_index_at_boundary[b].push_back(face_index);
        } // if (tmp_ele_pt != 0)

      } // for (n < nold_bnd_ele)

      // ... continue with the boundary elements in specific regions

      // Loop over the regions
      for (unsigned ir = 0; ir < n_regions; ir++)
      {
        // Get the region id
        const unsigned region_id =
          static_cast<unsigned>(this->region_attribute(ir));

        // Get the old number of boundary elements in region
        const unsigned nold_bnd_region_ele =
          ntmp_boundary_elements_in_region[b][ir];

        // Loop over the boundary region elements and check those still
        // alive
        for (unsigned e = 0; e < nold_bnd_region_ele; e++)
        {
          // Get the element
          FiniteElement* tmp_ele_pt =
            backed_up_boundary_region_element_pt[ir][e];
          // Include only those elements still alive
          Vector<FiniteElement*>::iterator it = std::find(
            deleted_elements.begin(), deleted_elements.end(), tmp_ele_pt);
          // Only copy those elements not found on the deleted elements
          // container
          if (it == deleted_elements.end())
          {
            FiniteElement* add_ele_pt =
              backed_up_boundary_region_element_pt[ir][e];
            this->Boundary_region_element_pt[b][region_id].push_back(
              add_ele_pt);
            const int face_index =
              backed_up_face_index_at_boundary_region[ir][e];
            this->Face_index_region_at_boundary[b][region_id].push_back(
              face_index);
          } // if (tmp_ele_pt != 0)

        } // for (n < nbound_ele)

      } // for (ir < n_regions)

      // ----------------------------------------------------------------
      // Now copy all those elements created after the re-establishment
      // of halo and haloed elements
      // ----------------------------------------------------------------
      // Loop over the boundary elements
      for (unsigned e = nold_bnd_ele; e < nbound_ele; e++)
      {
        FiniteElement* add_ele_pt = backed_up_boundary_element_pt[e];
        this->Boundary_element_pt[b].push_back(add_ele_pt);
        const int face_index = backed_up_face_index_at_boundary[e];
        this->Face_index_at_boundary[b].push_back(face_index);
      } // for (e < nbound_ele)

      // Now add the boundary elements in regions

      // Loop over the regions
      for (unsigned ir = 0; ir < n_regions; ir++)
      {
        // Get the region id
        const unsigned region_id =
          static_cast<unsigned>(this->region_attribute(ir));

        // Get the old number of boundary elements in region
        const unsigned nold_bnd_region_ele =
          ntmp_boundary_elements_in_region[b][ir];

        // Get the new number of boundary elements in region
        const unsigned nbnd_region_ele =
          this->nboundary_element_in_region(b, region_id);

        // Loop over the boundary region elements and check those still
        // alive
        for (unsigned e = nold_bnd_region_ele; e < nbnd_region_ele; e++)
        {
          FiniteElement* add_ele_pt =
            backed_up_boundary_region_element_pt[ir][e];
          this->Boundary_region_element_pt[b][region_id].push_back(add_ele_pt);
          const int face_index = backed_up_face_index_at_boundary_region[ir][e];
          this->Face_index_region_at_boundary[b][region_id].push_back(
            face_index);
        } // for (e < nbnd_region_ele)

      } // for (ir < n_regions)

    } // for (b < nbound)

    // Lookup scheme has now been setup yet
    Lookup_for_elements_next_boundary_is_setup = true;
  }

#endif // OOMPH_HAS_MPI

#ifdef OOMPH_HAS_TRIANGLE_LIB

  //========================================================================
  /// Build a new TriangulateIO object based on target areas specified
  //========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::refine_triangulateio(
    TriangulateIO& triangulate_io,
    const Vector<double>& target_area,
    struct TriangulateIO& triangle_refine)
  {
    //  Initialize
    TriangleHelper::initialise_triangulateio(triangle_refine);

    // Store the global number of vertices and segments
    // in the list
    unsigned n_points = triangulate_io.numberofpoints;
    triangle_refine.numberofpoints = n_points;

    unsigned n_segments = triangulate_io.numberofsegments;
    triangle_refine.numberofsegments = n_segments;

    // Initialization of the TriangulateIO objects to store the values
    triangle_refine.pointlist =
      (double*)malloc(triangulate_io.numberofpoints * 2 * sizeof(double));
    triangle_refine.pointmarkerlist =
      (int*)malloc(triangulate_io.numberofpoints * sizeof(int));
    triangle_refine.segmentlist =
      (int*)malloc(triangulate_io.numberofsegments * 2 * sizeof(int));
    triangle_refine.segmentmarkerlist =
      (int*)malloc(triangulate_io.numberofsegments * sizeof(int));

    // Storing the point's coordinates in the list
    // and in two vectors with x and y coordinates
    Vector<double> x_coord(n_points);
    Vector<double> y_coord(n_points);

    for (unsigned count_point = 0; count_point < n_points * 2; count_point++)
    {
      triangle_refine.pointlist[count_point] =
        triangulate_io.pointlist[count_point];

      // Even vaules represent the x coordinate
      // Odd values represent the y coordinate
      if (count_point % 2 == 0)
      {
        x_coord[count_point / 2] = triangulate_io.pointlist[count_point];
      }
      else
      {
        y_coord[(count_point - 1) / 2] = triangulate_io.pointlist[count_point];
      }
    }

    // Store the point's markers in the list
    for (unsigned count_marker = 0; count_marker < n_points; count_marker++)
    {
      triangle_refine.pointmarkerlist[count_marker] =
        triangulate_io.pointmarkerlist[count_marker];
    }

    // Storing the segment's edges in the list
    for (unsigned count_seg = 0; count_seg < n_segments * 2; count_seg++)
    {
      triangle_refine.segmentlist[count_seg] =
        triangulate_io.segmentlist[count_seg];
    }

    // Store the segment's markers in the list
    for (unsigned count_markers = 0; count_markers < n_segments;
         count_markers++)
    {
      triangle_refine.segmentmarkerlist[count_markers] =
        triangulate_io.segmentmarkerlist[count_markers];
    }

    // Store the hole's center coordinates
    unsigned n_holes = triangulate_io.numberofholes;
    triangle_refine.numberofholes = n_holes;

    triangle_refine.holelist =
      (double*)malloc(triangulate_io.numberofholes * 2 * sizeof(double));

    // Loop over the holes to get centre coords
    for (unsigned count_hole = 0; count_hole < n_holes * 2; count_hole++)
    {
      triangle_refine.holelist[count_hole] =
        triangulate_io.holelist[count_hole];
    }

    // Store the triangles values
    unsigned n_triangles = triangulate_io.numberoftriangles;
    triangle_refine.numberoftriangles = n_triangles;

#ifdef PARANOID
    if (n_triangles != target_area.size())
    {
      std::stringstream err;
      err << "Number of triangles in triangulate_io=" << n_triangles
          << " doesn't match\n"
          << "size of target area vector (" << target_area.size() << ")\n";
      throw OomphLibError(
        err.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    unsigned n_corners = triangulate_io.numberofcorners;
    triangle_refine.numberofcorners = n_corners;

    triangle_refine.trianglelist =
      (int*)malloc(triangulate_io.numberoftriangles * 3 * sizeof(int));

    // Store the triangle's corners in the list and get element sizes
    for (unsigned count_tri = 0; count_tri < n_triangles * 3; count_tri++)
    {
      triangle_refine.trianglelist[count_tri] =
        triangulate_io.trianglelist[count_tri];
    }

    // Store the triangle's area in the list
    triangle_refine.trianglearealist =
      (double*)malloc(triangulate_io.numberoftriangles * sizeof(double));
    for (unsigned count_area = 0; count_area < n_triangles; count_area++)
    {
      triangle_refine.trianglearealist[count_area] = target_area[count_area];
    }

    // Store the triangles attributes in the list
    triangle_refine.numberoftriangleattributes =
      triangulate_io.numberoftriangleattributes;

    triangle_refine.triangleattributelist = (double*)malloc(
      triangulate_io.numberoftriangles *
      triangulate_io.numberoftriangleattributes * sizeof(double));
    for (unsigned count_attribute = 0;
         count_attribute <
         (n_triangles * triangulate_io.numberoftriangleattributes);
         count_attribute++)
    {
      triangle_refine.triangleattributelist[count_attribute] =
        triangulate_io.triangleattributelist[count_attribute];
    }
  }

#ifdef OOMPH_HAS_MPI

  // ===================================================================
  // The comparison class for the map that sorts the nodes on the
  // shared boundary (using a lexicographic order)
  // ===================================================================
  struct classcomp
  {
    // Tolerance for lower-left comparison
    static double Tol;


    // Comparison operator for "lower left" ordering
    bool operator()(const std::pair<double, double>& lhs,
                    const std::pair<double, double>& rhs) const
    {
      double diff_y = lhs.second - rhs.second;
      if (diff_y < -Tol) // (lhs.second < rhs.second)
      {
        return true;
      }
      else
      {
        // Are they "equal" with 1.0e-14 tolerance?
        if (diff_y < Tol) // (lhs.second == rhs.second)
        {
#ifdef PARANOID
          double diff_x = lhs.first - rhs.first;
          if (fabs(diff_x) < Tol)
          {
            std::ostringstream warning_message;
            warning_message
              << "Dodgy \"lower left\" (lexicographic) comparison "
              << "of points with cooordinates: "
              << " lhs = ( " << lhs.first << " , " << lhs.second << " ) \n"
              << " rhs = ( " << rhs.first << " , " << rhs.second << " ) \n"
              << "x and y coordinates differ by less than tolerance!\n"
              << "diff_x = " << diff_x << "\n"
              << "diff_y = " << diff_y << "\n"
              << "Tol    = " << Tol << "\n";
            OomphLibError(warning_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
          }
#endif
          if (lhs.first < rhs.first)
          {
            return true;
          }
          else
          {
            return false;
          }
        }
        else
        {
          return false;
        }
      }


      // if (lhs.second < rhs.second)
      //  {
      //   return true;
      //  }
      // else
      //  {
      //   // // Are "equal" with 1.0e-14 tolerance
      //   // if (lhs.second - rhs.second < 1.0e-14)
      //   // Are equal?
      //   if (lhs.second == rhs.second)
      //    {
      //     if (lhs.first < rhs.first)
      //      {
      //       return true;
      //      }
      //     else
      //      {
      //       return false;
      //      }
      //    }
      //   else
      //    {
      //     return false;
      //    }
      //  }
    }

  } Bottom_left_sorter; // struct classcomp


  // Assign value for tolerance
  double classcomp::Tol = 1.0e-14;


  //======================================================================
  // Sort the nodes on shared boundaries so that the processors that share
  // a boundary agree with the order of the nodes on the boundary
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::sort_nodes_on_shared_boundaries()
  {
    // Get the shared boundaries in this processor
    Vector<unsigned> my_rank_shared_boundaries_ids;
    this->shared_boundaries_in_this_processor(my_rank_shared_boundaries_ids);

    // Get the number of shared boundaries
    const unsigned nmy_rank_shd_bnd = my_rank_shared_boundaries_ids.size();

    // Loop over the shared boundaries
    for (unsigned i = 0; i < nmy_rank_shd_bnd; i++)
    {
      // A map is used to sort the nodes using their coordinates as the key
      // of the map
      // std::map<std::pair<double, double>, Node*> sorted_nodes_pt;
      std::map<std::pair<double, double>, Node*, classcomp> sorted_nodes_pt;


#ifdef PARANOID

      // Check min distance between nodes; had better be less than the
      // tolerance used for the bottom left sorting
      double min_distance_squared = DBL_MAX;

#endif

      // Get the boundary id
      const unsigned b = my_rank_shared_boundaries_ids[i];

      // Get the number of nodes on the current boundary
      const unsigned nbnd_node = this->nshared_boundary_node(b);

      // Go through all the nodes on the boundary and temporarily store
      // them on the map container
      for (unsigned i_node = 0; i_node < nbnd_node; i_node++)
      {
        Node* node_pt = this->shared_boundary_node_pt(b, i_node);
        std::pair<double, double> vertex =
          std::make_pair(node_pt->x(0), node_pt->x(1));
        sorted_nodes_pt[vertex] = node_pt;


#ifdef PARANOID

        // Check for minimum distance
        for (unsigned j_node = 0; j_node < nbnd_node; j_node++)
        {
          if (i_node != j_node)
          {
            Node* node2_pt = this->shared_boundary_node_pt(b, j_node);

            // Squared distance
            double squared_distance = 0.0;
            for (unsigned ii = 0; ii < 2; ii++)
            {
              squared_distance += (node_pt->x(ii) - node2_pt->x(ii)) *
                                  (node_pt->x(ii) - node2_pt->x(ii));
            }
            if (squared_distance < min_distance_squared)
            {
              min_distance_squared = squared_distance;
            }
          }
        }

        if (sqrt(min_distance_squared) < Bottom_left_sorter.Tol)
        {
          std::ostringstream warning_message;
          warning_message << "Minimum distance between nodes on boundary " << b
                          << "\n"
                          << "is " << sqrt(min_distance_squared)
                          << " which is less than "
                          << "Bottom_left_sorter.Tol = "
                          << Bottom_left_sorter.Tol << "\n"
                          << "This may screw up the ordering of the nodes on "
                             "shared boundaries\n";
          OomphLibWarning(warning_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
        }

#endif
      }

      unsigned counter = 0;
      // Resize the sorted shared boundary node vector
      this->Sorted_shared_boundary_node_pt[b].resize(nbnd_node);

      // Now go through the map container, get the elements and store their
      // members on the Sorted_shared_boundary_node_pt container
      // The map has already sorted the nodes, now they keep the same sorting
      // on all processors
      for (std::map<std::pair<double, double>, Node*>::iterator it_map =
             sorted_nodes_pt.begin();
           it_map != sorted_nodes_pt.end();
           it_map++)
      {
        // Store the pointer to the node
        this->Sorted_shared_boundary_node_pt[b][counter++] = (*it_map).second;
      }

    } // for (i < nmy_rank_shd_bnd)
  }

  //========================================================================
  // Re-establish the shared boundary elements after the adaptation
  // process (the updating of shared nodes is optional and performed by
  // default)
  //========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::
    reset_shared_boundary_elements_and_nodes(const bool flush_elements,
                                             const bool update_elements,
                                             const bool flush_nodes,
                                             const bool update_nodes)
  {
    // Get the rank of the current processor
    const unsigned my_rank = this->communicator_pt()->my_rank();

    // Go through the boundaries know as shared boundaries and copy the
    // elements to the corresponding storage

    // Get the initial shared boundary id
    const unsigned initial_id = this->initial_shared_boundary_id();

    // Get the final shared boundary id
    const unsigned final_id = this->final_shared_boundary_id();

    if (flush_elements)
    {
      // Flush the shared boundaries storage for elements
      this->flush_shared_boundary_element();
      // .. and also flush the face indexes associated with the element
      this->flush_face_index_at_shared_boundary();
    } // if (flush_elements)

    if (flush_nodes)
    {
      // Flush the shared boundaries storage for nodes
      this->flush_shared_boundary_node();
    } // if (flush_nodes)

    for (unsigned b = initial_id; b < final_id; b++)
    {
      // Check if the boundary is on the current processor
      Vector<unsigned> procs_from_shrd_bnd;
      procs_from_shrd_bnd = this->shared_boundary_from_processors(b);
      bool current_processor_has_b_boundary = false;
      const unsigned n_procs_from_shrd_bnd = procs_from_shrd_bnd.size();
      for (unsigned p = 0; p < n_procs_from_shrd_bnd; p++)
      {
        if (procs_from_shrd_bnd[p] == my_rank)
        {
          current_processor_has_b_boundary = true;
          break; // break for (p < n_procs_from_shrd_bnd)
        }
      } // for (p < n_procs_from_shrd_bnd)

      if (current_processor_has_b_boundary)
      {
        if (update_elements)
        {
          const unsigned nboundary_ele = this->nboundary_element(b);
          for (unsigned e = 0; e < nboundary_ele; e++)
          {
            // Get the boundary element and add it to the shared
            // boundary elements structure
            FiniteElement* bnd_ele_pt = this->boundary_element_pt(b, e);
            this->add_shared_boundary_element(b, bnd_ele_pt);
            // ... do the same with the face index information
            int face_index = this->face_index_at_boundary(b, e);
            this->add_face_index_at_shared_boundary(b, face_index);
          } // for (e < nboundary_element)
        } // if (update_elements)

        if (update_nodes)
        {
          const unsigned nboundary_node = this->nboundary_node(b);
          for (unsigned n = 0; n < nboundary_node; n++)
          {
            Node* bnd_node_pt = this->boundary_node_pt(b, n);
            this->add_shared_boundary_node(b, bnd_node_pt);
          } // for (n < nboundary_node)
        } // if (update_nodes)

      } // if (current_processor_has_b_boundary)
    } // for (b < final_id)
  }

  //======================================================================
  // Sort the nodes on shared boundaries so that the processors that share
  // a boundary agree with the order of the nodes on the boundary
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::reset_halo_haloed_scheme()
  {
    // Get the number of processors
    unsigned nproc = this->communicator_pt()->nproc();
    // Get the rank of the current processor
    unsigned my_rank = this->communicator_pt()->my_rank();

    // Get some timings
    double tt_start = 0.0;
    double tt_end = 0.0;
    if (Global_timings::Doc_comprehensive_timings)
    {
      tt_start = TimingHelpers::timer();
    }

    // -------------------------------------------------------------------
    // BEGIN: Get the node names and the shared nodes
    // -------------------------------------------------------------------

    // Container where to store the nodes on shared boundaries no
    // associated with the processor that receives the elements/nodes
    // other_proc_shd_bnd_node_pt[iproc][jproc][shd_bnd_id][index]
    Vector<Vector<Vector<std::map<unsigned, Node*>>>>
      other_proc_shd_bnd_node_pt(nproc);
    // Resize the container
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Resize the container
      other_proc_shd_bnd_node_pt[iproc].resize(nproc);
      for (unsigned jproc = 0; jproc < nproc; jproc++)
      {
        // Get the number of shared boundaries
        const unsigned initial_shd_bnd_id = this->initial_shared_boundary_id();
        const unsigned final_shd_bnd_id = this->final_shared_boundary_id();
        const unsigned nshared_bound = final_shd_bnd_id - initial_shd_bnd_id;
        other_proc_shd_bnd_node_pt[iproc][jproc].resize(nshared_bound);
      } // for (jproc < nproc)

    } // for (iproc < nproc)

    // Store the global node names
    // global_node_name[x][ ][ ] Global node number
    // global_node_name[ ][x][ ] Global node names
    // global_node_name[ ][ ][x] Global node info.
    Vector<Vector<Vector<unsigned>>> global_node_names;

    // Creates a map between the node name and the index of the global
    // node so we can access all its node names
    std::map<Vector<unsigned>, unsigned> node_name_to_global_index;

    // Store the global shared nodes pointers
    Vector<Node*> global_shared_node_pt;

    // Get the time for computation of global nodes names and shared
    // nodes
    double t_start_global_node_names_and_shared_nodes = TimingHelpers::timer();

    // Compute all the names of the nodes and fill in the
    // "other_proc_shd_bnd_node_pt" structure with the nodes that live
    // on this processor (my_rank) by looking over all their names
    compute_global_node_names_and_shared_nodes(other_proc_shd_bnd_node_pt,
                                               global_node_names,
                                               node_name_to_global_index,
                                               global_shared_node_pt);

    // Compute the number of elements before adding new ones
    const unsigned n_ele = this->nelement();

    if (Print_timings_level_adaptation > 1)
    {
      // The total time for computation of global nodes names and
      // shared nodes
      double t_final_global_node_names_and_shared_nodes =
        TimingHelpers::timer() - t_start_global_node_names_and_shared_nodes;
      oomph_info << "CPU for computing global node names and shared nodes "
                 << "[n_ele=" << n_ele
                 << "]: " << t_final_global_node_names_and_shared_nodes
                 << std::endl;
    }

    // -------------------------------------------------------------------
    // END: Get the node names and the shared nodes
    // -------------------------------------------------------------------

    // -------------------------------------------------------------------
    // BEGIN: Using the global node names each processor sends info. of
    // the nodes shared with other processors regarding whether they are
    // on an original boundary or not. This is required so that at the
    // re-generation of halo(ed) elements stage they have the updated
    // information
    // -------------------------------------------------------------------

    // Get the time for sending info. of shared nodes on original
    // boundaries
    double t_start_send_info_shd_nodes_on_original_bnds =
      TimingHelpers::timer();

    // Send the boundary node info. of nodes on shared boundaries across
    // processors
    send_boundary_node_info_of_shared_nodes(
      global_node_names, node_name_to_global_index, global_shared_node_pt);

    if (Print_timings_level_adaptation > 1)
    {
      // The total time for sending info. of shared nodes lying on
      // original boundaries
      oomph_info
        << "CPU for sending info. of shared nodes on original boundaries: "
        << TimingHelpers::timer() - t_start_send_info_shd_nodes_on_original_bnds
        << std::endl;
    }

    // -------------------------------------------------------------------
    // END: Using the global node names each processor sends info. of
    // the nodes shared with other processors regarding whether they are
    // on an original boundary or not. This is required so that at the
    // re-generation of halo(ed) elements stage they have the updated
    // information
    // -------------------------------------------------------------------

    // -------------------------------------------------------------------
    // BEGIN: Identify the elements of the mesh that have nodes on the
    // shared boundaries
    // -------------------------------------------------------------------

    // Store the elements that have a node on a shared boundary with
    // other processors
    // ele_with_node_on_shd_bnd_pt[x][ ][ ]: iproc
    // ele_with_node_on_shd_bnd_pt[ ][x][ ]: ishd boundary with iproc
    // ele_with_node_on_shd_bnd_pt[ ][ ][x]: element with node on shared
    //                                       boundary with iproc
    Vector<Vector<Vector<FiniteElement*>>> ele_with_node_on_shd_bnd_pt(nproc);
    // Resize the container with the number of shared boundaries within
    // each processor

    // loop over the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      const unsigned n_shd_bnd_iproc = this->nshared_boundaries(my_rank, iproc);
      ele_with_node_on_shd_bnd_pt[iproc].resize(n_shd_bnd_iproc);
    } // for (iproc < nproc)

    // Go through all the elements and check whether any of their nodes
    // lies on any of the shared boundaries

    // loop over the elements
    for (unsigned e = 0; e < n_ele; e++)
    {
      // Get the element
      FiniteElement* ele_pt = this->finite_element_pt(e);
      // Get the number of nodes
      const unsigned n_nodes = ele_pt->nnode();
      // loop over the nodes and check whether any of them lies on a
      // shared boundary
      for (unsigned n = 0; n < n_nodes; n++)
      {
        // Get the node
        Node* node_pt = ele_pt->node_pt(n);

        // Now check whether the current node lies on a shared boundary
        // within any other processor

        // loop over the processors
        for (unsigned iproc = 0; iproc < nproc; iproc++)
        {
          // The number of boundaries shared with the current processor
          // (if iproc==my_rank then there are no shared boundaries
          // between them)
          const unsigned n_shd_bnd_iproc =
            this->nshared_boundaries(my_rank, iproc);

          // There are no info. with myself
          if (iproc != my_rank && n_shd_bnd_iproc > 0)
          {
            // Get the boundaries ids of the shared boundaries with
            // iproc processor
            Vector<unsigned> shd_bnd_ids =
              this->shared_boundaries_ids(my_rank, iproc);

            // Loop over shd bnds with processor "iproc"
            for (unsigned isb = 0; isb < n_shd_bnd_iproc; isb++)
            {
              const unsigned shd_bnd_id = shd_bnd_ids[isb];
              const unsigned n_ele_shd_bnd =
                this->nshared_boundary_element(shd_bnd_id);

              // Check if the node is on this boundary only if there are
              // elements on it
              if (n_ele_shd_bnd > 0 &&
                  this->is_node_on_shared_boundary(shd_bnd_id, node_pt))
              {
                // Add the element into those that have a
                // node on the current shared boundary
                ele_with_node_on_shd_bnd_pt[iproc][isb].push_back(ele_pt);

              } // Are there elements on the boundary and the node lies
                // on this boundary

            } // for (isb < n_shd_bnd_iproc)

          } // if (iproc != my_rank && n_shd_bnd_iproc > 0)

        } // for (iproc < nproc)

      } // for (n < n_nodes)

    } // for (e < n_ele)

    // -------------------------------------------------------------------
    // END: Identify the elements of the mesh that have nodes on the
    // shared boundaries
    // -------------------------------------------------------------------

    // -------------------------------------------------------------------
    // BEGIN: Create the halo(ed) elements. Loop over the processors and
    // the shared boundaries within each processor. Get the elements on
    // the shared boundaries, mark them as haloed in this processor and
    // as halo on the element that will receive the info.
    // -------------------------------------------------------------------

    // ********************************************************************
    // General strategy:
    // 1) Go through all the elements on the shared boundaries, mark these
    //    elements as haloed, same as their nodes.
    // 2) Package the info. of the nodes and the elements.
    // 3) Send and receive the info across processors
    // 4) Unpackage it and create halo elements and nodes as indicated by
    // the received info.
    // ********************************************************************

    // Keep track of the currently created nodes within each
    // processor. We need to keep track of these nodes so they can be
    // referred at a second stage.
    Vector<Vector<Node*>> iproc_currently_created_nodes_pt(nproc);

    // Get the time to re-generate halo(ed) elements/nodes (first stage)
    double t_start_regenerate_halo_ed_elements_nodes_first_stage =
      TimingHelpers::timer();

    // Go through all processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Send and receive info. to/from other processors
      if (iproc != my_rank)
      {
        // Get the number of boundaries shared with the send proc (iproc)
        const unsigned nshared_boundaries_with_iproc =
          this->nshared_boundaries(my_rank, iproc);

        if (nshared_boundaries_with_iproc > 0)
        {
          // ******************************************************************
          // Stage 1
          // ******************************************************************
          // Step (1) Mark the elements adjacent to the shared boundaries as
          //          haloed, mark the nodes on these elements as haloed nodes
          // Step (2) Create packages of information indicating the generation
          //          of halo elements and nodes
          // ******************************************************************

          // Clean send and receive buffers
          Flat_packed_unsigneds.clear();
          Flat_packed_doubles.clear();
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
          Flat_packed_unsigneds_string.clear();
#endif

          // Get the boundaries ids shared with "iproc"
          Vector<unsigned> bound_shared_with_iproc;
          bound_shared_with_iproc = this->shared_boundaries_ids(my_rank, iproc);

          // Loop over shared boundaries with processor "iproc"
          for (unsigned bs = 0; bs < nshared_boundaries_with_iproc; bs++)
          {
            const unsigned bnd_id = bound_shared_with_iproc[bs];
            //          DEBP(bnd_id);
            const unsigned nel_bnd = this->nshared_boundary_element(bnd_id);
            //          DEBP(nel_bnd);

            // Container to store the elements marked as haloed
            Vector<FiniteElement*> haloed_element;

            // All the elements adjacent to the boundary should be
            // marked as haloed elements
            if (nel_bnd > 0)
            {
              // Map to know which element have been already added
              std::map<FiniteElement*, bool> already_added;

              // Loop over the elements adjacent to boundary "bnd_id"
              for (unsigned e = 0; e < nel_bnd; e++)
              {
                // Get pointer to the element adjacent to boundary bnd_id
                FiniteElement* ele_pt =
                  this->shared_boundary_element_pt(bnd_id, e);

                // Check if the element has been already added. Elemets
                // are repeated if they have two faces on the shared
                // boundary
                if (!already_added[ele_pt])
                {
                  // Add the element to the container of haloed elements
                  haloed_element.push_back(ele_pt);
                  // Mark the element as already added
                  already_added[ele_pt] = true;
                }

              } // for (e < nel_bnd)

              // In addition to the elements on the boundary we also
              // need to mark (as haloed) any element on the mesh with a
              // node on the shared boundary

              // Get the number of elements with a node on the current
              // shared boundary
              const unsigned n_ele_with_node_on_shd_bnd =
                ele_with_node_on_shd_bnd_pt[iproc][bs].size();
              // loop and add the elements that have a node on the
              // current shared boundary with the current processor
              for (unsigned iele = 0; iele < n_ele_with_node_on_shd_bnd; iele++)
              {
                // Get the element
                FiniteElement* ele_pt =
                  ele_with_node_on_shd_bnd_pt[iproc][bs][iele];
                // Check if it has not been already added
                if (!already_added[ele_pt])
                {
                  // Add it!!
                  haloed_element.push_back(ele_pt);
                  // Mark it as done
                  already_added[ele_pt] = true;
                } // if (!already_added[ele_pt])

              } // for (iele < n_ele_with_node_on_shd_bnd)

            } // if (nel_bnd > 0)

            // Get the total number of haloed elements
            const unsigned nhaloed_ele = haloed_element.size();
            // DEBP(nhaloed_ele);
            // DEBP(my_rank);
            // DEBP(iproc);
            // The very first data of the flat packed is the number of haloed
            // elements, this will be the number of halo element to create on
            // the receiver processor
            Flat_packed_unsigneds.push_back(nhaloed_ele);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
            std::stringstream junk;
            junk << "Number of haloed elements " << nhaloed_ele;
            Flat_packed_unsigneds_string.push_back(junk.str());
#endif

            // Loop over the marked haloed elements
            for (unsigned e = 0; e < nhaloed_ele; e++)
            {
              // Get pointer to the marked haloed element
              FiniteElement* ele_pt = haloed_element[e];
              const unsigned nroot_haloed_ele =
                this->nroot_haloed_element(iproc);

              // Check if the element has been already added to the
              // halo(ed) scheme
              GeneralisedElement* gen_ele_pt = ele_pt;
              const unsigned haloed_ele_index =
                this->try_to_add_root_haloed_element_pt(iproc, gen_ele_pt);

              // Was the element added or only returned the index of the
              // element
              if (nroot_haloed_ele == haloed_ele_index)
              {
                Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
                Flat_packed_unsigneds_string.push_back(
                  "Haloed element needs to be constructed");
#endif

                // Get additional info. related with the haloed element
                get_required_elemental_information_helper(iproc, ele_pt);

                // Get the nodes on the element
                const unsigned nnodes = ele_pt->nnode();
                for (unsigned j = 0; j < nnodes; j++)
                {
                  Node* node_pt = ele_pt->node_pt(j);

                  // Package the info. of the nodes
                  // The destination processor goes in the arguments
                  add_haloed_node_helper(iproc, node_pt);

                } // for (j < nnodes)
              } // add the element and send its nodes
              else // The haloed element already exists
              {
                Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
                Flat_packed_unsigneds_string.push_back(
                  "Haloed element already exists");
#endif
                Flat_packed_unsigneds.push_back(haloed_ele_index);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
                Flat_packed_unsigneds_string.push_back(
                  "Index of existing haloed element");
#endif
              } // else (next_haloed_ele == external_haloed_ele_index)
            } // for (e < nel_bnd)

          } // for (bs < nshared_boundaries_with_iproc)

          // *******************************************************************
          // Stage (2)
          // *******************************************************************
          // Step (1) Send and receive the data to create halo elements and
          //          nodes
          // *******************************************************************
          // The processor to which send the elements
          int send_proc = static_cast<int>(iproc);
          // The processor from which receive the elements
          int recv_proc = static_cast<int>(iproc);
          send_and_receive_elements_nodes_info(send_proc, recv_proc);

          // *******************************************************************
          // Stage (3)
          // *******************************************************************
          // Step (1) Unpackage the info and create the halo elements and nodes
          // *******************************************************************

          // Reset the counters
          Counter_for_flat_packed_doubles = 0;
          Counter_for_flat_packed_unsigneds = 0;

          // Loop over shared boundaries with processor "iproc"
          for (unsigned bs = 0; bs < nshared_boundaries_with_iproc; bs++)
          {
            // Get the number of halo element to be created
            const unsigned nhaloed_ele =
              Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
            oomph_info
              << "Rec:" << Counter_for_flat_packed_unsigneds
              << " Number of elements need to be constructed "
              << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
              << std::endl;
#endif

            // Loop over boundaries shared with processor "urecv_proc"
            for (unsigned e = 0; e < nhaloed_ele; e++)
            {
              // Create halo element from received info. of "iproc"
              // processor on the current processor
              create_halo_element(iproc,
                                  iproc_currently_created_nodes_pt[iproc],
                                  other_proc_shd_bnd_node_pt,
                                  global_node_names,
                                  node_name_to_global_index,
                                  global_shared_node_pt);

            } // for (e < nhaloed_ele)

          } // for (bs < nshared_boundaries_with_iproc)

        } // if (nshared_bound_recv_proc > 0)

      } // if (iproc != my_rank)

    } // for (iproc < nproc) (general loop to send and receive info.)

    if (Print_timings_level_adaptation > 1)
    {
      // Get the time to re-generate halo(ed) elements/nodes (first stage)
      double t_final_regenerate_halo_ed_elements_nodes_first_stage =
        TimingHelpers::timer() -
        t_start_regenerate_halo_ed_elements_nodes_first_stage;

      oomph_info << "CPU for re-generating halo(ed) elements/nodes "
                 << "(first stage) [n_ele=" << n_ele << "]: "
                 << t_final_regenerate_halo_ed_elements_nodes_first_stage
                 << std::endl;
    }

    // -------------------------------------------------------------------
    // END: Create the halo(ed) elements. Loop over the processors and
    // the shared boundaries within each processor. Get the elements on
    // the shared boundaries, mark them as haloed in this processor and
    // as halo on the element that will receive the info.
    // -------------------------------------------------------------------

    // -------------------------------------------------------------------
    // BEGIN: Create any additional haloed element, those that dont lie
    // on a shared boundary but that shared a node with other processor
    // -------------------------------------------------------------------

    // Get the time to re-generate halo(ed) elements/nodes (second stage)
    double t_start_regenerate_halo_ed_elements_nodes_second_stage =
      TimingHelpers::timer();

    // Create any additional halo(ed) elements between processors that
    // have no shared boundaries but that have shared nodes
    reset_halo_haloed_scheme_helper(other_proc_shd_bnd_node_pt,
                                    iproc_currently_created_nodes_pt,
                                    global_node_names,
                                    node_name_to_global_index,
                                    global_shared_node_pt);

    if (Print_timings_level_adaptation > 1)
    {
      // Get the time to re-generate halo(ed) elements/nodes (second stage)
      double t_final_regenerate_halo_ed_elements_nodes_second_stage =
        TimingHelpers::timer() -
        t_start_regenerate_halo_ed_elements_nodes_second_stage;

      oomph_info << "CPU for re-generating halo(ed) elements/nodes "
                 << "(second stage) [n_ele=" << n_ele << "]: "
                 << t_final_regenerate_halo_ed_elements_nodes_second_stage
                 << std::endl;
    }

    // -------------------------------------------------------------------
    // END: Create any additional haloed element, those that dont lie on
    // a shared boundary but that shared a node with other processor
    // -------------------------------------------------------------------

    // Clean send and receive buffers
    Flat_packed_unsigneds.clear();
    Flat_packed_doubles.clear();
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    Flat_packed_unsigneds_string.clear();
#endif

    // Document the timings for reseting halo and haloed scheme (without
    // classification of halo and haloed nodes)
    if (Print_timings_level_adaptation > 1)
    {
      tt_end = TimingHelpers::timer();
      oomph_info << "CPU for resetting halo-haloed scheme (without "
                    "classification of halo and haloed nodes): "
                 << tt_end - tt_start << std::endl;
    }

    // ------------------------------------------------------------------
    // BEGIN: Classify halo(ed) elements and nodes
    // ------------------------------------------------------------------
    const bool report_stats = true;
    DocInfo tmp_doc_info;
    tmp_doc_info.disable_doc();

    // Classify nodes
    this->classify_halo_and_haloed_nodes(tmp_doc_info, report_stats);

    // Document the timings for reseting halo and haloed scheme (with
    // classification of halo and haloed nodes)
    if (Print_timings_level_adaptation > 1)
    {
      tt_end = TimingHelpers::timer();
      oomph_info << "CPU for resetting halo-haloed scheme (with classification "
                    "of halo and haloed nodes): "
                 << tt_end - tt_start << std::endl;
    }

    // ------------------------------------------------------------------
    // END: Classify halo(ed) elements and nodes
    // ------------------------------------------------------------------
  }

  //======================================================================
  // Compute the alias of the nodes on shared boundaries in this
  // (my_rank) processor with other processors. Also compute the alias
  // of nodes on shared boundaries of other processors with other
  // processors (useful when there is an element that requires to be
  // sent to this (my_rank) processor because there is a shared node
  // between this (my_rank) and other processors BUT there is not a
  // shared boundary between this and the other processor
  // ======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::
    compute_global_node_names_and_shared_nodes(
      Vector<Vector<Vector<std::map<unsigned, Node*>>>>&
        other_proc_shd_bnd_node_pt,
      Vector<Vector<Vector<unsigned>>>& global_node_names,
      std::map<Vector<unsigned>, unsigned>& node_name_to_global_index,
      Vector<Node*>& global_shared_node_pt)
  {
    // Get the number of processors
    const unsigned nproc = this->communicator_pt()->nproc();
    // Get the rank of the current processor
    const unsigned my_rank = this->communicator_pt()->my_rank();
    // Get the communicator of the mesh
    OomphCommunicator* comm_pt = this->communicator_pt();

    // ---------------------------------------------------------------
    // BEGIN: Get the elements adjacent to shared boundaries and give
    // a unique node number to the nodes on the shared boundaries in
    // this processor
    // ---------------------------------------------------------------

    // Counter for the nodes on shared boundaries in this (my_rank)
    // processor
    unsigned counter_nodes = 0;
    // Keep track of visited nodes
    std::map<Node*, bool> done_node;
    // ... and its local node number
    std::map<Node*, unsigned> local_node_number;
    // ... and the inverted relation from local node number to node_pt
    Vector<Node*> local_node_pt;

    // Stores the j-th node name associated with the i-th local node
    // on shared boundaries in this processor (my_rank)
    // local_node_names[i][j][0] = my_rank (this processor)
    // local_node_names[i][j][1] = iproc (the processor with which there
    //                             is a shared boundary)
    // local_node_names[i][j][2] = the shared boundary id between this
    //                             (my_rank) processor and iproc
    //                             processor
    // local_node_names[i][j][3] = the node index on the shared boundary
    // local_node_names[i][j][4] = the local node index (i). This may
    //                             be unnecessary since we alread know the
    //                             index but we also send this info. to
    //                             the root processor that is why we store
    //                             them here
    Vector<Vector<Vector<unsigned>>> local_node_names;

    // loop over the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // There are not shared boundaries with myself
      if (iproc != my_rank)
      {
        // Get the number of shared boundaries with iproc
        const unsigned n_shd_bnds_with_iproc =
          this->nshared_boundaries(my_rank, iproc);

        // Get the boundaries ids shared with iproc
        Vector<unsigned> bnd_shd_with_iproc =
          this->shared_boundaries_ids(my_rank, iproc);

        // Loop over the shared boundaries with processor iproc
        for (unsigned ishd = 0; ishd < n_shd_bnds_with_iproc; ishd++)
        {
          // Keep track of visited nodes with this shared boundary
          std::map<Node*, bool> done_node_shd_bnd;
          // The boundary id
          unsigned shd_bnd_id = bnd_shd_with_iproc[ishd];
          // Get the number of element on the shared boundary
          const unsigned n_shd_bnd_ele =
            this->nshared_boundary_element(shd_bnd_id);

          // loop over the elements adjacent to the shared boundary
          for (unsigned e = 0; e < n_shd_bnd_ele; e++)
          {
            // Get the element
            FiniteElement* ele_pt =
              this->shared_boundary_element_pt(shd_bnd_id, e);

            // Get the number of nodes on the element
            const unsigned n_nodes = ele_pt->nnode();

            // loop over the nodes of the current element
            for (unsigned n = 0; n < n_nodes; n++)
            {
              // Get the node
              Node* node_pt = ele_pt->node_pt(n);

              // Has the node been visited with this shared boundary?
              // And, is this a node on the shd_bnd_id shared boundary
              // with processor iproc?
              if (!done_node_shd_bnd[node_pt] &&
                  this->is_node_on_shared_boundary(shd_bnd_id, node_pt))
              {
                // Mark the done as done with this shared boundary
                done_node_shd_bnd[node_pt] = true;

                // Get the index of the node on the shared boundary
                // -------------------------------------------------
                // Get the number of nodes on the shared boundary
                const unsigned n_nodes_shd_bnd =
                  nsorted_shared_boundary_node(shd_bnd_id);

                // The index
                unsigned index = 0;

#ifdef PARANOID
                // Flag to know if the node has been found
                bool found_node_on_shared_boundary = false;
#endif
                // Loop over the nodes on the shared boundary to find
                // the node
                for (unsigned k = 0; k < n_nodes_shd_bnd; k++)
                {
                  // Get the k-th node on the shared boundary
                  Node* shd_bnd_node_pt =
                    sorted_shared_boundary_node_pt(shd_bnd_id, k);

                  // Is the same node?
                  if (shd_bnd_node_pt == node_pt)
                  {
                    // This is the index
                    index = k;
#ifdef PARANOID
                    // Mark as found
                    found_node_on_shared_boundary = true;
#endif
                    break; // break

                  } // if (shd_bnd_node_pt == node_pt)

                } // for (k < n_nodes_shd_bnd)

#ifdef PARANOID
                if (!found_node_on_shared_boundary)
                {
                  std::ostringstream error_message;
                  error_message << "The index of the node on boundary ("
                                << shd_bnd_id << ") was not found.\n"
                                << "These are the node coordinates\n"
                                << "(" << node_pt->x(0) << "," << node_pt->x(1)
                                << ").\n";
                  throw OomphLibError(error_message.str(),
                                      OOMPH_CURRENT_FUNCTION,
                                      OOMPH_EXCEPTION_LOCATION);
                }
#endif

                // Create the node name
                Vector<unsigned> node_name(5);
                node_name[0] = my_rank;
                node_name[1] = iproc;
                node_name[2] = shd_bnd_id;
                node_name[3] = index;
                // The node number is filled in the following if/else
                // node_name[4] = ?;

                // Has the node already been visited?
                if (!done_node[node_pt])
                {
                  // If not ...

                  // Add the node to the local nodes
                  local_node_pt.push_back(node_pt);

                  // Assign a local node number to the node
                  local_node_number[node_pt] = counter_nodes;
                  // Store the local node number
                  node_name[4] = counter_nodes;
                  // Increase the counter of nodes
                  counter_nodes++;
                  // ... and mark it as visited
                  done_node[node_pt] = true;

                  // Push back the node name (the first
                  // one found for this node)
                  Vector<Vector<unsigned>> first_node_name(1);
                  first_node_name[0] = node_name;
                  local_node_names.push_back(first_node_name);
                }
                else
                {
                  // If yes ...

                  // Get the local node number
                  unsigned node_number = local_node_number[node_pt];

                  // Store the local node number
                  node_name[4] = node_number;

                  // Push back the node name for the
                  // node number
                  local_node_names[node_number].push_back(node_name);
                }

              } // Is on shared boundary?

            } // for (n < nnodes)

          } // for (e < n_shd_bnd_ele)

        } // for (ishd < n_shd_bnds_with_iproc)

      } // if (iproc != my_rank)

    } // for (iproc < nproc)

    // ---------------------------------------------------------------
    // END: Get the elements adjacent to shared boundaries and give
    // a unique node number to the nodes on the shared boundaries in
    // this processor
    // ---------------------------------------------------------------

    // ---------------------------------------------------------------
    // BEGIN: Package the names of the local nodes
    // ---------------------------------------------------------------
    // Counter for the number of names of the nodes
    unsigned n_total_local_names = 0;
    // Get the number of local nodes
    const unsigned n_local_nodes = local_node_names.size();
    // loop over the number of local nodes and get the number of names
    // of each node
    for (unsigned i = 0; i < n_local_nodes; i++)
    {
      // Get the number of names of the i-th local node
      const unsigned n_inode_names = local_node_names[i].size();
      // ... and add them to the total number of local names
      n_total_local_names += n_inode_names;
    } // for (i < n_local_nodes)

    // We store five data per node name (my_rank,iproc,shd_bnd_id,idx,node#)
    // where node# is the node number on this processor (my_rank)
    const unsigned n_info_per_node_name = 5;
    // Storage for the flat package
    Vector<unsigned> flat_packed_send_udata(n_total_local_names *
                                            n_info_per_node_name);
    // A counter
    unsigned counter = 0;
    // loop over the local nodes
    for (unsigned i = 0; i < n_local_nodes; i++)
    {
      // Get the number of names of the i-th local node
      const unsigned n_inode_names = local_node_names[i].size();
      // loop over the names of the i-th local node
      for (unsigned j = 0; j < n_inode_names; j++)
      {
        // Store this processor id (my_rank)
        flat_packed_send_udata[counter++] = local_node_names[i][j][0];
        // Store the processor with which the shared boundary exist
        flat_packed_send_udata[counter++] = local_node_names[i][j][1];
        // Store the shared boundary id
        flat_packed_send_udata[counter++] = local_node_names[i][j][2];
        // Store the index of the node on the shared boundary
        flat_packed_send_udata[counter++] = local_node_names[i][j][3];
        // Store the local node number on this processor (my_rank)
        flat_packed_send_udata[counter++] = local_node_names[i][j][4];
      } // for (j < n_inode_names)

    } // for (i < n_local_nodes)

    // Reset the counter
    counter = 0;

    // The number of data that will be sent to root from this
    // (my_rank) processor
    const unsigned n_udata_send_to_root = flat_packed_send_udata.size();

    // ---------------------------------------------------------------
    // END: Package the names of the local nodes
    // ---------------------------------------------------------------
    // ---------------------------------------------------------------
    // BEGIN: Send the data to the root processor
    // ---------------------------------------------------------------

    // The root processor is in charge of computing all the node names
    // of the nodes on the shared boundaries

    // Choose the root processor
    const unsigned root_processor = 0;

    // The vector where the root processor receives how many names
    // will receive from the other processors
    Vector<unsigned> root_n_names_per_processor(nproc);

    // Send the number of names that the root processor will receive
    // from each processor
    MPI_Gather(&n_total_local_names,
               1,
               MPI_UNSIGNED,
               &root_n_names_per_processor[0],
               1,
               MPI_UNSIGNED,
               root_processor,
               comm_pt->mpi_comm());

    // Get the total number of data to receive from all processor in
    // root
    unsigned root_n_total_udata_receive = 0;
    Vector<int> root_n_udata_to_receive(nproc, 0);
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      root_n_udata_to_receive[iproc] =
        root_n_names_per_processor[iproc] * n_info_per_node_name;
      root_n_total_udata_receive += root_n_udata_to_receive[iproc];
    }

    // Stores and compute the offsets (in root) for the data received
    // from each processor
    Vector<int> root_uoffsets_receive(nproc, 0);
    root_uoffsets_receive[0] = 0;
    for (unsigned iproc = 1; iproc < nproc; iproc++)
    {
      // Compute the offset to obtain the data from each processor
      root_uoffsets_receive[iproc] =
        root_uoffsets_receive[iproc - 1] + root_n_udata_to_receive[iproc - 1];
    }

    // Create at least one entry so we don't get a seg fault below
    if (flat_packed_send_udata.size() == 0)
    {
      flat_packed_send_udata.resize(1);
    }

    // Vector where to receive the info on root from all processors
    Vector<unsigned> root_flat_packed_receive_udata(root_n_total_udata_receive);
    // Only root receive data, the others dont, then resize the
    // container to have at least one entry
    if (my_rank != root_processor)
    {
      // Create at least one entry so we don't get a seg fault below
      if (root_flat_packed_receive_udata.size() == 0)
      {
        root_flat_packed_receive_udata.resize(1);
      }
    } // if (my_rank!=root_processor)

    // Send the info. to the root processor
    MPI_Gatherv(&flat_packed_send_udata[0], // Flat package to send
                                            // info. from each
                                            // processor
                n_udata_send_to_root, // Total number of data send
                                      // from each processor to root
                MPI_UNSIGNED,
                &root_flat_packed_receive_udata[0], // Container where
                                                    // to receive the
                                                    // info. from all
                                                    // processors
                &root_n_udata_to_receive[0], // Number of data to
                                             // receive from each
                                             // processor
                &root_uoffsets_receive[0], // The offset to store the
                                           // info. from each
                                           // processor
                MPI_UNSIGNED,
                root_processor, // The processor that receives all the
                                // info.
                comm_pt->mpi_comm());

    // Clear and resize the flat package to send
    flat_packed_send_udata.clear();
    flat_packed_send_udata.resize(0);
    // ---------------------------------------------------------------
    // END: Send the data to the root processor
    // ---------------------------------------------------------------

    // Container where root stores the info. that will be sent to all
    // processors. This includes the number of global nodes, the
    // number of names for each global node and the names
    Vector<unsigned> flat_packed_root_send_receive_udata;

    // ---------------------------------------------------------------
    // BEGIN: Unpackage the info. received on root. Compute the alias
    //        of the nodes
    // ---------------------------------------------------------------
    if (my_rank == root_processor)
    {
      // Compute all the names of a node
      // root_global_node_name[x][ ][ ] Global node number
      // root_global_node_name[ ][x][ ] Global node names
      // root_global_node_name[ ][ ][x] Global node info.
      Vector<Vector<Vector<unsigned>>> root_global_node_names;

      // Store the info. extracted from the flat package sent to
      // root
      // root_local_node_names[x][ ] Node name
      // root_local_node_names[ ][x] Node info
      Vector<Vector<unsigned>> root_local_node_names;

      // Extract all the node names
      unsigned rcounter = 0;
      // loop over the processors
      for (unsigned iproc = 0; iproc < nproc; iproc++)
      {
        // Get the number of node names received from iproc
        const unsigned n_local_names_iproc = root_n_names_per_processor[iproc];
        for (unsigned i = 0; i < n_local_names_iproc; i++)
        {
          // Get the i-thnode name from iproc
          Vector<unsigned> node_name(n_info_per_node_name);
          for (unsigned j = 0; j < n_info_per_node_name; j++)
          {
            node_name[j] = root_flat_packed_receive_udata[rcounter++];
          }

          // Add the i-th node name
          root_local_node_names.push_back(node_name);

        } // for (i < n_local_names_iproc)

      } // for (iproc < nproc)

      // Get the number of node names received
      const unsigned n_root_local_node_names = root_local_node_names.size();

      // For each name of the node identify the position of its
      // counter-part

      // Given a node name on the iproc,
      // (iproc, jproc, ishd_bnd, idx, local_node_number1)
      // its counter part must live in jproc, so we look for the
      // node name
      // (jproc, iproc, ishd_bnd, idx, local_node_number2)

      // Store the index of the node name counter-part
      Vector<unsigned> node_name_counter_part(n_root_local_node_names);

      // Keep track of the names of nodes already done
      std::map<Vector<unsigned>, bool> done_name;

      // loop over the names of the nodes received from all
      // processors
      for (unsigned i = 0; i < n_root_local_node_names; i++)
      {
        // Get the i-th node name
        Vector<unsigned> node_name = root_local_node_names[i];

        // Check if this name node has been already done
        if (!done_name[node_name])
        {
          // Mark it as done
          done_name[node_name] = true;
#ifdef PARANOID
          // Flag to indicate the counter-part name node was
          // found
          bool found_both_names_node = false;
#endif
          // Find the counter-part name node (start from j+1
          // since all previous have been found, otherwise we
          // would not be here)
          for (unsigned j = i + 1; j < n_root_local_node_names; j++)
          {
            Vector<unsigned> node_name_r = root_local_node_names[j];

            // Check if this name node has been already done
            if (!done_name[node_name_r])
            {
              // Check whether this node is the
              // counter-part of the current name node
              if (node_name[0] == node_name_r[1] &&
                  node_name[1] == node_name_r[0] &&
                  node_name[2] == node_name_r[2] &&
                  node_name[3] == node_name_r[3])
              {
                // Mark the name as node
                done_name[node_name_r] = true;
                // Store the index of the counter-part of
                // the current node name
                node_name_counter_part[i] = j;
                // ... and indicate the current node name
                // as the index of the counter-part
                node_name_counter_part[j] = i;
#ifdef PARANOID
                // The node has been found
                found_both_names_node = true;
#endif
                // Break the loop to find the
                // counter-part
                break;
              }

            } // if (!done_name[node_name_r])

          } // for (j < n_root_local_node_names)
#ifdef PARANOID
          // Check whether the node counter-part was found
          if (!found_both_names_node)
          {
            std::ostringstream error_message;
            error_message << "The counter-part of the current name node was "
                          << "not found,\nthe current node name is:\n"
                          << "iproc:(" << node_name[0] << ")\n"
                          << "jproc:(" << node_name[1] << ")\n"
                          << "ishd_bnd:(" << node_name[2] << ")\n"
                          << "index:(" << node_name[3] << ")\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          } // if (!found_both_names_node)
#endif

        } // if (!done_name[node_name])

      } // for (i < n_root_local_node_names)

      // -----------------------------------------------------------
      // Look for all the names of each node received and store them
      // in the "global node names" container

      // Keep track of the names of nodes already done
      done_name.clear();
      // loop over the names of the nodes received from all
      // processors
      for (unsigned i = 0; i < n_root_local_node_names; i++)
      {
        // Get the i-th node name
        Vector<unsigned> node_name = root_local_node_names[i];

        // Check if this name node has been already done
        if (!done_name[node_name])
        {
          // Store all the names of the current node
          Vector<Vector<unsigned>> all_node_names;

          // Add the name of the node as the initial node name
          all_node_names.push_back(node_name);

          // Get the index of the counter-part
          unsigned idx_c = node_name_counter_part[i];
          // Get the counter-part of the node name
          Vector<unsigned> node_name_r = root_local_node_names[idx_c];

          // Add the name of the counter-part of the node
          all_node_names.push_back(node_name_r);
          // We do not mark it as done since we are interested in
          // the names that the counter-part may generate

          // Get the number of names for the current node (two at
          // the first time)
          unsigned n_current_names = all_node_names.size();
          // Counter to ensure to visit all the names of the current
          // node
          unsigned icounter = 0;

          // Visit all the names of the current node
          while (icounter < n_current_names)
          {
            // Get the current node name
            Vector<unsigned> current_node_name = all_node_names[icounter];

            // Search for other names for the current name of the
            // node, but first check if this has been already
            // visited
            if (!done_name[current_node_name])
            {
              // Mark it as done
              done_name[current_node_name] = true;

              // loop over the names of the nodes (start from the
              // j+1 position, all previous node names have all
              // their names already assigned)
              for (unsigned j = i + 1; j < n_root_local_node_names; j++)
              {
                // Get the j-th node name
                Vector<unsigned> other_node_name = root_local_node_names[j];

                // Is this name node already done
                if (!done_name[other_node_name])
                {
                  // Is this another name for the current name node?
                  if ((current_node_name[0] == other_node_name[0]) &&
                      (current_node_name[4] == other_node_name[4]))
                  {
                    // Mark it as done. If we search again using the
                    // "other_node_name" as the current node name we
                    // are not going to find new nodes to add
                    done_name[other_node_name] = true;
                    // Before adding it check that it is not already
                    // part of the names of the node
                    Vector<Vector<unsigned>>::iterator it =
                      std::find(all_node_names.begin(),
                                all_node_names.end(),
                                other_node_name);
                    if (it == all_node_names.end())
                    {
                      all_node_names.push_back(other_node_name);
                      // Get the index of the counter-part
                      unsigned k = node_name_counter_part[j];
                      // Get the counter-part of the node name
                      Vector<unsigned> other_node_name_r =
                        root_local_node_names[k];
                      // Add the name of the counter-part of the
                      // node only if it has not been previously
                      // done
                      if (!done_name[other_node_name_r])
                      {
                        all_node_names.push_back(other_node_name_r);
                      }
                    }

                  } // // Is this another name for the current name
                    // node?

                } // if (!done_name[other_node_name])

              } // for (j < n_root_local_node_names)

            } // if (!done_name[current_node_name])

            // Get the number of names
            n_current_names = all_node_names.size();
            // Increase the icounter to indicate we have visited the
            // current name of the node
            icounter++;

          } // while(icounter < n_current_names)

          // We now have all the names for the i-th global node
          root_global_node_names.push_back(all_node_names);

        } // if (!done_name[node_name])

      } // for (i < n_root_local_node_names)

      // -------------------------------------------------------------
      // Prepare the info to be sent to all processors. The number
      // of global nodes, the number of names for each global node,
      // and their respective names
      // -------------------------------------------------------------

      // Clear the container
      flat_packed_root_send_receive_udata.clear();
      // Get the number of global nodes
      const unsigned n_global_nodes = root_global_node_names.size();
      // ... and store this info. to be sent from root to all
      // processors
      flat_packed_root_send_receive_udata.push_back(n_global_nodes);

      // loop over the nodes
      for (unsigned i = 0; i < n_global_nodes; i++)
      {
        // Get the names of the i-th global node
        Vector<Vector<unsigned>> global_inode_names = root_global_node_names[i];
        // Get the number of names for the i-th global node
        const unsigned n_names_global_inode = global_inode_names.size();
        // ... and store this info. to be sent from root to all
        // processors
        flat_packed_root_send_receive_udata.push_back(n_names_global_inode);
        // loop over the names of the global i-th node
        for (unsigned j = 0; j < n_names_global_inode; j++)
        {
          // loop over the info. associated with each name
          for (unsigned k = 0; k < n_info_per_node_name; k++)
          {
            // Store the name info. of the current name in the
            // container to be sent from root to all processors
            flat_packed_root_send_receive_udata.push_back(
              global_inode_names[j][k]);
          } // for (k < n_info_per_node_name)

        } // for (j < n_names_inode)

      } // for (i < n_global_nodes)

    } // if (my_rank == root_processor)

    // ----------------------------------------------------------------
    //  END: Unpackage the info. received on root. Compute the alias
    //       of the nodes and prepare the info. to be sent back from
    //       root to all processors
    // ----------------------------------------------------------------

    // ---------------------------------------------------------------
    // BEGIN: Send the info. back to all processors, unpackage the
    //        info. and create the map from node name to global node
    //        index
    // ---------------------------------------------------------------
    // The number of data that root send to other processors.
    unsigned root_n_udata_sent_to_all_proc =
      flat_packed_root_send_receive_udata.size();

    MPI_Bcast(&root_n_udata_sent_to_all_proc, // Data to send and
                                              // receive
              1,
              MPI_UNSIGNED,
              root_processor,
              comm_pt->mpi_comm());

    // Resize the container if this is a processor that receives data
    if (my_rank != root_processor)
    {
      flat_packed_root_send_receive_udata.resize(root_n_udata_sent_to_all_proc);
    }

    // Send the info. from root and receive it on all processors
    MPI_Bcast(&flat_packed_root_send_receive_udata[0], // Info. sent
                                                       // from root to
                                                       // all
                                                       // processors
              root_n_udata_sent_to_all_proc, // Number of data sent
                                             // from root to each
                                             // procesor
              MPI_UNSIGNED,
              root_processor, // The processor that sends all the info.
              comm_pt->mpi_comm());

    // Counter to extract the info.
    counter = 0;
    // Read the number of global nodes
    const unsigned n_global_nodes =
      flat_packed_root_send_receive_udata[counter++];
    // Store the global names of the nodes
    // global_node_name[x][ ][ ] Global node number
    // global_node_name[ ][x][ ] Global node names
    // global_node_name[ ][ ][x] Global node info.
    // Vector<Vector<Vector<unsigned> > > global_node_names(n_global_nodes);
    // Resize the input vector
    global_node_names.resize(n_global_nodes);
    // Now loop until all global nodes info. has been read
    unsigned n_read_global_nodes = 0;
    while (n_read_global_nodes < n_global_nodes)
    {
      // Read the number of names for the current global node
      const unsigned n_names_global_inode =
        flat_packed_root_send_receive_udata[counter++];
      // Counter for the global node
      const unsigned i = n_read_global_nodes;
      // Resize the container
      global_node_names[i].resize(n_names_global_inode);
      // loop over the names of the global inode
      for (unsigned j = 0; j < n_names_global_inode; j++)
      {
        // Resize the container
        global_node_names[i][j].resize(n_info_per_node_name);
        // loop over the info. of the j-th node name of the i-th
        // global node
        for (unsigned k = 0; k < n_info_per_node_name; k++)
        {
          // Read the k-th node info. from the j-th node name of
          // the i-th global node
          global_node_names[i][j][k] =
            flat_packed_root_send_receive_udata[counter++];

        } // for (k < n_info_per_node_name)

        // Create the map from the node name to the global node
        // index
        Vector<unsigned> node_name(n_info_per_node_name - 1);
        node_name[0] = global_node_names[i][j][0];
        node_name[1] = global_node_names[i][j][1];
        node_name[2] = global_node_names[i][j][2];
        node_name[3] = global_node_names[i][j][3];
        // Do not add the local index since it will not longer be
        // used. Additionally, we will not know the local node
        // index outside this method
        // node_name[4] = global_node_names[i][j][4];
        node_name_to_global_index[node_name] = i;

      } // for (j < n_names_global_inode)

      // Increase the counter for read global nodes
      n_read_global_nodes++;

    } // while (n_read_global_nodes < n_global_nodes)

#ifdef PARANOID
    // Check we have read all the info.
    if (counter != root_n_udata_sent_to_all_proc)
    {
      std::ostringstream error_stream;
      error_stream
        << "The info. received from root regarding the global names of "
        << "the nodes\nwas not completely read.\n"
        << "The number of data sent/received from root is: ("
        << root_n_udata_sent_to_all_proc << ")\n"
        << "The number of data read from the received info. is: (" << counter
        << ")\n\n";
      throw OomphLibError(
        error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    } // if (counter != root_n_udata_sent_to_all_proc)
#endif

    // ---------------------------------------------------------------
    // END: Send the info. back to all processors, unpackage the info.
    //      and create the map from node name to global node index
    // ---------------------------------------------------------------

    // ---------------------------------------------------------------
    // BEGIN: Add the info. from the global node names into the
    //        info. of the local node names. We do this because the
    //        local node names have pointers to the nodes.
    //        Additionally, create a map from the node name to the
    //        index of its global node
    // ---------------------------------------------------------------

    // Resize the global shared node pointers container
    global_shared_node_pt.resize(n_global_nodes, 0);

    // loop over the number of global nodes
    for (unsigned i = 0; i < n_global_nodes; i++)
    {
      // Flag to indicate that the iglobal node is part of the nodes
      // on the current processor
      bool is_this_a_local_node_name = false;
      unsigned local_node_number;
      // Get the number of names of the i-th global node
      const unsigned n_names_global_inode = global_node_names[i].size();
      // loop over the names of the i-th global node
      for (unsigned j = 0; j < n_names_global_inode; j++)
      {
        // Get the node name info.
        const unsigned iproc = global_node_names[i][j][0];
        local_node_number = global_node_names[i][j][4];

        // Check if this node name lives on this processor
        if (my_rank == iproc)
        {
          // The node is part of the local node names
          is_this_a_local_node_name = true;
          // Break
          break;
        } // if (my_rank == iproc)

      } // for (j < n_names_global_inode)

      // If the node is part of the local nodes then add the
      // additional names of the node in the local container
      if (is_this_a_local_node_name)
      {
#ifdef PARANOID
        // Check that the global node include at least all the names
        // of the node on this processor
        const unsigned n_names_local_node =
          local_node_names[local_node_number].size();
        unsigned n_names_found_on_global_name_node = 0;
#endif

        // Add the pointer of the node into the global shared node
        // pointers container
        global_shared_node_pt[i] = local_node_pt[local_node_number];

        // Add all the global names of the node onto the local node
        // names

        // loop again over the names of the i-th global node
        for (unsigned j = 0; j < n_names_global_inode; j++)
        {
          // Get the node name info.
          const unsigned iproc = global_node_names[i][j][0];

          // Is this a node name on this processor?
          if (iproc != my_rank)
          {
            // Add the name
            local_node_names[local_node_number].push_back(
              global_node_names[i][j]);
          }
#ifdef PARANOID
          else
          {
            const unsigned jproc = global_node_names[i][j][1];
            const unsigned ishd_bnd = global_node_names[i][j][2];
            const unsigned idx = global_node_names[i][j][3];
            const unsigned n_local_node = global_node_names[i][j][4];
            // loop over the names of the local node
            for (unsigned k = 0; k < n_names_local_node; k++)
            {
              if ((local_node_names[local_node_number][k][0] == iproc) &&
                  (local_node_names[local_node_number][k][1] == jproc) &&
                  (local_node_names[local_node_number][k][2] == ishd_bnd) &&
                  (local_node_names[local_node_number][k][3] == idx) &&
                  (local_node_names[local_node_number][k][4] == n_local_node))
              {
                // Increase the number of local nodes found on the
                // global nodes
                n_names_found_on_global_name_node++;
              } // found global node on local nodes

            } // for (k < n_names_local_node)

          } // if (iproc != my_rank)
#endif

        } // for (j < n_names_global_inode)

#ifdef PARANOID
        // The number of local nodes names must be the same as the the
        // number of global nodes names associated with this processor
        // (my_rank, that start with iproc = my_rank)
        if (n_names_local_node != n_names_found_on_global_name_node)
        {
          std::ostringstream error_stream;
          error_stream << "The local node names corresponding to the local "
                       << "node (" << local_node_number << ") were\n"
                       << "not found on the global node names.\n\n"
                       << "These are the names of the local node\n"
                       << "Name k: iproc, jproc, ishd_bnd, idx. #node\n";
          for (unsigned k = 0; k < n_names_local_node; k++)
          {
            error_stream << "Name(" << k
                         << "): " << local_node_names[local_node_number][k][0]
                         << ", " << local_node_names[local_node_number][k][1]
                         << ", " << local_node_names[local_node_number][k][2]
                         << ", " << local_node_names[local_node_number][k][3]
                         << ", " << local_node_names[local_node_number][k][4]
                         << "\n";
          }

          error_stream << "\n\nThese are the names of the global node\n"
                       << "Name k: iproc, jproc, ishd_bnd, idx. #node\n";
          for (unsigned k = 0; k < n_names_global_inode; k++)
          {
            error_stream << "Name(" << k << "): " << global_node_names[i][k][0]
                         << ", " << global_node_names[i][k][1] << ", "
                         << global_node_names[i][k][2] << ", "
                         << global_node_names[i][k][3] << ", "
                         << global_node_names[i][k][4] << "\n";
          }

          throw OomphLibError(error_stream.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        }
#endif

      } // if (is_this_a_local_node_name)

    } // for (i < n_global_nodes)

    // ---------------------------------------------------------------
    // END: Add the info. from the global node names into the info.
    //      of the local node names. We do this because the local
    //      node names have pointers to the nodes
    // ---------------------------------------------------------------

    // ---------------------------------------------------------------
    // BEGIN: Fill the data structure other_proc_shd_bnd_node_pt with
    //        the local nodes.
    // ---------------------------------------------------------------

    // Loop over the local nodes and fill the
    // other_proc_shd_bnd_node_pt container with the corresponding
    // info. NOTE: We are using the old size of the local node names,
    // before adding the names of the global nodes so we only loop
    // over the local nodes and not global.

    // Compute the local shared boudary id
    const unsigned initial_shd_bnd_id = this->initial_shared_boundary_id();

    // loop over the local nodes names
    for (unsigned i = 0; i < n_local_nodes; i++)
    {
      // Get the number of names for the i-th local node
      const unsigned n_names = local_node_names[i].size();
      // Get a pointer to the first name of the node found on this
      // processor (this ensures that the node lives on this
      // processor)
      Node* node_pt = local_node_pt[i];
      // loop over the names of the i-th local node and add an entry
      // to the other_proc_shd_bnd_node_pt structure
      for (unsigned j = 0; j < n_names; j++)
      {
        // Get the node name info.
        const unsigned iproc = local_node_names[i][j][0];
        const unsigned jproc = local_node_names[i][j][1];
        const unsigned ishd_bnd =
          local_node_names[i][j][2] - initial_shd_bnd_id;
        const unsigned index = local_node_names[i][j][3];
        // We can ignore the last entry, it was just used to compute
        // the global node number by the root processor

        // Get the smallest processor number
        if (iproc < jproc)
        {
          other_proc_shd_bnd_node_pt[iproc][jproc][ishd_bnd][index] = node_pt;
        }
        else
        {
          other_proc_shd_bnd_node_pt[jproc][iproc][ishd_bnd][index] = node_pt;
        }

      } // for (j < n_names)

    } // for (i < n_local_node_names)

    // ---------------------------------------------------------------
    // END: Fill the data structure other_proc_shd_bnd_node_pt with
    //      the local nodes.
    // ---------------------------------------------------------------
  }

  //======================================================================
  // Get the original boundaries to which is associated each
  // shared node, and send the info. to the related processors. We
  // need to do this so that at the reset of halo(ed) info. stage,
  // the info. is updated
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::send_boundary_node_info_of_shared_nodes(
    Vector<Vector<Vector<unsigned>>>& global_node_names,
    std::map<Vector<unsigned>, unsigned>& node_name_to_global_index,
    Vector<Node*>& global_shared_node_pt)
  {
    // Get the rank and number of processors
    const unsigned nproc = this->communicator_pt()->nproc();
    const unsigned my_rank = this->communicator_pt()->my_rank();

    // The number of nodes on shared boundaries
    const unsigned n_nodes_on_shd_bnds = global_node_names.size();
    // ---------------------------------------------------------
    // BEGIN: Get the shared nodes between each of processors
    // ---------------------------------------------------------

    // Store the nodes on shared boundaries in this processor with other
    // processors
    Vector<std::set<Node*>> node_on_shd_bnd_pt(nproc);

    // A map to get access to the global shared node number from the
    // node pointer
    std::map<Node*, unsigned> node_pt_to_global_shd_bnd_index;

    // loop over the global nodes names and get only those in this
    // processor
    for (unsigned i = 0; i < n_nodes_on_shd_bnds; i++)
    {
      // Get the number of names of the current node on shared
      // boundaries
      const unsigned n_names = global_node_names[i].size();
      // loop over the names
      for (unsigned j = 0; j < n_names; j++)
      {
        // Store the node name
        Vector<unsigned> node_name(4);
        node_name[0] = global_node_names[i][j][0];
        node_name[1] = global_node_names[i][j][1];
        node_name[2] = global_node_names[i][j][2];
        node_name[3] = global_node_names[i][j][3];

        // Check whether the node is in the current processor
        if (node_name[0] == my_rank)
        {
          // Check with which processor the node is shared
          const unsigned jproc = node_name[1];

#ifdef PARANOID
          std::map<Vector<unsigned>, unsigned>::iterator it =
            node_name_to_global_index.find(node_name);
          if (it != node_name_to_global_index.end())
          {
            // Check whether the global node index correspond with that
            // of the current global node name
            if (i != (*it).second)
            {
              std::ostringstream error_message;
              error_message
                << "The global node number " << (*it).second
                << ") obtained from the current node\n"
                << "name is not the same as the current node number (" << i
                << ").\n\n"
                << "Node name:\n"
                << "iproc:" << node_name[0] << "\n"
                << "jproc:" << node_name[1] << "\n"
                << "shd_bnd_id:" << node_name[2] << "\n"
                << "index:" << node_name[3] << "\n\n";
              throw OomphLibError(error_message.str(),
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
            }
          }
          else
          {
            std::ostringstream error_message;
            error_message
              << "The node name is not registerd as living in this processor.\n"
              << "Node name:\n"
              << "iproc:" << node_name[0] << "\n"
              << "jproc:" << node_name[1] << "\n"
              << "shd_bnd_id:" << node_name[2] << "\n"
              << "index:" << node_name[3] << "\n\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }

#endif // #ifdef PARANOID

          // Get the node pointer
          Node* node_pt = global_shared_node_pt[i];

#ifdef PARANOID
          if (node_pt == 0)
          {
            std::ostringstream error_message;
            error_message << "There is not global shared node within this\n"
                          << "global node number (" << i
                          << "). The global shared\n"
                          << "node pointer is null\n\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }
#endif // #ifdef PARANOID

          // Add the node to the nodes on shared boundaries in this
          // processor
          node_on_shd_bnd_pt[jproc].insert(node_pt);

          // And store the global node index
          node_pt_to_global_shd_bnd_index[node_pt] = i;

        } // if (node_name[0]==my_rank)
        else if (node_name[1] == my_rank)
        {
          // Check with which processor the node is shared
          const unsigned jproc = node_name[0];

#ifdef PARANOID
          std::map<Vector<unsigned>, unsigned>::iterator it =
            node_name_to_global_index.find(node_name);
          if (it != node_name_to_global_index.end())
          {
            // Check whether the global node index correspond with that
            // of the current global node name
            if (i != (*it).second)
            {
              std::ostringstream error_message;
              error_message
                << "The global node number " << (*it).second
                << ") obtained from the current node\n"
                << "name is not the same as the current node number (" << i
                << ").\n\n"
                << "Node name:\n"
                << "iproc:" << node_name[0] << "\n"
                << "jproc:" << node_name[1] << "\n"
                << "shd_bnd_id:" << node_name[2] << "\n"
                << "index:" << node_name[3] << "\n\n";
              throw OomphLibError(error_message.str(),
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
            }
          }
          else
          {
            std::ostringstream error_message;
            error_message
              << "The node name is not registerd as living in this processor.\n"
              << "Node name:\n"
              << "iproc:" << node_name[0] << "\n"
              << "jproc:" << node_name[1] << "\n"
              << "shd_bnd_id:" << node_name[2] << "\n"
              << "index:" << node_name[3] << "\n\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }

#endif // #ifdef PARANOID

          // Get the node pointer
          Node* node_pt = global_shared_node_pt[i];

#ifdef PARANOID
          if (node_pt == 0)
          {
            std::ostringstream error_message;
            error_message << "There is not global shared node within this\n"
                          << "global node number (" << i
                          << "). The global shared\n"
                          << "node pointer is null\n\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }
#endif // #ifdef PARANOID

          // Add the node to the nodes on shared boundaries in this
          // processor
          node_on_shd_bnd_pt[jproc].insert(node_pt);

          // And store the global node index
          node_pt_to_global_shd_bnd_index[node_pt] = i;
        }

      } // for (j < n_names)

    } // for (i < n_nodes_on_shd_bnds)

    // ---------------------------------------------------------
    // END: Get the shared nodes between each of processors
    // ---------------------------------------------------------

    // ---------------------------------------------------------
    // BEGIN: Get the original boundaries associated to each
    //        node on a shared boundary
    // ---------------------------------------------------------

    // Store the global shared node number
    Vector<Vector<unsigned>> global_node_on_shared_bound(nproc);
    // Store the boundaries associated with the global shared node
    // number
    Vector<Vector<Vector<unsigned>>> global_node_original_boundaries(nproc);
    // Store the zeta boundary coordinate of the nodes on original
    // boundaries
    Vector<Vector<Vector<double>>> global_node_zeta_coordinate(nproc);

    // loop over the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Get the nodes added to be shared with the iproc processor
      std::set<Node*> nodes_shared_pt = node_on_shd_bnd_pt[iproc];

      // loop over the nodes
      for (std::set<Node*>::iterator it = nodes_shared_pt.begin();
           it != nodes_shared_pt.end();
           it++)
      {
        // Get the node
        Node* node_pt = (*it);
        // Store the boundaries on which it is stored
        Vector<unsigned> on_original_boundaries;
        // For each boundary get the corresponding z value of the node
        // on the boundary
        Vector<double> zeta_coordinate;
        // Get the number of boudandaries
        const unsigned n_bnd = this->initial_shared_boundary_id();
        // loop over the boundaries and register the boundaries to which
        // it is associated
        for (unsigned bb = 0; bb < n_bnd; bb++)
        {
          // Is the node on original boundary bb?
          if (node_pt->is_on_boundary(bb))
          {
            // Then save it as being on boundary bb
            on_original_boundaries.push_back(bb);
            // Get the boundary coordinate
            Vector<double> zeta(1);
            node_pt->get_coordinates_on_boundary(bb, zeta);
            // Save the boundary coordinate
            zeta_coordinate.push_back(zeta[0]);
          }

        } // for (bb < n_bnd)

        // Is the node on an original boundary
        if (on_original_boundaries.size() > 0)
        {
          // Get the global shared node number
          std::map<Node*, unsigned>::iterator it_index =
            node_pt_to_global_shd_bnd_index.find(node_pt);
#ifdef PARANOID
          if (it_index == node_pt_to_global_shd_bnd_index.end())
          {
            std::ostringstream error_message;
            error_message
              << "We could not find the global shared node index associated\n"
              << "with the node pointer with vertices coordinates:\n"
              << "(" << node_pt->x(0) << ", " << node_pt->x(1) << ")\n\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }
#endif
          // The global shared node index
          const unsigned global_shared_node_number = (*it_index).second;
          // Store the global shared node number
          global_node_on_shared_bound[iproc].push_back(
            global_shared_node_number);
          // And store the original boundaries to which it is associated
          global_node_original_boundaries[iproc].push_back(
            on_original_boundaries);
          // and the corresponding zeta coordinate
          global_node_zeta_coordinate[iproc].push_back(zeta_coordinate);
        }

      } // loop over nodes on shared boundaries with iproc

    } // for (iproc < nproc)

    // ---------------------------------------------------------
    // END: Get the original boundaries associated to each
    //      node on a shared boundary
    // ---------------------------------------------------------

    // ---------------------------------------------------------
    // BEGIN: Send the info. to the corresponding processors,
    //        package the info, send it and receive it in the
    //        corresponding processor, unpackage and set the
    //        boundaries associated with the received nodes
    // ---------------------------------------------------------

    // Get the communicator of the mesh
    OomphCommunicator* comm_pt = this->communicator_pt();

    // Set MPI info
    MPI_Status status;
    MPI_Request request;

    // loop over the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // The number of nodes shared between the pair of processors
      const unsigned n_shd_nodes_my_rank_iproc =
        node_on_shd_bnd_pt[iproc].size();

      // Are there shared nodes between these pair of processors
      // (my_rank, iproc)? Also ensure not to send info. within myself
      if (n_shd_nodes_my_rank_iproc > 0 && iproc != my_rank)
      {
        // The flat package to send the info, to the iproc processor
        Vector<unsigned> flat_package_unsigned_send;
        // The very first entry is the number of nodes shared by the
        // pair of processors (my_rank, iproc)
        flat_package_unsigned_send.push_back(n_shd_nodes_my_rank_iproc);

        // Get the number of shared nodes on original boundaries
        const unsigned n_global_shared_node_on_original_boundary =
          global_node_on_shared_bound[iproc].size();

        // The second data is the number of shared nodes on original
        // boundaries
        flat_package_unsigned_send.push_back(
          n_global_shared_node_on_original_boundary);

        // ... also send the zeta coordinates associated with the
        // original boundaries
        Vector<double> flat_package_double_send;

        // loop over the nodes shared between this pair of processors
        for (unsigned i = 0; i < n_global_shared_node_on_original_boundary; i++)
        {
          // Get the global shared node index
          const unsigned global_shared_node_index =
            global_node_on_shared_bound[iproc][i];

          // Put in the package the shared node index of the current
          // node
          flat_package_unsigned_send.push_back(global_shared_node_index);

          // Get the original boundaries to which the node is associated
          Vector<unsigned> on_original_boundaries =
            global_node_original_boundaries[iproc][i];

          // Get the associated zeta boundary coordinates
          Vector<double> zeta_coordinate =
            global_node_zeta_coordinate[iproc][i];

          // Get the number of original boundaries to which the node is
          // associated
          const unsigned n_original_boundaries = on_original_boundaries.size();

          // Put in the package the number of original boundaries the
          // node is associated
          flat_package_unsigned_send.push_back(n_original_boundaries);

          // loop over the original boundaries ids and include them in
          // the package
          for (unsigned j = 0; j < n_original_boundaries; j++)
          {
            // Put in the package each of the original boundaries to
            // which it is associated
            flat_package_unsigned_send.push_back(on_original_boundaries[j]);
            // The zeta coordinate on the boundary
            flat_package_double_send.push_back(zeta_coordinate[j]);
          } // for (j < n_original_boundaries)

        } // for (i < n_global_shared_node_on_original_boundary)

        // Send data UNSIGNED -----------------------------------------
        // Get the size of the package to communicate to the iproc
        // processor
        const unsigned n_udata_send = flat_package_unsigned_send.size();
        int n_udata_send_int = n_udata_send;

        // Send/receive data to/from iproc processor
        MPI_Isend(&n_udata_send_int,
                  1,
                  MPI_UNSIGNED,
                  iproc,
                  1,
                  comm_pt->mpi_comm(),
                  &request);

        int n_udata_received_int = 0;
        MPI_Recv(&n_udata_received_int,
                 1,
                 MPI_UNSIGNED,
                 iproc,
                 1,
                 comm_pt->mpi_comm(),
                 &status);
        MPI_Wait(&request, MPI_STATUS_IGNORE);

        if (n_udata_send != 0)
        {
          MPI_Isend(&flat_package_unsigned_send[0],
                    n_udata_send,
                    MPI_UNSIGNED,
                    iproc,
                    2,
                    comm_pt->mpi_comm(),
                    &request);
        }

        const unsigned n_udata_received =
          static_cast<unsigned>(n_udata_received_int);

        // Where to receive the data from the iproc processor
        Vector<unsigned> flat_package_unsigned_receive(n_udata_received);

        if (n_udata_received != 0)
        {
          MPI_Recv(&flat_package_unsigned_receive[0],
                   n_udata_received,
                   MPI_UNSIGNED,
                   iproc,
                   2,
                   comm_pt->mpi_comm(),
                   &status);
        }

        if (n_udata_send != 0)
        {
          MPI_Wait(&request, MPI_STATUS_IGNORE);
        }

        // Send data DOUBLE -----------------------------------------
        // Get the size of the package to communicate to the iproc
        // processor
        const unsigned n_ddata_send = flat_package_double_send.size();
        int n_ddata_send_int = n_ddata_send;

        // Send/receive data to/from iproc processor
        MPI_Isend(&n_ddata_send_int,
                  1,
                  MPI_UNSIGNED,
                  iproc,
                  1,
                  comm_pt->mpi_comm(),
                  &request);

        int n_ddata_received_int = 0;
        MPI_Recv(&n_ddata_received_int,
                 1,
                 MPI_UNSIGNED,
                 iproc,
                 1,
                 comm_pt->mpi_comm(),
                 &status);
        MPI_Wait(&request, MPI_STATUS_IGNORE);

        if (n_ddata_send != 0)
        {
          MPI_Isend(&flat_package_double_send[0],
                    n_ddata_send,
                    MPI_DOUBLE,
                    iproc,
                    2,
                    comm_pt->mpi_comm(),
                    &request);
        }

        const unsigned n_ddata_received =
          static_cast<unsigned>(n_ddata_received_int);

        // Where to receive the data from the iproc processor
        Vector<double> flat_package_double_receive(n_ddata_received);

        if (n_ddata_received != 0)
        {
          MPI_Recv(&flat_package_double_receive[0],
                   n_ddata_received,
                   MPI_DOUBLE,
                   iproc,
                   2,
                   comm_pt->mpi_comm(),
                   &status);
        }

        if (n_ddata_send != 0)
        {
          MPI_Wait(&request, MPI_STATUS_IGNORE);
        }

        // Unpackage -------------------------------------------------
        // ... and associate the nodes to the corresponding original
        // boundaries

        // The number of nodes to be received
        unsigned n_shared_nodes_received = flat_package_unsigned_receive[0];

        // Increase and decrease the number of received shared nodes to
        // avoid the warning when compiling without PARANOID
        n_shared_nodes_received++;
        n_shared_nodes_received--;

#ifdef PARANOID
        if (n_shd_nodes_my_rank_iproc != n_shared_nodes_received)
        {
          std::ostringstream error_message;
          error_message
            << "The number of shared nodes between the pair of processors is\n"
            << "not the same\n"
            << "N.shared nodes proc (" << my_rank << ") with proc (" << iproc
            << "): (" << n_shd_nodes_my_rank_iproc << "\n"
            << "N.shared nodes proc (" << iproc << ") with proc (" << my_rank
            << "): (" << n_shared_nodes_received << "\n\n"
            << "You should have got the same error in proc: (" << iproc
            << ")\n\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        } // if (n_shd_nodes_my_rank_iproc != n_shared_nodes_received)
#endif

        // Skip the number of nodes on shared boundaries on original
        // boundaries received (that is why next lines are commented)

        // The number of nodes on shared boundaries on original
        // boundaries
        // const unsigned n_shared_nodes_on_original_boundaries_received =
        // flat_package_unsigned_receive[1];

        // loop over the received info.
        unsigned current_index_data = 2;
        unsigned current_index_ddata = 0;
        while (current_index_data < n_udata_received)
        {
          // The global shared node number
          const unsigned global_shared_node_index =
            flat_package_unsigned_receive[current_index_data++];

          // The pointer to the node
          Node* node_pt = 0;

          // The number of original boundaries the node is associated
          // with
          const unsigned n_original_boundaries =
            flat_package_unsigned_receive[current_index_data++];

          // Get the node pointer
          node_pt = global_shared_node_pt[global_shared_node_index];
#ifdef PARANOID
          if (node_pt == 0)
          {
            std::ostringstream error_message;
            error_message
              << "The global shared node (" << global_shared_node_index << ") "
              << "could not be found in this processor!!!\n"
              << "However, it was found in processor (" << iproc << "). The "
              << "data may be no synchronised,\ntherefore "
              << "we may be looking for a global shared node number that "
              << "do not\ncorrespond with the one that was sent by "
              << "processor (" << iproc << ")\n\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }
#endif // #ifdef PARANOID

          // loop over the number of original boundaries and associate
          // the node to each of those boundaries
          for (unsigned i = 0; i < n_original_boundaries; i++)
          {
            // Get the original boundary to which the node is associated
            // with
            const unsigned original_bound_id =
              flat_package_unsigned_receive[current_index_data++];

            // Associate the node with the boundary
            this->add_boundary_node(original_bound_id, node_pt);

            // Get the zeta boundary coordinate
            Vector<double> zeta(1);
            zeta[0] = flat_package_double_receive[current_index_ddata++];
            node_pt->set_coordinates_on_boundary(original_bound_id, zeta);
          }

        } // while(current_data < n_data_received)

      } // if ((node_on_shd_bnd_pt(iproc) > 0) && iproc!=my_rank)

    } // for (iproc < nproc)

    // ---------------------------------------------------------
    // END: Send the info. to the corresponding processors,
    //      package the info, send it and receive it in the
    //      corresponding processor, unpackage and set the
    //      boundaries associated with the received nodes
    // ---------------------------------------------------------
  }

  //======================================================================
  // In charge of creating additional halo(ed) elements on those
  // processors that have no shared boundaries in common but have
  // shared nodes
  // ======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::reset_halo_haloed_scheme_helper(
    Vector<Vector<Vector<std::map<unsigned, Node*>>>>&
      other_proc_shd_bnd_node_pt,
    Vector<Vector<Node*>>& iproc_currently_created_nodes_pt,
    Vector<Vector<Vector<unsigned>>>& global_node_names,
    std::map<Vector<unsigned>, unsigned>& node_name_to_global_index,
    Vector<Node*>& global_shared_node_pt)
  {
    // Get the rank and number of processors
    const unsigned nproc = this->communicator_pt()->nproc();
    const unsigned my_rank = this->communicator_pt()->my_rank();

    // ---------------------------------------------------------------
    // BEGIN: Create a map to check whether a node is on the global
    //        shared nodes. Also set a map to obtain the global
    //        shared node index (this index is the same as the global
    //        node name)
    // ---------------------------------------------------------------
    std::map<Node*, bool> is_global_shared_node;
    std::map<Node*, unsigned> global_shared_node_index;

    // Get the number of global shared nodes
    const unsigned n_global_shared_nodes = global_shared_node_pt.size();
    // loop over the global shared nodes
    for (unsigned i = 0; i < n_global_shared_nodes; i++)
    {
      // Get the node
      Node* node_pt = global_shared_node_pt[i];
      // Indicate this is a shared global node
      is_global_shared_node[node_pt] = true;
      // Set the map to obtain the index of the global shared node
      global_shared_node_index[node_pt] = i;

    } // for (i < n_global_shared_nodes)

    // ---------------------------------------------------------------
    // END: Create a map to check whether a node is on the global
    //      shared nodes. Also set a map to obtain the global
    //      shared node index (this index is the same as the global
    //      node name)
    // ---------------------------------------------------------------

    // ---------------------------------------------------------------
    // BEGIN: Loop over the haloed elements and check whether the nodes
    //        on the haloed elements are part of the global shared
    //        nodes. If that is the case then check whether the
    //        element should be sent to the processors with which the
    //        node is shared
    // ---------------------------------------------------------------

    // Elements that may be sent to other processors
    Vector<std::set<GeneralisedElement*>> additional_elements_pt(nproc);

    // loop over the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      if (iproc != my_rank)
      {
        // Get the haloed element with iproc
        Vector<GeneralisedElement*> haloed_ele_pt =
          this->root_haloed_element_pt(iproc);

        // Get the number of haloed elements
        const unsigned n_haloed_ele = this->nroot_haloed_element(iproc);

        // loop over the haloed elements with iproc
        for (unsigned ihd = 0; ihd < n_haloed_ele; ihd++)
        {
          // A pointer to the generalised element
          GeneralisedElement* gele_pt = haloed_ele_pt[ihd];
          // Get the finite element representation of the element
          FiniteElement* ele_pt = dynamic_cast<FiniteElement*>(gele_pt);
          // Get the number of nodes
          const unsigned n_nodes = ele_pt->nnode();
          // loop over the nodes of the element
          for (unsigned n = 0; n < n_nodes; n++)
          {
            // Get the node
            Node* node_pt = ele_pt->node_pt(n);
            // Is the node a global shared node?
            if (is_global_shared_node[node_pt])
            {
              // Get the index of the global shared node
              const unsigned global_index = global_shared_node_index[node_pt];
              // Get the global names of the node
              Vector<Vector<unsigned>> iglobal_names =
                global_node_names[global_index];

              // Get the number of names
              const unsigned n_names = iglobal_names.size();
              // loop over the names and check which processors share
              // this node (the processors to which the element may be
              // sent
              for (unsigned j = 0; j < n_names; j++)
              {
                // Get the processors to which the element should be
                // sent
                const unsigned proc1 = iglobal_names[j][0];
                const unsigned proc2 = iglobal_names[j][1];
                // Add the element to the set of additional elements to
                // sent from proc1 to proc2
                additional_elements_pt[proc1].insert(gele_pt);
                additional_elements_pt[proc2].insert(gele_pt);

              } // for (j < n_names)

            } // if (is_global_shared_node[node_pt])

          } // for (n < n_nodes)

        } // for (ihd < n_haloed_ele)

      } // if (iproc!=my_rank)

    } // for (iproc < nproc)

    // ---------------------------------------------------------------
    // Now check whether the element should really be sent to the
    // indicated processors

    // The elements from this (my_rank) processor that will be sent to
    // other processors
    Vector<Vector<FiniteElement*>> send_haloed_ele_pt(nproc);

    // loop over the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      if (iproc != my_rank)
      {
        // Get the set of element that may be sent to the iproc
        // processor
        std::set<GeneralisedElement*> iproc_ele_pt =
          additional_elements_pt[iproc];
        // loop over the element that may be sent to the iproc
        // processor
        for (std::set<GeneralisedElement*>::iterator it = iproc_ele_pt.begin();
             it != iproc_ele_pt.end();
             it++)
        {
          // Get a pointer to the element
          GeneralisedElement* gele_pt = (*it);

          // Get the haloed element with iproc
          Vector<GeneralisedElement*> haloed_ele_pt =
            this->root_haloed_element_pt(iproc);

          // Get the number of haloed elements
          const unsigned n_haloed_ele = this->nroot_haloed_element(iproc);

          // Flag to indicate whether the element has been already sent
          // to the iproc processor
          bool send_ele_to_iproc_processor = true;
          // loop over the haloed elements with iproc and check whether
          // the element has been already sent to iproc (if it is
          // already a haloed element with iproc then it has been
          // already sent)
          for (unsigned ihd = 0; ihd < n_haloed_ele; ihd++)
          {
            // A pointer to the generalised element
            GeneralisedElement* ghd_ele_pt = haloed_ele_pt[ihd];
            if (gele_pt == ghd_ele_pt)
            {
              // Mark the element as not required to be sent
              send_ele_to_iproc_processor = false;
              // Break the loop that searchs for the element on the
              // haloed elements with iproc
              break;
            }

          } // for (ihd < n_haloed_ele)

          // Do we need to sent the element?
          if (send_ele_to_iproc_processor)
          {
            // Get the finite element representation of the element
            FiniteElement* ele_pt = dynamic_cast<FiniteElement*>(gele_pt);
            // Add the element to those that will be sent to the iproc
            // processor
            send_haloed_ele_pt[iproc].push_back(ele_pt);
          }

        } // loop over the elements that may be sent to the iproc
          // processor

      } // if (iproc!=my_rank)

    } // for (iproc < nproc)

    // ---------------------------------------------------------------
    // END: Loop over the haloed element and check whether the nodes
    //      on the haloed elements are part of the global shared
    //      nodes. If that is the case then check whether the element
    //      should be sent to the processors with which the node is
    //      shared
    // ---------------------------------------------------------------

    // ============================================================
    // Now send the additional elements
    // ============================================================
    // Loop over the processors to send data
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // There are no elements to send with myself
      if (iproc != my_rank)
      {
        // Get the number of additional haloed elements to send
        const unsigned n_additional_haloed_ele =
          send_haloed_ele_pt[iproc].size();

        // Clear send and receive buffers
        Flat_packed_unsigneds.clear();
        Flat_packed_doubles.clear();
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        Flat_packed_unsigneds_string.clear();
#endif

        // The very first data of the flat packed is the number of
        // additional haloed elements, this will be the number of
        // additional halo elements to create on the receiver processor
        Flat_packed_unsigneds.push_back(n_additional_haloed_ele);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        std::stringstream junk;
        junk << "Number of haloed elements " << nhaloed_ele;
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif

        // Loop over the additioanl haloed elements
        for (unsigned e = 0; e < n_additional_haloed_ele; e++)
        {
          // Get pointer to the additional haloed element
          FiniteElement* ele_pt = send_haloed_ele_pt[iproc][e];
          const unsigned nroot_haloed_ele = this->nroot_haloed_element(iproc);

          // Check if the element has been already added to the
          // halo(ed) scheme

          // Get the generalised version of the element
          GeneralisedElement* gen_ele_pt = ele_pt;
          // Try to add the haloed element
          const unsigned haloed_ele_index =
            this->try_to_add_root_haloed_element_pt(iproc, gen_ele_pt);

          // Was the element added or only returned the index of the
          // element
          if (nroot_haloed_ele == haloed_ele_index)
          {
            Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
            Flat_packed_unsigneds_string.push_back(
              "Haloed element needs to be constructed");
#endif

            // Get additional info. related with the haloed element
            get_required_elemental_information_helper(iproc, ele_pt);

            // Get the nodes on the element
            const unsigned nnodes = ele_pt->nnode();
            for (unsigned j = 0; j < nnodes; j++)
            {
              Node* node_pt = ele_pt->node_pt(j);

              // Package the info. of the nodes
              // The destination processor goes in the arguments
              add_haloed_node_helper(iproc, node_pt);

            } // for (j < nnodes)

          } // add the element and send its nodes
          else // The haloed element already exists
          {
            Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
            Flat_packed_unsigneds_string.push_back(
              "Haloed element already exists");
#endif
            Flat_packed_unsigneds.push_back(haloed_ele_index);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
            Flat_packed_unsigneds_string.push_back(
              "Index of existing haloed element");
#endif
          } // else (next_haloed_ele == external_haloed_ele_index)

        } // for (e < n_additional_haloed_ele)

        // Send and received the additional haloed elements (all
        // processors send and receive)

        // The processor to which send the elements
        int send_proc = static_cast<int>(iproc);
        // The processor from which receive the elements
        int recv_proc = static_cast<int>(iproc);
        send_and_receive_elements_nodes_info(send_proc, recv_proc);

        // Reset the counters
        Counter_for_flat_packed_doubles = 0;
        Counter_for_flat_packed_unsigneds = 0;

        // Get the number of additional halo element to be created
        const unsigned n_additional_halo_ele =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << " Number of elements need to be constructed "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif

        // Create the additional halo elements
        for (unsigned e = 0; e < n_additional_halo_ele; e++)
        {
          // Create halo element from received info. of "iproc"
          // processor on the current processor
          create_halo_element(iproc,
                              iproc_currently_created_nodes_pt[iproc],
                              other_proc_shd_bnd_node_pt,
                              global_node_names,
                              node_name_to_global_index,
                              global_shared_node_pt);

        } // for (e < n_additional_halo_ele)

      } // if (iproc != my_rank)

    } // for (iproc < nproc)
  }

  // *********************************************************************
  // Start communication functions
  // *********************************************************************

  //========start of get_required_elemental_information_helper==============
  /// Helper function to get the required elemental information from
  /// an haloed element. This info. involves the association of the element
  /// to a boundary or region.
  //========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<
    ELEMENT>::get_required_elemental_information_helper(unsigned& iproc,
                                                        FiniteElement* ele_pt)
  {
    // Check if the element is associated with the original boundaries
    const unsigned nbound = this->initial_shared_boundary_id();

    // ------------------------------------------------------------------
    // Stores the information regarding the boundaries associated to the
    // element (it that is the case)
    Vector<unsigned> associated_boundaries;
    Vector<unsigned> face_index_on_boundary;

    unsigned counter_face_indexes = 0;

    for (unsigned b = 0; b < nbound; b++)
    {
      // Get the number of elements associated to boundary i
      const unsigned nboundary_ele = nboundary_element(b);
      for (unsigned e = 0; e < nboundary_ele; e++)
      {
        if (ele_pt == this->boundary_element_pt(b, e))
        {
          // Keep track of the boundaries associated to the element
          associated_boundaries.push_back(b);
          // Get the face index
          face_index_on_boundary.push_back(face_index_at_boundary(b, e));
          counter_face_indexes++;
#ifdef PARANOID
          if (counter_face_indexes > 2)
          {
            std::stringstream error_message;
            error_message
              << "A triangular element can not have more than two of its faces "
              << "on a boundary!!!\n\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }
#else
          // Already found 2 face indexes on the same boundary?
          if (counter_face_indexes == 2)
          {
            break;
          }
#endif // #ifdef PARANOID

        } // if (ele_pt == this->boundary_element_pt(b,e))

      } // (e < nboundary_ele)

    } // (b < nbound)

    // If the element is associated to any boundary then package all the
    // relevant info
    const unsigned nassociated_boundaries = associated_boundaries.size();
    if (nassociated_boundaries > 0)
    {
      Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.push_back(
        "The element is a boundary element");
#endif
      Flat_packed_unsigneds.push_back(nassociated_boundaries);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk;
      junk << "The elements is associated to " << nassociated_boundaries
           << " boundaries";
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif

      // Package the ids of the associated boundaries and the
      // corresponding face index for each boundary (if the element is a
      // corner element, it will have two faces associated to the
      // boundary)
      for (unsigned i = 0; i < nassociated_boundaries; i++)
      {
        unsigned b = associated_boundaries[i];
        Flat_packed_unsigneds.push_back(b);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        std::stringstream junk;
        junk << "Element associated to boundary " << b << " of "
             << nassociated_boundaries << " total associated boundaries";
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif
        unsigned f = face_index_on_boundary[i];
        Flat_packed_unsigneds.push_back(f);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        std::stringstream junk2;
        junk2 << "Face index " << f << " for associated boundary " << b;
        Flat_packed_unsigneds_string.push_back(junk2.str());
#endif
      }

      // If the element is associated to any boundary then we should
      // check if the mesh has regions, if that is the case then we need
      // to check to which region the boundary element does belong

      // If the mesh has regions we should look for the element
      // associated to a boundary and a specified region
      Vector<Vector<unsigned>> associated_boundaries_and_regions;
      Vector<unsigned> face_index_on_boundary_and_region;

      // Now check for the case when we have regions in the mesh
      const unsigned n_regions = this->nregion();
      if (n_regions > 1)
      {
        // Used to count the number of faces associated with
        // boundary-regions
        unsigned counter_face_indexes_in_regions = 0;
        // Loop over the boundaries
        for (unsigned b = 0; b < nbound; b++)
        {
          // Go through each region by getting the region id
          for (unsigned i_reg = 0; i_reg < n_regions; i_reg++)
          {
            // Get thre region id associated with the (i_reg)-th region
            const unsigned region_id =
              static_cast<unsigned>(this->Region_attribute[i_reg]);

            // Loop over all elements associated with the current boundary
            // and the i_reg-th region and check if the element is part of
            // any region
            const unsigned nele_in_region =
              this->nboundary_element_in_region(b, region_id);
            for (unsigned ee = 0; ee < nele_in_region; ee++)
            {
              // Check if the boundary-region element is the same as the
              // element
              if (ele_pt ==
                  this->boundary_element_in_region_pt(b, region_id, ee))
              {
                // Storage for the boundary and region associated to the
                // element
                Vector<unsigned> bound_and_region(2);

                // Keep track of the boundaries associated to the element
                bound_and_region[0] = b;
                // Keep track of the regions associated to the element
                bound_and_region[1] = region_id;
                // Add the boundaries and regions in the storage to be
                // sent to other processors
                associated_boundaries_and_regions.push_back(bound_and_region);
                // Get the face index and keep track of it
                face_index_on_boundary_and_region.push_back(
                  this->face_index_at_boundary_in_region(b, region_id, ee));

                // Increase the number of faces of the element associated
                // to boundary-regions
                counter_face_indexes_in_regions++;

#ifdef PARANOID
                if (counter_face_indexes_in_regions > 2)
                {
                  std::stringstream error_message;
                  error_message << "A triangular element can not have more "
                                   "than two of its\n"
                                << "faces on a boundary!!!\n\n";
                  throw OomphLibError(error_message.str(),
                                      OOMPH_CURRENT_FUNCTION,
                                      OOMPH_EXCEPTION_LOCATION);
                } // if (counter_face_indexes_in_regions > 2)
#endif

              } // The element is a boundary-region element

            } // for (ee < nele_in_region)

          } // for (i_reg < n_regions)

        } // for (b < nbound)

      } // if (n_regions >  1)

      // Now package the info. to be sent to other processors
      const unsigned nassociated_boundaries_and_regions =
        associated_boundaries_and_regions.size();
      if (nassociated_boundaries_and_regions > 0)
      {
        Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        Flat_packed_unsigneds_string.push_back(
          "The element is associated to boundaries and regions");
#endif

        Flat_packed_unsigneds.push_back(nassociated_boundaries_and_regions);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        std::stringstream junk;
        junk << "The element is associated to "
             << nassociated_boundaries_and_regions << " boundaries-regions";
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif

        // Package the ids of the associated boundaries, regions and the
        // corresponding face index for each boundary-region (if the
        // element is a corner element, it will have two faces
        // associated to the boundary-region)
        for (unsigned i = 0; i < nassociated_boundaries_and_regions; i++)
        {
          const unsigned b = associated_boundaries_and_regions[i][0];
          Flat_packed_unsigneds.push_back(b);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
          std::stringstream junk;
          junk << "Element associated to boundary " << b << " of "
               << nassociated_boundaries_and_regions
               << " total associated boundaries-regions";
          Flat_packed_unsigneds_string.push_back(junk.str());
#endif

          const unsigned r = associated_boundaries_and_regions[i][1];
          Flat_packed_unsigneds.push_back(r);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
          std::stringstream junk2;
          junk2 << "Element associated to region " << r << " of "
                << nassociated_boundaries_and_regions
                << " total associated boundaries-regions";
          Flat_packed_unsigneds_string.push_back(junk2.str());
#endif

          const unsigned f = face_index_on_boundary_and_region[i];
          Flat_packed_unsigneds.push_back(f);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
          std::stringstream junk3;
          junk3 << "Face index " << f << " for associated boundary-region ("
                << b << "-" << r << ")";
          Flat_packed_unsigneds_string.push_back(junk3.str());
#endif
        } // for (i < nassociated_boundaries_and_regions)
      } // if (nassociated_boundaries_and_regions > 0)
      else
      {
        Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        Flat_packed_unsigneds_string.push_back(
          "The element is NOT associated to boundaries and regions");
#endif
      } // else if (nassociated_boundaries_and_regions > 0)
    }
    else
    {
      Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.push_back(
        "The element is not associated to any original boundary");
#endif
    }

    // ------------------------------------------------------------
    // Now review if the element is associated to a shared boundary

    // Store the shared boundaries, and therefore the face indexes
    // associated to the element
    Vector<unsigned> associated_shared_boundaries;
    Vector<unsigned> face_index_on_shared_boundary;

    // Get the shared boundaries in this processor
    Vector<unsigned> my_rank_shared_boundaries_ids;
    this->shared_boundaries_in_this_processor(my_rank_shared_boundaries_ids);

    // Get the number of shared boundaries
    const unsigned nmy_rank_shd_bnd = my_rank_shared_boundaries_ids.size();
    // Loop over the shared boundaries
    for (unsigned i = 0; i < nmy_rank_shd_bnd; i++)
    {
      // Get the boundary id
      const unsigned sb = my_rank_shared_boundaries_ids[i];

      // Get the number of elements associated to shared boundary sb
      const unsigned nboundary_ele = this->nshared_boundary_element(sb);
      for (unsigned e = 0; e < nboundary_ele; e++)
      {
        if (ele_pt == this->shared_boundary_element_pt(sb, e))
        {
          // Keep track of the boundaries associated to the element
          associated_shared_boundaries.push_back(sb);
          // Get the face index
          face_index_on_shared_boundary.push_back(
            this->face_index_at_shared_boundary(sb, e));
        }
      } // (e < nboundary_ele)
    } // (i < nmy_rank_shd_bnd)

    // If the element is associated to a shared boundary then package
    // all the relevant info
    const unsigned nassociated_shared_boundaries =
      associated_shared_boundaries.size();
    if (nassociated_shared_boundaries > 0)
    {
      Flat_packed_unsigneds.push_back(3);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.push_back(
        "The element is a shared boundary element");
#endif
      Flat_packed_unsigneds.push_back(nassociated_shared_boundaries);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk;
      junk << "The elements is associated to " << nassociated_shared_boundaries
           << "shared boundaries";
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif

      // Package the ids of the associated boundaries
      for (unsigned i = 0; i < nassociated_shared_boundaries; i++)
      {
        const unsigned b = associated_shared_boundaries[i];
        Flat_packed_unsigneds.push_back(b);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        std::stringstream junk;
        junk << "Element associated to shared boundary " << b << " of "
             << nassociated_shared_boundaries << " total associated boundaries";
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif

        const unsigned f = face_index_on_shared_boundary[i];
        Flat_packed_unsigneds.push_back(f);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        std::stringstream junk2;
        junk2 << "Face index " << f << " for associated shared boundary " << b;
        Flat_packed_unsigneds_string.push_back(junk2.str());
#endif
      }
    }
    else
    {
      Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.push_back(
        "The element is not associated to any shared boundary");
#endif
    }
  }

  //========start of get_required_nodal_information_helper==================
  /// Helper function to get the required nodal information from an
  /// haloed node so that a fully-functional halo node (and therefore element)
  /// can be created on the receiving process
  //========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::get_required_nodal_information_helper(
    unsigned& iproc, Node* nod_pt)
  {
    unsigned my_rank = this->communicator_pt()->my_rank();
    const unsigned nproc = this->communicator_pt()->nproc();

    // Tell the halo copy of this node how many values there are
    // [NB this may be different for nodes within the same element, e.g.
    //  when using Lagrange multipliers]
    unsigned n_val = nod_pt->nvalue();
    Flat_packed_unsigneds.push_back(n_val);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    Flat_packed_unsigneds_string.push_back("Number of values");
#endif

    unsigned n_dim = nod_pt->ndim();

    // Default number of previous values to 1
    unsigned n_prev = 1;
    if (this->Time_stepper_pt != 0)
    {
      // Add number of history values to n_prev
      n_prev = this->Time_stepper_pt->ntstorage();
    }

    // -----------------------------------------------------
    // Is the node on an original boundary?
    // Store the original boundaries where the node may be
    Vector<unsigned> original_boundaries;
    // Loop over the original boundaries of the mesh and check if live
    // on one of them
    const unsigned n_bnd = this->initial_shared_boundary_id();
    for (unsigned bb = 0; bb < n_bnd; bb++)
    {
      // Which boundaries (could be more than one) is it on?
      if (nod_pt->is_on_boundary(bb))
      {
        original_boundaries.push_back(bb);
      }
    }

    const unsigned n_original_boundaries = original_boundaries.size();
    // Is the node on any original boundary?
    if (n_original_boundaries > 0)
    {
      // Indicate that the node is on an original boundary
      Flat_packed_unsigneds.push_back(2);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.push_back(
        "Node is on the original boundaries");
#endif

      Flat_packed_unsigneds.push_back(n_original_boundaries);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk;
      junk << "Node is on " << n_original_boundaries << " original boundaries";
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif

      // Loop over the original boundaries the node is on
      for (unsigned i = 0; i < n_original_boundaries; i++)
      {
        Flat_packed_unsigneds.push_back(original_boundaries[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        std::stringstream junk;
        junk << "Node is on boundary " << original_boundaries[i] << " of "
             << nb;
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif
        // Get the boundary coordinate of the node
        Vector<double> zeta(1);
        nod_pt->get_coordinates_on_boundary(original_boundaries[i], zeta);
        Flat_packed_doubles.push_back(zeta[0]);
      }
    }
    else
    {
      // Indicate that the node is NOT on an original boundary
      Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.push_back(
        "Node is on any original boundary");
#endif
    }

    // -------------------------------------------------------
    // Is the node on shared boundaries?
    bool node_on_shared_boundary = false;
    // Loop over the shared boundaries with the iproc processors and
    // check if live on one of them
    const unsigned n_shd_bnd = this->nshared_boundaries(my_rank, iproc);
    for (unsigned bb = 0; bb < n_shd_bnd; bb++)
    {
      // Get the boundary id
      unsigned i_bnd = this->shared_boundaries_ids(my_rank, iproc, bb);
      // Which boundaries (could be more than one) is it on?
      if (this->is_node_on_shared_boundary(i_bnd, nod_pt))
      {
        node_on_shared_boundary = true;
        break;
      }
    }

    // If the node live on any of the shared boundaries with the iproc
    // processor then just get the node number according to the
    // sorted_shared_boundary_node_pt() scheme and send it accross
    if (node_on_shared_boundary)
    {
      Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.push_back("Node is on shared boundary");
#endif

      // Store the shared boundaries where the node is on
      Vector<unsigned> shd_boundaries;
      // Loop over the shared boundaries with the iproc processor
      for (unsigned bb = 0; bb < n_shd_bnd; bb++)
      {
        // Get the boundary id
        const unsigned i_bnd = this->shared_boundaries_ids(my_rank, iproc, bb);
        // Which boundaries (could be more than one) is it on?
        if (this->is_node_on_shared_boundary(i_bnd, nod_pt))
        {
          shd_boundaries.push_back(i_bnd);
        }
      }

      // Get the number of shared boundaries the node is on
      const unsigned n_shd_bnd_is_on = shd_boundaries.size();
      // Send the number of shared boundaries the node is on
      Flat_packed_unsigneds.push_back(n_shd_bnd_is_on);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk;
      junk << "Node is on " << n_shd_bnd_is_on << " shared boundaries";
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif

      // Loop over the shared boundaries to send their ids
      for (unsigned i = 0; i < n_shd_bnd_is_on; i++)
      {
        Flat_packed_unsigneds.push_back(shd_boundaries[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        std::stringstream junk;
        junk << "Node is on boundary " << shd_boundaries[i] << " of " << nb;
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif
      }

      // Given that the node is on at least one boundary get the index
      // of the node in one of the boundaries and send this index
      unsigned shared_boundary_id = shd_boundaries[0];
      // Get the number of nodes on the given shared boundary
      const unsigned n_nodes_on_shared_boundary =
        nsorted_shared_boundary_node(shared_boundary_id);
      // Store the index of the node on the shared boundary
      unsigned index_node_on_shared_boundary;
#ifdef PARANOID
      // Flag to know if the node has been found
      bool found_index_node_on_shared_boundary = false;
#endif
      // Loop over the nodes on the shared boundary to find the node
      for (unsigned i = 0; i < n_nodes_on_shared_boundary; i++)
      {
        // Get the i-th node on the shared boundary
        Node* shared_node_pt =
          sorted_shared_boundary_node_pt(shared_boundary_id, i);
        // Is the node we are looking for
        if (shared_node_pt == nod_pt)
        {
          // Store the index
          index_node_on_shared_boundary = i;
#ifdef PARANOID
          // Mark as found
          found_index_node_on_shared_boundary = true;
#endif
          break; // break
        }

      } // for (i < nnodes_on_shared_boundary)

#ifdef PARANOID
      if (!found_index_node_on_shared_boundary)
      {
        std::ostringstream error_message;
        error_message << "The index of the node on boundary ("
                      << shared_boundary_id << ") was not found.\n"
                      << "The node coordinates are (" << nod_pt->x(0) << ","
                      << nod_pt->x(1) << ").\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::get_required_nodal_information_helper()",
          OOMPH_EXCEPTION_LOCATION);
      }
#endif
      // Send the index of the node on the shared boundary
      Flat_packed_unsigneds.push_back(index_node_on_shared_boundary);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk2;
      junk2 << "Node index on boundary " << boundaries[0] << " is "
            << index_node_on_shared_boundary;
      Flat_packed_unsigneds_string.push_back(junk2.str());
#endif

    } // if (node_on_shared_boundary)
    else
    {
      // The node is not on a shared boundary
      Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.push_back(
        "Node is not on a shared boundary");
#endif
    }

    // ----------------------------------------------------------------
    // Is the node on any shared boundary where the receiver processor
    // is not involved?

    // Now check if the node is on a shared boundary created by the
    // current processor (my_rank) and other processor different that
    // the iproc processor. This info. will help to complete the sending
    // of halo(ed) information between processors

    // Flag to know if the node is on a shared boundary with other
    // processor
    bool node_on_shared_boundary_with_other_processors = false;
    // Count the number of other shared boundaries it could be on
    unsigned nshared_boundaries_with_other_processors_have_node = 0;

    // Loop over the shared boundaries of the sent processor (my_rank)
    // and other processors (jproc)
    for (unsigned jproc = 0; jproc < nproc; jproc++)
    {
      // Do not search with the iproc processor , that was done before
      // above because we are sending info to that processor
      if (jproc != iproc)
      {
        // Get the number of shared boundaries with the jproc processor
        const unsigned n_jshd_bnd = this->nshared_boundaries(my_rank, jproc);
        // Loop over the shared boundaries
        for (unsigned bb = 0; bb < n_jshd_bnd; bb++)
        {
          // Get the boundary id
          const unsigned j_shd_bnd =
            this->shared_boundaries_ids(my_rank, jproc, bb);
          // Is the node part of this boundary?
          if (this->is_node_on_shared_boundary(j_shd_bnd, nod_pt))
          {
            //           DEBP("Sending to");
            //           DEBP(iproc);
            //           DEBP("Pair of procs where other shared");
            //           DEBP(my_rank);
            //           DEBP(jproc);
            //           DEBP(i_bnd);
            node_on_shared_boundary_with_other_processors = true;
            // Increase the counter for the number of shared boundaries
            // with other processors the node is on
            nshared_boundaries_with_other_processors_have_node++;
          } // if (this->is_node_on_shared_boundary(j_shd_bnd, nod_pt)

        } // for (bb<n_jshd_bnd)

      } // if (jproc != iproc)

    } // for (jproc < nproc)

    // If the node is on a shared boundary with another processor
    // (my_rank, jproc), then send the flag and look for the info.
    if (node_on_shared_boundary_with_other_processors)
    {
      Flat_packed_unsigneds.push_back(4);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.push_back(
        "Node is on shared boundary no related with the received processor: 4");
#endif

      // The number of packages of information that will be sent to the
      // "iproc" processor. This helps to know how many packages of data
      // read from the received processor
      Flat_packed_unsigneds.push_back(
        nshared_boundaries_with_other_processors_have_node);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk;
      junk << "Number of other shared boundaries that the node is on: "
           << nshared_boundaries_with_other_processors_have_node;
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif

      // Counter to ensure that the correct number of data has been sent
      unsigned counter_shd_bnd_with_other_procs_have_node = 0;
      // Loop over the shared boundaries with other processors and get:
      // 1) The processors defining the shared boundary
      // 2) The shared boundary id
      // 3) The index of the node on the shared boundary
      Vector<unsigned> other_processor_1;
      Vector<unsigned> other_processor_2;
      Vector<unsigned> shd_bnd_ids;
      Vector<unsigned> indexes;
      // Loop over the processors again
      for (unsigned jproc = 0; jproc < nproc; jproc++)
      {
        // Do not search with the iproc processor, that was done before
        // above
        if (jproc != iproc)
        {
          // Get the number of shared boundaries with the jproc
          // processor
          const unsigned n_jshd_bnd = this->nshared_boundaries(my_rank, jproc);
          for (unsigned bb = 0; bb < n_jshd_bnd; bb++)
          {
            // Get the boundary id
            const unsigned j_shd_bnd =
              this->shared_boundaries_ids(my_rank, jproc, bb);
            // Is the node part of this boundary?
            if (this->is_node_on_shared_boundary(j_shd_bnd, nod_pt))
            {
              // Include the first processor
              other_processor_1.push_back(my_rank);
              // Include the second processor
              other_processor_2.push_back(jproc);
              // Include the shared boundary id
              shd_bnd_ids.push_back(j_shd_bnd);
              // Increase the counter for found shared boundaries with
              // other processors
              counter_shd_bnd_with_other_procs_have_node++;
            }

          } // for (bb < nshared_bnd)

        } // if (jproc != iproc)

      } // for (jproc < nproc)

      // Get the indexes of the node on all the shared boundaries where
      // it was found
      const unsigned n_other_processors = other_processor_1.size();
      // Loop over the processors where the node was found
      for (unsigned i = 0; i < n_other_processors; i++)
      {
        // Get the shared boundary id
        unsigned shd_bnd_id = shd_bnd_ids[i];
        // Get the number of nodes on that shared boundary
        const unsigned n_nodes_on_shd_bnd =
          nsorted_shared_boundary_node(shd_bnd_id);

#ifdef PARANOID
        bool found_index_node_on_shared_boundary = false;
#endif
        for (unsigned i = 0; i < n_nodes_on_shd_bnd; i++)
        {
          // Get the i-th shared boundary node
          Node* shared_node_pt = sorted_shared_boundary_node_pt(shd_bnd_id, i);
          // Is the same node?
          if (shared_node_pt == nod_pt)
          {
            //             DEBP(i_node);
            //             DEBP(nod_pt->x(0));
            //             DEBP(nod_pt->x(1));
            // Include the index of the node
            indexes.push_back(i);
#ifdef PARANOID
            // Mark as found the node
            found_index_node_on_shared_boundary = true;
#endif
            break;
          } // if (shared_node_pt == nod_pt)

        } // for (i < n_nodes_on_shd_bnd)

#ifdef PARANOID
        if (!found_index_node_on_shared_boundary)
        {
          std::ostringstream error_message;
          error_message << "The index of the node on boundary (" << shd_bnd_id
                        << "), shared by other processors\nwas not found.\n"
                        << "The node coordinates are (" << nod_pt->x(0) << ","
                        << nod_pt->x(1) << ").\n";
          throw OomphLibError(
            error_message.str(),
            "RefineableTriangleMesh::get_required_nodal_information_helper()",
            OOMPH_EXCEPTION_LOCATION);
        }
#endif
      } // for (i < n_other_processors)

      // Now send the info. but first check that the number of found
      // nodes be the same that the previously found shared boundaries
      // with the node
#ifdef PARANOID
      if (counter_shd_bnd_with_other_procs_have_node !=
          nshared_boundaries_with_other_processors_have_node)
      {
        std::ostringstream error_message;
        error_message << "The number of shared boundaries where the node is on "
                      << "is different:\n"
                      << "nshared_boundaries_with_other_processors_have_node: ("
                      << nshared_boundaries_with_other_processors_have_node
                      << ")\n"
                      << "counter_shd_bnd_with_other_procs_have_node: ("
                      << counter_shd_bnd_with_other_procs_have_node << ")\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::get_required_nodal_information_helper()",
          OOMPH_EXCEPTION_LOCATION);
      } // if (counter_shd_bnd_with_other_procs_have_node !=
        // nshared_boundaries_with_other_processors_have_node)
#endif

      // Loop over the info. to send it
      for (unsigned i = 0; i < n_other_processors; i++)
      {
        Flat_packed_unsigneds.push_back(other_processor_1[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        std::stringstream junk1;
        junk1 << "Processor where the other shared boundary "
              << "has the node: " << other_processor_1[i];
        Flat_packed_unsigneds_string.push_back(junk1.str());
#endif

        Flat_packed_unsigneds.push_back(other_processor_2[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        std::stringstream junk2;
        junk2 << "Processor where the other shared boundary "
              << "has the node: " << other_processor_2[i];
        Flat_packed_unsigneds_string.push_back(junk2.str());
#endif

        Flat_packed_unsigneds.push_back(shd_bnd_ids[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        std::stringstream junk3;
        junk3 << "Other shared boundary id where the node is on"
              << boundaries[i];
        Flat_packed_unsigneds_string.push_back(junk3.str());
#endif

        Flat_packed_unsigneds.push_back(indexes[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        std::stringstream junk4;
        junk4 << "Node index on other shared boundary " << boundaries[i]
              << " is " << indexes[i];
        Flat_packed_unsigneds_string.push_back(junk4.str());
#endif

      } // for (i < n_other_processors)

    } // if (node_on_shared_boundary_with_other_processors)
    else
    {
      Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.push_back(
        "Node is on any shared boundary with other processors");
#endif
    } // else if (node_on_shared_boundary_with_other_processors)

    // Now check if it is required to send the info. of the node. If the
    // node is not on a shared boundary with the iproc processor then we
    // need to send the info.

    if (!node_on_shared_boundary)
    {
      // Send all the info. to create it

      // Is the Node algebraic?  If so, send its ref values and
      // an indication of its geometric objects if they are stored
      // in the algebraic mesh
      AlgebraicNode* alg_nod_pt = dynamic_cast<AlgebraicNode*>(nod_pt);
      if (alg_nod_pt != 0)
      {
        // The external mesh should be algebraic
        AlgebraicMesh* alg_mesh_pt = dynamic_cast<AlgebraicMesh*>(this);

        // Get default node update function ID
        unsigned update_id = alg_nod_pt->node_update_fct_id();
        Flat_packed_unsigneds.push_back(update_id);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        Flat_packed_unsigneds_string.push_back("Alg Node update id");
#endif

        // Get reference values at default...
        unsigned n_ref_val = alg_nod_pt->nref_value();
        Flat_packed_unsigneds.push_back(n_ref_val);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        Flat_packed_unsigneds_string.push_back("Alg Node n ref values");
#endif
        for (unsigned i_ref_val = 0; i_ref_val < n_ref_val; i_ref_val++)
        {
          Flat_packed_doubles.push_back(alg_nod_pt->ref_value(i_ref_val));
        }

        // Access geometric objects at default...
        unsigned n_geom_obj = alg_nod_pt->ngeom_object();
        Flat_packed_unsigneds.push_back(n_geom_obj);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        Flat_packed_unsigneds_string.push_back("Alg Node n geom objects");
#endif
        for (unsigned i_geom = 0; i_geom < n_geom_obj; i_geom++)
        {
          GeomObject* geom_obj_pt = alg_nod_pt->geom_object_pt(i_geom);

          // Check this against the stored geometric objects in mesh
          unsigned n_geom_list = alg_mesh_pt->ngeom_object_list_pt();

          // Default found index to zero
          unsigned found_geom_object = 0;
          for (unsigned i_list = 0; i_list < n_geom_list; i_list++)
          {
            if (geom_obj_pt == alg_mesh_pt->geom_object_list_pt(i_list))
            {
              found_geom_object = i_list;
            }
          }
          Flat_packed_unsigneds.push_back(found_geom_object);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
          Flat_packed_unsigneds_string.push_back("Found geom object");
#endif
        }
      } // (if alg_nod_pt!=0)

      // Is it a SolidNode?
      SolidNode* solid_nod_pt = dynamic_cast<SolidNode*>(nod_pt);
      if (solid_nod_pt != 0)
      {
        unsigned n_solid_val = solid_nod_pt->variable_position_pt()->nvalue();
        for (unsigned i_val = 0; i_val < n_solid_val; i_val++)
        {
          for (unsigned t = 0; t < n_prev; t++)
          {
            Flat_packed_doubles.push_back(
              solid_nod_pt->variable_position_pt()->value(t, i_val));
          }
        }

        Vector<double> values_solid_node;
        solid_nod_pt->add_values_to_vector(values_solid_node);
        const unsigned nvalues_solid_node = values_solid_node.size();
        Flat_packed_unsigneds.push_back(nvalues_solid_node);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        std::stringstream junk;
        junk << "Number of values solid node: " << nvalues_solid_node;
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif
        for (unsigned i = 0; i < nvalues_solid_node; i++)
        {
          Flat_packed_doubles.push_back(values_solid_node[i]);
        }
      }

      // Finally copy info required for all node types
      for (unsigned i_val = 0; i_val < n_val; i_val++)
      {
        for (unsigned t = 0; t < n_prev; t++)
        {
          Flat_packed_doubles.push_back(nod_pt->value(t, i_val));
        }
      }

      // Now do positions
      for (unsigned idim = 0; idim < n_dim; idim++)
      {
        for (unsigned t = 0; t < n_prev; t++)
        {
          Flat_packed_doubles.push_back(nod_pt->x(t, idim));
        }
      }

    } // if (!node_on_shared_boundary)
  }

  //==========start of add_haloed_node_helper===============================
  /// Helper to add external haloed node that is not a master
  //========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::add_haloed_node_helper(unsigned& iproc,
                                                               Node* nod_pt)
  {
    // Attempt to add this node as a haloed node
    const unsigned n_haloed_nod = this->nhaloed_node(iproc);
    const unsigned haloed_node_index =
      this->try_to_add_haloed_node_pt(iproc, nod_pt);

    // If it was added then the new index should match the size of the storage
    if (haloed_node_index == n_haloed_nod)
    {
      Flat_packed_unsigneds.push_back(1);

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk;
      junk << "Node needs to be constructed [size="
           << Flat_packed_unsigneds.size() << "]; last entry: "
           << Flat_packed_unsigneds[Flat_packed_unsigneds.size() - 1];
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif

      // This helper function gets all the required information for the
      // specified node and stores it into MPI-sendable information
      // so that a halo copy can be made on the receiving process
      get_required_nodal_information_helper(iproc, nod_pt);
    }
    else // It was already added
    {
      Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      std::stringstream junk;
      junk << "Node was already added [size=" << Flat_packed_unsigneds.size()
           << "]; last entry: "
           << Flat_packed_unsigneds[Flat_packed_unsigneds.size() - 1];

      Flat_packed_unsigneds_string.push_back(junk.str());
#endif

      // This node is already a haloed node, so tell
      // the other process its index in the equivalent halo storage
      Flat_packed_unsigneds.push_back(haloed_node_index);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      Flat_packed_unsigneds_string.push_back("haloed node index");
#endif
    }
  }

  //================= send_and_receive_haloed_info =======================
  /// Send the information of the elements that will be created on the other
  /// processor
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::send_and_receive_elements_nodes_info(
    int& send_proc, int& recv_proc)
  {
    // Get the communicator of the mesh
    OomphCommunicator* comm_pt = this->communicator_pt();

    // Set MPI info
    MPI_Status status;
    MPI_Request request;

    // Prepare vectors to receive information
    Vector<double> received_double_values;
    Vector<unsigned> received_unsigned_values;

    // Send the double values associated with halo(ed) elements and nodes
    //-------------------------------------------------------------------
    unsigned send_count_double_values = Flat_packed_doubles.size();
    MPI_Isend(&send_count_double_values,
              1,
              MPI_UNSIGNED,
              send_proc,
              1,
              comm_pt->mpi_comm(),
              &request);

    int receive_count_double_values = 0;
    MPI_Recv(&receive_count_double_values,
             1,
             MPI_INT,
             recv_proc,
             1,
             comm_pt->mpi_comm(),
             &status);
    MPI_Wait(&request, MPI_STATUS_IGNORE);

    if (send_count_double_values != 0)
    {
      MPI_Isend(&Flat_packed_doubles[0],
                send_count_double_values,
                MPI_DOUBLE,
                send_proc,
                2,
                comm_pt->mpi_comm(),
                &request);
    }
    if (receive_count_double_values != 0)
    {
      received_double_values.resize(receive_count_double_values);
      MPI_Recv(&received_double_values[0],
               receive_count_double_values,
               MPI_DOUBLE,
               recv_proc,
               2,
               comm_pt->mpi_comm(),
               &status);
    }
    if (send_count_double_values != 0)
    {
      MPI_Wait(&request, MPI_STATUS_IGNORE);
    }

    // Now send unsigned values associated with halo(ed) elements and nodes
    //---------------------------------------------------------------------
    unsigned send_count_unsigned_values = Flat_packed_unsigneds.size();
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    unsigned send_count_unsigned_string = Flat_packed_unsigneds_string.size();
#ifdef PARANOID
    if (send_count_unsigned_string != send_count_unsigned_values)
    {
      std::ostringstream error_message;
      error_message << "The number of unsigned values to send to processor ("
                    << send_proc
                    << ") is different from the\nnumber of annotated strings "
                    << "for the communication\n\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif // #ifdef PARANOID
#endif
    MPI_Isend(&send_count_unsigned_values,
              1,
              MPI_UNSIGNED,
              send_proc,
              14,
              comm_pt->mpi_comm(),
              &request);

    int receive_count_unsigned_values = 0;
    MPI_Recv(&receive_count_unsigned_values,
             1,
             MPI_INT,
             recv_proc,
             14,
             comm_pt->mpi_comm(),
             &status);

    MPI_Wait(&request, MPI_STATUS_IGNORE);

    if (send_count_unsigned_values != 0)
    {
      MPI_Isend(&Flat_packed_unsigneds[0],
                send_count_unsigned_values,
                MPI_UNSIGNED,
                send_proc,
                15,
                comm_pt->mpi_comm(),
                &request);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      for (unsigned i = 0; i < send_count_unsigned_values; i++)
      {
        oomph_info << "Sent:" << i << " to orig_proc:" << send_proc << " "
                   << Flat_packed_unsigneds_string[i] << ": "
                   << Flat_packed_unsigneds[i] << std::endl;
      }
#endif
    }
    if (receive_count_unsigned_values != 0)
    {
      received_unsigned_values.resize(receive_count_unsigned_values);
      MPI_Recv(&received_unsigned_values[0],
               receive_count_unsigned_values,
               MPI_UNSIGNED,
               recv_proc,
               15,
               comm_pt->mpi_comm(),
               &status);
    }

    if (send_count_unsigned_values != 0)
    {
      MPI_Wait(&request, MPI_STATUS_IGNORE);
    }

    // Copy across into original containers -- these can now
    //------------------------------------------------------
    // be processed by create_external_halo_elements() to generate
    //------------------------------------------------------------
    // external halo elements
    //------------------------
    Flat_packed_doubles.resize(receive_count_double_values);
    for (int ii = 0; ii < receive_count_double_values; ii++)
    {
      Flat_packed_doubles[ii] = received_double_values[ii];
    }
    Flat_packed_unsigneds.resize(receive_count_unsigned_values);
    for (int ii = 0; ii < receive_count_unsigned_values; ii++)
    {
      Flat_packed_unsigneds[ii] = received_unsigned_values[ii];
    }
  }

  //=====================================================================
  /// Creates (halo) element on the loop process based on the
  /// information received from each processor
  //=====================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::create_halo_element(
    unsigned& iproc,
    Vector<Node*>& new_nodes_on_domain,
    Vector<Vector<Vector<std::map<unsigned, Node*>>>>&
      other_proc_shd_bnd_node_pt,
    Vector<Vector<Vector<unsigned>>>& global_node_names,
    std::map<Vector<unsigned>, unsigned>& node_name_to_global_index,
    Vector<Node*>& global_shared_node_pt)
  {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << " Bool: New element needs to be constructed "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif

    if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 1)
    {
      // Create a new element from the communicated values
      // and coords from the process that located zeta
      GeneralisedElement* new_el_pt = new ELEMENT;

      // Add the element, it is a new element in the mesh
      this->add_element_pt(new_el_pt);

      // Add halo element to this mesh
      this->add_root_halo_element_pt(iproc, new_el_pt);

      // Cast to the FE pointer
      FiniteElement* f_el_pt = dynamic_cast<FiniteElement*>(new_el_pt);

      // Check if new element is associated to any boundary
      this->add_halo_element_helper(iproc, f_el_pt);

      // Now we add nodes to the new element
      unsigned n_node = f_el_pt->nnode();

      for (unsigned j = 0; j < n_node; j++)
      {
        Node* new_nod_pt = 0;

        // Call the add halo node helper function
        add_halo_node_helper(new_nod_pt,
                             new_nodes_on_domain,
                             other_proc_shd_bnd_node_pt,
                             iproc,
                             j,
                             f_el_pt,
                             global_node_names,
                             node_name_to_global_index,
                             global_shared_node_pt);

      } // for (j<n_nod)
    }
    else // the element already exists as halo
    {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  Index of existing halo element "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      // The index itself is in Flat_packed_unsigneds[...]
      unsigned halo_ele_index =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      // Use this index to get the element
      FiniteElement* f_el_pt = dynamic_cast<FiniteElement*>(
        this->root_halo_element_pt(iproc, halo_ele_index));

      // If it's not a finite element die
      if (f_el_pt == 0)
      {
        throw OomphLibError("Halo element is not a FiniteElement\n",
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }

    } // else the element already exists as halo
  }

  //========start of add_halo_element_helper==============================
  /// Helper function to create (halo) elements on the loop
  /// process based on the info received in send_and_received_located_info
  /// This function is in charge of verify if the element is associated to
  /// a boundary
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::add_halo_element_helper(
    unsigned& iproc, FiniteElement* ele_pt)
  {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << " Bool: Element is associated to an original boundary "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif

    if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 1)
    {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  How many boundaries are associated with the element "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      const unsigned nassociated_boundaries =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      for (unsigned b = 0; b < nassociated_boundaries; b++)
      {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Boundary associated to the element "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        const unsigned bnd =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Face index of the element "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        const unsigned face_index =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        // Associate the element with the boundary and establish as many
        // face indexes it has
        this->Boundary_element_pt[bnd].push_back(ele_pt);
        this->Face_index_at_boundary[bnd].push_back(face_index);

      } // (b < nassociated_boundaries)

      // Here read the info. regarding the boundary-region of the element
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << " Bool: Element is associated to a boundary-region "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif

      if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 1)
      {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info
          << "Rec:" << Counter_for_flat_packed_unsigneds
          << "  How many boundaries-regions are associated with the element "
          << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
          << std::endl;
#endif
        const unsigned nassociated_boundaries_and_regions =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        for (unsigned br = 0; br < nassociated_boundaries_and_regions; br++)
        {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
          oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                     << "  Boundary associated to the element "
                     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                     << std::endl;
#endif
          const unsigned bnd =
            Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
          oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                     << "  Region associated to the element "
                     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                     << std::endl;
#endif
          const unsigned region =
            Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
          oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                     << "  Face index of the element in boundary-region "
                     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                     << std::endl;
#endif
          const unsigned face_index =
            Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

          // Associate the element with the boundary-regions and establish
          // as many face indexes it has
          this->Boundary_region_element_pt[bnd][region].push_back(ele_pt);
          this->Face_index_region_at_boundary[bnd][region].push_back(
            face_index);

        } // for (br < nassociated_boundaries_and_regions)

      } // Is the element associated with a boundary-region?
    }

    // Now check if the element is associated to a shared boundary
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << " Bool: Element is associated to a shared boundary "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 3)
    {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info
        << "Rec:" << Counter_for_flat_packed_unsigneds
        << "  How many shared boundaries are associated with the element "
        << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
        << std::endl;
#endif
      const unsigned nassociated_shared_boundaries =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      for (unsigned b = 0; b < nassociated_shared_boundaries; b++)
      {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Shared boundary associated to the element "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        const unsigned bnd =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info
          << "Rec:" << Counter_for_flat_packed_unsigneds
          << "  Face index of the element associated to the shared boundary "
          << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
          << std::endl;
#endif

        const unsigned face_index =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        this->add_shared_boundary_element(bnd, ele_pt);
        this->add_face_index_at_shared_boundary(bnd, face_index);

      } // (b < nassociated_shared_boundaries)

    } // The element is associted with a shared boundary
  }

  //========start of add_halo_node_helper==========================
  /// Helper function to add halo node
  //===============================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::add_halo_node_helper(
    Node*& new_nod_pt,
    Vector<Node*>& new_nodes_on_domain,
    Vector<Vector<Vector<std::map<unsigned, Node*>>>>&
      other_proc_shd_bnd_node_pt,
    unsigned& iproc,
    unsigned& node_index,
    FiniteElement* const& new_el_pt,
    Vector<Vector<Vector<unsigned>>>& global_node_names,
    std::map<Vector<unsigned>, unsigned>& node_name_to_global_index,
    Vector<Node*>& global_shared_node_pt)
  {
    // Given the node, received information about them from process
    // iproc, construct them on the current process
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << " Bool: New node needs to be constructed "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 1)
    {
      // Construct a new node based upon sent information, or copy a node
      // from one of the shared boundaries
      construct_new_halo_node_helper(new_nod_pt,
                                     new_nodes_on_domain,
                                     other_proc_shd_bnd_node_pt,
                                     iproc,
                                     node_index,
                                     new_el_pt,
                                     global_node_names,
                                     node_name_to_global_index,
                                     global_shared_node_pt);
    }
    else
    {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  Index of existing halo node "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif

      // Copy node from received location
      new_nod_pt = new_nodes_on_domain
        [Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++]];

      new_el_pt->node_pt(node_index) = new_nod_pt;
    }
  }

  //========start of construct_new_halo_node_helper=================
  // Helper function which constructs a new external halo node (on new element)
  // with the required information sent from the haloed process
  //========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::construct_new_halo_node_helper(
    Node*& new_nod_pt,
    Vector<Node*>& new_nodes_on_domain,
    Vector<Vector<Vector<std::map<unsigned, Node*>>>>&
      other_proc_shd_bnd_node_pt,
    unsigned& iproc,
    unsigned& node_index,
    FiniteElement* const& new_el_pt,
    Vector<Vector<Vector<unsigned>>>& global_node_names,
    std::map<Vector<unsigned>, unsigned>& node_name_to_global_index,
    Vector<Node*>& global_shared_node_pt)
  {
    // The first entry indicates the number of values at this new Node
    //(which may be different across the same element e.g. Lagrange multipliers)
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << "  Number of values of external halo node "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    unsigned n_val = Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

    // Null TimeStepper for now
    TimeStepper* time_stepper_pt = this->Time_stepper_pt;
    // Default number of previous values to 1
    unsigned n_prev = time_stepper_pt->ntstorage();

    // ------------------------------------------------------
    // Check if the node is on an original boundary
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << "  Is the node on an original boundary "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif

    // Flag to indicate if the node is on original boundaries
    const unsigned node_on_original_boundaries =
      Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

    // Store the original boundaries where the node is on
    Vector<unsigned> original_boundaries_node_is_on;
    // Store the zeta coordinates of the node on the original boundaries
    Vector<double> zeta_coordinates;
    // Store the number of original boundaries the node is on
    unsigned n_original_boundaries_node_is_on = 0;

    if (node_on_original_boundaries == 2)
    {
      // How many original boundaries does the node live on?
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << " Number of boundaries the node is on: "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      n_original_boundaries_node_is_on =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      // Resize the containers
      original_boundaries_node_is_on.resize(n_original_boundaries_node_is_on);
      zeta_coordinates.resize(n_original_boundaries_node_is_on);

      for (unsigned i = 0; i < n_original_boundaries_node_is_on; i++)
      {
        // Boundary number
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Node is on boundary "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        original_boundaries_node_is_on[i] =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        zeta_coordinates[i] =
          Flat_packed_doubles[Counter_for_flat_packed_doubles++];
      }

    } // if (node_on_original_boundaries==2)
#ifdef PARANOID
    else
    {
      if (node_on_original_boundaries != 0)
      {
        std::ostringstream error_message;
        error_message
          << "The current node is not on an original boundary, this should\n"
          << "be indicated by a zero flag. However, the read value for\n"
          << "that flag is (" << node_on_original_boundaries << ").\n\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::construct_new_halo_node_helper()",
          OOMPH_EXCEPTION_LOCATION);
      } // if (node_on_original_boundaries != 0)
    }
#endif

    // --------------------------------------------------------------
    // Check if the node was on a shared boundary with the iproc
    // processor
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << "  Is node on shared boundary? "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    const unsigned is_node_on_shared_boundary =
      Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    if (is_node_on_shared_boundary == 1)
    {
      // How many shared boundaries does the node live on?
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << " Number of boundaries the node is on: "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      const unsigned n_shd_bnd_node_is_on =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      Vector<unsigned> shd_bnds_node_is_on(n_shd_bnd_node_is_on);
      for (unsigned i = 0; i < n_shd_bnd_node_is_on; i++)
      {
        // Shared boundary number
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Node is on boundary "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        shd_bnds_node_is_on[i] =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      }

      // Get the index of the node on the shared boundary
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  Index of node on boundary "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      // Get the node index of the node on the shared boundary
      unsigned node_index_on_shared_boundary =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      // Get the pointer to the node with the received info.
      new_nod_pt = this->sorted_shared_boundary_node_pt(
        shd_bnds_node_is_on[0], node_index_on_shared_boundary);

    } // if (is_node_on_shared_boundary == 1)
#ifdef PARANOID
    else
    {
      if (is_node_on_shared_boundary != 0)
      {
        std::ostringstream error_message;
        error_message
          << "The current node is not on a shared boundary, this should\n"
          << "be indicated by a zero flag. However, the read value for\n"
          << "that flag is (" << is_node_on_shared_boundary << ").\n\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::construct_new_halo_node_helper()",
          OOMPH_EXCEPTION_LOCATION);
      } // if (node_on_shared_boundary != 0)
    }
#endif

    // ------------------------------------------------------------
    // Is the node on a shared boundary with other processor?
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << "  Is the node on shared boundaries with other processors "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif

    // Is the node in shared boundaries no associated with the
    // receiver processor
    const unsigned is_the_node_in_shared_boundaries_with_other_processors =
      Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

    // The containers where to store the info.
    Vector<unsigned> other_processor_1;
    Vector<unsigned> other_processor_2;
    Vector<unsigned> other_shared_boundaries;
    Vector<unsigned> other_indexes;

    // How many shared bounaries with other processors the node lives on
    unsigned n_shd_bnd_with_other_procs_have_node = 0;

    // Is the node on shared boundaries with other processors
    if (is_the_node_in_shared_boundaries_with_other_processors == 4)
    {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  In how many shared boundaries with other "
                 << "processors is the node "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif

      // How many nodes on other shared boundaries were found
      n_shd_bnd_with_other_procs_have_node =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      // Resize the containers
      other_processor_1.resize(n_shd_bnd_with_other_procs_have_node);
      other_processor_2.resize(n_shd_bnd_with_other_procs_have_node);
      other_shared_boundaries.resize(n_shd_bnd_with_other_procs_have_node);
      other_indexes.resize(n_shd_bnd_with_other_procs_have_node);

      for (unsigned i = 0; i < n_shd_bnd_with_other_procs_have_node; i++)
      {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Processor where the other shared boundary"
                   << "has the node"
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        // Read the other processor 1
        other_processor_1[i] =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Processor where the other shared boundary"
                   << "has the node"
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        // Read the other processor 2
        other_processor_2[i] =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Other shared boundary id where the node is on: "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif

        // Read the other shared boundary id
        other_shared_boundaries[i] =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Node index on the other shared boundary "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif

        // Read the node index on the other shared boundary
        other_indexes[i] =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      } // for (i < n_shd_bnd_with_other_procs_have_node)

    } // if (is_the_node_in_shared_boundaries_with_other_processors == 4)
#ifdef PARANOID
    else
    {
      if (is_the_node_in_shared_boundaries_with_other_processors != 0)
      {
        std::ostringstream error_message;
        error_message
          << "The current node is not on a shared boundary with\n"
          << "other processors, this should be indicated by a zero flag.\n"
          << "However, the read value for that flag is ("
          << is_the_node_in_shared_boundaries_with_other_processors << ").\n\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::construct_new_halo_node_helper()",
          OOMPH_EXCEPTION_LOCATION);
      }
    }
#endif

    // Now we have all the info. to decide whether the node should be
    // created or not

    // First check if the node is a shared boundary node
    if (is_node_on_shared_boundary == 1)
    {
      // We already have the node, we do not need to create it

      // Only check if we need to add boundary info. to the node
      if (node_on_original_boundaries == 2)
      {
        // The node is a boundary node, add the boundary info. before
        // adding it to the domain

        // Associate the node to the given boundaries
        for (unsigned i = 0; i < n_original_boundaries_node_is_on; i++)
        {
          add_boundary_node(original_boundaries_node_is_on[i], new_nod_pt);
          // Establish the boundary coordinates for the node
          Vector<double> zeta(1);
          zeta[0] = zeta_coordinates[i];
          new_nod_pt->set_coordinates_on_boundary(
            original_boundaries_node_is_on[i], zeta);
        }

      } // if (node_on_original_boundaries==2)

      // Add the node to the domain
      new_nodes_on_domain.push_back(new_nod_pt);

      // Add the node to the element
      new_el_pt->node_pt(node_index) = new_nod_pt;

    } // if (is_node_on_shared_boundary == 1)

    // Now check if the node is on a shared boundary with another
    // processor, if that is the case try to find the node that may have
    // been already sent by the other processors

    // This flags indicates if the node was found, and then decide if it
    // is required to create the node
    bool found_node_in_other_shared_boundaries = false;
    // Flag to indicate whether the node should be created as a boundary
    // node or not. If the node lies on a shared boundary with other
    // processor the we create it as a boundary node. The processor from
    // which we are receiving info. (iproc) may not know that the node
    // lies on an original boundary. If the node lies on an original
    // boundary then its info. will be sent by another processor, then
    // we can set its boundary info. since the node was constructed as a
    // boundary node
    bool build_node_as_boundary_node = false;

    if (is_the_node_in_shared_boundaries_with_other_processors == 4)
    {
      // Build the node as a boundary node
      build_node_as_boundary_node = true;

      // Try to get the node pointer in case that the node has been
      // already sent by the other processors

      // Get the number of initial shared boundaries to correct the
      // index of the shared boundary
      const unsigned initial_shd_bnd_id = this->initial_shared_boundary_id();

      // Add the found nodes in the container
      Vector<Node*> found_node_pt;

      // Now try to find the node in any of the other shared boundaries
      for (unsigned i = 0; i < n_shd_bnd_with_other_procs_have_node; i++)
      {
        // We always check with the lower processor number. The
        // info. is only stored in one direction. More importantly,
        // this is done with the hope that the info. has been already
        // received from the other processor given that its info. was
        // processed before the current processor (iproc). NOTE that
        // it is not always the case that this info. has been received
        // from the other processors since it may have not require to
        // send the elements (and nodes) on the shared boundary with
        // the current processor (iproc).
        unsigned oproc1 = other_processor_1[i];
        unsigned oproc2 = other_processor_2[i];
        if (other_processor_1[i] > other_processor_2[i])
        {
          oproc1 = other_processor_2[i];
          oproc2 = other_processor_1[i];
        } // if (other_processor_1[i] > other_processor_2[i])

        // Re-compute the shared boundary id between the other
        // processors
        const unsigned shd_bnd_id =
          other_shared_boundaries[i] - initial_shd_bnd_id;

        // Read the index
        const unsigned index = other_indexes[i];

        // Check if there are nodes received from the other processor
        // and with the given shared boundary
        const unsigned n_nodes_on_other_processor =
          other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id].size();

        if (n_nodes_on_other_processor > 0)
        {
          // Check if we can find the index of the node in that
          // other processor and shared boundary id
          std::map<unsigned, Node*>::iterator it =
            other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id].find(index);

          // If the index exist then get the node pointer
          if (it !=
              other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id].end())
          {
            // Mark the node as found
            found_node_in_other_shared_boundaries = true;
            // Get the node pointer
            Node* tmp_node_pt = (*it).second;

            // Push back the node pointer
            found_node_pt.push_back(tmp_node_pt);

          } // if (it!=
            // other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id].end())

        } // if (n_nodes_on_other_processor > 0)

      } // for (i < n_shd_bnd_with_other_procs_have_node)

      // If the node was found, then all their instances should be the
      // same but better check
      if (found_node_in_other_shared_boundaries)
      {
#ifdef PARANOID
        const unsigned n_times_node_found = found_node_pt.size();
        for (unsigned j = 1; j < n_times_node_found; j++)
        {
          if (found_node_pt[j - 1] != found_node_pt[j])
          {
            std::ostringstream error_message;
            error_message
              << "The instances of the node that was found on\n"
              << "shared boundaries with other processors (but not\n"
              << "on shared boundaries with this processor) are not\n"
              << "the same.\n"
              << "These are the coordinates of the instances of the\n"
              << "nodes:\n"
              << "(" << found_node_pt[j - 1]->x(0) << ", "
              << found_node_pt[j - 1]->x(1) << ")\n"
              << "(" << found_node_pt[j]->x(0) << ", " << found_node_pt[j]->x(1)
              << ")\n"
              << "Dont be surprised if they are the same since the "
              << "node is\nrepeated.\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);

          } // if (found_node_pt[j-1] != found_node_pt[j])

        } // for (j < ntimes_node_found)
#endif // #ifdef PARANOID

        // Check if the node is a shared boundary node from the
        // current processor and the iproc processor, if that is the
        // case, and the node is also on a shared boundary with other
        // processor, then the pointer should be the same!!!
        if (is_node_on_shared_boundary == 1)
        {
          // const unsigned n_times_node_found = found_node_pt.size();
          // The pointer to the node is already assigned, it was
          // assigned when the node was found to be on a shared
          // boundary with the sending processor (iproc). Check that
          // any previous instances of the node have been copied
          // from the shared boundary, if that is not the case then
          // there is a problem
          if (found_node_pt[0] != new_nod_pt)
          {
            std::ostringstream error_message;
            error_message
              << "The pointer of the node that was found to be on a\n"
              << "shared boundary with other processor(s) and the pointer\n"
              << "of the node on shared boundary with the receiver\n"
              << "processor (iproc) are not the same. This means we have a\n"
              << "repeated node)\n"
              << "The coordinates for the nodes are:\n"
              << "(" << found_node_pt[0]->x(0) << ", " << found_node_pt[0]->x(1)
              << ")\n"
              << "(" << new_nod_pt->x(0) << ", " << new_nod_pt->x(1) << ")\n"
              << "Dont be surprised if they are the same since the "
              << "node is\nrepeated.\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);

          } // if (found_node_pt[i] != new_nod_pt)

        } // if (is_node_on_shared_boundary == 1)
        else
        {
          // Take the first instance of the node in case that it was
          // found and is not on a shared boundary with the iproc
          // processor (the processor from which we are receiving
          // the info.)
          new_nod_pt = found_node_pt[0];
        }

      } // if (found_node_in_other_shared_boundaries)

    } // if (is_the_node_in_shared_boundaries_with_other_processors == 4)

    // -----------------------------------------------------------------
    // Create the node or read the received info if the node is not on a
    // shared boundary with the iproc processor
    if (is_node_on_shared_boundary != 1)
    {
      // If the node is on a shared boundary with other processor we
      // need to read all the info. since the processor that sent the
      // info. did not know that the node is part of another shared
      // boundary

      // If the node is not on a shared boundary (with any processor),
      // or if this is the first time that the info. of the node is
      // received from any of the processors with which it has a shared
      // boundary, then we create the node

      // Is the node a boundary node or should it be build as a boundary
      // node because it is on a shared boundary with other processors
      if (node_on_original_boundaries == 2 || build_node_as_boundary_node)
      {
        // Check if necessary to create the node, or if it has been
        // already found in shared boundaries with other processors
        if (!found_node_in_other_shared_boundaries)
        {
          // Construct a boundary node
          if (time_stepper_pt != 0)
          {
            new_nod_pt =
              new_el_pt->construct_boundary_node(node_index, time_stepper_pt);
          }
          else
          {
            new_nod_pt = new_el_pt->construct_boundary_node(node_index);
          }

        } // if (!found_node_in_other_shared_boundaries)
        else
        {
          // If the node was found then assign the node to the element
          new_el_pt->node_pt(node_index) = new_nod_pt;

        } // else if (!found_node_in_other_shared_boundaries)

        // Associate the node to the given boundaries
        for (unsigned i = 0; i < n_original_boundaries_node_is_on; i++)
        {
          add_boundary_node(original_boundaries_node_is_on[i], new_nod_pt);
          // Establish the boundary coordinates for the node
          Vector<double> zeta(1);
          zeta[0] = zeta_coordinates[i];
          new_nod_pt->set_coordinates_on_boundary(
            original_boundaries_node_is_on[i], zeta);
        }

      } // if (node is on an original boundary)
      else
      {
        // Check if necessary to create the node, or if it has been
        // already found in shared boundaries with other processors
        if (!found_node_in_other_shared_boundaries)
        {
          // Construct an ordinary (non-boundary) node
          if (time_stepper_pt != 0)
          {
            new_nod_pt = new_el_pt->construct_node(node_index, time_stepper_pt);
          }
          else
          {
            new_nod_pt = new_el_pt->construct_node(node_index);
          }
        } // if (!found_node_in_other_shared_boundaries)
        else
        {
          // If the node was found then assign the node to the element
          new_el_pt->node_pt(node_index) = new_nod_pt;
        } // else if (!found_node_in_other_shared_boundaries)

      } // else (the node is not a boundary node)

      // ... and gather all its information

      // If the node was found or not in other shared boundaries, this
      // is the first time the node is received from this processor
      // (iproc), therefore it is added to the vector of nodes received
      // from this processor (iproc)
      new_nodes_on_domain.push_back(new_nod_pt);

      // Check if necessary to state all the info. to the node if it has
      // been already found in shared boundaries with other processors
      if (!found_node_in_other_shared_boundaries)
      {
        // Add the node to the general node storage
        this->add_node_pt(new_nod_pt);
      } // if (!found_node_in_other_shared_boundaries)

      // Is the new constructed node Algebraic?
      AlgebraicNode* new_alg_nod_pt = dynamic_cast<AlgebraicNode*>(new_nod_pt);

      // If it is algebraic, its node update functions will
      // not yet have been set up properly
      if (new_alg_nod_pt != 0)
      {
        // The AlgebraicMesh is the external mesh
        AlgebraicMesh* alg_mesh_pt = dynamic_cast<AlgebraicMesh*>(this);

        /// The first entry of All_alg_nodal_info contains
        /// the default node update id
        /// e.g. for the quarter circle there are
        /// "Upper_left_box", "Lower right box" etc...
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Alg node update id "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif

        unsigned update_id =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        Vector<double> ref_value;

        // The size of this vector is in the next entry
        // of All_alg_nodal_info
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Alg node # of ref values "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        unsigned n_ref_val =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        // The reference values themselves are in
        // All_alg_ref_value
        ref_value.resize(n_ref_val);
        for (unsigned i_ref = 0; i_ref < n_ref_val; i_ref++)
        {
          ref_value[i_ref] =
            Flat_packed_doubles[Counter_for_flat_packed_doubles++];
        }

        Vector<GeomObject*> geom_object_pt;
        /// again we need the size of this vector as it varies
        /// between meshes; we also need some indication
        /// as to which geometric object should be used...

        // The size of this vector is in the next entry
        // of All_alg_nodal_info
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Alg node # of geom objects "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        unsigned n_geom_obj =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        // The remaining indices are in the rest of
        // All_alg_nodal_info
        geom_object_pt.resize(n_geom_obj);
        for (unsigned i_geom = 0; i_geom < n_geom_obj; i_geom++)
        {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
          oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                     << "  Alg node: geom object index "
                     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                     << std::endl;
#endif
          unsigned geom_index =
            Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
          // This index indicates which of the AlgebraicMesh's
          // stored geometric objects should be used
          // (0 is a null pointer; everything else should have
          //  been filled in by the specific Mesh).  If it
          // hasn't been filled in then the update_node_update
          // call should fix it
          geom_object_pt[i_geom] = alg_mesh_pt->geom_object_list_pt(geom_index);
        }

        // Check if necessary to state all the info. to the node if it has
        // been already found in shared boundaries with other processors
        if (!found_node_in_other_shared_boundaries)
        {
          /// For the received update_id, ref_value, geom_object
          /// call add_node_update_info
          new_alg_nod_pt->add_node_update_info(
            update_id, alg_mesh_pt, geom_object_pt, ref_value);

          /// Now call update_node_update
          alg_mesh_pt->update_node_update(new_alg_nod_pt);

        } // if (!found_node_in_other_shared_boundaries)

      } // if (new_alg_nod_pt!=0)

      // Check if necessary to state all the info. to the node if it has
      // been already found in shared boundaries with other processors
      if (!found_node_in_other_shared_boundaries)
      {
        // Is the node a MacroElementNodeUpdateNode?
        MacroElementNodeUpdateNode* macro_nod_pt =
          dynamic_cast<MacroElementNodeUpdateNode*>(new_nod_pt);

        if (macro_nod_pt != 0)
        {
          // Need to call set_node_update_info; this requires
          // a Vector<GeomObject*> (taken from the mesh)
          Vector<GeomObject*> geom_object_vector_pt;

          // Access the required geom objects from the
          // MacroElementNodeUpdateMesh
          MacroElementNodeUpdateMesh* macro_mesh_pt =
            dynamic_cast<MacroElementNodeUpdateMesh*>(this);
          geom_object_vector_pt = macro_mesh_pt->geom_object_vector_pt();

          // Get local coordinate of node in new element
          Vector<double> s_in_macro_node_update_element;
          new_el_pt->local_coordinate_of_node(node_index,
                                              s_in_macro_node_update_element);

          // Set node update info for this node
          macro_nod_pt->set_node_update_info(
            new_el_pt, s_in_macro_node_update_element, geom_object_vector_pt);
        }

      } // if (!found_node_in_other_shared_boundaries)

      // If there are additional values, resize the node
      unsigned n_new_val = new_nod_pt->nvalue();

      // Check if necessary to state all the info. to the node if it has
      // been already found in shared boundaries with other processors
      if (!found_node_in_other_shared_boundaries)
      {
        if (n_val > n_new_val)
        {
          // If it has been necessary to resize then it may be becuse
          // the node is on a FSI boundary, if that is the case we need
          // to set a map for these external values

          // Cast to a boundary node
          BoundaryNodeBase* bnod_pt =
            dynamic_cast<BoundaryNodeBase*>(new_nod_pt);

          // Create storage, if it doesn't already exist, for the map
          // that will contain the position of the first entry of
          // this face element's additional values,
          if (bnod_pt->index_of_first_value_assigned_by_face_element_pt() == 0)
          {
            bnod_pt->index_of_first_value_assigned_by_face_element_pt() =
              new std::map<unsigned, unsigned>;
          }

          // Get pointer to the map
          std::map<unsigned, unsigned>* map_pt =
            bnod_pt->index_of_first_value_assigned_by_face_element_pt();

          // The id of the face to which this node belong in the bulk
          // element
          const unsigned id_face = 0;
          // We only resize the node values Vector if we haven't done it yet
          std::map<unsigned, unsigned>::const_iterator p =
            map_pt->find(id_face);

          // If this node hasn't been resized for current id
          if (p == map_pt->end())
          {
            // assign the face element id and the position of the
            // first entry to the boundary node
            (*map_pt)[id_face] = n_new_val;

            // resize the node vector of values
            new_nod_pt->resize(n_val);
          }

        } // if (n_val>n_new_val)

      } // if (!found_node_in_other_shared_boundaries)

      // Is the new node a SolidNode?
      SolidNode* solid_nod_pt = dynamic_cast<SolidNode*>(new_nod_pt);
      if (solid_nod_pt != 0)
      {
        unsigned n_solid_val = solid_nod_pt->variable_position_pt()->nvalue();
        for (unsigned i_val = 0; i_val < n_solid_val; i_val++)
        {
          for (unsigned t = 0; t < n_prev; t++)
          {
            double read_data =
              Flat_packed_doubles[Counter_for_flat_packed_doubles++];

            // Check if necessary to state all the info. to the node if it has
            // been already found in shared boundaries with other processors
            if (!found_node_in_other_shared_boundaries)
            {
              solid_nod_pt->variable_position_pt()->set_value(
                t, i_val, read_data);
            } // if (!found_node_in_other_shared_boundaries)
          }
        }

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Number of values solid node: "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        const unsigned nvalues_solid_node =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        Vector<double> values_solid_node(nvalues_solid_node);
        for (unsigned i = 0; i < nvalues_solid_node; i++)
        {
          values_solid_node[i] =
            Flat_packed_doubles[Counter_for_flat_packed_doubles++];
        }

        // Check if necessary to state all the info. to the node if it has
        // been already found in shared boundaries with other processors
        if (!found_node_in_other_shared_boundaries)
        {
          unsigned index = 0;
          solid_nod_pt->read_values_from_vector(values_solid_node, index);
        }
      }

      // Get copied history values
      //  unsigned n_val=new_nod_pt->nvalue();
      for (unsigned i_val = 0; i_val < n_val; i_val++)
      {
        for (unsigned t = 0; t < n_prev; t++)
        {
          double read_data =
            Flat_packed_doubles[Counter_for_flat_packed_doubles++];

          // Check if necessary to state all the info. to the node if it
          // has been already found in shared boundaries with other
          // processors
          if (!found_node_in_other_shared_boundaries)
          {
            new_nod_pt->set_value(t, i_val, read_data);
          } // if (!found_node_in_other_shared_boundaries)
        }
      }

      // Get copied history values for positions
      unsigned n_dim = new_nod_pt->ndim();
      for (unsigned idim = 0; idim < n_dim; idim++)
      {
        for (unsigned t = 0; t < n_prev; t++)
        {
          double read_data =
            Flat_packed_doubles[Counter_for_flat_packed_doubles++];

          // Check if necessary to state all the info. to the node if it
          // has been already found in shared boundaries with other
          // processors
          if (!found_node_in_other_shared_boundaries)
          {
            // Copy to coordinate
            new_nod_pt->x(t, idim) = read_data;

          } // if (!found_node_in_other_shared_boundaries)
        }
      }

    } // if (is_node_on_shared_boundary != 1)

    // If the node was not found in other shared boundaries (possibly
    // because it is the first time the node has been sent) then copy
    // the node to the shared boundaries where it should be, use the
    // special container for this cases
    if (n_shd_bnd_with_other_procs_have_node > 0 && // The node is on
                                                    // shared
                                                    // boundaries with
                                                    // other processors
        !found_node_in_other_shared_boundaries) // The node has not
                                                // been previously
                                                // set as
                                                // shared with
                                                // other processors
                                                // (first time)
    {
      // Update the node pointer in all the (references) of the node
      this->update_other_proc_shd_bnd_node_helper(new_nod_pt,
                                                  other_proc_shd_bnd_node_pt,
                                                  other_processor_1,
                                                  other_processor_2,
                                                  other_shared_boundaries,
                                                  other_indexes,
                                                  global_node_names,
                                                  node_name_to_global_index,
                                                  global_shared_node_pt);

    } // if (!found_node_in_other_shared_boundaries)
  }

  //========start of update_other_proc_shd_bnd_node_helper=================
  // Helper function that assigns/updates the references to the node so
  // that it can be found with any other reference
  //========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::update_other_proc_shd_bnd_node_helper(
    Node*& new_node_pt,
    Vector<Vector<Vector<std::map<unsigned, Node*>>>>&
      other_proc_shd_bnd_node_pt,
    Vector<unsigned>& other_processor_1,
    Vector<unsigned>& other_processor_2,
    Vector<unsigned>& other_shared_boundaries,
    Vector<unsigned>& other_indexes,
    Vector<Vector<Vector<unsigned>>>& global_node_names,
    std::map<Vector<unsigned>, unsigned>& node_name_to_global_index,
    Vector<Node*>& global_shared_node_pt)
  {
    // Get the number of initial shared boundaries to correct the index
    // of the shared boundary
    const unsigned initial_shd_bnd_id = this->initial_shared_boundary_id();

#ifdef PARANOID
    // Get the number of instances of the node on other shared
    // boundaries with other processors
    const unsigned n_data = other_processor_1.size();
#endif // #ifdef PARANOID

    // Create the first node name
    Vector<unsigned> node_name(4);
    node_name[0] = other_processor_1[0];
    node_name[1] = other_processor_2[0];
    node_name[2] = other_shared_boundaries[0];
    node_name[3] = other_indexes[0];

#ifdef PARANOID
    // Get the global node index, and all the names of the node
    std::map<Vector<unsigned>, unsigned>::iterator it =
      node_name_to_global_index.find(node_name);
    if (it == node_name_to_global_index.end())
    {
      std::ostringstream error_stream;
      error_stream << "The node name does not exist in the global node names\n"
                   << "This is the name of the node\n"
                   << "Name: iproc, jproc, ishd_bnd, idx\n"
                   << "Name: " << node_name[0] << ", " << node_name[1] << ", "
                   << node_name[2] << ", " << node_name[3] << "\n";
      throw OomphLibError(
        error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    } // if (it!=node_name_to_global_index.end())
#endif // #ifdef PARANOID

    // Get the global node index
    const unsigned iglobal_node = node_name_to_global_index[node_name];
    // Add the node to the global shared node container
    global_shared_node_pt[iglobal_node] = new_node_pt;
    // Get the names
    Vector<Vector<unsigned>> inode_names = global_node_names[iglobal_node];
    // Get the number of names of the node
    const unsigned n_names = inode_names.size();

#ifdef PARANOID
    // Check that the received names of the node are part of the global
    // node names
    unsigned n_found_node_names_on_global_node_name = 0;
    // loop over the input node names
    for (unsigned j = 0; j < n_data; j++)
    {
      // loop over the inode_names
      for (unsigned k = 0; k < n_names; k++)
      {
        // Is this input name part of the global node names?
        if (inode_names[k][0] == other_processor_1[j] &&
            inode_names[k][1] == other_processor_2[j] &&
            inode_names[k][2] == other_shared_boundaries[j] &&
            inode_names[k][3] == other_indexes[j])
        {
          // Increase the number of found input node names in the
          // global node names
          n_found_node_names_on_global_node_name++;
        }

      } // for (k < n_names)

    } // for (j < n_data)

    // Were all the input node names found on the global node names?
    if (n_found_node_names_on_global_node_name != n_data)
    {
      std::ostringstream error_stream;
      error_stream
        << "Not all the node names of the current node were found on the\n"
        << "global node names. This happened when adding the node pointer\n"
        << "to the data structure that keeps tracks of nodes on shared\n"
        << "boundaries with other processors\n\n"
        << "These are the names of the current node\n"
        << "Name k: iproc, jproc, ishd_bnd, idx\n";
      for (unsigned j = 0; j < n_data; j++)
      {
        error_stream << "Name(" << j << "): " << other_processor_1[j] << ", "
                     << other_processor_2[j] << ", "
                     << other_shared_boundaries[j] << ", " << other_indexes[j]
                     << "\n";
      }

      error_stream << "\n\nThese are the names of the global node\n"
                   << "Name k: iproc, jproc, ishd_bnd, idx\n";
      for (unsigned k = 0; k < n_names; k++)
      {
        error_stream << "Name(" << k << "): " << inode_names[k][0] << ", "
                     << inode_names[k][1] << ", " << inode_names[k][2] << ", "
                     << inode_names[k][3] << "\n";
      }

      throw OomphLibError(
        error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif // #ifdef PARANOID

    // Set the node pointer in all of its names
    for (unsigned j = 0; j < n_names; j++)
    {
      // Get the j-th node name
      const unsigned iproc = inode_names[j][0];
      const unsigned jproc = inode_names[j][1];
      const unsigned ishd_bnd = inode_names[j][2] - initial_shd_bnd_id;
      const unsigned index = inode_names[j][3];

      // The info. is stored only in one direction
      // Get the smallest processor number
      if (iproc < jproc)
      {
        other_proc_shd_bnd_node_pt[iproc][jproc][ishd_bnd][index] = new_node_pt;
      }
      else
      {
        other_proc_shd_bnd_node_pt[jproc][iproc][ishd_bnd][index] = new_node_pt;
      }

    } // for (j < n_names)
  }

  // *********************************************************************
  // End communication functions
  // *********************************************************************

  // *********************************************************************
  // BEGIN: Methods to perform load balance
  // *********************************************************************

  //======================================================================
  /// Performs the load balancing for unstructured meshes, the
  /// load balancing strategy is based on mesh migration
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::load_balance(
    const Vector<unsigned>& target_domain_for_local_non_halo_element)
  {
    oomph_info << "Load balance (unstructured mesh) [BEGIN]" << std::endl;

    // This method can only be called when the mesh has been already
    // distributed
    if (!this->is_mesh_distributed())
    {
      std::ostringstream warning_message;
      warning_message
        << "\n===============================================================\n"
        << "The load balancing can only be performed in distributed meshes,\n"
        << "your mesh has not been distributed.\n"
        << "==============================================================="
           "\n\n";
      OomphLibWarning(warning_message.str(),
                      OOMPH_CURRENT_FUNCTION,
                      OOMPH_EXCEPTION_LOCATION);
      // Return
      return;
    }

    // Get the number of processors
    const unsigned nproc = this->communicator_pt()->nproc();
    // Get the rank of the current processors
    const unsigned my_rank = this->communicator_pt()->my_rank();

    // Check that there are at least two processors
    if (nproc == 1)
    {
      std::ostringstream warning_message;
      warning_message
        << "\n===============================================================\n"
        << "The load balancing can only be performed when there are at least\n"
        << "two procesors, the current number of processors is one.\n"
        << "==============================================================="
           "\n\n";
      OomphLibWarning(warning_message.str(),
                      OOMPH_CURRENT_FUNCTION,
                      OOMPH_EXCEPTION_LOCATION);
      // Return
      return;
    }

    // Get the time before load balance
    double t_start_overall_load_balance = 0.0;
    if (Print_timings_level_load_balance > 1)
    {
      t_start_overall_load_balance = TimingHelpers::timer();
    }

    // Get the number of elements in the mesh before load balance
    const unsigned nelement_before_load_balance = this->nelement();

#ifdef PARANOID
    // The number of elements in the mesh and the number of target
    // domains for the local non halo elements in the mesh should match
    if (nnon_halo_element() != target_domain_for_local_non_halo_element.size())
    {
      std::ostringstream error_message;
      error_message << "The number of non halo elements in the current mesh ("
                    << nnon_halo_element() << ") and the number\n"
                    << "of target areas for the local non halo elements ("
                    << target_domain_for_local_non_halo_element.size()
                    << ") is different\n\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Backup pointers to elements in this mesh
    Vector<FiniteElement*> backed_up_ele_pt(nelement_before_load_balance);
    for (unsigned e = 0; e < nelement_before_load_balance; e++)
    {
      backed_up_ele_pt[e] = this->finite_element_pt(e);
    }

    // =====================================================================
    // BEGIN: GET THE DOMAINS FOR THE HALO ELEMENTS
    // =====================================================================

    // Get the time to get the domains of halo elements
    double tt_start_get_domains_halo_elements = 0.0;
    if (Print_timings_level_load_balance > 1)
    {
      tt_start_get_domains_halo_elements = TimingHelpers::timer();
    }

    // Get the new domains for the halo elements

    // Send the new domains for the current haloed elements, and receive
    // the new domains for the current halo elements
    // -- 1) On the current processor get the new domains for the
    //       haloed elements
    // -- 2) Then send this info. to all the processor that have a
    //       halo copy of the element

    // The storing for the new domains of the haloed elements (sent to
    // other processors)
    Vector<Vector<unsigned>> new_domains_haloed_elements(nproc);
    // The storing for the new domains of the halo elements (received
    // from other processors)
    Vector<Vector<unsigned>> new_domains_halo_elements(nproc);

    // First resize the containers by getting the current number of
    // halo/haloed elements within each processor
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // There are no halo/haloed elements with myself (my_rank
      // processor)
      if (iproc != my_rank)
      {
        // Get the number of halo elements with iproc processor
        const unsigned n_halo_iproc = this->nroot_halo_element(iproc);
        // Resize the container
        new_domains_halo_elements[iproc].resize(n_halo_iproc);

        // Get the number of haloed elements with iproc processor
        const unsigned n_haloed_iproc = this->nroot_haloed_element(iproc);
        // Resize the container
        new_domains_haloed_elements[iproc].resize(n_haloed_iproc);
      } // if (iproc != my_rank)
    } // for (iproc < nproc)

#ifdef PARANOID
    // Count the number of found haloed elements
    Vector<unsigned> counter_for_found_haloed_elements(nproc, 0);
#endif

    // Go through all the haloed elements and find their new domain

    // Get the haloed elements with in each processor and check if the
    // element is haloed with the processor
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // There are no halo/haloed elements with myself (my_rank
      // processor)
      if (iproc != my_rank)
      {
        // Get the number of haloed elements with iproc processor
        const unsigned n_haloed_iproc = this->nroot_haloed_element(iproc);

        // Loop over the haloed elements
        for (unsigned ihd = 0; ihd < n_haloed_iproc; ihd++)
        {
          // Get the ihd-th haloed element with "iproc" processor
          GeneralisedElement* haloed_ele_pt =
            this->root_haloed_element_pt(iproc, ihd);

          // The counter for the nonhalo elements
          unsigned nh_count4 = 0;
          // Find the element in the general elements container
          for (unsigned e = 0; e < nelement_before_load_balance; e++)
          {
            // Get the e-th element
            GeneralisedElement* ele_pt = this->element_pt(e);
            // Check if the element is a nonhalo element
            if (!ele_pt->is_halo())
            {
              // Increase the counter for nonhalo elements, in case the
              // haloed element is found get the (nh_count4-1) position
              // in the target domains vector
              nh_count4++;

              if (ele_pt == haloed_ele_pt)
              {
                // Get the new domain for this element
                const unsigned element_domain =
                  target_domain_for_local_non_halo_element[nh_count4 - 1];
                // Here decrease the counter ---------------------^

                // Set the new domain for the haloed element in the
                // special container
                new_domains_haloed_elements[iproc][ihd] = element_domain;
#ifdef PARANOID
                // Increase the counter
                counter_for_found_haloed_elements[iproc]++;
#endif
                // ... and break the "for" with the general
                // elements. Continue with the next haloed element
                break;

              } // if (ele_pt == haloed_ele_pt))

            } // if (!ele_pt->is_halo())

          } // for (e < nelement_before_load_balance)

        } // for (ihd < n_haloed_iproc)

      } // if (iproc != my_rank)

    } // for (iproc < nproc)

#ifdef PARANOID
    // Check that all the haloed elements with all processors have been
    // found
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // There are no halo/haloed elements with myself (my_rank
      // processor)
      if (iproc != my_rank)
      {
        // Get the number of haloed elements with "iproc" processor
        const unsigned n_haloed_iproc = this->nroot_haloed_element(iproc);

        // Compare the number of found haloed elements with the current
        // number of haloed elements
        if (n_haloed_iproc != counter_for_found_haloed_elements[iproc])
        {
          std::ostringstream error_message;
          error_message << "The independent counting of found haloed elements ("
                        << counter_for_found_haloed_elements[iproc]
                        << ") with processor (" << iproc
                        << ") is not equal to the number of haloed elements ("
                        << n_haloed_iproc << ") with processor (" << iproc
                        << ")\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        } // if (nhaloed_iproc == counter_for_found_haloed_elements[iproc])

      } // if (iproc != my_rank)

    } // for (iproc < nproc)
#endif

    // Now we have the new domains for the haloed elements

    // Send this info. to the processor with a halo copy of the haloed
    // elements and set the new domains in the halo copies

    // First put all the info. in a flat package array
    Vector<unsigned> new_domains_haloed_flat_unsigned;
    // Put in a vector the number of haloed elements within each
    // processor
    Vector<int> nhaloed_elements_with_iproc(nproc);
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // There are no halo/haloed elements with myself (my_rank
      // processor)
      if (iproc != my_rank)
      {
        // Get the number of haloed elements with "iproc" processor
        const unsigned n_haloed_ele_iproc = this->nroot_haloed_element(iproc);
        // Copy the number of haloed elements with "iproc" processor
        nhaloed_elements_with_iproc[iproc] = n_haloed_ele_iproc;
        // Copy the new domains of the haloed elements in the flat
        // package
        for (unsigned i = 0; i < n_haloed_ele_iproc; i++)
        {
          new_domains_haloed_flat_unsigned.push_back(
            new_domains_haloed_elements[iproc][i]);
        } // for (i < n_haloed_ele_iproc)

      } // if (iproc != my_rank)

    } // for (iproc < nproc)

    // The offsets of the flat package within each processor
    Vector<int> offset_haloed_elements_with_iproc(nproc);
    offset_haloed_elements_with_iproc[0] = 0;
    for (unsigned ip = 1; ip < nproc; ip++)
    {
      // Compute the offset to send the values to each processor
      offset_haloed_elements_with_iproc[ip] =
        offset_haloed_elements_with_iproc[ip - 1] +
        nhaloed_elements_with_iproc[ip - 1];
    } // for (ip < nproc)

    // Prepare to receive the data

    // Compute the number of data (halo elements) to receive from each
    // processor and the displacements within each processor

    // Counter for the total number of halo elements within all processors
    unsigned counter_halo_ele_with_all_procs = 0;

    // Put in a vector the number of halo elements expected to receive
    // from each processor
    Vector<int> nhalo_elements_with_iproc(nproc);
    // Compute the number of total halo elements of (my_rank) this
    // processor with all other processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // There are no halo/haloed elements with myself (my_rank
      // processor)
      if (iproc != my_rank)
      {
        // Get the number of halo elements with "iproc" processor
        const unsigned n_halo_ele_iproc = this->nroot_halo_element(iproc);
        // Copy the number of halo elements with "iproc" processor
        nhalo_elements_with_iproc[iproc] = n_halo_ele_iproc;
        // Add the number of elements with this processor
        counter_halo_ele_with_all_procs += n_halo_ele_iproc;
      } // if (iproc != my_rank)

    } // for (iproc < nproc)

    // The offsets of the flat package within each processor
    Vector<int> offset_halo_elements_with_iproc(nproc);
    offset_halo_elements_with_iproc[0] = 0;
    for (unsigned ip = 1; ip < nproc; ip++)
    {
      // Compute the offset to receive the values from each processor
      offset_halo_elements_with_iproc[ip] =
        offset_halo_elements_with_iproc[ip - 1] +
        nhalo_elements_with_iproc[ip - 1];
    } // for (ip < nproc)

    // The flat container to receive the new domains of the halo
    // elements in the current processor

    // The flat package where all the info. will be gather from the
    // other processors (the halo flat package)
    Vector<unsigned> new_domains_halo_flat_unsigned(
      counter_halo_ele_with_all_procs);

    // Perform the sending and receiving of information to and from all
    // processors
    MPI_Alltoallv(&new_domains_haloed_flat_unsigned[0], // void *sendbuf
                  &nhaloed_elements_with_iproc[0], // int *sendcnts
                  &offset_haloed_elements_with_iproc[0], // int *sdispls
                  MPI_UNSIGNED, // MPI_Datatype sendtype
                  &new_domains_halo_flat_unsigned[0], // void *recvbuf
                  &nhalo_elements_with_iproc[0], // int *recvcnts
                  &offset_halo_elements_with_iproc[0], // int *rdispls
                  MPI_UNSIGNED, // MPI_Datatype recvtype
                  this->communicator_pt()->mpi_comm()); // MPI_Comm comm

    // Once received the new domains for the halo elements, copy the
    // domains back to an easier to handle container (from the flat
    // package to the one with the different halo elements domains
    // within each processor)
    unsigned counter_new_domains_halo_ele = 0;
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // There are no halo/haloed elements with myself (my_rank
      // processor)
      if (iproc != my_rank)
      {
        // Get the number of halo elements with "iproc"
        const unsigned ntmp_halo_elements_with_iproc =
          nhalo_elements_with_iproc[iproc];
        // Loop over the number of halo elements within "iproc" and copy
        // the elements from the flat package
        for (unsigned i = 0; i < ntmp_halo_elements_with_iproc; i++)
        {
          // Copy the new domain of the halo elements from the flat
          // package to an easier to use container
          new_domains_halo_elements[iproc][i] =
            new_domains_halo_flat_unsigned[counter_new_domains_halo_ele++];
        }
      } // if (iproc != my_rank)
    } // for (iproc < nproc)

    // The time to get domains of halo elements
    if (Print_timings_level_load_balance > 1)
    {
      oomph_info << "CPU for getting domains halo elements (load balance) [1]: "
                 << TimingHelpers::timer() - tt_start_get_domains_halo_elements
                 << std::endl;
    }

    // =====================================================================
    // END: GET THE DOMAINS FOR THE HALO ELEMENTS
    // =====================================================================

    // =====================================================================
    // BEGIN: CREATE FINITE ELEMENT LOCAL VERSIONS OF THE HALO(ED)
    // ELEMENTS
    // =====================================================================

    // Get the time to get FiniteElement versions from Generalised
    // halo(ed) elements
    double tt_start_get_fe_version_from_ge_halo_ed = 0.0;
    if (Print_timings_level_load_balance > 1)
    {
      tt_start_get_fe_version_from_ge_halo_ed = TimingHelpers::timer();
    }

    // The finite element storage for the halo elements
    Vector<Vector<FiniteElement*>> f_halo_element_pt(nproc);
    // The finite element storage for the haloed elements
    Vector<Vector<FiniteElement*>> f_haloed_element_pt(nproc);
    // Loop over the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // There are no halo(ed) elements with myself
      if (iproc != my_rank)
      {
        // Get the number of halo elements with the "iproc" processor
        const unsigned nhalo_ele_iproc = this->nroot_halo_element(iproc);
        // Get the halo elements with the "iproc" processor
        Vector<GeneralisedElement*> halo_element_pt_iproc =
          this->root_halo_element_pt(iproc);
        // Resize the finite element container
        f_halo_element_pt[iproc].resize(nhalo_ele_iproc);
        // Loop over the halo elements
        for (unsigned ih = 0; ih < nhalo_ele_iproc; ih++)
        {
          // Get the finite element
          FiniteElement* ele_pt =
            dynamic_cast<FiniteElement*>(halo_element_pt_iproc[ih]);
          // Store the finite element version of the element
          f_halo_element_pt[iproc][ih] = ele_pt;
        } // for (ih < nhalo_ele_iproc)

        // Get the number of haloed elements with the "iproc" processor
        const unsigned nhaloed_ele_iproc = this->nroot_haloed_element(iproc);
        // Get the haloed elements with the "iproc" processor
        Vector<GeneralisedElement*> haloed_element_pt_iproc =
          this->root_haloed_element_pt(iproc);
        // Resize the finite element container
        f_haloed_element_pt[iproc].resize(nhaloed_ele_iproc);
        // Loop over the haloed elements
        for (unsigned ihd = 0; ihd < nhaloed_ele_iproc; ihd++)
        {
          // Get the finite element
          FiniteElement* ele_pt =
            dynamic_cast<FiniteElement*>(haloed_element_pt_iproc[ihd]);
          // Store the finite element version of the element
          f_haloed_element_pt[iproc][ihd] = ele_pt;
        } // for (ih < nhaloed_ele_iproc)

      } // if (iproc != my_rank)

    } // for (iproc < nproc)

    // The time to get FiniteElement versions from Generalised halo(ed)
    // elements
    if (Print_timings_level_load_balance > 1)
    {
      oomph_info << "CPU for getting finite element versions from generalised "
                    "halo(ed) elements (load balance) [2]: "
                 << TimingHelpers::timer() -
                      tt_start_get_fe_version_from_ge_halo_ed
                 << std::endl;
    }

    // =====================================================================
    // END: CREATE FINITE ELEMENT LOCAL VERSIONS OF THE HALO(ED)
    // ELEMENTS
    // =====================================================================

    // =====================================================================
    // BEGIN: 1) PREPARE THE ELEMENTS THAT WILL BE SENT TO OTHER PROCESSORS
    //        ---- HALO ELEMENTS ARE NOT CONSIDERED FOR SENDING
    //        2) ASSOCIATE THE NODES WITH THE NEW DOMAIN OF THE ELEMENTS
    //        ---- THE SAME IS PERFORMED FOR NODES IN HALO ELEMENTS
    // =====================================================================

    // Get the time to prepare elements to send to other processors
    double tt_start_prepare_element_to_send = 0.0;
    if (Print_timings_level_load_balance > 1)
    {
      tt_start_prepare_element_to_send = TimingHelpers::timer();
    }

    // Store the elements that will be sent to other processors
    Vector<Vector<FiniteElement*>> elements_to_send_pt(nproc);

    // Associate the nodes of each element with the processor the
    // element will live on
    std::map<Data*, std::set<unsigned>>
      processors_associated_with_data_before_load_balance;

    // Compute the elements that will be sent to other processor and
    // associate the nodes with the processor the element will live on
    unsigned nh_count3 = 0;
    for (unsigned e = 0; e < nelement_before_load_balance; e++)
    {
      // Get the element
      FiniteElement* ele_pt = this->finite_element_pt(e);
      // Only work with nonhalo elements
      if (!(ele_pt->is_halo()))
      {
        // Get the new domain for the elment
        const unsigned element_domain =
          target_domain_for_local_non_halo_element[nh_count3++];

        // Include the element in the corresponding vector
        elements_to_send_pt[element_domain].push_back(ele_pt);

        // Get the number of nodes on the element
        const unsigned n_nodes = ele_pt->nnode();
        // Loop over the nodes
        for (unsigned j = 0; j < n_nodes; j++)
        {
          // Get each node of the element
          Node* node_pt = ele_pt->node_pt(j);
          // ... and associate it with element domains
          processors_associated_with_data_before_load_balance[node_pt].insert(
            element_domain);

        } // for (j < n_nodes)

      } // if (!(ele_pt->is_halo()))

    } // for (e < nelement_before_load_balance)

    // ... do the same for the halo elements (but do not add them to the
    // sending container since only the processor with the haloed
    // counterparts is in charge of that). Associate the nodes of the
    // halo elements with the processor they will live on
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // There is no halo elements with myself
      if (iproc != my_rank)
      {
        // Get the number of halo elements with the "iproc" processor
        const unsigned n_halo_ele_iproc = this->nroot_halo_element(iproc);
        // Get the halo elements with the "iproc" processor
        Vector<GeneralisedElement*> halo_element_pt_iproc =
          this->root_halo_element_pt(iproc);
        // Loop over the halo elements with iproc
        for (unsigned ih = 0; ih < n_halo_ele_iproc; ih++)
        {
          // Get the new domain for the halo element
          const unsigned element_domain = new_domains_halo_elements[iproc][ih];

          // Get the finite element
          FiniteElement* ele_pt =
            dynamic_cast<FiniteElement*>(halo_element_pt_iproc[ih]);

          // Get the number of nodes on the halo element
          const unsigned n_nodes = ele_pt->nnode();
          // Loop over the nodes
          for (unsigned j = 0; j < n_nodes; j++)
          {
            // Get each node of the halo element
            Node* node_pt = ele_pt->node_pt(j);

            // ... and associate it with element domains
            processors_associated_with_data_before_load_balance[node_pt].insert(
              element_domain);

          } // for (j < n_nodes)

        } // for (ih < nhalo_ele_iproc)

      } // if (iproc != my_rank)

    } // for (iproc < nproc)

    // The time to prepare elements to send to other processors
    if (Print_timings_level_load_balance > 1)
    {
      oomph_info << "CPU for preparing elements to send to other processors "
                    "(load balance) [3]: "
                 << TimingHelpers::timer() - tt_start_prepare_element_to_send
                 << std::endl;
    }

    // Now all the nodes are associated with the processor where the
    // element will live on. This is performed for the nonhalo and halo
    // elements

    // =====================================================================
    // END: 1) PREPARE THE ELEMENTS THAT WILL BE SENT TO OTHER PROCESSORS
    //        ---- HALO ELEMENTS ARE NOT CONSIDERED FOR SENDING
    //        2) ASSOCIATE THE NODES WITH THE NEW DOMAIN OF THE ELEMENTS
    //        ---- THE SAME IS PERFORMED FOR NODES IN HALO ELEMENTS
    // =====================================================================

    // =====================================================================
    // BEGIN: COMPUTE THE NEW LOCAL HALO ELEMENTS OF ALL PROCESSORS IN THE
    //        CURRENT PROCESSOR
    //        ----- FOR NONHALO ELEMENTS AND FOR HALO ELEMENTS
    // =====================================================================

    // Get the time to compute new local halo elements within all
    // processors
    double tt_start_compute_new_local_halo_elements = 0.0;
    if (Print_timings_level_load_balance > 1)
    {
      tt_start_compute_new_local_halo_elements = TimingHelpers::timer();
    }

    // Before sending the elements across compute the new local
    // halo/haloed elements of each processor. Each processor could have
    // elements that will be part of the new halo/haloed elements of
    // another processors, then these processors need to compute the
    // relations that may happen among these other processors

    // Example:
    // Processor 1 may have elements that will be sent to processor 3
    // and 4. These processors need to know about the new halo elements
    // betweeen them but at this moment only processor 1 can compute that
    // info., since it is the only one that currently has that info.

    // Store the new local-halo elements of each processor, the HALOED
    // elements are also stored in the container, only needs to INVERT
    // the indexes. For example, the HALO elements of processor 2 with
    // processor 3 are stored in new_local_halo_element_pt[2][3], and
    // the HALOED elements of processor 2 with processor 3 are stored in
    // new_local_halo_element_pt[3][2]. Notice that these are also the
    // halo elements of processor 3 with 2

    // How to identify the new local halo/haloed element: 1) Loop over
    // the element; 2) Only work with nonhalo elements; 3) If the
    // element is not assigned to the current processor (iproc) then
    // check; 4) Is one of its nodes assiociated to the iproc processor?
    // 5) If yes the element is a halo in the iproc processor whose
    // nonhalo counter part (haloed) lives in the domain assigned to the
    // element
    Vector<Vector<Vector<FiniteElement*>>> new_local_halo_element_pt(nproc);

    // Loop over the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Resize the container
      new_local_halo_element_pt[iproc].resize(nproc);

      // Boolean to know which elements have been already added to the
      // new local halo scheme in "iproc"
      Vector<std::map<FiniteElement*, bool>> new_local_halo_already_added(
        nproc);

      // Go through all the elements and identify the new local halo
      // elements of "iproc"
      unsigned nh_count5 = 0;
      for (unsigned e = 0; e < nelement_before_load_balance; e++)
      {
        // Get the element
        FiniteElement* ele_pt = this->finite_element_pt(e);
        // Only work with nonhalo elements
        if (!(ele_pt->is_halo()))
        {
          // Get the domain to which the current element is associated
          const unsigned ele_domain =
            target_domain_for_local_non_halo_element[nh_count5++];
          // If the current element is not associated to the "iproc"
          // processor then it could be a halo element
          if (ele_domain != iproc)
          {
            // Get the number of nodes
            const unsigned nnodes = ele_pt->nnode();
            // Loop over the nodes
            for (unsigned j = 0; j < nnodes; j++)
            {
              Node* node_pt = ele_pt->node_pt(j);
              // Check if the node is associated with the current
              // "iproc" processor
              std::set<unsigned>::iterator it =
                processors_associated_with_data_before_load_balance[node_pt]
                  .find(iproc);
              // If it is found then the element is a halo-element
              if (it !=
                  processors_associated_with_data_before_load_balance[node_pt]
                    .end())
              {
                // Add the element as new local-halo element with the
                // "ele_domain" processor. The non-halo counterpart will
                // be located on "ele_domain" processor after sending
                // elements across
                if (!new_local_halo_already_added[ele_domain][ele_pt])
                {
                  // The element is a halo element on "iproc" with
                  // "ele_domain"
                  new_local_halo_element_pt[iproc][ele_domain].push_back(
                    ele_pt);
                  // Mark as done
                  new_local_halo_already_added[ele_domain][ele_pt] = true;
                } // if (!new_local_halo_already_added[ele_domain][ele_pt])
              } // One of the nodes lies on an element on the current
                // "iproc" processor
            } // for (j < nnodes)
          } // if (ele_domain != iproc)
        } // if (!(ele_pt->is_halo()))
      } // for (e < nelement_before_load_balance)

      // Now do the same with the halo elements, we need to find those
      // halo elements that continue being halo elements but possibly
      // with/on another processor. The pair of processors where a
      // possible shared boundary is created needs to be notified.

      // Example
      //
      // ---------------*        *---------------
      // |             |*        *|             |
      // |             |*        *|             |
      // |  New domain |*        *|  New domain |       * Mark the position
      // |    proc 1   |*        *|    proc 3   |         of halo elements
      // |             |*        *|             |
      // |             |*        *|             |
      // ---------------*        *---------------
      //     Proc 1                  Proc 2

      // Processor 1: The halo elements on processor 1 continue being halo ON
      // PROCESSOR 1, but now WITH PROCESSOR 3

      // Processor 2: The halo elements on processor 2 continue being
      // halo BUT now ON PROCESSOR 3 WITH PROCESSOR 1

      // The current processor (my_rank) also needs to consider the halo
      // elements that will be halo elements of other processor with
      // another processor. The case of processor 2

      // Loop over all the halo elements in the current processor and
      // check if they will be halo with the "iproc" processor
      for (unsigned jproc = 0; jproc < nproc; jproc++)
      {
        // There are no halo elements with myself (the old halo elements
        // were halo in the "my_rank" processor)
        if (jproc != my_rank)
        {
          // Get the number of halo elements with the "jproc" processor
          const unsigned n_halo_ele_jproc = this->nroot_halo_element(jproc);
          // Get the halo elements with the "jproc" processor
          Vector<GeneralisedElement*> halo_element_pt_jproc =
            this->root_halo_element_pt(jproc);
          // ... and check if any of those elements is a new halo
          // element with the "iproc" processor
          for (unsigned jh = 0; jh < n_halo_ele_jproc; jh++)
          {
            // Get the new domain for the halo element
            const unsigned ele_domain = new_domains_halo_elements[jproc][jh];

            // If the current element is not associated to the "iproc"
            // processor then it could be a halo element on "iproc" with
            // "ele_domain".

            // NOTE OUTDATE: Check if the halo element is going to be
            // sent to this processor (my_rank), if that is the case
            // then we don't need to add it to the set of new halo
            // elements with any other processor since any possible
            // shared boundary will be created when checking for the
            // intersection of the sent and received elements

            // if (ele_domain != iproc && ele_domain != my_rank)

            // NOTE UPDATE: Only check if the halo element is not going
            // to be part of the iproc processor, not required to avoid
            // those halo elements whose domain is the current rank
            // (my_rank). When the shared boundaries are computed, these
            // last elements can not create a shared boundary since no
            // haloed elements (that shared an edge) are found for
            // them. By considering also those halo elements whose new
            // domain is the current one (commenting "ele_domain !=
            // my_rank") the current processor can compute shared
            // boundaries with the iproc processor with help of its old
            // halo elements but that will become nonhalo elements, in
            // fact they will become haloed elements The halo element is
            // not sent to the "element_domain" processor and is not
            // passed to the array used to create the new shared
            // boundaries "new_shared_boundary_element_pt" because of
            // its halo condition
            if (ele_domain != iproc)
            {
              // Get the finite element
              FiniteElement* ele_pt =
                dynamic_cast<FiniteElement*>(halo_element_pt_jproc[jh]);
              // Get the number of nodes on the halo element
              const unsigned nnodes = ele_pt->nnode();
              // Loop over the nodes
              for (unsigned j = 0; j < nnodes; j++)
              {
                // Get each node of the halo element
                Node* node_pt = ele_pt->node_pt(j);

                // Check if the node is associated with the "iproc"
                // processor
                std::set<unsigned>::iterator it =
                  processors_associated_with_data_before_load_balance[node_pt]
                    .find(iproc);
                // If it is found then the element is a halo-element
                if (it !=
                    processors_associated_with_data_before_load_balance[node_pt]
                      .end())
                {
                  // Add the element as new local-halo element with
                  // the "ele_domain" processor. The non-halo
                  // counterpart will be located on "ele_domain"
                  // processor. Because this is a old-halo element it
                  // will not be sent to the "element_domain" processor
                  if (!new_local_halo_already_added[ele_domain][ele_pt])
                  {
                    // The element is a halo element on "iproc" with
                    // "ele_domain"
                    new_local_halo_element_pt[iproc][ele_domain].push_back(
                      ele_pt);
                    new_local_halo_already_added[ele_domain][ele_pt] = true;

                    // Break the for of the nodes, the element has been
                    // already added to the new_local_halo_element_pt
                    // structure
                    break;

                  } // if (!new_local_halo_already_added[ele_domain][ele_pt])

                } // One of the nodes lies on an element belonging to
                  // "iproc" processor

              } // for (j < nnodes)

            } // if (ele_domain != iproc)

          } // for (jh < n_halo_ele_jproc)

        } // if (jproc != my_rank) // The old halo elements are halo
          // with other processors except with "my_rank"

      } // for (jproc < nproc): This is the one that goes for the halo
        // elements in the current processor to find the new halo
        // elements

    } // for (iproc < nproc)

    // Get the time to compute new local halo elements within all
    // processors
    if (Print_timings_level_load_balance > 1)
    {
      oomph_info
        << "CPU for computing new local halo elements (load balance) [4]: "
        << TimingHelpers::timer() - tt_start_compute_new_local_halo_elements
        << std::endl;
    }

    // =====================================================================
    // END: COMPUTE THE NEW LOCAL HALO ELEMENTS OF ALL PROCESSORS IN THE
    //      CURRENT PROCESSOR
    //      ----- FOR NONHALO ELEMENTS AND FOR HALO ELEMENTS
    // =====================================================================

    // =====================================================================
    // BEGIN: COMPUTE THE NEW LOCAL SHARED BOUNDARY ELEMENTS AND THE
    // FACE ELEMENTS. THE SUBSET OF THE ELEMENTS TO SENT THAT ARE PART
    // OF THE NEW LOCAL SHARED BOUNDARY ELEMENTS ARE IDENTIFIED TO BE
    // MARKED AS HALOED ELEMENTS AND BELONGING TO THE SHARED BOUNDARY
    // ELEMENTS IN THE RECEIVED PROCESSOR
    // =====================================================================

    // Get the time to compute new local shared boundary elements
    double tt_start_compute_new_local_shd_bnd_ele = 0.0;
    if (Print_timings_level_load_balance > 1)
    {
      tt_start_compute_new_local_shd_bnd_ele = TimingHelpers::timer();
    }

    // Store the new local-shared boundary elements and the face indexes
    // The halo elements and halo face indexes
    Vector<Vector<Vector<FiniteElement*>>>
      new_local_halo_shared_boundary_element_pt(nproc);
    Vector<Vector<Vector<unsigned>>>
      new_local_halo_shared_boundary_element_face_index(nproc);

    // Allocate enough memory for the containers
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      new_local_halo_shared_boundary_element_pt[iproc].resize(nproc);
      new_local_halo_shared_boundary_element_face_index[iproc].resize(nproc);
    } // for (iproc < nproc)

    // Get the elements that create the new local-halo-shared
    // boundaries, mark them and identify the face that lies on the
    // shared boundary. The new local-halo-shared boundary elements are
    // actually a sub-set of the halo elements of each processor with in
    // each processor
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Star from jproc = iproc + 1 to avoid double creation of shared
      // boundary elements, any shared boundary element identified
      // between processor "iproc" and "jproc" is also established as
      // shared boundary element between processor "jproc" and "iproc"
      for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
      {
        this->get_shared_boundary_elements_and_face_indexes(
          new_local_halo_element_pt[iproc][jproc],
          new_local_halo_element_pt[jproc][iproc],
          new_local_halo_shared_boundary_element_pt[iproc][jproc],
          new_local_halo_shared_boundary_element_face_index[iproc][jproc],
          new_local_halo_shared_boundary_element_pt[jproc][iproc],
          new_local_halo_shared_boundary_element_face_index[jproc][iproc]);
      } // for (jproc < nproc)
    } // for (iproc < nproc)

    // The time to compute new local shared boundary elements
    if (Print_timings_level_load_balance > 1)
    {
      oomph_info << "CPU for computing new local shared boundary elements "
                    "(load balance) [5]: "
                 << TimingHelpers::timer() -
                      tt_start_compute_new_local_shd_bnd_ele
                 << std::endl;
    }

    // =====================================================================
    // END: COMPUTE THE NEW LOCAL SHARED BOUNDARY ELEMENTS AND THE FACE
    // ELEMENTS. THE SUBSET OF THE ELEMENTS TO SENT THAT ARE PART OF THE
    // NEW LOCAL SHARED BOUNDARY ELEMENTS ARE IDENTIFIED TO BE MARKED AS
    // HALOED ELEMENTS AND BELONGING TO THE SHARED BOUNDARY ELEMENTS IN
    // THE RECEIVED PROCESSOR
    // =====================================================================

    // =====================================================================
    // BEGIN: SEND THE ELEMENTS AND IDENTIFY THOSE THAT ARE PART OF THE
    // SHARED BOUNDARIES AND HALOED WITH OTHER PROCESSORS
    // =====================================================================

    // Get the time to send the elements to their new processor in
    // charge
    double tt_start_send_elements_to_other_processors = 0.0;
    if (Print_timings_level_load_balance > 1)
    {
      tt_start_send_elements_to_other_processors = TimingHelpers::timer();
    }

    // Sort the nodes on shared boundaries so that they have the same
    // order on all the shared boundaries, this is required to know the
    // possible shared nodes among processors
    this->sort_nodes_on_shared_boundaries();

    // Store the received elements from each processor
    Vector<Vector<FiniteElement*>> received_elements_pt(nproc);

    // The haloed elements and haloed face indexes, these store the
    // haloed elements received from "iproc" but that are haloed with
    // "jproc". The elements are received from "iproc" which was the
    // processor that computed the haloed relation of the "my_rank"
    // processor with "jproc"
    Vector<Vector<Vector<FiniteElement*>>>
      new_received_haloed_shared_boundary_element_pt(nproc);
    Vector<Vector<Vector<unsigned>>>
      new_received_haloed_shared_boundary_element_face_index(nproc);

    // Container where to store the nodes on shared boundaries not
    // associated with the processor that receives the elements/nodes
    // other_proc_shd_bnd_node_pt[iproc][jproc][shd_bnd_id][index]
    Vector<Vector<Vector<std::map<unsigned, Node*>>>>
      other_proc_shd_bnd_node_pt(nproc);
    // Resize the container
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Resize the container
      other_proc_shd_bnd_node_pt[iproc].resize(nproc);
      for (unsigned jproc = 0; jproc < nproc; jproc++)
      {
        // Get the number of shared boundaries (OLD shared boundaries)
        const unsigned initial_shd_bnd_id = this->initial_shared_boundary_id();
        const unsigned final_shd_bnd_id = this->final_shared_boundary_id();
        const unsigned n_shared_bound = final_shd_bnd_id - initial_shd_bnd_id;
        other_proc_shd_bnd_node_pt[iproc][jproc].resize(n_shared_bound);
      } // for (jproc < nproc)

    } // for (iproc < nproc)

    // Store the global node names
    // global_node_name[x][ ][ ] Global node number
    // global_node_name[ ][x][ ] Global node names
    // global_node_name[ ][ ][x] Global node info.
    Vector<Vector<Vector<unsigned>>> global_node_names;

    // Creates a map between the node name and the index of the global
    // node so we can access all its node names
    std::map<Vector<unsigned>, unsigned> node_name_to_global_index;

    // Store the global shared nodes pointers
    Vector<Node*> global_shared_node_pt;

    // Compute all the names of the nodes and fill in the
    // "other_proc_shd_bnd_node_pt" structure with the nodes that live
    // on this processor (my_rank) by looking over all their names
    compute_global_node_names_and_shared_nodes(other_proc_shd_bnd_node_pt,
                                               global_node_names,
                                               node_name_to_global_index,
                                               global_shared_node_pt);

    // From the elements received from each processor, store the haloed
    // information of the element, it means, the processor with which it
    // is haloed and the haloed index with that processor
    Vector<Vector<std::map<unsigned, FiniteElement*>>>
      received_old_haloed_element_pt(nproc);
    // [x][][] : The receiver processor (the original processor)
    // [][x][] : The processor with which the receiver processor has
    //           haloed elements
    // [][][x]: The haloed element number

    // Resize the container
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      received_old_haloed_element_pt[iproc].resize(nproc);
    } // for (iproc < nproc)

    // Go through all processors and send the corresponding elements to
    // each one
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      if (iproc != my_rank)
      {
        // -----------------------------------------------------------
        // Send (package) information of the elements
        // -----------------------------------------------------------

        // Keep track of the currently sent elements
        Vector<FiniteElement*> currently_sent_elements;
        // Keep track of the currently sent nodes to the iproc processor
        Vector<Node*> currently_sent_nodes;

        // Clear send and receive buffers
        Flat_packed_unsigneds.clear();
        Flat_packed_doubles.clear();
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        Flat_packed_unsigneds_string.clear();
#endif

        // Get the number of elements to send to iproc processor
        const unsigned nelements_to_send = elements_to_send_pt[iproc].size();

        // The very first data of the flat package sent to processor
        // iproc is the number of elements that will be sent, this data
        // is used by the receiver processor to loop over the number of
        // expected elements to receive
        Flat_packed_unsigneds.push_back(nelements_to_send);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk;
        junk << "Number of elements to send from processor " << my_rank
             << " to processor " << iproc << ": (" << nelements_to_send << ")";
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif

        // Loop over the elements to sent
        for (unsigned e = 0; e < nelements_to_send; e++)
        {
          // Get the element to send
          FiniteElement* send_ele_pt = elements_to_send_pt[iproc][e];

          // Get the current number of sent elements
          const unsigned ncurrently_sent_elements =
            currently_sent_elements.size();

          // Try to add the element
          const unsigned index_ele = try_to_add_element_pt_load_balance(
            currently_sent_elements, send_ele_pt);

          // Element needs to be added
          if (index_ele == ncurrently_sent_elements)
          {
            Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
            Flat_packed_unsigneds_string.push_back(
              "Element needs to be constructed");
#endif

            // Get required info. related with the element
            get_required_elemental_information_load_balance_helper(
              iproc, f_haloed_element_pt, send_ele_pt);

            // Get the number of nodes in the element
            const unsigned nnodes = send_ele_pt->nnode();

            // Loop over the nodes in the element
            for (unsigned j = 0; j < nnodes; j++)
            {
              Node* node_pt = send_ele_pt->node_pt(j);

              // Package the info. of the nodes
              add_node_load_balance_helper(iproc, // The destination process
                                           f_halo_element_pt,
                                           currently_sent_nodes,
                                           node_pt);

            } // for (j < nnodes)

          } // if (index_ele == ncurrently_sent_elements)
          else
          {
            Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
            Flat_packed_unsigneds_string.push_back("Element already exists");
#endif
            Flat_packed_unsigneds.push_back(index_ele);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
            Flat_packed_unsigneds_string.push_back("Index of existing element");
#endif
          } // else if (index_ele == ncurrently_sent_elements)

        } // for (e < nelements_to_send)

        // After storing the info. of the elements identify the indexes
        // of the "new_local_halo_shared_boundary_elements" in the
        // "currently_send_elements" vector, these elements will be
        // identified as "new_received_haloed_shared_boundary_elements"
        // on the "receiver" processor

        // Each processor has information of every other processor so we
        // need to send all the corresponding info. to the other
        // processors. Processor 1 may have information of the relation
        // (halo elements) between processor 3 and 4 say, so processor 1
        // needs to let know processor 3 and 4 what this relation is
        // (which are the shared-elements among these processors)

        for (unsigned jproc = 0; jproc < nproc; jproc++)
        {
          // Get the number of new local-halo shared boundary elements
          // between processor "jproc" and "iproc" (we invert the index
          // since we really want the haloed elements, those elements
          // that we have just sent)
          const unsigned njproc_iproc_new_local_halo_shared_boundary_ele =
            new_local_halo_shared_boundary_element_pt[jproc][iproc].size();

          // The vector with the info. of the indexes
          Vector<unsigned> new_local_halo_shared_boundary_ele_index;

          // The number of found shared boundary elements in the sent
          // container (only consider the nonhalo elements)
          unsigned nfound_new_local_halo_shared_bound_ele_index = 0;
          // The number of nonhalo elements in the new local halo shared
          // boundary elements
          unsigned nnon_halo_new_local_halo_shared_bound_ele = 0;

          // Loop over the local halo shared boundary elements between
          // processor jproc and iproc
          for (unsigned e = 0;
               e < njproc_iproc_new_local_halo_shared_boundary_ele;
               e++)
          {
            // Get the shared boundary element
            FiniteElement* shared_ele_pt =
              new_local_halo_shared_boundary_element_pt[jproc][iproc][e];

            // Only consider the nonhalo elements since the halo
            // elements were no considered for sending
            if (!shared_ele_pt->is_halo())
            {
              nnon_halo_new_local_halo_shared_bound_ele++;

              // Now find the index on the currently sent elements

              // Get the current number of sent elements
              const unsigned ncurrently_sent_elements =
                currently_sent_elements.size();
              // Loop over the sent elements
              for (unsigned ics = 0; ics < ncurrently_sent_elements; ics++)
              {
                FiniteElement* currently_sent_ele_pt =
                  currently_sent_elements[ics];

                // Is this the element?
                if (currently_sent_ele_pt == shared_ele_pt)
                {
                  // Store the index on the sent elements of the local
                  // halo shared boundary element
                  new_local_halo_shared_boundary_ele_index.push_back(ics);
                  // Increase the number of found new local halo shared
                  // bound element index
                  nfound_new_local_halo_shared_bound_ele_index++;
                  // We have found it, no need to further search
                  break;
                } // if (currently_sent_ele_pt == shared_ele_pt)

              } // for (ics < ncurrently_sent_elements)

            } // if (!shared_ele_pt->is_halo())

          } // for (e < niproc_new_local_halo_shared_boundary_ele)

#ifdef PARANOID
          if (nfound_new_local_halo_shared_bound_ele_index !=
              nnon_halo_new_local_halo_shared_bound_ele)
          {
            std::ostringstream error_message;
            error_message << "Was only possible to identify ("
                          << nfound_new_local_halo_shared_bound_ele_index
                          << ") of ("
                          << nnon_halo_new_local_halo_shared_bound_ele
                          << ") shared "
                          << "elements between\nprocessor (" << iproc
                          << ") and (" << jproc << ") "
                          << "when sending elements to processor (" << iproc
                          << ")\n\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }
#endif

          // Send a flag for synchronisation issues
          Flat_packed_unsigneds.push_back(9999);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
          std::stringstream junk;
          junk << "Flag for synchronisation 9999";
          Flat_packed_unsigneds_string.push_back(junk.str());
#endif

          // Send the number of nonhalo new local-shared boundary
          // elements of processor "iproc" with processor "jproc"
          Flat_packed_unsigneds.push_back(
            nnon_halo_new_local_halo_shared_bound_ele);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
          std::stringstream junk2;
          junk2 << "Number of new local halo shared boundary elements "
                << nnon_halo_new_local_halo_shared_bound_ele;
          Flat_packed_unsigneds_string.push_back(junk2.str());
#endif

          // Send the indexes and the face indexes of the shared
          // boundary elements
          unsigned counter_nonhalo_sent = 0;
          // Loop over the local halo shared boundary elements between
          // processor jproc and iproc
          for (unsigned e = 0;
               e < njproc_iproc_new_local_halo_shared_boundary_ele;
               e++)
          {
            // Get the shared boundary element
            FiniteElement* shared_ele_pt =
              new_local_halo_shared_boundary_element_pt[jproc][iproc][e];

            // Only consider the nonhalo elements since the halo
            // elements were no considered for sending
            if (!shared_ele_pt->is_halo())
            {
              // Get the index on the sent elements of the current
              // nonhalo shared boundary element
              const unsigned ele_index =
                new_local_halo_shared_boundary_ele_index
                  [counter_nonhalo_sent++];
              // ... and get the face index
              const unsigned face_index =
                new_local_halo_shared_boundary_element_face_index[jproc][iproc]
                                                                 [e];

              // Send the index on the sent elements of the new local
              // halo shared boundary element
              Flat_packed_unsigneds.push_back(ele_index);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
              std::stringstream junk;
              junk << "The index of the halo shared boundary element "
                   << ele_index;
              Flat_packed_unsigneds_string.push_back(junk.str());
#endif

              // Send the face index of the new local halo shared boundary
              // element
              Flat_packed_unsigneds.push_back(face_index);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
              std::stringstream junk2;
              junk2 << "The face index of the halo shared boundary element "
                    << face_index;
              Flat_packed_unsigneds_string.push_back(junk2.str());
#endif

            } // if (!shared_ele_pt->is_halo())

          } // for (e < niproc_new_local_halo_shared_boundary_ele)

        } // for (jproc < nproc)

        // ----------------------------------------------------------
        // Send the info. perform the communications
        // ----------------------------------------------------------
        // Processor to which send the info.
        int send_proc = static_cast<int>(iproc);
        // Processor from which receive the info.
        int recv_proc = static_cast<int>(iproc);
        send_and_receive_elements_nodes_info(send_proc, recv_proc);

        // ----------------------------------------------------------
        // Receive (unpackage) the info of the elements
        // ----------------------------------------------------------

        // Keep track of the currently created elements
        Vector<FiniteElement*> currently_created_elements;
        // Keep track of the currently created nodes
        Vector<Node*> currently_created_nodes;

        // Reset the counters
        Counter_for_flat_packed_doubles = 0;
        Counter_for_flat_packed_unsigneds = 0;

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << " Number of elements need to be constructed "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif

        // Read the number of elements that need to be created
        const unsigned nelements_to_create =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        for (unsigned e = 0; e < nelements_to_create; e++)
        {
          // Create the element from received info. of "iproc"
          // processor on the current processor
          create_element_load_balance_helper(iproc,
                                             f_haloed_element_pt,
                                             received_old_haloed_element_pt,
                                             currently_created_elements,
                                             currently_created_nodes,
                                             other_proc_shd_bnd_node_pt,
                                             global_node_names,
                                             node_name_to_global_index,
                                             global_shared_node_pt);
        }

        // Copy the received elements from "iproc" processor

        // Number of received elements
        const unsigned nreceived_elements = currently_created_elements.size();
        received_elements_pt[iproc].resize(nreceived_elements);
        for (unsigned e = 0; e < nreceived_elements; e++)
        {
          received_elements_pt[iproc][e] = currently_created_elements[e];
        }

        // Go for the haloed elements received from processor "iproc"
        // but haloed with "jproc"

        // Allocate memory for the containers
        new_received_haloed_shared_boundary_element_pt[iproc].resize(nproc);
        new_received_haloed_shared_boundary_element_face_index[iproc].resize(
          nproc);

        // Loop over the processors
        for (unsigned jproc = 0; jproc < nproc; jproc++)
        {
          // Read the synchronisation flag
          const unsigned synchronisation_flag =
            Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

          if (synchronisation_flag != 9999)
          {
            std::ostringstream error_message;
            error_message << "The synchronisation flag was not read, the\n"
                          << "information sent between processor (" << my_rank
                          << ") "
                          << "and (" << iproc
                          << ")\nis no longer synchronised\n\n";
            throw OomphLibError(error_message.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }

          // Read the number of elements that will be part of the new
          // received haloed shared boundary elements received from "iproc"
          // and haloed with "jproc"
          const unsigned niproc_jproc_new_received_haloed_shared_boundary_ele =
            Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

          // Loop over the new received haloed shared boundary elements
          for (unsigned e = 0;
               e < niproc_jproc_new_received_haloed_shared_boundary_ele;
               e++)
          {
            // Read the index of the new received haloed shared boundary
            // ele with "jproc"
            const unsigned ele_index =
              Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
            // Read the face index for the new received haloed shared
            // boundary element
            const unsigned face_index =
              Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

            // Get the element
            FiniteElement* shared_ele_pt =
              currently_created_elements[ele_index];

            // Add the element to the new received-haloed shared
            // boundary elements. Received from "iproc" but haloed with
            // "jproc" processor
            new_received_haloed_shared_boundary_element_pt[iproc][jproc]
              .push_back(shared_ele_pt);
            // Store the face index
            new_received_haloed_shared_boundary_element_face_index[iproc][jproc]
              .push_back(face_index);

          } // for (e < niproc_jproc_read_new_local_shared_boundary_ele)

        } // for (jproc < nproc)

      } // if (iproc != my_rank)

    } // for (iproc < nproc)

    // The time to send the elements to their new processor in charge
    if (Print_timings_level_load_balance > 1)
    {
      oomph_info << "CPU for sending elements to their new processors (load "
                    "balance) [6]: "
                 << TimingHelpers::timer() -
                      tt_start_send_elements_to_other_processors
                 << std::endl;
    }

    // =====================================================================
    // END: SEND THE ELEMENTS AND IDENTIFY THOSE THAT ARE PART OF THE
    // SHARED BOUNDARIES AND HALOED WITH OTHER PROCESSORS
    // =====================================================================

    // =====================================================================
    // BEGIN: GET ANY ADDITIONAL SHARED BOUNDARY BY THE INTERSECTION OF
    // THE ELEMENTS SENT TO PROCESSOR "IPROC" AND THE ELEMENTS RECEIVED
    // FROM PROCESSOR "IPROC". IF ANY NEW SHARED BOUNDARY IS FOUND, IT
    // IS CREATED BY THE OLD HALO ELEMENTS (RECEIVED ELEMENTS) THAT HAVE
    // NOW BECOME PART OF THE DOMAIN AND THE OLD HALOED ELEMENTS (SENT
    // ELEMENTS)
    // =====================================================================

    // Get the time to compute any additional shared boundary
    double tt_start_compute_additional_shared_boundaries = 0.0;
    if (Print_timings_level_load_balance > 1)
    {
      tt_start_compute_additional_shared_boundaries = TimingHelpers::timer();
    }

    // Store any additional elements that may create a shared boundary,
    // after sending elements from one to other processor check for any
    // new possible shared boundaries
    Vector<Vector<FiniteElement*>> tmp_group1_shared_boundary_element_pt(nproc);
    Vector<Vector<unsigned>> tmp_group1_shared_boundary_element_face_index(
      nproc);
    Vector<Vector<FiniteElement*>> tmp_group2_shared_boundary_element_pt(nproc);
    Vector<Vector<unsigned>> tmp_group2_shared_boundary_element_face_index(
      nproc);

    // Compute any additional shared boundaries by checking the
    // intersection between the received elements from each processor
    // and the elements just sent to that processor, the lowest
    // processors number loops over its received elements and the
    // highest loops over its sent elements (halo elements that have
    // become part of the domain now can create shared boundaries with
    // other processor)

    // Note: These additional shared boundaries may be created by the
    // elements that previously were halo but now have become part of
    // the processor (the received elements), and the elements that were
    // previously part of the processor but now have become halo (a
    // subset of the sent-elements)

    // Then these new shared boundaries come from the intersection of
    // the new-haloed elements (received elements) and the new-halo
    // elements (sent elements). These could be computed previously (in
    // the computing of the local new-halo and local new-haloed elements
    // usign the info. of the new domains for the old halo elements),
    // however, it was decided to perform the computation here in order to
    // avoid the identification of the old halo element that was part of a
    // shared boundary in the set of just received elements
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      if (my_rank < iproc)
      {
        // Lowest processor loops over the received elements
        this->get_shared_boundary_elements_and_face_indexes(
          received_elements_pt[iproc],
          elements_to_send_pt[iproc],
          tmp_group1_shared_boundary_element_pt[iproc],
          tmp_group1_shared_boundary_element_face_index[iproc],
          tmp_group2_shared_boundary_element_pt[iproc],
          tmp_group2_shared_boundary_element_face_index[iproc]);

      } // if (my_rank < iproc)
      else if (my_rank > iproc)
      {
        // Highest processor loops over the sent elements
        this->get_shared_boundary_elements_and_face_indexes(
          elements_to_send_pt[iproc],
          received_elements_pt[iproc],
          tmp_group1_shared_boundary_element_pt[iproc],
          tmp_group1_shared_boundary_element_face_index[iproc],
          tmp_group2_shared_boundary_element_pt[iproc],
          tmp_group2_shared_boundary_element_face_index[iproc]);

      } //  else if (my_rank > iproc)

    } // for (iproc < nproc)

    // The time to compute any additional shared boundary
    if (Print_timings_level_load_balance > 1)
    {
      oomph_info
        << "CPU for computing additional shared boundaries (load balance) [7]: "
        << TimingHelpers::timer() -
             tt_start_compute_additional_shared_boundaries
        << std::endl;
    }

    // =====================================================================
    // END: GET ANY ADDITIONAL SHARED BOUNDARY BY THE INTERSECTION OF
    // THE ELEMENTS SENT TO PROCESSOR "IPROC" AND THE ELEMENTS RECEIVED
    // FROM PROCESSOR "IPROC". IF ANY NEW SHARED BOUNDARY IS FOUND, IT
    // IS CREATED BY THE OLD HALO ELEMENTS (RECEIVED ELEMENTS) THAT HAVE
    // NOW BECOME PART OF THE DOMAIN AND THE OLD HALOED ELEMENTS (SENT
    // ELEMENTS)
    // =====================================================================

    // =====================================================================
    // BEGIN: SORT THE SHARED BOUNDARIES SO THAT THEY ARE CREATED IN THE
    // SAME ORDER IN THE INVOLVED PROCESSORS (A PAIR OF PROCESSORS)
    // =====================================================================

    // Get the time to sort shared boundaries
    double tt_start_sort_shared_boundaries = 0.0;
    if (Print_timings_level_load_balance > 1)
    {
      tt_start_sort_shared_boundaries = TimingHelpers::timer();
    }

    // Once computed the elements that create the shared boundaries,
    // sort them so that the shared boundaries are created at the same
    // order in both processors that define the shared boundary

    // The order is like this

    // Lowest processors
    // 1) Shared boundary elements received from processors (local in
    // other processors)
    // 2) Local shared boundary elements (do not include halo elements)
    // 3) Shared boundary elements by intersection (already sorted)

    // Highest processors
    // 1) Local shared boundary elements (do not include halo elements)
    // 2) Shared boundary elements received from processors (local in
    // other processors)
    // 3) Shared boundary elements by intersection (already sorted)

    Vector<Vector<FiniteElement*>> new_shared_boundary_element_pt(nproc);
    Vector<Vector<unsigned>> new_shared_boundary_element_face_index(nproc);
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Lower processor
      if (my_rank < iproc)
      {
        // Copy the elements received from processor "jproc" but that
        // are haloed with "iproc" processor
        for (unsigned jproc = 0; jproc < nproc; jproc++)
        {
          // Can not receive elements from itself
          if (jproc != my_rank)
          {
            // Get the number of elements to copy from received processors
            const unsigned nrecvd_haloed_shared_bound_ele_jproc_iproc =
              new_received_haloed_shared_boundary_element_pt[jproc][iproc]
                .size();
            for (unsigned e = 0; e < nrecvd_haloed_shared_bound_ele_jproc_iproc;
                 e++)
            {
              // Get the element
              FiniteElement* ele_pt =
                new_received_haloed_shared_boundary_element_pt[jproc][iproc][e];
              // Get the face index
              const unsigned face_index =
                new_received_haloed_shared_boundary_element_face_index[jproc]
                                                                      [iproc]
                                                                      [e];

              // Add the elements to the containers
              new_shared_boundary_element_pt[iproc].push_back(ele_pt);
              new_shared_boundary_element_face_index[iproc].push_back(
                face_index);

            } // for (e < nrecvd_haloed_shared_bound_ele_iproc_jproc)

          } // if (jproc != my_rank)

        } // for (jproc < nproc)

        // Then the local shared haloed (invert the indexes to get the
        // haloed elements)
        const unsigned nlocal_haloed_shared_bound_ele_iproc_my_rank =
          new_local_halo_shared_boundary_element_pt[iproc][my_rank].size();
        for (unsigned e = 0; e < nlocal_haloed_shared_bound_ele_iproc_my_rank;
             e++)
        {
          // Get the element
          FiniteElement* ele_pt =
            new_local_halo_shared_boundary_element_pt[iproc][my_rank][e];
          // Get the face index
          const unsigned face_index =
            new_local_halo_shared_boundary_element_face_index[iproc][my_rank]
                                                             [e];

          // Only include the element if it is nonhalo (this may be an
          // old halo element that helped to indentify a shared boundary
          // with iproc)
          if (!ele_pt->is_halo())
          {
            // Add the elements to the containers
            new_shared_boundary_element_pt[iproc].push_back(ele_pt);
            new_shared_boundary_element_face_index[iproc].push_back(face_index);
          } // if (!ele_pt->is_halo())

        } // for (e < nlocal_haloed_shared_bound_ele_iproc_my_rank)

        // ... and finally any additional shared boundary elements from
        // tmp_group1
        const unsigned ntmp_group1_shared_bound_ele_iproc =
          tmp_group1_shared_boundary_element_pt[iproc].size();
        for (unsigned e = 0; e < ntmp_group1_shared_bound_ele_iproc; e++)
        {
          // Get the element
          FiniteElement* ele_pt =
            tmp_group1_shared_boundary_element_pt[iproc][e];
          // Get the face index
          const unsigned face_index =
            tmp_group1_shared_boundary_element_face_index[iproc][e];

          // Add the elements to the containers
          new_shared_boundary_element_pt[iproc].push_back(ele_pt);
          new_shared_boundary_element_face_index[iproc].push_back(face_index);

        } // for (e < ntmp_group1_shared_bound_ele_iproc)

      } // if (my_rank < iproc)
      // Highest processor
      else if (my_rank > iproc)
      {
        // Get the haloed elements first and then the elements received
        // from processor "jproc" but that are haloed with "iproc"
        // processor

        // Get the number of elements to copy from local elements
        // (invert the indexes to get the haloed elements)
        const unsigned nlocal_haloed_shared_bound_ele_iproc_my_rank =
          new_local_halo_shared_boundary_element_pt[iproc][my_rank].size();
        for (unsigned e = 0; e < nlocal_haloed_shared_bound_ele_iproc_my_rank;
             e++)
        {
          // Get the element
          FiniteElement* ele_pt =
            new_local_halo_shared_boundary_element_pt[iproc][my_rank][e];
          // Get the face index
          const unsigned face_index =
            new_local_halo_shared_boundary_element_face_index[iproc][my_rank]
                                                             [e];

          // Only include the element if it is nonhalo (this may be an
          // old halo element that helped to indentify a shared boundary
          // with iproc)
          if (!ele_pt->is_halo())
          {
            // Add the elements to the containers
            new_shared_boundary_element_pt[iproc].push_back(ele_pt);
            new_shared_boundary_element_face_index[iproc].push_back(face_index);
          } // if (!ele_pt->is_halo())

        } // for (e < nlocal_haloed_shared_bound_ele_iproc_my_rank)

        for (unsigned jproc = 0; jproc < nproc; jproc++)
        {
          // Can not receive elements from itself
          if (jproc != my_rank)
          {
            // Then the received shared elements from "jproc" but haloed
            // with "iproc"
            const unsigned nrecvd_haloed_shared_bound_ele_jproc_iproc =
              new_received_haloed_shared_boundary_element_pt[jproc][iproc]
                .size();
            for (unsigned e = 0; e < nrecvd_haloed_shared_bound_ele_jproc_iproc;
                 e++)
            {
              // Get the element
              FiniteElement* ele_pt =
                new_received_haloed_shared_boundary_element_pt[jproc][iproc][e];
              // Get the face index
              const unsigned face_index =
                new_received_haloed_shared_boundary_element_face_index[jproc]
                                                                      [iproc]
                                                                      [e];

              // Add the elements to the containers
              new_shared_boundary_element_pt[iproc].push_back(ele_pt);
              new_shared_boundary_element_face_index[iproc].push_back(
                face_index);

            } // for (e < nrecvd_haloed_shared_bound_ele_iproc)

          } // if (jproc != my_rank)

        } // for (jproc < nproc)

        // ... and finally any additional shared boundary elements from
        // tmp_group2
        const unsigned ntmp_group2_shared_bound_ele_iproc =
          tmp_group2_shared_boundary_element_pt[iproc].size();
        for (unsigned e = 0; e < ntmp_group2_shared_bound_ele_iproc; e++)
        {
          // Get the element
          FiniteElement* ele_pt =
            tmp_group2_shared_boundary_element_pt[iproc][e];
          // Get the face index
          const unsigned face_index =
            tmp_group2_shared_boundary_element_face_index[iproc][e];

          // Add the elements to the containers
          new_shared_boundary_element_pt[iproc].push_back(ele_pt);
          new_shared_boundary_element_face_index[iproc].push_back(face_index);

        } // for (e < ntmp_group2_shared_bound_ele_iproc)

      } // else if (my_rank > iproc)

    } // for (iproc < nproc)

    // The time to sort shared boundaries
    if (Print_timings_level_load_balance > 1)
    {
      oomph_info << "CPU for sorting shared boundaries (load balance) [8]: "
                 << TimingHelpers::timer() - tt_start_sort_shared_boundaries
                 << std::endl;
    }

    // =====================================================================
    // END: SORT THE SHARED BOUNDARIES SO THAT THEY ARE CREATED IN THE
    // SAME ORDER IN THE INVOLVED PROCESSORS (A PAIR OF PROCESSORS)
    // =====================================================================

    // =====================================================================
    // BEGIN: CREATE THE NEW SHARED BOUNDARIES. BEFORE THE GENERATION OF
    // THE SHARED BOUNDARIES PUT IN A CONTAINER THOSE NONHALO ELEMENTS
    // THAT WILL REMAIN IN THE CURRENT PROCESSOR (BECAUSE THEIR RANK IS
    // THE SAME AS THE CURRENT PROCESSOR), AND THOSE ELEMENTS RECEIVED
    // FROM OTHER PROCESSORS. THESE SET OF ELEMENTS WILL BE USED TO
    // CHECK FOR POSSIBLE CONNECTIONS OF THE NEW SHARED BOUNDARIES WITH
    // THE ORIGINAL BOUNDARIES
    // =====================================================================
    // Finally, create the new shared boundaries

    // Get the time to create the new shared boundaries
    double tt_start_create_new_shared_boundaries = 0.0;
    if (Print_timings_level_load_balance > 1)
    {
      tt_start_create_new_shared_boundaries = TimingHelpers::timer();
    }

    // Compute the elements that will remain after deletion in the
    // curent processor. This is required to check if the new shared
    // boundaries crete a connection with any node of the elements in
    // the boundaries

    // Try to use as much information as possible

    // Storage for the elements in the processor
    std::set<FiniteElement*> element_in_processor_pt;

    // Loop over the old elements, those before sending/received
    // elements to/from other processors
    unsigned nh_count6 = 0;
    for (unsigned e = 0; e < nelement_before_load_balance; e++)
    {
      // Get the element
      FiniteElement* ele_pt = backed_up_ele_pt[e];
      // Only work with nonhalo elements
      if (!(ele_pt->is_halo()))
      {
        // Is the element part of the new domain
        if (target_domain_for_local_non_halo_element[nh_count6++] == my_rank)
        {
          // Add the element to the set of elements in the processor
          element_in_processor_pt.insert(ele_pt);
        }

      } // if (!(ele_pt->is_halo()))

    } // for (e < nelement_before_load_balance)

    // Now include the received elements from the other processors
    // Loop over the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // No elements received from myself
      if (iproc != my_rank)
      {
        // Get the number of received elements with the "iproc"
        // processor
        const unsigned n_received_ele = received_elements_pt[iproc].size();
        for (unsigned ie = 0; ie < n_received_ele; ie++)
        {
          // Get the ie-th received element from processor iproc
          FiniteElement* ele_pt = received_elements_pt[iproc][ie];

          // Include it in the set of elements in the processor
          element_in_processor_pt.insert(ele_pt);

        } // for (ie < nreceived_ele)

      } // if (iproc != my_rank)

    } // for (iproc < nproc)

    // Now create the shared boundaries
    create_new_shared_boundaries(element_in_processor_pt,
                                 new_shared_boundary_element_pt,
                                 new_shared_boundary_element_face_index);

    // The time to create the new shared boundaries
    if (Print_timings_level_load_balance > 1)
    {
      oomph_info
        << "CPU for creating new shared boundaries (load balance) [9]: "
        << TimingHelpers::timer() - tt_start_create_new_shared_boundaries
        << std::endl;
    }

    // =====================================================================
    // END: CREATE THE NEW SHARED BOUNDARIES. BEFORE THE GENERATION OF
    // THE SHARED BOUNDARIES PUT IN A CONTAINER THOSE NONHALO ELEMENTS
    // THAT WILL REMAIN IN THE CURRENT PROCESSOR (BECAUSE THEIR RANK IS
    // THE SAME AS THE CURRENT PROCESSOR), AND THOSE ELEMENTS RECEIVED
    // FROM OTHER PROCESSORS. THESE SET OF ELEMENTS WILL BE USED TO
    // CHECK FOR POSSIBLE CONNECTIONS OF THE NEW SHARED BOUNDARIES WITH
    // THE ORIGINAL BOUNDARIES
    // =====================================================================

    // =====================================================================
    // BEGIN: DELETE THE ELEMENTS NO LONGER BELONGING TO THE DOMAIN,
    // INCLUDING HALO ELEMENTS. ADD THE KEPT ELEMENTS TO THE MESH AND
    // THE RECEIVED ELEMENTS FROM OTHER PROCESSORS
    // =====================================================================

    // Get the time to delete elements no longer belonging to the
    // processor
    double tt_start_delete_elements = 0.0;
    if (Print_timings_level_load_balance > 1)
    {
      tt_start_delete_elements = TimingHelpers::timer();
    }

    // Once computed the new shared boundaries delete the elements that
    // no longer belong to the processor (including the old halo
    // elements)

    // The procedure is similar to the one performed at the distribution
    // stage (src/generic/mesh.cc -- distribute() method)

    // Clean the storage for halo(ed) elements/nodes
    this->Halo_node_pt.clear();
    this->Root_halo_element_pt.clear();

    this->Haloed_node_pt.clear();
    this->Root_haloed_element_pt.clear();

    // Mark all the nodes as obsolete
    const unsigned nnodes = this->nnode();
    for (unsigned j = 0; j < nnodes; j++)
    {
      this->node_pt(j)->set_obsolete();
    }

    // Flush the mesh storage
    this->flush_element_storage();

    // Delete any storage of external elements and nodes
    this->delete_all_external_storage();

    // Clear external storage
    this->External_halo_node_pt.clear();
    this->External_halo_element_pt.clear();

    this->External_haloed_node_pt.clear();
    this->External_haloed_element_pt.clear();

    // Keep track of the deleted elements
    Vector<FiniteElement*> deleted_elements;

    // Delete the elements that no longer belong to the processor
    unsigned nh_count7 = 0;
    for (unsigned e = 0; e < nelement_before_load_balance; e++)
    {
      FiniteElement* ele_pt = backed_up_ele_pt[e];
      // Only work with nonhalo elements
      if (!(ele_pt->is_halo()))
      {
        if (target_domain_for_local_non_halo_element[nh_count7++] == my_rank)
        {
          // Add the element to the mesh
          this->add_element_pt(ele_pt);
          // Get the number of nodes on the element
          const unsigned nele_nodes = ele_pt->nnode();
          // Loop over the nodes of the element
          for (unsigned j = 0; j < nele_nodes; j++)
          {
            // Mark the node as non-obsolete
            ele_pt->node_pt(j)->set_non_obsolete();
          } // for (j < nele_nodes)

        } // The element belongs to the domain
        else
        {
          // Delete the element, but keep track of it
          deleted_elements.push_back(ele_pt);
          // Delete and point to null
          delete ele_pt;
          ele_pt = 0;
        }

      } // if (!(ele_pt->is_halo()))
      else
      {
        // If the element is halo, delete if but keep track of it
        deleted_elements.push_back(ele_pt);
        // Delete and point to null
        delete ele_pt;
        ele_pt = 0;
      }

    } // for (e < nelement_before_load_balance)

    // Now add the received elements from each processor
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      if (iproc != my_rank)
      {
        // Get the number of received elements with the "iproc"
        // processor
        const unsigned nreceived_ele = received_elements_pt[iproc].size();
        for (unsigned ie = 0; ie < nreceived_ele; ie++)
        {
          // Get the element and add it to the mesh
          FiniteElement* ele_pt = received_elements_pt[iproc][ie];
          // Add the element to the mesh
          this->add_element_pt(ele_pt);
          // Get the number of nodes on the element
          const unsigned nele_nodes = ele_pt->nnode();
          // Loop over the nodes of the element
          for (unsigned j = 0; j < nele_nodes; j++)
          {
            // Mark the node as non-obsolete
            ele_pt->node_pt(j)->set_non_obsolete();
          } // for (j < nele_nodes)

        } // for (ie < nreceived_ele)

      } // if (iproc != my_rank)

    } // for (iproc < nproc)

    // Now remove the obsolete nodes
    this->prune_dead_nodes();

    // The time to delete elements no longer belonging to the processor
    if (Print_timings_level_load_balance > 1)
    {
      oomph_info << "CPU for deleting elements no longer belonging to this "
                    "processor (load balance) [10]: "
                 << TimingHelpers::timer() - tt_start_delete_elements
                 << std::endl;
    }

    // =====================================================================
    // END: DELETE THE ELEMENTS NO LONGER BELONGING TO THE DOMAIN,
    // INCLUDING HALO ELEMENTS. ADD THE KEPT ELEMENTS TO THE MESH AND
    // THE RECEIVED ELEMENTS FROM OTHER PROCESSORS
    // =====================================================================

    // =====================================================================
    // BEGIN: REESTABLISH THE HALO(ED) SCHEME, ATTACH HALO ELEMENTS
    // (HALO NODES INCLUDED) TO THE NEW MESH (AFTER LOAD BALANCING)
    // RESTORE THE BOUNDARY ELEMENTS SCHEME AND THE NUMBER OF SEGMENTS
    // ON EACH BOUNDARY
    // =====================================================================

    // Get the time to re-establish the halo(ed) information
    double tt_start_re_etablish_halo_ed_info = 0.0;
    if (Print_timings_level_load_balance > 1)
    {
      tt_start_re_etablish_halo_ed_info = TimingHelpers::timer();
    }

    // Prepare the data to re-establish the halo(ed) scheme

    // Sort the nodes on the new shared boundaries so that they have the
    // same order on all processors
    this->sort_nodes_on_shared_boundaries();

    // Before re-establish the halo and haloed elements save the number
    // of current elements in the boundaries, this will be useful to
    // re-establish the boundary elements. Notice that there may be
    // boundary elements with null pointers, since the element may no
    // longer belong to the current processor
    const unsigned tmp_nboundary = this->nboundary();
    Vector<unsigned> ntmp_boundary_elements(tmp_nboundary);

    // If there are regions, save the number of boundary-region elements
    Vector<Vector<unsigned>> ntmp_boundary_elements_in_region(tmp_nboundary);
    // Are there regions?
    const unsigned n_regions = this->nregion();

    // Loop over the boundaries
    for (unsigned ib = 0; ib < tmp_nboundary; ib++)
    {
      // Get the number of boundary elements
      ntmp_boundary_elements[ib] = this->nboundary_element(ib);

      // Resize the container
      ntmp_boundary_elements_in_region[ib].resize(n_regions);

      // Loop over the regions
      for (unsigned rr = 0; rr < n_regions; rr++)
      {
        // Get the region id
        const unsigned region_id =
          static_cast<unsigned>(this->region_attribute(rr));

        // Store the number of element in the region (notice we are
        // using the region index not the region id to refer to the
        // region)
        ntmp_boundary_elements_in_region[ib][rr] =
          this->nboundary_element_in_region(ib, region_id);

      } // for (rr < n_regions)

    } // for (ib < tmp_nboundary)

    // Re-establish the halo(ed) scheme
    this->reset_halo_haloed_scheme();

    // Get the number of elements in the mesh after load balance
    const unsigned nelement_after_load_balance = this->nelement();

    // We need to reset boundary elements because we need to get rid of
    // the old boundary elements and stay only with the new ones
    this->reset_boundary_element_info(ntmp_boundary_elements,
                                      ntmp_boundary_elements_in_region,
                                      deleted_elements);

    // There is no need to re-set boundary coordinates since the
    // load-balanced mesh already has the correct information (the
    // boundary coordinate for each node was sent with the node
    // information)

    // We need to re-compute the number of segments on each boundary
    // after load balance. It may be possible that the boundary is now
    // split in more segments, or that previous gaps between the
    // segments have now dissapeared because the received elements
    // filled those gaps

    // In order to re-set the number of segments it is required to get
    // the face elements, attach them to create a contiguous
    // representation of the boundary (in segments possibly) and then
    // counter the number of segments. This can only be done after
    // restoring the boundary elements scheme (which has been done
    // above)

    // Set the number of segments for the boundaries with geom objects
    // associated. The correct value is not on the original mesh since
    // it is computed only when calling then
    // setup_boundary_coordinates() method (called only for those
    // boundaries with no geom object associated)
    for (unsigned b = 0; b < tmp_nboundary; b++)
    {
      if (this->boundary_geom_object_pt(b) != 0)
      {
        // Clear the boundary segment nodes storage
        this->flush_boundary_segment_node(b);

        // Dummy vector of nodes on segments
        Vector<Vector<Node*>> dummy_segment_node_pt;

        // Compute the new number of segments in the boundary
        get_boundary_segment_nodes_helper(b, dummy_segment_node_pt);

        // Get the number of segments from the vector of nodes
        const unsigned nsegments = dummy_segment_node_pt.size();

        // Set the number of segments for the storing of the nodes
        // associated to the segments
        this->set_nboundary_segment_node(b, nsegments);
      } // if (this->boundary_geom_object_pt(b)!=0)

    } // for (b < n_boundary)

    // The time to re-establish the halo(ed) information
    if (Print_timings_level_load_balance > 1)
    {
      oomph_info
        << "CPU for re-establishing halo(ed) information (load balance) [11]: "
        << TimingHelpers::timer() - tt_start_re_etablish_halo_ed_info
        << std::endl;
    }

    // =====================================================================
    // END: REESTABLISH THE HALO(ED) SCHEME, ATTACH HALO ELEMENTS (HALO
    // NODES INCLUDED) TO THE NEW MESH (AFTER LOAD BALANCING) RESTORE
    // THE BOUNDARY ELEMENTS SCHEME AND THE NUMBER OF SEGMENTS ON EACH
    // BOUNDARY
    // =====================================================================

    if (Print_timings_level_load_balance > 1)
    {
      oomph_info << "CPU for load balance [n_ele_before="
                 << nelement_before_load_balance
                 << ", n_ele_after=" << nelement_after_load_balance << "]: "
                 << TimingHelpers::timer() - t_start_overall_load_balance
                 << std::endl;
    }

    oomph_info << "Load balance (unstructured mesh) [END]" << std::endl;
  }

  //======================================================================
  /// Use the first and second group of elements to find the
  /// intersection between them to get the shared boundary
  /// elements from the first and second group
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::
    get_shared_boundary_elements_and_face_indexes(
      const Vector<FiniteElement*>& first_element_pt,
      const Vector<FiniteElement*>& second_element_pt,
      Vector<FiniteElement*>& first_shared_boundary_element_pt,
      Vector<unsigned>& first_shared_boundary_element_face_index,
      Vector<FiniteElement*>& second_shared_boundary_element_pt,
      Vector<unsigned>& second_shared_boundary_element_face_index)
  {
    // 1) Compare their faces (nodes) and if they match then they are
    //    part of a shared boundary
    // 2) Save the first and second group of elements that give rise to
    //    the shared boundary, also include the face index

    // Get the number of elements on the first group
    const unsigned nfirst_element = first_element_pt.size();
    // Loop over the elements in the first group
    for (unsigned ef = 0; ef < nfirst_element; ef++)
    {
      // Get the element
      FiniteElement* fele_pt = first_element_pt[ef];
      // Check if the element is halo
      bool first_ele_is_halo = false;
      if (fele_pt->is_halo())
      {
        first_ele_is_halo = true;
      }
      // Get each of the faces
      for (unsigned ifface = 0; ifface < 3; ifface++)
      {
        Vector<Node*> first_face(2);
        if (ifface == 0)
        {
          first_face[0] = fele_pt->node_pt(1);
          first_face[1] = fele_pt->node_pt(2);
        }
        else if (ifface == 1)
        {
          first_face[0] = fele_pt->node_pt(2);
          first_face[1] = fele_pt->node_pt(0);
        }
        else if (ifface == 2)
        {
          first_face[0] = fele_pt->node_pt(0);
          first_face[1] = fele_pt->node_pt(1);
        }

        // Now check each of the faces with the faces on the second
        // elements

        // Get the number of elements on the second group
        const unsigned nsecond_element = second_element_pt.size();
        // Loop over the elements in the second group
        for (unsigned es = 0; es < nsecond_element; es++)
        {
          // Get the element
          FiniteElement* sele_pt = second_element_pt[es];
          // Check if the element is halo
          bool second_ele_is_halo = false;
          if (sele_pt->is_halo())
          {
            second_ele_is_halo = true;
          }
          // Now check whether both elements are halo, if that is the
          // case then we go for the next elements. We can not look for
          // shared boundaries between halo elements since other
          // processors, those with the nonhalo counterpart of the
          // elements, are in charge of creating those shared boundaries
          if (!(first_ele_is_halo && second_ele_is_halo))
          {
            // Get each of the faces
            for (unsigned isface = 0; isface < 3; isface++)
            {
              Vector<Node*> second_face(2);
              if (isface == 0)
              {
                second_face[0] = sele_pt->node_pt(1);
                second_face[1] = sele_pt->node_pt(2);
              }
              else if (isface == 1)
              {
                second_face[0] = sele_pt->node_pt(2);
                second_face[1] = sele_pt->node_pt(0);
              }
              else if (isface == 2)
              {
                second_face[0] = sele_pt->node_pt(0);
                second_face[1] = sele_pt->node_pt(1);
              }

              // Now check for any intersection among first and second
              // faces
              if (first_face[0] == second_face[0] &&
                  first_face[1] == second_face[1])
              {
                // Save the elements on the corresponding containers
                first_shared_boundary_element_pt.push_back(fele_pt);
                // .. and the face index
                first_shared_boundary_element_face_index.push_back(ifface);

                // Save the elements on the corresponding containers
                second_shared_boundary_element_pt.push_back(sele_pt);
                // .. and the face index
                second_shared_boundary_element_face_index.push_back(isface);

                // Break the loop over the faces of the first elements
                // and the first elements, we need to continue looking
                // on the next face of the first elements

                // Increase the indexes to force breaking the loop
                isface = 3;
                es = nsecond_element;
              }
              // Check for intersection with the reversed case too
              else if (first_face[0] == second_face[1] &&
                       first_face[1] == second_face[0])
              {
                // Save the elements on the corresponding containers
                first_shared_boundary_element_pt.push_back(fele_pt);
                // .. and the face index
                first_shared_boundary_element_face_index.push_back(ifface);

                // Save the elements on the corresponding containers
                second_shared_boundary_element_pt.push_back(sele_pt);
                // .. and the face index
                second_shared_boundary_element_face_index.push_back(isface);

                // Break the loop over the faces of the first elements
                // and the first elements, we need to continue looking
                // on the next face of the first elements

                // Increase the indexes to force breaking the loop
                isface = 3;
                es = nsecond_element;
              }

            } // for (isface < 3)

          } // if (!(first_ele_is_halo && second_ele_is_halo))

        } // for (es < nsecond_element)

      } // for (ifface < 3)

    } // for (ef < nfirst_element)
  }

  //======================================================================
  /// Creates the new shared boundaries, this method is also in
  /// charge of computing the shared boundaries ids of each processor
  /// and send that info. to all the processors
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::create_new_shared_boundaries(
    std::set<FiniteElement*>& element_in_processor_pt,
    Vector<Vector<FiniteElement*>>& new_shared_boundary_element_pt,
    Vector<Vector<unsigned>>& new_shared_boundary_element_face_index)
  {
    // Get the number of processors
    const unsigned nproc = this->communicator_pt()->nproc();
    // Get the rank of the current processor
    const unsigned my_rank = this->communicator_pt()->my_rank();

    // ================================================================
    // BEGIN: GET THE SHARED BOUNDARY FACE ELEMENTS FROM THE SHARED
    // BOUNDARY ELEMENTS, AND ASSIGN A ROOT EDGE TO EACH FACE
    // ELEMENT. AVOID THE CREATION OF FACE ELEMENTS THAT REPRESENT THE
    // SAME EDGE (INTERNAL BOUNDARIES)
    // ================================================================

    // Get the time to get edges from shared boundary face elements
    double tt_start_get_edges_from_shd_bnd_face_ele = 0.0;
    if (Print_timings_level_load_balance > 2)
    {
      tt_start_get_edges_from_shd_bnd_face_ele = TimingHelpers::timer();
    }

    // Face elements that create the shared boundaries (unsorted)
    Vector<Vector<FiniteElement*>> tmp_unsorted_face_ele_pt(nproc);
    // The elements from where the face element was created
    Vector<Vector<FiniteElement*>> tmp_unsorted_ele_pt(nproc);
    // The face index of the bulk element from where was created the
    // face element
    Vector<Vector<int>> tmp_unsorted_face_index_ele(nproc);

    // Store the current edges lying on boundaries (this will help for
    // any edge of a shared boundary lying on an internal boundary)
    std::map<std::pair<Node*, Node*>, unsigned> elements_edges_on_boundary;

    // Compute the edges on the other boundaries
    this->get_element_edges_on_boundary(elements_edges_on_boundary);

    // Mark those edges (pair of nodes overlapped by a shared boundary)
    std::map<std::pair<Node*, Node*>, bool> overlapped_edge;

    // Associate every found edge (face element) on the shared boundary
    // with an original boundary only if the edge (face element) lies
    // (overlaps) on an original boundary, it may happen only for
    // internal boundaries
    Vector<Vector<int>> tmp_edge_boundary(nproc);

    // Get the face elements from the shared boundary elements with in
    // each processor
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // There are no shared boundary elements with myself
      if (iproc != my_rank)
      {
        // Get the number of shared boundary elements with in "iproc"
        // processor
        const unsigned n_shared_bound_ele =
          new_shared_boundary_element_pt[iproc].size();

        // Avoid to create repeated face elements, compare the nodes on
        // the edges of the face elements
        Vector<std::pair<Node*, Node*>> done_faces;

        // Count the number of repeated faces
        unsigned nrepeated_faces = 0;

        // Loop over the shared boundary elements with the iproc
        // processor
        for (unsigned iele = 0; iele < n_shared_bound_ele; iele++)
        {
          // Get the bulk element
          FiniteElement* bulk_ele_pt =
            new_shared_boundary_element_pt[iproc][iele];

          // Get the face index
          int face_index = static_cast<int>(
            new_shared_boundary_element_face_index[iproc][iele]);

          // Create the face element
          FiniteElement* tmp_ele_pt =
            new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);

          // Before adding the face element to the vector check that is
          // not has been previously created
          bool done_face = false;

          // Get the number of nodes on the face element and get the first
          // and last node
          const unsigned nnode_face_ele = tmp_ele_pt->nnode();
          Node* first_face_node_pt = tmp_ele_pt->node_pt(0);
          Node* last_face_node_pt = tmp_ele_pt->node_pt(nnode_face_ele - 1);

          // Get the number of already done face elements
          const unsigned ndone_faces = done_faces.size();
          // Loop over the already visited face elements
          for (unsigned n = 0; n < ndone_faces; n++)
          {
            Node* first_done_face_node_pt = done_faces[n].first;
            Node* second_done_face_node_pt = done_faces[n].second;
            if (first_face_node_pt == first_done_face_node_pt &&
                last_face_node_pt == second_done_face_node_pt)
            {
              done_face = true;
              nrepeated_faces++;
              break;
            }
            // Check for the reversed case
            else if (first_face_node_pt == second_done_face_node_pt &&
                     last_face_node_pt == first_done_face_node_pt)
            {
              done_face = true;
              nrepeated_faces++;
              break;
            }

          } // for (n < ndone_faces)

          // Only include the faces that are not repeated
          if (!done_face)
          {
            // Add the face element in the vector
            tmp_unsorted_face_ele_pt[iproc].push_back(tmp_ele_pt);
            // Add the bulk element to the vector
            tmp_unsorted_ele_pt[iproc].push_back(bulk_ele_pt);
            // Add the face index to the vector
            tmp_unsorted_face_index_ele[iproc].push_back(face_index);
            // Include the nodes in the done nodes vector
            std::pair<Node*, Node*> tmp_edge =
              std::make_pair(first_face_node_pt, last_face_node_pt);
            // Push the edge
            done_faces.push_back(tmp_edge);

            // Associate the face element with a boundary (if that is
            // the case)
            int edge_boundary_id = -1;
            std::map<std::pair<Node*, Node*>, unsigned>::iterator it;
            it = elements_edges_on_boundary.find(tmp_edge);
            // If the edges lie on a boundary then get the boundary id
            // on which the edges lie
            if (it != elements_edges_on_boundary.end())
            {
              // Assign the internal boundary id associated with the
              // edge
              edge_boundary_id = (*it).second;
              // Mark the edge as overlapped
              overlapped_edge[tmp_edge] = true;
              // Also include the reversed version of the edge
              std::pair<Node*, Node*> rev_tmp_edge =
                std::make_pair(last_face_node_pt, first_face_node_pt);
              // Mark the reversed version of the edge as overlapped
              overlapped_edge[rev_tmp_edge] = true;
            }
            else
            {
              // Look for the reversed version
              std::pair<Node*, Node*> rtmp_edge =
                std::make_pair(last_face_node_pt, first_face_node_pt);
              it = elements_edges_on_boundary.find(rtmp_edge);
              if (it != elements_edges_on_boundary.end())
              {
                // Assign the internal boundary id associated with the
                // edge
                edge_boundary_id = (*it).second;
                // Mark the edge as overlapped
                overlapped_edge[rtmp_edge] = true;
                // Mark the reversed version (normal) of the edge as
                // overlapped
                overlapped_edge[tmp_edge] = true;
              }
            }
            // Associate the edge with a boundary
            tmp_edge_boundary[iproc].push_back(edge_boundary_id);
          } // if (!done_face)
          else
          {
            // Delete the repeated face elements
            delete tmp_ele_pt;
            tmp_ele_pt = 0;
          }

        } // for (iele < n_shared_bound_ele)

      } // if (iproc != my_rank)

    } // for (iproc < nproc)

    // The time to get edges from shared boundary face elements
    if (Print_timings_level_load_balance > 2)
    {
      oomph_info << "CPU for getting edges from shared boundary face elements "
                    "(load balance) [9.1]: "
                 << TimingHelpers::timer() -
                      tt_start_get_edges_from_shd_bnd_face_ele
                 << std::endl;
    }

    // ================================================================
    // END: GET THE SHARED BOUNDARY FACE ELEMENTS FROM THE SHARED
    // BOUNDARY ELEMENTS, AND ASSIGN A ROOT EDGE TO EACH FACE
    // ELEMENT. AVOID THE CREATION OF FACE ELEMENTS THAT REPRESENT THE
    // SAME EDGE (INTERNAL BOUNDARIES)
    // ================================================================

    // ================================================================
    // BEGIN: BEFORE SORTING THE SHARED FACE ELEMENTS AND ITS ASSOCIATED
    // DATA, WE NEED TO ENSURE THAT THEY APPEAR (OR ARE STORED) IN THE
    // SAME ORDER IN BOTH OF THE PROCESSORS THAT CREATED THEM. WE USE
    // THE BOTTOM-LEFT NODE OF EACH FACE ELEMENT TO STORE THEM IN THE
    // SAME ORDER IN BOTH PROCESSORS. ALSO ENSURE THAT THE FACE ELEMENTS
    // AGREE WITH THE FIRST AND LAST NODE IN ALL PROCESSORS
    // ================================================================

    // Get the time to sort shared face elements
    double tt_start_sort_shared_face_elements = 0.0;
    if (Print_timings_level_load_balance > 2)
    {
      tt_start_sort_shared_face_elements = TimingHelpers::timer();
    }

    // -----------------------------------------------------------------
    // Before continuing we need to ensured that the face elements are
    // stored in the same order in all processors. Sort them starting
    // from the face element with the bottom-left node coordinate

    // Face elements that create the shared boundaries (unsorted)
    Vector<Vector<FiniteElement*>> unsorted_face_ele_pt(nproc);
    // The elements from where the face element was created
    Vector<Vector<FiniteElement*>> unsorted_ele_pt(nproc);
    // The face index of the bulk element from where was created the
    // face element
    Vector<Vector<int>> unsorted_face_index_ele(nproc);
    // Associate every found edge on the shared boundary with an
    // original boundary only if the edge lies on an original boundary,
    // it may happen only for internal boundaries
    Vector<Vector<int>> edge_boundary(nproc);

    // For each face element, mark if the element should be considered
    // in its inverted way to fullfill with the bottom-left node to be
    // the first (left) node. First get the status of each element and
    // when they get sorted copy the values across
    std::vector<std::vector<bool>> tmp_treat_as_inverted(nproc);
    // Vector to store the status of the sorted face elements based on
    // the bottom-left condition
    std::vector<std::vector<bool>> treat_as_inverted(nproc);

    // Get the bottom-left node of each face element and sort them
    // starting from the face element with the bottom-left node

    // Loop over the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // There are no shared face elements with myself
      if (iproc != my_rank)
      {
        // Get the number of unsorted face elements
        const unsigned n_face_ele = tmp_unsorted_face_ele_pt[iproc].size();
        // Store the centroid of the face element. Perform the sorting
        // based on the bottom-left centroid of each face element
        Vector<Vector<double>> centroid_vertices(n_face_ele);

        // Resize the storage for the treating as inverted face element
        // storage
        tmp_treat_as_inverted[iproc].resize(n_face_ele);

        // Loop over the face elements associated with the iproc
        // processor
        for (unsigned e = 0; e < n_face_ele; e++)
        {
          // Get the face element
          FiniteElement* face_ele_pt = tmp_unsorted_face_ele_pt[iproc][e];
          // Get the number of nodes of the face element
          const unsigned n_node = face_ele_pt->nnode();
          Vector<double> bottom_left(2);
          // Assign as the bottom-left node the first node
          // Get the node
          Node* node_pt = face_ele_pt->node_pt(0);
          bottom_left[0] = node_pt->x(0);
          bottom_left[1] = node_pt->x(1);
          // Set as not treat as inverted element
          tmp_treat_as_inverted[iproc][e] = false;
          // Loop over the nodes to get the bottom-left vertex of all
          // the nodes
          for (unsigned n = 1; n < n_node; n++)
          {
            // Get the node
            Node* node_pt = face_ele_pt->node_pt(n);
            if (node_pt->x(1) < bottom_left[1])
            {
              bottom_left[0] = node_pt->x(0);
              bottom_left[1] = node_pt->x(1);
              // The first node is no longer the bottom-left node, we
              // need to treat the element as inverted
              tmp_treat_as_inverted[iproc][e] = true;
            } // if (node_pt->x(1) < bottom_left[1])
            else if (node_pt->x(1) == bottom_left[1])
            {
              if (node_pt->x(0) < bottom_left[0])
              {
                bottom_left[0] = node_pt->x(0);
                bottom_left[1] = node_pt->x(1);
                // The first node is no longer the bottom-left node, we
                // need to treat the element as inverted
                tmp_treat_as_inverted[iproc][e] = true;
              } // if (node_pt->x(0) < bottom_left[0])
            } // else if (node_pt->x(1) == bottom_left[1])

          } // for (n < n_node

          // Resize the container
          centroid_vertices[e].resize(2);
          // Add the centroid of the face element
          centroid_vertices[e][0] = (face_ele_pt->node_pt(0)->x(0) +
                                     face_ele_pt->node_pt(n_node - 1)->x(0)) *
                                    0.5;
          centroid_vertices[e][1] = (face_ele_pt->node_pt(0)->x(1) +
                                     face_ele_pt->node_pt(n_node - 1)->x(1)) *
                                    0.5;

        } // for (e < n_face_ele)

        // Sort the face elements based on their bottom-left node
        unsigned n_sorted_bottom_left = 0;
        // Keep track of the already sorted face elements
        std::vector<bool> done_face(n_face_ele, false);

        // Loop until all face elements have been sorted
        while (n_sorted_bottom_left < n_face_ele)
        {
          // The index of the next bottom-left face element
          unsigned index = 0;
          Vector<double> current_bottom_left(2);
          for (unsigned e = 0; e < n_face_ele; e++)
          {
            // Get the first not done face element
            if (!done_face[e])
            {
              // Store the first not done
              current_bottom_left[0] = centroid_vertices[e][0];
              current_bottom_left[1] = centroid_vertices[e][1];
              // Set the index
              index = e;
              // Break
              break;
            } // if (!done_face[e])

          } // for (e < n_face_ele)

          // Loop over all the other nondone face elements
          for (unsigned e = index + 1; e < n_face_ele; e++)
          {
            // Get the first not done face element
            if (!done_face[e])
            {
              if (centroid_vertices[e][1] < current_bottom_left[1])
              {
                // Re-set the current bottom left vertex
                current_bottom_left[0] = centroid_vertices[e][0];
                current_bottom_left[1] = centroid_vertices[e][1];
                // Re-assign the index
                index = e;
              } // if (centroid_vertices[e][1] < current_bottom_left[1])
              else if (centroid_vertices[e][1] == current_bottom_left[1])
              {
                if (centroid_vertices[e][0] < current_bottom_left[0])
                {
                  // Re-set the current bottom left vertex
                  current_bottom_left[0] = centroid_vertices[e][0];
                  current_bottom_left[1] = centroid_vertices[e][1];
                  // Re-assign the index
                  index = e;
                } // if (centroid_vertices[e][0] < current_bottom_left[0])

              } // else if (centroid_vertices[e][1] == current_bottom_left[1])

            } // if (!done_face[e])

          } // for (e < n_face_ele)

          // The face element
          unsorted_face_ele_pt[iproc].push_back(
            tmp_unsorted_face_ele_pt[iproc][index]);
          // The boundary element
          unsorted_ele_pt[iproc].push_back(tmp_unsorted_ele_pt[iproc][index]);
          // The face index
          unsorted_face_index_ele[iproc].push_back(
            tmp_unsorted_face_index_ele[iproc][index]);
          // The edge boundary associated to the face element
          edge_boundary[iproc].push_back(tmp_edge_boundary[iproc][index]);
          // The treat as inverted condition
          treat_as_inverted[iproc].push_back(
            tmp_treat_as_inverted[iproc][index]);

          // Mark the face element as sorted (done or visited)
          done_face[index] = true;

          // Increase the number of sorted bottom-left face elements
          n_sorted_bottom_left++;

        } // while (n_sorted_bottom_left < n_face_ele)

#ifdef PARANOID
        // Get the number of face elements sorted with the bottom-left
        // condition
        const unsigned tmp_n_face_ele = unsorted_face_ele_pt[iproc].size();

        if (tmp_n_face_ele != n_face_ele)
        {
          std::ostringstream error_stream;
          error_stream
            << "The number of face elements before sorting them starting\n"
            << "from their bottom-left vertex is different from the number\n"
            << "of face elements after the sorting\n"
            << "N. ele before sorting: (" << n_face_ele << ")\n"
            << "N. ele after sorting: (" << tmp_n_face_ele << ")\n";
          throw OomphLibError(
            error_stream.str(),
            "RefineableTriangleMesh::create_new_shared_boundaries()",
            OOMPH_EXCEPTION_LOCATION);
        }
#endif

      } // if (iproc != my_rank)

    } // for (iproc < nproc)

    // The time to sort shared face elements
    if (Print_timings_level_load_balance > 2)
    {
      oomph_info << "CPU for sorting shared boundary face elements (load "
                    "balance) [9.2]: "
                 << TimingHelpers::timer() - tt_start_sort_shared_face_elements
                 << std::endl;
    }

    // ================================================================
    // END: SORTING THE SHARED FACE ELEMENTS AND ITS ASSOCIATED DATA, WE
    // NEED TO ENSURE THAT THEY APPEAR (OR ARE STORED) IN THE SAME ORDER
    // IN BOTH OF THE PROCESSORS THAT CREATED THEM. WE USE THE
    // BOTTOM-LEFT NODE OF EACH FACE ELEMENT TO STORE THEM IN THE SAME
    // ORDER IN BOTH PROCESSORS. ALSO ENSURE THAT THE FACE ELEMENTS
    // AGREE WITH THE FIRST AND LAST NODE IN ALL PROCESSORS
    // ================================================================

    // ================================================================
    // BEGIN: COMPUTE THE GLOBAL DEGREE (VALENCY OF EACH NODE). THE
    // DEGREE OF THE NODES IN THE CURRENT SHARED BOUNDARIES IS COMPUTED
    // FIRST, THEN THIS INFO. IS SENT TO A ROOT PROCESSOR WHICH IS IN
    // CHARGE OF IDENTIFY AND RE-ASSIGN THE DEGREE OF THE NODES (IF THAT
    // IS THE CASE)
    // ================================================================

    // Get the time to compute the valency of each node
    double tt_start_compute_valency_of_nodes = 0.0;
    if (Print_timings_level_load_balance > 2)
    {
      tt_start_compute_valency_of_nodes = TimingHelpers::timer();
    }

    // Stores the global-degree of each node
    std::map<Node*, unsigned> global_node_degree;

    // Get the global degree (valency) of each node
    compute_shared_node_degree_helper(unsorted_face_ele_pt, global_node_degree);

    // The time to compute the valency of each node
    if (Print_timings_level_load_balance > 2)
    {
      oomph_info
        << "CPU for computing the valency of nodes (load balance) [9.3]: "
        << TimingHelpers::timer() - tt_start_compute_valency_of_nodes
        << std::endl;
    }

    // ================================================================
    // END: COMPUTE THE GLOBAL DEGREE (VALENCY OF EACH NODE). THE
    // DEGREE OF THE NODES IN THE CURRENT SHARED BOUNDARIES IS COMPUTED
    // FIRST, THEN THIS INFO. IS SENT TO A ROOT PROCESSOR WHICH IS IN
    // CHARGE OF IDENTIFY AND RE-ASSIGN THE DEGREE OF THE NODES (IF THAT
    // IS THE CASE)
    // ================================================================

    // ================================================================
    // BEGIN: IDENTIFY THE NODES LYING ON EDGES NOT OVERLAPED BY SHARED
    // BOUNDARIES, IDENTIFY THE BOUNDARY TO WHICH THE EDGE CORRESPOND
    // ================================================================

    // Get the time to compute nodes on non overlapped shared boundaries
    double tt_start_nodes_on_non_overlapped_shd_bnd = 0.0;
    if (Print_timings_level_load_balance > 2)
    {
      tt_start_nodes_on_non_overlapped_shd_bnd = TimingHelpers::timer();
    }

    // Mark the nodes on original boundaries not overlapped by shared
    // boundaries
    std::map<unsigned, std::map<Node*, bool>>
      node_on_bnd_not_overlapped_by_shd_bnd;

    // Loop over the edges of the original boundaries
    for (std::map<std::pair<Node*, Node*>, unsigned>::iterator it_map =
           elements_edges_on_boundary.begin();
         it_map != elements_edges_on_boundary.end();
         it_map++)
    {
      // Get the edge
      std::pair<Node*, Node*> edge_pair = (*it_map).first;
      // Is the edge overlaped by a shared boundary
      if (!overlapped_edge[edge_pair])
      {
        // Mark the nodes of the edge as being on an edge not overlaped
        // by a shared boundary on the boundary the edge is
        unsigned b = (*it_map).second;

        // Get the left node
        Node* left_node_pt = edge_pair.first;
        node_on_bnd_not_overlapped_by_shd_bnd[b][left_node_pt] = true;

        // Get the right node
        Node* right_node_pt = edge_pair.second;
        node_on_bnd_not_overlapped_by_shd_bnd[b][right_node_pt] = true;

      } // if (!overlapped_edge[edge_pair])

    } // Loop over edges to mark those nodes on overlaped edge by
      // shared boundaries

    // The time to compute nodes on non overlapped shared boundaries
    if (Print_timings_level_load_balance > 2)
    {
      oomph_info << "CPU for computing nodes on non overlapped shared "
                    "boundaries (load balance) [9.4]: "
                 << TimingHelpers::timer() -
                      tt_start_nodes_on_non_overlapped_shd_bnd
                 << std::endl;
    }

    // ================================================================
    // END: IDENTIFY THE NODES LYING ON EDGES NOT OVERLAPED BY SHARED
    // BOUNDARIES, IDENTIFY THE BOUNDARY TO WHICH THE EDGE CORRESPOND
    // ================================================================

    // ==================================================================
    // BEGIN: SORT THE SHARED BOUNDARY FACE ELEMENTS, ADD FACE ELEMENTS
    // TO THE LEFT OR RIGHT OF THE ROOT FACE ELEMENT. STOP ADDING WHEN
    // THE MOST LEFT OR MOST RIGHT ELEMENT (NODE) IS ALREADY PART OF
    // ANOTHER BOUNDARY (THIS MEANS THAT THE SHARED BOUNDARY THAT IS
    // BEING CREATED HAS A CONNECTION). ALSO REMEMBER TO CHECK FOR THE
    // CASE WHEN THE MOST LEFT OR MOST RIGHT NODE IS A BOUNDARY NODE OF
    // A BOUNDARY THAT NO LONGER EXIST IN THE DOMAIN. AT THE END OF THIS
    // SECTION WE WILL HAVE THE NUMBER OF SHARED BOUNDARIES OF THIS
    // PROCESSOR WITH OTHERS BUT NOT THE GLOBAL SHARED BOUNDARY ID
    // ==================================================================

    // Get the time to sort shared boundaries face elements to create a
    // continuous representation of the boundary
    double tt_start_join_shd_bnd_face_ele = 0.0;
    if (Print_timings_level_load_balance > 2)
    {
      tt_start_join_shd_bnd_face_ele = TimingHelpers::timer();
    }

    // Face elements that create the shared boundaries (sorted)
    Vector<Vector<Vector<FiniteElement*>>> sorted_face_ele_pt(nproc);

    // Bulk elements that create the shared boundaries (sorted)
    Vector<Vector<Vector<FiniteElement*>>> sorted_ele_pt(nproc);

    // Face indexes of the bulk elements that create the shared
    // boundaries (sorted)
    Vector<Vector<Vector<int>>> sorted_face_index_ele(nproc);

    // Store the edge boundary id associated with a shared boundary (if
    // any, this apply for shared boundaries lying on internal
    // boundaries, then the shared boundary is marked as overlaping an
    // internal boundary)
    Vector<Vector<int>> edge_boundary_id(nproc);

    // Store the connection information obtained when joining the face
    // elements (used for connection purposes only)
    Vector<Vector<Vector<int>>> sorted_connection_info(nproc);

    // Store the local shared boundary id associated to the elements
    // that will give rise to the shared boundaries (used to compute the
    // global shared boundary id from the local shared boundary id)
    Vector<Vector<unsigned>> proc_local_shared_boundary_id(nproc);

    // Map that associates the local shared boundary id with the list of
    // nodes that create it
    std::map<unsigned, std::list<Node*>>
      local_shd_bnd_id_to_sorted_list_node_pt;

    // Local shared bouonday id (used to locally identify the lists of
    // nodes that create shared boundaries, it is also useful to
    // identify connections with shared boundaries)
    unsigned local_shd_bnd_id = this->Initial_shared_boundary_id;

    // Sort the face elements, using the nodes at its ends

    // Mark the done elements
    std::map<FiniteElement*, bool> done_ele;

    // Mark the inverted elements
    std::map<FiniteElement*, bool> is_inverted;

    // Sort the face elements to get the number of shared boundaries
    // with in each processor
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // No face elements with myself
      if (iproc != my_rank)
      {
        // Get the number of unsorted face elements with the iproc
        // processor
        const unsigned nunsorted_face_ele = unsorted_face_ele_pt[iproc].size();
        // Count the number of sorted face elements
        unsigned nsorted_face_ele = 0;

        // Iterate until all the face elements have been sorted
        while (nsorted_face_ele < nunsorted_face_ele)
        {
          // Take the first nonsorted element an use it as root element,
          // add elements to the left and right until no more elements
          // left or until a stop condition is reached (connection,
          // boundary node)

#ifdef PARANOID
          // Flag to indicate if a root element was found
          bool found_root_element = false;
#endif

          // Index of the found root element
          unsigned root_index = 0;

          // List that contains the sorted face elements
          std::list<FiniteElement*> tmp_sorted_face_ele_pt;

          // List that contains the sorted elements
          std::list<FiniteElement*> tmp_sorted_ele_pt;

          // List that contains the sorted face indexes of the bulk
          // elements
          std::list<int> tmp_sorted_face_index_ele;

          // Storing for the sorting nodes extracted from the face
          // elements. The sorted nodes are used to identify connections
          // among new shared boundaries or original boundaries
          std::list<Node*> tmp_sorted_nodes_pt;
          // Clear the storage (just in case)
          tmp_sorted_nodes_pt.clear();

          // The initial and final nodes
          Node* initial_node_pt = 0;
          Node* final_node_pt = 0;

          // Store the original boundary id related with the root face
          // element (if there is one)
          int root_edge_bound_id = -1;

          // Loop over the unsorted face elements until a root element
          // is found
          for (unsigned e = 0; e < nunsorted_face_ele; e++)
          {
            // Get a root element
            FiniteElement* root_ele_pt = unsorted_face_ele_pt[iproc][e];
            // Is the element already done?
            if (!done_ele[root_ele_pt])
            {
              // Get the edge boundary id associated with the edge (if
              // there is one)
              root_edge_bound_id = edge_boundary[iproc][e];
              // Add the face element to the list of sorted face
              // elements
              tmp_sorted_face_ele_pt.push_back(root_ele_pt);
              // Add the bulk element to the list of sorted elements
              tmp_sorted_ele_pt.push_back(unsorted_ele_pt[iproc][e]);
              // Add the face index to the list of sorted face index
              // elements
              tmp_sorted_face_index_ele.push_back(
                unsorted_face_index_ele[iproc][e]);

              // Get the nodes and state them as initial and final
              const unsigned nnodes = root_ele_pt->nnode();
              // Check if the face element should be treated as inverted
              if (!treat_as_inverted[iproc][e])
              {
                initial_node_pt = root_ele_pt->node_pt(0);
                final_node_pt = root_ele_pt->node_pt(nnodes - 1);
              }
              else
              {
                initial_node_pt = root_ele_pt->node_pt(nnodes - 1);
                final_node_pt = root_ele_pt->node_pt(0);
              }
              // Add both nodes to the list of sorted nodes
              tmp_sorted_nodes_pt.push_back(initial_node_pt);
              tmp_sorted_nodes_pt.push_back(final_node_pt);

              // Mark the element as done
              done_ele[root_ele_pt] = true;
              // Check if the face element should be treated as inverted
              if (!treat_as_inverted[iproc][e])
              {
                // Mark the element as not inverted
                is_inverted[root_ele_pt] = false;
              }
              else
              {
                // Mark the element as inverted
                is_inverted[root_ele_pt] = true;
              }
              // Increase the counter for sorted face elements
              nsorted_face_ele++;
              // Set the root index
              root_index = e;
#ifdef PARANOID
              // Set the flag of found root element
              found_root_element = true;
#endif
              // Break the loop
              break;

            } // if (!done_ele[root_ele_pt])

          } // for (e < nunsorted_face_ele)

#ifdef PARANOID
          if (!found_root_element)
          {
            std::ostringstream error_stream;
            error_stream
              << "It was not possible the found the root element\n\n";
            throw OomphLibError(error_stream.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }
#endif

          // New element added. Continue adding elements -- or nodes --
          // to the list of shared boundary elements while a new element
          // has been added to the list (we have just added the root
          // element)
          bool new_element_added = true;

          // Similarly that in the
          // "create_polylines_from_halo_elements_helper() method, we
          // extract the nodes (in order) that will create the shared
          // polyline, and also check for connections with the just
          // added face elements (nodes)

          // Flags to indicate at which end (of the sorted list of
          // boundary elements) the element was added (left or right)
          bool element_added_to_the_left = false;
          bool element_added_to_the_right = false;

          // Flag to indicate that the "left" node of the element added
          // to the left was found to be shared with another boundary
          bool connection_to_the_left = false;

          // Flag to indicate that the "right" node of the element added
          // to the right was found to be shared with another boundary
          bool connection_to_the_right = false;

          // Flag to stop the adding of elements (and nodes) to the
          // current shared boundary (because there are connections at
          // both ends)
          bool current_polyline_has_connections_at_both_ends = false;

          // Store the boundary ids of the polylines to connect (only
          // used when the polyline was found to have a connection)
          // -1: Indicates no connection
          // -2: Indicates connection with itself
          // -3: Indicates no connection BUT STOP adding elements
          // -because the node is a boundary node whose boundary is no
          // -currently part of the domain. Think in one of the corner
          // -nodes of a triangle touchin a boundary that does no longer
          // -exist
          // Any other value: Boundary id to connect
          int bound_id_connection_to_the_left = -1;
          int bound_id_connection_to_the_right = -1;

          // Get the global degree of the node (notice the local degree
          // has been updated to global degree)
          const unsigned initial_node_degree =
            global_node_degree[initial_node_pt];

          // Flag to indicate we are calling the method from a load
          // balance sub-rutine
          const bool called_for_load_balance = true;

          // Check if the nodes of the root element have connections
          // ... to the left
          bound_id_connection_to_the_left =
            this->check_connections_of_polyline_nodes(
              element_in_processor_pt,
              root_edge_bound_id,
              overlapped_edge,
              node_on_bnd_not_overlapped_by_shd_bnd,
              tmp_sorted_nodes_pt,
              local_shd_bnd_id_to_sorted_list_node_pt,
              initial_node_degree,
              initial_node_pt,
              called_for_load_balance);

          // If there is a stop condition then set the corresponding
          // flag
          if (bound_id_connection_to_the_left != -1)
          {
            connection_to_the_left = true;
          } // if (bound_id_connection_to_the_left != -1)

          // Get the global degree of the node (notice the local degree
          // has been updated to global degree)
          const unsigned final_node_degree = global_node_degree[final_node_pt];

          // ... and to the right
          bound_id_connection_to_the_right =
            this->check_connections_of_polyline_nodes(
              element_in_processor_pt,
              root_edge_bound_id,
              overlapped_edge,
              node_on_bnd_not_overlapped_by_shd_bnd,
              tmp_sorted_nodes_pt,
              local_shd_bnd_id_to_sorted_list_node_pt,
              final_node_degree,
              final_node_pt,
              called_for_load_balance);

          // If there is a stop condition then set the corresponding
          // flag
          if (bound_id_connection_to_the_right != -1)
          {
            connection_to_the_right = true;
          } // if (bound_id_connection_to_the_right != -1)

          // If the current shared boundary has connections at both ends
          // then stop the adding of elements (and nodes)
          if (connection_to_the_left && connection_to_the_right)
          {
            current_polyline_has_connections_at_both_ends = true;
          }

          // Continue searching for more elements to add if
          // 1) A new element was added at the left or right of the list
          // 2) There are more possible elements to add
          // 3) The nodes at the edges of the added element (left or
          //    right) are not part of any other previous shared
          //    boundary
          while (new_element_added && (nsorted_face_ele < nunsorted_face_ele) &&
                 !current_polyline_has_connections_at_both_ends)
          {
            // Loop over the remaining elements and try to create a
            // contiguous set of face elements, start looking from the
            // root index. Any previous element should have been already
            // visited
            for (unsigned e = root_index; e < nunsorted_face_ele; e++)
            {
              // Reset the flags for added elements, to the left and right
              new_element_added = false;
              element_added_to_the_left = false;
              element_added_to_the_right = false;

              // Get the "e"-th element on the vector
              FiniteElement* tmp_ele_pt = unsorted_face_ele_pt[iproc][e];
              // Get the boundary id associated with the edge (if any)
              const int edge_bound_id = edge_boundary[iproc][e];
              // Check if the element has been already sorted and the
              // related edge bound id is the same as the root edge (if
              // any)
              if (!done_ele[tmp_ele_pt] &&
                  (edge_bound_id == root_edge_bound_id))
              {
                // Get the number of nodes on the current element
                const unsigned nnodes = tmp_ele_pt->nnode();
                // Get the first and last node of the element
                // Check if the face element should be treated as inverted
                Node* first_node_pt = 0;
                Node* last_node_pt = 0;
                if (!treat_as_inverted[iproc][e])
                {
                  first_node_pt = tmp_ele_pt->node_pt(0);
                  last_node_pt = tmp_ele_pt->node_pt(nnodes - 1);
                }
                else
                {
                  first_node_pt = tmp_ele_pt->node_pt(nnodes - 1);
                  last_node_pt = tmp_ele_pt->node_pt(0);
                }

                // A pointer to the node at the left or right of the
                // just added element, the most left or the most right
                // node
                Node* new_added_node_pt = 0;

                // Check if the element goes to the left
                if (initial_node_pt == last_node_pt && !connection_to_the_left)
                {
                  // Update the initial node and the just added node
                  new_added_node_pt = initial_node_pt = first_node_pt;
                  // Add the most left node
                  tmp_sorted_nodes_pt.push_front(first_node_pt);
                  // Add the face element to the list of sorted face
                  // elements
                  tmp_sorted_face_ele_pt.push_front(tmp_ele_pt);
                  // Add the bulk element to the list of sorted elements
                  tmp_sorted_ele_pt.push_front(unsorted_ele_pt[iproc][e]);
                  // Add the face index to the list of sorted face index
                  // elements
                  tmp_sorted_face_index_ele.push_front(
                    unsorted_face_index_ele[iproc][e]);
                  if (!treat_as_inverted[iproc][e])
                  {
                    // Mark the element as not inverted
                    is_inverted[tmp_ele_pt] = false;
                  }
                  else
                  {
                    // Mark the element as inverted
                    is_inverted[tmp_ele_pt] = true;
                  }
                  // Set the flag to indicate a new element was added
                  new_element_added = true;
                  // Set the flag to indicate the element was added to
                  // the left
                  element_added_to_the_left = true;
                }
                // Check if the element goes to the left (but inverted)
                else if (initial_node_pt == first_node_pt &&
                         !connection_to_the_left)
                {
                  // Update the initial node and the just added node
                  new_added_node_pt = initial_node_pt = last_node_pt;
                  // Add the most left node
                  tmp_sorted_nodes_pt.push_front(last_node_pt);
                  // Add the face element to the list of sorted face
                  // elements
                  tmp_sorted_face_ele_pt.push_front(tmp_ele_pt);
                  // Add the bulk element to the list of sorted elements
                  tmp_sorted_ele_pt.push_front(unsorted_ele_pt[iproc][e]);
                  // Add the face index to the list of sorted face index
                  // elements
                  tmp_sorted_face_index_ele.push_front(
                    unsorted_face_index_ele[iproc][e]);
                  if (!treat_as_inverted[iproc][e])
                  {
                    // Mark the element as inverted
                    is_inverted[tmp_ele_pt] = true;
                  }
                  else
                  {
                    // Mark the element as not inverted
                    is_inverted[tmp_ele_pt] = false;
                  }
                  // Set the flag to indicate a new element was added
                  new_element_added = true;
                  // Set the flag to indicate the element was added to
                  // the left
                  element_added_to_the_left = true;
                }
                // Check if the elements goes to the right
                else if (final_node_pt == first_node_pt &&
                         !connection_to_the_right)
                {
                  // Update the final node and the just added node
                  new_added_node_pt = final_node_pt = last_node_pt;
                  // Add the most right node
                  tmp_sorted_nodes_pt.push_back(last_node_pt);
                  // Add the face element to the list of sorted face
                  // elements
                  tmp_sorted_face_ele_pt.push_back(tmp_ele_pt);
                  // Add the bulk element to the list of sorted elements
                  tmp_sorted_ele_pt.push_back(unsorted_ele_pt[iproc][e]);
                  // Add the face index to the list of sorted face index
                  // elements
                  tmp_sorted_face_index_ele.push_back(
                    unsorted_face_index_ele[iproc][e]);
                  if (!treat_as_inverted[iproc][e])
                  {
                    // Mark the element as not inverted
                    is_inverted[tmp_ele_pt] = false;
                  }
                  else
                  {
                    // Mark the element as inverted
                    is_inverted[tmp_ele_pt] = true;
                  }
                  // Set the flag to indicate a new element was added
                  new_element_added = true;
                  // Set the flag to indicate the element was added to
                  // the right
                  element_added_to_the_right = true;
                }
                // Check if the elements goes to the right (but inverted)
                else if (final_node_pt == last_node_pt &&
                         !connection_to_the_right)
                {
                  // Update the final node and the just added node
                  new_added_node_pt = final_node_pt = first_node_pt;
                  // Add the most right node
                  tmp_sorted_nodes_pt.push_back(first_node_pt);
                  // Add the face element to the list of sorted face
                  // elements
                  tmp_sorted_face_ele_pt.push_back(tmp_ele_pt);
                  // Add the bulk element to the list of sorted elements
                  tmp_sorted_ele_pt.push_back(unsorted_ele_pt[iproc][e]);
                  // Add the face index to the list of sorted face index
                  // elements
                  tmp_sorted_face_index_ele.push_back(
                    unsorted_face_index_ele[iproc][e]);
                  if (!treat_as_inverted[iproc][e])
                  {
                    // Mark the element as inverted
                    is_inverted[tmp_ele_pt] = true;
                  }
                  else
                  {
                    // Mark the element as not inverted
                    is_inverted[tmp_ele_pt] = false;
                  }
                  // Set the flag to indicate a new elements was added
                  new_element_added = true;
                  // Set the flag to indicate the element was added to
                  // the right
                  element_added_to_the_right = true;
                }

                // Do additional stuff if the element was added
                if (new_element_added)
                {
                  // Mark the element as done
                  done_ele[tmp_ele_pt] = true;
                  // Increase the counter for sorted face elements
                  nsorted_face_ele++;

                  // Get the global degree of the node (notice the
                  // local degree has been updated to global degree)
                  const unsigned new_added_node_degree =
                    global_node_degree[new_added_node_pt];

                  // Based on which side the element was added, look for
                  // connections on that side

                  // Verify for connections to the left (we need to
                  // check for the connection variable too, since
                  // after a connection has been done we no longer
                  // need to verify for this condition)
                  if (element_added_to_the_left && !connection_to_the_left)
                  {
                    // Check for connection
                    bound_id_connection_to_the_left =
                      this->check_connections_of_polyline_nodes(
                        element_in_processor_pt,
                        root_edge_bound_id,
                        overlapped_edge,
                        node_on_bnd_not_overlapped_by_shd_bnd,
                        tmp_sorted_nodes_pt,
                        local_shd_bnd_id_to_sorted_list_node_pt,
                        new_added_node_degree,
                        new_added_node_pt,
                        called_for_load_balance);

                    // If there is a stop condition then set the
                    // corresponding flag
                    if (bound_id_connection_to_the_left != -1)
                    {
                      connection_to_the_left = true;
                    } // if (bound_id_connection_to_the_left != -1)

                  } // if (node_added_to_the_left &&
                    //     !connection_to_the_left)

                  // Verify for connections to the right (we need to
                  // check for the connection variable too, since
                  // after a connection has been done we no longer
                  // need to verify for this condition)
                  if (element_added_to_the_right && !connection_to_the_right)
                  {
                    // Check for connection
                    bound_id_connection_to_the_right =
                      this->check_connections_of_polyline_nodes(
                        element_in_processor_pt,
                        root_edge_bound_id,
                        overlapped_edge,
                        node_on_bnd_not_overlapped_by_shd_bnd,
                        tmp_sorted_nodes_pt,
                        local_shd_bnd_id_to_sorted_list_node_pt,
                        new_added_node_degree,
                        new_added_node_pt,
                        called_for_load_balance);

                    // If there is a stop condition then set the
                    // corresponding flag
                    if (bound_id_connection_to_the_right != -1)
                    {
                      connection_to_the_right = true;
                    } // if (bound_id_connection_to_the_right != -1)

                  } // if (node_added_to_the_right &&
                    //     !connection_to_the_right)

                  // If the current shared boundary has connections at
                  // both ends then stop the adding of elements (and
                  // nodes)
                  if (connection_to_the_left && connection_to_the_right)
                  {
                    current_polyline_has_connections_at_both_ends = true;
                  }

                  // Break the for (looping over unsorted face
                  // elements) and re-start looking for more elements
                  // that fit to the left or right
                  break;

                } // if (new_element_added)

              } // if (!done_ele[tmp_ele_pt])

            } // for (e < nunsorted_face_ele)

          } // while(new_element_added &&
            // (nsorted_face_ele < nunsorted_face_ele)
            //  && !current_polyline_has_connections_at_both_ends)

          // ------------------------------------------------------------
          // Before assigning a local shared boundary id to the list of
          // nodes and boundary elements, check for any loop that the
          // shared boundary may be creating

          // The vector of the elements
          Vector<FiniteElement*> tmp_vector_sorted_ele_pt;
          // Store the list of elements on a vector of elements
          for (std::list<FiniteElement*>::iterator it =
                 tmp_sorted_ele_pt.begin();
               it != tmp_sorted_ele_pt.end();
               it++)
          {
            tmp_vector_sorted_ele_pt.push_back((*it));
          }

          // The vector of the face elements
          Vector<FiniteElement*> tmp_vector_sorted_face_ele_pt;
          // Store the list of face elements on a vector of face
          // elements
          for (std::list<FiniteElement*>::iterator it =
                 tmp_sorted_face_ele_pt.begin();
               it != tmp_sorted_face_ele_pt.end();
               it++)
          {
            tmp_vector_sorted_face_ele_pt.push_back((*it));
          }

          // The vector of the face indexes
          Vector<int> tmp_vector_sorted_face_index_ele;
          // Store the list of elements on a vector of elements
          for (std::list<int>::iterator it = tmp_sorted_face_index_ele.begin();
               it != tmp_sorted_face_index_ele.end();
               it++)
          {
            tmp_vector_sorted_face_index_ele.push_back((*it));
          }

          // Store the nodes for the new shared polylines without loops
          Vector<std::list<Node*>> final_sorted_nodes_pt;
          // Store the boundary elements of the shared polyline without
          // loops
          Vector<Vector<FiniteElement*>> final_boundary_element_pt;
          // Store the boundary face elements of the shared polyline
          // without loops
          Vector<Vector<FiniteElement*>> final_boundary_face_element_pt;
          // Face indexes of the boundary elements without loops
          Vector<Vector<int>> final_face_index_element;
          // Connection flags (to the left) of the shared boundaries
          // without loops
          Vector<int> final_bound_id_connection_to_the_left;
          // Connection flags (to the right) of the shared boundaries
          // without loops
          Vector<int> final_bound_id_connection_to_the_right;

          // Break any possible loop created by the shared polyline
          this->break_loops_on_shared_polyline_load_balance_helper(
            local_shd_bnd_id,
            tmp_sorted_nodes_pt,
            tmp_vector_sorted_ele_pt,
            tmp_vector_sorted_face_ele_pt,
            tmp_vector_sorted_face_index_ele,
            bound_id_connection_to_the_left,
            bound_id_connection_to_the_right,
            final_sorted_nodes_pt,
            final_boundary_element_pt,
            final_boundary_face_element_pt,
            final_face_index_element,
            final_bound_id_connection_to_the_left,
            final_bound_id_connection_to_the_right);

          // Get the number of final sorted nodes
          const unsigned n_final_sorted_nodes = final_sorted_nodes_pt.size();

          // Loop over the list of final sorted nodes
          for (unsigned i = 0; i < n_final_sorted_nodes; i++)
          {
            // Store the list of nodes that gave rise to the shared
            // boundary
            local_shd_bnd_id_to_sorted_list_node_pt[local_shd_bnd_id] =
              final_sorted_nodes_pt[i];

            // Store the local shared boundary id assigned to the
            // elements that will create the shared boundary
            proc_local_shared_boundary_id[iproc].push_back(local_shd_bnd_id);

            // Increase the shared boundary id (note that this is only
            // used to keep track of the list of nodes that create the
            // shared boundaries in the current processor)
            local_shd_bnd_id++;

            // Include the vector of elements to the sorted vector
            sorted_ele_pt[iproc].push_back(final_boundary_element_pt[i]);

            // Include the vector of face elements to the sorted vector
            sorted_face_ele_pt[iproc].push_back(
              final_boundary_face_element_pt[i]);

            // Include the vector of elements to the sorted vector
            sorted_face_index_ele[iproc].push_back(final_face_index_element[i]);

            // Include the possible associated boundary id to the vector
            edge_boundary_id[iproc].push_back(root_edge_bound_id);

            // Include the connection information associated with the
            // current set of face elements (that will give rise to a
            // shared polyline
            // The temporal storage for the boundary connections ids
            Vector<int> bnd_connections_ids(2);
            bnd_connections_ids[0] = final_bound_id_connection_to_the_left[i];
            bnd_connections_ids[1] = final_bound_id_connection_to_the_right[i];
            sorted_connection_info[iproc].push_back(bnd_connections_ids);

          } // for (i < n_final_sorted_nodes)

        } // while (nsorted_face_ele < nunsorted_face_ele)

      } // if (iproc != my_rank)

    } // for (iproc < nproc)

    // The time to sort shared boundaries face elements to create a
    // continuous representation of the boundary
    if (Print_timings_level_load_balance > 2)
    {
      oomph_info << "CPU for joining shared boundary face elements (load "
                    "balance) [9.5]: "
                 << TimingHelpers::timer() - tt_start_join_shd_bnd_face_ele
                 << std::endl;
    }

    // ==================================================================
    // END: SORT THE SHARED BOUNDARY FACE ELEMENTS, ADD FACE ELEMENTS TO
    // THE LEFT OR RIGHT OF THE ROOT FACE ELEMENT. STOP ADDING WHEN THE
    // MOST LEFT OR MOST RIGHT ELEMENT (NODE) IS ALREADY PART OF ANOTHER
    // BOUNDARY (THIS MEANS THAT THE SHARED BOUNDARY THAT IS BEING
    // CREATED HAS A CONNECTION). ALSO REMEMBER TO CHECK FOR THE CASE
    // WHEN THE MOST LEFT OR MOST RIGHT NODE IS A BOUNDARY NODE OF A
    // BOUNDARY THAT NO LONGER EXIST IN THE DOMAIN. AT THE END OF THIS
    // SECTION WE WILL HAVE THE NUMBER OF SHARED BOUNDARIES OF THIS
    // PROCESSOR WITH OTHERS BUT NOT THE GLOBAL SHARED BOUNDARY ID
    // ==================================================================

    // ==================================================================
    // BEGIN: COMPUTE THE GLOBAL SHARED BOUNDARIES IDS. GATHER THE
    // NUMBER OF SHARED BOUNDARIES OF EACH PROCESSOR, THEN A ROOT
    // PROCESSOR IS IN CHARGE OF VERIFYING THAT THE SAME NUMBER OF
    // SHARED BOUNDARIES HAVE BEEN CREATED BY A PAIR OF PROCESSORS. THE
    // ROOT PROCESSOR COMPUTES THE INITIAL GLOBAL SHARED BOUNDARY ID
    // BETWEEN EACH PAIR OR PROCESSORS AND SENDS THESE INFO. TO ALL
    // PROCESSORS. THE GLOBAL INITIAL AND FINAL SHARED BOUNDARY ID ARE
    // ALSO COMPUTED
    // ==================================================================

    // Get the time to compute new shared boundaries ids
    double tt_start_get_new_shared_boundaries_ids = 0.0;
    if (Print_timings_level_load_balance > 2)
    {
      tt_start_get_new_shared_boundaries_ids = TimingHelpers::timer();
    }

    // Get the number of shared boundaries with in each processor
    Vector<unsigned> nshared_boundaries_with_processor(nproc);
    // Loop over the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // No shared boundaries with myself
      if (iproc != my_rank)
      {
        // Store the number of shared boundaries of the current
        // processor (my_rank) with the iproc processor
        nshared_boundaries_with_processor[iproc] =
          sorted_face_ele_pt[iproc].size();

      } // if (iproc != my_rank)

    } // for (iproc < nproc)

    // Each processor sends the number of shared boundaries that it has
    // with in each other processor to the "root_processor" which will
    // be in charge of checking and computing the global shared
    // boundaries ids
    const unsigned root_processor = 0;

    // Get the communicator of the mesh
    OomphCommunicator* comm_pt = this->communicator_pt();

    // Container where to store the info. received from other processor
    // in root. It receives from all processors the number of shared
    // boundaries that each one has with any other processor
    Vector<unsigned> flat_unsigned_root_received_data(nproc * nproc);

    // Gather the info. in the "root_processor"
    MPI_Gather(&nshared_boundaries_with_processor[0], // Info. sent from
                                                      // each processor
               nproc, // Total number of data to send from each
                      // processor
               MPI_UNSIGNED,
               &flat_unsigned_root_received_data[0], // Container where
                                                     // to receive the
                                                     // info. from all
                                                     // the processors
               nproc, // Number of data to receive from each processor
               MPI_UNSIGNED,
               root_processor, // The processor that receives all the
                               // info.
               comm_pt->mpi_comm());

    // Container where root store the info. that will be sent back to
    // all processor, because root performs a Broadcast operation then
    // the info. is received in the same container
    Vector<unsigned> flat_unsigned_root_send_receive_data;

    // Compute the new initial and final shared boundary id (they are
    // based on the global number of shared boundaries)
    unsigned new_initial_shared_boundary_id = 0;
    unsigned new_final_shared_boundary_id = 0;

    // Compute the boundaries ids for the shared boundaries
    if (my_rank == root_processor)
    {
      // Change the representation of the data received from all
      // processors to a matrix representation for ease access
      Vector<Vector<unsigned>> root_nshared_bound_proc_with_proc(nproc);
      // Loop over the processors and get the number of shared
      // boundaries of processor iproc with jproc
      for (unsigned iproc = 0; iproc < nproc; iproc++)
      {
        // Resize the vector to store the data
        root_nshared_bound_proc_with_proc[iproc].resize(nproc);
        // Loop over the processors and get the number of shared
        // boundaries of processor iproc with jproc
        for (unsigned jproc = 0; jproc < nproc; jproc++)
        {
          root_nshared_bound_proc_with_proc[iproc][jproc] =
            flat_unsigned_root_received_data[(iproc * nproc) + jproc];

        } // for (jproc < nproc)

      } // for (iproc < nproc)

#ifdef PARANOID
      // Check that the same number of boundaries are shared by two
      // specific processors
      for (unsigned iproc = 0; iproc < nproc; iproc++)
      {
        for (unsigned jproc = 0; jproc < iproc; jproc++)
        {
          if (root_nshared_bound_proc_with_proc[iproc][jproc] !=
              root_nshared_bound_proc_with_proc[jproc][iproc])
          {
            std::ostringstream error_stream;
            error_stream
              << "ROOT PROCESSOR ERROR\n\n"
              << "The number of shared boundaries between processor (" << iproc
              << ") and (" << jproc << ") is not the same:\n"
              << "Shared boundaries of processor (" << iproc
              << ") with processor (" << jproc << "): ("
              << root_nshared_bound_proc_with_proc[iproc][jproc] << ")\n"
              << "Shared boundaries of processor (" << jproc
              << ") with processor (" << iproc << "): ("
              << root_nshared_bound_proc_with_proc[jproc][iproc] << ")\n\n";
            throw OomphLibError(error_stream.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);

          } // The number of shared boundaries between processors
            // "iproc" and "jproc" is not the same

        } // for (jproc < iproc)

      } // for (iproc < nproc)
#endif

      // The enumeration of the shared boundaries starts from the lowest
      // processor number to the highest processor number

      // Two processors share the same boundaries ids, the lowest
      // processor number is the one in charge of computing the shared
      // boundaries ids
      Vector<Vector<unsigned>> start_shared_bound_id_proc_with_proc(nproc);
      // Resize the vector, we can not do it when storing the
      // info. because of the strategy to save the info.
      for (unsigned iproc = 0; iproc < nproc; iproc++)
      {
        start_shared_bound_id_proc_with_proc[iproc].resize(nproc);
      }

      // The shared boundaries ids start from the current number of
      // original boundaries
      unsigned shared_bound_id = this->nboundary();

      // Set the new initial shared boundary id
      new_initial_shared_boundary_id = shared_bound_id;

      // Assign the global shared boundary id for the shared boundaries
      for (unsigned iproc = 0; iproc < nproc; iproc++)
      {
        for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
        {
          // Are there shared boundaries between the pair of processors
          if (root_nshared_bound_proc_with_proc[iproc][jproc] > 0)
          {
            // Set the start boundary id of processor "iproc" with
            // processor "jproc" and viceversa
            start_shared_bound_id_proc_with_proc[iproc][jproc] =
              shared_bound_id;
            start_shared_bound_id_proc_with_proc[jproc][iproc] =
              shared_bound_id;
            // Increase the shared boundary id counter with as many
            // shared boundaries there are between the iproc and jproc
            // processor
            shared_bound_id += root_nshared_bound_proc_with_proc[iproc][jproc];
          } // if (root_nshared_bound_proc_with_proc[iproc][jproc] > 0)

        } // for (jproc < iproc)

      } // for (iproc < nproc)

      // Set the new final shared boundary id
      new_final_shared_boundary_id = shared_bound_id;

      // Prepare the info. to send back to each processor
      Vector<unsigned> send_start_shared_bound_id_proc_with_proc(nproc * nproc);

      // Copy the info. to the storage to send the info. back to other
      // processors
      for (unsigned iproc = 0; iproc < nproc; iproc++)
      {
        for (unsigned jproc = 0; jproc < nproc; jproc++)
        {
          // Get the initial shared boundary id between each pair of
          // processors (iproc, jproc)
          const unsigned initial_shd_bnd_id =
            start_shared_bound_id_proc_with_proc[iproc][jproc];
          flat_unsigned_root_send_receive_data.push_back(initial_shd_bnd_id);

          // .. then copy the number of shared boundaries that there are
          // between processor iproc and jproc
          const unsigned nshared_bnd_iproc_jproc =
            root_nshared_bound_proc_with_proc[iproc][jproc];
          flat_unsigned_root_send_receive_data.push_back(
            nshared_bnd_iproc_jproc);

        } // for (jproc < nproc)

      } // for (iproc < nproc)

      // .. at the end of the data to send include the global initial
      // shared boundary id
      flat_unsigned_root_send_receive_data.push_back(
        new_initial_shared_boundary_id);

      // ... and the global final shared boundary id
      flat_unsigned_root_send_receive_data.push_back(
        new_final_shared_boundary_id);

    } // if (my_rank == root_processor)

    // Send the initial shared boundaries ids and the number of shared
    // boundaries between all procesors to all processors. All
    // processors need to know this info.

    // The number of data that will be sent by root to other processors
    // and the number of data that other processors receive from root,
    // it is the same because it is performed via a Broadcast
    unsigned root_ndata_sent_to_all_proc =
      flat_unsigned_root_send_receive_data.size();

    MPI_Bcast(&root_ndata_sent_to_all_proc, // Data to send
              1,
              MPI_UNSIGNED,
              root_processor,
              comm_pt->mpi_comm());

    // Resize the container if this is a processor that receives data
    if (my_rank != root_processor)
    {
      flat_unsigned_root_send_receive_data.resize(root_ndata_sent_to_all_proc);
    }

    // Send back the start boundaries ids for the shared boundaries
    // Scatter the info. from the "root_processor"
    MPI_Bcast(&flat_unsigned_root_send_receive_data[0], // Info. sent to
                                                        // each
                                                        // processor
              root_ndata_sent_to_all_proc, // Total number of data to
                                           // send to each processor
              MPI_UNSIGNED,
              root_processor, // The processor that sends all the info.
              comm_pt->mpi_comm());

    // The container to store the initial shared boundaries ids between
    // each pair of processors
    Vector<Vector<unsigned>> initial_shared_bound_id_proc_with_proc(nproc);

    // All processors need to know how many shared boundaries there are
    // between each pair of processors

    // The number of shared boundaries between each pair of processors
    Vector<Vector<unsigned>> nshared_bound_proc_with_proc(nproc);

    unsigned iflat_counter = 0;
    // Fill the containers with the received info. from root processor
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Resize the containers
      initial_shared_bound_id_proc_with_proc[iproc].resize(nproc);
      nshared_bound_proc_with_proc[iproc].resize(nproc);

      // Loop over the processors
      for (unsigned jproc = 0; jproc < nproc; jproc++)
      {
        // Get the initial shared boundary id between each pair of
        // processors (iproc, jproc)
        initial_shared_bound_id_proc_with_proc[iproc][jproc] =
          flat_unsigned_root_send_receive_data[iflat_counter++];

        // .. and copy the number of shared boundaries that there are
        // between processor iproc and jproc
        nshared_bound_proc_with_proc[iproc][jproc] =
          flat_unsigned_root_send_receive_data[iflat_counter++];

      } // for (jproc < nproc)

    } // for (iproc < nproc)

    // Read the new initial shared boundary id
    new_initial_shared_boundary_id =
      flat_unsigned_root_send_receive_data[root_ndata_sent_to_all_proc - 2];

    // Read the new final shared boundary id
    new_final_shared_boundary_id =
      flat_unsigned_root_send_receive_data[root_ndata_sent_to_all_proc - 1];

    // The time to compute new shared boundaries ids
    if (Print_timings_level_load_balance > 2)
    {
      oomph_info
        << "CPU for computing new shared boundaries ids (load balance) [9.6]: "
        << TimingHelpers::timer() - tt_start_get_new_shared_boundaries_ids
        << std::endl;
    }

    // ==================================================================
    // END: COMPUTE THE GLOBAL SHARED BOUNDARIES IDS. GATHER THE NUMBER
    // OF SHARED BOUNDARIES OF EACH PROCESSOR, THEN A ROOT PROCESSOR IS
    // IN CHARGE OF VERIFYING THAT THE SAME NUMBER OF SHARED BOUNDARIES
    // HAVE BEEN CREATED BY A PAIR OF PROCESSORS. THE ROOT PROCESSOR
    // COMPUTES THE INITIAL GLOBAL SHARED BOUNDARY ID BETWEEN EACH PAIR
    // OR PROCESSORS AND SENDS THESE INFO. TO ALL PROCESSORS. THE GLOBAL
    // INITIAL AND FINAL SHARED BOUNDARY ID ARE ALSO COMPUTED
    // ==================================================================

    // ==================================================================
    // BEGIN: CREATE THE NEW SHARED BOUNDARIES. DELETE THE OLD SHARED
    // BOUNDARIES INFORMATION. FILL THE DATA STRUCTURES WITH THE NEW
    // SHARED BOUNDARIES INFO.
    // ==================================================================

    // Get the time to create new shared boundaries representations
    double tt_start_create_new_shared_boundaries_polylines = 0.0;
    if (Print_timings_level_load_balance > 2)
    {
      tt_start_create_new_shared_boundaries_polylines = TimingHelpers::timer();
    }

    // Create the shared boundaries and establish all the related info.
    // - Create Polylines
    // - Store shared boundary elements
    // - Fill data structures to know which shared boundaries belong to
    //   which processor

    // Resize the shared polylines container
    this->flush_shared_boundary_polyline_pt();
    this->Shared_boundary_polyline_pt.resize(nproc);

    // Resize for the boundaries ids shared with all processors
    this->Shared_boundaries_ids.clear();
    this->Shared_boundaries_ids.resize(nproc);
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      this->Shared_boundaries_ids[iproc].clear();
      this->Shared_boundaries_ids[iproc].resize(nproc);
    } // for (iproc < nproc)

    // Clear data
    this->Shared_boundary_from_processors.clear();
    this->Shared_boundary_overlaps_internal_boundary.clear();
    this->Boundary_was_splitted.clear();
    this->Boundary_subpolylines.clear();
    this->Boundary_marked_as_shared_boundary.clear();

    // Flush data
    this->flush_shared_boundary_element();
    this->flush_face_index_at_shared_boundary();
    this->flush_shared_boundary_node();
    this->flush_sorted_shared_boundary_node();

    // Store the old local inital shared boundary id (used to map from
    // local shared boundary id to global shared boundary id)
    const unsigned old_local_shd_bnd_id = this->Initial_shared_boundary_id;

    // Update the initial and final shared boundary id
    this->Initial_shared_boundary_id = new_initial_shared_boundary_id;
    this->Final_shared_boundary_id = new_final_shared_boundary_id;

    // Storage for the new created polylines between the current
    // processor (my_rank) and the other processors, unsorted polylines
    Vector<TriangleMeshPolyLine*> unsorted_polylines_pt;

    // Map to get the global shared boundary id from the local shared
    // boundary id. Note that this is only used to get the global shared
    // boundary id when the shared boundary that is being created has
    // connections
    std::map<unsigned, unsigned> local_to_global_shd_bnd_id;

    // Each processor knows the boundaries ids for each of the shared
    // boundaries it has, establish that info. in the proper containers
    // Additionally, store the shared boundaries of ALL processors with
    // ALL processors, but only create the shared boundaries (and their
    // respective polylines) of the current processor (my_rank)
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Avoid creating double shared boundaries, the shared boundaries
      // created between processor "iproc" and processor "jproc" are the
      // same than those created between processor "jproc" and processor
      // "iproc"
      for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
      {
        // If we are working with the current processor (my_rank) then
        // create the shared boundaries, if that is not the case then
        // only fill the info. on the proper containers
        if (iproc == my_rank || jproc == my_rank)
        {
          // Check the condition that made it get here
          unsigned ref_proc = 0;
          if (iproc == my_rank)
          {
            ref_proc = jproc;
          }
          else if (jproc == my_rank)
          {
            ref_proc = iproc;
          }

          // Get the number of shared boundaries between processor iproc
          // and processor jproc
          const unsigned nshared_bound_iproc_jproc =
            nshared_bound_proc_with_proc[iproc][jproc];

          // Loop over the number of shared boundaries
          for (unsigned counter = 0; counter < nshared_bound_iproc_jproc;
               counter++)
          {
            // Compute the shared boundary id for the shared boundary
            const unsigned shd_bnd_id =
              initial_shared_bound_id_proc_with_proc[iproc][jproc] + counter;
            // Set up the shared boundaries between "iproc" (my_rank)
            // and "jproc"
            this->Shared_boundaries_ids[iproc][jproc].push_back(shd_bnd_id);
            this->Shared_boundaries_ids[jproc][iproc].push_back(shd_bnd_id);

            // Specify the processors involved for the creation of the
            // shared boundary
            Vector<unsigned> processors(2);
            processors[0] = iproc;
            processors[1] = jproc;
            this->Shared_boundary_from_processors[shd_bnd_id] = processors;

            // Get the possible root edge id associated to the shared
            // boundary (useful when the shared boundary overlaps an
            // original boundary)
            int root_edge_bound_id = edge_boundary_id[ref_proc][counter];
            // Check if the shared boundary is overlapping (or is part)
            // of an internal boundary
            if (root_edge_bound_id != -1)
            {
              // If the shared boundary is part of an internal boundary then
              // mark the shared boundary
              this->Shared_boundary_overlaps_internal_boundary[shd_bnd_id] =
                static_cast<unsigned>(root_edge_bound_id);
            } // if (root_edge_bound_id != -1)

            // Storing for the nodes of the polyline (these are different
            // from the nodes on the face elements -- it is actually a
            // sub-set -- since the polyline is created from the first and
            // last nodes on the face elements)
            Vector<Node*> node_pt_to_create_shared_polyline;

            // Add the first node for the very first face element. In
            // the loop we will only add the last node of the face
            // element
            FiniteElement* first_face_ele_pt =
              sorted_face_ele_pt[ref_proc][counter][0];

            // Get the number of nodes on the first face element
            const unsigned first_face_ele_nnodes = first_face_ele_pt->nnode();
            if (!is_inverted[first_face_ele_pt])
            {
              // Get the first node
              Node* first_node_pt = first_face_ele_pt->node_pt(0);
              // Add the node to create the polyline
              node_pt_to_create_shared_polyline.push_back(first_node_pt);
              // Add the first node to the shared boundary
              this->add_shared_boundary_node(shd_bnd_id, first_node_pt);
            }
            else
            {
              // Get the first node in the inverted face element
              Node* first_node_pt =
                first_face_ele_pt->node_pt(first_face_ele_nnodes - 1);
              // Add the node to create the polyline
              node_pt_to_create_shared_polyline.push_back(first_node_pt);
              // Add the first node to the shared boundary
              this->add_shared_boundary_node(shd_bnd_id, first_node_pt);
            }

            // ... and extract only the last nodes of the face elements
            // in the next loop and add them in the vector of nodes to
            // create polylines (node_pt_to_create_shared_polyline)

            // Get the number of elements
            const unsigned nshared_boundary_elements =
              sorted_face_ele_pt[ref_proc][counter].size();

            // Store the shared boundary elements, nodes and get the
            // sorted nodes to create the polyline
            for (unsigned ie = 0; ie < nshared_boundary_elements; ie++)
            {
              // Get the bulk element version of the face element
              FiniteElement* bulk_ele_pt = sorted_ele_pt[ref_proc][counter][ie];

              // Add the shared boundary element and associate it to the
              // "shd_bnd_id"
              this->add_shared_boundary_element(shd_bnd_id, bulk_ele_pt);

              // Get the face index from which the face element was
              // created from the bulk element
              const int face_index =
                sorted_face_index_ele[ref_proc][counter][ie];

              // Add the face index to the face indexes of the shared
              // boundary
              this->add_face_index_at_shared_boundary(shd_bnd_id, face_index);

              // Get the face element to obtain the last node
              FiniteElement* face_ele_pt =
                sorted_face_ele_pt[ref_proc][counter][ie];

              // Get the number of nodes
              const unsigned nnodes = face_ele_pt->nnode();
              if (!is_inverted[face_ele_pt])
              {
                // We have already added the first node, then start from
                // the second one
                for (unsigned n = 1; n < nnodes; n++)
                {
                  // Get the node to be added
                  Node* node_pt = face_ele_pt->node_pt(n);
                  // Add the node and associate it to the shared boundary
                  this->add_shared_boundary_node(shd_bnd_id, node_pt);
                } // for (n < nnodes)

                // Add the last node of the face element to the vector of
                // nodes to create the polyline
                // Get the last node
                Node* last_node_pt = face_ele_pt->node_pt(nnodes - 1);
                node_pt_to_create_shared_polyline.push_back(last_node_pt);
              } // if (!is_inverted[face_ele_pt])
              else
              {
                // We have already added the first node, then start from
                // the second one (in reverse order)
                for (int n = nnodes - 2; n >= 0; n--)
                {
                  // Get the node to be added
                  Node* node_pt = face_ele_pt->node_pt(n);
                  // Add the node and associate it to the shared boundary
                  this->add_shared_boundary_node(shd_bnd_id, node_pt);
                } // for (n < nnodes)

                // Add the last node of the face element to the vector of
                // nodes to create the polyline
                // Get the last node
                Node* last_node_pt = face_ele_pt->node_pt(0);
                node_pt_to_create_shared_polyline.push_back(last_node_pt);

              } // else if (!is_inverted[face_ele_pt])

            } // for (ie < nshared_boundary_elements)

            // The number of nodes for the shared boundary polyline
            const unsigned nnodes_to_create_shared_boundary =
              node_pt_to_create_shared_polyline.size();

            // Get the vertices that create the shared boundary polyline
            Vector<Vector<double>> vertices(nnodes_to_create_shared_boundary);
            for (unsigned n = 0; n < nnodes_to_create_shared_boundary; n++)
            {
              vertices[n].resize(2);
              // Get the node
              Node* tmp_node_pt = node_pt_to_create_shared_polyline[n];
              // Get the vertices
              vertices[n][0] = tmp_node_pt->x(0);
              vertices[n][1] = tmp_node_pt->x(1);
            } // for (n < nnodes_to_create_shared_boundary)

            // Create the polyline
            TriangleMeshPolyLine* polyline_pt =
              new TriangleMeshPolyLine(vertices, shd_bnd_id);

            // Updates bnd_id<--->curve section map
            this->Boundary_curve_section_pt[shd_bnd_id] = polyline_pt;

            // Add the new created polyline to the list of unsorted
            // polylines
            unsorted_polylines_pt.push_back(polyline_pt);

            // Mark the polyline for deletion (when calling destructor)
            this->Free_curve_section_pt.insert(polyline_pt);

            // Now assign the connection information
            // ---------------------------------------------------------
            // Get the local shared boundary id associated to the
            // elements that gave rise to this shared boundary
            const unsigned local_shd_bnd_id =
              proc_local_shared_boundary_id[ref_proc][counter];

            // Associate the local shared boundary to the global shared
            // boundary
            local_to_global_shd_bnd_id[local_shd_bnd_id] = shd_bnd_id;

            // Get the correct shared boundaries ids, from the local
            // shared boundaries ids established at the identification
            // of the conections

            // Get the local bnd id for the connection to the left
            int tmp_bnd_id_connection_to_the_left =
              sorted_connection_info[ref_proc][counter][0];
            // Get the local bnd id for the connection to the right
            int tmp_bnd_id_connection_to_the_right =
              sorted_connection_info[ref_proc][counter][1];

            // The global shared boundaries ids for connections to the
            // left or right
            int bnd_id_connection_to_the_left = -1;
            int bnd_id_connection_to_the_right = -1;

            // To the left
            // --------------

            // If the connection is with the same shared boundary then
            // set the current boundary id
            if (tmp_bnd_id_connection_to_the_left == -2)
            {
              // Set the current shared boundary id
              bnd_id_connection_to_the_left = shd_bnd_id;
            } // if (tmp_bnd_id_connection_to_the_left == -2)

            // Check if the connection was a stop adding nodes condition
            if (tmp_bnd_id_connection_to_the_left == -3)
            {
              // Set as no connected
              bnd_id_connection_to_the_left = -1;
            } // if (tmp_bnd_id_connection_to_the_left == -3)

            // There is a connection with another boundary, check if it
            // is a shared boundary or an original boundary
            if (tmp_bnd_id_connection_to_the_left >=
                static_cast<int>(old_local_shd_bnd_id))
            {
              // The connection is with a shared boundary, get the
              // global shared boundary id and set the connection
#ifdef PARANOID
              std::map<unsigned, unsigned>::iterator it =
                local_to_global_shd_bnd_id.find(
                  static_cast<unsigned>(tmp_bnd_id_connection_to_the_left));
              // If the global shared boundary id was not found we
              // are in trouble
              if (it == local_to_global_shd_bnd_id.end())
              {
                std::stringstream error_message;
                error_message
                  << "The global shared boundary id was not found for\n"
                  << "the local shared boundary shared with processor ("
                  << ref_proc << ").\n"
                  << "This processor: (" << my_rank << ")\n"
                  << "Boundary shared with processor: (" << ref_proc << ")\n"
                  << "Local shared boundary: ("
                  << tmp_bnd_id_connection_to_the_left << ")\n";
                throw OomphLibError(error_message.str(),
                                    OOMPH_CURRENT_FUNCTION,
                                    OOMPH_EXCEPTION_LOCATION);
              } // if (it==local_to_global_shd_bnd_id.end())
#endif

              // Get the global shared boundary id
              bnd_id_connection_to_the_left =
                local_to_global_shd_bnd_id[static_cast<unsigned>(
                  tmp_bnd_id_connection_to_the_left)];
            }
            else
            {
              // The connection is with an original boundary, copy
              // the boundary id
              bnd_id_connection_to_the_left = tmp_bnd_id_connection_to_the_left;

            } // else (connection with a shared boundary)

            // To the right
            // --------------

            // If the connection is with the same shared boundary then
            // set the current boundary id
            if (tmp_bnd_id_connection_to_the_right == -2)
            {
              // Set the current shared boundary id
              bnd_id_connection_to_the_right = shd_bnd_id;
            } // if (tmp_bnd_id_connection_to_the_right == -2)

            // Check if the connection was a stop adding nodes condition
            if (tmp_bnd_id_connection_to_the_right == -3)
            {
              // Set as no connected
              bnd_id_connection_to_the_right = -1;
            } // if (tmp_bnd_id_connection_to_the_right == -3)

            // There is a connection with another boundary, check if it
            // is a shared boundary or an original boundary
            if (tmp_bnd_id_connection_to_the_right >=
                static_cast<int>(old_local_shd_bnd_id))
            {
              // The connection is with a shared boundary, get the
              // global shared boundary id and set the connection
#ifdef PARANOID
              std::map<unsigned, unsigned>::iterator it =
                local_to_global_shd_bnd_id.find(
                  static_cast<unsigned>(tmp_bnd_id_connection_to_the_right));
              // If the global shared boundary id was not found we
              // are in trouble
              if (it == local_to_global_shd_bnd_id.end())
              {
                std::stringstream error_message;
                error_message
                  << "The global shared boundary id was not found for\n"
                  << "the local shared boundary shared with processor ("
                  << ref_proc << ").\n"
                  << "This processor: (" << my_rank << ")\n"
                  << "Boundary shared with processor: (" << ref_proc << ")\n"
                  << "Local shared boundary: ("
                  << tmp_bnd_id_connection_to_the_right << ")\n";
                throw OomphLibError(error_message.str(),
                                    OOMPH_CURRENT_FUNCTION,
                                    OOMPH_EXCEPTION_LOCATION);
              } // if (it==local_to_global_shd_bnd_id.end())
#endif
              // Get the global shared boundary id
              bnd_id_connection_to_the_right =
                local_to_global_shd_bnd_id[static_cast<unsigned>(
                  tmp_bnd_id_connection_to_the_right)];
            }
            else
            {
              // The connection is with an original boundary, copy the
              // boundary id
              bnd_id_connection_to_the_right =
                tmp_bnd_id_connection_to_the_right;

            } // else (connection with a shared boundary)

            // --------------------------------
            // Set the connection to the left
            if (bnd_id_connection_to_the_left != -1)
            {
              // Get the unsigned version of the boundary id to the left
              const unsigned ubnd_id_connection_to_the_left =
                static_cast<unsigned>(bnd_id_connection_to_the_left);
              // Set the initial vertex as connected
              polyline_pt->set_initial_vertex_connected();
              // Set the initial vertex connected boundary id
              polyline_pt->initial_vertex_connected_bnd_id() =
                ubnd_id_connection_to_the_left;
              // Set the chunk number to zero
              polyline_pt->initial_vertex_connected_n_chunk() = 0;

            } // if (bnd_id_connection_to_the_left != -1)

            // ---------------------------------
            // Set the connection to the right
            if (bnd_id_connection_to_the_right != -1)
            {
              // Get the unsigned version of the boundary id to the
              // right
              const unsigned ubnd_id_connection_to_the_right =
                static_cast<unsigned>(bnd_id_connection_to_the_right);
              // Set the final vertex as connected
              polyline_pt->set_final_vertex_connected();
              // Set the final vertex connected boundary id
              polyline_pt->final_vertex_connected_bnd_id() =
                ubnd_id_connection_to_the_right;
              // Set the chunk number to zero
              polyline_pt->final_vertex_connected_n_chunk() = 0;

            } // if (bnd_id_connection_to_the_right != -1)

          } // for (counter < nshared_bound_iproc_jproc)

        } // if (iproc  == my_rank || jproc == my_rank)
        else
        {
          // We are not working with the current processor, then we only
          // need to fill the containers

          // Get the number of shared boundaries between processor iproc
          // and processor jproc
          const unsigned nshared_bound_iproc_jproc =
            nshared_bound_proc_with_proc[iproc][jproc];
          // Loop over the number of shared boundaries
          for (unsigned counter = 0; counter < nshared_bound_iproc_jproc;
               counter++)
          {
            // Compute the shared boundary id for the shared boundary
            const unsigned shd_bnd_id =
              initial_shared_bound_id_proc_with_proc[iproc][jproc] + counter;

            // Set up the shared boundaries between "iproc" and "jproc"
            this->Shared_boundaries_ids[iproc][jproc].push_back(shd_bnd_id);
            this->Shared_boundaries_ids[jproc][iproc].push_back(shd_bnd_id);

            // Specify the processors involved for the creation of the
            // shared boundary
            Vector<unsigned> processors(2);
            processors[0] = iproc;
            processors[1] = jproc;
            this->Shared_boundary_from_processors[shd_bnd_id] = processors;

          } // for (counter < nshared_bound_iproc_jproc)

        } // else if (iproc  == my_rank || jproc == my_rank)

      } // for (jproc < nproc)

    } // for (iproc < nproc)

    // Get the time to create new shared boundaries representations
    if (Print_timings_level_load_balance > 2)
    {
      oomph_info << "CPU for creating new shared boundaries representations "
                    "(load balance) [9.7]: "
                 << TimingHelpers::timer() -
                      tt_start_create_new_shared_boundaries_polylines
                 << std::endl;
    }

    // ==================================================================
    // END: CREATE THE NEW SHARED BOUNDARIES. DELETE THE OLD SHARED
    // BOUNDARIES INFORMATION. FILL THE DATA STRUCTURES WITH THE NEW
    // SHARED BOUNDARIES INFO.
    // ==================================================================

    // ==================================================================
    // BEGIN: SORT THE SHARED BOUNDARIES AND CREATE SHARED CURVES (A SET
    // OF CONTIGUOUS SHARED POLYLINES). STORE THEM IN THE GLOBAL
    // CONTAINER FOR SHARED BOUNDARIES. FREE MEMORY BY DELETING FACE
    // ELEMENTS
    // ==================================================================

    // Get the time to create the new shared curves
    double tt_start_create_new_shared_curves = 0.0;
    if (Print_timings_level_load_balance > 2)
    {
      tt_start_create_new_shared_curves = TimingHelpers::timer();
    }

    // Sort the polylines and find if they create a contiguous open
    // curve
    if (unsorted_polylines_pt.size() > 0)
    {
      // Now that we have all the new unsorted polylines on "my_rank"x
      // processor it is time to sort them so they be all contiguous
      this->sort_polylines_helper(unsorted_polylines_pt,
                                  this->Shared_boundary_polyline_pt[my_rank]);
    }

    // Free the memory allocated for the face elements
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      const unsigned nface_ele = unsorted_face_ele_pt[iproc].size();
      for (unsigned e = 0; e < nface_ele; e++)
      {
        delete unsorted_face_ele_pt[iproc][e];
        unsorted_face_ele_pt[iproc][e] = 0;
      } // for (e < nface_ele)

    } // for (iproc < nproc)

    // The time to create the new shared curves
    if (Print_timings_level_load_balance > 2)
    {
      oomph_info
        << "CPU for creating the new shared curves (load balance) [9.8]: "
        << TimingHelpers::timer() - tt_start_create_new_shared_curves
        << std::endl;
    }

    // ==================================================================
    // END: SORT THE SHARED BOUNDARIES AND CREATE SHARED CURVES (A SET
    // OF CONTIGUOUS SHARED POLYLINES). STORE THEM IN THE GLOBAL
    // CONTAINER FOR SHARED BOUNDARIES. FREE MEMORY BY DELETING FACE
    // ELEMENTS
    // ==================================================================
  }

  //======================================================================
  // Computes the degree of the nodes on the shared boundaries, the
  // degree of the node is computed from the global graph created by the
  // shared boundaries of all processors
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::compute_shared_node_degree_helper(
    Vector<Vector<FiniteElement*>>& unsorted_face_ele_pt,
    std::map<Node*, unsigned>& global_node_degree)
  {
    // Get the rank and number of processors
    const unsigned nproc = this->communicator_pt()->nproc();
    const unsigned my_rank = this->communicator_pt()->my_rank();

    // Store a temporary sorting of the nodes, starting from the
    // lower-left position
    Vector<Vector<Node*>> tmp_sorted_shared_node_pt(nproc);

    // Store the alias of the node, it may be shared by more than two
    // processors, they should know that the node is the same
    // [0] iproc, processor with which the current processor shared the node
    // [1] node #, number of node in the number of nodes shared with iproc
    //     processor
    std::map<Node*, Vector<Vector<unsigned>>> node_alias;

    // Stores the local adjacency matrix
    // (nproc*n_shared_nodes*n_shared_nodes)
    Vector<Vector<Vector<unsigned>>> local_adjacency_matrix(nproc);

    // Sort the nodes and create the adjacency matrix of each sub-graph
    // created by the shared edges
    create_adjacency_matrix_new_shared_edges_helper(unsorted_face_ele_pt,
                                                    tmp_sorted_shared_node_pt,
                                                    node_alias,
                                                    local_adjacency_matrix);

    // Prepare the info. to be sent to the root processor, which will be
    // in charge of updating the nodes degree by combining the info. of
    // all the processors

    // The flat package with the info. to send to root
    Vector<unsigned> package_unsigned_send_data_to_root;

    // Encode the info. that will be sent to the root processor

    // Loop over the temporary sorted nodes between each pair of
    // processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Send the processor index
      package_unsigned_send_data_to_root.push_back(iproc);

      // Get the number of nodes shared between the processors
      const unsigned n_nodes = tmp_sorted_shared_node_pt[iproc].size();

      // Send the number of nodes shared with the iproc processor
      package_unsigned_send_data_to_root.push_back(n_nodes);

      // Loop over the nodes
      for (unsigned ishd = 0; ishd < n_nodes; ishd++)
      {
        // Get the node
        Node* shd_node_pt = tmp_sorted_shared_node_pt[iproc][ishd];

        // Get the alias info.
        Vector<Vector<unsigned>> alias_node_info = node_alias[shd_node_pt];

        // Get the number of alias for the node
        const unsigned n_alias = alias_node_info.size();

        // Send the number of alias assigned to the node
        package_unsigned_send_data_to_root.push_back(n_alias);

        // Loop over the alias to include them in the package
        for (unsigned i = 0; i < n_alias; i++)
        {
          // Send the alias info.
          // The current processor
          package_unsigned_send_data_to_root.push_back(alias_node_info[i][0]);
          // The prociesso with which is shared
          package_unsigned_send_data_to_root.push_back(alias_node_info[i][1]);
          // The index of the node
          package_unsigned_send_data_to_root.push_back(alias_node_info[i][2]);
        } // for (i < n_alias)

      } // for (ishd < n_nodes)

      // Now send the adjacency matrix
      for (unsigned i = 0; i < n_nodes; i++)
      {
        for (unsigned j = 0; j < n_nodes; j++)
        {
          // Package the adjacency matrix
          package_unsigned_send_data_to_root.push_back(
            local_adjacency_matrix[iproc][i][j]);

        } // for (j < n_nodes)

      } // for (i < n_nodes)

    } // for (iproc < nproc)

    // Define the root processor
    const unsigned root_processor = 0;

    // Get the communicator of the mesh
    OomphCommunicator* comm_pt = this->communicator_pt();

    // Number of data send. from this processor to root processor
    unsigned n_unsigned_data_send_to_root =
      package_unsigned_send_data_to_root.size();

    // Store the number of data to receive from each processor in root
    Vector<int> n_unsigned_data_received_in_root(nproc, 0);

    // Send the number of data that each processor will send to root
    // Gather the info. in the "root_processor"
    MPI_Gather(&n_unsigned_data_send_to_root, // Info. sent from
                                              // each processor
               1, // Total number of data to send from each processor
               MPI_UNSIGNED,
               &n_unsigned_data_received_in_root[0], // Container where
                                                     // to receive the
                                                     // info. from all
                                                     // the processors
               1, // Number of data to receive from each processor
               MPI_UNSIGNED,
               root_processor, // The processor that receives all the
                               // info.
               comm_pt->mpi_comm());

    // Compute the total number of data to receive from all processors
    unsigned n_unsigned_total_data_receive_in_root = 0;
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Add the number of data to receive from each processor
      n_unsigned_total_data_receive_in_root +=
        n_unsigned_data_received_in_root[iproc];
    }

    // Compute the offsets from each processor
    Vector<int> root_unsigned_offsets_receive(nproc, 0);
    root_unsigned_offsets_receive[0] = 0;
    for (unsigned iproc = 1; iproc < nproc; iproc++)
    {
      // Compute the offset to store the values received from each
      // processor
      root_unsigned_offsets_receive[iproc] =
        root_unsigned_offsets_receive[iproc - 1] +
        n_unsigned_data_received_in_root[iproc - 1];
    }

    // Create at least one entry so we don't get a seg fault below
    if (package_unsigned_send_data_to_root.size() == 0)
    {
      package_unsigned_send_data_to_root.resize(1);
    }

    // Vector where to receive the data sent from each processor
    Vector<unsigned> package_unsigned_data_received_root(
      n_unsigned_total_data_receive_in_root);
    if (my_rank != root_processor)
    {
      // Create at least one entry so we don't get a seg fault below
      if (package_unsigned_data_received_root.size() == 0)
      {
        package_unsigned_data_received_root.resize(1);
      }
    } // if (my_rank!=root_processor)

    // Gather the info. from all processors
    MPI_Gatherv(&package_unsigned_send_data_to_root[0], // Flat package
                                                        // to send
                                                        // info. from
                                                        // each
                                                        // processor
                n_unsigned_data_send_to_root, // Total number of data to
                                              // send from each
                                              // processor
                MPI_UNSIGNED,
                &package_unsigned_data_received_root[0], // Container
                                                         // where to
                                                         // receive the
                                                         // info. from
                                                         // all the
                                                         // processors
                &n_unsigned_data_received_in_root[0], // Number of data
                                                      // to receive from
                                                      // each processor
                &root_unsigned_offsets_receive[0], // The offset to
                                                   // store the
                                                   // info. from each
                                                   // processor
                MPI_UNSIGNED,
                root_processor, // The processor that receives all the
                                // info.
                comm_pt->mpi_comm());

    // Store the info. to be sent by root to other processors
    Vector<unsigned> package_unsigned_data_sent_from_root;
    // Total data sent to each processor from root
    Vector<int> n_unsigned_data_sent_from_root(nproc, 0);

    // The root processor now has all the info. regarding the shared
    // nodes and the adjacency matrix of each pair of processors
    if (my_rank == root_processor)
    {
      // Decode the info. received from all processors
      // Counter to decode the info.
      unsigned decode_counter = 0;

      // Store the local alias of the nodes in each processor
      // [x][][][][] iproc
      // [][x][][][] jproc
      // [][][x][][] inode
      // [][][][x][] ialias
      // [][][][][x] alias_data
      Vector<Vector<Vector<Vector<Vector<unsigned>>>>> local_node_alias(nproc);
      // Store the local adjacency matrix of each processor
      Vector<Vector<Vector<Vector<unsigned>>>> local_adjacency_matrix(nproc);

      // Loop over all the processors
      for (unsigned iproc = 0; iproc < nproc; iproc++)
      {
        local_node_alias[iproc].resize(nproc);

        // Resize the local adjacency matrix to store the info. sent
        // from all processors
        local_adjacency_matrix[iproc].resize(nproc);

        if (n_unsigned_data_received_in_root[iproc] > 0)
        {
          // Loop over all the processors to decode the info. received
          // from each one
          for (unsigned jproc = 0; jproc < nproc; jproc++)
          {
            // Read the processor number to which the info. correspond
            const unsigned read_jproc =
              package_unsigned_data_received_root[decode_counter++];

            // The read processor must be the same as the jproc, if that
            // is not the case then there is a synchronisation issue
            if (read_jproc != jproc)
            {
              std::ostringstream error_stream;
              error_stream
                << "The read processor is different from the jproc, this is\n"
                << "a synchronisation issue. The data are not read in the\n"
                << "sameorder as the were packaged\n"
                << "Read processor: (" << read_jproc << ")\n"
                << "Current jproc: (" << jproc << ")\n\n";
              throw OomphLibError(
                error_stream.str(),
                "RefineableTriangleMesh::compute_shared_node_degree_helper()",
                OOMPH_EXCEPTION_LOCATION);
            }

            // Read the number of nodes in the shared boundaries between
            // iproc and jproc
            const unsigned read_n_shd_nodes_iproc_jproc =
              package_unsigned_data_received_root[decode_counter++];

            // Resize the container
            local_node_alias[iproc][jproc].resize(read_n_shd_nodes_iproc_jproc);

            // Loop over the number of nodes shared between iproc and
            // jproc
            for (unsigned ishd = 0; ishd < read_n_shd_nodes_iproc_jproc; ishd++)
            {
              // Read the number of alias of the current ishd node
              const unsigned read_n_alias_node_iproc_jproc =
                package_unsigned_data_received_root[decode_counter++];

              // Resize the container
              local_node_alias[iproc][jproc][ishd].resize(
                read_n_alias_node_iproc_jproc);

              for (unsigned ialias = 0; ialias < read_n_alias_node_iproc_jproc;
                   ialias++)
              {
                // Resize the container, we know there are three data to
                // define the alias of a node
                local_node_alias[iproc][jproc][ishd][ialias].resize(3);

                // The 1st processor with which is shared
                local_node_alias[iproc][jproc][ishd][ialias][0] =
                  package_unsigned_data_received_root[decode_counter++];

                // The 2nd processor with which is shared
                local_node_alias[iproc][jproc][ishd][ialias][1] =
                  package_unsigned_data_received_root[decode_counter++];

                // The index of the node in the interaction iproc-jproc
                local_node_alias[iproc][jproc][ishd][ialias][2] =
                  package_unsigned_data_received_root[decode_counter++];

              } // for (ialias < read_n_alias_node_iproc_jproc)

            } // for (ishd < read_n_shd_nodes_iproc_jproc)

            // Resize the local adjacency matrix
            local_adjacency_matrix[iproc][jproc].resize(
              read_n_shd_nodes_iproc_jproc);
            // Read the adjacency matrix sent to root processor
            for (unsigned i = 0; i < read_n_shd_nodes_iproc_jproc; i++)
            {
              // Resize the local adjacency matrix
              local_adjacency_matrix[iproc][jproc][i].resize(
                read_n_shd_nodes_iproc_jproc);
              for (unsigned j = 0; j < read_n_shd_nodes_iproc_jproc; j++)
              {
                // Read the adjacency matrix entry
                local_adjacency_matrix[iproc][jproc][i][j] =
                  package_unsigned_data_received_root[decode_counter++];
              } // for (j < read_n_shd_nodes_iproc_jproc)

            } // for (i < read_n_shd_nodes_iproc_jproc)

          } // for (jproc < nproc)

        } // for (iproc < nproc)

      } // for (iproc < nproc)

#ifdef PARANOID
      if (decode_counter != n_unsigned_total_data_receive_in_root)
      {
        std::ostringstream error_stream;
        error_stream
          << "The number of data decoded in root received from others\n"
          << "processors is different from the total number of data received\n"
          << "Data decoded: (" << decode_counter << ")\n"
          << "Data received: (" << n_unsigned_total_data_receive_in_root
          << ")\n\n"
          << "This is a synchronisation issue so you are probably sending\n"
          << "more or less info. than the one that is being decoded\n\n";
        throw OomphLibError(
          error_stream.str(),
          "RefineableTriangleMesh::compute_shared_node_degree_helper()",
          OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Assign a unique id to the nodes (uses the alias information to
      // identify the repetition of a node in other processors). The
      // global node id is given by the position (index) in the global
      // node alias

      // Keep track of those alias already assigned a unique id
      std::map<Vector<unsigned>, bool> alias_done;

      // Store all the alias associated to each node
      Vector<Vector<Vector<unsigned>>> global_node_alias;

      // Loop over all the processors
      for (unsigned iproc = 0; iproc < nproc; iproc++)
      {
        for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
        {
          // Read the number of nodes shared between the processors
          const unsigned n_shd_nodes_iproc_jproc =
            local_node_alias[iproc][jproc].size();
#ifdef PARANOID
          // Read the number of nodes shared in the other direction
          const unsigned n_shd_nodes_jproc_iproc =
            local_node_alias[jproc][iproc].size();

          if (n_shd_nodes_iproc_jproc != n_shd_nodes_jproc_iproc)
          {
            std::ostringstream error_stream;
            error_stream
              << "The number of nodes shared between iproc and jproc is\n"
              << "different from the number of nodes shared between jproc\n"
              << "and iproc\n"
              << "Nodes shared between processor (" << iproc << ") and "
              << "processor (" << jproc << "): (" << n_shd_nodes_iproc_jproc
              << ")\n"
              << "Nodes shared between processor (" << jproc << ") and "
              << "processor (" << iproc << "): (" << n_shd_nodes_jproc_iproc
              << ")\n\n";
            throw OomphLibError(
              error_stream.str(),
              "RefineableTriangleMesh::compute_shared_node_degree_helper()",
              OOMPH_EXCEPTION_LOCATION);
          } // if (n_shd_nodes_iproc_jproc != n_shd_nodes_jproc_iproc)
#endif

          // Loop over the nodes shared between the processors
          for (unsigned ishd = 0; ishd < n_shd_nodes_iproc_jproc; ishd++)
          {
            // Get the number of alias associated to the node on each
            // processor
            const unsigned n_alias_iproc_jproc =
              local_node_alias[iproc][jproc][ishd].size();
            const unsigned n_alias_jproc_iproc =
              local_node_alias[jproc][iproc][ishd].size();

            // Store all the found alias to the node
            Vector<Vector<unsigned>> node_alias;

            // Flag to indicate if a new alias has been added
            bool new_alias_added = false;

            // Start by adding the "direct" alias of the node
            for (unsigned ialias = 0; ialias < n_alias_iproc_jproc; ialias++)
            {
              // Get the alias of the node
              Vector<unsigned> current_alias =
                local_node_alias[iproc][jproc][ishd][ialias];
              // Check if already done
              if (!alias_done[current_alias])
              {
                // Add the alias of the node
                node_alias.push_back(current_alias);
                // Set the flag to indicate a new alias has been added
                new_alias_added = true;
                // Mark the alias as done
                alias_done[current_alias] = true;
              } // if (!alias_done[i_alias])

            } // for (ialias < n_alias_iproc_jproc)

            // Start by adding the "direct" alias of the node
            for (unsigned ialias = 0; ialias < n_alias_jproc_iproc; ialias++)
            {
              // Get the alias of the node
              Vector<unsigned> current_alias =
                local_node_alias[jproc][iproc][ishd][ialias];

              // Check if already done
              if (!alias_done[current_alias])
              {
                // Add the alias of the node
                node_alias.push_back(current_alias);
                // Set the flag to indicate a new alias has been added
                new_alias_added = true;
                // Mark the alias as done
                alias_done[current_alias] = true;
              } // if (!alias_done[i_alias])

            } // for (ialias < n_alias_jproc_iproc)

            unsigned counter_alias = 0;
            // Visit the alias of the node and add any new found
            // alias, end until all its alias have been included

            unsigned n_current_alias = node_alias.size();
            while (new_alias_added || counter_alias < n_current_alias)
            // while(new_alias_added) // we need to check all the alias,
            // including those added during the process
            {
              new_alias_added = false;
              // Store the current visited alias
              Vector<unsigned> current_alias = node_alias[counter_alias];

              // Get the alias associated with the current alias
              Vector<Vector<unsigned>> alias_of_current_alias =
                local_node_alias[current_alias[0]][current_alias[1]]
                                [current_alias[2]];

              // Get all the alias associated with the alias of the
              // current alias
              const unsigned n_alias = alias_of_current_alias.size();

              // Loop over the new alias and check if require to add
              // them
              for (unsigned k = 0; k < n_alias; k++)
              {
                // Get the alias of the node
                Vector<unsigned> add_alias = alias_of_current_alias[k];

                // Check if already done
                if (!alias_done[add_alias])
                {
                  // Add the alias of the node
                  node_alias.push_back(add_alias);
                  // Set the flag to indicate a new alias has been
                  // added
                  new_alias_added = true;
                  // Mark the alias ad done
                  alias_done[add_alias] = true;
                } // if (!alias_done[i_alias])

              } // for (k < n_alias)

              // Get the alias associated with the current alias (in the
              // other direction)
              Vector<Vector<unsigned>> alias_of_current_alias2 =
                local_node_alias[current_alias[1]][current_alias[0]]
                                [current_alias[2]];

              // Get all the alias associated with the current alias
              // (in the other direction)
              const unsigned n_alias2 = alias_of_current_alias2.size();

              // Loop over the new alias and check if require to add
              // them
              for (unsigned k = 0; k < n_alias2; k++)
              {
                // Get the alias of the node
                Vector<unsigned> add_alias = alias_of_current_alias2[k];

                // Check if already done
                if (!alias_done[add_alias])
                {
                  // Add the alias of the node
                  node_alias.push_back(add_alias);
                  // Set the flag to indicate a new alias has been
                  // added
                  new_alias_added = true;
                  // Mark the alias ad done
                  alias_done[add_alias] = true;
                } // if (!alias_done[i_alias])

              } // for (k < n_alias)

              // Go for the next alias
              counter_alias++;

              // Update the number of alias so that the while stops when
              // all the alias have been visited and no new alias was
              // added
              n_current_alias = node_alias.size();

            } // while(new_alias_added || counter_alias < n_current_alias)

            // If the node has not been previously added, then include
            // all its alias
            if (node_alias.size() > 0)
            {
              // Add all the found alias of the node to the global alias
              // storage
              global_node_alias.push_back(node_alias);
            }

          } // for (ishd < n_shd_nodes_iproc_jproc)

        } // for (jproc < nproc)

      } // for (iproc < nproc)

      // We now have the global number of nodes, each with its own id
      // (the index in the global_node_alias vector)

      // Get the number of global shared nodes
      const unsigned n_global_shared_nodes = global_node_alias.size();

      // Create matrix from local to global shared node id
      Vector<Vector<Vector<int>>> local_to_global_shared_node(nproc);

      // Loop over all the processors to resize
      for (unsigned iproc = 0; iproc < nproc; iproc++)
      {
        // Resize the map matrix
        local_to_global_shared_node[iproc].resize(nproc);
      } // for (iproc < nproc)

      // Loop over all the processors to resize (the third direction,
      // required if we want to loop over the half of the matrix only)
      for (unsigned iproc = 0; iproc < nproc; iproc++)
      {
        // Loop over the half of the matrix to resize
        for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
        {
          // Read the number of nodes shared between the processors
          const unsigned n_shd_nodes = local_node_alias[iproc][jproc].size();

          // Resize the map matrix
          local_to_global_shared_node[iproc][jproc].resize(n_shd_nodes, -1);

          // ... and resize the other half map matrix
          local_to_global_shared_node[jproc][iproc].resize(n_shd_nodes, -1);

        } // for (jproc < nproc)

      } // for (iproc < nproc)

      // Fill the matrix for mapping from local to global node id

      // Loop over the global nodes, and for each alias assign the
      // corresponding global node id
      for (unsigned k = 0; k < n_global_shared_nodes; k++)
      {
        // Get the number of alias associated to the current global node
        const unsigned n_alias_global_node = global_node_alias[k].size();
        // Loop over the alias and assign the global node id
        for (unsigned l = 0; l < n_alias_global_node; l++)
        {
          // Get the 1st processor
          const unsigned iproc = global_node_alias[k][l][0];
          // Get the 2nd processor
          const unsigned jproc = global_node_alias[k][l][1];
          // Get the node number
          const unsigned ishd = global_node_alias[k][l][2];
          // Assign the global node id
          local_to_global_shared_node[iproc][jproc][ishd] = k;

        } // for (l < n_alias_global_node)

      } // for (k < n_global_shared_nodes)

      // Create the global adjacency matrix
      Vector<Vector<unsigned>> global_adjacency_matrix(n_global_shared_nodes);
      // Resize the global adjacency matrix
      for (unsigned k = 0; k < n_global_shared_nodes; k++)
      {
        // Resize
        global_adjacency_matrix[k].resize(n_global_shared_nodes, 0);
      } // for (k < n_global_shared_nodes)

      // Add the entries to the global adjacency matrix and compute the
      // degree of each node

      // Store the degree of the global nodes
      Vector<unsigned> global_node_degree(n_global_shared_nodes, 0);

      // Loop over the processors
      for (unsigned iproc = 0; iproc < nproc; iproc++)
      {
        // Loop over the half of the matrix to resize
        for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
        {
          // Get the number of nodes shared between the processors
          const unsigned n_shd_nodes = local_node_alias[iproc][jproc].size();

          // Search for entries in the local adjacency matrix that set a
          // connection among the nodes

          // Loop over the shared nodes in the current pair of
          // processors
          for (unsigned ishd = 0; ishd < n_shd_nodes; ishd++)
          {
            for (unsigned jshd = ishd + 1; jshd < n_shd_nodes; jshd++)
            {
              // Are the nodes associated
              if (local_adjacency_matrix[iproc][jproc][ishd][jshd] > 0)
              {
                // Get the global nodes id

                // Get the "left-node" global id
                const int global_shd_node_left =
                  local_to_global_shared_node[iproc][jproc][ishd];

                // Get the "right-node" global id
                const int global_shd_node_right =
                  local_to_global_shared_node[iproc][jproc][jshd];

#ifdef PARANOID
                // Check if the local nodes have a global node
                // associated
                if (global_shd_node_left == -1)
                {
                  std::ostringstream error_stream;
                  error_stream
                    << "The local node in processors iproc and jproc has no\n"
                    << "global node assigned\n"
                    << "iproc processor: (" << iproc << ")\n"
                    << "jproc processor: (" << jproc << ")\n"
                    << "Local node: (" << ishd << ")\n\n";
                  throw OomphLibError(error_stream.str(),
                                      "RefineableTriangleMesh::compute_shared_"
                                      "node_degree_helper()",
                                      OOMPH_EXCEPTION_LOCATION);
                }

                // Check if the local nodes have a global node
                // associated
                if (global_shd_node_right == -1)
                {
                  std::ostringstream error_stream;
                  error_stream
                    << "The local node in processors iproc and jproc has no\n"
                    << "global node assigned\n"
                    << "iproc processor: (" << iproc << ")\n"
                    << "jproc processor: (" << jproc << ")\n"
                    << "Local node: (" << jshd << ")\n\n";
                  throw OomphLibError(error_stream.str(),
                                      "RefineableTriangleMesh::compute_shared_"
                                      "node_degree_helper()",
                                      OOMPH_EXCEPTION_LOCATION);
                }
#endif
                // Get the unsigned version of the indexes
                const unsigned uleft =
                  static_cast<unsigned>(global_shd_node_left);
                const unsigned uright =
                  static_cast<unsigned>(global_shd_node_right);

                // Add the entry in the global adjacency matrix
                global_adjacency_matrix[uleft][uright]++;

                // ... and in the other direction too
                global_adjacency_matrix[uright][uleft]++;

                // Add on to the degree of the left node
                global_node_degree[uleft]++;

                // Add on to the degree of the right node
                global_node_degree[uright]++;

              } // if (local_adjacency_matrix[iproc][jproc][ishd][jshd] > 0)

            } // // for (jshd < n_shd_nodes)

          } // for (ishd < n_shd_nodes)

        } // for (jproc < nproc)

      } // for (iproc < nproc)

      // Assign the global degree to the shared nodes between each pair
      // of processors
      Vector<Vector<Vector<unsigned>>> root_local_node_degree(nproc);
      // Resize the container
      for (unsigned iproc = 0; iproc < nproc; iproc++)
      {
        root_local_node_degree[iproc].resize(nproc);
      }

      // Loop over the processors and visited their shared nodes
      for (unsigned iproc = 0; iproc < nproc; iproc++)
      {
        // Only visit the half of the data
        for (unsigned jproc = iproc + 1; jproc < nproc; jproc++)
        {
          // Get the number of shared nodes between this pair of
          // processors (iproc, jproc)
          const unsigned n_shd_nodes = local_node_alias[iproc][jproc].size();

          // Resize the container to store the local degree of the nodes
          root_local_node_degree[iproc][jproc].resize(n_shd_nodes);
          // ... and in the other way too
          root_local_node_degree[jproc][iproc].resize(n_shd_nodes);

          // Loop over the number of nodes shared between the pair of
          // processors
          for (unsigned ishd = 0; ishd < n_shd_nodes; ishd++)
          {
            // Get the global node id for the current shared node
            const int global_shd_node_id =
              local_to_global_shared_node[iproc][jproc][ishd];

#ifdef PARANOID
            // Check if the local nodes have a global node associated
            if (global_shd_node_id == -1)
            {
              std::ostringstream error_stream;
              error_stream
                << "The local node in processors iproc and jproc has no\n"
                << "global node assigned\n"
                << "iproc processor: (" << iproc << ")\n"
                << "jproc processor: (" << jproc << ")\n"
                << "Local node: (" << ishd << ")\n\n";
              throw OomphLibError(
                error_stream.str(),
                "RefineableTriangleMesh::compute_shared_node_degree_helper()",
                OOMPH_EXCEPTION_LOCATION);
            }
#endif

            // Get the unsigned version of the global index
            const unsigned uglobal_shd_node_id =
              static_cast<unsigned>(global_shd_node_id);

            // Get the degree of the node
            const unsigned node_degree =
              global_node_degree[uglobal_shd_node_id];

            // Set the degree in the container for the degree of the
            // nodes in the local interaction between processors
            root_local_node_degree[iproc][jproc][ishd] = node_degree;
            // ... and in the other way too
            root_local_node_degree[jproc][iproc][ishd] = node_degree;

          } // for (ishd < n_shd_nodes)

        } // for (jproc < nproc)

      } // for (iproc < nproc)

      // Clear the container where the info. will be sent back to each
      // processor
      package_unsigned_data_sent_from_root.clear();

      // Prepare the data to sent it back to each processor (encode the
      // info. to sent to all processors)
      for (unsigned iproc = 0; iproc < nproc; iproc++)
      {
        // Count the number of data sent to iproc processor
        unsigned count_n_data_sent_to_iproc = 0;
        for (unsigned jproc = 0; jproc < nproc; jproc++)
        {
          // No shared nodes between the same processor
          if (iproc != jproc)
          {
            // Get the number of nodes shared between the processors
            const unsigned n_shd_nodes =
              root_local_node_degree[iproc][jproc].size();

            // Add the number of data sent to iproc processor
            count_n_data_sent_to_iproc += n_shd_nodes;

            // Loop over the nodes shared between the pair of processors
            for (unsigned ishd = 0; ishd < n_shd_nodes; ishd++)
            {
              package_unsigned_data_sent_from_root.push_back(
                root_local_node_degree[iproc][jproc][ishd]);
            } // for (ishd < n_shd_nodes)

          } // if (iproc != jproc)

        } // for (jproc < nproc)

        // Set the number of data sent to iproc processor
        n_unsigned_data_sent_from_root[iproc] = count_n_data_sent_to_iproc;

      } // for (iproc < nproc)

    } // if (my_rank == root_processor)

    // Total data received from root to this processor
    int n_unsigned_data_received_from_root = 0;

    // Get the number of data that each processor receives from root
    MPI_Scatter(&n_unsigned_data_sent_from_root[0], // Info. sent from
                                                    // root to each
                                                    // processor
                1, // The number of data sent from root to each
                   // processor
                MPI_UNSIGNED,
                &n_unsigned_data_received_from_root, // Store the
                                                     // info. received
                                                     // from root
                1, // The number of data received from root
                MPI_UNSIGNED,
                root_processor, // The processor that sends the
                                // info.
                comm_pt->mpi_comm());

    // Receive the info. sent by root
    Vector<unsigned> package_unsigned_data_received_from_root(
      n_unsigned_data_received_from_root);

    // Compute the offsets to each processor
    Vector<int> root_unsigned_offsets_sent(nproc, 0);
    root_unsigned_offsets_sent[0] = 0;
    for (unsigned iproc = 1; iproc < nproc; iproc++)
    {
      // Compute the offset to send the values to each processor
      root_unsigned_offsets_sent[iproc] =
        root_unsigned_offsets_sent[iproc - 1] +
        n_unsigned_data_sent_from_root[iproc - 1];
    }

    if (my_rank != root_processor)
    {
      // Create at least one entry so we don't get a seg fault below
      if (package_unsigned_data_sent_from_root.size() == 0)
      {
        package_unsigned_data_sent_from_root.resize(1);
      }
    } // if (my_rank!=root_processor)

    // Create at least one entry so we don't get a seg fault below
    if (package_unsigned_data_received_from_root.size() == 0)
    {
      package_unsigned_data_received_from_root.resize(1);
    }

    // Get the data from root
    MPI_Scatterv(&package_unsigned_data_sent_from_root[0], // The
                                                           // info. sent
                                                           // from root
                                                           // to others
                                                           // processors
                 &n_unsigned_data_sent_from_root[0], // The number of
                                                     // data sent from
                                                     // root to others
                                                     // processors
                 &root_unsigned_offsets_sent[0], // The offsets to each
                                                 // processors
                 MPI_UNSIGNED,
                 &package_unsigned_data_received_from_root[0], // The
                                                               // storage
                                                               // in the
                                                               // processor
                                                               // that
                                                               // receives
                                                               // the
                                                               // info.
                 n_unsigned_data_received_from_root, // The number of
                                                     // data that the
                                                     // current
                                                     // processor
                                                     // receives from
                                                     // root
                 MPI_UNSIGNED,
                 root_processor, // The root processors
                 comm_pt->mpi_comm());

    // Decode the info.

    // Keep track of the already nodes done
    std::map<Node*, bool> node_done;

    // Read the global degree assigned to the shared nodes between the
    // current processors and the other processors
    int decode_counter = 0;
    // Store the global degree of the local nodes
    Vector<Vector<unsigned>> local_node_degree(nproc);
    // Loop over the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // There are no shared nodes with the current processor itself
      if (iproc != my_rank)
      {
        // Get the number of nodes shared with the iproc processor
        const unsigned n_nodes = tmp_sorted_shared_node_pt[iproc].size();

        // Read the global degree of the node
        package_unsigned_send_data_to_root.push_back(n_nodes);

        // Loop over the nodes
        for (unsigned ishd = 0; ishd < n_nodes; ishd++)
        {
          // Get the node degree assigned to the ishd node in between
          // the interaction of the iproc and the current processor
          const unsigned node_degree =
            package_unsigned_data_received_from_root[decode_counter++];

          // Get the node
          Node* shd_node_pt = tmp_sorted_shared_node_pt[iproc][ishd];

          // Has the node been assigned a global degree
          if (!node_done[shd_node_pt])
          {
            // Assign the global degree to the node
            global_node_degree[shd_node_pt] = node_degree;
            // Mark the node as done
            node_done[shd_node_pt] = true;
          }
#ifdef PARANOID
          else
          {
            // The node has been already done, check that the node
            // degree is the same as the already assigned
            if (global_node_degree[shd_node_pt] != node_degree)
            {
              std::ostringstream error_stream;
              error_stream
                << "The local node has already assigned a global degree,\n"
                << "however, a different degree for the same node has been\n"
                << "read from the data sent from root processor\n"
                << "iproc processor: (" << iproc << ")\n"
                << "Local node: (" << ishd << ")\n"
                << "---------------------------------------------------------\n"
                << "Already assigned degree: ("
                << global_node_degree[shd_node_pt] << ")\n"
                << "New found degree: (" << node_degree << ")\n"
                << "---------------------------------------------------------\n"
                << "Node coordinates: (" << shd_node_pt->x(0) << ", "
                << shd_node_pt->x(1) << ")\n\n";
              throw OomphLibError(
                error_stream.str(),
                "RefineableTriangleMesh::compute_shared_node_degree_helper()",
                OOMPH_EXCEPTION_LOCATION);
            }

          } // else if (!node_done[shd_node_pt])
#endif // #ifdef PARANOID

        } // for (ishd < n_nodes)

      } // if (iproc != my_rank)

    } // for (iproc < nproc)

#ifdef PARANOID
    // Ensure that all the info. sent from root processor has been read
    if (decode_counter != n_unsigned_data_received_from_root)
    {
      std::ostringstream error_stream;
      error_stream
        << "The number of data decoded received from root processor is\n"
        << "different from the total number of data received from the root\n"
        << "processor\n"
        << "Data decoded: (" << decode_counter << ")\n"
        << "Data received: (" << n_unsigned_data_received_from_root << ")\n\n"
        << "This is a synchronisation issue so you are probably sending\n"
        << "more or less info. than the one that is being decoded\n\n";
      throw OomphLibError(
        error_stream.str(),
        "RefineableTriangleMesh::compute_shared_node_degree_helper()",
        OOMPH_EXCEPTION_LOCATION);
    }
#endif
  }

  //======================================================================
  // Sort the nodes on the new shared boundaries (after load balancing),
  // computes the alias of the nodes and creates the adjacency matrix
  // that represent the graph created by the shared edges between each
  // pair of processors
  // ======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::
    create_adjacency_matrix_new_shared_edges_helper(
      Vector<Vector<FiniteElement*>>& unsorted_face_ele_pt,
      Vector<Vector<Node*>>& tmp_sorted_shared_node_pt,
      std::map<Node*, Vector<Vector<unsigned>>>& node_alias,
      Vector<Vector<Vector<unsigned>>>& adjacency_matrix)
  {
    // Get the number of processors and the rank
    const unsigned nproc = this->communicator_pt()->nproc();
    const unsigned my_rank = this->communicator_pt()->my_rank();

    // Assign a unique id to each node shared between each pair of
    // processors, in this case the current processor and the iproc

    // ... also compute the alias of each node (processor and index of
    // the node in all processors where it appears)

    // Clear the alias info
    node_alias.clear();

    // Temporary storage for the index of the nodes
    Vector<std::map<Node*, unsigned>> tmp_node_index(nproc);

    // Loop over the processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // There is no shared elements between the same processor
      if (iproc != my_rank)
      {
        // Map to mark those nodes already visited
        std::map<Node*, bool> done_node;

        // A map is used to sort the nodes using their coordinates as
        // the key of the map
        // std::map<std::pair<double, double>, Node*> sorted_nodes_pt;
        std::map<std::pair<double, double>, Node*, classcomp> sorted_nodes_pt;

        // Get the number of unsorted face elements
        const unsigned n_unsorted_face_ele = unsorted_face_ele_pt[iproc].size();

        // Loop over the unsorted elements
        for (unsigned e = 0; e < n_unsorted_face_ele; e++)
        {
          // Get a root element
          FiniteElement* face_ele_pt = unsorted_face_ele_pt[iproc][e];
          // Get the left node of the face element
          Node* left_node_pt = face_ele_pt->node_pt(0);

          // Check if the node has been already sorted in the
          // interaction between the current processor and iproc
          // processor
          if (!done_node[left_node_pt])
          {
            std::pair<double, double> vertex =
              std::make_pair(left_node_pt->x(0), left_node_pt->x(1));
            sorted_nodes_pt[vertex] = left_node_pt;
            // Mark the node as done
            done_node[left_node_pt] = true;
          }

          // Get the number of nodes of the face element
          const unsigned n_nodes = face_ele_pt->nnode();
          // Get the right node of the face element
          Node* right_node_pt = face_ele_pt->node_pt(n_nodes - 1);

          // Check if the node has been already sorted in the
          // interaction between the current processor and iproc
          // processor
          if (!done_node[right_node_pt])
          {
            std::pair<double, double> vertex =
              std::make_pair(right_node_pt->x(0), right_node_pt->x(1));
            sorted_nodes_pt[vertex] = right_node_pt;
            // Mark the node as done
            done_node[right_node_pt] = true;
          }

        } // for (e < nunsorted_face_ele)

        // The nodes are already sorted, we need to return them in the
        // proper container

        // The counter to enumerate the nodes
        unsigned counter = 0;

        // Go through the map container which already have the nodes
        // sorted they have the same sorting on all processors
        for (std::map<std::pair<double, double>, Node*>::iterator it =
               sorted_nodes_pt.begin();
             it != sorted_nodes_pt.end();
             it++)
        {
          // Get the node
          Node* node_pt = (*it).second;
          // Store the node at the corresponding index
          tmp_sorted_shared_node_pt[iproc].push_back(node_pt);

          // Create the temporary access to the node index
          tmp_node_index[iproc][node_pt] = counter;

          // Fill the info. for the node alias
          Vector<unsigned> alias(3);
          // The current processor
          alias[0] = my_rank;
          // The processor with which is shared
          alias[1] = iproc;
          // The index with that processor
          alias[2] = counter++;

          // Store the info. of the alias
          node_alias[node_pt].push_back(alias);

        } // Loop map

      } // if (iproc != my_rank)

    } // for (iproc < nproc)

    // Loop over the processors to resize and initialize the adjacency
    // matrix
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Get the number of nodes shared with iproc
      const unsigned n_shd_nodes = tmp_sorted_shared_node_pt[iproc].size();
      // Resize the adjacency matrix
      adjacency_matrix[iproc].resize(n_shd_nodes);
      for (unsigned i = 0; i < n_shd_nodes; i++)
      {
        // Resize the adjacency matrix
        adjacency_matrix[iproc][i].resize(n_shd_nodes);

        // Initialize the
        for (unsigned j = 0; j < n_shd_nodes; j++)
        {
          adjacency_matrix[iproc][i][j] = 0;
        } // for (j < n_shd_nodes)

      } // for (i < n_shd_nodes)

    } // for (iproc < nproc)

    // Loop over the processors to fill the adjacency matrix
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // There is no shared elements between the same processor
      if (iproc != my_rank)
      {
        // Get the number of unsorted face elements
        const unsigned n_unsorted_face_ele = unsorted_face_ele_pt[iproc].size();

        // Loop over the unsorted elements
        for (unsigned e = 0; e < n_unsorted_face_ele; e++)
        {
          // Get a root element
          FiniteElement* face_ele_pt = unsorted_face_ele_pt[iproc][e];
          // Get the left node of the face element
          Node* left_node_pt = face_ele_pt->node_pt(0);

          // Get the number of nodes of the face element
          const unsigned n_nodes = face_ele_pt->nnode();
          // Get the right node of the face element
          Node* right_node_pt = face_ele_pt->node_pt(n_nodes - 1);

          // Get the index of each of the nodes
          const unsigned left_node_index = tmp_node_index[iproc][left_node_pt];
          const unsigned right_node_index =
            tmp_node_index[iproc][right_node_pt];

          // Add an entry to the adjacency matrix to indicate the
          // association of left and right node
          adjacency_matrix[iproc][left_node_index][right_node_index]++;
          // ... both directions
          adjacency_matrix[iproc][right_node_index][left_node_index]++;

        } // for (e < n_unsorted_face_ele)

      } // if (iproc != my_rank)

    } // for (iproc < nproc)
  }

  //======================================================================
  /// Get the nodes on the shared boundary (b), these are stored
  /// in the segment they belong
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::
    get_shared_boundary_segment_nodes_helper(
      const unsigned& shd_bnd_id, Vector<Vector<Node*>>& tmp_segment_nodes)
  {
    // Clear the data structure were to return the nodes
    tmp_segment_nodes.clear();

    // Get the face elements that created the shared boundary from the
    // bulk shared boundary elements

#ifdef PARANOID
    // The temporary storage for the halo face elements
    Vector<FiniteElement*> halo_shared_face_ele_pt;
#endif
    // The temporary storage for the nonhalo face elements
    Vector<FiniteElement*> nonhalo_shared_face_ele_pt;

    // Get the number of shared boundary elements associated with the
    // current shared boundary
    const unsigned nshared_bound_ele =
      this->nshared_boundary_element(shd_bnd_id);

    // Loop over the elements in the shared boundary to create the face
    // elements
    for (unsigned e = 0; e < nshared_bound_ele; e++)
    {
      // Get the shared boundary element
      FiniteElement* bulk_ele_pt =
        this->shared_boundary_element_pt(shd_bnd_id, e);

      // Get the face index
      int face_index = this->face_index_at_shared_boundary(shd_bnd_id, e);

      // Before adding the new element we need to ensure that the edge
      // that this element represents has not been already added
      FiniteElement* face_ele_pt =
        new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);

      // Nonhalo element
      if (!bulk_ele_pt->is_halo())
      {
        // Add nonhalo shared face element to the container
        nonhalo_shared_face_ele_pt.push_back(face_ele_pt);
      }
#ifdef PARANOID
      else // halo element
      {
        // Add halo shared face element to the container
        halo_shared_face_ele_pt.push_back(face_ele_pt);
      }
#endif

    } // for (e < nshared_bound_ele)

    // Mark the face elements already used
    std::map<FiniteElement*, bool> shared_face_done;

    // Get the number of nonhalo face elements
    const unsigned nnonhalo_face_shared_ele = nonhalo_shared_face_ele_pt.size();

    // If we are in PARANOID mode check that there is one halo element
    // for each nonhalo element
#ifdef PARANOID
    // Get the number of halo face elements
    const unsigned nhalo_face_shared_ele = halo_shared_face_ele_pt.size();

    // The number of nonhalo shared face boundary elements must be the
    // half of the total number of shared boundary elements
    if (nshared_bound_ele / 2 != nnonhalo_face_shared_ele)
    {
      std::ostringstream error_message;
      error_message
        << "The number of shared boundary elements (" << nshared_bound_ele
        << ") is not the double\nof the number of unsorted nonhalo shared "
        << "face boundary elements (" << nnonhalo_face_shared_ele
        << ")\n for the current boundary (" << shd_bnd_id << ")\n\n";
      throw OomphLibError(
        error_message.str(),
        "RefineableTriangleMesh::get_shared_boundary_segment_nodes_helper()",
        OOMPH_EXCEPTION_LOCATION);
    }

    // The number of halo shared face boundary elements must be the
    // half of the total number of shared boundary elements
    if (nshared_bound_ele / 2 != nhalo_face_shared_ele)
    {
      std::ostringstream error_message;
      error_message
        << "The number of shared boundary elements (" << nshared_bound_ele
        << ") is not the double\nof the number of unsorted halo shared "
        << "face boundary elements (" << nhalo_face_shared_ele
        << ")\n for the current boundary (" << shd_bnd_id << ")\n\n";
      throw OomphLibError(
        error_message.str(),
        "RefineableTriangleMesh::get_shared_boundary_segment_nodes_helper()",
        OOMPH_EXCEPTION_LOCATION);
    }

    // ------------------------------------------------------------------
    // Loop over the nonhalo face elements and look for the halo face
    // element at the other side of the shared boundary
    for (unsigned inh = 0; inh < nnonhalo_face_shared_ele; inh++)
    {
      // Get the inh-th face element
      FiniteElement* nonhalo_face_ele_pt = nonhalo_shared_face_ele_pt[inh];

      // Get the number of nodes on the face element
      const unsigned nnodes_nh = nonhalo_face_ele_pt->nnode();
      // Get the first and last node on the element
      Node* nh_first_node_pt = nonhalo_face_ele_pt->node_pt(0);
      Node* nh_last_node_pt = nonhalo_face_ele_pt->node_pt(nnodes_nh - 1);

      // Now find the (halo) face element at the other side of the
      // shared boundary
      for (unsigned ih = 0; ih < nhalo_face_shared_ele; ih++)
      {
        // Get the ih-th face element
        FiniteElement* halo_face_ele_pt = halo_shared_face_ele_pt[ih];

        // Check that the face element has not been done
        if (!shared_face_done[halo_face_ele_pt])
        {
          // Get the number of nodes on the face element
          const unsigned nnodes_h = halo_face_ele_pt->nnode();
          // Get the first and last node on the element
          Node* h_first_node_pt = halo_face_ele_pt->node_pt(0);
          Node* h_last_node_pt = halo_face_ele_pt->node_pt(nnodes_h - 1);

          // If the nodes are the same then we have found the (halo)
          // face element at the other side of the shared boundary
          if (nh_first_node_pt == h_first_node_pt &&
              nh_last_node_pt == h_last_node_pt)
          {
            // Mark the face elements as done
            shared_face_done[nonhalo_face_ele_pt] = true;
            shared_face_done[halo_face_ele_pt] = true;

            // Break the loop for (ih < nhalo_face_shared_ele)
            break;
          } // if (nh_first_node_pt == h_first_node_pt &&
            //     nh_last_node_pt == h_last_node_pt)
          else if (nh_first_node_pt == h_last_node_pt &&
                   nh_last_node_pt == h_first_node_pt)
          {
            // Mark the face elements as done
            shared_face_done[nonhalo_face_ele_pt] = true;
            shared_face_done[halo_face_ele_pt] = true;

            // Break the loop for (ih < nhalo_face_shared_ele)
            break;
          } // else if (nh_first_node_pt == h_last_node_pt &&
            //          nh_last_node_pt == h_first_node_pt)

        } // if (face_done[halo_face_ele_pt])

      } // for (ih < nhalo_face_shared_ele)

    } // for (inh < nnonhalo_face_shared_ele)

    // The number of done shared face elements MUST be the same as the
    // sum of the nonhalo and halo shared boundary face elements
    if ((nnonhalo_face_shared_ele + nhalo_face_shared_ele) !=
        shared_face_done.size())
    {
      std::ostringstream error_message;
      error_message << "The number of DONE shared boundary face elements ("
                    << shared_face_done.size()
                    << ") is not the same\n as the sum of"
                    << "the nonhalo face shared boundary elements ("
                    << nnonhalo_face_shared_ele
                    << ")\nand the halo face shared "
                    << "boundary elements (" << nhalo_face_shared_ele
                    << ") for the\n/"
                    << "current boundary (" << shd_bnd_id << ")\n\n";
      throw OomphLibError(
        error_message.str(),
        "RefineableTriangleMesh::get_shared_boundary_segment_nodes_helper()",
        OOMPH_EXCEPTION_LOCATION);
    }
#endif // #ifdef PARANOID

    // -------------------------------------------------------------
    // Now sort the face elements
    // -------------------------------------------------------------

    // We already have the shared face elements that make the shared
    // boundary now sort them to create a contiguous boundary

    // Clear the already done face elements
    shared_face_done.clear();

    unsigned nsorted_face_ele = 0;

    // Storing for the sorting nodes extracted from the face elements
    std::list<Node*> sorted_nodes;

    // Get the root face element
    FiniteElement* root_face_ele_pt = nonhalo_shared_face_ele_pt[0];
    nsorted_face_ele++;

    // Mark face as done
    shared_face_done[root_face_ele_pt] = true;

    // The initial and final node on the list
    const unsigned nnodes_root = root_face_ele_pt->nnode();
    Node* first_node_pt = root_face_ele_pt->node_pt(0);
    Node* last_node_pt = root_face_ele_pt->node_pt(nnodes_root - 1);

    // Push back on the list the new nodes
    sorted_nodes.push_back(first_node_pt);
    sorted_nodes.push_back(last_node_pt);

    // Sort the face elements
    while (nsorted_face_ele < nnonhalo_face_shared_ele)
    {
      // Flag to indicate when a node was added
      bool node_added = false;

      // Start from the next edge since we have already added the
      // previous one as the initial face element
      for (unsigned iface = 1; iface < nnonhalo_face_shared_ele; iface++)
      {
        FiniteElement* tmp_shared_face_ele_pt =
          nonhalo_shared_face_ele_pt[iface];

        // If face has not been sorted
        if (!shared_face_done[tmp_shared_face_ele_pt])
        {
          // Get the number of nodes for the current face element
          const unsigned tmp_nnodes = tmp_shared_face_ele_pt->nnode();

          // Get each individual node
          Node* left_node_pt = tmp_shared_face_ele_pt->node_pt(0);
          Node* right_node_pt = tmp_shared_face_ele_pt->node_pt(tmp_nnodes - 1);

          if (left_node_pt == first_node_pt)
          {
            // Push front the new node
            sorted_nodes.push_front(right_node_pt);
            first_node_pt = right_node_pt;
            node_added = true;
          }
          else if (left_node_pt == last_node_pt)
          {
            // Push back the new node
            sorted_nodes.push_back(right_node_pt);
            last_node_pt = right_node_pt;
            node_added = true;
          }
          else if (right_node_pt == first_node_pt)
          {
            // Push front the new node
            sorted_nodes.push_front(left_node_pt);
            first_node_pt = left_node_pt;
            node_added = true;
          }
          else if (right_node_pt == last_node_pt)
          {
            // Push back the new node
            sorted_nodes.push_back(left_node_pt);
            last_node_pt = left_node_pt;
            node_added = true;
          }

          if (node_added)
          {
            // Mark as done only if one of its nodes has been added to
            // the list
            shared_face_done[tmp_shared_face_ele_pt] = true;
            nsorted_face_ele++;

            // Break the for
            break;
          }

        } // if (!shared_face_done[tmp_shared_face_ele_pt])

      } // for (iface < nnonhalo_face_shared_ele)

    } // while (nsorted_face_ele < nnonhalo_face_shared_ele))

    // Here we can safely delete the face elements, they are no longer
    // required

    // First the nonhalo face elements
    for (unsigned inh = 0; inh < nnonhalo_face_shared_ele; inh++)
    {
      delete nonhalo_shared_face_ele_pt[inh];
      nonhalo_shared_face_ele_pt[inh] = 0;
    } // for (inh < nnonhalo_face_shared_ele)

#ifdef PARANOID
    // ... then the halo face elements
    for (unsigned ih = 0; ih < nhalo_face_shared_ele; ih++)
    {
      delete halo_shared_face_ele_pt[ih];
      halo_shared_face_ele_pt[ih] = 0;
    } // for (inh < nhalo_face_shared_ele)
#endif

    // ------------------------------------------------
    // Now copy the nodes to the output container
    // ------------------------------------------------
    // Get the number of nodes in the container
    const unsigned n_nodes = sorted_nodes.size();

    // First resize the container
    tmp_segment_nodes.resize(1);
    tmp_segment_nodes[0].resize(n_nodes);

    // Counter
    unsigned counter = 0;

    // Loop over the list of nodes and copy them in the output container
    for (std::list<Node*>::iterator it = sorted_nodes.begin();
         it != sorted_nodes.end();
         it++)
    {
      tmp_segment_nodes[0][counter] = (*it);
      counter++;
    } // Loop over sorted nodes
  }

  //=====start of get_required_elemental_information_load_balance_helper====
  /// Helper function to get the required elemental information from
  /// the element that will be sent to iproc processor.
  /// This info. involves the association of the element to a boundary or
  /// region.
  //========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::
    get_required_elemental_information_load_balance_helper(
      unsigned& iproc,
      Vector<Vector<FiniteElement*>>& f_haloed_ele_pt,
      FiniteElement* ele_pt)
  {
    // Check if the element is associated with the original boundaries
    const unsigned nbound = this->initial_shared_boundary_id();

    // Get the number of processors
    const unsigned nproc = this->communicator_pt()->nproc();

    // ------------------------------------------------------------------
    // Stores the information regarding the boundaries associated to the
    // element (it that is the case)
    Vector<unsigned> associated_boundaries;
    Vector<unsigned> face_index_on_boundary;

    unsigned counter_face_indexes = 0;

    for (unsigned b = 0; b < nbound; b++)
    {
      // Get the number of elements associated to boundary i
      const unsigned nboundary_ele = nboundary_element(b);
      for (unsigned e = 0; e < nboundary_ele; e++)
      {
        if (ele_pt == this->boundary_element_pt(b, e))
        {
          // Keep track of the boundaries associated to the element
          associated_boundaries.push_back(b);
          // Get the face index
          face_index_on_boundary.push_back(face_index_at_boundary(b, e));
          counter_face_indexes++;
#ifdef PARANOID
          if (counter_face_indexes > 2)
          {
            std::stringstream error_message;
            error_message
              << "A triangular element can not have more than two of its faces "
              << "on a boundary!!!\n\n";
            throw OomphLibError(error_message.str(),
                                "RefineableTriangleMesh::get_required_"
                                "elemental_information_helper()",
                                OOMPH_EXCEPTION_LOCATION);
          }
#else
          // Already found 2 face indexes on the same boundary?
          if (counter_face_indexes == 2)
          {
            break;
          }
#endif // #ifdef PARANOID

        } // if (ele_pt == this->boundary_element_pt(b,e))

      } // (e < nboundary_ele)

    } // (b < nbound)

    // If the element is associated to any boundary then package all the
    // relevant info
    const unsigned nassociated_boundaries = associated_boundaries.size();
    if (nassociated_boundaries > 0)
    {
      Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back(
        "The element is a boundary element");
#endif
      Flat_packed_unsigneds.push_back(nassociated_boundaries);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk;
      junk << "The elements is associated to " << nassociated_boundaries
           << " boundaries";
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif

      // Package the ids of the associated boundaries and the
      // corresponding face index for each boundary (if the element is a
      // corner element, it will have two faces associated to the
      // boundary)
      for (unsigned i = 0; i < nassociated_boundaries; i++)
      {
        unsigned b = associated_boundaries[i];
        Flat_packed_unsigneds.push_back(b);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk;
        junk << "Element associated to boundary " << b << " of "
             << nassociated_boundaries << " total associated boundaries";
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif
        unsigned f = face_index_on_boundary[i];
        Flat_packed_unsigneds.push_back(f);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk2;
        junk2 << "Face index " << f << " for associated boundary " << b;
        Flat_packed_unsigneds_string.push_back(junk2.str());
#endif
      }

      // If the element is associated to any boundary then we should
      // check if the mesh has regions, if that is the case then we need
      // to check to which region the boundary element does belong

      // If the mesh has regions we should look for the element
      // associated to a boundary and a specified region
      Vector<Vector<unsigned>> associated_boundaries_and_regions;
      Vector<unsigned> face_index_on_boundary_and_region;

      // Now check for the case when we have regions in the mesh
      const unsigned n_regions = this->nregion();
      if (n_regions > 1)
      {
        // Used to count the number of faces associated with
        // boundary-regions
        unsigned counter_face_indexes_in_regions = 0;
        // Loop over the boundaries
        for (unsigned b = 0; b < nbound; b++)
        {
          // Go through each region by getting the region id
          for (unsigned i_reg = 0; i_reg < n_regions; i_reg++)
          {
            // Get thre region id associated with the (i_reg)-th region
            const unsigned region_id =
              static_cast<unsigned>(this->Region_attribute[i_reg]);

            // Loop over all elements associated with the current boundary
            // and the i_reg-th region and check if the element is part of
            // any region
            const unsigned nele_in_region =
              this->nboundary_element_in_region(b, region_id);
            for (unsigned ee = 0; ee < nele_in_region; ee++)
            {
              // Check if the boundary-region element is the same as the
              // element
              if (ele_pt ==
                  this->boundary_element_in_region_pt(b, region_id, ee))
              {
                // Storage for the boundary and region associated to the
                // element
                Vector<unsigned> bound_and_region(2);

                // Keep track of the boundaries associated to the element
                bound_and_region[0] = b;
                // Keep track of the regions associated to the element
                bound_and_region[1] = region_id;
                // Add the boundaries and regions in the storage to be
                // sent to other processors
                associated_boundaries_and_regions.push_back(bound_and_region);
                // Get the face index and keep track of it
                face_index_on_boundary_and_region.push_back(
                  this->face_index_at_boundary_in_region(b, region_id, ee));

                // Increase the number of faces of the element associated
                // to boundary-regions
                counter_face_indexes_in_regions++;

#ifdef PARANOID
                if (counter_face_indexes_in_regions > 2)
                {
                  std::stringstream error_message;
                  error_message << "A triangular element can not have more "
                                   "than two of its\n"
                                << "faces on a boundary!!!\n\n";
                  throw OomphLibError(error_message.str(),
                                      "RefineableTriangleMesh::get_required_"
                                      "elemental_information_helper()",
                                      OOMPH_EXCEPTION_LOCATION);
                } // if (counter_face_indexes_in_regions > 2)
#endif

              } // The element is a boundary-region element

            } // for (ee < nele_in_region)

          } // for (i_reg < n_regions)

        } // for (b < nbound)

      } // if (n_regions >  1)

      // Now package the info. to be sent to other processors
      const unsigned nassociated_boundaries_and_regions =
        associated_boundaries_and_regions.size();
      if (nassociated_boundaries_and_regions > 0)
      {
        Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        Flat_packed_unsigneds_string.push_back(
          "The element is associated to boundaries and regions");
#endif

        Flat_packed_unsigneds.push_back(nassociated_boundaries_and_regions);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk;
        junk << "The element is associated to "
             << nassociated_boundaries_and_regions << " boundaries-regions";
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif

        // Package the ids of the associated boundaries, regions and the
        // corresponding face index for each boundary-region (if the
        // element is a corner element, it will have two faces
        // associated to the boundary-region)
        for (unsigned i = 0; i < nassociated_boundaries_and_regions; i++)
        {
          const unsigned b = associated_boundaries_and_regions[i][0];
          Flat_packed_unsigneds.push_back(b);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
          std::stringstream junk;
          junk << "Element associated to boundary " << b << " of "
               << nassociated_boundaries_and_regions
               << " total associated boundaries-regions";
          Flat_packed_unsigneds_string.push_back(junk.str());
#endif

          const unsigned r = associated_boundaries_and_regions[i][1];
          Flat_packed_unsigneds.push_back(r);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
          std::stringstream junk2;
          junk2 << "Element associated to region " << r << " of "
                << nassociated_boundaries_and_regions
                << " total associated boundaries-regions";
          Flat_packed_unsigneds_string.push_back(junk2.str());
#endif

          const unsigned f = face_index_on_boundary_and_region[i];
          Flat_packed_unsigneds.push_back(f);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
          std::stringstream junk3;
          junk3 << "Face index " << f << " for associated boundary-region ("
                << b << "-" << r << ")";
          Flat_packed_unsigneds_string.push_back(junk3.str());
#endif
        } // for (i < nassociated_boundaries_and_regions)
      } // if (nassociated_boundaries_and_regions > 0)
      else
      {
        Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        Flat_packed_unsigneds_string.push_back(
          "The element is NOT associated to boundaries and regions");
#endif
      } // else if (nassociated_boundaries_and_regions > 0)
    }
    else
    {
      Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back(
        "The element is not associated to any original boundary");
#endif
    }

    // ------------------------------------------------------------
    // Now review if the element is associated to a shared boundary

    // Store the shared boundaries, and therefore the face indexes
    // associated to the element
    Vector<unsigned> associated_shared_boundaries;
    Vector<unsigned> face_index_on_shared_boundary;

    // Get the shared boundaries in this processor
    Vector<unsigned> my_rank_shared_boundaries_ids;
    this->shared_boundaries_in_this_processor(my_rank_shared_boundaries_ids);

    // Get the number of shared boundaries
    const unsigned nmy_rank_shd_bnd = my_rank_shared_boundaries_ids.size();
    // Loop over the shared boundaries
    for (unsigned i = 0; i < nmy_rank_shd_bnd; i++)
    {
      // Get the boundary id
      const unsigned sb = my_rank_shared_boundaries_ids[i];

      // Get the number of elements associated to shared boundary sb
      const unsigned nboundary_ele = this->nshared_boundary_element(sb);
      for (unsigned e = 0; e < nboundary_ele; e++)
      {
        if (ele_pt == this->shared_boundary_element_pt(sb, e))
        {
          // Keep track of the boundaries associated to the element
          associated_shared_boundaries.push_back(sb);
          // Get the face index
          face_index_on_shared_boundary.push_back(
            this->face_index_at_shared_boundary(sb, e));
        }
      } // (e < nboundary_ele)
    } // (i < nmy_rank_shd_bnd)

    // If the element is associated to a shared boundary then package
    // all the relevant info
    const unsigned nassociated_shared_boundaries =
      associated_shared_boundaries.size();
    if (nassociated_shared_boundaries > 0)
    {
      Flat_packed_unsigneds.push_back(3);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back(
        "The element is a shared boundary element");
#endif
      Flat_packed_unsigneds.push_back(nassociated_shared_boundaries);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk;
      junk << "The elements is associated to " << nassociated_shared_boundaries
           << "shared boundaries";
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif

      // Package the ids of the associated boundaries
      for (unsigned i = 0; i < nassociated_shared_boundaries; i++)
      {
        const unsigned b = associated_shared_boundaries[i];
        Flat_packed_unsigneds.push_back(b);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk;
        junk << "Element associated to shared boundary " << b << " of "
             << nassociated_shared_boundaries << " total associated boundaries";
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif

        const unsigned f = face_index_on_shared_boundary[i];
        Flat_packed_unsigneds.push_back(f);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk2;
        junk2 << "Face index " << f << " for associated shared boundary " << b;
        Flat_packed_unsigneds_string.push_back(junk2.str());
#endif
      }
    }
    else
    {
      Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back(
        "The element is not associated to any shared boundary");
#endif
    }

    // Now check if the element is haloed with any processor

    // Store the index of the haloed element with the jproc
    Vector<Vector<unsigned>> index_haloed(nproc);

    // Loop over the processors
    for (unsigned jproc = 0; jproc < nproc; jproc++)
    {
      // Get the number of haloed elements with jproc
      const unsigned n_haloed_jproc = f_haloed_ele_pt[jproc].size();
      // Loop over the haloed elements with jproc
      for (unsigned ihd = 0; ihd < n_haloed_jproc; ihd++)
      {
        // Is a haloed element?
        if (ele_pt == f_haloed_ele_pt[jproc][ihd])
        {
          // Store the haloed index with the jproc processor
          index_haloed[jproc].push_back(ihd);
          // Break the searching with the jproc processor
          break;
        } // if (ele_pt == f_haloed_ele_pt[jproc][ihd])

      } // for (ihd < n_haloed_jproc)

    } // for (jproc < nproc)

    // Send the haloed info.
    // Loop over the processors
    for (unsigned jproc = 0; jproc < nproc; jproc++)
    {
      // Is the element haloed with the jproc processor
      const unsigned n_index_haloed_jproc = index_haloed[jproc].size();
      Flat_packed_unsigneds.push_back(n_index_haloed_jproc);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back(
        "The number of haloed indexes the element is with processor jproc");
#endif
      for (unsigned ihd = 0; ihd < n_index_haloed_jproc; ihd++)
      {
        Flat_packed_unsigneds.push_back(index_haloed[jproc][ihd]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        Flat_packed_unsigneds_string.push_back(
          "The haloed index of the element with jproc");
#endif
      } // for (ihd < n_index_haloed_jproc)

    } // for (jproc < nproc)
  }

  //======================================================================
  /// Helper function to add nodes on a new domain as a result of
  /// load balance
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::add_node_load_balance_helper(
    unsigned& iproc,
    Vector<Vector<FiniteElement*>>& f_halo_ele_pt,
    Vector<Node*>& new_nodes_on_domain,
    Node* nod_pt)
  {
    // Attempt to add this node to the new domain
    const unsigned nnew_nodes_on_domain = new_nodes_on_domain.size();
    const unsigned new_added_node_index =
      this->try_to_add_node_pt_load_balance(new_nodes_on_domain, nod_pt);

    // If it was added then the new index should match the size of the storage
    if (new_added_node_index == nnew_nodes_on_domain)
    {
      Flat_packed_unsigneds.push_back(1);

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk;
      junk << "Node needs to be constructed [size="
           << Flat_packed_unsigneds.size() << "]; last entry: "
           << Flat_packed_unsigneds[Flat_packed_unsigneds.size() - 1];
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif

      // This helper function gets all the required information for the
      // specified node and stores it into MPI-sendable information
      // so that a new copy can be made on the receiving process
      get_required_nodal_information_load_balance_helper(
        f_halo_ele_pt, iproc, nod_pt);
    }
    else // It was already added
    {
      Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk;
      junk << "Node was already added [size=" << Flat_packed_unsigneds.size()
           << "]; last entry: "
           << Flat_packed_unsigneds[Flat_packed_unsigneds.size() - 1];

      Flat_packed_unsigneds_string.push_back(junk.str());
#endif

      // This node has been already added, so tell the other process
      // its index in the equivalent storage
      Flat_packed_unsigneds.push_back(new_added_node_index);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back("new added node index");
#endif
    }
  }

  //======start of get_required_nodal_information_load_balance_helper=======
  /// Helper function to get the required nodal information from an
  /// haloed node so that a fully-functional halo node (and therefore element)
  /// can be created on the receiving process
  //========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::
    get_required_nodal_information_load_balance_helper(
      Vector<Vector<FiniteElement*>>& f_halo_ele_pt,
      unsigned& iproc,
      Node* nod_pt)
  {
    unsigned my_rank = this->communicator_pt()->my_rank();
    const unsigned nproc = this->communicator_pt()->nproc();

    // Tell the halo copy of this node how many values there are
    // [NB this may be different for nodes within the same element, e.g.
    //  when using Lagrange multipliers]
    unsigned n_val = nod_pt->nvalue();
    Flat_packed_unsigneds.push_back(n_val);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    Flat_packed_unsigneds_string.push_back("Number of values");
#endif

    unsigned n_dim = nod_pt->ndim();

    // Default number of previous values to 1
    unsigned n_prev = 1;
    if (this->Time_stepper_pt != 0)
    {
      // Add number of history values to n_prev
      n_prev = this->Time_stepper_pt->ntstorage();
    }

    // -----------------------------------------------------
    // Is the node on an original boundary?
    // Store the original boundaries where the node may be
    Vector<unsigned> original_boundaries;
    // Loop over the original boundaries of the mesh and check if live
    // on one of them
    const unsigned n_bnd = this->initial_shared_boundary_id();
    for (unsigned bb = 0; bb < n_bnd; bb++)
    {
      // Which boundaries (could be more than one) is it on?
      if (nod_pt->is_on_boundary(bb))
      {
        original_boundaries.push_back(bb);
      }
    }

    const unsigned n_original_boundaries = original_boundaries.size();
    // Is the node on any original boundary?
    if (n_original_boundaries > 0)
    {
      // Indicate that the node is on an original boundary
      Flat_packed_unsigneds.push_back(2);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back(
        "Node is on the original boundaries");
#endif

      Flat_packed_unsigneds.push_back(n_original_boundaries);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk;
      junk << "Node is on " << n_original_boundaries << " original boundaries";
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif

      // Loop over the original boundaries the node is on
      for (unsigned i = 0; i < n_original_boundaries; i++)
      {
        Flat_packed_unsigneds.push_back(original_boundaries[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk;
        junk << "Node is on boundary " << original_boundaries[i] << " of "
             << nb;
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif
        // Get the boundary coordinate of the node
        Vector<double> zeta(1);
        nod_pt->get_coordinates_on_boundary(original_boundaries[i], zeta);
        Flat_packed_doubles.push_back(zeta[0]);
      }
    }
    else
    {
      // Indicate that the node is NOT on an original boundary
      Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back(
        "Node is on any original boundary");
#endif
    }

    // -------------------------------------------------------
    // Is the node on shared boundaries?
    bool node_on_shared_boundary = false;
    // Loop over the shared boundaries with the iproc processors and
    // check if live on one of them
    const unsigned n_shd_bnd = this->nshared_boundaries(my_rank, iproc);
    for (unsigned bb = 0; bb < n_shd_bnd; bb++)
    {
      // Get the boundary id
      unsigned i_bnd = this->shared_boundaries_ids(my_rank, iproc, bb);
      // Which boundaries (could be more than one) is it on?
      if (this->is_node_on_shared_boundary(i_bnd, nod_pt))
      {
        node_on_shared_boundary = true;
        break;
      }
    }

    // If the node live on any of the shared boundaries with the iproc
    // processor then just get the node number according to the
    // sorted_shared_boundary_node_pt() scheme and send it accross
    if (node_on_shared_boundary)
    {
      Flat_packed_unsigneds.push_back(1);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back("Node is on shared boundary");
#endif

      // Store the shared boundaries where the node is on
      Vector<unsigned> shd_boundaries;
      // Loop over the shared boundaries with the iproc processor
      for (unsigned bb = 0; bb < n_shd_bnd; bb++)
      {
        // Get the boundary id
        const unsigned i_bnd = this->shared_boundaries_ids(my_rank, iproc, bb);
        // Which boundaries (could be more than one) is it on?
        if (this->is_node_on_shared_boundary(i_bnd, nod_pt))
        {
          shd_boundaries.push_back(i_bnd);
        }
      }

      // Get the number of shared boundaries the node is on
      const unsigned n_shd_bnd_is_on = shd_boundaries.size();
      // Send the number of shared boundaries the node is on
      Flat_packed_unsigneds.push_back(n_shd_bnd_is_on);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk;
      junk << "Node is on " << n_shd_bnd_is_on << " shared boundaries";
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif

      // Loop over the shared boundaries to send their ids
      for (unsigned i = 0; i < n_shd_bnd_is_on; i++)
      {
        Flat_packed_unsigneds.push_back(shd_boundaries[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk;
        junk << "Node is on boundary " << shd_boundaries[i] << " of " << nb;
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif
      }

      // Given that the node is on at least one boundary get the index
      // of the node in one of the boundaries and send this index
      unsigned shared_boundary_id = shd_boundaries[0];
      // Get the number of nodes on the given shared boundary
      const unsigned n_nodes_on_shared_boundary =
        nsorted_shared_boundary_node(shared_boundary_id);
      // Store the index of the node on the shared boundary
      unsigned index_node_on_shared_boundary;
#ifdef PARANOID
      // Flag to know if the node has been found
      bool found_index_node_on_shared_boundary = false;
#endif
      // Loop over the nodes on the shared boundary to find the node
      for (unsigned i = 0; i < n_nodes_on_shared_boundary; i++)
      {
        // Get the i-th node on the shared boundary
        Node* shared_node_pt =
          sorted_shared_boundary_node_pt(shared_boundary_id, i);
        // Is the node we are looking for
        if (shared_node_pt == nod_pt)
        {
          // Store the index
          index_node_on_shared_boundary = i;
#ifdef PARANOID
          // Mark as found
          found_index_node_on_shared_boundary = true;
#endif
          break; // break
        }

      } // for (i < nnodes_on_shared_boundary)

#ifdef PARANOID
      if (!found_index_node_on_shared_boundary)
      {
        std::ostringstream error_message;
        error_message << "The index of the node on boundary ("
                      << shared_boundary_id << ") was not found.\n"
                      << "The node coordinates are (" << nod_pt->x(0) << ","
                      << nod_pt->x(1) << ").\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::get_required_nodal_information_helper()",
          OOMPH_EXCEPTION_LOCATION);
      }
#endif
      // Send the index of the node on the shared boundary
      Flat_packed_unsigneds.push_back(index_node_on_shared_boundary);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk2;
      junk2 << "Node index on boundary " << boundaries[0] << " is "
            << index_node_on_shared_boundary;
      Flat_packed_unsigneds_string.push_back(junk2.str());
#endif

    } // if (node_on_shared_boundary)
    else
    {
      // The node is not on a shared boundary
      Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back(
        "Node is not on a shared boundary");
#endif
    }

    // ----------------------------------------------------------------
    // Is the node on any shared boundary where the receiver processor
    // is not involved?

    // Now check if the node is on a shared boundary created by the
    // current processor (my_rank) and other processor different that
    // the iproc processor. This info. will help to complete the sending
    // of halo(ed) information between processors

    // Flag to know if the node is on a shared boundary with other
    // processor
    bool node_on_shared_boundary_with_other_processors = false;
    // Count the number of other shared boundaries it could be on
    unsigned nshared_boundaries_with_other_processors_have_node = 0;

    // Loop over the shared boundaries of the sent processor (my_rank)
    // and other processors (jproc)
    for (unsigned jproc = 0; jproc < nproc; jproc++)
    {
      // Do not search with the iproc processor, that was done before
      // above
      if (jproc != iproc)
      {
        // Get the number of shared boundaries with the jproc processor
        const unsigned n_jshd_bnd = this->nshared_boundaries(my_rank, jproc);
        // Loop over the shared boundaries
        for (unsigned bb = 0; bb < n_jshd_bnd; bb++)
        {
          // Get the boundary id
          const unsigned j_shd_bnd =
            this->shared_boundaries_ids(my_rank, jproc, bb);
          // Is the node part of this boundary?
          if (this->is_node_on_shared_boundary(j_shd_bnd, nod_pt))
          {
            //           DEBP("Sending to");
            //           DEBP(iproc);
            //           DEBP("Pair of procs where other shared");
            //           DEBP(my_rank);
            //           DEBP(jproc);
            //           DEBP(i_bnd);
            node_on_shared_boundary_with_other_processors = true;
            // Increase the counter for the number of shared boundaries
            // with other processors the node is on
            nshared_boundaries_with_other_processors_have_node++;
          } // if (this->is_node_on_shared_boundary(j_shd_bnd, nod_pt)

        } // for (bb<n_jshd_bnd)

      } // if (jproc != iproc)

    } // for (jproc < nproc)

    // If the node is on a shared boundary with another processor
    // (my_rank, jproc), then send the flag and look for the info.
    if (node_on_shared_boundary_with_other_processors)
    {
      Flat_packed_unsigneds.push_back(4);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back(
        "Node is on shared boundary no related with the received processor: 4");
#endif

      // The number of packages of information that will be sent to the
      // "iproc" processor. This helps to know how many packages of data
      // read from the received processor
      Flat_packed_unsigneds.push_back(
        nshared_boundaries_with_other_processors_have_node);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk;
      junk << "Number of other shared boundaries that the node is on: "
           << nshared_boundaries_with_other_processors_have_node;
      Flat_packed_unsigneds_string.push_back(junk.str());
#endif

      // Counter to ensure that the correct number of data has been sent
      unsigned counter_shd_bnd_with_other_procs_have_node = 0;
      // Loop over the shared boundaries with other processors and get:
      // 1) The processors defining the shared boundary
      // 2) The shared boundary id
      // 3) The index of the node on the shared boundary
      Vector<unsigned> other_processor_1;
      Vector<unsigned> other_processor_2;
      Vector<unsigned> shd_bnd_ids;
      Vector<unsigned> indexes;
      // Loop over the processors again
      for (unsigned jproc = 0; jproc < nproc; jproc++)
      {
        // Do not search with the iproc processor, that was done before
        // above
        if (jproc != iproc)
        {
          // Get the number of shared boundaries with the jproc
          // processor
          const unsigned n_jshd_bnd = this->nshared_boundaries(my_rank, jproc);
          for (unsigned bb = 0; bb < n_jshd_bnd; bb++)
          {
            // Get the boundary id
            const unsigned j_shd_bnd =
              this->shared_boundaries_ids(my_rank, jproc, bb);
            // Is the node part of this boundary?
            if (this->is_node_on_shared_boundary(j_shd_bnd, nod_pt))
            {
              // Include the first processor
              other_processor_1.push_back(my_rank);
              // Include the second processor
              other_processor_2.push_back(jproc);
              // Include the shared boundary id
              shd_bnd_ids.push_back(j_shd_bnd);
              // Increase the counter for found shared boundaries with
              // other processors
              counter_shd_bnd_with_other_procs_have_node++;
            }

          } // for (bb < nshared_bnd)

        } // if (jproc != iproc)

      } // for (jproc < nproc)

      // Get the indexes of the node on all the shared boundaries where
      // it was found
      const unsigned n_other_processors = other_processor_1.size();
      // Loop over the processors where the node was found
      for (unsigned i = 0; i < n_other_processors; i++)
      {
        // Get the shared boundary id
        unsigned shd_bnd_id = shd_bnd_ids[i];
        // Get the number of nodes on that shared boundary
        const unsigned n_nodes_on_shd_bnd =
          nsorted_shared_boundary_node(shd_bnd_id);

#ifdef PARANOID
        bool found_index_node_on_shared_boundary = false;
#endif
        for (unsigned i = 0; i < n_nodes_on_shd_bnd; i++)
        {
          // Get the i-th shared boundary node
          Node* shared_node_pt = sorted_shared_boundary_node_pt(shd_bnd_id, i);
          // Is the same node?
          if (shared_node_pt == nod_pt)
          {
            //             DEBP(i_node);
            //             DEBP(nod_pt->x(0));
            //             DEBP(nod_pt->x(1));
            // Include the index of the node
            indexes.push_back(i);
#ifdef PARANOID
            // Mark as found the node
            found_index_node_on_shared_boundary = true;
#endif
            break;
          } // if (shared_node_pt == nod_pt)

        } // for (i < n_nodes_on_shd_bnd)

#ifdef PARANOID
        if (!found_index_node_on_shared_boundary)
        {
          std::ostringstream error_message;
          error_message << "The index of the node on boundary (" << shd_bnd_id
                        << "), shared by other processors\nwas not found.\n"
                        << "The node coordinates are (" << nod_pt->x(0) << ","
                        << nod_pt->x(1) << ").\n";
          throw OomphLibError(
            error_message.str(),
            "RefineableTriangleMesh::get_required_nodal_information_helper()",
            OOMPH_EXCEPTION_LOCATION);
        }
#endif
      } // for (i < n_other_processors)

      // Now send the info. but first check that the number of found
      // nodes be the same that the previously found shared boundaries
      // with the node
#ifdef PARANOID
      if (counter_shd_bnd_with_other_procs_have_node !=
          nshared_boundaries_with_other_processors_have_node)
      {
        std::ostringstream error_message;
        error_message << "The number of shared boundaries where the node is on "
                      << "is different:\n"
                      << "nshared_boundaries_with_other_processors_have_node: ("
                      << nshared_boundaries_with_other_processors_have_node
                      << ")\n"
                      << "counter_shd_bnd_with_other_procs_have_node: ("
                      << counter_shd_bnd_with_other_procs_have_node << ")\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::get_required_nodal_information_helper()",
          OOMPH_EXCEPTION_LOCATION);
      } // if (counter_shd_bnd_with_other_procs_have_node !=
        // nshared_boundaries_with_other_processors_have_node)
#endif

      // Loop over the info. to send it
      for (unsigned i = 0; i < n_other_processors; i++)
      {
        Flat_packed_unsigneds.push_back(other_processor_1[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk1;
        junk1 << "Processor where the other shared boundary "
              << "has the node: " << other_processor_1[i];
        Flat_packed_unsigneds_string.push_back(junk1.str());
#endif

        Flat_packed_unsigneds.push_back(other_processor_2[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk2;
        junk2 << "Processor where the other shared boundary "
              << "has the node: " << other_processor_2[i];
        Flat_packed_unsigneds_string.push_back(junk2.str());
#endif

        Flat_packed_unsigneds.push_back(shd_bnd_ids[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk3;
        junk3 << "Other shared boundary id where the node is on"
              << boundaries[i];
        Flat_packed_unsigneds_string.push_back(junk3.str());
#endif

        Flat_packed_unsigneds.push_back(indexes[i]);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk4;
        junk4 << "Node index on other shared boundary " << boundaries[i]
              << " is " << indexes[i];
        Flat_packed_unsigneds_string.push_back(junk4.str());
#endif

      } // for (i < n_other_processors)

    } // if (node_on_shared_boundary_with_other_processors)
    else
    {
      Flat_packed_unsigneds.push_back(0);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      Flat_packed_unsigneds_string.push_back(
        "Node is on any shared boundary with other processors");
#endif
    } // else if (node_on_shared_boundary_with_other_processors)

    // It may still be possible that the node be shared with the
    // processor that receives the info. but it is neither on shared
    // boundary with the receiver processor nor on a shared boundary
    // with others processors. Think in the next case:

    // |-----|-----|   - The elements in processor 3 need to be sent to
    // |  4  |  3  |     processor 1, and that is all
    // |-----*-----|   - When processor 1 receives the data from node (*)
    // |  1  |  2  |     it just RE-CREATES it becasuse it is does not know
    // |-----|-----|     that the node is also on the shared boundary that
    //                   processor 1 and 2 or processor 1 and 4 share.

    // This problem become even worse if there would be more processors
    // between processor 3 and 2, or/and processor 3 and 4. Think in
    // triangles sharing the node (*)

    // To solve this check if the node that we are trying to send is
    // part of the halo elements of the curreent processor (my_rank)
    // with any other processor (we need to check with all the
    // processors and not just with the processors to which we will send
    // to cover more cases)

    // Store the halo element number with jproc where the node was found
    Vector<Vector<unsigned>> halo_element_number(nproc);
    // Store the node number on the halo element where the node was found
    Vector<Vector<unsigned>> halo_node_number_in_halo_element(nproc);

    // Loop over the processor
    for (unsigned jproc = 0; jproc < nproc; jproc++)
    {
      // Get the number of halo elements with the jproc processor
      const unsigned n_halo_jproc = f_halo_ele_pt[jproc].size();
      // Loop over the halo elements
      for (unsigned jh = 0; jh < n_halo_jproc; jh++)
      {
        FiniteElement* halo_ele_pt = f_halo_ele_pt[jproc][jh];
        // Get the number of nodes of the halo element
        const unsigned n_node = halo_ele_pt->nnode();
        // Loop over the nodes
        for (unsigned n = 0; n < n_node; n++)
        {
          // Is the node part of the ih-th halo element with jproc
          if (nod_pt == halo_ele_pt->node_pt(n))
          {
            halo_element_number[jproc].push_back(jh);
            halo_node_number_in_halo_element[jproc].push_back(n);
            // break with the nodes, no need to look for more nodes in
            // the element
            break;
          } // if (nod_pt == halo_ele_pt->node_pt(n))

        } // for (n < n_node)

      } // for (jh < n_halo_jproc)

    } // for (jproc < nproc)

    // Send the info. related with if the node is on halo elements with
    // any processor

    // Loop over the processors
    for (unsigned jproc = 0; jproc < nproc; jproc++)
    {
      // Get the number of halo elements with jproc processor where the
      // node is
      const unsigned n_jproc_halo_ele_node_is_on =
        halo_element_number[jproc].size();
      // Send the number of halo elements with jproc where the node is
      Flat_packed_unsigneds.push_back(n_jproc_halo_ele_node_is_on);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      std::stringstream junk5;
      junk5 << "Node is on " << n_jproc_halo_ele_node_is_on << " halo "
            << "elements with " << jproc << "-th processor";
      Flat_packed_unsigneds_string.push_back(junk5.str());
#endif
      // Send the halo elements indexes (which will be haloed elements
      // indexes in the receiver processor), and the indexes of the
      // nodes in each halo element
      for (unsigned i = 0; i < n_jproc_halo_ele_node_is_on; i++)
      {
        // The halo element index
        const unsigned halo_element_index = halo_element_number[jproc][i];
        Flat_packed_unsigneds.push_back(halo_element_index);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk6;
        junk6 << "Halo element index is (" << halo_element_index
              << ") with processor (" << jproc << ")";
        Flat_packed_unsigneds_string.push_back(junk6.str());
#endif
        // The node index on the halo element
        const unsigned node_index = halo_node_number_in_halo_element[jproc][i];
        Flat_packed_unsigneds.push_back(node_index);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk7;
        junk7 << "The node index on the halo element index is (" << node_index;
        Flat_packed_unsigneds_string.push_back(junk7.str());
#endif

      } // for (i < n_jproc_halo_ele_node_is_on)

    } // for (jproc < nproc)

    // Now check if it is required to send the info. of the node. If the
    // node is not on a shared boundary with the iproc processor then we
    // need to send the info.

    // Flag to indicate if it is on a halo element with the iproc
    // processor. If this flag is true then there is no need to send the
    // info. to create the node, in the receiver processor the info is
    // copied from the indicated haloed element-node
    bool on_halo_element_with_iproc_processor = false;
    if (halo_element_number[iproc].size() > 0)
    {
      on_halo_element_with_iproc_processor = true;
    } // if (halo_element_number[iproc].size() > 0)

    // if (!node_on_shared_boundary)
    if (!node_on_shared_boundary && !on_halo_element_with_iproc_processor)
    {
      // Send all the info. to create it

      // Is the Node algebraic?  If so, send its ref values and
      // an indication of its geometric objects if they are stored
      // in the algebraic mesh
      AlgebraicNode* alg_nod_pt = dynamic_cast<AlgebraicNode*>(nod_pt);
      if (alg_nod_pt != 0)
      {
        // The external mesh should be algebraic
        AlgebraicMesh* alg_mesh_pt = dynamic_cast<AlgebraicMesh*>(this);

        // Get default node update function ID
        unsigned update_id = alg_nod_pt->node_update_fct_id();
        Flat_packed_unsigneds.push_back(update_id);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        Flat_packed_unsigneds_string.push_back("Alg Node update id");
#endif

        // Get reference values at default...
        unsigned n_ref_val = alg_nod_pt->nref_value();
        Flat_packed_unsigneds.push_back(n_ref_val);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        Flat_packed_unsigneds_string.push_back("Alg Node n ref values");
#endif
        for (unsigned i_ref_val = 0; i_ref_val < n_ref_val; i_ref_val++)
        {
          Flat_packed_doubles.push_back(alg_nod_pt->ref_value(i_ref_val));
        }

        // Access geometric objects at default...
        unsigned n_geom_obj = alg_nod_pt->ngeom_object();
        Flat_packed_unsigneds.push_back(n_geom_obj);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        Flat_packed_unsigneds_string.push_back("Alg Node n geom objects");
#endif
        for (unsigned i_geom = 0; i_geom < n_geom_obj; i_geom++)
        {
          GeomObject* geom_obj_pt = alg_nod_pt->geom_object_pt(i_geom);

          // Check this against the stored geometric objects in mesh
          unsigned n_geom_list = alg_mesh_pt->ngeom_object_list_pt();

          // Default found index to zero
          unsigned found_geom_object = 0;
          for (unsigned i_list = 0; i_list < n_geom_list; i_list++)
          {
            if (geom_obj_pt == alg_mesh_pt->geom_object_list_pt(i_list))
            {
              found_geom_object = i_list;
            }
          }
          Flat_packed_unsigneds.push_back(found_geom_object);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
          Flat_packed_unsigneds_string.push_back("Found geom object");
#endif
        }
      } // (if alg_nod_pt!=0)

      // Is it a SolidNode?
      SolidNode* solid_nod_pt = dynamic_cast<SolidNode*>(nod_pt);
      if (solid_nod_pt != 0)
      {
        unsigned n_solid_val = solid_nod_pt->variable_position_pt()->nvalue();
        for (unsigned i_val = 0; i_val < n_solid_val; i_val++)
        {
          for (unsigned t = 0; t < n_prev; t++)
          {
            Flat_packed_doubles.push_back(
              solid_nod_pt->variable_position_pt()->value(t, i_val));
          }
        }

        Vector<double> values_solid_node;
        solid_nod_pt->add_values_to_vector(values_solid_node);
        const unsigned nvalues_solid_node = values_solid_node.size();
        Flat_packed_unsigneds.push_back(nvalues_solid_node);
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        std::stringstream junk;
        junk << "Number of values solid node: " << nvalues_solid_node;
        Flat_packed_unsigneds_string.push_back(junk.str());
#endif
        for (unsigned i = 0; i < nvalues_solid_node; i++)
        {
          Flat_packed_doubles.push_back(values_solid_node[i]);
        }
      }

      // Finally copy info required for all node types
      for (unsigned i_val = 0; i_val < n_val; i_val++)
      {
        for (unsigned t = 0; t < n_prev; t++)
        {
          Flat_packed_doubles.push_back(nod_pt->value(t, i_val));
        }
      }

      // Now do positions
      for (unsigned idim = 0; idim < n_dim; idim++)
      {
        for (unsigned t = 0; t < n_prev; t++)
        {
          Flat_packed_doubles.push_back(nod_pt->x(t, idim));
          //         DEBP(nod_pt->x(t,idim));
        }
      }

    } // if (!node_on_shared_boundary && !on_halo_element_with_iproc_processor)
  }

  //======================================================================
  /// Helper function to create elements on the loop
  /// process based on the info received in
  /// send_and_received_elements_nodes_info
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::create_element_load_balance_helper(
    unsigned& iproc,
    Vector<Vector<FiniteElement*>>& f_haloed_ele_pt,
    Vector<Vector<std::map<unsigned, FiniteElement*>>>&
      received_old_haloed_element_pt,
    Vector<FiniteElement*>& new_elements_on_domain,
    Vector<Node*>& new_nodes_on_domain,
    Vector<Vector<Vector<std::map<unsigned, Node*>>>>&
      other_proc_shd_bnd_node_pt,
    Vector<Vector<Vector<unsigned>>>& global_node_names,
    std::map<Vector<unsigned>, unsigned>& node_name_to_global_index,
    Vector<Node*>& global_shared_node_pt)
  {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << " Bool: New element needs to be constructed "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif

    if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 1)
    {
      // Create a new element from the communicated values
      // and coords from the process that located zeta
      GeneralisedElement* new_el_pt = new ELEMENT;

      // Add the new element to the mesh - Do not add the element yet
      // since no retained elements still need to be deleted
      // this->add_element_pt(new_el_pt);

      // Cast to the FE pointer
      FiniteElement* f_el_pt = dynamic_cast<FiniteElement*>(new_el_pt);

      // Add the element to the new elements in the domain container
      new_elements_on_domain.push_back(f_el_pt);

      // Set any additional information for the element
      this->add_element_load_balance_helper(
        iproc, received_old_haloed_element_pt, f_el_pt);

      // Add nodes to the new element
      unsigned n_node = f_el_pt->nnode();
      for (unsigned j = 0; j < n_node; j++)
      {
        Node* new_nod_pt = 0;

        // Call the add halo node helper function
        add_received_node_load_balance_helper(new_nod_pt,
                                              f_haloed_ele_pt,
                                              received_old_haloed_element_pt,
                                              new_nodes_on_domain,
                                              other_proc_shd_bnd_node_pt,
                                              iproc,
                                              j,
                                              f_el_pt,
                                              global_node_names,
                                              node_name_to_global_index,
                                              global_shared_node_pt);
      }
    }
    else // the element already exists
    {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  Index of existing element "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif

      // Incrase the index, we do anything else with the element
      Counter_for_flat_packed_unsigneds++;

    } // else the element already exists
  }

  //========start of add_element_load_balance_helper=====================
  /// Helper function to create elements on the loop
  /// process based on the info received in
  /// send_and_received_elements_nodes_info
  /// This function is in charge of verify if the element is associated
  /// to a boundary and associate to it if that is the case
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::add_element_load_balance_helper(
    const unsigned& iproc,
    Vector<Vector<std::map<unsigned, FiniteElement*>>>&
      received_old_haloed_element_pt,
    FiniteElement* ele_pt)
  {
    // Get the number of processors
    const unsigned nproc = this->communicator_pt()->nproc();

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << " Bool: Element is associated to a boundary "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif

    // Is on an original boundary?
    const unsigned is_on_original_boundary =
      Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    if (is_on_original_boundary == 1)
    {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  How many boundaries are associated with the element "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      // Number of boundaries the element is associated with
      const unsigned nassociated_boundaries =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      // Loop over the associated boundaries
      for (unsigned b = 0; b < nassociated_boundaries; b++)
      {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Boundary associated to the element "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif

        // The boundary id
        const unsigned bnd =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Face index of the element "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif

        // The face index
        const unsigned face_index =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        // Associate the element with the boundary and establish as many
        // face indexes it has
        this->Boundary_element_pt[bnd].push_back(ele_pt);
        this->Face_index_at_boundary[bnd].push_back(face_index);

      } // (b < nassociated_boundaries)

      // Here read the info. regarding the boundary-region of the element
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << " Bool: Element is associated to a boundary-region "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif

      // Is the element associated to a boundary-region?
      if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 1)
      {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info
          << "Rec:" << Counter_for_flat_packed_unsigneds
          << "  How many boundaries-regions are associated with the element "
          << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
          << std::endl;
#endif
        // Number of boundary-regions the element is associated
        const unsigned nassociated_boundaries_and_regions =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        for (unsigned br = 0; br < nassociated_boundaries_and_regions; br++)
        {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
          oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                     << "  Boundary associated to the element "
                     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                     << std::endl;
#endif
          // The boundary id
          const unsigned bnd =
            Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
          oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                     << "  Region associated to the element "
                     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                     << std::endl;
#endif
          // The region id
          const unsigned region =
            Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
          oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                     << "  Face index of the element in boundary-region "
                     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                     << std::endl;
#endif
          const unsigned face_index =
            Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

          // Associate the element with the boundary-regions and establish
          // as many face indexes it has
          this->Boundary_region_element_pt[bnd][region].push_back(ele_pt);
          this->Face_index_region_at_boundary[bnd][region].push_back(
            face_index);

        } // for (br < nassociated_boundaries_and_regions)

      } // Is the element associated with a boundary-region?

    } // The element is associated with an original boundary
#ifdef PARANOID
    else
    {
      if (is_on_original_boundary != 0)
      {
        std::ostringstream error_message;
        error_message
          << "The current element is not on an original boundary, this should\n"
          << "be indicated by a zero flag. However, the read value for\n"
          << "that flag is (" << is_on_original_boundary << ").\n\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::add_element_load_balance_helper()",
          OOMPH_EXCEPTION_LOCATION);
      } // if (is_on_shared_boundary != 0)
    }
#endif

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << " Bool: Element is associated to a shared boundary "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif

    // Is the element a shared boundary element?
    const unsigned is_on_shared_boundary =
      Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    if (is_on_shared_boundary == 3)
    {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info
        << "Rec:" << Counter_for_flat_packed_unsigneds
        << "  How many shared boundaries are associated with the element "
        << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
        << std::endl;
#endif

      // The number of shared boundaries the element is associated
      const unsigned nassociated_shared_boundaries =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      // Loop over the associated shared boundaries
      for (unsigned b = 0; b < nassociated_shared_boundaries; b++)
      {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Shared boundary associated to the element "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        const unsigned bnd =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info
          << "Rec:" << Counter_for_flat_packed_unsigneds
          << "  Face index of the element associated to the shared boundary "
          << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
          << std::endl;
#endif

        const unsigned face_index =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        this->add_shared_boundary_element(bnd, ele_pt);
        this->add_face_index_at_shared_boundary(bnd, face_index);

      } // (b < nassociated_shared_boundaries)

    } // The element is associted with a shared boundary
#ifdef PARANOID
    else
    {
      if (is_on_shared_boundary != 0)
      {
        std::ostringstream error_message;
        error_message
          << "The current element is not on a shared boundary, this should\n"
          << "be indicated by a zero flag. However, the read value for\n"
          << "that flag is (" << is_on_shared_boundary << ").\n\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::add_element_load_balance_helper()",
          OOMPH_EXCEPTION_LOCATION);
      } // if (is_on_shared_boundary != 0)
    }
#endif

    // Now check if the element is a haloed element in the sender
    // processor with any other processor

    // Loop over the processors
    for (unsigned jproc = 0; jproc < nproc; jproc++)
    {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << " Bool: Number of haloed indexes of the element with the "
                 << jproc << " processor: "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      // Is the element haloed with the jproc processor
      const unsigned n_index_haloed_jproc =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      // Loop over the number of haloed indexes
      for (unsigned ihd = 0; ihd < n_index_haloed_jproc; ihd++)
      {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << " Bool: The haloed element index with the " << jproc
                   << " processor: "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        const unsigned haloed_index =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        // Set the halod element in the proper storage
        received_old_haloed_element_pt[iproc][jproc][haloed_index] = ele_pt;

      } // for (ihd < n_index_haloed_jproc)

    } // for (jproc < nproc)
  }

  //======================================================================
  /// Helper function to add a new node from load balance
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::add_received_node_load_balance_helper(
    Node*& new_nod_pt,
    Vector<Vector<FiniteElement*>>& f_haloed_ele_pt,
    Vector<Vector<std::map<unsigned, FiniteElement*>>>&
      received_old_haloed_element_pt,
    Vector<Node*>& new_nodes_on_domain,
    Vector<Vector<Vector<std::map<unsigned, Node*>>>>&
      other_proc_shd_bnd_node_pt,
    unsigned& iproc,
    unsigned& node_index,
    FiniteElement* const& new_el_pt,
    Vector<Vector<Vector<unsigned>>>& global_node_names,
    std::map<Vector<unsigned>, unsigned>& node_name_to_global_index,
    Vector<Node*>& global_shared_node_pt)
  {
    // Given the node, received information about it from processor
    // iproc, construct it on the current process
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << " Bool: New node needs to be constructed "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 1)
    {
      // Construct a new node based upon sent information, or copy a node
      // from one of the shared boundaries
      construct_new_node_load_balance_helper(new_nod_pt,
                                             f_haloed_ele_pt,
                                             received_old_haloed_element_pt,
                                             new_nodes_on_domain,
                                             other_proc_shd_bnd_node_pt,
                                             iproc,
                                             node_index,
                                             new_el_pt,
                                             global_node_names,
                                             node_name_to_global_index,
                                             global_shared_node_pt);
    }
    else
    {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  Index of existing halo node "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      // The node already exist, copy it from the indicated position

      // Get the node's index, and copy it
      new_nod_pt = new_nodes_on_domain
        [Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++]];

      // Set the node in the current element
      new_el_pt->node_pt(node_index) = new_nod_pt;
    }
  }

  //============start_of_construct_new_node_load_balance_helper()=========
  /// Helper function which constructs a new node (on an
  /// element) with the information sent from the load balance
  /// process
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::construct_new_node_load_balance_helper(
    Node*& new_nod_pt,
    Vector<Vector<FiniteElement*>>& f_haloed_ele_pt,
    Vector<Vector<std::map<unsigned, FiniteElement*>>>&
      received_old_haloed_element_pt,
    Vector<Node*>& new_nodes_on_domain,
    Vector<Vector<Vector<std::map<unsigned, Node*>>>>&
      other_proc_shd_bnd_node_pt,
    unsigned& iproc,
    unsigned& node_index,
    FiniteElement* const& new_el_pt,
    Vector<Vector<Vector<unsigned>>>& global_node_names,
    std::map<Vector<unsigned>, unsigned>& node_name_to_global_index,
    Vector<Node*>& global_shared_node_pt)
  {
    // Get the number of processors
    const unsigned nproc = this->communicator_pt()->nproc();
    // Get the rank of the current processor
    const unsigned my_rank = this->communicator_pt()->my_rank();

    // The first entry indicates the number of values at this new Node
    //(which may be different across the same element e.g. Lagrange multipliers)
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << "  Number of values of external halo node "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    unsigned n_val = Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

    // Null TimeStepper for now
    TimeStepper* time_stepper_pt = this->Time_stepper_pt;
    // Default number of previous values to 1
    unsigned n_prev = time_stepper_pt->ntstorage();

    // ------------------------------------------------------
    // Check if the node is on an original boundary
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << "  Is the node on an original boundary "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif

    // Flag to indicate if the node is on original boundaries
    const unsigned node_on_original_boundaries =
      Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

    // Store the original boundaries where the node is on
    Vector<unsigned> original_boundaries_node_is_on;
    // Store the zeta coordinates of the node on the original boundaries
    Vector<double> zeta_coordinates;
    // Store the number of original boundaries the node is on
    unsigned n_original_boundaries_node_is_on = 0;

    if (node_on_original_boundaries == 2)
    {
      // How many original boundaries does the node live on?
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << " Number of boundaries the node is on: "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      n_original_boundaries_node_is_on =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      // Resize the containers
      original_boundaries_node_is_on.resize(n_original_boundaries_node_is_on);
      zeta_coordinates.resize(n_original_boundaries_node_is_on);

      for (unsigned i = 0; i < n_original_boundaries_node_is_on; i++)
      {
        // Boundary number
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Node is on boundary "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        original_boundaries_node_is_on[i] =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        zeta_coordinates[i] =
          Flat_packed_doubles[Counter_for_flat_packed_doubles++];
      }

    } // if (node_on_original_boundaries==2)
#ifdef PARANOID
    else
    {
      if (node_on_original_boundaries != 0)
      {
        std::ostringstream error_message;
        error_message
          << "The current node is not on an original boundary, this should\n"
          << "be indicated by a zero flag. However, the read value for\n"
          << "that flag is (" << node_on_original_boundaries << ").\n\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::construct_new_halo_node_helper()",
          OOMPH_EXCEPTION_LOCATION);
      } // if (node_on_original_boundaries != 0)
    }
#endif

    // --------------------------------------------------------------
    // Check if the node was on a shared boundary with the iproc
    // processor
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << "  Is node on shared boundary? "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    const unsigned is_node_on_shared_boundary =
      Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    if (is_node_on_shared_boundary == 1)
    {
      // How many shared boundaries does the node live on?
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << " Number of boundaries the node is on: "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      const unsigned n_shd_bnd_node_is_on =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      Vector<unsigned> shd_bnds_node_is_on(n_shd_bnd_node_is_on);
      for (unsigned i = 0; i < n_shd_bnd_node_is_on; i++)
      {
        // Shared boundary number
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Node is on boundary "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        shd_bnds_node_is_on[i] =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
      }

      // Get the index of the node on the shared boundary
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  Index of node on boundary "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      // Get the node index of the node on the shared boundary
      unsigned node_index_on_shared_boundary =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      // Get the pointer to the node with the received info.
      new_nod_pt = this->sorted_shared_boundary_node_pt(
        shd_bnds_node_is_on[0], node_index_on_shared_boundary);

    } // if (is_node_on_shared_boundary == 1)
#ifdef PARANOID
    else
    {
      if (is_node_on_shared_boundary != 0)
      {
        std::ostringstream error_message;
        error_message
          << "The current node is not on a shared boundary, this should\n"
          << "be indicated by a zero flag. However, the read value for\n"
          << "that flag is (" << is_node_on_shared_boundary << ").\n\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::construct_new_halo_node_helper()",
          OOMPH_EXCEPTION_LOCATION);
      } // if (node_on_shared_boundary != 0)
    }
#endif

    // ------------------------------------------------------------
    // Is the node on a shared boundary with other processor?
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << "  Is the node on shared boundaries with other processors "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif

    // Is the node in shared boundaries no associated with the
    // receiver processor
    const unsigned is_the_node_in_shared_boundaries_with_other_processors =
      Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

    // The containers where to store the info.
    Vector<unsigned> other_processor_1;
    Vector<unsigned> other_processor_2;
    Vector<unsigned> other_shared_boundaries;
    Vector<unsigned> other_indexes;

    // How many shared bounaries with other processors the node lives on
    unsigned n_shd_bnd_with_other_procs_have_node = 0;

    // Is the node on shared boundaries with other processors
    if (is_the_node_in_shared_boundaries_with_other_processors == 4)
    {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  In how many shared boundaries with other "
                 << "processors is the node "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif

      // How many nodes on other shared boundaries were found
      n_shd_bnd_with_other_procs_have_node =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      // Resize the containers
      other_processor_1.resize(n_shd_bnd_with_other_procs_have_node);
      other_processor_2.resize(n_shd_bnd_with_other_procs_have_node);
      other_shared_boundaries.resize(n_shd_bnd_with_other_procs_have_node);
      other_indexes.resize(n_shd_bnd_with_other_procs_have_node);

      for (unsigned i = 0; i < n_shd_bnd_with_other_procs_have_node; i++)
      {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Processor where the other shared boundary"
                   << "has the node"
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        // Read the other processor 1
        other_processor_1[i] =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Processor where the other shared boundary"
                   << "has the node"
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        // Read the other processor 2
        other_processor_2[i] =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Other shared boundary id where the node is on: "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif

        // Read the other shared boundary id
        other_shared_boundaries[i] =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Node index on the other shared boundary "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif

        // Read the node index on the other shared boundary
        other_indexes[i] =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      } // for (i < n_shd_bnd_with_other_procs_have_node)

    } // if (is_the_node_in_shared_boundaries_with_other_processors == 4)
#ifdef PARANOID
    else
    {
      if (is_the_node_in_shared_boundaries_with_other_processors != 0)
      {
        std::ostringstream error_message;
        error_message
          << "The current node is not on a shared boundary with\n"
          << "other processors, this should be indicated by a zero flag.\n"
          << "However, the read value for that flag is ("
          << is_the_node_in_shared_boundaries_with_other_processors << ").\n\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::construct_new_node_load_balance_helper()",
          OOMPH_EXCEPTION_LOCATION);
      }
    }
#endif

    // ------------------------------------------------------------
    // Receive the info. to check if the node is on a haloed element
    // with any processor

    // Store the halo element number with jproc where the node was found
    Vector<Vector<unsigned>> halo_element_number(nproc);
    // Store the node number on the halo element where the node was found
    Vector<Vector<unsigned>> halo_node_number_in_halo_element(nproc);

    // Loop over the processors
    for (unsigned jproc = 0; jproc < nproc; jproc++)
    {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  The node is on "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << " halo elements with " << jproc << " processor"
                 << std::endl;
#endif
      // Get the number of halo elements with jproc processor where the
      // node was found
      const unsigned n_jproc_halo_ele_node_is_on =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      // Resize the containers
      halo_element_number[jproc].resize(n_jproc_halo_ele_node_is_on);
      halo_node_number_in_halo_element[jproc].resize(
        n_jproc_halo_ele_node_is_on);

      // Read halo elements indexes (which are indexes of the halo
      // elements of the sender processor (iproc) with other processors
      // (included my_rank)
      for (unsigned i = 0; i < n_jproc_halo_ele_node_is_on; i++)
      {
        // Get the halo element index in the jproc processor
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  The halo element index where the node is on "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        // Get the node index on the halo element
        const unsigned halo_ele_index =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  The node index on the halo element where the node "
                   << "is on "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        const unsigned node_index_on_halo_ele =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        // Store the halo element number
        halo_element_number[jproc][i] = halo_ele_index;
        // Store the index of on the haloed element
        halo_node_number_in_halo_element[jproc][i] = node_index_on_halo_ele;

      } // for (i < n_jproc_halo_ele_node_is_on)

    } // for (jproc < nproc)

    // Store the node pointers obtained from the indicated halo elements
    // (use a set to check for the case when the node pointer is
    // different)
    std::set<Node*> set_haloed_node_pt;

    // Store the node pointer obtained from the haloed elements
    Node* haloed_node_pt = 0;

    // Flag to indicate if it is on a haloed element of the current
    // processor with the iproc processor. If this flag is true then
    // there is no need to read the info. to create the node, only copy
    // the node from the indicated haloed element-node
    bool on_haloed_element_with_iproc_processor = false;
    if (halo_element_number[my_rank].size() > 0)
    {
      // The node is part of the haloed element in the current processor
      // (my_rank) with the receiver processor
      on_haloed_element_with_iproc_processor = true;

      // Get the number of haloed elements in the current processor
      const unsigned n_haloed_indexes = halo_element_number[my_rank].size();
      // Loop over the different haloed indexes, and get the nodes
      // instances from all the indicated haloed elements (all of them
      // should be the same)
      for (unsigned i = 0; i < n_haloed_indexes; i++)
      {
        // Get the haloed element numbers where the node is on
        const unsigned haloed_index = halo_element_number[my_rank][i];
        // Get the node index on the haloed element
        const unsigned haloed_node_index =
          halo_node_number_in_halo_element[my_rank][i];

        // Get the haloed element (with iproc)
        FiniteElement* tmp_haloed_ele_pt = f_haloed_ele_pt[iproc][haloed_index];
        // Get the node on the indicated node number
        Node* tmp_haloed_node_pt =
          tmp_haloed_ele_pt->node_pt(haloed_node_index);

        // Set the pointer for the obtained haloed node
        haloed_node_pt = tmp_haloed_node_pt;

        // Add the node to the set of node pointers
        set_haloed_node_pt.insert(tmp_haloed_node_pt);

#ifdef PARANOID
        if (set_haloed_node_pt.size() > 1)
        {
          std::ostringstream error_message;
          error_message
            << "When adding the " << haloed_node_index << " node of the "
            << haloed_index << "-th haloed element\n"
            << "in the currrent processor with the " << iproc << " processor"
            << "it was found that\nthe node pointer is different from the other"
            << "instances of the node.\nIt means we have a repeated node."
            << "This are the node coordinates of the previous node instances\n"
            << "The last entry is for the just added node with a different "
               "node\n"
            << "pointer\n";
          for (std::set<Node*>::iterator it = set_haloed_node_pt.begin();
               it != set_haloed_node_pt.end();
               it++)
          {
            error_message << "Node: (" << (*it)->x(0) << ", " << (*it)->x(1)
                          << ")\n";
          }
          error_message << "\n";
          throw OomphLibError(
            error_message.str(),
            "RefineableTriangleMesh::construct_new_node_load_balance_helper()",
            OOMPH_EXCEPTION_LOCATION);
        }
#endif

      } // for (i < n_haloed_indexes)

    } // if (halo_element_number[iproc].size() > 0)

    // Flag to indicate if the node has been found on a haloed element
    // of other processor with the iproc processor
    bool found_on_haloed_element_with_other_processor = false;
    // Loop over the processors (only until the iproc since no info. of
    // higher processors has been received)
    for (unsigned jproc = 0; jproc < iproc; jproc++)
    {
      // Is the node on a halo element with the jproc processor
      if (halo_element_number[jproc].size() > 0)
      {
        // Get the number of halo elements with the jproc processor
        const unsigned n_halo_indexes = halo_element_number[jproc].size();
        // Loop over the different halo indexes, and get the nodes
        // instances from all the indicated halo elements (all of them
        // should be the same)
        for (unsigned i = 0; i < n_halo_indexes; i++)
        {
          // Get the haloed element numbers where the node is on
          const unsigned haloed_index = halo_element_number[jproc][i];
          // Get the node index on the haloed element
          const unsigned haloed_node_index =
            halo_node_number_in_halo_element[jproc][i];

          // Have we received the indicated element? (Get the haloed
          // element on jproc with the iproc processor)
          std::map<unsigned, FiniteElement*>::iterator it_map =
            received_old_haloed_element_pt[jproc][iproc].find(haloed_index);
          // Have we received the indicated element?
          if (it_map != received_old_haloed_element_pt[jproc][iproc].end())
          {
            // Set the flag of found element in other processors haloed
            // element, in this case in haloed elements of processor
            // jproc wiht iproc processor
            found_on_haloed_element_with_other_processor = true;

            // Get the element
            FiniteElement* tmp_haloed_ele_pt = (*it_map).second;
            // Get the node on the indicated node number
            Node* tmp_haloed_node_pt =
              tmp_haloed_ele_pt->node_pt(haloed_node_index);

            // Set the pointer for the obtained haloed node
            haloed_node_pt = tmp_haloed_node_pt;

            // Add the node to the set of node pointers
            set_haloed_node_pt.insert(tmp_haloed_node_pt);

#ifdef PARANOID
            if (set_haloed_node_pt.size() > 1)
            {
              std::ostringstream error_message;
              error_message
                << "When adding the " << haloed_node_index << " node of the "
                << haloed_index << "-th haloed element "
                << "of the " << jproc << " processor\nwith the " << iproc
                << " processor, it was found that\n"
                << "the node pointer is different from the other\n"
                << "instances of the node.\nThis means we have a repeated "
                   "node.\n"
                << "These are the node coordinates of the previous node "
                << "instances\n"
                << "The last entry is for the just added node with a "
                   "different\n"
                << "node pointer\n";
              for (std::set<Node*>::iterator it = set_haloed_node_pt.begin();
                   it != set_haloed_node_pt.end();
                   it++)
              {
                error_message << "Node: (" << (*it)->x(0) << ", " << (*it)->x(1)
                              << ")\n";
              }
              error_message << "\n";
              throw OomphLibError(error_message.str(),
                                  "RefineableTriangleMesh::construct_new_node_"
                                  "load_balance_helper()",
                                  OOMPH_EXCEPTION_LOCATION);
            }
#endif

          } // if (it_map != received_old_haloed_element_pt[jproc][iproc].end())
            // Have we received the element?

        } // for (i < n_haloed_indexes)

      } // if (halo_element_number[iproc].size() > 0)

    } // for (jproc < nproc)

    // If the node was found in the haloed elements of the current
    // processor with the iproc processor, or in the haloed elements of
    // any other processor with the iproc processor then copy the node
    // pointer (no problem if we overwrite the node info. it should be
    // the same node pointer)
    if (on_haloed_element_with_iproc_processor ||
        found_on_haloed_element_with_other_processor)
    {
      // Set the node pointer
      new_nod_pt = haloed_node_pt;
    }

    // Now we have all the info. to decide if the node should be created
    // or not

    // First check if the node is a shared boundary node, or if it has
    // been found on haloed elements
    if (is_node_on_shared_boundary == 1 ||
        (on_haloed_element_with_iproc_processor))
    {
      // We already have the node, we do not need to create it

      // Only check if we need to add boundary info. to the node
      if (node_on_original_boundaries == 2)
      {
        // The node is a boundary node, add the boundary info. before
        // adding it to the domain

        // Associate the node to the given boundaries
        for (unsigned i = 0; i < n_original_boundaries_node_is_on; i++)
        {
          add_boundary_node(original_boundaries_node_is_on[i], new_nod_pt);
          // Establish the boundary coordinates for the node
          Vector<double> zeta(1);
          zeta[0] = zeta_coordinates[i];
          new_nod_pt->set_coordinates_on_boundary(
            original_boundaries_node_is_on[i], zeta);
        }

      } // if (node_on_original_boundaries==2)

      // Add the node to the domain
      new_nodes_on_domain.push_back(new_nod_pt);

      // Add the node to the element
      new_el_pt->node_pt(node_index) = new_nod_pt;

    } // if (is_node_on_shared_boundary == 1)

    // Now check if the node is on a shared boundary with another
    // processor, if that is the case try to find the node that may have
    // been already sent by the other processors

    // This flags indicates if the node was found, and then decide if it
    // is required to create the node
    bool found_node_in_other_shared_boundaries = false;
    // Flag to indicate whether the node should be created as a boundary
    // node or not. If the node lies on a shared boundary with other
    // processor the we create it as a boundary node. The processor from
    // which we are receiving info. (iproc) may not know that the node
    // lies on an original boundary. If the node lies on an original
    // boundary then its info. will be sent by another processor, then
    // we can set its boundary info. since the node was constructed as a
    // boundary node
    bool build_node_as_boundary_node = false;

    if (is_the_node_in_shared_boundaries_with_other_processors == 4)
    {
      // Build the node as a boundary node
      build_node_as_boundary_node = true;

      // Try to get the node pointer in case that the node has been
      // already sent by the other processors

      // Get the number of initial shared boundaries to correct the
      // index of the shared boundary
      const unsigned initial_shd_bnd_id = this->initial_shared_boundary_id();

      // Add the found nodes in the container, should be the same but
      // better check
      Vector<Node*> found_node_pt;

      // Now try to find the node in any of the other shared boundaries
      for (unsigned i = 0; i < n_shd_bnd_with_other_procs_have_node; i++)
      {
        unsigned oproc1 = other_processor_1[i];
        unsigned oproc2 = other_processor_2[i];

        // Check that we always check with the lower processors number
        // first
        if (oproc1 > oproc2)
        {
          oproc2 = oproc1;
          oproc1 = other_processor_2[i];
        } // if (oproc1 > oproc2)

        // Re-compute the shared boundary id between the other
        // processors
        const unsigned shd_bnd_id =
          other_shared_boundaries[i] - initial_shd_bnd_id;
        // Read the index
        const unsigned index = other_indexes[i];

        // Check if there are nodes received from the other processor
        // and with the given shared boundary
        const unsigned n_nodes_on_other_processor =
          other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id].size();

        if (n_nodes_on_other_processor > 0)
        {
          // Check if we can find the index of the node in that other
          // processor and shared boundary id
          std::map<unsigned, Node*>::iterator it =
            other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id].find(index);

          // If the index exist then get the node pointer
          if (it !=
              other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id].end())
          {
            // Mark the node as found
            found_node_in_other_shared_boundaries = true;
            // Get the node pointer
            Node* tmp_node_pt =
              other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id][index];
            found_node_pt.push_back(tmp_node_pt);
          } // if (it!=
            // other_proc_shd_bnd_node_pt[oproc1][oproc2][shd_bnd_id].end())

        } // if (n_nodes_on_other_processor > 0)

      } // for (i < n_shd_bnd_with_other_procs_have_node)

      // If the node was found, then all their instances should be the
      // same but better check
      if (found_node_in_other_shared_boundaries)
      {
#ifdef PARANOID
        const unsigned ntimes_node_found = found_node_pt.size();
        for (unsigned j = 1; j < ntimes_node_found; j++)
        {
          if (found_node_pt[j - 1] != found_node_pt[j])
          {
            std::ostringstream error_message;
            error_message
              << "The instances of the node that was found to be on a\n"
              << "shared boundary with other processors are not the same,\n"
              << "the coordinates for the nodes are these:\n"
              << "(" << found_node_pt[j - 1]->x(0) << ", "
              << found_node_pt[j - 1]->x(1) << ")\n"
              << "(" << found_node_pt[j]->x(0) << ", " << found_node_pt[j]->x(1)
              << ")\n"
              << "Not be surprised if they are the same since the node is\n"
              << "repeated!!!\n";
            throw OomphLibError(
              error_message.str(),
              "RefineableTriangleMesh::construct_new_halo_node_helper()",
              OOMPH_EXCEPTION_LOCATION);

          } // if (found_node_pt[j-1] != found_node_pt[j])

        } // for (j < ntimes_node_found)
#endif

        // Check if the node is a shared boundary node from the current
        // processor and the iproc processor, if that is the case, and
        // the node is also on a shared boundary with other processor,
        // then the pointer should be the same!!!
        if (is_node_on_shared_boundary == 1)
        {
          // The pointer to the node is already assigned, it was
          // assigned when thenode was found to be on a shared boundary
          // with the iproc processor
          if (found_node_pt[0] != new_nod_pt)
          {
            std::ostringstream error_message;
            error_message
              << "The pointer of the node that was found to be on a\n"
              << "shared boundary with other processor(s) and the pointer\n"
              << "of the node on shared boundary with the receiver\n"
              << "processor (iproc) are not the same. This means we have a\n"
              << "repeated node)\n"
              << "The coordinates for the nodes are:\n"
              << "(" << found_node_pt[0]->x(0) << ", " << found_node_pt[0]->x(1)
              << ")\n"
              << "(" << new_nod_pt->x(0) << ", " << new_nod_pt->x(1) << ")\n"
              << "Not to be surprised if they are the same since the node is\n"
              << "repeated!!!\n";
            throw OomphLibError(
              error_message.str(),
              "RefineableTriangleMesh::construct_new_halo_node_helper()",
              OOMPH_EXCEPTION_LOCATION);
          } // if (found_node_pt[0] != new_nod_pt)

        } // if (is_node_on_shared_boundary == 1)
        else
        {
          // Take the first instance of the node in case that it was
          // found and is not on a shared boundary with the iproc
          // processor
          new_nod_pt = found_node_pt[0];
        }

      } // if (found_node_in_other_shared_boundaries)

    } // if (is_the_node_in_shared_boundaries_with_other_processors == 4)

    // -----------------------------------------------------------------
    // Create the node or read the received info if the node is not on a
    // shared boundary with the iproc processor and if the node is not
    // part of the haloed elements with the iproc processor in the
    // current processors
    if (is_node_on_shared_boundary != 1 &&
        !on_haloed_element_with_iproc_processor)
    {
      // If the node is on a shared boundary with other processor we
      // need to read all the info. since the processor that sent the
      // info. did not know that the node is part of another shared
      // boundary

      // If the node is not a shared boundary (with any processor), or
      // if this is the first time that the info. of the node is
      // received from any of the processors with which is has a shared
      // boundary, then we create the node

      // Is the node a boundary node or should it be build as a boundary
      // node because it is on a shared boundary with other processors
      if (node_on_original_boundaries == 2 || build_node_as_boundary_node)
      {
        // Check if necessary to create the node, or if it has been
        // already found in shared boundaries with other processors or
        // in the haloed elements with of other processors with the
        // iproc processor
        if (!found_node_in_other_shared_boundaries ||
            !found_on_haloed_element_with_other_processor)
        {
          // Construct a boundary node
          if (time_stepper_pt != 0)
          {
            new_nod_pt =
              new_el_pt->construct_boundary_node(node_index, time_stepper_pt);
          }
          else
          {
            new_nod_pt = new_el_pt->construct_boundary_node(node_index);
          }

        } // if (!found_node_in_other_shared_boundaries ||
          //     !found_on_haloed_element_with_other_processor)
        else
        {
          // If the node was found then assign the node to the element
          new_el_pt->node_pt(node_index) = new_nod_pt;
        } // else if (!found_node_in_other_shared_boundaries ||
          //      !found_on_haloed_element_with_other_processor)

        // Associate the node to the given boundaries
        for (unsigned i = 0; i < n_original_boundaries_node_is_on; i++)
        {
          add_boundary_node(original_boundaries_node_is_on[i], new_nod_pt);
          // Establish the boundary coordinates for the node
          Vector<double> zeta(1);
          zeta[0] = zeta_coordinates[i];
          new_nod_pt->set_coordinates_on_boundary(
            original_boundaries_node_is_on[i], zeta);
        }

      } // if (node is on an original boundary)
      else
      {
        // Check if necessary to create the node, or if it has been
        // already found in shared boundaries with other processors or
        // in the haloed elements with of other processors with the
        // iproc processor
        if (!found_node_in_other_shared_boundaries ||
            !found_on_haloed_element_with_other_processor)
        {
          // Construct an ordinary (non-boundary) node
          if (time_stepper_pt != 0)
          {
            new_nod_pt = new_el_pt->construct_node(node_index, time_stepper_pt);
          }
          else
          {
            new_nod_pt = new_el_pt->construct_node(node_index);
          }
        } // if (!found_node_in_other_shared_boundaries ||
          //     !found_on_haloed_element_with_other_processor)
        else
        {
          // If the node was found then assign the node to the element
          new_el_pt->node_pt(node_index) = new_nod_pt;
        } // else // if (!found_node_in_other_shared_boundaries ||
          //             !found_on_haloed_element_with_other_processor)

      } // else (the node is not a boundary node)

      // ... and gather all its information

      // If the node was found or not in other shared boundaries, this
      // is the first time the node is received from this processor
      // (iproc), therefore it is added to the vector of nodes received
      // from this processor (iproc)
      new_nodes_on_domain.push_back(new_nod_pt);

      // Check if necessary to state all the info. to the node if it has
      // been already found in shared boundaries with other processors
      // or in the haloed elements with of other processors with the
      // iproc processor
      if (!found_node_in_other_shared_boundaries ||
          !found_on_haloed_element_with_other_processor)
      {
        // Add the node to the general node storage
        this->add_node_pt(new_nod_pt);
      } // if (!found_node_in_other_shared_boundaries ||
        //     !found_on_haloed_element_with_other_processor)

      // Is the new constructed node Algebraic?
      AlgebraicNode* new_alg_nod_pt = dynamic_cast<AlgebraicNode*>(new_nod_pt);

      // If it is algebraic, its node update functions will
      // not yet have been set up properly
      if (new_alg_nod_pt != 0)
      {
        // The AlgebraicMesh is the external mesh
        AlgebraicMesh* alg_mesh_pt = dynamic_cast<AlgebraicMesh*>(this);

        /// The first entry of All_alg_nodal_info contains
        /// the default node update id
        /// e.g. for the quarter circle there are
        /// "Upper_left_box", "Lower right box" etc...
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Alg node update id "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif

        unsigned update_id =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        Vector<double> ref_value;

        // The size of this vector is in the next entry
        // of All_alg_nodal_info
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Alg node # of ref values "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        unsigned n_ref_val =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        // The reference values themselves are in
        // All_alg_ref_value
        ref_value.resize(n_ref_val);
        for (unsigned i_ref = 0; i_ref < n_ref_val; i_ref++)
        {
          ref_value[i_ref] =
            Flat_packed_doubles[Counter_for_flat_packed_doubles++];
        }

        Vector<GeomObject*> geom_object_pt;
        /// again we need the size of this vector as it varies
        /// between meshes; we also need some indication
        /// as to which geometric object should be used...

        // The size of this vector is in the next entry
        // of All_alg_nodal_info
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Alg node # of geom objects "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        unsigned n_geom_obj =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        // The remaining indices are in the rest of
        // All_alg_nodal_info
        geom_object_pt.resize(n_geom_obj);
        for (unsigned i_geom = 0; i_geom < n_geom_obj; i_geom++)
        {
#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
          oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                     << "  Alg node: geom object index "
                     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                     << std::endl;
#endif
          unsigned geom_index =
            Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
          // This index indicates which of the AlgebraicMesh's
          // stored geometric objects should be used
          // (0 is a null pointer; everything else should have
          //  been filled in by the specific Mesh).  If it
          // hasn't been filled in then the update_node_update
          // call should fix it
          geom_object_pt[i_geom] = alg_mesh_pt->geom_object_list_pt(geom_index);
        }

        // Check if necessary to state all the info. to the node if it
        // has been already found in shared boundaries with other
        // processors or in the haloed elements with of other processors
        // with the iproc processor
        if (!found_node_in_other_shared_boundaries ||
            !found_on_haloed_element_with_other_processor)
        {
          /// For the received update_id, ref_value, geom_object
          /// call add_node_update_info
          new_alg_nod_pt->add_node_update_info(
            update_id, alg_mesh_pt, geom_object_pt, ref_value);

          /// Now call update_node_update
          alg_mesh_pt->update_node_update(new_alg_nod_pt);

        } // if (!found_node_in_other_shared_boundaries ||
          //     !found_on_haloed_element_with_other_processor)

      } // if (new_alg_nod_pt!=0)

      // Check if necessary to state all the info. to the node if it has
      // been already found in shared boundaries with other processors
      // or in the haloed elements with of other processors with the
      // iproc processor
      if (!found_node_in_other_shared_boundaries ||
          !found_on_haloed_element_with_other_processor)
      {
        // Is the node a MacroElementNodeUpdateNode?
        MacroElementNodeUpdateNode* macro_nod_pt =
          dynamic_cast<MacroElementNodeUpdateNode*>(new_nod_pt);

        if (macro_nod_pt != 0)
        {
          // Need to call set_node_update_info; this requires
          // a Vector<GeomObject*> (taken from the mesh)
          Vector<GeomObject*> geom_object_vector_pt;

          // Access the required geom objects from the
          // MacroElementNodeUpdateMesh
          MacroElementNodeUpdateMesh* macro_mesh_pt =
            dynamic_cast<MacroElementNodeUpdateMesh*>(this);
          geom_object_vector_pt = macro_mesh_pt->geom_object_vector_pt();

          // Get local coordinate of node in new element
          Vector<double> s_in_macro_node_update_element;
          new_el_pt->local_coordinate_of_node(node_index,
                                              s_in_macro_node_update_element);

          // Set node update info for this node
          macro_nod_pt->set_node_update_info(
            new_el_pt, s_in_macro_node_update_element, geom_object_vector_pt);
        }

      } // if (!found_node_in_other_shared_boundaries ||
        //     !found_on_haloed_element_with_other_processor)

      // If there are additional values, resize the node
      unsigned n_new_val = new_nod_pt->nvalue();

      // Check if necessary to state all the info. to the node if it has
      // been already found in shared boundaries with other processors
      // or in the haloed elements with of other processors with the
      // iproc processor
      if (!found_node_in_other_shared_boundaries ||
          !found_on_haloed_element_with_other_processor)
      {
        if (n_val > n_new_val)
        {
          // If it has been necessary to resize then it may be becuse
          // the node is on a FSI boundary, if that is the case we need
          // to set a map for these external values

          // Cast to a boundary node
          BoundaryNodeBase* bnod_pt =
            dynamic_cast<BoundaryNodeBase*>(new_nod_pt);

          // Create storage, if it doesn't already exist, for the map
          // that will contain the position of the first entry of
          // this face element's additional values,
          if (bnod_pt->index_of_first_value_assigned_by_face_element_pt() == 0)
          {
            bnod_pt->index_of_first_value_assigned_by_face_element_pt() =
              new std::map<unsigned, unsigned>;
          }

          // Get pointer to the map
          std::map<unsigned, unsigned>* map_pt =
            bnod_pt->index_of_first_value_assigned_by_face_element_pt();

          // The id of the face to which this node belong in the bulk
          // element
          const unsigned id_face = 0;
          // We only resize the node values Vector if we haven't done it yet
          std::map<unsigned, unsigned>::const_iterator p =
            map_pt->find(id_face);

          // If this node hasn't been resized for current id
          if (p == map_pt->end())
          {
            // assign the face element id and the position of the
            // first entry to the boundary node
            (*map_pt)[id_face] = n_new_val;

            // resize the node vector of values
            new_nod_pt->resize(n_val);
          }

        } // if (n_val>n_new_val)

      } // if (!found_node_in_other_shared_boundaries ||
        //     !found_on_haloed_element_with_other_processor)

      // Is the new node a SolidNode?
      SolidNode* solid_nod_pt = dynamic_cast<SolidNode*>(new_nod_pt);
      if (solid_nod_pt != 0)
      {
        unsigned n_solid_val = solid_nod_pt->variable_position_pt()->nvalue();
        for (unsigned i_val = 0; i_val < n_solid_val; i_val++)
        {
          for (unsigned t = 0; t < n_prev; t++)
          {
            double read_data =
              Flat_packed_doubles[Counter_for_flat_packed_doubles++];

            // Check if necessary to state all the info. to the node if
            // it has been already found in shared boundaries with other
            // processors or in the haloed elements with of other
            // processors with the iproc processor
            if (!found_node_in_other_shared_boundaries ||
                !found_on_haloed_element_with_other_processor)
            {
              solid_nod_pt->variable_position_pt()->set_value(
                t, i_val, read_data);
            } // if (!found_node_in_other_shared_boundaries ||
              //     !found_on_haloed_element_with_other_processor)
          }
        }

#ifdef ANNOTATE_REFINEABLE_TRIANGLE_MESH_COMMUNICATION_LOAD_BALANCE
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Number of values solid node: "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        const unsigned nvalues_solid_node =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        Vector<double> values_solid_node(nvalues_solid_node);
        for (unsigned i = 0; i < nvalues_solid_node; i++)
        {
          values_solid_node[i] =
            Flat_packed_doubles[Counter_for_flat_packed_doubles++];
        }

        // Check if necessary to state all the info. to the node if it
        // has been already found in shared boundaries with other
        // processors or in the haloed elements with of other processors
        // with the iproc processor
        if (!found_node_in_other_shared_boundaries ||
            !found_on_haloed_element_with_other_processor)
        {
          unsigned index = 0;
          solid_nod_pt->read_values_from_vector(values_solid_node, index);
        } // if (!found_node_in_other_shared_boundaries ||
          //     !found_on_haloed_element_with_other_processor)
      }

      // Get copied history values
      //  unsigned n_val=new_nod_pt->nvalue();
      for (unsigned i_val = 0; i_val < n_val; i_val++)
      {
        for (unsigned t = 0; t < n_prev; t++)
        {
          double read_data =
            Flat_packed_doubles[Counter_for_flat_packed_doubles++];

          // Check if necessary to state all the info. to the node if it
          // has been already found in shared boundaries with other
          // processors or in the haloed elements with of other
          // processors with the iproc processor
          if (!found_node_in_other_shared_boundaries ||
              !found_on_haloed_element_with_other_processor)
          {
            new_nod_pt->set_value(t, i_val, read_data);
          } // if (!found_node_in_other_shared_boundaries ||
            //     !found_on_haloed_element_with_other_processor)
        }
      }

      // Get copied history values for positions
      unsigned n_dim = new_nod_pt->ndim();
      for (unsigned idim = 0; idim < n_dim; idim++)
      {
        for (unsigned t = 0; t < n_prev; t++)
        {
          double read_data =
            Flat_packed_doubles[Counter_for_flat_packed_doubles++];

          // Check if necessary to state all the info. to the node if it
          // has been already found in shared boundaries with other
          // processors or in the haloed elements with of other
          // processors with the iproc processor
          if (!found_node_in_other_shared_boundaries ||
              !found_on_haloed_element_with_other_processor)
          {
            // Copy to coordinate
            new_nod_pt->x(t, idim) = read_data;
            //          DEBP(new_nod_pt->x(t,idim));
          } // if (!found_node_in_other_shared_boundaries ||
            //     !found_on_haloed_element_with_other_processor)
        }
      }

    } // if (is_node_on_shared_boundary != 1)

    // If the node was not found in other shared boundaries (possibly
    // because it is the first time the node has been sent) then copy
    // the node to the shared boundaries where it should be, use the
    // special container for this cases
    if (n_shd_bnd_with_other_procs_have_node > 0 && // The node is on
                                                    // shared
                                                    // boundaries with
                                                    // other processors
        !found_node_in_other_shared_boundaries) // The node has not
                                                // been previously
                                                // set as with
                                                // shared with
                                                // other processors
                                                // (first time)
    {
      // Update the node pointer in all the references of the node
      this->update_other_proc_shd_bnd_node_helper(new_nod_pt,
                                                  other_proc_shd_bnd_node_pt,
                                                  other_processor_1,
                                                  other_processor_2,
                                                  other_shared_boundaries,
                                                  other_indexes,
                                                  global_node_names,
                                                  node_name_to_global_index,
                                                  global_shared_node_pt);

    } // if (!found_node_in_other_shared_boundaries)
  }

#endif // #ifdef OOMPH_HAS_MPI

  //======================================================================
  /// Get the nodes on the boundary (b), these are stored in the
  /// segment they belong (also used by the load balance method to
  /// re-set the number of segments per boundary after load balance has
  /// taken place)
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::get_boundary_segment_nodes_helper(
    const unsigned& b, Vector<Vector<Node*>>& tmp_segment_nodes)
  {
    // Clear the data structure were to return the nodes
    tmp_segment_nodes.clear();

    // Temporary storage for face elements
    Vector<FiniteElement*> face_el_pt;

    // Temporary storage for number of elements adjacent to the boundary
    unsigned nel = 0;

    // Temporary storage for elements adjacent to the boundary that have
    // a common edge (related with internal boundaries)
    unsigned n_repeated_ele = 0;

    // Get the number of regions
    const unsigned n_regions = this->nregion();

    // Temporary storage for already visited pair of nodes (edges)
    Vector<std::pair<Node*, Node*>> done_nodes_pt;

    // Are there more than one region?
    if (n_regions > 1)
    {
      for (unsigned rr = 0; rr < n_regions; rr++)
      {
        const unsigned region_id =
          static_cast<unsigned>(this->Region_attribute[rr]);

        // Loop over all elements on boundaries in region rr
        const unsigned nel_in_region =
          this->nboundary_element_in_region(b, region_id);

        // Number of repeated element in region
        unsigned nel_repeated_in_region = 0;

        // Only bother to do anything else, if there are elements
        // associated with the boundary and the current region
        if (nel_in_region > 0)
        {
          // Flag that activates when a repeated face element is found,
          // possibly because we are dealing with an internal boundary
          bool repeated = false;

          // Loop over the bulk elements adjacent to boundary b
          for (unsigned e = 0; e < nel_in_region; e++)
          {
            // Get pointer to the bulk element that is adjacent to boundary b
            FiniteElement* bulk_elem_pt =
              this->boundary_element_in_region_pt(b, region_id, e);

#ifdef OOMPH_HAS_MPI
            // In a distributed mesh only work with nonhalo elements
            if (this->is_mesh_distributed() && bulk_elem_pt->is_halo())
            {
              // Increase the number of repeated elements
              n_repeated_ele++;
              // Go for the next element
              continue;
            }
#endif

            // Find the index of the face of element e along boundary b
            int face_index =
              this->face_index_at_boundary_in_region(b, region_id, e);

            // Before adding the new element we need to be sure that the
            // edge that this element represents has not been already
            // added
            FiniteElement* tmp_ele_pt =
              new DummyFaceElement<ELEMENT>(bulk_elem_pt, face_index);

            // Number of nodes in the face element
            const unsigned n_nodes = tmp_ele_pt->nnode();

            std::pair<Node*, Node*> tmp_pair = std::make_pair(
              tmp_ele_pt->node_pt(0), tmp_ele_pt->node_pt(n_nodes - 1));

            std::pair<Node*, Node*> tmp_pair_inverse = std::make_pair(
              tmp_ele_pt->node_pt(n_nodes - 1), tmp_ele_pt->node_pt(0));

            // Search for repeated nodes
            unsigned n_done_nodes = done_nodes_pt.size();
            for (unsigned l = 0; l < n_done_nodes; l++)
            {
              if (tmp_pair == done_nodes_pt[l] ||
                  tmp_pair_inverse == done_nodes_pt[l])
              {
                nel_repeated_in_region++;
                repeated = true;
                break;
              }

            } // for (l < n_done_nodes)

            // Create new face element?
            if (!repeated)
            {
              // Add the pair of nodes (edge) to the node dones
              done_nodes_pt.push_back(tmp_pair);
              // Add the face element to the storage
              face_el_pt.push_back(tmp_ele_pt);
            }
            else
            {
              // Clean up
              delete tmp_ele_pt;
              tmp_ele_pt = 0;
            }

            // Re-start
            repeated = false;

          } // for (e < nel_in_region)

          // Add on the number of elements in the boundary with the
          // current region
          nel += nel_in_region;

          // Add on the number of repeated elements
          n_repeated_ele += nel_repeated_in_region;

        } // if (nel_in_region > 0)

      } // for (rr < n_regions)

    } // if (n_regions > 1)
    // Otherwise it's just the normal boundary functions
    else
    {
      // Assign the number of boundary elements
      nel = this->nboundary_element(b);

      // Only bother to do anything else, if there are elements
      if (nel > 0)
      {
        // Flag that activates when a repeated face element is found,
        // possibly because we are dealing with an internal boundary
        bool repeated = false;

        // Loop over the bulk elements adjacent to boundary b
        for (unsigned e = 0; e < nel; e++)
        {
          // Get pointer to the bulk element that is adjacent to boundary b
          FiniteElement* bulk_elem_pt = this->boundary_element_pt(b, e);

#ifdef OOMPH_HAS_MPI
          // In a distributed mesh only work with nonhalo elements
          if (this->is_mesh_distributed() && bulk_elem_pt->is_halo())
          {
            // Increase the number of repeated elements
            n_repeated_ele++;
            // Go for the next element
            continue;
          }
#endif

          // Find the index of the face of element e along boundary b
          int face_index = this->face_index_at_boundary(b, e);

          // Before adding the new element we need to be sure that the
          // edge that this element represent has not been already added
          FiniteElement* tmp_ele_pt =
            new DummyFaceElement<ELEMENT>(bulk_elem_pt, face_index);

          // Number of nodes in the face element
          const unsigned n_nodes = tmp_ele_pt->nnode();

          std::pair<Node*, Node*> tmp_pair = std::make_pair(
            tmp_ele_pt->node_pt(0), tmp_ele_pt->node_pt(n_nodes - 1));

          std::pair<Node*, Node*> tmp_pair_inverse = std::make_pair(
            tmp_ele_pt->node_pt(n_nodes - 1), tmp_ele_pt->node_pt(0));

          // Search for repeated nodes
          unsigned n_done_nodes = done_nodes_pt.size();
          for (unsigned l = 0; l < n_done_nodes; l++)
          {
            if (tmp_pair == done_nodes_pt[l] ||
                tmp_pair_inverse == done_nodes_pt[l])
            {
              n_repeated_ele++;
              repeated = true;
              break;
            }

          } // for (l < n_done_nodes)

          // Create new face element
          if (!repeated)
          {
            // Add the pair of nodes (edge) to the node dones
            done_nodes_pt.push_back(tmp_pair);
            // Add the face element to the storage
            face_el_pt.push_back(tmp_ele_pt);
          }
          else
          {
            // Free the repeated bulk element!!
            delete tmp_ele_pt;
            tmp_ele_pt = 0;
          }

          // Re-start
          repeated = false;

        } // for (e < nel)

      } // if (nel > 0)

    } // else if (n_regions > 1)

    // Substract the repeated elements
    nel -= n_repeated_ele;

#ifdef PARANOID
    if (nel != face_el_pt.size())
    {
      std::ostringstream error_message;
      error_message
        << "The independet counting of face elements (" << nel << ") for "
        << "boundary (" << b << ") is different\n"
        << "from the real number of face elements in the container ("
        << face_el_pt.size() << ")\n";
      throw OomphLibError(
        error_message.str(),
        "RefineableTriangleMesh::get_boundary_segment_nodes_helper()",
        OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Only bother to do anything else, if there are elements
    if (nel > 0)
    {
      // Assign the number of nonhalo face elements
      const unsigned nnon_halo_face_elements = nel;

      // The vector of list to store the "segments" that compound the
      // boundary (segments may appear only in a distributed mesh)
      Vector<std::list<FiniteElement*>> segment_sorted_ele_pt;

      // Number of already sorted face elements (only nonhalo face
      // elements for a distributed mesh)
      unsigned nsorted_face_elements = 0;

      // Keep track of who's done (in a distributed mesh this apply to
      // nonhalo only)
      std::map<FiniteElement*, bool> done_ele;

      // Keep track of which element is inverted (in distributed mesh
      // the elements may be inverted with respect to the segment they
      // belong)
      std::map<FiniteElement*, bool> is_inverted;

      // Iterate until all possible segments have been created. In a non
      // distributed mesh there is only one segment which defines the
      // complete boundary
      while (nsorted_face_elements < nnon_halo_face_elements)
      {
        // The ordered list of face elements (in a distributed mesh a
        // collection of continuous face elements define a segment)
        std::list<FiniteElement*> sorted_el_pt;

#ifdef PARANOID
        // Select an initial element for the segment
        bool found_initial_face_element = false;
#endif

        FiniteElement* ele_face_pt = 0;

        unsigned iface = 0;
#ifdef OOMPH_HAS_MPI
        if (this->is_mesh_distributed())
        {
          for (iface = 0; iface < nel; iface++)
          {
            ele_face_pt = face_el_pt[iface];
            // If not done then take it as initial face element
            if (!done_ele[ele_face_pt])
            {
#ifdef PARANOID
              // Set the flag to indicate the initial element was
              // found
              found_initial_face_element = true;
#endif
              // Increase the number of sorted face elements
              nsorted_face_elements++;
              // Set the index to the next face element
              iface++;
              // Add the face element in the container
              sorted_el_pt.push_back(ele_face_pt);
              // Mark as done
              done_ele[ele_face_pt] = true;
              break;
            } // if (!done_el[ele_face_pt])
          } // for (iface < nel)
        } // if (this->is_mesh_distributed())
        else
        {
#endif // #ifdef OOMPH_HAS_MPI

          // When the mesh is not distributed just take the first
          // element and put it in the ordered list
          ele_face_pt = face_el_pt[0];
#ifdef PARANOID
          // Set the flag to indicate the initial element was found
          found_initial_face_element = true;
#endif
          // Increase the number of sorted face elements
          nsorted_face_elements++;
          // Set the index to the next face element
          iface = 1;
          // Add the face element in the container
          sorted_el_pt.push_back(ele_face_pt);
          // Mark as done
          done_ele[ele_face_pt] = true;
#ifdef OOMPH_HAS_MPI
        } // else if (this->is_mesh_distributed())
#endif

#ifdef PARANOID
        if (!found_initial_face_element)
        {
          std::ostringstream error_message;
          error_message << "Could not find an initial face element for the "
                           "current segment\n";
          throw OomphLibError(
            error_message.str(),
            "RefineableTriangleMesh::get_boundary_segment_nodes_helper()",
            OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // Number of nodes in the face element
        const unsigned nnod = ele_face_pt->nnode();

        // Left and rightmost nodes (the left and right nodes of the
        // current face element)
        Node* left_node_pt = ele_face_pt->node_pt(0);
        Node* right_node_pt = ele_face_pt->node_pt(nnod - 1);

        // Continue iterating if a new face element has been added to
        // the list
        bool face_element_added = false;

        // While a new face element has been added to the set of sorted
        // face elements continue iterating
        do
        {
          // Start from the next face element since we have already
          // added the previous one as the initial face element (any
          // previous face element had to be added on previous
          // iterations)
          for (unsigned iiface = iface; iiface < nel; iiface++)
          {
            // Re-start flag
            face_element_added = false;

            // Get the candidate element
            ele_face_pt = face_el_pt[iiface];

            // Check that the candidate element has not been done and is
            // not a halo element
            if (!done_ele[ele_face_pt])
            {
              // Get the left and right nodes of the current element
              Node* local_left_node_pt = ele_face_pt->node_pt(0);
              Node* local_right_node_pt = ele_face_pt->node_pt(nnod - 1);

              // New element fits at the left of segment and is not inverted
              if (left_node_pt == local_right_node_pt)
              {
                left_node_pt = local_left_node_pt;
                sorted_el_pt.push_front(ele_face_pt);
                is_inverted[ele_face_pt] = false;
                face_element_added = true;
              }
              // New element fits at the left of segment and is inverted
              else if (left_node_pt == local_left_node_pt)
              {
                left_node_pt = local_right_node_pt;
                sorted_el_pt.push_front(ele_face_pt);
                is_inverted[ele_face_pt] = true;
                face_element_added = true;
              }
              // New element fits on the right of segment and is not inverted
              else if (right_node_pt == local_left_node_pt)
              {
                right_node_pt = local_right_node_pt;
                sorted_el_pt.push_back(ele_face_pt);
                is_inverted[ele_face_pt] = false;
                face_element_added = true;
              }
              // New element fits on the right of segment and is inverted
              else if (right_node_pt == local_right_node_pt)
              {
                right_node_pt = local_left_node_pt;
                sorted_el_pt.push_back(ele_face_pt);
                is_inverted[ele_face_pt] = true;
                face_element_added = true;
              }

              if (face_element_added)
              {
                // Mark the face element as done
                done_ele[ele_face_pt] = true;
                nsorted_face_elements++;
                break;
              }

            } // if (!done_el[ele_face_pt])

          } // for (iiface<nnon_halo_face_element)

        } while (face_element_added &&
                 (nsorted_face_elements < nnon_halo_face_elements));

        // Store the created segment in the vector of segments
        segment_sorted_ele_pt.push_back(sorted_el_pt);

      } // while(nsorted_face_elements < nnon_halo_face_elements);

      // The number of boundary segments in this processor
      const unsigned nsegments = segment_sorted_ele_pt.size();

#ifdef PARANOID
      if (nnon_halo_face_elements > 0 && nsegments == 0)
      {
        std::ostringstream error_message;
        error_message
          << "The number of segments is zero, but the number of nonhalo\n"
          << "elements is: (" << nnon_halo_face_elements << ")\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::get_boundary_segment_nodes_helper()",
          OOMPH_EXCEPTION_LOCATION);
      } // if (nnon_halo_face_elements > 0 && nsegments == 0)
#endif

      // Go through all the segments, visit each face element in order
      // and get the nodes based that represent the boundary segment

      // Resize the container to store the nodes with the required
      // number of segments
      tmp_segment_nodes.resize(nsegments);

      for (unsigned is = 0; is < nsegments; is++)
      {
#ifdef PARANOID
        if (segment_sorted_ele_pt[is].size() == 0)
        {
          std::ostringstream error_message;
          error_message << "The (" << is << ")-th segment has no elements\n";
          throw OomphLibError(
            error_message.str(),
            "RefineableTriangleMesh::get_boundary_segment_nodes_helper()",
            OOMPH_EXCEPTION_LOCATION);
        } // if (segment_sorted_ele_pt[is].size() == 0)
#endif

        // Get access to the first element on the segment
        FiniteElement* first_ele_pt = segment_sorted_ele_pt[is].front();

        // Number of nodes
        const unsigned nnod = first_ele_pt->nnode();

        // Get the first node of the current segment
        Node* first_node_pt = first_ele_pt->node_pt(0);
        if (is_inverted[first_ele_pt])
        {
          first_node_pt = first_ele_pt->node_pt(nnod - 1);
        }

        // Add the node to the corresponding segment
        tmp_segment_nodes[is].push_back(first_node_pt);

        // Now loop over face elements in order to get the nodes
        for (std::list<FiniteElement*>::iterator it =
               segment_sorted_ele_pt[is].begin();
             it != segment_sorted_ele_pt[is].end();
             it++)
        {
          // Get element
          FiniteElement* ele_pt = *it;

          // The last node pointer
          Node* last_node_pt = 0;

          // Get the last node
          if (!is_inverted[ele_pt])
          {
            last_node_pt = ele_pt->node_pt(nnod - 1);
          }
          else
          {
            last_node_pt = ele_pt->node_pt(0);
          }

          // Add the node to the corresponding segment
          tmp_segment_nodes[is].push_back(last_node_pt);

        } // iterator over the elements in the segment

      } // for (is < nsegments)

    } // for (if (nel > 0))

    // Free memory allocation
    for (unsigned e = 0; e < nel; e++)
    {
      delete face_el_pt[e];
      face_el_pt[e] = 0;
    } // for (e < nel)
  }

  //======================================================================
  /// Adapt problem based on specified elemental error estimates
  /// This function implement serial and parallel mesh adaptation, the
  /// sections for parallel mesh adaptation are clearly identified by
  /// checking whether the mesh is distributed or not
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::adapt(const Vector<double>& elem_error)
  {
    double t_start_overall = TimingHelpers::timer();

    // ==============================================================
    // BEGIN: Compute target areas
    // ==============================================================

    // Get refinement targets
    Vector<double> target_area(elem_error.size());
    double min_angle = compute_area_target(elem_error, target_area);

    // Post-process to allow only quantised target areas
    // in an attempt to more closely mimick the structured
    // case and limit the diffusion of small elements.
    bool quantised_areas = true;
    if (quantised_areas)
    {
      unsigned n = target_area.size();
      double total_area = 0;
      // If the mesh is distributed then we need to get the contribution
      // of all processors to compute the total areas
      // ------------------------------------------
      // DISTRIBUTED MESH: BEGIN
      // ------------------------------------------
#ifdef OOMPH_HAS_MPI
      if (this->is_mesh_distributed())
      {
        // When working in parallel we get the total area from the sum
        // of the the sub-areas of all the meshes
        double sub_area = 0.0;

        // Only add the area of nonhalo elements
        for (unsigned e = 0; e < n; e++)
        {
          // Get the pointer to the element
          FiniteElement* ele_pt = this->finite_element_pt(e);
          if (!ele_pt->is_halo())
          {
            sub_area += ele_pt->size();
          }
        } // for (e<n)

        // Get the communicator of the mesh
        OomphCommunicator* comm_pt = this->communicator_pt();

        // Get the total area
        MPI_Allreduce(
          &sub_area, &total_area, 1, MPI_DOUBLE, MPI_SUM, comm_pt->mpi_comm());
      }
      else
      {
        for (unsigned e = 0; e < n; e++)
        {
          total_area += this->finite_element_pt(e)->size();
        }
      }
      // ------------------------------------------
      // DISTRIBUTED MESH: END
      // ------------------------------------------
#else // #ifdef OOMPH_HAS_MPI
      for (unsigned e = 0; e < n; e++)
      {
        total_area += this->finite_element_pt(e)->size();
      }
#endif // #ifdef OOMPH_HAS_MPI

      for (unsigned e = 0; e < n; e++)
      {
        unsigned level =
          unsigned(ceil(log(target_area[e] / total_area) / log(1.0 / 3.0))) - 1;
        double new_target_area = total_area * pow(1.0 / 3.0, int(level));
        target_area[e] = new_target_area;
      }
    }

    // std::ofstream tmp;
    // tmp.open((Global_string_for_annotation::
    // String[0]+"overall_target_areas"+
    //               StringConversion::to_string(Global_unsigned::Number)+".dat").c_str());

    // Get maximum target area
    unsigned n = target_area.size();
    double max_area = 0.0;
    double min_area = DBL_MAX;
    for (unsigned e = 0; e < n; e++)
    {
      if (target_area[e] > max_area) max_area = target_area[e];
      if (target_area[e] < min_area) min_area = target_area[e];

      // tmp << (finite_element_pt(e)->node_pt(0)->x(0)+
      //            finite_element_pt(e)->node_pt(1)->x(0)+
      //           finite_element_pt(e)->node_pt(2)->x(0))/3.0 << " "
      //        << (finite_element_pt(e)->node_pt(0)->x(1)+
      //            finite_element_pt(e)->node_pt(1)->x(1)+
      //            finite_element_pt(e)->node_pt(2)->x(1))/3.0 << " "
      //        << target_area[e] << " "
      //        << finite_element_pt(e)->size() << " "
      //        << elem_error[e]  << " " << std::endl;
    }

    // tmp.close();

    oomph_info << "Maximum target area: " << max_area << std::endl;
    oomph_info << "Minimum target area: " << min_area << std::endl;
    oomph_info << "Number of elements to be refined: " << this->Nrefined
               << std::endl;
    oomph_info << "Number of elements to be unrefined: " << this->Nunrefined
               << std::endl;
    oomph_info << "Min. angle: " << min_angle << std::endl;

    double orig_max_area, orig_min_area;
    this->max_and_min_element_size(orig_max_area, orig_min_area);
    oomph_info << "Max./min. element size in original mesh: " << orig_max_area
               << " " << orig_min_area << std::endl;

    // ==============================================================
    // END: Compute target areas
    // ==============================================================

    // Check if boundaries need to be updated (regardless of
    // requirements of bulk error estimator) but don't do anything!
    bool check_only = true;
    bool outer_boundary_update_necessary = false;
    bool inner_boundary_update_necessary = false;
    bool inner_open_boundary_update_necessary = false;

    // Get the number of outer boundaries and check if they require
    // update
    const unsigned nouter = this->Outer_boundary_pt.size();

    if (this->is_automatic_creation_of_vertices_on_boundaries_allowed())
    {
      // loop over the outer boundaries
      for (unsigned i_outer = 0; i_outer < nouter; i_outer++)
      {
        outer_boundary_update_necessary = this->update_polygon_using_face_mesh(
          this->Outer_boundary_pt[i_outer], check_only);
        // Break the loop if at least one needs updating
        if (outer_boundary_update_necessary) break;
      }

      // Do not waste time if we already know that it is necessary an update
      // on the boundary representation
      if (!outer_boundary_update_necessary)
      {
        // Check if we need to generate a new 1D mesh representation of
        // the inner hole boundaries
        const unsigned nhole = this->Internal_polygon_pt.size();
        Vector<Vector<double>> internal_point_coord(nhole);
        inner_boundary_update_necessary =
          this->surface_remesh_for_inner_hole_boundaries(internal_point_coord,
                                                         check_only);

        // If there was not necessary a change even on the internal closed
        // curve then finally check for the open curves as well
        if (!inner_boundary_update_necessary)
        {
          const unsigned n_open_polyline = this->Internal_open_curve_pt.size();
          // loop over the open polylines
          for (unsigned i = 0; i < n_open_polyline; i++)
          {
            inner_open_boundary_update_necessary =
              this->update_open_curve_using_face_mesh(
                this->Internal_open_curve_pt[i], check_only);
            // If at least one needs modification then break the for loop
            if (inner_open_boundary_update_necessary) break;
          }
        }
      }
    }

    // Flag to indicate whether we need to adapt or not (for parallel
    // mesh adaptation only)
    int adapt_all = 0;
    // ------------------------------------------
    // DISTRIBUTED MESH: BEGIN
    // ------------------------------------------
#ifdef OOMPH_HAS_MPI
    // When working in distributed meshes we need to ensure that all the
    // processors take part on the adaptation process. If at least one
    // of the processors requires adaptation then all processor take
    // part on the adaptation process.
    int adapt_this_processor = 0;
    if (this->is_mesh_distributed())
    {
      // Do this processor requires adaptation?
      if ((Nrefined > 0) || (Nunrefined > max_keep_unrefined()) ||
          (min_angle < min_permitted_angle()) ||
          (outer_boundary_update_necessary) ||
          (inner_boundary_update_necessary) ||
          (inner_open_boundary_update_necessary))
      {
        adapt_this_processor = 1;
      }

      // Get the communicator of the mesh
      OomphCommunicator* comm_pt = this->communicator_pt();

      // Verify if at least one processor needs mesh adaptation
      MPI_Allreduce(&adapt_this_processor,
                    &adapt_all,
                    1,
                    MPI_INT,
                    MPI_SUM,
                    comm_pt->mpi_comm());
    }
#endif
    // ------------------------------------------
    // DISTRIBUTED MESH: END
    // ------------------------------------------

    // Should we bother to adapt?
    if ((Nrefined > 0) || (Nunrefined > max_keep_unrefined()) ||
        (min_angle < min_permitted_angle()) ||
        (outer_boundary_update_necessary) ||
        (inner_boundary_update_necessary) ||
        (inner_open_boundary_update_necessary) || (adapt_all))
    {
      if (!((Nrefined > 0) || (Nunrefined > max_keep_unrefined())))
      {
        if ((outer_boundary_update_necessary) ||
            (inner_boundary_update_necessary) ||
            (inner_open_boundary_update_necessary))
        {
          oomph_info
            << "Mesh regeneration triggered by inaccurate interface/surface\n"
            << "representation; setting Nrefined to number of elements.\n"
            << "outer_boundary_update_necessary     : "
            << outer_boundary_update_necessary << "\n"
            << "inner_boundary_update_necessary     : "
            << inner_boundary_update_necessary << "\n"
            << "inner_open_boundary_update_necessary: "
            << inner_open_boundary_update_necessary << "\n";
          Nrefined = nelement();
        }
        else
        {
          oomph_info << "Mesh regeneration triggered by min angle criterion;\n"
                     << "setting Nrefined to number of elements.\n";
          Nrefined = nelement();
        }
      }

      // ------------------------------------------
      // DISTRIBUTED MESH: BEGIN
      // ------------------------------------------
#ifdef OOMPH_HAS_MPI
      else if (this->is_mesh_distributed() && adapt_this_processor == 0 &&
               adapt_all > 0)
      {
        oomph_info << "Mesh regeneration triggered by (" << adapt_all
                   << ") processor(s) "
                   << "that require(s)\n adaptation\n";
      }
#endif
      // ------------------------------------------
      // DISTRIBUTED MESH: END
      // ------------------------------------------

      // ==============================================================
      // BEGIN: Updating of boundaries representation (unrefinement and
      // refinement of polylines)
      // ==============================================================

      // Add the initial and final vertices of the polylines that
      // present connections to a list of non-delete-able vertices. The
      // vertices where the connections are performed cannot be deleted
      add_vertices_for_non_deletion();

      // ------------------------------------------
      // DISTRIBUTED MESH: BEGIN
      // ------------------------------------------
#ifdef OOMPH_HAS_MPI
      // Synchronise connections for shared boundaries among
      // processors. This is required since one of the processor may noy
      // know that some of its shared boundaries have connections, thus
      // the vertices receiving the connections cannot be deleted
      if (this->is_mesh_distributed())
      {
        synchronize_shared_boundary_connections();
      }
#endif // #ifdef OOMPH_HAS_MPI
      // ------------------------------------------
      // DISTRIBUTED MESH: END
      // ------------------------------------------

      // Are we allowing automatic insertion of vertices on boundaries?
      // If YES then Triangle automatically insert points along
      // boundaries, if NOT, then points are inserted along the
      // boundaries based on the target areas of boundary elements. When
      // the mesh is distributed the automatic insertion of vertices by
      // Triangle along the boundaries is not allowed
      if (this->is_automatic_creation_of_vertices_on_boundaries_allowed())
      {
        // Generate a new 1D mesh representation of the inner hole boundaries
        unsigned nhole = this->Internal_polygon_pt.size();
        Vector<Vector<double>> internal_point_coord(nhole);
        this->surface_remesh_for_inner_hole_boundaries(internal_point_coord);

        // Update the representation of the outer boundary
        for (unsigned i_outer = 0; i_outer < nouter; i_outer++)
        {
          this->update_polygon_using_face_mesh(
            this->Outer_boundary_pt[i_outer]);
        }

        // After updating outer and internal closed boundaries it is also
        // necessary to update internal boundaries.
        unsigned n_open_polyline = this->Internal_open_curve_pt.size();
        for (unsigned i = 0; i < n_open_polyline; i++)
        {
          this->update_open_curve_using_face_mesh(
            this->Internal_open_curve_pt[i]);
        }
      }
      else
      {
        // Update the representation of the internal boundaries using
        // the element's target area

        // Get the number of interal polygons
        const unsigned ninternal = this->Internal_polygon_pt.size();
        for (unsigned i_internal = 0; i_internal < ninternal; i_internal++)
        {
          this->update_polygon_using_elements_area(
            this->Internal_polygon_pt[i_internal], target_area);
        }

        // Update the representation of the outer boundaries using the
        // element's target area
        for (unsigned i_outer = 0; i_outer < nouter; i_outer++)
        {
          this->update_polygon_using_elements_area(
            this->Outer_boundary_pt[i_outer], target_area);
        }

        // Update the representation of the internal open boundaries
        // using the element's target areas
        const unsigned n_open_polyline = this->Internal_open_curve_pt.size();
        for (unsigned i = 0; i < n_open_polyline; i++)
        {
          this->update_open_curve_using_elements_area(
            this->Internal_open_curve_pt[i], target_area);
        }

        // ------------------------------------------
        // DISTRIBUTED MESH: BEGIN
        // ------------------------------------------

        // When working with a distributed mesh we require to update the
        // boundary representation of the shared boundaries, this is
        // based on the target areas of the elements adjaced to the
        // shared boundaries
#ifdef OOMPH_HAS_MPI
        // Update shared boundaries if the mesh is distributed
        if (this->is_mesh_distributed())
        {
          // Get the rank of the current processor
          const unsigned my_rank = this->communicator_pt()->my_rank();

          // Get the number of shared curves
          const unsigned n_curves = this->nshared_boundary_curves(my_rank);
          // Loop over the shared curves in the current processor
          for (unsigned nc = 0; nc < n_curves; nc++)
          {
            // Update the shared polyline
            this->update_shared_curve_using_elements_area(
              this->Shared_boundary_polyline_pt[my_rank][nc], // shared_curve,
              target_area);
          }

        } // if (this->is_mesh_distributed())
#endif

        // ------------------------------------------
        // DISTRIBUTED MESH: END
        // ------------------------------------------

      } // else if
        // (this->is_automatic_creation_of_vertices_on_boundaries_allowed())

      // ==============================================================
      // END: Updating of boundaries representation (unrefinement and
      // refinement of polylines)
      // ==============================================================

      // ==============================================================
      // BEGIN: Reset boundary coordinates for boundaries with no
      // associated GeomObject
      // ==============================================================

      // If there is not a geometric object associated with the boundary
      // then reset the boundary coordinates so that the lengths are
      // consistent in the new mesh and the old mesh.
      const unsigned n_boundary = this->nboundary();

      const double t_start_first_stage_segments_connectivity =
        TimingHelpers::timer();

      // ------------------------------------------
      // DISTRIBUTED MESH: BEGIN
      // ------------------------------------------
#ifdef OOMPH_HAS_MPI
      // Clear storage for assignment of initial zeta values for
      // boundaries
      if (this->is_mesh_distributed())
      {
        this->Assigned_segments_initial_zeta_values.clear();
      }
#endif // #ifdef OOMPH_HAS_MPI
      // ------------------------------------------
      // DISTRIBUTED MESH: END
      // ------------------------------------------

      // Loop over the boundaries to assign boundary coordinates
      for (unsigned b = 0; b < n_boundary; ++b)
      {
        // ------------------------------------------
        // DISTRIBUTED MESH: BEGIN
        // ------------------------------------------
#ifdef OOMPH_HAS_MPI
        if (this->is_mesh_distributed())
        {
          // In a distributed mesh, the boundaries may have been split
          // across processors during the distribution process, thus we
          // need to compute the connectivity among the segments of the
          // boundary to correctly assign its boundary coordinates
          this->compute_boundary_segments_connectivity_and_initial_zeta_values(
            b);
        }
#endif
        // ------------------------------------------
        // DISTRIBUTED MESH: END
        // ------------------------------------------

        // Does the boundary has an associated GeomObject
        if (this->boundary_geom_object_pt(b) == 0)
        {
          this->template setup_boundary_coordinates<ELEMENT>(b);
        }

        // ------------------------------------------
        // DISTRIBUTED MESH: BEGIN
        // ------------------------------------------
#ifdef OOMPH_HAS_MPI
        if (this->is_mesh_distributed())
        {
          // Synchronise boundary coordinates for internal open curves,
          // also establish the boundary coordinates for the nodes on
          // the corners of elements not on the boundary
          this->synchronize_boundary_coordinates(b);
        }
#endif
        // ------------------------------------------
        // DISTRIBUTED MESH: END
        // ------------------------------------------

      } // for (b<n_boundary)

      const double t_total_first_stage_segments_connectivity =
        TimingHelpers::timer() - t_start_first_stage_segments_connectivity;

      // ==============================================================
      // END: Reset boundary coordinates for boundaries with no
      // associated GeomObject
      // ==============================================================

      // ------------------------------------------
      // DISTRIBUTED MESH: BEGIN
      // ------------------------------------------
#ifdef OOMPH_HAS_MPI
      // ==============================================================
      // BEGIN: Create the new representation of the domain by joining
      // the original boundaries and the shared boundaries.
      // ==============================================================

      // Storage for the new temporary polygons "closed" by the shared
      // boundaries
      Vector<TriangleMeshPolygon*> tmp_outer_polygons_pt;

      // Storage for the new temporary open curves, could be the
      // original open curves or "chunks" of the original open curves
      // not overlapped by shared boundaries
      Vector<TriangleMeshOpenCurve*> tmp_open_curves_pt;

      if (this->is_mesh_distributed())
      {
        // Create the new polygons and open curves with help of the
        // original polylines and shared polylines
        this->create_distributed_domain_representation(tmp_outer_polygons_pt,
                                                       tmp_open_curves_pt);

        // Create the connections of the temporary domain representations
        this->create_temporary_boundary_connections(tmp_outer_polygons_pt,
                                                    tmp_open_curves_pt);
      }
      // ==============================================================
      // END: Create the new representation of the domain by joining
      // the original boundaries and the shared boundaries.
      // ==============================================================
#endif
      // ------------------------------------------
      // DISTRIBUTED MESH: END
      // ------------------------------------------

      // Re-establish polylines' connections. The boundary
      // representation has changed (new polylines), therefore we need
      // to update the connection information
      Vector<TriangleMeshPolyLine*> resume_initial_connection_polyline_pt;
      Vector<TriangleMeshPolyLine*> resume_final_connection_polyline_pt;
      restore_boundary_connections(resume_initial_connection_polyline_pt,
                                   resume_final_connection_polyline_pt);

      // Update the region information by setting the coordinates from the
      // centroid of the first element in each region (which should allow
      // automatic updates when the regions deform)
      {
        unsigned n_region = this->nregion();
        if (n_region > 1)
        {
          for (std::map<unsigned, Vector<double>>::iterator it =
                 this->Regions_coordinates.begin();
               it != this->Regions_coordinates.end();
               ++it)
          {
            // Storage for the approximate centroid
            Vector<double> centroid(2, 0.0);

            // Get the region id
            unsigned region_id = it->first;

            // Report information
            oomph_info << "Region " << region_id << ": " << it->second[0] << " "
                       << it->second[1] << " ";

            // Check that there is at least one element in the region
            unsigned n_region_element = this->nregion_element(region_id);
            if (n_region_element > 0)
            {
              // Cache pointer to the first element
              FiniteElement* const elem_pt =
                this->region_element_pt(region_id, 0);

              // Loop over the corners of the triangle and average
              for (unsigned n = 0; n < 3; n++)
              {
                Node* const nod_pt = elem_pt->node_pt(n);
                for (unsigned i = 0; i < 2; i++)
                {
                  centroid[i] += nod_pt->x(i);
                }
              }
              for (unsigned i = 0; i < 2; i++)
              {
                centroid[i] /= 3;
              }
              // Now we have the centroid set it
              it->second = centroid;

              oomph_info << "   ,    " << it->second[0] << " " << it->second[1]
                         << std::endl;
            } // end of case when there is at least one element

          } // loop over regions coordinates

        } // if(n_region > 1)

      } // Updating region info.

      // ==============================================================
      // BEGIN: Create background mesh
      // ==============================================================

      // Are we dealing with a solid mesh?
      SolidMesh* solid_mesh_pt = dynamic_cast<SolidMesh*>(this);

      // Build temporary uniform background mesh
      //----------------------------------------
      // with area set by maximum required area
      //---------------------------------------
      RefineableTriangleMesh<ELEMENT>* tmp_new_mesh_pt = 0;

      // The storage for the new temporary boundaries representation to
      // create the background mesh
      Vector<TriangleMeshClosedCurve*> closed_curve_pt;
      Vector<TriangleMeshClosedCurve*> hole_pt;
      Vector<TriangleMeshOpenCurve*> open_curves_pt;

#ifdef OOMPH_HAS_MPI
      if (!this->is_mesh_distributed())
#endif
      {
        // Copy the outer boundaries
        closed_curve_pt.resize(nouter);
        for (unsigned i = 0; i < nouter; i++)
        {
          closed_curve_pt[i] = this->Outer_boundary_pt[i];
        }

        // Copy the internal closed boundaries (may be holes)
        const unsigned n_holes = this->Internal_polygon_pt.size();
        hole_pt.resize(n_holes);
        for (unsigned i = 0; i < n_holes; i++)
        {
          hole_pt[i] = this->Internal_polygon_pt[i];
        }

        // Copy the internal open curves
        const unsigned n_open_curves = this->Internal_open_curve_pt.size();
        open_curves_pt.resize(n_open_curves);
        for (unsigned i = 0; i < n_open_curves; i++)
        {
          open_curves_pt[i] = this->Internal_open_curve_pt[i];
        }
      }
      // ------------------------------------------
      // DISTRIBUTED MESH: BEGIN
      // ------------------------------------------
#ifdef OOMPH_HAS_MPI
      else
      {
        // Copy the new representation of the outer/internal closed
        // boundaries
        const unsigned n_tmp_outer = tmp_outer_polygons_pt.size();
        closed_curve_pt.resize(n_tmp_outer);
        for (unsigned i = 0; i < n_tmp_outer; i++)
        {
          closed_curve_pt[i] = tmp_outer_polygons_pt[i];
        }

        // Copy the new representation of the internal open curves
        const unsigned n_open_curves = tmp_open_curves_pt.size();
        open_curves_pt.resize(n_open_curves);
        for (unsigned i = 0; i < n_open_curves; i++)
        {
          open_curves_pt[i] = tmp_open_curves_pt[i];
        }
      }
#endif
      // ------------------------------------------
      // DISTRIBUTED MESH: END
      // ------------------------------------------

      // ----------------------------------------------------------------
      // Gather all the information and use the TriangleMeshParameters
      // object which help us on the manage of all TriangleMesh object's
      // information

      // Create the TriangleMeshParameters objects with the outer boundary
      // as the only one parameter
      TriangleMeshParameters triangle_mesh_parameters(closed_curve_pt);

      // Pass information about the holes
      triangle_mesh_parameters.internal_closed_curve_pt() = hole_pt;

      // Pass information about the internal open boundaries
      triangle_mesh_parameters.internal_open_curves_pt() = open_curves_pt;

      // Set the element area
      triangle_mesh_parameters.element_area() = max_area;

      // Pass information about the extra holes (not defined with closed
      // boundaries)
      triangle_mesh_parameters.extra_holes_coordinates() =
        this->Extra_holes_coordinates;

      // Pass information about regions
      triangle_mesh_parameters.regions_coordinates() =
        this->Regions_coordinates;

      // Pass information about the using of regions
      if (this->Use_attributes)
      {
        triangle_mesh_parameters.enable_use_attributes();
      }

      // Pass information about allowing the creation of new points
      if (!this->is_automatic_creation_of_vertices_on_boundaries_allowed())
      {
        triangle_mesh_parameters
          .disable_automatic_creation_of_vertices_on_boundaries();
      }

      // When the mesh is distributed we need to create a distributed
      // background mesh
#ifdef OOMPH_HAS_MPI
      if (this->is_mesh_distributed())
      {
        // Mark the mesh to be created as distributed by passing a
        // pointer to the communicator
        triangle_mesh_parameters.set_communicator_pt(this->communicator_pt());
      }
#endif

      // ----------------------------------------------------------
      // Build the background mesh using Triangle
      // ----------------------------------------------------------
      const double t_start_building_background_mesh = TimingHelpers::timer();

      if (solid_mesh_pt != 0)
      {
        tmp_new_mesh_pt = new RefineableSolidTriangleMesh<ELEMENT>(
          triangle_mesh_parameters, this->Time_stepper_pt);
      }
      else
      {
        tmp_new_mesh_pt = new RefineableTriangleMesh<ELEMENT>(
          triangle_mesh_parameters, this->Time_stepper_pt);
      }

      if (Print_timings_level_adaptation > 2)
      {
        oomph_info << "CPU for building background mesh: "
                   << TimingHelpers::timer() - t_start_building_background_mesh
                   << std::endl;
      }

      // Pass the info. regarding the maximum and minimum element size
      // from the old mesh to the background mesh
      const double this_max_element_size = this->max_element_size();
      const double this_min_element_size = this->min_element_size();
      tmp_new_mesh_pt->max_element_size() = this_max_element_size;
      tmp_new_mesh_pt->min_element_size() = this_min_element_size;

      // ... also copy the minimum permitted angle
      const double this_min_permitted_angle = this->min_permitted_angle();
      tmp_new_mesh_pt->min_permitted_angle() = this_min_permitted_angle;

      // ------------------------------------------
      // DISTRIBUTED MESH: BEGIN
      // ------------------------------------------
#ifdef OOMPH_HAS_MPI
      // If the mesh is distributed we need to pass and set the
      // information of internal boundaries overlaped by shared
      // boundaries
      if (this->is_mesh_distributed())
      {
        // Check if necessary to fill boundary elements for those
        // internal boundaries that overlap shared boundaries
        if (this->nshared_boundary_overlaps_internal_boundary() > 0)
        {
          // Copy the data structures that indicates which shared
          // boundaries are part of an internal boundary
          tmp_new_mesh_pt->shared_boundary_overlaps_internal_boundary() =
            this->shared_boundary_overlaps_internal_boundary();

          // Copy the data structure that indicates which are the shared
          // boundaries in each processor
          tmp_new_mesh_pt->shared_boundaries_ids() =
            this->shared_boundaries_ids();

          // Fill the structures for the boundary elements and face indexes
          // of the boundary elements
          tmp_new_mesh_pt
            ->fill_boundary_elements_and_nodes_for_internal_boundaries();

        } // if (this->nshared_boundary_overlaps_internal_boundary() > 0)

      } // if (this->is_mesh_distributed())
#endif // #ifdef OOMPH_HAS_MPI
      // ------------------------------------------
      // DISTRIBUTED MESH: END
      // ------------------------------------------

      // Snap to curvilinear boundaries (some code duplication as this
      // is repeated below but helper function would take so many
      // arguments that it's nearly as messy...

      // Pass the boundary geometric objects to the new mesh
      tmp_new_mesh_pt->boundary_geom_object_pt() =
        this->boundary_geom_object_pt();

      // Reset the boundary coordinates if there is
      // a geometric object associated with the boundary
      tmp_new_mesh_pt->boundary_coordinate_limits() =
        this->boundary_coordinate_limits();

      const double t_start_second_stage_segments_connectivity =
        TimingHelpers::timer();

      for (unsigned b = 0; b < n_boundary; b++)
      {
        // ------------------------------------------
        // DISTRIBUTED MESH: BEGIN
        // ------------------------------------------
#ifdef OOMPH_HAS_MPI
        if (this->is_mesh_distributed())
        {
          // Identify the segments of the new mesh with the ones of the
          // original mesh
          tmp_new_mesh_pt
            ->identify_boundary_segments_and_assign_initial_zeta_values(b,
                                                                        this);
        }
#endif
        // ------------------------------------------
        // DISTRIBUTED MESH: END
        // ------------------------------------------

        // Setup boundary coordinates for boundaries with GeomObject
        // associated
        if (tmp_new_mesh_pt->boundary_geom_object_pt(b) != 0)
        {
          tmp_new_mesh_pt->template setup_boundary_coordinates<ELEMENT>(b);
        }
      }

      const double t_total_second_stage_segments_connectivity =
        TimingHelpers::timer() - t_start_second_stage_segments_connectivity;

      const double t_start_snap_nodes_bg_mesh = TimingHelpers::timer();
      // Move the nodes on the new boundary onto the old curvilinear
      // boundary. If the boundary is straight this will do precisely
      // nothing but will be somewhat inefficient
      for (unsigned b = 0; b < n_boundary; b++)
      {
        this->snap_nodes_onto_boundary(tmp_new_mesh_pt, b);
      }

      const double t_total_snap_nodes_bg_mesh =
        TimingHelpers::timer() - t_start_snap_nodes_bg_mesh;

      if (Print_timings_level_adaptation > 2)
      {
        oomph_info << "CPU for snapping nodes onto boundaries "
                   << "(background mesh): " << t_total_snap_nodes_bg_mesh
                   << std::endl;
      }

      // Update mesh further?
      if (Mesh_update_fct_pt != 0)
      {
        Mesh_update_fct_pt(tmp_new_mesh_pt);
      }

      // If we have a continuation problem
      // any problem in which the timestepper is a "generalisedtimestepper",
      // which will have been set by the problem, then ensure
      // all data in the new mesh has the appropriate timestepper
      /*if(dynamic_cast<GeneralisedTimeStepper*>(this->Time_stepper_pt))
        {
        tmp_new_mesh_pt->set_nodal_and_elemental_time_stepper(
        this->Time_stepper_pt);
        tmp_new_mesh_pt->set_mesh_level_time_stepper(this->Time_stepper_pt);
        }*/


      // tmp_new_mesh_pt->output("mesh_nodes_snapped_0.dat");
      // this->output("existing_mesh.dat");

      // ==============================================================
      // END: Create background mesh
      // ==============================================================

      // ==============================================================
      // BEGIN: Transferring of target areas and creation of new mesh
      // ==============================================================

      // Get the TriangulateIO object associated with that mesh
      TriangulateIO tmp_new_triangulateio =
        tmp_new_mesh_pt->triangulateio_representation();
      RefineableTriangleMesh<ELEMENT>* new_mesh_pt = 0;

      // If the mesh is a solid mesh then do the mapping based on the
      // Eulerian coordinates
      bool use_eulerian_coords = false;
      if (solid_mesh_pt != 0)
      {
        use_eulerian_coords = true;
      }


#ifdef OOMPH_HAS_CGAL

      // Make cgal-based bin
      CGALSamplePointContainerParameters cgal_params(this);
      if (use_eulerian_coords)
      {
        cgal_params.enable_use_eulerian_coordinates_during_setup();
      }
      MeshAsGeomObject* mesh_geom_obj_pt = new MeshAsGeomObject(&cgal_params);

#else

      // Make nonrefineable bin
      NonRefineableBinArrayParameters params(this);
      if (use_eulerian_coords)
      {
        params.enable_use_eulerian_coordinates_during_setup();
      }
      Vector<unsigned> bin_dim(2);
      bin_dim[0] = Nbin_x_for_area_transfer;
      bin_dim[1] = Nbin_y_for_area_transfer;
      params.dimensions_of_bin_array() = bin_dim;
      MeshAsGeomObject* mesh_geom_obj_pt = new MeshAsGeomObject(&params);

#endif

      // Set up a map from pointer to element to its number
      // in the mesh
      std::map<GeneralisedElement*, unsigned> element_number;
      unsigned nelem = this->nelement();
      for (unsigned e = 0; e < nelem; e++)
      {
        element_number[this->element_pt(e)] = e;
      }

#ifndef OOMPH_HAS_CGAL

      // Create a vector to store the min target area of each bin (at
      // this stage the number of bins should not be that large, so it
      // should be safe to build a vector for the total number of bins)
      Vector<double> bin_min_target_area;

      // Get pointer to sample point container
      NonRefineableBinArray* bin_array_pt =
        dynamic_cast<NonRefineableBinArray*>(
          mesh_geom_obj_pt->sample_point_container_pt());
      if (bin_array_pt == 0)
      {
        throw OomphLibError(
          "Sample point container has to be NonRefineableBinArray",
          OOMPH_CURRENT_FUNCTION,
          OOMPH_EXCEPTION_LOCATION);
      }

      {
        unsigned n_bin = 0;
        unsigned max_n_entry = 0;
        unsigned min_n_entry = UINT_MAX;
        unsigned tot_n_entry = 0;
        unsigned n_empty = 0;
        bin_array_pt->get_fill_stats(
          n_bin, max_n_entry, min_n_entry, tot_n_entry, n_empty);

        oomph_info << "Before bin diffusion:"
                   << " nbin:(" << n_bin << ")"
                   << " nempty:(" << n_empty << ")"
                   << " min:(" << min_n_entry << ")"
                   << " max:(" << max_n_entry << ")"
                   << " average entries:("
                   << double(tot_n_entry) / double(n_bin) << ")" << std::endl;
      }

      // Fill bin by diffusion
      double t0_bin_diff = TimingHelpers::timer();
      oomph_info << "Going into diffusion bit...\n";
      bin_array_pt->fill_bin_by_diffusion();
      oomph_info << "Back from diffusion bit...\n";
      oomph_info << "Time for bin diffusion: "
                 << TimingHelpers::timer() - t0_bin_diff << std::endl;

      // Do some stats
      {
        unsigned n_bin = 0;
        unsigned max_n_entry = 0;
        unsigned min_n_entry = UINT_MAX;
        unsigned tot_n_entry = 0;
        unsigned n_empty = 0;
        bin_array_pt->get_fill_stats(
          n_bin, max_n_entry, min_n_entry, tot_n_entry, n_empty);

        oomph_info << "After bin diffusion:"
                   << " nbin:(" << n_bin << ")"
                   << " nempty:(" << n_empty << ")"
                   << " min:(" << min_n_entry << ")"
                   << " max:(" << max_n_entry << ")"
                   << " average entries:("
                   << double(tot_n_entry) / double(n_bin) << ")" << std::endl;
      }


      // For each bin, compute the minimum of the target areas in the bin

      // Timing for map
      double t_total_map = 0.0;

      // Counter for map
      unsigned counter_map = 0;

      // Get access to the bins (we need access to the content of the
      // bins to compute the minimum of the target areas of the elements
      // in each bin)
      const std::map<unsigned,
                     Vector<std::pair<FiniteElement*, Vector<double>>>>*
        bins_pt = bin_array_pt->get_all_bins_content();

      // Get the number of bins
      const unsigned n_bin = bins_pt->size();

      // Create a vector to store the min target area of each bin (at
      // this stage the number of bins should not be that large, so it
      // should be safe to build a vector for the total number of bins)
      bin_min_target_area.resize(n_bin);
      for (unsigned u = 0; u < n_bin; u++)
      {
        bin_min_target_area[u] = 0.0;
      }
      // loop over the bins, get their elements and compute the minimum
      // target area of all of them
      typedef std::map<
        unsigned,
        Vector<std::pair<FiniteElement*, Vector<double>>>>::const_iterator IT;
      for (IT it = bins_pt->begin(); it != bins_pt->end(); it++)
      {
        // The bin number
        unsigned ib = (*it).first;

        // Get the number of elements in the bin
        const unsigned n_ele_bin = (*it).second.size();

        // loop over the elements in the bin
        for (unsigned ee = 0; ee < n_ele_bin; ee++)
        {
          // Get ee-th element (in currrent mesh) in ib-th bin
          GeneralisedElement* ele_pt = (*it).second[ee].first;
          double t_map = TimingHelpers::timer();
          const unsigned ele_number = element_number[ele_pt];
          t_total_map += TimingHelpers::timer() - t_map;

          // Increase the number of calls to map
          counter_map++;

          // Go for smallest target area of any element in this bin to
          // force "one level" of refinement (the one-level-ness is
          // enforced below by limiting the actual reduction in area
          if (bin_min_target_area[ib] != 0)
          {
            bin_min_target_area[ib] =
              std::min(bin_min_target_area[ib], target_area[ele_number]);
          }
          else
          {
            bin_min_target_area[ib] = target_area[ele_number];
          }

        } // for (ee<n_ele_bin)

      } // for (it!=bins.end())

      oomph_info << "CPU for map[counter=" << counter_map
                 << "]: " << t_total_map << std::endl;


      // Optional output for debugging (keep it around!)
      const bool output_bins = false;
      if (output_bins)
      {
        unsigned length = bin_min_target_area.size();
        for (unsigned u = 0; u < length; u++)
        {
          oomph_info << "Bin n" << u
                     << ",target area: " << bin_min_target_area[u] << std::endl;
        }
      }

#endif


      // Now start iterating to refine mesh recursively
      //-----------------------------------------------
      bool done = false;
      unsigned iter = 0;
#ifdef OOMPH_HAS_MPI
      // The number of elements that require (un)refinement
      unsigned n_ele_need_refinement = 0;
#endif

      // The timing for the third stage of segments connectivity
      double t_total_third_stage_segments_connectivity = 0.0;

      // The timing for the transfering target areas
      double t_total_transfer_target_areas = 0.0;

      // The timing for the copying of target areas
      double t_total_limit_target_areas = 0.0;

      // The timing to create the new mesh
      double t_total_create_new_adapted_mesh = 0.0;

      // The timing for the snapping of the nodes on the new meshes
      double t_total_snap_nodes = 0.0;

      // The timing to check whether other processors need to adapt
      double t_total_wait_other_processors = 0.0;
      double t_iter = TimingHelpers::timer();
      while (!done)
      {
        // Accept by default but overwrite if things go wrong below
        done = true;

        double t_start_transfer_target_areas = TimingHelpers::timer();
        double t0_loop_int_pts = TimingHelpers::timer();

        // Loop over elements in new (tmp) mesh and visit all
        // its integration points. Check where it's located in the bin
        // structure of the current mesh and pass the target area
        // to the new element
        nelem = tmp_new_mesh_pt->nelement();

        // Store the target areas for elements in the temporary
        // TriangulateIO mesh
        Vector<double> new_transferred_target_area(nelem, 0.0);
        for (unsigned e = 0; e < nelem; e++)
        { // start loop el
          ELEMENT* el_pt =
            dynamic_cast<ELEMENT*>(tmp_new_mesh_pt->element_pt(e));
          unsigned nint = el_pt->integral_pt()->nweight();
          for (unsigned ipt = 0; ipt < nint; ipt++)
          {
            // Get the coordinate of current point
            Vector<double> s(2);
            for (unsigned i = 0; i < 2; i++)
            {
              s[i] = el_pt->integral_pt()->knot(ipt, i);
            }

            Vector<double> x(2);
            el_pt->interpolated_x(s, x);

#if OOMPH_HAS_CGAL

            // Try the five nearest sample points for Newton search
            // then just settle on the nearest one
            GeomObject* geom_obj_pt = 0;
            unsigned max_sample_points =
              Max_sample_points_for_limited_locate_zeta_during_target_area_transfer;
            dynamic_cast<CGALSamplePointContainer*>(
              mesh_geom_obj_pt->sample_point_container_pt())
              ->limited_locate_zeta(x, max_sample_points, geom_obj_pt, s);
#ifdef PARANOID
            if (geom_obj_pt == 0)
            {
              std::stringstream error_message;
              error_message << "Limited locate zeta failed for zeta = [ "
                            << x[0] << " " << x[1] << " ]. Makes no sense!\n";
              throw OomphLibError(error_message.str(),
                                  OOMPH_CURRENT_FUNCTION,
                                  OOMPH_EXCEPTION_LOCATION);
            }
            else
            {
#endif
              FiniteElement* fe_pt = dynamic_cast<FiniteElement*>(geom_obj_pt);
#ifdef PARANOID
              if (fe_pt == 0)
              {
                std::stringstream error_message;
                error_message << "Cast to FE for GeomObject returned by "
                                 "limited locate zeta failed for zeta = [ "
                              << x[0] << " " << x[1] << " ]. Makes no sense!\n";
                throw OomphLibError(error_message.str(),
                                    OOMPH_CURRENT_FUNCTION,
                                    OOMPH_EXCEPTION_LOCATION);
              }
              else
              {
#endif
                // What's the target area of the element that contains this
                // point
                double tg_area = target_area[element_number[fe_pt]];

                // Go for smallest target area over all integration
                // points in new element
                // to force "one level" of refinement (the one-level-ness
                // is enforced below by limiting the actual reduction in
                // area
                if (new_transferred_target_area[e] != 0)
                {
                  new_transferred_target_area[e] =
                    std::min(new_transferred_target_area[e], tg_area);
                }
                else
                {
                  new_transferred_target_area[e] = tg_area;
                }
#ifdef PARANOID
              }
            }
#endif

#else

            // Find the bin that contains that point and its contents
            int bin_number = 0;
            bin_array_pt->get_bin(x, bin_number);

            // Did we find it?
            if (bin_number < 0)
            {
              // Not even within bin boundaries... odd
              std::stringstream error_message;
              error_message << "Very odd -- we're looking for a point[ " << x[0]
                            << " " << x[1] << " ] that's not even \n"
                            << "located within the bin boundaries.\n";
              throw OomphLibError(error_message.str(),
                                  "RefineableTriangleMesh::adapt()",
                                  OOMPH_EXCEPTION_LOCATION);
            } // if (bin_number<0)
            else
            {
              // Go for smallest target area of any element in this bin
              // to force "one level" of refinement (the one-level-ness
              // is enforced below by limiting the actual reduction in
              // area
              if (new_transferred_target_area[e] != 0)
              {
                new_transferred_target_area[e] =
                  std::min(new_transferred_target_area[e],
                           bin_min_target_area[bin_number]);
              }
              else
              {
                new_transferred_target_area[e] =
                  bin_min_target_area[bin_number];
              }
            }

#endif

          } // for (ipt<nint)

        } // for (e<nelem)


        // do some output (keep it alive!)
        const bool output_target_areas = false;
        if (output_target_areas)
        {
          unsigned length = new_transferred_target_area.size();
          for (unsigned u = 0; u < length; u++)
          {
            oomph_info << "Element" << u
                       << ",target area: " << new_transferred_target_area[u]
                       << std::endl;
          }
        }
        oomph_info << "Time for loop over integration points in new mesh: "
                   << TimingHelpers::timer() - t0_loop_int_pts << std::endl;


        // {
        // tmp.open((Global_string_for_annotation::
        // String[0]+"binned_target_areas"+
        //               StringConversion::to_string(Global_unsigned::Number)+".dat").c_str());

        // Vector<Vector<std::pair<FiniteElement*,Vector<double> > > >
        // bin_content=
        //  mesh_geom_obj_pt->bin_content();
        // unsigned nbin=bin_content.size();
        // for (unsigned b=0;b<nbin;b++)
        //  {
        //   unsigned nentry=bin_content[b].size();
        //   for (unsigned entry=0;entry<nentry;entry++)
        //    {
        //     FiniteElement* el_pt=bin_content[b][entry].first;
        //     GeneralisedElement* gen_el_pt=bin_content[b][entry].first;
        //     Vector<double> s=bin_content[b][entry].second;
        //     Vector<double> x(2);
        //     el_pt->interpolated_x(s,x);
        //     unsigned e_current=element_number[gen_el_pt];
        //     tmp << x[0] << " " << x[1] << " "
        //             << target_area[e_current] << " "
        //             << el_pt->size() << " "
        //             << std::endl;
        //    }
        //  }
        // tmp.close();
        // }

        const double t_sub_total_transfer_target_areas =
          TimingHelpers::timer() - t_start_transfer_target_areas;

        if (Print_timings_level_adaptation > 2)
        {
          // Get the number of elements in the old mesh (this)
          const unsigned n_element = this->nelement();
          // Get the number of elements in the background mesh
          const unsigned n_element_background = tmp_new_mesh_pt->nelement();

          oomph_info << "CPU for transfer of target areas "
                     << "[n_ele_old_mesh=" << n_element
                     << ", n_ele_background_mesh=" << n_element_background
                     << "] (iter " << iter
                     << "): " << t_sub_total_transfer_target_areas << std::endl;
        }

        // Add the timing for tranfer of target areas
        t_total_transfer_target_areas += t_sub_total_transfer_target_areas;

        // // Output mesh
        // tmp_new_mesh_pt->output(("intermediate_mesh"+
        //                         StringConversion::to_string(iter)+".dat").c_str());

        // tmp.open((Global_string_for_annotation::
        // String[0]+"target_areas_intermediate_mesh_iter"+
        //               StringConversion::to_string(iter)+"_"+
        //               StringConversion::to_string(Global_unsigned::Number)+".dat").c_str());

        const double t_start_limit_target_areas = TimingHelpers::timer();

        // Now copy into target area for temporary mesh but limit to
        // the equivalent of one sub-division per iteration
#ifdef OOMPH_HAS_MPI
        unsigned n_ele_need_refinement_iter = 0;
#endif


        // Don't delete! Keep these around for debugging
        // ofstream tmp_mesh_file;
        // tmp_mesh_file.open("tmp_mesh_file.dat");
        // tmp_new_mesh_pt->output(tmp_mesh_file);
        // tmp_mesh_file.close();
        // ofstream target_areas_file;
        // target_areas_file.open("target_areas_file.dat");

        const unsigned nel_new = tmp_new_mesh_pt->nelement();
        Vector<double> new_target_area(nel_new);
        for (unsigned e = 0; e < nel_new; e++)
        {
          // The finite element
          FiniteElement* f_ele_pt = tmp_new_mesh_pt->finite_element_pt(e);

          // Transferred target area
          const double new_area = new_transferred_target_area[e];
          if (new_area <= 0.0)
          {
            std::ostringstream error_stream;
            error_stream
              << "This shouldn't happen! Element whose centroid is at "
              << (f_ele_pt->node_pt(0)->x(0) + f_ele_pt->node_pt(1)->x(0) +
                  f_ele_pt->node_pt(2)->x(0)) /
                   3.0
              << " "
              << (f_ele_pt->node_pt(0)->x(1) + f_ele_pt->node_pt(1)->x(1) +
                  f_ele_pt->node_pt(2)->x(1)) /
                   3.0
              << " "
              << " has no target area assigned\n";
            throw OomphLibError(error_stream.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }
          else
          {
            // Limit target area to the equivalent of uniform refinement
            // during this stage of the iteration
            new_target_area[e] = new_area;
            if (new_target_area[e] < f_ele_pt->size() / 3.0)
            {
              new_target_area[e] = f_ele_pt->size() / 3.0;

              // We'll need to give it another go later
              done = false;
            }

            // Don't delete! Keep around for debugging
            // target_areas_file
            //  <<  (f_ele_pt->node_pt(0)->x(0)+
            //       f_ele_pt->node_pt(1)->x(0)+
            //       f_ele_pt->node_pt(2)->x(0))/3.0 << " "
            //  << (f_ele_pt->node_pt(0)->x(1)+
            //      f_ele_pt->node_pt(1)->x(1)+
            //      f_ele_pt->node_pt(2)->x(1))/3.0 << " "
            //  << new_area << " "
            //  << new_target_area[e] << std::endl;


#ifdef OOMPH_HAS_MPI
            // Keep track of the elements that require (un)refinement
            n_ele_need_refinement_iter++;
#endif

          } // else if (new_area <= 0.0)

        } // for (e < nel_new)


        // Don't delete! Keep around for debugging
        // target_areas_file.close();

        const double t_sub_total_limit_target_areas =
          TimingHelpers::timer() - t_start_limit_target_areas;

        // Add the timing for copying target areas
        t_total_limit_target_areas += t_sub_total_limit_target_areas;

        if (Print_timings_level_adaptation > 2)
        {
          // Get the number of elements in the old mesh (this)
          const unsigned n_element = this->nelement();
          // Get the number of elements in the background mesh
          const unsigned n_element_background = tmp_new_mesh_pt->nelement();

          oomph_info << "CPU for limiting target areas "
                     << "[n_ele_old_mesh=" << n_element
                     << ", n_ele_background_mesh=" << n_element_background
                     << "] (iter " << iter
                     << "): " << t_sub_total_limit_target_areas << std::endl;
        }

        if (done)
        {
          oomph_info
            << "All area adjustments accommodated by max. permitted area"
            << " reduction \n";
        }
        else
        {
          oomph_info << "NOT all area adjustments accommodated by max. "
                     << "permitted area reduction \n";
        }

        // tmp.close();
        // pause("doced binned_target_areas.dat and intermediate mesh targets");

        // Now create the new mesh from TriangulateIO structure
        //-----------------------------------------------------
        // associated with uniform background mesh and the
        //------------------------------------------------
        // associated target element sizes.
        //---------------------------------

        const double t_start_create_new_adapted_mesh = TimingHelpers::timer();

        // Solid mesh?
        if (solid_mesh_pt != 0)
        {
          new_mesh_pt = new RefineableSolidTriangleMesh<ELEMENT>(
            new_target_area,
            tmp_new_triangulateio,
            this->Time_stepper_pt,
            this->Use_attributes,
            this->Allow_automatic_creation_of_vertices_on_boundaries,
            this->communicator_pt());
        }
        // No solid mesh
        else
        {
          new_mesh_pt = new RefineableTriangleMesh<ELEMENT>(
            new_target_area,
            tmp_new_triangulateio,
            this->Time_stepper_pt,
            this->Use_attributes,
            this->Allow_automatic_creation_of_vertices_on_boundaries,
            this->communicator_pt());
        }

        // Sub-total to create new adapted mesh
        const double t_sub_total_create_new_adapted_mesh =
          TimingHelpers::timer() - t_start_create_new_adapted_mesh;

        // Add the time to the total snap nodes time
        t_total_create_new_adapted_mesh += t_sub_total_create_new_adapted_mesh;

        if (Print_timings_level_adaptation > 2)
        {
          // Get the number of elements of the new adapted mesh
          const unsigned n_element_new_adapted_mesh = new_mesh_pt->nelement();

          oomph_info << "CPU for creation of new adapted mesh "
                     << t_sub_total_create_new_adapted_mesh
                     << "[nele=" << n_element_new_adapted_mesh << "] (iter "
                     << iter << "): " << t_sub_total_create_new_adapted_mesh
                     << std::endl;
        }

#ifdef OOMPH_HAS_MPI
        // ------------------------------------------
        // DISTRIBUTED MESH: BEGIN
        // ------------------------------------------

        // This section is only required if we are dealing with
        // distributed meshes, otherwise there are not shared boundaries
        // overlapping internal boundaries

        // Check if necessary to fill boundary elements for those internal
        // boundaries that overlap shared boundaries
        if (this->nshared_boundary_overlaps_internal_boundary() > 0)
        {
          // Copy the data structures that indicate which shared
          // boundaries are part of an internal boundary
          new_mesh_pt->shared_boundary_overlaps_internal_boundary() =
            this->shared_boundary_overlaps_internal_boundary();

          // Copy the data structure that indicates which are the shared
          // boundaries in each processor
          new_mesh_pt->shared_boundaries_ids() = this->shared_boundaries_ids();

          // Fill the structures for the boundary elements and face indexes
          // of the boundary elements
          new_mesh_pt
            ->fill_boundary_elements_and_nodes_for_internal_boundaries();
        }
        // ------------------------------------------
        // DISTRIBUTED MESH: END
        // ------------------------------------------
#endif // #ifdef OOMPH_HAS_MPI

        // Snap to curvilinear boundaries (some code duplication as this
        // is repeated below but helper function would take so many
        // arguments that it's nearly as messy...

        // Pass the boundary geometric objects to the new mesh
        new_mesh_pt->boundary_geom_object_pt() =
          this->boundary_geom_object_pt();

        // Reset the boundary coordinates if there is
        // a geometric object associated with the boundary
        new_mesh_pt->boundary_coordinate_limits() =
          this->boundary_coordinate_limits();

        const double t_start_third_stage_segments_connectivity =
          TimingHelpers::timer();

        for (unsigned b = 0; b < n_boundary; b++)
        {
          // ------------------------------------------
          // DISTRIBUTED MESH: BEGIN
          // ------------------------------------------

          // Before setting up boundary coordinates for the new mesh we
          // require to identify the segments with the old mesh to
          // assign initial zeta values
#ifdef OOMPH_HAS_MPI
          if (this->is_mesh_distributed())
          {
            // Identify the segments of the new mesh with the ones of
            // the original mesh
            new_mesh_pt
              ->identify_boundary_segments_and_assign_initial_zeta_values(b,
                                                                          this);
          }
#endif
          // ------------------------------------------
          // DISTRIBUTED MESH: END
          // ------------------------------------------

          // Setup boundary coordinates for boundaries with GeomObject
          // associated
          if (new_mesh_pt->boundary_geom_object_pt(b) != 0)
          {
            new_mesh_pt->template setup_boundary_coordinates<ELEMENT>(b);
          }
        }

        t_total_third_stage_segments_connectivity +=
          TimingHelpers::timer() - t_start_third_stage_segments_connectivity;

        const double t_start_snap_nodes_new_mesh = TimingHelpers::timer();
        // Move the nodes on the new boundary onto the old curvilinear
        // boundary. If the boundary is straight this will do precisely
        // nothing but will be somewhat inefficient
        for (unsigned b = 0; b < n_boundary; b++)
        {
          this->snap_nodes_onto_boundary(new_mesh_pt, b);
        }

        const double t_sub_total_snap_nodes_new_mesh =
          TimingHelpers::timer() - t_start_snap_nodes_new_mesh;

        // Add the time to the total snap nodes time
        t_total_snap_nodes += t_sub_total_snap_nodes_new_mesh;

        if (Print_timings_level_adaptation > 2)
        {
          oomph_info << "CPU for snapping nodes onto boundaries (new mesh) "
                     << "(iter " << iter
                     << "): " << t_sub_total_snap_nodes_new_mesh << std::endl;
        }

        // Update mesh further?
        if (Mesh_update_fct_pt != 0)
        {
          Mesh_update_fct_pt(new_mesh_pt);
        }

        // If we have a continuation problem
        // any problem in which the timestepper is a "generalisedtimestepper",
        // which will have been set by the problem, then ensure
        // all data in the new mesh has the appropriate timestepper
        if (dynamic_cast<GeneralisedTimeStepper*>(this->Time_stepper_pt))
        {
          new_mesh_pt->set_nodal_and_elemental_time_stepper(
            this->Time_stepper_pt, false);
          new_mesh_pt->set_mesh_level_time_stepper(this->Time_stepper_pt,
                                                   false);
        }

        // Not done: get ready for another iteration
        iter++;
        delete tmp_new_mesh_pt;

#ifdef OOMPH_HAS_MPI
        // Check whether the number of elements that need (un)refinement
        // from the previous iteration is the same, if that is the case
        // then we mark this processor as done
        if (n_ele_need_refinement_iter == n_ele_need_refinement)
        {
          done = true;
        }
        // Update the number of elements that require further
        // (un)refinement
        n_ele_need_refinement = n_ele_need_refinement_iter;
#endif // #ifdef OOMPH_HAS_MPI

        // ------------------------------------------
        // DISTRIBUTED MESH: BEGIN
        // ------------------------------------------

        // We can only finish the iteration adaptation process if ALL
        // the involved processor are marked as done, otherwise, ALL
        // processor need to go for another iteration
#ifdef OOMPH_HAS_MPI
        if (this->is_mesh_distributed())
        {
          // Time to check whether other processors have finish to adapt
          const double t_start_wait_other_processors = TimingHelpers::timer();

          // In case that the mesh is distributed it is necessary to
          // verify that no processor requires further refinement. If at
          // least one processor needs more refinement then all
          // processors need to go for another iteration to participate
          // in the communications
          unsigned this_processor_requires_another_iteration = 1;

          // Is this processor done?
          if (done)
          {
            this_processor_requires_another_iteration = 0;
          }
          int nproc_not_done = this_processor_requires_another_iteration;
          // Get the communicator of the mesh
          OomphCommunicator* comm_pt = this->communicator_pt();
          // Communicate with all procesoors to check whether we need to
          // re-iterate
          MPI_Allreduce(&this_processor_requires_another_iteration,
                        &nproc_not_done,
                        1,
                        MPI_UNSIGNED,
                        MPI_SUM,
                        comm_pt->mpi_comm());
          // Are all processors done?
          if (nproc_not_done > 0)
          {
            oomph_info
              << "At least one processors requires further refinement. "
              << "Go for another iteration." << std::endl;
            done = false;
          }

          // Total to check whether other processors have finish to
          // adapt
          const double t_sub_total_wait_other_processors =
            TimingHelpers::timer() - t_start_wait_other_processors;

          // Add to the total timings to check whether other processors
          // need to adapt
          t_total_wait_other_processors += t_sub_total_wait_other_processors;

          if (Print_timings_level_adaptation > 2)
          {
            oomph_info << "CPU for waiting other processors "
                       << "(iter " << iter
                       << "): " << t_sub_total_wait_other_processors
                       << std::endl;
          }

        } // if (this->is_mesh_distributed())
#endif
        // ------------------------------------------
        // DISTRIBUTED MESH: END
        // ------------------------------------------

        if (!done)
        {
          oomph_info << "Going for another iteration. Current iteration ("
                     << iter << ")" << std::endl;

          // Use the new mesh as the tmp mesh
          tmp_new_mesh_pt = new_mesh_pt;
          tmp_new_triangulateio = new_mesh_pt->triangulateio_representation();
        }

      } // end of iteration (while (!done))

      // Delete the temporary geometric object representation of the
      // current mesh
      delete mesh_geom_obj_pt;

      oomph_info << "CPU for iterative generation of new mesh (TOTAL): "
                 << TimingHelpers::timer() - t_iter << std::endl;

      if (Print_timings_level_adaptation > 1)
      {
        oomph_info << "-- CPU for creating new adapted meshes (TOTAL): "
                   << t_total_create_new_adapted_mesh << std::endl;

        oomph_info << "-- CPU for limiting target areas (TOTAL): "
                   << t_total_limit_target_areas << std::endl;

        oomph_info << "-- CPU for transferring target areas (TOTAL): "
                   << t_total_transfer_target_areas << std::endl;

        oomph_info << "-- CPU for waiting other processors (TOTAL): "
                   << t_total_wait_other_processors << std::endl;
      }

      // ==============================================================
      // END: Transferring of target areas and creation of new mesh
      // ==============================================================

      // ==============================================================
      // BEGIN: Project solution from the old to the new mesh
      // ==============================================================

      // Check that the projection step is not disabled
      if (!Disable_projection)
      {
        // Take the time for the projection step
        double tt_start_projection = TimingHelpers::timer();

        // Print info. for tranfering target areas
        if (Print_timings_projection)
        {
          // Switch timings and stats on
          Multi_domain_functions::Doc_timings = true;
          Multi_domain_functions::Doc_stats = true;
          Multi_domain_functions::Doc_full_stats = true;
        }

        double t_proj = TimingHelpers::timer();
        oomph_info << "About to begin projection.\n";

        // Project current solution onto new mesh
        //---------------------------------------
        ProjectionProblem<ELEMENT>* project_problem_pt =
          new ProjectionProblem<ELEMENT>;

        // Projection requires to be enabled as distributed if working
        // with a distributed mesh
#ifdef OOMPH_HAS_MPI
        if (this->is_mesh_distributed())
        {
          // ------------------------------------------
          // DISTRIBUTED MESH: BEGIN
          // ------------------------------------------

          // We need to back up the time stepper object since the
          // projection class creates a new one
          Time* backed_up_time_pt = this->Time_stepper_pt->time_pt();

          // Set the projection problem as distributed
          project_problem_pt->enable_problem_distributed();

          // Pass the time stepper to the projection problem (used when
          // setting multi_domain_interation)
          project_problem_pt->add_time_stepper_pt(this->Time_stepper_pt);

          // Set the mesh used for the projection object
          project_problem_pt->mesh_pt() = new_mesh_pt;
          // project_problem_pt->disable_suppress_output_during_projection();

          // Use iterative solver for projection? By default, an iterative
          // solver is used for the projection stage
          if (!this->use_iterative_solver_for_projection())
          {
            project_problem_pt->disable_use_iterative_solver_for_projection();
          }

          // Do the projection
          project_problem_pt->project(this);

          // Reset the time stepper object (only affects distributed meshes)
          this->Time_stepper_pt->time_pt() = backed_up_time_pt;

          // ------------------------------------------
          // DISTRIBUTED MESH: END
          // ------------------------------------------

        } // if (this->is_mesh_distributed())
        else
#endif // #ifdef OOMPH_HAS_MPI
        {
          // Set the mesh used for the projection object
          project_problem_pt->mesh_pt() = new_mesh_pt;

          // project_problem_pt->disable_suppress_output_during_projection();

          // Use iterative solver for projection? By default, an iterative
          // solver is used for the projection stage
          if (!this->use_iterative_solver_for_projection())
          {
            project_problem_pt->disable_use_iterative_solver_for_projection();
          }

          // Do the projection
          project_problem_pt->project(this);
        }

        // Reset printing info. for projection
        if (Print_timings_projection)
        {
          // Switch timings and stats off
          Multi_domain_functions::Doc_timings = false;
          Multi_domain_functions::Doc_stats = false;
          Multi_domain_functions::Doc_full_stats = false;
        }

        // Get the total time for projection
        const double tt_projection =
          TimingHelpers::timer() - tt_start_projection;

        if (Print_timings_level_adaptation > 1)
        {
          // Get the number of elements in the old mesh (this)
          const unsigned n_element = this->nelement();
          // Get the number of elements in the new mesh
          const unsigned n_element_new = new_mesh_pt->nelement();
          oomph_info << "CPU for projection (in mesh adaptation) "
                     << "[n_ele_old_mesh=" << n_element
                     << ", n_ele_new_mesh=" << n_element_new
                     << "]: " << tt_projection << std::endl;

          // ------------------------------------------
          // DISTRIBUTED MESH: BEGIN
          // ------------------------------------------
#ifdef OOMPH_HAS_MPI
          if (this->is_mesh_distributed())
          {
            // The maximum number of elements in the mesh (over all
            // processors)
            unsigned n_this_element_new = n_element_new;
            unsigned n_max_element_new_global = 0;
            // Get the maximum number of elements over all processors
            MPI_Reduce(&n_this_element_new,
                       &n_max_element_new_global,
                       1,
                       MPI_UNSIGNED,
                       MPI_MAX,
                       0,
                       this->communicator_pt()->mpi_comm());

            // The time for projection for this processor
            double tt_this_projection = tt_projection;
            double tt_global_min_projection = 0.0;
            double tt_global_max_projection = 0.0;

            // Get the minimum and maximum time for projection
            MPI_Reduce(&tt_this_projection,
                       &tt_global_min_projection,
                       1,
                       MPI_DOUBLE,
                       MPI_MIN,
                       0,
                       this->communicator_pt()->mpi_comm());
            MPI_Reduce(&tt_this_projection,
                       &tt_global_max_projection,
                       1,
                       MPI_DOUBLE,
                       MPI_MAX,
                       0,
                       this->communicator_pt()->mpi_comm());

            if (this->communicator_pt()->my_rank() == 0)
            {
              oomph_info << "CPU for projection global (MIN): "
                         << tt_global_min_projection << std::endl;
              oomph_info << "CPU for projection global (MAX) "
                         << "[n_max_ele_new_global=" << n_max_element_new_global
                         << "]: " << tt_global_max_projection << std::endl;

              std::cerr << "CPU for projection global (MIN): "
                        << tt_global_min_projection << std::endl;
              std::cerr << "CPU for projection global (MAX): "
                        << "[n_max_ele_new_global=" << n_max_element_new_global
                        << "]: " << tt_global_max_projection << std::endl;
            }
          }
#endif // #ifdef OOMPH_HAS_MPI
       // ------------------------------------------
       // DISTRIBUTED MESH: END
       // ------------------------------------------

        } // if (Print_timings_level_adaptation>1)

        oomph_info << "CPU for projection of solution onto new mesh: "
                   << TimingHelpers::timer() - t_proj << std::endl;

        // Delete the projection problem
        delete project_problem_pt;

      } // if (!Disable_projection)
      else
      {
        oomph_info << "Projection disabled! The new mesh will contain zeros"
                   << std::endl;
      }

      // ==============================================================
      // END: Project solution from the old to the new mesh
      // ==============================================================

      double t_rest = TimingHelpers::timer();

      // Flush the old mesh
      unsigned nnod = nnode();
      for (unsigned j = nnod; j > 0; j--)
      {
        delete Node_pt[j - 1];
        Node_pt[j - 1] = 0;
      }
      unsigned nel = nelement();
      for (unsigned e = nel; e > 0; e--)
      {
        delete Element_pt[e - 1];
        Element_pt[e - 1] = 0;
      }

      // Now copy back to current mesh
      //------------------------------
      nnod = new_mesh_pt->nnode();
      Node_pt.resize(nnod);
      nel = new_mesh_pt->nelement();
      Element_pt.resize(nel);
      for (unsigned j = 0; j < nnod; j++)
      {
        Node_pt[j] = new_mesh_pt->node_pt(j);
      }
      for (unsigned e = 0; e < nel; e++)
      {
        Element_pt[e] = new_mesh_pt->element_pt(e);
      }

      // Copy the boundary elements information from the new mesh to the
      // original mesh
      unsigned nbound = 0;

#ifdef OOMPH_HAS_MPI
      // If working with a distributed mesh we need to change the number
      // of boundaries so that shared boundaries information is also
      // copied from the old to the new mesh
      if (this->is_mesh_distributed())
      {
        // The boundaries to be copied include those new ones in the new
        // mesh (shared boundaries). This info. is required to
        // re-establish the halo/haloed scheme
        nbound = new_mesh_pt->nboundary();
        // After halo and haloed scheme has been re-established the
        // number of boundaries is changed to the original number of
        // boundaries
      }
      else
#endif
      {
        // The original number of boundaries
        nbound = n_boundary;
      }

      Boundary_element_pt.resize(nbound);
      Face_index_at_boundary.resize(nbound);
      Boundary_node_pt.resize(nbound);
      for (unsigned b = 0; b < nbound; b++)
      {
        unsigned nel = new_mesh_pt->nboundary_element(b);
        Boundary_element_pt[b].resize(nel);
        Face_index_at_boundary[b].resize(nel);
        for (unsigned e = 0; e < nel; e++)
        {
          Boundary_element_pt[b][e] = new_mesh_pt->boundary_element_pt(b, e);
          Face_index_at_boundary[b][e] =
            new_mesh_pt->face_index_at_boundary(b, e);
        }
        unsigned nnod = new_mesh_pt->nboundary_node(b);
        Boundary_node_pt[b].resize(nnod);
        for (unsigned j = 0; j < nnod; j++)
        {
          Boundary_node_pt[b][j] = new_mesh_pt->boundary_node_pt(b, j);
        }
      }

      // Also copy over the new boundary and region information
      unsigned n_region = new_mesh_pt->nregion();
      // Only bother if we have regions
      if (n_region > 1)
      {
        // Deal with the region information first
        this->Region_attribute.resize(n_region);
        for (unsigned r = 0; r < n_region; r++)
        {
          this->Region_attribute[r] = new_mesh_pt->region_attribute(r);
          // Get the region id
          unsigned r_id = static_cast<unsigned>(this->Region_attribute[r]);
          // Find the number of elements in the region
          unsigned n_region_element = new_mesh_pt->nregion_element(r_id);
          this->Region_element_pt[r_id].resize(n_region_element);
          for (unsigned e = 0; e < n_region_element; e++)
          {
            this->Region_element_pt[r_id][e] =
              new_mesh_pt->region_element_pt(r_id, e);
          }
        }

        // Now the boundary region information
        this->Boundary_region_element_pt.resize(nbound);
        this->Face_index_region_at_boundary.resize(nbound);

        // Now loop over the boundaries
        for (unsigned b = 0; b < nbound; ++b)
        {
          for (unsigned rr = 0; rr < n_region; rr++)
          {
            // The region id
            unsigned r = static_cast<unsigned>(this->Region_attribute[rr]);

            unsigned n_boundary_el_in_region =
              new_mesh_pt->nboundary_element_in_region(b, r);

            if (n_boundary_el_in_region > 0)
            {
              // Allocate storage in the map
              this->Boundary_region_element_pt[b][r].resize(
                n_boundary_el_in_region);
              this->Face_index_region_at_boundary[b][r].resize(
                n_boundary_el_in_region);

              // Copy over the information
              for (unsigned e = 0; e < n_boundary_el_in_region; ++e)
              {
                this->Boundary_region_element_pt[b][r][e] =
                  new_mesh_pt->boundary_element_in_region_pt(b, r, e);
                this->Face_index_region_at_boundary[b][r][e] =
                  new_mesh_pt->face_index_at_boundary_in_region(b, r, e);
              }
            }
          }
        } // End of loop over boundaries

      } // End of case when more than one region

      // ------------------------------------------
      // DISTRIBUTED MESH: BEGIN
      // ------------------------------------------

      // Re-generate halo(ed) information (only for distributed meshes)
#ifdef OOMPH_HAS_MPI
      if (this->is_mesh_distributed())
      {
        // Delete halo(ed) information in the original mesh, the new
        // halo(ed) information is generated usign the info. of the new
        // mesh
        if (this->is_mesh_distributed())
        {
          this->Halo_node_pt.clear();
          this->Root_halo_element_pt.clear();

          this->Haloed_node_pt.clear();
          this->Root_haloed_element_pt.clear();

          this->External_halo_node_pt.clear();
          this->External_halo_element_pt.clear();

          this->External_haloed_node_pt.clear();
          this->External_haloed_element_pt.clear();
        }

        // Re-establish the shared boundary elements and nodes scheme
        // before re-establish halo(ed) information
        this->reset_shared_boundary_elements_and_nodes();

        // -------------------------------------------------------------
        // Remove shared boundary elements and nodes from original
        // boundary elements and boundary nodes containers. Shared
        // boundary elements and nodes are stored in a special
        // container.

        // Get the shared boundaries in this processor with any other
        // processor
        Vector<unsigned> my_rank_shared_boundaries_ids;
        this->shared_boundaries_in_this_processor(
          my_rank_shared_boundaries_ids);

        // Get the number of shared boundaries
        const unsigned nmy_rank_shd_bnd = my_rank_shared_boundaries_ids.size();
        // Loop over the shared boundaries marked as original boundaries
        // in tmp_new_mesh
        for (unsigned i = 0; i < nmy_rank_shd_bnd; i++)
        {
          // Get the boundary id
          const unsigned shd_bnd_id = my_rank_shared_boundaries_ids[i];
          // Flush any previous relation of shared boundary elements
          // marked as original boundary elements in tmp_new_mesh
          this->Boundary_element_pt[shd_bnd_id].clear();

          // Get the number of nodes associated with the original
          // boundary in tmp_new_mesh that is a shared boundary
          const unsigned tmp_nnodes = this->nshared_boundary_node(shd_bnd_id);
          for (unsigned n = 0; n < tmp_nnodes; n++)
          {
            Node* tmp_node_pt = this->boundary_node_pt(shd_bnd_id, n);
            tmp_node_pt->remove_from_boundary(shd_bnd_id);
          } // for (n < nnodes)

        } // for (shd_bnd_id < nmy_rank_shd_bnd)

        // Re-set the number of boundaries to the original one
        this->set_nboundary(n_boundary);

        // Sort the nodes on the boundaries so that they have the same
        // order on all the boundaries
        this->sort_nodes_on_shared_boundaries();

        // Re-set the halo(ed) scheme
        this->reset_halo_haloed_scheme();

        // Set the correct number of segments for the boundaries with
        // geom objects associated
        for (unsigned b = 0; b < n_boundary; b++)
        {
          if (this->boundary_geom_object_pt(b) != 0)
          {
            const unsigned nsegments = new_mesh_pt->nboundary_segment(b);
            this->set_nboundary_segment_node(b, nsegments);
          }
        }

        // Resume the connections in boundaries were it was suspended
        resume_boundary_connections(resume_initial_connection_polyline_pt,
                                    resume_final_connection_polyline_pt);

      } // if (this->is_mesh_distributed())

#endif // #ifdef OOMPH_HAS_MPI

      // ------------------------------------------
      // DISTRIBUTED MESH: END
      // ------------------------------------------

      // Snap the newly created nodes onto any geometric objects
      this->snap_nodes_onto_geometric_objects();

      // Copy the IDs of the vertex nodes
      this->Oomph_vertex_nodes_id = new_mesh_pt->oomph_vertex_nodes_id();

      // Copy TriangulateIO representation
      TriangleHelper::clear_triangulateio(this->Triangulateio);
      bool quiet = true;
      this->Triangulateio =
        TriangleHelper::deep_copy_of_triangulateio_representation(
          new_mesh_pt->triangulateio_representation(), quiet);

      // Flush the mesh
      new_mesh_pt->flush_element_and_node_storage();

      // Delete the mesh
      delete new_mesh_pt;

      // Resume of timings
      if (Print_timings_level_adaptation > 2)
      {
        // Report timings related with setting boundary coordinates of
        // nodes on segments
        oomph_info << "CPU for segments connectivity (first stage) [sec]: "
                   << t_total_first_stage_segments_connectivity << std::endl;
        oomph_info << "CPU for segments connectivity (second stage) [sec]: "
                   << t_total_second_stage_segments_connectivity << std::endl;
        oomph_info << "CPU for segments connectivity (third stage) [sec]: "
                   << t_total_third_stage_segments_connectivity << std::endl;
      }

      if (Print_timings_level_adaptation > 1)
      {
        const double t_total_segments_connectivity =
          t_total_first_stage_segments_connectivity +
          t_total_second_stage_segments_connectivity +
          t_total_third_stage_segments_connectivity;

        oomph_info << "CPU for segments connectivity (TOTAL) [sec]: "
                   << t_total_segments_connectivity << std::endl;

        if (Print_timings_level_adaptation > 2)
        {
          // Report timings for snapping of nodes onto boundaries
          oomph_info << "CPU for snapping nodes onto boundaries "
                     << "(new mesh): " << t_total_snap_nodes << std::endl;
        }

        t_total_snap_nodes += t_total_snap_nodes_bg_mesh;
        oomph_info << "CPU for snapping nodes onto boundaries (TOTAL): "
                   << t_total_snap_nodes << std::endl;
      }

      double max_area = 0.0;
      double min_area = 0.0;

      this->max_and_min_element_size(max_area, min_area);
      oomph_info << "Max/min element size in adapted mesh: " << max_area << " "
                 << min_area << std::endl;

      oomph_info << "CPU time for final bits [sec]: "
                 << TimingHelpers::timer() - t_rest << std::endl;
    }
    else
    {
      oomph_info << "Not enough benefit in adaptation.\n";
      Nrefined = 0;
      Nunrefined = 0;
    }

    double CPU_for_adaptation = TimingHelpers::timer() - t_start_overall;
    oomph_info << "CPU time for adaptation [sec]: " << CPU_for_adaptation
               << std::endl;

    // ------------------------------------------
    // DISTRIBUTED MESH: BEGIN
    // ------------------------------------------
#ifdef OOMPH_HAS_MPI
    if (this->is_mesh_distributed())
    {
      // Get the communicator
      OomphCommunicator* comm_pt = this->communicator_pt();
      // Get the total number of processors to compute the average
      const unsigned n_proc = comm_pt->nproc();
      if (Print_timings_level_adaptation > 1 && n_proc > 1)
      {
        double global_min_CPU_for_adaptation = 0.0;
        double global_max_CPU_for_adaptation = 0.0;
        double global_average_CPU_for_adaptation = 0.0;

        // Get the maximum and minimum of the adaptation times
        MPI_Reduce(&CPU_for_adaptation,
                   &global_min_CPU_for_adaptation,
                   1,
                   MPI_DOUBLE,
                   MPI_MIN,
                   0,
                   comm_pt->mpi_comm());
        MPI_Reduce(&CPU_for_adaptation,
                   &global_max_CPU_for_adaptation,
                   1,
                   MPI_DOUBLE,
                   MPI_MAX,
                   0,
                   comm_pt->mpi_comm());
        MPI_Reduce(&CPU_for_adaptation,
                   &global_average_CPU_for_adaptation,
                   1,
                   MPI_DOUBLE,
                   MPI_SUM,
                   0,
                   comm_pt->mpi_comm());

        // Get the rank of the processor
        const unsigned my_rank = comm_pt->my_rank();
        if (my_rank == 0)
        {
          oomph_info << "CPU for adaptation (MIN): "
                     << global_min_CPU_for_adaptation << std::endl;
          oomph_info << "CPU for adaptation (MAX): "
                     << global_max_CPU_for_adaptation << std::endl;
          oomph_info << "CPU for adaptation (AVERAGE): "
                     << global_average_CPU_for_adaptation / n_proc << std::endl;
        } // if (my_rank==0)

      } // if (Print_timings_level_adaptation>1&&n_proc>1)

    } // if (this->is_mesh_distributed())

    // ------------------------------------------
    // DISTRIBUTED MESH: END
    // ------------------------------------------

#endif // #ifdef OOMPH_HAS_MPI
  }

  //=========================================================================
  /// Mark the vertices that are not allowed for deletion by
  /// the unrefienment/refinement polyline methods. In charge of
  /// filling the Boundary_connections_pt structure
  //=========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::add_vertices_for_non_deletion()
  {
    // Clear any previous information
    // Boundary_chunk_connections_pt.clear();
    Boundary_connections_pt.clear();

    // Loop over the boundaries in the domain (outer, internal -- closed
    // and open ---, and shared) and get the boundaries ids with
    // connections (have or receive)

    // Store the boundaries ids that have or receive connection
    std::set<unsigned> boundary_id_with_connections;

    // ------------------------------------------------------------------
    // Outer boundaries
    // ------------------------------------------------------------------

    // Get the number of outer boundaries (closed boundaries)
    const unsigned n_outer_boundaries = this->Outer_boundary_pt.size();

    // Loop over the outer boundaries
    for (unsigned i = 0; i < n_outer_boundaries; i++)
    {
      // Get a temporary polygon representation
      TriangleMeshPolygon* tmp_polygon_pt = this->Outer_boundary_pt[i];
      // Get the number of polylines associated to the current outer
      // boundary
      const unsigned n_polyline = tmp_polygon_pt->npolyline();
      // Loop over the polylines
      for (unsigned p = 0; p < n_polyline; p++)
      {
        // Get a temporary representation of the polyline
        TriangleMeshPolyLine* tmp_polyline_pt = tmp_polygon_pt->polyline_pt(p);

        // Is the initial vertex connected?
        if (tmp_polyline_pt->is_initial_vertex_connected())
        {
          // Get the boundary id of the current polyline
          const unsigned bnd_id = tmp_polyline_pt->boundary_id();

          // Include the boundary id to the set of boundaries with
          // connections
          boundary_id_with_connections.insert(bnd_id);

          // Boundary id to which the curve is connecte
          const unsigned dst_bnd_id =
            tmp_polyline_pt->initial_vertex_connected_bnd_id();

          // Include the destination boundary id to the set of
          // boundaries with connections
          boundary_id_with_connections.insert(dst_bnd_id);

        } // if (tmp_polyline_pt->is_initial_vertex_connected())

        // Is the final vertex connected?
        if (tmp_polyline_pt->is_final_vertex_connected())
        {
          // Get the boundary id of the current polyline
          const unsigned bnd_id = tmp_polyline_pt->boundary_id();

          // Include the boundary id to the set of boundaries with
          // connections
          boundary_id_with_connections.insert(bnd_id);

          // Boundary id to which the curve is connected
          const unsigned dst_bnd_id =
            tmp_polyline_pt->final_vertex_connected_bnd_id();

          // Include the destination boundary id to the set of
          // boundaries with connections
          boundary_id_with_connections.insert(dst_bnd_id);

        } // if (tmp_polyline_pt->is_final_vertex_connected())

      } // for (p < n_polyline)

    } // for (i < n_outer_boundaries)

    // ------------------------------------------------------------------
    // Internal boundaries
    // ------------------------------------------------------------------

    // Get the number of internal boundaries (closed boundaries)
    const unsigned n_internal_boundaries = this->Internal_polygon_pt.size();

    // Loop over the internal boundaries
    for (unsigned i = 0; i < n_internal_boundaries; i++)
    {
      // Get a temporary polygon representation
      TriangleMeshPolygon* tmp_polygon_pt = this->Internal_polygon_pt[i];
      // Get the number of polylines associated to the current internal
      // boundary
      const unsigned n_polyline = tmp_polygon_pt->npolyline();
      // Loop over the polylines
      for (unsigned p = 0; p < n_polyline; p++)
      {
        // Get a temporary representation of the polyline
        TriangleMeshPolyLine* tmp_polyline_pt = tmp_polygon_pt->polyline_pt(p);

        // Is the initial vertex connected?
        if (tmp_polyline_pt->is_initial_vertex_connected())
        {
          // Get the boundary id of the current polyline
          const unsigned bnd_id = tmp_polyline_pt->boundary_id();

          // Include the boundary id to the set of boundaries with
          // connections
          boundary_id_with_connections.insert(bnd_id);

          // Boundary id to which the curve is connecte
          const unsigned dst_bnd_id =
            tmp_polyline_pt->initial_vertex_connected_bnd_id();

          // Include the destination boundary id to the set of
          // boundaries with connections
          boundary_id_with_connections.insert(dst_bnd_id);

        } // if (tmp_polyline_pt->is_initial_vertex_connected())

        // Is the final vertex connected?
        if (tmp_polyline_pt->is_final_vertex_connected())
        {
          // Get the boundary id of the current polyline
          const unsigned bnd_id = tmp_polyline_pt->boundary_id();

          // Include the boundary id to the set of boundaries with
          // connections
          boundary_id_with_connections.insert(bnd_id);

          // Boundary id to which the curve is connected
          const unsigned dst_bnd_id =
            tmp_polyline_pt->final_vertex_connected_bnd_id();

          // Include the destination boundary id to the set of
          // boundaries with connections
          boundary_id_with_connections.insert(dst_bnd_id);

        } // if (tmp_polyline_pt->is_final_vertex_connected())

      } // for (p < n_polyline)

    } // for (i < n_internal_boundaries)

    // ------------------------------------------------------------------
    // Open boundaries (nonclosed internal boundaries)
    // ------------------------------------------------------------------

    // Get the number of internal boundaries (open boundaries)
    const unsigned n_open_boundaries = this->Internal_open_curve_pt.size();

    // Loop over the internal open boundaries
    for (unsigned i = 0; i < n_open_boundaries; i++)
    {
      // Get a temporary representation for the open curve
      TriangleMeshOpenCurve* tmp_open_curve_pt =
        this->Internal_open_curve_pt[i];

      // Get the number of curve sections associated to the current
      // internal open boundary
      const unsigned n_curve_section = tmp_open_curve_pt->ncurve_section();

      // Loop over the curve section
      for (unsigned p = 0; p < n_curve_section; p++)
      {
        // Get a temporary representation of the curve section
        // (polyline)
        TriangleMeshPolyLine* tmp_polyline_pt =
          tmp_open_curve_pt->polyline_pt(p);

        // Is the initial vertex connected?
        if (tmp_polyline_pt->is_initial_vertex_connected())
        {
          // Get the boundary id of the current polyline
          const unsigned bnd_id = tmp_polyline_pt->boundary_id();

          // Include the boundary id to the set of boundaries with
          // connections
          boundary_id_with_connections.insert(bnd_id);

          // Boundary id to which the curve is connecte
          const unsigned dst_bnd_id =
            tmp_polyline_pt->initial_vertex_connected_bnd_id();

          // Include the destination boundary id to the set of
          // boundaries with connections
          boundary_id_with_connections.insert(dst_bnd_id);

        } // if (tmp_polyline_pt->is_initial_vertex_connected())

        // Is the final vertex connected?
        if (tmp_polyline_pt->is_final_vertex_connected())
        {
          // Get the boundary id of the current polyline
          const unsigned bnd_id = tmp_polyline_pt->boundary_id();

          // Include the boundary id to the set of boundaries with
          // connections
          boundary_id_with_connections.insert(bnd_id);

          // Boundary id to which the curve is connected
          const unsigned dst_bnd_id =
            tmp_polyline_pt->final_vertex_connected_bnd_id();

          // Include the destination boundary id to the set of
          // boundaries with connections
          boundary_id_with_connections.insert(dst_bnd_id);

        } // if (tmp_polyline_pt->is_final_vertex_connected())

      } // for (p < n_curve_section)

    } // for (i < n_open_boundaries)

#ifdef OOMPH_HAS_MPI
    // ------------------------------------------------------------------
    // Shared boundaries (only for distributed meshes)
    // ------------------------------------------------------------------

    // Check if we need to include any information associated with
    // shared boundaries
    if (this->is_mesh_distributed())
    {
      // Get the rank of the current processor
      const unsigned my_rank = this->communicator_pt()->my_rank();

      // Get the number of shared curves in the current processor
      const unsigned n_shared_curves = this->nshared_boundary_curves(my_rank);

      // Loop over the shared curves
      for (unsigned i = 0; i < n_shared_curves; i++)
      {
        // Get the number of polylines associated to the current shared
        // curve
        const unsigned n_polyline = this->nshared_boundary_polyline(my_rank, i);

        // Loop over the polylines associated to the current shared
        // curve
        for (unsigned p = 0; p < n_polyline; p++)
        {
          // Get a temporary representation of the shared polyline
          TriangleMeshPolyLine* tmp_polyline_pt =
            this->shared_boundary_polyline_pt(my_rank, i, p);

          // Is the initial vertex connected?
          if (tmp_polyline_pt->is_initial_vertex_connected())
          {
            // Get the boundary id of the current polyline
            const unsigned bnd_id = tmp_polyline_pt->boundary_id();

            // Include the boundary id to the set of boundaries with
            // connections
            boundary_id_with_connections.insert(bnd_id);

            // Boundary id to which the curve is connecte
            const unsigned dst_bnd_id =
              tmp_polyline_pt->initial_vertex_connected_bnd_id();

            // Include the destination boundary id to the set of
            // boundaries with connections
            boundary_id_with_connections.insert(dst_bnd_id);

          } // if (tmp_polyline_pt->is_initial_vertex_connected())

          // Is the final vertex connected?
          if (tmp_polyline_pt->is_final_vertex_connected())
          {
            // Get the boundary id of the current polyline
            const unsigned bnd_id = tmp_polyline_pt->boundary_id();

            // Include the boundary id to the set of boundaries with
            // connections
            boundary_id_with_connections.insert(bnd_id);

            // Boundary id to which the curve is connected
            const unsigned dst_bnd_id =
              tmp_polyline_pt->final_vertex_connected_bnd_id();

            // Include the destination boundary id to the set of
            // boundaries with connections
            boundary_id_with_connections.insert(dst_bnd_id);

          } // if (tmp_polyline_pt->is_final_vertex_connected())

        } // for (p < n_polyline)

      } // for (i < n_shared_curves)

    } // if (this->is_mesh_distributed())

#endif // #ifdef OOMPH_HAS_MPI

    // ---------------------------------------------------------------
    // Get the nodes sorted by segments of the boundaries with
    // connections

    // Store the sorted nodes by segments of the boundaries with
    // connections
    std::map<unsigned, Vector<Vector<Node*>>> bnd_sorted_segment_node_pt;

    // Loop over the boundaries with connections
    for (std::set<unsigned>::iterator it = boundary_id_with_connections.begin();
         it != boundary_id_with_connections.end();
         it++)
    {
      // Get the boundary id
      const unsigned bnd_id = (*it);
#ifdef OOMPH_HAS_MPI
      // Working with a distributed mesh
      if (this->is_mesh_distributed())
      {
        // Get the initial shared boundary id
        const unsigned init_shd_bnd_id = this->initial_shared_boundary_id();
        // Is an original or shared boundary
        if (bnd_id >= init_shd_bnd_id)
        {
          // Is a shared boundary

          // Temporary storage for the nodes on the shared boundary
          Vector<Vector<Node*>> tmp_shared_nodes_pt;

          // Get the nodes associated to the shared boundary
          get_shared_boundary_segment_nodes_helper(bnd_id, tmp_shared_nodes_pt);

          // Store the nodes associated to the shared boundary
          bnd_sorted_segment_node_pt[bnd_id] = tmp_shared_nodes_pt;

        } // if (bnd_id >= init_shd_bnd_id)
        else
        {
          // Is an original boundary

          // Temporary storage for the nodes on the original boundary
          Vector<Vector<Node*>> tmp_boundary_nodes_pt;

          // Get the nodes associated to the shared boundary
          get_boundary_segment_nodes_helper(bnd_id, tmp_boundary_nodes_pt);

          // Store the nodes associated to the shared boundary
          bnd_sorted_segment_node_pt[bnd_id] = tmp_boundary_nodes_pt;

        } // if (bnd_id >= init_shd_bnd_id)

      } // if (this->is_mesh_distributed())
      else
#endif // #ifdef OOMPH_HAS_MPI
      {
        // Is an original boundary

        // Temporary storage for the nodes on the original boundary
        Vector<Vector<Node*>> tmp_boundary_nodes_pt;

        // Get the nodes associated to the shared boundary
        get_boundary_segment_nodes_helper(bnd_id, tmp_boundary_nodes_pt);

        // Store the nodes associated to the shared boundary
        bnd_sorted_segment_node_pt[bnd_id] = tmp_boundary_nodes_pt;

      } // if (this->is_mesh_distributed())

    } // Loop over boundaries with connections

    // -----------------------------------------------------------------
    // Loop again over the boundaries (original and shared) and search
    // for the repeated nodes in those boundaries with connections

    // ------------------------------------------------------------------
    // Outer boundaries
    // ------------------------------------------------------------------
    // Loop over the outer boundaries
    for (unsigned i = 0; i < n_outer_boundaries; i++)
    {
      // Get a temporary polygon representation
      TriangleMeshPolygon* tmp_polygon_pt = this->Outer_boundary_pt[i];
      // Get the number of polylines associated to the current outer
      // boundary
      const unsigned n_polyline = tmp_polygon_pt->npolyline();
      // Loop over the polylines
      for (unsigned p = 0; p < n_polyline; p++)
      {
        // Get a temporary representation of the polyline
        TriangleMeshPolyLine* tmp_polyline_pt = tmp_polygon_pt->polyline_pt(p);

        // Is the initial vertex connected?
        if (tmp_polyline_pt->is_initial_vertex_connected())
        {
          // Get the boundary id of the current polyline
          const unsigned bnd_id = tmp_polyline_pt->boundary_id();

          // Boundary id to which the curve is connected
          const unsigned dst_bnd_id =
            tmp_polyline_pt->initial_vertex_connected_bnd_id();

          // Boundary chunk to which the curve is connected
          const unsigned dst_chunk =
            tmp_polyline_pt->initial_vertex_connected_n_chunk();

          // Get the nodes representation of the current boundary
          Vector<Vector<Node*>> src_bnd_node_pt =
            bnd_sorted_segment_node_pt[bnd_id];

          // Get the nodes representation of the boundary to connect
          Vector<Vector<Node*>> dst_bnd_node_pt =
            bnd_sorted_segment_node_pt[dst_bnd_id];

          // Add the repeated node to the list of non delete-able
          // vertices
          add_non_delete_vertices_from_boundary_helper(
            src_bnd_node_pt, dst_bnd_node_pt, dst_bnd_id, dst_chunk);

        } // if (tmp_polyline_pt->is_initial_vertex_connected())

        // Is the final vertex connected?
        if (tmp_polyline_pt->is_final_vertex_connected())
        {
          // Get the boundary id of the current polyline
          const unsigned bnd_id = tmp_polyline_pt->boundary_id();

          // Boundary id to which the curve is connected
          const unsigned dst_bnd_id =
            tmp_polyline_pt->final_vertex_connected_bnd_id();

          // Boundary chunk to which the curve is connected
          const unsigned dst_chunk =
            tmp_polyline_pt->final_vertex_connected_n_chunk();

          // Get the nodes representation of the current boundary
          Vector<Vector<Node*>> src_bnd_node_pt =
            bnd_sorted_segment_node_pt[bnd_id];

          // Get the nodes representation of the boundary to connect
          Vector<Vector<Node*>> dst_bnd_node_pt =
            bnd_sorted_segment_node_pt[dst_bnd_id];

          // Add the repeated node to the list of non delete-able
          // vertices
          add_non_delete_vertices_from_boundary_helper(
            src_bnd_node_pt, dst_bnd_node_pt, dst_bnd_id, dst_chunk);

        } // if (tmp_polyline_pt->is_final_vertex_connected())

      } // for (p < n_polyline)

    } // for (i < n_outer_boundaries)

    // ------------------------------------------------------------------
    // Internal boundaries
    // ------------------------------------------------------------------
    // Loop over the internal boundaries
    for (unsigned i = 0; i < n_internal_boundaries; i++)
    {
      // Get a temporary polygon representation
      TriangleMeshPolygon* tmp_polygon_pt = this->Internal_polygon_pt[i];
      // Get the number of polylines associated to the current internal
      // boundary
      const unsigned n_polyline = tmp_polygon_pt->npolyline();
      // Loop over the polylines
      for (unsigned p = 0; p < n_polyline; p++)
      {
        // Get a temporary representation of the polyline
        TriangleMeshPolyLine* tmp_polyline_pt = tmp_polygon_pt->polyline_pt(p);

        // Is the initial vertex connected?
        if (tmp_polyline_pt->is_initial_vertex_connected())
        {
          // Get the boundary id of the current polyline
          const unsigned bnd_id = tmp_polyline_pt->boundary_id();

          // Boundary id to which the curve is connected
          const unsigned dst_bnd_id =
            tmp_polyline_pt->initial_vertex_connected_bnd_id();

          // Boundary chunk to which the curve is connected
          const unsigned dst_chunk =
            tmp_polyline_pt->initial_vertex_connected_n_chunk();

          // Get the nodes representation of the current boundary
          Vector<Vector<Node*>> src_bnd_node_pt =
            bnd_sorted_segment_node_pt[bnd_id];

          // Get the nodes representation of the boundary to connect
          Vector<Vector<Node*>> dst_bnd_node_pt =
            bnd_sorted_segment_node_pt[dst_bnd_id];

          // Add the repeated node to the list of non delete-able
          // vertices
          add_non_delete_vertices_from_boundary_helper(
            src_bnd_node_pt, dst_bnd_node_pt, dst_bnd_id, dst_chunk);

        } // if (tmp_polyline_pt->is_initial_vertex_connected())

        // Is the final vertex connected?
        if (tmp_polyline_pt->is_final_vertex_connected())
        {
          // Get the boundary id of the current polyline
          const unsigned bnd_id = tmp_polyline_pt->boundary_id();

          // Boundary id to which the curve is connected
          const unsigned dst_bnd_id =
            tmp_polyline_pt->final_vertex_connected_bnd_id();

          // Boundary chunk to which the curve is connected
          const unsigned dst_chunk =
            tmp_polyline_pt->final_vertex_connected_n_chunk();

          // Get the nodes representation of the current boundary
          Vector<Vector<Node*>> src_bnd_node_pt =
            bnd_sorted_segment_node_pt[bnd_id];

          // Get the nodes representation of the boundary to connect
          Vector<Vector<Node*>> dst_bnd_node_pt =
            bnd_sorted_segment_node_pt[dst_bnd_id];

          // Add the repeated node to the list of non delete-able
          // vertices
          add_non_delete_vertices_from_boundary_helper(
            src_bnd_node_pt, dst_bnd_node_pt, dst_bnd_id, dst_chunk);

        } // if (tmp_polyline_pt->is_final_vertex_connected())

      } // for (p < n_polyline)

    } // for (i < n_internal_boundaries)

    // ------------------------------------------------------------------
    // Open boundaries (nonclosed internal boundaries)
    // ------------------------------------------------------------------
    // Loop over the internal open boundaries
    for (unsigned i = 0; i < n_open_boundaries; i++)
    {
      // Get a temporary representation for the open curve
      TriangleMeshOpenCurve* tmp_open_curve_pt =
        this->Internal_open_curve_pt[i];

      // Get the number of curve sections associated to the current
      // internal open boundary
      const unsigned n_curve_section = tmp_open_curve_pt->ncurve_section();

      // Loop over the curve section
      for (unsigned p = 0; p < n_curve_section; p++)
      {
        // Get a temporary representation of the curve section
        // (polyline)
        TriangleMeshPolyLine* tmp_polyline_pt =
          tmp_open_curve_pt->polyline_pt(p);

        // Is the initial vertex connected?
        if (tmp_polyline_pt->is_initial_vertex_connected())
        {
          // Get the boundary id of the current polyline
          const unsigned bnd_id = tmp_polyline_pt->boundary_id();

          // Boundary id to which the curve is connected
          const unsigned dst_bnd_id =
            tmp_polyline_pt->initial_vertex_connected_bnd_id();

          // Boundary chunk to which the curve is connected
          const unsigned dst_chunk =
            tmp_polyline_pt->initial_vertex_connected_n_chunk();

          // Get the nodes representation of the current boundary
          Vector<Vector<Node*>> src_bnd_node_pt =
            bnd_sorted_segment_node_pt[bnd_id];

          // Get the nodes representation of the boundary to connect
          Vector<Vector<Node*>> dst_bnd_node_pt =
            bnd_sorted_segment_node_pt[dst_bnd_id];

          // Add the repeated node to the list of non delete-able
          // vertices
          add_non_delete_vertices_from_boundary_helper(
            src_bnd_node_pt, dst_bnd_node_pt, dst_bnd_id, dst_chunk);

        } // if (tmp_polyline_pt->is_initial_vertex_connected())

        // Is the final vertex connected?
        if (tmp_polyline_pt->is_final_vertex_connected())
        {
          // Get the boundary id of the current polyline
          const unsigned bnd_id = tmp_polyline_pt->boundary_id();

          // Boundary id to which the curve is connected
          const unsigned dst_bnd_id =
            tmp_polyline_pt->final_vertex_connected_bnd_id();

          // Boundary chunk to which the curve is connected
          const unsigned dst_chunk =
            tmp_polyline_pt->final_vertex_connected_n_chunk();

          // Get the nodes representation of the current boundary
          Vector<Vector<Node*>> src_bnd_node_pt =
            bnd_sorted_segment_node_pt[bnd_id];

          // Get the nodes representation of the boundary to connect
          Vector<Vector<Node*>> dst_bnd_node_pt =
            bnd_sorted_segment_node_pt[dst_bnd_id];

          // Add the repeated node to the list of non delete-able
          // vertices
          add_non_delete_vertices_from_boundary_helper(
            src_bnd_node_pt, dst_bnd_node_pt, dst_bnd_id, dst_chunk);

        } // if (tmp_polyline_pt->is_final_vertex_connected())

      } // for (p < n_curve_section)

    } // for (i < n_open_boundaries)

#ifdef OOMPH_HAS_MPI
    // ------------------------------------------------------------------
    // Shared boundaries (only for distributed meshes)
    // ------------------------------------------------------------------

    // Check if we need to include any information associated with
    // shared boundaries
    if (this->is_mesh_distributed())
    {
      // Get the rank of the current processor
      const unsigned my_rank = this->communicator_pt()->my_rank();

      // Get the number of shared curves in the current processor
      const unsigned n_shared_curves = this->nshared_boundary_curves(my_rank);

      // Loop over the shared curves
      for (unsigned i = 0; i < n_shared_curves; i++)
      {
        // Get the number of polylines associated to the current shared
        // curve
        const unsigned n_polyline = this->nshared_boundary_polyline(my_rank, i);

        // Loop over the polylines associated to the current shared
        // curve
        for (unsigned p = 0; p < n_polyline; p++)
        {
          // Get a temporary representation of the shared polyline
          TriangleMeshPolyLine* tmp_polyline_pt =
            this->shared_boundary_polyline_pt(my_rank, i, p);

          // Is the initial vertex connected?
          if (tmp_polyline_pt->is_initial_vertex_connected())
          {
            // Get the boundary id of the current polyline
            const unsigned bnd_id = tmp_polyline_pt->boundary_id();

            // Boundary id to which the curve is connected
            const unsigned dst_bnd_id =
              tmp_polyline_pt->initial_vertex_connected_bnd_id();

            // Boundary chunk to which the curve is connected
            const unsigned dst_chunk =
              tmp_polyline_pt->initial_vertex_connected_n_chunk();

            // Get the nodes representation of the current boundary
            Vector<Vector<Node*>> src_bnd_node_pt =
              bnd_sorted_segment_node_pt[bnd_id];

            // Get the nodes representation of the boundary to connect
            Vector<Vector<Node*>> dst_bnd_node_pt =
              bnd_sorted_segment_node_pt[dst_bnd_id];

            // Add the repeated node to the list of non delete-able
            // vertices
            add_non_delete_vertices_from_boundary_helper(
              src_bnd_node_pt, dst_bnd_node_pt, dst_bnd_id, dst_chunk);

          } // if (tmp_polyline_pt->is_initial_vertex_connected())

          // Is the final vertex connected?
          if (tmp_polyline_pt->is_final_vertex_connected())
          {
            // Get the boundary id of the current polyline
            const unsigned bnd_id = tmp_polyline_pt->boundary_id();

            // Boundary id to which the curve is connected
            const unsigned dst_bnd_id =
              tmp_polyline_pt->final_vertex_connected_bnd_id();

            // Boundary chunk to which the curve is connected
            const unsigned dst_chunk =
              tmp_polyline_pt->final_vertex_connected_n_chunk();

            // Get the nodes representation of the current boundary
            Vector<Vector<Node*>> src_bnd_node_pt =
              bnd_sorted_segment_node_pt[bnd_id];

            // Get the nodes representation of the boundary to connect
            Vector<Vector<Node*>> dst_bnd_node_pt =
              bnd_sorted_segment_node_pt[dst_bnd_id];

            // Add the repeated node to the list of non delete-able
            // vertices
            add_non_delete_vertices_from_boundary_helper(
              src_bnd_node_pt, dst_bnd_node_pt, dst_bnd_id, dst_chunk);

          } // if (tmp_polyline_pt->is_final_vertex_connected())

        } // for (p < n_polyline)

      } // for (i < n_shared_curves)

    } // if (this->is_mesh_distributed())

#endif // #ifdef OOMPH_HAS_MPI
  }

  //=========================================================================
  /// Adds the vertices from the sources boundary that are
  /// repeated in the destination boundary to the list of non
  /// delete-able vertices in the destination boundary
  //=========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::
    add_non_delete_vertices_from_boundary_helper(
      Vector<Vector<Node*>> src_bound_segment_node_pt,
      Vector<Vector<Node*>> dst_bound_segment_node_pt,
      const unsigned& dst_bnd_id,
      const unsigned& dst_bnd_chunk)
  {
    // Get the number of segments in the source boundary
    const unsigned n_seg = src_bound_segment_node_pt.size();
    // Loop over the segments in the source boundary
    for (unsigned iseg = 0; iseg < n_seg; iseg++)
    {
      // Get the number of nodes in the current segment
      const unsigned nnode = src_bound_segment_node_pt[iseg].size();
      // Get the left and right node of the current segment
      Node* left_node_pt = src_bound_segment_node_pt[iseg][0];
      Node* right_node_pt = src_bound_segment_node_pt[iseg][nnode - 1];

      // Get the number of segments in the destination boundary
      const unsigned n_dst_seg = dst_bound_segment_node_pt.size();
      // Loop over the segments in the destination boundary
      for (unsigned jseg = 0; jseg < n_dst_seg; jseg++)
      {
        // Get the number of nodes on the current destination segment
        const unsigned n_dst_node = dst_bound_segment_node_pt[jseg].size();
        // Loop over the nodes until the node has been found or we have
        // visited all the nodes
        for (unsigned jnode = 0; jnode < n_dst_node; jnode++)
        {
          // Get a pointer to the jnode in the destination segment
          // boundary
          Node* tmp_node_pt = dst_bound_segment_node_pt[jseg][jnode];
          // Is the node the same as the left or right node if
          // the source segment boundary
          if (tmp_node_pt == left_node_pt)
          {
            // We have foud the node to connect, get the vertex of the node
            Vector<double> vertex(2);
            vertex[0] = tmp_node_pt->x(0);
            vertex[1] = tmp_node_pt->x(1);

            // Establish the vertex coordinate as untouchable in the
            // destination boundary during the adaptation process. It
            // means that unrefinement can not take off the vertices
            // that receive connections in the destination boundary
            Boundary_connections_pt[dst_bnd_id].insert(vertex);
            // Boundary_chunk_connections_pt[dst_bnd_id][dst_bnd_chunk].
            // insert(vertex);

            // return
            return;

          } // if (tmp_node_pt == left_node_pt)
          else if (tmp_node_pt == right_node_pt)
          {
            // We have foud the node to connect, get the vertex of the node
            Vector<double> vertex(2);
            vertex[0] = tmp_node_pt->x(0);
            vertex[1] = tmp_node_pt->x(1);

            // Establish the vertex coordinate as untouchable in the
            // destination boundary during the adaptation process. It
            // means that unrefinement can not take off the vertices
            // that receive connections in the destination boundary
            // Boundary_chunk_connections_pt[dst_bnd_id][dst_bnd_chunk].
            // insert(vertex);
            Boundary_connections_pt[dst_bnd_id].insert(vertex);

            // return
            return;

          } // else if (tmp_node_pt == right_node_pt)

        } // for (jnode < n_dst_node)

      } // for (jseg < n_dst_seg)

    } // for (iseg < n_seg)
  }

#ifdef OOMPH_HAS_MPI
  //=========================================================================
  /// Synchronise the vertices that are marked for non deletion
  //  on the shared boundaries. Unrefinement of shared boundaries is
  //  performed only if the candidate node is not marked for non deletion
  //=========================================================================
  template<class ELEMENT>
  const void RefineableTriangleMesh<
    ELEMENT>::synchronize_shared_boundary_connections()
  {
    // Get the number of processors
    const unsigned nproc = this->communicator_pt()->nproc();
    // Get my rank
    const unsigned my_rank = this->communicator_pt()->my_rank();

    // loop over the processors
    for (unsigned jproc = 0; jproc < nproc; jproc++)
    {
      // The number of boundaries shared with the current processor
      // (if jproc==my_rank then there are no shared boundaries
      // between them)
      const unsigned n_shd_bnd_jproc = this->nshared_boundaries(my_rank, jproc);

      // Are there shared boundaries with the jproc processor?
      // There are no info. with myself
      if (jproc != my_rank && n_shd_bnd_jproc > 0)
      {
        // Storage for the boundaries ids with vertices for non
        // deletion
        Vector<unsigned> shd_bnd_id_for_non_deletion;

        // Storage for chunk numbers of boundaries with vertices
        // for non deletion
        Vector<unsigned> chunk_for_non_deletion;

        // The number of vertices for nondeletion in the shared
        // boundaries
        Vector<unsigned> number_vertices_non_deletion;

        // Vertices marked for nondeletion in shared boundaries
        Vector<Vector<Vector<double>>> vertices_for_non_deletion;

        // Get the boundary ids of the shared boundaries with jproc
        // processor
        Vector<unsigned> shd_bnd_ids =
          this->shared_boundaries_ids(my_rank, jproc);

        // Get the number of shared boundaries with jproc
        const unsigned n_shd_bnd_jproc = shd_bnd_ids.size();
        // loop over the shared boundaries with jproc
        for (unsigned ishd_bnd = 0; ishd_bnd < n_shd_bnd_jproc; ishd_bnd++)
        {
          // Get the shared boudary id
          const unsigned shd_bnd_id = shd_bnd_ids[ishd_bnd];
          // Get the associated polyline
          TriangleMeshPolyLine* shd_polyline_pt =
            this->boundary_polyline_pt(shd_bnd_id);
          // Get the chunk number
          const unsigned chunk = shd_polyline_pt->boundary_chunk();

          // Store the vertices not allowed for deletion
          std::set<Vector<double>> no_delete_vertex;

          // Does the boundary has vertives for nondeleteion?
          const bool boundary_receive_connections =
            this->boundary_connections(shd_bnd_id, chunk, no_delete_vertex);

          // Get the number of vertices for nondeletion
          const unsigned n_non_delete_vertex = no_delete_vertex.size();

          // Are there vertices for nondeletion?
          if (boundary_receive_connections && n_non_delete_vertex > 0)
          {
            // Add the shared boundary id
            shd_bnd_id_for_non_deletion.push_back(shd_bnd_id);
            // Add the chunk number
            chunk_for_non_deletion.push_back(chunk);
            // Add the number of vertices for non deletion
            number_vertices_non_deletion.push_back(n_non_delete_vertex);

            // The list of vertices to add
            Vector<Vector<double>> tmp_vertices;

            // Add the vertices for non deletion
            for (std::set<Vector<double>>::iterator it =
                   no_delete_vertex.begin();
                 it != no_delete_vertex.end();
                 it++)
            {
              // Get the vertex coordinate
              Vector<double> vertex = (*it);
              tmp_vertices.push_back(vertex);
            }

            // Add the vertices coordinates to a vector storage
            vertices_for_non_deletion.push_back(tmp_vertices);

          } // if (boundary_receive_connections && n_non_delete_vertex > 0)

        } // for (ishd_bnd<n_shd_bnd_jproc)

        // ----------------------------------------------------------
        // ----------------------------------------------------------
        // ----------------------------------------------------------
        // Now send the info. to the other processor (jproc)
        // ----------------------------------------------------------
        // ----------------------------------------------------------
        // ----------------------------------------------------------
        // Get the communicator of the mesh
        OomphCommunicator* comm_pt = this->communicator_pt();

        // Set MPI info
        MPI_Status status;
        MPI_Request request;

        // -----------------------------------------------------------
        // Prepare the data
        // Get the number of shared boundaires with vertices marked
        // for non deletion
        const unsigned n_shd_bnd_with_non_delete_vertices =
          shd_bnd_id_for_non_deletion.size();

        // Size of the package
        const unsigned size_package = 3;
        // Ndata to send
        const unsigned n_unsigned_data_to_send =
          n_shd_bnd_with_non_delete_vertices * size_package;
        // The flat package to send the info.
        Vector<unsigned> flat_package_unsigned_send(n_unsigned_data_to_send);
        Vector<double> flat_package_double_send;

        Vector<unsigned> flat_package_unsigned_recv;
        Vector<double> flat_package_double_recv;

        // Prepare the data to be sent
        unsigned j = 0;
        for (unsigned i = 0; i < n_shd_bnd_with_non_delete_vertices; i++)
        {
          // The  shared boundary id
          flat_package_unsigned_send[j++] = shd_bnd_id_for_non_deletion[i];
          // The chunk number
          flat_package_unsigned_send[j++] = chunk_for_non_deletion[i];
          // The number of vertices for nondeletion
          flat_package_unsigned_send[j++] = number_vertices_non_deletion[i];
          // Also package the vertices
          const unsigned n_vertices_non_deletion =
            number_vertices_non_deletion[i];
          // Loop over the vertices and store them in the flat
          // package to be sent
          for (unsigned h = 0; h < n_vertices_non_deletion; h++)
          {
            flat_package_double_send.push_back(
              vertices_for_non_deletion[i][h][0]);
            flat_package_double_send.push_back(
              vertices_for_non_deletion[i][h][1]);
          } // for (h<n_vertices_non_deletion)

        } // for (i<n_shd_bnd_with_non_delete_vertices)

        // ----------------------------------------------------------
        int send_proc = jproc;
        int recv_proc = jproc;
        unsigned send_count_unsigned_values = n_unsigned_data_to_send;
        unsigned send_count_double_values = flat_package_double_send.size();
        //-----------------------------------------------------------
        // Do the transfering of info.
        //-----------------------------------------------------------
        // Start with UNSIGNED info.
        MPI_Isend(&send_count_unsigned_values,
                  1,
                  MPI_UNSIGNED,
                  send_proc,
                  1,
                  comm_pt->mpi_comm(),
                  &request);

        unsigned receive_count_unsigned_values = 0;
        MPI_Recv(&receive_count_unsigned_values,
                 1,
                 MPI_UNSIGNED,
                 recv_proc,
                 1,
                 comm_pt->mpi_comm(),
                 &status);

        MPI_Wait(&request, MPI_STATUS_IGNORE);

        // Send the actual data
        if (send_count_unsigned_values != 0)
        {
          MPI_Isend(&flat_package_unsigned_send[0],
                    send_count_unsigned_values,
                    MPI_UNSIGNED,
                    send_proc,
                    2,
                    comm_pt->mpi_comm(),
                    &request);
        }

        // Receive the actual data
        if (receive_count_unsigned_values != 0)
        {
          flat_package_unsigned_recv.resize(receive_count_unsigned_values);
          MPI_Recv(&flat_package_unsigned_recv[0],
                   receive_count_unsigned_values,
                   MPI_UNSIGNED,
                   recv_proc,
                   2,
                   comm_pt->mpi_comm(),
                   &status);
        }

        // Wait for sending the data and the other processor
        // receives
        if (send_count_unsigned_values != 0)
        {
          MPI_Wait(&request, MPI_STATUS_IGNORE);
        }

        //-----------------------------------------------------------
        // Then continue with DOUBLE info.
        MPI_Isend(&send_count_double_values,
                  1,
                  MPI_UNSIGNED,
                  send_proc,
                  1,
                  comm_pt->mpi_comm(),
                  &request);

        unsigned receive_count_double_values = 0;
        MPI_Recv(&receive_count_double_values,
                 1,
                 MPI_UNSIGNED,
                 recv_proc,
                 1,
                 comm_pt->mpi_comm(),
                 &status);

        MPI_Wait(&request, MPI_STATUS_IGNORE);

        // Send the actual data
        if (send_count_double_values != 0)
        {
          MPI_Isend(&flat_package_double_send[0],
                    send_count_double_values,
                    MPI_DOUBLE,
                    send_proc,
                    2,
                    comm_pt->mpi_comm(),
                    &request);
        }

        // Receive the actual data
        if (receive_count_double_values != 0)
        {
          flat_package_double_recv.resize(receive_count_double_values);
          MPI_Recv(&flat_package_double_recv[0],
                   receive_count_double_values,
                   MPI_DOUBLE,
                   recv_proc,
                   2,
                   comm_pt->mpi_comm(),
                   &status);
        }

        // Wait for sending the data and the other processor
        // receives
        if (send_count_double_values != 0)
        {
          MPI_Wait(&request, MPI_STATUS_IGNORE);
        }

        // ------------------------------------------------------------
        // ------------------------------------------------------------
        // ------------------------------------------------------------
        // Now unpackage the data
        // ------------------------------------------------------------
        // ------------------------------------------------------------
        // ------------------------------------------------------------

        // Storage for the boundaries ids with vertices for non
        // deletion
        Vector<unsigned> recv_shd_bnd_id_for_non_deletion;

        // Storage for chunk numbers of boundaries with vertices
        // for non deletion
        Vector<unsigned> recv_chunk_for_non_deletion;

        // The number of vertices for nondeletion in the shared
        // boundaries
        Vector<unsigned> recv_number_vertices_non_deletion;

        // Vertices marked for nondeletion in shared boundaries
        Vector<Vector<Vector<double>>> recv_vertices_for_non_deletion;

        // Counter
        j = 0;
        for (unsigned i = 0; i < receive_count_unsigned_values; i += 3)
        {
          // Get the shared boundary id
          const unsigned recv_shd_bnd_id = flat_package_unsigned_recv[i];
          recv_shd_bnd_id_for_non_deletion.push_back(recv_shd_bnd_id);
          // Get the chunk number
          const unsigned recv_chunk = flat_package_unsigned_recv[i + 1];
          recv_chunk_for_non_deletion.push_back(recv_chunk);
          // Get the number of vertices for non deletion
          const unsigned recv_num_vertices = flat_package_unsigned_recv[i + 2];
          recv_number_vertices_non_deletion.push_back(recv_num_vertices);

          // Create a temporal storage
          Vector<Vector<double>> temp_recv_vertices;
          // Now get the vertices
          for (unsigned h = 0; h < recv_num_vertices; h++)
          {
            Vector<double> tmp_vertex(2);
            tmp_vertex[0] = flat_package_double_recv[j++];
            tmp_vertex[1] = flat_package_double_recv[j++];
            // Add the vertex to the vector of vertices
            temp_recv_vertices.push_back(tmp_vertex);
          } // for (h<recv_num_vertices)

          // Add the vertices to the vector of vertices
          recv_vertices_for_non_deletion.push_back(temp_recv_vertices);

        } // for(i<receive_count_unsigned_values)

        // ---------------------------------------------------------
        // ---------------------------------------------------------
        // ---------------------------------------------------------
        // Now add the vertices to the data structures to mark them
        // as non delete-able
        // ---------------------------------------------------------
        // ---------------------------------------------------------
        // ---------------------------------------------------------

        // Get the number of shd boundaries that have vertices
        // marked for non deletion
        const unsigned n_recv_shd_bnd_id_for_non_deletion =
          recv_shd_bnd_id_for_non_deletion.size();
        // loop over the shared boundaries and add the data for non
        // deletion
        for (unsigned i = 0; i < n_recv_shd_bnd_id_for_non_deletion; i++)
        {
          // Get the shared boundary id.
          const unsigned shd_bnd_id = recv_shd_bnd_id_for_non_deletion[i];
          // Get the chunk number
          unsigned chunk = recv_chunk_for_non_deletion[i];
          // Increase and decrease the chunk number to avoid the
          // warning when compiling without PARANOID
          chunk++;
          chunk--;

          // Get the number of vertices marked for non deletion
          const unsigned n_vertices = recv_number_vertices_non_deletion[i];
          // Add all the vertices
          for (unsigned h = 0; h < n_vertices; h++)
          {
            // Get the vertex
            Vector<double> vertex(2);
            vertex[0] = recv_vertices_for_non_deletion[i][h][0];
            vertex[1] = recv_vertices_for_non_deletion[i][h][1];
            // Add the vertex to the data structure for non
            // deletion
            // Boundary_chunk_connections_pt[shd_bnd_id][chunk].
            //  insert(vertex);
            Boundary_connections_pt[shd_bnd_id].insert(vertex);

          } // for (h<n_vertices)

        } // for (i<n_recv_shd_bnd_id_for_non_deletion)

      } // if (jproc != my_rank && n_shd_bnd_jproc > 0)

    } // for (jproc < nproc)
  }
#endif // #ifdef OOMPH_HAS_MPI

  //=========================================================================
  /// After unrefinement and refinement has taken place compute
  /// the new vertices numbers of the temporary representation of the
  //  boundaries to connect.
  //=========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::create_temporary_boundary_connections(
    Vector<TriangleMeshPolygon*>& tmp_outer_polygons_pt,
    Vector<TriangleMeshOpenCurve*>& tmp_open_curves_pt)
  {
    // Dummy storages
    Vector<TriangleMeshPolyLine*> dummy_resume_initial_connection_polyline_pt;
    Vector<TriangleMeshPolyLine*> dummy_resume_final_connection_polyline_pt;

    // Clear the storage
    dummy_resume_initial_connection_polyline_pt.clear();
    dummy_resume_final_connection_polyline_pt.clear();

    // Get the initial shared boundary id (to check whether the
    // polylines represent original or shared boundaries)
    const unsigned init_shd_bnd_id = this->initial_shared_boundary_id();

    // ------------------------------------------------------------------
    // This seems unnecesary since the outer polygons does not create
    // connections with other boundaries (the original ones)
    // ------------------------------------------------------------------
    // Unnecessary?
    // ------------------------------------------------------------------

    // Loop over the temporary outer polygons create the connection
    // information of those boundaries marked to be connected at their
    // ends

    // ------------------------------------------------------------------
    // Temporary outer polygons
    // ------------------------------------------------------------------

    // Get the number of outer boundaries (closed boundaries)
    const unsigned n_outer_boundaries = tmp_outer_polygons_pt.size();

    // Loop over the outer boundaries
    for (unsigned i = 0; i < n_outer_boundaries; i++)
    {
      // Get a temporary polygon representation
      TriangleMeshPolygon* tmp_polygon_pt = tmp_outer_polygons_pt[i];
      // Get the number of polylines associated to the current outer
      // boundary
      const unsigned n_polyline = tmp_polygon_pt->npolyline();
      // Loop over the polylines
      for (unsigned p = 0; p < n_polyline; p++)
      {
        // Get a temporary representation of the polyline
        TriangleMeshPolyLine* tmp_polyline_pt = tmp_polygon_pt->polyline_pt(p);

        // Get the boundary id
        const unsigned bnd_id = tmp_polyline_pt->boundary_id();

        // Is the boundary to connect a shared boundary
        if (bnd_id < init_shd_bnd_id)
        {
          // Restore the connections of the current polyline
          restore_polyline_connections_helper(
            tmp_polyline_pt,
            dummy_resume_initial_connection_polyline_pt,
            dummy_resume_final_connection_polyline_pt);

        } // if (bnd_id < init_shd_bnd_id)

      } // for (p < n_polyline)

    } // for (i < n_outer_boundaries)

    // ------------------------------------------------------------------
    // Unnecessary?
    // ------------------------------------------------------------------

    // ------------------------------------------------------------------
    // Temporary open boundaries (nonclosed internal boundaries)
    // ------------------------------------------------------------------

    // Get the number of internal boundaries (open boundaries)
    const unsigned n_open_boundaries = tmp_open_curves_pt.size();

    // Loop over the internal open boundaries
    for (unsigned i = 0; i < n_open_boundaries; i++)
    {
      // Get a temporary representation for the open curve
      TriangleMeshOpenCurve* tmp_open_curve_pt = tmp_open_curves_pt[i];

      // Get the number of curve sections associated to the current
      // internal open boundary
      const unsigned n_curve_section = tmp_open_curve_pt->ncurve_section();

      // Loop over the curve section
      for (unsigned p = 0; p < n_curve_section; p++)
      {
        // Get a temporary representation of the curve section
        // (polyline)
        TriangleMeshPolyLine* tmp_polyline_pt =
          tmp_open_curve_pt->polyline_pt(p);

        // Get the boundary id
        const unsigned bnd_id = tmp_polyline_pt->boundary_id();

        // Is the boundary to connect a shared boundary
        if (bnd_id < init_shd_bnd_id)
        {
          // Restore the connections of the current polyline
          restore_polyline_connections_helper(
            tmp_polyline_pt,
            dummy_resume_initial_connection_polyline_pt,
            dummy_resume_final_connection_polyline_pt);

        } // if (bnd_id < init_shd_bnd_id)

      } // for (p < n_curve_section)

    } // for (i < n_open_boundaries)
  }

  //=========================================================================
  /// After unrefinement and refinement has taken place compute
  /// the new vertices numbers of the boundaries to connect (in a
  /// distributed scheme it may be possible that the destination
  /// boundary does no longer exist, therefore the connection is
  /// suspended. It is not permanently deleted because if load balance
  /// takes place it may be possible that the boundary to connect be
  /// part of the new domain representation, so the connection would
  /// exist)
  //=========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::restore_boundary_connections(
    Vector<TriangleMeshPolyLine*>& resume_initial_connection_polyline_pt,
    Vector<TriangleMeshPolyLine*>& resume_final_connection_polyline_pt)
  {
    // Clear the storage
    resume_initial_connection_polyline_pt.clear();
    resume_final_connection_polyline_pt.clear();

    // Loop over the boundaries in the domain (outer, internal -- closed
    // and open) and restore the connection information of those
    // boundaries marked to be connected at their ends

    // ------------------------------------------------------------------
    // Outer boundaries
    // ------------------------------------------------------------------

    // Get the number of outer boundaries (closed boundaries)
    const unsigned n_outer_boundaries = this->Outer_boundary_pt.size();

    // Loop over the outer boundaries
    for (unsigned i = 0; i < n_outer_boundaries; i++)
    {
      // Get a temporary polygon representation
      TriangleMeshPolygon* tmp_polygon_pt = this->Outer_boundary_pt[i];
      // Get the number of polylines associated to the current outer
      // boundary
      const unsigned n_polyline = tmp_polygon_pt->npolyline();
      // Loop over the polylines
      for (unsigned p = 0; p < n_polyline; p++)
      {
        // Get a temporary representation of the polyline
        TriangleMeshPolyLine* tmp_polyline_pt = tmp_polygon_pt->polyline_pt(p);

        // Restore the connections of the current polyline
        restore_polyline_connections_helper(
          tmp_polyline_pt,
          resume_initial_connection_polyline_pt,
          resume_final_connection_polyline_pt);

      } // for (p < n_polyline)

    } // for (i < n_outer_boundaries)

    // ------------------------------------------------------------------
    // Internal boundaries
    // ------------------------------------------------------------------

    // Get the number of internal boundaries (closed boundaries)
    const unsigned n_internal_boundaries = this->Internal_polygon_pt.size();

    // Loop over the internal boundaries
    for (unsigned i = 0; i < n_internal_boundaries; i++)
    {
      // Get a temporary polygon representation
      TriangleMeshPolygon* tmp_polygon_pt = this->Internal_polygon_pt[i];
      // Get the number of polylines associated to the current internal
      // boundary
      const unsigned n_polyline = tmp_polygon_pt->npolyline();
      // Loop over the polylines
      for (unsigned p = 0; p < n_polyline; p++)
      {
        // Get a temporary representation of the polyline
        TriangleMeshPolyLine* tmp_polyline_pt = tmp_polygon_pt->polyline_pt(p);

        // Restore the connections of the current polyline
        restore_polyline_connections_helper(
          tmp_polyline_pt,
          resume_initial_connection_polyline_pt,
          resume_final_connection_polyline_pt);

      } // for (p < n_polyline)

    } // for (i < n_internal_boundaries)

    // ------------------------------------------------------------------
    // Open boundaries (nonclosed internal boundaries)
    // ------------------------------------------------------------------

    // Get the number of internal boundaries (open boundaries)
    const unsigned n_open_boundaries = this->Internal_open_curve_pt.size();

    // Loop over the internal open boundaries
    for (unsigned i = 0; i < n_open_boundaries; i++)
    {
      // Get a temporary representation for the open curve
      TriangleMeshOpenCurve* tmp_open_curve_pt =
        this->Internal_open_curve_pt[i];

      // Get the number of curve sections associated to the current
      // internal open boundary
      const unsigned n_curve_section = tmp_open_curve_pt->ncurve_section();

      // Loop over the curve section
      for (unsigned p = 0; p < n_curve_section; p++)
      {
        // Get a temporary representation of the curve section
        // (polyline)
        TriangleMeshPolyLine* tmp_polyline_pt =
          tmp_open_curve_pt->polyline_pt(p);

        // Restore the connections of the current polyline
        restore_polyline_connections_helper(
          tmp_polyline_pt,
          resume_initial_connection_polyline_pt,
          resume_final_connection_polyline_pt);

      } // for (p < n_curve_section)

    } // for (i < n_open_boundaries)
  }

  //=========================================================================
  /// Restore the connections of the specific polyline
  /// The vertices numbering on the destination boundaries may have
  /// change because of (un)refinement in the destination boundaries.
  /// Also deals with connection that do not longer exist because the
  /// destination boundary does no longer exist because of the distribution
  /// process
  //=========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::restore_polyline_connections_helper(
    TriangleMeshPolyLine* polyline_pt,
    Vector<TriangleMeshPolyLine*>& resume_initial_connection_polyline_pt,
    Vector<TriangleMeshPolyLine*>& resume_final_connection_polyline_pt)
  {
    // If the polyline is connected at any of its ends compute the new
    // vertex number on the destination boundary

    // ------------------------------------------------------------------
    // Is the initial vertex connected?
    if (polyline_pt->is_initial_vertex_connected())
    {
      // The pointer to the boundary to connect
      TriangleMeshPolyLine* poly_to_connect_pt = 0;

      // Get the boundary id of the destination/connected boundary
      const unsigned dst_bnd_id_initial =
        polyline_pt->initial_vertex_connected_bnd_id();

      // Get the initial vertex on the current boundary
      Vector<double> src_vertex_coordinates_initial =
        polyline_pt->vertex_coordinate(0);

#ifdef PARANOID
      // Is the mesh distributed?
#ifdef OOMPH_HAS_MPI
      if (this->is_mesh_distributed())
      {
        // Get the initial shared boundary id
        const unsigned init_shd_bnd_id = this->initial_shared_boundary_id();
        // Is the boundary to connect a shared boundary
        if (dst_bnd_id_initial >= init_shd_bnd_id)
        {
          // Get the current polyline original boundary id
          const unsigned bnd_id = polyline_pt->boundary_id();
          std::ostringstream error_message;
          error_message
            << "INITIAL VERTEX CONNECTION\n"
            << "The current original boundary is trying to connect to a\n"
            << "shared boundary, this is not allowed. In this case the\n"
            << "shared boundary should be the one that connects with the\n"
            << "original boundary\n"
            << "The current original boundary (" << bnd_id << ") is marked\n"
            << "to have a connection at the\nINITIAL vertex ("
            << src_vertex_coordinates_initial[0] << ","
            << src_vertex_coordinates_initial[1] << ")\n"
            << "with the shared boundary (" << dst_bnd_id_initial << ")\n"
            << "This is the list of vertices on the shared destination "
               "boundary\n";
          // Get the pointer to the associated polyline by using the
          // boundary id
          TriangleMeshPolyLine* dst_polyline =
            this->boundary_polyline_pt(dst_bnd_id_initial);
          // The number of vertices on the destination boundary
          const unsigned n_vertex_dst_boundary = dst_polyline->nvertex();
          // Loop over the vertices print them
          for (unsigned i = 0; i < n_vertex_dst_boundary; i++)
          {
            Vector<double> current_vertex = dst_polyline->vertex_coordinate(i);
            error_message << "Vertex#(i): (" << current_vertex[0] << ", "
                          << current_vertex[1] << ")\n";
          }
          throw OomphLibError(
            error_message.str(),
            "RefineableTriangleMesh::restore_polyline_connections_helper()",
            OOMPH_EXCEPTION_LOCATION);
        } // if (dst_bnd_id_initial >= init_shd_bnd_id)

      } // if (this->is_mesh_distributed())
#endif // #ifdef OOMPH_HAS_MPI

#endif // #ifdef PARANOID

      // Flag to indicate if the vertex was found on the destination
      // boundary
      bool found_vertex_on_dst_boundary_initial = false;

      // Flag that stores the chunk number to connect (only used in
      // distributed meshes)
      unsigned sub_poly_to_connect = 0;

      // Store the vertex number on the destination boundary
      unsigned n_vertex_connection_initial = 0;

      // Flags only used in a distributed mesh
      // ----------------------------------------
      // Flag to indicate we are trying to connect to an split boundary
      bool connecting_to_an_split_boundary = false;

      // Flag to indicate we are trying to connecto to an internal
      // boundary that is overlaped by a shared boundary)
      bool connecting_to_an_overlaped_boundary = false;

#ifdef OOMPH_HAS_MPI
      if (this->is_mesh_distributed())
      {
        // We can only connect to an original boundary, check if the
        // boundary was splitted during the distribution process to
        // consider all the chunks (sub-polylines) of the boundary
        if (this->boundary_was_splitted(dst_bnd_id_initial))
        {
          connecting_to_an_split_boundary = true;
        } // if (this->boundary_was_splitted(dst_bnd_id_initial))

        // Check if the destination boundary, or any of its chunks is
        // marked to be overlapped by a shared boundary, if that is the
        // case we can only connect to the chunks that are not
        // overlapped by shared boundaries (the shared boundaries are in
        // charge of generating the connections with original boundaries
        // and with themselves)
        if (connecting_to_an_split_boundary)
        {
          // Get the number of chucks that represent the destination
          // boundary
          const unsigned n_sub_poly =
            this->nboundary_subpolylines(dst_bnd_id_initial);
          // Now loop over the chunks of the destination boundary and if
          // any of them is marked to be overlaped by a shared boundary
          // then set the flag and break the loop
          for (unsigned ii = 0; ii < n_sub_poly; ii++)
          {
            if (this->boundary_marked_as_shared_boundary(dst_bnd_id_initial,
                                                         ii))
            {
              // Mark the boundary as being overlaped by a shared
              // boundary
              connecting_to_an_overlaped_boundary = true;
              // Break, no need to look for more overlapings
              break;
            } // if (boundary_marked_as_shared_boundary(...))
          } // for (ii < n_sub_poly)
        } // if (connecting_to_an_split_boundary)
        else
        {
          // If not connecting to an split boundary then check if the
          // whole destination boundary is overlaped by an internal
          // boundary
          if (this->boundary_marked_as_shared_boundary(dst_bnd_id_initial, 0))
          {
            // Mark the boundary as being overlaped by a shared boundary
            connecting_to_an_overlaped_boundary = true;
          } // if (boundary_marked_as_shared_boundary(...))
        } // else if (connecting_to_an_split_boundary)

      } // if (this->is_mesh_distributed())

#endif // #ifdef OOMPH_HAS_MPI

      // If we are connecting neither to an split boundary nor an
      // overlaped boundary then get the pointer to the original
      // boundary
      if (!(connecting_to_an_split_boundary ||
            connecting_to_an_overlaped_boundary))
      {
        // Get the polyline pointer representing the destination
        // boundary
        poly_to_connect_pt = this->boundary_polyline_pt(dst_bnd_id_initial);
      } // else if (NOT split, NOT overlaped)

      // Now look for the vertex number on the destination boundary(ies)
      // -- in case that the boundary was split ---

      // Do not check for same orientation, that was previously worked
      // by interchanging the connections boundaries (if necessary)

      // If the boundary was not split then ...
      if (!connecting_to_an_split_boundary)
      {
        // ... check if the boundary is marked to be overlaped by
        // a shared boundary
        if (!connecting_to_an_overlaped_boundary)
        {
          // If that is not the case then we can safely look for the
          // vertex number on the destination boundary
          found_vertex_on_dst_boundary_initial =
            this->get_connected_vertex_number_on_destination_polyline(
              poly_to_connect_pt,
              src_vertex_coordinates_initial,
              n_vertex_connection_initial);

        } // if (!connecting_to_an_overlaped_boundary)
        else
        {
          // If the whole boundary is marked to be overlaped by a shared
          // boundary then do nothing, the shared boundaries are already
          // in charge of performing the connection (it will be required
          // to disabled the connection) with the original boundary

        } // else if (!connecting_to_an_overlaped_boundary)

      } // if (!connecting_to_an_split_boundary)
#ifdef OOMPH_HAS_MPI
      else
      {
        // If the boundary was split then we need to look for the vertex
        // in the sub-polylines

        // Get the sub-polylines vector
        Vector<TriangleMeshPolyLine*> tmp_vector_subpolylines =
          this->boundary_subpolylines(dst_bnd_id_initial);

        // Get the number of sub-polylines
        const unsigned nsub_poly = tmp_vector_subpolylines.size();
#ifdef PARANOID
        if (nsub_poly <= 1)
        {
          std::ostringstream error_message;
          error_message << "The boundary (" << dst_bnd_id_initial << ") was "
                        << "marked to be splitted but\n"
                        << "there are only (" << nsub_poly << ") polylines to "
                        << "represent it.\n";
          throw OomphLibError(
            error_message.str(),
            "RefineableTriangleMesh::restore_polyline_connections_helper()",
            OOMPH_EXCEPTION_LOCATION);
        } // if (nsub_poly <= 1)
#endif
        // We need to check if the boundary is marked to be overlaped by
        // a shared boundary, if that is the case we need to check for
        // each indivual subpolyline, and for those overlaped by a
        // shared polyline do nothing, the shared polylines have already
        // deal with these connections

        // ... check if the boundary is marked to be overlaped by
        // a shared boundary
        if (!connecting_to_an_overlaped_boundary)
        {
          // The boundary is not overlapped by shared boundaries, we can
          // work without checking the subpolylines individually (non of
          // them are overlapped by a shared boundary)

          // Look for the vertex number to connect on each of the
          // subpolyines
          for (unsigned isub = 0; isub < nsub_poly; isub++)
          {
            // Assign the pointer to the sub-polyline
            poly_to_connect_pt = tmp_vector_subpolylines[isub];
            // Search for the vertex in the current sub-polyline
            found_vertex_on_dst_boundary_initial =
              this->get_connected_vertex_number_on_destination_polyline(
                poly_to_connect_pt,
                src_vertex_coordinates_initial,
                n_vertex_connection_initial);

            // If we have found the vertex to connect then break the
            // loop
            if (found_vertex_on_dst_boundary_initial)
            {
              // But first save the subpoly number (chunk), that will be
              // used to perform the connection
              sub_poly_to_connect = isub;
              break;
            } // if (found_vertex_on_dst_boundary_initial)

          } // for (isub < nsub_poly)

        } // if (!connecting_to_an_overlaped_boundary)
        else
        {
          // If connecting to an overlapped boundary then we ignore the
          // subpolylines overlapped by shared boundaries and only look
          // on the sub-polylines that are not marked as being overlaped
          // by shared boundaries

          // Look for the vertex number to connect on each of the
          // subpolyines
          for (unsigned isub = 0; isub < nsub_poly; isub++)
          {
            // Only work with those sub-polylines that are not overlaped
            // by shared boundaries
            if (!this->boundary_marked_as_shared_boundary(dst_bnd_id_initial,
                                                          isub))
            {
              // Assign the pointer to the sub-polyline
              poly_to_connect_pt = tmp_vector_subpolylines[isub];

              // Search for the vertex in the current sub-polyline
              found_vertex_on_dst_boundary_initial =
                this->get_connected_vertex_number_on_destination_polyline(
                  poly_to_connect_pt,
                  src_vertex_coordinates_initial,
                  n_vertex_connection_initial);

              // Was the vertex found?
              if (found_vertex_on_dst_boundary_initial)
              {
                // But first save the subpoly number (chunk), that will
                // be used to perform the connection
                sub_poly_to_connect = isub;
                break;
              } // if (found_vertex_on_dst_boundary_initial)

            } // if (not overlaped by shared boundary)

          } // for (isub < nsub_poly)

        } // else if (!connecting_to_an_overlaped_boundary)

      } // else if (!connecting_to_an_split_boundary)
#endif // #ifdef OOMPH_HAS_MPI

      // If not found it may be that the connection information is
      // inverted
      if (!found_vertex_on_dst_boundary_initial)
      {
        // Is the mesh distributed?
#ifdef OOMPH_HAS_MPI
        if (this->is_mesh_distributed())
        {
          // If the mesh is distributed and the vertex number was not
          // found, that means that the boundary (or vertex) to connect
          // in the destination boundary is not in the current
          // processor. In that case suspend the connection
          polyline_pt->suspend_initial_vertex_connected();
          // Add the polyline to the vector of polylines whose
          // connection will be resumed at the end of the adaptation
          // process
          resume_initial_connection_polyline_pt.push_back(polyline_pt);
          // The shared boundaries are marked to connect to the initial
          // vertex of the polyline (remember that a shared boundary
          // stops adding nodes when it finds a node on an original
          // boundary) -- The initial vertex is now a base node
        }
        else
#endif // #ifdef OOMPH_HAS_MPI
        {
#ifdef PARANOID
          // If not found then there is a problem with the vertices
          // Get the associated boundary id of the current polyline
          const unsigned bnd_id = polyline_pt->boundary_id();
          std::ostringstream error_message;
          error_message
            << "INITIAL VERTEX CONNECTION\n"
            << "It was not possible to find the associated "
            << "vertex number on the destination boundary\n"
            << "The current boundary (" << bnd_id << ") is marked to have"
            << "a connection at the\nINITIAL vertex ("
            << src_vertex_coordinates_initial[0] << ","
            << src_vertex_coordinates_initial[1] << ")\n"
            << "with boundary (" << dst_bnd_id_initial << ")\n"
            << "This is the list of vertices on the destination boundary\n";
          // Get the pointer to the associated polyline by using the
          // boundary id
          TriangleMeshPolyLine* dst_polyline =
            this->boundary_polyline_pt(dst_bnd_id_initial);
          // The number of vertices on the destination boundary
          const unsigned n_vertex_dst_boundary = dst_polyline->nvertex();
          // Loop over the vertices print them
          for (unsigned i = 0; i < n_vertex_dst_boundary; i++)
          {
            Vector<double> current_vertex = dst_polyline->vertex_coordinate(i);
            error_message << "Vertex#(i): (" << current_vertex[0] << ", "
                          << current_vertex[1] << ")\n";
          }
          throw OomphLibError(
            error_message.str(),
            "RefineableTriangleMesh::restore_polyline_connections_helper()",
            OOMPH_EXCEPTION_LOCATION);
#endif

        } // else if (this->is_mesh_distributed())

      } // if (!found_vertex_on_dst_boundary_initial)
      else
      {
        // Set the vertex number on the destination boundary
        polyline_pt->initial_vertex_connected_n_vertex() =
          n_vertex_connection_initial;

        // Set the chunk number on the destination boundary
        polyline_pt->initial_vertex_connected_n_chunk() = sub_poly_to_connect;

      } // else if (!found_vertex_on_dst_boundary_initial)

    } // if (polyline_pt->is_initial_vertex_connected())

    // ------------------------------------------------------------------
    // Is the final vertex connected?
    if (polyline_pt->is_final_vertex_connected())
    {
      // The pointer to the boundary to connect
      TriangleMeshPolyLine* poly_to_connect_pt = 0;

      // Get the boundary id of the destination/connected boundary
      const unsigned dst_bnd_id_final =
        polyline_pt->final_vertex_connected_bnd_id();

      // Get the final vertex on the current boundary
      const unsigned tmp_n_vertices = polyline_pt->nvertex();
      Vector<double> src_vertex_coordinates_final =
        polyline_pt->vertex_coordinate(tmp_n_vertices - 1);


#ifdef PARANOID
      // Is the mesh distributed?
#ifdef OOMPH_HAS_MPI
      if (this->is_mesh_distributed())
      {
        // Get the initial shared boundary id
        const unsigned init_shd_bnd_id = this->initial_shared_boundary_id();
        // Is the boundary to connect a shared boundary
        if (dst_bnd_id_final >= init_shd_bnd_id)
        {
          // Get the current polyline original boundary id
          const unsigned bnd_id = polyline_pt->boundary_id();
          std::ostringstream error_message;
          error_message
            << "FINAL VERTEX CONNECTION\n"
            << "The current original boundary is trying to connect to a\n"
            << "shared boundary, this is not allowed. In this case the\n"
            << "shared boundary should be the one that connects with the\n"
            << "original boundary\n"
            << "The current boundary (" << bnd_id << ") is marked to have "
            << "a connection at the\nFINAL vertex ("
            << src_vertex_coordinates_final[0] << ","
            << src_vertex_coordinates_final[1] << ")\n"
            << "with boundary (" << dst_bnd_id_final << ")\n"
            << "This is the list of vertices on the destination boundary\n";
          // Get the pointer to the associated polyline by using the
          // boundary id
          TriangleMeshPolyLine* dst_polyline =
            this->boundary_polyline_pt(dst_bnd_id_final);
          // The number of vertices on the destination boundary
          const unsigned n_vertex_dst_boundary = dst_polyline->nvertex();
          // Loop over the vertices print them
          for (unsigned i = 0; i < n_vertex_dst_boundary; i++)
          {
            Vector<double> current_vertex = dst_polyline->vertex_coordinate(i);
            error_message << "Vertex#(" << i << "): (" << current_vertex[0]
                          << ", " << current_vertex[1] << ")\n";
          }
          throw OomphLibError(
            error_message.str(),
            "RefineableTriangleMesh::restore_polyline_connections_helper()",
            OOMPH_EXCEPTION_LOCATION);
        } // if (dst_bnd_id_initial >= init_shd_bnd_id)

      } // if (this->is_mesh_distributed())
#endif // #ifdef OOMPH_HAS_MPI

#endif // #ifdef PARANOID

      // Flag to indicate if the vertex was found on the destination
      // boundary
      bool found_vertex_on_dst_boundary_final = false;

      // Flag that stores the chunk number to connect (only used in
      // distributed meshes)
      unsigned sub_poly_to_connect = 0;

      // Store the vertex number on the destination boundary
      unsigned n_vertex_connection_final = 0;

      // Flags only used in a distributed mesh
      // ----------------------------------------
      // Flag to indicate we are trying to connect to an split boundary
      bool connecting_to_an_split_boundary = false;

      // Flag to indicate we are trying to connecto to an internal
      // boundary that is overlaped by a shared boundary)
      bool connecting_to_an_overlaped_boundary = false;

#ifdef OOMPH_HAS_MPI
      if (this->is_mesh_distributed())
      {
        // We can only connect to an original boundary, check if the
        // boundary was splitted during the distribution process to
        // consider all the chunks (sub-polylines) of the boundary
        if (this->boundary_was_splitted(dst_bnd_id_final))
        {
          connecting_to_an_split_boundary = true;
        } // if (this->boundary_was_splitted(dst_bnd_id_final))

        // Check if the destination boundary, or any of its chunks is
        // marked to be overlapped by a shared boundary, if that is the
        // case we can only connect to the chunks that are not
        // overlapped by shared boundaries (the shared boundaries are in
        // charge of generating the connections with original boundaries
        // and with themselves)
        if (connecting_to_an_split_boundary)
        {
          // Get the number of chucks that represent the destination
          // boundary
          const unsigned n_sub_poly =
            this->nboundary_subpolylines(dst_bnd_id_final);
          // Now loop over the chunks of the destination boundary and if
          // any of them is marked to be overlaped by a shared boundary
          // then set the flag and break the loop
          for (unsigned ii = 0; ii < n_sub_poly; ii++)
          {
            if (this->boundary_marked_as_shared_boundary(dst_bnd_id_final, ii))
            {
              // Mark the boundary as being overlaped by a shared
              // boundary
              connecting_to_an_overlaped_boundary = true;
              // Break, no need to look for more overlapings
              break;
            } // if (boundary_marked_as_shared_boundary(...))
          } // for (ii < n_sub_poly)
        } // if (connecting_to_an_split_boundary)
        else
        {
          // If not connecting to an split boundary then check if the
          // whole destination boundary is overlaped by an internal
          // boundary
          if (this->boundary_marked_as_shared_boundary(dst_bnd_id_final, 0))
          {
            // Mark the boundary as being overlaped by a shared boundary
            connecting_to_an_overlaped_boundary = true;
          } // if (boundary_marked_as_shared_boundary(...))
        } // else if (connecting_to_an_split_boundary)

      } // if (this->is_mesh_distributed())

#endif // #ifdef OOMPH_HAS_MPI

      // If we are connecting neither to an split boundary nor an
      // overlaped boundary then get the pointer to the original
      // boundary
      if (!(connecting_to_an_split_boundary ||
            connecting_to_an_overlaped_boundary))
      {
        // Get the polyline pointer representing the destination
        // boundary
        poly_to_connect_pt = this->boundary_polyline_pt(dst_bnd_id_final);
      } // else if (NOT split, NOT overlaped)

      // Now look for the vertex number on the destination boundary(ies)
      // -- in case that the boundary was split ---

      // Do not check for same orientation, that was previously worked
      // by interchanging the connections boundaries (if necessary)

      // If the boundary was not split then ...
      if (!connecting_to_an_split_boundary)
      {
        // ... check if the boundary is marked to be overlaped by
        // a shared boundary
        if (!connecting_to_an_overlaped_boundary)
        {
          // If that is not the case then we can safely look for the
          // vertex number on the destination boundary
          found_vertex_on_dst_boundary_final =
            this->get_connected_vertex_number_on_destination_polyline(
              poly_to_connect_pt,
              src_vertex_coordinates_final,
              n_vertex_connection_final);

        } // if (!connecting_to_an_overlaped_boundary)
        else
        {
          // If the whole boundary is marked to be overlaped by a shared
          // boundary then do nothing, the shared boundaries are already
          // in charge of performing the connection (it will be required
          // to disabled the connection) with the original boundary

        } // else if (!connecting_to_an_overlaped_boundary)

      } // if (!connecting_to_an_split_boundary)
#ifdef OOMPH_HAS_MPI
      else
      {
        // If the boundary was split then we need to look for the vertex
        // in the sub-polylines

        // Get the sub-polylines vector
        Vector<TriangleMeshPolyLine*> tmp_vector_subpolylines =
          this->boundary_subpolylines(dst_bnd_id_final);

        // Get the number of sub-polylines
        const unsigned nsub_poly = tmp_vector_subpolylines.size();
#ifdef PARANOID
        if (nsub_poly <= 1)
        {
          std::ostringstream error_message;
          error_message << "The boundary (" << dst_bnd_id_final << ") was "
                        << "marked to be splitted but\n"
                        << "there are only (" << nsub_poly << ") polylines to "
                        << "represent it.\n";
          throw OomphLibError(
            error_message.str(),
            "RefineableTriangleMesh::restore_polyline_connections_helper()",
            OOMPH_EXCEPTION_LOCATION);
        } // if (nsub_poly <= 1)
#endif
        // We need to check if the boundary is marked to be overlaped by
        // a shared boundary, if that is the case we need to check for
        // each indivual subpolyline, and for those overlaped by a
        // shared polyline do nothing, the shared polylines have already
        // deal with these connections

        // ... check if the boundary is marked to be overlaped by
        // a shared boundary
        if (!connecting_to_an_overlaped_boundary)
        {
          // The boundary is not overlapped by shared boundaries, we can
          // work without checking the subpolylines individually (non of
          // them are overlapped by a shared boundary)

          // Look for the vertex number to connect on each of the
          // subpolyines
          for (unsigned isub = 0; isub < nsub_poly; isub++)
          {
            // Assign the pointer to the sub-polyline
            poly_to_connect_pt = tmp_vector_subpolylines[isub];
            // Search for the vertex in the current sub-polyline
            found_vertex_on_dst_boundary_final =
              this->get_connected_vertex_number_on_destination_polyline(
                poly_to_connect_pt,
                src_vertex_coordinates_final,
                n_vertex_connection_final);

            // If we have found the vertex to connect then break the
            // loop
            if (found_vertex_on_dst_boundary_final)
            {
              // But first save the subpoly number (chunk), that will be
              // used to perform the connection
              sub_poly_to_connect = isub;
              break;
            } // if (found_vertex_on_dst_boundary_initial)

          } // for (isub < nsub_poly)

        } // if (!connecting_to_an_overlaped_boundary)
        else
        {
          // If connecting to an overlapped boundary then we ignore the
          // subpolylines overlapped by shared boundaries and only look
          // on the sub-polylines that are not marked as being overlaped
          // by shared boundaries

          // Look for the vertex number to connect on each of the
          // subpolyines
          for (unsigned isub = 0; isub < nsub_poly; isub++)
          {
            // Only work with those sub-polylines that are not overlaped
            // by shared boundaries
            if (!this->boundary_marked_as_shared_boundary(dst_bnd_id_final,
                                                          isub))
            {
              // Assign the pointer to the sub-polyline
              poly_to_connect_pt = tmp_vector_subpolylines[isub];

              // Search for the vertex in the current sub-polyline
              found_vertex_on_dst_boundary_final =
                this->get_connected_vertex_number_on_destination_polyline(
                  poly_to_connect_pt,
                  src_vertex_coordinates_final,
                  n_vertex_connection_final);

              // Was the vertex found?
              if (found_vertex_on_dst_boundary_final)
              {
                // But first save the subpoly number (chunk), that will
                // be used to perform the connection
                sub_poly_to_connect = isub;
                break;
              } // if (found_vertex_on_dst_boundary_final)

            } // if (not overlaped by shared boundary)

          } // for (isub < nsub_poly)

        } // else if (!connecting_to_an_overlaped_boundary)

      } // else if (!connecting_to_an_split_boundary)
#endif // #ifdef OOMPH_HAS_MPI

      // If not found it may be that the connection information is
      // inverted
      if (!found_vertex_on_dst_boundary_final)
      {
        // Is the mesh distributed?
#ifdef OOMPH_HAS_MPI
        if (this->is_mesh_distributed())
        {
          // If the mesh is distributed and the vertex number was not
          // found, that means that the boundary (or vertex) to connect
          // in the destination boundary is not in the current
          // processor. In that suspend the connection
          polyline_pt->suspend_final_vertex_connected();
          // Add the polyline to the vector of polylines whose
          // connection will be resumed at the end of the adaptation
          // process
          resume_final_connection_polyline_pt.push_back(polyline_pt);
          // The shared boundaries are marked to connect to the final
          // vertex of the polyline (remember that a shared boundary
          // stops adding nodes when it finds a node on an original
          // boundary) -- The final vertex is now a base node
        } // if (this->is_mesh_distributed())
        else
#endif // #ifdef OOMPH_HAS_MPI
        {
#ifdef PARANOID
          // If not found then there is a problem with the vertices
          // Get the associated boundary id of the current polyline
          const unsigned bnd_id = polyline_pt->boundary_id();
          std::ostringstream error_message;
          error_message
            << "FINAL VERTEX CONNECTION\n"
            << "It was not possible to find the associated "
            << "vertex number on the destination boundary\n"
            << "The current boundary (" << bnd_id << ") is marked to have "
            << "a connection at the\nFINAL vertex ("
            << src_vertex_coordinates_final[0] << ","
            << src_vertex_coordinates_final[1] << ")\n"
            << "with boundary (" << dst_bnd_id_final << ")\n"
            << "This is the list of vertices on the destination boundary\n";
          // Get the pointer to the associated polyline by using the
          // boundary id
          TriangleMeshPolyLine* dst_polyline =
            this->boundary_polyline_pt(dst_bnd_id_final);
          // The number of vertices on the destination boundary
          const unsigned n_vertex_dst_boundary = dst_polyline->nvertex();
          // Loop over the vertices print them
          for (unsigned i = 0; i < n_vertex_dst_boundary; i++)
          {
            Vector<double> current_vertex = dst_polyline->vertex_coordinate(i);
            error_message << "Vertex#(" << i << "): (" << current_vertex[0]
                          << ", " << current_vertex[1] << ")\n";
          }
          throw OomphLibError(
            error_message.str(),
            "RefineableTriangleMesh::restore_polyline_connections_helper()",
            OOMPH_EXCEPTION_LOCATION);
#endif
        } // else if (this->is_mesh_distributed())

      } // if (!found_vertex_on_dst_boundary_final)
      else
      {
        // Set the vertex number on the destination boundary
        polyline_pt->final_vertex_connected_n_vertex() =
          n_vertex_connection_final;

        // Set the chunk number on the destination boundary
        polyline_pt->final_vertex_connected_n_chunk() = sub_poly_to_connect;

      } // else if (!found_vertex_on_dst_boundary_final)

    } // if (polyline_pt->is_final_vertex_connected())
  }

  //=========================================================================
  /// Resume the boundary connections that may have been
  /// suspended because the destination boundary is no part of the
  /// domain. The connections are no permanently suspended because if
  /// load balance takes place the destination boundary may be part of
  /// the new domain representation therefore the connection would
  /// exist
  //=========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::resume_boundary_connections(
    Vector<TriangleMeshPolyLine*>& resume_initial_connection_polyline_pt,
    Vector<TriangleMeshPolyLine*>& resume_final_connection_polyline_pt)
  {
    // Get the number of polylines that require to resume the connection
    // at the initial vertex
    const unsigned n_initial_poly =
      resume_initial_connection_polyline_pt.size();
    // Loop over the polylines that require to resume the connection
    // at the initial vertex
    for (unsigned p = 0; p < n_initial_poly; p++)
    {
      // Get the polyline
      TriangleMeshPolyLine* tmp_poly_pt =
        resume_initial_connection_polyline_pt[p];
      // Resume the connection with the initial vertex
      tmp_poly_pt->resume_initial_vertex_connected();
    } // for (p < n_initial_poly)

    // Get the number of polylines that require to resume the connection
    // at the final vertex
    const unsigned n_final_poly = resume_final_connection_polyline_pt.size();
    // Loop over the polylines that require to resume the connection at
    // the final vertex
    for (unsigned p = 0; p < n_final_poly; p++)
    {
      // Get the polyline
      TriangleMeshPolyLine* tmp_poly_pt =
        resume_final_connection_polyline_pt[p];
      // Resume the connection with the final vertex
      tmp_poly_pt->resume_final_vertex_connected();
    } // for (p < n_final_poly)

    // Clear the storage
    resume_initial_connection_polyline_pt.clear();
    resume_final_connection_polyline_pt.clear();
  }

  //=========================================================================
  /// Gets the associated vertex number according to the vertex
  /// coordinates on the destination boundary
  //=========================================================================
  template<class ELEMENT>
  bool RefineableTriangleMesh<ELEMENT>::
    get_connected_vertex_number_on_dst_boundary(
      Vector<double>& vertex_coordinates,
      const unsigned& dst_bnd_id,
      unsigned& vertex_number)
  {
    bool found_associated_vertex_number = false;

    // Get the pointer to the associated polyline by using the boundary id
    TriangleMeshPolyLine* dst_polyline = this->boundary_polyline_pt(dst_bnd_id);

    const unsigned n_vertices = dst_polyline->nvertex();

    // Loop over the vertices and return the closest vertex
    // to the given vertex coordinates
    for (unsigned i = 0; i < n_vertices; i++)
    {
      Vector<double> current_vertex = dst_polyline->vertex_coordinate(i);

      double error = (vertex_coordinates[0] - current_vertex[0]) *
                       (vertex_coordinates[0] - current_vertex[0]) +
                     (vertex_coordinates[1] - current_vertex[1]) *
                       (vertex_coordinates[1] - current_vertex[1]);

      error = sqrt(error);

      if (error < ToleranceForVertexMismatchInPolygons::Tolerable_error)
      {
        vertex_number = i;
        found_associated_vertex_number = true;
        break;
      }
    }

    return found_associated_vertex_number;
  }

  //=========================================================================
  /// Helper function that updates the input polygon's PSLG
  /// by using the end-points of elements from FaceMesh(es) that are
  /// constructed for the boundaries associated with the segments of the
  /// polygon. Optional boolean is used to run it as test only (if
  /// true is specified as input) in which case polygon isn't actually
  /// modified. Returned boolean indicates if polygon was (or would have
  /// been -- if called with check_only=false) changed.
  //=========================================================================
  template<class ELEMENT>
  bool RefineableTriangleMesh<ELEMENT>::update_polygon_using_face_mesh(
    TriangleMeshPolygon* polygon_pt, const bool& check_only)
  {
#ifdef PARANOID
    // If the mesh is marked as distributed this method can not be
    // called since there is no guarantee of creating (distributed)
    // meshes that match in the number and position of nodes at their
    // shared boundaries. The only exececption is when called with
    // check_only=true, since no boundary updating is performed
    if (this->is_mesh_distributed() && !check_only)
    {
      std::stringstream error_message;
      error_message
        << "The updating of polygons of a distributed mesh can ONLY be\n"
        << "performed using the element's area associated to the halo(ed)\n"
        << "elements.\n"
        << "1) Make sure you have enabled the parallel mesh adaptation\n"
        << "option if you are working with a distributed mesh, OR\n"
        << "2) Make sure to call the update_..._using_elements_area() methods\n"
        << "if the mesh is marked as distributed\n\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    } // if (this->is_mesh_distributed())
#endif

    // Boolean that indicates whether an actual update of the polygon
    // was performed or not
    bool unrefinement_was_performed = false;
    bool refinement_was_performed = false;
    bool max_length_applied = false;

    // Loop over the number of polylines
    const unsigned n_polyline = polygon_pt->npolyline();

    // Get face mesh representation of all polylines, possibly
    // with segments re-distributed to maintain an approximately
    // even sub-division of the polygon
    Vector<Mesh*> face_mesh_pt;
    get_face_mesh_representation(polygon_pt, face_mesh_pt);

    // Create vertices for the polylines by using the vertices
    // of the FaceElements
    Vector<double> vertex_coord(3); // zeta,x,y
    Vector<double> bound_left(1);
    Vector<double> bound_right(1);

    for (unsigned p = 0; p < n_polyline; p++)
    {
      // Set of coordinates that will be placed on the boundary
      // Set entries are ordered on first  entry in vector which stores
      // the boundary coordinate so the vertices come out in order!
      std::set<Vector<double>> vertex_nodes;

      // Get the boundary id
      const unsigned bound = polygon_pt->curve_section_pt(p)->boundary_id();

      // Get the chunk number
      const unsigned chunk = polygon_pt->curve_section_pt(p)->boundary_chunk();

      // Loop over the face elements (ordered) and add their vertices
      unsigned n_face_element = face_mesh_pt[p]->nelement();
      for (unsigned e = 0; e < n_face_element; ++e)
      {
        FiniteElement* el_pt = face_mesh_pt[p]->finite_element_pt(e);

#ifdef OOMPH_HAS_MPI
        // Only work with non-halo elements if the mesh is distributed
        if (this->is_mesh_distributed() && el_pt->is_halo())
        {
          continue;
        }
#endif

        unsigned n_node = el_pt->nnode();

        // Add the left-hand node to the set:

        // Boundary coordinate
        el_pt->node_pt(0)->get_coordinates_on_boundary(bound, bound_left);
        vertex_coord[0] = bound_left[0];

        // Actual coordinates
        for (unsigned i = 0; i < 2; i++)
        {
          vertex_coord[i + 1] = el_pt->node_pt(0)->x(i);
        }
        vertex_nodes.insert(vertex_coord);

        // Add the right-hand nodes to the set:

        // Boundary coordinate
        el_pt->node_pt(n_node - 1)
          ->get_coordinates_on_boundary(bound, bound_right);
        vertex_coord[0] = bound_right[0];

        // Actual coordinates
        for (unsigned i = 0; i < 2; i++)
        {
          vertex_coord[i + 1] = el_pt->node_pt(n_node - 1)->x(i);
        }
        vertex_nodes.insert(vertex_coord);
      }

      // Now turn into vector for ease of handling...
      unsigned n_poly_vertex = vertex_nodes.size();
      Vector<Vector<double>> tmp_vector_vertex_node(n_poly_vertex);
      unsigned count = 0;
      for (std::set<Vector<double>>::iterator it = vertex_nodes.begin();
           it != vertex_nodes.end();
           ++it)
      {
        tmp_vector_vertex_node[count].resize(3);
        tmp_vector_vertex_node[count][0] = (*it)[0];
        tmp_vector_vertex_node[count][1] = (*it)[1];
        tmp_vector_vertex_node[count][2] = (*it)[2];
        ++count;
      }

      // Size of the vector
      unsigned n_vertex = tmp_vector_vertex_node.size();

      // Tolerance below which the middle point can be deleted
      // (ratio of deflection to element length)
      double unrefinement_tolerance =
        polygon_pt->polyline_pt(p)->unrefinement_tolerance();

      //------------------------------------------------------
      // Unrefinement
      //------------------------------------------------------
      if (unrefinement_tolerance > 0.0 && n_vertex >= 3)
      {
        unrefinement_was_performed = unrefine_boundary(bound,
                                                       chunk,
                                                       tmp_vector_vertex_node,
                                                       unrefinement_tolerance,
                                                       check_only);

        // In this case the "unrefinement_was_performed" variable
        // tell us if the update had been performed when calling
        // with check_oly=false
        if (check_only && unrefinement_was_performed)
        {
          // Cleanup (but only the elements -- the nodes still exist in
          // the bulk mesh!
          for (unsigned p = 0; p < n_polyline; p++)
          {
            face_mesh_pt[p]->flush_node_storage();
            delete face_mesh_pt[p];
          }
          return true;
        }

      } // end of unrefinement

      // Do not perform refinement if there are no more than two vertices
      // New size of the vector
      n_vertex = tmp_vector_vertex_node.size();

      //------------------------------------------------
      // Refinement
      //------------------------------------------------
      double refinement_tolerance =
        polygon_pt->polyline_pt(p)->refinement_tolerance();
      if (refinement_tolerance > 0.0 && n_vertex >= 2)
      {
        refinement_was_performed = refine_boundary(face_mesh_pt[p],
                                                   tmp_vector_vertex_node,
                                                   refinement_tolerance,
                                                   check_only);

        // In this case the "refinement_was_performed" variable
        // tell us if the update had been performed when calling
        // with check_only=false
        if (check_only && refinement_was_performed)
        {
          // Cleanup (but only the elements -- the nodes still exist in
          // the bulk mesh!
          for (unsigned p = 0; p < n_polyline; p++)
          {
            face_mesh_pt[p]->flush_node_storage();
            delete face_mesh_pt[p];
          }
          return true;
        }

      } // end refinement

      // Do not perform maximum length constraint if there are no more than
      // two vertices
      // New size of the vector
      n_vertex = tmp_vector_vertex_node.size();

      //------------------------------------------------
      // Maximum length constrait
      //-----------------------------------------------
      double maximum_length = polygon_pt->polyline_pt(p)->maximum_length();
      if (maximum_length > 0.0 && n_vertex >= 2)
      {
        max_length_applied = apply_max_length_constraint(
          face_mesh_pt[p], tmp_vector_vertex_node, maximum_length);

        // In this case the max length criteria was applied, check if
        // check_only=false
        if (check_only && max_length_applied)
        {
          // Cleanup (but only the elements -- the nodes still exist in
          // the bulk mesh!
          for (unsigned p = 0; p < n_polyline; p++)
          {
            face_mesh_pt[p]->flush_node_storage();
            delete face_mesh_pt[p];
          }
          return true;
        }
      }

      // For further processing the three-dimensional vector
      // has to be reduced to a two-dimensional vector
      n_vertex = tmp_vector_vertex_node.size();
      Vector<Vector<double>> vector_vertex_node(n_vertex);

      for (unsigned i = 0; i < n_vertex; i++)
      {
        vector_vertex_node[i].resize(2);
        vector_vertex_node[i][0] = tmp_vector_vertex_node[i][1];
        vector_vertex_node[i][1] = tmp_vector_vertex_node[i][2];
      }

#ifdef OOMPH_HAS_MPI
      // Only perform this checking if the mesh is not distributed. When
      // the mesh is distributed the polylines continuity is addressed in
      // the sort_polylines_helper() method
      if (!this->is_mesh_distributed())
#endif
      {
        if ((p > 0) && !check_only)
        {
          // Final end point of previous line
          Vector<double> final_vertex_of_previous_segment;
          unsigned n_prev_vertex =
            polygon_pt->curve_section_pt(p - 1)->nvertex();
          final_vertex_of_previous_segment =
            polygon_pt->polyline_pt(p - 1)->vertex_coordinate(n_prev_vertex -
                                                              1);

          unsigned prev_seg_boundary_id =
            polygon_pt->curve_section_pt(p - 1)->boundary_id();

          // Find the error between the final vertex of the previous
          // line and the first vertex of the current line
          double error = 0.0;
          for (unsigned i = 0; i < 2; i++)
          {
            const double dist = final_vertex_of_previous_segment[i] -
                                (*vector_vertex_node.begin())[i];
            error += dist * dist;
          }
          error = sqrt(error);

          // If the error is bigger than the tolerance then
          // we probably need to reverse, but better check
          if (error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
          {
            // Find the error between the final vertex of the previous
            // line and the last vertex of the current line
            double rev_error = 0.0;
            for (unsigned i = 0; i < 2; i++)
            {
              const double dist = final_vertex_of_previous_segment[i] -
                                  (*--vector_vertex_node.end())[i];
              rev_error += dist * dist;
            }
            rev_error = sqrt(rev_error);

            if (rev_error >
                ToleranceForVertexMismatchInPolygons::Tolerable_error)
            {
              // It could be possible that the first segment be reversed and we
              // did not notice it because this check does not apply for the
              // first segment. We can verify if the first segment is reversed
              // by using the vertex number 1
              if (p == 1)
              {
                // Initial end point of previous line
                Vector<double> initial_vertex_of_previous_segment;

                initial_vertex_of_previous_segment =
                  polygon_pt->polyline_pt(p - 1)->vertex_coordinate(0);

                unsigned prev_seg_boundary_id =
                  polygon_pt->curve_section_pt(p - 1)->boundary_id();

                // Find the error between the initial vertex of the previous
                // line and the first vertex of the current line
                double error = 0.0;
                for (unsigned i = 0; i < 2; i++)
                {
                  const double dist = initial_vertex_of_previous_segment[i] -
                                      (*vector_vertex_node.begin())[i];
                  error += dist * dist;
                }
                error = sqrt(error); // Reversed only the previous one

                // If the error is bigger than the tolerance then
                // we probably need to reverse, but better check
                if (error >
                    ToleranceForVertexMismatchInPolygons::Tolerable_error)
                {
                  // Find the error between the final vertex of the previous
                  // line and the last vertex of the current line
                  double rev_error = 0.0;
                  for (unsigned i = 0; i < 2; i++)
                  {
                    const double dist = initial_vertex_of_previous_segment[i] -
                                        (*--vector_vertex_node.end())[i];
                    rev_error += dist * dist;
                  }
                  rev_error =
                    sqrt(rev_error); // Reversed both the current one and
                  // the previous one

                  if (rev_error >
                      ToleranceForVertexMismatchInPolygons::Tolerable_error)
                  {
                    std::ostringstream error_stream;
                    error_stream
                      << "The distance between the first node of the current\n"
                      << "line segment (boundary " << bound
                      << ") and either end of "
                      << "the previous line segment\n"
                      << "(boundary " << prev_seg_boundary_id
                      << ") is bigger than "
                      << "the desired tolerance "
                      << ToleranceForVertexMismatchInPolygons::Tolerable_error
                      << ".\n"
                      << "This suggests that the polylines defining the "
                         "polygonal\n"
                      << "representation are not properly ordered.\n"
                      << "Fail on last vertex of polyline: ("
                      << prev_seg_boundary_id
                      << ") and\nfirst vertex of polyline (" << bound
                      << ").\nThis should have failed when first trying to "
                      << "construct the\npolygon.\n";
                    throw OomphLibError(error_stream.str(),
                                        OOMPH_CURRENT_FUNCTION,
                                        OOMPH_EXCEPTION_LOCATION);
                  }
                  else
                  {
                    // Reverse both
                    // Reverse the current vector to line up with the previous
                    // one
                    std::reverse(vector_vertex_node.begin(),
                                 vector_vertex_node.end());

                    polygon_pt->polyline_pt(p - 1)->reverse();
                  }
                }
                else
                {
                  // Reverse the previous one
                  polygon_pt->polyline_pt(p - 1)->reverse();
                }

              } // if p == 1
              else
              {
                std::ostringstream error_stream;
                error_stream
                  << "The distance between the first node of the current\n"
                  << "line segment (boundary " << bound
                  << ") and either end of "
                  << "the previous line segment\n"
                  << "(boundary " << prev_seg_boundary_id
                  << ") is bigger than the "
                  << "desired tolerance "
                  << ToleranceForVertexMismatchInPolygons::Tolerable_error
                  << ".\n"
                  << "This suggests that the polylines defining the polygonal\n"
                  << "representation are not properly ordered.\n"
                  << "Fail on last vertex of polyline: ("
                  << prev_seg_boundary_id << ") and\nfirst vertex of polyline ("
                  << bound << ").\n"
                  << "This should have failed when first trying to construct "
                     "the\n"
                  << "polygon.\n";
                throw OomphLibError(error_stream.str(),
                                    OOMPH_CURRENT_FUNCTION,
                                    OOMPH_EXCEPTION_LOCATION);
              }
            }
            else
            {
              // Reverse the current vector to line up with the previous one
              std::reverse(vector_vertex_node.begin(),
                           vector_vertex_node.end());
            }

          } // first error
        } // p > 0
      } // is mesh not distributed?

      if (!check_only)
      {
        // Now update the polyline according to the new vertices
        // The new one representation
        TriangleMeshPolyLine* tmp_polyline_pt =
          new TriangleMeshPolyLine(vector_vertex_node, bound);

        // Create a temporal "curve section" version of the recently created
        // polyline
        TriangleMeshCurveSection* tmp_curve_section_pt = tmp_polyline_pt;

        // Establish refinement and unrefinement tolerance
        tmp_polyline_pt->set_unrefinement_tolerance(unrefinement_tolerance);
        tmp_polyline_pt->set_refinement_tolerance(refinement_tolerance);

        // Establish the maximum length constraint
        tmp_polyline_pt->set_maximum_length(maximum_length);

        // We pass the connection information from the old polyline to
        // the new one
        this->copy_connection_information(polygon_pt->polyline_pt(p),
                                          tmp_curve_section_pt);

        // Now update the polyline according to the new vertices but
        // first check if the object is allowed to delete the representation
        // or if it should be done by other object
        bool delete_it_on_destructor = false;

        std::set<TriangleMeshCurveSection*>::iterator it =
          this->Free_curve_section_pt.find(polygon_pt->curve_section_pt(p));

        if (it != this->Free_curve_section_pt.end())
        {
          this->Free_curve_section_pt.erase(it);
          delete polygon_pt->curve_section_pt(p);
          delete_it_on_destructor = true;
        }

        // ------------------------------------------------------------
        // Copying the new representation
        polygon_pt->curve_section_pt(p) = tmp_polyline_pt;

        // Update the Boundary - Polyline map
        this->Boundary_curve_section_pt[bound] =
          polygon_pt->curve_section_pt(p);

        // The new curve always needs to be added to the free section
        // because we created it internally
        this->Free_curve_section_pt.insert(polygon_pt->curve_section_pt(p));

      } // if(!check_only)

    } // for (p < n_polyline)

    // Cleanup (but only the elements -- the nodes still exist in
    // the bulk mesh!
    for (unsigned p = 0; p < n_polyline; p++)
    {
      face_mesh_pt[p]->flush_node_storage();
      delete face_mesh_pt[p];
    }

    if (check_only)
    {
      // if we end up all the way down here, no update of the internal
      // boundaries is necessary (in case we only check)
      return false;
    }
    else
    {
      // if we not only check, but actually perform the update and end up
      // all the way down here then we indicate whether an update was performed
      // or not
      return (unrefinement_was_performed || refinement_was_performed ||
              max_length_applied);
    }
  }

  //=========================================================================
  /// Helper function that updates the input open curve by using
  /// end-points of elements from FaceMesh(es) that are constructed for the
  /// boundaries associated with the polylines. Optional boolean is used to
  /// run it as test only (if true is specified as input) in which case the
  /// polylines are not actually modified. Returned boolean indicates if
  /// polylines were (or would have been -- if called with check_only=false)
  /// changed.
  //=========================================================================
  template<class ELEMENT>
  bool RefineableTriangleMesh<ELEMENT>::update_open_curve_using_face_mesh(
    TriangleMeshOpenCurve* open_polyline_pt, const bool& check_only)
  {
#ifdef PARANOID
    // If the mesh is marked as distributed this method can not be
    // called since there is no guarantee of creating (distributed)
    // meshes that match in the number and position of nodes at their
    // shared boundaries. The only exececption is when called with
    // check_only=true, since no boundary updating is performed
    if (this->is_mesh_distributed() && !check_only)
    {
      std::stringstream error_message;
      error_message
        << "The updating of open curves of a distributed mesh can ONLY be\n"
        << "performed using the element's area associated to the halo(ed)\n"
        << "elements.\n"
        << "1) Make sure you have enabled the parallel mesh adaptation\n"
        << "option if you are working with a distributed mesh, OR\n"
        << "2) Make sure to call the update_..._using_elements_area() methods\n"
        << "if the mesh is marked as distributed\n\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    } // if (this->is_mesh_distributed())
#endif

    // Boolean that indicates whether an actual update of the polylines
    // were performed or not
    bool unrefinement_was_performed = false;
    bool refinement_was_performed = false;
    bool max_length_applied = false;

    // Loop over the number of polylines
    const unsigned n_polyline = open_polyline_pt->ncurve_section();

    // Get face mesh representation of all polylines, possibly
    // with segments re-distributed to maintain an approximately
    // even sub-division of the polygon
    Vector<Mesh*> face_mesh_pt;
    get_face_mesh_representation(open_polyline_pt, face_mesh_pt);

    // Create vertices for the polylines by using the vertices
    // of the FaceElements
    Vector<double> vertex_coord(3); // zeta,x,y
    Vector<double> bound_left(1);
    Vector<double> bound_right(1);

    for (unsigned p = 0; p < n_polyline; p++)
    {
      // Set of coordinates that will be placed on the boundary
      // Set entries are ordered on first  entry in vector which stores
      // the boundary coordinate so the vertices come out in order!
      std::set<Vector<double>> vertex_nodes;

      // Get the boundary id
      const unsigned bound =
        open_polyline_pt->curve_section_pt(p)->boundary_id();

      // Get the chunk number
      const unsigned chunk =
        open_polyline_pt->curve_section_pt(p)->boundary_chunk();

      // Loop over the face elements (ordered) and add their vertices
      unsigned n_face_element = face_mesh_pt[p]->nelement();

      // n_count = 0;
      for (unsigned e = 0; e < n_face_element; ++e)
      {
        FiniteElement* el_pt = face_mesh_pt[p]->finite_element_pt(e);
        unsigned n_node = el_pt->nnode();

        // Add the left-hand node to the set:

        // Boundary coordinate
        el_pt->node_pt(0)->get_coordinates_on_boundary(bound, bound_left);
        vertex_coord[0] = bound_left[0];

        // Actual coordinates
        for (unsigned i = 0; i < 2; i++)
        {
          vertex_coord[i + 1] = el_pt->node_pt(0)->x(i);
        }
        vertex_nodes.insert(vertex_coord);

        // Add the right-hand nodes to the set:

        // Boundary coordinate
        el_pt->node_pt(n_node - 1)
          ->get_coordinates_on_boundary(bound, bound_right);
        vertex_coord[0] = bound_right[0];

        // Actual coordinates
        for (unsigned i = 0; i < 2; i++)
        {
          vertex_coord[i + 1] = el_pt->node_pt(n_node - 1)->x(i);
        }
        vertex_nodes.insert(vertex_coord);
      }

      // Now turn into vector for ease of handling...
      unsigned n_poly_vertex = vertex_nodes.size();
      Vector<Vector<double>> tmp_vector_vertex_node(n_poly_vertex);
      unsigned count = 0;
      for (std::set<Vector<double>>::iterator it = vertex_nodes.begin();
           it != vertex_nodes.end();
           ++it)
      {
        tmp_vector_vertex_node[count].resize(3);
        tmp_vector_vertex_node[count][0] = (*it)[0];
        tmp_vector_vertex_node[count][1] = (*it)[1];
        tmp_vector_vertex_node[count][2] = (*it)[2];
        ++count;
      }

      // Size of the vector
      unsigned n_vertex = tmp_vector_vertex_node.size();

      // Tolerance below which the middle point can be deleted
      // (ratio of deflection to element length)
      double unrefinement_tolerance =
        open_polyline_pt->polyline_pt(p)->unrefinement_tolerance();

      //------------------------------------------------------
      // Unrefinement
      //------------------------------------------------------
      if (unrefinement_tolerance > 0.0 && n_vertex >= 3)
      {
        unrefinement_was_performed = unrefine_boundary(bound,
                                                       chunk,
                                                       tmp_vector_vertex_node,
                                                       unrefinement_tolerance,
                                                       check_only);

        // In this case the unrefinement_was_performed variable actually
        // tell us if the update had been performed when calling
        // with check_only=false
        if (check_only && unrefinement_was_performed)
        {
          // Cleanup (but only the elements -- the nodes still exist in
          // the bulk mesh!
          for (unsigned p = 0; p < n_polyline; p++)
          {
            face_mesh_pt[p]->flush_node_storage();
            delete face_mesh_pt[p];
          }
          return true;
        }

      } // end of unrefinement

      // Do not perform refinement if there are no more than two vertices
      // (open curve version)
      // New size of the vector
      n_vertex = tmp_vector_vertex_node.size();

      //------------------------------------------------
      /// Refinement
      //------------------------------------------------
      double refinement_tolerance =
        open_polyline_pt->polyline_pt(p)->refinement_tolerance();
      if (refinement_tolerance > 0.0 && n_vertex >= 2)
      {
        refinement_was_performed = refine_boundary(face_mesh_pt[p],
                                                   tmp_vector_vertex_node,
                                                   refinement_tolerance,
                                                   check_only);

        // In this case the unrefinement_was_performed variable actually
        // tell us if the update had been performed when calling
        // with check_only=false
        if (check_only && refinement_was_performed)
        {
          // Cleanup (but only the elements -- the nodes still exist in
          // the bulk mesh!
          for (unsigned p = 0; p < n_polyline; p++)
          {
            face_mesh_pt[p]->flush_node_storage();
            delete face_mesh_pt[p];
          }
          return true;
        }

      } // end refinement

      // Do not perform maximum length constraint if there are no more than
      // two vertices
      // New size of the vector
      n_vertex = tmp_vector_vertex_node.size();

      //------------------------------------------------
      // Maximum length constraint
      //-----------------------------------------------
      double maximum_length =
        open_polyline_pt->polyline_pt(p)->maximum_length();
      if (maximum_length > 0.0 && n_vertex >= 2)
      {
        bool max_length_applied = false;
        max_length_applied = apply_max_length_constraint(
          face_mesh_pt[p], tmp_vector_vertex_node, maximum_length);

        // In this case the max length criteria was applied, check if
        // check_only=false
        if (check_only && max_length_applied)
        {
          // Cleanup (but only the elements -- the nodes still exist in
          // the bulk mesh!
          for (unsigned p = 0; p < n_polyline; p++)
          {
            face_mesh_pt[p]->flush_node_storage();
            delete face_mesh_pt[p];
          }
          return true;
        }
      }

      // For further processing the three-dimensional vector
      // has to be reduced to a two-dimensional vector
      n_vertex = tmp_vector_vertex_node.size();
      Vector<Vector<double>> vector_vertex_node(n_vertex);

      for (unsigned i = 0; i < n_vertex; i++)
      {
        vector_vertex_node[i].resize(2);
        vector_vertex_node[i][0] = tmp_vector_vertex_node[i][1];
        vector_vertex_node[i][1] = tmp_vector_vertex_node[i][2];
      }

#ifdef OOMPH_HAS_MPI
      // Only perform this checking if the mesh is not distributed. When
      // the mesh is distributed the polylines continuity is addressed
      // in the sort_polylines_helper() method
      if (!this->is_mesh_distributed())
#endif
      {
        // Check whether the segments are continguous (first vertex of this
        // segment is equal to last vertex of previous segment).
        // If not, we should reverse the order of the current segment.
        // This check only applies for segments other than the first.
        // We only bother with this check, if we actually perform an update
        // of the polyline, i.e. if it's not only a check
        if ((p > 0) && !check_only)
        {
          // Final end point of previous line
          Vector<double> final_vertex_of_previous_segment;
          open_polyline_pt->polyline_pt(p - 1)->final_vertex_coordinate(
            final_vertex_of_previous_segment);

          unsigned prev_seg_boundary_id =
            open_polyline_pt->curve_section_pt(p - 1)->boundary_id();

          // Find the error between the final vertex of the previous
          // line and the first vertex of the current line
          double error = 0.0;
          for (unsigned i = 0; i < 2; i++)
          {
            const double dist = final_vertex_of_previous_segment[i] -
                                (*vector_vertex_node.begin())[i];
            error += dist * dist;
          }
          error = sqrt(error);

          // If the error is bigger than the tolerance then
          // we probably need to reverse, but better check
          if (error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
          {
            // Find the error between the final vertex of the previous
            // line and the first vertex of the current line
            error = 0.0;
            for (unsigned i = 0; i < 2; i++)
            {
              const double dist = final_vertex_of_previous_segment[i] -
                                  (*--vector_vertex_node.end())[i];
              error += dist * dist;
            }
            error = sqrt(error);

            if (error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
            {
              // It could be possible that the first segment be reversed
              // and we did not notice it because this check does not
              // apply for the first segment. We can verify if the first
              // segment is reversed by using the vertex number 1
              if (p == 1)
              {
                // If no found it is possible that the previous polyline
                // be reversed Check for that case Initial point of
                // previous line
                Vector<double> initial_vertex_of_previous_segment;
                open_polyline_pt->polyline_pt(p - 1)->initial_vertex_coordinate(
                  initial_vertex_of_previous_segment);

                // Find the error between the initial vertex of the previous
                // line and the first vertex of the current line
                error = 0.0;
                for (unsigned i = 0; i < 2; i++)
                {
                  const double dist = initial_vertex_of_previous_segment[i] -
                                      (*vector_vertex_node.begin())[i];
                  error += dist * dist;
                }
                error = sqrt(error);

                // If the error is bigger than the tolerance then
                // we probably need to reverse, but better check
                if (error >
                    ToleranceForVertexMismatchInPolygons::Tolerable_error)
                {
                  // Find the error between the final vertex of the previous
                  // line and the first vertex of the current line
                  error = 0.0;
                  for (unsigned i = 0; i < 2; i++)
                  {
                    const double dist = initial_vertex_of_previous_segment[i] -
                                        (*--vector_vertex_node.end())[i];
                    error += dist * dist;
                  }
                  error = sqrt(error);

                  if (error >
                      ToleranceForVertexMismatchInPolygons::Tolerable_error)
                  {
                    std::ostringstream error_stream;
                    error_stream
                      << "The distance between the first node of the current\n"
                      << "line segment (boundary " << bound
                      << ") and either end of the previous line segment\n"
                      << "(boundary " << prev_seg_boundary_id
                      << ") is bigger than "
                      << "the desired tolerance "
                      << ToleranceForVertexMismatchInPolygons::Tolerable_error
                      << ".\n"
                      << "This suggests that the polylines defining the open "
                      << "curve\n"
                      << "representation are not properly ordered.\n"
                      << "Fail on last vertex of polyline: ("
                      << prev_seg_boundary_id
                      << ") and\nfirst vertex of polyline (" << bound << ").\n"
                      << "This should have failed when first trying to "
                         "construct\n"
                      << "the open curve.\n";
                    throw OomphLibError(error_stream.str(),
                                        OOMPH_CURRENT_FUNCTION,
                                        OOMPH_EXCEPTION_LOCATION);
                  }
                  else // We have to reverse both
                  {
                    // First reverse the previous polyline
                    open_polyline_pt->polyline_pt(p - 1)->reverse();
                    // Then reverse the current polyline
                    std::reverse(vector_vertex_node.begin(),
                                 vector_vertex_node.end());
                  }
                }
                else
                {
                  // Reverse the previous polyline only
                  open_polyline_pt->polyline_pt(p - 1)->reverse();
                }
              } // if (p == 1)
              else
              {
                std::ostringstream error_stream;
                error_stream
                  << "The distance between the first node of the current\n"
                  << "line segment (boundary " << bound
                  << ") and either end of "
                  << "the previous line segment\n"
                  << "(boundary " << prev_seg_boundary_id
                  << ") is bigger than the "
                  << "desired tolerance "
                  << ToleranceForVertexMismatchInPolygons::Tolerable_error
                  << ".\n"
                  << "This suggests that the polylines defining the polygonal\n"
                  << "representation are not properly ordered.\n"
                  << "Fail on last vertex of polyline: ("
                  << prev_seg_boundary_id << ") and\nfirst vertex of polyline ("
                  << bound << ").\n"
                  << "This should have failed when first trying to construct "
                     "the\n"
                  << "polygon.\n";
                throw OomphLibError(error_stream.str(),
                                    OOMPH_CURRENT_FUNCTION,
                                    OOMPH_EXCEPTION_LOCATION);
              }
            }
            else
            {
              // Reverse the current vector to line up with the previous one
              std::reverse(vector_vertex_node.begin(),
                           vector_vertex_node.end());
            }
          }

        } // if p > 0

      } // is mesh not distributed?

      if (!check_only)
      {
        // Now update the polyline according to the new vertices The new
        // one representation
        TriangleMeshPolyLine* tmp_polyline =
          new TriangleMeshPolyLine(vector_vertex_node, bound);

        // Create a temporal "curve section" version of the recently
        // created polyline
        TriangleMeshCurveSection* tmp_curve_section = tmp_polyline;

        // Copy the unrefinement and refinement information
        tmp_polyline->set_unrefinement_tolerance(unrefinement_tolerance);
        tmp_polyline->set_refinement_tolerance(refinement_tolerance);

        // Establish the maximum length constraint
        tmp_polyline->set_maximum_length(maximum_length);

        // Pass the connection information from the old polyline to the
        // new one
        this->copy_connection_information(open_polyline_pt->polyline_pt(p),
                                          tmp_curve_section);

        std::set<TriangleMeshCurveSection*>::iterator it =
          this->Free_curve_section_pt.find(
            open_polyline_pt->curve_section_pt(p));

        bool delete_it_on_destructor = false;

        if (it != this->Free_curve_section_pt.end())
        {
          // Free previous representation only if you created
          this->Free_curve_section_pt.erase(it);
          delete open_polyline_pt->curve_section_pt(p);
          delete_it_on_destructor = true;
        }

        // *****************************************************************
        // Copying the new representation
        open_polyline_pt->curve_section_pt(p) = tmp_polyline;

        // Update the Boundary <--> PolyLine map
        this->Boundary_curve_section_pt[bound] =
          open_polyline_pt->curve_section_pt(p);

        if (delete_it_on_destructor)
        {
          this->Free_curve_section_pt.insert(
            open_polyline_pt->curve_section_pt(p));
        }

      } // if(!check_only)

    } // n_polylines

    // Cleanup (but only the elements -- the nodes still exist in
    // the bulk mesh!
    for (unsigned p = 0; p < n_polyline; p++)
    {
      face_mesh_pt[p]->flush_node_storage();
      delete face_mesh_pt[p];
    }

    if (check_only)
    {
      // if we end up all the way down here, no update of the internal
      // boundaries is necessary (in case we only check)
      return false;
    }
    else
    {
      // if we not only check, but actually perform the update and end
      // up all the way down here then we indicate whether an update was
      // performed or not
      return (unrefinement_was_performed || refinement_was_performed ||
              max_length_applied);
    }
  }

  //=========================================================================
  /// Helper function that performs the unrefinement process
  /// on the specified boundary by using the provided vertices
  /// representation. Optional boolean is used to run it as test only (if
  /// true is specified as input) in which case vertex coordinates aren't
  /// actually modified. Returned boolean indicates if polyline was (or
  /// would have been -- if called with check_only=false) changed.
  //=========================================================================
  template<class ELEMENT>
  bool RefineableTriangleMesh<ELEMENT>::unrefine_boundary(
    const unsigned& b,
    const unsigned& c,
    Vector<Vector<double>>& vector_bnd_vertices,
    double& unrefinement_tolerance,
    const bool& check_only)
  {
    // Store the vertices not allowed for deletion
    std::set<Vector<double>> no_delete_vertex;

    // Does the boundary receives connections?
    const bool boundary_receive_connections =
      this->boundary_connections(b, c, no_delete_vertex);

    // Boolean that indicates whether an actual update of the vertex
    // coordinates was performed or not
    bool unrefinement_was_performed = false;

    unsigned n_vertex = vector_bnd_vertices.size();

    // Initialise counter that indicates at which vertex we're currently
    // considering for deletion
    unsigned counter = 1;

    // Loop over the nodes; start with the second one and increment by two
    // this way a "pack" of three nodes will be considered for calculation:
    // the middle-node (which is to be deleted or not) and the adjacent
    // nodes
    for (unsigned i = 1; i <= n_vertex - 2; i += 2)
    {
      // Maths from http://www.cgafaq.info/wiki/Circle_Through_Three_Points
      double a_x = vector_bnd_vertices[i - 1][1];
      double a_y = vector_bnd_vertices[i - 1][2];
      double b_x = vector_bnd_vertices[i][1];
      double b_y = vector_bnd_vertices[i][2];
      double c_x = vector_bnd_vertices[i + 1][1];
      double c_y = vector_bnd_vertices[i + 1][2];

      double a = b_x - a_x;
      double b = b_y - a_y;
      double c = c_x - a_x;
      double d = c_y - a_y;

      double e = a * (a_x + b_x) + b * (a_y + b_y);
      double f = c * (a_x + c_x) + d * (a_y + c_y);

      double g = 2.0 * (a * (c_y - b_y) - b * (c_x - b_x));

      bool do_it = false;
      if (std::fabs(g) < 1.0e-14)
      {
        do_it = true;
        if (check_only)
        {
          return true;
        }
      }
      else
      {
        double p_x = (d * e - b * f) / g;
        double p_y = (a * f - c * e) / g;

        double r = sqrt(pow((a_x - p_x), 2) + pow((a_y - p_y), 2));

        double rhalfca_x = 0.5 * (a_x - c_x);
        double rhalfca_y = 0.5 * (a_y - c_y);

        double halfca_squared = pow(rhalfca_x, 2) + pow(rhalfca_y, 2);

        double sticky_out_bit = r - sqrt(std::fabs((r * r) - halfca_squared));

        // If sticky out bit divided by distance between end nodes
        // is less than tolerance the boundary is so flat that we
        // can safely kill the node
        if ((sticky_out_bit / (2.0 * sqrt(halfca_squared))) <
            unrefinement_tolerance)
        {
          do_it = true;
          if (check_only)
          {
            return true;
          }
        }
      }

      // If the vertex was proposed for deletion check that it is
      // allowed for being deleted
      if (do_it && boundary_receive_connections)
      {
        // Is the vertex one of the non deletable vertices
        for (std::set<Vector<double>>::iterator it = no_delete_vertex.begin();
             it != no_delete_vertex.end();
             it++)
        {
          // Compute the distance between the proposed node to delete
          // and the ones that should not be deleted
          const double x = (*it)[0];
          const double y = (*it)[1];
          double error = (b_x - x) * (b_x - x) + (b_y - y) * (b_y - y);
          error = sqrt(error);

          if (error < ToleranceForVertexMismatchInPolygons::Tolerable_error)
          {
            // Do not delete the vertex
            do_it = false;
            break;
          }
        }

      } // if (do_it && boundary_receive_connections)

      // Remove node?
      if (do_it)
      {
        vector_bnd_vertices[i].resize(0);
      }

      // Increase the counter, that indicates the number of the
      // next middle node
      counter += 2;
    }

    // coming out of here the value of counter is the index of the
    // last node on the polyline counter=n_vertex-1 (in case of an
    // even number of nodes) or counter has the value of the number
    // of nodes on the polyline counter=n_vertex (in case of an odd
    // number of nodes

    // Special treatment for the end of the polyline:
    // If the number of nodes is even, then the previous loop stopped
    // at the last but second node, i.e. the current value of counter
    // is the index of the last node. If that's the case, the last but
    // one node needs to be treated separately
    if ((counter) == (n_vertex - 1))
    {
      // Set the last but one node as middle node
      unsigned i = vector_bnd_vertices.size() - 2;

      // Index of the current! last but second node (considering any
      // previous deletion)
      unsigned n = 0;

      if (vector_bnd_vertices[counter - 2].size() != 0)
      {
        // if the initial last but second node does still exist then
        // this one is obviously also the current last but second one
        n = counter - 2;
      }
      else
      {
        // if the initial last but second node was deleted then the
        // initial last but third node is the current last but second
        // node
        n = counter - 3;
      }

      // CODE DUPLICATION -- CAN'T BE BOTHERED TO WRITE A SEPARATE
      // FUNCTION FOR THIS; PROBABLY WORTH DOING IF/WHEN THERE'S
      // A MISTAKE IN ANY OF THIS AND IT NEEDS TO BE FIXED...

      // Maths from http://www.cgafaq.info/wiki/Circle_Through_Three_Points
      double a_x = vector_bnd_vertices[n][1];
      double a_y = vector_bnd_vertices[n][2];
      double b_x = vector_bnd_vertices[i][1];
      double b_y = vector_bnd_vertices[i][2];
      double c_x = vector_bnd_vertices[i + 1][1];
      double c_y = vector_bnd_vertices[i + 1][2];

      double a = b_x - a_x;
      double b = b_y - a_y;
      double c = c_x - a_x;
      double d = c_y - a_y;

      double e = a * (a_x + b_x) + b * (a_y + b_y);
      double f = c * (a_x + c_x) + d * (a_y + c_y);

      double g = 2.0 * (a * (c_y - b_y) - b * (c_x - b_x));

      bool do_it = false;
      if (std::fabs(g) < 1.0e-14)
      {
        do_it = true;
        if (check_only)
        {
          return true;
        }
      }
      else
      {
        double p_x = (d * e - b * f) / g;
        double p_y = (a * f - c * e) / g;

        double r = sqrt(pow((a_x - p_x), 2) + pow((a_y - p_y), 2));

        double rhalfca_x = 0.5 * (a_x - c_x);
        double rhalfca_y = 0.5 * (a_y - c_y);

        double halfca_squared = pow(rhalfca_x, 2) + pow(rhalfca_y, 2);

        double sticky_out_bit = r - sqrt(std::fabs((r * r) - halfca_squared));

        // If sticky out bit divided by distance between end nodes
        // is less than tolerance the boundary is so flat that we
        // can safely kill the node
        if ((sticky_out_bit / (2.0 * sqrt(halfca_squared))) <
            unrefinement_tolerance)
        {
          do_it = true;
          if (check_only)
          {
            return true;
          }
        }
      }

      // If the vertex was proposed for deletion check that it is
      // allowed for being deleted
      if (do_it && boundary_receive_connections)
      {
        // Is the vertex one of the non deletable vertices
        for (std::set<Vector<double>>::iterator it = no_delete_vertex.begin();
             it != no_delete_vertex.end();
             it++)
        {
          // Compute the distance between the proposed node to delete
          // and the ones that should not be deleted
          const double x = (*it)[0];
          const double y = (*it)[1];
          double error = (b_x - x) * (b_x - x) + (b_y - y) * (b_y - y);
          error = sqrt(error);

          if (error < ToleranceForVertexMismatchInPolygons::Tolerable_error)
          {
            // Do not delete the vertex
            do_it = false;
            break;
          }
        }

      } // if (do_it && boundary_receive_connections)

      // Remove node?
      if (do_it)
      {
        vector_bnd_vertices[i].resize(0);
      }
    }

    // Create another vector, which will only contain entries of
    // nodes that still exist
    Vector<Vector<double>> compact_vector;
    compact_vector.reserve(n_vertex);
    for (unsigned i = 0; i < n_vertex; i++)
    {
      // If the entry was not deleted include it in the new vector
      if (vector_bnd_vertices[i].size() != 0)
      {
        compact_vector.push_back(vector_bnd_vertices[i]);
      }
    }

    /// Get the size of the vector that now includes all remaining nodes
    n_vertex = compact_vector.size();

    // If the size of the vector containing the remaining nodes is
    // different from the size of the vector before the unrefinement
    // routine (with the original nodes)
    // then the polyline was obviously updated
    if (n_vertex != vector_bnd_vertices.size())
    {
      unrefinement_was_performed = true;
    }

    /// Copy back
    vector_bnd_vertices.resize(n_vertex);
    for (unsigned i = 0; i < n_vertex; i++)
    {
      vector_bnd_vertices[i].resize(3);
      vector_bnd_vertices[i][0] = compact_vector[i][0];
      vector_bnd_vertices[i][1] = compact_vector[i][1];
      vector_bnd_vertices[i][2] = compact_vector[i][2];
    }

    return unrefinement_was_performed;
  }

  //=========================================================================
  /// Helper function that performs the refinement process
  /// on the specified boundary by using the provided vertices
  /// representation. Optional boolean is used to run it as test only (if
  /// true is specified as input) in which case vertex coordinates aren't
  /// actually modified. Returned boolean indicates if polyline was (or
  /// would have been -- if called with check_only=false) changed.
  //=========================================================================
  template<class ELEMENT>
  bool RefineableTriangleMesh<ELEMENT>::refine_boundary(
    Mesh* face_mesh_pt,
    Vector<Vector<double>>& vector_bnd_vertices,
    double& refinement_tolerance,
    const bool& check_only)
  {
    // Boolean that indicates whether an actual update of the vertex
    // coordinates was performed or not
    bool refinement_was_performed = false;

    // Create a geometric object from the mesh to represent
    // the curvilinear boundary
    MeshAsGeomObject* mesh_geom_obj_pt = new MeshAsGeomObject(face_mesh_pt);

    // Get the total number of current vertices
    unsigned n_vertex = vector_bnd_vertices.size();

    // Create a new (temporary) vector for the nodes, so
    // that new nodes can be stored
    Vector<Vector<double>> extended_vector;

    // Reserve memory space for twice the number of already
    // existing nodes (worst case)
    extended_vector.reserve(2 * n_vertex);

    // Loop over the nodes until the last but one node
    for (unsigned inod = 0; inod < n_vertex - 1; inod++)
    {
      // Get local coordinate of "left" node
      double zeta_left = vector_bnd_vertices[inod][0];

      // Get position vector of "left" node
      Vector<double> R_left(2);
      for (unsigned i = 0; i < 2; i++)
      {
        R_left[i] = vector_bnd_vertices[inod][i + 1];
      }

      // Get local coordinate of "right" node
      double zeta_right = vector_bnd_vertices[inod + 1][0];

      // Get position vector of "right" node
      Vector<double> R_right(2);
      for (unsigned i = 0; i < 2; i++)
      {
        R_right[i] = vector_bnd_vertices[inod + 1][i + 1];
      }

      // Get the boundary coordinate of the midpoint
      Vector<double> zeta_mid(1);
      zeta_mid[0] = 0.5 * (zeta_left + zeta_right);

      // Get the position vector of the midpoint on the
      // curvilinear boundary
      Vector<double> R_mid(2);
      mesh_geom_obj_pt->position(zeta_mid, R_mid);

      // Get the position vector of the midpoint on the straight
      // line connecting "left" and "right" node
      Vector<double> R_mid_polygon(2);
      for (unsigned i = 0; i < 2; i++)
      {
        R_mid_polygon[i] = 0.5 * (R_right[i] + R_left[i]);
      }

      // Calculate the distance between the midpoint on the curvilinear
      // boundary and the midpoint on the straight line
      double distance =
        sqrt((R_mid[0] - R_mid_polygon[0]) * (R_mid[0] - R_mid_polygon[0]) +
             (R_mid[1] - R_mid_polygon[1]) * (R_mid[1] - R_mid_polygon[1]));

      // Calculating the length of the straight line
      double length = sqrt((R_right[0] - R_left[0]) * (R_right[0] - R_left[0]) +
                           (R_right[1] - R_left[1]) * (R_right[1] - R_left[1]));

      // If the ratio of distance between the midpoints to the length
      // of the straight line is larger than the tolerance
      // specified for the criterion when points can be deleted,
      // create a new node and add it to the (temporary) vector
      if ((distance / length) > refinement_tolerance)
      {
        if (check_only)
        {
          // Delete the allocated memory for the geometric object
          // that represents the curvilinear boundary
          delete mesh_geom_obj_pt;
          return true;
        }

        Vector<double> new_node(3);
        new_node[0] = zeta_mid[0];
        new_node[1] = R_mid[0];
        new_node[2] = R_mid[1];

        // Include the "left" node in the new "temporary" vector
        extended_vector.push_back(vector_bnd_vertices[inod]);

        // Include the new node as well
        extended_vector.push_back(new_node);
      }
      else
      {
        // Include the "left" node in the new "temporary" vector
        // and move on to the next node
        extended_vector.push_back(vector_bnd_vertices[inod]);
      }
    } // end of loop over nodes

    // Add the last node to the vector
    extended_vector.push_back(vector_bnd_vertices[n_vertex - 1]);

    /// Get the size of the vector that now includes all added nodes
    n_vertex = extended_vector.size();

    // If the size of the vector including the added nodes is
    // different from the size of the vector before the refinement
    // routine then the polyline was obviously updated
    if (n_vertex != vector_bnd_vertices.size())
    {
      refinement_was_performed = true;
    }

    // Copy across
    vector_bnd_vertices.resize(n_vertex);
    for (unsigned i = 0; i < n_vertex; i++)
    {
      vector_bnd_vertices[i].resize(3);
      vector_bnd_vertices[i][0] = extended_vector[i][0];
      vector_bnd_vertices[i][1] = extended_vector[i][1];
      vector_bnd_vertices[i][2] = extended_vector[i][2];
    }

    // Delete the allocated memory for the geometric object
    // that represents the curvilinear boundary
    delete mesh_geom_obj_pt;

    return refinement_was_performed;
  }

  //=========================================================================
  // Helper function that applies the maximum length constraint
  // when it was specified. This will increase the number of points in
  // the current curve section in case that any segment on it does not
  // fulfils the requirement
  //=========================================================================
  template<class ELEMENT>
  bool RefineableTriangleMesh<ELEMENT>::apply_max_length_constraint(
    Mesh* face_mesh_pt,
    Vector<Vector<double>>& vector_bnd_vertices,
    double& max_length_constraint)
  {
    // Boolean that indicates whether an actual update of the vertex
    // coordinates was performed or not
    bool max_length_applied = false;

    // Create a geometric object from the mesh to represent
    // the curvilinear boundary
    MeshAsGeomObject* mesh_geom_obj_pt = new MeshAsGeomObject(face_mesh_pt);

    // Get the total number of current vertices
    unsigned n_vertex = vector_bnd_vertices.size();

    // Create a new (temporary) vector for the nodes, so
    // that new nodes can be stored
    Vector<Vector<double>> extended_vector;

    // Loop over the nodes until the last but one node
    for (unsigned inod = 0; inod < n_vertex - 1; inod++)
    {
      // Get local coordinate of "left" node
      double zeta_left = vector_bnd_vertices[inod][0];

      // Get position vector of "left" node
      Vector<double> R_left(2);
      for (unsigned i = 0; i < 2; i++)
      {
        R_left[i] = vector_bnd_vertices[inod][i + 1];
      }

      // Get local coordinate of "right" node
      double zeta_right = vector_bnd_vertices[inod + 1][0];

      // Get position vector of "right" node
      Vector<double> R_right(2);
      for (unsigned i = 0; i < 2; i++)
      {
        R_right[i] = vector_bnd_vertices[inod + 1][i + 1];
      }

      // Include the "left" node in the new "temporary" vector
      extended_vector.push_back(vector_bnd_vertices[inod]);

      // Check whether the current distance between the left and right node
      // is longer than the specified constraint or not
      double length = std::fabs(zeta_right - zeta_left);

      // Do we need to introduce new nodes?
      if (length > max_length_constraint)
      {
        double n_pts = length / max_length_constraint;
        // We only want the integer part
        unsigned n_points = static_cast<unsigned>(n_pts);
        double zeta_increment =
          (zeta_right - zeta_left) / ((double)n_points + 1);

        Vector<double> zeta(1);
        // Create the n_points+1 points inside the segment
        for (unsigned s = 1; s < n_points + 1; s++)
        {
          // Get the coordinates
          zeta[0] = zeta_left + zeta_increment * double(s);
          Vector<double> vertex(2);
          mesh_geom_obj_pt->position(zeta, vertex);

          // Create the new node
          Vector<double> new_node(3);
          new_node[0] = zeta[0];
          new_node[1] = vertex[0];
          new_node[2] = vertex[1];

          // Include the new node
          extended_vector.push_back(new_node);
        }
      }
    }

    // Add the last node to the vector
    extended_vector.push_back(vector_bnd_vertices[n_vertex - 1]);

    /// Get the size of the vector that now includes all added nodes
    n_vertex = extended_vector.size();

    // If the size of the vector including the added nodes is
    // different from the size of the vector before applying the maximum length
    // constraint then the polyline was obviously updated
    if (n_vertex != vector_bnd_vertices.size())
    {
      max_length_applied = true;
    }

    // Copy across
    vector_bnd_vertices.resize(n_vertex);
    for (unsigned i = 0; i < n_vertex; i++)
    {
      vector_bnd_vertices[i].resize(3);
      vector_bnd_vertices[i][0] = extended_vector[i][0];
      vector_bnd_vertices[i][1] = extended_vector[i][1];
      vector_bnd_vertices[i][2] = extended_vector[i][2];
    }

    // Delete the allocated memory for the geometric object
    // that represents the curvilinear boundary
    delete mesh_geom_obj_pt;

    return max_length_applied;
  }

  //=========================================================================
  /// Helper function
  /// Creates an unsorted face mesh representation from the specified
  /// boundary id. It means that the elements are not sorted along the
  /// boundary
  //=========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::
    create_unsorted_face_mesh_representation(const unsigned& boundary_id,
                                             Mesh* face_mesh_pt)
  {
    // Create a face mesh adjacent to specified boundary.
    // The face mesh consists of FaceElements that may also be
    // interpreted as GeomObjects

    // Build the face mesh
    this->template build_face_mesh<ELEMENT, FaceElementAsGeomObject>(
      boundary_id, face_mesh_pt);

    // Find the total number of added elements
    unsigned n_element = face_mesh_pt->nelement();
    // Loop over the elements
    for (unsigned e = 0; e < n_element; e++)
    {
      // Cast the element pointer to the correct thing!
      FaceElementAsGeomObject<ELEMENT>* el_pt =
        dynamic_cast<FaceElementAsGeomObject<ELEMENT>*>(
          face_mesh_pt->element_pt(e));

      // Set bulk boundary number
      el_pt->set_boundary_number_in_bulk_mesh(boundary_id);
    }
  }

  //=========================================================================
  /// Helper function
  /// Creates a sorted face mesh representation of the specified PolyLine
  /// It means that the elements are sorted along the boundary
  //=========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::create_sorted_face_mesh_representation(
    const unsigned& boundary_id,
    Mesh* face_mesh_pt,
    std::map<FiniteElement*, bool>& is_inverted,
    bool& inverted_face_mesh)
  {
    Mesh* tmp_unsorted_face_mesh_pt = new Mesh();

    // First step we get the unsorted version of the face mesh
    create_unsorted_face_mesh_representation(boundary_id,
                                             tmp_unsorted_face_mesh_pt);

    // Once with the unsorted version of the face mesh
    // only left to sort it out!!!

    // Put all face elements in order
    //-------------------------------

    // Put first element into ordered list
    // Temporal list for sorting the elements
    std::list<FiniteElement*> sorted_el_pt;
    FiniteElement* el_pt = tmp_unsorted_face_mesh_pt->finite_element_pt(0);
    sorted_el_pt.push_back(el_pt);

    // Number of nodes
    unsigned nnod = el_pt->nnode();

    // Count elements that have been done
    unsigned count_done = 0;

    // How many face elements are there?
    unsigned n_face_element = tmp_unsorted_face_mesh_pt->nelement();

    // Keep track of who's done
    std::map<FiniteElement*, bool> done_el;

    is_inverted.clear();

    // Fit in the other elements in at most nel^2 loops
    for (unsigned ee = 1; ee < n_face_element; ee++)
    {
      // Loop over all elements to check if they fit to the right
      // or the left of the current one
      for (unsigned e = 1; e < n_face_element; e++)
      {
        // Candidate element
        el_pt = tmp_unsorted_face_mesh_pt->finite_element_pt(e);

        // Is it done yet?
        if (!done_el[el_pt])
        {
          // Left and rightmost elements
          FiniteElement* first_el_pt = (*sorted_el_pt.begin());
          std::list<FiniteElement*>::iterator it = sorted_el_pt.end();
          it--;
          FiniteElement* last_el_pt = *it;

          // Left and rightmost nodes
          Node* left_node_pt = first_el_pt->node_pt(0);
          if (is_inverted[first_el_pt])
          {
            left_node_pt = first_el_pt->node_pt(nnod - 1);
          }
          Node* right_node_pt = last_el_pt->node_pt(nnod - 1);
          if (is_inverted[last_el_pt])
          {
            right_node_pt = last_el_pt->node_pt(0);
          }

          // New element fits at the left of first element and is not inverted
          if (left_node_pt == el_pt->node_pt(nnod - 1))
          {
            sorted_el_pt.push_front(el_pt);
            done_el[el_pt] = true;
            count_done++;
            is_inverted[el_pt] = false;
          }
          // New element fits at the left of first element and is inverted

          else if (left_node_pt == el_pt->node_pt(0))
          {
            sorted_el_pt.push_front(el_pt);
            done_el[el_pt] = true;
            count_done++;
            is_inverted[el_pt] = true;
          }
          // New element fits on the right of last element and is not inverted

          else if (right_node_pt == el_pt->node_pt(0))
          {
            sorted_el_pt.push_back(el_pt);
            done_el[el_pt] = true;
            count_done++;
            is_inverted[el_pt] = false;
          }
          // New element fits on the right of last element and is inverted

          else if (right_node_pt == el_pt->node_pt(nnod - 1))
          {
            sorted_el_pt.push_back(el_pt);
            done_el[el_pt] = true;
            count_done++;
            is_inverted[el_pt] = true;
          }

          if (done_el[el_pt])
          {
            break;
          }
        }
      }
    }

    // Are we done?
    if (count_done != (n_face_element - 1))
    {
      std::ostringstream error_message;
      error_message << "When ordering FaceElements on  "
                    << "boundary " << boundary_id << " only managed to order \n"
                    << count_done << " of " << n_face_element
                    << " face elements.\n"
                    << std::endl;
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }

    // Now make a mesh that contains the FaceElements in order
    // Remember that we currently have a list, not a mesh of sorted elements

    // Fill it
    for (std::list<FiniteElement*>::iterator it = sorted_el_pt.begin();
         it != sorted_el_pt.end();
         it++)
    {
      // Get element
      FiniteElement* el_pt = *it;

      // add this face element to the order original mesh
      face_mesh_pt->add_element_pt(el_pt);
    }

    // Verify if face mesh representation is not inverted according to the
    // polyline specified by the user, it means that the initial and the
    // final vertex does really correspond to the first and last vertex
    // respectively, if not, state that the face mesh representation is
    // inverted

    // Get the associated polyline representation to the boundary
    TriangleMeshPolyLine* bnd_polyline =
      this->Boundary_curve_section_pt[boundary_id];

    // Get the really first vertex
    Vector<double> first_vertex = bnd_polyline->vertex_coordinate(0);

    // Now get the first node based on the face mesh representation
    // First get access to the first element
    FiniteElement* first_el_pt = face_mesh_pt->finite_element_pt(0);

    // Now get access to the first node
    unsigned n_node = first_el_pt->nnode();
    // Get the very first node (taking into account if it is
    // inverted or not!!)
    Node* first_node_pt = first_el_pt->node_pt(0);
    if (is_inverted[first_el_pt])
    {
      first_node_pt = first_el_pt->node_pt(n_node - 1);
    }

    double error = (first_node_pt->x(0) - first_vertex[0]) *
                     (first_node_pt->x(0) - first_vertex[0]) +
                   (first_node_pt->x(1) - first_vertex[1]) *
                     (first_node_pt->x(1) - first_vertex[1]);

    error = sqrt(error);

    if (error < ToleranceForVertexMismatchInPolygons::Tolerable_error)
    {
      inverted_face_mesh = false;
    }
    else
    {
      inverted_face_mesh = true;
    }
  }

  //=========================================================================
  /// Helper function to construct face mesh representation of all polylines,
  /// possibly with segments re-distributed between polylines
  /// to maintain an approximately even sub-division of the polygon
  //=========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::get_face_mesh_representation(
    TriangleMeshPolygon* polygon_pt, Vector<Mesh*>& face_mesh_pt)
  {
    // Number of polylines
    unsigned n_polyline = polygon_pt->npolyline();
    face_mesh_pt.resize(n_polyline);

    // Are we eligible for re-distributing polyline segments between
    // polylines? We're not if any of the boundaries are associated
    // with a GeomObject because we're then tied to the start and
    // end coordinates along it.
    bool eligible_for_segment_redistribution = true;

    // Loop over constituent polylines
    for (unsigned p = 0; p < n_polyline; p++)
    {
      // Get the boundary id of the polyline
      unsigned bound = polygon_pt->polyline_pt(p)->boundary_id();

      // If the boundary has a geometric object representation then
      // we can't redistribute
      GeomObject* const geom_object_pt = this->boundary_geom_object_pt(bound);
      if (geom_object_pt != 0)
      {
        eligible_for_segment_redistribution = false;
      }

      face_mesh_pt[p] = new Mesh();
      create_unsorted_face_mesh_representation(bound, face_mesh_pt[p]);
    }

    if (!polygon_pt->is_redistribution_of_segments_between_polylines_enabled())
    {
      return;
    }

    // If there is more than one region we have to think... Die for now.
    if (this->nregion() > 1)
    {
      std::ostringstream warn_message;
      warn_message
        << "Can't currently re-distribute segments between polylines if there\n"
        << "are multiple regions; returning..." << std::endl;
      OomphLibWarning(warn_message.str(),
                      "RefineableTriangleMesh::get_face_mesh_representation()",
                      OOMPH_EXCEPTION_LOCATION);
      return;
    }

    // Redistribution overruled
    if (!eligible_for_segment_redistribution)
    {
      std::ostringstream warn_message;
      warn_message
        << "Over-ruling re-distribution of segments between polylines\n"
        << "because at least one boundary is associated with a GeomObject."
        << "Returning..." << std::endl;
      OomphLibWarning(warn_message.str(),
                      "RefineableTriangleMesh::get_face_mesh_representation()",
                      OOMPH_EXCEPTION_LOCATION);
      return;
    }

    // Create a vector for ordered face mesh
    Vector<Mesh*> ordered_face_mesh_pt(n_polyline);

    // Storage for the total arclength of polygon
    double s_total = 0.0;

    // Storage for first and last nodes on polylines so we can figure
    // out if they are inverted relative to each other
    Vector<Node*> first_polyline_node_pt(n_polyline);
    Vector<Node*> last_polyline_node_pt(n_polyline);
    std::vector<bool> is_reversed(n_polyline, false);

    // Loop over constituent polylines
    for (unsigned p = 0; p < n_polyline; p++)
    {
      // Put all face elements in order
      //-------------------------------

      // Put first element into ordered list
      std::list<FiniteElement*> ordered_el_pt;
      FiniteElement* el_pt = face_mesh_pt[p]->finite_element_pt(0);
      ordered_el_pt.push_back(el_pt);

      // Number of nodes
      unsigned nnod = el_pt->nnode();

      // Default for first and last node on polyline
      first_polyline_node_pt[p] = el_pt->node_pt(0);
      last_polyline_node_pt[p] = el_pt->node_pt(nnod - 1);

      // Count elements that have been done
      unsigned count_done = 0;

      // How many face elements are there?
      unsigned n_face_element = face_mesh_pt[p]->nelement();

      // Get the boundary id of the polyline
      unsigned bound = polygon_pt->polyline_pt(p)->boundary_id();

      // Keep track of who's done
      std::map<FiniteElement*, bool> done_el;

      // Keep track of which element is inverted
      std::map<FiniteElement*, bool> is_inverted;

      // Fit in the other elements in at most nel^2 loops
      for (unsigned ee = 1; ee < n_face_element; ee++)
      {
        // Loop over all elements to check if they fit to the right
        // or the left of the current one
        for (unsigned e = 1; e < n_face_element; e++)
        {
          // Candidate element
          el_pt = face_mesh_pt[p]->finite_element_pt(e);

          // Is it done yet?
          if (!done_el[el_pt])
          {
            // Left and rightmost elements
            FiniteElement* first_el_pt = (*ordered_el_pt.begin());
            std::list<FiniteElement*>::iterator it = ordered_el_pt.end();
            it--;
            FiniteElement* last_el_pt = *it;

            // Left and rightmost nodes
            Node* left_node_pt = first_el_pt->node_pt(0);
            if (is_inverted[first_el_pt])
            {
              left_node_pt = first_el_pt->node_pt(nnod - 1);
            }
            Node* right_node_pt = last_el_pt->node_pt(nnod - 1);
            if (is_inverted[last_el_pt])
            {
              right_node_pt = last_el_pt->node_pt(0);
            }

            // New element fits at the left of first element and is not inverted
            if (left_node_pt == el_pt->node_pt(nnod - 1))
            {
              ordered_el_pt.push_front(el_pt);
              done_el[el_pt] = true;
              count_done++;
              is_inverted[el_pt] = false;
              first_polyline_node_pt[p] = el_pt->node_pt(0);
            }
            // New element fits at the left of first element and is inverted

            else if (left_node_pt == el_pt->node_pt(0))
            {
              ordered_el_pt.push_front(el_pt);
              done_el[el_pt] = true;
              count_done++;
              is_inverted[el_pt] = true;
              first_polyline_node_pt[p] = el_pt->node_pt(nnod - 1);
            }
            // New element fits on the right of last element and is not inverted

            else if (right_node_pt == el_pt->node_pt(0))
            {
              ordered_el_pt.push_back(el_pt);
              done_el[el_pt] = true;
              count_done++;
              is_inverted[el_pt] = false;
              last_polyline_node_pt[p] = el_pt->node_pt(nnod - 1);
            }
            // New element fits on the right of last element and is inverted

            else if (right_node_pt == el_pt->node_pt(nnod - 1))
            {
              ordered_el_pt.push_back(el_pt);
              done_el[el_pt] = true;
              count_done++;
              is_inverted[el_pt] = true;
              last_polyline_node_pt[p] = el_pt->node_pt(0);
            }

            if (done_el[el_pt])
            {
              break;
            }
          }
        }
      }

      // Are we done?
      if (count_done != (n_face_element - 1))
      {
        std::ostringstream error_message;
        error_message << "When ordering FaceElements on  "
                      << "boundary " << bound << " only managed to order \n"
                      << count_done << " of " << n_face_element
                      << " face elements.\n"
                      << std::endl;
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }

      // Now make a mesh that contains the FaceElements in order
      ordered_face_mesh_pt[p] = new Mesh;

      // Fill it
      for (std::list<FiniteElement*>::iterator it = ordered_el_pt.begin();
           it != ordered_el_pt.end();
           it++)
      {
        // Get element
        FiniteElement* el_pt = *it;

        // add this face element to the order original mesh
        ordered_face_mesh_pt[p]->add_element_pt(el_pt);
      }

      // Get the arclength along the polygon
      for (unsigned e = 0; e < n_face_element; ++e)
      {
        FiniteElement* el_pt = ordered_face_mesh_pt[p]->finite_element_pt(e);
        unsigned n_node = el_pt->nnode();
        double element_length_squared = 0.0;
        for (unsigned i = 0; i < 2; i++)
        {
          element_length_squared +=
            pow(el_pt->node_pt(n_node - 1)->x(i) - el_pt->node_pt(0)->x(i), 2);
        }

        // Determine element length
        double element_length = sqrt(element_length_squared);

        // Add this length to the total arclength
        s_total += element_length;
      }

      // Empty the original meshes
      face_mesh_pt[p]->flush_element_and_node_storage();
    }

    // Is first one reversed?
    if ((last_polyline_node_pt[0] == first_polyline_node_pt[1]) ||
        (last_polyline_node_pt[0] == last_polyline_node_pt[1]))
    {
      is_reversed[0] = false;
    }
    else if ((first_polyline_node_pt[0] == first_polyline_node_pt[1]) ||
             (first_polyline_node_pt[0] == last_polyline_node_pt[1]))
    {
      is_reversed[0] = true;
    }

    // Reorder the face meshes so that they are contiguous
    Vector<Mesh*> tmp_face_mesh_pt(n_polyline);
    std::vector<bool> mesh_done(n_polyline, false);
    Vector<unsigned> old_polyline_number(n_polyline);

    // Initial entry
    tmp_face_mesh_pt[0] = ordered_face_mesh_pt[0];
    unsigned current = 0;
    old_polyline_number[0] = 0;
    unsigned count_found = 0;

    // Fill in the next entries
    for (unsigned p = 1; p < n_polyline; p++)
    {
      Node* end_node_pt = last_polyline_node_pt[current];
      if (is_reversed[current])
      {
        end_node_pt = first_polyline_node_pt[current];
      }

      // Loop over all remaining face meshes to see which one fits
      for (unsigned pp = 1; pp < n_polyline; pp++)
      {
        if (!mesh_done[pp])
        {
          // Current one is not reversed, candidate is not reversed
          if ((!is_reversed[current]) &&
              (end_node_pt == first_polyline_node_pt[pp]))
          {
            tmp_face_mesh_pt[p] = ordered_face_mesh_pt[pp];
            mesh_done[pp] = true;
            is_reversed[pp] = false;
            old_polyline_number[p] = pp;
            current = pp;
            count_found++;
            break;
          }
          // Current one is not reversed, candidate is reversed

          else if ((!is_reversed[current]) &&
                   (end_node_pt == last_polyline_node_pt[pp]))
          {
            tmp_face_mesh_pt[p] = ordered_face_mesh_pt[pp];
            mesh_done[pp] = true;
            is_reversed[pp] = true;
            old_polyline_number[p] = pp;
            current = pp;
            count_found++;
            break;
          }
          // Current one is reversed, candidate is not reversed

          else if ((is_reversed[current]) &&
                   (end_node_pt == first_polyline_node_pt[pp]))
          {
            tmp_face_mesh_pt[p] = ordered_face_mesh_pt[pp];
            mesh_done[pp] = true;
            is_reversed[pp] = false;
            old_polyline_number[p] = pp;
            current = pp;
            count_found++;
            break;
          }
          // Current one is reversed, candidate is reversed

          else if ((is_reversed[current]) &&
                   (end_node_pt == last_polyline_node_pt[pp]))
          {
            tmp_face_mesh_pt[p] = ordered_face_mesh_pt[pp];
            mesh_done[pp] = true;
            is_reversed[pp] = true;
            old_polyline_number[p] = pp;
            current = pp;
            count_found++;
            break;
          }
        }
      }
    }

#ifdef PARANOID
    if (count_found != n_polyline - 1)
    {
      std::ostringstream error_message;
      error_message << "Only found " << count_found << " out of "
                    << n_polyline - 1 << " polylines to be fitted in.\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Now overwrite the re-ordered data
    for (unsigned i = 0; i < n_polyline; i++)
    {
      ordered_face_mesh_pt[i] = tmp_face_mesh_pt[i];
    }

    // Now do an approximate equidistribution of polylines
    //----------------------------------------------------
    double s = 0.0;
    unsigned new_face_id = 0;

    // Matrix map to indicate if node must not be removed from specified
    // boundary (!=0) or not (=0). Initialises itself to zero
    std::map<Node*, std::map<unsigned, unsigned>>
      node_must_not_be_removed_from_boundary_flag;

    // Loop over the old face mesh
    for (unsigned p = 0; p < n_polyline; p++)
    {
      // Loop over the face elements
      unsigned n_face_element = ordered_face_mesh_pt[p]->nelement();
      for (unsigned e = 0; e < n_face_element; e++)
      {
        unsigned el_number = e;
        if (is_reversed[p])
        {
          el_number = n_face_element - e - 1;
        }

        FiniteElement* el_pt =
          ordered_face_mesh_pt[p]->finite_element_pt(el_number);
        unsigned n_node = el_pt->nnode();

        // Determine element length
        double element_length_squared = 0.0;
        for (unsigned i = 0; i < 2; i++)
        {
          element_length_squared +=
            pow(el_pt->node_pt(n_node - 1)->x(i) - el_pt->node_pt(0)->x(i), 2);
        }
        double element_length = sqrt(element_length_squared);

        // Add this length to the total arclength
        s += element_length;

        // Check if the current 'arclength' is less than the
        // whole 'arclength' divided by the number of polylines
        if (s < s_total / double(n_polyline) + 1e-6)
        {
          // If so add this face element to the new face mesh
          face_mesh_pt[new_face_id]->add_element_pt(el_pt);

          unsigned bound_old =
            polygon_pt->polyline_pt(old_polyline_number[p])->boundary_id();

          unsigned bound_new =
            polygon_pt->polyline_pt(new_face_id)->boundary_id();

          // Loop over the nodes in the element
          for (unsigned i = 0; i < n_node; i++)
          {
            // Get the pointer to the node
            Node* nod_pt = el_pt->node_pt(i);

            // If the two boundary id's are different, the face element's nodes
            // have to be added to the new boundary
            if (bound_new != bound_old)
            {
              // Add it to the new boundary
              add_boundary_node(bound_new, nod_pt);

              // We are happy for this node to be removed from the
              // old boundary?
              node_must_not_be_removed_from_boundary_flag[nod_pt][bound_old] +=
                0;
            }

            // If the face element hasn't moved, its nodes MUST remain
            // on that boundary (incl. any nodes that ar shared by
            // FaceElements that have moved (see above)

            else
            {
              node_must_not_be_removed_from_boundary_flag[nod_pt][bound_old] +=
                1;
            }
          }
        }

        // If not, reset the current 'arclength' to zero,
        // increase the new face id by one and go one element
        // back by decreasing e by one to make sure the current
        // element gets added to the next face mesh

        else
        {
          if (new_face_id != n_polyline - 1)
          {
            s = 0.0;
            new_face_id++;
            --e;
          }
          else
          {
            s = 0.0;
            --e;
          }
        }
      }
    } // end of loop over all polylines -- they are now re-distributed


    // Loop over all nodes on the boundaries of the polygon to remove
    // nodes from boundaries they are no longer on
    unsigned move_count = 0;
    for (std::map<Node*, std::map<unsigned, unsigned>>::iterator it =
           node_must_not_be_removed_from_boundary_flag.begin();
         it != node_must_not_be_removed_from_boundary_flag.end();
         it++)
    {
      // Get the node
      Node* nod_pt = (*it).first;

      // Now we loop over the boundaries that this node is on
      for (std::map<unsigned, unsigned>::iterator it_2 = (*it).second.begin();
           it_2 != (*it).second.end();
           it_2++)
      {
        // Get the boundary id
        unsigned bound = (*it_2).first;

        // Remove it from that boundary?
        if ((*it_2).second == 0)
        {
          remove_boundary_node(bound, nod_pt);
          move_count++;
        }
      }
    }

    // Loop over the new face mesh to assign new boundary IDs
    for (unsigned p = 0; p < n_polyline; p++)
    {
      // Get the boundary id of the polyline
      unsigned bound = polygon_pt->polyline_pt(p)->boundary_id();

      // Loop over the face elements
      unsigned n_face_element = face_mesh_pt[p]->nelement();
      for (unsigned e = 0; e < n_face_element; e++)
      {
        // Cast the element pointer to the correct thing!
        FaceElementAsGeomObject<ELEMENT>* el_pt =
          dynamic_cast<FaceElementAsGeomObject<ELEMENT>*>(
            face_mesh_pt[p]->element_pt(e));

        // Set bulk boundary number
        el_pt->set_boundary_number_in_bulk_mesh(bound);
      }
    }

    // Update look-up for elements next to boundary
    setup_boundary_element_info();

    // Now re-create the boundary coordinates
    for (unsigned p = 0; p < n_polyline; p++)
    {
      // Get the boundary id of the polyline
      unsigned bound = polygon_pt->polyline_pt(p)->boundary_id();

      // Do it
      this->template setup_boundary_coordinates<ELEMENT>(bound);
    }

    // Clean up
    for (unsigned p = 0; p < n_polyline; p++)
    {
      // Flush the nodes from the face mesh to make sure we
      // don't delete them (the face mesh that we're returning from here
      // still needs them!)
      ordered_face_mesh_pt[p]->flush_element_and_node_storage();
      delete ordered_face_mesh_pt[p];
    }
  }

  //=========================================================================
  /// Helper function to construct face mesh representation of all polylines
  //=========================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::get_face_mesh_representation(
    TriangleMeshOpenCurve* open_polyline_pt, Vector<Mesh*>& face_mesh_pt)
  {
    // Number of polylines
    unsigned n_polyline = open_polyline_pt->ncurve_section();
    face_mesh_pt.resize(n_polyline);

    // Loop over constituent polylines
    for (unsigned p = 0; p < n_polyline; p++)
    {
      // Get the boundary id of the polyline
      unsigned bound = open_polyline_pt->curve_section_pt(p)->boundary_id();

      face_mesh_pt[p] = new Mesh();
      create_unsorted_face_mesh_representation(bound, face_mesh_pt[p]);
    }
  }

  //======================================================================
  /// Update the PSLG that define the inner boundaries of the mesh.
  /// Optional boolean is used to run it as test only (if
  /// true is specified as input) in which case PSLG isn't actually
  /// modified. Returned boolean indicates if PSLG was (or would have
  /// been -- if called with check_only=false) changed.
  //======================================================================
  template<class ELEMENT>
  bool RefineableTriangleMesh<
    ELEMENT>::surface_remesh_for_inner_hole_boundaries(Vector<Vector<double>>&
                                                         internal_point_coord,
                                                       const bool& check_only)
  {
    // Boolean to indicate whether an actual update of the internal
    // holes was performed
    bool update_was_performed = false;
    // Loop over the number of internal boundaries
    unsigned n_hole = internal_point_coord.size();
    for (unsigned ihole = 0; ihole < n_hole; ihole++)
    {
      // Cache the pointer to the polygon representation
      TriangleMeshPolygon* const poly_pt = this->Internal_polygon_pt[ihole];


      // Can the polygon update its own configuration, in which case this
      // is easy
      if (poly_pt->can_update_reference_configuration())
      {
        poly_pt->reset_reference_configuration();

        // Initialize Vector hole_coordinates
        internal_point_coord[ihole].resize(2);

        // Get the vector of hole coordinates
        internal_point_coord[ihole] = poly_pt->internal_point();
      }
      // Otherwise we have to work much harder

      else
      {
        // if we only want to check whether an update of the inner
        // hole is necessary
        if (check_only)
        {
          // is it necessary?
          bool update_necessary =
            this->update_polygon_using_face_mesh(poly_pt, check_only);

          // Yes?
          if (update_necessary)
          {
            // then we have to adaptand return 'true'
            return true;
          }
        }
        // if we not only want to check, then we actually perform
        // the update
        else
        {
          update_was_performed = this->update_polygon_using_face_mesh(poly_pt);
        }

        // Now we need to sort out the hole coordinates
        if (!poly_pt->internal_point().empty())
        {
          // If fixed don't update and simply
          // Read out the existing value
          if (poly_pt->is_internal_point_fixed())
          {
            // Get the vector of hole coordinates
            internal_point_coord[ihole] = poly_pt->internal_point();
          }
          // This is where the work starts and this could be made much
          // better than the current hack
          else
          {
            // If the user has set their own function then use that
            if (this->Internal_hole_point_update_fct_pt != 0)
            {
              this->Internal_hole_point_update_fct_pt(ihole, poly_pt);
            }
            // Otherwise use our clunky default
            else
            {
              // Now sort out the hole coordinates
              Vector<double> vertex_coord;
              unsigned n_polyline = poly_pt->npolyline();

              // Initialize Vector hole_coordinates
              vertex_coord.resize(2);
              internal_point_coord[ihole].resize(2);

              // Hole centre will be found by averaging the position of
              // all vertex nodes
              internal_point_coord[ihole][0] = 0.0;
              internal_point_coord[ihole][1] = 0.0;

              for (unsigned p = 0; p < n_polyline; p++)
              {
                Vector<double> poly_ave(2, 0.0);
                // How many vertices are there in the segment
                unsigned n_vertex = poly_pt->polyline_pt(p)->nvertex();
                for (unsigned v = 0; v < n_vertex; v++)
                {
                  vertex_coord = poly_pt->polyline_pt(p)->vertex_coordinate(v);
                  for (unsigned i = 0; i < 2; i++)
                  {
                    poly_ave[i] += vertex_coord[i];
                  }
                }

                // Add the average polyline coordinate to the hole centre
                for (unsigned i = 0; i < 2; i++)
                {
                  internal_point_coord[ihole][i] += poly_ave[i] / n_vertex;
                }
              }

              // Now average out the hole centre
              for (unsigned i = 0; i < 2; i++)
              {
                internal_point_coord[ihole][i] /= n_polyline;
              }

              // We have now found the hole centre stored in
              // internal_point_coordinate[ihole][i]

              // Find polylines that intersect at y average value
              // Alice's version but this does not work if the end point of a
              // segment is the intersection point (i.e. at the y average value)
              /*Vector<double> vertex_coord2;
                unsigned n_intersect=0;
                double x_average=0.0;

                for(unsigned p=0;p<n_polyline;p++)
                {
                //How many vertices are there in the segment
                unsigned n_vertex = poly_pt->polyline_pt(p)->nvertex();
                for(unsigned v=0;v<n_vertex-1;v++)
                {
                vertex_coord =  poly_pt->polyline_pt(p)->vertex_coordinate(v);
                vertex_coord2 = poly_pt->polyline_pt(p)->vertex_coordinate(v+1);
                std::cout << vertex_coord[0] << " " << vertex_coord[1]
                << " " <<
                vertex_coord2[0] << " " <<

                vertex_coord2[1] << "\n";
                //Does the line between vertices intersect the vertical position
                if((vertex_coord[1] -internal_point_coord[ihole][1])*
                (vertex_coord2[1] - internal_point_coord[ihole][1]) < 0.0)
                {
                ++n_intersect; x_average += 0.5*(vertex_coord[0] +
                vertex_coord2[0]);
                }
                }
                }

                //Now just report the value if we have had intersections
                if(n_intersect != 0)
                {
                //Report
                std::cout << "I have computed a hole " << x_average << " " <<
                n_intersect << " "
                << x_average/((double)n_intersect) << std::endl;
                internal_point_coord[ihole][0] =
                x_average/((double)n_intersect);
                }
              */

              // Set the new hole centre
              poly_pt->internal_point() = internal_point_coord[ihole];
              // std::cout << "I've had my centre updated to "
              //          << internal_point_coord[ihole][0]
              //          << " " << internal_point_coord[ihole][1] << "\n";
            }
          }
        }
      }
    } // End of the action (n_hole for)

    if (check_only)
    {
      // If we make it up to here and we only check then no update is required
      return false;
    }
    else
    {
      // otherwise indicate whether an actual update was performed
      return update_was_performed;
    }

  } // End of the loop of internal boundaries

  //======================================================================
  /// Create the polylines and fill associate data structures, used when
  /// creating from a mesh from polyfiles
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::create_polylines_from_polyfiles(
    const std::string& node_file_name, const std::string& poly_file_name)
  {
    // Get the nodes coordinates (the index of the nodes to build the
    // polylines is the one used in the node_file_name file)
    // Process node file
    // -----------------
    std::ifstream node_file(node_file_name.c_str(), std::ios_base::in);

    // Check that the file actually opened correctly
    if (!node_file.is_open())
    {
      std::string error_msg("Failed to open node file: ");
      error_msg += "\"" + node_file_name + "\".";
      throw OomphLibError(
        error_msg, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }

    // Read number of nodes
    unsigned nnodes;
    node_file >> nnodes;

    // Spatial dimension of nodes
    unsigned dimension;
    node_file >> dimension;

#ifdef PARANOID
    if (dimension != 2)
    {
      throw OomphLibError("The dimension must be 2\n",
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Storage the nodes vertices
    Vector<double> x_node(nnodes);
    Vector<double> y_node(nnodes);

    // Number of attributes
    unsigned npoint_attributes;
    node_file >> npoint_attributes;
    ;

    // Flag for boundary markers
    unsigned boundary_markers_flag = 0;
    node_file >> boundary_markers_flag;

    // Dummy for node number
    unsigned dummy_node_number;
    // Dummy for node attribute
    unsigned dummy_node_attribute;
    // Dummy for node boundary
    unsigned dummy_node_boundary;

    // Load in nodal posititions, point attributes
    // and boundary markers
    for (unsigned i = 0; i < nnodes; i++)
    {
      node_file >> dummy_node_number;
      node_file >> x_node[i];
      node_file >> y_node[i];
      for (unsigned j = 0; j < npoint_attributes; ++j)
      {
        node_file >> dummy_node_attribute;
      }
      if (boundary_markers_flag)
      {
        node_file >> dummy_node_boundary;
      }
    }
    node_file.close();

    // Get the segments information and use that info. to create the
    // polylines

    // A map to store the segments associated to a boundary, non sorted
    std::map<unsigned, Vector<std::pair<unsigned, unsigned>>>
      unsorted_boundary_segments;

    // Independent storage for the boundaries ids found in the segments so that
    // the polylines, and therefore polygons be created in the order they appear
    // in the polyfile
    Vector<unsigned> sorted_boundaries_ids;

    // Process poly file to extract edges
    //-----------------------------------

    // Open poly file
    std::ifstream poly_file(poly_file_name.c_str(), std::ios_base::in);

    // Check that the file actually opened correctly
    if (!poly_file.is_open())
    {
      std::string error_msg("Failed to open poly file: ");
      error_msg += "\"" + poly_file_name + "\".";
      throw OomphLibError(
        error_msg, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }

    // Number of nodes in poly file --- these will be ignore
    unsigned n_node_poly;
    poly_file >> n_node_poly;

    // Dimension
    poly_file >> dimension;

    // Attribute flag
    unsigned attribute_flag;
    poly_file >> attribute_flag;

    // Flag for boundary markers
    poly_file >> boundary_markers_flag;

    // Ignore node information: Note: No, we can't extract the
    // actual nodes themselves from here!
    unsigned dummy;
    for (unsigned i = 0; i < n_node_poly; i++)
    {
      // Read in (and discard) node number and x and y coordinates
      poly_file >> dummy;
      poly_file >> dummy;
      poly_file >> dummy;
      // read in the attributes
      for (unsigned j = 0; j < attribute_flag; ++j)
      {
        poly_file >> dummy;
      }
      // read in the boundary marker
      if (boundary_markers_flag == 1)
      {
        poly_file >> dummy;
      }
    }

    // Variable used to read the values from the input file
    unsigned read_value;

    // Number of segments
    poly_file >> read_value;
    const unsigned nglobal_segments = read_value;

    // Boundary marker flag
    poly_file >> boundary_markers_flag;

    // Global segment number
    unsigned global_segment_number;

    // Node identifier set (used to identify possible internal boundaries)
    std::set<unsigned> nodes_ids;

    // Extract information for each segment
    for (unsigned i = 0; i < nglobal_segments; i++)
    {
      // Node id on the edge of the segment
      unsigned lnode_id = 0; // left node
      unsigned rnode_id = 0; // right node
      unsigned bnd_id = 0; // boundary id associated to the current segment
      poly_file >> global_segment_number;
      poly_file >> lnode_id;
      poly_file >> rnode_id;
      nodes_ids.insert(lnode_id);
      nodes_ids.insert(rnode_id);
      if (boundary_markers_flag)
      {
        poly_file >> bnd_id;
      }

      // Store the segments info. (use bnd_id - 1 because the nodes and
      // elements associated the bnd_id have been associated by external
      // methods to bnd_id - 1)
      unsorted_boundary_segments[bnd_id - 1].push_back(
        std::make_pair(lnode_id, rnode_id));

      // Add the boundary id to the vector of boundaries ids only if it
      // has not been added, the polylines will be created using this
      // order

      // Get the number of boundaries ids currently sorted
      const unsigned nsorted_boundaries_ids = sorted_boundaries_ids.size();
      // Flag to know if the boundary id was found
      bool boundary_id_found = false;
      for (unsigned ib = 0; ib < nsorted_boundaries_ids; ib++)
      {
        if (sorted_boundaries_ids[ib] == bnd_id - 1)
        {
          boundary_id_found = true;
          break;
        } // if (sorted_boundaries_ids[ib] == bnd_id - 1)
      } // for (ib < nsorted_boundaries_ids)

      // If th boundary id has not been added, then add it!!!
      if (!boundary_id_found)
      {
        sorted_boundaries_ids.push_back(bnd_id - 1);
      } // if (!boundary_id_found)
    }

    // Verify if there are internal boundaries defined, if that is the
    // case we can not continue since we are not yet supporting internal
    // boundaries defined in polyfiles to created a mesh that may be
    // adapted
#ifdef PARANOID
    if (nglobal_segments != nodes_ids.size())
    {
      std::ostringstream error_message;
      error_message
        << "The number of nodes (" << nodes_ids.size() << ") and segments ("
        << nglobal_segments << ") is different.\nThis may mean that there  "
        << "are internal non-closed boundaries defined in\nthe polyfile. "
        << "If you need this feature please use the TriangleMeshPoyLine\n"
        << "and TriangleMeshCurviLine objects to define your domain.\n\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Now sort the segments associated to a boundary to create a contiguous
    // polyline, but first check that the number of found boundaries be the
    // same as the current number of boundaries in the mesh
    const unsigned nboundary = unsorted_boundary_segments.size();

#ifdef PARANOID
    if (nboundary != this->nboundary())
    {
      std::ostringstream error_message;
      error_message
        << "The number of boundaries on the mesh (" << this->nboundary()
        << ") is different from the number of\nboundaries read from the "
        << "polyfiles (" << unsorted_boundary_segments.size() << ")!!!\n\n\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Get the number of sorted boundaries ids and check that it matches
    // with the total number of boundaries
    const unsigned nsorted_boundaries_ids = sorted_boundaries_ids.size();
#ifdef PARANOID
    if (nsorted_boundaries_ids != this->nboundary())
    {
      std::ostringstream error_message;
      error_message
        << "The number of boundaries on the mesh (" << this->nboundary()
        << ") is different from the number of\nsorted boundaries ids read "
        << "from the polyfiles (" << nsorted_boundaries_ids << ")!!!\n\n\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Sorted segments (to create a polyline -- boundary)
    std::map<unsigned, std::list<unsigned>> sorted_boundary_segments;

    // Go through all the found boundaries
    std::map<unsigned, Vector<std::pair<unsigned, unsigned>>>::iterator it;

    for (it = unsorted_boundary_segments.begin();
         it != unsorted_boundary_segments.end();
         it++)
    {
      // Get the current boundary id, only look for the segments
      // associated with this boundary
      const unsigned bnd_id = (*it).first;
      Vector<std::pair<unsigned, unsigned>> segments_edges = (*it).second;

      // Now sort the segments associated to this boundary
      std::map<std::pair<unsigned, unsigned>, bool> segment_done;
      const unsigned nsegments = segments_edges.size();

      // Sorted nodes for the current segment
      std::list<unsigned> sorted_segments;

      // Get the left and right node of the zero segment
      unsigned left_node_id = segments_edges[0].first;
      unsigned right_node_id = segments_edges[0].second;

      // ...  and add it to the sorted segments structure
      sorted_segments.push_back(left_node_id);
      sorted_segments.push_back(right_node_id);

      // Mark the current segment as done
      segment_done[segments_edges[0]] = true;

      // Set the number of sorted segments
      unsigned nsorted_segments = 1;

      while (nsorted_segments < nsegments)
      {
        for (unsigned i = 1; i < nsegments; i++)
        {
          // Check if the i-th segments has been done
          if (!segment_done[segments_edges[i]])
          {
            // Get the left and right node id
            unsigned current_left_node_id = segments_edges[i].first;
            unsigned current_right_node_id = segments_edges[i].second;

            // Now check if the current segment can be added to the left
            // or right side of the sorted segments
            if (current_left_node_id == right_node_id)
            {
              // Add the current_right_node_id to the right of the sorted
              // segments
              sorted_segments.push_back(current_right_node_id);
              // Increase the number of sorted segments
              nsorted_segments++;
              // Mark the segment as done
              segment_done[segments_edges[i]] = true;
              // Update the right most node
              right_node_id = current_right_node_id;
              // Break the for loop
              break;
            }
            else if (current_right_node_id == left_node_id)
            {
              // Add the current_left_node_id to the left of the sorted
              // segments
              sorted_segments.push_front(current_left_node_id);
              // Increase the number of sorted segments
              nsorted_segments++;
              // Mark the segment as done
              segment_done[segments_edges[i]] = true;
              // Update the left most node
              left_node_id = current_left_node_id;
              // Break the for loop
              break;
            }
            else if (current_left_node_id == left_node_id)
            {
              // Add the current_right_node_id to the left of the sorted
              // segments
              sorted_segments.push_front(current_right_node_id);
              // Increase the number of sorted segments
              nsorted_segments++;
              // Mark the segment as done
              segment_done[segments_edges[i]] = true;
              // Update the left most node
              left_node_id = current_right_node_id;
              // Break the for loop
              break;
            }
            else if (current_right_node_id == right_node_id)
            {
              // Add the current_left_node_id to the right of the sorted
              // segments
              sorted_segments.push_back(current_left_node_id);
              // Increase the number of sorted segments
              nsorted_segments++;
              // Mark the segment as done
              segment_done[segments_edges[i]] = true;
              // Update the left most node
              right_node_id = current_left_node_id;
              // Break the for loop
              break;
            }
          } // if (!segment_done[segments_edges[i]])
        } // for (i < nsegments)
      } // while(nsorted_segments < nsegments)

      sorted_boundary_segments[bnd_id] = sorted_segments;

    } // for (unsorted_boundary_segments.begin();
      //      unsorted_boundary_segments.end())

#ifdef PARANOID
    if (sorted_boundary_segments.size() != this->nboundary())
    {
      std::ostringstream error_message;
      error_message
        << "The number of boundaries on the mesh (" << this->nboundary()
        << ") is different from the number\nof sorted boundaries to create the "
        << "polylines (" << sorted_boundary_segments.size() << ")\n\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Now we have the sorted nodes, we can create the polylines by
    // getting the vertices of the nodes
    Vector<TriangleMeshPolyLine*> polylines_pt(nboundary);
    unsigned current_polyline = 0;

    // Go through the sorted boundaries using the sorted boundaries ids
    for (unsigned ib = 0; ib < nsorted_boundaries_ids; ib++)
    {
      // Get the boundary id from the vector of sorted boundaries ids
      const unsigned bnd_id = sorted_boundaries_ids[ib];

      // Create a vector representation for ease to use
      // Get the vertices of the nodes that create the boundary / polyline
      Vector<unsigned> nodes_ids;
      for (std::list<unsigned>::iterator it_list =
             sorted_boundary_segments[bnd_id].begin();
           it_list != sorted_boundary_segments[bnd_id].end();
           it_list++)
      {
        nodes_ids.push_back((*it_list));
      }

      // Get the number of vertices for the polyline
      const unsigned nvertices = nodes_ids.size();

      // The storage for the vertices
      Vector<Vector<double>> vertices(nvertices);

      // Now get the vertices of the nodes of the current boundary
      for (unsigned i = 0; i < nvertices; i++)
      {
        // Get the vertices
        vertices[i].resize(2);
        vertices[i][0] = x_node[nodes_ids[i] - 1];
        vertices[i][1] = y_node[nodes_ids[i] - 1];
      }

      // Now create the polyline

      // Note: The bnd_id is the real bnd_id (from the input file) - 1
      // since nodes and elements of the current boundary have been
      // associated to bnd_id - 1)
      polylines_pt[current_polyline] =
        new TriangleMeshPolyLine(vertices, bnd_id);

      // Updates bnd_id<--->curve section map
      this->Boundary_curve_section_pt[bnd_id] =
        dynamic_cast<TriangleMeshCurveSection*>(polylines_pt[current_polyline]);

      // Increase the index for the polyline storage
      current_polyline++;

    } // for (it_sorted = sorted_boundary_segments.begin();
      //      it_sorted != sorted_boundary_segments.end())

    // Now create the polygons or closed curves
    // Sort the polylines to create polygons
    unsigned nsorted_polylines = 0;

    // Number of created polygons
    unsigned npolygons = 0;

    // Storage for the polygons
    Vector<TriangleMeshPolygon*> polygons_pt;

    // Mark the already done polylines
    std::map<unsigned, bool> polyline_done;
    while (nsorted_polylines < nboundary)
    {
      // Storage for the curve sections that create a polygon
      std::list<TriangleMeshCurveSection*> sorted_curve_sections_pt;

      unsigned init_poly = 0;
#ifdef PARANOID
      bool found_root_polyline = false;
#endif
      // Get the left and right node of the current polyline
      for (unsigned i = 0; i < nboundary; i++)
      {
        if (!polyline_done[i])
        {
          init_poly = i;
          // Increase the number of sorted polylines
          nsorted_polylines++;
#ifdef PARANOID
          // Mark as found the root polyline
          found_root_polyline = true;
#endif
          // Mark the polyline as done
          polyline_done[i] = true;
          // Add the polyline to the curve sections storage
          sorted_curve_sections_pt.push_back(polylines_pt[i]);
          // Break the loop to set we have found a root polyline
          break;
        }
      }

#ifdef PARANOID
      if (!found_root_polyline)
      {
        std::ostringstream error_message;
        error_message << "Was not possible to found the root polyline to "
                         "create polygons\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Get the associated boundary to the current polyline
      const unsigned bnd_id = polylines_pt[init_poly]->boundary_id();
      // Get the initial and final node id of the current polyline
      unsigned left_node_id = sorted_boundary_segments[bnd_id].front();
      unsigned right_node_id = sorted_boundary_segments[bnd_id].back();

      // Flag to know that we already have a closed polygon
      bool closed_polygon = false;

      do
      {
        // Go through all the polylines
        for (unsigned i = init_poly; i < nboundary; i++)
        {
          // Check that the polyline has not been currently done
          if (!polyline_done[i])
          {
            // Get the initial and final nodes id of the current polyline

            // Get the associated boundary to the current polyline
            const unsigned cbnd_id = polylines_pt[i]->boundary_id();
            // Get the initial and final node id of the current polyline
            unsigned cleft_node_id = sorted_boundary_segments[cbnd_id].front();
            unsigned cright_node_id = sorted_boundary_segments[cbnd_id].back();

            // Check if the polyline goes to the left or right of the
            // current sorted polylines
            if (cleft_node_id == right_node_id)
            {
              // Add the polyline to the curve section storage
              sorted_curve_sections_pt.push_back(polylines_pt[i]);
              // Mark the polyline as done
              polyline_done[i] = true;
              // Update the right node
              right_node_id = cright_node_id;
              // Increase the number of done polyines
              nsorted_polylines++;
              // Break the for loop
              break;
            }
            else if (cright_node_id == left_node_id)
            {
              // Add the polyline to the curve section storage
              sorted_curve_sections_pt.push_front(polylines_pt[i]);
              // Mark the polyline as done
              polyline_done[i] = true;
              // Update the right node
              left_node_id = cleft_node_id;
              // Increase the number of done polyines
              nsorted_polylines++;
              // Break the for loop
              break;
            }
            else if (cleft_node_id == left_node_id)
            {
              // First reverse the polyline
              polylines_pt[i]->reverse();
              // Add the polyline to the curve section storage
              sorted_curve_sections_pt.push_front(polylines_pt[i]);
              // Mark the polyline as done
              polyline_done[i] = true;
              // Update the right node
              left_node_id = cright_node_id;
              // Increase the number of done polyines
              nsorted_polylines++;
              // Break the for loop
              break;
            }
            else if (cright_node_id == right_node_id)
            {
              // First reverse the polyline
              polylines_pt[i]->reverse();
              // Add the polyline to the curve section storage
              sorted_curve_sections_pt.push_back(polylines_pt[i]);
              // Mark the polyline as done
              polyline_done[i] = true;
              // Update the right node
              right_node_id = cleft_node_id;
              // Increase the number of done polyines
              nsorted_polylines++;
              // Break the for loop
              break;
            }
          } // if (!polyline_done[i])

        } // for (i < nboundary)

        // We have created a polygon
        if (left_node_id == right_node_id)
        {
          // Set the flag as true
          closed_polygon = true;
        }

      } while (nsorted_polylines < nboundary && !closed_polygon);

#ifdef PARANOID
      if (!closed_polygon)
      {
        std::ostringstream error_message;
        error_message
          << "It was not possible to create a closed curve, these are the "
          << "vertices of the already sorted polylines\n\n";
        unsigned cpolyline = 0;
        for (std::list<TriangleMeshCurveSection*>::iterator it_list =
               sorted_curve_sections_pt.begin();
             it_list != sorted_curve_sections_pt.end();
             it_list++)
        {
          error_message << "Polyline (" << cpolyline << ")\n";
          TriangleMeshPolyLine* tmp_poly_pt =
            dynamic_cast<TriangleMeshPolyLine*>((*it_list));
          const unsigned nvertex = tmp_poly_pt->nvertex();
          for (unsigned v = 0; v < nvertex; v++)
          {
            error_message << "(" << tmp_poly_pt->vertex_coordinate(v)[0] << ", "
                          << tmp_poly_pt->vertex_coordinate(v)[1] << ")\n";
          }
          error_message << "\n";
          cpolyline++;
        }
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Create a vector version to create the polygon from the sorted
      // polyines
      Vector<TriangleMeshCurveSection*> tmp_sorted_curve_sections_pt;
      for (std::list<TriangleMeshCurveSection*>::iterator it_list =
             sorted_curve_sections_pt.begin();
           it_list != sorted_curve_sections_pt.end();
           it_list++)
      {
        tmp_sorted_curve_sections_pt.push_back((*it_list));
      }

      // Create a new polygon by using the new created polylines
      TriangleMeshPolygon* polygon_pt =
        new TriangleMeshPolygon(tmp_sorted_curve_sections_pt);

      // Keep track of new created polygons that need to be deleted!!!
      this->Free_polygon_pt.insert(polygon_pt);

      // Store the polygon in the polygons storages
      polygons_pt.push_back(polygon_pt);

      npolygons++;

    } // while(nsorted_polylines < nboundary)

    // ------------------------------------------------------------------
    // Before filling the data structures we need to identify the outer
    // closed boundary and the inner closed boundaries.
    // If the nodes are not in order we throw a warning message

    // Index for the polygon that is currently considered as the outer
    // boundary
    unsigned index_outer = 0;

    for (unsigned idx_outer = 0; idx_outer < npolygons; idx_outer++)
    {
      // Get the vertices of the outer boundary
      Vector<Vector<double>> outer_vertex_coordinates;

      // Flag to know if ALL the inner closed boundaries are inside the
      // outer closed boundary
      bool all_inner_inside = true;

      // Number of polylines of the outer boundary
      const unsigned nouter_polylines = polygons_pt[idx_outer]->npolyline();
      for (unsigned p = 0; p < nouter_polylines; p++)
      {
        TriangleMeshPolyLine* tmp_poly_pt =
          polygons_pt[idx_outer]->polyline_pt(p);
        const unsigned nvertex = tmp_poly_pt->nvertex();
        for (unsigned v = 0; v < nvertex; v++)
        {
          Vector<double> current_vertex = tmp_poly_pt->vertex_coordinate(v);
          outer_vertex_coordinates.push_back(current_vertex);
        } // for (v < nvertex)
      } // for (p < nouter_polylines)

      // Now get the vertices for the inner boundaries

      // First get the number of inner closed boundaries (polygons size
      // minus one because one of the polygons is considered to be the
      // outer closed boundary
      const unsigned ninner_polygons = polygons_pt.size() - 1;

      // Store the vertices of the inner closed boundaries
      Vector<Vector<Vector<double>>> inner_vertex_coordinates(ninner_polygons);
      // Get all the vertices of the inner closed boundaries
      for (unsigned i = 0; i <= ninner_polygons; i++)
      {
        if (i != idx_outer)
        {
          // Number of polylines of the current internal closed boundary
          const unsigned ninner_polylines = polygons_pt[i]->npolyline();
          for (unsigned p = 0; p < ninner_polylines; p++)
          {
            TriangleMeshPolyLine* tmp_poly_pt = polygons_pt[i]->polyline_pt(p);
            const unsigned nvertex = tmp_poly_pt->nvertex();
            for (unsigned v = 0; v < nvertex; v++)
            {
              Vector<double> current_vertex = tmp_poly_pt->vertex_coordinate(v);
              if (i < idx_outer)
              {
                inner_vertex_coordinates[i].push_back(current_vertex);
              }
              else if (i > idx_outer)
              {
                inner_vertex_coordinates[i - 1].push_back(current_vertex);
              }
            } // for (v < nvertex)

          } // for (p < ninner_polylines)

        } // if (i != index_outer)

      } // for (i <= ninner_polygons)

      // Now check that ALL the vertices of ALL the internal closed
      // boundaries are inside the outer closed boundary
      for (unsigned i = 0; i < ninner_polygons; i++)
      {
        // Get the number of vertices in the current internal closed
        // boundary
        const unsigned nvertex_internal = inner_vertex_coordinates[i].size();
        for (unsigned v = 0; v < nvertex_internal; v++)
        {
          // Get a vertex in the current internal closed boundary
          Vector<double> current_point = inner_vertex_coordinates[i][v];
          all_inner_inside &= this->is_point_inside_polygon_helper(
            outer_vertex_coordinates, current_point);

          // Check if we should continue checking for more points inside
          // the current proposed outer boundary
          if (!all_inner_inside)
          {
            // Break the "for" for the vertices
            break;
          }

        } // for (v < nvertex_internal)

        // Check if we should continue checking for more inner closed
        // boundaries inside the current proposed outer boundary
        if (!all_inner_inside)
        {
          // Break the "for" for the inner boundaries
          break;
        }

      } // for (i < ninner_polygons)

      // Check if all the vertices of all the polygones are inside the
      // current proposed outer boundary
      if (all_inner_inside)
      {
        index_outer = idx_outer;
        break;
      }

    } // for (idx_outer < npolygons)

#ifdef PARANOID
    // Check if the first nodes listed in the polyfiles correspond to
    // the outer boundary, if that is not the case then throw a warning
    // message
    if (index_outer != 0)
    {
      std::ostringstream warning_message;
      warning_message
        << "The first set of nodes listed in the input polyfiles does not\n"
        << "correspond to the outer closed boundary. This may lead to\n"
        << "problems at the adaptation stage if the holes coordinates\n"
        << "are no correctly associated to the inner closed boundaries.\n"
        << "You can check the generated mesh by calling the output() method\n"
        << "from the mesh object '(problem.mesh_pt()->output(string))'\n\n";
      OomphLibWarning(warning_message.str(),
                      OOMPH_CURRENT_FUNCTION,
                      OOMPH_EXCEPTION_LOCATION);
    } // if (index_outer != 0)
#endif

    // ------------------------------------------------------------------
    // Now fill the data structures

    // Store outer polygon
    // We are assuming there is only one outer polygon
    this->Outer_boundary_pt.resize(1);
    this->Outer_boundary_pt[0] = polygons_pt[index_outer];

    this->Internal_polygon_pt.resize(npolygons - 1);
    for (unsigned i = 0; i < npolygons; i++)
    {
      if (i != index_outer)
      {
        if (i < index_outer)
        {
          // Store internal polygons by copy constructor
          this->Internal_polygon_pt[i] = polygons_pt[i];
        }
        else if (i > index_outer)
        {
          // Store internal polygons by copy constructor
          this->Internal_polygon_pt[i - 1] = polygons_pt[i];
        }
      } // if (i != index_outer)
    } // for (i < npolygons)

    // Before assigning the hole vertex coordinate to the inner closed
    // boundaries check that the holes are listed in orderm if that is
    // not the case the associate each hole vertex coordinate to the
    // inner closed boundaries

    // Store the vertices of the inner closed boundaries
    Vector<Vector<Vector<double>>> inner_vertex_coordinates(npolygons - 1);
    // Get all the vertices of the inner closed boundaries
    for (unsigned i = 0; i < npolygons - 1; i++)
    {
      // Number of polylines of the current internal closed boundary
      const unsigned ninner_polylines =
        this->Internal_polygon_pt[i]->npolyline();
      for (unsigned p = 0; p < ninner_polylines; p++)
      {
        TriangleMeshPolyLine* tmp_poly_pt =
          this->Internal_polygon_pt[i]->polyline_pt(p);
        // Number of vertices of the current polyline in the current
        // internal closed polygon
        const unsigned nvertex = tmp_poly_pt->nvertex();
        for (unsigned v = 0; v < nvertex; v++)
        {
          Vector<double> current_vertex = tmp_poly_pt->vertex_coordinate(v);
          inner_vertex_coordinates[i].push_back(current_vertex);
        } // for (v < nvertex)

      } // for (p < ninner_polylines)

    } // for (i <= ninner_polygons)

    // Holes information
    unsigned nholes;
    poly_file >> nholes;

#ifdef PARANOID
    if (npolygons > 1 && (npolygons - 1) != nholes)
    {
      std::ostringstream error_message;
      error_message
        << "The number of holes (" << nholes << ") does not correspond "
        << "with the number\nof internal polygons (" << npolygons - 1 << ")\n\n"
        << "Using polyfiles as input does not currently allows the\n"
        << "definition of more than one outer polygon\n\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Storage for the holes
    Vector<Vector<double>> hole_coordinates(nholes);

    // Dummy for hole number
    unsigned dummy_hole;
    // Loop over the holes to get centre coords
    for (unsigned ihole = 0; ihole < nholes; ihole++)
    {
      hole_coordinates[ihole].resize(2);
      // Read the centre value
      poly_file >> dummy_hole;
      poly_file >> hole_coordinates[ihole][0];
      poly_file >> hole_coordinates[ihole][1];
    }

    // Vector that store the index of the hole coordinate that
    // correspond to each internal closed polygon
    Vector<unsigned> index_hole_of_internal_polygon(npolygons - 1);
    std::map<unsigned, bool> hole_done;

    // Now associate each hole vertex to a corresponding internal closed
    // polygon
    for (unsigned i = 0; i < npolygons - 1; i++)
    {
      // Find which hole is associated to each internal closed boundary
      for (unsigned h = 0; h < nholes; h++)
      {
        // If the hole has not been previously associated
        if (!hole_done[h])
        {
          // Get the hole coordinate
          Vector<double> current_point = hole_coordinates[h];

          const bool hole_in_polygon = this->is_point_inside_polygon_helper(
            inner_vertex_coordinates[i], current_point);

          // If the hole is inside the polygon
          if (hole_in_polygon)
          {
            // Mark the hole as done
            hole_done[h] = true;
            // Associate the current hole with the current inner closed
            // boundary
            index_hole_of_internal_polygon[i] = h;
            // Break the search
            break;
          }

        } // if (!hole_done[h])

      } // for (h < nholes)

    } // for (i < npolygons-1)

#ifdef PARANOID
    if (hole_done.size() != npolygons - 1)
    {
      std::ostringstream error_message;
      error_message
        << "Not all the holes were associated to an internal closed boundary\n"
        << "Only (" << hole_done.size()
        << ") holes were assigned for a total of\n"
        << "(" << npolygons - 1 << ") internal closed boundaries.\n"
        << "You can check the generated mesh by calling the output() method\n"
        << "from the mesh object '(problem.mesh_pt()->output(string))'\n\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    } // if (index_hole != ihole)
#endif

    // Assign the holes coordinates to the internal polygons
    for (unsigned ihole = 0; ihole < nholes; ihole++)
    {
      // Get the index hole of the current internal closed polygon
      const unsigned index_hole = index_hole_of_internal_polygon[ihole];
#ifdef PARANOID
      // Check if the hole index is the same as the internal closed
      // boundary, it means that the holes were listed in the same order
      // as the nodes of the internal closed boundaries
      if (index_hole != ihole)
      {
        std::ostringstream error_message;
        error_message
          << "The hole vertices coordinates are not listed in the same order\n"
          << "as the nodes that define the internal closed boundaries.\n"
          << "This may lead to problems in case that the holes coordinates\n"
          << "were no properly assigned to the internal closed boundaries.\n"
          << "You can check the generated mesh by calling the output() method\n"
          << "from the mesh object '(problem.mesh_pt()->output(string))'\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      } // if (index_hole != ihole)
#endif

      // Set the hole coordinate for the internal polygon
      this->Internal_polygon_pt[ihole]->internal_point() =
        hole_coordinates[index_hole];
    }

    // Ignore the first line with structure description
    poly_file.ignore(80, '\n');

    // Regions information
    unsigned nregions;

    // Extract regions information
    // But first check if there are regions or not
    std::string regions_info_string;

    // Read line up to termination sign
    getline(poly_file, regions_info_string);

    // Check if the read string is a number or a comment wrote by triangle,
    // if it is a number then that is the number of regions
    if (isdigit(regions_info_string.c_str()[0]))
    {
      nregions = std::atoi(regions_info_string.c_str());
    }
    else
    {
      nregions = 0;
    }

    // The regions coordinates
    std::map<unsigned, Vector<double>> regions_coordinates;

    // Dummy for regions number
    unsigned dummy_region;

    unsigned region_id;

    // Loop over the regions to get their coords
    for (unsigned iregion = 0; iregion < nregions; iregion++)
    {
      Vector<double> tmp_region_coordinates(2);
      // Read the regions coordinates
      poly_file >> dummy_region;
      poly_file >> tmp_region_coordinates[0];
      poly_file >> tmp_region_coordinates[1];
      poly_file >> region_id;
      regions_coordinates[region_id].resize(2);
      regions_coordinates[region_id][0] = tmp_region_coordinates[0];
      regions_coordinates[region_id][1] = tmp_region_coordinates[1];

      // Ignore the first line with structure description
      poly_file.ignore(80, '\n');

      // Verify if not using the default region number (zero)
      if (region_id == 0)
      {
        std::ostringstream error_message;
        error_message
          << "Please use another region id different from zero.\n"
          << "It is internally used as the default region number.\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
    }

    // Store the extra regions coordinates
    this->Regions_coordinates = regions_coordinates;

    poly_file.close();
  }

  //======================================================================
  /// Updates the polygon but using the elements area instead of
  /// the default refinement and unrefinement methods
  //======================================================================
  template<class ELEMENT>
  bool RefineableTriangleMesh<ELEMENT>::update_polygon_using_elements_area(
    TriangleMeshPolygon*& polygon_pt, const Vector<double>& target_area)
  {
    // Verify that there was a change on the polygon representation
    unsigned update_was_performed = false;

    const unsigned nele = this->nelement();

    // - Get the vertices along the boundaries and for each element identify
    //   its associated target error.
    //   - Get face mesh representation of each polyline.
    //   - Get the vertices with the help of face elements.
    //   - Find the global index in the mesh of the face element and use
    //     it to get its associated target area

    // Get the face mesh representation
    Vector<Mesh*> face_mesh_pt;
    get_face_mesh_representation(polygon_pt, face_mesh_pt);

    // Create vertices of the polylines by using the vertices of the
    // FaceElements
    Vector<double> vertex_coord(3); // zeta,x,y
    Vector<double> bound_left(1);
    Vector<double> bound_right(1);

    unsigned n_polyline = polygon_pt->npolyline();

    // Go for each polyline
    for (unsigned p = 0; p < n_polyline; p++)
    {
      // Get the MeshAsGeomObject representation just once per polyline,
      // this object is only used by the
      // refine_boundary_constrained_by_target_area() method. We get it
      // here to ensure that all processors (in a distributed context)
      // get this representation just once, and because an AllToAll MPI
      // communication is used in this calling
      MeshAsGeomObject* mesh_geom_obj_pt =
        new MeshAsGeomObject(face_mesh_pt[p]);

      // Set of coordinates on the boundary
      // Set entries are ordered on first entry in vector which stores
      // the boundary coordinate so the vertices come out in order!
      std::set<Vector<double>> vertex_nodes;

      // Vector to store the vertices, transfer the sorted vertices from the
      // set to this vector, --- including the z-value ---
      Vector<Vector<double>> tmp_vector_vertex_node;

      // Vector to store the coordinates of the polylines, same as the
      // tmp_vector_vertex_node vector (after adding more nodes) but
      // --- without the z-value ---, used to re-generate the polylines
      Vector<Vector<double>> vector_vertex_node;

#ifdef OOMPH_HAS_MPI
      // --------- Stuff to deal with splitted boundaries ---------- Begin -----
      // Set of coordinates that are on the boundary (splitted boundary version)
      // The first vector is used to allocate the points for each sub-boundary
      // Set entries are ordered on first entry in vector which stores
      // the boundary coordinate so the vertices come out in order!
      Vector<std::set<Vector<double>>> sub_vertex_nodes;

      // Vector to store the vertices, transfer the sorted vertices from the
      // set (sub_vertex_nodes) to this vector, --- including the z-value ---
      Vector<Vector<Vector<double>>> sub_tmp_vector_vertex_node;

      // Vector to store the coordinates of the polylines that will represent
      // the splitted boundary. Used to pass the info. from sub_vertex_nodes
      // but --- without the z-value ---, used to generate the sub-polylines
      Vector<Vector<Vector<double>>> sub_vector_vertex_node;
      // --------- Stuff to deal with splitted boundaries ----------- End ------
#endif

      // Get the boundary id
      const unsigned bound = polygon_pt->curve_section_pt(p)->boundary_id();

      // Get the chunk number
      const unsigned chunk = polygon_pt->curve_section_pt(p)->boundary_chunk();

      /// Use a vector of vector for vertices and target areas to deal
      /// with the cases when the boundaries are split by the
      /// distribution process

      // Loop over the face elements (ordered) and add their vertices
      const unsigned nface_element = face_mesh_pt[p]->nelement();

      // Store the non halo face elements, the ones from which we will
      // get the vertices
      Vector<FiniteElement*> non_halo_face_element_pt;

      // Map to store the index of the face element on a boundary
      std::map<FiniteElement*, unsigned> face_element_index_on_boundary;

      for (unsigned ef = 0; ef < nface_element; ++ef)
      {
        FiniteElement* ele_face_pt = face_mesh_pt[p]->finite_element_pt(ef);
#ifdef OOMPH_HAS_MPI
        // Skip the halo elements if working with a distributed mesh
        if (this->is_mesh_distributed() && ele_face_pt->is_halo())
        {
          continue;
        }
#endif
        // Add the face element to the vector
        non_halo_face_element_pt.push_back(ele_face_pt);
        face_element_index_on_boundary[ele_face_pt] = ef;
      }

      // Get the number of non halo face element
      const unsigned nnon_halo_face_element = non_halo_face_element_pt.size();

      // Map to know the already sorted face elements
      std::map<FiniteElement*, bool> face_element_done;

      // Number of done face elements
      unsigned nsorted_face_elements = 0;

#ifdef OOMPH_HAS_MPI
      // Counter for sub_boundaries
      unsigned nsub_boundaries = 0;
#endif // #ifdef OOMPH_HAS_MPI

      // Continue until all the face elements have been sorted
      // While to deal with split boundaries cases
      while (nsorted_face_elements < nnon_halo_face_element)
      {
        // Get and initial face element
        FiniteElement* ele_face_pt = 0;
#ifdef PARANOID
        bool found_initial_face_element = false;
#endif

        unsigned iface = 0;
        for (iface = 0; iface < nnon_halo_face_element; iface++)
        {
          ele_face_pt = non_halo_face_element_pt[iface];
          // If not done then take it as initial face element
          if (!face_element_done[ele_face_pt])
          {
#ifdef PARANOID
            found_initial_face_element = true;
#endif
            nsorted_face_elements++;
            iface++;
            break;
          }
        }

#ifdef PARANOID
        if (!found_initial_face_element)
        {
          std::ostringstream error_message;
          error_message << "Could not find an initial face element for the "
                           "current segment\n";
          // << "----- Possible memory leak -----\n";
          throw OomphLibError(
            error_message.str(),
            "RefineableTriangleMesh::update_polygon_using_elements_area()",
            OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // Local set of coordinates that are on the boundary
        // Set entries are ordered on first entry in vector which stores
        // the boundary coordinate so the vertices come out in order!
        std::set<Vector<double>> local_vertex_nodes;

        // Vector to store the vertices, transfer the sorted vertices from the
        // set (local) to this vector (local), --- including the z-value ---
        Vector<Vector<double>> local_tmp_vector_vertex_node;

        // Vector to store the target areas, uses the same approach as the
        // set for the local_vertex_nodes, ordered on first entry
        std::set<Vector<double>> sorted_target_areas;

        // Vector to store the target areas, used to transfer the sorted target
        // areas from "local_sorted_target_areas" set
        Vector<double> tmp_sorted_target_areas;

        // -----------------------------------------------------------------
        // Add the vertices of the initial face element to the set of
        // local sorted vertices
        // -----------------------------------------------------------------
        unsigned nnode = ele_face_pt->nnode();
        // Add the left-hand node to the set:
        // Boundary coordinate
        ele_face_pt->node_pt(0)->get_coordinates_on_boundary(bound, bound_left);
        vertex_coord[0] = bound_left[0];

        // Actual coordinates
        for (unsigned i = 0; i < 2; i++)
        {
          vertex_coord[i + 1] = ele_face_pt->node_pt(0)->x(i);
        }
        local_vertex_nodes.insert(vertex_coord);

        // Add the right-hand nodes to the set:
        // Boundary coordinate
        ele_face_pt->node_pt(nnode - 1)->get_coordinates_on_boundary(
          bound, bound_right);
        vertex_coord[0] = bound_right[0];

        // Actual coordinates
        for (unsigned i = 0; i < 2; i++)
        {
          vertex_coord[i + 1] = ele_face_pt->node_pt(nnode - 1)->x(i);
        }
        local_vertex_nodes.insert(vertex_coord);

        // The initial and final node on the set
        Node* first_node_pt = ele_face_pt->node_pt(0);
        Node* last_node_pt = ele_face_pt->node_pt(nnode - 1);

        // Mark the current face element as done
        face_element_done[ele_face_pt] = true;

        // -------------------------------------------------------
        // Find the global index in the mesh of the face element
        // and use it to get its associated target area
        // -------------------------------------------------------
        // Container to store the zeta value (used as index) and
        // the associated target area of the element
        Vector<double> zeta_target_area_values(2);

        // Use the minimum zeta value to sort the target areas
        // along the boundary
        zeta_target_area_values[0] = std::min(bound_left[0], bound_right[0]);

        // Get the index of the face element on the current boundary
        unsigned ef = face_element_index_on_boundary[ele_face_pt];
        // Get the "ef"-th element on the boundary
        FiniteElement* el_pt = this->boundary_element_pt(bound, ef);

#ifdef PARANOID
        bool found_global_element_index = false;
#endif
        for (unsigned eg = 0; eg < nele; eg++)
        {
          // Get the "eg-th" element
          FiniteElement* el_compare_pt = this->finite_element_pt(eg);

          // Compare with the element on the boundary, if equal then
          // store the target area
          if (el_pt == el_compare_pt)
          {
            zeta_target_area_values[1] = target_area[eg];
#ifdef PARANOID
            found_global_element_index = true;
#endif
            break; // break the for (e < nele) global element
          } // if element_pt == element_compare_pt
        } // for nele (on complete mesh)

#ifdef PARANOID
        if (!found_global_element_index)
        {
          std::ostringstream error_message;
          error_message << "The global index for the (" << ef
                        << ")-th face element "
                        << "on\nthe (" << bound
                        << ")-th boundary was not found!!!";
          throw OomphLibError(
            error_message.str(),
            "RefineableTriangleMesh::update_polygon_using_elements_area()",
            OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // Add the target areas to the sorted set
        sorted_target_areas.insert(zeta_target_area_values);
        // ------------------------------------------------------------------

        // Continue iterating if a new face element has been added to the
        // list
        bool face_element_added = false;

        // While a new face element has been added to the set of sorted
        // face elements then re-iterate
        do
        {
          // Start from the next face elements since we have already
          // added the previous one as the initial face element (any
          // previous face element had to be added on previous
          // iterations)
          for (unsigned iiface = iface; iiface < nnon_halo_face_element;
               iiface++)
          {
            face_element_added = false;
            ele_face_pt = non_halo_face_element_pt[iiface];
            if (!face_element_done[ele_face_pt])
            {
              // Get each individual node to check if they are contiguous
              nnode = ele_face_pt->nnode();
              Node* left_node_pt = ele_face_pt->node_pt(0);
              Node* right_node_pt = ele_face_pt->node_pt(nnode - 1);

              if (left_node_pt == first_node_pt)
              {
                first_node_pt = right_node_pt;
                face_element_added = true;
              }
              else if (left_node_pt == last_node_pt)
              {
                last_node_pt = right_node_pt;
                face_element_added = true;
              }
              else if (right_node_pt == first_node_pt)
              {
                first_node_pt = left_node_pt;
                face_element_added = true;
              }
              else if (right_node_pt == last_node_pt)
              {
                last_node_pt = left_node_pt;
                face_element_added = true;
              }

              if (face_element_added)
              {
                // Add the left-hand node to the set:
                // Boundary coordinate
                left_node_pt->get_coordinates_on_boundary(bound, bound_left);
                vertex_coord[0] = bound_left[0];

                // Actual coordinates
                for (unsigned i = 0; i < 2; i++)
                {
                  vertex_coord[i + 1] = left_node_pt->x(i);
                }
                local_vertex_nodes.insert(vertex_coord);

                // Add the right-hand nodes to the set:
                // Boundary coordinate
                right_node_pt->get_coordinates_on_boundary(bound, bound_right);
                vertex_coord[0] = bound_right[0];

                // Actual coordinates
                for (unsigned i = 0; i < 2; i++)
                {
                  vertex_coord[i + 1] = right_node_pt->x(i);
                }
                local_vertex_nodes.insert(vertex_coord);

                // Mark as done only if one of its nodes has been
                // added to the list
                face_element_done[ele_face_pt] = true;
                nsorted_face_elements++;

                // -----------------------------------------------------
                // Find the global index in the mesh of the face element
                // and use it to get its associated target area
                // -----------------------------------------------------
                // Use the minimum zeta value to sort the target areas
                // along the boundary
                zeta_target_area_values[0] =
                  std::min(bound_left[0], bound_right[0]);

                // Get the "ef"-th element on the boundary
                ef = face_element_index_on_boundary[ele_face_pt];
                FiniteElement* lel_pt = this->boundary_element_pt(bound, ef);

#ifdef PARANOID
                found_global_element_index = false;
#endif
                for (unsigned eg = 0; eg < nele; eg++)
                {
                  // Get the "eg-th" element
                  FiniteElement* lel_compare_pt = this->finite_element_pt(eg);

                  // Compare with the element on the boundary, if equal then
                  // store the target area
                  if (lel_pt == lel_compare_pt)
                  {
                    zeta_target_area_values[1] = target_area[eg];
#ifdef PARANOID
                    found_global_element_index = true;
#endif
                    break; // break the for (e < nele) global element
                  } // if element_pt == element_compare_pt
                } // for nele (on complete mesh)

#ifdef PARANOID
                if (!found_global_element_index)
                {
                  std::ostringstream error_message;
                  error_message << "The global index for the (" << ef
                                << ")-th face element "
                                << "on\nthe (" << bound
                                << ")-th boundary was not found!!!";
                  throw OomphLibError(error_message.str(),
                                      "RefineableTriangleMesh::update_polygon_"
                                      "using_elements_area()",
                                      OOMPH_EXCEPTION_LOCATION);
                }
#endif

                // Add the target areas to the sorted set
                sorted_target_areas.insert(zeta_target_area_values);

                break;
              }

            } // if (!edge_done[edge])
          } // for (iiedge < nedges)
        } while (face_element_added &&
                 (nsorted_face_elements < nnon_halo_face_element));

        // -----------------------------------------------------------------
        // At this point we already have a sorted set of nodes and
        // can be used to peform the unrefinement and refinement procedures
        // -----------------------------------------------------------------

        // Get the number of nodes on the list
        const unsigned nlocal_nodes = local_vertex_nodes.size();
        // Change representation to vector for easy of handling ...
        local_tmp_vector_vertex_node.resize(nlocal_nodes);

        // Copy the vertices of the nodes
        unsigned counter = 0;
        std::set<Vector<double>>::iterator it_vertex;
        for (it_vertex = local_vertex_nodes.begin();
             it_vertex != local_vertex_nodes.end();
             it_vertex++)
        {
          local_tmp_vector_vertex_node[counter].resize(3);
          local_tmp_vector_vertex_node[counter][0] = (*it_vertex)[0];
          local_tmp_vector_vertex_node[counter][1] = (*it_vertex)[1];
          local_tmp_vector_vertex_node[counter][2] = (*it_vertex)[2];
          counter++;
        }

        // ... same for the info. related with the target areas (turn
        // into vector)
        const unsigned ntarget_areas = sorted_target_areas.size();
        tmp_sorted_target_areas.resize(ntarget_areas);
        counter = 0;
        std::set<Vector<double>>::iterator it_area;
        for (it_area = sorted_target_areas.begin();
             it_area != sorted_target_areas.end();
             ++it_area)
        {
          tmp_sorted_target_areas[counter] = (*it_area)[1];
          ++counter;
        }

#ifdef PARANOID
        if (nlocal_nodes > 0 && (ntarget_areas != nlocal_nodes - 1))
        {
          std::ostringstream error_message;
          error_message
            << "The boundary (" << bound << ") was split during the "
            << "distribution process.\n"
            << "The problem is in the association of the target areas with "
               "the\n"
            << "elements that gave rise to the vertex coordinates.\n"
            << "The number of local nodes (" << nlocal_nodes
            << "), on the 'sub-polyline', is not\n"
            << "according with the number of target "
            << "areas (" << ntarget_areas << ")\nfor that number of nodes.\n"
            << "The target areas number MUST be equal to the number of\n"
            << "local nodes minus one\n\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // -------------------------------------------------------------------
        // Update the vertices along the boundary using the target area
        // to define the distance among them
        // -------------------------------------------------------------------

        // Tolerance below which the middle point can be deleted
        // (ratio of deflection to element length)
        double unrefinement_tolerance =
          polygon_pt->polyline_pt(p)->unrefinement_tolerance();

        // Apply unrefinement
        bool unrefinement_applied =
          unrefine_boundary_constrained_by_target_area(
            bound,
            chunk,
            local_tmp_vector_vertex_node,
            unrefinement_tolerance,
            tmp_sorted_target_areas);

        // Tolerance for refinement
        double refinement_tolerance =
          polygon_pt->polyline_pt(p)->refinement_tolerance();

        // Apply refinement
        bool refinement_applied = refine_boundary_constrained_by_target_area(
          mesh_geom_obj_pt,
          local_tmp_vector_vertex_node,
          refinement_tolerance,
          tmp_sorted_target_areas);

        // Clear the local containter to recover the nodes ordered using the
        // zeta value
        local_vertex_nodes.clear();

        // At the end of each unrefinement/refinement step store the new nodes
        // on the set that will give rise to the vertices of the new polyline
        // representation
        unsigned nnew_nodes = local_tmp_vector_vertex_node.size();
        for (unsigned i = 0; i < nnew_nodes; i++)
        {
          vertex_coord[0] = local_tmp_vector_vertex_node[i][0];
          vertex_coord[1] = local_tmp_vector_vertex_node[i][1];
          vertex_coord[2] = local_tmp_vector_vertex_node[i][2];
          vertex_nodes.insert(vertex_coord); // Global container
          local_vertex_nodes.insert(vertex_coord);
        }

        // Update the flag to indicate whether an unrefinement or
        // refinement was applied
        update_was_performed = (unrefinement_applied || refinement_applied);

#ifdef OOMPH_HAS_MPI
        if (this->is_mesh_distributed())
        {
          // Add the set of vertices for the boundary, this will help to
          // detect if we need to deal with sub-boundaries
          sub_vertex_nodes.push_back(local_vertex_nodes);
          // Increase the counter for sub-boundaries
          nsub_boundaries++;
        }
#endif

      } // while(nsorted_face_elements < nnon_halo_face_element)

      // Now turn into vector for ease of handling...
      unsigned npoly_vertex = vertex_nodes.size();
      // This will store all the vertices whether the boundary was split
      // or not
      tmp_vector_vertex_node.resize(npoly_vertex);
      unsigned count = 0;
      for (std::set<Vector<double>>::iterator it = vertex_nodes.begin();
           it != vertex_nodes.end();
           ++it)
      {
        tmp_vector_vertex_node[count].resize(3);
        tmp_vector_vertex_node[count][0] = (*it)[0];
        tmp_vector_vertex_node[count][1] = (*it)[1];
        tmp_vector_vertex_node[count][2] = (*it)[2];
        ++count;
      }

#ifdef OOMPH_HAS_MPI
      // --------- Stuff for the sub_boundaries ----- Begin section ---------
#ifdef PARANOID
      unsigned nsub_boundaries_set = sub_vertex_nodes.size();
      if (nsub_boundaries_set != nsub_boundaries)
      {
        std::ostringstream error_message;
        error_message
          << "The number of found sub-boundaries and the number of counted\n"
          << "sub-boundaries are different:\n"
          << "Number of found sub-boundaries: (" << nsub_boundaries_set << ")\n"
          << "Number of counted sub-boundaries: (" << nsub_boundaries << ")\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Are there sub-boundaries (only appear in distributed meshes)
      if (this->is_mesh_distributed() && nsub_boundaries > 1)
      {
        // Mark the boundary as been splitted in the partition process
        this->Boundary_was_splitted[bound] = true;
        // Resize the vector to store the info. of sub-boundaries
        sub_tmp_vector_vertex_node.resize(nsub_boundaries);
        for (unsigned isub = 0; isub < nsub_boundaries; isub++)
        {
          // Turn info. into vector for ease of handling...
          const unsigned nsubpoly_vertex = sub_vertex_nodes[isub].size();
          sub_tmp_vector_vertex_node[isub].resize(nsubpoly_vertex);
          unsigned subcount = 0;
          std::set<Vector<double>>::iterator subit;
          for (subit = sub_vertex_nodes[isub].begin();
               subit != sub_vertex_nodes[isub].end();
               ++subit)
          {
            sub_tmp_vector_vertex_node[isub][subcount].resize(3);
            sub_tmp_vector_vertex_node[isub][subcount][0] = (*subit)[0];
            sub_tmp_vector_vertex_node[isub][subcount][1] = (*subit)[1];
            sub_tmp_vector_vertex_node[isub][subcount][2] = (*subit)[2];
            ++subcount;
          }
        }
      } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
      // --------- Stuff for the sub_boundaries ----- End section ------------
#endif // OOMPH_HAS_MPI

      // For further processing the three-dimensional vector has to be
      // reduced to a two-dimensional vector
      unsigned n_vertex = tmp_vector_vertex_node.size();

      // Resize the vector for vectices
      vector_vertex_node.resize(n_vertex);
      for (unsigned i = 0; i < n_vertex; i++)
      {
        vector_vertex_node[i].resize(2);
        vector_vertex_node[i][0] = tmp_vector_vertex_node[i][1];
        vector_vertex_node[i][1] = tmp_vector_vertex_node[i][2];
      }

#ifdef OOMPH_HAS_MPI
      // --------- Stuff for the sub_boundaries ----- Begin section ----------
      // Verify if need to deal with sub_boundaries
      if (this->is_mesh_distributed() && nsub_boundaries > 1)
      {
        // For further processing the three-dimensional vector
        // has to be reduced to a two-dimensional vector
        // Resize the vector to store the info. of sub-boundaries
        sub_vector_vertex_node.resize(nsub_boundaries);
        for (unsigned isub = 0; isub < nsub_boundaries; isub++)
        {
          const unsigned subn_vertex = sub_tmp_vector_vertex_node[isub].size();
          // Resize the vector for vectices
          sub_vector_vertex_node[isub].resize(subn_vertex);
          for (unsigned i = 0; i < subn_vertex; i++)
          {
            sub_vector_vertex_node[isub][i].resize(2);
            sub_vector_vertex_node[isub][i][0] =
              sub_tmp_vector_vertex_node[isub][i][1];
            sub_vector_vertex_node[isub][i][1] =
              sub_tmp_vector_vertex_node[isub][i][2];
          }
        }
      } // if (this->is_mesh_distributed() && nsub_boundaries > 1)

      // We already have the info. for the sub-boundaries (if necessary)
      // and then we can create the sub-boundaries representations to
      // ease the generation of the mesh by Triangle

      // --------- Stuff for the sub_boundaries ----- End section ------------
#endif // OOMPH_HAS_MPI

      // --------------------------------------------------------------------
      // Check for contiguousness
      // --------------------------------------------------------------------
#ifdef OOMPH_HAS_MPI
      // Only perform this checking if the mesh is not distributed. When
      // the mesh is distributed the polylines continuity is addressed
      // by the sort_polylines_helper() method
      if (!this->is_mesh_distributed())
#endif
      {
        if (p > 0)
        {
          // Final end point of previous line
          Vector<double> final_vertex_of_previous_segment;
          unsigned n_prev_vertex =
            polygon_pt->curve_section_pt(p - 1)->nvertex();
          final_vertex_of_previous_segment =
            polygon_pt->polyline_pt(p - 1)->vertex_coordinate(n_prev_vertex -
                                                              1);

          unsigned prev_seg_boundary_id =
            polygon_pt->curve_section_pt(p - 1)->boundary_id();

          // Find the error between the final vertex of the previous
          // line and the first vertex of the current line
          double error = 0.0;
          for (unsigned i = 0; i < 2; i++)
          {
            const double dist = final_vertex_of_previous_segment[i] -
                                (*vector_vertex_node.begin())[i];
            error += dist * dist;
          }
          error = sqrt(error);

          // If the error is bigger than the tolerance then
          // we probably need to reverse, but better check
          if (error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
          {
            // Find the error between the final vertex of the previous
            // line and the last vertex of the current line
            double rev_error = 0.0;
            for (unsigned i = 0; i < 2; i++)
            {
              const double dist = final_vertex_of_previous_segment[i] -
                                  (*--vector_vertex_node.end())[i];
              rev_error += dist * dist;
            }
            rev_error = sqrt(rev_error);

            if (rev_error >
                ToleranceForVertexMismatchInPolygons::Tolerable_error)
            {
              // It could be possible that the first segment be reversed
              // and we did not notice it because this check does not
              // apply for the first segment. We can verify if the first
              // segment is reversed by using the vertex number 1
              if (p == 1)
              {
                // Initial end point of previous line
                Vector<double> initial_vertex_of_previous_segment;

                initial_vertex_of_previous_segment =
                  polygon_pt->polyline_pt(p - 1)->vertex_coordinate(0);

                unsigned prev_seg_boundary_id =
                  polygon_pt->curve_section_pt(p - 1)->boundary_id();

                // Find the error between the initial vertex of the previous
                // line and the first vertex of the current line
                double error = 0.0;
                for (unsigned i = 0; i < 2; i++)
                {
                  const double dist = initial_vertex_of_previous_segment[i] -
                                      (*vector_vertex_node.begin())[i];
                  error += dist * dist;
                }
                error = sqrt(error); // Reversed only the previous one

                // If the error is bigger than the tolerance then
                // we probably need to reverse, but better check
                if (error >
                    ToleranceForVertexMismatchInPolygons::Tolerable_error)
                {
                  // Find the error between the final vertex of the previous
                  // line and the last vertex of the current line
                  double rev_error = 0.0;
                  for (unsigned i = 0; i < 2; i++)
                  {
                    const double dist = initial_vertex_of_previous_segment[i] -
                                        (*--vector_vertex_node.end())[i];
                    rev_error += dist * dist;
                  }
                  rev_error =
                    sqrt(rev_error); // Reversed both the current one and
                  // the previous one

                  if (rev_error >
                      ToleranceForVertexMismatchInPolygons::Tolerable_error)
                  {
                    std::ostringstream error_stream;
                    error_stream
                      << "The distance between the first node of the current\n"
                      << "line segment (boundary " << bound
                      << ") and either end of "
                      << "the previous line segment\n"
                      << "(boundary " << prev_seg_boundary_id
                      << ") is bigger than "
                      << "the desired tolerance "
                      << ToleranceForVertexMismatchInPolygons::Tolerable_error
                      << ".\n"
                      << "This suggests that the polylines defining the "
                      << "polygonal\n"
                      << "representation are not properly ordered.\n"
                      << "Fail on last vertex of polyline: ("
                      << prev_seg_boundary_id << ") and\n"
                      << "first vertex of polyline (" << bound << ").\n"
                      << "This should have failed when first trying to "
                      << "construct the\npolygon.\n";
                    throw OomphLibError(error_stream.str(),
                                        OOMPH_CURRENT_FUNCTION,
                                        OOMPH_EXCEPTION_LOCATION);
                  }
                  else
                  {
                    // Reverse both
                    // Reverse the current vector to line up with the
                    // previous one
                    std::reverse(vector_vertex_node.begin(),
                                 vector_vertex_node.end());

                    polygon_pt->polyline_pt(p - 1)->reverse();
                  }
                }
                else
                {
                  // Reverse the previous one
                  polygon_pt->polyline_pt(p - 1)->reverse();
                }

              } // if p == 1
              else
              {
                std::ostringstream error_stream;
                error_stream
                  << "The distance between the first node of the current\n"
                  << "line segment (boundary " << bound
                  << ") and either end of "
                  << "the previous line segment\n"
                  << "(boundary " << prev_seg_boundary_id
                  << ") is bigger than the "
                  << "desired tolerance "
                  << ToleranceForVertexMismatchInPolygons::Tolerable_error
                  << ".\n"
                  << "This suggests that the polylines defining the polygonal\n"
                  << "representation are not properly ordered.\n"
                  << "Fail on last vertex of polyline: ("
                  << prev_seg_boundary_id << ") and\nfirst vertex of polyline ("
                  << bound << ").\n"
                  << "This should have failed when first trying to construct"
                  << " the polygon.\n";
                throw OomphLibError(error_stream.str(),
                                    OOMPH_CURRENT_FUNCTION,
                                    OOMPH_EXCEPTION_LOCATION);
              }
            }
            else
            {
              // Reverse the current vector to line up with the previous one
              std::reverse(vector_vertex_node.begin(),
                           vector_vertex_node.end());
            }
          } // error

        } // if ( p > 0 )

      } // if (!this->is_mesh_distributed())

      // --------------------------------------------------------------------
      // Update the polylines representation
      // --------------------------------------------------------------------

      // Always update the polylines representation, in a distributed
      // mesh it is necessary to update the polyline representation since
      // it may no longer have vertices (the boundary may not be part of
      // the domain in the current processor)

      // The new nunber of vertices
      n_vertex = vector_vertex_node.size();

      // Now update the polyline according to the new vertices
      TriangleMeshPolyLine* tmp_polyline_pt =
        new TriangleMeshPolyLine(vector_vertex_node, bound);

      // Create a temporal "curve section" version of the recently
      // created polyline
      TriangleMeshCurveSection* tmp_curve_section_pt = tmp_polyline_pt;

      // Tolerance below which the middle point can be deleted (ratio of
      // deflection to element length)
      double unrefinement_tolerance =
        polygon_pt->polyline_pt(p)->unrefinement_tolerance();

      // Tolerance to add points
      double refinement_tolerance =
        polygon_pt->polyline_pt(p)->refinement_tolerance();

      // Establish refinement and unrefinement tolerance
      tmp_polyline_pt->set_unrefinement_tolerance(unrefinement_tolerance);
      tmp_polyline_pt->set_refinement_tolerance(refinement_tolerance);

      // Establish the maximum length constraint
      double maximum_length = polygon_pt->polyline_pt(p)->maximum_length();
      tmp_polyline_pt->set_maximum_length(maximum_length);

#ifdef OOMPH_HAS_MPI
      // If the mesh is distributed check that the polyline still has
      // vertices
      if (this->is_mesh_distributed())
      {
        if (n_vertex >= 2)
        {
          // Pass the connection information from the old polyline to the
          // new one
          this->copy_connection_information(polygon_pt->polyline_pt(p),
                                            tmp_curve_section_pt);
        } // if (n_vertex >= 2)
      } // if (this->is_mesh_distributed())
      else
#endif
      {
        // Pass the connection information from the old polyline to the
        // new one
        this->copy_connection_information(polygon_pt->polyline_pt(p),
                                          tmp_curve_section_pt);
      }

      // Now update the polyline according to the new vertices but first
      // check if the object is allowed to delete the representation or
      // if it should be done by other object
      bool delete_it_on_destructor = false;

      std::set<TriangleMeshCurveSection*>::iterator it =
        this->Free_curve_section_pt.find(polygon_pt->curve_section_pt(p));

      if (it != this->Free_curve_section_pt.end())
      {
        this->Free_curve_section_pt.erase(it);
        delete polygon_pt->curve_section_pt(p);
        delete_it_on_destructor = true;
      }

      // -------------------------------------------------------
      // Copying the new representation
      polygon_pt->curve_section_pt(p) = tmp_polyline_pt;

      // Update the Boundary - Polyline map
      this->Boundary_curve_section_pt[bound] = polygon_pt->curve_section_pt(p);

      if (delete_it_on_destructor)
      {
        this->Free_curve_section_pt.insert(polygon_pt->curve_section_pt(p));
      }

#ifdef OOMPH_HAS_MPI
      // --------- Stuff for the sub_boundaries ----- Begin section --------
      // Verify if need to deal with sub_boundaries
      if (this->is_mesh_distributed() && nsub_boundaries > 1)
      {
        // Create temporary representations for the boundaries, only to
        // create the mesh when calling Triangle

        // Clear all previous stored data
        this->Boundary_subpolylines[bound].clear();

        // Create storage for the sub-boundaries
        this->Boundary_subpolylines[bound].resize(nsub_boundaries);
        for (unsigned isub = 0; isub < nsub_boundaries; isub++)
        {
          // Update the polyline according to the sub set of vertices,
          TriangleMeshPolyLine* sub_tmp_polyline_pt =
            new TriangleMeshPolyLine(sub_vector_vertex_node[isub], bound, isub);

          // Add the sub-polyline to the container to represent the
          // boundary in parts
          this->Boundary_subpolylines[bound][isub] = sub_tmp_polyline_pt;

          // No need to send the unrefinement/refinement and maximum
          // length constraints since these are only temporary
          // representations. These polylines can be deleted once the new
          // polygons that represent the distributed domain have been
          // created

        } // for (isub < nsub_boundaries)

      } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
      // --------- Stuff for the sub_boundaries ----- End section ---------
#endif // OOMPH_HAS_MPI

      // Delete the allocated memory for the geometric object that
      // represents the boundary
      delete mesh_geom_obj_pt;

    } // for (p < n_polyline)

    // Cleanup the face mesh
    for (unsigned p = 0; p < n_polyline; p++)
    {
      face_mesh_pt[p]->flush_node_storage();
      delete face_mesh_pt[p];
    }

    return update_was_performed;
  }

  //======================================================================
  /// Updates the open curve but using the elements area instead
  /// of the default refinement and unrefinement methods
  //======================================================================
  template<class ELEMENT>
  bool RefineableTriangleMesh<ELEMENT>::update_open_curve_using_elements_area(
    TriangleMeshOpenCurve*& open_curve_pt, const Vector<double>& target_area)
  {
    // Verify if there was a change on the open curve representation
    unsigned update_was_performed = false;

    const unsigned nele = this->nelement();

    // - Get the vertices along the boundaries and for each element identify
    //   its associated target error.
    //   - Get face mesh representation of each polyline.
    //   - Get the vertices with the help of face elements.
    //   - Find the global index in the mesh of the face element
    //     and use it to get its associated target area.

    // Get the face mesh representation
    Vector<Mesh*> face_mesh_pt;
    get_face_mesh_representation(open_curve_pt, face_mesh_pt);

    // Create vertices of the polylines by using the vertices of the
    // FaceElements
    Vector<double> vertex_coord(3); // zeta,x,y
    Vector<double> bound_left(1);
    Vector<double> bound_right(1);

    const unsigned ncurve_section = open_curve_pt->ncurve_section();

    // Go for each curve section
    for (unsigned cs = 0; cs < ncurve_section; cs++)
    {
      // Get the MeshAsGeomObject representation just once per polyline,
      // this object is only used by the
      // refine_boundary_constrained_by_target_area() method. We get it
      // here to ensure that all processors (in a distributed context)
      // get this representation just once, and because an AllToAll MPI
      // communication is used in this calling
      MeshAsGeomObject* mesh_geom_obj_pt =
        new MeshAsGeomObject(face_mesh_pt[cs]);

      // Get the boundary id
      const unsigned bound = open_curve_pt->curve_section_pt(cs)->boundary_id();

      // Get the chunk number
      const unsigned chunk =
        open_curve_pt->curve_section_pt(cs)->boundary_chunk();

      /// Use a vector of vector for vertices and target areas to deal
      /// with the cases when the boundaries are split by the
      /// distribution process. Internal boundaries may be completely or
      /// partially overlapped by shared boundaries

      // Loop over the face elements and add their vertices (they are
      // automatically sorted because of the set)
      const unsigned nface_element = face_mesh_pt[cs]->nelement();

      // Store the non halo elements and the element at the other side of
      // the boundary (whatever it be halo or not), the first will be the
      // ones from which we will get the vertices (in even position)
      Vector<FiniteElement*> non_halo_doubled_face_element_pt;

      // Map to store the index of the face element on a boundary
      std::map<FiniteElement*, unsigned> face_element_index_on_boundary;

      // Map to know the already sorted face elements
      std::map<FiniteElement*, bool> face_element_done;

      for (unsigned ef = 0; ef < nface_element; ++ef)
      {
        FiniteElement* ele_face_pt = face_mesh_pt[cs]->finite_element_pt(ef);

        // Skip the halo elements (not used as base elements, only
        // include those elements whose element at the other side of the
        // boundary is non halo)
#ifdef OOMPH_HAS_MPI
        if (this->is_mesh_distributed())
        {
          // Only work with non-halo elements
          if (ele_face_pt->is_halo())
          {
            continue;
          }
        }
#endif

        // Check if not already done
        if (!face_element_done[ele_face_pt])
        {
          // Add the element and look for the element at the other side
          // of the boundary to add it immediately after the new added
          // element
          non_halo_doubled_face_element_pt.push_back(ele_face_pt);
          // Create the map of the face element with the index
          face_element_index_on_boundary[ele_face_pt] = ef;
          // Mark the current element as done
          face_element_done[ele_face_pt] = true;
          // Get the number of nodes
          const unsigned nnodes = ele_face_pt->nnode();
          // Get the left and right node to look for the elements at the
          // other side of the boundary
          Node* left_node_pt = ele_face_pt->node_pt(0);
          Node* right_node_pt = ele_face_pt->node_pt(nnodes - 1);
#ifdef PARANOID
          // Flag to know if the element at the other side of the
          // boundary was found
          bool found_other_side_face_ele = false;
#endif
          for (unsigned iface = 0; iface < nface_element; iface++)
          {
            // Get the candidate face element
            FiniteElement* cele_face_pt =
              face_mesh_pt[cs]->finite_element_pt(iface);
            // Check if not already done
            if (!face_element_done[cele_face_pt])
            {
              Node* cleft_node_pt = cele_face_pt->node_pt(0);
              Node* cright_node_pt = cele_face_pt->node_pt(nnodes - 1);
              // Check if the nodes are the same
              if ((left_node_pt == cleft_node_pt &&
                   right_node_pt == cright_node_pt) ||
                  (left_node_pt == cright_node_pt &&
                   right_node_pt == cleft_node_pt))
              {
                // Add the element to the storage
                non_halo_doubled_face_element_pt.push_back(cele_face_pt);
                // ... and mark the element as done
                face_element_done[cele_face_pt] = true;
                // Create the map of the face element with the index
                face_element_index_on_boundary[cele_face_pt] = iface;
#ifdef PARANOID
                // Set the flag of found other side face element
                found_other_side_face_ele = true;
#endif
                break;
              }
            }
          } // (iface < nface_element)

#ifdef PARANOID
          if (!found_other_side_face_ele)
          {
            std::ostringstream error_message;
            error_message
              << "The face element at the other side of the boundary (" << bound
              << ") was not found!!\n"
              << "These are the nodes of the face element:\n"
              << "(" << left_node_pt->x(0) << ", " << left_node_pt->x(1) << ") "
              << "and (" << right_node_pt->x(0) << "," << right_node_pt->x(1)
              << ")\n\n";
            throw OomphLibError(
              error_message.str(),
              "RefineableTriangleMesh::update_open_curve_using_elements_area()",
              OOMPH_EXCEPTION_LOCATION);
          }
#endif
        } // if (!face_ele_done[ele_face_pt])

      } // (ef < nface_element)

      // Clear the map of the already done face elements
      // This will be used to help sorting the face elements
      face_element_done.clear();

      // Set of coordinates that are on the boundary
      // The entries are sorted on first entry in vector which stores
      // the boundary coordinate so the vertices come out in order!
      std::set<Vector<double>> vertex_nodes;

      // Vector to store the vertices, transfer the sorted vertices from the
      // set to this vector, --- including the z-value ---
      Vector<Vector<double>> tmp_vector_vertex_node;

      // Vector to store the coordinates of the polylines, same as the
      // tmp_vector_vertex_node vector (after adding more nodes) but
      // --- without the z-value ---, used to re-generate the polylines
      Vector<Vector<double>> vector_vertex_node;

#ifdef OOMPH_HAS_MPI
      // Indicates if the set of vertices give rise to a internal
      // boundary that will be used as shared boundary or as normal
      // internal boundary -- Only used to deal with internal boundaries
      // in a distributed scheme
      std::vector<bool> internal_to_shared_boundary;

      // --------- Stuff to deal with splitted boundaries ---------- Begin -----
      // Set of coordinates that are on the boundary (splitted boundary version)
      // The first vector is used to allocate the points for each sub-boundary
      // Set entries are ordered on first entry in vector which stores
      // the boundary coordinate so the vertices come out in order!
      Vector<std::set<Vector<double>>> sub_vertex_nodes;

      // Vector to store the vertices, transfer the sorted vertices from the
      // set (sub_vertex_nodes) to this vector, --- including the z-value ---
      Vector<Vector<Vector<double>>> sub_tmp_vector_vertex_node;

      // Vector to store the coordinates of the polylines that will represent
      // the splitted boundary. Used to pass the info. from sub_vertex_nodes
      // but --- without the z-value ---, used to generate the sub-polylines
      Vector<Vector<Vector<double>>> sub_vector_vertex_node;

      // --------- Stuff to deal with splitted boundaries ----------- End ------

#endif // #ifdef OOMPH_HAS_MPI

      // Sort the face element, those that have both elements (one at
      // each side of the boundary) marked as nonhalo, and those with one
      // nonhalo an the other as halo

      // Number of done face elements
      unsigned nsorted_face_elements = 0;

#ifdef OOMPH_HAS_MPI
      // Counter for sub_boundaries
      unsigned nsub_boundaries = 0;
#endif // #ifdef OOMPH_HAS_MPI

      // Total number of non halo double face element
      const unsigned nnon_halo_doubled_face_ele =
        non_halo_doubled_face_element_pt.size();

      // Continue until all the face elements have been sorted
      // This while is to deal with the cases of splitted boundaries
      while (nsorted_face_elements < nnon_halo_doubled_face_ele)
      {
        // Get and initial face element
        FiniteElement* ele_face_pt = 0;
        FiniteElement* repeated_ele_face_pt = 0;
#ifdef PARANOID
        bool found_initial_face_element = false;
#endif

        // Flag to know if we are working with a face element which the
        // face element at the other side of the boundary is also non
        // halo
        bool both_root_face_elements_are_nonhalo = false;

        unsigned iface = 0;
        for (iface = 0; iface < nnon_halo_doubled_face_ele; iface += 2)
        {
          ele_face_pt = non_halo_doubled_face_element_pt[iface];
          // If not done then take it as initial face element
          if (!face_element_done[ele_face_pt])
          {
            // Mark it as done
            face_element_done[ele_face_pt] = true;
            // Get the other side boundary face element
            repeated_ele_face_pt = non_halo_doubled_face_element_pt[iface + 1];
            // ... also mark as done the repeated face element
            face_element_done[repeated_ele_face_pt] = true;

#ifdef OOMPH_HAS_MPI
            if (!repeated_ele_face_pt->is_halo())
            {
              both_root_face_elements_are_nonhalo = true;
            }
#endif // #ifdef OOMPH_HAS_MPI

            // Plus two because internal boundaries have
            // two face elements per each edge
            nsorted_face_elements += 2;
            iface += 2;
#ifdef PARANOID
            // And set the flag to true
            found_initial_face_element = true;
#endif
            break;
          }
        }

#ifdef PARANOID
        if (!found_initial_face_element)
        {
          std::ostringstream error_message;
          error_message << "Could not find an initial face element for the "
                           "current segment\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // Local set of coordinates that are on the boundary Set entries
        // are ordered on first entry in vector which stores the boundary
        // coordinate so the vertices come out in order
        std::set<Vector<double>> local_vertex_nodes;

        // Vector to store the vertices, transfer the sorted vertices from the
        // set (local) to this vector (local), --- including the z-value ---
        Vector<Vector<double>> local_tmp_vector_vertex_node;

        // Vector to store the target areas, uses the same approach as the
        // set for the local_vertex_nodes, ordered on first entry
        std::set<Vector<double>> sorted_target_areas;

        // Vector to store the target areas, used to transfer the sorted target
        // areas from "sorted_target_areas" set
        Vector<double> tmp_sorted_target_areas;

        // ------------------------------------------------------------------
        // Add the vertices of the initial face element to the set of local
        // sorted vertices
        // ------------------------------------------------------------------
        const unsigned nnode = ele_face_pt->nnode();
        // Add the left-hand node to the set:
        // Boundary coordinate
        ele_face_pt->node_pt(0)->get_coordinates_on_boundary(bound, bound_left);
        vertex_coord[0] = bound_left[0];

        // Actual coordinates
        for (unsigned i = 0; i < 2; i++)
        {
          vertex_coord[i + 1] = ele_face_pt->node_pt(0)->x(i);
        }
        local_vertex_nodes.insert(vertex_coord);

        // Add the right-hand node to the set:
        // Boundary coordinate
        ele_face_pt->node_pt(nnode - 1)->get_coordinates_on_boundary(
          bound, bound_right);
        vertex_coord[0] = bound_right[0];

        // Actual coordinates
        for (unsigned i = 0; i < 2; i++)
        {
          vertex_coord[i + 1] = ele_face_pt->node_pt(nnode - 1)->x(i);
        }
        local_vertex_nodes.insert(vertex_coord);

        // The initial and final node on the set
        Node* first_node_pt = ele_face_pt->node_pt(0);
        Node* last_node_pt = ele_face_pt->node_pt(nnode - 1);

        // -----------------------------------------------------
        // Find the global index in the mesh of the face element
        // and use it to get its associated target area
        // -----------------------------------------------------
        // Container to store the zeta value (used as index) and
        // the associated target area of the element
        Vector<double> zeta_target_area_values(2);

        // Use the minimum zeta value to sort the target areas
        // along the boundary
        zeta_target_area_values[0] = std::min(bound_left[0], bound_right[0]);

        // Get the index of the face element on the current boundary
        const unsigned ef = face_element_index_on_boundary[ele_face_pt];
        // Get the "ef"-th element on the boundary
        FiniteElement* el_pt = this->boundary_element_pt(bound, ef);
        double target_area_face_element = 0.0;

#ifdef PARANOID
        bool found_global_element_index = false;
#endif
        for (unsigned eg = 0; eg < nele; eg++)
        {
          // Get the "eg-th" element
          FiniteElement* el_compare_pt = this->finite_element_pt(eg);

          // Compare with the element on the boundary, if equal then
          // store the target area
          if (el_pt == el_compare_pt)
          {
            target_area_face_element = target_area[eg];
#ifdef PARANOID
            found_global_element_index = true;
#endif
            break; // break the for (eg < nele) global element
          } // if el_pt == el_compare_pt
        } // for nele (on complete mesh)

#ifdef PARANOID
        if (!found_global_element_index)
        {
          std::ostringstream error_message;
          error_message << "The global index for the (" << ef
                        << ")-th face element "
                        << "on\nthe (" << bound
                        << ")-th boundary was not found!!!";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // Get the index of the repeated face element on the current boundary
        const unsigned ref =
          face_element_index_on_boundary[repeated_ele_face_pt];
        FiniteElement* rel_pt = this->boundary_element_pt(bound, ref);
        double target_area_repeated_face_element = 0.0;

#ifdef PARANOID
        bool found_global_repeated_element_index = false;
#endif
        for (unsigned eg = 0; eg < nele; eg++)
        {
          // Get the "eg-th" element
          FiniteElement* el_compare_pt = this->finite_element_pt(eg);

          // Compare with the element on the boundary, if equal then
          // store the target area
          if (rel_pt == el_compare_pt)
          {
            target_area_repeated_face_element = target_area[eg];
#ifdef PARANOID
            found_global_repeated_element_index = true;
#endif
            break; // break the for (eg < nele) global element
          } // if rel_pt == el_compare_pt
        } // for nele (on complete mesh)

#ifdef PARANOID
        if (!found_global_repeated_element_index)
        {
          std::ostringstream error_message;
          error_message << "The global index for the (" << ref
                        << ")-th face element "
                        << "on\nthe (" << bound
                        << ")-th boundary was not found (repeated "
                        << "face element)!!!";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // Choose the minimum target area from both elements, one at each side
        // of the edge on the boundary
        zeta_target_area_values[1] =
          std::min(target_area_face_element, target_area_repeated_face_element);

        // Add the target areas to the sorted set
        sorted_target_areas.insert(zeta_target_area_values);
        // ------------------------------------------------------------------

        // Continue iterating if a new face element has been added to the
        // list
        bool face_element_added = false;

        // While a new face element has been added to the set of sorted
        // face elements then re-iterate
        do
        {
          // Start from the next face elements since we have already
          // added the previous one as the initial face element (any
          // previous face element had to be added on previous
          // iterations)
          for (unsigned iiface = iface; iiface < nnon_halo_doubled_face_ele;
               iiface += 2)
          {
            face_element_added = false;
            ele_face_pt = non_halo_doubled_face_element_pt[iiface];

            // Check that the face element with which we are working has
            // the same conditions as the root face element (both faces
            // are nonhalo or one face is halo and the other nonhalo)

            // Get the face element at the other side of the boundary
            repeated_ele_face_pt = non_halo_doubled_face_element_pt[iiface + 1];
            bool both_face_elements_are_nonhalo = false;

#ifdef OOMPH_HAS_MPI
            if (!repeated_ele_face_pt->is_halo())
            {
              both_face_elements_are_nonhalo = true;
            }
#endif // #ifdef OOMPH_HAS_MPI

            if (!face_element_done[ele_face_pt] &&
                (both_face_elements_are_nonhalo ==
                 both_root_face_elements_are_nonhalo))
            {
              // Get each individual node to check if they are contiguous
              const unsigned nlnode = ele_face_pt->nnode();
              Node* left_node_pt = ele_face_pt->node_pt(0);
              Node* right_node_pt = ele_face_pt->node_pt(nlnode - 1);

              if (left_node_pt == first_node_pt)
              {
                first_node_pt = right_node_pt;
                face_element_added = true;
              }
              else if (left_node_pt == last_node_pt)
              {
                last_node_pt = right_node_pt;
                face_element_added = true;
              }
              else if (right_node_pt == first_node_pt)
              {
                first_node_pt = left_node_pt;
                face_element_added = true;
              }
              else if (right_node_pt == last_node_pt)
              {
                last_node_pt = left_node_pt;
                face_element_added = true;
              }

              if (face_element_added)
              {
                // Add the left-hand node to the set:
                // Boundary coordinate
                left_node_pt->get_coordinates_on_boundary(bound, bound_left);
                vertex_coord[0] = bound_left[0];

                // Actual coordinates
                for (unsigned i = 0; i < 2; i++)
                {
                  vertex_coord[i + 1] = left_node_pt->x(i);
                }
                local_vertex_nodes.insert(vertex_coord);

                // Add the right-hand nodes to the set:
                // Boundary coordinate
                right_node_pt->get_coordinates_on_boundary(bound, bound_right);
                vertex_coord[0] = bound_right[0];

                // Actual coordinates
                for (unsigned i = 0; i < 2; i++)
                {
                  vertex_coord[i + 1] = right_node_pt->x(i);
                }
                local_vertex_nodes.insert(vertex_coord);

                // Mark as done only if one of its nodes has been
                // added to the list
                face_element_done[ele_face_pt] = true;
                // .. also mark as done the face element at the othe side of
                // the boundary
                repeated_ele_face_pt =
                  non_halo_doubled_face_element_pt[iiface + 1];
                face_element_done[repeated_ele_face_pt] = true;
                // ... and increase the number of sorted face elements
                nsorted_face_elements += 2;

                // -----------------------------------------------------
                // Find the global index in the mesh of the face element
                // and use it to get its associated target area
                // -----------------------------------------------------
                // Use the minimum zeta value to sort the target areas
                // along the boundary
                zeta_target_area_values[0] =
                  std::min(bound_left[0], bound_right[0]);

                // Get the "ef"-th element on the boundary
                const unsigned lef =
                  face_element_index_on_boundary[ele_face_pt];
                FiniteElement* lel_pt = this->boundary_element_pt(bound, lef);

#ifdef PARANOID
                found_global_element_index = false;
#endif
                for (unsigned eg = 0; eg < nele; eg++)
                {
                  // Get the "eg-th" element
                  FiniteElement* lel_compare_pt = this->finite_element_pt(eg);

                  // Compare with the element on the boundary, if equal then
                  // store the target area
                  if (lel_pt == lel_compare_pt)
                  {
                    target_area_face_element = target_area[eg];
#ifdef PARANOID
                    found_global_element_index = true;
#endif
                    break; // break the for (eg < nele) global element
                  } // if lel_pt == lel_compare_pt
                } // for nele (on complete mesh)

#ifdef PARANOID
                if (!found_global_element_index)
                {
                  std::ostringstream error_message;
                  error_message << "The global index for the (" << lef
                                << ")-th face element "
                                << "on\nthe (" << bound
                                << ")-th boundary was not found!!!";
                  throw OomphLibError(error_message.str(),
                                      OOMPH_CURRENT_FUNCTION,
                                      OOMPH_EXCEPTION_LOCATION);
                }
#endif

                // Get the index of the repeated face element on the boundary
                const unsigned rlef =
                  face_element_index_on_boundary[repeated_ele_face_pt];
                FiniteElement* rlel_pt = this->boundary_element_pt(bound, rlef);

#ifdef PARANOID
                found_global_repeated_element_index = false;
#endif
                for (unsigned eg = 0; eg < nele; eg++)
                {
                  // Get the "eg-th" element
                  FiniteElement* lel_compare_pt = this->finite_element_pt(eg);

                  // Compare with the element on the boundary, if equal then
                  // store the target area
                  if (rlel_pt == lel_compare_pt)
                  {
                    target_area_repeated_face_element = target_area[eg];
#ifdef PARANOID
                    found_global_repeated_element_index = true;
#endif
                    break; // break the for (eg < nele) global element
                  } // if rlel_pt == el_compare_pt
                } // for nele (on complete mesh)

#ifdef PARANOID
                if (!found_global_repeated_element_index)
                {
                  std::ostringstream error_message;
                  error_message << "The global index for the (" << rlef
                                << ")-th face element "
                                << "on\nthe (" << bound
                                << ")-th boundary was not found "
                                << "(repeated face element)!!!";
                  throw OomphLibError(error_message.str(),
                                      OOMPH_CURRENT_FUNCTION,
                                      OOMPH_EXCEPTION_LOCATION);
                }
#endif

                // Choose the minimum target area from both elements, one
                // at each side of the edge on the boundary
                zeta_target_area_values[1] = std::min(
                  target_area_face_element, target_area_repeated_face_element);

                // Add the target areas to the sorted set
                sorted_target_areas.insert(zeta_target_area_values);

                break;
              }

            } // if (!face_element_done[[ele_face_pt])
          } // for (iiface<nnon_halo_doubled_face_ele)
        } while (face_element_added &&
                 (nsorted_face_elements < nnon_halo_doubled_face_ele));

        // -------------------------------------------------------------
        // At this point we already have a sorted set of nodes and can
        // be used to peform the unrefinement and refinement procedures
        // -------------------------------------------------------------

        // Get the number of nodes on the list
        const unsigned nlocal_nodes = local_vertex_nodes.size();
        // Change representation to vector for easy of handling ...
        local_tmp_vector_vertex_node.resize(nlocal_nodes);

        // Copy the vertices of the nodes
        unsigned counter = 0;
        std::set<Vector<double>>::iterator it_vertex;
        for (it_vertex = local_vertex_nodes.begin();
             it_vertex != local_vertex_nodes.end();
             it_vertex++)
        {
          local_tmp_vector_vertex_node[counter].resize(3);
          local_tmp_vector_vertex_node[counter][0] = (*it_vertex)[0];
          local_tmp_vector_vertex_node[counter][1] = (*it_vertex)[1];
          local_tmp_vector_vertex_node[counter][2] = (*it_vertex)[2];
          counter++;
        }

        // ... same for the info. related with the target areas (turn
        // into vector)
        const unsigned ntarget_areas = sorted_target_areas.size();
        tmp_sorted_target_areas.resize(ntarget_areas);
        counter = 0;
        std::set<Vector<double>>::iterator it_area;
        for (it_area = sorted_target_areas.begin();
             it_area != sorted_target_areas.end();
             ++it_area)
        {
          tmp_sorted_target_areas[counter] = (*it_area)[1];
          ++counter;
        }

#ifdef PARANOID
        if (nlocal_nodes > 0 && (ntarget_areas != nlocal_nodes - 1))
        {
          std::ostringstream error_message;
          error_message
            << "The boundary (" << bound << ") was split during the "
            << "distribution process.\n"
            << "The problem comes when associating the target areas with the "
            << "elements that gave\nrise to the vertex coordinates.\n"
            << "The number of local nodes on the 'sub-polyline' ("
            << nlocal_nodes << ") is not according with the number of target\n"
            << "areas (" << ntarget_areas << ") for that number of nodes.\n"
            << "The target areas number must be equal to the number of "
               "nodes-1\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // The unrefinement and refinement process needs to be applied
        // from the bottom-left node since the internal open curve could
        // lie on the shared boundaries
        if (local_tmp_vector_vertex_node[nlocal_nodes - 1][2] <
            local_tmp_vector_vertex_node[0][2])
        {
          std::reverse(local_tmp_vector_vertex_node.begin(),
                       local_tmp_vector_vertex_node.end());
          std::reverse(tmp_sorted_target_areas.begin(),
                       tmp_sorted_target_areas.end());
        }
        else if (local_tmp_vector_vertex_node[nlocal_nodes - 1][2] ==
                 local_tmp_vector_vertex_node[0][2])
        {
          if (local_tmp_vector_vertex_node[nlocal_nodes - 1][1] <
              local_tmp_vector_vertex_node[0][1])
          {
            std::reverse(local_tmp_vector_vertex_node.begin(),
                         local_tmp_vector_vertex_node.end());
            std::reverse(tmp_sorted_target_areas.begin(),
                         tmp_sorted_target_areas.end());
          }
        }

        // ------------------------------------------------------------
        // Create the vertices along the boundary using the target
        // area to define the distance among them
        // ------------------------------------------------------------

        // Tolerance below which the middle point can be deleted
        // (ratio of deflection to element length)
        double unrefinement_tolerance =
          open_curve_pt->polyline_pt(cs)->unrefinement_tolerance();

        // Apply unrefinement
        bool unrefinement_applied =
          unrefine_boundary_constrained_by_target_area(
            bound,
            chunk,
            local_tmp_vector_vertex_node,
            unrefinement_tolerance,
            tmp_sorted_target_areas);

        // Tolerance for refinement
        double refinement_tolerance =
          open_curve_pt->polyline_pt(cs)->refinement_tolerance();

        // Apply refinement
        bool refinement_applied = refine_boundary_constrained_by_target_area(
          mesh_geom_obj_pt,
          local_tmp_vector_vertex_node,
          refinement_tolerance,
          tmp_sorted_target_areas);

        // Clear the local containter to recover the nodes ordered using
        // the zeta value
        local_vertex_nodes.clear();

        // At the end of each unrefinement/refinement step store the new
        // nodes on the set that will give rise to the vertices of the
        // new polyline representation
        const unsigned nnew_nodes = local_tmp_vector_vertex_node.size();
        for (unsigned i = 0; i < nnew_nodes; i++)
        {
          vertex_coord[0] = local_tmp_vector_vertex_node[i][0];
          vertex_coord[1] = local_tmp_vector_vertex_node[i][1];
          vertex_coord[2] = local_tmp_vector_vertex_node[i][2];
          vertex_nodes.insert(vertex_coord); // Global container
          local_vertex_nodes.insert(vertex_coord);
        }

        // Update the flag to indicate whether an unrefinement or
        // refinement was applied
        update_was_performed = (unrefinement_applied || refinement_applied);

#ifdef OOMPH_HAS_MPI
        if (this->is_mesh_distributed())
        {
          // Add the set of vertices for the boundary, this will help to
          // detect if we need to deal with sub_boundaries and
          // sub_polylines representations
          sub_vertex_nodes.push_back(local_vertex_nodes);
          // Increase the counter for sub_boundaries
          nsub_boundaries++;

          // Mark if the polyline created by these vertices will be used
          // as a shared boundary or as an internal boundary
          if (both_root_face_elements_are_nonhalo)
          {
            internal_to_shared_boundary.push_back(false);
          }
          else
          {
            internal_to_shared_boundary.push_back(true);
          }
        }
#endif

      } // while(nsorted_face_elements < nnon_halo_doubled_face_ele)
        // This while is in charge of sorting all the face elements to
        // create the new representation of the polyline (also deals
        // with the sub-boundary cases)

      // Now turn into vector for ease of handling...
      const unsigned npoly_vertex = vertex_nodes.size();
      tmp_vector_vertex_node.resize(npoly_vertex);
      unsigned count = 0;
      for (std::set<Vector<double>>::iterator it = vertex_nodes.begin();
           it != vertex_nodes.end();
           ++it)
      {
        tmp_vector_vertex_node[count].resize(3);
        tmp_vector_vertex_node[count][0] = (*it)[0];
        tmp_vector_vertex_node[count][1] = (*it)[1];
        tmp_vector_vertex_node[count][2] = (*it)[2];
        ++count;
      }

#ifdef OOMPH_HAS_MPI
      // Check that the number of set of vertices marked to be part of a
      // shared boundary or of an internal boundaries be the same as the
      // total number of sub-boundaries
#ifdef PARANOID
      const unsigned nsub_boundaries_set = sub_vertex_nodes.size();
      const unsigned ninternal_to_shared_boundaries =
        internal_to_shared_boundary.size();
      if (nsub_boundaries_set != ninternal_to_shared_boundaries)
      {
        std::ostringstream error_message;
        error_message
          << "The number of found sub-boundaries and the number of marked "
          << "internal\nboundaries are different\n"
          << "Number of found sub-boundaries: (" << nsub_boundaries_set << ")\n"
          << "Number of marked internal boundaries: ("
          << ninternal_to_shared_boundaries << ")\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // --------- Stuff for the sub_boundaries ----- Begin section -------
#ifdef PARANOID
      if (nsub_boundaries_set != nsub_boundaries)
      {
        std::ostringstream error_message;
        error_message
          << "The number of found sub-boundaries and the number of counted\n"
          << "sub-boundaries are different:\n"
          << "Number of found sub-boundaries: (" << nsub_boundaries_set << ")\n"
          << "Number of counted sub-boundaries: (" << nsub_boundaries
          << ")\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Verify if need to deal with sub_boundaries
      if (this->is_mesh_distributed() && nsub_boundaries > 1)
      {
        // Mark the boundary as been splitted in the partition process
        this->Boundary_was_splitted[bound] = true;

        // Resize the vector to store the info. of sub-boundaries
        sub_tmp_vector_vertex_node.resize(nsub_boundaries);
        // Loop over the sub-boundaries
        for (unsigned isub = 0; isub < nsub_boundaries; isub++)
        {
          // Turn info. into vector for ease of handling...
          const unsigned nsubpoly_vertex = sub_vertex_nodes[isub].size();
          sub_tmp_vector_vertex_node[isub].resize(nsubpoly_vertex);
          unsigned subcount = 0;
          std::set<Vector<double>>::iterator subit;
          for (subit = sub_vertex_nodes[isub].begin();
               subit != sub_vertex_nodes[isub].end();
               ++subit)
          {
            sub_tmp_vector_vertex_node[isub][subcount].resize(3);
            sub_tmp_vector_vertex_node[isub][subcount][0] = (*subit)[0];
            sub_tmp_vector_vertex_node[isub][subcount][1] = (*subit)[1];
            sub_tmp_vector_vertex_node[isub][subcount][2] = (*subit)[2];
            ++subcount;
          }
        }
      } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
      // --------- Stuff for the sub_boundaries ----- End section ----------
#endif // OOMPH_HAS_MPI

      // For further processing the three-dimensional vector has to be
      // reduced to a two-dimensional vector
      unsigned n_vertex = tmp_vector_vertex_node.size();

      // Resize the vector for vectices
      vector_vertex_node.resize(n_vertex);
      for (unsigned i = 0; i < n_vertex; i++)
      {
        vector_vertex_node[i].resize(2);
        vector_vertex_node[i][0] = tmp_vector_vertex_node[i][1];
        vector_vertex_node[i][1] = tmp_vector_vertex_node[i][2];
      }

#ifdef OOMPH_HAS_MPI
      // --------- Stuff for the sub_boundaries ----- Begin section -------
      // Verify if need to deal with sub_boundaries
      if (this->is_mesh_distributed() && nsub_boundaries > 1)
      {
        // For further processing the three-dimensional vector has to be
        // reduced to a two-dimensional vector
        // Resize the vector to store the info. of sub-boundaries
        sub_vector_vertex_node.resize(nsub_boundaries);
        for (unsigned isub = 0; isub < nsub_boundaries; isub++)
        {
          const unsigned subn_vertex = sub_tmp_vector_vertex_node[isub].size();
          // Resize the vector for vectices
          sub_vector_vertex_node[isub].resize(subn_vertex);
          for (unsigned i = 0; i < subn_vertex; i++)
          {
            sub_vector_vertex_node[isub][i].resize(2);
            sub_vector_vertex_node[isub][i][0] =
              sub_tmp_vector_vertex_node[isub][i][1];
            sub_vector_vertex_node[isub][i][1] =
              sub_tmp_vector_vertex_node[isub][i][2];
          }
        }
      } // if (this->is_mesh_distributed() && nsub_boundaries > 1)

      // We already have the info. for the sub-boundaries (if necessary)
      // and then we can create the sub-boundaries representations to
      // ease the generation of the mesh by Triangle

      // --------- Stuff for the sub_boundaries ----- End section ---------
#endif // OOMPH_HAS_MPI

      // ------------------------------------------------------------------
      // Check for contiguousness
      // ------------------------------------------------------------------
#ifdef OOMPH_HAS_MPI
      // Only perform this checking if the mesh is not distributed When
      // the mesh is distributed the polylines continuity is addressed by
      // the sort_polylines_helper() method
      if (!this->is_mesh_distributed())
#endif
      {
        if (cs > 0)
        {
          // Final end point of previous line
          Vector<double> final_vertex_of_previous_segment;
          unsigned n_prev_vertex =
            open_curve_pt->curve_section_pt(cs - 1)->nvertex();
          final_vertex_of_previous_segment =
            open_curve_pt->polyline_pt(cs - 1)->vertex_coordinate(
              n_prev_vertex - 1);

          unsigned prev_seg_boundary_id =
            open_curve_pt->curve_section_pt(cs - 1)->boundary_id();

          // Find the error between the final vertex of the previous
          // line and the first vertex of the current line
          double error = 0.0;
          for (unsigned i = 0; i < 2; i++)
          {
            const double dist = final_vertex_of_previous_segment[i] -
                                (*vector_vertex_node.begin())[i];
            error += dist * dist;
          }
          error = sqrt(error);

          // If the error is bigger than the tolerance then
          // we probably need to reverse, but better check
          if (error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
          {
            // Find the error between the final vertex of the previous
            // line and the last vertex of the current line
            double rev_error = 0.0;
            for (unsigned i = 0; i < 2; i++)
            {
              const double dist = final_vertex_of_previous_segment[i] -
                                  (*--vector_vertex_node.end())[i];
              rev_error += dist * dist;
            }
            rev_error = sqrt(rev_error);

            if (rev_error >
                ToleranceForVertexMismatchInPolygons::Tolerable_error)
            {
              // It could be possible that the first segment be reversed and we
              // did not notice it because this check does not apply for the
              // first segment. We can verify if the first segment is reversed
              // by using the vertex number 1
              if (cs == 1)
              {
                // Initial end point of previous line
                Vector<double> initial_vertex_of_previous_segment;

                initial_vertex_of_previous_segment =
                  open_curve_pt->polyline_pt(cs - 1)->vertex_coordinate(0);

                unsigned prev_seg_boundary_id =
                  open_curve_pt->curve_section_pt(cs - 1)->boundary_id();

                // Find the error between the initial vertex of the previous
                // line and the first vertex of the current line
                double error = 0.0;
                for (unsigned i = 0; i < 2; i++)
                {
                  const double dist = initial_vertex_of_previous_segment[i] -
                                      (*vector_vertex_node.begin())[i];
                  error += dist * dist;
                }
                error = sqrt(error); // Reversed only the previous one

                // If the error is bigger than the tolerance then
                // we probably need to reverse, but better check
                if (error >
                    ToleranceForVertexMismatchInPolygons::Tolerable_error)
                {
                  // Find the error between the final vertex of the previous
                  // line and the last vertex of the current line
                  double rev_error = 0.0;
                  for (unsigned i = 0; i < 2; i++)
                  {
                    const double dist = initial_vertex_of_previous_segment[i] -
                                        (*--vector_vertex_node.end())[i];
                    rev_error += dist * dist;
                  }
                  rev_error = sqrt(rev_error); // Reversed both the current
                                               // one and the previous one

                  if (rev_error >
                      ToleranceForVertexMismatchInPolygons::Tolerable_error)
                  {
                    std::ostringstream error_stream;
                    error_stream
                      << "The distance between the first node of the current\n"
                      << "line segment (boundary " << bound
                      << ") and either end of "
                      << "the previous line segment\n"
                      << "(boundary " << prev_seg_boundary_id
                      << ") is bigger than"
                      << " the desired tolerance "
                      << ToleranceForVertexMismatchInPolygons::Tolerable_error
                      << ".\n"
                      << "This suggests that the polylines defining the "
                         "polygonal\n"
                      << "representation are not properly ordered.\n"
                      << "Fail on last vertex of polyline: ("
                      << prev_seg_boundary_id
                      << ") and\nfirst vertex of polyline (" << bound
                      << ").\nThis should have failed when first trying to "
                      << "construct the\npolygon.\n";
                    throw OomphLibError(error_stream.str(),
                                        OOMPH_CURRENT_FUNCTION,
                                        OOMPH_EXCEPTION_LOCATION);
                  }
                  else
                  {
                    // Reverse both
                    // Reverse the current vector to line up with the previous
                    // one
                    std::reverse(vector_vertex_node.begin(),
                                 vector_vertex_node.end());
                    open_curve_pt->polyline_pt(cs - 1)->reverse();
                  }
                }
                else
                {
                  // Reverse the previous one
                  open_curve_pt->polyline_pt(cs - 1)->reverse();
                }

              } // if (cs == 1)
              else
              {
                std::ostringstream error_stream;
                error_stream
                  << "The distance between the first node of the current\n"
                  << "line segment (boundary " << bound
                  << ") and either end of "
                  << "the previous line segment\n"
                  << "(boundary " << prev_seg_boundary_id
                  << ") is bigger than the "
                  << "desired tolerance "
                  << ToleranceForVertexMismatchInPolygons::Tolerable_error
                  << ".\n"
                  << "This suggests that the polylines defining the polygonal\n"
                  << "representation are not properly ordered.\n"
                  << "Fail on last vertex of polyline: ("
                  << prev_seg_boundary_id << ") and\nfirst vertex of polyline ("
                  << bound << ").\n"
                  << "This should have failed when first trying to construct\n"
                  << "the polygon.\n";
                throw OomphLibError(error_stream.str(),
                                    OOMPH_CURRENT_FUNCTION,
                                    OOMPH_EXCEPTION_LOCATION);
              }
            }
            else
            {
              // Reverse the current vector to line up with the previous one
              std::reverse(vector_vertex_node.begin(),
                           vector_vertex_node.end());
            }
          }

        } // if (cs > 0)

      } // if (!this->is_mesh_distributed())

      // ---------------------------------------------------------------
      // Update the polylines representation
      // ---------------------------------------------------------------
      // Always update the polylines representation, in a distributed
      // mesh it is necessary to update the polyline representation since
      // it may no longer have vertices (the boundary may not be part of
      // the domain in the current processor)

      // The new number of vertices
      n_vertex = vector_vertex_node.size();

      // Update the polyline according to the new vertices
      TriangleMeshPolyLine* tmp_polyline_pt =
        new TriangleMeshPolyLine(vector_vertex_node, bound);

      // Create a temporal "curve section" version of the recently
      // created polyline
      TriangleMeshCurveSection* tmp_curve_section_pt = tmp_polyline_pt;

      // Tolerance below which the middle point can be deleted (ratio of
      // deflection to element length)
      double unrefinement_tolerance =
        open_curve_pt->polyline_pt(cs)->unrefinement_tolerance();

      // Tolerance to add points
      double refinement_tolerance =
        open_curve_pt->polyline_pt(cs)->refinement_tolerance();

      // Establish refinement and unrefinement tolerance
      tmp_polyline_pt->set_unrefinement_tolerance(unrefinement_tolerance);
      tmp_polyline_pt->set_refinement_tolerance(refinement_tolerance);

      // Establish the maximum length constraint
      double maximum_length = open_curve_pt->polyline_pt(cs)->maximum_length();
      tmp_polyline_pt->set_maximum_length(maximum_length);

#ifdef OOMPH_HAS_MPI
      // If the mesh is distributed check that the polyline still has
      // vertices
      if (this->is_mesh_distributed())
      {
        if (n_vertex >= 2)
        {
          // Pass the connection information from the old polyline to
          // the new one
          this->copy_connection_information(open_curve_pt->polyline_pt(cs),
                                            tmp_curve_section_pt);
        } // if (n_vertex >= 2)
      } // if (this->is_mesh_distributed())
      else
#endif
      {
        // Pass the connection information from the old polyline to the
        // new one
        this->copy_connection_information(open_curve_pt->polyline_pt(cs),
                                          tmp_curve_section_pt);
      }

      // Now update the polyline according to the new vertices but first
      // check if the object is allowed to delete the representation or
      // if it should be done by other object
      bool delete_it_on_destructor = false;

      std::set<TriangleMeshCurveSection*>::iterator it =
        this->Free_curve_section_pt.find(open_curve_pt->curve_section_pt(cs));

      if (it != this->Free_curve_section_pt.end())
      {
        this->Free_curve_section_pt.erase(it);
        delete open_curve_pt->curve_section_pt(cs);
        delete_it_on_destructor = true;
      }

      // -------------------------------------------------------------
      // Copying the new representation
      open_curve_pt->curve_section_pt(cs) = tmp_polyline_pt;

      // Update the Boundary - Polyline map
      this->Boundary_curve_section_pt[bound] =
        open_curve_pt->curve_section_pt(cs);

      if (delete_it_on_destructor)
      {
        this->Free_curve_section_pt.insert(open_curve_pt->curve_section_pt(cs));
      }

#ifdef OOMPH_HAS_MPI
      // If there are not sub-boundaries mark the boundary if need to be
      // trated as shared or as internal boundary
      if (this->is_mesh_distributed() && nsub_boundaries == 1)
      {
        // Clear all previous stored data
        this->Boundary_marked_as_shared_boundary[bound].clear();

        // .. and store the flag for the boundary
        this->Boundary_marked_as_shared_boundary[bound].push_back(
          internal_to_shared_boundary[0]);
      }
      // --------- Stuff for the sub_boundaries ----- Begin section --------
      // Verify if need to deal with sub_boundaries
      else if (this->is_mesh_distributed() && nsub_boundaries > 1)
      {
        // Create temporary representations for the boundaries, only to
        // create the mesh when calling Triangle

        // Clear all previous stored data
        this->Boundary_subpolylines[bound].clear();
        // Now create storage for the sub-boundaries
        this->Boundary_subpolylines[bound].resize(nsub_boundaries);

        // Clear all previous stored data
        this->Boundary_marked_as_shared_boundary[bound].clear();
        // Create storage to mark the internal boundaries as shared
        // boundaries
        this->Boundary_marked_as_shared_boundary[bound].resize(nsub_boundaries);
        for (unsigned isub = 0; isub < nsub_boundaries; isub++)
        {
          // Now update the polyline according to the sub set of
          // vertices, set the chunk number of the polyline
          TriangleMeshPolyLine* sub_tmp_polyline_pt =
            new TriangleMeshPolyLine(sub_vector_vertex_node[isub], bound, isub);

          // Add the sub-polyline to the container to represent the
          // boundary in parts
          this->Boundary_subpolylines[bound][isub] = sub_tmp_polyline_pt;

          // Copy the flag that mark the boundary as internal or as
          // shared bound
          this->Boundary_marked_as_shared_boundary[bound][isub] =
            internal_to_shared_boundary[isub];

          // No need to send the unrefinement/refinement and maximum
          // length constraints since these are only temporary
          // representations

          // But we certanly we need to pass the connection information
          // to the sub-polylines
          // Get a curve section representation of the sub-polyline
          TriangleMeshCurveSection* tmp_sub_curve_section_pt =
            sub_tmp_polyline_pt;
          this->copy_connection_information_to_sub_polylines(
            tmp_curve_section_pt, tmp_sub_curve_section_pt);

        } // for (isub < nsub_boundaries)

      } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
      // --------- Stuff for the sub_boundaries ----- End section ---------
#endif // OOMPH_HAS_MPI

      // Delete the allocated memory for the geometric object
      // that represents the curvilinear boundary
      delete mesh_geom_obj_pt;

    } // for (cs < ncurve_section)

    // Cleanup the face mesh
    for (unsigned p = 0; p < ncurve_section; p++)
    {
      face_mesh_pt[p]->flush_node_storage();
      delete face_mesh_pt[p];
    }

    return update_was_performed;
  }

#ifdef OOMPH_HAS_MPI
  //======================================================================
  /// Updates the polylines using the elements area as
  /// constraint for the number of points along the boundaries
  //======================================================================
  template<class ELEMENT>
  bool RefineableTriangleMesh<ELEMENT>::update_shared_curve_using_elements_area(
    Vector<TriangleMeshPolyLine*>& vector_polyline_pt,
    const Vector<double>& target_areas)
  {
    // Flag to check if there were a change on the shared boundary
    // representation
    unsigned update_was_performed = false;

    // Go through all the shared boundaries/polylines
    const unsigned n_polylines = vector_polyline_pt.size();
    for (unsigned pp = 0; pp < n_polylines; pp++)
    {
      // Get the boundary id of the current polyline
      const unsigned shd_bnd_id = vector_polyline_pt[pp]->boundary_id();

      // Get the chunk number
      const unsigned chunk = vector_polyline_pt[pp]->boundary_chunk();

      // Get the face elements that created the shared boundary from the
      // bulk shared boundary elements

      // Compute the face elements from the shared boundary elements,
      // create an association from the face element with the "bulk"
      // elements
      std::map<FiniteElement*, FiniteElement*> face_ele_pt_to_bulk_element_pt;

      // The temporary storage for the halo face elements
      Vector<FiniteElement*> halo_shared_face_ele_pt;
      // The temporary storage for the nonhalo face elements
      Vector<FiniteElement*> nonhalo_shared_face_ele_pt;

      // Get the number of shared boundary elements associated with the
      // current shared boundary
      const unsigned nshared_bound_ele =
        this->nshared_boundary_element(shd_bnd_id);

      // Loop over the elements in the shared boundary to create the face
      // elements
      for (unsigned e = 0; e < nshared_bound_ele; e++)
      {
        // Get the shared boundary element
        FiniteElement* bulk_ele_pt =
          this->shared_boundary_element_pt(shd_bnd_id, e);

        // Get the face index
        int face_index = this->face_index_at_shared_boundary(shd_bnd_id, e);

        // Before adding the new element we need to ensure that the edge
        // that this element represents has not been already added
        FiniteElement* face_ele_pt =
          new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);

        // Establish the association between the bulk element and the
        // face element
        face_ele_pt_to_bulk_element_pt[face_ele_pt] = bulk_ele_pt;

        // Nonhalo element
        if (!bulk_ele_pt->is_halo())
        {
          // Add nonhalo shared face element to the container
          nonhalo_shared_face_ele_pt.push_back(face_ele_pt);
        }
        else // halo element
        {
          // Add halo shared face element to the container
          halo_shared_face_ele_pt.push_back(face_ele_pt);
        }

      } // for (e < nshared_bound_ele)

      // Now we have the face elements, we need to ensure that the halo
      // and nonhalo bulk element are sorted one after the other
      Vector<Vector<FiniteElement*>> unsorted_shared_bulk_ele_pt;

      // Mark the face elements already used
      std::map<FiniteElement*, bool> shared_face_done;

      // Get the number of nonhalo face elements
      const unsigned nnonhalo_face_shared_ele =
        nonhalo_shared_face_ele_pt.size();

      // Get the number of halo face elements
      const unsigned nhalo_face_shared_ele = halo_shared_face_ele_pt.size();

#ifdef PARANOID
      // The number of nonhalo shared face boundary elements must be the
      // half of the total number of shared boundary elements
      if (nshared_bound_ele / 2 != nnonhalo_face_shared_ele)
      {
        std::ostringstream error_message;
        error_message
          << "The number of shared boundary elements (" << nshared_bound_ele
          << ") is not the double\nof the number of unsorted NONHALO shared "
          << "face boundary elements (" << nnonhalo_face_shared_ele << ")\n"
          << "for the current boundary (" << shd_bnd_id << ")\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }

      // The number of halo shared face boundary elements must be the
      // half of the total number of shared boundary elements
      if (nshared_bound_ele / 2 != nhalo_face_shared_ele)
      {
        std::ostringstream error_message;
        error_message
          << "The number of shared boundary elements (" << nshared_bound_ele
          << ") is not the double\nof the number of unsorted HALO shared "
          << "face boundary elements (" << nhalo_face_shared_ele << ")\n"
          << "for the current boundary (" << shd_bnd_id << ")\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // ------------------------------------------------------------------
      // Loop over the nonhalo face elements and look for the halo face
      // element at the other side of the shared boundary
      for (unsigned inh = 0; inh < nnonhalo_face_shared_ele; inh++)
      {
        // Get the inh-th face element
        FiniteElement* nonhalo_face_ele_pt = nonhalo_shared_face_ele_pt[inh];

        // Get the number of nodes on the face element
        const unsigned nnodes_nh = nonhalo_face_ele_pt->nnode();
        // Get the first and last node on the element
        Node* nh_first_node_pt = nonhalo_face_ele_pt->node_pt(0);
        Node* nh_last_node_pt = nonhalo_face_ele_pt->node_pt(nnodes_nh - 1);

        // Now find the (halo) face element at the other side of the
        // shared boundary
        for (unsigned ih = 0; ih < nhalo_face_shared_ele; ih++)
        {
          // Get the ih-th face element
          FiniteElement* halo_face_ele_pt = halo_shared_face_ele_pt[ih];

          // Check that the face element has not been done
          if (!shared_face_done[halo_face_ele_pt])
          {
            // Get the number of nodes on the face element
            const unsigned nnodes_h = halo_face_ele_pt->nnode();
            // Get the first and last node on the element
            Node* h_first_node_pt = halo_face_ele_pt->node_pt(0);
            Node* h_last_node_pt = halo_face_ele_pt->node_pt(nnodes_h - 1);

            // If the nodes are the same then we have found the (halo)
            // face element at the other side of the shared boundary
            if (nh_first_node_pt == h_first_node_pt &&
                nh_last_node_pt == h_last_node_pt)
            {
              // Get the BULK elements associated with the face elements
              Vector<FiniteElement*> tmp_bulk_element_pt;
              // Get the BULK elements associated to the face elements
              // (the nonhalo and the halo)
              FiniteElement* nonhalo_bulk_ele_pt =
                face_ele_pt_to_bulk_element_pt[nonhalo_face_ele_pt];
              FiniteElement* halo_bulk_ele_pt =
                face_ele_pt_to_bulk_element_pt[halo_face_ele_pt];

              // Add the BULK elements to the temporal storage
              tmp_bulk_element_pt.push_back(nonhalo_bulk_ele_pt);
              tmp_bulk_element_pt.push_back(halo_bulk_ele_pt);

              // Store the pair of elements associated to the "edge"
              unsorted_shared_bulk_ele_pt.push_back(tmp_bulk_element_pt);

              // Mark the face elements as done
              shared_face_done[nonhalo_face_ele_pt] = true;
              shared_face_done[halo_face_ele_pt] = true;

              // Break the loop for (ih < nhalo_face_shared_ele)
              break;
            } // if (nh_first_node_pt == h_first_node_pt &&
              //     nh_last_node_pt == h_last_node_pt)
            else if (nh_first_node_pt == h_last_node_pt &&
                     nh_last_node_pt == h_first_node_pt)
            {
              // Get the BULK elements associated with the face elements
              Vector<FiniteElement*> tmp_bulk_element_pt;
              // Get the BULK elements associated to the face elements
              // (the nonhalo and the halo)
              FiniteElement* nonhalo_bulk_ele_pt =
                face_ele_pt_to_bulk_element_pt[nonhalo_face_ele_pt];
              FiniteElement* halo_bulk_ele_pt =
                face_ele_pt_to_bulk_element_pt[halo_face_ele_pt];

              // Add the BULK elements to the temporal storage
              tmp_bulk_element_pt.push_back(nonhalo_bulk_ele_pt);
              tmp_bulk_element_pt.push_back(halo_bulk_ele_pt);

              // Store the pair of elements associated to the "edge"
              unsorted_shared_bulk_ele_pt.push_back(tmp_bulk_element_pt);

              // Mark the face elements as done
              shared_face_done[nonhalo_face_ele_pt] = true;
              shared_face_done[halo_face_ele_pt] = true;

              // Break the loop for (ih < nhalo_face_shared_ele)
              break;
            } // else if (nh_first_node_pt == h_last_node_pt &&
              //          nh_last_node_pt == h_first_node_pt)

          } // if (face_done[halo_face_ele_pt])

        } // for (ih < nhalo_face_shared_ele)

      } // for (inh < nnonhalo_face_shared_ele)

      // -------------------------------------------------------------
      // Now sort the face elements
      // -------------------------------------------------------------

      // We already have the shared face elements that make the shared
      // boundary (and the bulk elements), now sort them to create a
      // contiguous boundary

#ifdef PARANOID
      const unsigned nunsorted_shared_bulk_ele =
        unsorted_shared_bulk_ele_pt.size();

      // The number of unsorted shared BULK elements MUST be the same
      // as the number of shared_boundary elements divided by two
      if (nshared_bound_ele / 2 != nunsorted_shared_bulk_ele)
      {
        std::ostringstream error_message;
        error_message
          << "The number of shared boundary elements (" << nshared_bound_ele
          << ") is not the double\nof the number of unsorted shared bulk "
          << "boundary elements (" << nunsorted_shared_bulk_ele << ")\n"
          << "for the current boundary (" << shd_bnd_id << ")\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }

      // The number of done shared face elements MUST be the same as the
      // sum of the nonhalo and halo shared boundary face elements
      if ((nnonhalo_face_shared_ele + nhalo_face_shared_ele) !=
          shared_face_done.size())
      {
        std::ostringstream error_message;
        error_message << "The number of DONE shared boundary face elements ("
                      << shared_face_done.size()
                      << ") is not the same\n as the sum of"
                      << "the nonhalo face shared boundary elements ("
                      << nnonhalo_face_shared_ele
                      << ")\nand the halo face shared "
                      << "boundary elements (" << nhalo_face_shared_ele
                      << ") for the\n/"
                      << "current boundary (" << shd_bnd_id << ")\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Clear the already done face elements
      shared_face_done.clear();

      // The number of sorted face elements
      unsigned nsorted_face_ele = 0;

      // Storing for the sorting nodes extracted from the face
      // elements. This are also used to update the polyline
      std::list<Node*> sorted_nodes;

      // Storing for the sorted shared face elements
      std::list<FiniteElement*> sorted_shared_bound_elements_pt;

      // Get the root face element
      FiniteElement* root_face_ele_pt = nonhalo_shared_face_ele_pt[0];
      nsorted_face_ele++;

      // Mark face as done
      shared_face_done[root_face_ele_pt] = true;

      // The initial and final node on the list
      const unsigned nnodes_root = root_face_ele_pt->nnode();
      Node* first_node_pt = root_face_ele_pt->node_pt(0);
      Node* last_node_pt = root_face_ele_pt->node_pt(nnodes_root - 1);

      // Push back on the list the new nodes
      sorted_nodes.push_back(first_node_pt);
      sorted_nodes.push_back(last_node_pt);

      // Store the bulk elements of the current face
      sorted_shared_bound_elements_pt.push_back(
        unsorted_shared_bulk_ele_pt[0][0]);
      sorted_shared_bound_elements_pt.push_back(
        unsorted_shared_bulk_ele_pt[0][1]);

      // Sort the face elements
      while (nsorted_face_ele < nnonhalo_face_shared_ele)
      {
        // Flag to indicate when a node was added
        bool node_added = false;

        // Start from the next edge since we have already added the
        // previous one as the initial face element
        for (unsigned iface = 1; iface < nnonhalo_face_shared_ele; iface++)
        {
          FiniteElement* tmp_shared_face_ele_pt =
            nonhalo_shared_face_ele_pt[iface];

          // If face has not been sorted
          if (!shared_face_done[tmp_shared_face_ele_pt])
          {
            // Get the number of nodes for the current face element
            const unsigned tmp_nnodes = tmp_shared_face_ele_pt->nnode();

            // Get each individual node
            Node* left_node_pt = tmp_shared_face_ele_pt->node_pt(0);
            Node* right_node_pt =
              tmp_shared_face_ele_pt->node_pt(tmp_nnodes - 1);

            if (left_node_pt == first_node_pt)
            {
              // Push front the new node
              sorted_nodes.push_front(right_node_pt);
              first_node_pt = right_node_pt;
              node_added = true;

              // Store the elements of the current face element
              sorted_shared_bound_elements_pt.push_front(
                unsorted_shared_bulk_ele_pt[iface][1]);
              sorted_shared_bound_elements_pt.push_front(
                unsorted_shared_bulk_ele_pt[iface][0]);
            }
            else if (left_node_pt == last_node_pt)
            {
              // Push back the new node
              sorted_nodes.push_back(right_node_pt);
              last_node_pt = right_node_pt;
              node_added = true;

              // Store the elements of the current face element
              sorted_shared_bound_elements_pt.push_back(
                unsorted_shared_bulk_ele_pt[iface][0]);
              sorted_shared_bound_elements_pt.push_back(
                unsorted_shared_bulk_ele_pt[iface][1]);
            }
            else if (right_node_pt == first_node_pt)
            {
              // Push front the new node
              sorted_nodes.push_front(left_node_pt);
              first_node_pt = left_node_pt;
              node_added = true;

              // Store the elements of the current face element
              sorted_shared_bound_elements_pt.push_front(
                unsorted_shared_bulk_ele_pt[iface][1]);
              sorted_shared_bound_elements_pt.push_front(
                unsorted_shared_bulk_ele_pt[iface][0]);
            }
            else if (right_node_pt == last_node_pt)
            {
              // Push back the new node
              sorted_nodes.push_back(left_node_pt);
              last_node_pt = left_node_pt;
              node_added = true;

              // Store the elements of the current face element
              sorted_shared_bound_elements_pt.push_back(
                unsorted_shared_bulk_ele_pt[iface][0]);
              sorted_shared_bound_elements_pt.push_back(
                unsorted_shared_bulk_ele_pt[iface][1]);
            }

            if (node_added)
            {
              // Mark as done if one of its nodes has been added to the
              // list
              shared_face_done[tmp_shared_face_ele_pt] = true;
              nsorted_face_ele++;

              // Break the for
              break;
            }

          } // if (!shared_face_done[tmp_shared_face_ele_pt])

        } // for (iface < nnonhalo_face_shared_ele)

      } // while (nsorted_face_ele < nnonhalo_face_shared_ele))

      // ----------------------------------------------------------------
      // Here we can safely delete the face elements, they are no longer
      // required

      // First the nonhalo face elements
      for (unsigned inh = 0; inh < nnonhalo_face_shared_ele; inh++)
      {
        delete nonhalo_shared_face_ele_pt[inh];
        nonhalo_shared_face_ele_pt[inh] = 0;
      } // for (inh < nnonhalo_face_shared_ele)

      // ... then the halo face elements
      for (unsigned ih = 0; ih < nhalo_face_shared_ele; ih++)
      {
        delete halo_shared_face_ele_pt[ih];
        halo_shared_face_ele_pt[ih] = 0;
      } // for (inh < nhalo_face_shared_ele)

      // ------------------------------------------------------------------
      // At this point we already have a sorted list of nodes, get the
      // vertices from them and store them in a vector container

      // Get the number of nodes on the list
      const unsigned n_nodes = sorted_nodes.size();

      // The vector to store the vertices
      Vector<Vector<double>> polyline_vertices(n_nodes);

      // Copy the vertices from the nodes
      unsigned counter = 0;
      for (std::list<Node*>::iterator it_nodes = sorted_nodes.begin();
           it_nodes != sorted_nodes.end();
           it_nodes++)
      {
        polyline_vertices[counter].resize(2);
        polyline_vertices[counter][0] = (*it_nodes)->x(0);
        polyline_vertices[counter][1] = (*it_nodes)->x(1);
        counter++;
      }

      // ------------------------------------------------------------------
      // Now get the target areas associated to the shared boundary
      // elements

      // Copy the sorted elements in a vector
      Vector<FiniteElement*> sorted_shared_ele_pt;
      for (std::list<FiniteElement*>::iterator it_ele =
             sorted_shared_bound_elements_pt.begin();
           it_ele != sorted_shared_bound_elements_pt.end();
           it_ele++)
      {
        sorted_shared_ele_pt.push_back((*it_ele));
      }

      // Get the number of target areas
      const unsigned n_shared_target_areas = sorted_shared_ele_pt.size();
      Vector<double> sorted_shared_target_areas(n_shared_target_areas);

      // Mark those shared elements already found
      std::map<std::pair<GeneralisedElement*, unsigned>, bool> shared_ele_done;

      // Counter for the number of already done shared elements
      unsigned count_found_shared_element = 0;

      // Get the target area associated to the shared boundary elements
      const unsigned nele = this->nelement();

      // Loop over the elements to find the target areas associated to
      // the shared boundary elements
      for (unsigned e = 0; e < nele; e++)
      {
        GeneralisedElement* current_ele_pt = this->element_pt(e);
        // Now compare the current element with those in the sorted
        // shared element array
        for (unsigned s = 0; s < n_shared_target_areas; s++)
        {
          // Get the element
          GeneralisedElement* current_shared_ele_pt = sorted_shared_ele_pt[s];
          // Create the pair element-index to check if done
          std::pair<GeneralisedElement*, unsigned> pair_gen_ele_idx =
            std::make_pair(current_shared_ele_pt, s);
          if (!shared_ele_done[pair_gen_ele_idx])
          {
            // Compare with the global element
            if (current_ele_pt == current_shared_ele_pt)
            {
              // Store the target area of the current shared element
              sorted_shared_target_areas[s] = target_areas[e];
              // Mark the shared element as done
              shared_ele_done[pair_gen_ele_idx] = true;
              // Increase the number of found elements
              count_found_shared_element++;
            } // if (current_ele_pt == current_shared_ele_pt)
          } // if (!shared_ele_done[current_shared_ele_pt])
        } // for (s < nshared_taget_areas)

        // Check if all shared elements have been found
        if (count_found_shared_element == n_shared_target_areas)
        {
          break;
        }

      } // for (e < nele)

#ifdef PARANOID
      // Check if the number of found target areas is the same as the
      // number of shared target areas
      if (count_found_shared_element != n_shared_target_areas)
      {
        std::ostringstream error_message;
        error_message << "The number of found target areas ("
                      << count_found_shared_element
                      << ") is different from the "
                      << "total number\nof target areas ("
                      << n_shared_target_areas << ") in shared boundary ("
                      << shd_bnd_id << ")\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // The number of vertices
      const unsigned n_vertices = n_nodes;

      // Get the number of segments from the input vector_polyline_pt
      const unsigned n_segments = vector_polyline_pt[pp]->nsegment();
      // Get the number of segments from the input vector_polyline_pt to
      // ensure that the shared boundary corresponds to the one
      // represented by the shared face elements (this has sence when the
      // mesh was re-created from re-starting)

      // Check that the number of vertices correspond with the number of
      // segments
#ifdef PARANOID
      if (n_segments != n_vertices - 1)
      {
        std::ostringstream error_message;
        error_message
          << "The number of segments from the current shared polyline "
          << "(" << n_segments << ") does not\ncorrespond with the number of "
          << "sorted vertices (" << n_vertices - 1
          << ") of the current shared\n"
          << "boundary\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }

      // Check that the number of target areas correspond with the number
      // of vertices
      if (n_segments != n_shared_target_areas / 2)
      {
        std::ostringstream error_message;
        error_message
          << "The number of segments for the current sorting of edges "
          << "(" << n_segments << ") is different\nfrom the number of "
          << "target areas (" << n_shared_target_areas / 2 << ")\n\n";
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // ------------------------------------------------------------------
      // Get the target areas that are used to perform the unrefinement
      // and refinement operation. For each face element on a shared
      // polyline there are two bulk elements, a halo and a haloed
      // element, each with an associated target area. Review the
      // function
      // TriangleMesh::create_polylines_from_halo_elements_helper() to
      // check how the shared boundaries were created
      Vector<double> polyline_target_area(n_segments);
      // Loop over the segments in the shared polyline
      for (unsigned s = 0; s < n_segments; s++)
      {
        // Get the minimum of the associated target areas
        polyline_target_area[s] =
          std::min(sorted_shared_target_areas[s * 2],
                   sorted_shared_target_areas[(s * 2) + 1]);
      }

      // Before going to the unrefinement or refinement process check
      // that in all processors where the shared boundary lives start
      // from the same vertex.
      // Start from the bottom left vertex
      if (polyline_vertices[n_vertices - 1][1] < polyline_vertices[0][1])
      {
        std::reverse(polyline_vertices.begin(), polyline_vertices.end());
        std::reverse(polyline_target_area.begin(), polyline_target_area.end());
      }
      else if (polyline_vertices[n_vertices - 1][1] == polyline_vertices[0][1])
      {
        if (polyline_vertices[n_vertices - 1][0] < polyline_vertices[0][0])
        {
          std::reverse(polyline_vertices.begin(), polyline_vertices.end());
          std::reverse(polyline_target_area.begin(),
                       polyline_target_area.end());
        }
      }

      // ------------------------------------------------------------------
      // Apply unrefinement
      bool unrefinement_applied = false;
      // Apply unefinement if there are more than three nodes at the
      // shared boundary
      if (n_vertices > 3)
      {
        unrefinement_applied =
          unrefine_shared_boundary_constrained_by_target_area(
            shd_bnd_id, chunk, polyline_vertices, polyline_target_area);
      }

      // Apply refinement
      bool refinement_applied =
        refine_shared_boundary_constrained_by_target_area(polyline_vertices,
                                                          polyline_target_area);

      // Was unrefinement/refinement applied
      update_was_performed |= (unrefinement_applied || refinement_applied);

      // ------------------------------------------------------------------
      // Update the polyline representation of the shared boundary

      // The new shared polyline representation
      TriangleMeshPolyLine* new_polyline_pt =
        new TriangleMeshPolyLine(polyline_vertices, shd_bnd_id);

      // Get the curve section representation
      TriangleMeshCurveSection* curve_section_pt = vector_polyline_pt[pp];

      // Copy the connection information from the old shared polyline to
      // the new one
      this->copy_connection_information(curve_section_pt, new_polyline_pt);

      // Now update the polyline according to the new vertices but first
      // check if the object is allowed to delete the representation or
      // if it should be done by other object
      bool delete_it_on_destructor = false;

      // Establish the element as being deleted by the destructor of the
      // class
      std::set<TriangleMeshCurveSection*>::iterator it =
        this->Free_curve_section_pt.find(curve_section_pt);

      if (it != this->Free_curve_section_pt.end())
      {
        this->Free_curve_section_pt.erase(it);
        delete curve_section_pt;
        delete_it_on_destructor = true;
      }

      // Copy the new representation to the output vector_polyline_pt
      vector_polyline_pt[pp] = new_polyline_pt;

      // Get the new curve section representation
      TriangleMeshCurveSection* new_curve_section_pt = vector_polyline_pt[pp];

      // Update the Boundary - Polyline map
      this->Boundary_curve_section_pt[shd_bnd_id] = new_curve_section_pt;

      if (delete_it_on_destructor)
      {
        this->Free_curve_section_pt.insert(new_curve_section_pt);
      }

    } // for (pp < npoly)

    return update_was_performed;
  }
#endif // #ifdef OOMPH_HAS_MPI

  //=========================================================================
  /// Helper function that performs the unrefinement process
  /// on the specified boundary by using the provided vertices
  /// representation and the associated target area.
  //=========================================================================
  template<class ELEMENT>
  bool RefineableTriangleMesh<ELEMENT>::
    unrefine_boundary_constrained_by_target_area(
      const unsigned& b,
      const unsigned& c,
      Vector<Vector<double>>& vector_bnd_vertices,
      double& unrefinement_tolerance,
      Vector<double>& area_constraint)
  {
    // Store the vertices not allowed for deletion
    std::set<Vector<double>> no_delete_vertex;

    // Does the boundary receives connections?
    const bool boundary_receive_connections =
      this->boundary_connections(b, c, no_delete_vertex);

    // Boolean that indicates whether an actual update of the vertex
    // coordinates was performed
    bool unrefinement_applied = false;

    // Return inmedately
    if (!Do_boundary_unrefinement_constrained_by_target_areas)
    {
      return unrefinement_applied;
    }

    // Strategy to delete nodes: Consider the target area of the
    // elements (e_i and e_(i+1)) sharing the i-th node (middle node),
    // if the number of segments to be added is equal to zero for both
    // elements then compute the average of both target areas and check
    // if the number of segments is still zero, if that holds mark the
    // node to be deleted. Before delete the node check whether it is in
    // the non_delete_vertex list. Skip the i+1-th node and go for the
    // (i+2)-th one, it means, increase the counter for current node by
    // two.

    // Number of vertices on the boundary
    unsigned n_vertex = vector_bnd_vertices.size();

    // Compute a constant value
    const double constant_value = 4.0 / sqrt(3.0);

    if (n_vertex > 2)
    {
      // Go through all the vertices and delete points when the target area
      // indicates zero points along the boundary
      for (unsigned i = 1; i < n_vertex - 1; i += 2)
      {
        if (area_constraint[i - 1] > 0 && area_constraint[i] > 0)
        {
          const double local_zeta_first = vector_bnd_vertices[i - 1][0];
          const double local_zeta_last = vector_bnd_vertices[i + 1][0];
          const double local_length_zeta =
            std::fabs(local_zeta_last - local_zeta_first);

          const double x1 = vector_bnd_vertices[i - 1][1];
          const double y1 = vector_bnd_vertices[i - 1][2];
          const double x2 = vector_bnd_vertices[i + 1][1];
          const double y2 = vector_bnd_vertices[i + 1][2];
          const double local_length =
            sqrt(((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2)));

          const double x_m = vector_bnd_vertices[i][1];
          const double y_m = vector_bnd_vertices[i][2];

          const double average_area_constraint =
            (area_constraint[i - 1] + area_constraint[i]) / 2.0;

          // Compute the length of the the side of an equilateral
          // triangle
          const double length_side =
            sqrt(constant_value * average_area_constraint);

          const double length_side_zeta =
            (local_length_zeta * length_side) / local_length;

          // Is the new length greater that the old one
          if ((length_side_zeta / local_length_zeta) > 1.0)
          {
            // If the number of segments is zero then verify the condition for
            // deletion of nodes but using the condition in the default
            // unrefine_boundary() method. If both conditions are true then
            // delete the node
            // Maths from
            // http://www.cgafaq.info/wiki/Circle_Through_Three_Points
            double a_x = vector_bnd_vertices[i - 1][1];
            double a_y = vector_bnd_vertices[i - 1][2];
            double b_x = vector_bnd_vertices[i][1];
            double b_y = vector_bnd_vertices[i][2];
            double c_x = vector_bnd_vertices[i + 1][1];
            double c_y = vector_bnd_vertices[i + 1][2];

            double a = b_x - a_x;
            double b = b_y - a_y;
            double c = c_x - a_x;
            double d = c_y - a_y;

            double e = a * (a_x + b_x) + b * (a_y + b_y);
            double f = c * (a_x + c_x) + d * (a_y + c_y);

            double g = 2.0 * (a * (c_y - b_y) - b * (c_x - b_x));

            bool do_it = false;
            if (std::fabs(g) < 1.0e-14)
            {
              do_it = true;
            }
            else
            {
              double p_x = (d * e - b * f) / g;
              double p_y = (a * f - c * e) / g;

              double r = sqrt(pow((a_x - p_x), 2) + pow((a_y - p_y), 2));

              double rhalfca_x = 0.5 * (a_x - c_x);
              double rhalfca_y = 0.5 * (a_y - c_y);

              double halfca_squared = pow(rhalfca_x, 2) + pow(rhalfca_y, 2);

              double sticky_out_bit =
                r - sqrt(std::fabs((r * r) - halfca_squared));

              // If sticky out bit divided by distance between end nodes
              // is less than tolerance the boundary is so flat that we
              // can safely kill the node
              if ((sticky_out_bit / (2.0 * sqrt(halfca_squared))) <
                  unrefinement_tolerance)
              {
                do_it = true;
              }
            }

            // If the vertex was proposed for deletion check if it is
            // allowed for being deleted
            if (do_it && boundary_receive_connections)
            {
              // Is the vertex one of the non deletable vertices
              for (std::set<Vector<double>>::iterator it =
                     no_delete_vertex.begin();
                   it != no_delete_vertex.end();
                   it++)
              {
                // Compute the distance between the proposed node to
                // delete and the ones that should not be deleted
                const double x = (*it)[0];
                const double y = (*it)[1];
                double error = (x_m - x) * (x_m - x) + (y_m - y) * (y_m - y);
                error = sqrt(error);

                if (error <
                    ToleranceForVertexMismatchInPolygons::Tolerable_error)
                {
                  // Do not delete the vertex
                  do_it = false;
                  break;
                }
              }

            } // if (do_it && boundary_receive_connections)

            // Remove node?
            if (do_it)
            {
              vector_bnd_vertices[i].resize(0);
            }
          } // if (n_seg == 0)
        } // if (area_constraint[i] >= 0)
      } // for (i < n_vertex-1)

      // Create a new (temporary) vector for the nodes, so that deleted nodes
      // are not stored
      Vector<Vector<double>> compact_vector;

      // Compact vector for target areas too
      Vector<double> compact_area_constraint;

      // Copy only the non deleted nodes
      for (unsigned i = 0; i < n_vertex; i++)
      {
        // If the entry was not deleted include it in the new vector
        if (vector_bnd_vertices[i].size() != 0)
        {
          compact_vector.push_back(vector_bnd_vertices[i]);
        }
      }

      // ------------------------------------------------------------------
      // Size of the target areas vector
      unsigned nsize_target = area_constraint.size();
      if (nsize_target == 1)
      {
        // No node was deleted, just copy the target area
        compact_area_constraint.push_back(area_constraint[0]);
      }

      // Copy the target areas
      for (unsigned i = 1; i < n_vertex; i += 2)
      {
        // If the entry was not deleted include the target areas of both
        // elements sharing the node
        if (vector_bnd_vertices[i].size() != 0)
        {
          compact_area_constraint.push_back(area_constraint[i - 1]);
          // To catch the case when working with even number of vertex
          if (i < nsize_target)
          {
            compact_area_constraint.push_back(area_constraint[i]);
          }
        }
        else
        {
          // If the node was deleted then compute the new target area as the
          // average of the target area of the elements sharing the node
          double new_area_constraint =
            (area_constraint[i - 1] + area_constraint[i]) / 2.0;
          compact_area_constraint.push_back(new_area_constraint);
        }
      }

      // If the size of the compact vector is different from the size of the
      // vector before applying the area length constraint then the polyline
      // was updated
      if (n_vertex != compact_vector.size())
      {
        unrefinement_applied = true;
      }

      // Copy back to the original vector
      n_vertex = compact_vector.size();
      vector_bnd_vertices.resize(n_vertex);
      for (unsigned i = 0; i < n_vertex; i++)
      {
        vector_bnd_vertices[i].resize(3);
        vector_bnd_vertices[i][0] = compact_vector[i][0];
        vector_bnd_vertices[i][1] = compact_vector[i][1];
        vector_bnd_vertices[i][2] = compact_vector[i][2];
      }

      // Copy back to the original vector of target areas
      unsigned ntarget_areas = compact_area_constraint.size();
      area_constraint.resize(ntarget_areas);
      for (unsigned i = 0; i < ntarget_areas; i++)
      {
        area_constraint[i] = compact_area_constraint[i];
      }

    } // if (n_vertex > 2)

    return unrefinement_applied;
  }

  //=========================================================================
  /// Helper function that performs the refinement process
  /// on the specified boundary by using the provided vertices
  /// representation and the associated elements target area.
  //=========================================================================
  template<class ELEMENT>
  bool RefineableTriangleMesh<ELEMENT>::
    refine_boundary_constrained_by_target_area(
      MeshAsGeomObject* mesh_geom_obj_pt,
      Vector<Vector<double>>& vector_bnd_vertices,
      double& refinement_tolerance,
      Vector<double>& area_constraint)
  {
    // Boolean that indicates whether an actual update of the vertex
    // coordinates was performed
    bool refinement_applied = false;

    // Return inmedately
    if (!Do_boundary_refinement_constrained_by_target_areas)
    {
      return refinement_applied;
    }

    // Get the total number of current vertices
    unsigned n_vertex = vector_bnd_vertices.size();

    // Compute a constant value
    const double constant_value = 4.0 / sqrt(3.0);

    if (n_vertex > 1)
    {
      // Create a new (temporary) vector for the nodes, so that new
      // nodes can be stored
      Vector<Vector<double>> new_vector;

      // Go through all the vertices and create points according to the
      // specified element area
      for (unsigned i = 0; i < n_vertex - 1; i++)
      {
        // Include the first node
        new_vector.push_back(vector_bnd_vertices[i]);

        if (area_constraint[i] > 0)
        {
          double local_zeta_first = vector_bnd_vertices[i][0];
          double local_zeta_last = vector_bnd_vertices[i + 1][0];
          const double local_length_zeta =
            std::fabs(local_zeta_last - local_zeta_first);

          // Check if need to interchange the zeta first and the zeta
          // last (to ensure the same order in zeta values in any two
          // processors)
          if (local_zeta_first > local_zeta_last)
          {
            const double tmp_zeta = local_zeta_first;
            local_zeta_first = local_zeta_last;
            local_zeta_last = tmp_zeta;
          }

          const double x1 = vector_bnd_vertices[i][1];
          const double y1 = vector_bnd_vertices[i][2];
          const double x2 = vector_bnd_vertices[i + 1][1];
          const double y2 = vector_bnd_vertices[i + 1][2];
          const double local_length =
            sqrt(((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2)));

          // Compute the length in zeta units
          const double length_side = sqrt(constant_value * area_constraint[i]);
          const double length_side_zeta =
            (local_length_zeta * length_side) / local_length;

          // How many segments should be introduced
          const double n_seg_double = length_side_zeta / local_length_zeta;

          // One segment initialy (the original one)
          unsigned n_seg = 1;

          // How many more segments to introduce?
          n_seg += static_cast<unsigned>(std::floor(1.0 / n_seg_double));

          // Are there segments to introduce? There must be at least one
          // segment, the original one
          if (n_seg > 0)
          {
            // The zeta increment
            double zeta_increment = (local_length_zeta) / ((double)n_seg);

            Vector<double> zeta(1);
            // Create the n_seg segmets between each pair of nodes
            for (unsigned s = 1; s < n_seg; s++)
            {
              // Get the coordinates
              zeta[0] = local_zeta_first + zeta_increment * double(s);
              Vector<double> vertex(2);
              mesh_geom_obj_pt->position(zeta, vertex);

              // Create the new node
              Vector<double> new_node(3);
              new_node[0] = zeta[0];
              new_node[1] = vertex[0];
              new_node[2] = vertex[1];

              // Include the new node
              new_vector.push_back(new_node);

            } // for (s<=n_seg)

          } // if (n_seg > 0)

        } // if (area_constraint[i] >= 0)

      } // for (i < n_vertex-1)

      // Once finished all the vertices add the last node to the vector
      new_vector.push_back(vector_bnd_vertices[n_vertex - 1]);

      // If the new size of the vector (including the added nodes) is
      // different from the size of the vector before applying the
      // area length constraint then the polyline was updated
      n_vertex = new_vector.size();
      if (n_vertex != vector_bnd_vertices.size())
      {
        refinement_applied = true;
      }

      // Copy the new representation
      vector_bnd_vertices.resize(n_vertex);
      for (unsigned i = 0; i < n_vertex; i++)
      {
        vector_bnd_vertices[i].resize(3);
        vector_bnd_vertices[i][0] = new_vector[i][0];
        vector_bnd_vertices[i][1] = new_vector[i][1];
        vector_bnd_vertices[i][2] = new_vector[i][2];
      }

    } // if (n_vertex > 1)

    return refinement_applied;
  }

  //======================================================================
  /// Helper function that performs the unrefinement process
  /// on the specified boundary by using the provided vertices
  /// representation and the associated target area.
  /// NOTE: This is the version that applies unrefinement to shared
  /// boundaries
  //======================================================================
  template<class ELEMENT>
  bool RefineableTriangleMesh<ELEMENT>::
    unrefine_shared_boundary_constrained_by_target_area(
      const unsigned& b,
      const unsigned& c,
      Vector<Vector<double>>& vector_bnd_vertices,
      Vector<double>& area_constraint)
  {
    // Store the vertices not allowed for deletion
    std::set<Vector<double>> no_delete_vertex;

    // Does the boundary receives connections?
    const bool boundary_receive_connections =
      this->boundary_connections(b, c, no_delete_vertex);

    // Boolean that indicates whether an actual update of the vertex
    // coordinates was performed
    bool unrefinement_applied = false;

    // Return inmedately
    if (!Do_shared_boundary_unrefinement_constrained_by_target_areas)
    {
      return unrefinement_applied;
    }

    // Strategy to delete nodes:

    // Strategy to delete nodes: Consider the target area of the
    // elements (e_i and e_(i+1)) sharing the i-th node (middle node),
    // if the number of segments to be added is equal to zero for both
    // elements then compute the average of both target areas and check
    // if the number of segments is still zero, if that holds mark the
    // node to be deleted. Before delete the node check whether it is in
    // the non_delete_vertex list. Skip the i+1-th node and go for the
    // (i+2)-th one, it means, increase the counter for current node by
    // two.

    // Number of vertices on the boundary
    unsigned n_vertex = vector_bnd_vertices.size();

    // Compute a constant value
    const double constant_value = 4.0 / sqrt(3.0);

    if (n_vertex > 2)
    {
      // Go through all the vertices and delete points when the target
      // area indicates zero points along the boundary
      for (unsigned i = 1; i < n_vertex - 1; i += 2)
      {
        // Is a target area assigned to the left and right element of
        // the i-th node
        if (area_constraint[i - 1] > 0 && area_constraint[i] > 0)
        {
          // Get the vertices to the left
          const double x1 = vector_bnd_vertices[i - 1][0];
          const double y1 = vector_bnd_vertices[i - 1][1];
          // ... and to the right of the i-th vertex
          const double x2 = vector_bnd_vertices[i + 1][0];
          const double y2 = vector_bnd_vertices[i + 1][1];

          // The distance
          const double local_length =
            sqrt(((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2)));

          // Get the middle vertex
          const double x_m = vector_bnd_vertices[i][0];
          const double y_m = vector_bnd_vertices[i][1];

          // The average area
          const double average_area_constraint =
            (area_constraint[i - 1] + area_constraint[i]) / 2.0;

          // Compute the base length of the triangle with
          // area_constraint area
          const double length_side =
            sqrt(constant_value * average_area_constraint);

          // Is the new length greater than the old one
          if ((length_side / local_length) > 1.0)
          {
            bool do_it = true;

            // If the vertex was proposed for deletion check that it is
            // allowed for being deleted
            if (do_it && boundary_receive_connections)
            {
              // Is the vertex one of the non deletable vertices
              for (std::set<Vector<double>>::iterator it =
                     no_delete_vertex.begin();
                   it != no_delete_vertex.end();
                   it++)
              {
                // Compute the distance between the proposed node to delete
                // and the ones that should not be deleted
                const double x = (*it)[0];
                const double y = (*it)[1];
                double error = (x_m - x) * (x_m - x) + (y_m - y) * (y_m - y);
                error = sqrt(error);

                if (error <
                    ToleranceForVertexMismatchInPolygons::Tolerable_error)
                {
                  // Do not delete the vertex
                  do_it = false;
                  break;
                }
              }

            } // if (do_it && boundary_receive_connections)

            // Remove node?
            if (do_it)
            {
              vector_bnd_vertices[i].resize(0);
            }
          } // if ((local_length / length_side) <= 1.3)

        } // if (area_constraint[i] >= 0)

      } // for (i < n_vertex-1)

      // Create a new (temporary) vector for the nodes, so that deleted nodes
      // are not stored
      Vector<Vector<double>> compact_vector;

      // Compact vector for target areas too
      Vector<double> compact_area_constraint;

      // Copy only the non deleted nodes
      for (unsigned i = 0; i < n_vertex; i++)
      {
        // If the entry was not deleted include it in the new vector
        if (vector_bnd_vertices[i].size() != 0)
        {
          compact_vector.push_back(vector_bnd_vertices[i]);
        }
      }

      // ------------------------------------------------------------------
      // The number of target areas
      unsigned n_area_constraint = area_constraint.size();
      if (n_area_constraint == 1)
      {
        // No node could be deleted then just copy the target area
        compact_area_constraint.push_back(area_constraint[0]);
      }

      // Copy the target areas
      for (unsigned i = 1; i < n_vertex; i += 2)
      {
        // If the entry was not deleted include the target areas of both
        // elements sharing the node
        if (vector_bnd_vertices[i].size() != 0)
        {
          compact_area_constraint.push_back(area_constraint[i - 1]);
          // To catch the case when working with even number of vertices
          if (i < n_area_constraint)
          {
            compact_area_constraint.push_back(area_constraint[i]);
          }
        }
        else
        {
          // If the node was deleted then compute the new target area as the
          // average of the target area of the elements sharing the node
          const double new_area_constraint =
            (area_constraint[i - 1] + area_constraint[i]) / 2.0;
          compact_area_constraint.push_back(new_area_constraint);
        }
      } // for (i < n_vertex)

      // If the size of the compact vector is different from the size of
      // the vector before applying the area length constraint then the
      // polyline was updated
      if (n_vertex != compact_vector.size())
      {
        unrefinement_applied = true;
      }

      // Copy back to the original vector
      n_vertex = compact_vector.size();
      vector_bnd_vertices.resize(n_vertex);
      for (unsigned i = 0; i < n_vertex; i++)
      {
        vector_bnd_vertices[i].resize(2);
        vector_bnd_vertices[i][0] = compact_vector[i][0];
        vector_bnd_vertices[i][1] = compact_vector[i][1];
      }

      // Copy back to the original vector of target areas
      unsigned ntarget_areas = compact_area_constraint.size();
      area_constraint.resize(ntarget_areas);
      for (unsigned i = 0; i < ntarget_areas; i++)
      {
        area_constraint[i] = compact_area_constraint[i];
      }

    } // if (n_vertex > 2)

    return unrefinement_applied;
  }

  //======================================================================
  /// Helper function that performs the refinement process
  /// on the specified boundary by using the provided vertices
  /// representation and the associated elements target area.
  /// NOTE: This is the version that applies refinement to shared
  /// boundaries
  //======================================================================
  template<class ELEMENT>
  bool RefineableTriangleMesh<ELEMENT>::
    refine_shared_boundary_constrained_by_target_area(
      Vector<Vector<double>>& vector_bnd_vertices,
      Vector<double>& area_constraint)
  {
    // Boolean that indicates whether an actual update of the vertex
    // coordinates was performed
    bool refinement_applied = false;

    // Return inmedately
    if (!Do_shared_boundary_refinement_constrained_by_target_areas)
    {
      return refinement_applied;
    }

    // Get the number of segments
    unsigned nsegments = vector_bnd_vertices.size() - 1;

    // Create a new (temporary) vector for the nodes, so that new nodes
    // can be stored
    Vector<Vector<double>> tmp_bnd_vertices;

    // Compute a constant value
    const double constant_value = 4.0 / sqrt(3.0);

    for (unsigned s = 0; s < nsegments; s++)
    {
      Vector<double> left_vertex = vector_bnd_vertices[s];
      Vector<double> right_vertex = vector_bnd_vertices[s + 1];

      // Initial and final point of the segment
      const double x1 = left_vertex[0];
      const double y1 = left_vertex[1];
      const double x2 = right_vertex[0];
      const double y2 = right_vertex[1];

      // Lenght of the segment
      const double segment_length =
        sqrt(((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2)));

      // Compute the distance for the new segments
      const double new_segment_length =
        sqrt(constant_value * area_constraint[s]);

      // How many segments should be introduced
      const double n_seg_double = new_segment_length / segment_length;

      // One segment initialy (the original one)
      unsigned nseg = 1;
      // How many more segments to introduce?
      nseg += static_cast<unsigned>(std::floor(1.0 / n_seg_double));

      // The left vertex must be always included, even though no new vertex
      // be added
      tmp_bnd_vertices.push_back(left_vertex);

      // Are there segments to introduce? There must be at least one
      // segment, the original one
      if (nseg > 0)
      {
        // Create intermediate vertices
        double incrementx = (right_vertex[0] - left_vertex[0]) / (double)(nseg);
        double incrementy = (right_vertex[1] - left_vertex[1]) / (double)(nseg);
        for (unsigned i = 1; i < nseg; i++)
        {
          Vector<double> tmp_vertex(2);
          tmp_vertex[0] = left_vertex[0] + incrementx * i;
          tmp_vertex[1] = left_vertex[1] + incrementy * i;
          tmp_bnd_vertices.push_back(tmp_vertex);
        } // for (i < nseg)

      } // if (nseg > 0)

    } // for (s < nsegments)

    // Add the last vertex
    tmp_bnd_vertices.push_back(vector_bnd_vertices[nsegments]);

    // If the new size of the vector (including the added nodes) is
    // different from the size of the vector before applying the
    // refinement then the polyline was updated
    nsegments = tmp_bnd_vertices.size() - 1;
    if (nsegments != vector_bnd_vertices.size() - 1)
    {
      refinement_applied = true;

      // Copy across
      vector_bnd_vertices.resize(nsegments + 1);
      for (unsigned i = 0; i < nsegments + 1; i++)
      {
        vector_bnd_vertices[i].resize(2);
        vector_bnd_vertices[i][0] = tmp_bnd_vertices[i][0];
        vector_bnd_vertices[i][1] = tmp_bnd_vertices[i][1];
      }
    }

    return refinement_applied;
  }

  //======================================================================
  /// Updates the polylines representation after restart
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::update_polygon_after_restart(
    TriangleMeshPolygon*& polygon_pt)
  {
    // **********************************************************************
    // 1) Collect the elements adjacet to the polyline boundary id and
    //    update the polyline
    // **********************************************************************

    // (1.1) Get the face mesh representation
    Vector<Mesh*> face_mesh_pt;
    get_face_mesh_representation(polygon_pt, face_mesh_pt);

    // (1.2) Create vertices of the polylines by using the vertices of the
    //       FaceElements
    Vector<double> vertex_coord(3); // zeta,x,y
    Vector<double> bound_left(1);
    Vector<double> bound_right(1);

    const unsigned n_polyline = polygon_pt->npolyline();

    // Go for each polyline
    for (unsigned p = 0; p < n_polyline; p++)
    {
      // Get the MeshAsGeomObject representation just once per polyline,
      // this object is only used by the
      // refine_boundary_constrained_by_target_area() method. We get it here
      // to ensure that all processors (in a distributed context) get this
      // representation just once, and because an AllToAll MPI communication
      // is used in this calling
      MeshAsGeomObject* mesh_geom_obj_pt =
        new MeshAsGeomObject(face_mesh_pt[p]);

      // Set of coordinates that are on the boundary
      // Set entries are ordered on first entry in vector which stores
      // the boundary coordinate so the vertices come out in order!
      std::set<Vector<double>> vertex_nodes;

      // Vector to store the vertices, transfer the sorted vertices from the
      // set to this vector, --- including the z-value ---
      Vector<Vector<double>> tmp_vector_vertex_node;

      // Vector to store the coordinates of the polylines, same as the
      // tmp_vector_vertex_node vector (after adding more nodes) but
      // --- without the z-value ---, used to re-generate the polylines
      Vector<Vector<double>> vector_vertex_node;

#ifdef OOMPH_HAS_MPI
      // --------- Stuff to deal with splitted boundaries ---------- Begin -----
      // Set of coordinates that are on the boundary (splitted boundary version)
      // The first vector is used to allocate the points for each sub-boundary
      // Set entries are ordered on first entry in vector which stores
      // the boundary coordinate so the vertices come out in order!
      Vector<std::set<Vector<double>>> sub_vertex_nodes;

      // Vector to store the vertices, transfer the sorted vertices from the
      // set (sub_vertex_nodes) to this vector, --- including the z-value ---
      Vector<Vector<Vector<double>>> sub_tmp_vector_vertex_node;

      // Vector to store the coordinates of the polylines that will represent
      // the splitted boundary. Used to pass the info. from sub_vertex_nodes
      // but --- without the z-value ---, used to generate the sub-polylines
      Vector<Vector<Vector<double>>> sub_vector_vertex_node;
      // --------- Stuff to deal with splitted boundaries ----------- End ------
#endif

      // Get the boundary id
      unsigned bound = polygon_pt->curve_section_pt(p)->boundary_id();

      /// Use a vector of vector for vertices and target areas to
      /// deal with the cases when the boundaries are split by the
      /// distribution process

      // Loop over the face elements (ordered) and add their vertices
      const unsigned nface_element = face_mesh_pt[p]->nelement();

      // Store the non halo face elements, the ones from which we will
      // get the vertices
      Vector<FiniteElement*> non_halo_face_element_pt;
      // Map to store the index of the face element on a boundary
      std::map<FiniteElement*, unsigned> face_element_index_on_boundary;

      for (unsigned ef = 0; ef < nface_element; ++ef)
      {
        FiniteElement* ele_face_pt = face_mesh_pt[p]->finite_element_pt(ef);
        // Skip the halo elements
#ifdef OOMPH_HAS_MPI
        if (this->is_mesh_distributed())
        {
          // Only work with non-halo elements
          if (ele_face_pt->is_halo())
          {
            continue;
          }
        }
#endif
        // Add the face element to the vector
        non_halo_face_element_pt.push_back(ele_face_pt);
        face_element_index_on_boundary[ele_face_pt] = ef;
      }

      // Get the number of non halo face element
      const unsigned nnon_halo_face_element = non_halo_face_element_pt.size();

      // Map to know the already sorted face elements
      std::map<FiniteElement*, bool> face_element_done;

      // Number of done face elements
      unsigned nsorted_face_elements = 0;

#ifdef OOMPH_HAS_MPI
      // Counter for sub_boundaries
      unsigned nsub_boundaries = 0;
#endif // #ifdef OOMPH_HAS_MPI

      // Continue until all the face elements have been sorted
      // This while is to deal with the cases of splitted boundaries
      while (nsorted_face_elements < nnon_halo_face_element)
      {
        // Get and initial face element
        FiniteElement* ele_face_pt = 0;
#ifdef PARANOID
        bool found_initial_face_element = false;
#endif

        unsigned iface = 0;
        for (iface = 0; iface < nnon_halo_face_element; iface++)
        {
          ele_face_pt = non_halo_face_element_pt[iface];
          // If not done then take it as initial face element
          if (!face_element_done[ele_face_pt])
          {
#ifdef PARANOID
            found_initial_face_element = true;
#endif
            nsorted_face_elements++;
            iface++;
            break;
          }
        }

#ifdef PARANOID
        if (!found_initial_face_element)
        {
          std::ostringstream error_message;
          error_message << "Could not find an initial face element for the "
                           "current segment\n";
          // << "----- Possible memory leak -----\n";
          throw OomphLibError(
            error_message.str(),
            "RefineableTriangleMesh::update_polygon_after_restart()",
            OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // Local set of coordinates that are on the boundary
        // Set entries are ordered on first entry in vector which stores
        // the boundary coordinate so the vertices come out in order!
        std::set<Vector<double>> local_vertex_nodes;

        // Vector to store the vertices, transfer the sorted vertices from the
        // set (local) to this vector (local), --- including the z-value ---
        Vector<Vector<double>> local_tmp_vector_vertex_node;

        // ------------------------------------------------------------------
        // ------------------------------------------------------------------
        // -----------------------------------------------------------------
        // Add the vertices of the initial face element to the set of local
        // sorted vertices
        // -----------------------------------------------------------------
        unsigned nnode = ele_face_pt->nnode();
        // Add the left-hand node to the set:
        // Boundary coordinate
        ele_face_pt->node_pt(0)->get_coordinates_on_boundary(bound, bound_left);
        vertex_coord[0] = bound_left[0];

        // Actual coordinates
        for (unsigned i = 0; i < 2; i++)
        {
          vertex_coord[i + 1] = ele_face_pt->node_pt(0)->x(i);
        }
        local_vertex_nodes.insert(vertex_coord);

        // Add the right-hand nodes to the set:
        // Boundary coordinate
        ele_face_pt->node_pt(nnode - 1)->get_coordinates_on_boundary(
          bound, bound_right);
        vertex_coord[0] = bound_right[0];

        // Actual coordinates
        for (unsigned i = 0; i < 2; i++)
        {
          vertex_coord[i + 1] = ele_face_pt->node_pt(nnode - 1)->x(i);
        }
        local_vertex_nodes.insert(vertex_coord);

        // The initial and final node on the set
        Node* first_node_pt = ele_face_pt->node_pt(0);
        Node* last_node_pt = ele_face_pt->node_pt(nnode - 1);

        // Mark the current face element as done
        face_element_done[ele_face_pt] = true;

        // ------------------------------------------------------------------
        // ------------------------------------------------------------------
        // ------------------------------------------------------------------

        // Continue iterating if a new face element has been added to the
        // list
        bool face_element_added = false;

        // While a new face element has been added to the set of sorted
        // face elements then re-iterate
        do
        {
          // Start from the next face elements since we have already added
          // the previous one as the initial face element (any previous face
          // element had to be added on previous iterations)
          for (unsigned iiface = iface; iiface < nnon_halo_face_element;
               iiface++)
          {
            face_element_added = false;
            ele_face_pt = non_halo_face_element_pt[iiface];
            if (!face_element_done[ele_face_pt])
            {
              // Get each individual node to check if they are contiguous
              nnode = ele_face_pt->nnode();
              Node* left_node_pt = ele_face_pt->node_pt(0);
              Node* right_node_pt = ele_face_pt->node_pt(nnode - 1);

              if (left_node_pt == first_node_pt)
              {
                first_node_pt = right_node_pt;
                face_element_added = true;
              }
              else if (left_node_pt == last_node_pt)
              {
                last_node_pt = right_node_pt;
                face_element_added = true;
              }
              else if (right_node_pt == first_node_pt)
              {
                first_node_pt = left_node_pt;
                face_element_added = true;
              }
              else if (right_node_pt == last_node_pt)
              {
                last_node_pt = left_node_pt;
                face_element_added = true;
              }

              if (face_element_added)
              {
                // Add the left-hand node to the set:
                // Boundary coordinate
                left_node_pt->get_coordinates_on_boundary(bound, bound_left);
                vertex_coord[0] = bound_left[0];

                // Actual coordinates
                for (unsigned i = 0; i < 2; i++)
                {
                  vertex_coord[i + 1] = left_node_pt->x(i);
                }
                local_vertex_nodes.insert(vertex_coord);

                // Add the right-hand nodes to the set:
                // Boundary coordinate
                right_node_pt->get_coordinates_on_boundary(bound, bound_right);
                vertex_coord[0] = bound_right[0];

                // Actual coordinates
                for (unsigned i = 0; i < 2; i++)
                {
                  vertex_coord[i + 1] = right_node_pt->x(i);
                }
                local_vertex_nodes.insert(vertex_coord);

                // Mark as done only if one of its nodes has been
                // added to the list
                face_element_done[ele_face_pt] = true;
                nsorted_face_elements++;

                break;
              }

            } // if (!edge_done[edge])
          } // for (iiedge < nedges)
        } while (face_element_added &&
                 (nsorted_face_elements < nnon_halo_face_element));

        // -----------------------------------------------------------------
        // At this point we already have a sorted set of nodes and
        // can be used to peform the unrefinement and refinement procedures
        // -----------------------------------------------------------------

        // Get the number of nodes on the list
        const unsigned nlocal_nodes = local_vertex_nodes.size();
        // Change representation to vector for easy of handling ...
        local_tmp_vector_vertex_node.resize(nlocal_nodes);

        // Copy the vertices of the nodes
        unsigned counter = 0;
        std::set<Vector<double>>::iterator it_vertex;
        for (it_vertex = local_vertex_nodes.begin();
             it_vertex != local_vertex_nodes.end();
             it_vertex++)
        {
          local_tmp_vector_vertex_node[counter].resize(3);
          local_tmp_vector_vertex_node[counter][0] = (*it_vertex)[0];
          local_tmp_vector_vertex_node[counter][1] = (*it_vertex)[1];
          local_tmp_vector_vertex_node[counter][2] = (*it_vertex)[2];
          counter++;
        }

        // *********************************************************************
        // 3) Create the vertices along the boundary using the target area to
        //    define the distance among them
        // *********************************************************************

        // Clear the local containter to recover the nodes ordered using the
        // zeta value
        local_vertex_nodes.clear();

        // At the end of each unrefinement/refinement step store the new nodes
        // on the set that will give rise to the vertices of the new polyline
        // representation
        unsigned nnew_nodes = local_tmp_vector_vertex_node.size();
        for (unsigned i = 0; i < nnew_nodes; i++)
        {
          vertex_coord[0] = local_tmp_vector_vertex_node[i][0];
          vertex_coord[1] = local_tmp_vector_vertex_node[i][1];
          vertex_coord[2] = local_tmp_vector_vertex_node[i][2];
          vertex_nodes.insert(vertex_coord); // Global container
          local_vertex_nodes.insert(vertex_coord);
        }

#ifdef OOMPH_HAS_MPI
        if (this->is_mesh_distributed())
        {
          // Add the set of vertices for the boundary, this will help to detect
          // if we need to deal with sub_boundaries and sub_polylines represen.
          sub_vertex_nodes.push_back(local_vertex_nodes);
          // Increase the counter for sub_boundaries
          nsub_boundaries++;
        }
#endif

      } // while(nsorted_face_elements < nnon_halo_face_element)

      // Now turn into vector for ease of handling...
      unsigned npoly_vertex = vertex_nodes.size();
      tmp_vector_vertex_node.resize(npoly_vertex);
      unsigned count = 0;
      std::set<Vector<double>>::iterator it;
      for (it = vertex_nodes.begin(); it != vertex_nodes.end(); ++it)
      {
        tmp_vector_vertex_node[count].resize(3);
        tmp_vector_vertex_node[count][0] = (*it)[0];
        tmp_vector_vertex_node[count][1] = (*it)[1];
        tmp_vector_vertex_node[count][2] = (*it)[2];
        ++count;
      }

#ifdef OOMPH_HAS_MPI
      // --------- Stuff for the sub_boundaries ----- Begin section ---------
#ifdef PARANOID
      unsigned nsub_boundaries_set = sub_vertex_nodes.size();
      if (nsub_boundaries_set != nsub_boundaries)
      {
        std::ostringstream error_message;
        error_message
          << "The number of found sub-boundaries and the number of counted\n"
          << "sub-boundaries are different:\n"
          << "Number of found sub-boundaries: (" << nsub_boundaries_set << ")\n"
          << "Number of counted sub-boundaries: (" << nsub_boundaries << ")\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::update_polygon_after_restart()",
          OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Verify if need to deal with sub_boundaries
      if (this->is_mesh_distributed() && nsub_boundaries > 1)
      {
        // Mark the boundary as been splitted in the partition process
        this->Boundary_was_splitted[bound] = true;
        // Resize the vector to store the info. of sub-boundaries
        sub_tmp_vector_vertex_node.resize(nsub_boundaries);
        for (unsigned isub = 0; isub < nsub_boundaries; isub++)
        {
          // Turn info. into vector for ease of handling...
          const unsigned nsubpoly_vertex = sub_vertex_nodes[isub].size();
          sub_tmp_vector_vertex_node[isub].resize(nsubpoly_vertex);
          unsigned subcount = 0;
          std::set<Vector<double>>::iterator subit;
          for (subit = sub_vertex_nodes[isub].begin();
               subit != sub_vertex_nodes[isub].end();
               ++subit)
          {
            sub_tmp_vector_vertex_node[isub][subcount].resize(3);
            sub_tmp_vector_vertex_node[isub][subcount][0] = (*subit)[0];
            sub_tmp_vector_vertex_node[isub][subcount][1] = (*subit)[1];
            sub_tmp_vector_vertex_node[isub][subcount][2] = (*subit)[2];
            ++subcount;
          }
        }
      } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
      // --------- Stuff for the sub_boundaries ----- End section ------------
#endif // OOMPH_HAS_MPI


      // For further processing the three-dimensional vector
      // has to be reduced to a two-dimensional vector
      unsigned n_vertex = tmp_vector_vertex_node.size();

      // Resize the vector for vectices
      vector_vertex_node.resize(n_vertex);
      for (unsigned i = 0; i < n_vertex; i++)
      {
        vector_vertex_node[i].resize(2);
        vector_vertex_node[i][0] = tmp_vector_vertex_node[i][1];
        vector_vertex_node[i][1] = tmp_vector_vertex_node[i][2];
      }

#ifdef OOMPH_HAS_MPI
      // --------- Stuff for the sub_boundaries ----- Begin section ----------
      // Verify if need to deal with sub_boundaries
      if (this->is_mesh_distributed() && nsub_boundaries > 1)
      {
        // For further processing the three-dimensional vector
        // has to be reduced to a two-dimensional vector
        // Resize the vector to store the info. of sub-boundaries
        sub_vector_vertex_node.resize(nsub_boundaries);
        for (unsigned isub = 0; isub < nsub_boundaries; isub++)
        {
          const unsigned subn_vertex = sub_tmp_vector_vertex_node[isub].size();
          // Resize the vector for vectices
          sub_vector_vertex_node[isub].resize(subn_vertex);
          for (unsigned i = 0; i < subn_vertex; i++)
          {
            sub_vector_vertex_node[isub][i].resize(2);
            sub_vector_vertex_node[isub][i][0] =
              sub_tmp_vector_vertex_node[isub][i][1];
            sub_vector_vertex_node[isub][i][1] =
              sub_tmp_vector_vertex_node[isub][i][2];
          }
        }
      } // if (this->is_mesh_distributed() && nsub_boundaries > 1)

      // We already have the info. for the sub-boundaries (if necessary)
      // and then we can create the sub-boundaries representations to
      // ease the generation of the mesh by Triangle

      // --------- Stuff for the sub_boundaries ----- End section ------------
#endif // OOMPH_HAS_MPI

      // *********************************************************************
      // 4) Check for contiguousness
      // *********************************************************************
#ifdef OOMPH_HAS_MPI
      // Only perform this checking if the mesh is not distributed
      // When the mesh is distributed the polylines continuity is
      // addressed with the sort_polylines_helper() method
      if (!this->is_mesh_distributed())
#endif
      {
        if (p > 0)
        {
          // Final end point of previous line
          Vector<double> final_vertex_of_previous_segment;
          unsigned n_prev_vertex =
            polygon_pt->curve_section_pt(p - 1)->nvertex();
          final_vertex_of_previous_segment =
            polygon_pt->polyline_pt(p - 1)->vertex_coordinate(n_prev_vertex -
                                                              1);

          unsigned prev_seg_boundary_id =
            polygon_pt->curve_section_pt(p - 1)->boundary_id();

          // Find the error between the final vertex of the previous
          // line and the first vertex of the current line
          double error = 0.0;
          for (unsigned i = 0; i < 2; i++)
          {
            const double dist = final_vertex_of_previous_segment[i] -
                                (*vector_vertex_node.begin())[i];
            error += dist * dist;
          }
          error = sqrt(error);

          // If the error is bigger than the tolerance then
          // we probably need to reverse, but better check
          if (error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
          {
            // Find the error between the final vertex of the previous
            // line and the last vertex of the current line
            double rev_error = 0.0;
            for (unsigned i = 0; i < 2; i++)
            {
              const double dist = final_vertex_of_previous_segment[i] -
                                  (*--vector_vertex_node.end())[i];
              rev_error += dist * dist;
            }
            rev_error = sqrt(rev_error);

            if (rev_error >
                ToleranceForVertexMismatchInPolygons::Tolerable_error)
            {
              // It could be possible that the first segment be reversed and we
              // did not notice it because this check does not apply for the
              // first segment. We can verify if the first segment is reversed
              // by using the vertex number 1
              if (p == 1)
              {
                // Initial end point of previous line
                Vector<double> initial_vertex_of_previous_segment;

                initial_vertex_of_previous_segment =
                  polygon_pt->polyline_pt(p - 1)->vertex_coordinate(0);

                unsigned prev_seg_boundary_id =
                  polygon_pt->curve_section_pt(p - 1)->boundary_id();

                // Find the error between the initial vertex of the previous
                // line and the first vertex of the current line
                double error = 0.0;
                for (unsigned i = 0; i < 2; i++)
                {
                  const double dist = initial_vertex_of_previous_segment[i] -
                                      (*vector_vertex_node.begin())[i];
                  error += dist * dist;
                }
                error = sqrt(error); // Reversed only the previous one

                // If the error is bigger than the tolerance then
                // we probably need to reverse, but better check
                if (error >
                    ToleranceForVertexMismatchInPolygons::Tolerable_error)
                {
                  // Find the error between the final vertex of the previous
                  // line and the last vertex of the current line
                  double rev_error = 0.0;
                  for (unsigned i = 0; i < 2; i++)
                  {
                    const double dist = initial_vertex_of_previous_segment[i] -
                                        (*--vector_vertex_node.end())[i];
                    rev_error += dist * dist;
                  }
                  rev_error =
                    sqrt(rev_error); // Reversed both the current one and
                  // the previous one

                  if (rev_error >
                      ToleranceForVertexMismatchInPolygons::Tolerable_error)
                  {
                    std::ostringstream error_stream;
                    error_stream
                      << "The distance between the first node of the current\n"
                      << "line segment (boundary " << bound
                      << ") and either end of "
                      << "the previous line segment\n"
                      << "(boundary " << prev_seg_boundary_id
                      << ") is bigger than "
                      << "the desired tolerance "
                      << ToleranceForVertexMismatchInPolygons::Tolerable_error
                      << ".\n"
                      << "This suggests that the polylines defining the "
                         "polygonal\n"
                      << "representation are not properly ordered.\n"
                      << "Fail on last vertex of polyline: ("
                      << prev_seg_boundary_id
                      << ") and\nfirst vertex of polyline (" << bound
                      << ").\nThis should have failed when first trying to"
                      << " construct the\npolygon.\n";
                    throw OomphLibError(
                      error_stream.str(),
                      "RefineableTriangleMesh::update_polygon_after_restart()",
                      OOMPH_EXCEPTION_LOCATION);
                  }
                  else
                  {
                    // Reverse both
                    // Reverse the current vector to line up with the previous
                    // one
                    std::reverse(vector_vertex_node.begin(),
                                 vector_vertex_node.end());
                    polygon_pt->polyline_pt(p - 1)->reverse();
                  }
                }
                else
                {
                  // Reverse the previous one
                  polygon_pt->polyline_pt(p - 1)->reverse();
                }

              } // if p == 1
              else
              {
                std::ostringstream error_stream;
                error_stream
                  << "The distance between the first node of the current\n"
                  << "line segment (boundary " << bound
                  << ") and either end of "
                  << "the previous line segment\n"
                  << "(boundary " << prev_seg_boundary_id
                  << ") is bigger than the "
                  << "desired tolerance "
                  << ToleranceForVertexMismatchInPolygons::Tolerable_error
                  << ".\n"
                  << "This suggests that the polylines defining the polygonal\n"
                  << "representation are not properly ordered.\n"
                  << "Fail on last vertex of polyline: ("
                  << prev_seg_boundary_id << ") and\nfirst vertex of polyline ("
                  << bound << ").\n"
                  << "This should have failed when first trying to construct "
                     "the\n"
                  << "polygon.\n";
                throw OomphLibError(
                  error_stream.str(),
                  "RefineableTriangleMesh::update_polygon_after_restart()",
                  OOMPH_EXCEPTION_LOCATION);
              }
            }
            else
            {
              // Reverse the current vector to line up with the previous one
              std::reverse(vector_vertex_node.begin(),
                           vector_vertex_node.end());
            }
          } // error
        } // p > 0
      } // is mesh not distributed

      // *********************************************************************
      // 5) Update the polylines representation
      // *********************************************************************
      //   if (applied_area_length_constraint)
      // If only applied when there is a change then it keeps the
      // previous polyline representation, it means, it does not delete
      // the boundaries that are not part of the domain. We must update
      // the boundary representation
      {
        n_vertex = vector_vertex_node.size();

        // Now update the polyline according to the new vertices
        // The new one representation
        TriangleMeshPolyLine* tmp_polyline_pt =
          new TriangleMeshPolyLine(vector_vertex_node, bound);

        //    for (unsigned h = 0; h < vector_vertex_node.size(); h++)
        //     {
        //       DEBP(h);
        //       DEBP(vector_vertex_node[h][0]);
        //       DEBP(vector_vertex_node[h][1]);
        //     }

        // Create a temporal "curve section" version of the recently created
        // polyline
        TriangleMeshCurveSection* tmp_curve_section_pt = tmp_polyline_pt;

        // Tolerance below which the middle point can be deleted
        // (ratio of deflection to element length)
        double unrefinement_tolerance =
          polygon_pt->polyline_pt(p)->unrefinement_tolerance();

        // Tolerance to add points
        double refinement_tolerance =
          polygon_pt->polyline_pt(p)->refinement_tolerance();

        // Establish refinement and unrefinement tolerance
        tmp_polyline_pt->set_unrefinement_tolerance(unrefinement_tolerance);
        tmp_polyline_pt->set_refinement_tolerance(refinement_tolerance);

        // Establish the maximum length constraint
        double maximum_length = polygon_pt->polyline_pt(p)->maximum_length();
        tmp_polyline_pt->set_maximum_length(maximum_length);

        if (n_vertex >= 2)
        {
          // Pass the connection information from the old polyline to the
          // new one
          this->copy_connection_information(polygon_pt->polyline_pt(p),
                                            tmp_curve_section_pt);
        }

        // Now update the polyline according to the new vertices but
        // first check if the object is allowed to delete the representation
        // or if it should be done by other object
        bool delete_it_on_destructor = false;

        std::set<TriangleMeshCurveSection*>::iterator it =
          this->Free_curve_section_pt.find(polygon_pt->curve_section_pt(p));

        if (it != this->Free_curve_section_pt.end())
        {
          this->Free_curve_section_pt.erase(it);
          delete polygon_pt->curve_section_pt(p);
          delete_it_on_destructor = true;
        }

        // *****************************************************************
        // Copying the new representation
        polygon_pt->curve_section_pt(p) = tmp_polyline_pt;

        // Update the Boundary - Polyline map
        this->Boundary_curve_section_pt[bound] =
          polygon_pt->curve_section_pt(p);

        if (delete_it_on_destructor)
        {
          this->Free_curve_section_pt.insert(polygon_pt->curve_section_pt(p));
        }

#ifdef OOMPH_HAS_MPI
        // --------- Stuff for the sub_boundaries ----- Begin section --------
        // Verify if need to deal with sub_boundaries
        if (this->is_mesh_distributed() && nsub_boundaries > 1)
        {
          // Create temporary representations for the boundaries, only to
          // create the mesh when calling Triangle
          // Clear all previous stored data
          this->Boundary_subpolylines[bound].clear();
          // Now create storage for the sub-boundaries
          this->Boundary_subpolylines[bound].resize(nsub_boundaries);
          for (unsigned isub = 0; isub < nsub_boundaries; isub++)
          {
            // Now update the polyline according to the sub set of
            // vertices, set the chunk number of the polyline
            TriangleMeshPolyLine* sub_tmp_polyline_pt =
              new TriangleMeshPolyLine(
                sub_vector_vertex_node[isub], bound, isub);

            // Add the sub-polyline to the container to represent the boundary
            // in parts
            this->Boundary_subpolylines[bound][isub] = sub_tmp_polyline_pt;

            // No need to send the unrefinement/refinement and maximum
            // length constraints since these are only temporary
            // representations. These polylines can be deleted once the
            // new polygons that represent the distributed domain have
            // been created

          } // for (isub < nsub_boundaries)

        } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
        // --------- Stuff for the sub_boundaries ----- End section ---------
#endif // OOMPH_HAS_MPI

      } // update polyline representation

      // Delete the allocated memory for the geometric object that
      // represents the curvilinear boundary
      delete mesh_geom_obj_pt;

    } // npolyline

    // Cleanup the face mesh
    for (unsigned p = 0; p < n_polyline; p++)
    {
      face_mesh_pt[p]->flush_node_storage();
      delete face_mesh_pt[p];
    }
  }


  //======================================================================
  /// Updates the open curve representation after restart
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::update_open_curve_after_restart(
    TriangleMeshOpenCurve*& open_curve_pt)
  {
    // **********************************************************************
    // 1) Get the vertices along the boundaries ids of the polylines and
    //    update them
    // **********************************************************************

    // (1.1) Get the face mesh representation
    Vector<Mesh*> face_mesh_pt;
    get_face_mesh_representation(open_curve_pt, face_mesh_pt);

    // (1.2) Create vertices of the polylines by using the vertices of the
    //       FaceElements
    Vector<double> vertex_coord(3); // zeta,x,y
    Vector<double> bound_left(1);
    Vector<double> bound_right(1);

    const unsigned ncurve_section = open_curve_pt->ncurve_section();
    // Go for each curve section
    for (unsigned cs = 0; cs < ncurve_section; cs++)
    {
      // Get the MeshAsGeomObject representation just once per polyline,
      // this object is only used by the
      // refine_boundary_constrained_by_target_area() method. We get it here
      // to ensure that all processors (in a distributed context) get this
      // representation just once, and because an AllToAll MPI communication
      // is used in this calling
      MeshAsGeomObject* mesh_geom_obj_pt =
        new MeshAsGeomObject(face_mesh_pt[cs]);

      // Get the boundary id
      const unsigned bound = open_curve_pt->curve_section_pt(cs)->boundary_id();

      /// Use a vector of vector for vertices and target areas to deal
      /// with the cases when the boundaries are split bn the
      /// distribution process. Internal boundaries may be completely or
      /// partially overlapped by shared boundaries

      // Loop over the face elements and add their vertices (they are
      // automatically sorted because of the set)
      const unsigned nface_element = face_mesh_pt[cs]->nelement();
      // Store the non halo elements and the element at the other side of
      // the boundary (whatever it be halo or not), the first will be the
      // ones from which we will get the vertices (in even position)
      Vector<FiniteElement*> non_halo_doubled_face_element_pt;

      // Map to store the index of the face element on a boundary
      std::map<FiniteElement*, unsigned> face_element_index_on_boundary;

      // Map to know the already sorted face elements
      std::map<FiniteElement*, bool> face_element_done;

      for (unsigned ef = 0; ef < nface_element; ++ef)
      {
        FiniteElement* ele_face_pt = face_mesh_pt[cs]->finite_element_pt(ef);

        // Skip the halo elements (not used as base elements, only
        // include those elements which one of its counterparts -- at the
        // other side of the boundary -- is non halo)
#ifdef OOMPH_HAS_MPI
        if (this->is_mesh_distributed())
        {
          // Only work with non-halo elements
          if (ele_face_pt->is_halo())
          {
            continue;
          }
        }
#endif

        // Check if not already done
        if (!face_element_done[ele_face_pt])
        {
          // Add the element and look for the element at the other side
          // of the boundary to add it immediately after the new added
          // element
          non_halo_doubled_face_element_pt.push_back(ele_face_pt);
          // Create the map of the face element with the index
          face_element_index_on_boundary[ele_face_pt] = ef;
          // Mark the current element as done
          face_element_done[ele_face_pt] = true;
          // Get the number of nodes
          const unsigned nnodes = ele_face_pt->nnode();
          // Get the left and right node to look for the elements at the
          // other side of the boundary
          Node* left_node_pt = ele_face_pt->node_pt(0);
          Node* right_node_pt = ele_face_pt->node_pt(nnodes - 1);

#ifdef PARANOID
          // Flag to know if the element at the other side of the
          // boundary was found
          bool found_other_side_face_ele = false;
#endif
          for (unsigned iface = 0; iface < nface_element; iface++)
          {
            // Get the candidate face element
            FiniteElement* cele_face_pt =
              face_mesh_pt[cs]->finite_element_pt(iface);
            // Check if not already done
            if (!face_element_done[cele_face_pt])
            {
              Node* cleft_node_pt = cele_face_pt->node_pt(0);
              Node* cright_node_pt = cele_face_pt->node_pt(nnodes - 1);

              // Check if the nodes are the same
              if ((left_node_pt == cleft_node_pt &&
                   right_node_pt == cright_node_pt) ||
                  (left_node_pt == cright_node_pt &&
                   right_node_pt == cleft_node_pt))
              {
                // Add the element to the storage
                non_halo_doubled_face_element_pt.push_back(cele_face_pt);
                // ... and mark the element as done
                face_element_done[cele_face_pt] = true;
                // Create the map of the face element with the index
                face_element_index_on_boundary[cele_face_pt] = iface;
#ifdef PARANOID
                // Set the flag of found other side face element
                found_other_side_face_ele = true;
#endif
                break;
              }
            }
          } // (iface < nface_element)

#ifdef PARANOID
          if (!found_other_side_face_ele)
          {
            std::ostringstream error_message;
            error_message
              << "The face element at the other side of the boundary (" << bound
              << ") was not found!!\n"
              << "These are the nodes of the face element:\n"
              << "(" << left_node_pt->x(0) << ", " << left_node_pt->x(1) << ") "
              << "and (" << right_node_pt->x(0) << "," << right_node_pt->x(1)
              << ")\n\n";
            throw OomphLibError(
              error_message.str(),
              "RefineableTriangleMesh::update_open_curve_after_restart()",
              OOMPH_EXCEPTION_LOCATION);
          }
#endif
        } // if (!face_ele_done[ele_face_pt])

      } // (ef < nface_element)

      // Clear the map of the already done face elements
      // This will now be used to sort the face elements
      face_element_done.clear();

      // Set of coordinates that are on the boundary
      // The entries are sorted on first entry in vector which stores
      // the boundary coordinate so the vertices come out in order!
      std::set<Vector<double>> vertex_nodes;

      // Vector to store the vertices, transfer the sorted vertices from the
      // set to this vector, --- including the z-value ---
      Vector<Vector<double>> tmp_vector_vertex_node;

      // Vector to store the coordinates of the polylines, same as the
      // tmp_vector_vertex_node vector (after adding more nodes) but
      // --- without the z-value ---, used to re-generate the polylines
      Vector<Vector<double>> vector_vertex_node;

#ifdef OOMPH_HAS_MPI
      // Indicates if the set of vertices give rise to a internal
      // boundary that will be used as shared boundary or as normal
      // internal boundary -- Only used to deal with internal boundaries
      // in a distributed scheme
      std::vector<bool> internal_to_shared_boundary;

      // --------- Stuff to deal with splitted boundaries ---------- Begin -----
      // Set of coordinates that are on the boundary (splitted boundary version)
      // The first vector is used to allocate the points for each sub-boundary
      // Set entries are ordered on first entry in vector which stores
      // the boundary coordinate so the vertices come out in order!
      Vector<std::set<Vector<double>>> sub_vertex_nodes;

      // Vector to store the vertices, transfer the sorted vertices from the
      // set (sub_vertex_nodes) to this vector, --- including the z-value ---
      Vector<Vector<Vector<double>>> sub_tmp_vector_vertex_node;

      // Vector to store the coordinates of the polylines that will represent
      // the splitted boundary. Used to pass the info. from sub_vertex_nodes
      // but --- without the z-value ---, used to generate the sub-polylines
      Vector<Vector<Vector<double>>> sub_vector_vertex_node;

      // --------- Stuff to deal with splitted boundaries ----------- End ------
#endif

      // Sort face elements, separate those with both nonhalo face
      // elements from those with one halo and one nonhalo face element

      // Number of done face elements
      unsigned nsorted_face_elements = 0;

#ifdef OOMPH_HAS_MPI
      // Counter for sub_boundaries
      unsigned nsub_boundaries = 0;
#endif // #ifdef OOMPH_HAS_MPI

      // Total number of non halo double face element
      const unsigned nnon_halo_doubled_face_ele =
        non_halo_doubled_face_element_pt.size();

      // Continue until all the face elements have been sorted
      // This while is to deal with the cases of splitted boundaries
      while (nsorted_face_elements < nnon_halo_doubled_face_ele)
      {
        // Get and initial face element
        FiniteElement* ele_face_pt = 0;
        FiniteElement* repeated_ele_face_pt = 0;
#ifdef PARANOID
        bool found_initial_face_element = false;
#endif

        // Flag to know if we are working with a face element which the
        // face element at the other side of the boundary is also non
        // halo
        bool both_root_face_elements_are_nonhalo = false;

        unsigned iface = 0;
        for (iface = 0; iface < nnon_halo_doubled_face_ele; iface += 2)
        {
          ele_face_pt = non_halo_doubled_face_element_pt[iface];
          // If not done then take it as initial face element
          if (!face_element_done[ele_face_pt])
          {
            // Mark it as done
            face_element_done[ele_face_pt] = true;
            // Get the other side boundary face element
            repeated_ele_face_pt = non_halo_doubled_face_element_pt[iface + 1];
            // ... also mark as done the repeated face element
            face_element_done[repeated_ele_face_pt] = true;

#ifdef OOMPH_HAS_MPI
            if (!repeated_ele_face_pt->is_halo())
            {
              both_root_face_elements_are_nonhalo = true;
            }
#endif // #ifdef OOMPH_HAS_MPI

            // Plus two because internal boundaries have
            // two face elements per each edge
            nsorted_face_elements += 2;
            iface += 2;
#ifdef PARANOID
            // And set the flag to true
            found_initial_face_element = true;
#endif
            break;
          }
        }

#ifdef PARANOID
        if (!found_initial_face_element)
        {
          std::ostringstream error_message;
          error_message << "Could not find an initial face element for the "
                           "current segment\n";
          // << "----- Possible memory leak -----\n";
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // Local set of coordinates that are on the boundary Set entries
        // are ordered on first entry in vector which stores the boundary
        // coordinate so the vertices come out in order
        std::set<Vector<double>> local_vertex_nodes;

        // Vector to store the vertices, transfer the sorted vertices from the
        // set (local) to this vector (local), --- including the z-value ---
        Vector<Vector<double>> local_tmp_vector_vertex_node;

        // ------------------------------------------------------------------
        // ------------------------------------------------------------------
        // Add the vertices of the initial face element to the set of local
        // sorted vertices
        // ------------------------------------------------------------------
        // ------------------------------------------------------------------
        const unsigned nnode = ele_face_pt->nnode();
        // Add the left-hand node to the set:
        // Boundary coordinate
        ele_face_pt->node_pt(0)->get_coordinates_on_boundary(bound, bound_left);
        vertex_coord[0] = bound_left[0];

        // Actual coordinates
        for (unsigned i = 0; i < 2; i++)
        {
          vertex_coord[i + 1] = ele_face_pt->node_pt(0)->x(i);
        }
        local_vertex_nodes.insert(vertex_coord);

        // Add the right-hand node to the set:
        // Boundary coordinate
        ele_face_pt->node_pt(nnode - 1)->get_coordinates_on_boundary(
          bound, bound_right);
        vertex_coord[0] = bound_right[0];

        // Actual coordinates
        for (unsigned i = 0; i < 2; i++)
        {
          vertex_coord[i + 1] = ele_face_pt->node_pt(nnode - 1)->x(i);
        }
        local_vertex_nodes.insert(vertex_coord);

        // The initial and final node on the set
        Node* first_node_pt = ele_face_pt->node_pt(0);
        Node* last_node_pt = ele_face_pt->node_pt(nnode - 1);

        // Continue iterating if a new face element has been added to the
        // list
        bool face_element_added = false;

        // While a new face element has been added to the set of sorted
        // face elements then re-iterate
        do
        {
          // Start from the next face elements since we have already
          // added the previous one as the initial face element (any
          // previous face element had to be added on previous
          // iterations)
          for (unsigned iiface = iface; iiface < nnon_halo_doubled_face_ele;
               iiface += 2)
          {
            face_element_added = false;
            ele_face_pt = non_halo_doubled_face_element_pt[iiface];

            // Check that the face element with which we are working has
            // the same conditions as the root face element (both faces
            // are nonhalo or one face is halo and the other nonhalo)

            // Get the face element at the other side of the boundary
            repeated_ele_face_pt = non_halo_doubled_face_element_pt[iiface + 1];
            bool both_face_elements_are_nonhalo = false;

#ifdef OOMPH_HAS_MPI
            if (!repeated_ele_face_pt->is_halo())
            {
              both_face_elements_are_nonhalo = true;
            }
#endif // #ifdef OOMPH_HAS_MPI

            if (!face_element_done[ele_face_pt] &&
                (both_face_elements_are_nonhalo ==
                 both_root_face_elements_are_nonhalo))
            {
              // Get each individual node to check if they are contiguous
              const unsigned nlnode = ele_face_pt->nnode();
              Node* left_node_pt = ele_face_pt->node_pt(0);
              Node* right_node_pt = ele_face_pt->node_pt(nlnode - 1);

              if (left_node_pt == first_node_pt)
              {
                first_node_pt = right_node_pt;
                face_element_added = true;
              }
              else if (left_node_pt == last_node_pt)
              {
                last_node_pt = right_node_pt;
                face_element_added = true;
              }
              else if (right_node_pt == first_node_pt)
              {
                first_node_pt = left_node_pt;
                face_element_added = true;
              }
              else if (right_node_pt == last_node_pt)
              {
                last_node_pt = left_node_pt;
                face_element_added = true;
              }

              if (face_element_added)
              {
                // Add the left-hand node to the set:
                // Boundary coordinate
                left_node_pt->get_coordinates_on_boundary(bound, bound_left);
                vertex_coord[0] = bound_left[0];

                // Actual coordinates
                for (unsigned i = 0; i < 2; i++)
                {
                  vertex_coord[i + 1] = left_node_pt->x(i);
                }
                local_vertex_nodes.insert(vertex_coord);

                // Add the right-hand nodes to the set:
                // Boundary coordinate
                right_node_pt->get_coordinates_on_boundary(bound, bound_right);
                vertex_coord[0] = bound_right[0];

                // Actual coordinates
                for (unsigned i = 0; i < 2; i++)
                {
                  vertex_coord[i + 1] = right_node_pt->x(i);
                }
                local_vertex_nodes.insert(vertex_coord);

                // Mark as done only if one of its nodes has been
                // added to the list
                face_element_done[ele_face_pt] = true;
                // .. also mark as done the face element at the othe side of
                // the boundary
                repeated_ele_face_pt =
                  non_halo_doubled_face_element_pt[iiface + 1];
                face_element_done[repeated_ele_face_pt] = true;
                // ... and increase the number of sorted face elements
                nsorted_face_elements += 2;

                break;
              }

            } // if (!face_element_done[[ele_face_pt])
          } // for (iiface<nnon_halo_doubled_face_ele)
        } while (face_element_added &&
                 (nsorted_face_elements < nnon_halo_doubled_face_ele));

        // -------------------------------------------------------------
        // At this point we already have a sorted set of nodes and can
        // be used to peform the unrefinement and refinement procedures
        // -------------------------------------------------------------

        // Get the number of nodes on the list
        const unsigned nlocal_nodes = local_vertex_nodes.size();
        // Change representation to vector for easy of handling ...
        local_tmp_vector_vertex_node.resize(nlocal_nodes);

        // Copy the vertices of the nodes
        unsigned counter = 0;
        std::set<Vector<double>>::iterator it_vertex;
        for (it_vertex = local_vertex_nodes.begin();
             it_vertex != local_vertex_nodes.end();
             it_vertex++)
        {
          local_tmp_vector_vertex_node[counter].resize(3);
          local_tmp_vector_vertex_node[counter][0] = (*it_vertex)[0];
          local_tmp_vector_vertex_node[counter][1] = (*it_vertex)[1];
          local_tmp_vector_vertex_node[counter][2] = (*it_vertex)[2];
          counter++;
        }

        // The unrefinement and refinement process needs to be applied
        // from the bottom-left node since the internal open curve could
        // lie on the shared boundaries
        if (local_tmp_vector_vertex_node[nlocal_nodes - 1][2] <
            local_tmp_vector_vertex_node[0][2])
        {
          std::reverse(local_tmp_vector_vertex_node.begin(),
                       local_tmp_vector_vertex_node.end());
        }
        else if (local_tmp_vector_vertex_node[nlocal_nodes - 1][2] ==
                 local_tmp_vector_vertex_node[0][2])
        {
          if (local_tmp_vector_vertex_node[nlocal_nodes - 1][1] <
              local_tmp_vector_vertex_node[0][1])
          {
            std::reverse(local_tmp_vector_vertex_node.begin(),
                         local_tmp_vector_vertex_node.end());
          }
        }

        // ****************************************************************
        // 3) Create the vertices along the boundary using the target
        // area to define the distance among them
        // ****************************************************************

        // Clear the local containter to recover the nodes ordered using
        // the zeta value
        local_vertex_nodes.clear();

        // At the end of each unrefinement/refinement step store the new
        // nodes on the set that will give rise to the vertices of the
        // new polyline representation
        const unsigned nnew_nodes = local_tmp_vector_vertex_node.size();
        for (unsigned i = 0; i < nnew_nodes; i++)
        {
          vertex_coord[0] = local_tmp_vector_vertex_node[i][0];
          vertex_coord[1] = local_tmp_vector_vertex_node[i][1];
          vertex_coord[2] = local_tmp_vector_vertex_node[i][2];
          vertex_nodes.insert(vertex_coord); // Global container
          local_vertex_nodes.insert(vertex_coord);
        }

#ifdef OOMPH_HAS_MPI
        if (this->is_mesh_distributed())
        {
          // Add the set of vertices for the boundary, this will help to
          // detect if we need to deal with sub_boundaries and
          // sub_polylines representations
          sub_vertex_nodes.push_back(local_vertex_nodes);
          // Increase the counter for sub_boundaries
          nsub_boundaries++;

          // Mark if the polyline created by these vertices will be used
          // as a shared boundary or as an internal boundary
          if (both_root_face_elements_are_nonhalo)
          {
            internal_to_shared_boundary.push_back(false);
          }
          else
          {
            internal_to_shared_boundary.push_back(true);
          }
        }
#endif

      } // while(nsorted_face_elements < nnon_halo_doubled_face_ele)
        // This while is in charge of sorting all the face elements to
        // create the new representation of the polyline (also deals
        // with the sub-boundary cases)

      // Now turn into vector for ease of handling...
      const unsigned npoly_vertex = vertex_nodes.size();
      tmp_vector_vertex_node.resize(npoly_vertex);
      unsigned count = 0;
      std::set<Vector<double>>::iterator it;
      for (it = vertex_nodes.begin(); it != vertex_nodes.end(); ++it)
      {
        tmp_vector_vertex_node[count].resize(3);
        tmp_vector_vertex_node[count][0] = (*it)[0];
        tmp_vector_vertex_node[count][1] = (*it)[1];
        tmp_vector_vertex_node[count][2] = (*it)[2];
        ++count;
      }

#ifdef OOMPH_HAS_MPI
      // Check that the number of set of vertices marked to be shared or
      // internal boundaries be the same as the total number of
      // sub-boundaries
#ifdef PARANOID
      const unsigned nsub_boundaries_set = sub_vertex_nodes.size();
      const unsigned ninternal_to_shared_boundaries =
        internal_to_shared_boundary.size();
      if (nsub_boundaries_set != ninternal_to_shared_boundaries)
      {
        std::ostringstream error_message;
        error_message
          << "The number of found sub-boundaries and the number of marked "
          << "internal\nboundaries are different\n"
          << "Number of found sub-boundaries: (" << nsub_boundaries_set << ")\n"
          << "Number of marked internal boundaries: ("
          << ninternal_to_shared_boundaries << ")\n\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::update_open_curve_after_restart()",
          OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // --------- Stuff for the sub_boundaries ----- Begin section -------
#ifdef PARANOID
      if (nsub_boundaries_set != nsub_boundaries)
      {
        std::ostringstream error_message;
        error_message
          << "The number of found sub-boundaries and the number of counted\n"
          << "sub-boundaries are different:\n"
          << "Number of found sub-boundaries: (" << nsub_boundaries_set << ")\n"
          << "Number of counted sub-boundaries: (" << nsub_boundaries
          << ")\n\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::update_open_curve_after_restart()",
          OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Verify if need to deal with sub_boundaries
      if (this->is_mesh_distributed() && nsub_boundaries > 1)
      {
        // Mark the boundary as been splitted in the partition process
        this->Boundary_was_splitted[bound] = true;
        // Resize the vector to store the info. of sub-boundaries
        sub_tmp_vector_vertex_node.resize(nsub_boundaries);
        for (unsigned isub = 0; isub < nsub_boundaries; isub++)
        {
          // Turn info. into vector for ease of handling...
          const unsigned nsubpoly_vertex = sub_vertex_nodes[isub].size();
          sub_tmp_vector_vertex_node[isub].resize(nsubpoly_vertex);
          unsigned subcount = 0;
          std::set<Vector<double>>::iterator subit;
          for (subit = sub_vertex_nodes[isub].begin();
               subit != sub_vertex_nodes[isub].end();
               ++subit)
          {
            sub_tmp_vector_vertex_node[isub][subcount].resize(3);
            sub_tmp_vector_vertex_node[isub][subcount][0] = (*subit)[0];
            sub_tmp_vector_vertex_node[isub][subcount][1] = (*subit)[1];
            sub_tmp_vector_vertex_node[isub][subcount][2] = (*subit)[2];
            ++subcount;
          }
        }
      } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
      // --------- Stuff for the sub_boundaries ----- End section ----------
#endif // OOMPH_HAS_MPI

      // For further processing the three-dimensional vector has to be
      // reduced to a two-dimensional vector
      unsigned n_vertex = tmp_vector_vertex_node.size();

      // Resize the vector for vectices
      vector_vertex_node.resize(n_vertex);
      for (unsigned i = 0; i < n_vertex; i++)
      {
        vector_vertex_node[i].resize(2);
        vector_vertex_node[i][0] = tmp_vector_vertex_node[i][1];
        vector_vertex_node[i][1] = tmp_vector_vertex_node[i][2];
      }

#ifdef OOMPH_HAS_MPI
      // --------- Stuff for the sub_boundaries ----- Begin section ----------
      // Verify if need to deal with sub_boundaries
      if (this->is_mesh_distributed() && nsub_boundaries > 1)
      {
        // For further processing the three-dimensional vector
        // has to be reduced to a two-dimensional vector
        // Resize the vector to store the info. of sub-boundaries
        sub_vector_vertex_node.resize(nsub_boundaries);
        for (unsigned isub = 0; isub < nsub_boundaries; isub++)
        {
          const unsigned subn_vertex = sub_tmp_vector_vertex_node[isub].size();
          // Resize the vector for vectices
          sub_vector_vertex_node[isub].resize(subn_vertex);
          for (unsigned i = 0; i < subn_vertex; i++)
          {
            sub_vector_vertex_node[isub][i].resize(2);
            sub_vector_vertex_node[isub][i][0] =
              sub_tmp_vector_vertex_node[isub][i][1];
            sub_vector_vertex_node[isub][i][1] =
              sub_tmp_vector_vertex_node[isub][i][2];
          }
        }
      } // if (this->is_mesh_distributed() && nsub_boundaries > 1)

      // We already have the info. for the sub-boundaries (if necessary) and
      // then we can create the sub-boundaries representations to ease the
      // generation of the mesh by Triangle

      // --------- Stuff for the sub_boundaries ----- End section ------------
#endif // OOMPH_HAS_MPI

      // *********************************************************************
      // 4) Check for contiguousness
      // *********************************************************************
#ifdef OOMPH_HAS_MPI
      // Only perform this checking if the mesh is not distributed
      // When the mesh is distributed the polylines continuity is
      // addressed with the sort_polylines_helper() method
      if (!this->is_mesh_distributed())
#endif
      {
        if (cs > 0)
        {
          // Final end point of previous line
          Vector<double> final_vertex_of_previous_segment;
          unsigned n_prev_vertex =
            open_curve_pt->curve_section_pt(cs - 1)->nvertex();
          final_vertex_of_previous_segment =
            open_curve_pt->polyline_pt(cs - 1)->vertex_coordinate(
              n_prev_vertex - 1);

          unsigned prev_seg_boundary_id =
            open_curve_pt->curve_section_pt(cs - 1)->boundary_id();

          // Find the error between the final vertex of the previous
          // line and the first vertex of the current line
          double error = 0.0;
          for (unsigned i = 0; i < 2; i++)
          {
            const double dist = final_vertex_of_previous_segment[i] -
                                (*vector_vertex_node.begin())[i];
            error += dist * dist;
          }
          error = sqrt(error);

          // If the error is bigger than the tolerance then
          // we probably need to reverse, but better check
          if (error > ToleranceForVertexMismatchInPolygons::Tolerable_error)
          {
            // Find the error between the final vertex of the previous
            // line and the last vertex of the current line
            double rev_error = 0.0;
            for (unsigned i = 0; i < 2; i++)
            {
              const double dist = final_vertex_of_previous_segment[i] -
                                  (*--vector_vertex_node.end())[i];
              rev_error += dist * dist;
            }
            rev_error = sqrt(rev_error);

            if (rev_error >
                ToleranceForVertexMismatchInPolygons::Tolerable_error)
            {
              // It could be possible that the first segment be reversed and we
              // did not notice it because this check does not apply for the
              // first segment. We can verify if the first segment is reversed
              // by using the vertex number 1
              if (cs == 1)
              {
                // Initial end point of previous line
                Vector<double> initial_vertex_of_previous_segment;

                initial_vertex_of_previous_segment =
                  open_curve_pt->polyline_pt(cs - 1)->vertex_coordinate(0);

                unsigned prev_seg_boundary_id =
                  open_curve_pt->curve_section_pt(cs - 1)->boundary_id();

                // Find the error between the initial vertex of the previous
                // line and the first vertex of the current line
                double error = 0.0;
                for (unsigned i = 0; i < 2; i++)
                {
                  const double dist = initial_vertex_of_previous_segment[i] -
                                      (*vector_vertex_node.begin())[i];
                  error += dist * dist;
                }
                error = sqrt(error); // Reversed only the previous one

                // If the error is bigger than the tolerance then
                // we probably need to reverse, but better check
                if (error >
                    ToleranceForVertexMismatchInPolygons::Tolerable_error)
                {
                  // Find the error between the final vertex of the previous
                  // line and the last vertex of the current line
                  double rev_error = 0.0;
                  for (unsigned i = 0; i < 2; i++)
                  {
                    const double dist = initial_vertex_of_previous_segment[i] -
                                        (*--vector_vertex_node.end())[i];
                    rev_error += dist * dist;
                  }
                  rev_error = sqrt(rev_error); // Reversed both the current
                                               // one and the previous one

                  if (rev_error >
                      ToleranceForVertexMismatchInPolygons::Tolerable_error)
                  {
                    std::ostringstream error_stream;
                    error_stream
                      << "The distance between the first node of the current\n"
                      << "line segment (boundary " << bound
                      << ") and either end of "
                      << "the previous line segment\n"
                      << "(boundary " << prev_seg_boundary_id
                      << ") is bigger than"
                      << " the desired tolerance "
                      << ToleranceForVertexMismatchInPolygons::Tolerable_error
                      << ".\n"
                      << "This suggests that the polylines defining the "
                         "polygonal\n"
                      << "representation are not properly ordered.\n"
                      << "Fail on last vertex of polyline: ("
                      << prev_seg_boundary_id
                      << ") and\nfirst vertex of polyline (" << bound
                      << ").\nThis should have failed when first trying to "
                      << "construct the\npolygon.\n";
                    throw OomphLibError(error_stream.str(),
                                        "RefineableTriangleMesh::update_open_"
                                        "curve_after_restart()",
                                        OOMPH_EXCEPTION_LOCATION);
                  }
                  else
                  {
                    // Reverse both
                    // Reverse the current vector to line up with the previous
                    // one
                    std::reverse(vector_vertex_node.begin(),
                                 vector_vertex_node.end());
                    open_curve_pt->polyline_pt(cs - 1)->reverse();
                  }
                }
                else
                {
                  // Reverse the previous one
                  open_curve_pt->polyline_pt(cs - 1)->reverse();
                }

              } // if (cs == 1)
              else
              {
                std::ostringstream error_stream;
                error_stream
                  << "The distance between the first node of the current\n"
                  << "line segment (boundary " << bound
                  << ") and either end of "
                  << "the previous line segment\n"
                  << "(boundary " << prev_seg_boundary_id
                  << ") is bigger than the "
                  << "desired tolerance "
                  << ToleranceForVertexMismatchInPolygons::Tolerable_error
                  << ".\n"
                  << "This suggests that the polylines defining the polygonal\n"
                  << "representation are not properly ordered.\n"
                  << "Fail on last vertex of polyline: ("
                  << prev_seg_boundary_id << ") and\nfirst vertex of polyline ("
                  << bound << ").\n"
                  << "This should have failed when first trying to construct "
                     "the\n"
                  << "polygon.\n";
                throw OomphLibError(
                  error_stream.str(),
                  "RefineableTriangleMesh::update_open_curve_after_restart()",
                  OOMPH_EXCEPTION_LOCATION);
              }
            }
            else
            {
              // Reverse the current vector to line up with the previous one
              std::reverse(vector_vertex_node.begin(),
                           vector_vertex_node.end());
            }
          } // error
        } // (cs > 0)
      } // is mesh not distributed

      //   DEBP(applied_area_length_constraint);
      //   DEBP(p);
      //   getchar();
      // *********************************************************************
      // 5) Update the polylines representation
      // *********************************************************************
      //   if (applied_area_length_constraint)
      // If only applied when there is a change then it keeps the
      // previous polyline representation, it means, it does not delete
      // the boundaries that are not part of the domain. We must update
      // the boundary representation
      {
        n_vertex = vector_vertex_node.size();

        // Now update the polyline according to the new vertices
        // The new one representation
        TriangleMeshPolyLine* tmp_polyline_pt =
          new TriangleMeshPolyLine(vector_vertex_node, bound);

        // Create a temporal "curve section" version of the recently created
        // polyline
        TriangleMeshCurveSection* tmp_curve_section_pt = tmp_polyline_pt;

        // Tolerance below which the middle point can be deleted
        // (ratio of deflection to element length)
        double unrefinement_tolerance =
          open_curve_pt->polyline_pt(cs)->unrefinement_tolerance();

        // Tolerance to add points
        double refinement_tolerance =
          open_curve_pt->polyline_pt(cs)->refinement_tolerance();

        // Establish refinement and unrefinement tolerance
        tmp_polyline_pt->set_unrefinement_tolerance(unrefinement_tolerance);
        tmp_polyline_pt->set_refinement_tolerance(refinement_tolerance);

        // Establish the maximum length constraint
        double maximum_length =
          open_curve_pt->polyline_pt(cs)->maximum_length();
        tmp_polyline_pt->set_maximum_length(maximum_length);

        if (n_vertex >= 2)
        {
          // Pass the connection information from the old polyline to the
          // new one
          this->copy_connection_information(open_curve_pt->polyline_pt(cs),
                                            tmp_curve_section_pt);
        }

        // Now update the polyline according to the new vertices but first
        // check if the object is allowed to delete the representation or
        // if it should be done by other object
        bool delete_it_on_destructor = false;

        std::set<TriangleMeshCurveSection*>::iterator it =
          this->Free_curve_section_pt.find(open_curve_pt->curve_section_pt(cs));

        if (it != this->Free_curve_section_pt.end())
        {
          this->Free_curve_section_pt.erase(it);
          delete open_curve_pt->curve_section_pt(cs);
          delete_it_on_destructor = true;
        }

        // *****************************************************************
        // Copying the new representation
        open_curve_pt->curve_section_pt(cs) = tmp_polyline_pt;

        // Update the Boundary - Polyline map
        this->Boundary_curve_section_pt[bound] =
          open_curve_pt->curve_section_pt(cs);

        if (delete_it_on_destructor)
        {
          this->Free_curve_section_pt.insert(
            open_curve_pt->curve_section_pt(cs));
        }

#ifdef OOMPH_HAS_MPI

        // If there are not sub-boundaries mark the boundary if need to be
        // trated as shared or as internal boundary
        if (this->is_mesh_distributed() && nsub_boundaries == 1)
        {
          // Clear all previous stored data
          this->Boundary_marked_as_shared_boundary[bound].clear();

          // .. and store the flag for the boundary
          this->Boundary_marked_as_shared_boundary[bound].push_back(
            internal_to_shared_boundary[0]);
        }
        // --------- Stuff for the sub_boundaries ----- Begin section --------
        // Verify if need to deal with sub_boundaries
        else if (this->is_mesh_distributed() && nsub_boundaries > 1)
        {
          // Create temporary representations for the boundaries, only to
          // create the mesh when calling Triangle
          // Clear all previous stored data
          this->Boundary_subpolylines[bound].clear();
          // Now create storage for the sub-boundaries
          this->Boundary_subpolylines[bound].resize(nsub_boundaries);

          // Clear all previous stored data
          this->Boundary_marked_as_shared_boundary[bound].clear();
          // Create storage to mark the internal boundaries as shared
          // boundaries
          this->Boundary_marked_as_shared_boundary[bound].resize(
            nsub_boundaries);
          for (unsigned isub = 0; isub < nsub_boundaries; isub++)
          {
            // Now update the polyline according to the sub set of
            // vertices, set the chunk number of the polyline
            TriangleMeshPolyLine* sub_tmp_polyline_pt =
              new TriangleMeshPolyLine(
                sub_vector_vertex_node[isub], bound, isub);

            // Add the sub-polyline to the container to represent the
            // boundary in parts
            this->Boundary_subpolylines[bound][isub] = sub_tmp_polyline_pt;

            // Copy the flag that mark the boundary as internal or as
            // shared bound
            this->Boundary_marked_as_shared_boundary[bound][isub] =
              internal_to_shared_boundary[isub];

            // No need to send the unrefinement/refinement and maximum
            // length constraints since these are only temporary
            // representations
          }

        } // if (this->is_mesh_distributed() && nsub_boundaries > 1)
        // --------- Stuff for the sub_boundaries ----- End section ---------
#endif // OOMPH_HAS_MPI

      } // update polyline representation

      // Delete the allocated memory for the geometric object
      // that represents the curvilinear boundary
      delete mesh_geom_obj_pt;

    } // npolyline

    // Cleanup the face mesh
    for (unsigned p = 0; p < ncurve_section; p++)
    {
      face_mesh_pt[p]->flush_node_storage();
      delete face_mesh_pt[p];
    }
  }

#ifdef OOMPH_HAS_MPI
  //======================================================================
  /// Updates the shared polylines representation after restart
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::update_shared_curve_after_restart(
    Vector<TriangleMeshPolyLine*>& vector_polyline_pt)
  {
    // Go through all the shared boundaries/polylines
    const unsigned npolylines = vector_polyline_pt.size();
    for (unsigned pp = 0; pp < npolylines; pp++)
    {
      // Get the boundary of the current polyline
      const unsigned b = vector_polyline_pt[pp]->boundary_id();

      // Get the edges of the shared boundary elements that create the
      // shared boundary and store the shared boundary elements from where
      // were created
      std::map<std::pair<Node*, Node*>, FiniteElement*> halo_edge_element_pt;
      std::map<std::pair<Node*, Node*>, FiniteElement*> nonhalo_edge_element_pt;

      // Store the nodes that define the edges
      Vector<Node*> halo_edge_nodes_pt;
      Vector<Node*> nonhalo_edge_nodes_pt;

      // Go through the shared boundary elements and store their edges
      const unsigned nshared_bound_ele = this->nshared_boundary_element(b);
      for (unsigned e = 0; e < nshared_bound_ele; e++)
      {
        // Get the shared boundary element
        FiniteElement* current_ele_pt = this->shared_boundary_element_pt(b, e);

        // Get the corner nodes, the first three nodes
        Node* first_node_pt = current_ele_pt->node_pt(0);
        Node* second_node_pt = current_ele_pt->node_pt(1);
        Node* third_node_pt = current_ele_pt->node_pt(2);

        // Check if the elements is halo
        if (!current_ele_pt->is_halo())
        {
          // Store the edges
          nonhalo_edge_nodes_pt.push_back(first_node_pt);
          nonhalo_edge_nodes_pt.push_back(second_node_pt);

          nonhalo_edge_nodes_pt.push_back(second_node_pt);
          nonhalo_edge_nodes_pt.push_back(third_node_pt);

          nonhalo_edge_nodes_pt.push_back(third_node_pt);
          nonhalo_edge_nodes_pt.push_back(first_node_pt);

          // Store the info. of the element used to create these edges
          std::pair<Node*, Node*> edge1 =
            std::make_pair(first_node_pt, second_node_pt);
          nonhalo_edge_element_pt[edge1] = current_ele_pt;

          std::pair<Node*, Node*> edge2 =
            std::make_pair(second_node_pt, third_node_pt);
          nonhalo_edge_element_pt[edge2] = current_ele_pt;

          std::pair<Node*, Node*> edge3 =
            std::make_pair(third_node_pt, first_node_pt);
          nonhalo_edge_element_pt[edge3] = current_ele_pt;
        }
        else
        {
          // Store the edges
          halo_edge_nodes_pt.push_back(first_node_pt);
          halo_edge_nodes_pt.push_back(second_node_pt);

          halo_edge_nodes_pt.push_back(second_node_pt);
          halo_edge_nodes_pt.push_back(third_node_pt);

          halo_edge_nodes_pt.push_back(third_node_pt);
          halo_edge_nodes_pt.push_back(first_node_pt);

          // Store the info. of the element used to create these edges
          std::pair<Node*, Node*> edge1 =
            std::make_pair(first_node_pt, second_node_pt);
          halo_edge_element_pt[edge1] = current_ele_pt;

          std::pair<Node*, Node*> edge2 =
            std::make_pair(second_node_pt, third_node_pt);
          halo_edge_element_pt[edge2] = current_ele_pt;

          std::pair<Node*, Node*> edge3 =
            std::make_pair(third_node_pt, first_node_pt);
          halo_edge_element_pt[edge3] = current_ele_pt;
        }

      } // for (e < nshared_bound_ele)

      // Filter the edges that give rise to a shared boundary

      // Mark the done edges
      std::map<std::pair<Node*, Node*>, bool> edge_done;

      // Storage for the edges shared by the elements
      Vector<std::pair<Node*, Node*>> unsorted_edges;

      // Storage for the elements that created the unsorted edges (two
      // elements, one at each side of the shared boundary)
      Vector<Vector<FiniteElement*>> unsorted_edges_elements_pt;

      const unsigned nnonhalo_edge_nodes = nonhalo_edge_nodes_pt.size();
      for (unsigned i = 0; i < nnonhalo_edge_nodes; i += 2)
      {
        Vector<Node*> currenti_edge(2);
        currenti_edge[0] = nonhalo_edge_nodes_pt[i];
        currenti_edge[1] = nonhalo_edge_nodes_pt[i + 1];

        // Create the edge (both nodes that make the edge)
        std::pair<Node*, Node*> new_edge =
          std::make_pair(currenti_edge[0], currenti_edge[1]);

        if (!edge_done[new_edge])
        {
          const unsigned nhalo_edge_nodes = halo_edge_nodes_pt.size();
          for (unsigned j = 0; j < nhalo_edge_nodes; j += 2)
          {
            Vector<Node*> currentj_edge(2);
            currentj_edge[0] = halo_edge_nodes_pt[j];
            currentj_edge[1] = halo_edge_nodes_pt[j + 1];

            // Comparing pointer of nodes
            if (currenti_edge[0] == currentj_edge[0] &&
                currenti_edge[1] == currentj_edge[1])
            {
              // Store the edge in the proper container
              unsorted_edges.push_back(new_edge);

              // Get the elements associated with the edges
              Vector<FiniteElement*> tmp_edge_element_pt;

              FiniteElement* nonhalo_ele_pt = nonhalo_edge_element_pt[new_edge];
              FiniteElement* halo_ele_pt = halo_edge_element_pt[new_edge];

              tmp_edge_element_pt.push_back(nonhalo_ele_pt);
              tmp_edge_element_pt.push_back(halo_ele_pt);

              // Store the elements associated with the edge
              unsorted_edges_elements_pt.push_back(tmp_edge_element_pt);

              // Mark the edge as done
              edge_done[new_edge] = true;

              // Break the loop for (j < nedge_node)
              break;

            } // equal edge

            // Comparing pointer of nodes (reversed)
            else if (currenti_edge[0] == currentj_edge[1] &&
                     currenti_edge[1] == currentj_edge[0])
            {
              // Create the edge (both nodes that make the edge)
              std::pair<Node*, Node*> new_edge =
                std::make_pair(currenti_edge[0], currenti_edge[1]);

              // Store the edge in the proper container
              unsorted_edges.push_back(new_edge);

              // Create the (reversed) edge (both nodes that make the edge)
              std::pair<Node*, Node*> rev_new_edge =
                std::make_pair(currentj_edge[0], currentj_edge[1]);

              // Get the elements associated with the edge
              Vector<FiniteElement*> tmp_edge_element_pt;

              FiniteElement* nonhalo_ele_pt = nonhalo_edge_element_pt[new_edge];
              FiniteElement* halo_ele_pt = halo_edge_element_pt[rev_new_edge];

              tmp_edge_element_pt.push_back(nonhalo_ele_pt);
              tmp_edge_element_pt.push_back(halo_ele_pt);

              // Store the elements associated with the edge
              unsorted_edges_elements_pt.push_back(tmp_edge_element_pt);

              // Mark the edge as done
              edge_done[new_edge] = true;

              // Break the loop for (j < nedge_node)
              break;

            } // if (equal edge)

          } // for (j < nhalo_edge_nodes)

        } // if (!edge_done[new_edge])

      } // for (i < nnonhalo_edge_nodes)

      // We already have the edges that make the shared boundary (and the
      // elements)
      // Sort them to create a contiguous boundary

      // Mark the already sorted edges
      std::map<std::pair<Node*, Node*>, bool> edge_sorted;

      const unsigned nunsorted_edges = unsorted_edges.size();

#ifdef PARANOID
      // The number of unsorted edges must be the same as the number of
      // shared_boundary element / 2
      if (nshared_bound_ele / 2 != nunsorted_edges)
      {
        std::ostringstream error_message;
        error_message
          << "The number of shared boundary elements (" << nshared_bound_ele
          << ") is not the double\nof the number of unsorted edges ("
          << nunsorted_edges << ") for the current boundary (" << b << ")\n\n";
        throw OomphLibError(
          error_message.str(),
          "RefineableTriangleMesh::update_shared_curve_after_restart()",
          OOMPH_EXCEPTION_LOCATION);
      }
#endif

      unsigned nsorted_edges = 0;

      // Storing for the sorting nodes extracted from the edges, and
      // then used to update the polyline
      std::list<Node*> sorted_nodes;

      // Storing for the edges elements
      std::list<FiniteElement*> sorted_edges_elements_pt;

      // Get the root edge
      std::pair<Node*, Node*> edge = unsorted_edges[0];
      nsorted_edges++;

      // Mark edge as done
      edge_sorted[edge] = true;

      // The initial and final node on the list
      Node* first_node_pt = edge.first;
      Node* last_node_pt = edge.second;

      // Push back on the list the new edge (nodes)
      sorted_nodes.push_back(first_node_pt);
      sorted_nodes.push_back(last_node_pt);

      // Store the elements for the current edge
      sorted_edges_elements_pt.push_back(unsorted_edges_elements_pt[0][0]);
      sorted_edges_elements_pt.push_back(unsorted_edges_elements_pt[0][1]);

      // Iterate while the number of sorted edges be less than the number of
      // unsorted edges
      while (nsorted_edges < nunsorted_edges)
      {
        // Flag to indicate when a node was added
        bool node_added = false;

        // Start from the next edge since we have already added the
        // previous one as the initial edge
        for (unsigned iedge = 1; iedge < nunsorted_edges; iedge++)
        {
          edge = unsorted_edges[iedge];

          // If edge not done
          if (!edge_sorted[edge])
          {
            // Get each individual node
            Node* left_node_pt = edge.first;
            Node* right_node_pt = edge.second;

            if (left_node_pt == first_node_pt)
            {
              // Push front the new node
              sorted_nodes.push_front(right_node_pt);
              first_node_pt = right_node_pt;
              node_added = true;

              // Store the elements for the current edge
              sorted_edges_elements_pt.push_front(
                unsorted_edges_elements_pt[iedge][1]);
              sorted_edges_elements_pt.push_front(
                unsorted_edges_elements_pt[iedge][0]);
            }
            else if (left_node_pt == last_node_pt)
            {
              // Push back the new node
              sorted_nodes.push_back(right_node_pt);
              last_node_pt = right_node_pt;
              node_added = true;

              // Store the elements for the current edge
              sorted_edges_elements_pt.push_back(
                unsorted_edges_elements_pt[iedge][0]);
              sorted_edges_elements_pt.push_back(
                unsorted_edges_elements_pt[iedge][1]);
            }
            else if (right_node_pt == first_node_pt)
            {
              // Push front the new node
              sorted_nodes.push_front(left_node_pt);
              first_node_pt = left_node_pt;
              node_added = true;

              // Store the elements for the current edge
              sorted_edges_elements_pt.push_front(
                unsorted_edges_elements_pt[iedge][1]);
              sorted_edges_elements_pt.push_front(
                unsorted_edges_elements_pt[iedge][0]);
            }
            else if (right_node_pt == last_node_pt)
            {
              // Push back the new node
              sorted_nodes.push_back(left_node_pt);
              last_node_pt = left_node_pt;
              node_added = true;

              // Store the elements for the current edge
              sorted_edges_elements_pt.push_back(
                unsorted_edges_elements_pt[iedge][0]);
              sorted_edges_elements_pt.push_back(
                unsorted_edges_elements_pt[iedge][1]);
            }

            if (node_added)
            {
              // Mark as done only if one of its nodes has been
              // added to the list
              edge_sorted[edge] = true;
              nsorted_edges++;

              // Break the for
              break;
            }

          } // if (!edge_done[edge])
        } // for (iedge < nunsorted_edges)
      } // while (nsorted_edges < nunsorted_edges)

      // At this point we already have a sorted list of nodes, get the
      // vertices from them and store them in a vector container

      // Get the number of nodes on the list
      unsigned nvertex = sorted_nodes.size();
      // The vector to store the vertices (assign space)
      Vector<Vector<double>> polyline_vertices(nvertex);

      // Copy the vertices of the nodes
      unsigned counter = 0;
      for (std::list<Node*>::iterator it_nodes = sorted_nodes.begin();
           it_nodes != sorted_nodes.end();
           it_nodes++)
      {
        polyline_vertices[counter].resize(2);
        polyline_vertices[counter][0] = (*it_nodes)->x(0);
        polyline_vertices[counter][1] = (*it_nodes)->x(1);
        counter++;
      }

      // Before going to the unrefinement or refinement process check that
      // all processors start from the same vertex. Start from the bottom
      // left vertex
      if (polyline_vertices[nvertex - 1][1] < polyline_vertices[0][1])
      {
        std::reverse(polyline_vertices.begin(), polyline_vertices.end());
      }
      else if (polyline_vertices[nvertex - 1][1] == polyline_vertices[0][1])
      {
        if (polyline_vertices[nvertex - 1][0] < polyline_vertices[0][0])
        {
          std::reverse(polyline_vertices.begin(), polyline_vertices.end());
        }
      }

      // Create the polyline associated with this edge
      TriangleMeshPolyLine* new_polyline_pt =
        new TriangleMeshPolyLine(polyline_vertices, b);

      // Get the curve section representation
      TriangleMeshCurveSection* curve_section_pt = vector_polyline_pt[pp];

      // Copy the connection information from the old shared polyline
      // to the new one
      this->copy_connection_information(curve_section_pt, new_polyline_pt);

      // Now update the polyline according to the new vertices but first
      // check if the object is allowed to delete the representation
      // or if it should be done by other object
      bool delete_it_on_destructor = false;

      // Establish the element as being deleted by the destructor of
      // the class
      std::set<TriangleMeshCurveSection*>::iterator it =
        this->Free_curve_section_pt.find(curve_section_pt);

      if (it != this->Free_curve_section_pt.end())
      {
        this->Free_curve_section_pt.erase(it);
        delete curve_section_pt;
        delete_it_on_destructor = true;
      }

      // Copy the new representation
      vector_polyline_pt[pp] = new_polyline_pt;

      // Get the new curve section representation
      TriangleMeshCurveSection* new_curve_section_pt = vector_polyline_pt[pp];

      // Update the Boundary - Polyline map
      this->Boundary_curve_section_pt[b] = new_curve_section_pt;

      if (delete_it_on_destructor)
      {
        this->Free_curve_section_pt.insert(new_curve_section_pt);
      }

    } // for (pp < npoly)
  }

  //===================================================================
  // Fill the boundary elements structures when dealing with
  // shared boundaries that overlap internal boundaries. Document the
  // number of elements on the shared boundaries that go to internal
  // boundaries
  //===================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<
    ELEMENT>::fill_boundary_elements_and_nodes_for_internal_boundaries()
  {
    // Dummy file
    std::ofstream some_file;
    fill_boundary_elements_and_nodes_for_internal_boundaries(some_file);
  }

  //===================================================================
  // Fill the boundary elements structures when dealing with
  // shared boundaries that overlap internal boundaries
  //===================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::
    fill_boundary_elements_and_nodes_for_internal_boundaries(
      std::ofstream& outfile)
  {
    // Get the number of processors
    const unsigned nproc = this->communicator_pt()->nproc();
    // Get the rank of the current processor
    unsigned my_rank = this->communicator_pt()->my_rank();

    // Temporal name for the shared boundary overlaps structure
    std::map<unsigned, unsigned> shd_bnd_over_int_bnd =
      this->Shared_boundary_overlaps_internal_boundary;

    // Register the internal boundary elements that where found to be
    // overlapped by shared boundaries
    std::set<unsigned> internal_boundary_overlaped;

    // Document the number of elements and nodes associated to the
    // boundaries before filling elements and nodes
    if (outfile.is_open())
    {
      const unsigned nbound = this->nboundary();
      outfile << "Number of boundaries: " << nbound << "\n\n";
      outfile << "Number of elements and nodes associated to each "
              << "boundary before\nfilling elements and nodes\n\n";
      for (unsigned i = 0; i < nbound; i++)
      {
        outfile << "Boundary (" << i << ") Elements ("
                << this->nboundary_element(i) << ") "
                << "Nodes (" << this->nboundary_node(i) << ")\n";
      }
    }

    // Storage for the shared boundaries in this processor
    std::set<unsigned> shared_boundaries_in_this_processor;

    // Get the shared boundaries that this processor has with other
    // processors
    for (unsigned iproc = 0; iproc < nproc; iproc++)
    {
      // Work with other processors only
      if (iproc != my_rank)
      {
        // Get the number of boundaries shared with the "iproc"-th processor
        unsigned nshared_boundaries_with_iproc =
          this->nshared_boundaries(my_rank, iproc);

        if (nshared_boundaries_with_iproc > 0)
        {
          // Get the boundaries ids shared with "iproc"-th processor
          Vector<unsigned> bound_shared_with_iproc;
          bound_shared_with_iproc = this->shared_boundaries_ids(my_rank, iproc);

          // Loop over shared boundaries with "iproc"-th processor
          for (unsigned bs = 0; bs < nshared_boundaries_with_iproc; bs++)
          {
            unsigned bnd_id = bound_shared_with_iproc[bs];
            shared_boundaries_in_this_processor.insert(bnd_id);
          }
        }
      }
    }

    // ------------------------------------------------------------------
    // Copy the boundary elements and nodes from the shared boundary to
    // the internal boundary it overlaps
    // ------------------------------------------------------------------
    // Go through the shared boundaries that overlap internal boundaries
    for (std::map<unsigned, unsigned>::iterator it =
           shd_bnd_over_int_bnd.begin();
         it != shd_bnd_over_int_bnd.end();
         it++)
    {
      // The shared boundary id that overlaps with an internal boundary
      const unsigned shd_bnd_id = (*it).first;
      // The internal boundary overlapped by the shared boundary
      const unsigned int_bnd_id = (*it).second;

      // Check if the shared boundary exist in this processor
      std::set<unsigned>::iterator it_set =
        shared_boundaries_in_this_processor.find(shd_bnd_id);
      if (it_set != shared_boundaries_in_this_processor.end())
      {
        internal_boundary_overlaped.insert(int_bnd_id);

        // -----------------------------------------------------------------
        // First work the nodes of the shared boundaries that should be
        // added to the internal boundaries
        const unsigned nbnd_node_shd_bnd = this->nboundary_node(shd_bnd_id);

        // Document the number of nodes that will be passed to the internal
        // boundary from the current shared boundary
        if (outfile.is_open())
        {
          outfile << "\nPass info. from shared (" << shd_bnd_id
                  << ") to internal (" << int_bnd_id << ")\n";
          outfile << "Number of shared boundary nodes: " << nbnd_node_shd_bnd
                  << "\n";
        }

        for (unsigned in = 0; in < nbnd_node_shd_bnd; in++)
        {
          // Get the boundary node
          Node* bnd_node_pt = this->boundary_node_pt(shd_bnd_id, in);
          // Add the node to the internal boundary
          this->add_boundary_node(int_bnd_id, bnd_node_pt);
        }

        // -----------------------------------------------------------------
        // Second work the boundary elements
        // Get the number of boundary elements that should be copied to the
        // internal boundary
        const unsigned nbnd_ele_shd_bnd = this->nboundary_element(shd_bnd_id);

        // Document the number of elements that will be passed to the
        // internal boundary from the current shared boundary
        if (outfile.is_open())
        {
          outfile << "Number of shared boundary elements: " << nbnd_ele_shd_bnd
                  << "\n\n";
        }

        // Go through the boundary elements in the shrared boundary and add
        // them to the boundary elements of the internal boundary
        for (unsigned ie = 0; ie < nbnd_ele_shd_bnd; ie++)
        {
          // Get the boundary element
          FiniteElement* bnd_ele_pt = this->boundary_element_pt(shd_bnd_id, ie);
          // Add the element to the boundary elements storage of the
          // internal boundary
          Boundary_element_pt[int_bnd_id].push_back(bnd_ele_pt);
          // Get the face index of the boundary
          int face_index = this->face_index_at_boundary(shd_bnd_id, ie);
          // Add the face index to the storage of the boundary
          Face_index_at_boundary[int_bnd_id].push_back(face_index);

        } // for (ie < nbnd_ele_shd_bnd)

        // If there are regions we need to fill the storage for regions too
        const unsigned nregions = this->nregion();
        if (nregions > 1)
        {
          for (unsigned ir = 0; ir < nregions; ir++)
          {
            // Get the region attribute
            const unsigned region_id =
              static_cast<unsigned>(this->Region_attribute[ir]);

            // Loop over all elements on boundaries in region ir
            const unsigned nele_ir =
              this->nboundary_element_in_region(shd_bnd_id, region_id);
            for (unsigned ier = 0; ier < nele_ir; ier++)
            {
              // Get the boundary element in current region
              FiniteElement* bnd_ele_pt =
                this->boundary_element_in_region_pt(shd_bnd_id, region_id, ier);
              // Add the boundary element to the internal boundary in the
              // region
              this->Boundary_region_element_pt[int_bnd_id][region_id].push_back(
                bnd_ele_pt);

              // Get the face index of the boundary
              int face_index = this->face_index_at_boundary_in_region(
                shd_bnd_id, region_id, ier);
              // Add the face index to the storage of the boundary region
              this->Face_index_region_at_boundary[int_bnd_id][region_id]
                .push_back(face_index);

            } // for (ier < nele_ir)

          } // for (ir < nregions)

        } // if (nregions > 1)

      } // if (the shared boundary appears in the current processor)

    } // for (loop over the shared bound that overlap an internal bound)

    // Document the number of elements and nodes associated to the
    // boundaries after filling elements and nodes
    if (outfile.is_open())
    {
      const unsigned nbound = this->nboundary();
      outfile << "Number of boundaries: " << nbound << "\n\n";
      outfile << "Number of elements and nodes associated to each "
              << "boundary after\nfilling elements and nodes\n\n";
      for (unsigned i = 0; i < nbound; i++)
      {
        outfile << "Boundary (" << i << ") Elements ("
                << this->nboundary_element(i) << ")"
                << " Nodes (" << this->nboundary_node(i) << ")\n";
      }
    }

    // ------------------------------------------------------------------
    // Finally, re-setup the boundary coordinates for the new nodes on
    // the overlaped internal boundaries
    // ------------------------------------------------------------------
    for (std::set<unsigned>::iterator it = internal_boundary_overlaped.begin();
         it != internal_boundary_overlaped.end();
         it++)
    {
      const unsigned overlaped_internal_bnd_id = (*it);

      // Re-setup boundary coordinates
      this->template setup_boundary_coordinates<ELEMENT>(
        overlaped_internal_bnd_id);
    }
  }

#endif // #ifdef OOMPH_HAS_MPI

  //======================================================================
  /// Move the boundary nodes onto the boundary defined by the old mesh
  //======================================================================
  template<class ELEMENT>
  void RefineableTriangleMesh<ELEMENT>::snap_nodes_onto_boundary(
    RefineableTriangleMesh<ELEMENT>*& new_mesh_pt, const unsigned& b)
  {
    // Quick return
    if (!Boundary_coordinate_exists[b])
    {
      return;
    }

    // Firstly we set the boundary coordinates of the new nodes
    // In case the mapping between the geometric object's intrinsic coordinate
    // and the arc-length coordinate is nonlinear. This is only an
    // approximation, but it will ensure that the nodes that were input to
    // triangle will retain exactly the same boundary coordinates and then
    // linear interpolation is used between those values for any newly created
    // nodes.

    // We need to get the boundary nodes from the boundary face
    // elements since the "multi_domain" methods add nodes to the
    // "Boundary_node_pt" structure which have no boundary coordinates
    // assigned
    std::set<Node*> tmp_boundary_node_pt;
    const unsigned nboundary_ele = this->nboundary_element(b);
    for (unsigned e = 0; e < nboundary_ele; e++)
    {
      // Get the boundary bulk element
      FiniteElement* bulk_ele_pt = this->boundary_element_pt(b, e);
#ifdef OOMPH_HAS_MPI
      // Only work with nonhalo elements if the mesh is distributed
      if (!bulk_ele_pt->is_halo())
      {
#endif
        // Get the face index
        int face_index = this->face_index_at_boundary(b, e);
        // Create the face element
        FiniteElement* face_ele_pt =
          new DummyFaceElement<ELEMENT>(bulk_ele_pt, face_index);

        // Get the number of nodes on the face element
        const unsigned nnodes = face_ele_pt->nnode();
        for (unsigned i = 0; i < nnodes; i++)
        {
          // Get the nodes in the face elements
          Node* tmp_node_pt = face_ele_pt->node_pt(i);
          // Add the nodes to the set of boundary nodes
          tmp_boundary_node_pt.insert(tmp_node_pt);
        } // for (i < nnodes)

        // Free the memory allocated for the face element
        delete face_ele_pt;
        face_ele_pt = 0;
#ifdef OOMPH_HAS_MPI
      } // if (!bulk_ele_pt->is_halo())
#endif

    } // for (e < nboundary_ele)

    // Get the number of boundary nodes
    const unsigned long n_boundary_node = tmp_boundary_node_pt.size();

    // Quick return if there are no nodes
    if (n_boundary_node == 0)
    {
#ifdef OOMPH_HAS_MPI
      // Check if we are working with a distributed mesh
      if (!this->is_mesh_distributed())
      {
#endif
        return;
#ifdef OOMPH_HAS_MPI
      }
      else // The mesh is distributed !!!
      {
        // Do not forget to participate in the communication
        Mesh* face_mesh_pt = new Mesh();
        create_unsorted_face_mesh_representation(b, face_mesh_pt);
        MeshAsGeomObject* mesh_geom_obj_pt = new MeshAsGeomObject(face_mesh_pt);

        // Delete the allocated memory for the geometric object and face mesh
        delete mesh_geom_obj_pt;

        // Flush the nodes from the face mesh to make sure we
        // don't delete them (the bulk mesh still needs them!)
        face_mesh_pt->flush_node_storage();
        delete face_mesh_pt;
        return;
      }
#endif
    } // if (n_boundary_node==0)

    // Create a vector of existing boundary nodes with their boundary
    // coordinate as the first entry so that we can use standard sort algorithms
    Vector<double> node_coord(3);
    Vector<double> b_coord(1);

    Vector<Vector<double>> old_boundary_node(n_boundary_node);
    unsigned tmp_counter = 0;
    for (std::set<Node*>::iterator it_node = tmp_boundary_node_pt.begin();
         it_node != tmp_boundary_node_pt.end();
         it_node++, tmp_counter++)
    {
      Node* nod_pt = (*it_node);
      nod_pt->get_coordinates_on_boundary(b, b_coord);
      node_coord[0] = b_coord[0];
      node_coord[1] = nod_pt->x(0);
      node_coord[2] = nod_pt->x(1);
      old_boundary_node[tmp_counter] = node_coord;
    } // for (it_node != tmp_boundary_node_pt.end())

    // Sort the vector
    std::sort(old_boundary_node.begin(), old_boundary_node.end());

    // Set up an equivalent ordered vector for the new nodes, based on the
    // current coordinate which is the scaled arc-length.
    // Also provide storage for the original node index,
    // the mapped coordinate and a flag to indicate whether the mapped
    // coordinate has been assigned.
    // Get the nodes on the boundary but consider to which segment (which
    // may appear in a distributed mesh) they belong
    Vector<Vector<Node*>> segment_nodes_pt;

#ifdef OOMPH_HAS_MPI
    // Get the number of segments
    const unsigned nsegments = new_mesh_pt->nboundary_segment(b);
#else
    // The number of segments is one since the boundary is not split
    // over multiple processors
    const unsigned nsegments = 1;
#endif // #ifdef OOMPH_HAS_MPI

#ifdef OOMPH_HAS_MPI
    // Get the total number of nodes on the boundary
    const unsigned n_new_boundary_node = new_mesh_pt->nboundary_segment_node(b);

    // Check if we are working with a distributed mesh
    if (this->is_mesh_distributed())
    {
      // If that is the case we need to ensure that the new mesh has
      // nodes too, if that is not the case then return
      // Quick return if there are no nodes
      if (n_new_boundary_node == 0)
      {
        // Do not forget to participate in the communication
        Mesh* face_mesh_pt = new Mesh();
        create_unsorted_face_mesh_representation(b, face_mesh_pt);
        MeshAsGeomObject* mesh_geom_obj_pt = new MeshAsGeomObject(face_mesh_pt);

        // Delete the allocated memory for the geometric object and face mesh
        delete mesh_geom_obj_pt;
        // Flush the nodes from the face mesh to make sure we
        // don't delete them (the bulk mesh still needs them!)
        face_mesh_pt->flush_node_storage();
        delete face_mesh_pt;
        return;
      }
    }
#endif // #ifdef OOMPH_HAS_MPI

    // Create a vector of boundary nodes that must be moved
    Vector<Vector<unsigned>> nodes_to_be_snapped(nsegments);

    // Go through all the segments to assign the snapped zeta coordinates
    // for the new nodes
    for (unsigned is = 0; is < nsegments; is++)
    {
#ifdef OOMPH_HAS_MPI
      const unsigned n_new_boundary_segment_node =
        new_mesh_pt->nboundary_segment_node(b, is);
#else
      const unsigned n_new_boundary_segment_node =
        new_mesh_pt->nboundary_node(b);
#endif // #ifdef OOMPH_HAS_MPI

      Vector<Vector<double>> new_boundary_node(n_new_boundary_segment_node);
      // There will be six data associated with each node
      node_coord.resize(6, 0.0);
      for (unsigned n = 0; n < n_new_boundary_segment_node; n++)
      {
#ifdef OOMPH_HAS_MPI
        Node* nod_pt = new_mesh_pt->boundary_segment_node_pt(b, is, n);
#else
        Node* nod_pt = new_mesh_pt->boundary_node_pt(b, n);
#endif // #ifdef OOMPH_HAS_MPI
        nod_pt->get_coordinates_on_boundary(b, b_coord);
        node_coord[0] = b_coord[0];
        node_coord[1] = nod_pt->x(0);
        node_coord[2] = nod_pt->x(1);
        node_coord[3] = n;
        new_boundary_node[n] = node_coord;
      } // for (n < n_new_boundary_segment_node)

      // Sort the new boundary nodes based on their arc-length coordinate
      std::sort(new_boundary_node.begin(), new_boundary_node.end());

      // We now have two sets of nodes ordered by a coordinate that acts in the
      // same direction and has the same limits.

      // Loop over the vector of new nodes and allocate exactly the same
      // coordinate as the old nodes at points of coincidence
      unsigned old_index = 0;
      for (unsigned n = 0; n < n_new_boundary_segment_node; ++n)
      {
        // Loop over the set of old nodes and if the x and y coordinates
        // coincide with the new node copy accross the new boundary coordinate
        for (unsigned m = old_index; m < n_boundary_node; ++m)
        {
          if ((std::fabs(old_boundary_node[m][1] - new_boundary_node[n][1]) <
               1.0e-14) &&
              (std::fabs(old_boundary_node[m][2] - new_boundary_node[n][2]) <
               1.0e-14))
          {
            // Store the boundary coordinate from the old mesh
            new_boundary_node[n][4] = old_boundary_node[m][0];
            // Say that it has been stored
            new_boundary_node[n][5] = 1.0;
            // For efficiency, we can start the iteration from here next
            // time round because both vectors are ordered
            old_index = m;
            break;
          }
        }
      }

      // Check that the end-points have new boundary coordinates allocated
#ifdef PARANOID
      if ((new_boundary_node[0][5] == 0.0) ||
          (new_boundary_node[n_new_boundary_segment_node - 1][5] == 0.0))
      {
        std::ostringstream error_stream;
        error_stream
          << "New boundary coordinates not found for the first and/or last "
          << "nodes\n"
          << "on the boundary " << b << ". This should not happen because "
          << "these\nlimits should have been setup in the constructor\n";
        error_stream
          << "The distance between the new and old nodes is probably outside\n"
          << "our tolerance.\n";
        error_stream.precision(20);
        error_stream << "Old boundaries: \n";
        error_stream << old_boundary_node[0][1] << " "
                     << old_boundary_node[0][2] << " : "
                     << old_boundary_node[n_boundary_node - 1][1] << " "
                     << old_boundary_node[n_boundary_node - 1][2] << "\n";
        error_stream << "New boundaries: \n"
                     << new_boundary_node[0][1] << " "
                     << new_boundary_node[0][2] << " : "
                     << new_boundary_node[n_new_boundary_segment_node - 1][1]
                     << " "
                     << new_boundary_node[n_new_boundary_segment_node - 1][2]
                     << "\n";
        OomphLibWarning(error_stream.str(),
                        "RefineableTriangleMesh::snap_nodes_onto_boundary()",
                        OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // This is only true if the boundary is not splitted among the
      // processors
      if (!this->is_mesh_distributed())
      {
        // The end points should always be present, so we
        // can (and must) always add them in exactly
        new_boundary_node[0][4] = new_boundary_node[0][0];

        /// Correct!? Because assigned again below
        new_boundary_node[n_new_boundary_segment_node - 1][4] =
          new_boundary_node[0][5] = 1.0;

        new_boundary_node[n_new_boundary_segment_node - 1][4] =
          new_boundary_node[n_new_boundary_segment_node - 1][0];
        new_boundary_node[n_new_boundary_segment_node - 1][5] = 1.0;
      }

      // Now loop over the interior nodes again and
      // use linear interpolation to fill in any unassigned coordiantes
      for (unsigned n = 1; n < n_new_boundary_segment_node - 1; ++n)
      {
        // If the new boundary coordinate has NOT been allocated
        if (new_boundary_node[n][5] == 0.0)
        {
          // Add its (unsorted) node number to the list
          nodes_to_be_snapped[is].push_back(
            static_cast<unsigned>(new_boundary_node[n][3]));

          // We assume that the previous nodal value has been assigned
          // and read out the old and new boundary coordinates
          double zeta_old_low = new_boundary_node[n - 1][0];
          double zeta_new_low = new_boundary_node[n - 1][4];

          // Loop over the nodes above the current node until
          // we find the next one that has been allocated
          for (unsigned m = n + 1; m < n_new_boundary_segment_node; ++m)
          {
            if (new_boundary_node[m][5] == 1.0)
            {
              // Read out the old boundary coordinate
              double zeta_old_high = new_boundary_node[m][0];
              double zeta_new_high = new_boundary_node[m][4];
              // Use linear interpolation to assign the new boundary coordinate
              double frac = (new_boundary_node[n][0] - zeta_old_low) /
                            (zeta_old_high - zeta_old_low);
              new_boundary_node[n][4] =
                zeta_new_low + frac * (zeta_new_high - zeta_new_low);
              new_boundary_node[n][5] = 1.0;
              break;
            }
          }
        }
      }

      // Loop over all the nodes and set the new boundary coordinate
      for (unsigned n = 0; n < n_new_boundary_segment_node; ++n)
      {
        if (new_boundary_node[n][5] == 0)
        {
          throw OomphLibError(
            "New boundary coordinate not assigned\n",
            "RefineableTriangleMesh::snap_nodes_onto_boundary()",
            OOMPH_EXCEPTION_LOCATION);
        }

#ifdef OOMPH_HAS_MPI
        // get the old coordinate
        new_mesh_pt
          ->boundary_segment_node_pt(
            b, is, static_cast<unsigned>(new_boundary_node[n][3]))
          ->get_coordinates_on_boundary(b, b_coord);
        // Set the new coordinate
        b_coord[0] = new_boundary_node[n][4];
        new_mesh_pt
          ->boundary_segment_node_pt(
            b, is, static_cast<unsigned>(new_boundary_node[n][3]))
          ->set_coordinates_on_boundary(b, b_coord);
#else
        // get the old coordinate
        new_mesh_pt
          ->boundary_node_pt(b, static_cast<unsigned>(new_boundary_node[n][3]))
          ->get_coordinates_on_boundary(b, b_coord);
        // Set the new coordinate
        b_coord[0] = new_boundary_node[n][4];
        new_mesh_pt
          ->boundary_node_pt(b, static_cast<unsigned>(new_boundary_node[n][3]))
          ->set_coordinates_on_boundary(b, b_coord);
#endif // #ifdef OOMPH_HAS_MPI
      }

    } // for (is < nsegments)

    Mesh* face_mesh_pt = new Mesh();
    create_unsorted_face_mesh_representation(b, face_mesh_pt);

    // Now that the coordinates have been set up we can do the snapping
    MeshAsGeomObject* mesh_geom_obj_pt = new MeshAsGeomObject(face_mesh_pt);

    // Now assign the new nodes positions based on the old meshes
    // potentially curvilinear boundary (its geom object incarnation)
    Vector<double> new_x(2);

    // Loop over the nodes that need to be snapped
    for (unsigned is = 0; is < nsegments; is++)
    {
      const unsigned nnodes_to_snap = nodes_to_be_snapped[is].size();

      for (unsigned in = 0; in < nnodes_to_snap; in++)
      {
        // Read out the boundary node number
        unsigned n = nodes_to_be_snapped[is][in];
#ifdef OOMPH_HAS_MPI
        // Get the boundary coordinate of all new nodes
        Node* const nod_pt = new_mesh_pt->boundary_segment_node_pt(b, is, n);
#else
        // Get the boundary coordinate of all new nodes
        Node* const nod_pt = new_mesh_pt->boundary_node_pt(b, n);
#endif // #ifdef OOMPH_HAS_MPI

        nod_pt->get_coordinates_on_boundary(b, b_coord);
        // Let's find boundary coordinates of the new node
        mesh_geom_obj_pt->position(b_coord, new_x);

        // Now snap to the boundary
        for (unsigned i = 0; i < 2; i++)
        {
          nod_pt->x(i) = new_x[i];
        }
      }
    }

    // Delete the allocated memory for the geometric object and face mesh
    delete mesh_geom_obj_pt;
    // Flush the nodes from the face mesh to make sure we
    // don't delete them (the bulk mesh still needs them!)
    face_mesh_pt->flush_node_storage();
    delete face_mesh_pt;

    // Fix up the elements adjacent to the boundary

    // Dummy six node element for sorting out bubble node for
    // seven node enriched quadratic triangles
    TElement<2, 3> dummy_six_node_element;
    for (unsigned j = 0; j < 6; j++)
    {
      dummy_six_node_element.construct_node(j);
    }

    // This should definitely become a triangular element member function
    // Loop over elements
    unsigned n_bound_el = new_mesh_pt->nboundary_element(b);
    for (unsigned e = 0; e < n_bound_el; e++)
    {
      FiniteElement* el_pt = new_mesh_pt->boundary_element_pt(b, e);

      // Deal with different numbers of nodes separately
      unsigned nnod = el_pt->nnode();

      // #ifdef PARANOID
      //     // Flag to indicate if we successully classified/dealt with the
      //     element bool success=false;
      // #endif

      // Simplex element: Nothing to be done other than error checking
      if (nnod == 3)
      {
#ifdef PARANOID
        // Try to cast to a simplex element
        TElement<2, 2>* t_el_pt = dynamic_cast<TElement<2, 2>*>(el_pt);
        if (t_el_pt == 0)
        {
          throw OomphLibError(
            "Have a three-noded element that's not a TElement<2,2>",
            OOMPH_CURRENT_FUNCTION,
            OOMPH_EXCEPTION_LOCATION);
        }
        // If I get there I must not have thrown :)
        // success=true;
#endif
      }
      // Quadratic element (or enriched quadratic)

      else if ((nnod == 6) || (nnod == 7))
      {
#ifdef PARANOID
        // Try to cast to a quadratic element
        TElement<2, 3>* t_el_pt = dynamic_cast<TElement<2, 3>*>(el_pt);
        if (t_el_pt == 0)
        {
          if (nnod == 6)
          {
            throw OomphLibError(
              "Have a six-noded element that's not a TElement<2,3>",
              OOMPH_CURRENT_FUNCTION,
              OOMPH_EXCEPTION_LOCATION);
          }
          else
          {
            throw OomphLibError(
              "Have a seven-noded element that's not a TElement<2,3>",
              OOMPH_CURRENT_FUNCTION,
              OOMPH_EXCEPTION_LOCATION);
          }
        }
        // If I get there I must not have thrown :)
        // success=true;
#endif
        // Deal with six noded stuff for all (normal and enriched) elements

        /// ----------------------------------------------------------------
        ///         Repositioning of mid-side nodes
        /// ----------------------------------------------------------------

        // Side between 0 and 1
        if (el_pt->node_pt(3)->is_on_boundary(b))
        {
          // Make sure that the node I'm about to move is NOT on
          // a boundary
          if (!el_pt->node_pt(5)->is_on_boundary())
          {
            // Reset the internal nodes
            for (unsigned i = 0; i < 2; i++)
            {
              el_pt->node_pt(5)->x(i) =
                0.5 * (el_pt->node_pt(0)->x(i) + el_pt->node_pt(2)->x(i));
            }
          }
          // Make sure that the node I'm about to move is NOT on
          // a boundary
          if (!el_pt->node_pt(4)->is_on_boundary())
          {
            // Reset the internal nodes
            for (unsigned i = 0; i < 2; i++)
            {
              el_pt->node_pt(4)->x(i) =
                0.5 * (el_pt->node_pt(1)->x(i) + el_pt->node_pt(2)->x(i));
            }
          }
        }

        // Side between 1 and 2
        if (el_pt->node_pt(4)->is_on_boundary(b))
        {
          // Make sure that the node I'm about to move is NOT on
          // a boundary
          if (!el_pt->node_pt(5)->is_on_boundary())
          {
            // Reset the internal nodes
            for (unsigned i = 0; i < 2; i++)
            {
              el_pt->node_pt(5)->x(i) =
                0.5 * (el_pt->node_pt(0)->x(i) + el_pt->node_pt(2)->x(i));
            }
          }
          // Make sure that the node I'm about to move is NOT on
          // a boundary
          if (!el_pt->node_pt(3)->is_on_boundary())
          {
            // Reset the internal nodes
            for (unsigned i = 0; i < 2; i++)
            {
              el_pt->node_pt(3)->x(i) =
                0.5 * (el_pt->node_pt(0)->x(i) + el_pt->node_pt(1)->x(i));
            }
          }
        }

        // Side between 0 and 2
        if (el_pt->node_pt(5)->is_on_boundary(b))
        {
          // Make sure that the node I'm about to move is NOT on
          // a boundary
          if (!el_pt->node_pt(4)->is_on_boundary())
          {
            // Reset the internal nodes
            for (unsigned i = 0; i < 2; i++)
            {
              el_pt->node_pt(4)->x(i) =
                0.5 * (el_pt->node_pt(1)->x(i) + el_pt->node_pt(2)->x(i));
            }
          }
          // Make sure that the node I'm about to move is NOT on
          // a boundary
          if (!el_pt->node_pt(3)->is_on_boundary())
          {
            // Reset the internal nodes
            for (unsigned i = 0; i < 2; i++)
            {
              el_pt->node_pt(3)->x(i) =
                0.5 * (el_pt->node_pt(0)->x(i) + el_pt->node_pt(1)->x(i));
            }
          }
        }

        // If it's seven noded it's likely to be an enriched one: Deal with
        // the central (bubble) node
        if (nnod == 7)
        {
          // Try to cast to an enriched quadratic element
          TBubbleEnrichedElement<2, 3>* t_el_pt =
            dynamic_cast<TBubbleEnrichedElement<2, 3>*>(el_pt);
          if (t_el_pt == 0)
          {
            throw OomphLibError("Have seven-noded element that's not a "
                                "TBubbleEnrichedElement<2,3>",
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }

          // Assign the new non-bubble coordinates to the six noded dummy
          // element
          for (unsigned j = 0; j < 6; j++)
          {
            for (unsigned i = 0; i < 2; i++)
            {
              dummy_six_node_element.node_pt(j)->x(i) = el_pt->node_pt(j)->x(i);
            }
          }

          // Local coordinate of enriched node
          unsigned j_enriched = 6;
          Vector<double> s(2);
          el_pt->local_coordinate_of_node(j_enriched, s);

          // Get its position from non-enriched element
          Vector<double> x(2);
          dummy_six_node_element.interpolated_x(s, x);
          el_pt->node_pt(j_enriched)->x(0) = x[0];
          el_pt->node_pt(j_enriched)->x(1) = x[1];
        }
      }
      // Any other case cannot be dealt with at the moment

      else
      {
        std::ostringstream error_stream;
        error_stream << "Cannot deal with this particular " << nnod
                     << "-noded element yet.\n"
                     << "Please implement this yourself.\n";
        throw OomphLibError(
          error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
      }
    }

    // Cleanup
    for (unsigned j = 0; j < 6; j++)
    {
      delete dummy_six_node_element.node_pt(j);
    }
  }


#endif // #ifdef OOMPH_HAS_TRIANGLE_LIB

} // namespace oomph

#endif
