// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC// Copyright (C) 2006-2023 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
// Templated multi-domain functions

// Include guards to prevent multiple inclusion of the header
#ifndef OOMPH_MULTI_DOMAIN_CC
#define OOMPH_MULTI_DOMAIN_CC

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

// Oomph-lib headers
#include "geom_objects.h"
#include "problem.h"
#include "shape.h"

#include "mesh.h"
#include "mesh_as_geometric_object.h"
#include "algebraic_elements.h"
#include "macro_element_node_update_element.h"
#include "Qelements.h"
#include "element_with_external_element.h"
#include "multi_domain.h"
#include "face_element_as_geometric_object.h"

// Needed to check if elements have nonuniformly spaced nodes
#include "refineable_elements.h"
#include "Qspectral_elements.h"

namespace oomph
{
  /// / Templated helper functions for multi-domain methods using locate_zeta


  //============================================================================
  /// Identify the \c FaceElements (stored in the mesh pointed to by
  /// \c face_mesh_pt) that are adjacent to the bulk elements next to the
  /// \c boundary_in_bulk_mesh -th boundary of the mesh pointed to by
  /// \c bulk_mesh_pt. The \c FaceElements must be derived
  /// from the \c ElementWithExternalElement base class and the adjacent
  /// bulk elements are stored as their external elements.
  ///
  /// This is the vector-based version which deals with multiple bulk
  /// mesh boundaries at the same time.
  //============================================================================
  template<class BULK_ELEMENT, unsigned DIM>
  void Multi_domain_functions::setup_bulk_elements_adjacent_to_face_mesh(
    Problem* problem_pt,
    Vector<unsigned>& boundary_in_bulk_mesh,
    Mesh* const& bulk_mesh_pt,
    Vector<Mesh*>& face_mesh_pt,
    const unsigned& interaction)
  {
    unsigned n_mesh = boundary_in_bulk_mesh.size();

#ifdef PARANOID
    // Check sizes match
    if (boundary_in_bulk_mesh.size() != face_mesh_pt.size())
    {
      std::ostringstream error_message;
      error_message << "Sizes of vector of boundary ids in bulk mesh ("
                    << boundary_in_bulk_mesh.size()
                    << ") and vector of pointers\n"
                    << "to FaceElements (" << face_mesh_pt.size()
                    << " doesn't match.\n";
      throw OomphLibError(
        error_message.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Create face meshes adjacent to the bulk mesh's b-th boundary.
    // Each face mesh consists of FaceElements that may also be
    // interpreted as GeomObjects
    Vector<Mesh*> bulk_face_mesh_pt(n_mesh);

    // Loop over all meshes
    for (unsigned i_mesh = 0; i_mesh < n_mesh; i_mesh++)
    {
      bulk_face_mesh_pt[i_mesh] = new Mesh;
      bulk_mesh_pt
        ->template build_face_mesh<BULK_ELEMENT, FaceElementAsGeomObject>(
          boundary_in_bulk_mesh[i_mesh], bulk_face_mesh_pt[i_mesh]);

      // Loop over these new face elements and tell them the boundary number
      // from the bulk mesh -- this is required to they can
      // get access to the boundary coordinates!
      unsigned n_face_element = bulk_face_mesh_pt[i_mesh]->nelement();
      for (unsigned e = 0; e < n_face_element; e++)
      {
        // Cast the element pointer to the correct thing!
        FaceElementAsGeomObject<BULK_ELEMENT>* el_pt =
          dynamic_cast<FaceElementAsGeomObject<BULK_ELEMENT>*>(
            bulk_face_mesh_pt[i_mesh]->element_pt(e));

        // Set bulk boundary number
        el_pt->set_boundary_number_in_bulk_mesh(boundary_in_bulk_mesh[i_mesh]);

        // Doc?
        if (Doc_boundary_coordinate_file.is_open())
        {
          Vector<double> s(DIM - 1);
          Vector<double> zeta(DIM - 1);
          Vector<double> x(DIM);
          unsigned n_plot = 5;
          Doc_boundary_coordinate_file << el_pt->tecplot_zone_string(n_plot);

          // Loop over plot points
          unsigned num_plot_points = el_pt->nplot_points(n_plot);
          for (unsigned iplot = 0; iplot < num_plot_points; iplot++)
          {
            // Get local coordinates of plot point
            el_pt->get_s_plot(iplot, n_plot, s);
            el_pt->interpolated_zeta(s, zeta);
            el_pt->interpolated_x(s, x);
            for (unsigned i = 0; i < DIM; i++)
            {
              Doc_boundary_coordinate_file << x[i] << " ";
            }
            for (unsigned i = 0; i < DIM - 1; i++)
            {
              Doc_boundary_coordinate_file << zeta[i] << " ";
            }
            Doc_boundary_coordinate_file << std::endl;
          }
          el_pt->write_tecplot_zone_footer(Doc_boundary_coordinate_file,
                                           n_plot);
        }
      }

      // Now sort the elements based on the boundary coordinates.
      // This may allow a faster implementation of the locate_zeta
      // function for the MeshAsGeomObject representation of this
      // mesh, but also creates a unique ordering of the elements
      std::sort(bulk_face_mesh_pt[i_mesh]->element_pt().begin(),
                bulk_face_mesh_pt[i_mesh]->element_pt().end(),
                CompareBoundaryCoordinate<BULK_ELEMENT>());
    } // end of loop over meshes


    // Setup the interactions for this problem using the surface mesh
    // on the fluid mesh.  The interaction parameter in this instance is
    // given by the "face" parameter.
    Multi_domain_functions::setup_multi_domain_interaction<
      BULK_ELEMENT,
      FaceElementAsGeomObject<BULK_ELEMENT>>(
      problem_pt, face_mesh_pt, bulk_mesh_pt, bulk_face_mesh_pt, interaction);


    // Loop over all meshes to clean up
    for (unsigned i_mesh = 0; i_mesh < n_mesh; i_mesh++)
    {
      unsigned n_face_element = bulk_face_mesh_pt[i_mesh]->nelement();

      // The MeshAsGeomObject has already been deleted (in set_external_storage)

      // Must be careful with the FaceMesh, because we cannot delete the nodes
      // Loop over the elements backwards (paranoid!) and delete them
      for (unsigned e = n_face_element; e > 0; e--)
      {
        delete bulk_face_mesh_pt[i_mesh]->element_pt(e - 1);
        bulk_face_mesh_pt[i_mesh]->element_pt(e - 1) = 0;
      }
      // Now clear all element and node storage (should maybe fine-grain this)
      bulk_face_mesh_pt[i_mesh]->flush_element_and_node_storage();

      // Finally delete the mesh
      delete bulk_face_mesh_pt[i_mesh];

    } // end of loop over meshes
  }


  //========================================================================
  /// Identify the \c FaceElements (stored in the mesh pointed to by
  /// \c face_mesh_pt) that are adjacent to the bulk elements next to the
  /// \c boundary_in_bulk_mesh -th boundary of the mesh pointed to by
  /// \c bulk_mesh_pt. The \c FaceElements must be derived
  /// from the \c ElementWithExternalElement base class and the adjacent
  /// bulk elements are stored as their external elements.
  //========================================================================
  template<class BULK_ELEMENT, unsigned DIM>
  void Multi_domain_functions::setup_bulk_elements_adjacent_to_face_mesh(
    Problem* problem_pt,
    const unsigned& boundary_in_bulk_mesh,
    Mesh* const& bulk_mesh_pt,
    Mesh* const& face_mesh_pt,
    const unsigned& interaction)
  {
    // Convert to vector-based storage
    Vector<unsigned> boundary_in_bulk_mesh_vect(1);
    boundary_in_bulk_mesh_vect[0] = boundary_in_bulk_mesh;
    Vector<Mesh*> face_mesh_pt_vect(1);
    face_mesh_pt_vect[0] = face_mesh_pt;

    // Call vector-based version
    setup_bulk_elements_adjacent_to_face_mesh<BULK_ELEMENT, DIM>(
      problem_pt,
      boundary_in_bulk_mesh_vect,
      bulk_mesh_pt,
      face_mesh_pt_vect,
      interaction);
  }


  //========================================================================
  /// Set up the two-way multi-domain interactions for the
  /// problem pointed to by \c problem_pt.
  /// Use this for cases where first_mesh_pt and second_mesh_pt
  /// occupy the same physical space and are populated by
  /// ELEMENT_0 and ELEMENT_1 respectively, and are combined to solve
  /// a single problem. The elements in two meshes interact both ways
  /// the elements in each mesh act as "external elements" for the
  /// elements in the "other" mesh. The interaction indices allow the
  /// specification of which interaction we're setting up in the two
  /// meshes. They default to zero, which is appropriate if there's
  /// only a single interaction.
  //========================================================================
  template<class ELEMENT_0, class ELEMENT_1>
  void Multi_domain_functions::setup_multi_domain_interactions(
    Problem* problem_pt,
    Mesh* const& first_mesh_pt,
    Mesh* const& second_mesh_pt,
    const unsigned& first_interaction,
    const unsigned& second_interaction)
  {
    // Delete all the current external halo(ed) element and node storage
    first_mesh_pt->delete_all_external_storage();
    second_mesh_pt->delete_all_external_storage();

    // Call setup_multi_domain_interaction in both directions
    setup_multi_domain_interaction<ELEMENT_1>(
      problem_pt, first_mesh_pt, second_mesh_pt, first_interaction);

    setup_multi_domain_interaction<ELEMENT_0>(
      problem_pt, second_mesh_pt, first_mesh_pt, second_interaction);
  }


  //========================================================================
  ///  Function to set up the one-way multi-domain interaction for
  /// problems where the meshes pointed to by \c mesh_pt and \c external_mesh_pt
  /// occupy the same physical space, and the elements in \c external_mesh_pt
  /// act as "external elements" for the \c ElementWithExternalElements
  /// in \c mesh_pt (but not vice versa):
  /// - \c mesh_pt points to the mesh of ElemenWithExternalElements for which
  ///   the interaction is set up.
  /// - \c external_mesh_pt points to the mesh that contains the elements
  ///   of type EXT_ELEMENT that act as "external elements" for the
  ///   \c ElementWithExternalElements in \c mesh_pt.
  /// - The interaction_index parameter defaults to zero and must be otherwise
  ///   set by the user if there is more than one mesh that provides sources
  ///   for the Mesh pointed to by mesh_pt.
  //========================================================================
  template<class EXT_ELEMENT>
  void Multi_domain_functions::setup_multi_domain_interaction(
    Problem* problem_pt,
    Mesh* const& mesh_pt,
    Mesh* const& external_mesh_pt,
    const unsigned& interaction_index)
  {
    // Bulk elements must not be external elements in this case
    Use_bulk_element_as_external = false;

    // Call the auxiliary function with GEOM_OBJECT=EXT_ELEMENT
    // and EL_DIM_EUL=EL_DIM_LAG=dimension returned from helper function
    get_dim_helper(problem_pt, mesh_pt, external_mesh_pt);

    if (Dim > 3)
    {
      std::ostringstream error_stream;
      error_stream << "The elements within the two interacting meshes have a\n"
                   << "dimension not equal to 1, 2 or 3.\n"
                   << "The multi-domain method will not work in this case.\n"
                   << "The dimension is: " << Dim << "\n";
      throw OomphLibError(
        error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }

    // Wrapper for each dimension (template parameter)
    aux_setup_multi_domain_interaction<EXT_ELEMENT, EXT_ELEMENT>(
      problem_pt, mesh_pt, external_mesh_pt, interaction_index);
  }


  //========================================================================
  /// Function to set up the one-way multi-domain interaction for
  /// FSI-like problems.
  /// - \c mesh_pt points to the mesh of \c ElemenWithExternalElements for which
  ///   the interaction is set up. In an FSI example, this mesh would contain
  ///   the \c FSIWallElements (either beam/shell elements or the
  ///   \c FSISolidTractionElements that apply the traction to
  ///   a "bulk" solid mesh that is loaded by the fluid.)
  /// - \c external_mesh_pt points to the mesh that contains the elements
  ///   of type EXT_ELEMENT that provide the "source" for the
  ///   \c ElementWithExternalElements. In an FSI example, this
  ///   mesh would contain the "bulk" fluid elements.
  /// - \c external_face_mesh_pt points to the mesh of \c FaceElements
  ///   attached to the \c external_mesh_pt. The mesh pointed to by
  ///   \c external_face_mesh_pt has the same dimension as \c mesh_pt.
  ///   The elements contained in \c external_face_mesh_pt are of type
  ///   FACE_ELEMENT_GEOM_OBJECT. In an FSI example, these elements
  ///   are usually the \c FaceElementAsGeomObjects (templated by the
  ///   type of the "bulk" fluid elements to which they are attached)
  ///   that define the FSI boundary of the fluid domain.
  /// - The interaction_index parameter defaults to zero and must otherwise be
  ///   set by the user if there is more than one mesh that provides "external
  ///   elements" for the Mesh pointed to by mesh_pt (e.g. in the case
  ///   when a beam or shell structure is loaded by fluid from both sides.)
  //========================================================================
  template<class EXT_ELEMENT, class FACE_ELEMENT_GEOM_OBJECT>
  void Multi_domain_functions::setup_multi_domain_interaction(
    Problem* problem_pt,
    Mesh* const& mesh_pt,
    Mesh* const& external_mesh_pt,
    Mesh* const& external_face_mesh_pt,
    const unsigned& interaction_index)
  {
    // Bulk elements must be external elements in this case
    Use_bulk_element_as_external = true;

    // Call the auxiliary routine with GEOM_OBJECT=FACE_ELEMENT_GEOM_OBJECT
    // and EL_DIM_LAG=Dim, EL_DIM_EUL=Dim+1
    get_dim_helper(problem_pt, mesh_pt, external_face_mesh_pt);

    if (Dim > 2)
    {
      std::ostringstream error_stream;
      error_stream << "The elements within the two interacting meshes have a\n"
                   << "dimension not equal to 1 or 2.\n"
                   << "The multi-domain method will not work in this case.\n"
                   << "The dimension is: " << Dim << "\n";
      throw OomphLibError(
        error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }

    // Call the function that actually does the work
    aux_setup_multi_domain_interaction<EXT_ELEMENT, FACE_ELEMENT_GEOM_OBJECT>(
      problem_pt,
      mesh_pt,
      external_mesh_pt,
      interaction_index,
      external_face_mesh_pt);
  }


  //========================================================================
  /// Function to set up the one-way multi-domain interaction for
  /// FSI-like problems.
  /// - \c mesh_pt points to the mesh of \c ElemenWithExternalElements for which
  ///   the interaction is set up. In an FSI example, this mesh would contain
  ///   the \c FSIWallElements (either beam/shell elements or the
  ///   \c FSISolidTractionElements that apply the traction to
  ///   a "bulk" solid mesh that is loaded by the fluid.)
  /// - \c external_mesh_pt points to the mesh that contains the elements
  ///   of type EXT_ELEMENT that provide the "source" for the
  ///   \c ElementWithExternalElements. In an FSI example, this
  ///   mesh would contain the "bulk" fluid elements.
  /// - \c external_face_mesh_pt points to the mesh of \c FaceElements
  ///   attached to the \c external_mesh_pt. The mesh pointed to by
  ///   \c external_face_mesh_pt has the same dimension as \c mesh_pt.
  ///   The elements contained in \c external_face_mesh_pt are of type
  ///   FACE_ELEMENT_GEOM_OBJECT. In an FSI example, these elements
  ///   are usually the \c FaceElementAsGeomObjects (templated by the
  ///   type of the "bulk" fluid elements to which they are attached)
  ///   that define the FSI boundary of the fluid domain.
  /// - The interaction_index parameter defaults to zero and must otherwise be
  ///   set by the user if there is more than one mesh that provides "external
  ///   elements" for the Mesh pointed to by mesh_pt (e.g. in the case
  ///   when a beam or shell structure is loaded by fluid from both sides.)
  /// .
  /// Vector-based version operates simultaneously on the meshes contained
  /// in the vectors.
  //========================================================================
  template<class EXT_ELEMENT, class FACE_ELEMENT_GEOM_OBJECT>
  void Multi_domain_functions::setup_multi_domain_interaction(
    Problem* problem_pt,
    const Vector<Mesh*>& mesh_pt,
    Mesh* const& external_mesh_pt,
    const Vector<Mesh*>& external_face_mesh_pt,
    const unsigned& interaction_index)
  {
    // How many meshes do we have?
    unsigned n_mesh = mesh_pt.size();

#ifdef PARANOID
    if (external_face_mesh_pt.size() != n_mesh)
    {
      std::ostringstream error_stream;
      error_stream << "Sizes of external_face_mesh_pt [ "
                   << external_face_mesh_pt.size() << " ] and "
                   << "mesh_pt [ " << n_mesh << " ] don't match.\n";
      throw OomphLibError(
        error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Bail out?
    if (n_mesh == 0) return;

    // Bulk elements must be external elements in this case
    Use_bulk_element_as_external = true;

    // Call the auxiliary routine with GEOM_OBJECT=FACE_ELEMENT_GEOM_OBJECT
    // and EL_DIM_LAG=Dim, EL_DIM_EUL=Dim+1. Use first mesh only.
    get_dim_helper(problem_pt, mesh_pt[0], external_face_mesh_pt[0]);


#ifdef PARANOID
    // Check consitency
    unsigned old_dim = Dim;
    for (unsigned i = 1; i < n_mesh; i++)
    {
      // Set up Dim again
      get_dim_helper(problem_pt, mesh_pt[i], external_face_mesh_pt[i]);

      if (Dim != old_dim)
      {
        std::ostringstream error_stream;
        error_stream << "Inconsistency: Mesh  " << i << " has Dim=" << Dim
                     << "while mesh 0 has Dim=" << old_dim << std::endl;
        throw OomphLibError(
          error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
      }
    }
#endif

    if (Dim > 2)
    {
      std::ostringstream error_stream;
      error_stream << "The elements within the two interacting meshes have a\n"
                   << "dimension not equal to 1 or 2.\n"
                   << "The multi-domain method will not work in this case.\n"
                   << "The dimension is: " << Dim << "\n";
      throw OomphLibError(
        error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }

    // Now do the actual work for all meshes simultaneously
    aux_setup_multi_domain_interaction<EXT_ELEMENT, FACE_ELEMENT_GEOM_OBJECT>(
      problem_pt,
      mesh_pt,
      external_mesh_pt,
      interaction_index,
      external_face_mesh_pt);
  }


  //========================================================================
  /// This routine calls the locate_zeta routine (simultaneously on each
  /// processor for each individual processor's element set if necessary)
  /// and sets up the external (halo) element and node storage as
  /// necessary.  The locate_zeta procedure here works for all multi-domain
  /// problems where either two meshes occupy the same physical space but have
  /// differing element types (e.g. a Boussinesq convection problem where
  /// AdvectionDiffusion elements interact with Navier-Stokes type elements)
  /// or two meshes interact along some boundary of the external mesh,
  /// represented by a "face mesh", such as an FSI problem.
  //========================================================================
  template<class EXT_ELEMENT, class GEOM_OBJECT>
  void Multi_domain_functions::aux_setup_multi_domain_interaction(
    Problem* problem_pt,
    Mesh* const& mesh_pt,
    Mesh* const& external_mesh_pt,
    const unsigned& interaction_index,
    Mesh* const& external_face_mesh_pt)
  {
    // Convert to vector-based storage
    Vector<Mesh*> mesh_pt_vector(1);
    mesh_pt_vector[0] = mesh_pt;
    Vector<Mesh*> external_face_mesh_pt_vector(1);
    external_face_mesh_pt_vector[0] = external_face_mesh_pt;

    // Call vector-based version
    aux_setup_multi_domain_interaction<EXT_ELEMENT, GEOM_OBJECT>(
      problem_pt,
      mesh_pt_vector,
      external_mesh_pt,
      interaction_index,
      external_face_mesh_pt_vector);

  } // end of aux_setup_multi_domain_interaction


  //========================================================================
  /// This routine calls the locate_zeta routine (simultaneously on each
  /// processor for each individual processor's element set if necessary)
  /// and sets up the external (halo) element and node storage as
  /// necessary.  The locate_zeta procedure here works for all multi-domain
  /// problems where either two meshes occupy the same physical space but have
  /// differing element types (e.g. a Boussinesq convection problem where
  /// AdvectionDiffusion elements interact with Navier-Stokes type elements)
  /// or two meshes interact along some boundary of the external mesh,
  /// represented by a "face mesh", such as an FSI problem.
  ///
  /// Vector-based version operates simultaneously on the meshes contained
  /// in the vectors.
  //========================================================================
  template<class EXT_ELEMENT, class GEOM_OBJECT>
  void Multi_domain_functions::aux_setup_multi_domain_interaction(
    Problem* problem_pt,
    const Vector<Mesh*>& mesh_pt,
    Mesh* const& external_mesh_pt,
    const unsigned& interaction_index,
    const Vector<Mesh*>& external_face_mesh_pt)
  {
    // How many meshes do we have?
    unsigned n_mesh = mesh_pt.size();

#ifdef PARANOID
    if (external_face_mesh_pt.size() != n_mesh)
    {
      std::ostringstream error_stream;
      error_stream << "Sizes of external_face_mesh_pt [ "
                   << external_face_mesh_pt.size() << " ] and "
                   << "mesh_pt [ " << n_mesh << " ] don't match.\n";
      throw OomphLibError(
        error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Bail out?
    if (n_mesh == 0) return;

      // Multi-domain setup will not work for elements with
      // nonuniformly spaced nodes
      // Must check type of elements in the mesh and in the external mesh
      //(assume element type is the same for all elements in each mesh)

#ifdef PARANOID

    // Pointer to first element in external mesh
    GeneralisedElement* ext_el_pt_0 = 0;
    if (external_mesh_pt->nelement() != 0)
    {
      ext_el_pt_0 = external_mesh_pt->element_pt(0);
    }

    // Loop over all meshes
    for (unsigned i_mesh = 0; i_mesh < n_mesh; i_mesh++)
    {
      // Get pointer to first element in each mesh
      GeneralisedElement* el_pt_0 = 0;
      if (mesh_pt[i_mesh]->nelement() != 0)
      {
        el_pt_0 = mesh_pt[i_mesh]->element_pt(0);
      }

      // Check they are not spectral elements
      if (dynamic_cast<SpectralElement*>(el_pt_0) != 0 ||
          dynamic_cast<SpectralElement*>(ext_el_pt_0) != 0)
      {
        throw OomphLibError(
          "Multi-domain setup does not work with spectral elements.",
          OOMPH_CURRENT_FUNCTION,
          OOMPH_EXCEPTION_LOCATION);
      }

      // Check they are not hp-refineable elements
      if (dynamic_cast<PRefineableElement*>(el_pt_0) != 0 ||
          dynamic_cast<PRefineableElement*>(ext_el_pt_0) != 0)
      {
        throw OomphLibError(
          "Multi-domain setup does not work with hp-refineable elements.",
          OOMPH_CURRENT_FUNCTION,
          OOMPH_EXCEPTION_LOCATION);
      }
    } // end over initial loop over meshes

#endif


#ifdef OOMPH_HAS_MPI
    // Storage for number of processors and my rank
    int n_proc = problem_pt->communicator_pt()->nproc();
    int my_rank = problem_pt->communicator_pt()->my_rank();
#endif

    // Timing
    double t_start = 0.0;
    double t_end = 0.0;
    double t_local = 0.0;
    double t_set = 0.0;
    double t_locate = 0.0;
    double t_spiral_start = 0.0;
#ifdef OOMPH_HAS_MPI
    double t_loop_start = 0.0;
    double t_sendrecv = 0.0;
    double t_missing = 0.0;
    double t_send_info = 0.0;
    double t_create_halo = 0.0;
#endif

    if (Doc_timings)
    {
      t_start = TimingHelpers::timer();
    }

    // Initialize number of zeta coordinates not found yet
    unsigned n_zeta_not_found = 0;

    // Geometric objects used to represent the external (face) meshes
    Vector<MeshAsGeomObject*> mesh_geom_obj_pt(n_mesh, 0);

#ifdef PARANOID

    // Initialise lagrangian dimension of element (test only)
    unsigned el_dim_lag = 0;

#endif

    // Create mesh as geom objects for all meshes
    for (unsigned i_mesh = 0; i_mesh < n_mesh; i_mesh++)
    {
      // Are bulk elements used as external elements?
      if (!Use_bulk_element_as_external)
      {
        // Fix this when required
        if (n_mesh != 1)
        {
          std::ostringstream error_stream;
          error_stream
            << "Sorry I currently can't deal with non-bulk external elements\n"
            << "in multi-domain setup for multiple meshes.\n"
            << "The functionality should be easy to implement now that you\n"
            << "have a test case. If you're not willinig to do this, call\n"
            << "the multi-domain setup mesh-by-mesh instead (though this can\n"
            << "be costly in parallel because of global comms. \n";
          throw OomphLibError(error_stream.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        }

        // Set the geometric object from the external mesh
        mesh_geom_obj_pt[0] = new MeshAsGeomObject(external_mesh_pt);
      }
      else
      {
        // Set the geometric object from the external face mesh argument
        mesh_geom_obj_pt[i_mesh] =
          new MeshAsGeomObject(external_face_mesh_pt[i_mesh]);
      }

#ifdef PARANOID
      unsigned old_el_dim_lag = el_dim_lag;

      // Set lagrangian dimension of element
      el_dim_lag = mesh_geom_obj_pt[i_mesh]->nlagrangian();

      // Check consistency
      if (i_mesh > 0)
      {
        if (el_dim_lag != old_el_dim_lag)
        {
          std::ostringstream error_stream;
          error_stream << "Lagrangian dimensions of elements don't match \n "
                       << "between meshes: " << el_dim_lag << " "
                       << old_el_dim_lag << "\n";
          throw OomphLibError(error_stream.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        }
      }
#endif


    } // end of loop over meshes

    double t_setup_lookups = 0.0;
    if (Doc_timings)
    {
      t_set = TimingHelpers::timer();
      oomph_info << "CPU for creation of MeshAsGeomObjects and bin structure: "
                 << t_set - t_start << std::endl;
      t_setup_lookups = TimingHelpers::timer();
    }

    // Total number of integration points
    unsigned tot_int = 0;

    // Counter for total number of elements (in flat packed order)
    unsigned e_count = 0;

    // Loop over all meshes to get total number of elements
    for (unsigned i_mesh = 0; i_mesh < n_mesh; i_mesh++)
    {
      e_count += mesh_pt[i_mesh]->nelement();
    }
    External_element_located.resize(e_count);

    // Reset counter for elements in flat packed storage
    e_count = 0;

    // Loop over all meshes
    for (unsigned i_mesh = 0; i_mesh < n_mesh; i_mesh++)
    {
      // Loop over (this processor's) elements and set lookup array
      unsigned n_element = mesh_pt[i_mesh]->nelement();
      for (unsigned e = 0; e < n_element; e++)
      {
        // Zero-sized vector means its a halo
        External_element_located[e_count].resize(0);
        ElementWithExternalElement* el_pt =
          dynamic_cast<ElementWithExternalElement*>(
            mesh_pt[i_mesh]->element_pt(e));

#ifdef OOMPH_HAS_MPI
        // We're not setting up external elements for halo elements
        if (!el_pt->is_halo())
#endif
        {
          // We need to allocate storage for the external elements
          // within the element. Memory will actually only be
          // allocated the first time this function is called for
          // each element, or if the number of interactions or integration
          // points within the element has changed.
          el_pt->initialise_external_element_storage();

          // Clear any previous allocation
          unsigned n_intpt = el_pt->integral_pt()->nweight();
          for (unsigned ipt = 0; ipt < n_intpt; ipt++)
          {
            el_pt->external_element_pt(interaction_index, ipt) = 0;
          }

          External_element_located[e_count].resize(n_intpt);
          for (unsigned ipt = 0; ipt < n_intpt; ipt++)
          {
            External_element_located[e_count][ipt] = 0;
            tot_int++;
          }
        }
        // next element
        e_count++;
      }
    } // end of loop over meshes

    if (Doc_timings)
    {
      double t = TimingHelpers::timer();
      oomph_info
        << "CPU for setup of lookup schemes for located elements/coords: "
        << t - t_setup_lookups << std::endl;
    }

    // Initialise maximum spiral level within the cartesian bin structure
    // Used to terminate spiraling for non-refineable bin
    unsigned n_max_level = 0;

#ifdef OOMPH_HAS_MPI
    unsigned max_level_reached = 1;
#endif

    // Max. number of sample points -- used to decide on termination of
    // "spiraling"
    unsigned max_n_sample_points_of_sample_point_containers = 0;

    // Loop over all meshes
    for (unsigned i_mesh = 0; i_mesh < n_mesh; i_mesh++)
    {
      if (mesh_geom_obj_pt[i_mesh]->sample_point_container_version() ==
          UseRefineableBinArray)
      {
        RefineableBinArray* bin_array_pt = dynamic_cast<RefineableBinArray*>(
          mesh_geom_obj_pt[i_mesh]->sample_point_container_pt());

        bin_array_pt
          ->last_sample_point_to_actually_lookup_during_locate_zeta() =
          bin_array_pt
            ->initial_last_sample_point_to_actually_lookup_during_locate_zeta();
        bin_array_pt
          ->first_sample_point_to_actually_lookup_during_locate_zeta() = 0;

        unsigned nsp =
          bin_array_pt->total_number_of_sample_points_computed_recursively();
        if (nsp > max_n_sample_points_of_sample_point_containers)
        {
          max_n_sample_points_of_sample_point_containers = nsp;
        }


#ifdef OOMPH_HAS_MPI
        // If the mesh has been distributed we want the max. number
        // of sample points across all processors
        if (problem_pt->communicator_pt()->nproc() > 1)
        {
          unsigned local_max_n_sample_points_of_sample_point_containers =
            max_n_sample_points_of_sample_point_containers;

          // Get  maximum over all processors
          MPI_Allreduce(&local_max_n_sample_points_of_sample_point_containers,
                        &max_n_sample_points_of_sample_point_containers,
                        1,
                        MPI_UNSIGNED,
                        MPI_MAX,
                        problem_pt->communicator_pt()->mpi_comm());
        }
#endif
      }
      else if (mesh_geom_obj_pt[i_mesh]->sample_point_container_version() ==
               UseNonRefineableBinArray)
      {
        NonRefineableBinArray* bin_array_pt =
          dynamic_cast<NonRefineableBinArray*>(
            mesh_geom_obj_pt[i_mesh]->sample_point_container_pt());

        // Initialise spiral levels
        bin_array_pt->current_min_spiral_level() = 0;
        bin_array_pt->current_max_spiral_level() =
          bin_array_pt->n_spiral_chunk() - 1;

        // Find maximum spiral level within the cartesian bin structure
        n_max_level = bin_array_pt->max_bin_dimension();

        // Limit it
        if (bin_array_pt->current_max_spiral_level() > n_max_level)
        {
          bin_array_pt->current_max_spiral_level() = n_max_level - 1;
        }
      }
#ifdef OOMPH_HAS_CGAL
      // CGAL
      else if (mesh_geom_obj_pt[i_mesh]->sample_point_container_version() ==
               UseCGALSamplePointContainer)
      {
        CGALSamplePointContainer* bin_array_pt =
          dynamic_cast<CGALSamplePointContainer*>(
            mesh_geom_obj_pt[i_mesh]->sample_point_container_pt());
        bin_array_pt
          ->last_sample_point_to_actually_lookup_during_locate_zeta() =
          bin_array_pt
            ->initial_last_sample_point_to_actually_lookup_during_locate_zeta();
        bin_array_pt
          ->first_sample_point_to_actually_lookup_during_locate_zeta() = 0;

        unsigned nsp =
          bin_array_pt->total_number_of_sample_points_computed_recursively();
        if (nsp > max_n_sample_points_of_sample_point_containers)
        {
          max_n_sample_points_of_sample_point_containers = nsp;
        }


#ifdef OOMPH_HAS_MPI
        // If the mesh has been distributed we want the max. number
        // of sample points across all processors
        if (problem_pt->communicator_pt()->nproc() > 1)
        {
          unsigned local_max_n_sample_points_of_sample_point_containers =
            max_n_sample_points_of_sample_point_containers;

          // Get  maximum over all processors
          MPI_Allreduce(&local_max_n_sample_points_of_sample_point_containers,
                        &max_n_sample_points_of_sample_point_containers,
                        1,
                        MPI_UNSIGNED,
                        MPI_MAX,
                        problem_pt->communicator_pt()->mpi_comm());
        }
#endif
      }
#endif // cgal
    }


    // Storage for info about coordinate location
    Vector<double> percentage_coords_located_locally;
    Vector<double> percentage_coords_located_elsewhere;

    // Loop over "spirals/levels" away from the current position
    // Note: All meshes go through their spirals simultaneously;
    // read out spiral level from first one
    unsigned i_level = 0;
    bool has_not_reached_max_level_of_search = true;
    while (has_not_reached_max_level_of_search)
    {
      // Record time at start of spiral loop
      if (Doc_timings)
      {
        t_spiral_start = TimingHelpers::timer();
      }

      // Perform locate_zeta locally first! This looks locally for
      // all not-yet-located zetas within the current spiral range.
      locate_zeta_for_local_coordinates(
        mesh_pt, external_mesh_pt, mesh_geom_obj_pt, interaction_index);

      // Store stats about successful locates for reporting later
      if (Doc_stats)
      {
        unsigned count_locates = 0;
        unsigned n_ext_loc = External_element_located.size();
        for (unsigned e = 0; e < n_ext_loc; e++)
        {
          unsigned n_intpt = External_element_located[e].size();
          for (unsigned ipt = 0; ipt < n_intpt; ipt++)
          {
            count_locates += External_element_located[e][ipt];
          }
        }

        // Store percentage of integration points successfully located.
        // Only assign if we had anything to allocte, otherwise 100%
        // (default assignment; see above) is correct
        if (tot_int != 0)
        {
          percentage_coords_located_locally.push_back(
            100.0 * double(count_locates) / double(tot_int));
        }
        else
        {
          // Had none to find so we found them all!
          percentage_coords_located_locally.push_back(100.0);
        }
      }


      // Now test whether anything needs to be broadcast elsewhere
      // (i.e. were there any failures in the locate method above?)
      // If there are, then the zetas for these failures need to be
      // broadcast...

      // How many zetas have we failed to find? [Note: Array is padded
      // by Dim padded entries (DBL_MAX) for each mesh]
      n_zeta_not_found =
        Flat_packed_zetas_not_found_locally.size() - Dim * n_mesh;

      if (Doc_timings)
      {
        t_local = TimingHelpers::timer();
        oomph_info << "CPU for local location of zeta coordinate [spiral level "
                   << i_level << "]: " << t_local - t_spiral_start << std::endl
                   << "Number of missing zetas: " << n_zeta_not_found
                   << std::endl;
      }


#ifdef OOMPH_HAS_MPI
      // Only perform the reduction operation if there's more than one process
      if (problem_pt->communicator_pt()->nproc() > 1)
      {
        unsigned count_local_zetas = n_zeta_not_found;
        MPI_Allreduce(&count_local_zetas,
                      &n_zeta_not_found,
                      1,
                      MPI_UNSIGNED,
                      MPI_SUM,
                      problem_pt->communicator_pt()->mpi_comm());
      }

      // If we have missing zetas on any process
      // and the problem is distributed, we need to locate elsewhere
      if ((n_zeta_not_found != 0) &&
          (problem_pt->problem_has_been_distributed()))
      {
        // Timings
        double t_sendrecv_min = DBL_MAX;
        double t_sendrecv_max = -DBL_MAX;
        double t_sendrecv_tot = 0.0;

        double t_missing_min = DBL_MAX;
        double t_missing_max = -DBL_MAX;
        double t_missing_tot = 0.0;

        double t_send_info_min = DBL_MAX;
        double t_send_info_max = -DBL_MAX;
        double t_send_info_tot = 0.0;

        double t_create_halo_min = DBL_MAX;
        double t_create_halo_max = -DBL_MAX;
        double t_create_halo_tot = 0.0;

        // Start ring communication: Loop (number of processes - 1)
        // starting from 1. The variable iproc represents the "distance" from
        // the current process to the process for which it is attempting
        // to locate an element for the current set of not-yet-located
        // zeta coordinates
        unsigned ring_count = 0;
        for (int iproc = 1; iproc < n_proc; iproc++)
        {
          // Record time at start of loop
          if (Doc_timings)
          {
            t_loop_start = TimingHelpers::timer();
          }

          // Send the zeta values you haven't found to the
          // next process, receive from the previous process:
          // (Padded) Flat_packed_zetas_not_found_locally are sent
          // to next processor where they are received as
          // (padded) Received_flat_packed_zetas_to_be_found.
          send_and_receive_missing_zetas(problem_pt);

          if (Doc_timings)
          {
            ring_count++;
            t_sendrecv = TimingHelpers::timer();
            t_sendrecv_max =
              std::max(t_sendrecv_max, t_sendrecv - t_loop_start);
            t_sendrecv_min =
              std::min(t_sendrecv_min, t_sendrecv - t_loop_start);
            t_sendrecv_tot += (t_sendrecv - t_loop_start);
          }

          // Perform the locate_zeta for the new set of zetas on this process
          locate_zeta_for_missing_coordinates(
            iproc, external_mesh_pt, problem_pt, mesh_geom_obj_pt);

          if (Doc_timings)
          {
            t_missing = TimingHelpers::timer();
            t_missing_max = std::max(t_missing_max, t_missing - t_sendrecv);
            t_missing_min = std::min(t_missing_min, t_missing - t_sendrecv);
            t_missing_tot += (t_missing - t_sendrecv);
          }

          // Send any located coordinates back to the correct process, and
          // prepare to send on to the next process if necessary
          send_and_receive_located_info(iproc, external_mesh_pt, problem_pt);

          if (Doc_timings)
          {
            t_send_info = TimingHelpers::timer();
            t_send_info_max =
              std::max(t_send_info_max, t_send_info - t_missing);
            t_send_info_min =
              std::min(t_send_info_min, t_send_info - t_missing);
            t_send_info_tot += (t_send_info - t_missing);
          }

          // Create any located external halo elements on the current process
          create_external_halo_elements<EXT_ELEMENT>(
            iproc, mesh_pt, external_mesh_pt, problem_pt, interaction_index);

          if (Doc_timings)
          {
            t_create_halo = TimingHelpers::timer();
            t_create_halo_max =
              std::max(t_create_halo_max, t_create_halo - t_send_info);
            t_create_halo_min =
              std::min(t_create_halo_min, t_create_halo - t_send_info);
            t_create_halo_tot += (t_create_halo - t_send_info);
          }

          // Do we have any further locating to do or have we found
          // everything at this level of the ring communication?
          // Only perform the reduction operation if there's more than
          // one process [Note: Array is padded
          // by DIM times DBL_MAX entries for each mesh]
          n_zeta_not_found =
            Flat_packed_zetas_not_found_locally.size() - Dim * n_mesh;


#ifdef OOMPH_HAS_MPI
          if (problem_pt->communicator_pt()->nproc() > 1)
          {
            unsigned count_local_zetas = n_zeta_not_found;
            MPI_Allreduce(&count_local_zetas,
                          &n_zeta_not_found,
                          1,
                          MPI_UNSIGNED,
                          MPI_SUM,
                          problem_pt->communicator_pt()->mpi_comm());
          }
#endif

          // If  its is now zero then break out of the ring comms loop
          if (n_zeta_not_found == 0)
          {
            if (Doc_timings)
            {
              t_local = TimingHelpers::timer();
              oomph_info << "BREAK N-1: CPU for entrire spiral [spiral level "
                         << i_level << "]: " << t_local - t_spiral_start
                         << std::endl;
            }
            break;
          }
        }


        // Doc timings
        if (Doc_timings)
        {
          oomph_info << "Ring-based search continued until iteration "
                     << ring_count << " out of a maximum of "
                     << problem_pt->communicator_pt()->nproc() - 1 << "\n";
          oomph_info << "Total, av, max, min CPU for send/recv of remaining "
                        "zeta coordinates: "
                     << t_sendrecv_tot << " "
                     << t_sendrecv_tot / double(ring_count) << " "
                     << t_sendrecv_max << " " << t_sendrecv_min << "\n";
          oomph_info << "Total, av, max, min CPU for location of missing zeta "
                        "coordinates   : "
                     << t_missing_tot << " "
                     << t_missing_tot / double(ring_count) << " "
                     << t_missing_max << " " << t_missing_min << "\n";
          oomph_info << "Total, av, max, min CPU for send/recv of new element "
                        "info          : "
                     << t_send_info_tot << " "
                     << t_send_info_tot / double(ring_count) << " "
                     << t_send_info_max << " " << t_send_info_min << "\n";
          oomph_info << "Total, av, max, min CPU for local creation of "
                        "external halo objects: "
                     << t_create_halo_tot << " "
                     << t_create_halo_tot / double(ring_count) << " "
                     << t_create_halo_max << " " << t_create_halo_min << "\n";
        }

      } // end if for missing zetas on any process
#endif


      // Store information about location of elements for integration points
      if (Doc_stats)
      {
        unsigned count_locates = 0;
        unsigned n_ext_loc = External_element_located.size();
        for (unsigned e = 0; e < n_ext_loc; e++)
        {
          unsigned n_intpt = External_element_located[e].size();
          for (unsigned ipt = 0; ipt < n_intpt; ipt++)
          {
            count_locates += External_element_located[e][ipt];
          }
        }


        // Store total percentage of locates so far.
        // Only assign if we had anything to allocte, otherwise 100%
        // (default assignment) is correct
        if (tot_int != 0)
        {
          percentage_coords_located_elsewhere.push_back(
            100.0 * double(count_locates) / double(tot_int));
        }
        else
        {
          // Had none to find so we found them all!
          percentage_coords_located_locally.push_back(100.0);
        }
      }

      // Do we have any further locating to do? If so, the remaining
      // zetas will (hopefully) be found at the next spiral level.
      // Only perform the reduction operation if there's more than one process
      // [Note: Array is padded
      // by DIM times DBL_MAX entries for each mesh]
      n_zeta_not_found =
        Flat_packed_zetas_not_found_locally.size() - Dim * n_mesh;


#ifdef OOMPH_HAS_MPI
      if (problem_pt->communicator_pt()->nproc() > 1)
      {
        unsigned count_local_zetas = n_zeta_not_found;
        MPI_Allreduce(&count_local_zetas,
                      &n_zeta_not_found,
                      1,
                      MPI_UNSIGNED,
                      MPI_SUM,
                      problem_pt->communicator_pt()->mpi_comm());
      }

      // Specify max level reached for later loop
      max_level_reached = i_level + 1;
#endif

      /// If it's is now zero then break out of the spirals loop
      if (n_zeta_not_found == 0)
      {
        if (Doc_timings)
        {
          t_local = TimingHelpers::timer();
          oomph_info << "BREAK N: CPU for entrire spiral [spiral level "
                     << i_level << "]: " << t_local - t_spiral_start
                     << std::endl;
        }
        break;
      }

      if (Doc_timings)
      {
        t_local = TimingHelpers::timer();
        oomph_info << "CPU for entrire spiral [spiral level " << i_level
                   << "]: " << t_local - t_spiral_start << std::endl;
      }

      // Bump up spiral levels for all meshes
      i_level++;
      for (unsigned i_mesh = 0; i_mesh < n_mesh; i_mesh++)
      {
        if (mesh_geom_obj_pt[i_mesh]->sample_point_container_version() ==
            UseRefineableBinArray)
        {
          RefineableBinArray* bin_array_pt = dynamic_cast<RefineableBinArray*>(
            mesh_geom_obj_pt[i_mesh]->sample_point_container_pt());
          bin_array_pt
            ->first_sample_point_to_actually_lookup_during_locate_zeta() =
            bin_array_pt
              ->last_sample_point_to_actually_lookup_during_locate_zeta();
          bin_array_pt
            ->last_sample_point_to_actually_lookup_during_locate_zeta() *=
            bin_array_pt
              ->multiplier_for_max_sample_point_to_actually_lookup_during_locate_zeta();
        }
        else if (mesh_geom_obj_pt[i_mesh]->sample_point_container_version() ==
                 UseNonRefineableBinArray)
        {
          NonRefineableBinArray* bin_array_pt =
            dynamic_cast<NonRefineableBinArray*>(
              mesh_geom_obj_pt[i_mesh]->sample_point_container_pt());

          bin_array_pt->current_min_spiral_level() +=
            bin_array_pt->n_spiral_chunk();
          bin_array_pt->current_max_spiral_level() +=
            bin_array_pt->n_spiral_chunk();
        }
#ifdef OOMPH_HAS_CGAL
        else if (mesh_geom_obj_pt[i_mesh]->sample_point_container_version() ==
                 UseCGALSamplePointContainer)
        {
          CGALSamplePointContainer* bin_array_pt =
            dynamic_cast<CGALSamplePointContainer*>(
              mesh_geom_obj_pt[i_mesh]->sample_point_container_pt());
          bin_array_pt
            ->first_sample_point_to_actually_lookup_during_locate_zeta() =
            bin_array_pt
              ->last_sample_point_to_actually_lookup_during_locate_zeta();
          bin_array_pt
            ->last_sample_point_to_actually_lookup_during_locate_zeta() *=
            bin_array_pt
              ->multiplier_for_max_sample_point_to_actually_lookup_during_locate_zeta();
        }
#endif // cgal
      }

      // Check termination criterion for while loop
      if (mesh_geom_obj_pt[0]->sample_point_container_version() ==
          UseRefineableBinArray)
      {
        RefineableBinArray* bin_array_pt = dynamic_cast<RefineableBinArray*>(
          mesh_geom_obj_pt[0]->sample_point_container_pt());

        if (bin_array_pt
              ->first_sample_point_to_actually_lookup_during_locate_zeta() <=
            max_n_sample_points_of_sample_point_containers)
        {
          has_not_reached_max_level_of_search = true;
        }
        else
        {
          has_not_reached_max_level_of_search = false;
        }
      }
      else if (mesh_geom_obj_pt[0]->sample_point_container_version() ==
               UseNonRefineableBinArray)
      {
        NonRefineableBinArray* bin_array_pt =
          dynamic_cast<NonRefineableBinArray*>(
            mesh_geom_obj_pt[0]->sample_point_container_pt());

        if (bin_array_pt->current_max_spiral_level() < n_max_level)
        {
          has_not_reached_max_level_of_search = true;
        }
        else
        {
          has_not_reached_max_level_of_search = false;
        }
      }
#ifdef OOMPH_HAS_CGAL
      else if (mesh_geom_obj_pt[0]->sample_point_container_version() ==
               UseCGALSamplePointContainer)
      {
        CGALSamplePointContainer* bin_array_pt =
          dynamic_cast<CGALSamplePointContainer*>(
            mesh_geom_obj_pt[0]->sample_point_container_pt());

        if (bin_array_pt
              ->first_sample_point_to_actually_lookup_during_locate_zeta() <=
            max_n_sample_points_of_sample_point_containers)
        {
          has_not_reached_max_level_of_search = true;
        }
        else
        {
          has_not_reached_max_level_of_search = false;
        }
      }
#endif // cgal
    } // end of "spirals" loop


    // If we haven't found all zetas we're dead now...
    //-------------------------------------------------
    if (n_zeta_not_found != 0)
    {
      // Shout?
      if (!Accept_failed_locate_zeta_in_setup_multi_domain_interaction)
      {
        std::ostringstream error_stream;
        error_stream
          << "Multi_domain_functions::locate_zeta_for_local_coordinates()"
          << "\nhas failed ";

#ifdef OOMPH_HAS_MPI
        if (problem_pt->communicator_pt()->nproc() > 1)
        {
          error_stream << " on proc: "
                       << problem_pt->communicator_pt()->my_rank() << std::endl;
        }
#endif
        error_stream
          << "\n\n\nThis is most likely to arise because the two meshes\n"
          << "that are to be matched don't overlap perfectly or\n"
          << "because the elements are distorted and too small a \n"
          << "number of sampling points has been used when setting\n"
          << "up the bin structure.\n\n"
          << "You should try to increase the value of \n"
          << "the number of sample points defined in \n\n"
          << "  "
             "SamplePointContainerParameters::Default_nsample_points_generated_"
             "per_element"
          << "\n\n from its current value of "
          << SamplePointContainerParameters::
               Default_nsample_points_generated_per_element
          << "\n"
          << "\n\n"
          << "NOTE: You can suppress this error and \"accept failure\""
          << "      by setting the public boolean \n\n"
          << "        "
             "Multi_domain_functions::Accept_failed_locate_zeta_in_setup_multi_"
             "domain_interaction\n\n"
          << "      to true. In this case, the pointers to external elements\n"
          << "      that couldn't be located will remain null\n";

        std::ostringstream modifier;
#ifdef OOMPH_HAS_MPI
        if (problem_pt->communicator_pt()->nproc() > 1)
        {
          modifier << "_proc" << problem_pt->communicator_pt()->my_rank();
        }
#endif

        // Loop over all meshes
        for (unsigned i_mesh = 0; i_mesh < n_mesh; i_mesh++)
        {
          // Add yet another modifier to distinguish meshes if reqd
          if (n_mesh > 1)
          {
            modifier << "_mesh" << i_mesh;
          }

          std::ofstream outfile;
          char filename[100];
          sprintf(
            filename, "missing_coords_mesh%s.dat", modifier.str().c_str());
          outfile.open(filename);
          unsigned nel = mesh_pt[i_mesh]->nelement();
          for (unsigned e = 0; e < nel; e++)
          {
            mesh_pt[i_mesh]->finite_element_pt(e)->output(outfile);
            // FiniteElement::output(outfile);
          }
          outfile.close();

          sprintf(
            filename, "missing_coords_ext_mesh%s.dat", modifier.str().c_str());
          outfile.open(filename);
          nel = external_mesh_pt->nelement();
          for (unsigned e = 0; e < nel; e++)
          {
            external_mesh_pt->finite_element_pt(e)->output(outfile);
            // FiniteElement::output(outfile);
          }
          outfile.close();

          BinArray* bin_array_pt = dynamic_cast<BinArray*>(
            mesh_geom_obj_pt[i_mesh]->sample_point_container_pt());
          if (bin_array_pt != 0)
          {
            sprintf(
              filename, "missing_coords_bin%s.dat", modifier.str().c_str());
            outfile.open(filename);
            bin_array_pt->output_bins(outfile);
            outfile.close();
          }

          sprintf(filename, "missing_coords%s.dat", modifier.str().c_str());
          outfile.open(filename);
          unsigned n = External_element_located.size();
          error_stream << "Number of unlocated elements " << n << std::endl;
          for (unsigned e = 0; e < n; e++)
          {
            unsigned n_intpt = External_element_located[e].size();
            if (n_intpt == 0)
            {
              error_stream << "Failure to locate in halo element! "
                           << "Why are we searching there?" << std::endl;
            }
            for (unsigned ipt = 0; ipt < n_intpt; ipt++)
            {
              if (External_element_located[e][ipt] == 0)
              {
                error_stream << "Failure at element/intpt: " << e << " " << ipt
                             << std::endl;

                // Cast
                ElementWithExternalElement* el_pt =
                  dynamic_cast<ElementWithExternalElement*>(
                    mesh_pt[i_mesh]->element_pt(e));

                unsigned n_dim_el = el_pt->dim();
                Vector<double> s(n_dim_el);
                for (unsigned i = 0; i < n_dim_el; i++)
                {
                  s[i] = el_pt->integral_pt()->knot(ipt, i);
                }
                unsigned n_dim = el_pt->node_pt(0)->ndim();
                Vector<double> x(n_dim);
                el_pt->interpolated_x(s, x);
                for (unsigned i = 0; i < n_dim; i++)
                {
                  error_stream << x[i] << " ";
                  outfile << x[i] << " ";
                }
                error_stream << std::endl;
                outfile << std::endl;
              }
            }
          }
          outfile.close();
        }

        error_stream
          << "Mesh and external mesh documented in missing_coords_mesh*.dat\n"
          << "and missing_coords_ext_mesh*.dat, respectively. Missing \n"
          << "coordinates in missing_coords*.dat\n";
        throw OomphLibError(
          error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
      }
      // Failure is deeemed to be acceptable
      else
      {
        oomph_info
          << "NOTE: Haven't found " << n_zeta_not_found
          << " external elements in \n"
          << "Multi_domain_functions::aux_setup_multi_domain_interaction(...)\n"
          << "but this deemed to be acceptable because \n"
          << "Multi_domain_functions::Accept_failed_locate_zeta_in_setup_multi_"
             "domain_interaction\n"
          << "is true.\n";
      }
    }


    // Doc timings if required
    if (Doc_timings)
    {
      t_locate = TimingHelpers::timer();
      oomph_info
        << "Total CPU for location and creation of all external elements: "
        << t_locate - t_start << std::endl;
    }

    // Delete the geometric object representing the mesh
    for (unsigned i_mesh = 0; i_mesh < n_mesh; i_mesh++)
    {
      delete mesh_geom_obj_pt[i_mesh];
    }

    // Clean up all the (extern) Vectors associated with creating the
    // external storage information
    clean_up();

#ifdef OOMPH_HAS_MPI

    // Output information about external storage if required
    if (Doc_stats)
    {
      // Report stats regarding location method
      bool comm_was_required = false;
      oomph_info << "-------------------------------------------" << std::endl;
      oomph_info << "- Cumulative percentage of locate success -" << std::endl;
      oomph_info << "--- Spiral -- Found local -- Found else ---" << std::endl;
      for (unsigned level = 0; level < max_level_reached; level++)
      {
        oomph_info << "---   " << level << "   -- "
                   << percentage_coords_located_locally[level] << " -- "
                   << percentage_coords_located_elsewhere[level] << " ---"
                   << std::endl;
        // Has communication with other processors at this level actually
        // produced any results?
        if (percentage_coords_located_elsewhere[level] >
            percentage_coords_located_locally[level])
        {
          comm_was_required = true;
        }
      }
      oomph_info << "-------------------------------------------" << std::endl;


      // No need for any of this malaki if we're not running in parallel
      if (problem_pt->communicator_pt()->nproc() > 1)
      {
        // Initialise to indicate that none of the zetas required
        // on this processor were located through parallel ring search,
        // i.e. comm was not required and we could have done some
        // more local searching first
        oomph_info << std::endl;
        oomph_info << "ASSESSMENT OF NEED FOR PARALLEL SEARCH: \n";
        oomph_info << "=======================================\n";
        unsigned status = 0;
        if (comm_was_required)
        {
          oomph_info << "- Ring-based parallel search did successfully locate "
                        "zetas on proc "
                     << my_rank << std::endl;
          status = 1;
        }
        else
        {
          if (max_level_reached > 1)
          {
            oomph_info
              << "- Ring-based parallel search did NOT locate zetas on proc"
              << my_rank << std::endl;
          }
          else
          {
            oomph_info
              << "- No ring-based parallel search was performed on proc"
              << my_rank << std::endl;
          }
        }

        // Allreduce to check if anyone has benefitted from parallel ring
        // search
        unsigned overall_status = 0;
        MPI_Allreduce(&status,
                      &overall_status,
                      1,
                      MPI_UNSIGNED,
                      MPI_MAX,
                      problem_pt->communicator_pt()->mpi_comm());

        // Report of mpi was useful to anyone
        if (overall_status == 1)
        {
          oomph_info << "- Ring-based, parallel search did succesfully\n";
          oomph_info << "  locate zetas on at least one other proc, so it\n";
          oomph_info << "  was worthwhile.\n";
          oomph_info << std::endl;
        }
        else
        {
          if (max_level_reached > 1)
          {
            oomph_info
              << "- Ring-based, parallel search did NOT locate zetas\n";
            oomph_info << "  on ANY other procs, i.e it was useless.\n";
            oomph_info
              << "  --> We should really have done more local search\n";
            oomph_info
              << "   by reducing number of bins, or doing more spirals\n";
            oomph_info << "   in one go before initiating parallel search.\n";
            oomph_info << std::endl;
          }
          else
          {
            oomph_info << "- No ring-based, parallel search was performed\n";
            oomph_info << "  or necessary. Perfect!\n";
            oomph_info << std::endl;
          }
        }
      }

      // How many external elements does the external mesh have now?
      oomph_info << "------------------------------------------" << std::endl;
      oomph_info << "External mesh: I have " << external_mesh_pt->nelement()
                 << " elements, and " << std::endl
                 << external_mesh_pt->nexternal_halo_element()
                 << " external halo elements, "
                 << external_mesh_pt->nexternal_haloed_element()
                 << " external haloed elements" << std::endl;

      // How many external nodes does each submesh have now?
      oomph_info << "------------------------------------------" << std::endl;
      oomph_info << "External mesh: I have " << external_mesh_pt->nnode()
                 << " nodes, and " << std::endl
                 << external_mesh_pt->nexternal_halo_node()
                 << " external halo nodes, "
                 << external_mesh_pt->nexternal_haloed_node()
                 << " external haloed nodes" << std::endl;
      oomph_info << "------------------------------------------" << std::endl;
    }

    // Output further information about (external) halo(ed)
    // elements and nodes if required
    if (Doc_full_stats)
    {
      // How many elements does this submesh have for each of the processors?
      for (int iproc = 0; iproc < n_proc; iproc++)
      {
        oomph_info << "----------------------------------------" << std::endl;
        oomph_info << "With process " << iproc << " there are "
                   << external_mesh_pt->nroot_halo_element(iproc)
                   << " root halo elements, and "
                   << external_mesh_pt->nroot_haloed_element(iproc)
                   << " root haloed elements" << std::endl
                   << "and there are "
                   << external_mesh_pt->nexternal_halo_element(iproc)
                   << " external halo elements, and "
                   << external_mesh_pt->nexternal_haloed_element(iproc)
                   << " external haloed elements." << std::endl;

        oomph_info << "----------------------------------------" << std::endl;
        oomph_info << "With process " << iproc << " there are "
                   << external_mesh_pt->nhalo_node(iproc) << " halo nodes, and "
                   << external_mesh_pt->nhaloed_node(iproc) << " haloed nodes"
                   << std::endl
                   << "and there are "
                   << external_mesh_pt->nexternal_halo_node(iproc)
                   << " external halo nodes, and "
                   << external_mesh_pt->nexternal_haloed_node(iproc)
                   << " external haloed nodes." << std::endl;
      }
      oomph_info << "-----------------------------------------" << std::endl
                 << std::endl;
    }

#endif

    // Doc timings if required
    if (Doc_timings)
    {
      t_end = TimingHelpers::timer();
      oomph_info << "CPU for (one way) aux_setup_multi_domain_interaction: "
                 << t_end - t_start << std::endl;
    }

  } // end of aux_setup_multi_domain_interaction

#ifdef OOMPH_HAS_MPI

  //=====================================================================
  /// Creates external (halo) elements on the loop process based on the
  /// information received from each locate_zeta call on other processes.
  /// vector based version
  //=====================================================================
  template<class EXT_ELEMENT>
  void Multi_domain_functions::create_external_halo_elements(
    int& iproc,
    const Vector<Mesh*>& mesh_pt,
    Mesh* const& external_mesh_pt,
    Problem* problem_pt,
    const unsigned& interaction_index)
  {
    OomphCommunicator* comm_pt = problem_pt->communicator_pt();
    int my_rank = comm_pt->my_rank();

    // Reset counters for flat packed unsigneds (namespace data because
    // it's also accessed by helper functions)
    Counter_for_flat_packed_doubles = 0;
    Counter_for_flat_packed_unsigneds = 0;

    // Initialise counter for stepping through zetas
    unsigned zeta_counter = 0;

    // Initialise counter for stepping through flat-packed located
    // coordinates
    unsigned counter_for_located_coord = 0;

    // Counter for elements in flag packed storage
    unsigned e_count = 0;

    // Loop over all meshes
    unsigned n_mesh = mesh_pt.size();
    for (unsigned i_mesh = 0; i_mesh < n_mesh; i_mesh++)
    {
      // The creation all happens on the current processor
      // Loop over this processors elements
      unsigned n_element = mesh_pt[i_mesh]->nelement();
      for (unsigned e = 0; e < n_element; e++)
      {
        // Cast to ElementWithExternalElement to set external element
        // (if located)
        ElementWithExternalElement* el_pt =
          dynamic_cast<ElementWithExternalElement*>(
            mesh_pt[i_mesh]->element_pt(e));

        // We're not setting up external elements for halo elements
        // (Note: this is consistent with padding introduced when
        // External_element_located was first assigned)
        if (!el_pt->is_halo())
        {
          // Loop over integration points
          unsigned n_intpt = el_pt->integral_pt()->nweight();
          for (unsigned ipt = 0; ipt < n_intpt; ipt++)
          {
            // Has an external element been assigned to this integration point?
            if (External_element_located[e_count][ipt] == 0)
            {
              // Was a (non-halo) element located for this integration point
              if (((Proc_id_plus_one_of_external_element[zeta_counter] - 1) ==
                   my_rank) ||
                  (Proc_id_plus_one_of_external_element[zeta_counter] == 0))
              {
                // Either it was already found, or not found on the current
                // proc. In either case, we don't need to do anything for this
                // integration point
              }
              else
              {
                // Get the process number on which the element was located
                unsigned loc_p =
                  Proc_id_plus_one_of_external_element[zeta_counter] - 1;

                // Is it a new external halo element or not?
                // If so, then create it, populate it, and add it as a
                // source; if not, then find the right one which
                // has already been created and use it as the source
                // element.

                // FiniteElement stored at this integration point
                FiniteElement* f_el_pt = 0;

                // Is it a new element?
                if (Located_element_status[zeta_counter] == New)
                {
                  // Create a new element from the communicated values
                  // and coords from the process that located zeta
                  GeneralisedElement* new_el_pt = new EXT_ELEMENT;

                  // Add external halo element to this mesh
                  external_mesh_pt->add_external_halo_element_pt(loc_p,
                                                                 new_el_pt);

                  // Cast to the FE pointer
                  f_el_pt = dynamic_cast<FiniteElement*>(new_el_pt);

                  // We need the number of interpolated values if Refineable
                  int n_cont_inter_values = -1;
                  if (dynamic_cast<RefineableElement*>(new_el_pt) != 0)
                  {
                    n_cont_inter_values =
                      dynamic_cast<RefineableElement*>(new_el_pt)
                        ->ncont_interpolated_values();
                  }

                  // If we're using macro elements to update
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
                  oomph_info
                    << "Rec:" << Counter_for_flat_packed_unsigneds
                    << "  Using macro element node update "
                    << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                    << std::endl;
#endif
                  if (Flat_packed_unsigneds
                        [Counter_for_flat_packed_unsigneds++] == 1)
                  {
                    // Set the macro element
                    MacroElementNodeUpdateMesh* macro_mesh_pt =
                      dynamic_cast<MacroElementNodeUpdateMesh*>(
                        external_mesh_pt);

#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
                    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                               << "  Number of macro element "
                               << Flat_packed_unsigneds
                                    [Counter_for_flat_packed_unsigneds]
                               << std::endl;
#endif
                    unsigned macro_el_num = Flat_packed_unsigneds
                      [Counter_for_flat_packed_unsigneds++];
                    f_el_pt->set_macro_elem_pt(
                      macro_mesh_pt->macro_domain_pt()->macro_element_pt(
                        macro_el_num));


                    // We need to receive the lower left
                    // and upper right coordinates of the macro element
                    QElementBase* q_el_pt =
                      dynamic_cast<QElementBase*>(new_el_pt);
                    if (q_el_pt != 0)
                    {
                      unsigned el_dim = q_el_pt->dim();
                      for (unsigned i_dim = 0; i_dim < el_dim; i_dim++)
                      {
                        q_el_pt->s_macro_ll(i_dim) = Flat_packed_doubles
                          [Counter_for_flat_packed_doubles++];
                        q_el_pt->s_macro_ur(i_dim) = Flat_packed_doubles
                          [Counter_for_flat_packed_doubles++];
                      }
                    }
                    else // Throw an error, since this is only implemented for Q
                    {
                      std::ostringstream error_stream;
                      error_stream << "Using MacroElement node update\n"
                                   << "in a case with non-QElements\n"
                                   << "has not yet been implemented.\n";
                      throw OomphLibError(error_stream.str(),
                                          OOMPH_CURRENT_FUNCTION,
                                          OOMPH_EXCEPTION_LOCATION);
                    }
                  }

                  // Now we add nodes to the new element
                  unsigned n_node = f_el_pt->nnode();
                  for (unsigned j = 0; j < n_node; j++)
                  {
                    Node* new_nod_pt = 0;

                    // Call the add external halo node helper function
                    add_external_halo_node_to_storage<EXT_ELEMENT>(
                      new_nod_pt,
                      external_mesh_pt,
                      loc_p,
                      j,
                      f_el_pt,
                      n_cont_inter_values,
                      problem_pt);
                  }
                }
                else // the element already exists as an external_halo
                {
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
                  oomph_info
                    << "Rec:" << Counter_for_flat_packed_unsigneds
                    << "  Index of existing external halo element "
                    << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                    << std::endl;
#endif
                  // The index itself is in Flat_packed_unsigneds[...]
                  unsigned external_halo_el_index =
                    Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

                  // Use this index to get the element
                  f_el_pt = dynamic_cast<FiniteElement*>(
                    external_mesh_pt->external_halo_element_pt(
                      loc_p, external_halo_el_index));

                  // If it's not a finite element die
                  if (f_el_pt == 0)
                  {
                    throw OomphLibError(
                      "External halo element is not a FiniteElement\n",
                      OOMPH_CURRENT_FUNCTION,
                      OOMPH_EXCEPTION_LOCATION);
                  }
                }

                // The source element storage was initialised but
                // not filled earlier, so do it now
                // The located coordinates are required
                // (which could be a different dimension to zeta, e.g. in FSI)
                unsigned el_dim = f_el_pt->dim();
                Vector<double> s_located(el_dim);
                for (unsigned i = 0; i < el_dim; i++)
                {
                  s_located[i] =
                    Flat_packed_located_coordinates[counter_for_located_coord];
                  counter_for_located_coord++;
                }

                // Set the element for this integration point
                el_pt->external_element_pt(interaction_index, ipt) = f_el_pt;
                el_pt->external_element_local_coord(interaction_index, ipt) =
                  s_located;

                // Set the lookup array to true
                External_element_located[e_count][ipt] = 1;
              }

              // Increment the integration point counter
              zeta_counter++;
            }
          } // end loop over integration points
        } // end of is halo

        // Bump flat-packed element counter
        e_count++;

      } // end of loop over elements

      // Bump up zeta counter to skip over padding entry at end of
      // mesh
      zeta_counter++;

    } // end loop over meshes
  }


  //============start of add_external_halo_node_to_storage===============
  /// Helper function to add external halo nodes, including any masters,
  /// based on information received from the haloed process
  //=========================================================================
  template<class EXT_ELEMENT>
  void Multi_domain_functions::add_external_halo_node_to_storage(
    Node*& new_nod_pt,
    Mesh* const& external_mesh_pt,
    unsigned& loc_p,
    unsigned& node_index,
    FiniteElement* const& new_el_pt,
    int& n_cont_inter_values,
    Problem* problem_pt)
  {
    // Add the external halo node if required
    add_external_halo_node_helper(new_nod_pt,
                                  external_mesh_pt,
                                  loc_p,
                                  node_index,
                                  new_el_pt,
                                  n_cont_inter_values,
                                  problem_pt);

    // Recursively add masters
    recursively_add_masters_of_external_halo_node_to_storage<EXT_ELEMENT>(
      new_nod_pt,
      external_mesh_pt,
      loc_p,
      node_index,
      new_el_pt,
      n_cont_inter_values,
      problem_pt);
  }


  //========================================================================
  /// Recursively add masters of external halo nodes (and their masters, etc)
  /// based on information received from the haloed process
  //=========================================================================
  template<class EXT_ELEMENT>
  void Multi_domain_functions::
    recursively_add_masters_of_external_halo_node_to_storage(
      Node*& new_nod_pt,
      Mesh* const& external_mesh_pt,
      unsigned& loc_p,
      unsigned& node_index,
      FiniteElement* const& new_el_pt,
      int& n_cont_inter_values,
      Problem* problem_pt)
  {
    for (int i_cont = -1; i_cont < n_cont_inter_values; i_cont++)
    {
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << " Boolean to indicate that continuously interpolated "
                    "variable i_cont "
                 << i_cont << " is hanging "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 1)
      {
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Number of master nodes "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        unsigned n_master =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        // Setup new HangInfo
        HangInfo* hang_pt = new HangInfo(n_master);
        for (unsigned m = 0; m < n_master; m++)
        {
          Node* master_nod_pt = 0;
          // Get the master node (creating and adding it if required)
          add_external_halo_master_node_helper<EXT_ELEMENT>(master_nod_pt,
                                                            new_nod_pt,
                                                            external_mesh_pt,
                                                            loc_p,
                                                            n_cont_inter_values,
                                                            problem_pt);

          // Get the weight and set the HangInfo
          double master_weight =
            Flat_packed_doubles[Counter_for_flat_packed_doubles++];
          hang_pt->set_master_node_pt(m, master_nod_pt, master_weight);

          // Recursively add masters of master
          recursively_add_masters_of_external_halo_node_to_storage<EXT_ELEMENT>(
            master_nod_pt,
            external_mesh_pt,
            loc_p,
            node_index,
            new_el_pt,
            n_cont_inter_values,
            problem_pt);
        }
        new_nod_pt->set_hanging_pt(hang_pt, i_cont);
      }
    } // end loop over continous interpolated values
  }

  //========================================================================
  /// Helper function to add external halo node that is a master
  //========================================================================
  template<class EXT_ELEMENT>
  void Multi_domain_functions::add_external_halo_master_node_helper(
    Node*& new_master_nod_pt,
    Node*& new_nod_pt,
    Mesh* const& external_mesh_pt,
    unsigned& loc_p,
    int& ncont_inter_values,
    Problem* problem_pt)
  {
    // Given the node and the external mesh, and received information
    // about them from process loc_p, construct them on the current process
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
    oomph_info
      << "Rec:" << Counter_for_flat_packed_unsigneds
      << "  Boolean to trigger construction of new external halo master node "
      << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds] << std::endl;
#endif
    if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 1)
    {
      // Construct a new node based upon sent information
      construct_new_external_halo_master_node_helper<EXT_ELEMENT>(
        new_master_nod_pt, new_nod_pt, loc_p, external_mesh_pt, problem_pt);
    }
    else
    {
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  index of existing external halo master node "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      // Copy node from received location
      new_master_nod_pt = external_mesh_pt->external_halo_node_pt(
        loc_p, Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++]);
    }
  }

  //======start of construct_new_external_halo_master_node_helper===========
  /// Helper function which constructs a new external halo master node
  /// with the required information sent from the haloed process
  //========================================================================
  template<class EXT_ELEMENT>
  void Multi_domain_functions::construct_new_external_halo_master_node_helper(
    Node*& new_master_nod_pt,
    Node*& nod_pt,
    unsigned& loc_p,
    Mesh* const& external_mesh_pt,
    Problem* problem_pt)
  {
    // First three sent numbers are dimension, position type and nvalue
    // (to be used in Node constructors)
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << "  ndim for external halo master node "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    unsigned n_dim = Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << "  nposition type for external halo master node "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    unsigned n_position_type =
      Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << "  nvalue for external halo master node "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    unsigned n_value =
      Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

    // If it's a solid node also receive the lagrangian dimension and pos type
    SolidNode* solid_nod_pt = dynamic_cast<SolidNode*>(nod_pt);
    unsigned n_lag_dim;
    unsigned n_lag_type;
    if (solid_nod_pt != 0)
    {
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  nlagrdim for external halo master solid node "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      n_lag_dim = Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  nlagrtype for external halo master solid node "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      n_lag_type = Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
    }

    // Null TimeStepper for now
    TimeStepper* time_stepper_pt = 0;
    // Default number of previous values to 1
    unsigned n_prev = 1;

    // The first entry in nodal_info indicates
    // the timestepper required for this halo node
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
    oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
               << "  Boolean: need timestepper "
               << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
               << std::endl;
#endif
    if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 1)
    {
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  Index minus one of timestepper "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      // Index minus one!
      time_stepper_pt = problem_pt->time_stepper_pt(
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++]);

      // Check whether number of prev values is "sent" across
      n_prev = time_stepper_pt->ntstorage();
    }

    // Is the node for which the master is required Algebraic, Macro or Solid?
    AlgebraicNode* alg_nod_pt = dynamic_cast<AlgebraicNode*>(nod_pt);
    MacroElementNodeUpdateNode* macro_nod_pt =
      dynamic_cast<MacroElementNodeUpdateNode*>(nod_pt);

    // What type of node was the node for which we are constructing a master?
    if (alg_nod_pt != 0)
    {
      // The master node should also be algebraic
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  Boolean for algebraic boundary node "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      // If this master node's haloed copy is on a boundary then
      // it needs to be on the same boundary here
      if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 1)
      {
        // Create a new BoundaryNode (not attached to an element)
        if (time_stepper_pt != 0)
        {
          new_master_nod_pt = new BoundaryNode<AlgebraicNode>(
            time_stepper_pt, n_dim, n_position_type, n_value);
        }
        else
        {
          new_master_nod_pt =
            new BoundaryNode<AlgebraicNode>(n_dim, n_position_type, n_value);
        }

        // How many boundaries does the algebraic master node live on?
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << " Number of boundaries the algebraic master node is on: "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        unsigned nb =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        for (unsigned i = 0; i < nb; i++)
        {
          // Boundary number
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
          oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                     << "  Algebraic master node is on boundary "
                     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                     << std::endl;
#endif
          unsigned i_bnd =
            Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
          external_mesh_pt->add_boundary_node(i_bnd, new_master_nod_pt);
        }


        // Do we have additional values created by face elements?
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds << " "
                   << "Number of additional values created by face element "
                   << "for master node "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        unsigned n_entry =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        if (n_entry > 0)
        {
          // Create storage, if it doesn't already exist, for the map
          // that will contain the position of the first entry of
          // this face element's additional values,
          BoundaryNodeBase* bnew_master_nod_pt =
            dynamic_cast<BoundaryNodeBase*>(new_master_nod_pt);
#ifdef PARANOID
          if (bnew_master_nod_pt == 0)
          {
            throw OomphLibError("Failed to cast new node to boundary node\n",
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }
#endif
          if (bnew_master_nod_pt
                ->index_of_first_value_assigned_by_face_element_pt() == 0)
          {
            bnew_master_nod_pt
              ->index_of_first_value_assigned_by_face_element_pt() =
              new std::map<unsigned, unsigned>;
          }

          // Get pointer to the map of indices associated with
          // additional values created by face elements
          std::map<unsigned, unsigned>* map_pt =
            bnew_master_nod_pt
              ->index_of_first_value_assigned_by_face_element_pt();

          // Loop over number of entries in map
          for (unsigned i = 0; i < n_entry; i++)
          {
            // Read out pairs...

#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
            oomph_info
              << "Rec:" << Counter_for_flat_packed_unsigneds
              << " Key of map entry for master node"
              << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
              << std::endl;
#endif
            unsigned first =
              Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
            oomph_info
              << "Rec:" << Counter_for_flat_packed_unsigneds
              << " Value of map entry for master node"
              << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
              << std::endl;
#endif
            unsigned second =
              Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

            // ...and assign
            (*map_pt)[first] = second;
          }
        }
      }
      else
      {
        // Create node (not attached to any element)
        if (time_stepper_pt != 0)
        {
          new_master_nod_pt =
            new AlgebraicNode(time_stepper_pt, n_dim, n_position_type, n_value);
        }
        else
        {
          new_master_nod_pt =
            new AlgebraicNode(n_dim, n_position_type, n_value);
        }
      }

      // Add this as an external halo node BEFORE considering node update!
      external_mesh_pt->add_external_halo_node_pt(loc_p, new_master_nod_pt);

      // The external mesh is itself Algebraic...
      AlgebraicMesh* alg_mesh_pt =
        dynamic_cast<AlgebraicMesh*>(external_mesh_pt);

#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  algebraic node update id for master node "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      /// The first entry of All_unsigned_values is the default node update id
      unsigned update_id =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      // Setup algebraic node update info for this new node
      Vector<double> ref_value;

#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  algebraic node number of ref values for master node "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      // The size of this vector is in the next entry
      unsigned n_ref_val =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      // The reference values are in the subsequent entries of All_double_values
      ref_value.resize(n_ref_val);
      for (unsigned i_ref = 0; i_ref < n_ref_val; i_ref++)
      {
        ref_value[i_ref] =
          Flat_packed_doubles[Counter_for_flat_packed_doubles++];
      }

      // Also require a Vector of geometric objects
      Vector<GeomObject*> geom_object_pt;

#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  algebraic node number of geom objects for master node "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif

      // The size of this vector is in the next entry of All_unsigned_values
      unsigned n_geom_obj =
        Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

      // The remaining indices are in the rest of
      // All_alg_nodal_info
      geom_object_pt.resize(n_geom_obj);
      for (unsigned i_geom = 0; i_geom < n_geom_obj; i_geom++)
      {
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  algebraic node: " << i_geom << "-th out of "
                   << n_geom_obj << "-th geom index "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        unsigned geom_index =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

        // This index indicates which (if any) of the AlgebraicMesh's
        // stored geometric objects should be used
        geom_object_pt[i_geom] = alg_mesh_pt->geom_object_list_pt(geom_index);
      }

      AlgebraicNode* alg_master_nod_pt =
        dynamic_cast<AlgebraicNode*>(new_master_nod_pt);

      /// ... so for the specified update_id, call
      /// add_node_update_info
      alg_master_nod_pt->add_node_update_info(
        update_id, alg_mesh_pt, geom_object_pt, ref_value);

      /// Now call update_node_update
      alg_mesh_pt->update_node_update(alg_master_nod_pt);
    }
    else if (macro_nod_pt != 0)
    {
      // The master node should also be a macro node
      // If this master node's haloed copy is on a boundary then
      // it needs to be on the same boundary here
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  Boolean for master algebraic node is boundary node "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 1)
      {
        // Create a new BoundaryNode (not attached to an element)
        if (time_stepper_pt != 0)
        {
          new_master_nod_pt = new BoundaryNode<MacroElementNodeUpdateNode>(
            time_stepper_pt, n_dim, n_position_type, n_value);
        }
        else
        {
          new_master_nod_pt = new BoundaryNode<MacroElementNodeUpdateNode>(
            n_dim, n_position_type, n_value);
        }


        // How many boundaries does the macro element master node live on?
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
        oomph_info
          << "Rec:" << Counter_for_flat_packed_unsigneds
          << " Number of boundaries the macro element master node is on: "
          << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
          << std::endl;
#endif
        unsigned nb =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        for (unsigned i = 0; i < nb; i++)
        {
          // Boundary number
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
          oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                     << "  Macro element master node is on boundary "
                     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                     << std::endl;
#endif
          unsigned i_bnd =
            Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
          external_mesh_pt->add_boundary_node(i_bnd, new_master_nod_pt);
        }

        // Do we have additional values created by face elements?
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << " Number of additional values created by face element "
                   << "for macro element master node "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        unsigned n_entry =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        if (n_entry > 0)
        {
          // Create storage, if it doesn't already exist, for the map
          // that will contain the position of the first entry of
          // this face element's additional values,
          BoundaryNodeBase* bnew_master_nod_pt =
            dynamic_cast<BoundaryNodeBase*>(new_master_nod_pt);
#ifdef PARANOID
          if (bnew_master_nod_pt == 0)
          {
            throw OomphLibError("Failed to cast new node to boundary node\n",
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }
#endif
          if (bnew_master_nod_pt
                ->index_of_first_value_assigned_by_face_element_pt() == 0)
          {
            bnew_master_nod_pt
              ->index_of_first_value_assigned_by_face_element_pt() =
              new std::map<unsigned, unsigned>;
          }

          // Get pointer to the map of indices associated with
          // additional values created by face elements
          std::map<unsigned, unsigned>* map_pt =
            bnew_master_nod_pt
              ->index_of_first_value_assigned_by_face_element_pt();

          // Loop over number of entries in map
          for (unsigned i = 0; i < n_entry; i++)
          {
            // Read out pairs...

#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
            oomph_info
              << "Rec:" << Counter_for_flat_packed_unsigneds
              << " Key of map entry for macro element master node"
              << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
              << std::endl;
#endif
            unsigned first =
              Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
            oomph_info
              << "Rec:" << Counter_for_flat_packed_unsigneds
              << " Value of map entry for macro element master node"
              << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
              << std::endl;
#endif
            unsigned second =
              Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

            // ...and assign
            (*map_pt)[first] = second;
          }
        }
      }
      else
      {
        // Create node (not attached to any element)
        if (time_stepper_pt != 0)
        {
          new_master_nod_pt = new MacroElementNodeUpdateNode(
            time_stepper_pt, n_dim, n_position_type, n_value);
        }
        else
        {
          new_master_nod_pt =
            new MacroElementNodeUpdateNode(n_dim, n_position_type, n_value);
        }
      }

      // Add this as an external halo node
      external_mesh_pt->add_external_halo_node_pt(loc_p, new_master_nod_pt);

      // Create a new node update element for this master node if required
      FiniteElement* new_node_update_f_el_pt = 0;
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  Bool: need new external halo element "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 1)
      {
        GeneralisedElement* new_node_update_el_pt = new EXT_ELEMENT;

        // Add external hal element to this mesh
        external_mesh_pt->add_external_halo_element_pt(loc_p,
                                                       new_node_update_el_pt);

        // Cast to finite element
        new_node_update_f_el_pt =
          dynamic_cast<FiniteElement*>(new_node_update_el_pt);

        // Need number of interpolated values if Refineable
        int n_cont_inter_values;
        if (dynamic_cast<RefineableElement*>(new_node_update_f_el_pt) != 0)
        {
          n_cont_inter_values =
            dynamic_cast<RefineableElement*>(new_node_update_f_el_pt)
              ->ncont_interpolated_values();
        }
        else
        {
          n_cont_inter_values = -1;
        }
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Bool: we have a macro element mesh "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        // If we're using macro elements to update,
        if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 1)
        {
          // Set the macro element
          MacroElementNodeUpdateMesh* macro_mesh_pt =
            dynamic_cast<MacroElementNodeUpdateMesh*>(external_mesh_pt);

#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
          oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                     << "  Number of macro element "
                     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                     << std::endl;
#endif
          unsigned macro_el_num =
            Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
          new_node_update_f_el_pt->set_macro_elem_pt(
            macro_mesh_pt->macro_domain_pt()->macro_element_pt(macro_el_num));

          // we need to receive
          // the lower left and upper right coordinates of the macro
          QElementBase* q_el_pt =
            dynamic_cast<QElementBase*>(new_node_update_f_el_pt);
          if (q_el_pt != 0)
          {
            unsigned el_dim = q_el_pt->dim();
            for (unsigned i_dim = 0; i_dim < el_dim; i_dim++)
            {
              q_el_pt->s_macro_ll(i_dim) =
                Flat_packed_doubles[Counter_for_flat_packed_doubles++];
              q_el_pt->s_macro_ur(i_dim) =
                Flat_packed_doubles[Counter_for_flat_packed_doubles++];
            }
          }
          else // Throw an error
          {
            std::ostringstream error_stream;
            error_stream << "You are using a MacroElement node update\n"
                         << "in a case with non-QElements. This has not\n"
                         << "yet been implemented.\n";
            throw OomphLibError(error_stream.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }
        }

        unsigned n_node = new_node_update_f_el_pt->nnode();
        for (unsigned j = 0; j < n_node; j++)
        {
          Node* new_nod_pt = 0;
          add_external_halo_node_to_storage<EXT_ELEMENT>(
            new_nod_pt,
            external_mesh_pt,
            loc_p,
            j,
            new_node_update_f_el_pt,
            n_cont_inter_values,
            problem_pt);
        }
      }
      else // The node update element exists already
      {
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << "  Number of already existing external halo element "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        new_node_update_f_el_pt = dynamic_cast<FiniteElement*>(
          external_mesh_pt->external_halo_element_pt(
            loc_p, Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++]));
      }

      // Remaining required information to create functioning
      // MacroElementNodeUpdateNode...

      // Get the required geom objects for the node update
      // from the mesh
      Vector<GeomObject*> geom_object_vector_pt;
      MacroElementNodeUpdateMesh* macro_mesh_pt =
        dynamic_cast<MacroElementNodeUpdateMesh*>(external_mesh_pt);
      geom_object_vector_pt = macro_mesh_pt->geom_object_vector_pt();

      // Cast to MacroElementNodeUpdateNode
      MacroElementNodeUpdateNode* macro_master_nod_pt =
        dynamic_cast<MacroElementNodeUpdateNode*>(new_master_nod_pt);

      // Set all required information - node update element,
      // local coordinate in this element, and then set node update info
      macro_master_nod_pt->node_update_element_pt() = new_node_update_f_el_pt;

      // Need to get the local node index of the macro_master_nod_pt
      unsigned local_node_index;
      unsigned n_node = new_node_update_f_el_pt->nnode();
      for (unsigned j = 0; j < n_node; j++)
      {
        if (macro_master_nod_pt == new_node_update_f_el_pt->node_pt(j))
        {
          local_node_index = j;
          break;
        }
      }

      Vector<double> s_in_macro_node_update_element;
      new_node_update_f_el_pt->local_coordinate_of_node(
        local_node_index, s_in_macro_node_update_element);

      macro_master_nod_pt->set_node_update_info(new_node_update_f_el_pt,
                                                s_in_macro_node_update_element,
                                                geom_object_vector_pt);
    }
    else if (solid_nod_pt != 0)
    {
      // The master node should also be a SolidNode
      // If this node was on a boundary then it needs to
      // be on the same boundary here
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  Bool master is a boundary (solid) node "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif
      if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 1)
      {
        // Construct a new boundary node
        if (time_stepper_pt != 0)
        {
          new_master_nod_pt = new BoundaryNode<SolidNode>(time_stepper_pt,
                                                          n_lag_dim,
                                                          n_lag_type,
                                                          n_dim,
                                                          n_position_type,
                                                          n_value);
        }
        else
        {
          new_master_nod_pt = new BoundaryNode<SolidNode>(
            n_lag_dim, n_lag_type, n_dim, n_position_type, n_value);
        }


        // How many boundaries does the macro element master node live on?
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << " Number of boundaries the solid master node is on: "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        unsigned nb =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        for (unsigned i = 0; i < nb; i++)
        {
          // Boundary number
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
          oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                     << " Solid master node is on boundary "
                     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                     << std::endl;
#endif
          unsigned i_bnd =
            Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
          external_mesh_pt->add_boundary_node(i_bnd, new_master_nod_pt);
        }

        // Do we have additional values created by face elements?
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << " Number of additional values created by face element "
                   << "for solid master node "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        unsigned n_entry =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        if (n_entry > 0)
        {
          // Create storage, if it doesn't already exist, for the map
          // that will contain the position of the first entry of
          // this face element's additional values,
          BoundaryNodeBase* bnew_master_nod_pt =
            dynamic_cast<BoundaryNodeBase*>(new_master_nod_pt);
#ifdef PARANOID
          if (bnew_master_nod_pt == 0)
          {
            throw OomphLibError("Failed to cast new node to boundary node\n",
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }
#endif
          if (bnew_master_nod_pt
                ->index_of_first_value_assigned_by_face_element_pt() == 0)
          {
            bnew_master_nod_pt
              ->index_of_first_value_assigned_by_face_element_pt() =
              new std::map<unsigned, unsigned>;
          }

          // Get pointer to the map of indices associated with
          // additional values created by face elements
          std::map<unsigned, unsigned>* map_pt =
            bnew_master_nod_pt
              ->index_of_first_value_assigned_by_face_element_pt();

          // Loop over number of entries in map
          for (unsigned i = 0; i < n_entry; i++)
          {
            // Read out pairs...

#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
            oomph_info
              << "Rec:" << Counter_for_flat_packed_unsigneds
              << " Key of map entry for solid master node"
              << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
              << std::endl;
#endif
            unsigned first =
              Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
            oomph_info
              << "Rec:" << Counter_for_flat_packed_unsigneds
              << " Value of map entry for solid master node"
              << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
              << std::endl;
#endif
            unsigned second =
              Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

            // ...and assign
            (*map_pt)[first] = second;
          }
        }
      }
      else
      {
        // Construct an ordinary (non-boundary) node
        if (time_stepper_pt != 0)
        {
          new_master_nod_pt = new SolidNode(time_stepper_pt,
                                            n_lag_dim,
                                            n_lag_type,
                                            n_dim,
                                            n_position_type,
                                            n_value);
        }
        else
        {
          new_master_nod_pt = new SolidNode(
            n_lag_dim, n_lag_type, n_dim, n_position_type, n_value);
        }
      }

      // Add this as an external halo node
      external_mesh_pt->add_external_halo_node_pt(loc_p, new_master_nod_pt);

      // Copy across particular info required for SolidNode
      // NOTE: Are there any problems with additional values for SolidNodes?
      SolidNode* solid_master_nod_pt =
        dynamic_cast<SolidNode*>(new_master_nod_pt);
      unsigned n_solid_val =
        solid_master_nod_pt->variable_position_pt()->nvalue();
      for (unsigned i_val = 0; i_val < n_solid_val; i_val++)
      {
        for (unsigned t = 0; t < n_prev; t++)
        {
          solid_master_nod_pt->variable_position_pt()->set_value(
            t, i_val, Flat_packed_doubles[Counter_for_flat_packed_doubles++]);
        }
      }
    }
    else // Just an ordinary node!
    {
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
      oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                 << "  Bool node is on boundary "
                 << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                 << std::endl;
#endif

      // If this node was on a boundary then it needs to
      // be on the same boundary here
      if (Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++] == 1)
      {
        // Construct a new boundary node
        if (time_stepper_pt != 0)
        {
          new_master_nod_pt = new BoundaryNode<Node>(
            time_stepper_pt, n_dim, n_position_type, n_value);
        }
        else
        {
          new_master_nod_pt =
            new BoundaryNode<Node>(n_dim, n_position_type, n_value);
        }

        // How many boundaries does the master node live on?
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << " Number of boundaries the master node is on: "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        unsigned nb =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        for (unsigned i = 0; i < nb; i++)
        {
          // Boundary number
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
          oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                     << "  Master node is on boundary "
                     << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                     << std::endl;
#endif
          unsigned i_bnd =
            Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
          external_mesh_pt->add_boundary_node(i_bnd, new_master_nod_pt);
        }


        // Do we have additional values created by face elements?
#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
        oomph_info << "Rec:" << Counter_for_flat_packed_unsigneds
                   << " Number of additional values created by face element "
                   << "for master node "
                   << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
                   << std::endl;
#endif
        unsigned n_entry =
          Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];
        if (n_entry > 0)
        {
          // Create storage, if it doesn't already exist, for the map
          // that will contain the position of the first entry of
          // this face element's additional values,
          BoundaryNodeBase* bnew_master_nod_pt =
            dynamic_cast<BoundaryNodeBase*>(new_master_nod_pt);
#ifdef PARANOID
          if (bnew_master_nod_pt == 0)
          {
            throw OomphLibError("Failed to cast new node to boundary node\n",
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
          }
#endif
          if (bnew_master_nod_pt
                ->index_of_first_value_assigned_by_face_element_pt() == 0)
          {
            bnew_master_nod_pt
              ->index_of_first_value_assigned_by_face_element_pt() =
              new std::map<unsigned, unsigned>;
          }

          // Get pointer to the map of indices associated with
          // additional values created by face elements
          std::map<unsigned, unsigned>* map_pt =
            bnew_master_nod_pt
              ->index_of_first_value_assigned_by_face_element_pt();

          // Loop over number of entries in map
          for (unsigned i = 0; i < n_entry; i++)
          {
            // Read out pairs...

#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
            oomph_info
              << "Rec:" << Counter_for_flat_packed_unsigneds
              << " Key of map entry for master node"
              << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
              << std::endl;
#endif
            unsigned first =
              Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

#ifdef ANNOTATE_MULTI_DOMAIN_COMMUNICATION
            oomph_info
              << "Rec:" << Counter_for_flat_packed_unsigneds
              << " Value of map entry for master node"
              << Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds]
              << std::endl;
#endif
            unsigned second =
              Flat_packed_unsigneds[Counter_for_flat_packed_unsigneds++];

            // ...and assign
            (*map_pt)[first] = second;
          }
        }
      }
      else
      {
        // Construct an ordinary (non-boundary) node
        if (time_stepper_pt != 0)
        {
          new_master_nod_pt =
            new Node(time_stepper_pt, n_dim, n_position_type, n_value);
        }
        else
        {
          new_master_nod_pt = new Node(n_dim, n_position_type, n_value);
        }
      }

      // Add this as an external halo node
      external_mesh_pt->add_external_halo_node_pt(loc_p, new_master_nod_pt);
    }

    // Remaining info received for all node types
    // Get copied history values
    //  unsigned n_val=new_master_nod_pt->nvalue();
    for (unsigned i_val = 0; i_val < n_value; i_val++)
    {
      for (unsigned t = 0; t < n_prev; t++)
      {
        new_master_nod_pt->set_value(
          t, i_val, Flat_packed_doubles[Counter_for_flat_packed_doubles++]);
      }
    }

    // Get copied history values for positions
    unsigned n_nod_dim = new_master_nod_pt->ndim();
    for (unsigned idim = 0; idim < n_nod_dim; idim++)
    {
      for (unsigned t = 0; t < n_prev; t++)
      {
        // Copy to coordinate
        new_master_nod_pt->x(t, idim) =
          Flat_packed_doubles[Counter_for_flat_packed_doubles++];
      }
    }
  }


#endif


} // namespace oomph

#endif
