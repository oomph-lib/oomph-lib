// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC// Copyright (C) 2006-2025 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
// Non-inline and non-templated functions for QuadTree and QuadTreeForest
// classes

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

#include <set>

// oomph-lib headers
#include "quadtree.h"
#include "refineable_quad_element.h"


namespace oomph
{
  //========================================================================
  /// Bool indicating that static member data has been setup
  //========================================================================
  bool QuadTree::Static_data_has_been_setup = false;

  //========================================================================
  /// Colours for neighbours in various directions (static data)
  //========================================================================
  Vector<std::string> QuadTree::Colour;

  //=======================================================================
  ///  S_base(i,direction):  Initial value for coordinate s[i] on
  /// the edge indicated by direction (S/E/N/W) (static data)
  //======================================================================
  DenseMatrix<double> QuadTree::S_base;

  //======================================================================
  /// S_step(i,direction) Increments for coordinate s[i] when
  /// progressing along the edge indicated by direction (S/E/N/W);
  /// Left/lower vertex: S_base; Right/upper vertex: S_base + S_step
  /// (static data)
  //=====================================================================
  DenseMatrix<double> QuadTree::S_step;

  //=====================================================================
  /// Translate (enumerated) directions into strings (static data)
  //=====================================================================
  Vector<std::string> QuadTree::Direct_string;

  //====================================================================
  /// Get opposite edge, e.g. Reflect_edge[N]=S (static data)
  //====================================================================
  Vector<int> QuadTree::Reflect_edge;

  //===================================================================
  /// Array of direction/quadrant adjacency scheme:
  /// Is_adjacent(i_vertex_or_edge,j_quadrant): Is edge/vertex
  /// adjacent to quadrant? (static data)
  //===================================================================
  DenseMatrix<bool> QuadTree::Is_adjacent;

  //====================================================================
  /// Reflection scheme: Reflect(direction,quadrant): Get mirror
  /// of quadrant in specified direction. E.g. Reflect(S,NE)=SE
  /// (static data)
  //====================================================================
  DenseMatrix<int> QuadTree::Reflect;

  //=====================================================================
  /// Rotate coordinates: If north becomes NorthIs then direction
  /// becomes Rotate(NorthIs,direction). E.g.  Rotate(E,NW)=NE;
  /// (static data)
  //=====================================================================
  DenseMatrix<int> QuadTree::Rotate;

  //=====================================================================
  /// Angle betwen rotated coordinates: If old_direction becomes
  /// new_direction then the angle between the axes (in anti-clockwise
  /// direction is Rotate_angle(old_direction,new_direction); E.g.
  /// Rotate_angle(E,N)=90; (static data)
  //=====================================================================
  DenseMatrix<int> QuadTree::Rotate_angle;

  //==========================================================================
  /// S_direct(direction,son_quadrant): The lower left corner
  /// of son_quadrant has an offset of h/2 S_direct(direction,son_quadrant)
  /// in the specified direction. E.g. S_direct(S,NE)=1 and  S_direct(S,NW)=0
  /// (static data)
  //==========================================================================
  DenseMatrix<int> QuadTree::S_direct;


  //====================================================================
  /// Setup the static data stored in the QuadTree -- this needs to be
  /// called before QuadTrees can be used. Automatically called
  /// by RefineableQuadMesh constructor.
  //====================================================================
  void QuadTree::setup_static_data()
  {
    using namespace QuadTreeNames;


#ifdef PARANOID
    if (Tree::OMEGA != QuadTree::OMEGA)
    {
      std::ostringstream error_stream;
      error_stream << "Inconsistent enumeration!  \n    Tree::OMEGA="
                   << Tree::OMEGA << "\nQuadTree::OMEGA=" << QuadTree::OMEGA
                   << std::endl;
      throw OomphLibError(
        error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif


    // Set flag to indicate that static data has been setup
    Static_data_has_been_setup = true;

    // Tecplot Colours for neighbours in various directions
    Colour.resize(27);
    Colour[SW] = "YELLOW";
    Colour[SE] = "YELLOW";
    Colour[NW] = "YELLOW";
    Colour[NE] = "YELLOW";
    Colour[E] = "CYAN";
    Colour[W] = "RED";
    Colour[N] = "GREEN";
    Colour[S] = "BLUE";
    Colour[OMEGA] = "YELLOW";

    // S_base(i,direction):  Initial value for coordinate s[i] on the
    // edge indicated by direction (S/E/N/W)
    //
    // S_step(i,direction) Increments for coordinate s[i] when progressing
    // along the edge indicated by direction (S/E/N/W)
    S_base.resize(2, 27);
    S_step.resize(2, 27);

    S_base(0, N) = -1.0;
    S_base(1, N) = 1.0;
    S_step(0, N) = 2.0;
    S_step(1, N) = 0.0;

    S_base(0, S) = -1.0;
    S_base(1, S) = -1.0;
    S_step(0, S) = 2.0;
    S_step(1, S) = 0.0;

    S_base(0, W) = -1.0;
    S_base(1, W) = -1.0;
    S_step(0, W) = 0.0;
    S_step(1, W) = 2.0;

    S_base(0, E) = 1.0;
    S_base(1, E) = -1.0;
    S_step(0, E) = 0.0;
    S_step(1, E) = 2.0;

    // Translate (enumerated) directions into strings
    Direct_string.resize(27);

    Direct_string[SW] = "SW";
    Direct_string[NW] = "NW";
    Direct_string[SE] = "SE";
    Direct_string[NE] = "NE";

    Direct_string[S] = "S";
    Direct_string[N] = "N";
    Direct_string[E] = "E";
    Direct_string[W] = "W";
    Direct_string[OMEGA] = "OMEGA";

    // Build direction/quadrant adjacency scheme
    // Is_adjacent(i_vertex_or_edge,j_quadrant):
    // Is edge/vertex adjacent to quadrant?
    Is_adjacent.resize(27, 27);

    Is_adjacent(N, NW) = true;
    Is_adjacent(E, NW) = false;
    Is_adjacent(S, NW) = false;
    Is_adjacent(W, NW) = true;
    Is_adjacent(NW, NW) = true;
    Is_adjacent(NE, NW) = false;
    Is_adjacent(SW, NW) = false;
    Is_adjacent(SE, NW) = false;

    Is_adjacent(N, NE) = true;
    Is_adjacent(E, NE) = true;
    Is_adjacent(S, NE) = false;
    Is_adjacent(W, NE) = false;
    Is_adjacent(NW, NE) = false;
    Is_adjacent(NE, NE) = true;
    Is_adjacent(SW, NE) = false;
    Is_adjacent(SE, NE) = false;

    Is_adjacent(N, SW) = false;
    Is_adjacent(E, SW) = false;
    Is_adjacent(S, SW) = true;
    Is_adjacent(W, SW) = true;
    Is_adjacent(NW, SW) = false;
    Is_adjacent(NE, SW) = false;
    Is_adjacent(SW, SW) = true;
    Is_adjacent(SE, SW) = false;


    Is_adjacent(N, SE) = false;
    Is_adjacent(E, SE) = true;
    Is_adjacent(S, SE) = true;
    Is_adjacent(W, SE) = false;
    Is_adjacent(NW, SE) = false;
    Is_adjacent(NE, SE) = false;
    Is_adjacent(SW, SE) = false;
    Is_adjacent(SE, SE) = true;

    // Rotation scheme: If north becomes NorthIs then
    // direction becomes Rotate(NorthIs,direction)
    // Initialise to OMEGA
    Rotate.resize(27, 27);

    Rotate(N, N) = N;
    Rotate(N, E) = E;
    Rotate(N, S) = S;
    Rotate(N, W) = W;
    Rotate(N, NW) = NW;
    Rotate(N, NE) = NE;
    Rotate(N, SE) = SE;
    Rotate(N, SW) = SW;

    Rotate(W, N) = W;
    Rotate(W, E) = N;
    Rotate(W, S) = E;
    Rotate(W, W) = S;
    Rotate(W, NW) = SW;
    Rotate(W, NE) = NW;
    Rotate(W, SE) = NE;
    Rotate(W, SW) = SE;

    Rotate(S, N) = S;
    Rotate(S, E) = W;
    Rotate(S, S) = N;
    Rotate(S, W) = E;
    Rotate(S, NW) = SE;
    Rotate(S, NE) = SW;
    Rotate(S, SE) = NW;
    Rotate(S, SW) = NE;

    Rotate(E, N) = E;
    Rotate(E, E) = S;
    Rotate(E, S) = W;
    Rotate(E, W) = N;
    Rotate(E, NW) = NE;
    Rotate(E, NE) = SE;
    Rotate(E, SE) = SW;
    Rotate(E, SW) = NW;

    // Angle betwen rotated coordinates:
    // old_direction becomes new_direction then the angle between
    // the axes is Rotate_angle(old_direction,new_direction)
    Rotate_angle.resize(27, 27);

    Rotate_angle(N, N) = 0;
    Rotate_angle(N, W) = 90;
    Rotate_angle(N, S) = 180;
    Rotate_angle(N, E) = 270;

    Rotate_angle(S, S) = 0;
    Rotate_angle(S, E) = 90;
    Rotate_angle(S, N) = 180;
    Rotate_angle(S, W) = 270;

    Rotate_angle(W, W) = 0;
    Rotate_angle(W, S) = 90;
    Rotate_angle(W, E) = 180;
    Rotate_angle(W, N) = 270;

    Rotate_angle(E, E) = 0;
    Rotate_angle(E, N) = 90;
    Rotate_angle(E, W) = 180;
    Rotate_angle(E, S) = 270;

    // Reflection scheme:
    // Reflect(direction,quadrant): Get mirror of quadrant in direction
    Reflect.resize(27, 27);

    Reflect(N, NW) = SW;
    Reflect(E, NW) = NE;
    Reflect(S, NW) = SW;
    Reflect(W, NW) = NE;
    Reflect(NW, NW) = SE;
    Reflect(NE, NW) = SE;
    Reflect(SW, NW) = SE;
    Reflect(SE, NW) = SE;

    Reflect(N, NE) = SE;
    Reflect(E, NE) = NW;
    Reflect(S, NE) = SE;
    Reflect(W, NE) = NW;
    Reflect(NW, NE) = SW;
    Reflect(NE, NE) = SW;
    Reflect(SW, NE) = SW;
    Reflect(SE, NE) = SW;

    Reflect(N, SW) = NW;
    Reflect(E, SW) = SE;
    Reflect(S, SW) = NW;
    Reflect(W, SW) = SE;
    Reflect(NW, SW) = NE;
    Reflect(NE, SW) = NE;
    Reflect(SW, SW) = NE;
    Reflect(SE, SW) = NE;

    Reflect(N, SE) = NE;
    Reflect(E, SE) = SW;
    Reflect(S, SE) = NE;
    Reflect(W, SE) = SW;
    Reflect(NW, SE) = NW;
    Reflect(NE, SE) = NW;
    Reflect(SW, SE) = NW;
    Reflect(SE, SE) = NW;

    // S_direct(direction,son_quadrant): The lower left corner of
    // my son_quadrant has an offset of h/2 S_direct(direction,son_quadrant)
    // in the direction. [Look in the positive direction along the
    // edge 'direction' and measure the offset of the lower left corner
    // of the son quadrant in this direction]
    S_direct.resize(27, 27);

    S_direct(W, NW) = 1;
    S_direct(E, NW) = 1;
    S_direct(N, NW) = 0;
    S_direct(S, NW) = 0;

    S_direct(W, NE) = 1;
    S_direct(E, NE) = 1;
    S_direct(N, NE) = 1;
    S_direct(S, NE) = 1;

    S_direct(W, SW) = 0;
    S_direct(E, SW) = 0;
    S_direct(N, SW) = 0;
    S_direct(S, SW) = 0;

    S_direct(W, SE) = 0;
    S_direct(E, SE) = 0;
    S_direct(N, SE) = 1;
    S_direct(S, SE) = 1;

    // Get opposite edge, e.g. Reflect_edge(N)=S
    Reflect_edge.resize(27);

    Reflect_edge[N] = S;
    Reflect_edge[S] = N;
    Reflect_edge[E] = W;
    Reflect_edge[W] = E;
  }

  //================================================================
  /// Return pointer to greater or equal-sized edge neighbour
  /// in specified \c direction; also provide info regarding the relative
  /// size and orientation of neighbour:
  /// - The vector translate_s turns the index of the local coordinate
  ///   in the present quadtree into that of the neighbour. If there are no
  ///   rotations then translate_s[i] = i, but if, for example, the neighbour's
  ///   eastern face is adjacent to our northern face translate_s[0] = 1
  ///   and translate_s[1] = 0. Of course, this could be deduced after the
  ///   fact, but it's easier to do it here.
  /// - Let's have a look at the current quadtree's edge in the specified
  ///   direction. The edge will be parallel to one of the two
  ///   local coordinates in the element. This edge has two
  ///   vertices. The vertex at the minimum value of the local
  ///   coordinate (the "lo" vertex) is located
  ///   at the local coordinates (\c s_lo[0], \c s_lo[1]) in the neighbouring
  ///   quadtree.
  /// - ditto with s_hi: The vertex at the maximum value of the local
  ///   coordinate located at the local coordinates (\c s_hi[0],
  ///   \c s_hi[1]) in the neighbouring quadtree.
  /// - We're looking for a neighbour in the specified \c direction. When
  ///   viewed from the neighbouring quadtree, the edge that separates
  ///   the present quadtree from its neighbour is the neighbour's \c edge
  ///   edge. If there's no rotation between the two quadtrees, this is a
  ///   simple reflection: For instance, if we're looking
  ///   for a neighhbour in the \c N [orthern] \c direction, \c edge will
  ///   be \c S [outh]
  /// - \c diff_level <= 0 indicates the difference in refinement levels between
  ///   the two neighbours. If \c diff_level==0, the neighbour has the
  ///   same size as the current quadtree.
  /// - \c in_neighbouring_tree returns true is we have had to flip
  ///      to a different root, even if that root is actually the same
  ///      as it can be in periodic problems.
  //=================================================================
  QuadTree* QuadTree::gteq_edge_neighbour(const int& direction,
                                          Vector<unsigned>& translate_s,
                                          Vector<double>& s_lo,
                                          Vector<double>& s_hi,
                                          int& edge,
                                          int& diff_level,
                                          bool& in_neighbouring_tree) const
  {
    using namespace QuadTreeNames;

#ifdef PARANOID
    if ((direction != S) && (direction != E) && (direction != N) &&
        (direction != W))
    {
      std::ostringstream error_stream;
      error_stream << "Direction " << direction << " is not N, S, E, W"
                   << std::endl;

      throw OomphLibError(
        error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Initialise in_neighbouring tree to false. It will be set to true
    // during the recursion if we do actually hop over in to the neighbour
    in_neighbouring_tree = false;

    // Maximum level to which we're allowed to descend (we only want
    // greater-or-equal-sized neighbours)
    int max_level = Level;

    // Current element has the following root:
    QuadTreeRoot* orig_root_pt = dynamic_cast<QuadTreeRoot*>(Root_pt);

    // Initialise offset in local coordinate
    double s_diff = 0;

    // Initialise difference in level
    diff_level = 0;

    // Find neighbour
    QuadTree* return_pt = gteq_edge_neighbour(direction,
                                              s_diff,
                                              diff_level,
                                              in_neighbouring_tree,
                                              max_level,
                                              orig_root_pt);

    QuadTree* neighb_pt = return_pt;

    // If neighbour exists: What's the direction of the interfacial
    // edge when viewed from within the neighbour element?
    if (neighb_pt != 0)
    {
      // Rotate things around (the orientation of N in the neighbour might be
      // be different from that in the present element)
      // Initialise the direction
      int new_dir = direction;
      // If the neighbour has a different root, then there could be a possible
      // rotation, find it
      if (neighb_pt->root_pt() != Root_pt)
      {
        new_dir = Rotate(orig_root_pt->north_equivalent(direction), direction);
      }

      s_lo[0] = S_base(0, Reflect_edge[new_dir]) +
                S_step(0, Reflect_edge[new_dir]) * s_diff;
      s_lo[1] = S_base(1, Reflect_edge[new_dir]) +
                S_step(1, Reflect_edge[new_dir]) * s_diff;

      s_hi[0] = S_base(0, Reflect_edge[new_dir]) +
                S_step(0, Reflect_edge[new_dir]) * pow(2.0, diff_level) +
                S_step(0, Reflect_edge[new_dir]) * s_diff;
      s_hi[1] = S_base(1, Reflect_edge[new_dir]) +
                S_step(1, Reflect_edge[new_dir]) * pow(2.0, diff_level) +
                S_step(1, Reflect_edge[new_dir]) * s_diff;

      Vector<double> s_lo_new(2), s_hi_new(2);

      // What's the direction of the interfacial edge when viewed from within
      // the neighbour element?
      edge = Reflect_edge[new_dir];

      // Set up the translation scheme for the local coordinates
      {
        bool swap = false;
        // Do we need to switch the coordinate
        switch (direction)
        {
            // If the direction is north or south,
            // but the neighbour's coordinate s[1] is not constant, we must swap
          case N:
          case S:
            if (s_lo[1] != s_hi[1])
            {
              swap = true;
            }
            break;
            // If the direction is east or west
            // but the neighbour's corodinate s[0] is not constant, we must swap
          case E:
          case W:
            if (s_lo[0] != s_hi[0])
            {
              swap = true;
            }
            break;
          // Catch all totally un-necessary
          default:
            std::ostringstream error_stream;
            error_stream << "Direction " << direction << " is not N, S, E, W"
                         << std::endl;

            throw OomphLibError(error_stream.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
        }

        // If we must swap, then do so
        if (swap)
        {
          translate_s[0] = 1;
          translate_s[1] = 0;
        }
        // Othewise, it's just a straight translation
        else
        {
          translate_s[0] = 0;
          translate_s[1] = 1;
        }
      }

      // Reverse directions?
      s_lo_new[0] = s_lo[0];
      s_lo_new[1] = s_lo[1];
      s_hi_new[0] = s_hi[0];
      s_hi_new[1] = s_hi[1];

      if (((edge == N) || (edge == S)) &&
          ((Rotate_angle(direction, new_dir) == 90) ||
           (Rotate_angle(direction, new_dir) == 180)))
      {
        s_lo_new[0] = -s_lo[0];
        s_hi_new[0] = -s_hi[0];
      }
      if (((edge == E) || (edge == W)) &&
          ((Rotate_angle(direction, new_dir) == 270) ||
           (Rotate_angle(direction, new_dir) == 180)))
      {
        s_lo_new[1] = -s_lo[1];
        s_hi_new[1] = -s_hi[1];
      }

      s_lo[0] = s_lo_new[0];
      s_lo[1] = s_lo_new[1];
      s_hi[0] = s_hi_new[0];
      s_hi[1] = s_hi_new[1];
    }
    return return_pt;
  }

  //================================================================
  /// Find `greater-or-equal-sized edge neighbour' in given direction
  /// (N/E/S/W).
  ///
  /// This is an auxiliary routine which allows neighbour finding in adjacent
  /// quadtrees. Needs to keep track of previous son types and
  /// the maximum level to which search is performed.
  ///
  /// Parameters:
  ///
  /// - direction: N/S/E/W: Direction in which neighbour has to be found.
  /// - s_diff: Offset of lower/left vertex from corresponding vertex in
  ///   neighbour. Note that this is input/output as it needs to be incremented/
  ///   decremented during the recursive calls to this function.
  /// - edge: We're looking for the neighbour across our edge 'direction'
  ///   (N/S/E/W). When viewed from the neighbour, this edge is
  ///   `edge' (N/S/E/W). [If there's no relative rotation between neighbours
  ///    then this is a mere reflection, e.g. direction=N  --> edge=S etc.]
  /// - diff_level <= 0 indicates the difference in quadtree levels
  ///   between the current element and its neighbour.
  /// - max_level is the maximum level to which the neighbour search is
  ///   allowed to proceed. This is again necessary because in a forest,
  ///   the neighbour search isn't based on pure recursion.
  /// - orig_root_pt identifies the root node of the element whose
  ///   neighbour we're really trying to find by all these recursive calls.
  ///
  //=================================================================
  QuadTree* QuadTree::gteq_edge_neighbour(
    const int& direction,
    double& s_diff,
    int& diff_level,
    bool& in_neighbouring_tree,
    int max_level,
    QuadTreeRoot* const& orig_root_pt) const
  {
    using namespace QuadTreeNames;

#ifdef PARANOID
    if ((direction != S) && (direction != E) && (direction != N) &&
        (direction != W))
    {
      std::ostringstream error_stream;
      error_stream << "Direction " << direction << " is not N, S, E, W"
                   << std::endl;

      throw OomphLibError(
        error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
#endif

    QuadTree* next_el_pt;
    QuadTree* return_el_pt;

    // STEP 1: Find the neighbour's father
    //--------

    // Does the element have a father?
    if (Father_pt != 0)
    {
      // If the present quadrant (whose location inside its
      // father element is specified by Son_type) is adjacent to the
      // father's edge in the required direction, then its neighbour has
      // a different father ---> we need to climb up the tree to
      // the father and find his neighbour in the required direction

      // Note that this is the cunning recursive part. The returning may not
      // stop until we hit the very top of the tree, when the element does NOT
      // have a father
      if (Is_adjacent(direction, Son_type))
      {
        next_el_pt = dynamic_cast<QuadTree*>(Father_pt)->gteq_edge_neighbour(
          direction,
          s_diff,
          diff_level,
          in_neighbouring_tree,
          max_level,
          orig_root_pt);
      }
      // If the present quadrant is not adjacent to the
      // father's edge in the required direction, then the
      // neighbour has the same father and is obtained
      // by the appropriate reflection inside the father element
      // This will only be called if we have not left the original tree.
      else
      {
        next_el_pt = dynamic_cast<QuadTree*>(Father_pt);
      }

      // We're about to ascend one level:
      diff_level -= 1;

      // Work out position of lower (or left) corner of present edge
      // in its father element
      s_diff += pow(0.5, -diff_level) * S_direct(direction, Son_type);

      // STEP 2:  We have now located the neighbour's father and need to
      // -------  find the appropriate son.

      // Buffer cases where the neighbour (and hence its father) lie outside
      // the boundary
      if (next_el_pt != 0)
      {
        // If the father is a leaf then we can't descend to the same
        // level as the present node ---> simply return the father himself
        // as the (greater) neighbour. Same applies if we are about
        // to descend lower than the max_level (in a  neighbouring tree)
        if ((next_el_pt->Son_pt.size() == 0) ||
            (next_el_pt->Level > max_level - 1))
        {
          return_el_pt = next_el_pt;
        }
        // We have located the neighbour's father: The position of the
        // neighbour is obtained by `reflecting' the position of the
        // node itself.

        // We know exactly how to reflect, because we know which son type we
        // are and we have the pointer to the neighbours father
        else
        {
          int son_quadrant = Reflect(direction, Son_type);

          // If the root of the neighbour's father is not our root, we
          // might need to rotate
          if (orig_root_pt != next_el_pt->Root_pt)
          {
            // Get the north equivalent of the next element
            int my_north =
              dynamic_cast<QuadTreeRoot*>(Root_pt)->north_equivalent(direction);
            son_quadrant = Rotate(my_north, son_quadrant);
          }

          // The next element in the tree is the appropriate son of the
          // neighbour's father
          return_el_pt =
            dynamic_cast<QuadTree*>(next_el_pt->Son_pt[son_quadrant]);

          // Work out position of lower (or left) corner of present edge
          // in next higher element
          s_diff -= pow(0.5, -diff_level) * S_direct(direction, Son_type);

          // We have just descended one level
          diff_level += 1;
        }
      }
      // The neighbour's father lies outside the boundary --> the neighbour
      // itself does too --> return NULL.
      else
      {
        return_el_pt = 0;
      }
    }
    // Element does not have a father --> check if it has a neighbouring
    // tree in the appropriate direction
    else
    {
      // Find  neighbouring root
      if (Root_pt->neighbour_pt(direction) != 0)
      {
        // In this case we have moved to a neighbour, so set the flag
        in_neighbouring_tree = true;
        return_el_pt =
          dynamic_cast<QuadTreeRoot*>(Root_pt->neighbour_pt(direction));
      }
      // No neighbouring tree, so there really is no neighbour --> return NULL
      else
      {
        return_el_pt = 0;
      }
    }

    return return_el_pt;
  }

  //================================================================
  /// Traverse Tree: Preorder traverse and stick pointers to
  /// neighbouring leaf nodes (only) into Vector
  //=================================================================
  void QuadTree::stick_neighbouring_leaves_into_vector(
    Vector<const QuadTree*>& tree_neighbouring_nodes,
    Vector<Vector<double>>& tree_neighbouring_s_lo,
    Vector<Vector<double>>& tree_neighbouring_s_hi,
    Vector<int>& tree_neighbouring_diff_level,
    const QuadTree* my_neigh_pt,
    const int& direction) const
  {
    // If the tree has sons
    unsigned numsons = Son_pt.size();
    if (numsons > 0)
    {
      // Now do the sons (if they exist)
      for (unsigned i = 0; i < numsons; i++)
      {
        dynamic_cast<QuadTree*>(Son_pt[i])
          ->stick_neighbouring_leaves_into_vector(tree_neighbouring_nodes,
                                                  tree_neighbouring_s_lo,
                                                  tree_neighbouring_s_hi,
                                                  tree_neighbouring_diff_level,
                                                  my_neigh_pt,
                                                  direction);
      }
    }
    else
    {
      // Required data for neighbour-finding routine
      Vector<unsigned> translate_s(2);
      Vector<double> s_lo(2), s_hi(2);
      int edge, diff_level;
      bool in_neighbouring_tree;
      QuadTree* neigh_pt;

      // Get neighbouring tree
      neigh_pt = gteq_edge_neighbour(direction,
                                     translate_s,
                                     s_lo,
                                     s_hi,
                                     edge,
                                     diff_level,
                                     in_neighbouring_tree);

      // Check if the neighbour is the same as the tree passed in
      // (i.e. Am I a neighbour of the master element's tree?)
      if (neigh_pt == my_neigh_pt)
      {
        // Add the element and the diff_level to passed vectors
        tree_neighbouring_nodes.push_back(this);
        tree_neighbouring_s_lo.push_back(s_lo);
        tree_neighbouring_s_hi.push_back(s_hi);
        tree_neighbouring_diff_level.push_back(diff_level);
      }
    }
  }

  //================================================================
  /// Self-test: Check neighbour finding routine. For each element
  /// in the tree and for each vertex, determine the
  /// distance between the vertex and its position in the
  /// neigbour. If the difference is less than
  /// Tree::Max_neighbour_finding_tolerance.
  /// return success (0), otherwise failure (1)
  //=================================================================
  unsigned QuadTree::self_test()
  {
    // Stick pointers to all nodes into Vector and number elements
    // in the process
    Vector<Tree*> all_nodes_pt;
    stick_all_tree_nodes_into_vector(all_nodes_pt);
    long int count = 0;
    unsigned long num_nodes = all_nodes_pt.size();
    for (unsigned long i = 0; i < num_nodes; i++)
    {
      all_nodes_pt[i]->object_pt()->set_number(++count);
    }

    // Check neighbours (distance between hanging nodes) -- don't print (keep
    // output streams closed)
    double max_error = 0.0;
    std::ofstream neighbours_file;
    std::ofstream neighbours_txt_file;
    QuadTree::doc_neighbours(
      all_nodes_pt, neighbours_file, neighbours_txt_file, max_error);

    if (max_error > Max_neighbour_finding_tolerance)
    {
      oomph_info << "\n \n Failed self_test() for QuadTree: Max. error "
                 << max_error << std::endl
                 << std::endl;
      return 1;
    }
    else
    {
      oomph_info << "\n \n Passed self_test() for QuadTree: Max. error "
                 << max_error << std::endl
                 << std::endl;
      return 0;
    }
  }


  //================================================================
  /// Constructor for QuadTreeForest:
  ///
  /// Pass:
  ///  - trees_pt[], the Vector of pointers to the constituent trees
  ///    (QuadTreeRoot objects)
  ///
  /// Note that the pointers to the neighbour's of each tree must have
  /// been allocated before the constructor is called, otherwise the
  /// relative rotation scheme will not be constructed correctly.
  //=================================================================
  QuadTreeForest::QuadTreeForest(Vector<TreeRoot*>& trees_pt)
    : TreeForest(trees_pt)
  {
#ifdef LEAK_CHECK
    LeakCheckNames::QuadTreeForest_build += 1;
#endif

    // Don't setup neighbours etc. if forest is empty
    if (trees_pt.size() == 0)
    {
      return;
    }

    using namespace QuadTreeNames;

    // Setup the neighbours
    find_neighbours();

    // Construct the rotation scheme, note that all neighbour pointers must
    // be set before the constructor is called
    construct_north_equivalents();
  }


  //================================================================
  /// Setup the neighbour lookup schemes for all constituent
  /// quadtrees.
  //================================================================
  void QuadTreeForest::find_neighbours()
  {
    using namespace QuadTreeNames;

    unsigned numtrees = ntree();
    unsigned n = 0; // to store nnode1d
    if (numtrees > 0)
    {
      n = Trees_pt[0]->object_pt()->nnode_1d();
    }
    else
    {
      throw OomphLibError(
        "Trying to setup the neighbour scheme for an empty forest\n",
        OOMPH_CURRENT_FUNCTION,
        OOMPH_EXCEPTION_LOCATION);
    }

    // Number of vertex nodes: 4
    unsigned n_vertex_node = 4;

    // Find potentially connected trees by identifying
    // those whose associated elements share a common vertex node
    std::map<Node*, std::set<unsigned>> tree_assoc_with_vertex_node;

    // Loop over all trees
    for (unsigned i = 0; i < numtrees; i++)
    {
      // Loop over the vertex nodes of the associated element
      for (unsigned j = 0; j < n_vertex_node; j++)
      {
        Node* nod_pt = dynamic_cast<QuadElementBase*>(Trees_pt[i]->object_pt())
                         ->vertex_node_pt(j);
        tree_assoc_with_vertex_node[nod_pt].insert(i);
      }
    }


    // For each tree we store a set of potentially neighbouring trees
    // i.e. trees that share at least one node
    Vector<std::set<unsigned>> potentially_neighb_tree(numtrees);

    // Loop over vertex nodes
    for (std::map<Node*, std::set<unsigned>>::iterator it =
           tree_assoc_with_vertex_node.begin();
         it != tree_assoc_with_vertex_node.end();
         it++)
    {
      // Loop over connected elements twice
      for (std::set<unsigned>::iterator it_el1 = it->second.begin();
           it_el1 != it->second.end();
           it_el1++)
      {
        unsigned i = (*it_el1);
        for (std::set<unsigned>::iterator it_el2 = it->second.begin();
             it_el2 != it->second.end();
             it_el2++)
        {
          unsigned j = (*it_el2);
          // These two elements are potentially connected
          if (i != j)
          {
            potentially_neighb_tree[i].insert(j);
          }
        }
      }
    }


    // Loop over all trees
    for (unsigned i = 0; i < numtrees; i++)
    {
      // Loop over their potential neighbours
      for (std::set<unsigned>::iterator it = potentially_neighb_tree[i].begin();
           it != potentially_neighb_tree[i].end();
           it++)
      {
        unsigned j = (*it);

        // is it the Northern neighbour ?
        bool is_N_neighbour =
          ((Trees_pt[j]->object_pt()->get_node_number(
              Trees_pt[i]->object_pt()->node_pt(n * (n - 1))) != -1) &&
           (Trees_pt[j]->object_pt()->get_node_number(
              Trees_pt[i]->object_pt()->node_pt(n * n - 1)) != -1));


        // is it the Southern neighbour ?
        bool is_S_neighbour =
          ((Trees_pt[j]->object_pt()->get_node_number(
              Trees_pt[i]->object_pt()->node_pt(0)) != -1) &&
           (Trees_pt[j]->object_pt()->get_node_number(
              Trees_pt[i]->object_pt()->node_pt(n - 1)) != -1));


        // is it the Eastern neighbour ?
        bool is_E_neighbour =
          ((Trees_pt[j]->object_pt()->get_node_number(
              Trees_pt[i]->object_pt()->node_pt(n - 1)) != -1) &&
           (Trees_pt[j]->object_pt()->get_node_number(
              Trees_pt[i]->object_pt()->node_pt(n * n - 1)) != -1));

        // is it the Western neighbour ?
        bool is_W_neighbour =
          ((Trees_pt[j]->object_pt()->get_node_number(
              Trees_pt[i]->object_pt()->node_pt(0)) != -1) &&
           (Trees_pt[j]->object_pt()->get_node_number(
              Trees_pt[i]->object_pt()->node_pt(n * (n - 1))) != -1));


        if (is_N_neighbour) Trees_pt[i]->neighbour_pt(N) = Trees_pt[j];
        if (is_S_neighbour) Trees_pt[i]->neighbour_pt(S) = Trees_pt[j];
        if (is_E_neighbour) Trees_pt[i]->neighbour_pt(E) = Trees_pt[j];
        if (is_W_neighbour) Trees_pt[i]->neighbour_pt(W) = Trees_pt[j];
      }
    }


    // Old hacky version with horrendous scaling
    if (false)
    {
      // Loop over all trees
      for (unsigned i = 0; i < numtrees; i++)
      {
        // Loop over all the other elements
        for (unsigned j = 0; j < numtrees; j++)
        {
          if (j != i) // make sure we are not looking at the element itself
          {
            // is it the Northern neighbour ?
            bool is_N_neighbour =
              ((Trees_pt[j]->object_pt()->get_node_number(
                  Trees_pt[i]->object_pt()->node_pt(n * (n - 1))) != -1) &&
               (Trees_pt[j]->object_pt()->get_node_number(
                  Trees_pt[i]->object_pt()->node_pt(n * n - 1)) != -1));


            // is it the Southern neighbour ?
            bool is_S_neighbour =
              ((Trees_pt[j]->object_pt()->get_node_number(
                  Trees_pt[i]->object_pt()->node_pt(0)) != -1) &&
               (Trees_pt[j]->object_pt()->get_node_number(
                  Trees_pt[i]->object_pt()->node_pt(n - 1)) != -1));


            // is it the Eastern neighbour ?
            bool is_E_neighbour =
              ((Trees_pt[j]->object_pt()->get_node_number(
                  Trees_pt[i]->object_pt()->node_pt(n - 1)) != -1) &&
               (Trees_pt[j]->object_pt()->get_node_number(
                  Trees_pt[i]->object_pt()->node_pt(n * n - 1)) != -1));

            // is it the Western neighbour ?
            bool is_W_neighbour =
              ((Trees_pt[j]->object_pt()->get_node_number(
                  Trees_pt[i]->object_pt()->node_pt(0)) != -1) &&
               (Trees_pt[j]->object_pt()->get_node_number(
                  Trees_pt[i]->object_pt()->node_pt(n * (n - 1))) != -1));


            if (is_N_neighbour) Trees_pt[i]->neighbour_pt(N) = Trees_pt[j];
            if (is_S_neighbour) Trees_pt[i]->neighbour_pt(S) = Trees_pt[j];
            if (is_E_neighbour) Trees_pt[i]->neighbour_pt(E) = Trees_pt[j];
            if (is_W_neighbour) Trees_pt[i]->neighbour_pt(W) = Trees_pt[j];
          }
        }
      }
    }
  }


  //================================================================
  /// Construct the rotation scheme for the quadtree forest.
  /// Note that all pointers to neighbours must have been allocated
  /// for this to work.
  //================================================================
  void QuadTreeForest::construct_north_equivalents()
  {
    using namespace QuadTreeNames;

    unsigned numtrees = ntree();
    // Loop over all the trees
    for (unsigned i = 0; i < numtrees; i++)
    {
      // Find the pointer to the northern neighbour
      QuadTreeRoot* neigh_pt = quad_neigh_pt(i, N);
      // If there is a neighbour
      if (neigh_pt != 0)
      {
        // Find the direction of the present tree, as viewed from the neighbour
        int direction = neigh_pt->direction_of_neighbour(quadtree_pt(i));

        // Set up the rotation scheme
        switch (direction)
        {
            // If N neighbour has this tree on S, north equivalent is N
          case S:
            quadtree_pt(i)->north_equivalent(N) = N;
            break;
            // If N neighbour has this tree on W, north equivalent is E
          case W:
            quadtree_pt(i)->north_equivalent(N) = E;
            break;
            // If N neighbour has this tree on N, north equivalent is S
          case N:
            quadtree_pt(i)->north_equivalent(N) = S;
            break;
            // If N neighbour has this tree on E, north equivalent is W
          case E:
            quadtree_pt(i)->north_equivalent(N) = W;
            break;
            // If N neighbour does not have pointer to this tree, die
          default:
            std::ostringstream error_stream;
            error_stream
              << "Tree " << i
              << "'s Northern neighbour has no neighbour pointer to Tree " << i
              << std::endl;

            throw OomphLibError(error_stream.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
        }
      }

      // Find the pointer to the eastern neighbour
      neigh_pt = quad_neigh_pt(i, E);
      // If there is a neighbour
      if (neigh_pt != 0)
      {
        // Find the direction of the present tree, as viewed from the neighbour
        int direction = neigh_pt->direction_of_neighbour(quadtree_pt(i));

        // Set up the rotation scheme
        switch (direction)
        {
            // If E neighbour has this tree on W, north equivalent is N
          case W:
            quadtree_pt(i)->north_equivalent(E) = N;
            break;
            // If E neighbour has this tree on N, north equivalent is E
          case N:
            quadtree_pt(i)->north_equivalent(E) = E;
            break;
            // If E neighbour has this tree on E, north equivalent is S
          case E:
            quadtree_pt(i)->north_equivalent(E) = S;
            break;
            // If E neighbour has this tree on S, north equivalent is W
          case S:
            quadtree_pt(i)->north_equivalent(E) = W;
            break;
            // If E neighbour does not have pointer to this tree, die
          default:
            std::ostringstream error_stream;
            error_stream
              << "Tree " << i
              << "'s Eastern neighbour has no neighbour pointer to Tree " << i
              << std::endl;

            throw OomphLibError(error_stream.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
        }
      }

      // Find the pointer to the southern neighbour
      neigh_pt = quad_neigh_pt(i, S);
      // If there is a neighbour
      if (neigh_pt != 0)
      {
        // Find the direction of the present tree, as viewed from the neighbour
        int direction = neigh_pt->direction_of_neighbour(quadtree_pt(i));

        // Set up the rotation scheme
        switch (direction)
        {
            // If S neighbour has this tree on N, north equivalent is N
          case N:
            quadtree_pt(i)->north_equivalent(S) = N;
            break;
            // If S neighbour has this tree on E, north equivalent is E
          case E:
            quadtree_pt(i)->north_equivalent(S) = E;
            break;
            // If S neighbour has this tree on S, north equivalent is S
          case S:
            quadtree_pt(i)->north_equivalent(S) = S;
            break;
            // If S neighbour has this tree on W, north equivalent is W
          case W:
            quadtree_pt(i)->north_equivalent(S) = W;
            break;
            // If S neighbour does not have pointer to this tree, die
          default:
            std::ostringstream error_stream;
            error_stream
              << "Tree " << i
              << "'s Southern neighbour has no neighbour pointer to Tree " << i
              << std::endl;

            throw OomphLibError(error_stream.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
        }
      }

      // Find the pointer to the western neighbour
      neigh_pt = quad_neigh_pt(i, W);
      // If there is a neighbour
      if (neigh_pt != 0)
      {
        // Find the direction of the present tree, as viewed from the neighbour
        int direction = neigh_pt->direction_of_neighbour(quadtree_pt(i));

        // Set up the rotation scheme
        switch (direction)
        {
            // If W neighbour has this tree on E, north equivalent is N
          case E:
            quadtree_pt(i)->north_equivalent(W) = N;
            break;
            // If W neighbour has this tree on S, north equivalent is E
          case S:
            quadtree_pt(i)->north_equivalent(W) = E;
            break;
            // If W neighbour has this tree on W, north equivalent is S
          case W:
            quadtree_pt(i)->north_equivalent(W) = S;
            break;
            // If W neighbour has this tree on N, north equivalent is W
          case N:
            quadtree_pt(i)->north_equivalent(W) = W;
            break;
            // If W neighbour does not have pointer to this tree, die
          default:
            std::ostringstream error_stream;
            error_stream
              << "Tree " << i
              << "'s Western neighbour has no neighbour pointer to Tree " << i
              << std::endl;

            throw OomphLibError(error_stream.str(),
                                OOMPH_CURRENT_FUNCTION,
                                OOMPH_EXCEPTION_LOCATION);
        }
      }
    }
  }

  //================================================================
  /// Document and check all the neighbours in all the nodes in
  /// the forest
  //================================================================
  void QuadTreeForest::check_all_neighbours(DocInfo& doc_info)
  {
    // Create Vector of elements
    Vector<Tree*> all_tree_nodes_pt;
    this->stick_all_tree_nodes_into_vector(all_tree_nodes_pt);

    // Create storage for information files
    std::ofstream neigh_file;
    std::ofstream neigh_txt_file;

    // If we are documenting the results, then open the files
    if (doc_info.is_doc_enabled())
    {
      std::ostringstream fullname;
      fullname << doc_info.directory() << "/neighbours" << doc_info.number()
               << ".dat";
      oomph_info << "opened " << fullname.str() << " to doc neighbours"
                 << std::endl;
      neigh_file.open(fullname.str().c_str());
      fullname.str("");
      fullname << doc_info.directory() << "/neighbours" << doc_info.number()
               << ".txt";
      oomph_info << "opened " << fullname.str() << " to doc neighbours"
                 << std::endl;
      neigh_txt_file.open(fullname.str().c_str());
    }

    // Call the standard documentation function
    double max_error = 0.0;
    QuadTree::doc_neighbours(
      all_tree_nodes_pt, neigh_file, neigh_txt_file, max_error);

    // If the error is too large complain
    if (max_error > Tree::max_neighbour_finding_tolerance())
    {
      std::ostringstream error_stream;
      error_stream << "Max. error in quadtree neighbour finding: " << max_error
                   << " is too big" << std::endl;
      error_stream
        << "i.e. bigger than Tree::max_neighbour_finding_tolerance()="
        << Tree::max_neighbour_finding_tolerance() << std::endl;

      // Close the files if they were opened
      if (doc_info.is_doc_enabled())
      {
        neigh_file.close();
        neigh_txt_file.close();
      }

      throw OomphLibError(
        error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }
    else
    {
      oomph_info << "Max. error in quadtree neighbour finding: " << max_error
                 << " is OK" << std::endl;
      oomph_info
        << "i.e. less than QuadTree::max_neighbour_finding_tolerance()="
        << QuadTree::max_neighbour_finding_tolerance() << std::endl;
    }

    // Close the files if they were opened
    if (doc_info.is_doc_enabled())
    {
      neigh_file.close();
      neigh_txt_file.close();
    }
  }

  //================================================================
  /// Open output files that will stored any hanging nodes that are
  /// created in the mesh refinement process.
  /// ===============================================================
  void QuadTreeForest::open_hanging_node_files(
    DocInfo& doc_info, Vector<std::ofstream*>& output_stream)
  {
    // In 2D, there will be four output files
    for (unsigned i = 0; i < 4; i++)
    {
      output_stream.push_back(new std::ofstream);
    }

    // If we are documenting the output, open the files
    if (doc_info.is_doc_enabled())
    {
      std::ostringstream fullname;
      fullname << doc_info.directory() << "/hang_nodes_s" << doc_info.number()
               << ".dat";
      output_stream[0]->open(fullname.str().c_str());
      fullname.str("");
      fullname << doc_info.directory() << "/hang_nodes_n" << doc_info.number()
               << ".dat";
      output_stream[1]->open(fullname.str().c_str());
      fullname.str("");
      fullname << doc_info.directory() << "/hang_nodes_w" << doc_info.number()
               << ".dat";
      output_stream[2]->open(fullname.str().c_str());
      fullname.str("");
      fullname << doc_info.directory() << "/hang_nodes_e" << doc_info.number()
               << ".dat";
      output_stream[3]->open(fullname.str().c_str());
    }
  }

  //================================================================
  /// Self test:  Check neighbour finding routine. For each element
  /// in the tree and for each vertex, determine the
  /// distance between the vertex and its position in the
  /// neigbour. If the difference is less than
  /// Tree::Max_neighbour_finding_tolerance.
  /// return success (0), otherwise failure (1)
  //=================================================================
  unsigned QuadTreeForest::self_test()
  {
    // Stick pointers to all nodes into Vector and number elements
    // in the process
    Vector<Tree*> all_forest_nodes_pt;
    stick_all_tree_nodes_into_vector(all_forest_nodes_pt);
    long int count = 0;
    unsigned long num_nodes = all_forest_nodes_pt.size();
    for (unsigned long i = 0; i < num_nodes; i++)
    {
      all_forest_nodes_pt[i]->object_pt()->set_number(++count);
    }

    // Check neighbours (distance between hanging nodes) -- don't print
    // (keep output streams closed)
    double max_error = 0.0;
    std::ofstream neighbours_file;
    std::ofstream neighbours_txt_file;
    QuadTree::doc_neighbours(
      all_forest_nodes_pt, neighbours_file, neighbours_txt_file, max_error);
    if (max_error > QuadTree::max_neighbour_finding_tolerance())
    {
      oomph_info << "\n \n Failed self_test() for QuadTree: Max. error "
                 << max_error << std::endl
                 << std::endl;
      return 1;
    }
    else
    {
      oomph_info << "\n \n Passed self_test() for QuadTree: Max. error "
                 << max_error << std::endl
                 << std::endl;
      return 0;
    }
  }

  //=================================================================
  /// Doc/check all neighbours of quadtree ("nodes") contained in the
  /// Vector forest_node_pt. Output into neighbours_file which can
  /// be viewed from tecplot with QuadTreeNeighbours.mcr
  /// Neighbour info and errors are displayed on
  /// neighbours_txt_file.  Finally, compute the max. error between
  /// vertices when viewed from neighhbouring element.
  /// Output is suppressed if the output streams are closed.
  //=================================================================
  void QuadTree::doc_neighbours(Vector<Tree*> forest_nodes_pt,
                                std::ofstream& neighbours_file,
                                std::ofstream& neighbours_txt_file,
                                double& max_error)
  {
    using namespace QuadTreeNames;

    int diff_level;
    double s_diff;
    bool in_neighbouring_tree;
    int edge = OMEGA;

    Vector<double> s(2);
    Vector<double> x(2);
    Vector<int> prev_son_type;

    Vector<unsigned> translate_s(2);
    Vector<double> s_lo(2);
    Vector<double> s_hi(2);

    Vector<double> x_small(2);
    Vector<double> x_large(2);

    // Initialise error in vertex positions
    max_error = 0.0;


    // Loop over all elements to assign numbers for plotting
    // -----------------------------------------------------
    unsigned long num_nodes = forest_nodes_pt.size();
    for (unsigned long i = 0; i < num_nodes; i++)
    {
      // Set number
      forest_nodes_pt[i]->object_pt()->set_number(i);
    }

    // Loop over all elements for checks
    // ---------------------------------
    for (unsigned long i = 0; i < num_nodes; i++)
    {
      // Doc the element itself
      QuadTree* el_pt = dynamic_cast<QuadTree*>(forest_nodes_pt[i]);

      // If the object is incomplete complain
      if (el_pt->object_pt()->nodes_built())
      {
        // Print it
        if (neighbours_file.is_open())
        {
          dynamic_cast<RefineableQElement<2>*>(el_pt->object_pt())
            ->output_corners(neighbours_file, "BLACK");
        }

        // Loop over directions to find neighbours
        // ----------------------------------------
        for (int direction = N; direction <= W; direction++)
        {
          // Initialise difference in levels and coordinate offset
          diff_level = 0;
          s_diff = 0.0;

          // Find greater-or-equal-sized neighbour...
          QuadTree* neighb_pt =
            el_pt->gteq_edge_neighbour(direction,
                                       translate_s,
                                       s_lo,
                                       s_hi,
                                       edge,
                                       diff_level,
                                       in_neighbouring_tree);

          // If neighbour exist and nodes are created: Doc it
          if ((neighb_pt != 0) && (neighb_pt->object_pt()->nodes_built()))
          {
            // Doc neighbour stats
            if (neighbours_txt_file.is_open())
            {
              neighbours_txt_file
                << Direct_string[direction] << " neighbour of "
                << el_pt->object_pt()->number() << " is "
                << neighb_pt->object_pt()->number() << " diff_level "
                << diff_level << " s_diff " << s_diff
                << " inside neighbour the edge is " << Direct_string[edge]
                << std::endl
                << std::endl;
            }

            // Plot neighbour in the appropriate Colour
            if (neighbours_file.is_open())
            {
              dynamic_cast<RefineableQElement<2>*>(neighb_pt->object_pt())
                ->output_corners(neighbours_file, Colour[direction]);
            }

            // Check that local
            // coordinates in the larger element (obtained via s_diff)
            // lead to the same spatial point as the node vertices
            // in the current element
            {
              if (neighbours_file.is_open())
              {
                neighbours_file << "ZONE I=2 \n";
              }

              // (Lower)/(left) vertex:
              //-----------------------

              // Get coordinates in large (neighbour) element
              s[0] = s_lo[0];
              s[1] = s_lo[1];
              neighb_pt->object_pt()->get_x(s, x_large);

              // Get coordinates in small element
              Vector<double> s(2);
              s[0] = S_base(0, direction);
              s[1] = S_base(1, direction);
              el_pt->object_pt()->get_x(s, x_small);


              // Need to exclude periodic nodes from this check
              // There can only be periodic nodes if we have moved into the
              // neighbour
              bool is_periodic = false;
              if (in_neighbouring_tree)
              {
                // is the node periodic
                is_periodic =
                  el_pt->root_pt()->is_neighbour_periodic(direction);
              }

              double error = 0.0;
              // Only bother to calculate the error if the node is NOT periodic
              if (is_periodic == false)
              {
                for (int i = 0; i < 2; i++)
                {
                  error += pow(x_small[i] - x_large[i], 2);
                }
              }

              // Take the root of the square error
              error = sqrt(error);
              if (neighbours_txt_file.is_open())
              {
                neighbours_txt_file << "Error (1) " << error << std::endl;
              }

              if (std::fabs(error) > max_error)
              {
                max_error = std::fabs(error);
              }

              if (neighbours_file.is_open())
              {
                neighbours_file << x_large[0] << " " << x_large[1] << "  0 \n";
              }

              // (Upper)/(right) vertex:
              //------------------------

              // Get coordinates in large (neighbour) element
              s[0] = s_hi[0];
              s[1] = s_hi[1];
              neighb_pt->object_pt()->get_x(s, x_large);

              // Get coordinates in small element
              s[0] = S_base(0, direction) + S_step(0, direction);
              s[1] = S_base(1, direction) + S_step(1, direction);
              el_pt->object_pt()->get_x(s, x_small);

              error = 0.0;
              // Only do this if we are NOT periodic
              if (is_periodic == false)
              {
                for (int i = 0; i < 2; i++)
                {
                  error += pow(x_small[i] - x_large[i], 2);
                }
              }
              // Take the root of the square error
              error = sqrt(error);

              // error=
              // sqrt(pow(x_small[0]-x_large[0],2)+pow(x_small[1]-x_large[1],2));
              if (neighbours_txt_file.is_open())
              {
                neighbours_txt_file << "Error (2) " << error << std::endl;
              }

              if (std::fabs(error) > max_error)
              {
                max_error = std::fabs(error);
              }

              if (neighbours_file.is_open())
              {
                neighbours_file << x_large[0] << " " << x_large[1] << "  0 \n";
              }
            }
            //        else
            //         {
            //          // No neighbour: write dummy zone so tecplot can find
            //          four
            //          // neighbours for every element
            //          if (neighbours_file.is_open())
            //            {
            //             neighbours_file << "ZONE I=2 \n";
            //             neighbours_file << "-0.05 -0.05   0 \n";
            //             neighbours_file << "-0.05 -0.05   0 \n";
            //            }
            //         }
          }
          // If neighbour does not exist: Insert blank zones into file
          // so that tecplot can find four neighbours for every element
          else
          {
            if (neighbours_file.is_open())
            {
              neighbours_file << "ZONE \n 0.00 0.00  0 \n";
              neighbours_file << "ZONE I=2 \n";
              neighbours_file << "-0.05 -0.05  0 \n";
              neighbours_file << "-0.05 -0.05  0 \n";
            }
          }
        }
      } // End of case when element can be documented
    }
  }

} // namespace oomph
