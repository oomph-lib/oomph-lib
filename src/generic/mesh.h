//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//Header file for general mesh classes

//Include guards to prevent multiple inclusion of the header
#ifndef OOMPH_GENERIC_MESH_HEADER
#define OOMPH_GENERIC_MESH_HEADER



// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//oomph-lib headers
#include "Vector.h"
#include "nodes.h"
#include "elements.h"
#include "timesteppers.h"
#include "matrices.h"
#include "refineable_elements.h"
#include <list>
#include <typeinfo>

namespace oomph
{

//=================================================================
/// \short  A general mesh class.
///
/// The main components of a Mesh are:
/// - pointers to its Nodes
/// - pointers to its Elements
/// - pointers to its boundary Nodes 
/// 
//=================================================================
class Mesh
{
  
 /// Problem is a friend
 friend class Problem;

 private:

 /// \short Vector of Vector of pointers to nodes on the boundaries: 
 /// Boundary_node_pt(b,n). Note that this is private to force
 /// the use of the add_boundary_node() function, which ensures
 /// that the reverse look-up schemes for the nodes are set up.
 Vector<Vector<Node*> > Boundary_node_pt;

 protected:

 /// Flag to indicate that the lookup schemes for elements that are adjacent
 /// to the boundaries has been set up.
 bool Lookup_for_elements_next_boundary_is_setup;

 /// \short Vector of Vector of pointers to elements on the boundaries: 
 /// Boundary_element_pt(b,e)
 Vector<Vector<FiniteElement*> > Boundary_element_pt;

 /// \short  For the e-th finite element on boundary b, this is the index of 
 /// the face that lies along that boundary
 Vector<Vector<int> > Face_index_at_boundary;

 /// \short Default Steady Timestepper, to be used in default arguments
 /// to Mesh constructors 
 static Steady<0> Default_TimeStepper;


#ifdef OOMPH_HAS_MPI

 /// Map of vectors holding the pointers to the root halo elements
 std::map<unsigned, Vector<FiniteElement*> > Root_halo_element_pt;

 /// Map of vectors holding the pointers to the root haloed elements
 std::map<unsigned, Vector<FiniteElement*> > Root_haloed_element_pt;

 /// Map of vectors holding the pointers to the halo nodes
 std::map<unsigned, Vector<Node*> > Halo_node_pt;

 /// Map of vectors holding the pointers to the haloed nodes
 std::map<unsigned, Vector<Node*> > Haloed_node_pt;

 /// Map of vectors holding the pointers to the shared nodes.
 /// These are all the nodes that are on two "neighbouring" processes
 /// (the halo(ed) lookup scheme depends upon which processor is in charge
 /// - a node which is on 3 processors, for example, will not feature in
 /// the halo(ed) lookup scheme between the two lowest-numbered processors)
 std::map<unsigned, Vector<Node*> > Shared_node_pt;

 /// bool to say whether the mesh has been distributed yet
 bool Mesh_has_been_distributed;

 /// External halo(ed) elements are created as and when they are needed
 /// to act as source elements for the particular process's mesh.
 /// The storage is wiped and rebuilt every time the mesh is refined.

 /// Map of vectors holding the pointers to the external halo elements
 std::map<unsigned, Vector<FiniteElement*> > External_halo_element_pt;

 /// Map of vectors holding the pointers to the external haloed elements
 std::map<unsigned, Vector<FiniteElement*> > External_haloed_element_pt;

#endif

 /// Vector holding the pointers to the external elements, which are the
 /// elements that are source elements for elements within an existing
 /// Mesh that are contained on a different Mesh but the same processor
 /// (obviously only important after distribution of the mesh has occurred)
 Vector<FiniteElement*> External_element_pt;

 /// Vector holding pointers to the external nodes on the external elements
 Vector<Node*> External_node_pt;

#ifdef OOMPH_HAS_MPI

 /// External halo(ed) nodes are on the external halo(ed) elements

 /// Map of vectors holding the pointers to the external halo nodes
 std::map<unsigned, Vector<Node*> > External_halo_node_pt;

 /// Map of vectors holding the pointers to the external haloed nodes
 std::map<unsigned, Vector<Node*> > External_haloed_node_pt;

 /// bool to indicate whether to keep all elements in a mesh as halos or not
 bool Keep_all_elements_as_halos;

#endif

 /// \short Assign the global equation numbers in the Data stored at the nodes 
 /// and also internal element Data. Also, build (via push_back) the 
 /// Vector of pointers to the dofs (variables).
 virtual unsigned long 
  assign_global_eqn_numbers(Vector<double *> &Dof_pt);

 /// Assign the local equation numbers in all elements
 virtual void assign_local_eqn_numbers();

 /// Vector of pointers to nodes
 Vector<Node*> Node_pt;
 
/// Vector of pointers to generalised elements
 Vector<GeneralisedElement*> Element_pt;
 
 /// \short Vector of boolean data that indicates whether the boundary
 /// coordinates have been set for the boundary
 std::vector<bool> Boundary_coordinate_exists;
 
 /// \short A function that upgrades an ordinary node to a boundary node
 /// We shouldn't ever really use this, but it does make life that
 /// bit easier for the lazy mesh writer. The pointer to the node is
 /// replaced by a pointer to the new boundary node in all element look-up
 /// schemes and in the mesh's Node_pt vector. The new node is also 
 /// addressed by node_pt on return from the function.
 void convert_to_boundary_node(Node* &node_pt);
     
public:


 /// \short Typedef for function pointer to function that computes 
 /// steady exact solution
 typedef void (FiniteElement::*SteadyExactSolutionFctPt)(
  const Vector<double>& x, Vector<double>& soln);

 /// \short Typedef for function pointer to function that computes unsteady 
 /// exact solution
 typedef void (FiniteElement::*UnsteadyExactSolutionFctPt)(
  const double& time, const Vector<double>& x, Vector<double>& soln);

 /// \short Default constructor
 Mesh()
  {
   // Lookup scheme hasn't been setup yet
   Lookup_for_elements_next_boundary_is_setup=false;
#ifdef OOMPH_HAS_MPI
   // Set defaults for distributed meshes

   // Mesh hasn't been distributed
   Mesh_has_been_distributed=false;
   // Don't keep all objects as halos
   Keep_all_elements_as_halos=false;
   // Don't output halo elements
   Output_halo_elements=false;
#endif
  }

 /// \short Constructor builds combined mesh from the meshes specified.
 /// Note: This simply merges the meshes' elements and nodes (ignoring
 /// duplicates; no boundary information etc. is created). 
 Mesh(const Vector<Mesh*>& sub_mesh_pt)
  {
   merge_meshes(sub_mesh_pt);
  }

 /// \short Merge meshes.
 /// Note: This simply merges the meshes' elements and nodes (ignoring
 /// duplicates; no boundary information etc. is created). 
 void merge_meshes(const Vector<Mesh*>& sub_mesh_pt);

 /// \short Interface for function that is used to setup the boundary 
 /// information (Empty virtual function -- implement this for specific 
 /// Mesh classes)
 virtual void setup_boundary_element_info() { }

 /// \short Setup lookup schemes which establish whic elements are located
 /// next to mesh's boundaries. Doc in outfile (if it's open).
 /// (Empty virtual function -- implement this for specific 
 /// Mesh classes)
 virtual void setup_boundary_element_info(std::ostream &outfile) {}
 
 /// Broken copy constructor
 Mesh(const Mesh& dummy) 
  { 
   BrokenCopy::broken_copy("Mesh");
  } 
 
 /// Broken assignment operator
 void operator=(const Mesh&) 
  {
   BrokenCopy::broken_assign("Mesh");
  }

 /// Virtual Destructor to clean up all memory
 virtual ~Mesh();


/// \short Flush storage for elements and nodes by emptying the
/// vectors that store the pointers to them. This is
/// useful if a particular mesh is only built to generate
/// a small part of a bigger mesh. Once the elements and
/// nodes have been created, they are typically copied
/// into the new mesh and the auxiliary mesh can be
/// deleted. However, if we simply call the destructor
/// of the auxiliary mesh, it will also wipe out
/// the nodes and elements, because it still "thinks"
/// it's in charge of these...
 void flush_element_and_node_storage();

 /// Return pointer to global node n
 Node* &node_pt(const unsigned long &n) {return Node_pt[n];}

 /// Return  pointer to element e
 GeneralisedElement* &element_pt(const unsigned long &e) 
  {return Element_pt[e];}

 /// Return reference to the Vector of elements
 const Vector<GeneralisedElement*> &element_pt() const {return Element_pt;}
 
 /// Return reference to the Vector of elements
 Vector<GeneralisedElement*> &element_pt() {return Element_pt;}

 /// \short Upcast (downcast?) to FiniteElement
 /// (needed to access FiniteElement member functions).
 FiniteElement* finite_element_pt(const unsigned &e)
  {
#ifdef PARANOID
   FiniteElement* el_pt=dynamic_cast<FiniteElement*>(Element_pt[e]);
   if (el_pt==0)
    {
     //Error
     throw OomphLibError("Failed cast to FiniteElement* ",
                         "Mesh::finite_element_pt()",
                         OOMPH_EXCEPTION_LOCATION);
     //Dummy return to keep intel compiler happy
     return el_pt;
    }
   return el_pt;
#else
   return dynamic_cast<FiniteElement*>(Element_pt[e]);
#endif
  }

 /// Return pointer to node n on boundary b
 Node* &boundary_node_pt(const unsigned &b, const unsigned &n)
  {return Boundary_node_pt[b][n];}

 /// Set the number of boundaries in the mesh
 void set_nboundary(const unsigned &nbound)
  {
   Boundary_node_pt.resize(nbound);
   Boundary_coordinate_exists.resize(nbound,false);
  }

 ///\short Clear all pointers to boundary nodes
 void remove_boundary_nodes();

 /// \short Remove all information about nodes stored on the b-th
 /// boundary of the mesh
 void remove_boundary_nodes(const unsigned &b);

 //\ short Remove a node from the boundary b
 void remove_boundary_node(const unsigned &b, Node* const &node_pt);

 /// Add a (pointer to) a node to the b-th boundary 
 void add_boundary_node(const unsigned &b, Node* const &node_pt);

 /// Indicate whether the i-th boundary has an intrinsic coordinate.
 // By default, if the array Boundary_coordinate has not been resized,
 // return false
 bool boundary_coordinate_exists(const unsigned &i) const
  {
   if(Boundary_coordinate_exists.empty()) {return false;}
   //ALH: This bounds-checking code needs to remain, because 
   //Boundary_coordinate_exists is 
   //an stl vector not our overloaded Vector class
#ifdef RANGE_CHECKING
   if (i>=Boundary_coordinate_exists.size())
    {
     std::ostringstream error_message;
     error_message << "Range Error: " << i << " is not in the range (0," 
                   << Boundary_coordinate_exists.size()-1 << std::endl;

     throw OomphLibError(error_message.str(),
                         "Mesh::boundary_coordinate_exists()",
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif  
   return Boundary_coordinate_exists[i];
  }
  
 /// Return number of elements in the mesh
 unsigned long nelement() const {return Element_pt.size();}

 /// Return number of nodes in the mesh
 unsigned long nnode() const {return Node_pt.size();}

 /// Add a (pointer to a) node to the mesh
 void add_node_pt(Node* const &node_pt) {Node_pt.push_back(node_pt);}

 /// Add a (pointer to) an element to the mesh
 void add_element_pt(GeneralisedElement* const &element_pt)
  {Element_pt.push_back(element_pt);}


 /// \short Update nodal positions in response to changes in the domain shape.
 /// Uses the FiniteElement::get_x(...) function for FiniteElements
 /// and doesn't do anything for other element types. \n\n 
 /// If a MacroElement pointer has been set for a FiniteElement,
 /// the MacroElement representation is used to update the
 /// nodal positions; if not get_x(...) uses the FE interpolation
 /// and thus leaves the nodal positions unchanged.
 /// Virtual, so it can be overloaded by specific meshes,
 /// such as AlgebraicMeshes or SpineMeshes. \n\n
 /// Generally, this function updates the position of all nodes
 /// in response to changes in the boundary position. For
 /// SolidNodes it only applies the update to those SolidNodes
 /// whose position is determined by the boundary position, unless
 /// the bool flag is set to true.
 virtual void node_update(const bool& update_all_solid_nodes=false);

 /// \short Re-order nodes in the order in which they appear in elements --
 /// can be overloaded for more efficient re-ordering
 virtual void reorder_nodes();
 
 /// \short Constuct a Mesh of FACE_ELEMENTs along the b-th boundary
 /// of the mesh (which contains elements of type BULK_ELEMENT)
 template<class BULK_ELEMENT, template<class> class FACE_ELEMENT>
  void build_face_mesh(const unsigned &b, Mesh* const &face_mesh_pt)
  {
   //Find the number of nodes on the boundary
   unsigned nbound_node = nboundary_node(b);
   //Loop over the boundary nodes and add them to face mesh node pointer
   for(unsigned n=0;n<nbound_node;n++) 
    {face_mesh_pt->add_node_pt(boundary_node_pt(b,n));}

   //Find the number of elements next to the boundary
   unsigned nbound_element = nboundary_element(b);
   //Loop over the elements adjacent to boundary b
   for(unsigned e=0;e<nbound_element;e++)
    {
     //Create the FaceElement
     FACE_ELEMENT<BULK_ELEMENT>* face_element_pt =
      new FACE_ELEMENT<BULK_ELEMENT>(boundary_element_pt(b,e),
                                     face_index_at_boundary(b,e));
     
     //Add the face element to the face mesh
     face_mesh_pt->add_element_pt(face_element_pt);
    }

#ifdef OOMPH_HAS_MPI
   // If the bulk mesh has been distributed then the face mesh is too
   if (this->mesh_has_been_distributed())
    {
     face_mesh_pt->mesh_has_been_distributed()=true;
    }
#endif
  }

 /// \short Self-test: Check elements and nodes. Return 0 for OK
 unsigned self_test();

 /// \short Check for repeated nodes within a given spatial tolerance.
 /// Return (0/1) for (pass/fail). 
 unsigned check_for_repeated_nodes(const double& epsilon=1.0e-12)
  {
   oomph_info <<"\n\nStarting check for repeated nodes...";
   unsigned nnod=nnode();
   for (unsigned j=0;j<nnod;j++)
    {
     Node* nod1_pt=this->node_pt(j);
     unsigned dim=nod1_pt->ndim();
     for (unsigned k=j+1;k<nnod;k++)
      {
       Node* nod2_pt=this->node_pt(k);
       double dist=0.0;
       for (unsigned i=0;i<dim;i++)
        {
         dist+=pow((nod1_pt->x(i)-nod2_pt->x(i)),2);
        }
       dist=sqrt(dist);
       if (dist<epsilon)
        {
         oomph_info << "\n\nRepeated node!" << std::endl;
         oomph_info << "Distance between nodes " << j << " and " << k 
                    << std::endl;
         oomph_info << "is " << dist << " which is less than the" 
                    << std::endl;
         oomph_info << "permitted distance of " << epsilon  
                    << std::endl << std::endl;
         oomph_info << "The offending nodes are located at: " << std::endl;
         for (unsigned i=0;i<dim;i++)
          {
           oomph_info << nod1_pt->x(i) << " ";
          }
         oomph_info << std::endl << std::endl;
         return 1;
        }
      }
    }
   // If we made it to here, we must have passed the test.
   oomph_info <<"...done: Test passed!" << std::endl << std::endl;
   return 0;
  }

 /// \short Prune nodes. Nodes that have been marked as obsolete are removed
 /// from the mesh (and its boundary-node scheme)
 void prune_dead_nodes();

 /// Return number of boundaries
 unsigned nboundary() const {return Boundary_node_pt.size();}

 /// Return number of nodes on a particular boundary
 unsigned long nboundary_node(const unsigned &ibound) const 
  {return Boundary_node_pt[ibound].size();}


 /// Return pointer to e-th finite element on boundary b
 FiniteElement* boundary_element_pt(const unsigned &b, const unsigned &e) const
  {
#ifdef PARANOID
   if (!Lookup_for_elements_next_boundary_is_setup)
    {
     throw OomphLibError(
      "Lookup scheme for elements next to boundary hasn't been set up yet!\n",
      "Mesh::boundary_element_pt()",
      OOMPH_EXCEPTION_LOCATION);
    }
#endif
   return Boundary_element_pt[b][e];
  }


 /// Return number of finite elements that are adjacent to boundary b
 unsigned nboundary_element(const unsigned &b) const
  {
#ifdef PARANOID
   if (!Lookup_for_elements_next_boundary_is_setup)
    {
     throw OomphLibError(
      "Lookup scheme for elements next to boundary hasn't been set up yet!\n",
      "Mesh::n_boundary_element()",
      OOMPH_EXCEPTION_LOCATION);
    }
#endif
   return Boundary_element_pt[b].size();
  }


 /// \short For the e-th finite element on boundary b, return int to indicate
 /// the face_index of the face adjacent to the boundary. This is consistent 
 /// with input required during the generation of FaceElements.
 int face_index_at_boundary(const unsigned &b, const unsigned &e) const
  {
#ifdef PARANOID
   if (!Lookup_for_elements_next_boundary_is_setup)
    {
     throw OomphLibError(
      "Lookup scheme for elements next to boundary hasn't been set up yet!\n",
      "Mesh::face_index_at_boundary()",
      OOMPH_EXCEPTION_LOCATION);
    }
#endif
   return Face_index_at_boundary[b][e];
  }

 /// Dump the data in the mesh into a file for restart
 virtual void dump(std::ofstream &dump_file);

 /// \short Read solution from restart file
 virtual void read(std::ifstream &restart_file);

 /// Output for all elements
 void output(std::ostream &outfile);

 /// Output at f(n_plot) points in each element
 void output(std::ostream &outfile, const unsigned &n_plot);

 /// Output for all elements (C-style output)
 void output(FILE* file_pt);

 /// Output at f(n_plot) points in each element (C-style output)
 void output(FILE* file_pt, const unsigned &nplot);

 /// Output for all elements
 void output(const std::string& output_filename)
  {
   std::ofstream outfile;
   outfile.open(output_filename.c_str());
   output(outfile);
   outfile.close();
  }

 /// Output at f(n_plot) points in each element
 void output(const std::string& output_filename, const unsigned &n_plot)
  {
   std::ofstream outfile;
   outfile.open(output_filename.c_str());
   output(outfile,n_plot);
   outfile.close();
  }

 /// Output a given Vector function at f(n_plot) points in each element
 void output_fct(std::ostream &outfile, const unsigned &n_plot,
                 FiniteElement::SteadyExactSolutionFctPt);

 /// \short Output a given time-dep. Vector function at f(n_plot) points in 
 /// each element
 void output_fct(std::ostream &outfile, const unsigned &n_plot,
                 const double& time, 
                 FiniteElement::UnsteadyExactSolutionFctPt);

 /// Output the nodes on the boundaries (into separate tecplot zones)
 void output_boundaries(std::ostream &outfile);

 /// Output the nodes on the boundaries (into separate tecplot zones).
 /// Specify filename
 void output_boundaries(const std::string& output_filename)
  {
   std::ofstream outfile;
   outfile.open(output_filename.c_str());
   output_boundaries(outfile);
   outfile.close();
  }

 /// \short Assign initial values for an impulsive start
 void assign_initial_values_impulsive();

 ///  \short Shift time-dependent data along for next timestep:
 /// Deal with nodal Data/positions and the element's internal 
 /// Data 
 void shift_time_values();

 /// \short Calculate predictions for all Data and positions associated 
 /// with the mesh, usually used in adaptive time-stepping.
 void calculate_predictions();

 /// \short Plot error when compared against a given exact solution.
 ///  Also returns the norm  of the error and that of the exact solution
 virtual void compute_error(std::ostream &outfile,
                            FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt,
                            const double& time,
                            double& error, double& norm)
  {
   //Initialse the norm and error
   norm=0.0; error=0.0;
   //Per-element norm and error
   double el_error,el_norm;
   
   //Loop over the elements
   unsigned long Element_pt_range = Element_pt.size();
   for(unsigned long e=0;e<Element_pt_range;e++)
    {
     // Try to cast to FiniteElement
     FiniteElement* el_pt=dynamic_cast<FiniteElement*>(Element_pt[e]);
     if (el_pt==0)
      {
       throw OomphLibError(
        "Can't execute compute_error(...) for non FiniteElements",
        "Mesh::compute_error()",
        OOMPH_EXCEPTION_LOCATION);
      }

     // Reset elemental errors and norms
     el_norm=0.0;
     el_error=0.0;
     //Compute error for each element
     el_pt->compute_error(outfile,exact_soln_pt,time,el_error,el_norm);
     //Add each element error to the global errors
     norm+=el_norm; error+=el_error;
    }
  }

 /// \short Plot error when compared against a given time-depdendent 
 ///  exact solution. Also returns the norm  of the error and 
 ///  that of the exact solution
 virtual void compute_error(std::ostream &outfile, 
                            FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,
                            double& error, double& norm)
  {
   //Initialise norm and error
   norm=0.0; error=0.0;
   //Per-element norm and error
   double el_error,el_norm;
   
   //Loop over the elements
   unsigned long Element_pt_range = Element_pt.size();
   for(unsigned long e=0;e<Element_pt_range;e++)
    {
     // Try to cast to FiniteElement
     FiniteElement* el_pt=dynamic_cast<FiniteElement*>(Element_pt[e]);
     if (el_pt==0)
      {
       throw OomphLibError(
        "Can't execute compute_error(...) for non FiniteElements",
        "Mesh::compute_error()",
        OOMPH_EXCEPTION_LOCATION);
      }
     // Reset elemental errors and norms
     el_norm=0.0;
     el_error=0.0;
     //Calculate the elemental errors
     el_pt->compute_error(outfile,exact_soln_pt,el_error,el_norm);
     //Add each elemental error to the global error
     norm+=el_norm; error+=el_error;
    }
  }

#ifdef OOMPH_HAS_MPI

 /// Access function for Mesh_has_been_distributed
 bool& mesh_has_been_distributed() 
  {
   return Mesh_has_been_distributed;
  }

 /// Access function for Keep_all_elements_as_halos
 bool& keep_all_elements_as_halos()
  {
   return Keep_all_elements_as_halos;
  }

 /// Distribute the problem and doc; make this virtual to allow
 /// overloading for particular meshes where further work is required
 virtual void distribute(OomphCommunicator* comm_pt,
                         const Vector<unsigned>& element_domain,
                         DocInfo& doc_info,
                         const bool& report_stats);
  
 /// Distribute the problem
 void distribute(OomphCommunicator* comm_pt,
                 const Vector<unsigned>& element_domain,
                 const bool& report_stats=false)
  {
   DocInfo doc_info;
   doc_info.doc_flag()=false;
   distribute(comm_pt,element_domain,doc_info,report_stats);
  }

 /// \short (Irreversibly) prune halo(ed) elements and nodes, usually
 /// after another round of refinement, to get rid of
 /// excessively wide halo layers. Note that the current
 /// mesh will be now regarded as the base mesh and no unrefinement
 /// relative to it will be possible once this function 
 /// has been called.
 void prune_halo_elements_and_nodes(OomphCommunicator* comm_pt,
                                    const bool& report_stats=false)
  {
   DocInfo doc_info;
   doc_info.doc_flag()=false;
   prune_halo_elements_and_nodes(comm_pt,doc_info,report_stats);
  }


 /// \short (Irreversibly) prune halo(ed) elements and nodes, usually
 /// after another round of refinement, to get rid of
 /// excessively wide halo layers. Note that the current
 /// mesh will be now regarded as the base mesh and no unrefinement
 /// relative to it will be possible once this function 
 /// has been called.
 void prune_halo_elements_and_nodes(OomphCommunicator* comm_pt,
                                    DocInfo& doc_info,
                                    const bool& report_stats);

 /// \short Get efficiency of mesh distribution: In an ideal distribution
 /// without halo overhead, each processor would only hold its own
 /// elements. Efficieny per processor =  (number of non-halo elements)/
 /// (total number of elements). 
 void get_efficiency_of_mesh_distribution(OomphCommunicator* comm_pt,
                                          double& av_efficiency,
                                          double& max_efficiency,
                                          double& min_efficiency);

 /// Doc the mesh distribution, to be processed with tecplot macros
 void doc_mesh_distribution(OomphCommunicator* comm_pt, DocInfo& doc_info);
 
 /// Check halo and shared schemes on the mesh
 void check_halo_schemes(OomphCommunicator* comm_pt, DocInfo& doc_info, 
                         double& max_permitted_error_for_halo_check);

 /// \short Classify the halo and haloed nodes in the mesh
 void classify_halo_and_haloed_nodes(OomphCommunicator* comm_pt,
                                     DocInfo& doc_info,
                                     const bool& report_stats);

 /// Classify the halo and haloed nodes in the mesh
 void classify_halo_and_haloed_nodes(OomphCommunicator* comm_pt,
                                     const bool& report_stats=false)
  {
   DocInfo doc_info;
   doc_info.doc_flag()=false;
   classify_halo_and_haloed_nodes(comm_pt,doc_info,report_stats);
  }

 /// \short Return vector of halo elements in this Mesh 
 /// whose non-halo counterpart is held on processor p.
 Vector<FiniteElement*> halo_element_pt(const unsigned& p)
  {
   // Prepare vector
   Vector<FiniteElement*> el_pt;

   // Loop over all root halo elements
   unsigned nelem=nroot_halo_element(p);
   for (unsigned e=0;e<nelem;e++)
    {
     FiniteElement* fe_pt=root_halo_element_pt(p,e);

     // Is it a refineable element?
     RefineableElement* ref_el_pt=dynamic_cast<RefineableElement*>(fe_pt);
     if (ref_el_pt!=0)
      {
       // Vector of pointers to leaves in tree emanating from
       // current root halo element
       Vector<Tree*> leaf_pt;
       ref_el_pt->tree_pt()->stick_leaves_into_vector(leaf_pt);
       
       // Loop over leaves and add their objects (the finite elements)
       // to vector
       unsigned nleaf=leaf_pt.size();
       for (unsigned l=0;l<nleaf;l++)
        {
         el_pt.push_back(leaf_pt[l]->object_pt());
        }
      }
     else
      {
       el_pt.push_back(fe_pt);
      }
    }
   return el_pt;
  }
 

 /// \short Return vector of haloed elements in this Mesh 
 /// whose haloing counterpart is held on processor p.
 Vector<FiniteElement*> haloed_element_pt(const unsigned& p)
  {
   // Prepare vector
   Vector<FiniteElement*> el_pt;
   
   // Loop over all root haloed elements
   unsigned nelem=nroot_haloed_element(p);
   for (unsigned e=0;e<nelem;e++)
    {
     FiniteElement* fe_pt=root_haloed_element_pt(p,e);

     // Is it a refineable element?
     RefineableElement* ref_el_pt=dynamic_cast<RefineableElement*>(fe_pt);
     if (ref_el_pt!=0)
      {
       // Vector of pointers to leaves in tree emanating from
       // current root haloed element
       Vector<Tree*> leaf_pt;
       ref_el_pt->tree_pt()->stick_leaves_into_vector(leaf_pt);
       
       // Loop over leaves and add their objects (the finite elements)
       // to vector
       unsigned nleaf=leaf_pt.size();
       for (unsigned l=0;l<nleaf;l++)
        {
         el_pt.push_back(leaf_pt[l]->object_pt());
        }
      }
     else
      {
       el_pt.push_back(fe_pt);
      }
    }
   return el_pt;
  }


 /// \short Total number of root halo elements in this Mesh
 unsigned nroot_halo_element()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<FiniteElement*> >::iterator it=
         Root_halo_element_pt.begin();it!=Root_halo_element_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }


 /// \short Number of root halo elements in this Mesh whose non-halo 
 /// counterpart is held on processor p.
 unsigned nroot_halo_element(const unsigned& p)
  {
   return Root_halo_element_pt[p].size();
  }

 /// \short Access fct to the e-th root halo element in this Mesh 
 /// whose non-halo counterpart is held on processor p.
 FiniteElement* root_halo_element_pt(const unsigned& p, const unsigned& e)
  {
   return Root_halo_element_pt[p][e];
  }


 /// \short Add root halo element whose non-halo counterpart is held 
 /// on processor p to this Mesh. 
 void add_root_halo_element_pt(const unsigned& p, FiniteElement*& el_pt)
  {
   Root_halo_element_pt[p].push_back(el_pt);
   el_pt->is_halo()=true; 
  }

 /// \short Total number of halo nodes in this Mesh
 unsigned nhalo_node()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<Node*> >::iterator it=
         Halo_node_pt.begin();it!=Halo_node_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }

 /// \short Number of halo nodes in this Mesh whose non-halo counterpart
 /// is held on processor p.
 unsigned nhalo_node(const unsigned& p)
  {
   return Halo_node_pt[p].size();
  }

 /// \short Add halo node whose non-halo counterpart is held 
 /// on processor p to the storage scheme for halo nodes.
 void add_halo_node_pt(const unsigned& p, Node*& nod_pt)
  {
   Halo_node_pt[p].push_back(nod_pt);
  }


 /// \short  Access fct to the j-th halo node in this Mesh 
 /// whose non-halo counterpart is held on processor p.
 Node* halo_node_pt(const unsigned& p, const unsigned& j)
  {
   return Halo_node_pt[p][j];
  }


 /// \short Total number of root haloed elements in this Mesh
 unsigned nroot_haloed_element()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<FiniteElement*> >::iterator it=
         Root_haloed_element_pt.begin();it!=Root_haloed_element_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }

 /// \short Number of root haloed elements in this Mesh whose non-halo
 /// counterpart is held on processor p.
 unsigned nroot_haloed_element(const unsigned& p)
  {
   return Root_haloed_element_pt[p].size();
  }

 /// \short Access fct to the e-th root haloed element in this Mesh 
 /// whose non-halo counterpart is held on processor p.
 FiniteElement* root_haloed_element_pt(const unsigned& p, const unsigned& e)
  {
   return Root_haloed_element_pt[p][e];
  }

 /// \short Add root haloed element whose non-halo counterpart is held 
 /// on processor p to the storage scheme for haloed elements.
 /// Note: This does not add the element to the storage scheme
 /// for elements as it's understood to naturally live on this
 /// processor anyway!
 void add_root_haloed_element_pt(const unsigned& p, FiniteElement*& el_pt)
  {
   Root_haloed_element_pt[p].push_back(el_pt);
  }


 /// \short Total number of haloed nodes in this Mesh
 unsigned nhaloed_node()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<Node*> >::iterator it=
         Haloed_node_pt.begin();it!=Haloed_node_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }


 /// \short Number of haloed nodes in this Mesh whose haloed counterpart
 /// is held on processor p.
 unsigned nhaloed_node(const unsigned& p)
  {
   return Haloed_node_pt[p].size();
  }

 /// \short Access fct to the j-th haloed node in this Mesh 
 /// whose halo counterpart is held on processor p.
 Node* haloed_node_pt(const unsigned& p, const unsigned& j)
  {
   return Haloed_node_pt[p][j];
  }

 /// \short Add haloed node whose halo counterpart is held 
 /// on processor p to the storage scheme for haloed nodes.
 void add_haloed_node_pt(const unsigned& p, Node*& nod_pt)
  {
   Haloed_node_pt[p].push_back(nod_pt);
  }

 /// Bool for output of halo elements
 bool Output_halo_elements;

 /// Function to disable halo element output
 void disable_output_of_halo_elements()
  {
   Output_halo_elements=false;
  }

 /// Function to enable halo element output
 void enable_output_of_halo_elements()
  {
   Output_halo_elements=true;
  }

 /// \short Total number of shared nodes in this Mesh
 unsigned nshared_node()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<Node*> >::iterator it=
         Shared_node_pt.begin();it!=Shared_node_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }

 /// \short Number of shared nodes in this Mesh who have a counterpart
 /// on processor p.
 unsigned nshared_node(const unsigned& p)
  {
   return Shared_node_pt[p].size();
  }

 /// \short Access fct to the j-th shared node in this Mesh 
 /// who has a counterpart on processor p.
 Node* shared_node_pt(const unsigned& p, const unsigned& j)
  {
   return Shared_node_pt[p][j];
  }

 /// \short Add shared node whose counterpart is held 
 /// on processor p to the storage scheme for shared nodes.
 /// (NB: ensure that this routine is called twice, once for each process)
 void add_shared_node_pt(const unsigned& p, Node*& nod_pt)
  {
   Shared_node_pt[p].push_back(nod_pt);
  }

 /// \short Get halo node stats for this distributed mesh:
 /// Average/max/min number of halo nodes over all processors.
 /// \b Careful: Involves MPI Broadcasts and must therefore
 /// be called on all processors!
 void get_halo_node_stats(OomphCommunicator* comm_pt,
                          double& av_number,
                          unsigned& max_number,
                          unsigned& min_number);

 /// \short Get haloed node stats for this distributed mesh:
 /// Average/max/min number of haloed nodes over all processors.
 /// \b Careful: Involves MPI Broadcasts and must therefore
 /// be called on all processors!
 void get_haloed_node_stats(OomphCommunicator* comm_pt,
                            double& av_number,
                            unsigned& max_number,
                            unsigned& min_number);

 // External halo(ed) elements are "source/other" elements which are
 // on different processes to the element for which they are the source

 /// \short Total number of external halo elements in this Mesh
 unsigned nexternal_halo_element()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<FiniteElement*> >::iterator it=
         External_halo_element_pt.begin();
        it!=External_halo_element_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }

 /// \short Number of external halo elements in this Mesh whose non-halo 
 /// counterpart is held on processor p.
 unsigned nexternal_halo_element(const unsigned& p)
  {
   return External_halo_element_pt[p].size();
  }

 /// \short Access fct to the e-th external halo element in this Mesh 
 /// whose non-halo counterpart is held on processor p.
 FiniteElement* external_halo_element_pt(const unsigned& p, const unsigned& e)
  {
   return External_halo_element_pt[p][e];
  }

 /// \short Add external halo element whose non-halo counterpart is held 
 /// on processor p to this Mesh. 
 void add_external_halo_element_pt(const unsigned& p, FiniteElement*& el_pt)
  {
   External_halo_element_pt[p].push_back(el_pt);
  }

 /// \short Total number of external haloed elements in this Mesh
 unsigned nexternal_haloed_element()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<FiniteElement*> >::iterator it=
         External_haloed_element_pt.begin();
        it!=External_haloed_element_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }

 /// \short Number of external haloed elements in this Mesh whose non-halo
 /// counterpart is held on processor p.
 unsigned nexternal_haloed_element(const unsigned& p)
  {
   return External_haloed_element_pt[p].size();
  }

 /// \short Access fct to the e-th external haloed element in this Mesh 
 /// whose non-halo counterpart is held on processor p.
 FiniteElement* external_haloed_element_pt(const unsigned& p, 
                                           const unsigned& e)
  {
   return External_haloed_element_pt[p][e];
  }

 /// \short Add external haloed element whose non-halo counterpart is held 
 /// on processor p to the storage scheme for haloed elements.
 unsigned add_external_haloed_element_pt(const unsigned& p, 
                                         FiniteElement*& el_pt);

 /// \short Total number of external halo nodes in this Mesh
 unsigned nexternal_halo_node()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<Node*> >::iterator it=
         External_halo_node_pt.begin();it!=External_halo_node_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }

 /// \short Number of external halo nodes in this Mesh whose non-halo 
 /// (external) counterpart is held on processor p.
 unsigned nexternal_halo_node(const unsigned& p)
  {
   return External_halo_node_pt[p].size();
  }

 /// \short Add external halo node whose non-halo (external) counterpart 
 /// is held on processor p to the storage scheme for halo nodes.
 void add_external_halo_node_pt(const unsigned& p, Node*& nod_pt)
  {
   External_halo_node_pt[p].push_back(nod_pt);
  }


 /// \short Access fct to the j-th external halo node in this Mesh 
 /// whose non-halo external counterpart is held on processor p.
 Node* &external_halo_node_pt(const unsigned& p, const unsigned& j)
  {
   return External_halo_node_pt[p][j];
  }

 /// \short Total number of external haloed nodes in this Mesh
 unsigned nexternal_haloed_node()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<Node*> >::iterator it=
       External_haloed_node_pt.begin();it!=External_haloed_node_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }

 /// \short Number of external haloed nodes in this Mesh 
 /// whose halo (external) counterpart is held on processor p.
 unsigned nexternal_haloed_node(const unsigned& p)
  {
   return External_haloed_node_pt[p].size();
  }

 /// \short Access fct to the j-th external haloed node in this Mesh 
 /// whose halo external counterpart is held on processor p.
 Node* &external_haloed_node_pt(const unsigned &p, const unsigned &j)
  {
   return External_haloed_node_pt[p][j];
  }

 /// \short Add external haloed node whose halo (external) counterpart
 /// is held on processor p to the storage scheme for haloed nodes.
 unsigned add_external_haloed_node_pt(const unsigned& p, Node*& nod_pt);

 /// \short Return the size of the External_halo(ed)_node_pt storage
 /// (which should always be the same as the number of processors used
 ///  by the communicator passed into Mesh::distribute(...))  This is
 /// required to avoid having to pass a communicator into the node_update 
 /// functions for Algebraic-based and MacroElement-based Meshes
 unsigned nexternal_halo_proc()
  {
   return External_halo_node_pt.size();
  }

#endif 

 /// External elements are "source" non-halo elements which are
 /// on the same process as the element for which they are the source

 /// \short Number of external elements for this Mesh
 unsigned nexternal_element()
  {
   return External_element_pt.size();
  }

 /// \short Access fct to the e-th external element in this Mesh.
 FiniteElement* external_element_pt(const unsigned& e)
  {
   return External_element_pt[e];
  }

 /// \short Add external element to this Mesh.
 bool add_external_element_pt(FiniteElement*& el_pt);

 /// External nodes are on the external elements

 /// \short Number of external nodes for this Mesh
 unsigned nexternal_node()
  {
   return External_node_pt.size();
  }

 /// \short Access fct to the j-th external node in this Mesh.
 Node* external_node_pt(const unsigned& j)
  {
   return External_node_pt[j];
  }

 /// \short Add external node to this Mesh.
 bool add_external_node_pt(Node*& nod_pt);

 /// \short Wipe the storage for all externally-based elements
 void flush_all_external_storage();


};



//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

class SolidICProblem;

//========================================================================
/// \short General SolidMesh class.
///
/// Solid meshes contain SolidFiniteElements which contain
/// SolidNodes. This class simply overloads the appropriate access
/// functions from the underlying Mesh class.
//
// Needs to be derived from Mesh with virtual so that 
// solid meshes can be derived from general meshes, without
// multiple copies of Mesh objects
//========================================================================
class SolidMesh : public virtual Mesh
{
  public:


 /// \short Default constructor
 SolidMesh() {}

 /// Broken copy constructor
 SolidMesh(const SolidMesh& dummy) 
  { 
   BrokenCopy::broken_copy("SolidMesh");
  } 
 
 /// Broken assignment operator
 void operator=(const SolidMesh&) 
  {
   BrokenCopy::broken_assign("SolidMesh");
  }


 /// \short Constructor builds combined mesh from the meshes specified.
 /// Note: This simply merges the meshes' elements and nodes (ignoring
 /// duplicates; no boundary information etc. is created). 
 SolidMesh(const Vector<SolidMesh*>& sub_mesh_pt)
  {
   unsigned n=sub_mesh_pt.size();
   Vector<Mesh*> sub_mesh_mesh_pt(n);
   for (unsigned i=0;i<n;i++)
    {
     sub_mesh_mesh_pt[i]=static_cast<Mesh*>(sub_mesh_pt[i]);
    }
   merge_meshes(sub_mesh_mesh_pt);
  }

 /// Return a pointer to the n-th global SolidNode
 //Can safely cast the nodes to SolidNodes
 SolidNode* node_pt(const unsigned long &n) 
  {
#ifdef PARANOID
   if(!dynamic_cast<SolidNode*>(Node_pt[n]))
    {
     std::ostringstream error_stream;
     error_stream  << "Error: Node " << n << "is a " 
                   << typeid(Node_pt[n]).name() 
                   << ", not an SolidNode" << std::endl; 
     throw OomphLibError(error_stream.str(),
                         "SolidMesh::node_pt()",
                         OOMPH_EXCEPTION_LOCATION);
    } 
#endif
   //Return a static cast to the Node_pt
   return (static_cast<SolidNode*>(Node_pt[n]));
  }

 /// Return n-th SolidNodes on b-th boundary
 SolidNode* boundary_node_pt(const unsigned &b,
                             const unsigned &n)
  {
#ifdef PARANOID
   if(!dynamic_cast<SolidNode*>(Mesh::boundary_node_pt(b,n)))
    {
     std::ostringstream error_stream;
     error_stream 
      << "Error: Node " << n << "is a " 
      << typeid(Mesh::boundary_node_pt(b,n)).name() 
      << ", not an SolidNode" << std::endl;
     throw OomphLibError(error_stream.str(),
                         "SolidMesh::boundary_node_pt()",
                         OOMPH_EXCEPTION_LOCATION);
    } 
#endif
      return static_cast<SolidNode*>(Mesh::boundary_node_pt(b,n));
  }

 /// \short Return the n-th local SolidNode in elemnet e. 
 ///This is required to cast the nodes in a solid mesh to be 
 ///SolidNodes and therefore allow access to the extra SolidNode data
 SolidNode* element_node_pt(const unsigned long &e, 
                              const unsigned &n)
  {
#ifdef PARANOID
   // Try to cast to FiniteElement
   FiniteElement* el_pt=dynamic_cast<FiniteElement*>(Element_pt[e]);
   if (el_pt==0)
    {
     //Error
     throw OomphLibError("Failed cast to FiniteElement* ",
                         "SolidMesh::element_node_pt()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   if(!dynamic_cast<SolidNode*>(el_pt->node_pt(n)))
    {
     std::ostringstream error_message;
     error_message << "Error: Node " << n << " of element " << e
                   << "is a " << typeid(*el_pt->node_pt(n)).name() 
                   << ", not an SolidNode" << std::endl;

     throw OomphLibError(error_message.str(),
                         "SolidMesh::element_node_pt()",
                         OOMPH_EXCEPTION_LOCATION);
    } 
#endif
   //Return a cast to an SolidNode
   return(static_cast<SolidNode*>(
          dynamic_cast<FiniteElement*>(Element_pt[e])->node_pt(n)));
  }
 
 /// \short Make the current configuration the undeformed one by
 /// setting the nodal Lagrangian coordinates to their current
 /// Eulerian ones
 void set_lagrangian_nodal_coordinates();

 /// \short Static problem that can be used to assign initial conditions
 /// on a given  solid mesh (need to define this as a static problem 
 /// somewhere because deleting the problem would wipe out the mesh too!)
 static SolidICProblem Solid_IC_problem;


};





}

#endif
