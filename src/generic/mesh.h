//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC// Copyright (C) 2006-2021 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//Header file for general mesh classes

//Include guards to prevent multiple inclusion of the header
#ifndef OOMPH_GENERIC_MESH_HEADER
#define OOMPH_GENERIC_MESH_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#ifdef OOMPH_HAS_MPI
#include "mpi.h"
#endif

#include<float.h>
#include <list>
#include <typeinfo>
#include<string>

//oomph-lib headers
#include "Vector.h"
#include "nodes.h"
#include "elements.h"
#include "timesteppers.h"
#include "generalised_timesteppers.h"
#include "matrices.h"
#include "refineable_elements.h"

namespace oomph
{




//=================================================================
/// \short  A general mesh class.
///
/// The main components of a Mesh are:
/// - pointers to its Nodes
/// - pointers to its Elements
/// - pointers to its boundary Nodes
///
//=================================================================
class Mesh
{

  public:

  /// Problem is a friend
 friend class Problem;


 /// \short Default Steady Timestepper, to be used in default arguments
 /// to Mesh constructors
 static Steady<0> Default_TimeStepper;


 protected:

 /// \short Vector of Vector of pointers to nodes on the boundaries:
 /// Boundary_node_pt(b,n). Note that this is private to force
 /// the use of the add_boundary_node() function, which ensures
 /// that the reverse look-up schemes for the nodes are set up.
 Vector<Vector<Node*> > Boundary_node_pt;

 /// Flag to indicate that the lookup schemes for elements that are adjacent
 /// to the boundaries has been set up.
 bool Lookup_for_elements_next_boundary_is_setup;

 /// \short Vector of Vector of pointers to elements on the boundaries:
 /// Boundary_element_pt(b,e)
 Vector<Vector<FiniteElement*> > Boundary_element_pt;

 /// \short  For the e-th finite element on boundary b, this is the index of
 /// the face that lies along that boundary
 Vector<Vector<int> > Face_index_at_boundary;

#ifdef OOMPH_HAS_MPI

 /// Map of vectors holding the pointers to the root halo elements
 std::map<unsigned, Vector<GeneralisedElement*> > Root_halo_element_pt;

 /// Map of vectors holding the pointers to the root haloed elements
 std::map<unsigned, Vector<GeneralisedElement*> > Root_haloed_element_pt;

 /// Map of vectors holding the pointers to the halo nodes
 std::map<unsigned, Vector<Node*> > Halo_node_pt;

 /// Map of vectors holding the pointers to the haloed nodes
 std::map<unsigned, Vector<Node*> > Haloed_node_pt;

 /// Map of vectors holding the pointers to the shared nodes.
 /// These are all the nodes that are on two "neighbouring" processes
 /// (the halo(ed) lookup scheme depends upon which processor is in charge
 /// - a node which is on 3 processors, for example, will not feature in
 /// the halo(ed) lookup scheme between the two lowest-numbered processors)
 std::map<unsigned, Vector<Node*> > Shared_node_pt;

 /// Pointer to communicator -- set to NULL if mesh is not distributed
 OomphCommunicator* Comm_pt;

 /// External halo(ed) elements are created as and when they are needed
 /// to act as source elements for the particular process's mesh.
 /// The storage is wiped and rebuilt every time the mesh is refined.

 /// Map of vectors holding the pointers to the external halo elements
 std::map<unsigned, Vector<GeneralisedElement*> > External_halo_element_pt;

 /// Map of vectors holding the pointers to the external haloed elements
 std::map<unsigned, Vector<GeneralisedElement*> > External_haloed_element_pt;


 // External halo(ed) nodes are on the external halo(ed) elements

 /// Map of vectors holding the pointers to the external halo nodes
 std::map<unsigned, Vector<Node*> > External_halo_node_pt;

 /// Map of vectors holding the pointers to the external haloed nodes
 std::map<unsigned, Vector<Node*> > External_haloed_node_pt;

 /// bool to indicate whether to keep all elements in a mesh as halos or not
 bool Keep_all_elements_as_halos;

 /// Set this to true to suppress resizing of halo nodes (at your own risk!)
 bool Resize_halo_nodes_not_required;

 /// Setup shared node scheme
 void setup_shared_node_scheme();

#endif

 /// \short Assign the global equation numbers in the Data stored at the nodes
 /// and also internal element Data. Also, build (via push_back) the
 /// Vector of pointers to the dofs (variables).
 unsigned long
  assign_global_eqn_numbers(Vector<double *> &Dof_pt);

 /// \short Function to describe the dofs of the Mesh. The ostream 
 /// specifies the output stream to which the description 
 /// is written; the string stores the currently 
 /// assembled output that is ultimately written to the
 /// output stream by Data::describe_dofs(...); it is typically
 /// built up incrementally as we descend through the
 /// call hierarchy of this function when called from 
 /// Problem::describe_dofs(...)
 void describe_dofs(std::ostream& out,const std::string& current_string) const;

 /// \short Function to describe the local dofs of the elements. The ostream 
 /// specifies the output stream to which the description 
 /// is written; the string stores the currently 
 /// assembled output that is ultimately written to the
 /// output stream by Data::describe_dofs(...); it is typically
 /// built up incrementally as we descend through the
 /// call hierarchy of this function when called from 
 /// Problem::describe_dofs(...)
 void describe_local_dofs(std::ostream& out,
                          const std::string& current_string) const;

 /// \short Assign the local equation numbers in all elements
 /// If the boolean argument is true then also store pointers to dofs
 void assign_local_eqn_numbers(const bool &store_local_dof_pt);

 /// Vector of pointers to nodes
 Vector<Node*> Node_pt;

 /// Vector of pointers to generalised elements
 Vector<GeneralisedElement*> Element_pt;

 /// \short Vector of boolean data that indicates whether the boundary
 /// coordinates have been set for the boundary
 std::vector<bool> Boundary_coordinate_exists;

 /// \short A function that upgrades an ordinary node to a boundary node
 /// We shouldn't ever really use this, but it does make life that
 /// bit easier for the lazy mesh writer. The pointer to the node is
 /// replaced by a pointer to the new boundary node in all element look-up
 /// schemes and in the mesh's Node_pt vector. The new node is also
 /// addressed by node_pt on return from the function.
 void convert_to_boundary_node(Node* &node_pt,
                               const Vector<FiniteElement*>& finite_element_pt);

 void convert_to_boundary_node(Node* &node_pt);


public:


#ifdef OOMPH_HAS_MPI


 /// \short Helper function that resizes halo nodes to the same
 /// size as their non-halo counterparts if required. (A discrepancy
 /// can arise if a FaceElement that introduces additional unknowns
 /// are attached to a bulk element that shares a node with a haloed element.
 /// In that case the joint node between haloed and non-haloed element
 /// is resized on that processor but not on the one that holds the
 /// halo counterpart (because no FaceElement is attached to the halo
 /// element)
 void resize_halo_nodes();

#endif


 /// \short Typedef for function pointer to function that computes
 /// steady exact solution
 typedef void (FiniteElement::*SteadyExactSolutionFctPt)(
  const Vector<double>& x, Vector<double>& soln);

 /// \short Typedef for function pointer to function that computes unsteady
 /// exact solution
 typedef void (FiniteElement::*UnsteadyExactSolutionFctPt)(
  const double& time, const Vector<double>& x, Vector<double>& soln);

 /// \short Boolean used to control warning about empty mesh level 
 /// timestepper function
 static bool Suppress_warning_about_empty_mesh_level_time_stepper_function;

 /// \short Default constructor
 Mesh()
  {
   // Lookup scheme hasn't been setup yet
   Lookup_for_elements_next_boundary_is_setup=false;
#ifdef OOMPH_HAS_MPI
   // Set defaults for distributed meshes

   // Mesh hasn't been distributed: Null out pointer to communicator
   Comm_pt=0;
   // Don't keep all objects as halos
   Keep_all_elements_as_halos=false;
   // Don't output halo elements
   Output_halo_elements=false;
   // Don't suppress automatic resizing of halo nodes
   Resize_halo_nodes_not_required=false;
#endif
  }

 /// \short Constructor builds combined mesh from the meshes specified.
 /// Note: This simply merges the meshes' elements and nodes (ignoring
 /// duplicates; no boundary information etc. is created).
 Mesh(const Vector<Mesh*>& sub_mesh_pt)
  {
#ifdef OOMPH_HAS_MPI
   // Mesh hasn't been distributed: Null out pointer to communicator
   Comm_pt=0;
#endif
   // Now merge the meshes
   merge_meshes(sub_mesh_pt);
  }

 /// \short Merge meshes.
 /// Note: This simply merges the meshes' elements and nodes (ignoring
 /// duplicates; no boundary information etc. is created).
 void merge_meshes(const Vector<Mesh*>& sub_mesh_pt);

 /// \short Interface for function that is used to setup the boundary
 /// information (Empty virtual function -- implement this for specific
 /// Mesh classes)
 virtual void setup_boundary_element_info() { }

 /// \short Setup lookup schemes which establish whic elements are located
 /// next to mesh's boundaries. Doc in outfile (if it's open).
 /// (Empty virtual function -- implement this for specific
 /// Mesh classes)
 virtual void setup_boundary_element_info(std::ostream &outfile) {}
 
 /// Virtual function to perform the reset boundary elements info rutines
 virtual void reset_boundary_element_info(
  Vector<unsigned> &ntmp_boundary_elements,
  Vector<Vector<unsigned> > &ntmp_boundary_elements_in_region,
  Vector<FiniteElement*> &deleted_elements)
  {
   std::ostringstream error_stream;
   error_stream << "Empty default reset boundary element info function"
                << "called.\n";
   error_stream << "This should be overloaded in a specific "
                << "TriangleMeshBase\n";
   throw OomphLibError(error_stream.str(),
                       "Mesh::reset_boundary_element_info()",
                       OOMPH_EXCEPTION_LOCATION);
  }
  
 /// \short Output boundary coordinates on boundary b -- template argument
 /// specifies the bulk element type (needed to create FaceElement
 /// of appropriate type on mesh boundary).
 template<class BULK_ELEMENT>
  void doc_boundary_coordinates(const unsigned& b, std::ofstream& the_file)
  {
   if (nelement()==0) return;
   if (!Boundary_coordinate_exists[b])
    {
     oomph_info << "No boundary coordinates were set up for boundary "
                << b << std::endl;
     return;
    }

   // Get spatial dimension
   unsigned dim=finite_element_pt(0)->node_pt(0)->ndim();

   // Loop over all elements on boundaries
   unsigned nel=this->nboundary_element(b);

   // Loop over the bulk elements adjacent to boundary b
   for(unsigned e=0;e<nel;e++)
    {
     // Get pointer to the bulk element that is adjacent to boundary b
     FiniteElement* bulk_elem_pt = this->boundary_element_pt(b,e);

     //Find the index of the face of element e along boundary b
     int face_index = this->face_index_at_boundary(b,e);

     // Create new face element
     DummyFaceElement<BULK_ELEMENT>* el_pt=
      new DummyFaceElement<BULK_ELEMENT>(bulk_elem_pt,face_index);

     // Specify boundary id in bulk mesh (needed to extract
     // boundary coordinate)
     el_pt->set_boundary_number_in_bulk_mesh(b);

     // Doc boundary coordinate
     Vector<double> s(dim-1);
     Vector<double> zeta(dim-1);
     Vector<double> x(dim);
     unsigned n_plot=5;
     the_file << el_pt->tecplot_zone_string(n_plot);

     // Loop over plot points
     unsigned num_plot_points=el_pt->nplot_points(n_plot);
     for (unsigned iplot=0;iplot<num_plot_points;iplot++)
      {
       // Get local coordinates of plot point
       el_pt->get_s_plot(iplot,n_plot,s);
       el_pt->interpolated_zeta(s,zeta);
       el_pt->interpolated_x(s,x);
       for (unsigned i=0;i<dim;i++)
        {
         the_file << x[i] << " ";
        }
       for (unsigned i=0;i<(dim-1);i++)
        {
         the_file << zeta[i] << " ";
        }

       the_file << std::endl;
      }
     el_pt->write_tecplot_zone_footer(the_file,n_plot);

     // Cleanup
     delete el_pt;
    }
  }


 /// \short Scale all nodal coordinates by given factor. Virtual
 /// so it can be overloaded in SolidMesh class where it also
 /// re-assigns the Lagrangian coordinates.
 virtual void scale_mesh(const double& factor)
 {
  unsigned nnod=this->nnode();
  unsigned dim=this->node_pt(0)->ndim();
  for (unsigned j=0;j<nnod;j++)
   {
    Node* nod_pt=this->node_pt(j);
    for (unsigned i=0;i<dim;i++)
     {
      nod_pt->x(i)*=factor;
     }
   }
 }


 /// Broken copy constructor
 Mesh(const Mesh& dummy)
  {
   BrokenCopy::broken_copy("Mesh");
  }

 /// Broken assignment operator
 void operator=(const Mesh&)
  {
   BrokenCopy::broken_assign("Mesh");
  }

 /// Virtual Destructor to clean up all memory
 virtual ~Mesh();


/// \short Flush storage for elements and nodes by emptying the
/// vectors that store the pointers to them. This is
/// useful if a particular mesh is only built to generate
/// a small part of a bigger mesh. Once the elements and
/// nodes have been created, they are typically copied
/// into the new mesh and the auxiliary mesh can be
/// deleted. However, if we simply call the destructor
/// of the auxiliary mesh, it will also wipe out
/// the nodes and elements, because it still "thinks"
/// it's in charge of these...
 void flush_element_and_node_storage()
 {
  flush_element_storage();
  flush_node_storage();
 }

/// \short Flush storage for elements (only) by emptying the
/// vectors that store the pointers to them. This is
/// useful if a particular mesh is only built to generate
/// a small part of a bigger mesh. Once the elements and
/// nodes have been created, they are typically copied
/// into the new mesh and the auxiliary mesh can be
/// deleted. However, if we simply call the destructor
/// of the auxiliary mesh, it will also wipe out
/// the nodes and elements, because it still "thinks"
/// it's in charge of these...
 void flush_element_storage()
 {
  Element_pt.clear();
 }

/// \short Flush storage for nodes (only) by emptying the
/// vectors that store the pointers to them.
 void flush_node_storage()
 {
  Node_pt.clear();
 }

 /// Return pointer to global node n
 Node* &node_pt(const unsigned long &n) {return Node_pt[n];}

 /// Return pointer to global node n (const version)
 Node* node_pt(const unsigned long &n) const {return Node_pt[n];}

 /// Return  pointer to element e
 GeneralisedElement* &element_pt(const unsigned long &e)
  {return Element_pt[e];}

 /// Return pointer to element e (const version)
 GeneralisedElement* element_pt(const unsigned long &e) const
  {return Element_pt[e];}

 /// Return reference to the Vector of elements
 const Vector<GeneralisedElement*> &element_pt() const {return Element_pt;}

 /// Return reference to the Vector of elements
 Vector<GeneralisedElement*> &element_pt() {return Element_pt;}

 /// \short Upcast (downcast?) to FiniteElement
 /// (needed to access FiniteElement member functions).
 FiniteElement* finite_element_pt(const unsigned &e) const
  {
#ifdef PARANOID
   FiniteElement* el_pt=dynamic_cast<FiniteElement*>(Element_pt[e]);
   if (el_pt==0)
    {
     //Error
     throw OomphLibError("Failed cast to FiniteElement* ",
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
     //Dummy return to keep intel compiler happy
     return el_pt;
    }
   return el_pt;
#else
   return dynamic_cast<FiniteElement*>(Element_pt[e]);
#endif
  }

 /// Return pointer to node n on boundary b
 Node* &boundary_node_pt(const unsigned &b, const unsigned &n)
  {return Boundary_node_pt[b][n];}

 /// Return pointer to node n on boundary b
 Node* boundary_node_pt(const unsigned &b, const unsigned &n) const
  {return Boundary_node_pt[b][n];}

 /// Set the number of boundaries in the mesh
 void set_nboundary(const unsigned &nbound)
  {
   Boundary_node_pt.resize(nbound);
   Boundary_coordinate_exists.resize(nbound,false);
  }

 ///\short Clear all pointers to boundary nodes
 void remove_boundary_nodes();

 /// \short Remove all information about nodes stored on the b-th
 /// boundary of the mesh
 void remove_boundary_nodes(const unsigned &b);

 //\ short Remove a node from the boundary b
 void remove_boundary_node(const unsigned &b, Node* const &node_pt);

 /// Add a (pointer to) a node to the b-th boundary
 void add_boundary_node(const unsigned &b, Node* const &node_pt);

 /// Replace existing boundary node lookup schemes with new schemes created
 /// using the boundary data stored in the nodes.
 void copy_boundary_node_data_from_nodes()
 {
  // Clear existing boundary data
  Boundary_node_pt.clear();

  // Loop over nodes adding them to the appropriate boundary lookup schemes
  // in the mesh.
  const unsigned n_node = nnode();
  for(unsigned nd=0; nd<n_node; nd++)
   {
    Node* nd_pt = node_pt(nd);

    if(nd_pt->is_on_boundary())
     {
      // Get set of boundaries that the node is on
      std::set<unsigned>* boundaries_pt;
      nd_pt->get_boundaries_pt(boundaries_pt);

      // If needed then add more boundaries to this mesh
      unsigned max_boundary_n = 1 +
       *std::max_element(boundaries_pt->begin(), boundaries_pt->end());
      if(max_boundary_n > nboundary())
       {
        set_nboundary(max_boundary_n);
       }

      // Add node pointer to the appropriate Boundary_node_pt vectors
      std::set<unsigned>::const_iterator it;
      for(it=boundaries_pt->begin(); it!=boundaries_pt->end(); it++)
       {
        Boundary_node_pt[*it].push_back(nd_pt);
       }
     }
   }
 }

 /// Indicate whether the i-th boundary has an intrinsic coordinate.
 // By default, if the array Boundary_coordinate has not been resized,
 // return false
 bool boundary_coordinate_exists(const unsigned &i) const
  {
   if(Boundary_coordinate_exists.empty()) {return false;}
   //ALH: This bounds-checking code needs to remain, because
   //Boundary_coordinate_exists is
   //an stl vector not our overloaded Vector class
#ifdef RANGE_CHECKING
   if (i>=Boundary_coordinate_exists.size())
    {
     std::ostringstream error_message;
     error_message << "Range Error: " << i << " is not in the range (0,"
                   << Boundary_coordinate_exists.size()-1 << std::endl;

     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   return Boundary_coordinate_exists[i];
  }

 /// Return number of elements in the mesh
 unsigned long nelement() const {return Element_pt.size();}

 /// Return number of nodes in the mesh
 unsigned long nnode() const {return Node_pt.size();}

 /// Return number of dof types in mesh
 unsigned ndof_types() const;

 /// Return number of elemental dimension in mesh
 unsigned elemental_dimension() const;

 /// Return number of nodal dimension in mesh
 unsigned nodal_dimension() const;

 /// Add a (pointer to a) node to the mesh
 void add_node_pt(Node* const &node_pt) {Node_pt.push_back(node_pt);}

 /// Add a (pointer to) an element to the mesh
 void add_element_pt(GeneralisedElement* const &element_pt)
  {Element_pt.push_back(element_pt);}

 /// \short Update nodal positions in response to changes in the domain shape.
 /// Uses the FiniteElement::get_x(...) function for FiniteElements
 /// and doesn't do anything for other element types. 
 /// If a MacroElement pointer has been set for a FiniteElement,
 /// the MacroElement representation is used to update the
 /// nodal positions; if not get_x(...) uses the FE interpolation
 /// and thus leaves the nodal positions unchanged.
 /// Virtual, so it can be overloaded by specific meshes,
 /// such as AlgebraicMeshes or SpineMeshes. 
 /// Generally, this function updates the position of all nodes
 /// in response to changes in the boundary position. 
 /// However, we ignore all SolidNodes since their
 /// position is computed as part of the solution -- unless
 /// the bool flag is set to true. Such calls are typically made
 /// when the initial mesh is created and/or after a mesh has been
 /// refined repeatedly before the start of the computation.
 virtual void node_update(const bool& update_all_solid_nodes=false);

 /// \short Re-order nodes in the order in which they appear in elements --
 /// can be overloaded for more efficient re-ordering
 virtual void reorder_nodes(const bool& use_old_ordering=true);

 /// \short Get a reordering of the nodes in the order in which they
 /// appear in elements -- can be overloaded for more efficient
 /// re-ordering
 virtual void get_node_reordering(Vector<Node*> &reordering,
                                  const bool& use_old_ordering=true) const;

 /// \short Constuct a Mesh of FACE_ELEMENTs along the b-th boundary
 /// of the mesh (which contains elements of type BULK_ELEMENT)
 template<class BULK_ELEMENT, template<class> class FACE_ELEMENT>
  void build_face_mesh(const unsigned &b, Mesh* const &face_mesh_pt)
  {
   //Find the number of nodes on the boundary
   unsigned nbound_node = nboundary_node(b);
   //Loop over the boundary nodes and add them to face mesh node pointer
   for(unsigned n=0;n<nbound_node;n++)
    {face_mesh_pt->add_node_pt(boundary_node_pt(b,n));}

   //Find the number of elements next to the boundary
   unsigned nbound_element = nboundary_element(b);
   //Loop over the elements adjacent to boundary b
   for(unsigned e=0;e<nbound_element;e++)
    {
     //Create the FaceElement
     FACE_ELEMENT<BULK_ELEMENT>* face_element_pt =
      new FACE_ELEMENT<BULK_ELEMENT>(boundary_element_pt(b,e),
                                     face_index_at_boundary(b,e));

     //Add the face element to the face mesh
     face_mesh_pt->add_element_pt(face_element_pt);
    }

#ifdef OOMPH_HAS_MPI
   // If the bulk mesh has been distributed then the face mesh is too
   if (this->is_mesh_distributed())
    {
     face_mesh_pt->set_communicator_pt(this->communicator_pt());
    }
#endif
  }

 /// \short Self-test: Check elements and nodes. Return 0 for OK
 unsigned self_test();


 /// \short Determine max and min area for all FiniteElements in the mesh
 /// (non-FiniteElements are ignored)
 void max_and_min_element_size(double& max_size, double& min_size)
 {
  max_size=0.0;
  min_size=DBL_MAX;
  unsigned nel=nelement();
  for (unsigned e=0;e<nel;e++)
   {
    max_size=std::max(max_size,
                      finite_element_pt(e)->size());
    min_size=std::min(min_size,
                      finite_element_pt(e)->size());   }
 }


 /// \short Determine the sum of all "sizes" of the FiniteElements in the mesh
 /// (non-FiniteElements are ignored). This gives the length/area/volume
 /// occupied by the mesh
 double total_size()
 {
  double size=0.0;
  unsigned nel=nelement();
  for (unsigned e=0;e<nel;e++)
   {
    FiniteElement* fe_pt=finite_element_pt(e);
    if (fe_pt!=0)
     {
      size+=fe_pt->size();
     }
   }
  return size;
 }


 /// \short Check for inverted elements and report outcome
 /// in boolean variable. This visits all elements at their
 /// integration points and checks if the Jacobian of the
 /// mapping between local and global coordinates is positive --
 /// using the same test that would be carried out (but only in PARANOID
 /// mode) during the assembly of the elements' Jacobian matrices.
 /// Inverted elements are output in inverted_element_file (if the
 /// stream is open).
 void check_inverted_elements(bool& mesh_has_inverted_elements,
                              std::ofstream& inverted_element_file);


/// \short Check for inverted elements and report outcome
 /// in boolean variable. This visits all elements at their
 /// integration points and checks if the Jacobian of the
 /// mapping between local and global coordinates is positive --
 /// using the same test that would be carried out (but only in PARANOID
 /// mode) during the assembly of the elements' Jacobian matrices.
 void check_inverted_elements(bool& mesh_has_inverted_elements)
 {
  std::ofstream inverted_element_file;
  check_inverted_elements(mesh_has_inverted_elements,
                          inverted_element_file);
 }


 /// \short Check for repeated nodes within a given spatial tolerance.
 /// Return (0/1) for (pass/fail).
 unsigned check_for_repeated_nodes(const double& epsilon=1.0e-12)
  {
   oomph_info <<"\n\nStarting check for repeated nodes...";
   bool failed=false;
   unsigned nnod=nnode();
   for (unsigned j=0;j<nnod;j++)
    {
     Node* nod1_pt=this->node_pt(j);
     unsigned dim=nod1_pt->ndim();
     for (unsigned k=j+1;k<nnod;k++)
      {
       Node* nod2_pt=this->node_pt(k);
       double dist=0.0;
       for (unsigned i=0;i<dim;i++)
        {
         dist+=pow((nod1_pt->x(i)-nod2_pt->x(i)),2);
        }
       dist=sqrt(dist);
       if (dist<epsilon)
        {
         oomph_info << "\n\nRepeated node!" << std::endl;
         oomph_info << "Distance between nodes " << j << " and " << k
                    << std::endl;
         oomph_info << "is " << dist << " which is less than the"
                    << std::endl;
         oomph_info << "permitted distance of " << epsilon
                    << std::endl << std::endl;
         oomph_info << "The offending nodes are located at: " << std::endl;
         for (unsigned i=0;i<dim;i++)
          {
           oomph_info << nod1_pt->x(i) << " ";
          }
         if (nod1_pt->is_a_copy()||
             nod2_pt->is_a_copy())
          {
           oomph_info 
            << "\n\n[NOTE: message issued as diagonistic rather than an error\n"
            << " because at least one of the nodes is a copy; you may still\n"
            << " want to check this out. BACKGROUND: Copied nodes share the same Data but\n"
            << " will, in general, have different spatial positions (e.g. when used\n"
            << " as periodic nodes); however there are cases when they are located\n"
            << " at the same spatial position (e.g. in oomph-lib's annular mesh which\n"
            << " is a rolled-around version of the rectangular quadmesh). In such cases,\n"
            << " the nodes could have been deleted and completely replaced by \n"
            << " pointers to existing nodes, but may have been left there for convenience\n"
            << " or out of laziness...]\n";
          }
         else
          {
           failed=true;
          }
         oomph_info << std::endl << std::endl;

        }
      }
    }
   if (failed) return 1;

   // If we made it to here, we must have passed the test.
   oomph_info <<"...done: Test passed!" << std::endl << std::endl;
   return 0;
  }

 /// \short Prune nodes. Nodes that have been marked as obsolete are removed
 /// from the mesh (and its boundary-node scheme). Returns vector
 /// of pointers to deleted nodes.
 Vector<Node*> prune_dead_nodes();

 /// Return number of boundaries
 unsigned nboundary() const {return Boundary_node_pt.size();}

 /// Return number of nodes on a particular boundary
 unsigned long nboundary_node(const unsigned &ibound) const
  {return Boundary_node_pt[ibound].size();}


 /// Return pointer to e-th finite element on boundary b
 FiniteElement* boundary_element_pt(const unsigned &b, const unsigned &e) const
  {
#ifdef PARANOID
   if (!Lookup_for_elements_next_boundary_is_setup)
    {
     throw OomphLibError(
      "Lookup scheme for elements next to boundary hasn't been set up yet!\n",
      OOMPH_CURRENT_FUNCTION,
      OOMPH_EXCEPTION_LOCATION);
    }
#endif
   return Boundary_element_pt[b][e];
  }


 /// \short Find a node not on any boundary in mesh_pt (useful for pinning
 /// a single node in a purely Neumann problem so that it is fully
 /// determined).
 Node* get_some_non_boundary_node() const
 {
  for(unsigned nd=0, nnd=nnode(); nd<nnd; nd++)
   {
    if( !(node_pt(nd)->is_on_boundary()))
     {
      return node_pt(nd);
     }
   }

  std::ostringstream error_msg;
  error_msg << "No non-boundary nodes in the mesh.";
  throw OomphLibError(error_msg.str(),
                      OOMPH_CURRENT_FUNCTION,
                      OOMPH_EXCEPTION_LOCATION);
  // Never get here!
  return 0;
 }

 /// Return number of finite elements that are adjacent to boundary b
 unsigned nboundary_element(const unsigned &b) const
  {
#ifdef PARANOID
   if (!Lookup_for_elements_next_boundary_is_setup)
    {
     throw OomphLibError(
      "Lookup scheme for elements next to boundary hasn't been set up yet!\n",
      OOMPH_CURRENT_FUNCTION,
      OOMPH_EXCEPTION_LOCATION);
    }
#endif
   return Boundary_element_pt[b].size();
  }


 /// \short For the e-th finite element on boundary b, return int to indicate
 /// the face_index of the face adjacent to the boundary. This is consistent
 /// with input required during the generation of FaceElements.
 int face_index_at_boundary(const unsigned &b, const unsigned &e) const
  {
#ifdef PARANOID
   if (!Lookup_for_elements_next_boundary_is_setup)
    {
     throw OomphLibError(
      "Lookup scheme for elements next to boundary hasn't been set up yet!\n",
      OOMPH_CURRENT_FUNCTION,
      OOMPH_EXCEPTION_LOCATION);
    }
#endif
   return Face_index_at_boundary[b][e];
  }

 /// Dump the data in the mesh into a file for restart
 virtual void dump(std::ofstream &dump_file,
                   const bool& use_old_ordering=true) const;

 /// Dump the data in the mesh into a file for restart
 void dump(const std::string &dump_file_name,
           const bool& use_old_ordering=true) const
 {
  std::ofstream dump_stream(dump_file_name.c_str());
#ifdef PARANOID
  if(!dump_stream.is_open())
   {
    std::string err = "Couldn't open file "+dump_file_name;
    throw OomphLibError(err, OOMPH_EXCEPTION_LOCATION,
                        OOMPH_CURRENT_FUNCTION);
   }
#endif
  dump(dump_stream, use_old_ordering);
 }

 /// \short Read solution from restart file
 virtual void read(std::ifstream &restart_file);


 /// \short Output in paraview format into specified file. Breaks up each
 /// element into sub-elements for plotting purposes. We assume
 /// that all elements are of the same type (fct will break 
 /// break (in paranoid mode) if paraview output fcts of the
 /// elements are inconsistent). 
 void output_paraview(std::ofstream &file_out, 
                      const unsigned &nplot) const;

 /// \short Output in paraview format into specified file. Breaks up each
 /// element into sub-elements for plotting purposes. We assume
 /// that all elements are of the same type (fct will break 
 /// break (in paranoid mode) if paraview output fcts of the
 /// elements are inconsistent). 
 void output_fct_paraview(std::ofstream &file_out, 
 			  const unsigned &nplot,
 			  FiniteElement::SteadyExactSolutionFctPt exact_soln_pt) const;

 /// \short Output in paraview format into specified file. Breaks up each
 /// element into sub-elements for plotting purposes. We assume
 /// that all elements are of the same type (fct will break 
 /// break (in paranoid mode) if paraview output fcts of the
 /// elements are inconsistent). 
 void output_fct_paraview(std::ofstream &file_out, 
 			  const unsigned &nplot,
			  const double& time,
 			  FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt) const;

 /// Output for all elements
 void output(std::ostream &outfile);

 /// Output at f(n_plot) points in each element
 void output(std::ostream &outfile, const unsigned &n_plot);

 /// Output for all elements (C-style output)
 void output(FILE* file_pt);

 /// Output at f(n_plot) points in each element (C-style output)
 void output(FILE* file_pt, const unsigned &nplot);

 /// Output for all elements
 void output(const std::string& output_filename)
  {
   std::ofstream outfile;
   outfile.open(output_filename.c_str());
   output(outfile);
   outfile.close();
  }

 /// Output at f(n_plot) points in each element
 void output(const std::string& output_filename, const unsigned &n_plot)
  {
   std::ofstream outfile;
   outfile.open(output_filename.c_str());
   output(outfile,n_plot);
   outfile.close();
  }

 /// Output a given Vector function at f(n_plot) points in each element
 void output_fct(std::ostream &outfile, const unsigned &n_plot,
                 FiniteElement::SteadyExactSolutionFctPt);

 /// \short Output a given time-dep. Vector function at f(n_plot) points in
 /// each element
 void output_fct(std::ostream &outfile, const unsigned &n_plot,
                 const double& time,
                 FiniteElement::UnsteadyExactSolutionFctPt);

 /// Output the nodes on the boundaries (into separate tecplot zones)
 void output_boundaries(std::ostream &outfile);
 
 /// Output the nodes on the boundaries (into separate tecplot zones).
 /// Specify filename
 void output_boundaries(const std::string& output_filename)
  {
   std::ofstream outfile;
   outfile.open(output_filename.c_str());
   output_boundaries(outfile);
   outfile.close();
  }

 /// \short Assign initial values for an impulsive start
 void assign_initial_values_impulsive();

 ///  \short Shift time-dependent data along for next timestep:
 /// Deal with nodal Data/positions and the element's internal
 /// Data
 void shift_time_values();

 
 /// \short Calculate predictions for all Data and positions associated
 /// with the mesh, usually used in adaptive time-stepping.
 void calculate_predictions();

 /// \short Set the timestepper associated with all nodal and elemental 
 /// data stored in the mesh. 
 void set_nodal_and_elemental_time_stepper(TimeStepper* const &time_stepper_pt,
  const bool &preserve_existing_data)
 {
  this->set_nodal_time_stepper(time_stepper_pt,preserve_existing_data);
  this->set_elemental_internal_time_stepper(time_stepper_pt,
                                            preserve_existing_data);
 }

 /// \short Function that can be used to set any additional timestepper data
 /// stored at the Mesh (as opposed to nodal and elemental) levels. This
 /// is virtual so that it can be overloaded in the appropriate Meshes. 
 /// Examples include the SpineMeshes and adaptive triangle and tet meshes
 virtual void set_mesh_level_time_stepper(TimeStepper* const &time_stepper_pt,
                                          const bool &preserve_existing_data);
 
 /// \short Set consistent values for pinned data in continuation
 void set_consistent_pinned_values_for_continuation(
  ContinuationStorageScheme* const &continuation_stepper_pt);

 /// \short Does the double pointer correspond to any mesh data
 bool does_pointer_correspond_to_mesh_data(double* const &parameter_pt);

 /// \short Set the timestepper associated with the nodal data in the mesh
 void set_nodal_time_stepper(TimeStepper* const &time_stepper_pt,
                             const bool &preserve_existing_data);

 /// \short Set the timestepper associated with the internal data stored
 /// within elements in the meah
 void set_elemental_internal_time_stepper(TimeStepper* const &time_stepper_pt,
                                          const bool &preserve_existing_data);
 
 /// \short Compute norm of solution by summing contributions of
 /// compute_norm(...) for all constituent elements in the mesh.
 /// What that norm means depends on what's defined in the element's
 /// function; may need to take the square root afterwards if the elements
 /// compute the square of the L2 norm, say.
 virtual void compute_norm(double& norm)
  {
   //Initialse the norm
   norm=0.0;

   //Per-element norm
   double el_norm=0;

   //Loop over the elements
   unsigned long n_element = Element_pt.size();
   for(unsigned long e=0;e<n_element;e++)
    {
     GeneralisedElement* el_pt=Element_pt[e];

#ifdef OOMPH_HAS_MPI
     //Compute error for each non-halo element
     if (!(el_pt->is_halo()))
#endif
      {
       el_pt->compute_norm(el_norm);
      }
     norm+=el_norm;
    }
  }

 
 /// \short Compute norm of solution by summing contributions of
 /// compute_norm(...) for all constituent elements in the mesh.
 /// What that norm means depends on what's defined in the element's
 /// function; may need to take the square root afterwards if the elements
 /// compute the square of the L2 norm, say.
 virtual void compute_norm(Vector<double>& norm)
 {
  // How many unknowns are there?
  unsigned n_entry=norm.size();
   
  // Initialse the norm
  norm.initialise(0.0);

  // Per-element norm 
  Vector<double> el_norm(n_entry,0.0);

  // How many elements are there?
  unsigned long n_element=Element_pt.size();
   
  // Loop over the elements
  for (unsigned long e=0;e<n_element;e++)
  {
   // Get a pointer to the e-th generalised element
   GeneralisedElement* el_pt=Element_pt[e];

#ifdef OOMPH_HAS_MPI
   // Compute error for each non-halo element
   if (!(el_pt->is_halo()))
#endif
   {
    // Compute the elemental norm
    el_pt->compute_norm(el_norm);
   }

   // Loop over the norm vector entries
   for (unsigned i=0;i<n_entry;i++)
   {
    // Update the norm of the i-th component
    norm[i]+=el_norm[i];
   }
  } // for (unsigned long e=0;e<n_element;e++)
 } // End of compute_norm


 /// \short Plot error when compared against a given exact solution.
 ///  Also returns the norm  of the error and that of the exact solution
 virtual void compute_error(std::ostream &outfile,
                            FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt,
                            const double& time,
                            double& error, double& norm)
  {
   //Initialse the norm and error
   norm=0.0; error=0.0;
   //Per-element norm and error
   double el_error,el_norm;

   //Loop over the elements
   unsigned long Element_pt_range = Element_pt.size();
   for(unsigned long e=0;e<Element_pt_range;e++)
    {
     // Try to cast to FiniteElement
     FiniteElement* el_pt=dynamic_cast<FiniteElement*>(Element_pt[e]);
     if (el_pt==0)
      {
       throw OomphLibError(
        "Can't execute compute_error(...) for non FiniteElements",
        OOMPH_CURRENT_FUNCTION,
        OOMPH_EXCEPTION_LOCATION);
      }

     // Reset elemental errors and norms
     el_norm=0.0;
     el_error=0.0;
#ifdef OOMPH_HAS_MPI
     //Compute error for each non-halo element
     if (!(el_pt->is_halo()))
#endif
      {
       el_pt->compute_error(outfile,exact_soln_pt,time,el_error,el_norm);
      }
     //Add each element error to the global errors
     norm+=el_norm; error+=el_error;
    }
  }

 /// \short Plot error when compared against a given time-depdendent
 ///  exact solution. Also returns the norm  of the error and
 ///  that of the exact solution
 virtual void compute_error(std::ostream &outfile,
                            FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,
                            double& error, double& norm)
  {
   //Initialise norm and error
   norm=0.0; error=0.0;
   //Per-element norm and error
   double el_error,el_norm;

   //Loop over the elements
   unsigned long Element_pt_range = Element_pt.size();
   for(unsigned long e=0;e<Element_pt_range;e++)
    {
     // Try to cast to FiniteElement
     FiniteElement* el_pt=dynamic_cast<FiniteElement*>(Element_pt[e]);
     if (el_pt==0)
      {
       throw OomphLibError(
        "Can't execute compute_error(...) for non FiniteElements",
        OOMPH_CURRENT_FUNCTION,
        OOMPH_EXCEPTION_LOCATION);
      }
     // Reset elemental errors and norms
     el_norm=0.0;
     el_error=0.0;
     //Calculate the elemental errors for each non-halo element
#ifdef OOMPH_HAS_MPI
     if (!(el_pt->is_halo()))
#endif
      {
       el_pt->compute_error(outfile,exact_soln_pt,el_error,el_norm);
      }
     //Add each elemental error to the global error
     norm+=el_norm; error+=el_error;
    }
  }
 

 /// \short Plot error when compared against a given time-dependent
 /// exact solution. Also returns the norm of the error and
 /// that of the exact solution
 virtual void compute_error(FiniteElement::SteadyExactSolutionFctPt
			    exact_soln_pt,double& error,double& norm)
  {
   // Initialise norm and error
   norm=0.0;
   error=0.0;
   
   // Per-element norm and error
   double el_error,el_norm;

   // Loop over the elements
   unsigned long Element_pt_range = Element_pt.size();
   for(unsigned long e=0;e<Element_pt_range;e++)
   {
    // Try to cast to FiniteElement
    FiniteElement* el_pt=dynamic_cast<FiniteElement*>(Element_pt[e]);
    if (el_pt==0)
    {
     throw OomphLibError(
      "Can't execute compute_error(...) for non FiniteElements",
      OOMPH_CURRENT_FUNCTION,
      OOMPH_EXCEPTION_LOCATION);
    }
     
    // Reset elemental errors and norms
    el_norm=0.0;
    el_error=0.0;
     
    //Calculate the elemental errors for each non-halo element
#ifdef OOMPH_HAS_MPI
    if (!(el_pt->is_halo()))
#endif
    {
     el_pt->compute_error(exact_soln_pt,el_error,el_norm);
    }
     
    // Add each elemental error to the global error
    norm+=el_norm; error+=el_error;
   }
  } // End of compute_error
 

 /// \short Plot error when compared against a given time-dependent
 /// exact solution. Also returns the norm of the error and
 /// that of the exact solution
 virtual void compute_error(FiniteElement::SteadyExactSolutionFctPt
			    exact_soln_pt,
			    Vector<double>& error,
			    Vector<double>& norm)
 {
  // Initialise norm vector entries
  norm.initialise(0.0);
   
  // Initialise error vector entries
  error.initialise(0.0);
   
  // Norm vector size
  unsigned n_norm=norm.size();
   
  // Error vector size
  unsigned n_error=error.size();
   
  // Per-element norm and error
  Vector<double> el_norm(n_norm,0.0);
   
  // Per-element norm and error
  Vector<double> el_error(n_error,0.0);

  // How many elements are there?
  unsigned long element_pt_range=Element_pt.size();
   
  // Loop over the elements
  for (unsigned long e=0;e<element_pt_range;e++)
  {
   // Try to cast to FiniteElement
   FiniteElement* el_pt=dynamic_cast<FiniteElement*>(Element_pt[e]);
   if (el_pt==0)
   {
    throw OomphLibError(
     "Can't execute compute_error(...) for non FiniteElements",
     OOMPH_CURRENT_FUNCTION,
     OOMPH_EXCEPTION_LOCATION);
   }
     
   // Re-initialise norm vector entries
   el_norm.initialise(0.0);
   
   // Re-initialise error vector entries
   el_error.initialise(0.0);
        
   //Calculate the elemental errors for each non-halo element
#ifdef OOMPH_HAS_MPI
   if (!(el_pt->is_halo()))
#endif
   {
    el_pt->compute_error(exact_soln_pt,el_error,el_norm);
   }    
    
   // Add each elemental norm contribution to the global norm
   for(unsigned i=0;i<n_norm;i++)
   {
    norm[i]+=el_norm[i];
   }
    
   //Add each elemental error contribution to the global error
   for(unsigned i=0;i<n_error;i++)
   {
    error[i]+=el_error[i];
   }
  } // for (unsigned long e=0;e<element_pt_range;e++)
 } // End of compute_error
 

 /// \short Plot error when compared against a given time-depdendent
 ///  exact solution. Also returns the norm  of the error and
 ///  that of the exact solution. Version with vectors of norms and errors so
 ///  that different variables' norms and errors can be returned individually
 virtual void compute_error(
   std::ostream &outfile,
   FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt,
   const double& time,
   Vector<double>& error, Vector<double>& norm)
  {
   //Initialise norm and error
   unsigned n_error=error.size();
   unsigned n_norm=norm.size();
   for(unsigned i=0;i<n_error;i++)
    {
     error[i]=0.0;
    }
   for(unsigned i=0;i<n_norm;i++)
    {
     norm[i]=0.0;
    }
   //Per-element norm and error
   Vector<double> el_error(n_error),el_norm(n_norm);

   //Loop over the elements
   unsigned long Element_pt_range = Element_pt.size();
   for(unsigned long e=0;e<Element_pt_range;e++)
    {
     // Try to cast to FiniteElement
     FiniteElement* el_pt=dynamic_cast<FiniteElement*>(Element_pt[e]);
     if (el_pt==0)
      {
       throw OomphLibError(
        "Can't execute compute_error(...) for non FiniteElements",
        OOMPH_CURRENT_FUNCTION,
        OOMPH_EXCEPTION_LOCATION);
      }
     // Reset elemental errors and norms
     for(unsigned i=0;i<n_error;i++)
      {
       el_error[i]=0.0;
      }
     for(unsigned i=0;i<n_norm;i++)
      {
       el_norm[i]=0.0;
      }
     //Calculate the elemental errors for each non-halo element
#ifdef OOMPH_HAS_MPI
     if (!(el_pt->is_halo()))
#endif
      {
       el_pt->compute_error(outfile,exact_soln_pt,time,el_error,el_norm);
      }
     //Add each elemental error to the global error
     for(unsigned i=0;i<n_error;i++)
      {
       error[i]+=el_error[i];
      }
     for(unsigned i=0;i<n_norm;i++)
      {
       norm[i]+=el_norm[i];
      }
    }
  }

 /// \short Plot error when compared against a given time-depdendent
 ///  exact solution. Also returns the norm  of the error and
 ///  that of the exact solution. Version with vectors of norms and errors so
 ///  that different variables' norms and errors can be returned individually
 virtual void compute_error(std::ostream &outfile,
                            FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,
                            Vector<double>& error, Vector<double>& norm)
  {
   //Initialise norm and error
   unsigned n_error=error.size();
   unsigned n_norm=norm.size();
   for(unsigned i=0;i<n_error;i++)
    {
     error[i]=0.0;
    }
   for(unsigned i=0;i<n_norm;i++)
    {
     norm[i]=0.0;
    }
   //Per-element norm and error
   Vector<double> el_error(n_error),el_norm(n_norm);

   //Loop over the elements
   unsigned long Element_pt_range = Element_pt.size();
   for(unsigned long e=0;e<Element_pt_range;e++)
    {
     // Try to cast to FiniteElement
     FiniteElement* el_pt=dynamic_cast<FiniteElement*>(Element_pt[e]);
     if (el_pt==0)
      {
       throw OomphLibError(
        "Can't execute compute_error(...) for non FiniteElements",
        OOMPH_CURRENT_FUNCTION,
        OOMPH_EXCEPTION_LOCATION);
      }
     // Reset elemental errors and norms
     for(unsigned i=0;i<n_error;i++)
      {
       el_error[i]=0.0;
      }
     for(unsigned i=0;i<n_norm;i++)
      {
       el_norm[i]=0.0;
      }
     //Calculate the elemental errors for each non-halo element
#ifdef OOMPH_HAS_MPI
     if (!(el_pt->is_halo()))
#endif
      {
       el_pt->compute_error(outfile,exact_soln_pt,el_error,el_norm);
      }
     //Add each elemental error to the global error
     for(unsigned i=0;i<n_error;i++)
      {
       error[i]+=el_error[i];
      }
     for(unsigned i=0;i<n_norm;i++)
      {
       norm[i]+=el_norm[i];
      }
    }
  }

 /// \short Returns the norm of the error and that of the exact solution
 virtual void compute_error(FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt,
                            const double& time, double& error, double& norm)
  {
   //Initialse the norm and error
   norm=0.0; error=0.0;
   //Per-element norm and error
   double el_error,el_norm;

   //Loop over the elements
   unsigned long Element_pt_range = Element_pt.size();
   for(unsigned long e=0;e<Element_pt_range;e++)
   {
    // Try to cast to FiniteElement
    FiniteElement* el_pt=dynamic_cast<FiniteElement*>(Element_pt[e]);
    if (el_pt==0)
    {
     throw OomphLibError(
      "Can't execute compute_error(...) for non FiniteElements",
      OOMPH_CURRENT_FUNCTION,
      OOMPH_EXCEPTION_LOCATION);
    }

    // Reset elemental errors and norms
    el_norm=0.0;
    el_error=0.0;
#ifdef OOMPH_HAS_MPI
    //Compute error for each non-halo element
    if (!(el_pt->is_halo()))
#endif
    {
     el_pt->compute_error(exact_soln_pt,time,el_error,el_norm);
    }
    //Add each element error to the global errors
    norm+=el_norm; error+=el_error;
   }
  }
 

 /// \short Returns the norm of the error and that of the exact solution.
 /// Version with vectors of norms and errors so that different variables'
 /// norms and errors can be returned individually
 virtual void compute_error(FiniteElement::UnsteadyExactSolutionFctPt
			    exact_soln_pt,
			    const double& time,
			    Vector<double>& error,
			    Vector<double>& norm)
  {
   // Initialise norm and error
   unsigned n_error=error.size();
   unsigned n_norm=norm.size();
   for(unsigned i=0;i<n_error;i++)
   {
    error[i]=0.0;
   }
   for(unsigned i=0;i<n_norm;i++)
   {
    norm[i]=0.0;
   }
   // Per-element norm and error
   Vector<double> el_error(n_error),el_norm(n_norm);

   // Loop over the elements
   unsigned long Element_pt_range = Element_pt.size();
   for (unsigned long e=0;e<Element_pt_range;e++)
   {
    // Try to cast to FiniteElement
    FiniteElement* el_pt=dynamic_cast<FiniteElement*>(Element_pt[e]);
    if (el_pt==0)
    {
     throw OomphLibError(
      "Can't execute compute_error(...) for non FiniteElements",
      OOMPH_CURRENT_FUNCTION,
      OOMPH_EXCEPTION_LOCATION);
    }
    // Reset elemental errors and norms
    for(unsigned i=0;i<n_error;i++)
    {
     el_error[i]=0.0;
    }
    for(unsigned i=0;i<n_norm;i++)
    {
     el_norm[i]=0.0;
    }
    //Calculate the elemental errors for each non-halo element
#ifdef OOMPH_HAS_MPI
    if (!(el_pt->is_halo()))
#endif
    {
     el_pt->compute_error(exact_soln_pt,time,el_error,el_norm);
    }
    //Add each elemental error to the global error
    for(unsigned i=0;i<n_error;i++)
    {
     error[i]+=el_error[i];
    }
    for(unsigned i=0;i<n_norm;i++)
    {
     norm[i]+=el_norm[i];
    }
   } // for (unsigned long e=0;e<Element_pt_range;e++)
  } // End of compute_error
 

 /// Boolean to indicate if Mesh has been distributed
 bool is_mesh_distributed() const 
 {
#ifdef OOMPH_HAS_MPI
  return communicator_pt() != 0; 
#else
  // Can't be distributed without mpi
  return false;
#endif
 }

 /// Read-only access fct to communicator (Null if mesh is not distributed,
 /// i.e. if we don't have mpi).
 OomphCommunicator* communicator_pt() const 
 {
#ifdef OOMPH_HAS_MPI 
  return Comm_pt;
#else
  return 0;
#endif
 }


#ifdef OOMPH_HAS_MPI

 /// Function to set communicator (mesh is assumed to be distributed if the
 /// communicator pointer is non-null). Only defined if mpi is enabled
 /// becaus Comm_pt itself is only defined when mpi is enabled.
 void set_communicator_pt(OomphCommunicator* comm_pt) {Comm_pt = comm_pt;} 

 /// \short Call this function to keep all the elements as halo elements
 void set_keep_all_elements_as_halos() {Keep_all_elements_as_halos=true;}

 /// \short Calll this function to unset the flag that keeps all elements
 /// in the mesh as halo elements
 void unset_keep_all_elements_as_halos() {Keep_all_elements_as_halos=false;}

 /// \short Distribute the problem and doc; make this virtual to allow
 /// overloading for particular meshes where further work is required.
 /// Add to vector of pointers to deleted elements.
 virtual void distribute(OomphCommunicator* comm_pt,
                         const Vector<unsigned>& element_domain,
                         Vector<GeneralisedElement*>& deleted_element_pt,
                         DocInfo& doc_info,
                         const bool& report_stats,
                         const bool& overrule_keep_as_halo_element_status);

 /// \short Distribute the problem
 /// Add to vector of pointers to deleted elements.
 void distribute(OomphCommunicator* comm_pt,
                 const Vector<unsigned>& element_domain,
                 Vector<GeneralisedElement*>& deleted_element_pt,
                 const bool& report_stats=false)
 {
   DocInfo doc_info;
   doc_info.disable_doc();
   bool overrule_keep_as_halo_element_status=false;
   return distribute(comm_pt,element_domain,deleted_element_pt,
                     doc_info,report_stats,
                     overrule_keep_as_halo_element_status);
  }

 /// \short (Irreversibly) prune halo(ed) elements and nodes, usually
 /// after another round of refinement, to get rid of
 /// excessively wide halo layers. Note that the current
 /// mesh will be now regarded as the base mesh and no unrefinement
 /// relative to it will be possible once this function
 /// has been called.
 void prune_halo_elements_and_nodes(Vector<GeneralisedElement*>&
                                    deleted_element_pt,
                                    const bool& report_stats=false)
  {
   DocInfo doc_info;
   doc_info.disable_doc();
   prune_halo_elements_and_nodes(deleted_element_pt,
                                 doc_info,report_stats);
  }


 /// \short (Irreversibly) prune halo(ed) elements and nodes, usually
 /// after another round of refinement, to get rid of
 /// excessively wide halo layers. Note that the current
 /// mesh will be now regarded as the base mesh and no unrefinement
 /// relative to it will be possible once this function
 /// has been called.
 void prune_halo_elements_and_nodes(Vector<GeneralisedElement*>&
                                    deleted_element_pt,
                                    DocInfo& doc_info,
                                    const bool& report_stats);

 /// \short Get efficiency of mesh distribution: In an ideal distribution
 /// without halo overhead, each processor would only hold its own
 /// elements. Efficieny per processor =  (number of non-halo elements)/
 /// (total number of elements).
 void get_efficiency_of_mesh_distribution(double& av_efficiency,
                                          double& max_efficiency,
                                          double& min_efficiency);

 /// Doc the mesh distribution, to be processed with tecplot macros
 void doc_mesh_distribution(DocInfo& doc_info);

 /// Check halo and shared schemes on the mesh
 void check_halo_schemes(DocInfo& doc_info,
                         double& max_permitted_error_for_halo_check);

 /// \short Classify the halo and haloed nodes in the mesh. Virtual
 /// so it can be overloaded to perform additional functionality
 /// (such as synchronising hanging nodes) in refineable meshes, say.
 virtual void classify_halo_and_haloed_nodes(DocInfo& doc_info,
                                             const bool& report_stats);

 /// Classify the halo and haloed nodes in the mesh. Virtual
 /// so it can be overloaded to perform additional functionality
 /// (such as synchronising hanging nodes) in refineable meshes, say.
 virtual void classify_halo_and_haloed_nodes(const bool& report_stats=false)
  {
   DocInfo doc_info;
   doc_info.disable_doc();
   classify_halo_and_haloed_nodes(doc_info,report_stats);
  }

 /// \short Synchronise shared node lookup schemes to cater for the
 /// the case where:
 /// (1) a certain node on the current processor is halo with proc p
 ///     (i.e. its non-halo counterpart lives on processor p)
 /// (2) that node is also exists (also as a halo) on another processor
 ///     (q, say) where its non-halo counter part is also known to be
 ///     on processor p.
 /// However, without calling this function the current processor does not
 /// necessarily know that it shares a node with processor q. This
 /// information can be required, e.g. when synchronising hanging node
 /// schemes over all processors.
 void synchronise_shared_nodes(const bool& report_stats);


 /// \short Get all the halo data stored in the mesh and add pointers to
 /// the data to the map, indexed by global equation number
 void get_all_halo_data(std::map<unsigned,double*> &map_of_halo_data);

 /// \short Return vector of halo elements in this Mesh
 /// whose non-halo counterpart is held on processor p.
 Vector<GeneralisedElement*> halo_element_pt(const unsigned& p)
  {
   // Prepare vector
   Vector<GeneralisedElement*> vec_el_pt;

   // Loop over all root halo elements
   unsigned nelem=nroot_halo_element(p);
   for (unsigned e=0;e<nelem;e++)
    {
     GeneralisedElement* el_pt=root_halo_element_pt(p,e);

     // Is it a refineable element?
     RefineableElement* ref_el_pt=dynamic_cast<RefineableElement*>(el_pt);
     if (ref_el_pt!=0)
      {
       // Vector of pointers to leaves in tree emanating from
       // current root halo element
       Vector<Tree*> leaf_pt;
       ref_el_pt->tree_pt()->stick_leaves_into_vector(leaf_pt);

       // Loop over leaves and add their objects (the finite elements)
       // to vector
       unsigned nleaf=leaf_pt.size();
       for (unsigned l=0;l<nleaf;l++)
        {
         vec_el_pt.push_back(leaf_pt[l]->object_pt());
        }
      }
     else
      {
       vec_el_pt.push_back(el_pt);
      }
    }
   return vec_el_pt;
  }


 /// \short Return vector of haloed elements in this Mesh
 /// whose haloing counterpart is held on processor p.
 Vector<GeneralisedElement*> haloed_element_pt(const unsigned& p)
  {
   // Prepare vector
   Vector<GeneralisedElement*> vec_el_pt;

   // Loop over all root haloed elements
   unsigned nelem=nroot_haloed_element(p);
   for (unsigned e=0;e<nelem;e++)
    {
     GeneralisedElement* el_pt=root_haloed_element_pt(p,e);

     // Is it a refineable element?
     RefineableElement* ref_el_pt=dynamic_cast<RefineableElement*>(el_pt);
     if (ref_el_pt!=0)
      {
       // Vector of pointers to leaves in tree emanating from
       // current root haloed element
       Vector<Tree*> leaf_pt;
       ref_el_pt->tree_pt()->stick_leaves_into_vector(leaf_pt);

       // Loop over leaves and add their objects (the finite elements)
       // to vector
       unsigned nleaf=leaf_pt.size();
       for (unsigned l=0;l<nleaf;l++)
        {
         vec_el_pt.push_back(leaf_pt[l]->object_pt());
        }
      }
     else
      {
       vec_el_pt.push_back(el_pt);
      }
    }
   return vec_el_pt;
  }

 /// \short Total number of non-halo elements in this mesh (Costly call computes
 /// result on the fly)
 unsigned nnon_halo_element()
  {
   unsigned count=0;
   unsigned n=nelement();
   for (unsigned e=0;e<n;e++)
    {
     if (!(element_pt(e)->is_halo())) count++;
    }
   return count;
  }


 /// \short Total number of root halo elements in this Mesh
 unsigned nroot_halo_element()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<GeneralisedElement*> >::iterator it=
         Root_halo_element_pt.begin();it!=Root_halo_element_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }


 /// \short Number of root halo elements in this Mesh whose non-halo
 /// counterpart is held on processor p.
 unsigned nroot_halo_element(const unsigned& p)
  {
   return Root_halo_element_pt[p].size();
  }


 /// \short Vector of pointers to root halo elements in this Mesh
 /// whose non-halo counterpart is held on processor p.
 Vector<GeneralisedElement*> root_halo_element_pt(const unsigned& p)
  {
   return Root_halo_element_pt[p];
  }


 /// \short Access fct to the e-th root halo element in this Mesh
 /// whose non-halo counterpart is held on processor p.
 GeneralisedElement* &root_halo_element_pt(const unsigned& p,
                                           const unsigned& e)
  {
   return Root_halo_element_pt[p][e];
  }


 /// \short Add root halo element whose non-halo counterpart is held
 /// on processor p to this Mesh.
 void add_root_halo_element_pt(const unsigned& p, GeneralisedElement*& el_pt)
  {
   Root_halo_element_pt[p].push_back(el_pt);
   el_pt->set_halo(p);
  }

 /// \short Total number of halo nodes in this Mesh
 unsigned nhalo_node()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<Node*> >::iterator it=
         Halo_node_pt.begin();it!=Halo_node_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }

 /// \short Number of halo nodes in this Mesh whose non-halo counterpart
 /// is held on processor p.
 unsigned nhalo_node(const unsigned& p)
  {
   //Memory saving version of: return Halo_node_pt[p].size();
   std::map<unsigned, Vector<Node*> >::iterator it=
    Halo_node_pt.find(p);
   if (it==Halo_node_pt.end())
    {
     return 0;
    }
   return (*it).second.size();
  }

 /// \short Add halo node whose non-halo counterpart is held
 /// on processor p to the storage scheme for halo nodes.
 void add_halo_node_pt(const unsigned& p, Node*& nod_pt)
  {
   Halo_node_pt[p].push_back(nod_pt);
  }


 /// \short  Access fct to the j-th halo node in this Mesh
 /// whose non-halo counterpart is held on processor p.
 Node* halo_node_pt(const unsigned& p, const unsigned& j)
  {
   return Halo_node_pt[p][j];
  }


 /// \short Total number of root haloed elements in this Mesh
 unsigned nroot_haloed_element()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<GeneralisedElement*> >::iterator it=
         Root_haloed_element_pt.begin();it!=Root_haloed_element_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }

 /// \short Number of root haloed elements in this Mesh whose non-halo
 /// counterpart is held on processor p.
 unsigned nroot_haloed_element(const unsigned& p)
  {
   //Memory saving version of: return Root_haloed_element_pt[p].size();
   std::map<unsigned, Vector<GeneralisedElement*> >::iterator it=
    Root_haloed_element_pt.find(p);
   if (it==Root_haloed_element_pt.end())
    {
     return 0;
    }
   return (*it).second.size();
  }


 /// \short Vector of pointers to root haloed elements in this Mesh
 /// whose non-halo counterpart is held on processor p.
 Vector<GeneralisedElement*> root_haloed_element_pt(const unsigned& p)
  {
   //Memory saving version of:  return Root_haloed_element_pt[p];
   std::map<unsigned, Vector<GeneralisedElement*> >::iterator it=
    Root_haloed_element_pt.find(p);
   if (it==Root_haloed_element_pt.end())
    {
     Vector<GeneralisedElement*> tmp;
     return tmp;
    }
   return (*it).second;
  }

 /// \short Access fct to the e-th root haloed element in this Mesh
 /// whose non-halo counterpart is held on processor p.
 GeneralisedElement* &root_haloed_element_pt(const unsigned& p,
                                             const unsigned& e)
  {
   return Root_haloed_element_pt[p][e];
  }

 /// \short Add root haloed element whose non-halo counterpart is held
 /// on processor p to the storage scheme for haloed elements.
 /// Note: This does not add the element to the storage scheme
 /// for elements as it's understood to naturally live on this
 /// processor anyway!
 void add_root_haloed_element_pt(const unsigned& p, GeneralisedElement*& el_pt)
  {
   Root_haloed_element_pt[p].push_back(el_pt);
  }


 /// \short Total number of haloed nodes in this Mesh
 unsigned nhaloed_node()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<Node*> >::iterator it=
         Haloed_node_pt.begin();it!=Haloed_node_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }


 /// \short Number of haloed nodes in this Mesh whose haloed counterpart
 /// is held on processor p.
 unsigned nhaloed_node(const unsigned& p)
  {
   // Memory saving version of: return Haloed_node_pt[p].size();
   std::map<unsigned, Vector<Node*> >::iterator it=
    Haloed_node_pt.find(p);
   if (it==Haloed_node_pt.end())
    {
     return 0;
    }
   return (*it).second.size();
  }

 /// \short Access fct to the j-th haloed node in this Mesh
 /// whose halo counterpart is held on processor p.
 Node* haloed_node_pt(const unsigned& p, const unsigned& j)
  {
   return Haloed_node_pt[p][j];
  }

 /// \short Add haloed node whose halo counterpart is held
 /// on processor p to the storage scheme for haloed nodes.
 void add_haloed_node_pt(const unsigned& p, Node*& nod_pt)
  {
   Haloed_node_pt[p].push_back(nod_pt);
  }

 /// Bool for output of halo elements
 bool Output_halo_elements;


 /// \short Function to suppress resizing of halo nodes -- optmisation
 /// but call it at your own risk!
 void disable_resizing_of_halo_nodes()
 {
  Resize_halo_nodes_not_required=true;
 }


 /// \short Function to (re-)enable resizing of halo nodes -- this returns
 /// things to the default behaviour.
 void enable_resizing_of_halo_nodes()
 {
  Resize_halo_nodes_not_required=false;
 }

 /// Function to disable halo element output
 void disable_output_of_halo_elements()
  {
   Output_halo_elements=false;
  }

 /// Function to enable halo element output
 void enable_output_of_halo_elements()
  {
   Output_halo_elements=true;
  }

 /// \short Total number of shared nodes in this Mesh
 unsigned nshared_node()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<Node*> >::iterator it=
         Shared_node_pt.begin();it!=Shared_node_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }

 /// \short Doc shared nodes
 void doc_shared_nodes()
  {
   for (std::map<unsigned,Vector<Node*> >::iterator it=
         Shared_node_pt.begin();it!=Shared_node_pt.end();it++)
    {
     unsigned n=it->second.size();
     for (unsigned j=0;j<n;j++)
      {
       oomph_info << "Shared node with proc " << it->first << " ";
       Node* nod_pt=it->second[j];
       unsigned ndim=nod_pt->ndim();
       for (unsigned i=0;i<ndim;i++)
        {
         oomph_info << nod_pt->x(i) << " ";
        }
       oomph_info << nod_pt->is_hanging() << " ";
       oomph_info << j << " " << nod_pt << std::endl;
      }
    }
  }

 /// \short Number of shared nodes in this Mesh who have a counterpart
 /// on processor p.
 unsigned nshared_node(const unsigned& p)
  {
   // Memory saving version of: return Shared_node_pt[p].size();
   std::map<unsigned, Vector<Node*> >::iterator it=
    Shared_node_pt.find(p);
   if (it==Shared_node_pt.end())
    {
     return 0;
    }
   return (*it).second.size();
  }

 /// \short Access fct to the j-th shared node in this Mesh
 /// who has a counterpart on processor p.
 Node* shared_node_pt(const unsigned& p, const unsigned& j)
  {
   return Shared_node_pt[p][j];
  }

 /// \short Get vector of pointers to shared nodes with processor p.
 /// Required for faster search in
 /// Missing_masters_functions::add_external_haloed_node_helper() and
 /// Missing_masters_functions::add_external_haloed_master_node_helper()
 void get_shared_node_pt(const unsigned& p, Vector<Node*>& shared_node_pt)
 {
  unsigned np=nshared_node(p);
  shared_node_pt.resize(np);
  for (unsigned j=0;j<np;j++)
   {
    shared_node_pt[j] = Shared_node_pt[p][j];
   }
 }


 /// \short Add shared node whose counterpart is held
 /// on processor p to the storage scheme for shared nodes.
 /// (NB: ensure that this routine is called twice, once for each process)
 void add_shared_node_pt(const unsigned& p, Node*& nod_pt)
  {
   Shared_node_pt[p].push_back(nod_pt);
  }

 /// \short Get halo node stats for this distributed mesh:
 /// Average/max/min number of halo nodes over all processors.
 /// \b Careful: Involves MPI Broadcasts and must therefore
 /// be called on all processors!
 void get_halo_node_stats(double& av_number,
                          unsigned& max_number,
                          unsigned& min_number);

 /// \short Get haloed node stats for this distributed mesh:
 /// Average/max/min number of haloed nodes over all processors.
 /// \b Careful: Involves MPI Broadcasts and must therefore
 /// be called on all processors!
 void get_haloed_node_stats(double& av_number,
                            unsigned& max_number,
                            unsigned& min_number);

 // External halo(ed) elements are "source/other" elements which are
 // on different processes to the element for which they are the source

 /// \short Output all external halo elements
 void output_external_halo_elements(std::ostream &outfile,
                                    const unsigned &n_plot=5)
 {
  for (std::map<unsigned,Vector<GeneralisedElement*> >::iterator it=
        External_halo_element_pt.begin();
       it!=External_halo_element_pt.end();it++)
   {
    unsigned p=(*it).first;
    output_external_halo_elements(p,outfile,n_plot);
   }
 }

 /// \short Output all external halo elements with processor p
 void output_external_halo_elements(const unsigned& p, std::ostream &outfile,
                                    const unsigned &n_plot=5)
 {
  unsigned nel=External_halo_element_pt[p].size();
  for (unsigned e=0;e<nel;e++)
   {
    FiniteElement* fe_pt=dynamic_cast<FiniteElement*>(
     External_halo_element_pt[p][e]);
    if (fe_pt!=0)
     {
      fe_pt->output(outfile,n_plot);
     }
   }
 }


 /// \short Output all external haloed elements
 void output_external_haloed_elements(std::ostream &outfile,
                                      const unsigned &n_plot=5)
 {
  for (std::map<unsigned,Vector<GeneralisedElement*> >::iterator it=
        External_haloed_element_pt.begin();
       it!=External_haloed_element_pt.end();it++)
   {
    unsigned p=(*it).first;
    output_external_haloed_elements(p,outfile,n_plot);
   }
 }

 /// \short Output all external haloed elements with processor p
 void output_external_haloed_elements(const unsigned& p, std::ostream &outfile,
                                      const unsigned &n_plot=5)
 {
  unsigned nel=External_haloed_element_pt[p].size();
  for (unsigned e=0;e<nel;e++)
   {
    FiniteElement* fe_pt=dynamic_cast<FiniteElement*>(
     External_haloed_element_pt[p][e]);
    if (fe_pt!=0)
     {
      fe_pt->output(outfile,n_plot);
     }
   }
 }


 /// \short Total number of external halo elements in this Mesh
 unsigned nexternal_halo_element()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<GeneralisedElement*> >::iterator it=
         External_halo_element_pt.begin();
        it!=External_halo_element_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }

 /// \short Number of external halo elements in this Mesh whose non-halo
 /// counterpart is held on processor p.
 unsigned nexternal_halo_element(const unsigned& p)
  {
   // Memory saving version of: return External_halo_element_pt[p].size();
   std::map<unsigned, Vector<GeneralisedElement*> >::iterator it=
    External_halo_element_pt.find(p);
   if (it==External_halo_element_pt.end())
    {
     return 0;
    }
   return (*it).second.size();
  }

 /// \short Access fct to the e-th external halo element in this Mesh
 /// whose non-halo counterpart is held on processor p.
 GeneralisedElement* &external_halo_element_pt(const unsigned& p,
                                              const unsigned& e)
  {
   return External_halo_element_pt[p][e];
  }

 /// \short Add external halo element whose non-halo counterpart is held
 /// on processor p to this Mesh.
 void add_external_halo_element_pt(const unsigned& p,
                                   GeneralisedElement*& el_pt)
  {
   External_halo_element_pt[p].push_back(el_pt);
   el_pt->set_halo(p);
  }

 /// \short Total number of external haloed elements in this Mesh
 unsigned nexternal_haloed_element()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<GeneralisedElement*> >::iterator it=
         External_haloed_element_pt.begin();
        it!=External_haloed_element_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }

 /// \short Number of external haloed elements in this Mesh whose non-halo
 /// counterpart is held on processor p.
 unsigned nexternal_haloed_element(const unsigned& p)
  {
   // Memory saving version of: return External_haloed_element_pt[p].size();
   std::map<unsigned, Vector<GeneralisedElement*> >::iterator it=
    External_haloed_element_pt.find(p);
   if (it==External_haloed_element_pt.end())
    {
     return 0;
    }
   return (*it).second.size();
  }

 /// \short Access fct to the e-th external haloed element in this Mesh
 /// whose non-halo counterpart is held on processor p.
 GeneralisedElement* &external_haloed_element_pt(const unsigned& p,
                                                 const unsigned& e)
  {
   return External_haloed_element_pt[p][e];
  }

 /// \short Add external haloed element whose non-halo counterpart is held
 /// on processor p to the storage scheme for haloed elements.
 unsigned add_external_haloed_element_pt(const unsigned& p,
                                         GeneralisedElement*& el_pt);

 /// \short Total number of external halo nodes in this Mesh
 unsigned nexternal_halo_node()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<Node*> >::iterator it=
         External_halo_node_pt.begin();it!=External_halo_node_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }


 /// \short Get vector of pointers to all external halo nodes
 void get_external_halo_node_pt(Vector<Node*>& external_halo_node_pt)
 {
  unsigned n_total=nexternal_halo_node();
  external_halo_node_pt.reserve(n_total);
  for (std::map<unsigned,Vector<Node*> >::iterator it=
        External_halo_node_pt.begin();it!=External_halo_node_pt.end();it++)
   {
    unsigned np=(it->second).size();
    for (unsigned j=0;j<np;j++)
     {
      external_halo_node_pt.push_back((it->second)[j]);
     }
   }
#ifdef PARANOID
  if (external_halo_node_pt.size()!=n_total)
   {
    std::ostringstream error_stream;
    error_stream
     << "Total number of external halo nodes, "
     << n_total << " doesn't match number of entries \n in vector, "
     << external_halo_node_pt.size() << std::endl;
    throw OomphLibError(error_stream.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif
 }


 /// \short Number of external halo nodes in this Mesh whose non-halo
 /// (external) counterpart is held on processor p.
 unsigned nexternal_halo_node(const unsigned& p)
 {
  // Memory saving version of: return External_halo_node_pt[p].size();
  std::map<unsigned, Vector<Node*> >::iterator it=
   External_halo_node_pt.find(p);
  if (it==External_halo_node_pt.end())
   {
    return 0;
   }
  return (*it).second.size();
 }

 /// \short Add external halo node whose non-halo (external) counterpart
 /// is held on processor p to the storage scheme for halo nodes.
 void add_external_halo_node_pt(const unsigned& p, Node*& nod_pt)
  {
   External_halo_node_pt[p].push_back(nod_pt);
   nod_pt->set_halo(p);
  }


 /// \short Access fct to the j-th external halo node in this Mesh
 /// whose non-halo external counterpart is held on processor p.
 Node* &external_halo_node_pt(const unsigned& p, const unsigned& j)
  {
   return External_halo_node_pt[p][j];
  }

 /// \short Access fct to vector  of  external halo node in this Mesh
 /// whose non-halo external counterpart is held on processor p. (read only)
 Vector<Node*> external_halo_node_pt(const unsigned& p)
  {
   std::map<unsigned, Vector<Node*> >::iterator it=
    External_halo_node_pt.find(p);
   if (it==External_halo_node_pt.end())
    {
     Vector<Node*> tmp;
     return tmp;
    }
   return (*it).second;
  }

 /// \short Set vector of external halo node in this Mesh
 /// whose non-halo external counterpart is held on processor p.
 void set_external_halo_node_pt(const unsigned& p,
                                const Vector<Node*>& external_halo_node_pt)
  {
   External_halo_node_pt[p]=external_halo_node_pt;
  }

 /// Null out specified external halo node (used when deleting duplicates)
 void null_external_halo_node(const unsigned& p, Node* nod_pt);

 /// \short Consolidate external halo node storage by removing nulled out
 /// pointes in external halo and haloed schemes
 void remove_null_pointers_from_external_halo_node_storage();

 /// \short Total number of external haloed nodes in this Mesh
 unsigned nexternal_haloed_node()
  {
   unsigned n=0;
   for (std::map<unsigned,Vector<Node*> >::iterator it=
       External_haloed_node_pt.begin();it!=External_haloed_node_pt.end();it++)
    {
     n+=it->second.size();
    }
   return n;
  }

 /// \short Number of external haloed nodes in this Mesh
 /// whose halo (external) counterpart is held on processor p.
 unsigned nexternal_haloed_node(const unsigned& p)
  {
   // Memory saving version of: return External_haloed_node_pt[p].size();
   std::map<unsigned, Vector<Node*> >::iterator it=
    External_haloed_node_pt.find(p);
   if (it==External_haloed_node_pt.end())
    {
     return 0;
    }
   return (*it).second.size();
  }

 /// \short Access fct to the j-th external haloed node in this Mesh
 /// whose halo external counterpart is held on processor p.
 Node* &external_haloed_node_pt(const unsigned &p, const unsigned &j)
  {
   return External_haloed_node_pt[p][j];
  }

 /// \short Add external haloed node whose halo (external) counterpart
 /// is held on processor p to the storage scheme for haloed nodes.
 unsigned add_external_haloed_node_pt(const unsigned& p, Node*& nod_pt);

 /// \short Access fct to vector of external haloed node in this Mesh
 /// whose halo external counterpart is held on processor p. (read only)
 Vector<Node*> external_haloed_node_pt(const unsigned& p)
  {
   std::map<unsigned, Vector<Node*> >::iterator it=
    External_haloed_node_pt.find(p);
   if (it==External_haloed_node_pt.end())
    {
     Vector<Node*> tmp;
     return tmp;
    }
   return (*it).second;
  }

 /// \short Set vector of external haloed node in this Mesh
 /// whose halo external counterpart is held on processor p.
 void set_external_haloed_node_pt(const unsigned& p,
                                  const Vector<Node*>& external_haloed_node_pt)
  {
   External_haloed_node_pt[p]=external_haloed_node_pt;
  }

 /// \short Return the set of processors that hold external halo nodes. This is
 /// required to avoid having to pass a communicator into the node_update
 /// functions for Algebraic-based and MacroElement-based Meshes
 std::set<int> external_halo_proc()
  {
   std::set<int> procs;
   for (std::map<unsigned,Vector<Node*> >::iterator it=
         External_halo_node_pt.begin();it!=External_halo_node_pt.end();it++)
    {
     procs.insert((*it).first);
    }
   return procs;
  }

 /// \short Creates the shared boundaries, only used in unstructured meshes
 /// In this case with the "TriangleMesh" class
 virtual void create_shared_boundaries(OomphCommunicator* comm_pt, 
                                       const Vector<unsigned> &element_domain,
                                       const Vector<GeneralisedElement*>
                                       &backed_up_el_pt,
                                       const Vector<FiniteElement*>
                                       &backed_up_f_el_pt,
                                       std::map<Data*,std::set<unsigned> >
                                       &processors_associated_with_data,
                                       const bool&
                                       overrule_keep_as_halo_element_status)
  {
   std::ostringstream error_stream;
   error_stream << "Empty default create_shared_boundaries() method"
                << "called.\n";
   error_stream << "This should be overloaded in a specific "
                << "TriangleMeshBase\n";
   throw OomphLibError(error_stream.str(),
                       "Mesh::create_shared_boundaries()",
                       OOMPH_EXCEPTION_LOCATION);
  }
 
 // Check if necessary to add the element as haloed or if it has been
 // previously added to the haloed scheme
 virtual unsigned try_to_add_root_haloed_element_pt(const unsigned& p, 
                                                    GeneralisedElement*& el_pt)
 {  
  std::ostringstream error_stream;
  error_stream << "Empty default try_to_add_root_haloed_element_pt() method"
               << "called.\n";
  error_stream << "This should be overloaded in a specific "
               << "TriangleMeshBase\n";
  throw OomphLibError(error_stream.str(),
                      "Mesh::try_to_add_root_haloed_element_pt()",
                      OOMPH_EXCEPTION_LOCATION);
 }
 
 // Check if necessary to add the node as haloed or if it has been
 // previously added to the haloed scheme
 virtual unsigned try_to_add_haloed_node_pt(const unsigned& p, Node*& nod_pt)
 {
  std::ostringstream error_stream;
  error_stream << "Empty default try_to_add_haloed_node_pt() method"
               << "called.\n";
  error_stream << "This should be overloaded in a specific "
               << "TriangleMeshBase\n";
  throw OomphLibError(error_stream.str(),
                      "Mesh::try_to_add_haloed_node_pt()",
                      OOMPH_EXCEPTION_LOCATION);
 }
 
#endif 

 /// \short Wipe the storage for all externally-based elements
 void delete_all_external_storage();




};



//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

class SolidICProblem;

//========================================================================
/// \short General SolidMesh class.
///
/// Solid meshes contain SolidFiniteElements which contain
/// SolidNodes. This class simply overloads the appropriate access
/// functions from the underlying Mesh class.
//
// Needs to be derived from Mesh with virtual so that
// solid meshes can be derived from general meshes, without
// multiple copies of Mesh objects
//========================================================================
class SolidMesh : public virtual Mesh
{
  public:


 /// \short Default constructor
 SolidMesh() {}

 /// Broken copy constructor
 SolidMesh(const SolidMesh& dummy)
  {
   BrokenCopy::broken_copy("SolidMesh");
  }

 /// Broken assignment operator
 void operator=(const SolidMesh&)
  {
   BrokenCopy::broken_assign("SolidMesh");
  }


 /// \short Constructor builds combined mesh from the meshes specified.
 /// Note: This simply merges the meshes' elements and nodes (ignoring
 /// duplicates; no boundary information etc. is created).
 SolidMesh(const Vector<SolidMesh*>& sub_mesh_pt)
  {
#ifdef OOMPH_HAS_MPI
   // Mesh hasn't been distributed: Null out pointer to communicator
   Comm_pt=0;
#endif

   unsigned n=sub_mesh_pt.size();
   Vector<Mesh*> sub_mesh_mesh_pt(n);
   for (unsigned i=0;i<n;i++)
    {
     sub_mesh_mesh_pt[i]=static_cast<Mesh*>(sub_mesh_pt[i]);
    }
   merge_meshes(sub_mesh_mesh_pt);
  }

 /// Return a pointer to the n-th global SolidNode
 //Can safely cast the nodes to SolidNodes
 SolidNode* node_pt(const unsigned long &n)
  {
#ifdef PARANOID
   if(!dynamic_cast<SolidNode*>(Node_pt[n]))
    {
     std::ostringstream error_stream;
     error_stream  << "Error: Node " << n << "is a "
                   << typeid(Node_pt[n]).name()
                   << ", not an SolidNode" << std::endl;
     throw OomphLibError(error_stream.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   //Return a static cast to the Node_pt
   return (static_cast<SolidNode*>(Node_pt[n]));
  }

 /// Return n-th SolidNodes on b-th boundary
 SolidNode* boundary_node_pt(const unsigned &b,
                             const unsigned &n)
  {
#ifdef PARANOID
   if(!dynamic_cast<SolidNode*>(Mesh::boundary_node_pt(b,n)))
    {
     std::ostringstream error_stream;
     error_stream
      << "Error: Node " << n << "is a "
      << typeid(Mesh::boundary_node_pt(b,n)).name()
      << ", not an SolidNode" << std::endl;
     throw OomphLibError(error_stream.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
      return static_cast<SolidNode*>(Mesh::boundary_node_pt(b,n));
  }

 /// \short Return the n-th local SolidNode in elemnet e.
 ///This is required to cast the nodes in a solid mesh to be
 ///SolidNodes and therefore allow access to the extra SolidNode data
 SolidNode* element_node_pt(const unsigned long &e,
                              const unsigned &n)
  {
#ifdef PARANOID
   // Try to cast to FiniteElement
   FiniteElement* el_pt=dynamic_cast<FiniteElement*>(Element_pt[e]);
   if (el_pt==0)
    {
     //Error
     throw OomphLibError("Failed cast to FiniteElement* ",
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
   if(!dynamic_cast<SolidNode*>(el_pt->node_pt(n)))
    {
     std::ostringstream error_message;
	 Node *np = el_pt->node_pt(n);
     error_message << "Error: Node " << n << " of element " << e
                   << "is a " << typeid(*np).name()
                   << ", not an SolidNode" << std::endl;

     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   //Return a cast to an SolidNode
   return(static_cast<SolidNode*>(
          dynamic_cast<FiniteElement*>(Element_pt[e])->node_pt(n)));
  }

 /// \short Make the current configuration the undeformed one by
 /// setting the nodal Lagrangian coordinates to their current
 /// Eulerian ones
 void set_lagrangian_nodal_coordinates();


 /// \short Scale all nodal coordinates by given factor and re-assign the
 /// Lagrangian coordinates
 void scale_mesh(const double& factor)
 {
  Mesh::scale_mesh(factor);

  //Re-assign the Lagrangian coordinates
  set_lagrangian_nodal_coordinates();
 }
 /// \short Static problem that can be used to assign initial conditions
 /// on a given  solid mesh (need to define this as a static problem
 /// somewhere because deleting the problem would wipe out the mesh too!)
 static SolidICProblem Solid_IC_problem;


};




///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////



//===================================================
/// Edge class
//===================================================
 class Edge
 {

 public:

  /// Constructor: Pass in the two vertex nodes
  Edge(Node* node1_pt, Node* node2_pt)
   {
    if (node1_pt==node2_pt)
     {
#ifdef PARANOID
      std::ostringstream error_stream;
      error_stream << "Edge cannot have two identical vertex nodes\n";
      throw OomphLibError(
       error_stream.str(),
       OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
#endif
     }


    // Sort lexicographically based on pointer address of nodes
    if (node1_pt>node2_pt)
     {
      Node1_pt=node1_pt;
      Node2_pt=node2_pt;
     }
    else
     {
      Node1_pt=node2_pt;
      Node2_pt=node1_pt;
     }
   }


  /// Access to the first vertex node
  Node* node1_pt() const {return Node1_pt;}

  /// Access to the second vertex node
  Node* node2_pt() const {return Node2_pt;}

  /// Comparison operator
  bool operator==(const Edge& other) const
   {
    if ((Node1_pt==other.node1_pt())&&
        (Node2_pt==other.node2_pt()))

     {
       return true;
     }
    else
     {
      return false;
     }
   }



  /// Less-than operator
  bool operator<(const Edge& other) const
   {
    if (Node1_pt<other.node1_pt())
     {
      return true;
     }
    else if (Node1_pt==other.node1_pt())
     {
      if (Node2_pt<other.node2_pt())
       {
        return true;
       }
      else
       {
        return false;
       }
     }
    else
     {
      return false;
     }
   }

  /// \short Test whether the Edge lies on a boundary. Relatively simple
  /// test, based on both vertices lying on (some) boundary.
  bool is_on_boundary()  const
  {
   return (Node1_pt->is_on_boundary() && Node2_pt->is_on_boundary() );
  }


  /// \short Test whether the Edge is a boundary edge, i.e. does it
  /// connnect two boundary nodes?
  bool is_boundary_edge()  const
  {
   return ((dynamic_cast<BoundaryNodeBase*>(Node1_pt)!=0)&&
           (dynamic_cast<BoundaryNodeBase*>(Node2_pt)!=0));
  }

 private:

  /// First vertex node
  Node* Node1_pt;

  /// Second vertex node
  Node* Node2_pt;
 };



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////



//=================================================================
/// Namespace with helper function to check element type in mesh
/// constructors (say).
//=================================================================
namespace MeshChecker
{


//=================================================================
/// \short Helper function to assert that finite element of type ELEMENT
/// can be cast to base class of type GEOM_ELEMENT_BASE -- useful
/// to avoid confusion if a mesh that was written for a specific
/// element type (e.g. a QElement) is used with another one (e.g.
/// a TElement. First argument specifies the required spatial dimension
/// of the element (i.e. the number of local coordinates). The optional
/// second argument specifies the required nnode_1d (i.e. the number
/// of nodes along a 1D element edge). Can be omitted if the mesh
/// can handle any number in which case this test is skipped.
//=================================================================
 template<class GEOM_ELEMENT_BASE, class ELEMENT>
  void assert_geometric_element(const unsigned& dim,
                                const unsigned& nnode_1d=0)
  {
   // Only do tests in paranoia mode
#ifndef PARANOID
   return;
#endif

   // Instantiate element
   ELEMENT* el_pt=new ELEMENT;

   // Can we cast to required geometric element base type
   if (dynamic_cast<GEOM_ELEMENT_BASE*>(el_pt)==0)
    {
     std::stringstream error_message;
     error_message
      << "You have specified an illegal element type! Element is of type \n\n"
      << typeid(el_pt).name()
      << "\n\nand cannot be cast to type \n\n "
      << typeid(GEOM_ELEMENT_BASE).name()
      << "\n\n";
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }

   // Does the dimension match?
   if (dim!=el_pt->dim())
    {
     std::stringstream error_message;
     error_message
      << "You have specified an illegal element type! Element is of type \n\n"
      << typeid(el_pt).name()
      << "\n\nand has dimension = " << el_pt->dim()
      << " but we need dim = " << dim << std::endl;
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);

    }

   // Does nnode_1d match?
   if (nnode_1d!=0)
    {
     if (nnode_1d!=el_pt->nnode_1d())
      {
       std::stringstream error_message;
       error_message
        << "You have specified an illegal element type! Element is of type \n\n"
        << typeid(el_pt).name()
        << "\n\nand has nnode_1d = " << el_pt->nnode_1d()
        << " but we need nnode_1d = " << nnode_1d << std::endl;
       throw OomphLibError(error_message.str(),
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
      }
    }

   // Clean up
   delete el_pt;

  }

}



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


//=================paraview_helper=================================
/// Namespace for paraview-style output helper functions 
//=================================================================
namespace ParaviewHelper
{

 /// Write the pvd file header
 extern void write_pvd_header(std::ofstream &pvd_file);
 
 /// \short Add name of output file and associated continuous time
 /// to pvd file.
 extern void write_pvd_information(std::ofstream &pvd_file,
                                   const std::string& output_filename,
                                   const double& time);
 
 /// Write the pvd file footer
 extern void write_pvd_footer(std::ofstream &pvd_file);

}

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

namespace NodeOrdering 
{
 /// Function for ordering nodes. Return true if first node's position is
 /// "before" second nodes. Dimension 0 checked first, then... until they
 /// are different (by more than tol=1e-10). If they are both in exactly
 /// the same place an error is thrown.
 inline bool node_global_position_comparison(Node* nd1_pt, Node* nd2_pt) 
 {
  unsigned ndim = nd1_pt->ndim();

  unsigned j;
  for(j=0; j<ndim; j++)
   {
    if(std::abs(nd1_pt->x(j) - nd2_pt->x(j)) > 1e-10)
     {
      if(nd1_pt->x(j) < nd2_pt->x(j))
       {
        return true;
       }
      else 
       {
        return false;
       }
     }
    // otherwise they are the same in this dimension, check next one.
   }

  std::string err = "Nodes are at the same point to ~ 1e-10!";
  err += " difference is " +
   StringConversion::to_string(std::abs(nd1_pt->x(j) - nd2_pt->x(j)));
  throw OomphLibError(err, OOMPH_EXCEPTION_LOCATION,
                      OOMPH_CURRENT_FUNCTION);
 }
}


}

#endif
