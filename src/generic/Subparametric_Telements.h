// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC// Copyright (C) 2006-2021 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
// Header functions for classes that define Subparametric_Telements
#ifndef OOMPH_SUBPARAMETRIC_TELEMENT_HEADER
#define OOMPH_SUBPARAMETRIC_TELEMENT_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

#ifdef OOMPH_HAS_MPI
#include "mpi.h"
#endif

// oomph-lib headers
#include "Vector.h"
#include "shape.h"
#include "integral.h"
#include "elements.h"
#include "Telements.h"

namespace oomph
{
  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////
  /// BellElementShape
  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////

  //========================================================================
  /// A class for Bell triangular shape function with 3 vertex nodes and
  /// WITHOUT 3 middle-side node
  //========================================================================
  template<unsigned DIM>
  class BellElementShape
  {
  };

  template<>
  class BellElementShape<2>
  {
  public:
    //=======================================================================
    /// Return local coordinates of node j
    //=======================================================================
    void local_coordinate_of_node(const unsigned& j, Vector<double>& s) const
    {
      switch (j)
      {
        case 0:
          s[0] = 1.0;
          s[1] = 0.0;
          break;

        case 1:
          s[0] = 0.0;
          s[1] = 1.0;
          break;

        case 2:
          s[0] = 0.0;
          s[1] = 0.0;
          break;

        default:
          std::ostringstream error_message;
          error_message
            << "Element only has three nodes; called with node number " << j
            << std::endl;

          throw OomphLibError(error_message.str(),
                              "BellElement::local_coordinate_of_node()",
                              OOMPH_EXCEPTION_LOCATION);
      }
    }

    void Bshape(const Vector<double>& s,
                Shape& psi,
                DenseMatrix<double>& position) const
    {
      //---------------------------------------------
      // the mapping to physical coordinates
      //----------------------------------------------
      Vector<double> phi(2);
      phi[0] = position(2, 0) + (position(0, 0) - position(2, 0)) * s[0] +
               (position(1, 0) - position(2, 0)) * s[1];
      phi[1] = position(2, 1) + (position(0, 1) - position(2, 1)) * s[0] +
               (position(1, 1) - position(2, 1)) * s[1];

      double A =
        ((position(1, 0) * position(2, 1) - position(2, 0) * position(1, 1)) -
         (position(0, 0) * position(2, 1) - position(2, 0) * position(0, 1)) +
         (position(0, 0) * position(1, 1) - position(1, 0) * position(0, 1))) /
        2.0;
      double A0 =
        ((position(1, 0) * position(2, 1) - position(2, 0) * position(1, 1)) -
         (phi[0] * position(2, 1) - position(2, 0) * phi[1]) +
         (phi[0] * position(1, 1) - position(1, 0) * phi[1])) /
        2.0;
      double A1 =
        ((phi[0] * position(2, 1) - position(2, 0) * phi[1]) -
         (position(0, 0) * position(2, 1) - position(2, 0) * position(0, 1)) +
         (position(0, 0) * phi[1] - phi[0] * position(0, 1))) /
        2.0;
      double A2 =
        ((position(1, 0) * phi[1] - phi[0] * position(1, 1)) -
         (position(0, 0) * phi[1] - phi[0] * position(0, 1)) +
         (position(0, 0) * position(1, 1) - position(1, 0) * position(0, 1))) /
        2.0;
      // assigned area coordinates
      Vector<double> xi(3);
      xi[0] = A0 / A;
      xi[1] = A1 / A;
      xi[2] = A2 / A;

      Vector<double> b(3);
      Vector<double> c(3);
      Vector<double> lamb(3);
      Vector<double> lamb_p(3);
      Vector<double> pp(2);
      Vector<double> a(2), cc(2);

      // compute for b and c
      b[1] = position(0, 0) - position(2, 0);
      b[2] = position(1, 0) - position(0, 0);
      b[0] = position(2, 0) - position(1, 0);

      c[1] = position(2, 1) - position(0, 1);
      c[2] = position(0, 1) - position(1, 1);
      c[0] = position(1, 1) - position(2, 1);

      // compute for a point of perpendicular
      // on the edge opposite to node0 (top vertex)
      Vector<double> v(2);
      v[0] = (position(2, 0) - position(1, 0));
      v[1] = (position(2, 1) - position(1, 1));
      double m = v[1] / v[0];
      a[0] = position(1, 0);
      a[1] = position(1, 1);
      cc[0] = position(0, 0);
      cc[1] = position(0, 1);
      if (v[0] == 0)
      {
        m = v[0] / v[1];
        pp[1] = (v[0] * m * a[1] + v[1] * cc[1] - v[0] * a[0] + v[0] * cc[0]) /
                ((v[0] * m) + v[1]);
        pp[0] = (pp[1] - a[1]) * m + a[0];
      }
      else
      {
        pp[0] = (v[1] * m * a[0] + v[1] * cc[1] - v[1] * a[1] + v[0] * cc[0]) /
                (v[1] * m + v[0]);
        pp[1] = m * (pp[0] - a[0]) + a[1];
      }
      double l = sqrt(v[0] * v[0] + v[1] * v[1]);
      double l1 =
        sqrt((pp[0] - a[0]) * (pp[0] - a[0]) + (pp[1] - a[1]) * (pp[1] - a[1]));
      lamb_p[0] = l1 / l;
      lamb[0] = 1 - lamb_p[0];

      // on the edge opposite to node1
      v[0] = (position(0, 0) - position(2, 0));
      v[1] = (position(0, 1) - position(2, 1));
      m = v[1] / v[0];
      a[0] = position(2, 0);
      a[1] = position(2, 1);
      cc[0] = position(1, 0);
      cc[1] = position(1, 1);
      if (v[0] == 0)
      {
        m = v[0] / v[1];
        pp[1] = (v[0] * m * a[1] + v[1] * cc[1] - v[0] * a[0] + v[0] * cc[0]) /
                ((v[0] * m) + v[1]);
        pp[0] = (pp[1] - a[1]) * m + a[0];
      }
      else
      {
        pp[0] = (v[1] * m * a[0] + v[1] * cc[1] - v[1] * a[1] + v[0] * cc[0]) /
                (v[1] * m + v[0]);
        pp[1] = m * (pp[0] - a[0]) + a[1];
      }
      l = sqrt(v[0] * v[0] + v[1] * v[1]);
      l1 =
        sqrt((pp[0] - a[0]) * (pp[0] - a[0]) + (pp[1] - a[1]) * (pp[1] - a[1]));
      lamb_p[1] = l1 / l;
      lamb[1] = 1 - lamb_p[1];

      // on the edge opposite to node2 (right bottom)
      v[0] = (position(1, 0) - position(0, 0));
      v[1] = (position(1, 1) - position(0, 1));
      m = v[1] / v[0];
      a[0] = position(0, 0);
      a[1] = position(0, 1);
      cc[0] = position(2, 0);
      cc[1] = position(2, 1);
      if (v[0] == 0)
      {
        m = v[0] / v[1];
        pp[1] = (v[0] * m * a[1] + v[1] * cc[1] - v[0] * a[0] + v[0] * cc[0]) /
                ((v[0] * m) + v[1]);
        pp[0] = (pp[1] - a[1]) * m + a[0];
      }
      else
      {
        pp[0] = (v[1] * m * a[0] + v[1] * cc[1] - v[1] * a[1] + v[0] * cc[0]) /
                (v[1] * m + v[0]);
        pp[1] = m * (pp[0] - a[0]) + a[1];
      }
      l = sqrt(v[0] * v[0] + v[1] * v[1]);
      l1 =
        sqrt((pp[0] - a[0]) * (pp[0] - a[0]) + (pp[1] - a[1]) * (pp[1] - a[1]));
      lamb_p[2] = l1 / l;
      lamb[2] = 1 - lamb_p[2];

      // define shape functions that associated to dofs at node 0
      psi(0, 0) =
        xi[0] * xi[0] * xi[0] * xi[0] * xi[0] +
        5.0 * xi[0] * xi[0] * xi[0] * xi[0] * (xi[1] + xi[2]) +
        10.0 * xi[0] * xi[0] * xi[0] * (xi[1] + xi[2]) * (xi[1] + xi[2]) +
        30.0 * xi[0] * xi[0] * xi[1] * xi[2] *
          (lamb[2] * xi[1] + lamb_p[1] * xi[2]);
      psi(0, 1) = 3.0 * b[0] * xi[0] * xi[0] * xi[1] * xi[2] * (xi[1] - xi[2]) +
                  xi[0] * xi[0] * xi[0] * (b[2] * xi[1] - b[1] * xi[2]) *
                    (xi[0] + 4.0 * xi[1] + 4 * xi[2]) +
                  15 * xi[0] * xi[0] * xi[1] * xi[2] *
                    (b[2] * lamb[2] * xi[1] - b[1] * lamb_p[1] * xi[2]);
      psi(0, 2) =
        -3.0 * c[0] * xi[0] * xi[0] * xi[1] * xi[2] * (xi[1] - xi[2]) -
        xi[0] * xi[0] * xi[0] * (c[2] * xi[1] - c[1] * xi[2]) *
          (xi[0] + 4.0 * xi[1] + 4.0 * xi[2]) -
        15.0 * xi[0] * xi[0] * xi[1] * xi[2] *
          (c[2] * lamb[2] * xi[1] - c[1] * lamb_p[1] * xi[2]);
      psi(0, 3) =
        1.0 / 2.0 * xi[0] * xi[0] * xi[0] *
          (b[2] * b[2] * xi[1] * xi[1] + b[1] * b[1] * xi[2] * xi[2]) +
        xi[0] * xi[0] * xi[1] * xi[2] *
          (-b[1] * b[2] * xi[0] + b[2] * b[0] * xi[1] + b[0] * b[1] * xi[2]) +
        5.0 / 2.0 * xi[0] * xi[0] * xi[1] * xi[2] *
          (b[2] * b[2] * lamb[2] * xi[1] + b[1] * b[1] * lamb_p[1] * xi[2]);
      psi(0, 4) =
        1.0 / 2.0 * xi[0] * xi[0] * xi[0] *
          (c[2] * c[2] * xi[1] * xi[1] + c[1] * c[1] * xi[2] * xi[2]) +
        xi[0] * xi[0] * xi[1] * xi[2] *
          (-c[1] * c[2] * xi[0] + c[2] * c[0] * xi[1] + c[0] * c[1] * xi[2]) +
        5.0 / 2.0 * xi[0] * xi[0] * xi[1] * xi[2] *
          (c[2] * c[2] * lamb[2] * xi[1] + c[1] * c[1] * lamb_p[1] * xi[2]);
      psi(0, 5) =
        b[0] * c[0] * xi[0] * xi[0] * xi[1] * xi[2] * (xi[0] + xi[1] + xi[2]) +
        b[1] * c[1] * xi[0] * xi[0] * xi[2] *
          (xi[1] * xi[2] - xi[2] * xi[0] - xi[0] * xi[1] - xi[1] * xi[1]) +
        b[2] * c[2] * xi[0] * xi[0] * xi[1] *
          (xi[1] * xi[2] - xi[2] * xi[0] - xi[0] * xi[1] - xi[2] * xi[2]) -
        5.0 * xi[0] * xi[0] * xi[1] * xi[2] *
          (b[1] * c[1] * lamb_p[1] * xi[2] + b[2] * c[2] * lamb[2] * xi[1]);

      // define shape functions that associated to dofs at node 1
      psi(1, 0) =
        xi[1] * xi[1] * xi[1] * xi[1] * xi[1] +
        5.0 * xi[1] * xi[1] * xi[1] * xi[1] * (xi[2] + xi[0]) +
        10.0 * xi[1] * xi[1] * xi[1] * (xi[2] + xi[0]) * (xi[2] + xi[0]) +
        30.0 * xi[1] * xi[1] * xi[2] * xi[0] *
          (lamb[0] * xi[2] + lamb_p[2] * xi[0]);
      psi(1, 1) = 3.0 * b[1] * xi[1] * xi[1] * xi[2] * xi[0] * (xi[2] - xi[0]) +
                  xi[1] * xi[1] * xi[1] * (b[0] * xi[2] - b[2] * xi[0]) *
                    (xi[1] + 4.0 * xi[2] + 4 * xi[0]) +
                  15 * xi[1] * xi[1] * xi[2] * xi[0] *
                    (b[0] * lamb[0] * xi[2] - b[2] * lamb_p[2] * xi[0]);
      psi(1, 2) =
        -3.0 * c[1] * xi[1] * xi[1] * xi[2] * xi[0] * (xi[2] - xi[0]) -
        xi[1] * xi[1] * xi[1] * (c[0] * xi[2] - c[2] * xi[0]) *
          (xi[1] + 4.0 * xi[2] + 4.0 * xi[0]) -
        15.0 * xi[1] * xi[1] * xi[2] * xi[0] *
          (c[0] * lamb[0] * xi[2] - c[2] * lamb_p[2] * xi[0]);
      psi(1, 3) =
        1.0 / 2.0 * xi[1] * xi[1] * xi[1] *
          (b[0] * b[0] * xi[2] * xi[2] + b[2] * b[2] * xi[0] * xi[0]) +
        xi[1] * xi[1] * xi[2] * xi[0] *
          (-b[2] * b[0] * xi[1] + b[0] * b[1] * xi[2] + b[1] * b[2] * xi[0]) +
        5.0 / 2.0 * xi[1] * xi[1] * xi[2] * xi[0] *
          (b[0] * b[0] * lamb[0] * xi[2] + b[2] * b[2] * lamb_p[2] * xi[0]);
      psi(1, 4) =
        1.0 / 2.0 * xi[1] * xi[1] * xi[1] *
          (c[0] * c[0] * xi[2] * xi[2] + c[2] * c[2] * xi[0] * xi[0]) +
        xi[1] * xi[1] * xi[2] * xi[0] *
          (-c[2] * c[0] * xi[1] + c[0] * c[1] * xi[2] + c[1] * c[2] * xi[0]) +
        5.0 / 2.0 * xi[1] * xi[1] * xi[2] * xi[0] *
          (c[0] * c[0] * lamb[0] * xi[2] + c[2] * c[2] * lamb_p[2] * xi[0]);
      psi(1, 5) =
        b[1] * c[1] * xi[1] * xi[1] * xi[2] * xi[0] * (xi[1] + xi[2] + xi[0]) +
        b[2] * c[2] * xi[1] * xi[1] * xi[0] *
          (xi[2] * xi[0] - xi[0] * xi[1] - xi[1] * xi[2] - xi[2] * xi[2]) +
        b[0] * c[0] * xi[1] * xi[1] * xi[2] *
          (xi[2] * xi[0] - xi[0] * xi[1] - xi[1] * xi[2] - xi[0] * xi[0]) -
        5.0 * xi[1] * xi[1] * xi[2] * xi[0] *
          (b[2] * c[2] * lamb_p[2] * xi[0] + b[0] * c[0] * lamb[0] * xi[2]);

      // define shape functions that associated to dofs at node 2
      psi(2, 0) =
        xi[2] * xi[2] * xi[2] * xi[2] * xi[2] +
        5.0 * xi[2] * xi[2] * xi[2] * xi[2] * (xi[0] + xi[1]) +
        10.0 * xi[2] * xi[2] * xi[2] * (xi[0] + xi[1]) * (xi[0] + xi[1]) +
        30.0 * xi[2] * xi[2] * xi[0] * xi[1] *
          (lamb[1] * xi[0] + lamb_p[0] * xi[1]);
      psi(2, 1) = 3.0 * b[2] * xi[2] * xi[2] * xi[0] * xi[1] * (xi[0] - xi[1]) +
                  xi[2] * xi[2] * xi[2] * (b[1] * xi[0] - b[0] * xi[1]) *
                    (xi[2] + 4.0 * xi[0] + 4 * xi[1]) +
                  15 * xi[2] * xi[2] * xi[0] * xi[1] *
                    (b[1] * lamb[1] * xi[0] - b[0] * lamb_p[0] * xi[1]);
      psi(2, 2) =
        -3.0 * c[2] * xi[2] * xi[2] * xi[0] * xi[1] * (xi[0] - xi[1]) -
        xi[2] * xi[2] * xi[2] * (c[1] * xi[0] - c[0] * xi[1]) *
          (xi[2] + 4.0 * xi[0] + 4.0 * xi[1]) -
        15.0 * xi[2] * xi[2] * xi[0] * xi[1] *
          (c[1] * lamb[1] * xi[0] - c[0] * lamb_p[0] * xi[1]);
      psi(2, 3) =
        1.0 / 2.0 * xi[2] * xi[2] * xi[2] *
          (b[1] * b[1] * xi[0] * xi[0] + b[0] * b[0] * xi[1] * xi[1]) +
        xi[2] * xi[2] * xi[0] * xi[1] *
          (-b[0] * b[1] * xi[2] + b[1] * b[2] * xi[0] + b[2] * b[0] * xi[1]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[0] * xi[1] *
          (b[1] * b[1] * lamb[1] * xi[0] + b[0] * b[0] * lamb_p[0] * xi[1]);
      psi(2, 4) =
        1.0 / 2.0 * xi[2] * xi[2] * xi[2] *
          (c[1] * c[1] * xi[0] * xi[0] + c[0] * c[0] * xi[1] * xi[1]) +
        xi[2] * xi[2] * xi[0] * xi[1] *
          (-c[0] * c[1] * xi[2] + c[1] * c[2] * xi[0] + c[2] * c[0] * xi[1]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[0] * xi[1] *
          (c[1] * c[1] * lamb[1] * xi[0] + c[0] * c[0] * lamb_p[0] * xi[1]);
      psi(2, 5) =
        b[2] * c[2] * xi[2] * xi[2] * xi[0] * xi[1] * (xi[2] + xi[0] + xi[1]) +
        b[0] * c[0] * xi[2] * xi[2] * xi[1] *
          (xi[0] * xi[1] - xi[1] * xi[2] - xi[2] * xi[0] - xi[0] * xi[0]) +
        b[1] * c[1] * xi[2] * xi[2] * xi[0] *
          (xi[0] * xi[1] - xi[1] * xi[2] - xi[2] * xi[0] - xi[1] * xi[1]) -
        5.0 * xi[2] * xi[2] * xi[0] * xi[1] *
          (b[0] * c[0] * lamb_p[0] * xi[1] + b[1] * c[1] * lamb[1] * xi[0]);
    }

    void dBshape_local(const Vector<double>& s,
                       Shape& psi,
                       DShape& dpsids,
                       DenseMatrix<double>& position) const
    {
      // assign for shape functions
      Bshape(s, psi, position);
      //---------------------------------------------
      // the mapping to physical coordinates
      //----------------------------------------------
      Vector<double> phi(2);
      phi[0] = position(2, 0) + (position(0, 0) - position(2, 0)) * s[0] +
               (position(1, 0) - position(2, 0)) * s[1];
      phi[1] = position(2, 1) + (position(0, 1) - position(2, 1)) * s[0] +
               (position(1, 1) - position(2, 1)) * s[1];

      double A =
        ((position(1, 0) * position(2, 1) - position(2, 0) * position(1, 1)) -
         (position(0, 0) * position(2, 1) - position(2, 0) * position(0, 1)) +
         (position(0, 0) * position(1, 1) - position(1, 0) * position(0, 1))) /
        2.0;
      double A0, A1, A2;
      A0 =
        ((position(1, 0) * position(2, 1) - position(2, 0) * position(1, 1)) -
         (phi[0] * position(2, 1) - position(2, 0) * phi[1]) +
         (phi[0] * position(1, 1) - position(1, 0) * phi[1])) /
        2.0;
      A1 =
        ((phi[0] * position(2, 1) - position(2, 0) * phi[1]) -
         (position(0, 0) * position(2, 1) - position(2, 0) * position(0, 1)) +
         (position(0, 0) * phi[1] - phi[0] * position(0, 1))) /
        2.0;
      A2 =
        ((position(1, 0) * phi[1] - phi[0] * position(1, 1)) -
         (position(0, 0) * phi[1] - phi[0] * position(0, 1)) +
         (position(0, 0) * position(1, 1) - position(1, 0) * position(0, 1))) /
        2.0;

      // assigned area coordinates
      Vector<double> xi(3);
      xi[0] = A0 / A;
      xi[1] = A1 / A;
      xi[2] = A2 / A;

      Vector<double> b(3);
      Vector<double> c(3);
      Vector<double> lamb(3);
      Vector<double> lamb_p(3);
      Vector<double> pp(2);
      Vector<double> a(2), cc(2);

      // compute for b and c
      b[1] = position(0, 0) - position(2, 0);
      b[2] = position(1, 0) - position(0, 0);
      b[0] = position(2, 0) - position(1, 0);

      c[1] = position(2, 1) - position(0, 1);
      c[2] = position(0, 1) - position(1, 1);
      c[0] = position(1, 1) - position(2, 1);

      // compute for a point of perpendicular
      // on the edge opposite to node0 (top vertex)
      Vector<double> v(2);
      v[0] = (position(2, 0) - position(1, 0));
      v[1] = (position(2, 1) - position(1, 1));
      double m = v[1] / v[0];
      a[0] = position(1, 0);
      a[1] = position(1, 1);
      cc[0] = position(0, 0);
      cc[1] = position(0, 1);
      if (v[0] == 0)
      {
        m = v[0] / v[1];
        pp[1] = (v[0] * m * a[1] + v[1] * cc[1] - v[0] * a[0] + v[0] * cc[0]) /
                ((v[0] * m) + v[1]);
        pp[0] = (pp[1] - a[1]) * m + a[0];
      }
      else
      {
        pp[0] = (v[1] * m * a[0] + v[1] * cc[1] - v[1] * a[1] + v[0] * cc[0]) /
                (v[1] * m + v[0]);
        pp[1] = m * (pp[0] - a[0]) + a[1];
      }
      double l = sqrt(v[0] * v[0] + v[1] * v[1]);
      double l1 =
        sqrt((pp[0] - a[0]) * (pp[0] - a[0]) + (pp[1] - a[1]) * (pp[1] - a[1]));
      lamb_p[0] = l1 / l;
      lamb[0] = 1 - lamb_p[0];

      // on the edge opposite to node1
      v[0] = (position(0, 0) - position(2, 0));
      v[1] = (position(0, 1) - position(2, 1));
      m = v[1] / v[0];
      a[0] = position(2, 0);
      a[1] = position(2, 1);
      cc[0] = position(1, 0);
      cc[1] = position(1, 1);
      if (v[0] == 0)
      {
        m = v[0] / v[1];
        pp[1] = (v[0] * m * a[1] + v[1] * cc[1] - v[0] * a[0] + v[0] * cc[0]) /
                ((v[0] * m) + v[1]);
        pp[0] = (pp[1] - a[1]) * m + a[0];
      }
      else
      {
        pp[0] = (v[1] * m * a[0] + v[1] * cc[1] - v[1] * a[1] + v[0] * cc[0]) /
                (v[1] * m + v[0]);
        pp[1] = m * (pp[0] - a[0]) + a[1];
      }
      l = sqrt(v[0] * v[0] + v[1] * v[1]);
      l1 =
        sqrt((pp[0] - a[0]) * (pp[0] - a[0]) + (pp[1] - a[1]) * (pp[1] - a[1]));
      lamb_p[1] = l1 / l;
      lamb[1] = 1 - lamb_p[1];

      // on the edge opposite to node2 (right bottom)
      v[0] = (position(1, 0) - position(0, 0));
      v[1] = (position(1, 1) - position(0, 1));
      m = v[1] / v[0];
      a[0] = position(0, 0);
      a[1] = position(0, 1);
      cc[0] = position(2, 0);
      cc[1] = position(2, 1);
      if (v[0] == 0)
      {
        m = v[0] / v[1];
        pp[1] = (v[0] * m * a[1] + v[1] * cc[1] - v[0] * a[0] + v[0] * cc[0]) /
                ((v[0] * m) + v[1]);
        pp[0] = (pp[1] - a[1]) * m + a[0];
      }
      else
      {
        pp[0] = (v[1] * m * a[0] + v[1] * cc[1] - v[1] * a[1] + v[0] * cc[0]) /
                (v[1] * m + v[0]);
        pp[1] = m * (pp[0] - a[0]) + a[1];
      }
      l = sqrt(v[0] * v[0] + v[1] * v[1]);
      l1 =
        sqrt((pp[0] - a[0]) * (pp[0] - a[0]) + (pp[1] - a[1]) * (pp[1] - a[1]));
      lamb_p[2] = l1 / l;
      lamb[2] = 1 - lamb_p[2];


      Vector<double> dxids0(3, 0.0);
      Vector<double> dxids1(3, 0.0);

      dxids0[0] = c[0] / A / 2.0;
      dxids0[1] = c[1] / A / 2.0;
      dxids0[2] = c[2] / A / 2.0;

      dxids1[0] = b[0] / A / 2.0;
      dxids1[1] = b[1] / A / 2.0;
      dxids1[2] = b[2] / A / 2.0;

      DShape psi1(3, 6, 3);
      // define dshape functions that associated to dofs at node 0
      psi1(0, 0, 0) =
        5.0 * xi[0] * xi[0] * xi[0] * xi[0] +
        5.0 * 4.0 * xi[0] * xi[0] * xi[0] * (xi[1] + xi[2]) +
        10.0 * 3.0 * xi[0] * xi[0] * (xi[1] + xi[2]) * (xi[1] + xi[2]) +
        30.0 * 2.0 * xi[0] * xi[1] * xi[2] *
          (lamb[2] * xi[1] + lamb_p[1] * xi[2]);
      psi1(0, 1, 0) =
        3.0 * b[0] * 2.0 * xi[0] * xi[1] * xi[2] * (xi[1] - xi[2]) +
        3.0 * xi[0] * xi[0] * (b[2] * xi[1] - b[1] * xi[2]) *
          (xi[0] + 4.0 * xi[1] + 4.0 * xi[2]) +
        xi[0] * xi[0] * xi[0] * (b[2] * xi[1] - b[1] * xi[2]) +
        15 * 2.0 * xi[0] * xi[1] * xi[2] *
          (b[2] * lamb[2] * xi[1] - b[1] * lamb_p[1] * xi[2]);
      psi1(0, 2, 0) =
        -3.0 * c[0] * 2.0 * xi[0] * xi[1] * xi[2] * (xi[1] - xi[2]) -
        3.0 * xi[0] * xi[0] * (c[2] * xi[1] - c[1] * xi[2]) *
          (xi[0] + 4.0 * xi[1] + 4.0 * xi[2]) -
        xi[0] * xi[0] * xi[0] * (c[2] * xi[1] - c[1] * xi[2]) -
        15.0 * 2.0 * xi[0] * xi[1] * xi[2] *
          (c[2] * lamb[2] * xi[1] - c[1] * lamb_p[1] * xi[2]);
      psi1(0, 3, 0) =
        1.0 / 2.0 * 3.0 * xi[0] * xi[0] *
          (b[2] * b[2] * xi[1] * xi[1] + b[1] * b[1] * xi[2] * xi[2]) +
        2.0 * xi[0] * xi[1] * xi[2] *
          (-b[1] * b[2] * xi[0] + b[2] * b[0] * xi[1] + b[0] * b[1] * xi[2]) +
        5.0 / 2.0 * 2.0 * xi[0] * xi[1] * xi[2] *
          (b[2] * b[2] * lamb[2] * xi[1] + b[1] * b[1] * lamb_p[1] * xi[2]) +
        xi[0] * xi[0] * xi[1] * xi[2] * (-b[1] * b[2]);
      psi1(0, 4, 0) =
        1.0 / 2.0 * 3.0 * xi[0] * xi[0] *
          (c[2] * c[2] * xi[1] * xi[1] + c[1] * c[1] * xi[2] * xi[2]) +
        2.0 * xi[0] * xi[1] * xi[2] *
          (-c[1] * c[2] * xi[0] + c[2] * c[0] * xi[1] + c[0] * c[1] * xi[2]) +
        5.0 / 2.0 * 2.0 * xi[0] * xi[1] * xi[2] *
          (c[2] * c[2] * lamb[2] * xi[1] + c[1] * c[1] * lamb_p[1] * xi[2]) +
        xi[0] * xi[0] * xi[1] * xi[2] * (-c[1] * c[2]);
      psi1(0, 5, 0) =
        b[0] * c[0] * 2.0 * xi[0] * xi[1] * xi[2] * (xi[0] + xi[1] + xi[2]) +
        b[0] * c[0] * xi[0] * xi[0] * xi[1] * xi[2] +
        b[1] * c[1] * 2.0 * xi[0] * xi[2] *
          (xi[1] * xi[2] - xi[2] * xi[0] - xi[0] * xi[1] - xi[1] * xi[1]) +
        b[1] * c[1] * xi[0] * xi[0] * xi[2] * (-xi[1] - xi[2]) +
        b[2] * c[2] * 2.0 * xi[0] * xi[1] *
          (xi[1] * xi[2] - xi[2] * xi[0] - xi[0] * xi[1] - xi[2] * xi[2]) +
        b[2] * c[2] * xi[0] * xi[0] * xi[1] * (-xi[2] - xi[1]) -
        5.0 * 2.0 * xi[0] * xi[1] * xi[2] *
          (b[1] * c[1] * lamb_p[1] * xi[2] + b[2] * c[2] * lamb[2] * xi[1]);

      psi1(0, 0, 1) =
        5.0 * xi[0] * xi[0] * xi[0] * xi[0] +
        10.0 * xi[0] * xi[0] * xi[0] * 2.0 * (xi[1] + xi[2]) +
        30.0 * xi[0] * xi[0] * xi[2] * (lamb[2] * xi[1] + lamb_p[1] * xi[2]) +
        30.0 * xi[0] * xi[0] * xi[1] * xi[2] * (lamb[2]);
      psi1(0, 1, 1) =
        3.0 * b[0] * xi[0] * xi[0] * xi[2] * (xi[1] - xi[2]) +
        3.0 * b[0] * xi[0] * xi[0] * xi[1] * xi[2] +
        xi[0] * xi[0] * xi[0] * (b[2]) * (xi[0] + 4.0 * xi[1] + 4 * xi[2]) +
        xi[0] * xi[0] * xi[0] * (b[2] * xi[1] - b[1] * xi[2]) * (4.0) +
        15 * xi[0] * xi[0] * xi[2] *
          (b[2] * lamb[2] * xi[1] - b[1] * lamb_p[1] * xi[2]) +
        15 * xi[0] * xi[0] * xi[1] * xi[2] * (b[2] * lamb[2]);
      psi1(0, 2, 1) =
        -3.0 * c[0] * xi[0] * xi[0] * xi[2] * (xi[1] - xi[2]) -
        3.0 * c[0] * xi[0] * xi[0] * xi[1] * xi[2] -
        xi[0] * xi[0] * xi[0] * (c[2] * xi[1] - c[1] * xi[2]) * (4.0) -
        xi[0] * xi[0] * xi[0] * (c[2]) * (xi[0] + 4.0 * xi[1] + 4.0 * xi[2]) -
        15.0 * xi[0] * xi[0] * xi[1] * xi[2] * (c[2] * lamb[2]) -
        15.0 * xi[0] * xi[0] * xi[2] *
          (c[2] * lamb[2] * xi[1] - c[1] * lamb_p[1] * xi[2]);
      psi1(0, 3, 1) =
        1.0 / 2.0 * xi[0] * xi[0] * xi[0] * (b[2] * b[2] * 2.0 * xi[1]) +
        xi[0] * xi[0] * xi[1] * xi[2] * (b[2] * b[0]) +
        xi[0] * xi[0] * xi[2] *
          (-b[1] * b[2] * xi[0] + b[2] * b[0] * xi[1] + b[0] * b[1] * xi[2]) +
        5.0 / 2.0 * xi[0] * xi[0] * xi[1] * xi[2] * (b[2] * b[2] * lamb[2]) +
        5.0 / 2.0 * xi[0] * xi[0] * xi[2] *
          (b[2] * b[2] * lamb[2] * xi[1] + b[1] * b[1] * lamb_p[1] * xi[2]);
      psi1(0, 4, 1) =
        1.0 / 2.0 * xi[0] * xi[0] * xi[0] * (c[2] * c[2] * 2.0 * xi[1]) +
        xi[0] * xi[0] * xi[1] * xi[2] * (c[2] * c[0]) +
        xi[0] * xi[0] * xi[2] *
          (-c[1] * c[2] * xi[0] + c[2] * c[0] * xi[1] + c[0] * c[1] * xi[2]) +
        5.0 / 2.0 * xi[0] * xi[0] * xi[1] * xi[2] * (c[2] * c[2] * lamb[2]) +
        5.0 / 2.0 * xi[0] * xi[0] * xi[2] *
          (c[2] * c[2] * lamb[2] * xi[1] + c[1] * c[1] * lamb_p[1] * xi[2]);
      psi1(0, 5, 1) =
        b[0] * c[0] * xi[0] * xi[0] * xi[1] * xi[2] +
        b[0] * c[0] * xi[0] * xi[0] * xi[2] * (xi[0] + xi[1] + xi[2]) +
        b[1] * c[1] * xi[0] * xi[0] * xi[2] * (xi[2] - xi[0] - 2.0 * xi[1]) +
        b[2] * c[2] * xi[0] * xi[0] *
          (xi[1] * xi[2] - xi[2] * xi[0] - xi[0] * xi[1] - xi[2] * xi[2]) +
        b[2] * c[2] * xi[0] * xi[0] * xi[1] * (xi[2] - xi[0]) -
        5.0 * xi[0] * xi[0] * xi[2] *
          (b[1] * c[1] * lamb_p[1] * xi[2] + b[2] * c[2] * lamb[2] * xi[1]) -
        5.0 * xi[0] * xi[0] * xi[1] * xi[2] * (b[2] * c[2] * lamb[2]);

      psi1(0, 0, 2) =
        5.0 * xi[0] * xi[0] * xi[0] * xi[0] +
        10.0 * xi[0] * xi[0] * xi[0] * 2.0 * (xi[1] + xi[2]) +
        30.0 * xi[0] * xi[0] * xi[1] * xi[2] * (lamb_p[1]) +
        30.0 * xi[0] * xi[0] * xi[1] * (lamb[2] * xi[1] + lamb_p[1] * xi[2]);
      psi1(0, 1, 2) =
        3.0 * b[0] * xi[0] * xi[0] * xi[1] * xi[2] * (-1.0) +
        3.0 * b[0] * xi[0] * xi[0] * xi[1] * (xi[1] - xi[2]) +
        xi[0] * xi[0] * xi[0] * (b[2] * xi[1] - b[1] * xi[2]) * (4.0) +
        xi[0] * xi[0] * xi[0] * (-b[1]) * (xi[0] + 4.0 * xi[1] + 4 * xi[2]) +
        15 * xi[0] * xi[0] * xi[1] * xi[2] * (-b[1] * lamb_p[1]) +
        15 * xi[0] * xi[0] * xi[1] *
          (b[2] * lamb[2] * xi[1] - b[1] * lamb_p[1] * xi[2]);
      psi1(0, 2, 2) =
        -3.0 * c[0] * xi[0] * xi[0] * xi[1] * xi[2] * (-1.0) +
        -3.0 * c[0] * xi[0] * xi[0] * xi[1] * (xi[1] - xi[2]) -
        xi[0] * xi[0] * xi[0] * (c[2] * xi[1] - c[1] * xi[2]) * (4.0) -
        xi[0] * xi[0] * xi[0] * (-1.0 * c[1]) *
          (xi[0] + 4.0 * xi[1] + 4.0 * xi[2]) -
        15.0 * xi[0] * xi[0] * xi[1] * xi[2] * (-1.0 * c[1] * lamb_p[1]) -
        15.0 * xi[0] * xi[0] * xi[1] *
          (c[2] * lamb[2] * xi[1] - c[1] * lamb_p[1] * xi[2]);
      psi1(0, 3, 2) =
        1.0 / 2.0 * xi[0] * xi[0] * xi[0] * (b[1] * b[1] * 2.0 * xi[2]) +
        xi[0] * xi[0] * xi[1] * xi[2] * (b[0] * b[1]) +
        xi[0] * xi[0] * xi[1] *
          (-b[1] * b[2] * xi[0] + b[2] * b[0] * xi[1] + b[0] * b[1] * xi[2]) +
        5.0 / 2.0 * xi[0] * xi[0] * xi[1] * xi[2] * (b[1] * b[1] * lamb_p[1]) +
        5.0 / 2.0 * xi[0] * xi[0] * xi[1] *
          (b[2] * b[2] * lamb[2] * xi[1] + b[1] * b[1] * lamb_p[1] * xi[2]);
      psi1(0, 4, 2) =
        1.0 / 2.0 * xi[0] * xi[0] * xi[0] * (c[1] * c[1] * 2.0 * xi[2]) +
        xi[0] * xi[0] * xi[1] * xi[2] * (c[0] * c[1]) +
        xi[0] * xi[0] * xi[1] *
          (-c[1] * c[2] * xi[0] + c[2] * c[0] * xi[1] + c[0] * c[1] * xi[2]) +
        5.0 / 2.0 * xi[0] * xi[0] * xi[1] * xi[2] * (c[1] * c[1] * lamb_p[1]) +
        5.0 / 2.0 * xi[0] * xi[0] * xi[1] *
          (c[2] * c[2] * lamb[2] * xi[1] + c[1] * c[1] * lamb_p[1] * xi[2]);
      psi1(0, 5, 2) =
        b[0] * c[0] * xi[0] * xi[0] * xi[1] * xi[2] +
        b[0] * c[0] * xi[0] * xi[0] * xi[1] * (xi[0] + xi[1] + xi[2]) +
        b[1] * c[1] * xi[0] * xi[0] * xi[2] * (xi[1] - xi[0]) +
        b[1] * c[1] * xi[0] * xi[0] *
          (xi[1] * xi[2] - xi[2] * xi[0] - xi[0] * xi[1] - xi[1] * xi[1]) +
        b[2] * c[2] * xi[0] * xi[0] * xi[1] * (xi[1] - xi[0] - 2.0 * xi[2]) -
        5.0 * xi[0] * xi[0] * xi[1] * xi[2] * (b[1] * c[1] * lamb_p[1]) -
        5.0 * xi[0] * xi[0] * xi[1] *
          (b[1] * c[1] * lamb_p[1] * xi[2] + b[2] * c[2] * lamb[2] * xi[1]);

      // by chain rule, we can obtain dshape wrt s0 at node0
      dpsids(0, 0, 0) = psi1(0, 0, 0) * dxids0[0] + psi1(0, 0, 1) * dxids0[1] +
                        psi1(0, 0, 2) * dxids0[2];
      dpsids(0, 1, 0) = psi1(0, 1, 0) * dxids0[0] + psi1(0, 1, 1) * dxids0[1] +
                        psi1(0, 1, 2) * dxids0[2];
      dpsids(0, 2, 0) = psi1(0, 2, 0) * dxids0[0] + psi1(0, 2, 1) * dxids0[1] +
                        psi1(0, 2, 2) * dxids0[2];
      dpsids(0, 3, 0) = psi1(0, 3, 0) * dxids0[0] + psi1(0, 3, 1) * dxids0[1] +
                        psi1(0, 3, 2) * dxids0[2];
      dpsids(0, 4, 0) = psi1(0, 4, 0) * dxids0[0] + psi1(0, 4, 1) * dxids0[1] +
                        psi1(0, 4, 2) * dxids0[2];
      dpsids(0, 5, 0) = psi1(0, 5, 0) * dxids0[0] + psi1(0, 5, 1) * dxids0[1] +
                        psi1(0, 5, 2) * dxids0[2];

      // by chain rule, we can obtain dshape wrt s1 at node0
      dpsids(0, 0, 1) = psi1(0, 0, 0) * dxids1[0] + psi1(0, 0, 1) * dxids1[1] +
                        psi1(0, 0, 2) * dxids1[2];
      dpsids(0, 1, 1) = psi1(0, 1, 0) * dxids1[0] + psi1(0, 1, 1) * dxids1[1] +
                        psi1(0, 1, 2) * dxids1[2];
      dpsids(0, 2, 1) = psi1(0, 2, 0) * dxids1[0] + psi1(0, 2, 1) * dxids1[1] +
                        psi1(0, 2, 2) * dxids1[2];
      dpsids(0, 3, 1) = psi1(0, 3, 0) * dxids1[0] + psi1(0, 3, 1) * dxids1[1] +
                        psi1(0, 3, 2) * dxids1[2];
      dpsids(0, 4, 1) = psi1(0, 4, 0) * dxids1[0] + psi1(0, 4, 1) * dxids1[1] +
                        psi1(0, 4, 2) * dxids1[2];
      dpsids(0, 5, 1) = psi1(0, 5, 0) * dxids1[0] + psi1(0, 5, 1) * dxids1[1] +
                        psi1(0, 5, 2) * dxids1[2];
      //-------------------------------------------------------------------------------------
      // define shape functions that associated to dofs at node 1
      // wrt area coordinate 1
      psi1(1, 0, 1) =
        5.0 * xi[1] * xi[1] * xi[1] * xi[1] +
        5.0 * 4.0 * xi[1] * xi[1] * xi[1] * (xi[2] + xi[0]) +
        10.0 * 3.0 * xi[1] * xi[1] * (xi[2] + xi[0]) * (xi[2] + xi[0]) +
        30.0 * 2.0 * xi[1] * xi[2] * xi[0] *
          (lamb[0] * xi[2] + lamb_p[2] * xi[0]);
      psi1(1, 1, 1) =
        3.0 * b[1] * 2.0 * xi[1] * xi[2] * xi[0] * (xi[2] - xi[0]) +
        3.0 * xi[1] * xi[1] * (b[0] * xi[2] - b[2] * xi[0]) *
          (xi[1] + 4.0 * xi[2] + 4.0 * xi[0]) +
        xi[1] * xi[1] * xi[1] * (b[0] * xi[2] - b[2] * xi[0]) +
        15 * 2.0 * xi[1] * xi[2] * xi[0] *
          (b[0] * lamb[0] * xi[2] - b[2] * lamb_p[2] * xi[0]);
      psi1(1, 2, 1) =
        -3.0 * c[1] * 2.0 * xi[1] * xi[2] * xi[0] * (xi[2] - xi[0]) -
        3.0 * xi[1] * xi[1] * (c[0] * xi[2] - c[2] * xi[0]) *
          (xi[1] + 4.0 * xi[2] + 4.0 * xi[0]) -
        xi[1] * xi[1] * xi[1] * (c[0] * xi[2] - c[2] * xi[0]) -
        15.0 * 2.0 * xi[1] * xi[2] * xi[0] *
          (c[0] * lamb[0] * xi[2] - c[2] * lamb_p[2] * xi[0]);
      psi1(1, 3, 1) =
        1.0 / 2.0 * 3.0 * xi[1] * xi[1] *
          (b[0] * b[0] * xi[2] * xi[2] + b[2] * b[2] * xi[0] * xi[0]) +
        2.0 * xi[1] * xi[2] * xi[0] *
          (-b[2] * b[0] * xi[1] + b[0] * b[1] * xi[2] + b[1] * b[2] * xi[0]) +
        5.0 / 2.0 * 2.0 * xi[1] * xi[2] * xi[0] *
          (b[0] * b[0] * lamb[0] * xi[2] + b[2] * b[2] * lamb_p[2] * xi[0]) +
        xi[1] * xi[1] * xi[2] * xi[0] * (-b[2]) * b[0];
      psi1(1, 4, 1) =
        1.0 / 2.0 * 3.0 * xi[1] * xi[1] *
          (c[0] * c[0] * xi[2] * xi[2] + c[2] * c[2] * xi[0] * xi[0]) +
        2.0 * xi[1] * xi[2] * xi[0] *
          (-c[2] * c[0] * xi[1] + c[0] * c[1] * xi[2] + c[1] * c[2] * xi[0]) +
        5.0 / 2.0 * 2.0 * xi[1] * xi[2] * xi[0] *
          (c[0] * c[0] * lamb[0] * xi[2] + c[2] * c[2] * lamb_p[2] * xi[0]) +
        xi[1] * xi[1] * xi[2] * xi[0] * (-c[2]) * c[0];
      psi1(1, 5, 1) =
        b[1] * c[1] * 2.0 * xi[1] * xi[2] * xi[0] * (xi[1] + xi[2] + xi[0]) +
        b[1] * c[1] * xi[1] * xi[1] * xi[2] * xi[0] +
        b[2] * c[2] * 2.0 * xi[1] * xi[0] *
          (xi[2] * xi[0] - xi[0] * xi[1] - xi[1] * xi[2] - xi[2] * xi[2]) +
        b[2] * c[2] * xi[1] * xi[1] * xi[0] * (-xi[2] - xi[0]) +
        b[0] * c[0] * 2.0 * xi[1] * xi[2] *
          (xi[2] * xi[0] - xi[0] * xi[1] - xi[1] * xi[2] - xi[0] * xi[0]) +
        b[0] * c[0] * xi[1] * xi[1] * xi[2] * (-xi[0] - xi[2]) -
        5.0 * 2.0 * xi[1] * xi[2] * xi[0] *
          (b[2] * c[2] * lamb_p[2] * xi[0] + b[0] * c[0] * lamb[0] * xi[2]);

      // wrt area coordinate2
      psi1(1, 0, 2) =
        5.0 * xi[1] * xi[1] * xi[1] * xi[1] +
        10.0 * xi[1] * xi[1] * xi[1] * 2.0 * (xi[2] + xi[0]) +
        30.0 * xi[1] * xi[1] * xi[0] * (lamb[0] * xi[2] + lamb_p[2] * xi[0]) +
        30.0 * xi[1] * xi[1] * xi[2] * xi[0] * (lamb[0]);
      psi1(1, 1, 2) =
        3.0 * b[1] * xi[1] * xi[1] * xi[0] * (xi[2] - xi[0]) +
        3.0 * b[1] * xi[1] * xi[1] * xi[2] * xi[0] +
        xi[1] * xi[1] * xi[1] * (b[0]) * (xi[1] + 4.0 * xi[2] + 4.0 * xi[0]) +
        xi[1] * xi[1] * xi[1] * (b[0] * xi[2] - b[2] * xi[0]) * (4.0) +
        15.0 * xi[1] * xi[1] * xi[0] *
          (b[0] * lamb[0] * xi[2] - b[2] * lamb_p[2] * xi[0]) +
        15 * xi[1] * xi[1] * xi[2] * xi[0] * (b[0] * lamb[0]);
      psi1(1, 2, 2) =
        -3.0 * c[1] * xi[1] * xi[1] * xi[2] * xi[0] +
        -3.0 * c[1] * xi[1] * xi[1] * xi[0] * (xi[2] - xi[0]) -
        xi[1] * xi[1] * xi[1] * (c[0] * xi[2] - c[2] * xi[0]) * (4.0) -
        xi[1] * xi[1] * xi[1] * (c[0]) * (xi[1] + 4.0 * xi[2] + 4.0 * xi[0]) -
        15.0 * xi[1] * xi[1] * xi[2] * xi[0] * (c[0] * lamb[0]) -
        15.0 * xi[1] * xi[1] * xi[0] *
          (c[0] * lamb[0] * xi[2] - c[2] * lamb_p[2] * xi[0]);
      psi1(1, 3, 2) =
        1.0 / 2.0 * xi[1] * xi[1] * xi[1] * (b[0] * b[0] * 2.0 * xi[2]) +
        xi[1] * xi[1] * xi[2] * xi[0] * (b[0] * b[1]) +
        xi[1] * xi[1] * xi[0] *
          (-b[2] * b[0] * xi[1] + b[0] * b[1] * xi[2] + b[1] * b[2] * xi[0]) +
        5.0 / 2.0 * xi[1] * xi[1] * xi[2] * xi[0] * (b[0] * b[0] * lamb[0]) +
        5.0 / 2.0 * xi[1] * xi[1] * xi[0] *
          (b[0] * b[0] * lamb[0] * xi[2] + b[2] * b[2] * lamb_p[2] * xi[0]);
      psi1(1, 4, 2) =
        1.0 / 2.0 * xi[1] * xi[1] * xi[1] * (c[0] * c[0] * 2.0 * xi[2]) +
        xi[1] * xi[1] * xi[2] * xi[0] * (c[0] * c[1]) +
        xi[1] * xi[1] * xi[0] *
          (-c[2] * c[0] * xi[1] + c[0] * c[1] * xi[2] + c[1] * c[2] * xi[0]) +
        5.0 / 2.0 * xi[1] * xi[1] * xi[2] * xi[0] * (c[0] * c[0] * lamb[0]) +
        5.0 / 2.0 * xi[1] * xi[1] * xi[0] *
          (c[0] * c[0] * lamb[0] * xi[2] + c[2] * c[2] * lamb_p[2] * xi[0]);
      psi1(1, 5, 2) =
        b[1] * c[1] * xi[1] * xi[1] * xi[2] * xi[0] +
        b[1] * c[1] * xi[1] * xi[1] * xi[0] * (xi[1] + xi[2] + xi[0]) +
        b[2] * c[2] * xi[1] * xi[1] * xi[0] * (xi[0] - xi[1] - 2.0 * xi[2]) +
        b[0] * c[0] * xi[1] * xi[1] * xi[2] * (xi[0] - xi[1]) +
        b[0] * c[0] * xi[1] * xi[1] *
          (xi[2] * xi[0] - xi[0] * xi[1] - xi[1] * xi[2] - xi[0] * xi[0]) -
        5.0 * xi[1] * xi[1] * xi[2] * xi[0] * (b[0] * c[0] * lamb[0]) -
        5.0 * xi[1] * xi[1] * xi[0] *
          (b[2] * c[2] * lamb_p[2] * xi[0] + b[0] * c[0] * lamb[0] * xi[2]);

      // wrt area coordinate0
      psi1(1, 0, 0) =
        5.0 * xi[1] * xi[1] * xi[1] * xi[1] +
        10.0 * xi[1] * xi[1] * xi[1] * 2.0 * (xi[2] + xi[0]) +
        30.0 * xi[1] * xi[1] * xi[2] * xi[0] * (lamb_p[2]) +
        30.0 * xi[1] * xi[1] * xi[2] * (lamb[0] * xi[2] + lamb_p[2] * xi[0]);
      psi1(1, 1, 0) =
        -3.0 * b[1] * xi[1] * xi[1] * xi[2] * xi[0] +
        3.0 * b[1] * xi[1] * xi[1] * xi[2] * (xi[2] - xi[0]) +
        xi[1] * xi[1] * xi[1] * (b[0] * xi[2] - b[2] * xi[0]) * (4.0) +
        xi[1] * xi[1] * xi[1] * (-b[2]) * (xi[1] + 4.0 * xi[2] + 4.0 * xi[0]) -
        15 * xi[1] * xi[1] * xi[2] * xi[0] * (b[2] * lamb_p[2]) +
        15 * xi[1] * xi[1] * xi[2] *
          (b[0] * lamb[0] * xi[2] - b[2] * lamb_p[2] * xi[0]);
      psi1(1, 2, 0) =
        3.0 * c[1] * xi[1] * xi[1] * xi[2] * xi[0] -
        3.0 * c[1] * xi[1] * xi[1] * xi[2] * (xi[2] - xi[0]) -
        xi[1] * xi[1] * xi[1] * (c[0] * xi[2] - c[2] * xi[0]) * (4.0) -
        xi[1] * xi[1] * xi[1] * (-c[2]) * (xi[1] + 4.0 * xi[2] + 4.0 * xi[0]) +
        15.0 * xi[1] * xi[1] * xi[2] * xi[0] * (c[2] * lamb_p[2]) -
        15.0 * xi[1] * xi[1] * xi[2] *
          (c[0] * lamb[0] * xi[2] - c[2] * lamb_p[2] * xi[0]);
      psi1(1, 3, 0) =
        1.0 / 2.0 * xi[1] * xi[1] * xi[1] * (b[2] * b[2] * 2.0 * xi[0]) +
        xi[1] * xi[1] * xi[2] * xi[0] * (b[1] * b[2]) +
        xi[1] * xi[1] * xi[2] *
          (-b[2] * b[0] * xi[1] + b[0] * b[1] * xi[2] + b[1] * b[2] * xi[0]) +
        5.0 / 2.0 * xi[1] * xi[1] * xi[2] * xi[0] * (b[2] * b[2] * lamb_p[2]) +
        5.0 / 2.0 * xi[1] * xi[1] * xi[2] *
          (b[0] * b[0] * lamb[0] * xi[2] + b[2] * b[2] * lamb_p[2] * xi[0]);
      psi1(1, 4, 0) =
        1.0 / 2.0 * xi[1] * xi[1] * xi[1] * (c[2] * c[2] * 2.0 * xi[0]) +
        xi[1] * xi[1] * xi[2] * xi[0] * (c[1] * c[2]) +
        xi[1] * xi[1] * xi[2] *
          (-c[2] * c[0] * xi[1] + c[0] * c[1] * xi[2] + c[1] * c[2] * xi[0]) +
        5.0 / 2.0 * xi[1] * xi[1] * xi[2] * xi[0] * (c[2] * c[2] * lamb_p[2]) +
        5.0 / 2.0 * xi[1] * xi[1] * xi[2] *
          (c[0] * c[0] * lamb[0] * xi[2] + c[2] * c[2] * lamb_p[2] * xi[0]);
      psi1(1, 5, 0) =
        b[1] * c[1] * xi[1] * xi[1] * xi[2] * xi[0] +
        b[1] * c[1] * xi[1] * xi[1] * xi[2] * (xi[1] + xi[2] + xi[0]) +
        b[2] * c[2] * xi[1] * xi[1] * xi[0] * (xi[2] - xi[1]) +
        b[2] * c[2] * xi[1] * xi[1] *
          (xi[2] * xi[0] - xi[0] * xi[1] - xi[1] * xi[2] - xi[2] * xi[2]) +
        b[0] * c[0] * xi[1] * xi[1] * xi[2] * (xi[2] - xi[1] - 2.0 * xi[0]) -
        5.0 * xi[1] * xi[1] * xi[2] * xi[0] * (b[2] * c[2] * lamb_p[2]) -
        5.0 * xi[1] * xi[1] * xi[2] *
          (b[2] * c[2] * lamb_p[2] * xi[0] + b[0] * c[0] * lamb[0] * xi[2]);
      //--------------------------------------------------------------------------------------
      // by chain rule, we can obtain dshape wrt s0 at node1
      dpsids(1, 0, 0) = psi1(1, 0, 0) * dxids0[0] + psi1(1, 0, 1) * dxids0[1] +
                        psi1(1, 0, 2) * dxids0[2];
      dpsids(1, 1, 0) = psi1(1, 1, 0) * dxids0[0] + psi1(1, 1, 1) * dxids0[1] +
                        psi1(1, 1, 2) * dxids0[2];
      dpsids(1, 2, 0) = psi1(1, 2, 0) * dxids0[0] + psi1(1, 2, 1) * dxids0[1] +
                        psi1(1, 2, 2) * dxids0[2];
      dpsids(1, 3, 0) = psi1(1, 3, 0) * dxids0[0] + psi1(1, 3, 1) * dxids0[1] +
                        psi1(1, 3, 2) * dxids0[2];
      dpsids(1, 4, 0) = psi1(1, 4, 0) * dxids0[0] + psi1(1, 4, 1) * dxids0[1] +
                        psi1(1, 4, 2) * dxids0[2];
      dpsids(1, 5, 0) = psi1(1, 5, 0) * dxids0[0] + psi1(1, 5, 1) * dxids0[1] +
                        psi1(1, 5, 2) * dxids0[2];

      // by chain rule, we can obtain dshape wrt s1 at node1
      dpsids(1, 0, 1) = psi1(1, 0, 0) * dxids1[0] + psi1(1, 0, 1) * dxids1[1] +
                        psi1(1, 0, 2) * dxids1[2];
      dpsids(1, 1, 1) = psi1(1, 1, 0) * dxids1[0] + psi1(1, 1, 1) * dxids1[1] +
                        psi1(1, 1, 2) * dxids1[2];
      dpsids(1, 2, 1) = psi1(1, 2, 0) * dxids1[0] + psi1(1, 2, 1) * dxids1[1] +
                        psi1(1, 2, 2) * dxids1[2];
      dpsids(1, 3, 1) = psi1(1, 3, 0) * dxids1[0] + psi1(1, 3, 1) * dxids1[1] +
                        psi1(1, 3, 2) * dxids1[2];
      dpsids(1, 4, 1) = psi1(1, 4, 0) * dxids1[0] + psi1(1, 4, 1) * dxids1[1] +
                        psi1(1, 4, 2) * dxids1[2];
      dpsids(1, 5, 1) = psi1(1, 5, 0) * dxids1[0] + psi1(1, 5, 1) * dxids1[1] +
                        psi1(1, 5, 2) * dxids1[2];
      //-------------------------------------------------------------------------------------
      // define shape functions that associated to dofs at node 2
      // wrt area coordinate0
      psi1(2, 0, 0) =
        5.0 * xi[2] * xi[2] * xi[2] * xi[2] +
        10.0 * xi[2] * xi[2] * xi[2] * 2.0 * (xi[0] + xi[1]) +
        30.0 * xi[2] * xi[2] * xi[1] * (lamb[1] * xi[0] + lamb_p[0] * xi[1]) +
        30.0 * xi[2] * xi[2] * xi[0] * xi[1] * (lamb[1]);
      psi1(2, 1, 0) =
        3.0 * b[2] * xi[2] * xi[2] * xi[1] * (xi[0] - xi[1]) +
        3.0 * b[2] * xi[2] * xi[2] * xi[0] * xi[1] +
        xi[2] * xi[2] * xi[2] * (b[1]) * (xi[2] + 4.0 * xi[0] + 4.0 * xi[1]) +
        xi[2] * xi[2] * xi[2] * (b[1] * xi[0] - b[0] * xi[1]) * (4.0) +
        15.0 * xi[2] * xi[2] * xi[1] *
          (b[1] * lamb[1] * xi[0] - b[0] * lamb_p[0] * xi[1]) +
        15.0 * xi[2] * xi[2] * xi[0] * xi[1] * (b[1] * lamb[1]);
      psi1(2, 2, 0) =
        -3.0 * c[2] * xi[2] * xi[2] * xi[0] * xi[1] +
        -3.0 * c[2] * xi[2] * xi[2] * xi[1] * (xi[0] - xi[1]) -
        xi[2] * xi[2] * xi[2] * (c[1] * xi[0] - c[0] * xi[1]) * (4.0) -
        xi[2] * xi[2] * xi[2] * (c[1]) * (xi[2] + 4.0 * xi[0] + 4.0 * xi[1]) -
        15.0 * xi[2] * xi[2] * xi[0] * xi[1] * (c[1] * lamb[1]) -
        15.0 * xi[2] * xi[2] * xi[1] *
          (c[1] * lamb[1] * xi[0] - c[0] * lamb_p[0] * xi[1]);
      psi1(2, 3, 0) =
        1.0 / 2.0 * xi[2] * xi[2] * xi[2] * (b[1] * b[1] * 2.0 * xi[0]) +
        xi[2] * xi[2] * xi[0] * xi[1] * (b[1] * b[2]) +
        xi[2] * xi[2] * xi[1] *
          (-b[0] * b[1] * xi[2] + b[1] * b[2] * xi[0] + b[2] * b[0] * xi[1]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[0] * xi[1] * (b[1] * b[1] * lamb[1]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[1] *
          (b[1] * b[1] * lamb[1] * xi[0] + b[0] * b[0] * lamb_p[0] * xi[1]);
      psi1(2, 4, 0) =
        1.0 / 2.0 * xi[2] * xi[2] * xi[2] * (c[1] * c[1] * 2.0 * xi[0]) +
        xi[2] * xi[2] * xi[0] * xi[1] * (c[1] * c[2]) +
        xi[2] * xi[2] * xi[1] *
          (-c[0] * c[1] * xi[2] + c[1] * c[2] * xi[0] + c[2] * c[0] * xi[1]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[0] * xi[1] * (c[1] * c[1] * lamb[1]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[1] *
          (c[1] * c[1] * lamb[1] * xi[0] + c[0] * c[0] * lamb_p[0] * xi[1]);
      psi1(2, 5, 0) =
        b[2] * c[2] * xi[2] * xi[2] * xi[0] * xi[1] +
        b[2] * c[2] * xi[2] * xi[2] * xi[1] * (xi[2] + xi[0] + xi[1]) +
        b[0] * c[0] * xi[2] * xi[2] * xi[1] * (xi[1] - xi[2] - 2.0 * xi[0]) +
        b[1] * c[1] * xi[2] * xi[2] * xi[0] * (xi[1] - xi[2]) +
        b[1] * c[1] * xi[2] * xi[2] *
          (xi[0] * xi[1] - xi[1] * xi[2] - xi[2] * xi[0] - xi[1] * xi[1]) -
        5.0 * xi[2] * xi[2] * xi[0] * xi[1] * (b[1] * c[1] * lamb[1]) -
        5.0 * xi[2] * xi[2] * xi[1] *
          (b[0] * c[0] * lamb_p[0] * xi[1] + b[1] * c[1] * lamb[1] * xi[0]);

      // wrt area coordinate1
      psi1(2, 0, 1) =
        5.0 * xi[2] * xi[2] * xi[2] * xi[2] +
        10.0 * xi[2] * xi[2] * xi[2] * 2.0 * (xi[0] + xi[1]) +
        30.0 * xi[2] * xi[2] * xi[0] * xi[1] * (lamb_p[0]) +
        30.0 * xi[2] * xi[2] * xi[0] * (lamb[1] * xi[0] + lamb_p[0] * xi[1]);
      psi1(2, 1, 1) =
        3.0 * b[2] * xi[2] * xi[2] * xi[0] * xi[1] * (-1.0) +
        3.0 * b[2] * xi[2] * xi[2] * xi[0] * (xi[0] - xi[1]) +
        xi[2] * xi[2] * xi[2] * (-b[0]) * (xi[2] + 4.0 * xi[0] + 4.0 * xi[1]) +
        xi[2] * xi[2] * xi[2] * (b[1] * xi[0] - b[0] * xi[1]) * (4.0) +
        15 * xi[2] * xi[2] * xi[0] *
          (b[1] * lamb[1] * xi[0] - b[0] * lamb_p[0] * xi[1]) +
        15.0 * xi[2] * xi[2] * xi[0] * xi[1] * (-b[0] * lamb_p[0]);
      psi1(2, 2, 1) =
        -3.0 * c[2] * xi[2] * xi[2] * xi[0] * xi[1] * (-1.0) +
        -3.0 * c[2] * xi[2] * xi[2] * xi[0] * (xi[0] - xi[1]) -
        xi[2] * xi[2] * xi[2] * (c[1] * xi[0] - c[0] * xi[1]) * (4.0) -
        xi[2] * xi[2] * xi[2] * (-1.0 * c[0]) *
          (xi[2] + 4.0 * xi[0] + 4.0 * xi[1]) -
        15.0 * xi[2] * xi[2] * xi[0] * xi[1] * (-1.0 * c[0] * lamb_p[0]) -
        15.0 * xi[2] * xi[2] * xi[0] *
          (c[1] * lamb[1] * xi[0] - c[0] * lamb_p[0] * xi[1]);
      psi1(2, 3, 1) =
        1.0 / 2.0 * xi[2] * xi[2] * xi[2] * (b[0] * b[0] * 2.0 * xi[1]) +
        xi[2] * xi[2] * xi[0] * xi[1] * (b[2] * b[0]) +
        xi[2] * xi[2] * xi[0] *
          (-b[0] * b[1] * xi[2] + b[1] * b[2] * xi[0] + b[2] * b[0] * xi[1]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[0] * xi[1] * (b[0] * b[0] * lamb_p[0]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[0] *
          (b[1] * b[1] * lamb[1] * xi[0] + b[0] * b[0] * lamb_p[0] * xi[1]);
      psi1(2, 4, 1) =
        1.0 / 2.0 * xi[2] * xi[2] * xi[2] * (c[0] * c[0] * 2.0 * xi[1]) +
        xi[2] * xi[2] * xi[0] * xi[1] * (c[2] * c[0]) +
        xi[2] * xi[2] * xi[0] *
          (-c[0] * c[1] * xi[2] + c[1] * c[2] * xi[0] + c[2] * c[0] * xi[1]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[0] * xi[1] * (c[0] * c[0] * lamb_p[0]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[0] *
          (c[1] * c[1] * lamb[1] * xi[0] + c[0] * c[0] * lamb_p[0] * xi[1]);
      psi1(2, 5, 1) =
        b[2] * c[2] * xi[2] * xi[2] * xi[0] * xi[1] +
        b[2] * c[2] * xi[2] * xi[2] * xi[0] * (xi[2] + xi[0] + xi[1]) +
        b[0] * c[0] * xi[2] * xi[2] * xi[1] * (xi[0] - xi[2]) +
        b[0] * c[0] * xi[2] * xi[2] *
          (xi[0] * xi[1] - xi[1] * xi[2] - xi[2] * xi[0] - xi[0] * xi[0]) +
        b[1] * c[1] * xi[2] * xi[2] * xi[0] * (xi[0] - xi[2] - 2.0 * xi[1]) -
        5.0 * xi[2] * xi[2] * xi[0] * xi[1] * (b[0] * c[0] * lamb_p[0]) -
        5.0 * xi[2] * xi[2] * xi[0] *
          (b[0] * c[0] * lamb_p[0] * xi[1] + b[1] * c[1] * lamb[1] * xi[0]);

      // wrt area coordinate2
      psi1(2, 0, 2) =
        5.0 * xi[2] * xi[2] * xi[2] * xi[2] +
        5.0 * 4.0 * xi[2] * xi[2] * xi[2] * (xi[0] + xi[1]) +
        10.0 * 3.0 * xi[2] * xi[2] * (xi[0] + xi[1]) * (xi[0] + xi[1]) +
        30.0 * 2.0 * xi[2] * xi[0] * xi[1] *
          (lamb[1] * xi[0] + lamb_p[0] * xi[1]);
      psi1(2, 1, 2) =
        3.0 * b[2] * 2.0 * xi[2] * xi[0] * xi[1] * (xi[0] - xi[1]) +
        3.0 * xi[2] * xi[2] * (b[1] * xi[0] - b[0] * xi[1]) *
          (xi[2] + 4.0 * xi[0] + 4.0 * xi[1]) +
        xi[2] * xi[2] * xi[2] * (b[1] * xi[0] - b[0] * xi[1]) +
        15 * 2.0 * xi[2] * xi[0] * xi[1] *
          (b[1] * lamb[1] * xi[0] - b[0] * lamb_p[0] * xi[1]);
      psi1(2, 2, 2) =
        -3.0 * c[2] * 2.0 * xi[2] * xi[0] * xi[1] * (xi[0] - xi[1]) -
        3.0 * xi[2] * xi[2] * (c[1] * xi[0] - c[0] * xi[1]) *
          (xi[2] + 4.0 * xi[0] + 4.0 * xi[1]) -
        xi[2] * xi[2] * xi[2] * (c[1] * xi[0] - c[0] * xi[1]) -
        15.0 * 2.0 * xi[2] * xi[0] * xi[1] *
          (c[1] * lamb[1] * xi[0] - c[0] * lamb_p[0] * xi[1]);
      psi1(2, 3, 2) =
        1.0 / 2.0 * 3.0 * xi[2] * xi[2] *
          (b[1] * b[1] * xi[0] * xi[0] + b[0] * b[0] * xi[1] * xi[1]) +
        2.0 * xi[2] * xi[0] * xi[1] *
          (-b[0] * b[1] * xi[2] + b[1] * b[2] * xi[0] + b[2] * b[0] * xi[1]) +
        5.0 / 2.0 * 2.0 * xi[2] * xi[0] * xi[1] *
          (b[1] * b[1] * lamb[1] * xi[0] + b[0] * b[0] * lamb_p[0] * xi[1]) +
        xi[2] * xi[2] * xi[0] * xi[1] * (-b[0]) * b[1];
      psi1(2, 4, 2) =
        1.0 / 2.0 * 3.0 * xi[2] * xi[2] *
          (c[1] * c[1] * xi[0] * xi[0] + c[0] * c[0] * xi[1] * xi[1]) +
        2.0 * xi[2] * xi[0] * xi[1] *
          (-c[0] * c[1] * xi[2] + c[1] * c[2] * xi[0] + c[2] * c[0] * xi[1]) +
        5.0 / 2.0 * 2.0 * xi[2] * xi[0] * xi[1] *
          (c[1] * c[1] * lamb[1] * xi[0] + c[0] * c[0] * lamb_p[0] * xi[1]) +
        xi[2] * xi[2] * xi[0] * xi[1] * (-c[0] * c[1]);
      psi1(2, 5, 2) =
        b[2] * c[2] * 2.0 * xi[2] * xi[0] * xi[1] * (xi[2] + xi[0] + xi[1]) +
        b[2] * c[2] * xi[2] * xi[2] * xi[0] * xi[1] +
        b[0] * c[0] * 2.0 * xi[2] * xi[1] *
          (xi[0] * xi[1] - xi[1] * xi[2] - xi[2] * xi[0] - xi[0] * xi[0]) +
        b[0] * c[0] * xi[2] * xi[2] * xi[1] * (-xi[0] - xi[1]) +
        b[1] * c[1] * 2.0 * xi[2] * xi[0] *
          (xi[0] * xi[1] - xi[1] * xi[2] - xi[2] * xi[0] - xi[1] * xi[1]) +
        b[1] * c[1] * xi[2] * xi[2] * xi[0] * (-xi[1] - xi[0]) -
        5.0 * 2.0 * xi[2] * xi[0] * xi[1] *
          (b[0] * c[0] * lamb_p[0] * xi[1] + b[1] * c[1] * lamb[1] * xi[0]);

      // by chain rule, we can obtain dshape wrt s0 at node2
      dpsids(2, 0, 0) = psi1(2, 0, 0) * dxids0[0] + psi1(2, 0, 1) * dxids0[1] +
                        psi1(2, 0, 2) * dxids0[2];
      dpsids(2, 1, 0) = psi1(2, 1, 0) * dxids0[0] + psi1(2, 1, 1) * dxids0[1] +
                        psi1(2, 1, 2) * dxids0[2];
      dpsids(2, 2, 0) = psi1(2, 2, 0) * dxids0[0] + psi1(2, 2, 1) * dxids0[1] +
                        psi1(2, 2, 2) * dxids0[2];
      dpsids(2, 3, 0) = psi1(2, 3, 0) * dxids0[0] + psi1(2, 3, 1) * dxids0[1] +
                        psi1(2, 3, 2) * dxids0[2];
      dpsids(2, 4, 0) = psi1(2, 4, 0) * dxids0[0] + psi1(2, 4, 1) * dxids0[1] +
                        psi1(2, 4, 2) * dxids0[2];
      dpsids(2, 5, 0) = psi1(2, 5, 0) * dxids0[0] + psi1(2, 5, 1) * dxids0[1] +
                        psi1(2, 5, 2) * dxids0[2];

      // by chain rule, we can obtain dshape wrt s1 at node2
      dpsids(2, 0, 1) = psi1(2, 0, 0) * dxids1[0] + psi1(2, 0, 1) * dxids1[1] +
                        psi1(2, 0, 2) * dxids1[2];
      dpsids(2, 1, 1) = psi1(2, 1, 0) * dxids1[0] + psi1(2, 1, 1) * dxids1[1] +
                        psi1(2, 1, 2) * dxids1[2];
      dpsids(2, 2, 1) = psi1(2, 2, 0) * dxids1[0] + psi1(2, 2, 1) * dxids1[1] +
                        psi1(2, 2, 2) * dxids1[2];
      dpsids(2, 3, 1) = psi1(2, 3, 0) * dxids1[0] + psi1(2, 3, 1) * dxids1[1] +
                        psi1(2, 3, 2) * dxids1[2];
      dpsids(2, 4, 1) = psi1(2, 4, 0) * dxids1[0] + psi1(2, 4, 1) * dxids1[1] +
                        psi1(2, 4, 2) * dxids1[2];
      dpsids(2, 5, 1) = psi1(2, 5, 0) * dxids1[0] + psi1(2, 5, 1) * dxids1[1] +
                        psi1(2, 5, 2) * dxids1[2];
    }

    void d2Bshape_local(const Vector<double>& s,
                        Shape& psi,
                        DShape& dpsids,
                        DShape& d2psids,
                        DenseMatrix<double>& position) const
    {
      // assign for dshape functions
      dBshape_local(s, psi, dpsids, position);
      //---------------------------------------------
      // the mapping to physical coordinates
      //----------------------------------------------
      Vector<double> phi(2);
      phi[0] = position(2, 0) + (position(0, 0) - position(2, 0)) * s[0] +
               (position(1, 0) - position(2, 0)) * s[1];
      phi[1] = position(2, 1) + (position(0, 1) - position(2, 1)) * s[0] +
               (position(1, 1) - position(2, 1)) * s[1];

      double A =
        ((position(1, 0) * position(2, 1) - position(2, 0) * position(1, 1)) -
         (position(0, 0) * position(2, 1) - position(2, 0) * position(0, 1)) +
         (position(0, 0) * position(1, 1) - position(1, 0) * position(0, 1))) /
        2.0;
      double A0, A1, A2;
      A0 =
        ((position(1, 0) * position(2, 1) - position(2, 0) * position(1, 1)) -
         (phi[0] * position(2, 1) - position(2, 0) * phi[1]) +
         (phi[0] * position(1, 1) - position(1, 0) * phi[1])) /
        2.0;
      A1 =
        ((phi[0] * position(2, 1) - position(2, 0) * phi[1]) -
         (position(0, 0) * position(2, 1) - position(2, 0) * position(0, 1)) +
         (position(0, 0) * phi[1] - phi[0] * position(0, 1))) /
        2.0;
      A2 =
        ((position(1, 0) * phi[1] - phi[0] * position(1, 1)) -
         (position(0, 0) * phi[1] - phi[0] * position(0, 1)) +
         (position(0, 0) * position(1, 1) - position(1, 0) * position(0, 1))) /
        2.0;

      // assigned area coordinates
      Vector<double> xi(3);
      xi[0] = A0 / A;
      xi[1] = A1 / A;
      xi[2] = A2 / A;

      Vector<double> b(3);
      Vector<double> c(3);
      Vector<double> lamb(3);
      Vector<double> lamb_p(3);
      Vector<double> pp(2);
      Vector<double> a(2), cc(2);

      // compute for b and c
      b[1] = position(0, 0) - position(2, 0);
      b[2] = position(1, 0) - position(0, 0);
      b[0] = position(2, 0) - position(1, 0);

      c[1] = position(2, 1) - position(0, 1);
      c[2] = position(0, 1) - position(1, 1);
      c[0] = position(1, 1) - position(2, 1);

      // compute for a point of perpendicular
      // on the edge opposite to node0 (top vertex)
      Vector<double> v(2);
      v[0] = (position(2, 0) - position(1, 0));
      v[1] = (position(2, 1) - position(1, 1));
      double m = v[1] / v[0];
      a[0] = position(1, 0);
      a[1] = position(1, 1);
      cc[0] = position(0, 0);
      cc[1] = position(0, 1);
      if (v[0] == 0)
      {
        m = v[0] / v[1];
        pp[1] = (v[0] * m * a[1] + v[1] * cc[1] - v[0] * a[0] + v[0] * cc[0]) /
                ((v[0] * m) + v[1]);
        pp[0] = (pp[1] - a[1]) * m + a[0];
      }
      else
      {
        pp[0] = (v[1] * m * a[0] + v[1] * cc[1] - v[1] * a[1] + v[0] * cc[0]) /
                (v[1] * m + v[0]);
        pp[1] = m * (pp[0] - a[0]) + a[1];
      }
      double l = sqrt(v[0] * v[0] + v[1] * v[1]);
      double l1 =
        sqrt((pp[0] - a[0]) * (pp[0] - a[0]) + (pp[1] - a[1]) * (pp[1] - a[1]));
      lamb_p[0] = l1 / l;
      lamb[0] = 1 - lamb_p[0];

      // on the edge opposite to node1
      v[0] = (position(0, 0) - position(2, 0));
      v[1] = (position(0, 1) - position(2, 1));
      m = v[1] / v[0];
      a[0] = position(2, 0);
      a[1] = position(2, 1);
      cc[0] = position(1, 0);
      cc[1] = position(1, 1);
      if (v[0] == 0)
      {
        m = v[0] / v[1];
        pp[1] = (v[0] * m * a[1] + v[1] * cc[1] - v[0] * a[0] + v[0] * cc[0]) /
                ((v[0] * m) + v[1]);
        pp[0] = (pp[1] - a[1]) * m + a[0];
      }
      else
      {
        pp[0] = (v[1] * m * a[0] + v[1] * cc[1] - v[1] * a[1] + v[0] * cc[0]) /
                (v[1] * m + v[0]);
        pp[1] = m * (pp[0] - a[0]) + a[1];
      }
      l = sqrt(v[0] * v[0] + v[1] * v[1]);
      l1 =
        sqrt((pp[0] - a[0]) * (pp[0] - a[0]) + (pp[1] - a[1]) * (pp[1] - a[1]));
      lamb_p[1] = l1 / l;
      lamb[1] = 1 - lamb_p[1];

      // on the edge opposite to node2 (right bottom)
      v[0] = (position(1, 0) - position(0, 0));
      v[1] = (position(1, 1) - position(0, 1));
      m = v[1] / v[0];
      a[0] = position(0, 0);
      a[1] = position(0, 1);
      cc[0] = position(2, 0);
      cc[1] = position(2, 1);
      if (v[0] == 0)
      {
        m = v[0] / v[1];
        pp[1] = (v[0] * m * a[1] + v[1] * cc[1] - v[0] * a[0] + v[0] * cc[0]) /
                ((v[0] * m) + v[1]);
        pp[0] = (pp[1] - a[1]) * m + a[0];
      }
      else
      {
        pp[0] = (v[1] * m * a[0] + v[1] * cc[1] - v[1] * a[1] + v[0] * cc[0]) /
                (v[1] * m + v[0]);
        pp[1] = m * (pp[0] - a[0]) + a[1];
      }
      l = sqrt(v[0] * v[0] + v[1] * v[1]);
      l1 =
        sqrt((pp[0] - a[0]) * (pp[0] - a[0]) + (pp[1] - a[1]) * (pp[1] - a[1]));
      lamb_p[2] = l1 / l;
      lamb[2] = 1 - lamb_p[2];

      Vector<double> dxids0(3, 0.0);
      Vector<double> dxids1(3, 0.0);

      dxids0[0] = c[0] / A / 2.0;
      dxids0[1] = c[1] / A / 2.0;
      dxids0[2] = c[2] / A / 2.0;

      dxids1[0] = b[0] / A / 2.0;
      dxids1[1] = b[1] / A / 2.0;
      dxids1[2] = b[2] / A / 2.0;

      //------------------------------------------------------------------
      DShape psi2(3, 6, 6);

      //------------------------------------------------------------------------------------
      // compute for all second derivatives at node 0
      //------------------------------------------------------------------------------------
      // compute for the second derivatives wrt area coordinate0
      psi2(0, 0, 0) =
        5.0 * 4.0 * xi[0] * xi[0] * xi[0] +
        5.0 * 4.0 * 3.0 * xi[0] * xi[0] * (xi[1] + xi[2]) +
        10.0 * 3.0 * 2.0 * xi[0] * (xi[1] + xi[2]) * (xi[1] + xi[2]) +
        30.0 * 2.0 * xi[1] * xi[2] * (lamb[2] * xi[1] + lamb_p[1] * xi[2]);
      psi2(0, 1, 0) = 3.0 * b[0] * 2.0 * xi[1] * xi[2] * (xi[1] - xi[2]) +
                      3.0 * 2.0 * xi[0] * (b[2] * xi[1] - b[1] * xi[2]) *
                        (xi[0] + 4.0 * xi[1] + 4.0 * xi[2]) +
                      6.0 * xi[0] * xi[0] * (b[2] * xi[1] - b[1] * xi[2]) +
                      15 * 2.0 * xi[1] * xi[2] *
                        (b[2] * lamb[2] * xi[1] - b[1] * lamb_p[1] * xi[2]);
      psi2(0, 2, 0) = -6.0 * c[0] * xi[1] * xi[2] * (xi[1] - xi[2]) -
                      3.0 * 2.0 * xi[0] * (c[2] * xi[1] - c[1] * xi[2]) *
                        (xi[0] + 4.0 * xi[1] + 4.0 * xi[2]) -
                      6.0 * xi[0] * xi[0] * (c[2] * xi[1] - c[1] * xi[2]) -
                      15.0 * 2.0 * xi[1] * xi[2] *
                        (c[2] * lamb[2] * xi[1] - c[1] * lamb_p[1] * xi[2]);
      psi2(0, 3, 0) =
        3.0 * xi[0] *
          (b[2] * b[2] * xi[1] * xi[1] + b[1] * b[1] * xi[2] * xi[2]) +
        2.0 * xi[1] * xi[2] *
          (-b[1] * b[2] * xi[0] + b[2] * b[0] * xi[1] + b[0] * b[1] * xi[2]) -
        4.0 * xi[0] * xi[1] * xi[2] * (b[1] * b[2]) +
        5.0 * xi[1] * xi[2] *
          (b[2] * b[2] * lamb[2] * xi[1] + b[1] * b[1] * lamb_p[1] * xi[2]);
      psi2(0, 4, 0) =
        3.0 * xi[0] *
          (c[2] * c[2] * xi[1] * xi[1] + c[1] * c[1] * xi[2] * xi[2]) +
        2.0 * xi[1] * xi[2] *
          (-c[1] * c[2] * xi[0] + c[2] * c[0] * xi[1] + c[0] * c[1] * xi[2]) -
        4.0 * xi[0] * xi[1] * xi[2] * (c[1] * c[2]) +
        5.0 * xi[1] * xi[2] *
          (c[2] * c[2] * lamb[2] * xi[1] + c[1] * c[1] * lamb_p[1] * xi[2]);
      psi2(0, 5, 0) =
        b[0] * c[0] * 2.0 * xi[1] * xi[2] * (xi[0] + xi[1] + xi[2]) +
        b[0] * c[0] * 2.0 * xi[0] * xi[1] * xi[2] +
        b[0] * c[0] * 2.0 * xi[0] * xi[1] * xi[2] +
        b[1] * c[1] * 2.0 * xi[2] *
          (xi[1] * xi[2] - xi[2] * xi[0] - xi[0] * xi[1] - xi[1] * xi[1]) -
        b[1] * c[1] * 4.0 * xi[0] * xi[2] * (xi[2] + xi[1]) +
        b[2] * c[2] * 2.0 * xi[1] *
          (xi[1] * xi[2] - xi[2] * xi[0] - xi[0] * xi[1] - xi[2] * xi[2]) -
        b[2] * c[2] * 4.0 * xi[0] * xi[1] * (xi[2] + xi[1]) -
        5.0 * 2.0 * xi[1] * xi[2] *
          (b[1] * c[1] * lamb_p[1] * xi[2] + b[2] * c[2] * lamb[2] * xi[1]);

      // compute for the second derivative wrt area coordinate1
      psi2(0, 0, 1) = 10.0 * xi[0] * xi[0] * xi[0] * 2.0 +
                      30.0 * xi[0] * xi[0] * xi[2] * (lamb[2]) +
                      30.0 * xi[0] * xi[0] * xi[2] * (lamb[2]);
      psi2(0, 1, 1) = 3.0 * b[0] * xi[0] * xi[0] * xi[2] +
                      3.0 * b[0] * xi[0] * xi[0] * xi[2] +
                      xi[0] * xi[0] * xi[0] * (b[2]) * (4.0) +
                      xi[0] * xi[0] * xi[0] * (b[2]) * (4.0) +
                      15 * xi[0] * xi[0] * xi[2] * (b[2] * lamb[2]) +
                      15 * xi[0] * xi[0] * xi[2] * (b[2] * lamb[2]);
      psi2(0, 2, 1) = -6.0 * c[0] * xi[0] * xi[0] * xi[2] -
                      8.0 * xi[0] * xi[0] * xi[0] * (c[2]) -
                      30.0 * xi[0] * xi[0] * xi[2] * (c[2] * lamb[2]);
      psi2(0, 3, 1) = xi[0] * xi[0] * xi[0] * (b[2] * b[2]) +
                      2.0 * xi[0] * xi[0] * xi[2] * (b[2] * b[0]) +
                      5.0 * xi[0] * xi[0] * xi[2] * (b[2] * b[2] * lamb[2]);
      psi2(0, 4, 1) = xi[0] * xi[0] * xi[0] * (c[2] * c[2]) +
                      2.0 * xi[0] * xi[0] * xi[2] * (c[2] * c[0]) +
                      5.0 * xi[0] * xi[0] * xi[2] * (c[2] * c[2] * lamb[2]);
      psi2(0, 5, 1) = b[0] * c[0] * xi[0] * xi[0] * xi[2] +
                      b[0] * c[0] * xi[0] * xi[0] * xi[2] -
                      2.0 * b[1] * c[1] * xi[0] * xi[0] * xi[2] -
                      2.0 * b[2] * c[2] * xi[0] * xi[0] * (xi[0] - xi[2]) -
                      10.0 * xi[0] * xi[0] * xi[2] * (b[2] * c[2] * lamb[2]);

      // compute for the second derivative wrt area coordinate2
      psi2(0, 0, 2) = 10.0 * xi[0] * xi[0] * xi[0] * 2.0 +
                      30.0 * xi[0] * xi[0] * xi[1] * (lamb_p[1]) +
                      30.0 * xi[0] * xi[0] * xi[1] * (lamb_p[1]);
      psi2(0, 1, 2) = -6.0 * b[0] * xi[0] * xi[0] * xi[1] -
                      8.0 * xi[0] * xi[0] * xi[0] * (b[1]) -
                      30.0 * xi[0] * xi[0] * xi[1] * (b[1] * lamb_p[1]);
      psi2(0, 2, 2) = 6.0 * c[0] * xi[0] * xi[0] * xi[1] +
                      8.0 * xi[0] * xi[0] * xi[0] * (c[1]) +
                      30.0 * xi[0] * xi[0] * xi[1] * (c[1] * lamb_p[1]);
      psi2(0, 3, 2) = xi[0] * xi[0] * xi[0] * (b[1] * b[1]) +
                      2.0 * xi[0] * xi[0] * xi[1] * (b[0] * b[1]) +
                      5.0 * xi[0] * xi[0] * xi[1] * (b[1] * b[1] * lamb_p[1]);
      psi2(0, 4, 2) = xi[0] * xi[0] * xi[0] * (c[1] * c[1]) +
                      2.0 * xi[0] * xi[0] * xi[1] * (c[0] * c[1]) +
                      5.0 * xi[0] * xi[0] * xi[1] * (c[1] * c[1] * lamb_p[1]);
      psi2(0, 5, 2) = b[0] * c[0] * xi[0] * xi[0] * xi[1] +
                      b[0] * c[0] * xi[0] * xi[0] * xi[1] +
                      b[1] * c[1] * xi[0] * xi[0] * (xi[1] - xi[0]) +
                      b[1] * c[1] * xi[0] * xi[0] * (xi[1] - xi[0]) +
                      b[2] * c[2] * xi[0] * xi[0] * xi[1] * (-2.0) -
                      5.0 * xi[0] * xi[0] * xi[1] * (b[1] * c[1] * lamb_p[1]) -
                      5.0 * xi[0] * xi[0] * xi[1] * (b[1] * c[1] * lamb_p[1]);

      // compute for the mixed-derivative wrt area coordinate0 and 1
      psi2(0, 0, 3) =
        5.0 * 4.0 * xi[0] * xi[0] * xi[0] +
        10.0 * 3.0 * xi[0] * xi[0] * 2.0 * (xi[1] + xi[2]) +
        30.0 * 2.0 * xi[0] * xi[2] * (lamb[2] * xi[1] + lamb_p[1] * xi[2]) +
        30.0 * 2.0 * xi[0] * xi[1] * xi[2] * (lamb[2]);
      psi2(0, 1, 3) =
        3.0 * b[0] * 2.0 * xi[0] * xi[2] * (xi[1] - xi[2]) +
        3.0 * b[0] * 2.0 * xi[0] * xi[1] * xi[2] +
        3.0 * xi[0] * xi[0] * (b[2]) * (xi[0] + 4.0 * xi[1] + 4.0 * xi[2]) +
        3.0 * xi[0] * xi[0] * (b[2] * xi[1] - b[1] * xi[2]) * (4.0) +
        xi[0] * xi[0] * xi[0] * (b[2]) +
        15 * 2.0 * xi[0] * xi[2] *
          (b[2] * lamb[2] * xi[1] - b[1] * lamb_p[1] * xi[2]) +
        15 * 2.0 * xi[0] * xi[1] * xi[2] * (b[2] * lamb[2]);
      psi2(0, 2, 3) =
        -3.0 * c[0] * 2.0 * xi[0] * xi[2] * (xi[1] - xi[2]) -
        3.0 * c[0] * 2.0 * xi[0] * xi[1] * xi[2] -
        3.0 * xi[0] * xi[0] * (c[2]) * (xi[0] + 4.0 * xi[1] + 4.0 * xi[2]) -
        3.0 * xi[0] * xi[0] * (c[2] * xi[1] - c[1] * xi[2]) * (4.0) -
        xi[0] * xi[0] * xi[0] * (c[2]) -
        15.0 * 2.0 * xi[0] * xi[2] *
          (c[2] * lamb[2] * xi[1] - c[1] * lamb_p[1] * xi[2]) -
        15.0 * 2.0 * xi[0] * xi[1] * xi[2] * (c[2] * lamb[2]);
      psi2(0, 3, 3) =
        3.0 * xi[0] * xi[0] * (b[2] * b[2] * xi[1]) +
        2.0 * xi[0] * xi[2] *
          (-b[1] * b[2] * xi[0] + b[2] * b[0] * xi[1] + b[0] * b[1] * xi[2]) +
        2.0 * xi[0] * xi[1] * xi[2] * (b[2] * b[0]) +
        5.0 / 2.0 * 2.0 * xi[0] * xi[2] *
          (b[2] * b[2] * lamb[2] * xi[1] + b[1] * b[1] * lamb_p[1] * xi[2]) +
        5.0 / 2.0 * 2.0 * xi[0] * xi[1] * xi[2] * (b[2] * b[2] * lamb[2]) +
        xi[0] * xi[0] * xi[2] * (-b[1]) * b[2];
      psi2(0, 4, 3) =
        3.0 * xi[0] * xi[0] * (c[2] * c[2] * xi[1]) +
        2.0 * xi[0] * xi[2] *
          (-c[1] * c[2] * xi[0] + c[2] * c[0] * xi[1] + c[0] * c[1] * xi[2]) +
        2.0 * xi[0] * xi[1] * xi[2] * (c[2] * c[0]) +
        5.0 * xi[0] * xi[2] *
          (c[2] * c[2] * lamb[2] * xi[1] + c[1] * c[1] * lamb_p[1] * xi[2]) +
        5.0 * xi[0] * xi[1] * xi[2] * (c[2] * c[2] * lamb[2]) +
        xi[0] * xi[0] * xi[2] * (-c[1]) * c[2];
      psi2(0, 5, 3) =
        b[0] * c[0] * 2.0 * xi[0] * xi[2] * (xi[0] + xi[1] + xi[2]) +
        b[0] * c[0] * 2.0 * xi[0] * xi[1] * xi[2] +
        b[0] * c[0] * xi[0] * xi[0] * xi[2] +
        b[1] * c[1] * 2.0 * xi[0] * xi[2] * (xi[2] - xi[0] - 2.0 * xi[1]) +
        b[1] * c[1] * xi[0] * xi[0] * xi[2] * (-1.0) +
        b[2] * c[2] * 2.0 * xi[0] *
          (xi[1] * xi[2] - xi[2] * xi[0] - xi[0] * xi[1] - xi[2] * xi[2]) +
        b[2] * c[2] * 2.0 * xi[0] * xi[1] * (xi[2] - xi[0]) +
        b[2] * c[2] * xi[0] * xi[0] * (-xi[2] - xi[1]) +
        b[2] * c[2] * xi[0] * xi[0] * xi[1] * (-1.0) -
        5.0 * 2.0 * xi[0] * xi[2] *
          (b[1] * c[1] * lamb_p[1] * xi[2] + b[2] * c[2] * lamb[2] * xi[1]) -
        5.0 * 2.0 * xi[0] * xi[1] * xi[2] * (b[2] * c[2] * lamb[2]);

      // compute for the mixed-derivative wrt area coordinate0 and 2
      psi2(0, 0, 4) =
        5.0 * 4.0 * xi[0] * xi[0] * xi[0] +
        10.0 * 3.0 * xi[0] * xi[0] * 2.0 * (xi[1] + xi[2]) +
        30.0 * 2.0 * xi[0] * xi[1] * (lamb[2] * xi[1] + lamb_p[1] * xi[2]) +
        30.0 * 2.0 * xi[0] * xi[1] * xi[2] * (lamb_p[1]);
      psi2(0, 1, 4) =
        3.0 * b[0] * 2.0 * xi[0] * xi[1] * (xi[1] - xi[2]) +
        3.0 * b[0] * 2.0 * xi[0] * xi[1] * xi[2] * (-1.0) -
        3.0 * xi[0] * xi[0] * (b[1]) * (xi[0] + 4.0 * xi[1] + 4.0 * xi[2]) +
        3.0 * xi[0] * xi[0] * (b[2] * xi[1] - b[1] * xi[2]) * (4.0) +
        xi[0] * xi[0] * xi[0] * (-b[1]) +
        15 * 2.0 * xi[0] * xi[1] *
          (b[2] * lamb[2] * xi[1] - b[1] * lamb_p[1] * xi[2]) -
        15 * 2.0 * xi[0] * xi[1] * xi[2] * (b[1] * lamb_p[1]);
      psi2(0, 2, 4) =
        -3.0 * c[0] * 2.0 * xi[0] * xi[1] * (xi[1] - xi[2]) +
        3.0 * c[0] * 2.0 * xi[0] * xi[1] * xi[2] +
        3.0 * xi[0] * xi[0] * (c[1]) * (xi[0] + 4.0 * xi[1] + 4.0 * xi[2]) -
        3.0 * xi[0] * xi[0] * (c[2] * xi[1] - c[1] * xi[2]) * (4.0) +
        xi[0] * xi[0] * xi[0] * (c[1]) -
        15.0 * 2.0 * xi[0] * xi[1] *
          (c[2] * lamb[2] * xi[1] - c[1] * lamb_p[1] * xi[2]) +
        15.0 * 2.0 * xi[0] * xi[1] * xi[2] * (c[1] * lamb_p[1]);
      psi2(0, 3, 4) =
        3.0 * xi[0] * xi[0] * (b[1] * b[1] * xi[2]) +
        2.0 * xi[0] * xi[1] *
          (-b[1] * b[2] * xi[0] + b[2] * b[0] * xi[1] + b[0] * b[1] * xi[2]) +
        2.0 * xi[0] * xi[1] * xi[2] * (b[0] * b[1]) +
        5.0 / 2.0 * 2.0 * xi[0] * xi[1] *
          (b[2] * b[2] * lamb[2] * xi[1] + b[1] * b[1] * lamb_p[1] * xi[2]) +
        5.0 / 2.0 * 2.0 * xi[0] * xi[1] * xi[2] * (b[1] * b[1] * lamb_p[1]) +
        xi[0] * xi[0] * xi[1] * (-b[1]) * b[2];
      psi2(0, 4, 4) =
        3.0 * xi[0] * xi[0] * (c[1] * c[1] * xi[2]) +
        2.0 * xi[0] * xi[1] *
          (-c[1] * c[2] * xi[0] + c[2] * c[0] * xi[1] + c[0] * c[1] * xi[2]) +
        2.0 * xi[0] * xi[1] * xi[2] * (c[0] * c[1]) +
        5.0 * xi[0] * xi[1] *
          (c[2] * c[2] * lamb[2] * xi[1] + c[1] * c[1] * lamb_p[1] * xi[2]) +
        5.0 * xi[0] * xi[1] * xi[2] * (c[1] * c[1] * lamb_p[1]) -
        xi[0] * xi[0] * xi[1] * (c[1]) * c[2];
      psi2(0, 5, 4) =
        b[0] * c[0] * 2.0 * xi[0] * xi[1] * xi[2] +
        b[0] * c[0] * 2.0 * xi[0] * xi[1] * (xi[0] + xi[1] + xi[2]) +
        b[0] * c[0] * xi[0] * xi[0] * xi[1] +
        b[1] * c[1] * 2.0 * xi[0] *
          (xi[1] * xi[2] - xi[2] * xi[0] - xi[0] * xi[1] - xi[1] * xi[1]) +
        b[1] * c[1] * 2.0 * xi[0] * xi[2] * (xi[1] - xi[0]) +
        b[1] * c[1] * xi[0] * xi[0] * (-xi[1] - xi[2]) +
        b[1] * c[1] * xi[0] * xi[0] * xi[2] * (-1.0) +
        b[2] * c[2] * 2.0 * xi[0] * xi[1] * (xi[1] - xi[0] - 2.0 * xi[2]) +
        b[2] * c[2] * xi[0] * xi[0] * xi[1] * (-1.0) -
        5.0 * 2.0 * xi[0] * xi[1] *
          (b[1] * c[1] * lamb_p[1] * xi[2] + b[2] * c[2] * lamb[2] * xi[1]) -
        5.0 * 2.0 * xi[0] * xi[1] * xi[2] * (b[1] * c[1] * lamb_p[1]);

      // compute for the mixed-derivative wrt area coordinate1 and 2
      psi2(0, 0, 5) =
        10.0 * xi[0] * xi[0] * xi[0] * 2.0 +
        30.0 * xi[0] * xi[0] * (lamb[2] * xi[1] + lamb_p[1] * xi[2]) +
        30.0 * xi[0] * xi[0] * xi[2] * (lamb_p[1]) +
        30.0 * xi[0] * xi[0] * xi[1] * (lamb[2]);
      psi2(0, 1, 5) = 3.0 * b[0] * xi[0] * xi[0] * (xi[1] - xi[2]) -
                      3.0 * b[0] * xi[0] * xi[0] * xi[2] +
                      3.0 * b[0] * xi[0] * xi[0] * xi[1] +
                      xi[0] * xi[0] * xi[0] * (-b[1]) * (4.0) +
                      xi[0] * xi[0] * xi[0] * (b[2]) * (4.0) +
                      15 * xi[0] * xi[0] *
                        (b[2] * lamb[2] * xi[1] - b[1] * lamb_p[1] * xi[2]) +
                      15 * xi[0] * xi[0] * xi[2] * (-b[1] * lamb_p[1]) +
                      15 * xi[0] * xi[0] * xi[1] * (b[2] * lamb[2]);
      psi2(0, 2, 5) = -3.0 * c[0] * xi[0] * xi[0] * xi[1] +
                      3.0 * c[0] * xi[0] * xi[0] * xi[2] -
                      3.0 * c[0] * xi[0] * xi[0] * (xi[1] - xi[2]) +
                      xi[0] * xi[0] * xi[0] * (c[1]) * (4.0) -
                      xi[0] * xi[0] * xi[0] * (c[2]) * (4.0) -
                      15.0 * xi[0] * xi[0] * xi[1] * (c[2] * lamb[2]) +
                      15.0 * xi[0] * xi[0] * xi[2] * (c[1] * lamb_p[1]) -
                      15.0 * xi[0] * xi[0] *
                        (c[2] * lamb[2] * xi[1] - c[1] * lamb_p[1] * xi[2]);
      psi2(0, 3, 5) =
        xi[0] * xi[0] * xi[2] * (b[0] * b[1]) +
        xi[0] * xi[0] *
          (-b[1] * b[2] * xi[0] + b[2] * b[0] * xi[1] + b[0] * b[1] * xi[2]) +
        xi[0] * xi[0] * xi[1] * (b[2] * b[0]) +
        5.0 / 2.0 * xi[0] * xi[0] * xi[2] * (b[1] * b[1] * lamb_p[1]) +
        5.0 / 2.0 * xi[0] * xi[0] *
          (b[2] * b[2] * lamb[2] * xi[1] + b[1] * b[1] * lamb_p[1] * xi[2]) +
        5.0 / 2.0 * xi[0] * xi[0] * xi[1] * (b[2] * b[2] * lamb[2]);
      psi2(0, 4, 5) =
        xi[0] * xi[0] * xi[1] * (c[2] * c[0]) +
        xi[0] * xi[0] *
          (-c[1] * c[2] * xi[0] + c[2] * c[0] * xi[1] + c[0] * c[1] * xi[2]) +
        xi[0] * xi[0] * xi[2] * (c[0] * c[1]) +
        5.0 / 2.0 * xi[0] * xi[0] * xi[1] * (c[2] * c[2] * lamb[2]) +
        5.0 / 2.0 * xi[0] * xi[0] *
          (c[2] * c[2] * lamb[2] * xi[1] + c[1] * c[1] * lamb_p[1] * xi[2]) +
        5.0 / 2.0 * xi[0] * xi[0] * xi[2] * (c[1] * c[1] * lamb_p[1]);
      psi2(0, 5, 5) =
        b[0] * c[0] * xi[0] * xi[0] * xi[1] +
        b[0] * c[0] * xi[0] * xi[0] * (xi[0] + xi[1] + xi[2]) +
        b[0] * c[0] * xi[0] * xi[0] * xi[2] +
        b[1] * c[1] * xi[0] * xi[0] * (xi[2] - xi[0] - 2.0 * xi[1]) +
        b[1] * c[1] * xi[0] * xi[0] * xi[2] +
        b[2] * c[2] * xi[0] * xi[0] * (xi[1] - xi[0] - 2.0 * xi[2]) +
        b[2] * c[2] * xi[0] * xi[0] * xi[1] -
        5.0 * xi[0] * xi[0] *
          (b[1] * c[1] * lamb_p[1] * xi[2] + b[2] * c[2] * lamb[2] * xi[1]) -
        5.0 * xi[0] * xi[0] * xi[2] * (b[1] * c[1] * lamb_p[1]) -
        5.0 * xi[0] * xi[0] * xi[1] * (b[2] * c[2] * lamb[2]);

      // by chain rule, we can obtain d2shape wrt s0s0 at node0
      d2psids(0, 0, 0) =
        (psi2(0, 0, 0) * dxids0[0] + psi2(0, 0, 3) * dxids0[1] +
         psi2(0, 0, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(0, 0, 3) * dxids0[0] + psi2(0, 0, 1) * dxids0[1] +
         psi2(0, 0, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(0, 0, 4) * dxids0[0] + psi2(0, 0, 5) * dxids0[1] +
         psi2(0, 0, 2) * dxids0[2]) *
          dxids0[2];
      d2psids(0, 1, 0) =
        (psi2(0, 1, 0) * dxids0[0] + psi2(0, 1, 3) * dxids0[1] +
         psi2(0, 1, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(0, 1, 3) * dxids0[0] + psi2(0, 1, 1) * dxids0[1] +
         psi2(0, 1, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(0, 1, 4) * dxids0[0] + psi2(0, 1, 5) * dxids0[1] +
         psi2(0, 1, 2) * dxids0[2]) *
          dxids0[2];
      d2psids(0, 2, 0) =
        (psi2(0, 2, 0) * dxids0[0] + psi2(0, 2, 3) * dxids0[1] +
         psi2(0, 2, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(0, 2, 3) * dxids0[0] + psi2(0, 2, 1) * dxids0[1] +
         psi2(0, 2, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(0, 2, 4) * dxids0[0] + psi2(0, 2, 5) * dxids0[1] +
         psi2(0, 2, 2) * dxids0[2]) *
          dxids0[2];
      d2psids(0, 3, 0) =
        (psi2(0, 3, 0) * dxids0[0] + psi2(0, 3, 3) * dxids0[1] +
         psi2(0, 3, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(0, 3, 3) * dxids0[0] + psi2(0, 3, 1) * dxids0[1] +
         psi2(0, 3, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(0, 3, 4) * dxids0[0] + psi2(0, 3, 5) * dxids0[1] +
         psi2(0, 3, 2) * dxids0[2]) *
          dxids0[2];
      d2psids(0, 4, 0) =
        (psi2(0, 4, 0) * dxids0[0] + psi2(0, 4, 3) * dxids0[1] +
         psi2(0, 4, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(0, 4, 3) * dxids0[0] + psi2(0, 4, 1) * dxids0[1] +
         psi2(0, 4, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(0, 4, 4) * dxids0[0] + psi2(0, 4, 5) * dxids0[1] +
         psi2(0, 4, 2) * dxids0[2]) *
          dxids0[2];
      d2psids(0, 5, 0) =
        (psi2(0, 5, 0) * dxids0[0] + psi2(0, 5, 3) * dxids0[1] +
         psi2(0, 5, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(0, 5, 3) * dxids0[0] + psi2(0, 5, 1) * dxids0[1] +
         psi2(0, 5, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(0, 5, 4) * dxids0[0] + psi2(0, 5, 5) * dxids0[1] +
         psi2(0, 5, 2) * dxids0[2]) *
          dxids0[2];

      // by chain rule, we can obtain d2shape wrt s1s1 at node0
      d2psids(0, 0, 1) =
        (psi2(0, 0, 0) * dxids1[0] + psi2(0, 0, 3) * dxids1[1] +
         psi2(0, 0, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(0, 0, 3) * dxids1[0] + psi2(0, 0, 1) * dxids1[1] +
         psi2(0, 0, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(0, 0, 4) * dxids1[0] + psi2(0, 0, 5) * dxids1[1] +
         psi2(0, 0, 2) * dxids1[2]) *
          dxids1[2];
      d2psids(0, 1, 1) =
        (psi2(0, 1, 0) * dxids1[0] + psi2(0, 1, 3) * dxids1[1] +
         psi2(0, 1, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(0, 1, 3) * dxids1[0] + psi2(0, 1, 1) * dxids1[1] +
         psi2(0, 1, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(0, 1, 4) * dxids1[0] + psi2(0, 1, 5) * dxids1[1] +
         psi2(0, 1, 2) * dxids1[2]) *
          dxids1[2];
      d2psids(0, 2, 1) =
        (psi2(0, 2, 0) * dxids1[0] + psi2(0, 2, 3) * dxids1[1] +
         psi2(0, 2, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(0, 2, 3) * dxids1[0] + psi2(0, 2, 1) * dxids1[1] +
         psi2(0, 2, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(0, 2, 4) * dxids1[0] + psi2(0, 2, 5) * dxids1[1] +
         psi2(0, 2, 2) * dxids1[2]) *
          dxids1[2];
      d2psids(0, 3, 1) =
        (psi2(0, 3, 0) * dxids1[0] + psi2(0, 3, 3) * dxids1[1] +
         psi2(0, 3, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(0, 3, 3) * dxids1[0] + psi2(0, 3, 1) * dxids1[1] +
         psi2(0, 3, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(0, 3, 4) * dxids1[0] + psi2(0, 3, 5) * dxids1[1] +
         psi2(0, 3, 2) * dxids1[2]) *
          dxids1[2];
      d2psids(0, 4, 1) =
        (psi2(0, 4, 0) * dxids1[0] + psi2(0, 4, 3) * dxids1[1] +
         psi2(0, 4, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(0, 4, 3) * dxids1[0] + psi2(0, 4, 1) * dxids1[1] +
         psi2(0, 4, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(0, 4, 4) * dxids1[0] + psi2(0, 4, 5) * dxids1[1] +
         psi2(0, 4, 2) * dxids1[2]) *
          dxids1[2];
      d2psids(0, 5, 1) =
        (psi2(0, 5, 0) * dxids1[0] + psi2(0, 5, 3) * dxids1[1] +
         psi2(0, 5, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(0, 5, 3) * dxids1[0] + psi2(0, 5, 1) * dxids1[1] +
         psi2(0, 5, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(0, 5, 4) * dxids1[0] + psi2(0, 5, 5) * dxids1[1] +
         psi2(0, 5, 2) * dxids1[2]) *
          dxids1[2];

      // by chain rule, we can obtain d2shape wrt s0s1 at node0
      d2psids(0, 0, 2) =
        (psi2(0, 0, 0) * dxids0[0] + psi2(0, 0, 3) * dxids0[1] +
         psi2(0, 0, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(0, 0, 3) * dxids0[0] + psi2(0, 0, 1) * dxids0[1] +
         psi2(0, 0, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(0, 0, 4) * dxids0[0] + psi2(0, 0, 5) * dxids0[1] +
         psi2(0, 0, 2) * dxids0[2]) *
          dxids1[2];
      d2psids(0, 1, 2) =
        (psi2(0, 1, 0) * dxids0[0] + psi2(0, 1, 3) * dxids0[1] +
         psi2(0, 1, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(0, 1, 3) * dxids0[0] + psi2(0, 1, 1) * dxids0[1] +
         psi2(0, 1, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(0, 1, 4) * dxids0[0] + psi2(0, 1, 5) * dxids0[1] +
         psi2(0, 1, 2) * dxids0[2]) *
          dxids1[2];
      d2psids(0, 2, 2) =
        (psi2(0, 2, 0) * dxids0[0] + psi2(0, 2, 3) * dxids0[1] +
         psi2(0, 2, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(0, 2, 3) * dxids0[0] + psi2(0, 2, 1) * dxids0[1] +
         psi2(0, 2, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(0, 2, 4) * dxids0[0] + psi2(0, 2, 5) * dxids0[1] +
         psi2(0, 2, 2) * dxids0[2]) *
          dxids1[2];
      d2psids(0, 3, 2) =
        (psi2(0, 3, 0) * dxids0[0] + psi2(0, 3, 3) * dxids0[1] +
         psi2(0, 3, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(0, 3, 3) * dxids0[0] + psi2(0, 3, 1) * dxids0[1] +
         psi2(0, 3, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(0, 3, 4) * dxids0[0] + psi2(0, 3, 5) * dxids0[1] +
         psi2(0, 3, 2) * dxids0[2]) *
          dxids1[2];
      d2psids(0, 4, 2) =
        (psi2(0, 4, 0) * dxids0[0] + psi2(0, 4, 3) * dxids0[1] +
         psi2(0, 4, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(0, 4, 3) * dxids0[0] + psi2(0, 4, 1) * dxids0[1] +
         psi2(0, 4, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(0, 4, 4) * dxids0[0] + psi2(0, 4, 5) * dxids0[1] +
         psi2(0, 4, 2) * dxids0[2]) *
          dxids1[2];
      d2psids(0, 5, 2) =
        (psi2(0, 5, 0) * dxids0[0] + psi2(0, 5, 3) * dxids0[1] +
         psi2(0, 5, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(0, 5, 3) * dxids0[0] + psi2(0, 5, 1) * dxids0[1] +
         psi2(0, 5, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(0, 5, 4) * dxids0[0] + psi2(0, 5, 5) * dxids0[1] +
         psi2(0, 5, 2) * dxids0[2]) *
          dxids1[2];
      //-------------------------------------------------------------------------------------
      // compute for all second derivatives at node 1
      //------------------------------------------------------------------------------------
      // compute for the second derivatives wrt area coordinate1
      psi2(1, 0, 1) =
        5.0 * 4.0 * xi[1] * xi[1] * xi[1] +
        5.0 * 4.0 * 3.0 * xi[1] * xi[1] * (xi[2] + xi[0]) +
        10.0 * 3.0 * 2.0 * xi[1] * (xi[2] + xi[0]) * (xi[2] + xi[0]) +
        30.0 * 2.0 * xi[2] * xi[0] * (lamb[0] * xi[2] + lamb_p[2] * xi[0]);
      psi2(1, 1, 1) = 3.0 * b[1] * 2.0 * xi[2] * xi[0] * (xi[2] - xi[0]) +
                      3.0 * 2.0 * xi[1] * (b[0] * xi[2] - b[2] * xi[0]) *
                        (xi[1] + 4.0 * xi[2] + 4.0 * xi[0]) +
                      3.0 * xi[1] * xi[1] * (b[0] * xi[2] - b[2] * xi[0]) +
                      3.0 * xi[1] * xi[1] * (b[0] * xi[2] - b[2] * xi[0]) +
                      15 * 2.0 * xi[2] * xi[0] *
                        (b[0] * lamb[0] * xi[2] - b[2] * lamb_p[2] * xi[0]);
      psi2(1, 2, 1) = -3.0 * c[1] * 2.0 * xi[2] * xi[0] * (xi[2] - xi[0]) -
                      3.0 * 2.0 * xi[1] * (c[0] * xi[2] - c[2] * xi[0]) *
                        (xi[1] + 4.0 * xi[2] + 4.0 * xi[0]) -
                      3.0 * xi[1] * xi[1] * (c[0] * xi[2] - c[2] * xi[0]) -
                      3.0 * xi[1] * xi[1] * (c[0] * xi[2] - c[2] * xi[0]) -
                      15.0 * 2.0 * xi[2] * xi[0] *
                        (c[0] * lamb[0] * xi[2] - c[2] * lamb_p[2] * xi[0]);
      psi2(1, 3, 1) =
        1.0 / 2.0 * 3.0 * 2.0 * xi[1] *
          (b[0] * b[0] * xi[2] * xi[2] + b[2] * b[2] * xi[0] * xi[0]) +
        2.0 * xi[2] * xi[0] *
          (-b[2] * b[0] * xi[1] + b[0] * b[1] * xi[2] + b[1] * b[2] * xi[0]) -
        4.0 * xi[1] * xi[2] * xi[0] * (b[2] * b[0]) +
        5.0 * xi[2] * xi[0] *
          (b[0] * b[0] * lamb[0] * xi[2] + b[2] * b[2] * lamb_p[2] * xi[0]);
      psi2(1, 4, 1) =
        1.0 / 2.0 * 3.0 * 2.0 * xi[1] *
          (c[0] * c[0] * xi[2] * xi[2] + c[2] * c[2] * xi[0] * xi[0]) +
        2.0 * xi[2] * xi[0] *
          (-c[2] * c[0] * xi[1] + c[0] * c[1] * xi[2] + c[1] * c[2] * xi[0]) -
        4.0 * xi[1] * xi[2] * xi[0] * (c[2] * c[0]) +
        5.0 * xi[2] * xi[0] *
          (c[0] * c[0] * lamb[0] * xi[2] + c[2] * c[2] * lamb_p[2] * xi[0]);
      psi2(1, 5, 1) =
        b[1] * c[1] * 2.0 * xi[2] * xi[0] * (xi[1] + xi[2] + xi[0]) +
        b[1] * c[1] * 2.0 * xi[1] * xi[2] * xi[0] +
        b[1] * c[1] * 2.0 * xi[1] * xi[2] * xi[0] +
        b[2] * c[2] * 2.0 * xi[0] *
          (xi[2] * xi[0] - xi[0] * xi[1] - xi[1] * xi[2] - xi[2] * xi[2]) -
        4.0 * b[2] * c[2] * xi[1] * xi[0] * (xi[0] + xi[2]) +
        b[0] * c[0] * 2.0 * xi[2] *
          (xi[2] * xi[0] - xi[0] * xi[1] - xi[1] * xi[2] - xi[0] * xi[0]) -
        4.0 * b[0] * c[0] * 2.0 * xi[1] * xi[2] * (xi[0] + xi[2]) -
        5.0 * 2.0 * xi[2] * xi[0] *
          (b[2] * c[2] * lamb_p[2] * xi[0] + b[0] * c[0] * lamb[0] * xi[2]);

      // compute for the second derivatives wrt area coordinate2
      psi2(1, 0, 2) = 10.0 * xi[1] * xi[1] * xi[1] * 2.0 +
                      30.0 * xi[1] * xi[1] * xi[0] * (lamb[0]) +
                      30.0 * xi[1] * xi[1] * xi[0] * (lamb[0]);
      psi2(1, 1, 2) = 3.0 * b[1] * xi[1] * xi[1] * xi[0] +
                      3.0 * b[1] * xi[1] * xi[1] * xi[0] +
                      xi[1] * xi[1] * xi[1] * (b[0]) * (4.0) +
                      xi[1] * xi[1] * xi[1] * (b[0]) * (4.0) +
                      15 * xi[1] * xi[1] * xi[0] * (b[0] * lamb[0]) +
                      15 * xi[1] * xi[1] * xi[0] * (b[0] * lamb[0]);
      psi2(1, 2, 2) = -3.0 * c[1] * xi[1] * xi[1] * xi[0] -
                      3.0 * c[1] * xi[1] * xi[1] * xi[0] -
                      xi[1] * xi[1] * xi[1] * (c[0]) * (4.0) -
                      xi[1] * xi[1] * xi[1] * (c[0]) * (4.0) -
                      15.0 * xi[1] * xi[1] * xi[0] * (c[0] * lamb[0]) -
                      15.0 * xi[1] * xi[1] * xi[0] * (c[0] * lamb[0]);
      psi2(1, 3, 2) = 1.0 / 2.0 * xi[1] * xi[1] * xi[1] * (b[0] * b[0] * 2.0) +
                      xi[1] * xi[1] * xi[0] * (b[0] * b[1]) +
                      xi[1] * xi[1] * xi[0] * (b[0] * b[1]) +
                      5.0 * xi[1] * xi[1] * xi[0] * (b[0] * b[0] * lamb[0]);
      psi2(1, 4, 2) = 1.0 / 2.0 * xi[1] * xi[1] * xi[1] * (c[0] * c[0] * 2.0) +
                      xi[1] * xi[1] * xi[0] * (c[0] * c[1]) +
                      xi[1] * xi[1] * xi[0] * (c[0] * c[1]) +
                      5.0 * xi[1] * xi[1] * xi[0] * (c[0] * c[0] * lamb[0]);
      psi2(1, 5, 2) = b[1] * c[1] * xi[1] * xi[1] * xi[0] +
                      b[1] * c[1] * xi[1] * xi[1] * xi[0] +
                      b[2] * c[2] * xi[1] * xi[1] * xi[0] * (-2.0) +
                      b[0] * c[0] * xi[1] * xi[1] * (xi[0] - xi[1]) +
                      b[0] * c[0] * xi[1] * xi[1] * (xi[0] - xi[1]) -
                      5.0 * xi[1] * xi[1] * xi[0] * (b[0] * c[0] * lamb[0]) -
                      5.0 * xi[1] * xi[1] * xi[0] * (b[0] * c[0] * lamb[0]);

      // compute for the second derivatives wrt area coordinate0
      psi2(1, 0, 0) = 10.0 * xi[1] * xi[1] * xi[1] * 2.0 +
                      30.0 * xi[1] * xi[1] * xi[2] * (lamb_p[2]) +
                      30.0 * xi[1] * xi[1] * xi[2] * (lamb_p[2]);
      psi2(1, 1, 0) = -6.0 * b[1] * xi[1] * xi[1] * xi[2] +
                      xi[1] * xi[1] * xi[1] * (-b[2]) * (4.0) +
                      xi[1] * xi[1] * xi[1] * (-b[2]) * (4.0) -
                      30 * xi[1] * xi[1] * xi[2] * (b[2] * lamb_p[2]);
      psi2(1, 2, 0) = 3.0 * c[1] * xi[1] * xi[1] * xi[2] +
                      3.0 * c[1] * xi[1] * xi[1] * xi[2] +
                      xi[1] * xi[1] * xi[1] * (c[2]) * (4.0) +
                      xi[1] * xi[1] * xi[1] * (c[2]) * (4.0) +
                      30.0 * xi[1] * xi[1] * xi[2] * (c[2] * lamb_p[2]);
      psi2(1, 3, 0) = xi[1] * xi[1] * xi[1] * (b[2] * b[2]) +
                      2.0 * xi[1] * xi[1] * xi[2] * (b[1] * b[2]) +
                      5.0 * xi[1] * xi[1] * xi[2] * (b[2] * b[2] * lamb_p[2]);
      psi2(1, 4, 0) = xi[1] * xi[1] * xi[1] * (c[2] * c[2]) +
                      2.0 * xi[1] * xi[1] * xi[2] * (c[1] * c[2]) +
                      5.0 * xi[1] * xi[1] * xi[2] * (c[2] * c[2] * lamb_p[2]);
      psi2(1, 5, 0) = 2.0 * b[1] * c[1] * xi[1] * xi[1] * xi[2] +
                      b[2] * c[2] * xi[1] * xi[1] * (xi[2] - xi[1]) +
                      b[2] * c[2] * xi[1] * xi[1] * (xi[2] - xi[1]) +
                      b[0] * c[0] * xi[1] * xi[1] * xi[2] * (-2.0) -
                      5.0 * xi[1] * xi[1] * xi[2] * (b[2] * c[2] * lamb_p[2]) -
                      5.0 * xi[1] * xi[1] * xi[2] * (b[2] * c[2] * lamb_p[2]);

      // compute for the second derivatives wrt area coordinate0 and 1
      psi2(1, 0, 3) =
        5.0 * 4.0 * xi[1] * xi[1] * xi[1] +
        10.0 * 3.0 * xi[1] * xi[1] * 2.0 * (xi[2] + xi[0]) +
        30.0 * 2.0 * xi[1] * xi[2] * xi[0] * (lamb_p[2]) +
        30.0 * 2.0 * xi[1] * xi[2] * (lamb[0] * xi[2] + lamb_p[2] * xi[0]);
      psi2(1, 1, 3) =
        3.0 * b[1] * 2.0 * xi[1] * xi[2] * (xi[2] - xi[0]) +
        3.0 * b[1] * 2.0 * xi[1] * xi[2] * xi[0] * (-1.0) +
        3.0 * xi[1] * xi[1] * (-b[2]) * (xi[1] + 4.0 * xi[2] + 4.0 * xi[0]) +
        3.0 * xi[1] * xi[1] * (b[0] * xi[2] - b[2] * xi[0]) * (4.0) +
        xi[1] * xi[1] * xi[1] * (-b[2]) +
        15 * 2.0 * xi[1] * xi[2] *
          (b[0] * lamb[0] * xi[2] - b[2] * lamb_p[2] * xi[0]) +
        15 * 2.0 * xi[1] * xi[2] * xi[0] * (-b[2] * lamb_p[2]);
      psi2(1, 2, 3) =
        3.0 * c[1] * 2.0 * xi[1] * xi[2] * xi[0] -
        3.0 * c[1] * 2.0 * xi[1] * xi[2] * (xi[2] - xi[0]) -
        3.0 * xi[1] * xi[1] * (c[0] * xi[2] - c[2] * xi[0]) * (4.0) +
        3.0 * xi[1] * xi[1] * (c[2]) * (xi[1] + 4.0 * xi[2] + 4.0 * xi[0]) +
        xi[1] * xi[1] * xi[1] * (c[2]) +
        15.0 * 2.0 * xi[1] * xi[2] * xi[0] * (c[2] * lamb_p[2]) -
        15.0 * 2.0 * xi[1] * xi[2] *
          (c[0] * lamb[0] * xi[2] - c[2] * lamb_p[2] * xi[0]);
      psi2(1, 3, 3) =
        3.0 * xi[1] * xi[1] * (b[2] * b[2] * xi[0]) +
        2.0 * xi[1] * xi[2] *
          (-b[2] * b[0] * xi[1] + b[0] * b[1] * xi[2] + b[1] * b[2] * xi[0]) +
        2.0 * xi[1] * xi[2] * xi[0] * (b[1] * b[2]) +
        5.0 / 2.0 * 2.0 * xi[1] * xi[2] *
          (b[0] * b[0] * lamb[0] * xi[2] + b[2] * b[2] * lamb_p[2] * xi[0]) +
        5.0 / 2.0 * 2.0 * xi[1] * xi[2] * xi[0] * (b[2] * b[2] * lamb_p[2]) +
        xi[1] * xi[1] * xi[2] * (-b[2]) * b[0];
      psi2(1, 4, 3) =
        3.0 * xi[1] * xi[1] * (c[2] * c[2] * xi[0]) +
        2.0 * xi[1] * xi[2] *
          (-c[2] * c[0] * xi[1] + c[0] * c[1] * xi[2] + c[1] * c[2] * xi[0]) +
        2.0 * xi[1] * xi[2] * xi[0] * (c[1] * c[2]) +
        5.0 / 2.0 * 2.0 * xi[1] * xi[2] *
          (c[0] * c[0] * lamb[0] * xi[2] + c[2] * c[2] * lamb_p[2] * xi[0]) +
        5.0 / 2.0 * 2.0 * xi[1] * xi[2] * xi[0] * (c[2] * c[2] * lamb_p[2]) +
        xi[1] * xi[1] * xi[2] * (-c[2]) * c[0];
      psi2(1, 5, 3) =
        b[1] * c[1] * 2.0 * xi[1] * xi[2] * xi[0] +
        b[1] * c[1] * 2.0 * xi[1] * xi[2] * (xi[1] + xi[2] + xi[0]) +
        b[1] * c[1] * xi[1] * xi[1] * xi[2] +
        b[2] * c[2] * 2.0 * xi[1] *
          (xi[2] * xi[0] - xi[0] * xi[1] - xi[1] * xi[2] - xi[2] * xi[2]) +
        b[2] * c[2] * 2.0 * xi[1] * xi[0] * (xi[2] - xi[1]) +
        b[2] * c[2] * xi[1] * xi[1] * (-xi[2] - xi[0]) +
        b[2] * c[2] * xi[1] * xi[1] * xi[0] * (-1.0) +
        b[0] * c[0] * 2.0 * xi[1] * xi[2] * (xi[2] - xi[1] - 2.0 * xi[0]) +
        b[0] * c[0] * xi[1] * xi[1] * xi[2] * (-1.0) -
        5.0 * 2.0 * xi[1] * xi[2] *
          (b[2] * c[2] * lamb_p[2] * xi[0] + b[0] * c[0] * lamb[0] * xi[2]) -
        5.0 * 2.0 * xi[1] * xi[2] * xi[0] * (b[2] * c[2] * lamb_p[2]);

      // compute for the second derivatives wrt area coordinate0 and 2
      psi2(1, 0, 4) =
        10.0 * xi[1] * xi[1] * xi[1] * 2.0 +
        30.0 * xi[1] * xi[1] * (lamb[0] * xi[2] + lamb_p[2] * xi[0]) +
        30.0 * xi[1] * xi[1] * xi[0] * (lamb_p[2]) +
        30.0 * xi[1] * xi[1] * xi[2] * (lamb[0]);
      psi2(1, 1, 4) = 3.0 * b[1] * xi[1] * xi[1] * (xi[2] - xi[0]) +
                      3.0 * b[1] * xi[1] * xi[1] * xi[0] * (-1.0) +
                      3.0 * b[1] * xi[1] * xi[1] * xi[2] +
                      xi[1] * xi[1] * xi[1] * (-b[2]) * (4.0) +
                      xi[1] * xi[1] * xi[1] * (b[0]) * (4.0) +
                      15 * xi[1] * xi[1] *
                        (b[0] * lamb[0] * xi[2] - b[2] * lamb_p[2] * xi[0]) +
                      15 * xi[1] * xi[1] * xi[0] * (-b[2] * lamb_p[2]) +
                      15 * xi[1] * xi[1] * xi[2] * (b[0] * lamb[0]);
      psi2(1, 2, 4) = 3.0 * c[1] * xi[1] * xi[1] * xi[0] -
                      3.0 * c[1] * xi[1] * xi[1] * (xi[2] - xi[0]) -
                      3.0 * c[1] * xi[1] * xi[1] * xi[2] -
                      xi[1] * xi[1] * xi[1] * (c[0]) * (4.0) +
                      4.0 * xi[1] * xi[1] * xi[1] * (c[2]) +
                      15.0 * xi[1] * xi[1] * xi[0] * (c[2] * lamb_p[2]) -
                      15.0 * xi[1] * xi[1] *
                        (c[0] * lamb[0] * xi[2] - c[2] * lamb_p[2] * xi[0]) -
                      15.0 * xi[1] * xi[1] * xi[2] * (c[0] * lamb[0]);
      psi2(1, 3, 4) =
        xi[1] * xi[1] * xi[0] * (b[1] * b[2]) +
        xi[1] * xi[1] *
          (-b[2] * b[0] * xi[1] + b[0] * b[1] * xi[2] + b[1] * b[2] * xi[0]) +
        xi[1] * xi[1] * xi[2] * (b[0] * b[1]) +
        5.0 / 2.0 * xi[1] * xi[1] * xi[0] * (b[2] * b[2] * lamb_p[2]) +
        5.0 / 2.0 * xi[1] * xi[1] *
          (b[0] * b[0] * lamb[0] * xi[2] + b[2] * b[2] * lamb_p[2] * xi[0]) +
        5.0 / 2.0 * xi[1] * xi[1] * xi[2] * (b[0] * b[0] * lamb[0]);
      psi2(1, 4, 4) =
        xi[1] * xi[1] * xi[2] * (c[0] * c[1]) +
        xi[1] * xi[1] *
          (-c[2] * c[0] * xi[1] + c[0] * c[1] * xi[2] + c[1] * c[2] * xi[0]) +
        xi[1] * xi[1] * xi[0] * (c[1] * c[2]) +
        5.0 / 2.0 * xi[1] * xi[1] * xi[2] * (c[0] * c[0] * lamb[0]) +
        5.0 / 2.0 * xi[1] * xi[1] *
          (c[0] * c[0] * lamb[0] * xi[2] + c[2] * c[2] * lamb_p[2] * xi[0]) +
        5.0 / 2.0 * xi[1] * xi[1] * xi[0] * (c[2] * c[2] * lamb_p[2]);
      psi2(1, 5, 4) =
        b[1] * c[1] * xi[1] * xi[1] * xi[2] +
        b[1] * c[1] * xi[1] * xi[1] * (xi[1] + xi[2] + xi[0]) +
        b[1] * c[1] * xi[1] * xi[1] * xi[0] +
        b[2] * c[2] * xi[1] * xi[1] * (xi[0] - xi[1] - 2.0 * xi[2]) +
        b[2] * c[2] * xi[1] * xi[1] * xi[0] +
        b[0] * c[0] * xi[1] * xi[1] * xi[2] +
        b[0] * c[0] * xi[1] * xi[1] * (xi[2] - xi[1] - 2.0 * xi[0]) -
        5.0 * xi[1] * xi[1] * xi[2] * (b[0] * c[0] * lamb[0]) -
        5.0 * xi[1] * xi[1] *
          (b[2] * c[2] * lamb_p[2] * xi[0] + b[0] * c[0] * lamb[0] * xi[2]) -
        5.0 * xi[1] * xi[1] * xi[0] * (b[2] * c[2] * lamb_p[2]);

      // compute for the second derivatives wrt area coordinate1 and 2
      psi2(1, 0, 5) =
        5.0 * 4.0 * xi[1] * xi[1] * xi[1] +
        10.0 * 3.0 * xi[1] * xi[1] * 2.0 * (xi[2] + xi[0]) +
        30.0 * 2.0 * xi[1] * xi[0] * (lamb[0] * xi[2] + lamb_p[2] * xi[0]) +
        30.0 * 2.0 * xi[1] * xi[2] * xi[0] * (lamb[0]);
      psi2(1, 1, 5) =
        3.0 * b[1] * 2.0 * xi[1] * xi[0] * (xi[2] - xi[0]) +
        3.0 * b[1] * 2.0 * xi[1] * xi[2] * xi[0] +
        3.0 * xi[1] * xi[1] * (b[0]) * (xi[1] + 4.0 * xi[2] + 4.0 * xi[0]) +
        3.0 * xi[1] * xi[1] * (b[0] * xi[2] - b[2] * xi[0]) * (4.0) +
        xi[1] * xi[1] * xi[1] * (b[0]) +
        15 * 2.0 * xi[1] * xi[0] *
          (b[0] * lamb[0] * xi[2] - b[2] * lamb_p[2] * xi[0]) +
        15 * 2.0 * xi[1] * xi[2] * xi[0] * (b[0] * lamb[0]);
      psi2(1, 2, 5) =
        -3.0 * c[1] * 2.0 * xi[1] * xi[0] * (xi[2] - xi[0]) -
        3.0 * c[1] * 2.0 * xi[1] * xi[2] * xi[0] -
        3.0 * xi[1] * xi[1] * (c[0]) * (xi[1] + 4.0 * xi[2] + 4.0 * xi[0]) -
        3.0 * xi[1] * xi[1] * (c[0] * xi[2] - c[2] * xi[0]) * (4.0) -
        xi[1] * xi[1] * xi[1] * (c[0]) -
        15.0 * 2.0 * xi[1] * xi[0] *
          (c[0] * lamb[0] * xi[2] - c[2] * lamb_p[2] * xi[0]) -
        15.0 * 2.0 * xi[1] * xi[2] * xi[0] * (c[0] * lamb[0]);
      psi2(1, 3, 5) =
        3.0 * xi[1] * xi[1] * (b[0] * b[0] * xi[2]) +
        2.0 * xi[1] * xi[0] *
          (-b[2] * b[0] * xi[1] + b[0] * b[1] * xi[2] + b[1] * b[2] * xi[0]) +
        2.0 * xi[1] * xi[2] * xi[0] * (b[0] * b[1]) +
        5.0 / 2.0 * 2.0 * xi[1] * xi[0] *
          (b[0] * b[0] * lamb[0] * xi[2] + b[2] * b[2] * lamb_p[2] * xi[0]) +
        5.0 / 2.0 * 2.0 * xi[1] * xi[2] * xi[0] * (b[0] * b[0] * lamb[0]) +
        xi[1] * xi[1] * xi[0] * (-b[2]) * b[0];
      psi2(1, 4, 5) =
        3.0 * xi[1] * xi[1] * (c[0] * c[0] * xi[2]) +
        2.0 * xi[1] * xi[0] *
          (-c[2] * c[0] * xi[1] + c[0] * c[1] * xi[2] + c[1] * c[2] * xi[0]) +
        2.0 * xi[1] * xi[2] * xi[0] * (c[0] * c[1]) +
        5.0 / 2.0 * 2.0 * xi[1] * xi[0] *
          (c[0] * c[0] * lamb[0] * xi[2] + c[2] * c[2] * lamb_p[2] * xi[0]) +
        5.0 / 2.0 * 2.0 * xi[1] * xi[2] * xi[0] * (c[0] * c[0] * lamb[0]) +
        xi[1] * xi[1] * xi[0] * (-c[2]) * c[0];
      psi2(1, 5, 5) =
        b[1] * c[1] * 2.0 * xi[1] * xi[0] * (xi[1] + xi[2] + xi[0]) +
        b[1] * c[1] * 2.0 * xi[1] * xi[2] * xi[0] +
        b[1] * c[1] * xi[1] * xi[1] * xi[0] +
        b[2] * c[2] * 2.0 * xi[1] * xi[0] * (xi[0] - xi[1] - 2.0 * xi[2]) +
        b[2] * c[2] * xi[1] * xi[1] * xi[0] * (-1.0) +
        b[0] * c[0] * 2.0 * xi[1] *
          (xi[2] * xi[0] - xi[0] * xi[1] - xi[1] * xi[2] - xi[0] * xi[0]) +
        b[0] * c[0] * 2.0 * xi[1] * xi[2] * (xi[0] - xi[1]) +
        b[0] * c[0] * xi[1] * xi[1] * (-xi[0] - xi[2]) +
        b[0] * c[0] * xi[1] * xi[1] * xi[2] * (-1.0) -
        5.0 * 2.0 * xi[1] * xi[0] *
          (b[2] * c[2] * lamb_p[2] * xi[0] + b[0] * c[0] * lamb[0] * xi[2]) -
        5.0 * 2.0 * xi[1] * xi[2] * xi[0] * (b[0] * c[0] * lamb[0]);

      // by chain rule, we can obtain d2shape wrt s0s0 at node1
      d2psids(1, 0, 0) =
        (psi2(1, 0, 0) * dxids0[0] + psi2(1, 0, 3) * dxids0[1] +
         psi2(1, 0, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(1, 0, 3) * dxids0[0] + psi2(1, 0, 1) * dxids0[1] +
         psi2(1, 0, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(1, 0, 4) * dxids0[0] + psi2(1, 0, 5) * dxids0[1] +
         psi2(1, 0, 2) * dxids0[2]) *
          dxids0[2];
      d2psids(1, 1, 0) =
        (psi2(1, 1, 0) * dxids0[0] + psi2(1, 1, 3) * dxids0[1] +
         psi2(1, 1, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(1, 1, 3) * dxids0[0] + psi2(1, 1, 1) * dxids0[1] +
         psi2(1, 1, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(1, 1, 4) * dxids0[0] + psi2(1, 1, 5) * dxids0[1] +
         psi2(1, 1, 2) * dxids0[2]) *
          dxids0[2];
      d2psids(1, 2, 0) =
        (psi2(1, 2, 0) * dxids0[0] + psi2(1, 2, 3) * dxids0[1] +
         psi2(1, 2, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(1, 2, 3) * dxids0[0] + psi2(1, 2, 1) * dxids0[1] +
         psi2(1, 2, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(1, 2, 4) * dxids0[0] + psi2(1, 2, 5) * dxids0[1] +
         psi2(1, 2, 2) * dxids0[2]) *
          dxids0[2];
      d2psids(1, 3, 0) =
        (psi2(1, 3, 0) * dxids0[0] + psi2(1, 3, 3) * dxids0[1] +
         psi2(1, 3, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(1, 3, 3) * dxids0[0] + psi2(1, 3, 1) * dxids0[1] +
         psi2(1, 3, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(1, 3, 4) * dxids0[0] + psi2(1, 3, 5) * dxids0[1] +
         psi2(1, 3, 2) * dxids0[2]) *
          dxids0[2];
      d2psids(1, 4, 0) =
        (psi2(1, 4, 0) * dxids0[0] + psi2(1, 4, 3) * dxids0[1] +
         psi2(1, 4, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(1, 4, 3) * dxids0[0] + psi2(1, 4, 1) * dxids0[1] +
         psi2(1, 4, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(1, 4, 4) * dxids0[0] + psi2(1, 4, 5) * dxids0[1] +
         psi2(1, 4, 2) * dxids0[2]) *
          dxids0[2];
      d2psids(1, 5, 0) =
        (psi2(1, 5, 0) * dxids0[0] + psi2(1, 5, 3) * dxids0[1] +
         psi2(1, 5, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(1, 5, 3) * dxids0[0] + psi2(1, 5, 1) * dxids0[1] +
         psi2(1, 5, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(1, 5, 4) * dxids0[0] + psi2(1, 5, 5) * dxids0[1] +
         psi2(1, 5, 2) * dxids0[2]) *
          dxids0[2];

      // by chain rule, we can obtain d2shape wrt s1s1 at node1
      d2psids(1, 0, 1) =
        (psi2(1, 0, 0) * dxids1[0] + psi2(1, 0, 3) * dxids1[1] +
         psi2(1, 0, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(1, 0, 3) * dxids1[0] + psi2(1, 0, 1) * dxids1[1] +
         psi2(1, 0, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(1, 0, 4) * dxids1[0] + psi2(1, 0, 5) * dxids1[1] +
         psi2(1, 0, 2) * dxids1[2]) *
          dxids1[2];
      d2psids(1, 1, 1) =
        (psi2(1, 1, 0) * dxids1[0] + psi2(1, 1, 3) * dxids1[1] +
         psi2(1, 1, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(1, 1, 3) * dxids1[0] + psi2(1, 1, 1) * dxids1[1] +
         psi2(1, 1, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(1, 1, 4) * dxids1[0] + psi2(1, 1, 5) * dxids1[1] +
         psi2(1, 1, 2) * dxids1[2]) *
          dxids1[2];
      d2psids(1, 2, 1) =
        (psi2(1, 2, 0) * dxids1[0] + psi2(1, 2, 3) * dxids1[1] +
         psi2(1, 2, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(1, 2, 3) * dxids1[0] + psi2(1, 2, 1) * dxids1[1] +
         psi2(1, 2, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(1, 2, 4) * dxids1[0] + psi2(1, 2, 5) * dxids1[1] +
         psi2(1, 2, 2) * dxids1[2]) *
          dxids1[2];
      d2psids(1, 3, 1) =
        (psi2(1, 3, 0) * dxids1[0] + psi2(1, 3, 3) * dxids1[1] +
         psi2(1, 3, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(1, 3, 3) * dxids1[0] + psi2(1, 3, 1) * dxids1[1] +
         psi2(1, 3, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(1, 3, 4) * dxids1[0] + psi2(1, 3, 5) * dxids1[1] +
         psi2(1, 3, 2) * dxids1[2]) *
          dxids1[2];
      d2psids(1, 4, 1) =
        (psi2(1, 4, 0) * dxids1[0] + psi2(1, 4, 3) * dxids1[1] +
         psi2(1, 4, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(1, 4, 3) * dxids1[0] + psi2(1, 4, 1) * dxids1[1] +
         psi2(1, 4, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(1, 4, 4) * dxids1[0] + psi2(1, 4, 5) * dxids1[1] +
         psi2(1, 4, 2) * dxids1[2]) *
          dxids1[2];
      d2psids(1, 5, 1) =
        (psi2(1, 5, 0) * dxids1[0] + psi2(1, 5, 3) * dxids1[1] +
         psi2(1, 5, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(1, 5, 3) * dxids1[0] + psi2(1, 5, 1) * dxids1[1] +
         psi2(1, 5, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(1, 5, 4) * dxids1[0] + psi2(1, 5, 5) * dxids1[1] +
         psi2(1, 5, 2) * dxids1[2]) *
          dxids1[2];

      // by chain rule, we can obtain d2shape wrt s0s1 at node1
      d2psids(1, 0, 2) =
        (psi2(1, 0, 0) * dxids0[0] + psi2(1, 0, 3) * dxids0[1] +
         psi2(1, 0, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(1, 0, 3) * dxids0[0] + psi2(1, 0, 1) * dxids0[1] +
         psi2(1, 0, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(1, 0, 4) * dxids0[0] + psi2(1, 0, 5) * dxids0[1] +
         psi2(1, 0, 2) * dxids0[2]) *
          dxids1[2];
      d2psids(1, 1, 2) =
        (psi2(1, 1, 0) * dxids0[0] + psi2(1, 1, 3) * dxids0[1] +
         psi2(1, 1, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(1, 1, 3) * dxids0[0] + psi2(1, 1, 1) * dxids0[1] +
         psi2(1, 1, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(1, 1, 4) * dxids0[0] + psi2(1, 1, 5) * dxids0[1] +
         psi2(1, 1, 2) * dxids0[2]) *
          dxids1[2];
      d2psids(1, 2, 2) =
        (psi2(1, 2, 0) * dxids0[0] + psi2(1, 2, 3) * dxids0[1] +
         psi2(1, 2, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(1, 2, 3) * dxids0[0] + psi2(1, 2, 1) * dxids0[1] +
         psi2(1, 2, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(1, 2, 4) * dxids0[0] + psi2(1, 2, 5) * dxids0[1] +
         psi2(1, 2, 2) * dxids0[2]) *
          dxids1[2];
      d2psids(1, 3, 2) =
        (psi2(1, 3, 0) * dxids0[0] + psi2(1, 3, 3) * dxids0[1] +
         psi2(1, 3, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(1, 3, 3) * dxids0[0] + psi2(1, 3, 1) * dxids0[1] +
         psi2(1, 3, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(1, 3, 4) * dxids0[0] + psi2(1, 3, 5) * dxids0[1] +
         psi2(1, 3, 2) * dxids0[2]) *
          dxids1[2];
      d2psids(1, 4, 2) =
        (psi2(1, 4, 0) * dxids0[0] + psi2(1, 4, 3) * dxids0[1] +
         psi2(1, 4, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(1, 4, 3) * dxids0[0] + psi2(1, 4, 1) * dxids0[1] +
         psi2(1, 4, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(1, 4, 4) * dxids0[0] + psi2(1, 4, 5) * dxids0[1] +
         psi2(1, 4, 2) * dxids0[2]) *
          dxids1[2];
      d2psids(1, 5, 2) =
        (psi2(1, 5, 0) * dxids0[0] + psi2(1, 5, 3) * dxids0[1] +
         psi2(1, 5, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(1, 5, 3) * dxids0[0] + psi2(1, 5, 1) * dxids0[1] +
         psi2(1, 5, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(1, 5, 4) * dxids0[0] + psi2(1, 5, 5) * dxids0[1] +
         psi2(1, 5, 2) * dxids0[2]) *
          dxids1[2];
      //-------------------------------------------------------------------------------------
      // compute for all second derivatives at node 2
      //------------------------------------------------------------------------------------
      // compute for the second derivatives wrt area coordinate2
      psi2(2, 0, 2) =
        5.0 * 4.0 * xi[2] * xi[2] * xi[2] +
        5.0 * 4.0 * 3.0 * xi[2] * xi[2] * (xi[0] + xi[1]) +
        10.0 * 3.0 * 2.0 * xi[2] * (xi[0] + xi[1]) * (xi[0] + xi[1]) +
        30.0 * 2.0 * xi[0] * xi[1] * (lamb[1] * xi[0] + lamb_p[0] * xi[1]);
      psi2(2, 1, 2) = 3.0 * b[2] * 2.0 * xi[0] * xi[1] * (xi[0] - xi[1]) +
                      6.0 * xi[2] * xi[2] * (b[1] * xi[0] - b[0] * xi[1]) +
                      30.0 * xi[0] * xi[1] *
                        (b[1] * lamb[1] * xi[0] - b[0] * lamb_p[0] * xi[1]) +
                      3.0 * 2.0 * xi[2] * (b[1] * xi[0] - b[0] * xi[1]) *
                        (xi[2] + 4.0 * xi[0] + 4 * xi[1]);
      psi2(2, 2, 2) = -3.0 * c[2] * 2.0 * xi[0] * xi[1] * (xi[0] - xi[1]) -
                      3.0 * 2.0 * xi[2] * (c[1] * xi[0] - c[0] * xi[1]) *
                        (xi[2] + 4.0 * xi[0] + 4.0 * xi[1]) -
                      6.0 * xi[2] * xi[2] * (c[1] * xi[0] - c[0] * xi[1]) -
                      15.0 * 2.0 * xi[0] * xi[1] *
                        (c[1] * lamb[1] * xi[0] - c[0] * lamb_p[0] * xi[1]);
      psi2(2, 3, 2) =
        1.0 / 2.0 * 3.0 * 2.0 * xi[2] *
          (b[1] * b[1] * xi[0] * xi[0] + b[0] * b[0] * xi[1] * xi[1]) +
        2.0 * xi[0] * xi[1] *
          (-b[0] * b[1] * xi[2] + b[1] * b[2] * xi[0] + b[2] * b[0] * xi[1]) +
        2.0 * xi[2] * xi[0] * xi[1] * (-b[0] * b[1]) +
        5.0 / 2.0 * 2.0 * xi[0] * xi[1] *
          (b[1] * b[1] * lamb[1] * xi[0] + b[0] * b[0] * lamb_p[0] * xi[1]) +
        2.0 * xi[2] * xi[0] * xi[1] * (-b[0]) * b[1];
      psi2(2, 4, 2) =
        1.0 / 2.0 * 3.0 * 2.0 * xi[2] *
          (c[1] * c[1] * xi[0] * xi[0] + c[0] * c[0] * xi[1] * xi[1]) +
        2.0 * xi[0] * xi[1] *
          (-c[0] * c[1] * xi[2] + c[1] * c[2] * xi[0] + c[2] * c[0] * xi[1]) +
        2.0 * xi[2] * xi[0] * xi[1] * (-c[0] * c[1]) +
        5.0 / 2.0 * 2.0 * xi[0] * xi[1] *
          (c[1] * c[1] * lamb[1] * xi[0] + c[0] * c[0] * lamb_p[0] * xi[1]) +
        2.0 * xi[2] * xi[0] * xi[1] * (-c[0]) * c[1];
      psi2(2, 5, 2) =
        b[2] * c[2] * 2.0 * xi[0] * xi[1] * (xi[2] + xi[0] + xi[1]) +
        b[2] * c[2] * 2.0 * xi[2] * xi[0] * xi[1] +
        b[2] * c[2] * 2.0 * xi[2] * xi[0] * xi[1] +
        b[0] * c[0] * 2.0 * xi[1] *
          (xi[0] * xi[1] - xi[1] * xi[2] - xi[2] * xi[0] - xi[0] * xi[0]) +
        b[0] * c[0] * 2.0 * xi[2] * xi[1] * (-1.0 * xi[1] - 1.0 * xi[0]) +
        b[0] * c[0] * 2.0 * xi[2] * xi[1] * (-xi[0] - xi[1]) +
        b[1] * c[1] * 2.0 * xi[0] *
          (xi[0] * xi[1] - xi[1] * xi[2] - xi[2] * xi[0] - xi[1] * xi[1]) +
        b[1] * c[1] * 2.0 * xi[2] * xi[0] * (-xi[1] - xi[0]) +
        b[1] * c[1] * 2.0 * xi[2] * xi[0] * (-xi[1] - xi[0]) -
        5.0 * 2.0 * xi[0] * xi[1] *
          (b[0] * c[0] * lamb_p[0] * xi[1] + b[1] * c[1] * lamb[1] * xi[0]);

      // compute for the second derivatives wrt area coordinate0
      psi2(2, 0, 0) = 10.0 * xi[2] * xi[2] * xi[2] * 2.0 +
                      60.0 * xi[2] * xi[2] * xi[1] * (lamb[1]);
      psi2(2, 1, 0) = 6.0 * b[2] * xi[2] * xi[2] * xi[1] +
                      xi[2] * xi[2] * xi[2] * (b[1]) * (8.0) +
                      30 * xi[2] * xi[2] * xi[1] * (b[1] * lamb[1]);
      psi2(2, 2, 0) = -6.0 * c[2] * xi[2] * xi[2] * xi[1] -
                      xi[2] * xi[2] * xi[2] * (c[1]) * (8.0) -
                      30.0 * xi[2] * xi[2] * xi[1] * (c[1] * lamb[1]);
      psi2(2, 3, 0) =
        1.0 / 2.0 * xi[2] * xi[2] * xi[2] * (b[1] * b[1] * 2.0) +
        xi[2] * xi[2] * xi[1] * (b[1] * b[2]) +
        xi[2] * xi[2] * xi[1] * (b[1] * b[2]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[1] * (b[1] * b[1] * lamb[1]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[1] * (b[1] * b[1] * lamb[1]);
      psi2(2, 4, 0) =
        1.0 / 2.0 * xi[2] * xi[2] * xi[2] * (c[1] * c[1] * 2.0) +
        xi[2] * xi[2] * xi[1] * (c[1] * c[2]) +
        xi[2] * xi[2] * xi[1] * (c[1] * c[2]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[1] * (c[1] * c[1] * lamb[1]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[1] * (c[1] * c[1] * lamb[1]);
      psi2(2, 5, 0) = b[2] * c[2] * xi[2] * xi[2] * xi[1] +
                      b[2] * c[2] * xi[2] * xi[2] * xi[1] +
                      b[0] * c[0] * xi[2] * xi[2] * xi[1] * (-2.0) +
                      b[1] * c[1] * xi[2] * xi[2] * (xi[1] - xi[2]) +
                      b[1] * c[1] * xi[2] * xi[2] * (xi[1] - xi[2]) -
                      5.0 * xi[2] * xi[2] * xi[1] * (b[1] * c[1] * lamb[1]) -
                      5.0 * xi[2] * xi[2] * xi[1] * (b[1] * c[1] * lamb[1]);

      // compute for the second derivatives wrt area coordinate1
      psi2(2, 0, 1) = 10.0 * xi[2] * xi[2] * xi[2] * 2.0 +
                      30.0 * xi[2] * xi[2] * xi[0] * (lamb_p[0]) +
                      30.0 * xi[2] * xi[2] * xi[0] * (lamb_p[0]);
      psi2(2, 1, 1) = -30.0 * b[0] * lamb_p[0] * xi[0] * xi[2] * xi[2] -
                      6.0 * b[2] * xi[2] * xi[2] * xi[0] -
                      xi[2] * xi[2] * xi[2] * (b[0]) * (8.0);
      psi2(2, 2, 1) = 6.0 * c[2] * xi[2] * xi[2] * xi[0] +
                      xi[2] * xi[2] * xi[2] * (c[0]) * (8.0) +
                      30.0 * xi[2] * xi[2] * xi[0] * (c[0] * lamb_p[0]);
      psi2(2, 3, 1) =
        1.0 / 2.0 * xi[2] * xi[2] * xi[2] * (b[0] * b[0] * 2.0) +
        xi[2] * xi[2] * xi[0] * (b[2] * b[0]) +
        xi[2] * xi[2] * xi[0] * (b[2] * b[0]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[0] * (b[0] * b[0] * lamb_p[0]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[0] * (b[0] * b[0] * lamb_p[0]);
      psi2(2, 4, 1) =
        1.0 / 2.0 * xi[2] * xi[2] * xi[2] * (c[0] * c[0] * 2.0) +
        xi[2] * xi[2] * xi[0] * (c[2] * c[0]) +
        xi[2] * xi[2] * xi[0] * (c[2] * c[0]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[0] * (c[0] * c[0] * lamb_p[0]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[0] * (c[0] * c[0] * lamb_p[0]);
      psi2(2, 5, 1) = b[2] * c[2] * xi[2] * xi[2] * xi[0] +
                      b[2] * c[2] * xi[2] * xi[2] * xi[0] +
                      b[0] * c[0] * xi[2] * xi[2] * (xi[0] - xi[2]) +
                      b[0] * c[0] * xi[2] * xi[2] * (xi[0] - xi[2]) +
                      b[1] * c[1] * xi[2] * xi[2] * xi[0] * (-2.0) -
                      5.0 * xi[2] * xi[2] * xi[0] * (b[0] * c[0] * lamb_p[0]) -
                      5.0 * xi[2] * xi[2] * xi[0] * (b[0] * c[0] * lamb_p[0]);

      // compute for the second derivatives wrt area coordinate0 and 1
      psi2(2, 0, 3) =
        10.0 * xi[2] * xi[2] * xi[2] * 2.0 +
        30.0 * xi[2] * xi[2] * (lamb[1] * xi[0] + lamb_p[0] * xi[1]) +
        30.0 * xi[2] * xi[2] * xi[0] * (lamb[1]) +
        30.0 * xi[2] * xi[2] * xi[1] * (lamb_p[0]);
      psi2(2, 1, 3) = 3.0 * b[2] * xi[2] * xi[2] * (xi[0] - xi[1]) -
                      3.0 * b[2] * xi[2] * xi[2] * xi[1] +
                      3.0 * b[2] * xi[2] * xi[2] * xi[0] +
                      xi[2] * xi[2] * xi[2] * (b[1]) * (4.0) +
                      xi[2] * xi[2] * xi[2] * (-b[0]) * (4.0) +
                      15 * xi[2] * xi[2] *
                        (b[1] * lamb[1] * xi[0] - b[0] * lamb_p[0] * xi[1]) +
                      15 * xi[2] * xi[2] * xi[1] * (-b[0] * lamb_p[0]) +
                      15 * xi[2] * xi[2] * xi[0] * (b[1] * lamb[1]);
      psi2(2, 2, 3) = -3.0 * c[2] * xi[2] * xi[2] * xi[0] +
                      -3.0 * c[2] * xi[2] * xi[2] * (xi[0] - xi[1]) +
                      3.0 * c[2] * xi[2] * xi[2] * xi[1] +
                      xi[2] * xi[2] * xi[2] * (c[0]) * (4.0) -
                      xi[2] * xi[2] * xi[2] * (c[1]) * (4.0) -
                      15.0 * xi[2] * xi[2] * xi[0] * (c[1] * lamb[1]) -
                      15.0 * xi[2] * xi[2] *
                        (c[1] * lamb[1] * xi[0] - c[0] * lamb_p[0] * xi[1]) +
                      15.0 * xi[2] * xi[2] * xi[1] * (c[0] * lamb_p[0]);
      psi2(2, 3, 3) =
        xi[2] * xi[2] * xi[0] * (b[1] * b[2]) +
        xi[2] * xi[2] *
          (-b[0] * b[1] * xi[2] + b[1] * b[2] * xi[0] + b[2] * b[0] * xi[1]) +
        xi[2] * xi[2] * xi[1] * (b[2] * b[0]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[0] * (b[1] * b[1] * lamb[1]) +
        5.0 / 2.0 * xi[2] * xi[2] *
          (b[1] * b[1] * lamb[1] * xi[0] + b[0] * b[0] * lamb_p[0] * xi[1]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[1] * (b[0] * b[0] * lamb_p[0]);
      psi2(2, 4, 3) =
        xi[2] * xi[2] * xi[0] * (c[1] * c[2]) +
        xi[2] * xi[2] *
          (-c[0] * c[1] * xi[2] + c[1] * c[2] * xi[0] + c[2] * c[0] * xi[1]) +
        xi[2] * xi[2] * xi[1] * (c[2] * c[0]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[0] * (c[1] * c[1] * lamb[1]) +
        5.0 / 2.0 * xi[2] * xi[2] *
          (c[1] * c[1] * lamb[1] * xi[0] + c[0] * c[0] * lamb_p[0] * xi[1]) +
        5.0 / 2.0 * xi[2] * xi[2] * xi[1] * (c[0] * c[0] * lamb_p[0]);
      psi2(2, 5, 3) =
        b[2] * c[2] * xi[2] * xi[2] * xi[0] +
        b[2] * c[2] * xi[2] * xi[2] * (xi[2] + xi[0] + xi[1]) +
        b[2] * c[2] * xi[2] * xi[2] * xi[1] +
        b[0] * c[0] * xi[2] * xi[2] * (xi[1] - xi[2] - 2.0 * xi[0]) +
        b[0] * c[0] * xi[2] * xi[2] * xi[1] +
        b[1] * c[1] * xi[2] * xi[2] * xi[0] +
        b[1] * c[1] * xi[2] * xi[2] * (xi[0] - xi[2] - 2.0 * xi[1]) -
        5.0 * xi[2] * xi[2] * xi[0] * (b[1] * c[1] * lamb[1]) -
        5.0 * xi[2] * xi[2] *
          (b[0] * c[0] * lamb_p[0] * xi[1] + b[1] * c[1] * lamb[1] * xi[0]) -
        5.0 * xi[2] * xi[2] * xi[1] * (b[0] * c[0] * lamb_p[0]);

      // compute for the second derivatives wrt area coordinate0 and 2
      psi2(2, 0, 4) =
        5.0 * 4.0 * xi[2] * xi[2] * xi[2] +
        10.0 * 3.0 * xi[2] * xi[2] * 2.0 * (xi[0] + xi[1]) +
        30.0 * 2.0 * xi[2] * xi[1] * (lamb[1] * xi[0] + lamb_p[0] * xi[1]) +
        30.0 * 2.0 * xi[2] * xi[0] * xi[1] * (lamb[1]);
      psi2(2, 1, 4) =
        3.0 * b[2] * 2.0 * xi[2] * xi[1] * (xi[0] - xi[1]) +
        3.0 * b[2] * 2.0 * xi[2] * xi[0] * xi[1] +
        3.0 * xi[2] * xi[2] * (b[1]) * (xi[2] + 4.0 * xi[0] + 4.0 * xi[1]) +
        xi[2] * xi[2] * xi[2] * (b[1]) +
        12.0 * xi[2] * xi[2] * (b[1] * xi[0] - b[0] * xi[1]) +
        15 * 2.0 * xi[2] * xi[1] *
          (b[1] * lamb[1] * xi[0] - b[0] * lamb_p[0] * xi[1]) +
        15 * 2.0 * xi[2] * xi[0] * xi[1] * (b[1] * lamb[1]);
      psi2(2, 2, 4) =
        -3.0 * c[2] * 2.0 * xi[2] * xi[1] * (xi[0] - xi[1]) -
        3.0 * c[2] * 2.0 * xi[2] * xi[0] * xi[1] -
        3.0 * xi[2] * xi[2] * (c[1]) * (xi[2] + 4.0 * xi[0] + 4.0 * xi[1]) -
        3.0 * xi[2] * xi[2] * (c[1] * xi[0] - c[0] * xi[1]) * (4.0) -
        xi[2] * xi[2] * xi[2] * (c[1]) -
        15.0 * 2.0 * xi[2] * xi[1] *
          (c[1] * lamb[1] * xi[0] - c[0] * lamb_p[0] * xi[1]) -
        15.0 * 2.0 * xi[2] * xi[0] * xi[1] * (c[1] * lamb[1]);
      psi2(2, 3, 4) =
        1.0 / 2.0 * 3.0 * xi[2] * xi[2] * (b[1] * b[1] * 2.0 * xi[0]) +
        2.0 * xi[2] * xi[1] *
          (-b[0] * b[1] * xi[2] + b[1] * b[2] * xi[0] + b[2] * b[0] * xi[1]) +
        2.0 * xi[2] * xi[0] * xi[1] * (b[1] * b[2]) +
        5.0 / 2.0 * 2.0 * xi[2] * xi[1] *
          (b[1] * b[1] * lamb[1] * xi[0] + b[0] * b[0] * lamb_p[0] * xi[1]) +
        5.0 / 2.0 * 2.0 * xi[2] * xi[0] * xi[1] * (b[1] * b[1] * lamb[1]) +
        xi[2] * xi[2] * xi[1] * (-b[0]) * b[1];
      psi2(2, 4, 4) =
        1.0 / 2.0 * 3.0 * xi[2] * xi[2] * (c[1] * c[1] * 2.0 * xi[0]) +
        2.0 * xi[2] * xi[1] *
          (-c[0] * c[1] * xi[2] + c[1] * c[2] * xi[0] + c[2] * c[0] * xi[1]) +
        2.0 * xi[2] * xi[0] * xi[1] * (c[1] * c[2]) +
        5.0 / 2.0 * 2.0 * xi[2] * xi[1] *
          (c[1] * c[1] * lamb[1] * xi[0] + c[0] * c[0] * lamb_p[0] * xi[1]) +
        5.0 / 2.0 * 2.0 * xi[2] * xi[0] * xi[1] * (c[1] * c[1] * lamb[1]) +
        xi[2] * xi[2] * xi[1] * (-c[0]) * c[1];
      psi2(2, 5, 4) =
        b[2] * c[2] * 2.0 * xi[2] * xi[1] * (xi[2] + xi[0] + xi[1]) +
        b[2] * c[2] * 2.0 * xi[2] * xi[0] * xi[1] +
        b[2] * c[2] * xi[2] * xi[2] * xi[1] +
        b[0] * c[0] * 2.0 * xi[2] * xi[1] * (xi[1] - xi[2] - 2.0 * xi[0]) +
        b[0] * c[0] * xi[2] * xi[2] * xi[1] * (-1.0) +
        b[1] * c[1] * 2.0 * xi[2] *
          (xi[0] * xi[1] - xi[1] * xi[2] - xi[2] * xi[0] - xi[1] * xi[1]) +
        b[1] * c[1] * 2.0 * xi[2] * xi[0] * (xi[1] - xi[2]) +
        b[1] * c[1] * xi[2] * xi[2] * (-xi[1] - xi[0]) +
        b[1] * c[1] * xi[2] * xi[2] * xi[0] * (-1.0) -
        5.0 * 2.0 * xi[2] * xi[1] *
          (b[0] * c[0] * lamb_p[0] * xi[1] + b[1] * c[1] * lamb[1] * xi[0]) -
        5.0 * 2.0 * xi[2] * xi[0] * xi[1] * (b[1] * c[1] * lamb[1]);

      // compute for the second derivatives wrt area coordinate1 and 2
      psi2(2, 0, 5) =
        5.0 * 4.0 * xi[2] * xi[2] * xi[2] +
        10.0 * 3.0 * xi[2] * xi[2] * 2.0 * (xi[0] + xi[1]) +
        30.0 * 2.0 * xi[2] * xi[0] * (lamb[1] * xi[0] + lamb_p[0] * xi[1]) +
        60.0 * lamb_p[0] * xi[0] * xi[1] * xi[2];
      psi2(2, 1, 5) =
        3.0 * b[2] * 2.0 * xi[2] * xi[0] * xi[1] * (-1.0) +
        3.0 * b[2] * 2.0 * xi[2] * xi[0] * (xi[0] - xi[1]) +
        12.0 * xi[2] * xi[2] * (b[1] * xi[0] - b[0] * xi[1]) +
        3.0 * xi[2] * xi[2] * (-b[0]) * (xi[2] + 4.0 * xi[0] + 4 * xi[1]) +
        xi[2] * xi[2] * xi[2] * (-b[0]) +
        15 * 2.0 * xi[2] * xi[0] * xi[1] * (-b[0] * lamb_p[0]) +
        15 * 2.0 * xi[2] * xi[0] *
          (b[1] * lamb[1] * xi[0] - b[0] * lamb_p[0] * xi[1]);
      psi2(2, 2, 5) =
        3.0 * c[2] * 2.0 * xi[2] * xi[0] * xi[1] +
        -3.0 * c[2] * 2.0 * xi[2] * xi[0] * (xi[0] - xi[1]) -
        3.0 * xi[2] * xi[2] * (c[1] * xi[0] - c[0] * xi[1]) * (4.0) +
        3.0 * xi[2] * xi[2] * (c[0]) * (xi[2] + 4.0 * xi[0] + 4.0 * xi[1]) +
        xi[2] * xi[2] * xi[2] * (c[0]) +
        15.0 * 2.0 * xi[2] * xi[0] * xi[1] * (c[0] * lamb_p[0]) -
        15.0 * 2.0 * xi[2] * xi[0] *
          (c[1] * lamb[1] * xi[0] - c[0] * lamb_p[0] * xi[1]);
      psi2(2, 3, 5) =
        1.0 / 2.0 * 3.0 * xi[2] * xi[2] * (b[0] * b[0] * 2.0 * xi[1]) +
        2.0 * xi[2] * xi[0] * xi[1] * (b[2] * b[0]) +
        2.0 * xi[2] * xi[0] *
          (-b[0] * b[1] * xi[2] + b[1] * b[2] * xi[0] + b[2] * b[0] * xi[1]) +
        xi[2] * xi[2] * xi[0] * (-b[0] * b[1]) +
        5.0 / 2.0 * 2.0 * xi[2] * xi[0] * xi[1] * (b[0] * b[0] * lamb_p[0]) +
        5.0 / 2.0 * 2.0 * xi[2] * xi[0] *
          (b[1] * b[1] * lamb[1] * xi[0] + b[0] * b[0] * lamb_p[0] * xi[1]);
      psi2(2, 4, 5) =
        3.0 * xi[2] * xi[2] * (c[0] * c[0] * xi[1]) +
        2.0 * xi[2] * xi[0] * xi[1] * (c[2] * c[0]) +
        2.0 * xi[2] * xi[0] *
          (-c[0] * c[1] * xi[2] + c[1] * c[2] * xi[0] + c[2] * c[0] * xi[1]) +
        xi[2] * xi[2] * xi[0] * (-c[0] * c[1]) +
        5.0 / 2.0 * 2.0 * xi[2] * xi[0] * xi[1] * (c[0] * c[0] * lamb_p[0]) +
        5.0 / 2.0 * 2.0 * xi[2] * xi[0] *
          (c[1] * c[1] * lamb[1] * xi[0] + c[0] * c[0] * lamb_p[0] * xi[1]);
      psi2(2, 5, 5) =
        b[2] * c[2] * 2.0 * xi[2] * xi[0] * xi[1] +
        b[2] * c[2] * 2.0 * xi[2] * xi[0] * (xi[2] + xi[0] + xi[1]) +
        b[2] * c[2] * xi[2] * xi[2] * xi[0] +
        b[0] * c[0] * xi[2] * xi[2] * xi[1] * (-1.0) +
        b[0] * c[0] * 2.0 * xi[2] * xi[1] * (xi[0] - xi[2]) +
        b[0] * c[0] * 2.0 * xi[2] *
          (xi[0] * xi[1] - xi[1] * xi[2] - xi[2] * xi[0] - xi[0] * xi[0]) +
        b[0] * c[0] * xi[2] * xi[2] * (-xi[1] - xi[0]) +
        b[1] * c[1] * 2.0 * xi[2] * xi[0] * (xi[0] - xi[2] - 2.0 * xi[1]) +
        b[1] * c[1] * xi[2] * xi[2] * xi[0] * (-1.0) -
        5.0 * 2.0 * xi[2] * xi[0] * xi[1] * (b[0] * c[0] * lamb_p[0]) -
        5.0 * 2.0 * xi[2] * xi[0] *
          (b[0] * c[0] * lamb_p[0] * xi[1] + b[1] * c[1] * lamb[1] * xi[0]);

      // by chain rule, we can obtain d2shape wrt s0s0 at node2
      d2psids(2, 0, 0) =
        (psi2(2, 0, 0) * dxids0[0] + psi2(2, 0, 3) * dxids0[1] +
         psi2(2, 0, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(2, 0, 3) * dxids0[0] + psi2(2, 0, 1) * dxids0[1] +
         psi2(2, 0, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(2, 0, 4) * dxids0[0] + psi2(2, 0, 5) * dxids0[1] +
         psi2(2, 0, 2) * dxids0[2]) *
          dxids0[2];
      d2psids(2, 1, 0) =
        (psi2(2, 1, 0) * dxids0[0] + psi2(2, 1, 3) * dxids0[1] +
         psi2(2, 1, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(2, 1, 3) * dxids0[0] + psi2(2, 1, 1) * dxids0[1] +
         psi2(2, 1, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(2, 1, 4) * dxids0[0] + psi2(2, 1, 5) * dxids0[1] +
         psi2(2, 1, 2) * dxids0[2]) *
          dxids0[2];
      d2psids(2, 2, 0) =
        (psi2(2, 2, 0) * dxids0[0] + psi2(2, 2, 3) * dxids0[1] +
         psi2(2, 2, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(2, 2, 3) * dxids0[0] + psi2(2, 2, 1) * dxids0[1] +
         psi2(2, 2, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(2, 2, 4) * dxids0[0] + psi2(2, 2, 5) * dxids0[1] +
         psi2(2, 2, 2) * dxids0[2]) *
          dxids0[2];
      d2psids(2, 3, 0) =
        (psi2(2, 3, 0) * dxids0[0] + psi2(2, 3, 3) * dxids0[1] +
         psi2(2, 3, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(2, 3, 3) * dxids0[0] + psi2(2, 3, 1) * dxids0[1] +
         psi2(2, 3, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(2, 3, 4) * dxids0[0] + psi2(2, 3, 5) * dxids0[1] +
         psi2(2, 3, 2) * dxids0[2]) *
          dxids0[2];
      d2psids(2, 4, 0) =
        (psi2(2, 4, 0) * dxids0[0] + psi2(2, 4, 3) * dxids0[1] +
         psi2(2, 4, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(2, 4, 3) * dxids0[0] + psi2(2, 4, 1) * dxids0[1] +
         psi2(2, 4, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(2, 4, 4) * dxids0[0] + psi2(2, 4, 5) * dxids0[1] +
         psi2(2, 4, 2) * dxids0[2]) *
          dxids0[2];
      d2psids(2, 5, 0) =
        (psi2(2, 5, 0) * dxids0[0] + psi2(2, 5, 3) * dxids0[1] +
         psi2(2, 5, 4) * dxids0[2]) *
          dxids0[0] +
        (psi2(2, 5, 3) * dxids0[0] + psi2(2, 5, 1) * dxids0[1] +
         psi2(2, 5, 5) * dxids0[2]) *
          dxids0[1] +
        (psi2(2, 5, 4) * dxids0[0] + psi2(2, 5, 5) * dxids0[1] +
         psi2(2, 5, 2) * dxids0[2]) *
          dxids0[2];

      // by chain rule, we can obtain d2shape wrt s1s1 at node2
      d2psids(2, 0, 1) =
        (psi2(2, 0, 0) * dxids1[0] + psi2(2, 0, 3) * dxids1[1] +
         psi2(2, 0, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(2, 0, 3) * dxids1[0] + psi2(2, 0, 1) * dxids1[1] +
         psi2(2, 0, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(2, 0, 4) * dxids1[0] + psi2(2, 0, 5) * dxids1[1] +
         psi2(2, 0, 2) * dxids1[2]) *
          dxids1[2];
      d2psids(2, 1, 1) =
        (psi2(2, 1, 0) * dxids1[0] + psi2(2, 1, 3) * dxids1[1] +
         psi2(2, 1, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(2, 1, 3) * dxids1[0] + psi2(2, 1, 1) * dxids1[1] +
         psi2(2, 1, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(2, 1, 4) * dxids1[0] + psi2(2, 1, 5) * dxids1[1] +
         psi2(2, 1, 2) * dxids1[2]) *
          dxids1[2];
      d2psids(2, 2, 1) =
        (psi2(2, 2, 0) * dxids1[0] + psi2(2, 2, 3) * dxids1[1] +
         psi2(2, 2, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(2, 2, 3) * dxids1[0] + psi2(2, 2, 1) * dxids1[1] +
         psi2(2, 2, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(2, 2, 4) * dxids1[0] + psi2(2, 2, 5) * dxids1[1] +
         psi2(2, 2, 2) * dxids1[2]) *
          dxids1[2];
      d2psids(2, 3, 1) =
        (psi2(2, 3, 0) * dxids1[0] + psi2(2, 3, 3) * dxids1[1] +
         psi2(2, 3, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(2, 3, 3) * dxids1[0] + psi2(2, 3, 1) * dxids1[1] +
         psi2(2, 3, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(2, 3, 4) * dxids1[0] + psi2(2, 3, 5) * dxids1[1] +
         psi2(2, 3, 2) * dxids1[2]) *
          dxids1[2];
      d2psids(2, 4, 1) =
        (psi2(2, 4, 0) * dxids1[0] + psi2(2, 4, 3) * dxids1[1] +
         psi2(2, 4, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(2, 4, 3) * dxids1[0] + psi2(2, 4, 1) * dxids1[1] +
         psi2(2, 4, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(2, 4, 4) * dxids1[0] + psi2(2, 4, 5) * dxids1[1] +
         psi2(2, 4, 2) * dxids1[2]) *
          dxids1[2];
      d2psids(2, 5, 1) =
        (psi2(2, 5, 0) * dxids1[0] + psi2(2, 5, 3) * dxids1[1] +
         psi2(2, 5, 4) * dxids1[2]) *
          dxids1[0] +
        (psi2(2, 5, 3) * dxids1[0] + psi2(2, 5, 1) * dxids1[1] +
         psi2(2, 5, 5) * dxids1[2]) *
          dxids1[1] +
        (psi2(2, 5, 4) * dxids1[0] + psi2(2, 5, 5) * dxids1[1] +
         psi2(2, 5, 2) * dxids1[2]) *
          dxids1[2];

      // by chain rule, we can obtain d2shape wrt s0s1 at node2
      d2psids(2, 0, 2) =
        (psi2(2, 0, 0) * dxids0[0] + psi2(2, 0, 3) * dxids0[1] +
         psi2(2, 0, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(2, 0, 3) * dxids0[0] + psi2(2, 0, 1) * dxids0[1] +
         psi2(2, 0, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(2, 0, 4) * dxids0[0] + psi2(2, 0, 5) * dxids0[1] +
         psi2(2, 0, 2) * dxids0[2]) *
          dxids1[2];
      d2psids(2, 1, 2) =
        (psi2(2, 1, 0) * dxids0[0] + psi2(2, 1, 3) * dxids0[1] +
         psi2(2, 1, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(2, 1, 3) * dxids0[0] + psi2(2, 1, 1) * dxids0[1] +
         psi2(2, 1, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(2, 1, 4) * dxids0[0] + psi2(2, 1, 5) * dxids0[1] +
         psi2(2, 1, 2) * dxids0[2]) *
          dxids1[2];
      d2psids(2, 2, 2) =
        (psi2(2, 2, 0) * dxids0[0] + psi2(2, 2, 3) * dxids0[1] +
         psi2(2, 2, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(2, 2, 3) * dxids0[0] + psi2(2, 2, 1) * dxids0[1] +
         psi2(2, 2, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(2, 2, 4) * dxids0[0] + psi2(2, 2, 5) * dxids0[1] +
         psi2(2, 2, 2) * dxids0[2]) *
          dxids1[2];
      d2psids(2, 3, 2) =
        (psi2(2, 3, 0) * dxids0[0] + psi2(2, 3, 3) * dxids0[1] +
         psi2(2, 3, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(2, 3, 3) * dxids0[0] + psi2(2, 3, 1) * dxids0[1] +
         psi2(2, 3, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(2, 3, 4) * dxids0[0] + psi2(2, 3, 5) * dxids0[1] +
         psi2(2, 3, 2) * dxids0[2]) *
          dxids1[2];
      d2psids(2, 4, 2) =
        (psi2(2, 4, 0) * dxids0[0] + psi2(2, 4, 3) * dxids0[1] +
         psi2(2, 4, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(2, 4, 3) * dxids0[0] + psi2(2, 4, 1) * dxids0[1] +
         psi2(2, 4, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(2, 4, 4) * dxids0[0] + psi2(2, 4, 5) * dxids0[1] +
         psi2(2, 4, 2) * dxids0[2]) *
          dxids1[2];
      d2psids(2, 5, 2) =
        (psi2(2, 5, 0) * dxids0[0] + psi2(2, 5, 3) * dxids0[1] +
         psi2(2, 5, 4) * dxids0[2]) *
          dxids1[0] +
        (psi2(2, 5, 3) * dxids0[0] + psi2(2, 5, 1) * dxids0[1] +
         psi2(2, 5, 5) * dxids0[2]) *
          dxids1[1] +
        (psi2(2, 5, 4) * dxids0[0] + psi2(2, 5, 5) * dxids0[1] +
         psi2(2, 5, 2) * dxids0[2]) *
          dxids1[2];
    }
  };

  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////
  // C1CurvedElementsShape
  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////
  //========================================================================
  /// A class for Linear triangular shape function with 3 vertex nodes
  //========================================================================
  template<unsigned DIM>
  class LinearTElement
  {
  };

  template<>
  class LinearTElement<2>
  {
  public:
    //=======================================================================
    /// Return local coordinates of node j
    //=======================================================================
    void local_coordinate_of_node(const unsigned& j, Vector<double>& s) const
    {
      switch (j)
      {
        case 0:
          s[0] = 1.0;
          s[1] = 0.0;
          break;

        case 1:
          s[0] = 0.0;
          s[1] = 1.0;
          break;

        case 2:
          s[0] = 0.0;
          s[1] = 0.0;
          break;

        default:
          std::ostringstream error_message;
          error_message
            << "Element only has three nodes; called with node number " << j
            << std::endl;

          throw OomphLibError(error_message.str(),
                              "TElement::local_coordinate_of_node()",
                              OOMPH_EXCEPTION_LOCATION);
      }
    }


    //=======================================================================
    /// Shape function for specific TElement<2,2>
    //=======================================================================
    void Lshape(const Vector<double>& s, Shape& psi) const
    {
      psi[0] = s[0];
      psi[1] = s[1];
      psi[2] = 1.0 - s[0] - s[1];
    }


    //=======================================================================
    /// Derivatives of shape functions for specific TElement<2,2>
    //=======================================================================
    void dLshape_local(const Vector<double>& s,
                       Shape& psi,
                       DShape& dpsids) const
    {
      this->Lshape(s, psi);

      // Derivatives
      dpsids(0, 0) = 1.0;
      dpsids(0, 1) = 0.0;
      dpsids(1, 0) = 0.0;
      dpsids(1, 1) = 1.0;
      dpsids(2, 0) = -1.0;
      dpsids(2, 1) = -1.0;
    }


    //=======================================================================
    /// Second derivatives of shape functions for specific TElement<2,2>:
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
    //=======================================================================
    void d2Lshape_local(const Vector<double>& s,
                        Shape& psi,
                        DShape& dpsids,
                        DShape& d2psids) const
    {
      this->dLshape_local(s, psi, dpsids);

      for (unsigned i = 0; i < 3; i++)
      {
        d2psids(i, 0) = 0.0;
        d2psids(i, 1) = 0.0;
        d2psids(i, 2) = 0.0;
      }
    }
  };

  //=====================================================================
  /// Define integration schemes that are required to exactly integrate
  /// the mass matrices of the bubble-enriched elements. The enrichement
  /// increases the polynomial order which means that higher-order Gauss
  /// rules must be used.
  //====================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  class CurvedTGauss
  {
  };

  //====================================================================
  /// Specialisation for two-dimensional elements, in which the highest
  /// order polynomial is cubic, so we need the integration scheme
  /// for the unenriched cubic element
  //======================================================================
  template<>
  class CurvedTGauss<2, 2> : public TGauss<2, 4>
  {
  public:
    CurvedTGauss() : TGauss<2, 4>() {}
  };

  //========================================================================
  /// A class for subparametric shape functions of
  /// a curved triangular element with 3 vertex nodes
  /// Affine mapping is used when dealing with a straight-boundary element
  /// Nonlinear mapping is used when dealing with a curved-boundary element
  /// Note that a cubic-Hermite polynomial is employed to approximate a
  /// curved boundary
  //========================================================================
  template<unsigned DIM>
  class GeometricTElement
  {
  };

  template<>
  class GeometricTElement<2>
  {
  public:
    //=======================================================================
    /// Return local coordinates of node j
    //=======================================================================
    void local_coordinate_of_node(const unsigned& j, Vector<double>& s) const
    {
      switch (j)
      {
        case 0:
          s[0] = 1.0;
          s[1] = 0.0;
          break;

        case 1:
          s[0] = 0.0;
          s[1] = 1.0;
          break;

        case 2:
          s[0] = 0.0;
          s[1] = 0.0;
          break;

        default:
          std::ostringstream error_message;
          error_message
            << "Element only has three nodes; called with node number " << j
            << std::endl;

          throw OomphLibError(error_message.str(),
                              "GeometricTElement::local_coordinate_of_node()",
                              OOMPH_EXCEPTION_LOCATION);
      }
    }
    //=======================================================================
    /// Geometric interpolation for specific C1CurvedElement<>
    /// This function return the physical coordinates at the local coordinate s
    /// rather than a value of shape function at the local coordinate s
    //=======================================================================
    void Lshape(const Vector<double>& s,
                Shape& psi,
                Shape& phi,
                DenseMatrix<double>& position,
                unsigned& bd_element,
                DenseMatrix<double>& bd_position,
                Vector<double>& x) const
    {
      // assign shape functions to the interior elements
      psi[0] = s[0];
      psi[1] = s[1];
      psi[2] = 1.0 - s[0] - s[1];

      // assign shape functions to the boundary elements
      double angle_1 = atan2(bd_position(0, 1), bd_position(0, 0));
      double angle_2 = atan2(bd_position(1, 1), bd_position(1, 0));
      double angle_min = 0.0;
      double angle_max = 0.0;

      DenseMatrix<double> p(3, 2);
      if (angle_1 < angle_2)
      {
        angle_min = angle_1;
        angle_max = angle_2;

        p(0, 0) = bd_position(0, 0);
        p(0, 1) = bd_position(0, 1);

        p(1, 0) = bd_position(1, 0);
        p(1, 1) = bd_position(1, 1);
      }
      else if (angle_1 > angle_2)
      {
        angle_min = angle_2;
        angle_max = angle_1;

        p(0, 0) = bd_position(1, 0);
        p(0, 1) = bd_position(1, 1);

        p(1, 0) = bd_position(0, 0);
        p(1, 1) = bd_position(0, 1);
      }

      Vector<double> b_fn_derivative_min(2), b_fn_derivative_max(2);
      b_fn_derivative_min[0] = -1.0 * sin(angle_min);
      b_fn_derivative_min[1] = cos(angle_min);
      b_fn_derivative_max[0] = -1.0 * sin(angle_max);
      b_fn_derivative_max[1] = cos(angle_max);

      // compute the physical coordinates at the local coordinate s
      if (bd_element == 0)
      {
        phi[0] = position(2, 0) + (position(0, 0) - position(2, 0)) * s[0] +
                 (position(1, 0) - position(2, 0)) * s[1];
        phi[1] = position(2, 1) + (position(0, 1) - position(2, 1)) * s[0] +
                 (position(1, 1) - position(2, 1)) * s[1];
      }
      else
      {
        Vector<double> psi_h(2);
        for (unsigned i = 0; i < 2; i++)
        {
          // polynomial of degree 3 to approximate boundary
          psi_h[i] = ((2.0 * (p(1, i) - p(0, i)) -
                       (angle_max - angle_min) *
                         (b_fn_derivative_min[i] + b_fn_derivative_max[i])) *
                        (s[1] - s[0]) +
                      (angle_max - angle_min) *
                        (b_fn_derivative_min[i] - b_fn_derivative_max[i]));
          phi[i] = x[i] + (p(0, i) - x[i]) * s[0] + (p(1, i) - x[i]) * s[1] +
                   1.0 / 2.0 * s[0] * s[1] * psi_h[i];
        }
      }
    }


    //=======================================================================
    /// Derivatives of Geometric interpolation for specific C1CurvedElement<>
    /// This function return the derivatives of physical coordinates at
    /// the local coordinate s rather than a value of the derivatives of
    /// shape function at the local coordinate s
    //=======================================================================
    void dLshape_local(const Vector<double>& s,
                       Shape& psi,
                       DShape& dpsids,
                       Shape& phi,
                       DShape& dphids,
                       DenseMatrix<double>& position,
                       unsigned& bd_element,
                       DenseMatrix<double>& bd_position,
                       Vector<double>& x) const
    {
      this->Lshape(s, psi, phi, position, bd_element, bd_position, x);
      // Derivatives
      dpsids(0, 0) = 1.0;
      dpsids(0, 1) = 0.0;
      dpsids(1, 0) = 0.0;
      dpsids(1, 1) = 1.0;
      dpsids(2, 0) = -1.0;
      dpsids(2, 1) = -1.0;

      double angle_1 = atan2(bd_position(0, 1), bd_position(0, 0));
      double angle_2 = atan2(bd_position(1, 1), bd_position(1, 0));
      double angle_min = 0.0;
      double angle_max = 0.0;

      DenseMatrix<double> p(3, 2);
      if (angle_1 < angle_2)
      {
        angle_min = angle_1;
        angle_max = angle_2;

        p(0, 0) = bd_position(0, 0);
        p(0, 1) = bd_position(0, 1);

        p(1, 0) = bd_position(1, 0);
        p(1, 1) = bd_position(1, 1);
      }
      else if (angle_1 > angle_2)
      {
        angle_min = angle_2;
        angle_max = angle_1;

        p(0, 0) = bd_position(1, 0);
        p(0, 1) = bd_position(1, 1);

        p(1, 0) = bd_position(0, 0);
        p(1, 1) = bd_position(0, 1);
      }

      Vector<double> b_fn_derivative_min(2), b_fn_derivative_max(2);
      b_fn_derivative_min[0] = -1.0 * sin(angle_min);
      b_fn_derivative_min[1] = cos(angle_min);
      b_fn_derivative_max[0] = -1.0 * sin(angle_max);
      b_fn_derivative_max[1] = cos(angle_max);

      // compute shape functions
      if (bd_element == 0)
      {
        dphids(0, 0) = position(0, 0) - position(2, 0);
        dphids(0, 1) = position(1, 0) - position(2, 0);
        dphids(1, 0) = position(0, 1) - position(2, 1);
        dphids(1, 1) = position(1, 1) - position(2, 1);
      }
      else
      {
        Vector<double> psi_h(2);
        for (unsigned i = 0; i < 2; i++)
        {
          psi_h[i] = ((2.0 * (p(1, i) - p(0, i)) -
                       (angle_max - angle_min) *
                         (b_fn_derivative_min[i] + b_fn_derivative_max[i])) *
                        (s[1] - s[0]) +
                      (angle_max - angle_min) *
                        (b_fn_derivative_min[i] - b_fn_derivative_max[i]));
        }
        // compute shape functions derivatives
        DenseMatrix<double> dpsi_h(2, 2);
        for (unsigned i = 0; i < 2; i++)
        {
          dpsi_h(i, 0) = (2.0 * (p(1, i) - p(0, i)) -
                          (angle_max - angle_min) *
                            (b_fn_derivative_min[i] + b_fn_derivative_max[i])) *
                         (-1.0);
          dpsi_h(i, 1) = (2.0 * (p(1, i) - p(0, i)) -
                          (angle_max - angle_min) *
                            (b_fn_derivative_min[i] + b_fn_derivative_max[i]));
        }
        for (unsigned i = 0; i < 2; i++)
        {
          dphids(i, 0) = p(0, i) - x[i] +
                         1.0 / 2.0 * s[0] * s[1] * dpsi_h(i, 0) +
                         psi_h[i] * s[1] / 2.0;
          dphids(i, 1) = p(1, i) - x[i] +
                         1.0 / 2.0 * s[0] * s[1] * dpsi_h(i, 1) +
                         psi_h[i] * s[0] / 2.0;
        }
      }
    }

    //=======================================================================
    /// Second derivatives of Geometric interpolation for
    /// specific C1CurvedElement<>:
    /// This function return the second-order derivatives of physical
    /// coordinates at the local coordinate s rather than a value of the
    /// second-order derivatives of shape function at the local coordinate s
    ///=======================================================================
    void d2Lshape_local(const Vector<double>& s,
                        Shape& psi,
                        DShape& dpsids,
                        DShape& d2psids,
                        Shape& phi,
                        DShape& dphids,
                        DShape& d2phids,
                        DenseMatrix<double>& position,
                        unsigned& bd_element,
                        DenseMatrix<double>& bd_position,
                        Vector<double>& x) const
    {
      this->dLshape_local(
        s, psi, dpsids, phi, dphids, position, bd_element, bd_position, x);
      // 2nd Derivatives
      for (unsigned i = 0; i < 3; i++)
      {
        d2psids(i, 0) = 0.0;
        d2psids(i, 1) = 0.0;
        d2psids(i, 2) = 0.0;
      }
      double angle_1 = atan2(bd_position(0, 1), bd_position(0, 0));
      double angle_2 = atan2(bd_position(1, 1), bd_position(1, 0));
      double angle_min = 0.0;
      double angle_max = 0.0;

      DenseMatrix<double> p(3, 2);
      if (angle_1 < angle_2)
      {
        angle_min = angle_1;
        angle_max = angle_2;

        p(0, 0) = bd_position(0, 0);
        p(0, 1) = bd_position(0, 1);

        p(1, 0) = bd_position(1, 0);
        p(1, 1) = bd_position(1, 1);
      }
      else if (angle_1 > angle_2)
      {
        angle_min = angle_2;
        angle_max = angle_1;

        p(0, 0) = bd_position(1, 0);
        p(0, 1) = bd_position(1, 1);

        p(1, 0) = bd_position(0, 0);
        p(1, 1) = bd_position(0, 1);
      }

      Vector<double> b_fn_derivative_min(2), b_fn_derivative_max(2);
      b_fn_derivative_min[0] = -1.0 * sin(angle_min);
      b_fn_derivative_min[1] = cos(angle_min);
      b_fn_derivative_max[0] = -1.0 * sin(angle_max);
      b_fn_derivative_max[1] = cos(angle_max);

      // compute the 2nd-order of derivatives of the  physical coordinates
      if (bd_element == 0)
      {
        for (unsigned i = 0; i < 2; i++)
        {
          d2phids(i, 0) = 0.0;
          d2phids(i, 1) = 0.0;
          d2phids(i, 2) = 0.0;
        }
      }
      else
      {
        // compute the 2nd-order derivatives of the physical coordinates
        Vector<double> psi_h(2);
        DenseMatrix<double> dpsi_h(2, 2), d2psi_h(2, 3);

        for (unsigned i = 0; i < 2; i++)
        {
          psi_h[i] = ((2.0 * (p(1, i) - p(0, i)) -
                       (angle_max - angle_min) *
                         (b_fn_derivative_min[i] + b_fn_derivative_max[i])) *
                        (s[1] - s[0]) +
                      (angle_max - angle_min) *
                        (b_fn_derivative_min[i] - b_fn_derivative_max[i]));
        }

        for (unsigned i = 0; i < 2; i++)
        {
          dpsi_h(i, 0) = (2.0 * (p(1, i) - p(0, i)) -
                          (angle_max - angle_min) *
                            (b_fn_derivative_min[i] + b_fn_derivative_max[i])) *
                         (-1.0);
          dpsi_h(i, 1) = (2.0 * (p(1, i) - p(0, i)) -
                          (angle_max - angle_min) *
                            (b_fn_derivative_min[i] + b_fn_derivative_max[i]));
        }

        for (unsigned i = 0; i < 2; i++)
        {
          d2psi_h(i, 0) = 0.0;
          d2psi_h(i, 1) = 0.0;
          d2psi_h(i, 2) = 0.0;
        }

        for (unsigned i = 0; i < 2; i++)
        {
          d2phids(i, 0) = 1.0 / 2.0 * s[0] * s[1] * d2psi_h(i, 0) +
                          dpsi_h(i, 0) * s[1] / 2.0 +
                          1.0 / 2.0 * s[1] * dpsi_h(i, 0);
          d2phids(i, 1) = 1.0 / 2.0 * s[0] * s[1] * d2psi_h(i, 1) +
                          1.0 / 2.0 * s[0] * dpsi_h(i, 1) +
                          1.0 / 2.0 * s[0] * dpsi_h(i, 1);
          d2phids(i, 2) = 1.0 / 2.0 * s[0] * s[1] * d2psi_h(i, 2) +
                          1.0 / 2.0 * s[0] * dpsi_h(i, 0) + psi_h[i] / 2.0 +
                          dpsi_h(i, 1) * s[1] / 2.0;
        }
      }
    }
  };

  //========================================================================
  /// A class for C1-curved triangular shape function with 3 vertex nodes and
  /// 3 middle-side node
  //========================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  class C1CurvedElementShape
  {
  };

  template<unsigned NNODE_1D>
  class C1CurvedElementShape<2, NNODE_1D>
  {
  public:
    //=======================================================================
    /// Return local coordinates of node j
    //=======================================================================
    void local_coordinate_of_node(const unsigned& j, Vector<double>& s) const
    {
      if (NNODE_1D == 2)
      {
        switch (j)
        {
          case 0:
            s[0] = 1.0;
            s[1] = 0.0;
            break;

          case 1:
            s[0] = 0.0;
            s[1] = 1.0;
            break;

          case 2:
            s[0] = 0.0;
            s[1] = 0.0;
            break;

          case 3:
            s[0] = 1.0 / 2.0;
            s[1] = 1.0 / 4.0;
            break;

          case 4:
            s[0] = 1.0 / 4.0;
            s[1] = 1.0 / 2.0;
            break;

          case 5:
            s[0] = 1.0 / 4.0;
            s[1] = 1.0 / 4.0;
            break;

          default:
            std::ostringstream error_message;
            error_message << "Element only has three vertices and three "
                             "internal nodes; called with node number "
                          << j << std::endl;

            throw OomphLibError(error_message.str(),
                                "CurvedTElement::local_coordinate_of_node()",
                                OOMPH_EXCEPTION_LOCATION);
        }
      }

      else if (NNODE_1D == 3)
      {
        switch (j)
        {
          case 0:
            s[0] = 1.0;
            s[1] = 0.0;
            break;

          case 1:
            s[0] = 0.0;
            s[1] = 1.0;
            break;

          case 2:
            s[0] = 0.0;
            s[1] = 0.0;
            break;

          case 3:
            s[0] = 0.5;
            s[1] = 0.5;
            break;

          case 4:
            s[0] = 0.0;
            s[1] = 0.5;
            break;

          case 5:
            s[0] = 0.5;
            s[1] = 0.0;
            break;

          case 6:
            s[0] = 1.0 / 2.0;
            s[1] = 1.0 / 4.0;
            break;

          case 7:
            s[0] = 1.0 / 4.0;
            s[1] = 1.0 / 2.0;
            break;

          case 8:
            s[0] = 1.0 / 4.0;
            s[1] = 1.0 / 4.0;
            break;

          default:
            std::ostringstream error_message;
            error_message << "Element has maximum of six nodes and three "
                             "internal nodes; called with node number "
                          << j << std::endl;

            throw OomphLibError(error_message.str(),
                                "CurvedTElement::local_coordinate_of_node()",
                                OOMPH_EXCEPTION_LOCATION);
        }
      }
    }

    ///============================================================
    /// compute for the set of value in the reference triangle
    ///============================================================
    void set_of_value(DenseMatrix<double>& D,
                      DenseMatrix<double>& B,
                      DenseMatrix<double>& position,
                      unsigned& bd_element,
                      DenseMatrix<double>& bd_position,
                      Vector<double>& x) const
    {
      double angle_1 = atan2(bd_position(0, 1), bd_position(0, 0));
      double angle_2 = atan2(bd_position(1, 1), bd_position(1, 0));
      double angle_min = 0.0;
      double angle_max = 0.0;

      DenseMatrix<double> p(3, 2);
      if (angle_1 < angle_2)
      {
        angle_min = angle_1;
        angle_max = angle_2;

        p(0, 0) = bd_position(0, 0);
        p(0, 1) = bd_position(0, 1);

        p(1, 0) = bd_position(1, 0);
        p(1, 1) = bd_position(1, 1);
      }
      else if (angle_1 > angle_2)
      {
        angle_min = angle_2;
        angle_max = angle_1;

        p(0, 0) = bd_position(1, 0);
        p(0, 1) = bd_position(1, 1);

        p(1, 0) = bd_position(0, 0);
        p(1, 1) = bd_position(0, 1);
      }
      p(2, 0) = x[0];
      p(2, 1) = x[1];

      Vector<double> fn_derivative1(2), fn_derivative2(2);
      fn_derivative1[0] = (angle_max - angle_min) * -1.0 * sin(angle_min);
      fn_derivative1[1] = (angle_max - angle_min) * -1.0 * sin(angle_max);
      fn_derivative2[0] = (angle_max - angle_min) * cos(angle_min);
      fn_derivative2[1] = (angle_max - angle_min) * cos(angle_max);

      // compute for the transformation matrix D from global to local
      // coordinates
      // initialise the matrix first
      for (unsigned i = 0; i < 21; i++)
      {
        for (unsigned j = 0; j < 21; j++)
        {
          D(i, j) = 0.0;
        }
      }
      double x31, x23, x13, x32, y13, y31, y32, y23;
      x31 = p(2, 0) - p(0, 0);
      y31 = p(2, 1) - p(0, 1);
      x32 = p(2, 0) - p(1, 0);
      y32 = p(2, 1) - p(1, 1);
      x23 = p(1, 0) - p(2, 0);
      y23 = p(1, 1) - p(2, 1);
      x13 = p(0, 0) - p(2, 0);
      y13 = p(0, 1) - p(2, 1);

      // assign values to the matrix D
      D(0, 0) = 1.0;
      D(1, 1) = 1.0;
      D(2, 2) = 1.0;
      D(3 + 0, 3 + 0) = x31;
      D(3 + 0, 3 + 1) = fn_derivative1[0];
      D(3 + 1, 3 + 0) = y31;
      D(3 + 1, 3 + 1) = fn_derivative2[0];
      // define submatrix d2
      D(5 + 0, 5 + 0) = -1.0 * fn_derivative1[1];
      D(5 + 0, 5 + 1) = x32;
      D(5 + 1, 5 + 0) = -1.0 * fn_derivative2[1];
      D(5 + 1, 5 + 1) = y32;
      // define submatrix d3
      D(7 + 0, 7 + 0) = x23;
      D(7 + 0, 7 + 1) = x13;
      D(7 + 1, 7 + 0) = y23;
      D(7 + 1, 7 + 1) = y13;
      // define submatrix d4
      D(9 + 0, 9 + 0) = x31 * x31;
      D(9 + 0, 9 + 1) = fn_derivative1[0] * fn_derivative1[0];
      D(9 + 0, 9 + 6) = x32 * x32;
      D(9 + 1, 9 + 0) = 2.0 * x31 * y31;
      D(9 + 1, 9 + 1) = 2.0 * fn_derivative1[0] * fn_derivative2[0];
      D(9 + 1, 9 + 6) = 2.0 * x32 * y32;
      D(9 + 2, 9 + 0) = y31 * y31;
      D(9 + 2, 9 + 1) = fn_derivative2[0] * fn_derivative2[0];
      D(9 + 2, 9 + 6) = y32 * y32;
      D(9 + 3, 9 + 2) = fn_derivative1[1] * fn_derivative1[1];
      D(9 + 3, 9 + 3) = x32 * x32;
      D(9 + 3, 9 + 7) = x31 * x31;
      D(9 + 4, 9 + 2) = 2.0 * fn_derivative1[1] * fn_derivative2[1];
      D(9 + 4, 9 + 3) = 2.0 * x32 * y32;
      D(9 + 4, 9 + 7) = 2.0 * x31 * y31;
      D(9 + 5, 9 + 2) = fn_derivative2[1] * fn_derivative2[1];
      D(9 + 5, 9 + 3) = y32 * y32;
      D(9 + 5, 9 + 7) = y31 * y31;
      D(9 + 6, 9 + 4) = x32 * x32;
      D(9 + 6, 9 + 5) = x31 * x31;
      D(9 + 6, 9 + 8) = fn_derivative1[0] * fn_derivative1[1];
      D(9 + 7, 9 + 4) = 2.0 * x32 * y32;
      D(9 + 7, 9 + 5) = 2.0 * x31 * y31;
      D(9 + 7, 9 + 8) = fn_derivative1[0] * fn_derivative2[1] +
                        fn_derivative2[0] * fn_derivative1[1];
      D(9 + 8, 9 + 4) = y32 * y32;
      D(9 + 8, 9 + 5) = y31 * y31;
      D(9 + 8, 9 + 8) = fn_derivative2[0] * fn_derivative2[1];

      D(18, 18) = 1.0;
      D(19, 19) = 1.0;
      D(20, 20) = 1.0;
      // assign  the matrix of transformation from the dofs on curved element to
      // the dofs on reference element
      DenseMatrix<double> Bt(36, 21);
      // Initialize the matrix
      for (unsigned i = 0; i < 36; i++)
      {
        for (unsigned j = 0; j < 21; j++)
        {
          Bt(i, j) = 0.0;
        }
      }
      // submatrix b1
      Bt(0, 0) = 1.0;
      Bt(1, 1) = 1.0;
      Bt(2, 2) = 1.0;
      // submatrix b2
      Bt(3 + 0, 3 + 0) = -1.0;
      Bt(3 + 1, 3 + 0) = -1.0;
      Bt(3 + 1, 3 + 1) = 1.0;
      Bt(3 + 2, 3 + 2) = 1.0;
      Bt(3 + 2, 3 + 3) = -1.0;
      Bt(3 + 3, 3 + 3) = -1.0;
      Bt(3 + 4, 3 + 5) = 1.0;
      Bt(3 + 5, 3 + 4) = 1.0;
      // submatrix b3
      double a1, a2, aa1, aa2, b1, b2, bb1, bb2, c1, c2, cc1, cc2;
      Vector<double> A1(2), A2(2), B1(2), B2(2), C1(2), C2(2);
      for (unsigned i = 0; i < 2; i++)
      {
        A1[i] = p(2, i) - p(0, i);
        B2[i] = p(2, i) - p(1, i);
        C1[i] = p(1, i) - p(2, i);
        C2[i] = p(0, i) - p(2, i);
      }
      A2[0] = (angle_max - angle_min) * -1.0 * sin(angle_min);
      A2[1] = (angle_max - angle_min) * cos(angle_min);
      B1[0] = -1.0 * (angle_max - angle_min) * -1.0 * sin(angle_max);
      B1[1] = -1.0 * (angle_max - angle_min) * cos(angle_max);
      double B2xA2, A1xA2, A1xB2, B1xA2, A1xB1, B1xA1, A2xB2, B1xB2;
      B2xA2 = B2[0] * A2[1] - B2[1] * A2[0];
      A1xA2 = A1[0] * A2[1] - A1[1] * A2[0];
      A1xB2 = A1[0] * B2[1] - A1[1] * B2[0];
      B1xA2 = B1[0] * A2[1] - B1[1] * A2[0];
      A1xB1 = A1[0] * B1[1] - A1[1] * B1[0];
      A2xB2 = A2[0] * B2[1] - A2[1] * B2[0];
      B1xA1 = B1[0] * A1[1] - B1[1] * A1[0];
      B1xB2 = B1[0] * B2[1] - B1[1] * B2[0];
      a1 = B2xA2 / A1xA2 - 1.0;
      a2 = A1xB2 / A1xA2;
      aa1 = -1.0 * B1xA2 / A1xA2;
      aa2 = -1.0 * A1xB1 / A1xA2;
      b1 = A1xB2 / B1xB2;
      b2 = B1xA1 / B1xB2 - 1.0;
      bb1 = A2xB2 / B1xB2;
      bb2 = B1xA2 / B1xB2;
      c1 = -1.0 / a2;
      c2 = -1.0 * bb1 / b1;
      cc1 = aa2 / a2;
      cc2 = -1.0 / b1;

      Bt(9 + 1, 3 + 0) = 2.0 * a1 + aa1 / 2.0;
      Bt(9 + 2, 3 + 0) = -1.0 * (2.0 * a1 + aa1);
      Bt(9 + 1, 3 + 1) = 3.0 / 2.0 + 2.0 * a2 + aa2 / 2.0;
      Bt(9 + 2, 3 + 1) = -1.0 * (1.0 + 2.0 * a2 + aa2);
      Bt(9 + 3, 3 + 2) = -1.0 * (1.0 + 2.0 * b1 - bb1);
      Bt(9 + 4, 3 + 2) = 3.0 / 2.0 + 2.0 * b1 - bb1 / 2.0;
      Bt(9 + 3, 3 + 3) = -1.0 * (2.0 * b2 - bb2);
      Bt(9 + 4, 3 + 3) = 2.0 * b2 - bb2 / 2.0;
      Bt(9 + 7, 3 + 4) = (c1 + cc1) / 2.0;
      Bt(9 + 7, 3 + 5) = (c2 + cc2) / 2.0;

      Bt(9 + 0, 9 + 0) = 1.0;
      Bt(9 + 1, 9 + 0) = 1.0 + (1.0 + a1) / (2.0 * a2);
      Bt(9 + 2, 9 + 0) = 1.0 + (1.0 + a1) / (a2);
      Bt(9 + 1, 9 + 1) = (a2) / (2.0 * (1.0 + a1));
      Bt(9 + 2, 9 + 1) = 1.0 + (a2) / (1.0 + a1);
      Bt(9 + 3, 9 + 2) = 1.0 + (b1) / (1.0 + b2);
      Bt(9 + 4, 9 + 2) = (b1) / (2.0 * (1.0 + b2));
      Bt(9 + 3, 9 + 3) = 1.0 + (1.0 + b2) / (b1);
      Bt(9 + 4, 9 + 3) = 1.0 + (1.0 + b2) / (2.0 * b1);
      Bt(9 + 5, 9 + 3) = 1.0;
      Bt(9 + 7, 9 + 4) = -1.0 * (c1 * cc1) / (c1 * cc2 + c2 * cc1);
      Bt(9 + 8, 9 + 4) = 1.0;
      Bt(9 + 6, 9 + 5) = 1.0;
      Bt(9 + 7, 9 + 5) = -1.0 * (c2 * cc2) / (c1 * cc2 + c2 * cc1);
      Bt(9 + 1, 9 + 6) = (-1.0) / (2.0 * a2 * (1.0 + a1));
      Bt(9 + 2, 9 + 6) = (-1.0) / (a2 * (1.0 + a1));
      Bt(9 + 3, 9 + 7) = (-1.0) / (b1 * (1.0 + b2));
      Bt(9 + 4, 9 + 7) = (-1.0) / (2.0 * b1 * (1.0 + b2));
      Bt(9 + 7, 9 + 8) = (-1.0) / (c1 * cc2 + c2 * cc1);

      double ata1, ata2;
      // assign the points of perpendicular for the sides a1a3 nd a2a3
      Vector<double> s1(2), s2(2);
      // find the point that the point a1(on the boundary) is perpendicular to
      // the vector a2a3
      double m = (p(1, 1) - p(2, 1)) / (p(1, 0) - p(2, 0));
      double k = p(2, 1) - m * p(2, 0);
      s1[0] =
        ((p(1, 0) - p(2, 0)) * p(0, 0) + (p(1, 1) - p(2, 1)) * (p(0, 1) - k)) /
        ((p(1, 0) - p(2, 0)) + (p(1, 1) - p(2, 1)) * m);
      s1[1] = m * s1[0] + k;

      if ((p(1, 0) - p(2, 0)) == 0)
      {
        m = (p(1, 0) - p(2, 0)) / (p(1, 1) - p(2, 1));
        k = p(2, 0) - m * p(2, 1);
        s1[1] = ((p(1, 0) - p(2, 0)) * (p(0, 0) - k) +
                 (p(1, 1) - p(2, 1)) * (p(0, 1))) /
                ((p(1, 0) - p(2, 0)) * m + (p(1, 1) - p(2, 1)));
        s1[0] = m * s1[1] + k;
      }

      // find the point that the point a2(on the boundary) is perpendicular to
      // the vector a1a3
      m = (p(0, 1) - p(2, 1)) / (p(0, 0) - p(2, 0));
      k = p(2, 1) - m * p(2, 0);
      s2[0] =
        ((p(0, 0) - p(2, 0)) * p(1, 0) + (p(0, 1) - p(2, 1)) * (p(1, 1) - k)) /
        ((p(0, 0) - p(2, 0)) + (p(0, 1) - p(2, 1)) * m);
      s2[1] = m * s2[0] + k;

      if ((p(0, 0) - p(2, 0)) == 0)
      {
        m = (p(0, 0) - p(2, 0)) / (p(0, 1) - p(2, 1));
        k = p(2, 0) - m * p(2, 1);
        s2[1] = ((p(0, 0) - p(2, 0)) * (p(1, 0) - k) +
                 (p(0, 1) - p(2, 1)) * (p(1, 1))) /
                ((p(0, 0) - p(2, 0)) * m + (p(0, 1) - p(2, 1)));
        s2[0] = m * s2[1] + k;
      }

      double len1, len2, len3;
      len1 = sqrt((p(1, 0) - p(2, 0)) * (p(1, 0) - p(2, 0)) +
                  (p(1, 1) - p(2, 1)) * (p(1, 1) - p(2, 1)));
      len2 = sqrt((p(0, 0) - p(2, 0)) * (p(0, 0) - p(2, 0)) +
                  (p(0, 1) - p(2, 1)) * (p(0, 1) - p(2, 1)));
      len3 = sqrt((p(1, 0) - p(0, 0)) * (p(1, 0) - p(0, 0)) +
                  (p(1, 1) - p(0, 1)) * (p(1, 1) - p(0, 1)));
      ata1 = (len3 * len3 - len2 * len2) / (len1 * len1);
      ata2 = (len1 * len1 - len3 * len3) / (len2 * len2);

      Vector<double> F1(21, 0.0), F2(21, 0.0), F3(21, 0.0), H1(21, 0.0),
        H2(21, 0.0), H3(21, 0.0);
      DenseMatrix<double> F1_div(21, 2, 0.0), F2_div(21, 2, 0.0);
      // Initialize the Vectors
      for (unsigned i = 0; i < 21; i++)
      {
        F1[i] = 0.0;
        F2[i] = 0.0;
        F3[i] = 0.0;
        H1[i] = 0.0;
        H2[i] = 0.0;
        H3[i] = 0.0;
        for (unsigned j = 0; j < 2; j++)
        {
          F1_div(i, j) = 0;
          F2_div(i, j) = 0;
        }
      }
      double e1, e2, f1, f2;
      double magnitude;
      Vector<double> t(2, 0.0), aa(2, 0.0), s(2, 0.0);

      t[0] = p(2, 0) - p(0, 0) + 1.0 / 4.0 * (p(0, 0) - p(1, 0)) +
             1.0 / 8.0 * (angle_max - angle_min) *
               (-3.0 * sin(angle_max) + sin(angle_min));
      t[1] = p(2, 1) - p(0, 1) + 1.0 / 4.0 * (p(0, 1) - p(1, 1)) +
             1.0 / 8.0 * (angle_max - angle_min) *
               (3.0 * cos(angle_max) - cos(angle_min));
      magnitude = sqrt((p(1, 0) - p(2, 0)) * (p(1, 0) - p(2, 0)) +
                       (p(1, 1) - p(2, 1)) * (p(1, 1) - p(2, 1)));
      aa[0] = (p(1, 0) - p(2, 0)) / (magnitude * magnitude);
      aa[1] = (p(1, 1) - p(2, 1)) / (magnitude * magnitude);
      e1 = (t[0] * aa[0] + t[1] * aa[1]);

      magnitude = sqrt((p(0, 0) - s1[0]) * (p(0, 0) - s1[0]) +
                       (p(0, 1) - s1[1]) * (p(0, 1) - s1[1]));
      aa[0] = (p(0, 0) - s1[0]) / (magnitude * magnitude);
      aa[1] = (p(0, 1) - s1[1]) / (magnitude * magnitude);
      e2 = (t[0] * aa[0] + t[1] * aa[1]);

      s[1] = 1.0 / 2.0;
      F2_div(1, 1) = 5.0 * s[1] * s[1] * 6.0 * s[1] * s[1] -
                     4.0 * s[1] * s[1] * 15.0 * s[1] + 3.0 * s[1] * s[1] * 10.0;
      F2_div(2, 1) =
        (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1]) * (12.0 * s[1] + 3.0) -
        3.0 * (1.0 - s[1]) * (1.0 - s[1]) *
          (6.0 * s[1] * s[1] + 3.0 * s[1] + 1.0);
      F2_div(6, 1) = s[1] * s[1] * s[1] * (1.0 - s[1]) * (-3.0) +
                     (4.0 - 3.0 * s[1]) *
                       (-s[1] * s[1] * s[1] + 3.0 * s[1] * s[1] * (1.0 - s[1]));
      F2_div(7, 1) = s[1] * (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1]) * 3.0 +
                     (-3.0 * s[1] * (1.0 - s[1]) * (1.0 - s[1]) +
                      (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1])) *
                       (1.0 + 3.0 * s[1]);
      F2_div(12, 1) = -1.0 * s[1] * s[1] * s[1] * (1.0 - s[1]) +
                      3.0 / 2.0 * (1.0 - s[1]) * (1.0 - s[1]) * s[1] * s[1];
      F2_div(13, 1) =
        -3.0 / 2.0 * s[1] * s[1] * (1.0 - s[1]) * (1.0 - s[1]) +
        1.0 / 2.0 * (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1]) * 2.0 * s[1];

      s[1] = 1.0 / 2.0;
      H2[5] = -1.0 * b1 * (3.0 * s[1] * s[1] - 2.0 * s[1] * s[1] * s[1]);
      H2[6] = -1.0 / 2.0 * (2.0 * b2 + 1.0 + ata1) *
              (3.0 * s[1] * s[1] - 2.0 * s[1] * s[1] * s[1]);
      H2[7] = -1.0 / 2.0 * (1.0 - ata1) *
              (1.0 - 3.0 * s[1] * s[1] + 2.0 * s[1] * s[1] * s[1]);
      H2[8] = (1.0 - 3.0 * s[1] * s[1] + 2.0 * s[1] * s[1] * s[1]);
      H2[11] = -1.0 / 2.0 * ((b1 * b1) / (1.0 + b2)) *
               (s[1] * s[1] * s[1] - s[1] * s[1]);
      H2[12] = 1.0 / 2.0 * (b2 + ata1) * (s[1] * s[1] * s[1] - s[1] * s[1]);
      H2[13] = -1.0 / 2.0 *
               ((2.0 * c1 * cc1) / (c1 * cc2 + c2 * cc1) + 1.0 - ata1) *
               (s[1] - 2.0 * s[1] * s[1] + s[1] * s[1] * s[1]);
      H2[14] = -1.0 * ((c2 * cc2) / (c1 * cc2 + c2 * cc1)) *
               (s[1] - 2.0 * s[1] * s[1] + s[1] * s[1] * s[1]);
      H2[16] =
        1.0 / 2.0 * (1.0 / (1.0 + b2)) * (s[1] * s[1] * s[1] - s[1] * s[1]);
      H2[17] = ((-1.0) / (c1 * cc2 + c2 * cc1)) *
               (s[1] - 2.0 * s[1] * s[1] + s[1] * s[1] * s[1]);

      for (unsigned i = 0; i < 21; i++)
      {
        Bt(18, i) = e1 * F2_div(i, 1) + e2 * H2[i];
      }

      t[0] = p(2, 0) - p(1, 0) + 1.0 / 4.0 * (p(1, 0) - p(0, 0)) -
             1.0 / 8.0 * (angle_max - angle_min) *
               (-3.0 * sin(angle_min) + sin(angle_max));
      t[1] = p(2, 1) - p(1, 1) + 1.0 / 4.0 * (p(1, 1) - p(0, 1)) -
             1.0 / 8.0 * (angle_max - angle_min) *
               (3.0 * cos(angle_min) - cos(angle_max));
      magnitude = sqrt((p(0, 0) - p(2, 0)) * (p(0, 0) - p(2, 0)) +
                       (p(0, 1) - p(2, 1)) * (p(0, 1) - p(2, 1)));
      aa[0] = (p(0, 0) - p(2, 0)) / (magnitude * magnitude);
      aa[1] = (p(0, 1) - p(2, 1)) / (magnitude * magnitude);
      f1 = (t[0] * aa[0] + t[1] * aa[1]);

      magnitude = sqrt((p(1, 0) - s2[0]) * (p(1, 0) - s2[0]) +
                       (p(1, 1) - s2[1]) * (p(1, 1) - s2[1]));
      aa[0] = (p(1, 0) - s2[0]) / (magnitude * magnitude);
      aa[1] = (p(1, 1) - s2[1]) / (magnitude * magnitude);
      f2 = (t[0] * aa[0] + t[1] * aa[1]);

      s[0] = 1.0 / 2.0;
      F1_div(0, 0) = 5.0 * s[0] * s[0] * 6.0 * s[0] * s[0] -
                     4.0 * s[0] * s[0] * 15.0 * s[0] + 3.0 * s[0] * s[0] * 10.0;
      F1_div(2, 0) =
        (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) * (12.0 * s[0] + 3.0) -
        3.0 * (1.0 - s[0]) * (1.0 - s[0]) *
          (6.0 * s[0] * s[0] + 3.0 * s[0] + 1.0);
      F1_div(3, 0) = s[0] * s[0] * s[0] * (1.0 - s[0]) * (-3.0) +
                     (4.0 - 3.0 * s[0]) *
                       (-s[0] * s[0] * s[0] + 3.0 * s[0] * s[0] * (1.0 - s[0]));
      F1_div(8, 0) = s[0] * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) * 3.0 +
                     (-3.0 * s[0] * (1.0 - s[0]) * (1.0 - s[0]) +
                      (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0])) *
                       (1.0 + 3.0 * s[0]);
      F1_div(9, 0) = -1.0 * s[0] * s[0] * s[0] * (1.0 - s[0]) +
                     3.0 / 2.0 * (1.0 - s[0]) * (1.0 - s[0]) * s[0] * s[0];
      F1_div(14, 0) =
        -3.0 / 2.0 * s[0] * s[0] * (1.0 - s[0]) * (1.0 - s[0]) +
        1.0 / 2.0 * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) * 2.0 * s[0];

      s[0] = 1.0 / 2.0;
      H1[3] = -1.0 / 2.0 * (1.0 - ata2 + 2.0 * a1) *
              (3.0 * s[0] * s[0] - 2.0 * s[0] * s[0] * s[0]);
      H1[4] = -1.0 * a2 * (3.0 * s[0] * s[0] - 2.0 * s[0] * s[0] * s[0]);
      H1[7] = 1.0 - 3.0 * s[0] * s[0] + 2.0 * s[0] * s[0] * s[0];
      H1[8] = -1.0 / 2.0 * (1.0 + ata2) *
              (1.0 - 3.0 * s[0] * s[0] + 2.0 * s[0] * s[0] * s[0]);
      H1[9] = 1.0 / 2.0 * (a1 - ata2) * (s[0] * s[0] * s[0] - s[0] * s[0]);
      H1[10] = -1.0 / 2.0 * (a2 * a2 / (1.0 + a1)) *
               (s[0] * s[0] * s[0] - s[0] * s[0]);
      H1[13] = ((-1.0 * c1 * cc1) / (c1 * cc2 + c2 * cc1)) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H1[14] = -1.0 *
               (1.0 / 2.0 * (1.0 + ata2) + (c2 * cc2 / (c1 * cc2 + c2 * cc1))) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H1[15] = (s[0] * s[0] * s[0] - s[0] * s[0]) / (2.0 * (1.0 + a1));
      H1[17] = -1.0 / (c1 * cc2 + c2 * cc1) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);

      for (unsigned i = 0; i < 21; i++)
      {
        Bt(19, i) = f1 * F1_div(i, 0) + f2 * H1[i];
      }

      double A = a1 + 1.0 / 2.0 * aa1;
      double BB = a2 + 1.0 / 2.0 * aa2;
      double C = 2.0 * b1 - bb1;
      double E = 2.0 * b2 - bb2;
      s[0] = 1.0 / 2.0;
      H3[3] = (3.0 * s[0] * s[0] - 2.0 * s[0] * s[0] * s[0]) -
              A * (-1.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[4] = -1.0 / 2.0 * (3.0 * s[0] * s[0] - 2.0 * s[0] * s[0] * s[0]) -
              (BB + 1.0 / 2.0) * (-1.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[5] =
        -1.0 / 2.0 * (1.0 - 3.0 * s[0] * s[0] + 2.0 * s[0] * s[0] * s[0]) +
        1.0 / 2.0 * (C + 1.0) * (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[6] = (1.0 - 3.0 * s[0] * s[0] + 2.0 * s[0] * s[0] * s[0]) +
              1.0 / 2.0 * E * (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[9] = (1.0 + a1) / (2.0 * a2) * (s[0] * s[0] * s[0] - s[0] * s[0]);
      H3[10] = 1.0 / 2.0 * (1.0 + a2 / (1.0 + a1)) *
               (s[0] * s[0] * s[0] - s[0] * s[0]);
      H3[11] = -1.0 / 2.0 * (1.0 + b1 / (1.0 + b2)) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[12] = -1.0 * (1.0 + b2) / (2.0 * b1) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[15] =
        -1.0 / (2.0 * (1.0 + a1) * a2) * (s[0] * s[0] * s[0] - s[0] * s[0]);
      H3[16] = 1.0 / (2.0 * b1 * (1.0 + b2)) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);

      for (unsigned i = 0; i < 21; i++)
      {
        Bt(20, i) = -1.0 * sqrt(2.0) * H3[i];
      }

      s[1] = 3.0 / 4.0;
      F2[1] = s[1] * s[1] * s[1] * (6.0 * s[1] * s[1] - 15.0 * s[1] + 10.0);
      F2[2] = (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1]) *
              (6.0 * s[1] * s[1] + 3.0 * s[1] + 1.0);
      F2[6] = s[1] * s[1] * s[1] * (1.0 - s[1]) * (4.0 - 3.0 * s[1]);
      F2[7] =
        s[1] * (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1]) * (1.0 + 3.0 * s[1]);
      F2[12] = 1.0 / 2.0 * s[1] * s[1] * s[1] * (1.0 - s[1]) * (1.0 - s[1]);
      F2[13] =
        1.0 / 2.0 * s[1] * s[1] * (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1]);
      for (unsigned i = 0; i < 21; i++)
      {
        Bt(21, i) = F2[i];
      }

      s[1] = 1.0 / 4.0;
      F2[1] = s[1] * s[1] * s[1] * (6.0 * s[1] * s[1] - 15.0 * s[1] + 10.0);
      F2[2] = (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1]) *
              (6.0 * s[1] * s[1] + 3.0 * s[1] + 1.0);
      F2[6] = s[1] * s[1] * s[1] * (1.0 - s[1]) * (4.0 - 3.0 * s[1]);
      F2[7] =
        s[1] * (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1]) * (1.0 + 3.0 * s[1]);
      F2[12] = 1.0 / 2.0 * s[1] * s[1] * s[1] * (1.0 - s[1]) * (1.0 - s[1]);
      F2[13] =
        1.0 / 2.0 * s[1] * s[1] * (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1]);
      for (unsigned i = 0; i < 21; i++)
      {
        Bt(22, i) = F2[i];
      }

      s[0] = 1.0 / 4.0;
      F1[0] = s[0] * s[0] * s[0] * (6.0 * s[0] * s[0] - 15.0 * s[0] + 10.0);
      F1[2] = (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) *
              (6.0 * s[0] * s[0] + 3.0 * s[0] + 1.0);
      F1[3] = s[0] * s[0] * s[0] * (1.0 - s[0]) * (4.0 - 3.0 * s[0]);
      F1[8] =
        s[0] * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 + 3.0 * s[0]);
      F1[9] = 1.0 / 2.0 * s[0] * s[0] * s[0] * (1.0 - s[0]) * (1.0 - s[0]);
      F1[14] =
        1.0 / 2.0 * s[0] * s[0] * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]);
      for (unsigned i = 0; i < 21; i++)
      {
        Bt(23, i) = F1[i];
      }

      s[0] = 3.0 / 4.0;
      F1[0] = s[0] * s[0] * s[0] * (6.0 * s[0] * s[0] - 15.0 * s[0] + 10.0);
      F1[2] = (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) *
              (6.0 * s[0] * s[0] + 3.0 * s[0] + 1.0);
      F1[3] = s[0] * s[0] * s[0] * (1.0 - s[0]) * (4.0 - 3.0 * s[0]);
      F1[8] =
        s[0] * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 + 3.0 * s[0]);
      F1[9] = 1.0 / 2.0 * s[0] * s[0] * s[0] * (1.0 - s[0]) * (1.0 - s[0]);
      F1[14] =
        1.0 / 2.0 * s[0] * s[0] * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]);
      for (unsigned i = 0; i < 21; i++)
      {
        Bt(24, i) = F1[i];
      }

      s[0] = 3.0 / 4.0;
      F3[0] = s[0] * s[0] * s[0] * (6.0 * s[0] * s[0] - 15.0 * s[0] + 10.0);
      F3[1] = (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) *
              (6.0 * s[0] * s[0] + 3.0 * s[0] + 1.0);
      F3[3] = -1.0 * (3.0 * a1 + aa1) * s[0] * s[0] * s[0] * (1.0 - s[0]) *
              (1.0 - s[0]);
      F3[4] = s[0] * s[0] * s[0] * (1.0 - s[0]) *
              (2.0 - s[0] - (1.0 - s[0]) * (3.0 * a2 + aa2));
      F3[5] = s[0] * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) *
              (1.0 + s[0] - s[0] * (3.0 * b1 - bb1));
      F3[6] = -1.0 * s[0] * s[0] * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) *
              (3.0 * b2 - bb2);
      F3[10] = 1.0 / 2.0 * s[0] * s[0] * s[0] * (1.0 - s[0]) * (1.0 - s[0]);
      F3[11] =
        1.0 / 2.0 * s[0] * s[0] * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]);
      for (unsigned i = 0; i < 21; i++)
      {
        Bt(25, i) = F3[i];
      }

      s[0] = 1.0 / 4.0;
      F3[0] = s[0] * s[0] * s[0] * (6.0 * s[0] * s[0] - 15.0 * s[0] + 10.0);
      F3[1] = (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) *
              (6.0 * s[0] * s[0] + 3.0 * s[0] + 1.0);
      F3[3] = -1.0 * (3.0 * a1 + aa1) * s[0] * s[0] * s[0] * (1.0 - s[0]) *
              (1.0 - s[0]);
      F3[4] = s[0] * s[0] * s[0] * (1.0 - s[0]) *
              (2.0 - s[0] - (1.0 - s[0]) * (3.0 * a2 + aa2));
      F3[5] = s[0] * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) *
              (1.0 + s[0] - s[0] * (3.0 * b1 - bb1));
      F3[6] = -1.0 * s[0] * s[0] * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) *
              (3.0 * b2 - bb2);
      F3[10] = 1.0 / 2.0 * s[0] * s[0] * s[0] * (1.0 - s[0]) * (1.0 - s[0]);
      F3[11] =
        1.0 / 2.0 * s[0] * s[0] * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]);
      for (unsigned i = 0; i < 21; i++)
      {
        Bt(26, i) = F3[i];
      }

      double g1, g2, h1, h2, k1, k2, j1, j2;
      t[0] = p(0, 0) - p(2, 0) + 9.0 / 16.0 * (p(1, 0) - p(0, 0)) +
             3.0 / 32.0 * (angle_max - angle_min) *
               (-sin(angle_min) + 7.0 * sin(angle_max));
      t[1] = p(0, 1) - p(2, 1) + 9.0 / 16.0 * (p(1, 1) - p(0, 1)) +
             3.0 / 32.0 * (angle_max - angle_min) *
               (cos(angle_min) - 7.0 * cos(angle_max));
      magnitude = sqrt((p(1, 0) - p(2, 0)) * (p(1, 0) - p(2, 0)) +
                       (p(1, 1) - p(2, 1)) * (p(1, 1) - p(2, 1)));
      aa[0] = (p(1, 0) - p(2, 0)) / (magnitude * magnitude);
      aa[1] = (p(1, 1) - p(2, 1)) / (magnitude * magnitude);
      g1 = -1.0 * (t[0] * aa[0] + t[1] * aa[1]);

      magnitude = sqrt((p(0, 0) - s1[0]) * (p(0, 0) - s1[0]) +
                       (p(0, 1) - s1[1]) * (p(0, 1) - s1[1]));
      aa[0] = (p(0, 0) - s1[0]) / (magnitude * magnitude);
      aa[1] = (p(0, 1) - s1[1]) / (magnitude * magnitude);
      g2 = -1.0 * (t[0] * aa[0] + t[1] * aa[1]);

      s[1] = 3.0 / 4.0;
      F2_div(1, 1) = 5.0 * s[1] * s[1] * 6.0 * s[1] * s[1] -
                     4.0 * s[1] * s[1] * 15.0 * s[1] + 3.0 * s[1] * s[1] * 10.0;
      F2_div(2, 1) =
        (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1]) * (12.0 * s[1] + 3.0) -
        3.0 * (1.0 - s[1]) * (1.0 - s[1]) *
          (6.0 * s[1] * s[1] + 3.0 * s[1] + 1.0);
      F2_div(6, 1) = s[1] * s[1] * s[1] * (1.0 - s[1]) * (-3.0) +
                     (4.0 - 3.0 * s[1]) *
                       (-s[1] * s[1] * s[1] + 3.0 * s[1] * s[1] * (1.0 - s[1]));
      F2_div(7, 1) = s[1] * (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1]) * 3.0 +
                     (-3.0 * s[1] * (1.0 - s[1]) * (1.0 - s[1]) +
                      (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1])) *
                       (1.0 + 3.0 * s[1]);
      F2_div(12, 1) = -1.0 * s[1] * s[1] * s[1] * (1.0 - s[1]) +
                      3.0 / 2.0 * (1.0 - s[1]) * (1.0 - s[1]) * s[1] * s[1];
      F2_div(13, 1) =
        -3.0 / 2.0 * s[1] * s[1] * (1.0 - s[1]) * (1.0 - s[1]) +
        1.0 / 2.0 * (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1]) * 2.0 * s[1];

      s[1] = 3.0 / 4.0;
      H2[5] = -1.0 * b1 * (3.0 * s[1] * s[1] - 2.0 * s[1] * s[1] * s[1]);
      H2[6] = -1.0 / 2.0 * (2.0 * b2 + 1.0 + ata1) *
              (3.0 * s[1] * s[1] - 2.0 * s[1] * s[1] * s[1]);
      H2[7] = -1.0 / 2.0 * (1.0 - ata1) *
              (1.0 - 3.0 * s[1] * s[1] + 2.0 * s[1] * s[1] * s[1]);
      H2[8] = (1.0 - 3.0 * s[1] * s[1] + 2.0 * s[1] * s[1] * s[1]);
      H2[11] = -1.0 / 2.0 * ((b1 * b1) / (1.0 + b2)) *
               (s[1] * s[1] * s[1] - s[1] * s[1]);
      H2[12] = 1.0 / 2.0 * (b2 + ata1) * (s[1] * s[1] * s[1] - s[1] * s[1]);
      H2[13] = -1.0 / 2.0 *
               ((2.0 * c1 * cc1) / (c1 * cc2 + c2 * cc1) + 1.0 - ata1) *
               (s[1] - 2.0 * s[1] * s[1] + s[1] * s[1] * s[1]);
      H2[14] = -1.0 * ((c2 * cc2) / (c1 * cc2 + c2 * cc1)) *
               (s[1] - 2.0 * s[1] * s[1] + s[1] * s[1] * s[1]);
      H2[16] =
        1.0 / 2.0 * (1.0 / (1.0 + b2)) * (s[1] * s[1] * s[1] - s[1] * s[1]);
      H2[17] = ((-1.0) / (c1 * cc2 + c2 * cc1)) *
               (s[1] - 2.0 * s[1] * s[1] + s[1] * s[1] * s[1]);
      for (unsigned i = 0; i < 21; i++)
      {
        Bt(27, i) = g1 * F2_div(i, 1) + g2 * H2[i];
      }

      t[0] = p(0, 0) - p(2, 0) + 1.0 / 16.0 * (p(1, 0) - p(0, 0)) +
             1.0 / 32.0 * (angle_max - angle_min) *
               (-3.0 * sin(angle_min) + 5.0 * sin(angle_max));
      t[1] = p(0, 1) - p(2, 1) + 1.0 / 16.0 * (p(1, 1) - p(0, 1)) +
             1.0 / 32.0 * (angle_max - angle_min) *
               (3.0 * cos(angle_min) - 5.0 * cos(angle_max));
      magnitude = sqrt((p(1, 0) - p(2, 0)) * (p(1, 0) - p(2, 0)) +
                       (p(1, 1) - p(2, 1)) * (p(1, 1) - p(2, 1)));
      aa[0] = (p(1, 0) - p(2, 0)) / (magnitude * magnitude);
      aa[1] = (p(1, 1) - p(2, 1)) / (magnitude * magnitude);
      h1 = -1.0 * (t[0] * aa[0] + t[1] * aa[1]);

      magnitude = sqrt((p(0, 0) - s1[0]) * (p(0, 0) - s1[0]) +
                       (p(0, 1) - s1[1]) * (p(0, 1) - s1[1]));
      aa[0] = (p(0, 0) - s1[0]) / (magnitude * magnitude);
      aa[1] = (p(0, 1) - s1[1]) / (magnitude * magnitude);
      h2 = -1.0 * (t[0] * aa[0] + t[1] * aa[1]);

      s[1] = 1.0 / 4.0;
      F2_div(1, 1) = 5.0 * s[1] * s[1] * 6.0 * s[1] * s[1] -
                     4.0 * s[1] * s[1] * 15.0 * s[1] + 3.0 * s[1] * s[1] * 10.0;
      F2_div(2, 1) =
        (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1]) * (12.0 * s[1] + 3.0) -
        3.0 * (1.0 - s[1]) * (1.0 - s[1]) *
          (6.0 * s[1] * s[1] + 3.0 * s[1] + 1.0);
      F2_div(6, 1) = s[1] * s[1] * s[1] * (1.0 - s[1]) * (-3.0) +
                     (4.0 - 3.0 * s[1]) *
                       (-s[1] * s[1] * s[1] + 3.0 * s[1] * s[1] * (1.0 - s[1]));
      F2_div(7, 1) = s[1] * (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1]) * 3.0 +
                     (-3.0 * s[1] * (1.0 - s[1]) * (1.0 - s[1]) +
                      (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1])) *
                       (1.0 + 3.0 * s[1]);
      F2_div(12, 1) = -1.0 * s[1] * s[1] * s[1] * (1.0 - s[1]) +
                      3.0 / 2.0 * (1.0 - s[1]) * (1.0 - s[1]) * s[1] * s[1];
      F2_div(13, 1) =
        -3.0 / 2.0 * s[1] * s[1] * (1.0 - s[1]) * (1.0 - s[1]) +
        1.0 / 2.0 * (1.0 - s[1]) * (1.0 - s[1]) * (1.0 - s[1]) * 2.0 * s[1];

      s[1] = 1.0 / 4.0;
      H2[5] = -1.0 * b1 * (3.0 * s[1] * s[1] - 2.0 * s[1] * s[1] * s[1]);
      H2[6] = -1.0 / 2.0 * (2.0 * b2 + 1.0 + ata1) *
              (3.0 * s[1] * s[1] - 2.0 * s[1] * s[1] * s[1]);
      H2[7] = -1.0 / 2.0 * (1.0 - ata1) *
              (1.0 - 3.0 * s[1] * s[1] + 2.0 * s[1] * s[1] * s[1]);
      H2[8] = (1.0 - 3.0 * s[1] * s[1] + 2.0 * s[1] * s[1] * s[1]);
      H2[11] = -1.0 / 2.0 * ((b1 * b1) / (1.0 + b2)) *
               (s[1] * s[1] * s[1] - s[1] * s[1]);
      H2[12] = 1.0 / 2.0 * (b2 + ata1) * (s[1] * s[1] * s[1] - s[1] * s[1]);
      H2[13] = -1.0 / 2.0 *
               ((2.0 * c1 * cc1) / (c1 * cc2 + c2 * cc1) + 1.0 - ata1) *
               (s[1] - 2.0 * s[1] * s[1] + s[1] * s[1] * s[1]);
      H2[14] = -1.0 * ((c2 * cc2) / (c1 * cc2 + c2 * cc1)) *
               (s[1] - 2.0 * s[1] * s[1] + s[1] * s[1] * s[1]);
      H2[16] =
        1.0 / 2.0 * (1.0 / (1.0 + b2)) * (s[1] * s[1] * s[1] - s[1] * s[1]);
      H2[17] = ((-1.0) / (c1 * cc2 + c2 * cc1)) *
               (s[1] - 2.0 * s[1] * s[1] + s[1] * s[1] * s[1]);

      for (unsigned i = 0; i < 21; i++)
      {
        Bt(28, i) = h1 * F2_div(i, 1) + h2 * H2[i];
      }

      t[0] = p(1, 0) - p(2, 0) + 1.0 / 16.0 * (p(0, 0) - p(1, 0)) -
             1.0 / 32.0 * (angle_max - angle_min) *
               (-3.0 * sin(angle_max) + 5.0 * sin(angle_min));
      t[1] = p(1, 1) - p(2, 1) + 1.0 / 16.0 * (p(0, 1) - p(1, 1)) -
             1.0 / 32.0 * (angle_max - angle_min) *
               (3.0 * cos(angle_max) - 5.0 * cos(angle_min));
      magnitude = sqrt((p(0, 0) - p(2, 0)) * (p(0, 0) - p(2, 0)) +
                       (p(0, 1) - p(2, 1)) * (p(0, 1) - p(2, 1)));
      aa[0] = (p(0, 0) - p(2, 0)) / (magnitude * magnitude);
      aa[1] = (p(0, 1) - p(2, 1)) / (magnitude * magnitude);
      j1 = -1.0 * (t[0] * aa[0] + t[1] * aa[1]);

      magnitude = sqrt((p(1, 0) - s2[0]) * (p(1, 0) - s2[0]) +
                       (p(1, 1) - s2[1]) * (p(1, 1) - s2[1]));
      aa[0] = (p(1, 0) - s2[0]) / (magnitude * magnitude);
      aa[1] = (p(1, 1) - s2[1]) / (magnitude * magnitude);
      j2 = -1.0 * (t[0] * aa[0] + t[1] * aa[1]);

      s[0] = 1.0 / 4.0;
      F1_div(0, 0) = 5.0 * s[0] * s[0] * 6.0 * s[0] * s[0] -
                     4.0 * s[0] * s[0] * 15.0 * s[0] + 3.0 * s[0] * s[0] * 10.0;
      F1_div(2, 0) =
        (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) * (12.0 * s[0] + 3.0) -
        3.0 * (1.0 - s[0]) * (1.0 - s[0]) *
          (6.0 * s[0] * s[0] + 3.0 * s[0] + 1.0);
      F1_div(3, 0) = s[0] * s[0] * s[0] * (1.0 - s[0]) * (-3.0) +
                     (4.0 - 3.0 * s[0]) *
                       (-s[0] * s[0] * s[0] + 3.0 * s[0] * s[0] * (1.0 - s[0]));
      F1_div(8, 0) = s[0] * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) * 3.0 +
                     (-3.0 * s[0] * (1.0 - s[0]) * (1.0 - s[0]) +
                      (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0])) *
                       (1.0 + 3.0 * s[0]);
      F1_div(9, 0) = -1.0 * s[0] * s[0] * s[0] * (1.0 - s[0]) +
                     3.0 / 2.0 * (1.0 - s[0]) * (1.0 - s[0]) * s[0] * s[0];
      F1_div(14, 0) =
        -3.0 / 2.0 * s[0] * s[0] * (1.0 - s[0]) * (1.0 - s[0]) +
        1.0 / 2.0 * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) * 2.0 * s[0];
      s[0] = 1.0 / 4.0;
      H1[3] = -1.0 / 2.0 * (1.0 - ata2 + 2.0 * a1) *
              (3.0 * s[0] * s[0] - 2.0 * s[0] * s[0] * s[0]);
      H1[4] = -1.0 * a2 * (3.0 * s[0] * s[0] - 2.0 * s[0] * s[0] * s[0]);
      H1[7] = 1.0 - 3.0 * s[0] * s[0] + 2.0 * s[0] * s[0] * s[0];
      H1[8] = -1.0 / 2.0 * (1.0 + ata2) *
              (1.0 - 3.0 * s[0] * s[0] + 2.0 * s[0] * s[0] * s[0]);
      H1[9] = 1.0 / 2.0 * (a1 - ata2) * (s[0] * s[0] * s[0] - s[0] * s[0]);
      H1[10] = -1.0 / 2.0 * (a2 * a2 / (1.0 + a1)) *
               (s[0] * s[0] * s[0] - s[0] * s[0]);
      H1[13] = ((-1.0 * c1 * cc1) / (c1 * cc2 + c2 * cc1)) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H1[14] = -1.0 *
               (1.0 / 2.0 * (1.0 + ata2) + (c2 * cc2 / (c1 * cc2 + c2 * cc1))) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H1[15] = (s[0] * s[0] * s[0] - s[0] * s[0]) / (2.0 * (1.0 + a1));
      H1[17] = -1.0 / (c1 * cc2 + c2 * cc1) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      for (unsigned i = 0; i < 21; i++)
      {
        Bt(29, i) = j1 * F1_div(i, 0) + j2 * H1[i];
      }

      t[0] = p(1, 0) - p(2, 0) + 9.0 / 16.0 * (p(0, 0) - p(1, 0)) -
             3.0 / 32.0 * (angle_max - angle_min) *
               (-sin(angle_max) + 7.0 * sin(angle_min));
      t[1] = p(1, 1) - p(2, 1) + 9.0 / 16.0 * (p(0, 1) - p(1, 1)) -
             3.0 / 32.0 * (angle_max - angle_min) *
               (cos(angle_max) - 7.0 * cos(angle_min));
      magnitude = sqrt((p(0, 0) - p(2, 0)) * (p(0, 0) - p(2, 0)) +
                       (p(0, 1) - p(2, 1)) * (p(0, 1) - p(2, 1)));
      aa[0] = (p(0, 0) - p(2, 0)) / (magnitude * magnitude);
      aa[1] = (p(0, 1) - p(2, 1)) / (magnitude * magnitude);
      k1 = -1.0 * (t[0] * aa[0] + t[1] * aa[1]);

      magnitude = sqrt((p(1, 0) - s2[0]) * (p(1, 0) - s2[0]) +
                       (p(1, 1) - s2[1]) * (p(1, 1) - s2[1]));
      aa[0] = (p(1, 0) - s2[0]) / (magnitude * magnitude);
      aa[1] = (p(1, 1) - s2[1]) / (magnitude * magnitude);
      k2 = -1.0 * (t[0] * aa[0] + t[1] * aa[1]);

      s[0] = 3.0 / 4.0;
      F1_div(0, 0) = 5.0 * s[0] * s[0] * 6.0 * s[0] * s[0] -
                     4.0 * s[0] * s[0] * 15.0 * s[0] + 3.0 * s[0] * s[0] * 10.0;
      F1_div(2, 0) =
        (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) * (12.0 * s[0] + 3.0) -
        3.0 * (1.0 - s[0]) * (1.0 - s[0]) *
          (6.0 * s[0] * s[0] + 3.0 * s[0] + 1.0);
      F1_div(3, 0) = s[0] * s[0] * s[0] * (1.0 - s[0]) * (-3.0) +
                     (4.0 - 3.0 * s[0]) *
                       (-s[0] * s[0] * s[0] + 3.0 * s[0] * s[0] * (1.0 - s[0]));
      F1_div(8, 0) = s[0] * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) * 3.0 +
                     (-3.0 * s[0] * (1.0 - s[0]) * (1.0 - s[0]) +
                      (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0])) *
                       (1.0 + 3.0 * s[0]);
      F1_div(9, 0) = -1.0 * s[0] * s[0] * s[0] * (1.0 - s[0]) +
                     3.0 / 2.0 * (1.0 - s[0]) * (1.0 - s[0]) * s[0] * s[0];
      F1_div(14, 0) =
        -3.0 / 2.0 * s[0] * s[0] * (1.0 - s[0]) * (1.0 - s[0]) +
        1.0 / 2.0 * (1.0 - s[0]) * (1.0 - s[0]) * (1.0 - s[0]) * 2.0 * s[0];

      s[0] = 3.0 / 4.0;
      H1[3] = -1.0 / 2.0 * (1.0 - ata2 + 2.0 * a1) *
              (3.0 * s[0] * s[0] - 2.0 * s[0] * s[0] * s[0]);
      H1[4] = -1.0 * a2 * (3.0 * s[0] * s[0] - 2.0 * s[0] * s[0] * s[0]);
      H1[7] = 1.0 - 3.0 * s[0] * s[0] + 2.0 * s[0] * s[0] * s[0];
      H1[8] = -1.0 / 2.0 * (1.0 + ata2) *
              (1.0 - 3.0 * s[0] * s[0] + 2.0 * s[0] * s[0] * s[0]);
      H1[9] = 1.0 / 2.0 * (a1 - ata2) * (s[0] * s[0] * s[0] - s[0] * s[0]);
      H1[10] = -1.0 / 2.0 * (a2 * a2 / (1.0 + a1)) *
               (s[0] * s[0] * s[0] - s[0] * s[0]);
      H1[13] = ((-1.0 * c1 * cc1) / (c1 * cc2 + c2 * cc1)) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H1[14] = -1.0 *
               (1.0 / 2.0 * (1.0 + ata2) + (c2 * cc2 / (c1 * cc2 + c2 * cc1))) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H1[15] = (s[0] * s[0] * s[0] - s[0] * s[0]) / (2.0 * (1.0 + a1));
      H1[17] = -1.0 / (c1 * cc2 + c2 * cc1) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      for (unsigned i = 0; i < 21; i++)
      {
        Bt(30, i) = k1 * F1_div(i, 0) + k2 * H1[i];
      }

      s[0] = 3.0 / 4.0;
      H3[3] = (3.0 * s[0] * s[0] - 2.0 * s[0] * s[0] * s[0]) -
              A * (-1.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[4] = -1.0 / 2.0 * (3.0 * s[0] * s[0] - 2.0 * s[0] * s[0] * s[0]) -
              (BB + 1.0 / 2.0) * (-1.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[5] =
        -1.0 / 2.0 * (1.0 - 3.0 * s[0] * s[0] + 2.0 * s[0] * s[0] * s[0]) +
        1.0 / 2.0 * (C + 1.0) * (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[6] = (1.0 - 3.0 * s[0] * s[0] + 2.0 * s[0] * s[0] * s[0]) +
              1.0 / 2.0 * E * (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[9] = (1.0 + a1) / (2.0 * a2) * (s[0] * s[0] * s[0] - s[0] * s[0]);
      H3[10] = 1.0 / 2.0 * (1.0 + a2 / (1.0 + a1)) *
               (s[0] * s[0] * s[0] - s[0] * s[0]);
      H3[11] = -1.0 / 2.0 * (1.0 + b1 / (1.0 + b2)) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[12] = -1.0 * (1.0 + b2) / (2.0 * b1) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[15] =
        -1.0 / (2.0 * (1.0 + a1) * a2) * (s[0] * s[0] * s[0] - s[0] * s[0]);
      H3[16] = 1.0 / (2.0 * b1 * (1.0 + b2)) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);

      for (unsigned i = 0; i < 21; i++)
        for (unsigned i = 0; i < 21; i++)
        {
          Bt(31, i) = -1.0 * sqrt(2.0) * H3[i];
        }

      s[0] = 1.0 / 4.0;
      H3[3] = (3.0 * s[0] * s[0] - 2.0 * s[0] * s[0] * s[0]) -
              A * (-1.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[4] = -1.0 / 2.0 * (3.0 * s[0] * s[0] - 2.0 * s[0] * s[0] * s[0]) -
              (BB + 1.0 / 2.0) * (-1.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[5] =
        -1.0 / 2.0 * (1.0 - 3.0 * s[0] * s[0] + 2.0 * s[0] * s[0] * s[0]) +
        1.0 / 2.0 * (C + 1.0) * (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[6] = (1.0 - 3.0 * s[0] * s[0] + 2.0 * s[0] * s[0] * s[0]) +
              1.0 / 2.0 * E * (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[9] = (1.0 + a1) / (2.0 * a2) * (s[0] * s[0] * s[0] - s[0] * s[0]);
      H3[10] = 1.0 / 2.0 * (1.0 + a2 / (1.0 + a1)) *
               (s[0] * s[0] * s[0] - s[0] * s[0]);
      H3[11] = -1.0 / 2.0 * (1.0 + b1 / (1.0 + b2)) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[12] = -1.0 * (1.0 + b2) / (2.0 * b1) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);
      H3[15] =
        -1.0 / (2.0 * (1.0 + a1) * a2) * (s[0] * s[0] * s[0] - s[0] * s[0]);
      H3[16] = 1.0 / (2.0 * b1 * (1.0 + b2)) *
               (s[0] - 2.0 * s[0] * s[0] + s[0] * s[0] * s[0]);

      for (unsigned i = 0; i < 21; i++)
      {
        Bt(32, i) = -1.0 * sqrt(2.0) * H3[i];
      }
      // submatrix b7
      Bt(33, 18) = 1.0;
      Bt(34, 19) = 1.0;
      Bt(35, 20) = 1.0;
      for (unsigned i = 0; i < 21; i++)
      {
        for (unsigned j = 0; j < 36; j++)
        {
          B(i, j) = Bt(j, i);
        }
      }
    }

    ///=========================================================================
    /// Compute C1-curved shape functions at the local coordinate s
    ///========================================================================
    void Cshape(const Vector<double>& s, Shape& psi_curve) const
    {
      // get basis
      Shape basis(36);
      basis_curve(s, basis);
      // get coefficient of the basis polynomial
      DenseMatrix<double> A(36, 36);
      get_coefficient(A);

      Vector<double> psi(36, 0.0);
      for (unsigned i = 0; i < 36; i++)
      {
        for (unsigned j = 0; j < 36; j++)
        {
          psi[i] += A(i, j) * basis[j];
        }
      }
      for (unsigned i = 0; i < 36; i++)
      {
        psi_curve[i] = psi[i];
      }
    }

    ///=========================================================================
    /// Compute the derivatives of C1-curved shape functions at the local
    /// coordinate s
    ///=========================================================================
    void dCshape_local(const Vector<double>& s,
                       Shape& psi_curve,
                       DShape& dpsi_curve) const
    {
      Cshape(s, psi_curve);
      // get dbasis
      Shape basis(36);
      DShape dbasis(36, 2);
      dbasis_local_curve(s, basis, dbasis);
      // get coefficient of the basis polynomial
      DenseMatrix<double> A(36, 36);
      get_coefficient(A);
      DenseMatrix<double> dpsi(36, 2, 0.0);
      for (unsigned i = 0; i < 36; i++)
      {
        for (unsigned j = 0; j < 36; j++)
        {
          for (unsigned k = 0; k < 2; k++)
          {
            dpsi(i, k) += A(i, j) * dbasis(j, k);
          }
        }
      }
      for (unsigned i = 0; i < 36; i++)
      {
        for (unsigned k = 0; k < 2; k++)
        {
          dpsi_curve(i, k) = dpsi(i, k);
        }
      }
    }

    ///=========================================================================
    /// Compute the second-order derivatives of C1-curved shape functions
    /// at the local coordinate s
    ///=========================================================================
    void d2Cshape_local(const Vector<double>& s,
                        Shape& psi_curve,
                        DShape& dpsi_curve,
                        DShape& d2psi_curve) const
    {
      dCshape_local(s, psi_curve, dpsi_curve);

      // get d2basis
      Shape basis(36);
      DShape dbasis(36, 2), d2basis(36, 3);
      d2basis_local_curve(s, basis, dbasis, d2basis);
      // get coefficient of the basis polynomial
      DenseMatrix<double> A(36, 36, 0.0);
      get_coefficient(A);
      DenseMatrix<double> d2psi(36, 3, 0.0);
      for (unsigned i = 0; i < 36; i++)
      {
        for (unsigned j = 0; j < 36; j++)
        {
          for (unsigned k = 0; k < 3; k++)
          {
            d2psi(i, k) += A(i, j) * d2basis(j, k);
          }
        }
      }
      for (unsigned i = 0; i < 36; i++)
      {
        for (unsigned k = 0; k < 3; k++)
        {
          d2psi_curve(i, k) = d2psi(i, k);
        }
      }
    }

    ///=========================================================================
    /// Compute coefficients of the bases of the C1-curved shape functions
    ///=========================================================================
    void get_coefficient(DenseMatrix<double>& A) const
    {
      // initialize the matrix A
      for (unsigned i = 0; i < 36; i++)
      {
        for (unsigned j = 0; j < 36; j++)
        {
          A(i, j) = 0.0;
        }
      }
      // 1
      A(1, 0) = 6496.0 / 27.0;
      A(1, 2) = 55376.0 / 27.0;
      A(1, 3) = 15296.0 / 3.0;
      A(1, 4) = 86464.0 / 27.0;
      A(1, 5) = 464.0 / 3.0;
      A(1, 8) = -6896.0 / 9.0;
      A(1, 10) = -136424.0 / 27.0;
      A(1, 11) = -187040.0 / 27.0;
      A(1, 12) = -27880.0 / 27.0;
      A(1, 15) = 7750.0 / 9.0;
      A(1, 17) = 98371.0 / 27.0;
      A(1, 18) = 41027.0 / 27.0;
      A(1, 21) = -10501.0 / 27.0;
      A(1, 23) = -17323.0 / 27.0;
      A(1, 26) = 490.0 / 9.0;
      A(0, 2) = 464.0 / 3.0;
      A(0, 3) = 86464.0 / 27.0;
      A(0, 4) = 15296.0 / 3.0;
      A(0, 5) = 55376.0 / 27.0;
      A(0, 7) = 6496.0 / 27.0;
      A(0, 10) = -27880.0 / 27.0;
      A(0, 11) = -187040.0 / 27.0;
      A(0, 12) = -136424.0 / 27.0;
      A(0, 14) = -6896.0 / 9.0;
      A(0, 17) = 41027.0 / 27.0;
      A(0, 18) = 98371.0 / 27.0;
      A(0, 20) = 7750.0 / 9.00;
      A(0, 23) = -17323.0 / 27.0;
      A(0, 25) = -10501.0 / 27.0;
      A(0, 29) = 490.00 / 9.0;
      A(2, 0) = -6496.00 / 27.0;
      A(2, 2) = 14176.00 / 27.00;
      A(2, 3) = -2944.00 / 27.00;
      A(2, 4) = -2944.00 / 27.00;
      A(2, 5) = 14176.00 / 27.00;
      A(2, 7) = -6496.00 / 27.00;
      A(2, 8) = 24784.00 / 27.00;
      A(2, 10) = -5680.00 / 27.00;
      A(2, 11) = 12736.00 / 9.00;
      A(2, 12) = -5680.00 / 27.00;
      A(2, 14) = 24784.00 / 27.00;
      A(2, 15) = -11846.00 / 9.00;
      A(2, 17) = -26758.00 / 27.00;
      A(2, 18) = -26758.00 / 27.00;
      A(2, 20) = -11846.00 / 9.00;
      A(2, 21) = 22789.00 / 27.00;
      A(2, 23) = 18262.00 / 27.00;
      A(2, 25) = 22789.00 / 27.00;
      A(2, 26) = -5566.00 / 27.00;
      A(2, 29) = -5566.00 / 27.00;
      A(2, 35) = 1.00;
      A(6, 0) = -400.00 / 9.00;
      A(6, 2) = -3080.00 / 9.00;
      A(6, 3) = -816.00;
      A(6, 4) = -4496.00 / 9.00;
      A(6, 5) = -232.00 / 9.00;
      A(6, 8) = 416.00 / 3.00;
      A(6, 10) = 7448.00 / 9.00;
      A(6, 11) = 9872.00 / 9.00;
      A(6, 12) = 1472.00 / 9.00;
      A(6, 15) = -457.00 / 3.00;
      A(6, 17) = -1177.00 / 2.00;
      A(6, 18) = -4337.00 / 18.00;
      A(6, 21) = 607.00 / 9.00;
      A(6, 23) = 619.00 / 6.00;
      A(6, 26) = -28.00 / 3.00;
      A(5, 1) = -896.00 / 9.00;
      A(5, 2) = -392.00 / 9.00;
      A(5, 3) = 2384.00 / 9.00;
      A(5, 4) = 2512.00 / 9.00;
      A(5, 5) = 232.00 / 9.00;
      A(5, 9) = 2336.00 / 9.00;
      A(5, 10) = -8.00 / 9.00;
      A(5, 11) = -3920.00 / 9.00;
      A(5, 12) = -976.00 / 9.00;
      A(5, 16) = -2104.00 / 9.00;
      A(5, 17) = 123.00 / 2.00;
      A(5, 18) = 1981.00 / 18.00;
      A(5, 22) = 766.00 / 9.00;
      A(5, 23) = -307.00 / 18.00;
      A(5, 27) = -31.00 / 3.00;
      A(4, 2) = 232.00 / 9.00;
      A(4, 3) = 2512.00 / 9.00;
      A(4, 4) = 2384.00 / 9.00;
      A(4, 5) = -392.00 / 9.00;
      A(4, 6) = -896.00 / 9.00;
      A(4, 10) = -976.00 / 9.00;
      A(4, 11) = -3920.00 / 9.00;
      A(4, 12) = -8.00 / 9.00;
      A(4, 13) = 2336.00 / 9.00;
      A(4, 17) = 1981.00 / 18.00;
      A(4, 18) = 123.00 / 2.00;
      A(4, 19) = -2104.00 / 9.00;
      A(4, 23) = -307.00 / 18.00;
      A(4, 24) = 766.00 / 9.00;
      A(4, 28) = -31.00 / 3.00;
      A(3, 2) = -232.00 / 9.00;
      A(3, 3) = -4496.00 / 9.00;
      A(3, 4) = -816.00;
      A(3, 5) = -3080.00 / 9.00;
      A(3, 7) = -400.00 / 9.00;
      //------- 2
      A(3, 10) = 1472.00 / 9.00;
      A(3, 11) = 9872.00 / 9.00;
      A(3, 12) = 7448.00 / 9.00;
      A(3, 14) = 416.00 / 3.00;
      A(3, 17) = -4337.00 / 18.00;
      A(3, 18) = -1177.00 / 2.00;
      A(3, 20) = -457.00 / 3.00;
      A(3, 23) = 619.00 / 6.00;
      A(3, 25) = 607.00 / 9.00;
      A(3, 29) = -28.00 / 3.00;
      A(8, 0) = -400.00 / 9.00;
      A(8, 2) = 1456.00 / 9.00;
      A(8, 3) = -992.00 / 9.00;
      A(8, 4) = -5248.00 / 9.00;
      A(8, 5) = -4096.00 / 9.00;
      A(8, 6) = -896.00 / 9.00;
      A(8, 8) = 1552.00 / 9.00;
      A(8, 10) = -464.00 / 3.00;
      A(8, 11) = 2464.00 / 3.00;
      A(8, 12) = 3424.00 / 3.00;
      A(8, 13) = 3040.00 / 9.00;
      A(8, 15) = -761.00 / 3.00;
      A(8, 17) = -1831.00 / 9.00;
      A(8, 18) = -938.00;
      A(8, 19) = -1288.00 / 3.00;
      A(8, 21) = 1528.00 / 9.00;
      A(8, 23) = 2266.00 / 9.00;
      A(8, 24) = 2210.00 / 9.00;
      A(8, 26) = -406.00 / 9.00;
      A(8, 28) = -499.00 / 9.00;
      A(8, 33) = 1.00;
      A(7, 1) = -896.00 / 9.00;
      A(7, 2) = -4096.00 / 9.00;
      A(7, 3) = -5248.00 / 9.00;
      A(7, 4) = -992.00 / 9.00;
      A(7, 5) = 1456.00 / 9.00;
      A(7, 7) = -400.00 / 9.00;
      A(7, 9) = 3040.00 / 9.00;
      A(7, 10) = 3424.00 / 3.00;
      A(7, 11) = 2464.00 / 3.00;
      A(7, 12) = -464.00 / 3.00;
      A(7, 14) = 1552.00 / 9.00;
      A(7, 16) = -1288.00 / 3.00;
      A(7, 17) = -938.00;
      A(7, 18) = -1831.00 / 9.00;
      A(7, 20) = -761.00 / 3.00;
      A(7, 22) = 2210.00 / 9.00;
      A(7, 23) = 2266.00 / 9.00;
      A(7, 25) = 1528.00 / 9.00;
      A(7, 27) = -499.00 / 9.00;
      A(7, 29) = -406.00 / 9.00;
      A(7, 34) = 1.00;
      A(14, 0) = 8.00 / 3.00;
      A(14, 2) = 52.00 / 3.00;
      A(14, 3) = 40.00;
      A(14, 4) = 24.00;
      A(14, 5) = 4.00 / 3.00;
      A(14, 8) = -8.00;
      A(14, 10) = -124.00 / 3.00;
      A(14, 11) = -160.00 / 3.00;
      A(14, 12) = -8.00;
      A(14, 15) = 17.00 / 2.00;
      A(14, 17) = 349.00 / 12.00;
      A(14, 18) = 47.00 / 4.00;
      A(14, 21) = -11.00 / 3.00;
      A(14, 23) = -61.00 / 12.00;
      A(14, 26) = 1.00 / 2.00;
      A(13, 1) = 32.00 / 3.00;
      A(13, 2) = 8.00 / 3.00;
      A(13, 3) = -80.00 / 3.00;
      A(13, 4) = -80.00 / 3.00;
      A(13, 5) = -8.00 / 3.00;
      A(13, 9) = -80.00 / 3.00;
      A(13, 10) = 8.00 / 3.00;
      A(13, 11) = 128.00 / 3.00;
      A(13, 12) = 32.00 / 3.00;
      A(13, 16) = 70.00 / 3.0;
      A(13, 17) = -43.0 / 6.0;
      A(13, 18) = -65.0 / 6.0;
      A(13, 22) = -25.0 / 3.0;
      A(13, 23) = 11.0 / 6.0;
      A(13, 27) = 1.0;
      A(12, 2) = 4.0;
      A(12, 3) = 40.0 / 3.0;
      A(12, 4) = 40.0 / 3.0;
      A(12, 5) = 4.0 / 3.0;
      A(12, 10) = -28.0 / 3.0;
      A(12, 11) = -64.0 / 3.0;
      A(12, 12) = -16.0 / 3.0;
      A(12, 17) = 29.0 / 4.0;
      A(12, 18) = 65.0 / 12.0;
      A(12, 23) = -17.0 / 12.0;
      A(11, 2) = 4.0 / 3.0;
      A(11, 3) = 40.0 / 3.0;
      A(11, 4) = 40.0 / 3.0;
      A(11, 5) = 4.0;
      A(11, 10) = -16.0 / 3.0;
      A(11, 11) = -64.0 / 3.0;
      A(11, 12) = -28.0 / 3.0;
      A(11, 17) = 65.0 / 12.0;
      A(11, 18) = 29.0 / 4.0;
      A(11, 23) = -17.0 / 12.0;
      //------- 3
      A(10, 2) = -8.0 / 3.0;
      A(10, 3) = -80.0 / 3.0;
      A(10, 4) = -80.0 / 3.0;
      A(10, 5) = 8.0 / 3.0;
      A(10, 6) = 32.0 / 3.0;
      A(10, 10) = 32.0 / 3.0;
      A(10, 11) = 128.0 / 3.0;
      A(10, 12) = 8.0 / 3.0;
      A(10, 13) = -80.0 / 3.0;
      A(10, 17) = -65.0 / 6.0;
      A(10, 18) = -43.0 / 6.0;
      A(10, 19) = 70.0 / 3.0;
      A(10, 23) = 11.0 / 6.0;
      A(10, 24) = -25.0 / 3.0;
      A(10, 28) = 1.0;
      A(9, 2) = 4.0 / 3.0;
      A(9, 3) = 24.0;
      A(9, 4) = 40.0;
      A(9, 5) = 52.0 / 3.0;
      A(9, 7) = 8.0 / 3.0;
      A(9, 10) = -8.0;
      A(9, 11) = -160.0 / 3.0;
      A(9, 12) = -124.0 / 3.0;
      A(9, 14) = -8.0;
      A(9, 17) = 47.0 / 4.0;
      A(9, 18) = 349.0 / 12.0;
      A(9, 20) = 17.0 / 2.0;
      A(9, 23) = -61.0 / 12.0;
      A(9, 25) = -11.0 / 3.0;
      A(9, 29) = 1.0 / 2.0;
      A(17, 0) = -8.0 / 3.0;
      A(17, 2) = 56.0 / 3.0;
      A(17, 3) = 80.0 / 3.0;
      A(17, 4) = 32.0 / 3.0;
      A(17, 8) = 32.0 / 3.0;
      A(17, 10) = -40.0;
      A(17, 11) = -32.0;
      A(17, 12) = -8.0 / 3.0;
      A(17, 15) = -33.0 / 2.0;
      A(17, 17) = 51.0 / 2.0;
      A(17, 18) = 19.0 / 3.0;
      A(17, 21) = 73.0 / 6.0;
      A(17, 23) = -25.0 / 6.0;
      A(17, 26) = -25.0 / 6.0;
      A(17, 30) = 1.0 / 2.0;
      A(16, 1) = -32.0 / 3.0;
      A(16, 2) = -160.0 / 3.0;
      A(16, 3) = -320.0 / 3.0;
      A(16, 4) = -320.0 / 3.0;
      A(16, 5) = -160.0 / 3.0;
      A(16, 6) = -32.0 / 3.0;
      A(16, 9) = 112.0 / 3.0;
      A(16, 10) = 448.0 / 3.0;
      A(16, 11) = 224.0;
      A(16, 12) = 448.0 / 3.0;
      A(16, 13) = 112.0 / 3.0;
      A(16, 16) = -50.0;
      A(16, 17) = -150.0;
      A(16, 18) = -150.0;
      A(16, 19) = -50.0;
      A(16, 22) = 95.0 / 3.0;
      A(16, 23) = 190.0 / 3.0;
      A(16, 24) = 95.0 / 3.0;
      A(16, 27) = -28.0 / 3.0;
      A(16, 28) = -28.0 / 3.0;
      A(16, 31) = 1.0;
      A(15, 3) = 32.0 / 3.0;
      A(15, 4) = 80.0 / 3.0;
      A(15, 5) = 56.0 / 3.0;
      A(15, 7) = -8.0 / 3.0;
      A(15, 10) = -8.0 / 3.0;
      A(15, 11) = -32.0;
      A(15, 12) = -40.0;
      A(15, 14) = 32.0 / 3.0;
      A(15, 17) = 19.0 / 3.0;
      A(15, 18) = 51.0 / 2.0;
      A(15, 20) = -33.0 / 2.0;
      A(15, 23) = -25.0 / 6.0;
      A(15, 25) = 73.0 / 6.0;
      A(15, 29) = -25.0 / 6.0;
      A(15, 32) = 1.0 / 2.0;
      A(19, 3) = 256.0;
      A(19, 4) = 768.0;
      A(19, 5) = 768.0;
      A(19, 6) = 256.0;
      A(19, 10) = -64.0;
      A(19, 11) = -896.0;
      A(19, 12) = -1600.0;
      A(19, 13) = -768.0;
      A(19, 17) = 176.0;
      A(19, 18) = 992.0;
      A(19, 19) = 816.0;
      A(19, 23) = -160.0;
      A(19, 24) = -352.0;
      A(19, 28) = 48.0;
      A(18, 1) = 256.0;
      A(18, 2) = 768.0;
      A(18, 3) = 768.0;
      A(18, 4) = 256.0;
      A(18, 9) = -768.0;
      A(18, 10) = -1600.0;
      A(18, 11) = -896.0;

      //--------- 4
      A(18, 12) = -64.0;
      A(18, 16) = 816.0;
      A(18, 17) = 992.0;
      A(18, 18) = 176.0;
      A(18, 22) = -352.0;
      A(18, 23) = -160.0;
      A(18, 27) = 48.0;
      A(20, 3) = 128.0 * sqrt(2.0);
      A(20, 4) = 128.0 * sqrt(2.0);
      A(20, 10) = -32.0 * sqrt(2.0);
      A(20, 11) = -192.0 * sqrt(2.0);
      A(20, 12) = -32.0 * sqrt(2.0);
      A(20, 17) = 40.0 * sqrt(2.0);
      A(20, 18) = 40.0 * sqrt(2.0);
      A(20, 23) = -8.0 * sqrt(2.0);
      A(24, 3) = -65536.0 / 27.0;
      A(24, 4) = -114688.0 / 27.0;
      A(24, 5) = -40960.0 / 27.0;
      A(24, 7) = -8192.0 / 27.0;
      A(24, 10) = 16384.0 / 27.0;
      A(24, 11) = 53248. / 9.0;
      A(24, 12) = 38912.0 / 9.0;
      A(24, 14) = 26624.0 / 27.0;
      A(24, 17) = -32768.0 / 27.0;
      A(24, 18) = -10240.0 / 3.0;
      A(24, 20) = -10240.0 / 9.0;
      A(24, 23) = 16384.0 / 27.0;
      A(24, 25) = 14336.0 / 27.0;
      A(24, 29) = -2048.0 / 27.0;
      A(23, 2) = 53248.0 / 27.0;
      A(23, 3) = 40960.0 / 9.0;
      A(23, 4) = 69632.0 / 27.0;
      A(23, 5) = -8192.0 / 27.0;
      A(23, 7) = 8192.0 / 27.0;
      A(23, 10) = -48128.0 / 9.0;
      A(23, 11) = -22528.0 / 3.0;
      A(23, 12) = -1024.0;
      A(23, 14) = -10240.0 / 9.0;
      A(23, 17) = 14336.0 / 3.0;
      A(23, 18) = 8192.0 / 3.0;
      A(23, 20) = 14336.0 / 9.0;
      A(23, 23) = -37888.0 / 27.0;
      A(23, 25) = -26624.0 / 27.0;
      A(23, 29) = 2048.0 / 9.0;
      A(22, 0) = 8192.0 / 27.0;
      A(22, 2) = -8192.0 / 27.0;
      A(22, 3) = 69632.0 / 27.0;
      A(22, 4) = 40960.0 / 9.0;
      A(22, 5) = 53248.0 / 27.0;
      A(22, 8) = -10240.0 / 9.0;
      A(22, 10) = -1024.0;
      A(22, 11) = -22528.0 / 3.0;
      A(22, 12) = -48128.0 / 9.0;
      A(22, 15) = 14336.0 / 9.0;
      A(22, 17) = 8192.0 / 3.0;
      A(22, 18) = 14336.0 / 3.0;
      A(22, 21) = -26624.0 / 27.0;
      A(22, 23) = -37888.0 / 27.0;
      A(22, 26) = 2048.0 / 9.0;
      A(21, 0) = -8192.0 / 27.0;
      A(21, 2) = -40960.0 / 27.0;
      A(21, 3) = -114688.0 / 27.0;
      A(21, 4) = -65536.0 / 27.0;
      A(21, 8) = 26624.0 / 27.0;
      A(21, 10) = 38912.0 / 9.0;
      A(21, 11) = 53248.0 / 9.0;
      A(21, 12) = 16384.0 / 27.0;
      A(21, 15) = -10240.0 / 9.0;
      A(21, 17) = -10240.0 / 3.0;
      A(21, 18) = -32768.0 / 27.0;
      A(21, 21) = 14336.0 / 27.0;
      A(21, 23) = 16384.0 / 27.0;
      A(21, 26) = -2048.0 / 27.0;
      A(26, 2) = -71680.0 / 27.0;
      A(26, 3) = -145408.0 / 27.0;
      A(26, 4) = -88064.0 / 27.0;
      A(26, 5) = -2048.0 / 9.0;
      A(26, 10) = 150016.0 / 27.0;
      A(26, 11) = 183296.0 / 27.0;
      A(26, 12) = 31232.0 / 27.0;
      A(26, 17) = -94208.0 / 27.0;
      A(26, 18) = -40960.0 / 27.0;
      A(26, 23) = 15872.0 / 27.0;
      A(25, 2) = -2048.0 / 9.0;
      A(25, 3) = -88064.0 / 27.0;
      A(25, 4) = -145408.0 / 27.0;
      A(25, 5) = -71680.0 / 27.0;
      A(25, 10) = 31232.0 / 27.0;
      A(25, 11) = 183296.0 / 27.0;
      A(25, 12) = 150016.0 / 27.0;
      A(25, 17) = -40960.0 / 27.0;
      A(25, 18) = -94208.0 / 27.0;
      A(25, 23) = 15872.0 / 27.0;
      A(30, 4) = -2048.0 / 9.0;
      A(30, 5) = -4096.0 / 9.0;
      A(30, 6) = -2048.0 / 9.0;
      A(30, 11) = 512.0 / 3.0;
      A(30, 12) = 7168.0 / 9.0;
      A(30, 13) = 5632.0 / 9.0;
      A(30, 17) = -256.0 / 9.0;
      A(30, 18) = -3584.0 / 9.0;
      A(30, 19) = -1792.0 / 3.0;

      //-------- 5
      A(30, 23) = 512.0 / 9.0;
      A(30, 24) = 2048.0 / 9.0;
      A(30, 28) = -256.0 / 9.0;
      A(29, 2) = -2048.0 / 9.0;
      A(29, 3) = -8192.0 / 9.0;
      A(29, 4) = -4096.0 / 3.0;
      A(29, 5) = -8192.0 / 9.0;
      A(29, 6) = -2048.0 / 9.0;
      A(29, 10) = 6656.0 / 9.0;
      A(29, 11) = 6656.0 / 3.0;
      A(29, 12) = 6656.0 / 3.0;
      A(29, 13) = 6656.0 / 9.0;
      A(29, 17) = -7936.0 / 9.0;
      A(29, 18) = -15872.0 / 9.0;
      A(29, 19) = -7936.0 / 9.0;
      A(29, 23) = 4096.0 / 9.0;
      A(29, 24) = 4096.0 / 9.0;
      A(29, 28) = -256.0 / 3.0;
      A(28, 1) = -2048.0 / 9.0;
      A(28, 2) = -8192.0 / 9.0;
      A(28, 3) = -4096.0 / 3.0;
      A(28, 4) = -8192.0 / 9.0;
      A(28, 5) = -2048.0 / 9.0;
      A(28, 9) = 6656.0 / 9.0;
      A(28, 10) = 6656.0 / 3.0;
      A(28, 11) = 6656.0 / 3.0;
      A(28, 12) = 6656.0 / 9.0;
      A(28, 16) = -7936.0 / 9.0;
      A(28, 17) = -15872.0 / 9.0;
      A(28, 18) = -7936.0 / 9.0;
      A(28, 22) = 4096.0 / 9.0;
      A(28, 23) = 4096.0 / 9.0;
      A(28, 27) = -256.0 / 3.0;
      A(27, 1) = -2048.0 / 9.0;
      A(27, 2) = -4096.0 / 9.0;
      A(27, 3) = -2048.0 / 9.0;
      A(27, 9) = 5632.0 / 9.0;
      A(27, 10) = 7168.0 / 9.0;
      A(27, 11) = 512.0 / 3.0;
      A(27, 16) = -1792.0 / 3.0;
      A(27, 17) = -3584.0 / 9.0;
      A(27, 18) = -256.0 / 9.0;
      A(27, 22) = 2048.0 / 9.0;
      A(27, 23) = 512.0 / 9.0;
      A(27, 27) = -256.0 / 9.0;
      A(32, 2) = 1024.0 * sqrt(2.0) / 9.0;
      A(32, 3) = 1024.0 * sqrt(2.0) / 9.0;
      A(32, 10) = -1792.0 * sqrt(2.0) / 9.0;
      A(32, 11) = -256.0 * sqrt(2.0) / 3.0;
      A(32, 17) = 896 * sqrt(2.0) / 9.0;
      A(32, 18) = 128.0 * sqrt(2.0) / 9.0;
      A(32, 23) = -128.0 * sqrt(2.0) / 9.0;
      A(31, 4) = 1024.0 * sqrt(2.0) / 9.0;
      A(31, 5) = 1024.0 * sqrt(2.0) / 9.0;
      A(31, 11) = -256.0 * sqrt(2.0) / 3.0;
      A(31, 12) = -1792.0 * sqrt(2.0) / 9.0;
      A(31, 17) = 128.0 * sqrt(2.0) / 9.0;
      A(31, 18) = 896.0 * sqrt(2.0) / 9.0;
      A(31, 23) = -128.0 * sqrt(2.0) / 9.0;
      A(34, 2) = 4096.0;
      A(34, 3) = 8192.0;
      A(34, 4) = 4096.0;
      A(34, 10) = -9216.0;
      A(34, 11) = -10240.0;
      A(34, 12) = -1024.0;
      A(34, 17) = 6144.0;
      A(34, 18) = 2048.0;
      A(34, 23) = -1024.0;
      A(33, 3) = 4096.0;
      A(33, 4) = 8192.0;
      A(33, 5) = 4096.0;
      A(33, 10) = -1024.0;
      A(33, 11) = -10240.0;
      A(33, 12) = -9216.0;
      A(33, 17) = 2048.0;
      A(33, 18) = 6144.0;
      A(33, 23) = -1024.0;
      A(35, 2) = -4096.0;
      A(35, 3) = -12288.0;
      A(35, 4) = -12288.0;
      A(35, 5) = -4096.0;
      A(35, 10) = 11264.0;
      A(35, 11) = 22528.0;
      A(35, 12) = 11264.0;
      A(35, 17) = -10240.0;
      A(35, 18) = -10240.0;
      A(35, 23) = 3072.0;
    }

    ///=========================================================================
    /// Bases of the C1-curved shape functions:
    /// it is a complete polynomial of degree 7
    ///=========================================================================
    void basis_curve(const Vector<double>& s, Shape& psi_curve) const
    {
      // Get the shape function and derivatives
      psi_curve[7] = s[0] * s[0] * s[0] * s[0] * s[0] * s[0] * s[0];
      psi_curve[6] = s[0] * s[0] * s[0] * s[0] * s[0] * s[0] * s[1];
      psi_curve[5] = s[0] * s[0] * s[0] * s[0] * s[0] * s[1] * s[1];
      psi_curve[4] = s[0] * s[0] * s[0] * s[0] * s[1] * s[1] * s[1];
      psi_curve[3] = s[0] * s[0] * s[0] * s[1] * s[1] * s[1] * s[1];
      psi_curve[2] = s[0] * s[0] * s[1] * s[1] * s[1] * s[1] * s[1];
      psi_curve[1] = s[0] * s[1] * s[1] * s[1] * s[1] * s[1] * s[1];
      psi_curve[0] = s[1] * s[1] * s[1] * s[1] * s[1] * s[1] * s[1];
      psi_curve[14] = s[0] * s[0] * s[0] * s[0] * s[0] * s[0];
      psi_curve[13] = s[0] * s[0] * s[0] * s[0] * s[0] * s[1];
      psi_curve[12] = s[0] * s[0] * s[0] * s[0] * s[1] * s[1];
      psi_curve[11] = s[0] * s[0] * s[0] * s[1] * s[1] * s[1];
      psi_curve[10] = s[0] * s[0] * s[1] * s[1] * s[1] * s[1];
      psi_curve[9] = s[0] * s[1] * s[1] * s[1] * s[1] * s[1];
      psi_curve[8] = s[1] * s[1] * s[1] * s[1] * s[1] * s[1];
      psi_curve[20] = s[0] * s[0] * s[0] * s[0] * s[0];
      psi_curve[19] = s[0] * s[0] * s[0] * s[0] * s[1];
      psi_curve[18] = s[0] * s[0] * s[0] * s[1] * s[1];
      psi_curve[17] = s[0] * s[0] * s[1] * s[1] * s[1];
      psi_curve[16] = s[0] * s[1] * s[1] * s[1] * s[1];
      psi_curve[15] = s[1] * s[1] * s[1] * s[1] * s[1];
      psi_curve[25] = s[0] * s[0] * s[0] * s[0];
      psi_curve[24] = s[0] * s[0] * s[0] * s[1];
      psi_curve[23] = s[0] * s[0] * s[1] * s[1];
      psi_curve[22] = s[0] * s[1] * s[1] * s[1];
      psi_curve[21] = s[1] * s[1] * s[1] * s[1];
      psi_curve[29] = s[0] * s[0] * s[0];
      psi_curve[28] = s[0] * s[0] * s[1];
      psi_curve[27] = s[0] * s[1] * s[1];
      psi_curve[26] = s[1] * s[1] * s[1];
      psi_curve[32] = s[0] * s[0];
      psi_curve[31] = s[0] * s[1];
      psi_curve[30] = s[1] * s[1];
      psi_curve[34] = s[0];
      psi_curve[33] = s[1];
      psi_curve[35] = 1.0;
    }

    ///=========================================================================
    /// Derivatives of bases of the C1-curved shape functions
    /// it is a complete polynomial of degree 7
    ///=========================================================================
    void dbasis_local_curve(const Vector<double>& s,
                            Shape& psi_curve,
                            DShape& dpsi_curve) const
    {
      basis_curve(s, psi_curve);

      // Get the shape function and derivatives
      dpsi_curve(7, 0) = 7.0 * s[0] * s[0] * s[0] * s[0] * s[0] * s[0];
      dpsi_curve(6, 0) = 6.0 * s[0] * s[0] * s[0] * s[0] * s[0] * s[1];
      dpsi_curve(5, 0) = 5.0 * s[0] * s[0] * s[0] * s[0] * s[1] * s[1];
      dpsi_curve(4, 0) = 4.0 * s[0] * s[0] * s[0] * s[1] * s[1] * s[1];
      dpsi_curve(3, 0) = 3.0 * s[0] * s[0] * s[1] * s[1] * s[1] * s[1];
      dpsi_curve(2, 0) = 2.0 * s[0] * s[1] * s[1] * s[1] * s[1] * s[1];
      dpsi_curve(1, 0) = 1.0 * s[1] * s[1] * s[1] * s[1] * s[1] * s[1];
      dpsi_curve(0, 0) = 0.0;
      dpsi_curve(14, 0) = 6.0 * s[0] * s[0] * s[0] * s[0] * s[0];
      dpsi_curve(13, 0) = 5.0 * s[0] * s[0] * s[0] * s[0] * s[1];
      dpsi_curve(12, 0) = 4.0 * s[0] * s[0] * s[0] * s[1] * s[1];
      dpsi_curve(11, 0) = 3.0 * s[0] * s[0] * s[1] * s[1] * s[1];
      dpsi_curve(10, 0) = 2.0 * s[0] * s[1] * s[1] * s[1] * s[1];
      dpsi_curve(9, 0) = 1.0 * s[1] * s[1] * s[1] * s[1] * s[1];
      dpsi_curve(8, 0) = 0.0;
      dpsi_curve(20, 0) = 5.0 * s[0] * s[0] * s[0] * s[0];
      dpsi_curve(19, 0) = 4.0 * s[0] * s[0] * s[0] * s[1];
      dpsi_curve(18, 0) = 3.0 * s[0] * s[0] * s[1] * s[1];
      dpsi_curve(17, 0) = 2.0 * s[0] * s[1] * s[1] * s[1];
      dpsi_curve(16, 0) = 1.0 * s[1] * s[1] * s[1] * s[1];
      dpsi_curve(15, 0) = 0.0;
      dpsi_curve(25, 0) = 4.0 * s[0] * s[0] * s[0];
      dpsi_curve(24, 0) = 3.0 * s[0] * s[0] * s[1];
      dpsi_curve(23, 0) = 2.0 * s[0] * s[1] * s[1];
      dpsi_curve(22, 0) = 1.0 * s[1] * s[1] * s[1];
      dpsi_curve(21, 0) = 0.0;
      dpsi_curve(29, 0) = 3.0 * s[0] * s[0];
      dpsi_curve(28, 0) = 2.0 * s[0] * s[1];
      dpsi_curve(27, 0) = 1.0 * s[1] * s[1];
      dpsi_curve(26, 0) = 0.0;
      dpsi_curve(32, 0) = 2.0 * s[0];
      dpsi_curve(31, 0) = 1.0 * s[1];
      dpsi_curve(30, 0) = 0.0;
      dpsi_curve(34, 0) = 1.0;
      dpsi_curve(33, 0) = 0.0;
      dpsi_curve(35, 0) = 0.0;

      dpsi_curve(7, 1) = 0.0;
      dpsi_curve(6, 1) = s[0] * s[0] * s[0] * s[0] * s[0] * s[0] * 1.0;
      dpsi_curve(5, 1) = s[0] * s[0] * s[0] * s[0] * s[0] * s[1] * 2.0;
      dpsi_curve(4, 1) = s[0] * s[0] * s[0] * s[0] * s[1] * s[1] * 3.0;
      dpsi_curve(3, 1) = s[0] * s[0] * s[0] * s[1] * s[1] * s[1] * 4.0;
      dpsi_curve(2, 1) = s[0] * s[0] * s[1] * s[1] * s[1] * s[1] * 5.0;
      dpsi_curve(1, 1) = s[0] * s[1] * s[1] * s[1] * s[1] * s[1] * 6.0;
      dpsi_curve(0, 1) = s[1] * s[1] * s[1] * s[1] * s[1] * s[1] * 7.0;
      dpsi_curve(14, 1) = 0.0;
      dpsi_curve(13, 1) = s[0] * s[0] * s[0] * s[0] * s[0] * 1.0;
      dpsi_curve(12, 1) = s[0] * s[0] * s[0] * s[0] * s[1] * 2.0;
      dpsi_curve(11, 1) = s[0] * s[0] * s[0] * s[1] * s[1] * 3.0;
      dpsi_curve(10, 1) = s[0] * s[0] * s[1] * s[1] * s[1] * 4.0;
      dpsi_curve(9, 1) = s[0] * s[1] * s[1] * s[1] * s[1] * 5.0;
      dpsi_curve(8, 1) = s[1] * s[1] * s[1] * s[1] * s[1] * 6.0;
      dpsi_curve(20, 1) = 0.0;
      dpsi_curve(19, 1) = s[0] * s[0] * s[0] * s[0] * 1.0;
      dpsi_curve(18, 1) = s[0] * s[0] * s[0] * s[1] * 2.0;
      dpsi_curve(17, 1) = s[0] * s[0] * s[1] * s[1] * 3.0;
      dpsi_curve(16, 1) = s[0] * s[1] * s[1] * s[1] * 4.0;
      dpsi_curve(15, 1) = s[1] * s[1] * s[1] * s[1] * 5.0;
      dpsi_curve(25, 1) = 0.0;
      dpsi_curve(24, 1) = s[0] * s[0] * s[0] * 1.0;
      dpsi_curve(23, 1) = s[0] * s[0] * s[1] * 2.0;
      dpsi_curve(22, 1) = s[0] * s[1] * s[1] * 3.0;
      dpsi_curve(21, 1) = s[1] * s[1] * s[1] * 4.0;
      dpsi_curve(29, 1) = 0.0;
      dpsi_curve(28, 1) = s[0] * s[0] * 1.0;
      dpsi_curve(27, 1) = s[0] * s[1] * 2.0;
      dpsi_curve(26, 1) = s[1] * s[1] * 3.0;
      dpsi_curve(32, 1) = 0.0;
      dpsi_curve(31, 1) = s[0] * 1.0;
      dpsi_curve(30, 1) = s[1] * 2.0;
      dpsi_curve(34, 1) = 0.0;
      dpsi_curve(33, 1) = 1.0;
      dpsi_curve(35, 1) = 0.0;
    }

    ///=========================================================================
    /// The second derivatived of bases of the C1-curved shape functions
    /// it is a complete polynomial of degree 7
    ///=========================================================================
    void d2basis_local_curve(const Vector<double>& s,
                             Shape& psi_curve,
                             DShape& dpsi_curve,
                             DShape& d2psi_curve) const
    {
      dbasis_local_curve(s, psi_curve, dpsi_curve);
      // Get the shape function and derivatives
      d2psi_curve(7, 0) = 7.0 * 6.0 * s[0] * s[0] * s[0] * s[0] * s[0];
      d2psi_curve(6, 0) = 6.0 * 5.0 * s[0] * s[0] * s[0] * s[0] * s[1];
      d2psi_curve(5, 0) = 5.0 * 4.0 * s[0] * s[0] * s[0] * s[1] * s[1];
      d2psi_curve(4, 0) = 4.0 * 3.0 * s[0] * s[0] * s[1] * s[1] * s[1];
      d2psi_curve(3, 0) = 3.0 * 2.0 * s[0] * s[1] * s[1] * s[1] * s[1];
      d2psi_curve(2, 0) = 2.0 * 1.0 * s[1] * s[1] * s[1] * s[1] * s[1];
      d2psi_curve(1, 0) = 0.0;
      d2psi_curve(0, 0) = 0.0;
      d2psi_curve(14, 0) = 6.0 * 5.0 * s[0] * s[0] * s[0] * s[0];
      d2psi_curve(13, 0) = 5.0 * 4.0 * s[0] * s[0] * s[0] * s[1];
      d2psi_curve(12, 0) = 4.0 * 3.0 * s[0] * s[0] * s[1] * s[1];
      d2psi_curve(11, 0) = 3.0 * 2.0 * s[0] * s[1] * s[1] * s[1];
      d2psi_curve(10, 0) = 2.0 * 1.0 * s[1] * s[1] * s[1] * s[1];
      d2psi_curve(9, 0) = 0.0;
      d2psi_curve(8, 0) = 0.0;
      d2psi_curve(20, 0) = 5.0 * 4.0 * s[0] * s[0] * s[0];
      d2psi_curve(19, 0) = 4.0 * 3.0 * s[0] * s[0] * s[1];
      d2psi_curve(18, 0) = 3.0 * 2.0 * s[0] * s[1] * s[1];
      d2psi_curve(17, 0) = 2.0 * 1.0 * s[1] * s[1] * s[1];
      d2psi_curve(16, 0) = 0.0;
      d2psi_curve(15, 0) = 0.0;
      d2psi_curve(25, 0) = 4.0 * 3.0 * s[0] * s[0];
      d2psi_curve(24, 0) = 3.0 * 2.0 * s[0] * s[1];
      d2psi_curve(23, 0) = 2.0 * 1.0 * s[1] * s[1];
      d2psi_curve(22, 0) = 0.0;
      d2psi_curve(21, 0) = 0.0;
      d2psi_curve(29, 0) = 3.0 * 2.0 * s[0];
      d2psi_curve(28, 0) = 2.0 * 1.0 * s[1];
      d2psi_curve(27, 0) = 0.0;
      d2psi_curve(26, 0) = 0.0;
      d2psi_curve(32, 0) = 2.0 * 1.0;
      d2psi_curve(31, 0) = 0.0;
      d2psi_curve(30, 0) = 0.0;
      d2psi_curve(34, 0) = 0.0;
      d2psi_curve(33, 0) = 0.0;
      d2psi_curve(35, 0) = 0.0;

      d2psi_curve(7, 1) = 0.0;
      d2psi_curve(6, 1) = 0.0;
      d2psi_curve(5, 1) = s[0] * s[0] * s[0] * s[0] * s[0] * 1.0 * 2.0;
      d2psi_curve(4, 1) = s[0] * s[0] * s[0] * s[0] * s[1] * 2.0 * 3.0;
      d2psi_curve(3, 1) = s[0] * s[0] * s[0] * s[1] * s[1] * 3.0 * 4.0;
      d2psi_curve(2, 1) = s[0] * s[0] * s[1] * s[1] * s[1] * 4.0 * 5.0;
      d2psi_curve(1, 1) = s[0] * s[1] * s[1] * s[1] * s[1] * 5.0 * 6.0;
      d2psi_curve(0, 1) = s[1] * s[1] * s[1] * s[1] * s[1] * 6.0 * 7.0;
      d2psi_curve(14, 1) = 0.0;
      d2psi_curve(13, 1) = 0.0;
      d2psi_curve(12, 1) = s[0] * s[0] * s[0] * s[0] * 1.0 * 2.0;
      d2psi_curve(11, 1) = s[0] * s[0] * s[0] * s[1] * 2.0 * 3.0;
      d2psi_curve(10, 1) = s[0] * s[0] * s[1] * s[1] * 3.0 * 4.0;
      d2psi_curve(9, 1) = s[0] * s[1] * s[1] * s[1] * 4.0 * 5.0;
      d2psi_curve(8, 1) = s[1] * s[1] * s[1] * s[1] * 5.0 * 6.0;
      d2psi_curve(20, 1) = 0.0;
      d2psi_curve(19, 1) = 0.0;
      d2psi_curve(18, 1) = s[0] * s[0] * s[0] * 1.0 * 2.0;
      d2psi_curve(17, 1) = s[0] * s[0] * s[1] * 2.0 * 3.0;
      d2psi_curve(16, 1) = s[0] * s[1] * s[1] * 3.0 * 4.0;
      d2psi_curve(15, 1) = s[1] * s[1] * s[1] * 4.0 * 5.0;
      d2psi_curve(25, 1) = 0.0;
      d2psi_curve(24, 1) = 0.0;
      d2psi_curve(23, 1) = s[0] * s[0] * 1.0 * 2.0;
      d2psi_curve(22, 1) = s[0] * s[1] * 2.0 * 3.0;
      d2psi_curve(21, 1) = s[1] * s[1] * 3.0 * 4.0;
      d2psi_curve(29, 1) = 0.0;
      d2psi_curve(28, 1) = 0.0;
      d2psi_curve(27, 1) = s[0] * 1.0 * 2.0;
      d2psi_curve(26, 1) = s[1] * 2.0 * 3.0;
      d2psi_curve(32, 1) = 0.0;
      d2psi_curve(31, 1) = 0.0;
      d2psi_curve(30, 1) = 1.0 * 2.0;
      d2psi_curve(34, 1) = 0.0;
      d2psi_curve(33, 1) = 0.0;
      d2psi_curve(35, 1) = 0.0;

      d2psi_curve(7, 2) = 0.0;
      d2psi_curve(6, 2) = 6.0 * s[0] * s[0] * s[0] * s[0] * s[0] * 1.0;
      d2psi_curve(5, 2) = 5.0 * s[0] * s[0] * s[0] * s[0] * s[1] * 2.0;
      d2psi_curve(4, 2) = 4.0 * s[0] * s[0] * s[0] * s[1] * s[1] * 3.0;
      d2psi_curve(3, 2) = 3.0 * s[0] * s[0] * s[1] * s[1] * s[1] * 4.0;
      d2psi_curve(2, 2) = 2.0 * s[0] * s[1] * s[1] * s[1] * s[1] * 5.0;
      d2psi_curve(1, 2) = s[1] * s[1] * s[1] * s[1] * s[1] * 6.0;
      d2psi_curve(0, 2) = 0.0;
      d2psi_curve(14, 2) = 0.0;
      d2psi_curve(13, 2) = 5.0 * s[0] * s[0] * s[0] * s[0] * 1.0;
      d2psi_curve(12, 2) = 4.0 * s[0] * s[0] * s[0] * s[1] * 2.0;
      d2psi_curve(11, 2) = 3.0 * s[0] * s[0] * s[1] * s[1] * 3.0;
      d2psi_curve(10, 2) = 2.0 * s[0] * s[1] * s[1] * s[1] * 4.0;
      d2psi_curve(9, 2) = s[1] * s[1] * s[1] * s[1] * 5.0;
      d2psi_curve(8, 2) = 0.0;
      d2psi_curve(20, 2) = 0.0;
      d2psi_curve(19, 2) = 4.0 * s[0] * s[0] * s[0] * 1.0;
      d2psi_curve(18, 2) = 3.0 * s[0] * s[0] * s[1] * 2.0;
      d2psi_curve(17, 2) = 2.0 * s[0] * s[1] * s[1] * 3.0;
      d2psi_curve(16, 2) = s[1] * s[1] * s[1] * 4.0;
      d2psi_curve(15, 2) = 0.0;
      d2psi_curve(25, 2) = 0.0;
      d2psi_curve(24, 2) = 3.0 * s[0] * s[0] * 1.0;
      d2psi_curve(23, 2) = 2.0 * s[0] * s[1] * 2.0;
      d2psi_curve(22, 2) = s[1] * s[1] * 3.0;
      d2psi_curve(21, 2) = 0.0;
      d2psi_curve(29, 2) = 0.0;
      d2psi_curve(28, 2) = 2.0 * s[0] * 1.0;
      d2psi_curve(27, 2) = s[1] * 2.0;
      d2psi_curve(26, 2) = 0.0;
      d2psi_curve(32, 2) = 0.0;
      d2psi_curve(31, 2) = 1.0;
      d2psi_curve(30, 2) = 0.0;
      d2psi_curve(34, 2) = 0.0;
      d2psi_curve(33, 2) = 0.0;
      d2psi_curve(35, 2) = 0.0;
    }
  };

  //========================================================================
  /// Empty base class for the subparametric Bellelements (created so that
  /// we can use dynamic_cast<>() to figure out if a an element
  /// is a C1Curvedelement). This element is sub-parametric which means
  /// the geometry will be parametrised by the linear Lagrange functions,
  /// while unknowns will be parametrised by two kinds of shape functions
  /// basis : denotes C1-interpolations for c1-variables
  /// basis_c0 : denotes C0-interpolations for c0-variables
  //========================================================================

  template<unsigned NNODE_1D>
  class BellElementBase : public virtual FiniteElement
  {
  public:
    ///\short  Constructor: Call constructors for FiniteElement
    BellElementBase() : FiniteElement() {}


    virtual void basis(const Vector<double>& s, Shape& psi) const {}


    virtual void dbasis_local(const Vector<double>& s,
                              Shape& psi,
                              DShape& dpsids) const
    {
    }

    virtual void d2basis_local(const Vector<double>& s,
                               Shape& psi,
                               DShape& dpsids,
                               DShape& d2psids) const
    {
    }

    virtual void basis_c0(const Vector<double>& s, Shape& psi) const {}


    virtual void dbasis_c0_local(const Vector<double>& s,
                                 Shape& psi,
                                 DShape& dpsids) const
    {
    }

    virtual void d2basis_c0_local(const Vector<double>& s,
                                  Shape& psi,
                                  DShape& dpsids,
                                  DShape& d2psids) const
    {
    }

    virtual void test(const Vector<double>& s, Shape& phi) const {}


    virtual void dtest_local(const Vector<double>& s,
                             Shape& phi,
                             DShape& dphids) const
    {
    }

    virtual void d2test_local(const Vector<double>& s,
                              Shape& phi,
                              DShape& dphids,
                              DShape& d2phids) const
    {
    }


    //=========================================================================
    /// \short Return the C1-basis function stored at the ipt-th integration
    /// point.
    //=========================================================================
    void basis_at_knot(const unsigned& ipt, Shape& psi) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function
      basis(s, psi);
    }

    //=========================================================================
    /// \short Return the C1-basis function and its derivatives w.r.t. the
    /// global coordinates at the ipt-th integration point.
    //=========================================================================
    void dbasis_local_at_knot(const unsigned& ipt,
                              Shape& psi,
                              DShape& dpsids) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }

      // Get the shape function and derivatives
      dbasis_local(s, psi, dpsids);
    }

    //=========================================================================
    /// Calculate the C1-basis function and its first and second derivatives
    /// w.r.t. global coordinates at the ipt-th integration point.
    /// \n\n Numbering:
    //=========================================================================
    void d2basis_local_at_knot(const unsigned& ipt,
                               Shape& psi,
                               DShape& dpsids,
                               DShape& d2psids) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }

      // Get the shape function and first and second derivatives
      d2basis_local(s, psi, dpsids, d2psids);
    }

    //=========================================================================
    /// \short Return the C0-basis function stored at the ipt-th integration
    /// point.
    //=========================================================================
    void basis_c0_at_knot(const unsigned& ipt, Shape& psi) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function
      basis_c0(s, psi);
    }

    //=========================================================================
    /// \short Return the C0-basis function and its derivatives w.r.t. the local
    /// coordinates at the ipt-th integration point.
    //=========================================================================
    void dbasis_c0_local_at_knot(const unsigned& ipt,
                                 Shape& psi,
                                 DShape& dpsids) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function and derivatives

      dbasis_c0_local(s, psi, dpsids);
    }

    //=========================================================================
    /// Calculate the C0-basis function and its first and second derivatives
    /// w.r.t. local coordinates at the ipt-th integration point.
    /// \n\n Numbering:
    //=========================================================================
    void d2basis_c0_local_at_knot(const unsigned& ipt,
                                  Shape& psi,
                                  DShape& dpsids,
                                  DShape& d2psids) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function and first and second derivatives
      d2basis_c0_local(s, psi, dpsids, d2psids);
    }

    //=========================================================================
    /// \short Return the test function stored at the ipt-th integration
    /// point.
    //=========================================================================
    void test_at_knot(const unsigned& ipt, Shape& phi) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function
      test(s, phi);
    }

    //=========================================================================
    /// \short Return the test function and its derivatives w.r.t. the local
    /// coordinates at the ipt-th integration point.
    //=========================================================================
    void dtest_local_at_knot(const unsigned& ipt,
                             Shape& phi,
                             DShape& dphids) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function and derivatives
      dtest_local(s, phi, dphids);
    }

    //=========================================================================
    /// Calculate the test function and its first and second derivatives
    /// w.r.t. local coordinates at the ipt-th integration point.
    /// \n\n Numbering:
    //=========================================================================
    void d2test_local_at_knot(const unsigned& ipt,
                              Shape& phi,
                              DShape& dphids,
                              DShape& d2phids) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function and first and second derivatives
      d2test_local(s, phi, dphids, d2phids);
    }

    //=========================================================================
    /// \short Compute the curved-element shape functions and also
    /// first derivatives w.r.t. local coordinates at local coordinate s;
    /// Returns Jacobian of mapping from global to local coordinates.
    /// Most general form of the function, but may be over-loaded, if desired
    //=========================================================================
    double dbasis_c0_eulerian(const Vector<double>& s,
                              Shape& psi,
                              DShape& dpsi) const
    {
      // Find the element dimension
      const unsigned el_dim = dim();
      // Get the values of the shape functions and their local derivatives
      // Temporarily stored in dpsi
      dbasis_c0_local(s, psi, dpsi);

      // assign shape functions for geometry
      unsigned n_node = 3;
      Shape psi_x(n_node);
      DShape dpsi_x(n_node, 2);
      DShape d2psi_x(n_node, 3);

      d2shape_local(s, psi_x, dpsi_x, d2psi_x);

      // Allocate memory for the jacobian and inverse jacobian
      DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);

      // Calculate the jacobian and inverse jacobian
      const double det =
        this->local_to_eulerian_mapping2(dpsi_x, jacobian, inverse_jacobian);

      // Now set the values of the derivatives to be dpsidx
      transform_derivatives(inverse_jacobian, dpsi);

      // Return the determinant of the jacobian
      return det;
    }

    //===========================================================================
    /// \short Compute the c0-basis functions and also first
    /// and second derivatives w.r.t. local coordinates at ipt-th integration
    /// point
    //===========================================================================
    double d2basis_c0_eulerian(const Vector<double>& s,
                               Shape& psi,
                               DShape& dpsi,
                               DShape& d2psi) const
    {
      // Find the element dimension
      const unsigned el_dim = dim();
      // Find the number of second derivatives required
      const unsigned n_deriv = N2deriv[el_dim];
      // Get the values of the shape function and local derivatives for unknowns
      d2basis_c0_local(s, psi, dpsi, d2psi);

      // assign shape functions for geometry
      unsigned n_node = 3;
      Shape psi_x(n_node);
      DShape dpsi_x(n_node, 2);
      DShape d2psi_x(n_node, 3);

      d2shape_local(s, psi_x, dpsi_x, d2psi_x);

      // Allocate memory for the jacobian and inverse jacobian
      DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);

      // Calculate the jacobian and inverse jacobian
      const double det =
        local_to_eulerian_mapping2(dpsi_x, jacobian, inverse_jacobian);

      // Allocate memory for the jacobian of second derivatives
      DenseMatrix<double> jacobian2(n_deriv, el_dim, 0.0);

      // Assemble the jacobian of second derivatives
      myassemble_local_to_eulerian_jacobian2(d2psi_x, jacobian2);

      // Now set the value of the derivatives
      transform_second_derivatives(
        jacobian, inverse_jacobian, jacobian2, dpsi, d2psi);

      // Return the determinant of the jacobian
      return det;
    }

    //=========================================================================
    /// \short Compute the c1-basis functions and also
    /// first derivatives w.r.t. global coordinates at local coordinate s;
    /// Returns Jacobian of mapping from global to local coordinates.
    /// Most general form of the function, but may be over-loaded, if desired
    //=========================================================================
    double dbasis_eulerian(const Vector<double>& s,
                           Shape& psi,
                           DShape& dpsi) const
    {
      // Find the element dimension
      const unsigned el_dim = dim();
      // Get the values of the shape functions and their local derivatives
      // Temporarily stored in dpsi
      dbasis_local(s, psi, dpsi);

      // assign shape functions for geometry
      unsigned n_node = 3;
      Shape psi_x(n_node);
      DShape dpsi_x(n_node, 2);
      DShape d2psi_x(n_node, 3);

      d2shape_local(s, psi_x, dpsi_x, d2psi_x);

      // Allocate memory for the jacobian and inverse jacobian
      DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);

      // Calculate the jacobian and inverse jacobian
      const double det =
        this->local_to_eulerian_mapping2(dpsi_x, jacobian, inverse_jacobian);

      // Return the determinant of the jacobian
      return det;
    }

    //===========================================================================
    /// \short Compute the c1-basis functions and also first
    /// and second derivatives w.r.t. global coordinates at ipt-th integration
    /// point
    //===========================================================================
    double d2basis_eulerian(const Vector<double>& s,
                            Shape& psi,
                            DShape& dpsi,
                            DShape& d2psi) const
    {
      // Find the element dimension
      const unsigned el_dim = dim();
      // Find the number of second derivatives required
      // const unsigned n_deriv = N2deriv[el_dim];
      // Get the values of the shape function and local derivatives for unknowns
      d2basis_local(s, psi, dpsi, d2psi);

      // assign shape functions for geometry
      unsigned n_node = 3;
      Shape psi_x(n_node);
      DShape dpsi_x(n_node, 2);
      DShape d2psi_x(n_node, 3);

      d2shape_local(s, psi_x, dpsi_x, d2psi_x);

      // Allocate memory for the jacobian and inverse jacobian
      DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);

      // Calculate the jacobian and inverse jacobian
      const double det =
        local_to_eulerian_mapping2(dpsi_x, jacobian, inverse_jacobian);

      // Return the determinant of the jacobian
      return det;
    }

    //=========================================================================
    /// Calculate the c0-shape function and its first-order derivatives
    /// w.r.t. local coordinates at the ipt-th integration point.
    /// \n\n Numbering:
    //=========================================================================

    double dshape_and_dtest_eulerian_at_knot(const unsigned& ipt,
                                             Shape& psi,
                                             DShape& dpsi,
                                             Shape& test,
                                             DShape& dtest) const
    {
      // Find the element dimension
      const unsigned el_dim = dim();

      // Get the values of the c0-shape function for c0-unknowns
      // and local derivatives
      // Temporarily store it in dpsi
      dbasis_c0_local_at_knot(ipt, psi, dpsi);

      // assign shape functions for geometry -> linear Lagrange
      unsigned n_node = 3;
      Shape psi_x(n_node);
      DShape dpsi_x(n_node, 2);
      dshape_local_at_knot(ipt, psi_x, dpsi_x);

      // assign test function
      dtest_local_at_knot(ipt, test, dtest);

      // Allocate memory for the inverse jacobian
      DenseMatrix<double> inverse_jacobian(el_dim);
      // Now calculate the inverse jacobian
      const double det = local_to_eulerian_mapping2(dpsi_x, inverse_jacobian);

      // Now set the values of the derivatives to dpsidx
      transform_derivatives(inverse_jacobian, dpsi);

      // Return the determinant of the jacobian
      return det;
    }

    //===========================================================================
    /// \short Compute the c1-shape functions and also first and second
    /// derivatives w.r.t. global coordinates at ipt-th integration points
    /// Returns Jacobian of mapping from global to local coordinates.
    //===========================================================================
    double d2shape_and_d2test_eulerian_at_knot(const unsigned& ipt,
                                               Shape& psi,
                                               DShape& dpsi,
                                               DShape& d2psi,
                                               Shape& test,
                                               DShape& dtest,
                                               DShape& d2test) const
    {
      // Find the element dimension
      const unsigned el_dim = dim();

      // Get the values of the shape function and local derivatives for unknowns
      d2basis_local_at_knot(ipt, psi, dpsi, d2psi);

      // assign shape functions for geometry
      unsigned n_node = nnode();
      Shape psi_x(n_node);
      DShape dpsi_x(n_node, 2);
      DShape d2psi_x(n_node, 3);
      dshape_local_at_knot(ipt, psi_x, dpsi_x);

      // assign for test function
      d2test_local_at_knot(ipt, test, dtest, d2test);

      // Allocate memory for the jacobian and inverse jacobian
      DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);

      // Calculate the jacobian and inverse jacobian
      const double det =
        local_to_eulerian_mapping2(dpsi_x, jacobian, inverse_jacobian);

      // Return the determinant of the mapping
      return det;
    }

    //===========================================================================
    /// \short Calculate the mapping from local to Eulerian coordinates,
    /// given the derivatives of the shape functions w.r.t. local coordinates,
    /// Return only the determinant of the jacobian and the inverse of the
    /// mapping (ds/dx).
    //===========================================================================
    double local_to_eulerian_mapping2(
      const DShape& dpsids, DenseMatrix<double>& inverse_jacobian) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Assign memory for the jacobian
      DenseMatrix<double> jacobian(el_dim);
      // Calculate the jacobian and inverse
      return local_to_eulerian_mapping2(dpsids, jacobian, inverse_jacobian);
    }

    ///////////////////////////////////////////////////////////////
    virtual double local_to_eulerian_mapping2(
      const DShape& dpsids,
      DenseMatrix<double>& jacobian,
      DenseMatrix<double>& inverse_jacobian) const
    {
      // Assemble the jacobian
      // Locally cache the elemental dimension
      const unsigned el_dim = dim();
      // The number of shape functions must be equal to the number
      // of nodes (by definition)
      const unsigned n_shape = 3;
      // The number of shape function types must be equal to the number
      // of nodal position types (by definition)
      const unsigned n_shape_type = 1;

      // Loop over the rows of the jacobian
      for (unsigned i = 0; i < el_dim; i++)
      {
        // Loop over the columns of the jacobian
        for (unsigned j = 0; j < el_dim; j++)
        {
          // Zero the entry
          jacobian(i, j) = 0.0;
          // Loop over the shape functions
          for (unsigned l = 0; l < n_shape; l++)
          {
            for (unsigned k = 0; k < n_shape_type; k++)
            {
              // Jacobian is dx_j/ds_i, which is represented by the sum
              // over the dpsi/ds_i of the nodal points X j
              // Call the Non-hanging version of positions
              // This is overloaded in refineable elements
              jacobian(i, j) +=
                raw_nodal_position_gen(l, k, j) * dpsids(l, k, i);
            }
          }
        }
      }

      // Invert the jacobian (use the template-free interface)
      return invert_jacobian_mapping(jacobian, inverse_jacobian);
    }

    //========================================================================
    /// \short Calculate the Jacobian of the mapping between local and global
    /// coordinates at the position s
    //========================================================================
    double J_eulerian1(const Vector<double>& s) const
    {
      // Find the number of nodes and position types
      const unsigned n_node = 3;
      const unsigned n_position_type = 1;
      // Find the dimension of the node and element
      const unsigned n_dim_node = nodal_dimension();
      const unsigned n_dim_element = dim();


      // Set up dummy memory for the shape functions
      Shape psi(n_node, n_position_type);
      DShape dpsids(n_node, n_position_type, n_dim_element);
      // Get the shape functions and local derivatives
      this->dshape_local(s, psi, dpsids);

      // Right calculate the base vectors
      DenseMatrix<double> interpolated_G(n_dim_element, n_dim_node);

      // Loop over the dimensions and compute the entries of the
      // base vector matrix
      for (unsigned i = 0; i < n_dim_element; i++)
      {
        for (unsigned j = 0; j < n_dim_node; j++)
        {
          // Initialise the j-th component of the i-th base vector to zero
          interpolated_G(i, j) = 0.0;
          for (unsigned l = 0; l < n_node; l++)
          {
            for (unsigned k = 0; k < n_position_type; k++)
            {
              interpolated_G(i, j) +=
                raw_nodal_position_gen(l, k, j) * dpsids(l, k, i);
            }
          }
        }
      }

      // Calculate the metric tensor of the element
      DenseMatrix<double> G(n_dim_element);
      for (unsigned i = 0; i < n_dim_element; i++)
      {
        for (unsigned j = 0; j < n_dim_element; j++)
        {
          // Initialise to zero
          G(i, j) = 0.0;
          for (unsigned k = 0; k < n_dim_node; k++)
          {
            G(i, j) += interpolated_G(i, k) * interpolated_G(j, k);
          }
        }
      }

      // Calculate the determinant of the metric tensor
      double det = 0.0;
      switch (n_dim_element)
      {
        case 0:
          throw OomphLibError(
            "Cannot calculate J_eulerian() for point element\n",
            "FiniteElement::J_eulerian()",
            OOMPH_EXCEPTION_LOCATION);
          break;
        case 1:
          det = G(0, 0);
          break;
        case 2:
          det = G(0, 0) * G(1, 1) - G(0, 1) * G(1, 0);
          break;
        case 3:
          det = G(0, 0) * G(1, 1) * G(2, 2) + G(0, 1) * G(1, 2) * G(2, 0) +
                G(0, 2) * G(1, 0) * G(2, 1) - G(0, 0) * G(1, 2) * G(2, 1) -
                G(0, 1) * G(1, 0) * G(2, 2) - G(0, 2) * G(1, 1) * G(2, 0);
          break;
        default:
          oomph_info << "More than 3 dimensions in J_eulerian()" << std::endl;
          break;
      }

#ifdef PARANOID
      check_jacobian(det);
#endif

      // Return the Jacobian (square-root of the determinant of the metric
      // tensor)
      return sqrt(det);
    }

    //=========================================================================
    /// Internal function that is used to assemble the jacobian of second
    /// derivatives of the the mapping from local coordinates (s) to the
    /// eulerian coordinates (x), given the second derivatives of the
    /// shape functions.
    //=========================================================================
    void myassemble_local_to_eulerian_jacobian2(
      const DShape& d2psids, DenseMatrix<double>& jacobian2) const
    {
      // Find the the dimension of the element
      const unsigned el_dim = dim();
      // Find the number of shape functions and shape functions types
      // Must be equal to the number of nodes and their position types
      // by the definition of the shape function.
      const unsigned n_shape = 3;
      unsigned n_shape_type = 1;
      // Find the number of second derivatives
      const unsigned n_row = N2deriv[el_dim];
      // Assemble the "jacobian" (d^2 x_j/ds_i^2) for second derivatives of
      // shape functions
      // Loop over the rows (number of second derivatives)
      for (unsigned i = 0; i < n_row; i++)
      {
        // Loop over the columns (element dimension
        for (unsigned j = 0; j < el_dim; j++)
        {
          // Zero the entry
          jacobian2(i, j) = 0.0;
          // Loop over the shape functions
          for (unsigned l = 0; l < n_shape; l++)
          {
            // Loop over the shape function types
            for (unsigned k = 0; k < n_shape_type; k++)
            {
              // Add the terms to the jacobian entry
              // Call the Non-hanging version of positions
              // This is overloaded in refineable elements
              jacobian2(i, j) +=
                raw_nodal_position_gen(l, k, j) * d2psids(l, k, i);
            }
          }
        }
      }
    }

    //=======================================================================
    /// Return FE interpolated position x[] at local coordinate s as Vector
    // (using linear Lagrange interpolation)
    //=======================================================================
    void my_interpolated_x(const Vector<double>& s, Vector<double>& x) const
    {
      // Find the number of nodes
      const unsigned n_node = 3;
      // Find the number of positional types
      const unsigned n_position_type = 1;

      // Find the dimension stored in the node
      const unsigned nodal_dim = nodal_dimension();

      // Assign storage for the local shape function
      Shape psi(n_node);
      // Find the values of shape function
      shape(s, psi);

      // Loop over the dimensions
      for (unsigned i = 0; i < nodal_dim; i++)
      {
        // Initilialise value of x[i] to zero
        x[i] = 0.0;
        // Loop over the local nodes
        for (unsigned l = 0; l < n_node; l++)
        {
          for (unsigned k = 0; k < n_position_type; k++)
          {
            x[i] += nodal_position_gen(l, k, i) * psi[l];
          }
        }
      }
    }
  };

  /////////////////////////////////////////////////////////////////////////////
  /// General BellElement class  ///
  /// Empty, just establishes the template parameters
  /////////////////////////////////////////////////////////////////////
  template<unsigned DIM, unsigned NNODE_1D>
  class BellElement : public virtual BellElementBase<NNODE_1D>,
                      public virtual TElement<DIM, NNODE_1D>,
                      public virtual BellElementShape<DIM>,
                      public virtual LinearTElement<DIM>
  {
  public:
    ///\short  Constructor: Call constructors for BellElement
    BellElement()
      : BellElementBase<NNODE_1D>(),
        TElement<DIM, NNODE_1D>(),
        BellElementShape<DIM>(),
        LinearTElement<DIM>()
    {
      // Set the number of types required to interpolate the coordinate
      this->set_nnodal_position_type(6);
      TGauss<2, 4>* new_integral_pt = new TGauss<2, 4>;
      this->set_integration_scheme(new_integral_pt);
    }

    /// Broken copy constructor
    BellElement(const BellElement&)
    {
      BrokenCopy::broken_copy("BellElement");
    }

    /// Broken assignment operator
    void operator=(const BellElement&)
    {
      BrokenCopy::broken_assign("BellElement");
    }

    /// Calculate the geometric shape functions at local coordinate s
    inline void shape(const Vector<double>& s, Shape& psi) const
    {
      LinearTElement<2>::Lshape(s, psi);
    }

    /// \short Compute the geometric shape functions and
    /// derivatives w.r.t. local coordinates at local coordinate s
    inline void dshape_local(const Vector<double>& s,
                             Shape& psi,
                             DShape& dpsids) const
    {
      LinearTElement<2>::dLshape_local(s, psi, dpsids);
    }

    /// \short Computer the geometric shape functions, derivatives and
    /// second derivatives w.r.t local coordinates at local coordinate s \n
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
    inline void d2shape_local(const Vector<double>& s,
                              Shape& psi,
                              DShape& dpsids,
                              DShape& d2psids) const
    {
      LinearTElement<2>::d2Lshape_local(s, psi, dpsids, d2psids);
    }

    /// Calculate the c1-basis functions at local coordinate s
    inline void basis(const Vector<double>& s, Shape& psi) const
    {
      /// Number of nodes along each element edge
      unsigned n_node = 3;

      DenseMatrix<double> node_position(n_node, DIM);
      for (unsigned l = 0; l < n_node; l++)
      {
        for (unsigned k = 0; k < 1; k++)
        {
          for (unsigned j = 0; j < DIM; j++)
          {
            node_position(l, j) = this->raw_nodal_position_gen(l, k, j);
          }
        }
      }
      BellElementShape<2>::Bshape(s, psi, node_position);
    }

    /// \short Compute the c1-basis functions and
    /// derivatives w.r.t. global coordinates at local coordinate s
    inline void dbasis_local(const Vector<double>& s,
                             Shape& psi,
                             DShape& dpsids) const
    {
      /// Number of nodes along each element edge
      unsigned n_node = 3;

      DenseMatrix<double> node_position(3, DIM);

      for (unsigned l = 0; l < n_node; l++)
      {
        for (unsigned k = 0; k < 1; k++)
        {
          for (unsigned j = 0; j < DIM; j++)
          {
            node_position(l, j) = this->raw_nodal_position_gen(l, k, j);
          }
        }
      }
      BellElementShape<2>::dBshape_local(s, psi, dpsids, node_position);
    }

    /// \short Compute the c1-basis functions and
    /// derivatives w.r.t. global coordinates at local coordinate s
    inline void d2basis_local(const Vector<double>& s,
                              Shape& psi,
                              DShape& dpsids,
                              DShape& d2psids) const
    {
      /// Number of nodes along each element edge
      unsigned n_node = 3;
      DenseMatrix<double> node_position(3, DIM);

      for (unsigned l = 0; l < n_node; l++)
      {
        for (unsigned k = 0; k < 1; k++)
        {
          for (unsigned j = 0; j < DIM; j++)
          {
            node_position(l, j) = this->raw_nodal_position_gen(l, k, j);
          }
        }
      }
      BellElementShape<2>::d2Bshape_local(
        s, psi, dpsids, d2psids, node_position);
    }

    /// Calculate the c0-basis functions at local coordinate s
    inline void basis_c0(const Vector<double>& s, Shape& psi) const
    {
      TElementShape<2, NNODE_1D>::shape(s, psi);
    }

    /// \short Compute the c0-basis functions and
    /// derivatives w.r.t. local coordinates at local coordinate s
    inline void dbasis_c0_local(const Vector<double>& s,
                                Shape& psi,
                                DShape& dpsids) const
    {
      TElementShape<2, NNODE_1D>::dshape_local(s, psi, dpsids);
    }

    /// \short Computer the c0-basis functions, derivatives and
    /// second derivatives w.r.t local coordinates at local coordinate s \n
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
    inline void d2basis_c0_local(const Vector<double>& s,
                                 Shape& psi,
                                 DShape& dpsids,
                                 DShape& d2psids) const
    {
      TElementShape<2, NNODE_1D>::d2shape_local(s, psi, dpsids, d2psids);
    }

    /// Calculate the test functions at local coordinate s
    inline void test(const Vector<double>& s, Shape& psi) const
    {
      TElementShape<2, NNODE_1D>::shape(s, psi);
    }

    /// \short Compute the  test functions and
    /// derivatives w.r.t. local coordinates at local coordinate s
    inline void dtest_local(const Vector<double>& s,
                            Shape& psi,
                            DShape& dpsids) const
    {
      TElementShape<2, NNODE_1D>::dshape_local(s, psi, dpsids);
    }

    /// \short Computer the test functions, derivatives and
    /// second derivatives w.r.t local coordinates at local coordinate s \n
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
    inline void d2test_local(const Vector<double>& s,
                             Shape& psi,
                             DShape& dpsids,
                             DShape& d2psids) const
    {
      TElementShape<2, NNODE_1D>::d2shape_local(s, psi, dpsids, d2psids);
    }
  };


  //========================================================================
  /// Empty base class for C1Curvedelements (created so that
  /// we can use dynamic_cast<>() to figure out if a an element
  /// is a C1Curvedelement). This element is sup-parametric
  /// Note that this type of element carries three kinds of shape functions
  /// shape_straight : denotes C1-shape functions for straight-edged triangle
  /// shape_curve : denotes C1-shape functions for curve-edged triangle
  /// shape_geom : denotes C0-shape functions for geometry
  //========================================================================
  template<unsigned NNODE_1D>
  class C1CurvedElementBase : public virtual FiniteElement
  {
  public:
    ///\short  Constructor: Call constructors for FiniteElement
    C1CurvedElementBase() : FiniteElement() {}
    virtual void get_value_transform_matrix(
      DenseMatrix<double>& D,
      DenseMatrix<double>& B,
      DenseMatrix<double>& node_position,
      unsigned& bd_element,
      DenseMatrix<double>& bd_node_position,
      Vector<double>& x) const
    {
    }

    virtual void classify_boundary_node(DenseMatrix<double>& node_position,
                                        unsigned& bd_element,
                                        DenseMatrix<double>& bd_node_position,
                                        Vector<double>& x) const
    {
    }

    virtual void basis_straight(const Vector<double>& s, Shape& psi) const {}


    virtual void dbasis_local_straight(const Vector<double>& s,
                                       Shape& psi,
                                       DShape& dpsids) const
    {
    }

    virtual void d2basis_local_straight(const Vector<double>& s,
                                        Shape& psi,
                                        DShape& dpsids,
                                        DShape& d2psids) const
    {
    }

    virtual void shape_geom(const Vector<double>& s,
                            Shape& psi,
                            Shape& phi) const
    {
    }


    virtual void dshape_local_geom(const Vector<double>& s,
                                   Shape& psi,
                                   DShape& dpsids,
                                   Shape& phi,
                                   DShape& dphids) const
    {
    }

    virtual void d2shape_local_geom(const Vector<double>& s,
                                    Shape& psi,
                                    DShape& dpsids,
                                    DShape& d2psids,
                                    Shape& phi,
                                    DShape& dphids,
                                    DShape& d2phids) const
    {
    }

    virtual void basis_curve(const Vector<double>& s, Shape& psi) const {}


    virtual void dbasis_local_curve(const Vector<double>& s,
                                    Shape& psi,
                                    DShape& dpsids) const
    {
    }

    virtual void d2basis_local_curve(const Vector<double>& s,
                                     Shape& psi,
                                     DShape& dpsids,
                                     DShape& d2psids) const
    {
    }

    virtual void basis_c0(const Vector<double>& s, Shape& psi) const {}


    virtual void dbasis_c0_local(const Vector<double>& s,
                                 Shape& psi,
                                 DShape& dpsids) const
    {
    }

    virtual void d2basis_c0_local(const Vector<double>& s,
                                  Shape& psi,
                                  DShape& dpsids,
                                  DShape& d2psids) const
    {
    }


    virtual void test(const Vector<double>& s, Shape& phi) const {}


    virtual void dtest_local(const Vector<double>& s,
                             Shape& phi,
                             DShape& dphids) const
    {
    }

    virtual void d2test_local(const Vector<double>& s,
                              Shape& phi,
                              DShape& dphids,
                              DShape& d2phids) const
    {
    }


    //=========================================================================
    /// \short Return the c1-shape function associated with a straight-sided
    /// boundary stored at the ipt-th integration point.
    //=========================================================================
    void basis_at_knot_straight(const unsigned& ipt, Shape& psi) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function
      basis_straight(s, psi);
    }

    //=========================================================================
    /// \short Return the c1-shape function associated with a straight-sided
    /// boundary and its derivatives w.r.t. the global
    /// coordinates at the ipt-th integration point.
    //=========================================================================
    void dbasis_local_at_knot_straight(const unsigned& ipt,
                                       Shape& psi,
                                       DShape& dpsids) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function and derivatives
      dbasis_local_straight(s, psi, dpsids);
    }

    //=========================================================================
    /// Calculate the c1-shape function associated with a straight-sided
    /// boundary and its first and second derivatives
    /// w.r.t. global coordinates at the ipt-th integration point.
    /// \n\n Numbering:
    //=========================================================================
    void d2basis_local_at_knot_straight(const unsigned& ipt,
                                        Shape& psi,
                                        DShape& dpsids,
                                        DShape& d2psids) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function and first and second derivatives
      d2basis_local_straight(s, psi, dpsids, d2psids);
    }

    //=========================================================================
    /// \short Return the c1-shape function  associated with a curvilinear
    /// boundary stored at the ipt-th integration point.
    //=========================================================================
    void basis_at_knot_curve(const unsigned& ipt, Shape& psi) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function
      basis_curve(s, psi);
    }

    //=========================================================================
    /// Return the c1-shape function associated with a curvilinear boundary
    /// and its derivatives w.r.t. the local coordinates at the ipt-th
    /// integration point.
    //=========================================================================
    void dbasis_local_at_knot_curve(const unsigned& ipt,
                                    Shape& psi,
                                    DShape& dpsids) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function and derivatives
      dbasis_local_curve(s, psi, dpsids);
    }

    //=========================================================================
    /// Calculate the c1-shape function associated with a curvilinear boundary
    /// and its first and second derivatives w.r.t. local coordinates at the
    /// ipt-th integration point.
    /// \n\n Numbering:
    //=========================================================================
    void d2basis_local_at_knot_curve(const unsigned& ipt,
                                     Shape& psi,
                                     DShape& dpsids,
                                     DShape& d2psids) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function and first and second derivatives
      d2basis_local_curve(s, psi, dpsids, d2psids);
    }

    //=========================================================================
    /// \short Return the c0-shape function stored at the ipt-th integration
    /// point.
    //=========================================================================
    void basis_c0_at_knot(const unsigned& ipt, Shape& psi) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function
      basis_c0(s, psi);
    }

    //=========================================================================
    /// \short Return the c0-shape function and its derivatives w.r.t. the local
    /// coordinates at the ipt-th integration point.
    //=========================================================================
    void dbasis_c0_local_at_knot(const unsigned& ipt,
                                 Shape& psi,
                                 DShape& dpsids) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function and derivatives
      dbasis_c0_local(s, psi, dpsids);
    }

    //=========================================================================
    /// Calculate the c0-shape function and its first and second derivatives
    /// w.r.t. local coordinates at the ipt-th integration point.
    /// \n\n Numbering:
    //=========================================================================
    void d2basis_c0_local_at_knot(const unsigned& ipt,
                                  Shape& psi,
                                  DShape& dpsids,
                                  DShape& d2psids) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function and first and second derivatives
      d2basis_c0_local(s, psi, dpsids, d2psids);
    }

    //=========================================================================
    /// \short Return the geometric shape function stored at the ipt-th
    /// integration point.
    //=========================================================================
    void shape_at_knot_geom(const unsigned& ipt, Shape& psi, Shape& phi) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function
      shape_geom(s, psi, phi);
    }

    //=========================================================================
    /// \short Return the geometric shape function and its derivatives w.r.t.
    /// the local coordinates at the ipt-th integration point.
    //=========================================================================
    void dshape_local_at_knot_geom(const unsigned& ipt,
                                   Shape& psi,
                                   DShape& dpsids,
                                   Shape& phi,
                                   DShape& dphids) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function and derivatives

      dshape_local_geom(s, psi, dpsids, phi, dphids);
    }

    //=========================================================================
    /// Calculate the geometric shape function and its first and second
    /// derivatives w.r.t. local coordinates at the ipt-th integration point.
    /// \n\n Numbering:
    //=========================================================================
    void d2shape_local_at_knot_geom(const unsigned& ipt,
                                    Shape& psi,
                                    DShape& dpsids,
                                    DShape& d2psids,
                                    Shape& phi,
                                    DShape& dphids,
                                    DShape& d2phids) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function and first and second derivatives
      d2shape_local_geom(s, psi, dpsids, d2psids, phi, dphids, d2phids);
    }

    //=========================================================================
    /// \short Return the test function stored at the ipt-th integration
    /// point.
    //=========================================================================
    void test_at_knot(const unsigned& ipt, Shape& phi) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function
      test(s, phi);
    }

    //=========================================================================
    /// \short Return the test function and its derivatives w.r.t. the local
    /// coordinates at the ipt-th integration point.
    //=========================================================================
    void dtest_local_at_knot(const unsigned& ipt,
                             Shape& phi,
                             DShape& dphids) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function and derivatives
      dtest_local(s, phi, dphids);
    }

    //=========================================================================
    /// Calculate the test function and its first and second derivatives
    /// w.r.t. local coordinates at the ipt-th integration point.
    /// \n\n Numbering:
    //=========================================================================
    void d2test_local_at_knot(const unsigned& ipt,
                              Shape& phi,
                              DShape& dphids,
                              DShape& d2phids) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Storage for the local coordinates of the integration point
      Vector<double> s(el_dim);
      // Set the local coordinate
      for (unsigned i = 0; i < el_dim; i++)
      {
        s[i] = integral_pt()->knot(ipt, i);
      }
      // Get the shape function and first and second derivatives
      d2test_local(s, phi, dphids, d2phids);
    }

    //=========================================================================
    /// Calculate the shape function and its first and second derivatives
    /// w.r.t. local coordinates at the ipt-th integration point.
    /// \n\n Numbering:
    //=========================================================================
    double dshape_and_dtest_eulerian_at_knot(const unsigned& ipt,
                                             Shape& psi,
                                             DShape& dpsi,
                                             Shape& test,
                                             DShape& dtest) const
    {
      // Find the element dimension
      const unsigned el_dim = dim();
      // Get the values of the shape function and local derivatives
      // Temporarily store it in dpsi
      // assign shape functions for unknowns
      dshape_local_at_knot(ipt, psi, dpsi);

      // assign shape functions for geometry -> Lagrange family
      unsigned n_node = 3;
      Shape psi_x(n_node);
      DShape dpsi_x(n_node, 2);
      Shape phi(2);
      DShape dphi(2, 2);

      // assign 'linear' shape function to geometry
      dshape_local_at_knot_geom(ipt, psi_x, dpsi_x, phi, dphi);

      // assign test function
      dtest_local_at_knot(ipt, test, dtest);

      // Allocate memory for the inverse jacobian
      DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);

      // Now calculate the inverse jacobian
      const double det =
        local_to_eulerian_mapping2(dpsi_x, dphi, jacobian, inverse_jacobian);

      // Now set the values of the derivatives to dpsidx
      transform_derivatives(inverse_jacobian, dpsi);

      // Return the determinant of the jacobian
      return det;
    }

    //===========================================================================
    /// \short Compute the  c1-shape functions that associated with the
    /// straight- boundary element and also first and second derivatives w.r.t.
    /// global coordinates at ipt-th integration point Returns Jacobian of
    /// mapping from global to local coordinates.
    //===========================================================================
    double d2shape_and_d2test_eulerian_at_knot(const unsigned& ipt,
                                               Shape& psi,
                                               DShape& dpsi,
                                               DShape& d2psi,
                                               Shape& test,
                                               DShape& dtest,
                                               DShape& d2test) const
    {
      // Find the values of the indices of the shape functions
      // Locally cached
      // Find the element dimension
      const unsigned el_dim = dim();
      // Get the values of the shape function and local derivatives for unknowns
      d2basis_local_at_knot_straight(ipt, psi, dpsi, d2psi);

      // assign shape functions for geometry
      unsigned n_node = 3;
      Shape psi_x(n_node);
      DShape dpsi_x(n_node, 2);
      DShape d2psi_x(n_node, 3);
      Shape phi(2);
      DShape dphi(2, 2);
      DShape d2phi(2, 3);
      d2shape_local_at_knot_geom(ipt, psi_x, dpsi_x, d2psi_x, phi, dphi, d2phi);

      // assign for test function
      d2test_local_at_knot(ipt, test, dtest, d2test);

      // Allocate memory for the jacobian and inverse jacobian
      DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);

      // Calculate the jacobian and inverse jacobian
      const double det =
        local_to_eulerian_mapping2(dpsi_x, dphi, jacobian, inverse_jacobian);

      // Return the determinant of the mapping
      return det;
    }

    //===========================================================================
    /// \short Calculate the mapping from local to Eulerian coordinates,
    /// given the derivatives of the shape functions w.r.t. local coordinates,
    /// Return only the determinant of the jacobian and the inverse of the
    /// mapping (ds/dx).
    //===========================================================================
    double local_to_eulerian_mapping2(
      const DShape& dpsids,
      DShape& dphids,
      DenseMatrix<double>& inverse_jacobian) const
    {
      // Find the dimension of the element
      const unsigned el_dim = dim();
      // Assign memory for the jacobian
      DenseMatrix<double> jacobian(el_dim);
      // Calculate the jacobian and inverse
      return local_to_eulerian_mapping2(
        dpsids, dphids, jacobian, inverse_jacobian);
    }

    ///////////////////////////////////////////////////////////////
    virtual double local_to_eulerian_mapping2(
      const DShape& dpsids,
      DShape& dphids,
      DenseMatrix<double>& jacobian,
      DenseMatrix<double>& inverse_jacobian) const
    {
      // Assemble the jacobian
      // Locally cache the elemental dimension
      const unsigned el_dim = dim();

      // Loop over the rows of the jacobian
      for (unsigned i = 0; i < el_dim; i++)
      {
        // Loop over the columns of the jacobian
        for (unsigned j = 0; j < el_dim; j++)
        {
          // Zero the entry
          jacobian(i, j) = 0.0;
          jacobian(i, j) = dphids(j, i);
        }
      }
      // Invert the jacobian (use the template-free interface)
      return invert_jacobian_mapping(jacobian, inverse_jacobian);
    }

    //=========================================================================
    /// Internal function that is used to assemble the jacobian of second
    /// derivatives of the the mapping from local coordinates (s) to the
    /// eulerian coordinates (x), given the second derivatives of the
    /// shape functions.
    //=========================================================================
    void myassemble_local_to_eulerian_jacobian2(
      const DShape& d2psids, DenseMatrix<double>& jacobian2) const
    {
      // Find the the dimension of the element
      const unsigned el_dim = dim();
      // Find the number of second derivatives
      const unsigned n_row = N2deriv[el_dim];
      // Assemble the "jacobian" (d^2 x_j/ds_i^2) for second derivatives of
      // shape functions
      // Loop over the rows (number of second derivatives)
      for (unsigned i = 0; i < n_row; i++)
      {
        // Loop over the columns (element dimension
        for (unsigned j = 0; j < el_dim; j++)
        {
          // Zero the entry
          jacobian2(i, j) = 0.0;
          jacobian2(i, j) = d2psids(j, i);
        }
      }
    }

    //=======================================================================
    /// Return FE interpolated position x[] at local coordinate s as Vector
    // (using Hermite interpolation)
    //=======================================================================
    void my_interpolated_x(const Vector<double>& s, Vector<double>& x) const
    {
      // Find the number of nodes
      const unsigned n_node = 3;
      // Assign storage for the local shape function
      Shape psi(n_node);
      Shape phi(2);
      // Find the values of shape function
      shape_geom(s, psi, phi);

      x[0] = phi[0];
      x[1] = phi[1];
    }

    //========================================================================
    /// \short Calculate the Jacobian of the mapping between local and global
    /// coordinates at the position s
    //========================================================================
    double J_eulerian1(const Vector<double>& s) const
    {
      // Find the number of nodes and position types
      const unsigned n_node = 3;
      // Find the dimension of the node and element
      const unsigned n_dim_node = this->nodal_dimension();
      const unsigned n_dim_element = this->dim();

      // Set up dummy memory for the shape functions
      // compute the jacobian of mapping matrix
      Shape psi(n_node), phi(2);
      DShape dpsids(n_node, n_dim_element), dphi(2, 2);
      // Get the shape functions and local derivatives for geometry
      this->dshape_local_geom(s, psi, dpsids, phi, dphi);

      // Right calculate the base vectors
      DenseMatrix<double> interpolated_G(n_dim_element, n_dim_node);

      // Loop over the dimensions and compute the entries of the
      // base vector matrix
      for (unsigned i = 0; i < n_dim_element; i++)
      {
        for (unsigned j = 0; j < n_dim_node; j++)
        {
          interpolated_G(i, j) = dphi(j, i);
        }
      }

      // Calculate the metric tensor of the element
      DenseMatrix<double> G(n_dim_element);
      for (unsigned i = 0; i < n_dim_element; i++)
      {
        for (unsigned j = 0; j < n_dim_element; j++)
        {
          // Initialise to zero
          G(i, j) = 0.0;
          for (unsigned k = 0; k < n_dim_node; k++)
          {
            G(i, j) += interpolated_G(i, k) * interpolated_G(j, k);
          }
        }
      }

      // Calculate the determinant of the metric tensor
      double det = 0.0;
      switch (n_dim_element)
      {
        case 0:
          throw OomphLibError(
            "Cannot calculate J_eulerian() for point element\n",
            "FiniteElement::J_eulerian()",
            OOMPH_EXCEPTION_LOCATION);
          break;
        case 1:
          det = G(0, 0);
          break;
        case 2:
          det = G(0, 0) * G(1, 1) - G(0, 1) * G(1, 0);
          break;
        case 3:
          det = G(0, 0) * G(1, 1) * G(2, 2) + G(0, 1) * G(1, 2) * G(2, 0) +
                G(0, 2) * G(1, 0) * G(2, 1) - G(0, 0) * G(1, 2) * G(2, 1) -
                G(0, 1) * G(1, 0) * G(2, 2) - G(0, 2) * G(1, 1) * G(2, 0);
          break;
        default:
          oomph_info << "More than 3 dimensions in J_eulerian()" << std::endl;
          break;
      }

#ifdef PARANOID
      this->check_jacobian(det);
#endif

      // Return the Jacobian (square-root of the determinant of the metric
      // tensor)
      return det;
    }

    // =======================================================================
    // Check whether this element is a boundary element or not
    //========================================================================
    unsigned is_boundary_element() const
    {
      unsigned n_node = 3;
      int count = 0;
      // check whether this element is on boundary or not
      for (unsigned i = 0; i < n_node; i++)
      {
        // check whether this node is on 1st boundary (curve boundary)
        bool bd_node1 = node_pt(i)->is_on_boundary(1);
        if (bd_node1 == 1)
        {
          count += 1;
        }
      }
      unsigned bd_element;
      if (count == 2)
      {
        bd_element = 1;
      }
      else
      {
        bd_element = 0;
      }
      return bd_element;
    }

    //=========================================================================
    /// \short Compute the c0-shape functions and also
    /// first derivatives w.r.t. global coordinates at local coordinate s;
    /// Returns Jacobian of mapping from global to local coordinates.
    /// Most general form of the function, but may be over-loaded, if desired
    //=========================================================================
    double dbasis_c0_eulerian(const Vector<double>& s,
                              Shape& psi,
                              DShape& dpsi) const
    {
      // Find the element dimension
      const unsigned el_dim = dim();
      // Get the values of the shape functions and their local derivatives
      // Temporarily stored in dpsi
      dbasis_c0_local(s, psi, dpsi);

      // assign shape functions for geometry
      unsigned n_node = 3;
      Shape psi_x(n_node);
      DShape dpsi_x(n_node, 2);
      DShape d2psi_x(n_node, 3);
      Shape phi(2);
      DShape dphi(2, 2);
      DShape d2phi(2, 3);
      d2shape_local_geom(s, psi_x, dpsi_x, d2psi_x, phi, dphi, d2phi);

      // Allocate memory for the jacobian and inverse jacobian
      DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);
      // Calculate the jacobian and inverse jacobian
      const double det = this->local_to_eulerian_mapping2(
        dpsi_x, dphi, jacobian, inverse_jacobian);
      // Now set the values of the derivatives to be dpsidx
      transform_derivatives(inverse_jacobian, dpsi);
      // Return the determinant of the jacobian
      return det;
    }

    //=========================================================================
    /// \short Compute the c0-shape functions and also the first and the
    /// second derivatives w.r.t.global coordinates at local coordinate s;
    /// Returns Jacobian of mapping from global to local coordinates.
    /// Most general form of the function, but may be over-loaded, if desired
    //=========================================================================
    double d2basis_c0_eulerian(const Vector<double>& s,
                               Shape& psi,
                               DShape& dpsi,
                               DShape& d2psi) const
    {
      // Find the element dimension
      const unsigned el_dim = dim();
      // Find the number of second derivatives required
      const unsigned n_deriv = N2deriv[el_dim];
      // Get the values of the shape function and local derivatives for unknowns
      d2basis_c0_local(s, psi, dpsi, d2psi);

      // assign shape functions for geometry
      unsigned n_node = 3;
      Shape psi_x(n_node);
      DShape dpsi_x(n_node, 2);
      DShape d2psi_x(n_node, 3);
      Shape phi(2);
      DShape dphi(2, 2);
      DShape d2phi(2, 3);
      d2shape_local_geom(s, psi_x, dpsi_x, d2psi_x, phi, dphi, d2phi);

      // Allocate memory for the jacobian and inverse jacobian
      DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);
      // Calculate the jacobian and inverse jacobian
      const double det =
        local_to_eulerian_mapping2(dpsi_x, dphi, jacobian, inverse_jacobian);
      // Allocate memory for the jacobian of second derivatives
      DenseMatrix<double> jacobian2(n_deriv, el_dim, 0.0);
      // Assemble the jacobian of second derivatives
      myassemble_local_to_eulerian_jacobian2(d2phi, jacobian2);
      // Now set the value of the derivatives
      transform_second_derivatives(
        jacobian, inverse_jacobian, jacobian2, dpsi, d2psi);
      // Return the determinant of the jacobian
      return det;
    }

    //=========================================================================
    /// \short Compute the curved-element shape functions and also
    /// first derivatives w.r.t. global coordinates at local coordinate s;
    /// Returns Jacobian of mapping from global to local coordinates.
    /// Most general form of the function, but may be over-loaded, if desired
    //=========================================================================
    double dbasis_eulerian_curve(const Vector<double>& s,
                                 Shape& psi,
                                 DShape& dpsi) const
    {
      // Find the element dimension
      const unsigned el_dim = dim();
      // Get the values of the shape functions and their local derivatives
      // Temporarily stored in dpsi
      dbasis_local_curve(s, psi, dpsi);

      // assign shape functions for geometry
      unsigned n_node = 3;
      Shape psi_x(n_node);
      DShape dpsi_x(n_node, 2);
      DShape d2psi_x(n_node, 3);
      Shape phi(2);
      DShape dphi(2, 2);
      DShape d2phi(2, 3);
      d2shape_local_geom(s, psi_x, dpsi_x, d2psi_x, phi, dphi, d2phi);

      // Allocate memory for the jacobian and inverse jacobian
      DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);
      // Calculate the jacobian and inverse jacobian
      const double det = this->local_to_eulerian_mapping2(
        dpsi_x, dphi, jacobian, inverse_jacobian);
      // Now set the values of the derivatives to be dpsidx
      transform_derivatives(inverse_jacobian, dpsi);
      // Return the determinant of the jacobian
      return det;
    }

    //===========================================================================
    /// \short Compute the cuved-element shape functions and also first
    /// and second derivatives w.r.t. global coordinates at ipt-th integration
    /// point
    //===========================================================================
    double d2basis_eulerian_curve(const Vector<double>& s,
                                  Shape& psi,
                                  DShape& dpsi,
                                  DShape& d2psi) const
    {
      // Find the element dimension
      const unsigned el_dim = dim();
      // Find the number of second derivatives required
      const unsigned n_deriv = N2deriv[el_dim];
      // Get the values of the shape function and local derivatives for unknowns
      d2basis_local_curve(s, psi, dpsi, d2psi);

      // assign shape functions for geometry
      unsigned n_node = 3;
      Shape psi_x(n_node);
      DShape dpsi_x(n_node, 2);
      DShape d2psi_x(n_node, 3);
      Shape phi(2);
      DShape dphi(2, 2);
      DShape d2phi(2, 3);
      d2shape_local_geom(s, psi_x, dpsi_x, d2psi_x, phi, dphi, d2phi);

      // Allocate memory for the jacobian and inverse jacobian
      DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);
      // Calculate the jacobian and inverse jacobian
      const double det =
        local_to_eulerian_mapping2(dpsi_x, dphi, jacobian, inverse_jacobian);
      // Allocate memory for the jacobian of second derivatives
      DenseMatrix<double> jacobian2(n_deriv, el_dim, 0.0);
      // Assemble the jacobian of second derivatives
      myassemble_local_to_eulerian_jacobian2(d2phi, jacobian2);
      // Now set the value of the derivatives
      transform_second_derivatives(
        jacobian, inverse_jacobian, jacobian2, dpsi, d2psi);
      // Return the determinant of the jacobian
      return det;
    }

    //=======================================================================
    /// Return raw nodal value for nodes specified on the reference triangle
    //=======================================================================
    void get_nodal_value_curve1(Vector<double>& u_value, DenseMatrix<double>& M)
    {
      // assign degrees of freedom to the reference element
      DenseMatrix<double> D(21, 21), B(21, 36);
      Vector<double> temp(21, 0.0);
      DenseMatrix<double> position(3, 2);
      unsigned bd_element;
      DenseMatrix<double> bd_position(20, 2);
      Vector<double> x(2);

      // Get the nodal values of the unknown
      Vector<double> value(21);

      value[0] = raw_nodal_value(0, 0);
      value[1] = raw_nodal_value(1, 0);
      value[2] = raw_nodal_value(2, 0);
      value[3] = raw_nodal_value(0, 1);
      value[4] = raw_nodal_value(0, 2);
      value[5] = raw_nodal_value(1, 1);
      value[6] = raw_nodal_value(1, 2);
      value[7] = raw_nodal_value(2, 1);
      value[8] = raw_nodal_value(2, 2);
      value[9] = raw_nodal_value(0, 3);
      value[10] = raw_nodal_value(0, 5);
      value[11] = raw_nodal_value(0, 4);
      value[12] = raw_nodal_value(1, 3);
      value[13] = raw_nodal_value(1, 5);
      value[14] = raw_nodal_value(1, 4);
      value[15] = raw_nodal_value(2, 3);
      value[16] = raw_nodal_value(2, 5);
      value[17] = raw_nodal_value(2, 4);
      value[18] = raw_nodal_value(3, 0);
      value[19] = raw_nodal_value(4, 0);
      value[20] = raw_nodal_value(5, 0);

      // Transformation metrix associating nodal values between the reference
      // and the physical curved triangle
      get_value_transform_matrix(D, B, position, bd_element, bd_position, x);

      for (unsigned i = 0; i < 21; i++)
      {
        for (unsigned j = 0; j < 36; j++)
        {
          for (unsigned k = 0; k < 21; k++)
          {
            M(i, j) += D(i, k) * B(k, j);
          }
        }
      }

      for (unsigned i = 0; i < 21; i++)
      {
        for (unsigned j = 0; j < 21; j++)
        {
          // get values wrt local coordinates
          temp[i] += value[j] * D(j, i);
        }
      }

      for (unsigned i = 0; i < 36; i++)
      {
        for (unsigned j = 0; j < 21; j++)
        {
          u_value[i] += temp[j] * B(j, i);
        }
      }
    }

    //=======================================================================
    /// Return raw nodal equations for nodes specified on the curved triangle
    ///  This function will be employed for the post-permutation as
    /// the nodal values defined on the element doesn't match with the defined
    /// shape functions
    //=======================================================================
    void get_nodal_eqn_curve(DenseMatrix<int>& nodal_eqn)
    {
      // assign degrees of freedom to the reference element
      DenseMatrix<double> D(21, 21), B(21, 36);
      DenseMatrix<double> position(3, 2);
      unsigned bd_element;
      DenseMatrix<double> bd_position(20, 2);
      Vector<double> x(2);
      unsigned n_position_type = 6;

      // Get nodal values at nodes on the reference element
      get_value_transform_matrix(D, B, position, bd_element, bd_position, x);

      double angle_1 = atan(bd_position(0, 1) / bd_position(0, 0));
      double angle_2 = atan(bd_position(1, 1) / bd_position(1, 0));
      if (angle_1 > angle_2)
      {
        for (unsigned k = 0; k < n_position_type; k++)
        {
          unsigned i = 2 + k;
          nodal_eqn(0, k) = nodal_local_eqn(2, i);
          nodal_eqn(1, k) = nodal_local_eqn(0, i);
          nodal_eqn(2, k) = nodal_local_eqn(1, i);
          nodal_eqn(3, k) = nodal_local_eqn(5, i);
          nodal_eqn(4, k) = nodal_local_eqn(3, i);
          nodal_eqn(5, k) = nodal_local_eqn(4, i);
          nodal_eqn(nnode() - 3, k) = nodal_local_eqn(nnode() - 3, i);
          nodal_eqn(nnode() - 2, k) = nodal_local_eqn(nnode() - 2, i);
          nodal_eqn(nnode() - 1, k) = nodal_local_eqn(nnode() - 1, i);
        }
      }
      else if (angle_1 < angle_2)
      {
        if (position(0, 0) == bd_position(0, 0) &&
            position(0, 1) == bd_position(0, 1))
        {
          for (unsigned k = 0; k < n_position_type; k++)
          {
            nodal_eqn(0, k) = nodal_local_eqn(0, 2 + k);
            nodal_eqn(1, k) = nodal_local_eqn(1, 2 + k);
            nodal_eqn(2, k) = nodal_local_eqn(2, 2 + k);
            nodal_eqn(3, k) = nodal_local_eqn(3, 2 + k);
            nodal_eqn(4, k) = nodal_local_eqn(4, 2 + k);
            nodal_eqn(5, k) = nodal_local_eqn(5, 2 + k);
            nodal_eqn(nnode() - 3, k) = nodal_local_eqn(nnode() - 2, 2 + k);
            nodal_eqn(nnode() - 2, k) = nodal_local_eqn(nnode() - 1, 2 + k);
            nodal_eqn(nnode() - 1, k) = nodal_local_eqn(nnode() - 3, 2 + k);
          }
        }
        else
        {
          for (unsigned k = 0; k < n_position_type; k++)
          {
            nodal_eqn(0, k) = nodal_local_eqn(1, 2 + k);
            nodal_eqn(1, k) = nodal_local_eqn(2, 2 + k);
            nodal_eqn(2, k) = nodal_local_eqn(0, 2 + k);
            nodal_eqn(3, k) = nodal_local_eqn(4, 2 + k);
            nodal_eqn(4, k) = nodal_local_eqn(5, 2 + k);
            nodal_eqn(5, k) = nodal_local_eqn(3, 2 + k);
            nodal_eqn(nnode() - 3, k) = nodal_local_eqn(nnode() - 1, 2 + k);
            nodal_eqn(nnode() - 2, k) = nodal_local_eqn(nnode() - 3, 2 + k);
            nodal_eqn(nnode() - 1, k) = nodal_local_eqn(nnode() - 2, 2 + k);
          }
        }
      }
    }

    //=======================================================================
    /// Return FE interpolated value u[] at local coordinate s as Vector
    /// using Bell interpolations for the straight-edges triangle
    /// using C1-curved interpolations for the curve-edges triangle
    // This one is for the pre-permutation
    //=======================================================================
    void my_interpolated_u_normal1(const Vector<double> s,
                                   Vector<double>& interpolated_u,
                                   DenseMatrix<double>& interpolated_dudxi,
                                   DenseMatrix<double>& interpolated_d2udxi,
                                   DenseMatrix<double>& M)
    {
      // To check whether this element is on the boundary
      unsigned bd_element = is_boundary_element();
      // Find the number of positional types
      const unsigned n_position_type = nnodal_position_type();
      if (bd_element == 0)
      {
        // Assign storage for the local shape function
        Shape psi(3, 6);
        DShape dpsi(3, 6, 2), d2psi(3, 6, 3);

        // Assign shape functions and their derivatives
        d2basis_local_straight(s, psi, dpsi, d2psi);

        // Loop over nodes
        for (unsigned l = 0; l < 3; l++)
        {
          for (unsigned k = 0; k < n_position_type; k++)
          {
            // Get the nodal value of the unknown
            double u_val = raw_nodal_value(l, k);
            interpolated_u[0] += u_val * psi(l, k);

            // Loop over directions
            for (unsigned j = 0; j < 2; j++)
            {
              interpolated_dudxi(0, j) += u_val * dpsi(l, k, j);
            }
            for (unsigned j = 0; j < 3; j++)
            {
              interpolated_d2udxi(0, j) += u_val * d2psi(l, k, j);
            }
          }
        }
      }
      // if it is the boundary element
      else if (bd_element == 1)
      {
        Vector<double> u_value(36, 0.0);
        // Get nodal values at nodes on the reference element
        get_nodal_value_curve1(u_value, M);

        // Assign storage for the local shape functio to a curved element
        Shape psi_curve(36), basis(36);
        DShape dpsi_curve(36, 2), d2psi_curve(36, 3), dbasis(36, 2),
          d2basis(36, 3);

        // derivative have to be wrt global coor.
        d2basis_eulerian_curve(s, psi_curve, dpsi_curve, d2psi_curve);
        for (unsigned i = 0; i < 36; i++)
        {
          interpolated_u[0] += u_value[i] * psi_curve[i];
          // Loop over directions
          for (unsigned j = 0; j < 2; j++)
          {
            interpolated_dudxi(0, j) += u_value[i] * dpsi_curve(i, j);
          }
          for (unsigned j = 0; j < 3; j++)
          {
            interpolated_d2udxi(0, j) += u_value[i] * d2psi_curve(i, j);
          }
        }
      }
    }

    //=======================================================================
    /// Return FE interpolated value u[] at local coordinate s as Vector
    /// using Bell interpolations for the straight-edges triangle
    /// using C1-curved interpolations for the curve-edges triangle
    // This one is for post-permutation
    //=======================================================================
    void my_interpolated_u_normal(
      const Vector<double> s,
      Vector<double>& interpolated_u,
      DenseMatrix<double>& interpolated_dudxi,
      DenseMatrix<double>& interpolated_d2udxi) const
    {
      // To check whether this element is on the boundary
      unsigned bd_element = is_boundary_element();

      // Find the number of positional types
      const unsigned n_position_type = nnodal_position_type();

      if (bd_element == 0)
      {
        // Assign storage for the local shape function
        Shape psi(3, 6);
        DShape dpsi(3, 6, 2), d2psi(3, 6, 3);
        // Assign shape functions and their derivatives
        d2basis_local_straight(s, psi, dpsi, d2psi);

        // Loop over nodes
        for (unsigned l = 0; l < 3; l++)
        {
          for (unsigned k = 0; k < n_position_type; k++)
          {
            // Get the nodal value of the poisson unknown
            double u_val = raw_nodal_value(l, 2 + k);
            interpolated_u[0] += u_val * psi(l, k);
            // Loop over directions
            for (unsigned j = 0; j < 2; j++)
            {
              interpolated_dudxi(0, j) += u_val * dpsi(l, k, j);
            }
            for (unsigned j = 0; j < 3; j++)
            {
              interpolated_d2udxi(0, j) += u_val * d2psi(l, k, j);
            }
          }
        }
      }
      // if it is the boundary element
      else if (bd_element == 1)
      {
        // assign degrees of freedom to the reference element
        DenseMatrix<double> D(21, 21), B(21, 36);
        Vector<double> temp(21, 0.0);
        Vector<double> u_value(36, 0.0);
        DenseMatrix<double> position(3, 2);
        unsigned bd_element;
        DenseMatrix<double> bd_position(20, 2);
        Vector<double> x(2);
        // Get nodal values at nodes on the reference element
        get_value_transform_matrix(D, B, position, bd_element, bd_position, x);

        Vector<double> value(21);

        double angle_1 = atan(bd_position(0, 1) / bd_position(0, 0));
        double angle_2 = atan(bd_position(1, 1) / bd_position(1, 0));
        if (angle_1 > angle_2)
        {
          DenseMatrix<double> nodal_value(3, n_position_type);
          for (unsigned k = 0; k < n_position_type; k++)
          {
            nodal_value(0, k) = raw_nodal_value(2, 2 + k);
            nodal_value(1, k) = raw_nodal_value(0, 2 + k);
            nodal_value(2, k) = raw_nodal_value(1, 2 + k);
          }
          value[0] = nodal_value(0, 0);
          value[1] = nodal_value(1, 0);
          value[2] = nodal_value(2, 0);
          value[3] = nodal_value(0, 1);
          value[4] = nodal_value(0, 2);
          value[5] = nodal_value(1, 1);
          value[6] = nodal_value(1, 2);
          value[7] = nodal_value(2, 1);
          value[8] = nodal_value(2, 2);
          value[9] = nodal_value(0, 3);
          value[10] = nodal_value(0, 5);
          value[11] = nodal_value(0, 4);
          value[12] = nodal_value(1, 3);
          value[13] = nodal_value(1, 5);
          value[14] = nodal_value(1, 4);
          value[15] = nodal_value(2, 3);
          value[16] = nodal_value(2, 5);
          value[17] = nodal_value(2, 4);
          value[18] = raw_nodal_value(nnode() - 3, 2 + 0);
          value[19] = raw_nodal_value(nnode() - 2, 2 + 0);
          value[20] = raw_nodal_value(nnode() - 1, 2 + 0);
        }
        else if (angle_1 < angle_2)
        {
          if (position(0, 0) == bd_position(0, 0) &&
              position(0, 1) == bd_position(0, 1))
          {
            value[0] = raw_nodal_value(0, 2 + 0);
            value[1] = raw_nodal_value(1, 2 + 0);
            value[2] = raw_nodal_value(2, 2 + 0);
            value[3] = raw_nodal_value(0, 2 + 1);
            value[4] = raw_nodal_value(0, 2 + 2);
            value[5] = raw_nodal_value(1, 2 + 1);
            value[6] = raw_nodal_value(1, 2 + 2);
            value[7] = raw_nodal_value(2, 2 + 1);
            value[8] = raw_nodal_value(2, 2 + 2);
            value[9] = raw_nodal_value(0, 2 + 3);
            value[10] = raw_nodal_value(0, 2 + 5);
            value[11] = raw_nodal_value(0, 2 + 4);
            value[12] = raw_nodal_value(1, 2 + 3);
            value[13] = raw_nodal_value(1, 2 + 5);
            value[14] = raw_nodal_value(1, 2 + 4);
            value[15] = raw_nodal_value(2, 2 + 3);
            value[16] = raw_nodal_value(2, 2 + 5);
            value[17] = raw_nodal_value(2, 2 + 4);
            value[18] = raw_nodal_value(nnode() - 2, 2 + 0);
            value[19] = raw_nodal_value(nnode() - 1, 2 + 0);
            value[20] = raw_nodal_value(nnode() - 3, 2 + 0);
          }
          else
          {
            DenseMatrix<double> nodal_value(3, n_position_type);
            for (unsigned k = 0; k < n_position_type; k++)
            {
              nodal_value(2, k) = raw_nodal_value(0, 2 + k);
              nodal_value(0, k) = raw_nodal_value(1, 2 + k);
              nodal_value(1, k) = raw_nodal_value(2, 2 + k);
            }
            value[0] = nodal_value(0, 0);
            value[1] = nodal_value(1, 0);
            value[2] = nodal_value(2, 0);
            value[3] = nodal_value(0, 1);
            value[4] = nodal_value(0, 2);
            value[5] = nodal_value(1, 1);
            value[6] = nodal_value(1, 2);
            value[7] = nodal_value(2, 1);
            value[8] = nodal_value(2, 2);
            value[9] = nodal_value(0, 3);
            value[10] = nodal_value(0, 5);
            value[11] = nodal_value(0, 4);
            value[12] = nodal_value(1, 3);
            value[13] = nodal_value(1, 5);
            value[14] = nodal_value(1, 4);
            value[15] = nodal_value(2, 3);
            value[16] = nodal_value(2, 5);
            value[17] = nodal_value(2, 4);
            value[18] = raw_nodal_value(nnode() - 1, 2 + 0);
            value[19] = raw_nodal_value(nnode() - 3, 2 + 0);
            value[20] = raw_nodal_value(nnode() - 2, 2 + 0);
          }
        }

        for (unsigned i = 0; i < 21; i++)
        {
          for (unsigned j = 0; j < 21; j++)
          {
            // get values wrt local coordinates
            temp[i] += value[j] * D(j, i);
          }
        }

        for (unsigned i = 0; i < 36; i++)
        {
          for (unsigned j = 0; j < 21; j++)
          {
            u_value[i] += temp[j] * B(j, i);
          }
        }

        // Assign storage for the local shape functio to a curved element
        Shape psi_curve(36), basis(36);
        DShape dpsi_curve(36, 2), d2psi_curve(36, 3), dbasis(36, 2),
          d2basis(36, 3);
        // derivative have to be wrt global coor.
        d2basis_eulerian_curve(s, psi_curve, dpsi_curve, d2psi_curve);

        for (unsigned i = 0; i < 36; i++)
        {
          interpolated_u[0] += u_value[i] * psi_curve[i];
          // Loop over directions
          for (unsigned j = 0; j < 2; j++)
          {
            interpolated_dudxi(0, j) += u_value[i] * dpsi_curve(i, j);
          }
          for (unsigned j = 0; j < 3; j++)
          {
            interpolated_d2udxi(0, j) += u_value[i] * d2psi_curve(i, j);
          }
        }
      }
    }

    //=======================================================================
    /// Return FE interpolated value u[] at local coordinate s as Vector
    // (using Lagrange interpolations)
    //=======================================================================
    void my_interpolated_u_tangential(
      const Vector<double> s,
      Vector<double>& interpolated_u,
      DenseMatrix<double>& interpolated_dudxi) const
    {
      unsigned n_node = nnode() - 3;

      // Local shape function
      Shape psi(n_node);
      DShape dpsi(n_node, 2);
      this->dbasis_c0_eulerian(s, psi, dpsi);

      // Interpolated in tangential direction
      for (unsigned l = 0; l < n_node; l++)
      {
        interpolated_u[0] += this->raw_nodal_value(l, 0) * psi[l];
        interpolated_u[1] += this->raw_nodal_value(l, 1) * psi[l];
        // Loop over directions
        for (unsigned j = 0; j < 2; j++)
        {
          interpolated_dudxi(0, j) += this->raw_nodal_value(l, 0) * dpsi(l, j);
          interpolated_dudxi(1, j) += this->raw_nodal_value(l, 1) * dpsi(l, j);
        }
      }
    }
  };

  /////////////////////////////////////////////////////////////////////////////
  /// General C1CurvedElement class  ///
  /// Empty, just establishes the template parameters
  /////////////////////////////////////////////////////////////////////
  template<unsigned DIM, unsigned NNODE_1D>
  class C1CurvedElement
  {
  };

  //=======================================================================
  /// C1CurvedElement elements, specialised to two spatial dimensions
  //=======================================================================
  template<unsigned NNODE_1D>
  class C1CurvedElement<2, NNODE_1D>
    : public virtual C1CurvedElementBase<NNODE_1D>,
      public virtual TElement<2, NNODE_1D>,
      public virtual GeometricTElement<2>,
      public virtual C1CurvedElementShape<2, NNODE_1D>,
      public virtual BellElementShape<2>
  {
  private:
    /// Nodal translation scheme for use when generating face elements
    static const unsigned NodeOnFace[3][NNODE_1D];

  public:
    ///\short  Constructor: Call constructors for C1CurvedElement
    C1CurvedElement()
      : C1CurvedElementBase<NNODE_1D>(),
        TElement<2, NNODE_1D>(),
        GeometricTElement<2>(),
        C1CurvedElementShape<2, NNODE_1D>(),
        BellElementShape<2>()
    {
      // Number of nodes
      switch (NNODE_1D)
      {
        case 2:
        case 3:
          break;

        default:
          std::string error_message =
            "Triangles are currently only implemented for\n";
          error_message +=
            "three vertices and three internal nodes, i.e. NNODE_1D=2,3 only\n";

          throw OomphLibError(error_message,
                              "CurvedTElement::CurvedTElement()",
                              OOMPH_EXCEPTION_LOCATION);
      }

      // Set the number of nodes
      unsigned n_node = (NNODE_1D * (NNODE_1D + 1)) / 2 + 3;
      this->set_n_node(n_node);
      // Set the elemental and nodal dimension
      this->set_dimension(2);
      // Set the number of types required to interpolate the coordinate
      this->set_nnodal_position_type(6);
      TGauss<2, 5>* new_integral_pt = new TGauss<2, 5>;
      this->set_integration_scheme(new_integral_pt);
    }

    /// Broken copy constructor
    C1CurvedElement(const C1CurvedElement&)
    {
      BrokenCopy::broken_copy("C1CurvedElement");
    }

    /// Broken assignment operator
    void operator=(const C1CurvedElement&)
    {
      BrokenCopy::broken_assign("C1CurvedElement");
    }
    /// Destructor
    ~C1CurvedElement() {}

    /// Number of nodes along each element edge
    unsigned nnode_1d() const
    {
      return NNODE_1D;
    }

    /// \short Number of vertex nodes in the element: One more
    /// than spatial dimension
    unsigned nvertex_node() const
    {
      return 3;
    }

    /// Number of internal nodes
    unsigned ninternal_node() const
    {
      return 3;
    }

    /// \short Pointer to the j-th vertex node in the element
    Node* vertex_node_pt(const unsigned& j) const
    {
      // Vertex nodes come first:
#ifdef PARANOID
      if (j > 2)
      {
        std::ostringstream error_message;
        error_message
          << "Element only has three vertex nodes; called with node number "
          << j << std::endl;
        throw OomphLibError(error_message.str(),
                            "TElement::vertex_node_pt()",
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif
      return this->node_pt(j);
    }

    // Classify nodes on the element: boundary nodes and non-boundary nodes
    inline void classify_boundary_node(DenseMatrix<double>& node_position,
                                       unsigned& bd_element,
                                       DenseMatrix<double>& bd_node_position,
                                       Vector<double>& x) const
    {
      /// Number of nodes along each element edge: Just for the three vertices
      /// not the internal points
      unsigned n_node = 3;
      /// Loop over vertices
      for (unsigned l = 0; l < n_node; l++)
      {
        for (unsigned k = 0; k < 1; k++)
        {
          for (unsigned j = 0; j < 2; j++)
          {
            node_position(l, j) = this->raw_nodal_position_gen(l, k, j);
          }
        }
      }

      int count = 0;

      // check whether this element is on boundary or not
      for (unsigned i = 0; i < n_node; i++)
      {
        // check whether this node is on 1st boundary (curve boundary)
        bool bd_node1 = this->node_pt(i)->is_on_boundary(1);
        if (bd_node1 == 1)
        {
          count += 1;
          for (unsigned k = 0; k < 1; k++)
          {
            for (unsigned j = 0; j < 2; j++)
            {
              bd_node_position(count - 1, j) =
                this->raw_nodal_position_gen(i, k, j);
            }
          }
        }
        else
        {
          for (unsigned k = 0; k < 1; k++)
          {
            for (unsigned j = 0; j < 2; j++)
            {
              x[j] = this->raw_nodal_position_gen(i, k, j);
            }
          }
        }
      }
      if (count == 2) // this case is a boundary element
      {
        bd_element = 1;
      }
      else
      {
        bd_element = 0;
      }
    }

    // assign the set of value for a curved element
    inline void get_value_transform_matrix(
      DenseMatrix<double>& D,
      DenseMatrix<double>& B,
      DenseMatrix<double>& node_position,
      unsigned& bd_element,
      DenseMatrix<double>& bd_node_position,
      Vector<double>& x) const
    {
      /// classify nodes in the element
      classify_boundary_node(node_position, bd_element, bd_node_position, x);
      /// compute the set of value of degree of freedom
      C1CurvedElementShape<2, NNODE_1D>::set_of_value(
        D, B, node_position, bd_element, bd_node_position, x);
    }

    /// Return local coordinates of node j
    inline void local_coordinate_of_node(const unsigned& j,
                                         Vector<double>& s) const
    {
      C1CurvedElementShape<2, NNODE_1D>::local_coordinate_of_node(j, s);
    }

    /// Calculate the c1-shape functions associated with a straight-sided
    /// boundary at local coordinate s
    inline void basis_straight(const Vector<double>& s, Shape& psi) const
    {
      /// classify nodes in the element
      DenseMatrix<double> node_position(3, 2);
      DenseMatrix<double> bd_node_position(20, 2);
      Vector<double> x(2);
      unsigned bd_element;
      classify_boundary_node(node_position, bd_element, bd_node_position, x);
      BellElementShape<2>::Bshape(s, psi, node_position);
    }

    /// \short Compute the c1-shape functions associated with a straight-sided
    /// boundary and derivatives w.r.t. global coordinates at local coordinate s
    inline void dbasis_local_straight(const Vector<double>& s,
                                      Shape& psi,
                                      DShape& dpsids) const
    {
      /// classify nodes in the element
      DenseMatrix<double> node_position(3, 2);
      DenseMatrix<double> bd_node_position(20, 2);
      Vector<double> x(2);
      unsigned bd_element;
      classify_boundary_node(node_position, bd_element, bd_node_position, x);
      BellElementShape<2>::dBshape_local(s, psi, dpsids, node_position);
    }

    /// \short Compute the c1-shape functions associated with a straight-sided
    /// boundary and derivatives w.r.t. global coordinates at local coordinate s
    inline void d2basis_local_straight(const Vector<double>& s,
                                       Shape& psi,
                                       DShape& dpsids,
                                       DShape& d2psids) const
    {
      /// classify nodes in the element
      DenseMatrix<double> node_position(3, 2);
      DenseMatrix<double> bd_node_position(20, 2);
      Vector<double> x(2);
      unsigned bd_element;
      classify_boundary_node(node_position, bd_element, bd_node_position, x);
      BellElementShape<2>::d2Bshape_local(
        s, psi, dpsids, d2psids, node_position);
    }

    /// Calculate the c1-shape functions associated with a curved-sided
    /// boundary at local coordinate s
    inline void basis_curve(const Vector<double>& s, Shape& psi) const
    {
      C1CurvedElementShape<2, NNODE_1D>::Cshape(s, psi);
    }

    /// \short Compute the c1-shape functions associated with a curved-sided
    /// boundary and derivatives w.r.t. local coordinates at local coordinate s
    inline void dbasis_local_curve(const Vector<double>& s,
                                   Shape& psi,
                                   DShape& dpsids) const
    {
      C1CurvedElementShape<2, NNODE_1D>::dCshape_local(s, psi, dpsids);
    }

    /// \short Compute the c1-shape functions associated with a curved-sided
    /// boundary and derivatives w.r.t. local coordinates at local coordinate s
    inline void d2basis_local_curve(const Vector<double>& s,
                                    Shape& psi,
                                    DShape& dpsids,
                                    DShape& d2psids) const
    {
      C1CurvedElementShape<2, NNODE_1D>::d2Cshape_local(
        s, psi, dpsids, d2psids);
    }

    /// Calculate the linear shape functions at local coordinate s
    inline void shape_geom(const Vector<double>& s,
                           Shape& psi,
                           Shape& phi) const
    {
      /// classify nodes in the element
      DenseMatrix<double> node_position(3, 2);
      DenseMatrix<double> bd_node_position(20, 2);
      Vector<double> x(2);
      unsigned bd_element;
      classify_boundary_node(node_position, bd_element, bd_node_position, x);
      // Calculate the geometric shape functions at local coordinate s
      GeometricTElement<2>::Lshape(
        s, psi, phi, node_position, bd_element, bd_node_position, x);
    }

    /// \short Compute the linear functions and
    /// derivatives w.r.t. local coordinates at local coordinate s
    inline void dshape_local_geom(const Vector<double>& s,
                                  Shape& psi,
                                  DShape& dpsids,
                                  Shape& phi,
                                  DShape& dphids) const
    {
      /// classify nodes in the element
      DenseMatrix<double> node_position(3, 2);
      DenseMatrix<double> bd_node_position(20, 2);
      Vector<double> x(2);
      unsigned bd_element;
      classify_boundary_node(node_position, bd_element, bd_node_position, x);
      GeometricTElement<2>::dLshape_local(s,
                                          psi,
                                          dpsids,
                                          phi,
                                          dphids,
                                          node_position,
                                          bd_element,
                                          bd_node_position,
                                          x);
    }

    /// \short Compute the linear functions and
    /// derivatives w.r.t. local coordinates at local coordinate s
    inline void d2shape_local_geom(const Vector<double>& s,
                                   Shape& psi,
                                   DShape& dpsids,
                                   DShape& d2psids,
                                   Shape& phi,
                                   DShape& dphids,
                                   DShape& d2phids) const
    {
      /// classify nodes in the element
      DenseMatrix<double> node_position(3, 2);
      DenseMatrix<double> bd_node_position(20, 2);
      Vector<double> x(2);
      unsigned bd_element;
      classify_boundary_node(node_position, bd_element, bd_node_position, x);
      GeometricTElement<2>::d2Lshape_local(s,
                                           psi,
                                           dpsids,
                                           d2psids,
                                           phi,
                                           dphids,
                                           d2phids,
                                           node_position,
                                           bd_element,
                                           bd_node_position,
                                           x);
    }

    /// Calculate the c0-shape functions at local coordinate s
    inline void basis_c0(const Vector<double>& s, Shape& psi) const
    {
      TElementShape<2, NNODE_1D>::shape(s, psi);
    }

    /// \short Compute the c0-shape functions and
    /// derivatives w.r.t. local coordinates at local coordinate s
    inline void dbasis_c0_local(const Vector<double>& s,
                                Shape& psi,
                                DShape& dpsids) const
    {
      TElementShape<2, NNODE_1D>::dshape_local(s, psi, dpsids);
    }

    /// \short Computer the c0-shape functions, derivatives and
    /// second derivatives w.r.t local coordinates at local coordinate s \n
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
    inline void d2basis_c0_local(const Vector<double>& s,
                                 Shape& psi,
                                 DShape& dpsids,
                                 DShape& d2psids) const
    {
      TElementShape<2, NNODE_1D>::d2shape_local(s, psi, dpsids, d2psids);
    }

    /// Calculate the test functions at local coordinate s
    inline void test(const Vector<double>& s, Shape& psi) const
    {
      TElementShape<2, NNODE_1D>::shape(s, psi);
    }

    /// \short Compute the  test functions and
    /// derivatives w.r.t. local coordinates at local coordinate s
    inline void dtest_local(const Vector<double>& s,
                            Shape& psi,
                            DShape& dpsids) const
    {
      TElementShape<2, NNODE_1D>::dshape_local(s, psi, dpsids);
    }

    /// \short Computer the geometric shape functions, derivatives and
    /// second derivatives w.r.t local coordinates at local coordinate s \n
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
    inline void d2test_local(const Vector<double>& s,
                             Shape& psi,
                             DShape& dpsids,
                             DShape& d2psids) const
    {
      TElementShape<2, NNODE_1D>::d2shape_local(s, psi, dpsids, d2psids);
    }

    /// \short Build the lower-dimensional FaceElement (an element of type
    /// SolidTElement<1,NNODE_1D>). The face index takes three possible values:
    /// 0 (Left)         s[0] = 0.0
    /// 1 (Bottom)       s[1] = 0.0
    /// 2 (Sloping face) s[0] = 1.0 - s[1]
    void build_face_element(const int& face_index,
                            FaceElement* face_element_pt);
  };

  //===========================================================
  /// Function to setup geometrical information for lower-dimensional
  /// FaceElements (which are of type TElement<1,NNODE_1D>).
  //===========================================================
  template<unsigned NNODE_1D>
  void C1CurvedElement<2, NNODE_1D>::build_face_element(
    const int& face_index, FaceElement* face_element_pt)
  {
    // Build the standard non-solid FaceElement
    TElement<2, NNODE_1D>::build_face_element(face_index, face_element_pt);
  }

  //=======================================================================
  /// Face geometry for the 2D C1CurvedElement elements is exactly
  /// the same as for the corresponding TElement. The spatial
  /// dimension of the face elements is one lower than that of the
  /// bulk element but they have the same number of points
  /// along their 1D edges.
  //=======================================================================
  template<unsigned NNODE_1D>
  class FaceGeometry<C1CurvedElement<2, NNODE_1D>>
    : public virtual TElement<1, NNODE_1D>
  {
  public:
    /// \short Constructor: Call the constructor for the
    /// appropriate lower-dimensional QElement
    FaceGeometry() : TElement<1, NNODE_1D>() {}
  };


} // namespace oomph
#endif
