//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC// Copyright (C) 2006-2021 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//Header functions for classes that define Subparametric_Telements
#ifndef OOMPH_SUBPARAMETRIC_TELEMENT_HEADER
#define OOMPH_SUBPARAMETRIC_TELEMENT_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#ifdef OOMPH_HAS_MPI
#include "mpi.h"
#endif

//oomph-lib headers
#include "Vector.h"
#include "shape.h"
#include "integral.h"
#include "elements.h"
#include "Telements.h"
 
namespace oomph
{

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
/// BellElementShape
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

//========================================================================
/// A class for Bell triangular shape function with 3 vertex nodes and
/// WITHOUT 3 middle-side node
//========================================================================
template<unsigned DIM>
 class BellElementShape { };

template<>
 class BellElementShape<2>
 {
   public:
//=======================================================================
/// Return local coordinates of node j
//=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s) const
   {
    switch (j)
     {
     case 0:
      s[0]=1.0;
      s[1]=0.0;
      break;
      
     case 1:
      s[0]=0.0;
      s[1]=1.0;
      break;
      
     case 2:
      s[0]=0.0;
      s[1]=0.0;
      break;
      
     default:
      std::ostringstream error_message;
      error_message << "Element only has three nodes; called with node number " 
                    << j << std::endl;
      
      throw OomphLibError(error_message.str(),
                          "BellElement::local_coordinate_of_node()",
                          OOMPH_EXCEPTION_LOCATION);
     }
   }
   
  void Bshape(const Vector<double> &s, Shape &psi, DenseMatrix<double> &position) const
   {
    //---------------------------------------------
    // the mapping to physical coordinates 
    //----------------------------------------------
    Vector<double> phi(2);
    phi[0] = position(2,0) + (position(0,0) - position(2,0))*s[0] + (position(1,0) - position(2,0))*s[1];
    phi[1] = position(2,1) + (position(0,1) - position(2,1))*s[0] + (position(1,1) - position(2,1))*s[1];
    
    double A = ( (position(1,0)*position(2,1)-position(2,0)*position(1,1)) - (position(0,0)*position(2,1)-position(2,0)*position(0,1)) + (position(0,0)*position(1,1)-position(1,0)*position(0,1)))/2.0;
    double A0 = ( (position(1,0)*position(2,1)-position(2,0)*position(1,1)) - (phi[0]*position(2,1)-position(2,0)*phi[1]) + (phi[0]*position(1,1)-position(1,0)*phi[1]))/2.0;
    double A1 = ( (phi[0]*position(2,1)-position(2,0)*phi[1]) - (position(0,0)*position(2,1)-position(2,0)*position(0,1)) + (position(0,0)*phi[1]-phi[0]*position(0,1)))/2.0;
    double A2 = ( (position(1,0)*phi[1]-phi[0]*position(1,1)) - (position(0,0)*phi[1]-phi[0]*position(0,1)) + (position(0,0)*position(1,1)-position(1,0)*position(0,1)))/2.0;
    // assigned area coordinates
    Vector<double> xi(3);
    xi[0] = A0/A;
    xi[1] = A1/A;
    xi[2] = A2/A;

    Vector<double> b(3);
    Vector<double> c(3);
    Vector<double> lamb(3);
    Vector<double> lamb_p(3);
    Vector<double> pp(2);
    Vector<double> a(2),cc(2);
    
    //compute for b and c
    b[1] = position(0,0)-position(2,0);
    b[2] = position(1,0)-position(0,0);
    b[0] = position(2,0)-position(1,0);

    c[1] = position(2,1)-position(0,1);
    c[2] = position(0,1)-position(1,1);
    c[0] = position(1,1)-position(2,1);
    
    //compute for a point of perpendicular
    // on the edge opposite to node0 (top vertex)
    Vector<double> v(2);
    v[0] = (position(2,0)-position(1,0));
    v[1] = (position(2,1)-position(1,1));
    double m = v[1]/v[0];
    a[0] = position(1,0);
    a[1] = position(1,1);
    cc[0] = position(0,0);
    cc[1] = position(0,1);
    if(v[0]==0)
     {
      m = v[0]/v[1];
      pp[1] = ( v[0]*m*a[1] + v[1]*cc[1] - v[0]*a[0] + v[0]*cc[0] )/((v[0]*m)+v[1]);
      pp[0] = (pp[1]-a[1])*m + a[0];
     }
    else
     {
      pp[0] = (v[1]*m*a[0] + v[1]*cc[1] - v[1]*a[1] + v[0]*cc[0])/(v[1]*m+v[0]);
      pp[1] = m*(pp[0]-a[0]) + a[1];
     }
    double l = sqrt(v[0]*v[0] + v[1]*v[1]);
    double l1 = sqrt( (pp[0]-a[0])*(pp[0]-a[0]) + (pp[1]-a[1])*(pp[1]-a[1]));
    lamb_p[0] = l1/l;
    lamb[0] = 1-lamb_p[0];
    
    // on the edge opposite to node1
    v[0] = (position(0,0)-position(2,0));
    v[1] = (position(0,1)-position(2,1));
    m = v[1]/v[0];
    a[0] = position(2,0);
    a[1] = position(2,1);
    cc[0] = position(1,0);
    cc[1] = position(1,1);
    if(v[0]==0)
     {
      m = v[0]/v[1];
      pp[1] = ( v[0]*m*a[1] + v[1]*cc[1] - v[0]*a[0] + v[0]*cc[0] )/((v[0]*m)+v[1]);
      pp[0] = (pp[1]-a[1])*m + a[0];
     }
    else
     {
      pp[0] = (v[1]*m*a[0] + v[1]*cc[1] - v[1]*a[1] + v[0]*cc[0])/(v[1]*m+v[0]);
      pp[1] = m*(pp[0]-a[0]) + a[1];
     }
    l = sqrt(v[0]*v[0] + v[1]*v[1]);
    l1 = sqrt( (pp[0]-a[0])*(pp[0]-a[0]) + (pp[1]-a[1])*(pp[1]-a[1]));
    lamb_p[1] = l1/l;
    lamb[1] = 1-lamb_p[1];
    
    // on the edge opposite to node2 (right bottom)
    v[0] = (position(1,0)-position(0,0));
    v[1] = (position(1,1)-position(0,1));
    m = v[1]/v[0];
    a[0] = position(0,0);
    a[1] = position(0,1);
    cc[0] = position(2,0);
    cc[1] = position(2,1);
    if(v[0]==0)
     {
      m = v[0]/v[1];
      pp[1] = ( v[0]*m*a[1] + v[1]*cc[1] - v[0]*a[0] + v[0]*cc[0] )/((v[0]*m)+v[1]);
      pp[0] = (pp[1]-a[1])*m + a[0];
     }
    else
     {
      pp[0] = (v[1]*m*a[0] + v[1]*cc[1] - v[1]*a[1] + v[0]*cc[0])/(v[1]*m+v[0]);
      pp[1] = m*(pp[0]-a[0]) + a[1];
     }
    l = sqrt(v[0]*v[0] + v[1]*v[1]);
    l1 = sqrt( (pp[0]-a[0])*(pp[0]-a[0]) + (pp[1]-a[1])*(pp[1]-a[1]));
    lamb_p[2] = l1/l;
    lamb[2] = 1-lamb_p[2];

    // define shape functions that associated to dofs at node 0
    psi(0,0) = xi[0]*xi[0]*xi[0]*xi[0]*xi[0] +5.0*xi[0]*xi[0]*xi[0]*xi[0]*(xi[1]+xi[2]) + 10.0*xi[0]*xi[0]*xi[0]*(xi[1]+xi[2])*(xi[1]+xi[2])
     +30.0*xi[0]*xi[0]*xi[1]*xi[2]*(lamb[2]*xi[1] + lamb_p[1]*xi[2]);
    psi(0,1) = 3.0*b[0]*xi[0]*xi[0]*xi[1]*xi[2]*(xi[1]-xi[2]) +  xi[0]*xi[0]*xi[0]*(b[2]*xi[1] -b[1]*xi[2])*(xi[0] + 4.0*xi[1] + 4*xi[2])
     + 15*xi[0]*xi[0]*xi[1]*xi[2]*(b[2]*lamb[2]*xi[1] - b[1]*lamb_p[1]*xi[2]);
    psi(0,2) =  -3.0*c[0]*xi[0]*xi[0]*xi[1]*xi[2]*(xi[1]-xi[2]) - xi[0]*xi[0]*xi[0]*(c[2]*xi[1] - c[1]*xi[2])*(xi[0] + 4.0*xi[1] + 4.0*xi[2])
     -15.0*xi[0]*xi[0]*xi[1]*xi[2]*(c[2]*lamb[2]*xi[1] -c[1]*lamb_p[1]*xi[2]);
    psi(0,3) = 1.0/2.0*xi[0]*xi[0]*xi[0]*(b[2]*b[2]*xi[1]*xi[1] + b[1]*b[1]*xi[2]*xi[2]) + xi[0]*xi[0]*xi[1]*xi[2]*(-b[1]*b[2]*xi[0] + b[2]*b[0]*xi[1] + b[0]*b[1]*xi[2])
     + 5.0/2.0*xi[0]*xi[0]*xi[1]*xi[2]*(b[2]*b[2]*lamb[2]*xi[1] + b[1]*b[1]*lamb_p[1]*xi[2]);
    psi(0,4) = 1.0/2.0*xi[0]*xi[0]*xi[0]*(c[2]*c[2]*xi[1]*xi[1] + c[1]*c[1]*xi[2]*xi[2]) + xi[0]*xi[0]*xi[1]*xi[2]*(-c[1]*c[2]*xi[0] + c[2]*c[0]*xi[1] + c[0]*c[1]*xi[2])
     + 5.0/2.0*xi[0]*xi[0]*xi[1]*xi[2]*(c[2]*c[2]*lamb[2]*xi[1] + c[1]*c[1]*lamb_p[1]*xi[2]);
    psi(0,5) = b[0]*c[0]*xi[0]*xi[0]*xi[1]*xi[2]*(xi[0] + xi[1] + xi[2]) + b[1]*c[1]*xi[0]*xi[0]*xi[2]*(xi[1]*xi[2] - xi[2]*xi[0] - xi[0]*xi[1] - xi[1]*xi[1])
     + b[2]*c[2]*xi[0]*xi[0]*xi[1]*(xi[1]*xi[2] - xi[2]*xi[0] -xi[0]*xi[1] - xi[2]*xi[2]) - 5.0*xi[0]*xi[0]*xi[1]*xi[2]*(b[1]*c[1]*lamb_p[1]*xi[2] + b[2]*c[2]*lamb[2]*xi[1]);

    // define shape functions that associated to dofs at node 1
    psi(1,0) = xi[1]*xi[1]*xi[1]*xi[1]*xi[1] +5.0*xi[1]*xi[1]*xi[1]*xi[1]*(xi[2]+xi[0]) + 10.0*xi[1]*xi[1]*xi[1]*(xi[2]+xi[0])*(xi[2]+xi[0])
     +30.0*xi[1]*xi[1]*xi[2]*xi[0]*(lamb[0]*xi[2] + lamb_p[2]*xi[0]);
    psi(1,1) = 3.0*b[1]*xi[1]*xi[1]*xi[2]*xi[0]*(xi[2]-xi[0]) +  xi[1]*xi[1]*xi[1]*(b[0]*xi[2] -b[2]*xi[0])*(xi[1] + 4.0*xi[2] + 4*xi[0])
     + 15*xi[1]*xi[1]*xi[2]*xi[0]*(b[0]*lamb[0]*xi[2] - b[2]*lamb_p[2]*xi[0]);
    psi(1,2) =  -3.0*c[1]*xi[1]*xi[1]*xi[2]*xi[0]*(xi[2]-xi[0]) - xi[1]*xi[1]*xi[1]*(c[0]*xi[2] - c[2]*xi[0])*(xi[1] + 4.0*xi[2] + 4.0*xi[0])
     -15.0*xi[1]*xi[1]*xi[2]*xi[0]*(c[0]*lamb[0]*xi[2] -c[2]*lamb_p[2]*xi[0]);
    psi(1,3) = 1.0/2.0*xi[1]*xi[1]*xi[1]*(b[0]*b[0]*xi[2]*xi[2] + b[2]*b[2]*xi[0]*xi[0]) + xi[1]*xi[1]*xi[2]*xi[0]*(-b[2]*b[0]*xi[1] + b[0]*b[1]*xi[2] + b[1]*b[2]*xi[0])
     + 5.0/2.0*xi[1]*xi[1]*xi[2]*xi[0]*(b[0]*b[0]*lamb[0]*xi[2] + b[2]*b[2]*lamb_p[2]*xi[0]);
    psi(1,4) = 1.0/2.0*xi[1]*xi[1]*xi[1]*(c[0]*c[0]*xi[2]*xi[2] + c[2]*c[2]*xi[0]*xi[0]) + xi[1]*xi[1]*xi[2]*xi[0]*(-c[2]*c[0]*xi[1] + c[0]*c[1]*xi[2] + c[1]*c[2]*xi[0])
     + 5.0/2.0*xi[1]*xi[1]*xi[2]*xi[0]*(c[0]*c[0]*lamb[0]*xi[2] + c[2]*c[2]*lamb_p[2]*xi[0]);
    psi(1,5) = b[1]*c[1]*xi[1]*xi[1]*xi[2]*xi[0]*(xi[1] + xi[2] + xi[0]) + b[2]*c[2]*xi[1]*xi[1]*xi[0]*(xi[2]*xi[0] - xi[0]*xi[1] - xi[1]*xi[2] - xi[2]*xi[2])
     + b[0]*c[0]*xi[1]*xi[1]*xi[2]*(xi[2]*xi[0] - xi[0]*xi[1] -xi[1]*xi[2] - xi[0]*xi[0]) - 5.0*xi[1]*xi[1]*xi[2]*xi[0]*(b[2]*c[2]*lamb_p[2]*xi[0] + b[0]*c[0]*lamb[0]*xi[2]);

    // define shape functions that associated to dofs at node 2
    psi(2,0) = xi[2]*xi[2]*xi[2]*xi[2]*xi[2] +5.0*xi[2]*xi[2]*xi[2]*xi[2]*(xi[0]+xi[1]) + 10.0*xi[2]*xi[2]*xi[2]*(xi[0]+xi[1])*(xi[0]+xi[1])
     +30.0*xi[2]*xi[2]*xi[0]*xi[1]*(lamb[1]*xi[0] + lamb_p[0]*xi[1]);
    psi(2,1) = 3.0*b[2]*xi[2]*xi[2]*xi[0]*xi[1]*(xi[0]-xi[1]) +  xi[2]*xi[2]*xi[2]*(b[1]*xi[0] -b[0]*xi[1])*(xi[2] + 4.0*xi[0] + 4*xi[1])
     + 15*xi[2]*xi[2]*xi[0]*xi[1]*(b[1]*lamb[1]*xi[0] - b[0]*lamb_p[0]*xi[1]);
    psi(2,2) =  -3.0*c[2]*xi[2]*xi[2]*xi[0]*xi[1]*(xi[0]-xi[1]) - xi[2]*xi[2]*xi[2]*(c[1]*xi[0] - c[0]*xi[1])*(xi[2] + 4.0*xi[0] + 4.0*xi[1])
     -15.0*xi[2]*xi[2]*xi[0]*xi[1]*(c[1]*lamb[1]*xi[0] -c[0]*lamb_p[0]*xi[1]);
    psi(2,3) = 1.0/2.0*xi[2]*xi[2]*xi[2]*(b[1]*b[1]*xi[0]*xi[0] + b[0]*b[0]*xi[1]*xi[1]) + xi[2]*xi[2]*xi[0]*xi[1]*(-b[0]*b[1]*xi[2] + b[1]*b[2]*xi[0] + b[2]*b[0]*xi[1])
     + 5.0/2.0*xi[2]*xi[2]*xi[0]*xi[1]*(b[1]*b[1]*lamb[1]*xi[0] + b[0]*b[0]*lamb_p[0]*xi[1]);
    psi(2,4) = 1.0/2.0*xi[2]*xi[2]*xi[2]*(c[1]*c[1]*xi[0]*xi[0] + c[0]*c[0]*xi[1]*xi[1]) + xi[2]*xi[2]*xi[0]*xi[1]*(-c[0]*c[1]*xi[2] + c[1]*c[2]*xi[0] + c[2]*c[0]*xi[1])
     + 5.0/2.0*xi[2]*xi[2]*xi[0]*xi[1]*(c[1]*c[1]*lamb[1]*xi[0] + c[0]*c[0]*lamb_p[0]*xi[1]);
    psi(2,5) = b[2]*c[2]*xi[2]*xi[2]*xi[0]*xi[1]*(xi[2] + xi[0] + xi[1]) + b[0]*c[0]*xi[2]*xi[2]*xi[1]*(xi[0]*xi[1] - xi[1]*xi[2] - xi[2]*xi[0] - xi[0]*xi[0])
     + b[1]*c[1]*xi[2]*xi[2]*xi[0]*(xi[0]*xi[1] - xi[1]*xi[2] -xi[2]*xi[0] - xi[1]*xi[1]) - 5.0*xi[2]*xi[2]*xi[0]*xi[1]*(b[0]*c[0]*lamb_p[0]*xi[1] + b[1]*c[1]*lamb[1]*xi[0]);
   
   }

   void dBshape_local(const Vector<double> &s, Shape &psi, DShape &dpsids, DenseMatrix<double> &position) const
   {
    // assign for shape functions
    Bshape(s,psi,position);
    //---------------------------------------------
    // the mapping to physical coordinates 
    //----------------------------------------------
    Vector<double> phi(2);
    phi[0] = position(2,0) + (position(0,0) - position(2,0))*s[0] + (position(1,0) - position(2,0))*s[1];
    phi[1] = position(2,1) + (position(0,1) - position(2,1))*s[0] + (position(1,1) - position(2,1))*s[1];
    
    double A = ( (position(1,0)*position(2,1)-position(2,0)*position(1,1)) - (position(0,0)*position(2,1)-position(2,0)*position(0,1)) + (position(0,0)*position(1,1)-position(1,0)*position(0,1)))/2.0;
    double A0, A1, A2;
    A0 = ( (position(1,0)*position(2,1)-position(2,0)*position(1,1)) - (phi[0]*position(2,1)-position(2,0)*phi[1]) + (phi[0]*position(1,1)-position(1,0)*phi[1]))/2.0;
    A1 = ( (phi[0]*position(2,1)-position(2,0)*phi[1]) - (position(0,0)*position(2,1)-position(2,0)*position(0,1)) + (position(0,0)*phi[1]-phi[0]*position(0,1)))/2.0;
    A2 = ( (position(1,0)*phi[1]-phi[0]*position(1,1)) - (position(0,0)*phi[1]-phi[0]*position(0,1)) + (position(0,0)*position(1,1)-position(1,0)*position(0,1)))/2.0;
    
    // assigned area coordinates
    Vector<double> xi(3);
    xi[0] = A0/A;
    xi[1] = A1/A;
    xi[2] = A2/A;

    Vector<double> b(3);
    Vector<double> c(3);
    Vector<double> lamb(3);
    Vector<double> lamb_p(3);
    Vector<double> pp(2);
    Vector<double> a(2),cc(2);
    
    //compute for b and c
    b[1] = position(0,0)-position(2,0);
    b[2] = position(1,0)-position(0,0);
    b[0] = position(2,0)-position(1,0);

    c[1] = position(2,1)-position(0,1);
    c[2] = position(0,1)-position(1,1);
    c[0] = position(1,1)-position(2,1);
    
    //compute for a point of perpendicular
    // on the edge opposite to node0 (top vertex)
    Vector<double> v(2);
    v[0] = (position(2,0)-position(1,0));
    v[1] = (position(2,1)-position(1,1));
    double m = v[1]/v[0];
    a[0] = position(1,0);
    a[1] = position(1,1);
    cc[0] = position(0,0);
    cc[1] = position(0,1);
    if(v[0]==0)
     {
      m = v[0]/v[1];
      pp[1] = ( v[0]*m*a[1] + v[1]*cc[1] - v[0]*a[0] + v[0]*cc[0] )/((v[0]*m)+v[1]);
      pp[0] = (pp[1]-a[1])*m + a[0];
     }
    else
     {
      pp[0] = (v[1]*m*a[0] + v[1]*cc[1] - v[1]*a[1] + v[0]*cc[0])/(v[1]*m+v[0]);
      pp[1] = m*(pp[0]-a[0]) + a[1];
     }
    double l = sqrt(v[0]*v[0] + v[1]*v[1]);
    double l1 = sqrt( (pp[0]-a[0])*(pp[0]-a[0]) + (pp[1]-a[1])*(pp[1]-a[1]));
    lamb_p[0] = l1/l;
    lamb[0] = 1-lamb_p[0];
    
    // on the edge opposite to node1
    v[0] = (position(0,0)-position(2,0));
    v[1] = (position(0,1)-position(2,1));
    m = v[1]/v[0];
    a[0] = position(2,0);
    a[1] = position(2,1);
    cc[0] = position(1,0);
    cc[1] = position(1,1);
    if(v[0]==0)
     {
      m = v[0]/v[1];
      pp[1] = ( v[0]*m*a[1] + v[1]*cc[1] - v[0]*a[0] + v[0]*cc[0] )/((v[0]*m)+v[1]);
      pp[0] = (pp[1]-a[1])*m + a[0];
     }
    else
     {
      pp[0] = (v[1]*m*a[0] + v[1]*cc[1] - v[1]*a[1] + v[0]*cc[0])/(v[1]*m+v[0]);
      pp[1] = m*(pp[0]-a[0]) + a[1];
     }
    l = sqrt(v[0]*v[0] + v[1]*v[1]);
    l1 = sqrt( (pp[0]-a[0])*(pp[0]-a[0]) + (pp[1]-a[1])*(pp[1]-a[1]));
    lamb_p[1] = l1/l;
    lamb[1] = 1-lamb_p[1];
    
    // on the edge opposite to node2 (right bottom)
    v[0] = (position(1,0)-position(0,0));
    v[1] = (position(1,1)-position(0,1));
    m = v[1]/v[0];
    a[0] = position(0,0);
    a[1] = position(0,1);
    cc[0] = position(2,0);
    cc[1] = position(2,1);
    if(v[0]==0)
     {
      m = v[0]/v[1];
      pp[1] = ( v[0]*m*a[1] + v[1]*cc[1] - v[0]*a[0] + v[0]*cc[0] )/((v[0]*m)+v[1]);
      pp[0] = (pp[1]-a[1])*m + a[0];
     }
    else
     {
      pp[0] = (v[1]*m*a[0] + v[1]*cc[1] - v[1]*a[1] + v[0]*cc[0])/(v[1]*m+v[0]);
      pp[1] = m*(pp[0]-a[0]) + a[1];
     }
    l = sqrt(v[0]*v[0] + v[1]*v[1]);
    l1 = sqrt( (pp[0]-a[0])*(pp[0]-a[0]) + (pp[1]-a[1])*(pp[1]-a[1]));
    lamb_p[2] = l1/l;
    lamb[2] = 1-lamb_p[2];
    
   
    Vector<double> dxids0(3,0.0);
    Vector<double> dxids1(3,0.0);
     
    dxids0[0] = c[0]/A/2.0;
    dxids0[1] = c[1]/A/2.0;
    dxids0[2] = c[2]/A/2.0;
    
    dxids1[0] = b[0]/A/2.0;
    dxids1[1] = b[1]/A/2.0;
    dxids1[2] = b[2]/A/2.0;
    
    DShape psi1(3,6,3);
    // define dshape functions that associated to dofs at node 0
    psi1(0,0,0) = 5.0*xi[0]*xi[0]*xi[0]*xi[0] + 5.0*4.0*xi[0]*xi[0]*xi[0]*(xi[1]+xi[2]) + 10.0*3.0*xi[0]*xi[0]*(xi[1]+xi[2])*(xi[1]+xi[2])
     +30.0*2.0*xi[0]*xi[1]*xi[2]*(lamb[2]*xi[1] + lamb_p[1]*xi[2]);
    psi1(0,1,0) = 3.0*b[0]*2.0*xi[0]*xi[1]*xi[2]*(xi[1]-xi[2]) +  3.0*xi[0]*xi[0]*(b[2]*xi[1] -b[1]*xi[2])*(xi[0] + 4.0*xi[1] + 4.0*xi[2]) 
     + xi[0]*xi[0]*xi[0]*(b[2]*xi[1] -b[1]*xi[2]) + 15*2.0*xi[0]*xi[1]*xi[2]*(b[2]*lamb[2]*xi[1] - b[1]*lamb_p[1]*xi[2]);
    psi1(0,2,0) = -3.0*c[0]*2.0*xi[0]*xi[1]*xi[2]*(xi[1]-xi[2]) - 3.0*xi[0]*xi[0]*(c[2]*xi[1] - c[1]*xi[2])*(xi[0] + 4.0*xi[1] + 4.0*xi[2]) - xi[0]*xi[0]*xi[0]*(c[2]*xi[1] - c[1]*xi[2]) 
     -15.0*2.0*xi[0]*xi[1]*xi[2]*(c[2]*lamb[2]*xi[1] -c[1]*lamb_p[1]*xi[2]);
    psi1(0,3,0) = 1.0/2.0*3.0*xi[0]*xi[0]*(b[2]*b[2]*xi[1]*xi[1] + b[1]*b[1]*xi[2]*xi[2]) + 2.0*xi[0]*xi[1]*xi[2]*(-b[1]*b[2]*xi[0] + b[2]*b[0]*xi[1] + b[0]*b[1]*xi[2])
     + 5.0/2.0*2.0*xi[0]*xi[1]*xi[2]*(b[2]*b[2]*lamb[2]*xi[1] + b[1]*b[1]*lamb_p[1]*xi[2]) + xi[0]*xi[0]*xi[1]*xi[2]*(-b[1]*b[2]);
    psi1(0,4,0) = 1.0/2.0*3.0*xi[0]*xi[0]*(c[2]*c[2]*xi[1]*xi[1] + c[1]*c[1]*xi[2]*xi[2]) + 2.0*xi[0]*xi[1]*xi[2]*(-c[1]*c[2]*xi[0] + c[2]*c[0]*xi[1] + c[0]*c[1]*xi[2])
     + 5.0/2.0*2.0*xi[0]*xi[1]*xi[2]*(c[2]*c[2]*lamb[2]*xi[1] + c[1]*c[1]*lamb_p[1]*xi[2])+ xi[0]*xi[0]*xi[1]*xi[2]*(-c[1]*c[2]);
    psi1(0,5,0) = b[0]*c[0]*2.0*xi[0]*xi[1]*xi[2]*(xi[0] + xi[1] + xi[2]) + b[0]*c[0]*xi[0]*xi[0]*xi[1]*xi[2] + b[1]*c[1]*2.0*xi[0]*xi[2]*(xi[1]*xi[2] - xi[2]*xi[0] - xi[0]*xi[1] - xi[1]*xi[1]) 
     + b[1]*c[1]*xi[0]*xi[0]*xi[2]*(-xi[1] - xi[2]) + b[2]*c[2]*2.0*xi[0]*xi[1]*(xi[1]*xi[2] - xi[2]*xi[0] -xi[0]*xi[1] - xi[2]*xi[2]) 
     + b[2]*c[2]*xi[0]*xi[0]*xi[1]*(-xi[2]-xi[1]) - 5.0*2.0*xi[0]*xi[1]*xi[2]*(b[1]*c[1]*lamb_p[1]*xi[2] + b[2]*c[2]*lamb[2]*xi[1]);
    
    psi1(0,0,1) = 5.0*xi[0]*xi[0]*xi[0]*xi[0] + 10.0*xi[0]*xi[0]*xi[0]*2.0*(xi[1]+xi[2])
     +30.0*xi[0]*xi[0]*xi[2]*(lamb[2]*xi[1] + lamb_p[1]*xi[2])+30.0*xi[0]*xi[0]*xi[1]*xi[2]*(lamb[2]);
    psi1(0,1,1) = 3.0*b[0]*xi[0]*xi[0]*xi[2]*(xi[1]-xi[2])+ 3.0*b[0]*xi[0]*xi[0]*xi[1]*xi[2] + xi[0]*xi[0]*xi[0]*(b[2])*(xi[0] + 4.0*xi[1] + 4*xi[2])
     + xi[0]*xi[0]*xi[0]*(b[2]*xi[1] -b[1]*xi[2])*(4.0) + 15*xi[0]*xi[0]*xi[2]*(b[2]*lamb[2]*xi[1] - b[1]*lamb_p[1]*xi[2]) +15*xi[0]*xi[0]*xi[1]*xi[2]*(b[2]*lamb[2]);
    psi1(0,2,1) = -3.0*c[0]*xi[0]*xi[0]*xi[2]*(xi[1]-xi[2]) - 3.0*c[0]*xi[0]*xi[0]*xi[1]*xi[2] - xi[0]*xi[0]*xi[0]*(c[2]*xi[1] - c[1]*xi[2])*(4.0) - xi[0]*xi[0]*xi[0]*(c[2])*(xi[0] + 4.0*xi[1] + 4.0*xi[2]) -15.0*xi[0]*xi[0]*xi[1]*xi[2]*(c[2]*lamb[2])
     -15.0*xi[0]*xi[0]*xi[2]*(c[2]*lamb[2]*xi[1] -c[1]*lamb_p[1]*xi[2]);
    psi1(0,3,1) = 1.0/2.0*xi[0]*xi[0]*xi[0]*(b[2]*b[2]*2.0*xi[1]) + xi[0]*xi[0]*xi[1]*xi[2]*(b[2]*b[0]) + xi[0]*xi[0]*xi[2]*(-b[1]*b[2]*xi[0] + b[2]*b[0]*xi[1] + b[0]*b[1]*xi[2])  + 5.0/2.0*xi[0]*xi[0]*xi[1]*xi[2]*(b[2]*b[2]*lamb[2]) + 5.0/2.0*xi[0]*xi[0]*xi[2]*(b[2]*b[2]*lamb[2]*xi[1] + b[1]*b[1]*lamb_p[1]*xi[2]);
    psi1(0,4,1) = 1.0/2.0*xi[0]*xi[0]*xi[0]*(c[2]*c[2]*2.0*xi[1]) + xi[0]*xi[0]*xi[1]*xi[2]*(c[2]*c[0]) + xi[0]*xi[0]*xi[2]*(-c[1]*c[2]*xi[0] + c[2]*c[0]*xi[1] + c[0]*c[1]*xi[2])+ 5.0/2.0*xi[0]*xi[0]*xi[1]*xi[2]*(c[2]*c[2]*lamb[2])  + 5.0/2.0*xi[0]*xi[0]*xi[2]*(c[2]*c[2]*lamb[2]*xi[1] + c[1]*c[1]*lamb_p[1]*xi[2]);
    psi1(0,5,1) = b[0]*c[0]*xi[0]*xi[0]*xi[1]*xi[2] + b[0]*c[0]*xi[0]*xi[0]*xi[2]*(xi[0] + xi[1] + xi[2]) + b[1]*c[1]*xi[0]*xi[0]*xi[2]*(xi[2] - xi[0] - 2.0*xi[1])
     + b[2]*c[2]*xi[0]*xi[0]*(xi[1]*xi[2] - xi[2]*xi[0] -xi[0]*xi[1] - xi[2]*xi[2]) + b[2]*c[2]*xi[0]*xi[0]*xi[1]*(xi[2]-xi[0]) - 5.0*xi[0]*xi[0]*xi[2]*(b[1]*c[1]*lamb_p[1]*xi[2] + b[2]*c[2]*lamb[2]*xi[1])
     - 5.0*xi[0]*xi[0]*xi[1]*xi[2]*(b[2]*c[2]*lamb[2]);

    psi1(0,0,2) = 5.0*xi[0]*xi[0]*xi[0]*xi[0] + 10.0*xi[0]*xi[0]*xi[0]*2.0*(xi[1]+xi[2])
     +30.0*xi[0]*xi[0]*xi[1]*xi[2]*(lamb_p[1])  +30.0*xi[0]*xi[0]*xi[1]*(lamb[2]*xi[1] + lamb_p[1]*xi[2]);
    psi1(0,1,2) = 3.0*b[0]*xi[0]*xi[0]*xi[1]*xi[2]*(-1.0) + 3.0*b[0]*xi[0]*xi[0]*xi[1]*(xi[1]-xi[2]) +  xi[0]*xi[0]*xi[0]*(b[2]*xi[1] -b[1]*xi[2])*( 4.0)+  xi[0]*xi[0]*xi[0]*(-b[1])*(xi[0] + 4.0*xi[1] + 4*xi[2]) + 15*xi[0]*xi[0]*xi[1]*xi[2]*(- b[1]*lamb_p[1])
     + 15*xi[0]*xi[0]*xi[1]*(b[2]*lamb[2]*xi[1] - b[1]*lamb_p[1]*xi[2]);
    psi1(0,2,2) =  -3.0*c[0]*xi[0]*xi[0]*xi[1]*xi[2]*(-1.0) +  -3.0*c[0]*xi[0]*xi[0]*xi[1]*(xi[1]-xi[2]) - xi[0]*xi[0]*xi[0]*(c[2]*xi[1] - c[1]*xi[2])*( 4.0) - xi[0]*xi[0]*xi[0]*(-1.0*c[1])*(xi[0] + 4.0*xi[1] + 4.0*xi[2]) -15.0*xi[0]*xi[0]*xi[1]*xi[2]*( -1.0*c[1]*lamb_p[1]) -15.0*xi[0]*xi[0]*xi[1]*(c[2]*lamb[2]*xi[1] -c[1]*lamb_p[1]*xi[2]);
    psi1(0,3,2) = 1.0/2.0*xi[0]*xi[0]*xi[0]*(b[1]*b[1]*2.0*xi[2]) + xi[0]*xi[0]*xi[1]*xi[2]*( b[0]*b[1]) + xi[0]*xi[0]*xi[1]*(-b[1]*b[2]*xi[0] + b[2]*b[0]*xi[1] + b[0]*b[1]*xi[2]) + 5.0/2.0*xi[0]*xi[0]*xi[1]*xi[2]*( b[1]*b[1]*lamb_p[1])+ 5.0/2.0*xi[0]*xi[0]*xi[1]*(b[2]*b[2]*lamb[2]*xi[1] + b[1]*b[1]*lamb_p[1]*xi[2]);
    psi1(0,4,2) = 1.0/2.0*xi[0]*xi[0]*xi[0]*(c[1]*c[1]*2.0*xi[2]) + xi[0]*xi[0]*xi[1]*xi[2]*(c[0]*c[1]) + xi[0]*xi[0]*xi[1]*(-c[1]*c[2]*xi[0] + c[2]*c[0]*xi[1] + c[0]*c[1]*xi[2])  + 5.0/2.0*xi[0]*xi[0]*xi[1]*xi[2]*(c[1]*c[1]*lamb_p[1]) + 5.0/2.0*xi[0]*xi[0]*xi[1]*(c[2]*c[2]*lamb[2]*xi[1] + c[1]*c[1]*lamb_p[1]*xi[2]);
    psi1(0,5,2) = b[0]*c[0]*xi[0]*xi[0]*xi[1]*xi[2] + b[0]*c[0]*xi[0]*xi[0]*xi[1]*(xi[0] + xi[1] + xi[2]) + b[1]*c[1]*xi[0]*xi[0]*xi[2]*(xi[1] - xi[0]) + b[1]*c[1]*xi[0]*xi[0]*(xi[1]*xi[2] - xi[2]*xi[0] - xi[0]*xi[1] - xi[1]*xi[1]) + b[2]*c[2]*xi[0]*xi[0]*xi[1]*(xi[1] - xi[0] - 2.0*xi[2]) - 5.0*xi[0]*xi[0]*xi[1]*xi[2]*(b[1]*c[1]*lamb_p[1])
     - 5.0*xi[0]*xi[0]*xi[1]*(b[1]*c[1]*lamb_p[1]*xi[2] + b[2]*c[2]*lamb[2]*xi[1]);
    
    // by chain rule, we can obtain dshape wrt s0 at node0
    dpsids(0,0,0) = psi1(0,0,0)*dxids0[0] + psi1(0,0,1)*dxids0[1] + psi1(0,0,2)*dxids0[2];
    dpsids(0,1,0) = psi1(0,1,0)*dxids0[0] + psi1(0,1,1)*dxids0[1] + psi1(0,1,2)*dxids0[2];
    dpsids(0,2,0) = psi1(0,2,0)*dxids0[0] + psi1(0,2,1)*dxids0[1] + psi1(0,2,2)*dxids0[2];
    dpsids(0,3,0) = psi1(0,3,0)*dxids0[0] + psi1(0,3,1)*dxids0[1] + psi1(0,3,2)*dxids0[2];
    dpsids(0,4,0) = psi1(0,4,0)*dxids0[0] + psi1(0,4,1)*dxids0[1] + psi1(0,4,2)*dxids0[2];
    dpsids(0,5,0) = psi1(0,5,0)*dxids0[0] + psi1(0,5,1)*dxids0[1] + psi1(0,5,2)*dxids0[2];
    
    // by chain rule, we can obtain dshape wrt s1 at node0
    dpsids(0,0,1) = psi1(0,0,0)*dxids1[0] + psi1(0,0,1)*dxids1[1] + psi1(0,0,2)*dxids1[2];
    dpsids(0,1,1) = psi1(0,1,0)*dxids1[0] + psi1(0,1,1)*dxids1[1] + psi1(0,1,2)*dxids1[2];
    dpsids(0,2,1) = psi1(0,2,0)*dxids1[0] + psi1(0,2,1)*dxids1[1] + psi1(0,2,2)*dxids1[2];
    dpsids(0,3,1) = psi1(0,3,0)*dxids1[0] + psi1(0,3,1)*dxids1[1] + psi1(0,3,2)*dxids1[2];
    dpsids(0,4,1) = psi1(0,4,0)*dxids1[0] + psi1(0,4,1)*dxids1[1] + psi1(0,4,2)*dxids1[2];
    dpsids(0,5,1) = psi1(0,5,0)*dxids1[0] + psi1(0,5,1)*dxids1[1] + psi1(0,5,2)*dxids1[2];
    //-------------------------------------------------------------------------------------
    // define shape functions that associated to dofs at node 1
    // wrt area coordinate 1
    psi1(1,0,1) = 5.0*xi[1]*xi[1]*xi[1]*xi[1] +5.0*4.0*xi[1]*xi[1]*xi[1]*(xi[2]+xi[0]) + 10.0*3.0*xi[1]*xi[1]*(xi[2]+xi[0])*(xi[2]+xi[0]) +30.0*2.0*xi[1]*xi[2]*xi[0]*(lamb[0]*xi[2] + lamb_p[2]*xi[0]);
    psi1(1,1,1) = 3.0*b[1]*2.0*xi[1]*xi[2]*xi[0]*(xi[2]-xi[0]) +   3.0*xi[1]*xi[1]*(b[0]*xi[2] -b[2]*xi[0])*(xi[1] + 4.0*xi[2] + 4.0*xi[0]) +xi[1]*xi[1]*xi[1]*(b[0]*xi[2] -b[2]*xi[0]) + 15*2.0*xi[1]*xi[2]*xi[0]*(b[0]*lamb[0]*xi[2] - b[2]*lamb_p[2]*xi[0]);
    psi1(1,2,1) = -3.0*c[1]*2.0*xi[1]*xi[2]*xi[0]*(xi[2]-xi[0]) - 3.0*xi[1]*xi[1]*(c[0]*xi[2] -c[2]*xi[0])*(xi[1] + 4.0*xi[2] + 4.0*xi[0]) - xi[1]*xi[1]*xi[1]*(c[0]*xi[2] -c[2]*xi[0]) -15.0*2.0*xi[1]*xi[2]*xi[0]*(c[0]*lamb[0]*xi[2] -c[2]*lamb_p[2]*xi[0]);
    psi1(1,3,1) = 1.0/2.0*3.0*xi[1]*xi[1]*(b[0]*b[0]*xi[2]*xi[2] + b[2]*b[2]*xi[0]*xi[0]) + 2.0*xi[1]*xi[2]*xi[0]*(-b[2]*b[0]*xi[1] + b[0]*b[1]*xi[2] + b[1]*b[2]*xi[0]) + 5.0/2.0*2.0*xi[1]*xi[2]*xi[0]*(b[0]*b[0]*lamb[0]*xi[2] + b[2]*b[2]*lamb_p[2]*xi[0]) + xi[1]*xi[1]*xi[2]*xi[0]*(-b[2])*b[0];
    psi1(1,4,1) = 1.0/2.0*3.0*xi[1]*xi[1]*(c[0]*c[0]*xi[2]*xi[2] + c[2]*c[2]*xi[0]*xi[0]) + 2.0*xi[1]*xi[2]*xi[0]*(-c[2]*c[0]*xi[1] + c[0]*c[1]*xi[2] + c[1]*c[2]*xi[0])
     + 5.0/2.0*2.0*xi[1]*xi[2]*xi[0]*(c[0]*c[0]*lamb[0]*xi[2] + c[2]*c[2]*lamb_p[2]*xi[0])+ xi[1]*xi[1]*xi[2]*xi[0]*(-c[2])*c[0];
    psi1(1,5,1) = b[1]*c[1]*2.0*xi[1]*xi[2]*xi[0]*(xi[1] + xi[2] + xi[0]) + b[1]*c[1]*xi[1]*xi[1]*xi[2]*xi[0] + b[2]*c[2]*2.0*xi[1]*xi[0]*(xi[2]*xi[0] - xi[0]*xi[1] - xi[1]*xi[2] - xi[2]*xi[2]) + b[2]*c[2]*xi[1]*xi[1]*xi[0]*(-xi[2] - xi[0]) + b[0]*c[0]*2.0*xi[1]*xi[2]*(xi[2]*xi[0] - xi[0]*xi[1] -xi[1]*xi[2] - xi[0]*xi[0]) + b[0]*c[0]*xi[1]*xi[1]*xi[2]*(- xi[0]-xi[2]) - 5.0*2.0*xi[1]*xi[2]*xi[0]*(b[2]*c[2]*lamb_p[2]*xi[0] + b[0]*c[0]*lamb[0]*xi[2]);
    
    // wrt area coordinate2
    psi1(1,0,2) = 5.0*xi[1]*xi[1]*xi[1]*xi[1] + 10.0*xi[1]*xi[1]*xi[1]*2.0*(xi[2]+xi[0])+30.0*xi[1]*xi[1]*xi[0]*(lamb[0]*xi[2] + lamb_p[2]*xi[0]) +30.0*xi[1]*xi[1]*xi[2]*xi[0]*(lamb[0]);
    psi1(1,1,2) = 3.0*b[1]*xi[1]*xi[1]*xi[0]*(xi[2]-xi[0])+ 3.0*b[1]*xi[1]*xi[1]*xi[2]*xi[0] +  xi[1]*xi[1]*xi[1]*(b[0])*(xi[1] + 4.0*xi[2] + 4.0*xi[0])+  xi[1]*xi[1]*xi[1]*(b[0]*xi[2] -b[2]*xi[0])*(4.0) + 15.0*xi[1]*xi[1]*xi[0]*(b[0]*lamb[0]*xi[2] - b[2]*lamb_p[2]*xi[0]) + 15*xi[1]*xi[1]*xi[2]*xi[0]*(b[0]*lamb[0]);
    psi1(1,2,2) =  -3.0*c[1]*xi[1]*xi[1]*xi[2]*xi[0] + -3.0*c[1]*xi[1]*xi[1]*xi[0]*(xi[2]-xi[0]) - xi[1]*xi[1]*xi[1]*(c[0]*xi[2] - c[2]*xi[0])*(4.0) - xi[1]*xi[1]*xi[1]*(c[0])*(xi[1] + 4.0*xi[2] + 4.0*xi[0]) -15.0*xi[1]*xi[1]*xi[2]*xi[0]*(c[0]*lamb[0]) - 15.0*xi[1]*xi[1]*xi[0]*(c[0]*lamb[0]*xi[2] -c[2]*lamb_p[2]*xi[0]);
    psi1(1,3,2) = 1.0/2.0*xi[1]*xi[1]*xi[1]*(b[0]*b[0]*2.0*xi[2]) + xi[1]*xi[1]*xi[2]*xi[0]*(b[0]*b[1]) + xi[1]*xi[1]*xi[0]*(-b[2]*b[0]*xi[1] + b[0]*b[1]*xi[2] + b[1]*b[2]*xi[0])  + 5.0/2.0*xi[1]*xi[1]*xi[2]*xi[0]*(b[0]*b[0]*lamb[0]) + 5.0/2.0*xi[1]*xi[1]*xi[0]*(b[0]*b[0]*lamb[0]*xi[2] + b[2]*b[2]*lamb_p[2]*xi[0]);
    psi1(1,4,2) = 1.0/2.0*xi[1]*xi[1]*xi[1]*(c[0]*c[0]*2.0*xi[2]) + xi[1]*xi[1]*xi[2]*xi[0]*(c[0]*c[1]) + xi[1]*xi[1]*xi[0]*(-c[2]*c[0]*xi[1] + c[0]*c[1]*xi[2] + c[1]*c[2]*xi[0])+ 5.0/2.0*xi[1]*xi[1]*xi[2]*xi[0]*(c[0]*c[0]*lamb[0])  + 5.0/2.0*xi[1]*xi[1]*xi[0]*(c[0]*c[0]*lamb[0]*xi[2] + c[2]*c[2]*lamb_p[2]*xi[0]);
    psi1(1,5,2) = b[1]*c[1]*xi[1]*xi[1]*xi[2]*xi[0] + b[1]*c[1]*xi[1]*xi[1]*xi[0]*(xi[1] + xi[2] + xi[0]) + b[2]*c[2]*xi[1]*xi[1]*xi[0]*(xi[0] - xi[1] - 2.0*xi[2])
     + b[0]*c[0]*xi[1]*xi[1]*xi[2]*(xi[0] -xi[1]) + b[0]*c[0]*xi[1]*xi[1]*(xi[2]*xi[0] - xi[0]*xi[1] -xi[1]*xi[2] - xi[0]*xi[0]) - 5.0*xi[1]*xi[1]*xi[2]*xi[0]*( b[0]*c[0]*lamb[0]) - 5.0*xi[1]*xi[1]*xi[0]*(b[2]*c[2]*lamb_p[2]*xi[0] + b[0]*c[0]*lamb[0]*xi[2]);
     
    // wrt area coordinate0
    psi1(1,0,0) = 5.0*xi[1]*xi[1]*xi[1]*xi[1] + 10.0*xi[1]*xi[1]*xi[1]*2.0*(xi[2]+xi[0]) + 30.0*xi[1]*xi[1]*xi[2]*xi[0]*(lamb_p[2])+ 30.0*xi[1]*xi[1]*xi[2]*(lamb[0]*xi[2] + lamb_p[2]*xi[0]);
    psi1(1,1,0) = -3.0*b[1]*xi[1]*xi[1]*xi[2]*xi[0] + 3.0*b[1]*xi[1]*xi[1]*xi[2]*(xi[2]-xi[0]) +  xi[1]*xi[1]*xi[1]*(b[0]*xi[2] -b[2]*xi[0])*(4.0) + xi[1]*xi[1]*xi[1]*(-b[2])*(xi[1] + 4.0*xi[2] + 4.0*xi[0]) - 15*xi[1]*xi[1]*xi[2]*xi[0]*(b[2]*lamb_p[2]) + 15*xi[1]*xi[1]*xi[2]*(b[0]*lamb[0]*xi[2] - b[2]*lamb_p[2]*xi[0]);
    psi1(1,2,0) =  3.0*c[1]*xi[1]*xi[1]*xi[2]*xi[0] - 3.0*c[1]*xi[1]*xi[1]*xi[2]*(xi[2]-xi[0]) -  xi[1]*xi[1]*xi[1]*(c[0]*xi[2] -c[2]*xi[0])*(4.0) - xi[1]*xi[1]*xi[1]*(-c[2])*(xi[1] + 4.0*xi[2] + 4.0*xi[0]) + 15.0*xi[1]*xi[1]*xi[2]*xi[0]*(c[2]*lamb_p[2]) -15.0*xi[1]*xi[1]*xi[2]*(c[0]*lamb[0]*xi[2] -c[2]*lamb_p[2]*xi[0]);
    psi1(1,3,0) = 1.0/2.0*xi[1]*xi[1]*xi[1]*(b[2]*b[2]*2.0*xi[0]) + xi[1]*xi[1]*xi[2]*xi[0]*(b[1]*b[2]) + xi[1]*xi[1]*xi[2]*(-b[2]*b[0]*xi[1] + b[0]*b[1]*xi[2] + b[1]*b[2]*xi[0]) + 5.0/2.0*xi[1]*xi[1]*xi[2]*xi[0]*( b[2]*b[2]*lamb_p[2])+ 5.0/2.0*xi[1]*xi[1]*xi[2]*(b[0]*b[0]*lamb[0]*xi[2] + b[2]*b[2]*lamb_p[2]*xi[0]);
    psi1(1,4,0) = 1.0/2.0*xi[1]*xi[1]*xi[1]*(c[2]*c[2]*2.0*xi[0]) + xi[1]*xi[1]*xi[2]*xi[0]*(c[1]*c[2]) + xi[1]*xi[1]*xi[2]*(-c[2]*c[0]*xi[1] + c[0]*c[1]*xi[2] + c[1]*c[2]*xi[0])  + 5.0/2.0*xi[1]*xi[1]*xi[2]*xi[0]*(c[2]*c[2]*lamb_p[2]) + 5.0/2.0*xi[1]*xi[1]*xi[2]*(c[0]*c[0]*lamb[0]*xi[2] + c[2]*c[2]*lamb_p[2]*xi[0]);
    psi1(1,5,0) = b[1]*c[1]*xi[1]*xi[1]*xi[2]*xi[0] + b[1]*c[1]*xi[1]*xi[1]*xi[2]*(xi[1] + xi[2] + xi[0]) + b[2]*c[2]*xi[1]*xi[1]*xi[0]*(xi[2] - xi[1])  + b[2]*c[2]*xi[1]*xi[1]*(xi[2]*xi[0] - xi[0]*xi[1] - xi[1]*xi[2] - xi[2]*xi[2]) + b[0]*c[0]*xi[1]*xi[1]*xi[2]*(xi[2] - xi[1] - 2.0*xi[0]) - 5.0*xi[1]*xi[1]*xi[2]*xi[0]*(b[2]*c[2]*lamb_p[2]) - 5.0*xi[1]*xi[1]*xi[2]*(b[2]*c[2]*lamb_p[2]*xi[0] + b[0]*c[0]*lamb[0]*xi[2]);
    //--------------------------------------------------------------------------------------
    // by chain rule, we can obtain dshape wrt s0 at node1
    dpsids(1,0,0) = psi1(1,0,0)*dxids0[0] + psi1(1,0,1)*dxids0[1] + psi1(1,0,2)*dxids0[2];
    dpsids(1,1,0) = psi1(1,1,0)*dxids0[0] + psi1(1,1,1)*dxids0[1] + psi1(1,1,2)*dxids0[2];
    dpsids(1,2,0) = psi1(1,2,0)*dxids0[0] + psi1(1,2,1)*dxids0[1] + psi1(1,2,2)*dxids0[2];
    dpsids(1,3,0) = psi1(1,3,0)*dxids0[0] + psi1(1,3,1)*dxids0[1] + psi1(1,3,2)*dxids0[2];
    dpsids(1,4,0) = psi1(1,4,0)*dxids0[0] + psi1(1,4,1)*dxids0[1] + psi1(1,4,2)*dxids0[2];
    dpsids(1,5,0) = psi1(1,5,0)*dxids0[0] + psi1(1,5,1)*dxids0[1] + psi1(1,5,2)*dxids0[2];
    
    // by chain rule, we can obtain dshape wrt s1 at node1
    dpsids(1,0,1) = psi1(1,0,0)*dxids1[0] + psi1(1,0,1)*dxids1[1] + psi1(1,0,2)*dxids1[2];
    dpsids(1,1,1) = psi1(1,1,0)*dxids1[0] + psi1(1,1,1)*dxids1[1] + psi1(1,1,2)*dxids1[2];
    dpsids(1,2,1) = psi1(1,2,0)*dxids1[0] + psi1(1,2,1)*dxids1[1] + psi1(1,2,2)*dxids1[2];
    dpsids(1,3,1) = psi1(1,3,0)*dxids1[0] + psi1(1,3,1)*dxids1[1] + psi1(1,3,2)*dxids1[2];
    dpsids(1,4,1) = psi1(1,4,0)*dxids1[0] + psi1(1,4,1)*dxids1[1] + psi1(1,4,2)*dxids1[2];
    dpsids(1,5,1) = psi1(1,5,0)*dxids1[0] + psi1(1,5,1)*dxids1[1] + psi1(1,5,2)*dxids1[2];
    //-------------------------------------------------------------------------------------
    // define shape functions that associated to dofs at node 2
    // wrt area coordinate0
    psi1(2,0,0) = 5.0*xi[2]*xi[2]*xi[2]*xi[2] + 10.0*xi[2]*xi[2]*xi[2]*2.0*(xi[0]+xi[1]) + 30.0*xi[2]*xi[2]*xi[1]*(lamb[1]*xi[0] + lamb_p[0]*xi[1]) 
     +30.0*xi[2]*xi[2]*xi[0]*xi[1]*(lamb[1]);
    psi1(2,1,0)= 3.0*b[2]*xi[2]*xi[2]*xi[1]*(xi[0]-xi[1]) + 3.0*b[2]*xi[2]*xi[2]*xi[0]*xi[1] +   xi[2]*xi[2]*xi[2]*(b[1])*(xi[2] + 4.0*xi[0] + 4.0*xi[1])+  xi[2]*xi[2]*xi[2]*(b[1]*xi[0] -b[0]*xi[1])*(4.0) + 15.0*xi[2]*xi[2]*xi[1]*(b[1]*lamb[1]*xi[0] - b[0]*lamb_p[0]*xi[1]) + 15.0*xi[2]*xi[2]*xi[0]*xi[1]*(b[1]*lamb[1]);
    psi1(2,2,0) =  -3.0*c[2]*xi[2]*xi[2]*xi[0]*xi[1] + -3.0*c[2]*xi[2]*xi[2]*xi[1]*(xi[0]-xi[1]) - xi[2]*xi[2]*xi[2]*(c[1]*xi[0] - c[0]*xi[1])*(4.0) - xi[2]*xi[2]*xi[2]*(c[1])*(xi[2] + 4.0*xi[0] + 4.0*xi[1]) -15.0*xi[2]*xi[2]*xi[0]*xi[1]*(c[1]*lamb[1])
     -15.0*xi[2]*xi[2]*xi[1]*(c[1]*lamb[1]*xi[0] -c[0]*lamb_p[0]*xi[1]);
    psi1(2,3,0) = 1.0/2.0*xi[2]*xi[2]*xi[2]*(b[1]*b[1]*2.0*xi[0]) + xi[2]*xi[2]*xi[0]*xi[1]*(b[1]*b[2]) + xi[2]*xi[2]*xi[1]*(-b[0]*b[1]*xi[2] + b[1]*b[2]*xi[0] + b[2]*b[0]*xi[1])  + 5.0/2.0*xi[2]*xi[2]*xi[0]*xi[1]*(b[1]*b[1]*lamb[1]) + 5.0/2.0*xi[2]*xi[2]*xi[1]*(b[1]*b[1]*lamb[1]*xi[0] + b[0]*b[0]*lamb_p[0]*xi[1]);
    psi1(2,4,0) = 1.0/2.0*xi[2]*xi[2]*xi[2]*(c[1]*c[1]*2.0*xi[0]) + xi[2]*xi[2]*xi[0]*xi[1]*( c[1]*c[2]) + xi[2]*xi[2]*xi[1]*(-c[0]*c[1]*xi[2] + c[1]*c[2]*xi[0] + c[2]*c[0]*xi[1])+ 5.0/2.0*xi[2]*xi[2]*xi[0]*xi[1]*(c[1]*c[1]*lamb[1])  + 5.0/2.0*xi[2]*xi[2]*xi[1]*(c[1]*c[1]*lamb[1]*xi[0] + c[0]*c[0]*lamb_p[0]*xi[1]);
    psi1(2,5,0) = b[2]*c[2]*xi[2]*xi[2]*xi[0]*xi[1] + b[2]*c[2]*xi[2]*xi[2]*xi[1]*(xi[2] + xi[0] + xi[1]) + b[0]*c[0]*xi[2]*xi[2]*xi[1]*(xi[1] - xi[2] - 2.0*xi[0])
     + b[1]*c[1]*xi[2]*xi[2]*xi[0]*(xi[1] -xi[2]) + b[1]*c[1]*xi[2]*xi[2]*(xi[0]*xi[1] - xi[1]*xi[2] -xi[2]*xi[0] - xi[1]*xi[1]) - 5.0*xi[2]*xi[2]*xi[0]*xi[1]*( b[1]*c[1]*lamb[1]) - 5.0*xi[2]*xi[2]*xi[1]*(b[0]*c[0]*lamb_p[0]*xi[1] + b[1]*c[1]*lamb[1]*xi[0]);
    
    // wrt area coordinate1
    psi1(2,0,1) = 5.0*xi[2]*xi[2]*xi[2]*xi[2] + 10.0*xi[2]*xi[2]*xi[2]*2.0*(xi[0]+xi[1]) +30.0*xi[2]*xi[2]*xi[0]*xi[1]*(lamb_p[0])  +30.0*xi[2]*xi[2]*xi[0]*(lamb[1]*xi[0] + lamb_p[0]*xi[1]);
    psi1(2,1,1) = 3.0*b[2]*xi[2]*xi[2]*xi[0]*xi[1]*(-1.0) + 3.0*b[2]*xi[2]*xi[2]*xi[0]*(xi[0]-xi[1])+  xi[2]*xi[2]*xi[2]*(-b[0])*(xi[2] + 4.0*xi[0] + 4.0*xi[1])+   xi[2]*xi[2]*xi[2]*(b[1]*xi[0] -b[0]*xi[1])*(4.0)+ 15*xi[2]*xi[2]*xi[0]*(b[1]*lamb[1]*xi[0] - b[0]*lamb_p[0]*xi[1]) + 15.0*xi[2]*xi[2]*xi[0]*xi[1]*(-b[0]*lamb_p[0]);
    psi1(2,2,1) =  -3.0*c[2]*xi[2]*xi[2]*xi[0]*xi[1]*(-1.0) +  -3.0*c[2]*xi[2]*xi[2]*xi[0]*(xi[0]-xi[1]) - xi[2]*xi[2]*xi[2]*(c[1]*xi[0] - c[0]*xi[1])*(4.0) - xi[2]*xi[2]*xi[2]*(-1.0*c[0])*(xi[2] + 4.0*xi[0] + 4.0*xi[1]) -15.0*xi[2]*xi[2]*xi[0]*xi[1]*( -1.0*c[0]*lamb_p[0]) -15.0*xi[2]*xi[2]*xi[0]*(c[1]*lamb[1]*xi[0] -c[0]*lamb_p[0]*xi[1]);
    psi1(2,3,1) = 1.0/2.0*xi[2]*xi[2]*xi[2]*(b[0]*b[0]*2.0*xi[1]) + xi[2]*xi[2]*xi[0]*xi[1]*( b[2]*b[0]) + xi[2]*xi[2]*xi[0]*(-b[0]*b[1]*xi[2] + b[1]*b[2]*xi[0] + b[2]*b[0]*xi[1]) + 5.0/2.0*xi[2]*xi[2]*xi[0]*xi[1]*( b[0]*b[0]*lamb_p[0])+ 5.0/2.0*xi[2]*xi[2]*xi[0]*(b[1]*b[1]*lamb[1]*xi[0] + b[0]*b[0]*lamb_p[0]*xi[1]);
    psi1(2,4,1) = 1.0/2.0*xi[2]*xi[2]*xi[2]*(c[0]*c[0]*2.0*xi[1]) + xi[2]*xi[2]*xi[0]*xi[1]*(c[2]*c[0]) + xi[2]*xi[2]*xi[0]*(-c[0]*c[1]*xi[2] + c[1]*c[2]*xi[0] + c[2]*c[0]*xi[1])  + 5.0/2.0*xi[2]*xi[2]*xi[0]*xi[1]*(c[0]*c[0]*lamb_p[0]) + 5.0/2.0*xi[2]*xi[2]*xi[0]*(c[1]*c[1]*lamb[1]*xi[0] + c[0]*c[0]*lamb_p[0]*xi[1]);
    psi1(2,5,1) = b[2]*c[2]*xi[2]*xi[2]*xi[0]*xi[1] + b[2]*c[2]*xi[2]*xi[2]*xi[0]*(xi[2] + xi[0] + xi[1]) + b[0]*c[0]*xi[2]*xi[2]*xi[1]*(xi[0] - xi[2]) + b[0]*c[0]*xi[2]*xi[2]*(xi[0]*xi[1] - xi[1]*xi[2] - xi[2]*xi[0] - xi[0]*xi[0]) + b[1]*c[1]*xi[2]*xi[2]*xi[0]*(xi[0] - xi[2] - 2.0*xi[1]) - 5.0*xi[2]*xi[2]*xi[0]*xi[1]*(b[0]*c[0]*lamb_p[0]) - 5.0*xi[2]*xi[2]*xi[0]*(b[0]*c[0]*lamb_p[0]*xi[1] + b[1]*c[1]*lamb[1]*xi[0]);
    
    // wrt area coordinate2
    psi1(2,0,2) = 5.0*xi[2]*xi[2]*xi[2]*xi[2] +5.0*4.0*xi[2]*xi[2]*xi[2]*(xi[0]+xi[1]) + 10.0*3.0*xi[2]*xi[2]*(xi[0]+xi[1])*(xi[0]+xi[1])
     +30.0*2.0*xi[2]*xi[0]*xi[1]*(lamb[1]*xi[0] + lamb_p[0]*xi[1]);
    psi1(2,1,2) = 3.0*b[2]*2.0*xi[2]*xi[0]*xi[1]*(xi[0]-xi[1]) +  3.0*xi[2]*xi[2]*(b[1]*xi[0] -b[0]*xi[1])*(xi[2] + 4.0*xi[0] + 4.0*xi[1]) + xi[2]*xi[2]*xi[2]*(b[1]*xi[0] -b[0]*xi[1]) + 15*2.0*xi[2]*xi[0]*xi[1]*(b[1]*lamb[1]*xi[0] - b[0]*lamb_p[0]*xi[1]);
    psi1(2,2,2) = -3.0*c[2]*2.0*xi[2]*xi[0]*xi[1]*(xi[0]-xi[1]) - 3.0*xi[2]*xi[2]*(c[1]*xi[0] -c[0]*xi[1])*(xi[2] + 4.0*xi[0] + 4.0*xi[1]) - xi[2]*xi[2]*xi[2]*(c[1]*xi[0] -c[0]*xi[1]) -15.0*2.0*xi[2]*xi[0]*xi[1]*(c[1]*lamb[1]*xi[0] -c[0]*lamb_p[0]*xi[1]);
    psi1(2,3,2) = 1.0/2.0*3.0*xi[2]*xi[2]*(b[1]*b[1]*xi[0]*xi[0] + b[0]*b[0]*xi[1]*xi[1]) + 2.0*xi[2]*xi[0]*xi[1]*(-b[0]*b[1]*xi[2] + b[1]*b[2]*xi[0] + b[2]*b[0]*xi[1])
     + 5.0/2.0*2.0*xi[2]*xi[0]*xi[1]*(b[1]*b[1]*lamb[1]*xi[0] + b[0]*b[0]*lamb_p[0]*xi[1]) + xi[2]*xi[2]*xi[0]*xi[1]*(-b[0])*b[1];
    psi1(2,4,2) =  1.0/2.0*3.0*xi[2]*xi[2]*(c[1]*c[1]*xi[0]*xi[0] + c[0]*c[0]*xi[1]*xi[1]) + 2.0*xi[2]*xi[0]*xi[1]*(-c[0]*c[1]*xi[2] + c[1]*c[2]*xi[0] + c[2]*c[0]*xi[1])
     + 5.0/2.0*2.0*xi[2]*xi[0]*xi[1]*(c[1]*c[1]*lamb[1]*xi[0] + c[0]*c[0]*lamb_p[0]*xi[1])+ xi[2]*xi[2]*xi[0]*xi[1]*(-c[0]*c[1]);
    psi1(2,5,2) = b[2]*c[2]*2.0*xi[2]*xi[0]*xi[1]*(xi[2] + xi[0] + xi[1]) + b[2]*c[2]*xi[2]*xi[2]*xi[0]*xi[1] + b[0]*c[0]*2.0*xi[2]*xi[1]*(xi[0]*xi[1] - xi[1]*xi[2] - xi[2]*xi[0] - xi[0]*xi[0]) + b[0]*c[0]*xi[2]*xi[2]*xi[1]*(-xi[0] - xi[1]) + b[1]*c[1]*2.0*xi[2]*xi[0]*(xi[0]*xi[1] - xi[1]*xi[2] -xi[2]*xi[0] - xi[1]*xi[1]) + b[1]*c[1]*xi[2]*xi[2]*xi[0]*(- xi[1]-xi[0]) - 5.0*2.0*xi[2]*xi[0]*xi[1]*(b[0]*c[0]*lamb_p[0]*xi[1] + b[1]*c[1]*lamb[1]*xi[0]);
    
    // by chain rule, we can obtain dshape wrt s0 at node2
    dpsids(2,0,0) = psi1(2,0,0)*dxids0[0] + psi1(2,0,1)*dxids0[1] + psi1(2,0,2)*dxids0[2];
    dpsids(2,1,0) = psi1(2,1,0)*dxids0[0] + psi1(2,1,1)*dxids0[1] + psi1(2,1,2)*dxids0[2];
    dpsids(2,2,0) = psi1(2,2,0)*dxids0[0] + psi1(2,2,1)*dxids0[1] + psi1(2,2,2)*dxids0[2];
    dpsids(2,3,0) = psi1(2,3,0)*dxids0[0] + psi1(2,3,1)*dxids0[1] + psi1(2,3,2)*dxids0[2];
    dpsids(2,4,0) = psi1(2,4,0)*dxids0[0] + psi1(2,4,1)*dxids0[1] + psi1(2,4,2)*dxids0[2];
    dpsids(2,5,0) = psi1(2,5,0)*dxids0[0] + psi1(2,5,1)*dxids0[1] + psi1(2,5,2)*dxids0[2];
    
    // by chain rule, we can obtain dshape wrt s1 at node2
    dpsids(2,0,1) = psi1(2,0,0)*dxids1[0] + psi1(2,0,1)*dxids1[1] + psi1(2,0,2)*dxids1[2];
    dpsids(2,1,1) = psi1(2,1,0)*dxids1[0] + psi1(2,1,1)*dxids1[1] + psi1(2,1,2)*dxids1[2];
    dpsids(2,2,1) = psi1(2,2,0)*dxids1[0] + psi1(2,2,1)*dxids1[1] + psi1(2,2,2)*dxids1[2];
    dpsids(2,3,1) = psi1(2,3,0)*dxids1[0] + psi1(2,3,1)*dxids1[1] + psi1(2,3,2)*dxids1[2];
    dpsids(2,4,1) = psi1(2,4,0)*dxids1[0] + psi1(2,4,1)*dxids1[1] + psi1(2,4,2)*dxids1[2];
    dpsids(2,5,1) = psi1(2,5,0)*dxids1[0] + psi1(2,5,1)*dxids1[1] + psi1(2,5,2)*dxids1[2];
   }

   void d2Bshape_local(const Vector<double> &s, Shape &psi, DShape &dpsids, DShape &d2psids, DenseMatrix<double> &position) const
   {
    // assign for dshape functions
    dBshape_local(s,psi,dpsids,position);
    //---------------------------------------------
    // the mapping to physical coordinates 
    //----------------------------------------------
    Vector<double> phi(2);
    phi[0] = position(2,0) + (position(0,0) - position(2,0))*s[0] + (position(1,0) - position(2,0))*s[1];
    phi[1] = position(2,1) + (position(0,1) - position(2,1))*s[0] + (position(1,1) - position(2,1))*s[1];
    
    double A = ( (position(1,0)*position(2,1)-position(2,0)*position(1,1)) - (position(0,0)*position(2,1)-position(2,0)*position(0,1)) + (position(0,0)*position(1,1)-position(1,0)*position(0,1)))/2.0;
    double A0, A1, A2;
    A0 = ( (position(1,0)*position(2,1)-position(2,0)*position(1,1)) - (phi[0]*position(2,1)-position(2,0)*phi[1]) + (phi[0]*position(1,1)-position(1,0)*phi[1]))/2.0;
    A1 = ( (phi[0]*position(2,1)-position(2,0)*phi[1]) - (position(0,0)*position(2,1)-position(2,0)*position(0,1)) + (position(0,0)*phi[1]-phi[0]*position(0,1)))/2.0;
    A2 = ( (position(1,0)*phi[1]-phi[0]*position(1,1)) - (position(0,0)*phi[1]-phi[0]*position(0,1)) + (position(0,0)*position(1,1)-position(1,0)*position(0,1)))/2.0;
    
    // assigned area coordinates
    Vector<double> xi(3);
    xi[0] = A0/A;
    xi[1] = A1/A;
    xi[2] = A2/A;
    
    Vector<double> b(3);
    Vector<double> c(3);
    Vector<double> lamb(3);
    Vector<double> lamb_p(3);
    Vector<double> pp(2);
    Vector<double> a(2),cc(2);
    
    //compute for b and c
    b[1] = position(0,0)-position(2,0);
    b[2] = position(1,0)-position(0,0);
    b[0] = position(2,0)-position(1,0);

    c[1] = position(2,1)-position(0,1);
    c[2] = position(0,1)-position(1,1);
    c[0] = position(1,1)-position(2,1);
     
    //compute for a point of perpendicular
    // on the edge opposite to node0 (top vertex)
    Vector<double> v(2);
    v[0] = (position(2,0)-position(1,0));
    v[1] = (position(2,1)-position(1,1));
    double m = v[1]/v[0];
    a[0] = position(1,0);
    a[1] = position(1,1);
    cc[0] = position(0,0);
    cc[1] = position(0,1);
    if(v[0]==0)
     {
      m = v[0]/v[1];
      pp[1] = ( v[0]*m*a[1] + v[1]*cc[1] - v[0]*a[0] + v[0]*cc[0] )/((v[0]*m)+v[1]);
      pp[0] = (pp[1]-a[1])*m + a[0];
     }
    else
     {
      pp[0] = (v[1]*m*a[0] + v[1]*cc[1] - v[1]*a[1] + v[0]*cc[0])/(v[1]*m+v[0]);
      pp[1] = m*(pp[0]-a[0]) + a[1];
     }
    double l = sqrt(v[0]*v[0] + v[1]*v[1]);
    double l1 = sqrt( (pp[0]-a[0])*(pp[0]-a[0]) + (pp[1]-a[1])*(pp[1]-a[1]));
    lamb_p[0] = l1/l;
    lamb[0] = 1-lamb_p[0];
    
    // on the edge opposite to node1
    v[0] = (position(0,0)-position(2,0));
    v[1] = (position(0,1)-position(2,1));
    m = v[1]/v[0];
    a[0] = position(2,0);
    a[1] = position(2,1);
    cc[0] = position(1,0);
    cc[1] = position(1,1);
    if(v[0]==0)
     {
      m = v[0]/v[1];
      pp[1] = ( v[0]*m*a[1] + v[1]*cc[1] - v[0]*a[0] + v[0]*cc[0] )/((v[0]*m)+v[1]);
      pp[0] = (pp[1]-a[1])*m + a[0];
     }
    else
     {
      pp[0] = (v[1]*m*a[0] + v[1]*cc[1] - v[1]*a[1] + v[0]*cc[0])/(v[1]*m+v[0]);
      pp[1] = m*(pp[0]-a[0]) + a[1];
     }
    l = sqrt(v[0]*v[0] + v[1]*v[1]);
    l1 = sqrt( (pp[0]-a[0])*(pp[0]-a[0]) + (pp[1]-a[1])*(pp[1]-a[1]));
    lamb_p[1] = l1/l;
    lamb[1] = 1-lamb_p[1];
    
    // on the edge opposite to node2 (right bottom)
    v[0] = (position(1,0)-position(0,0));
    v[1] = (position(1,1)-position(0,1));
    m = v[1]/v[0];
    a[0] = position(0,0);
    a[1] = position(0,1);
    cc[0] = position(2,0);
    cc[1] = position(2,1);
    if(v[0]==0)
     {
      m = v[0]/v[1];
      pp[1] = ( v[0]*m*a[1] + v[1]*cc[1] - v[0]*a[0] + v[0]*cc[0] )/((v[0]*m)+v[1]);
      pp[0] = (pp[1]-a[1])*m + a[0];
     }
    else
     {
      pp[0] = (v[1]*m*a[0] + v[1]*cc[1] - v[1]*a[1] + v[0]*cc[0])/(v[1]*m+v[0]);
      pp[1] = m*(pp[0]-a[0]) + a[1];
     }
    l = sqrt(v[0]*v[0] + v[1]*v[1]);
    l1 = sqrt( (pp[0]-a[0])*(pp[0]-a[0]) + (pp[1]-a[1])*(pp[1]-a[1]));
    lamb_p[2] = l1/l;
    lamb[2] = 1-lamb_p[2];
    
    Vector<double> dxids0(3,0.0);
    Vector<double> dxids1(3,0.0);
   
    dxids0[0] = c[0]/A/2.0;
    dxids0[1] = c[1]/A/2.0;
    dxids0[2] = c[2]/A/2.0;
    
    dxids1[0] = b[0]/A/2.0;
    dxids1[1] = b[1]/A/2.0;
    dxids1[2] = b[2]/A/2.0;

    //------------------------------------------------------------------
    DShape psi2(3,6,6);
    
    //------------------------------------------------------------------------------------
    // compute for all second derivatives at node 0
    //------------------------------------------------------------------------------------
    // compute for the second derivatives wrt area coordinate0
    psi2(0,0,0) = 5.0*4.0*xi[0]*xi[0]*xi[0] +5.0*4.0*3.0*xi[0]*xi[0]*(xi[1]+xi[2]) + 10.0*3.0*2.0*xi[0]*(xi[1]+xi[2])*(xi[1]+xi[2]) +30.0*2.0*xi[1]*xi[2]*(lamb[2]*xi[1] + lamb_p[1]*xi[2]);
    psi2(0,1,0) = 3.0*b[0]*2.0*xi[1]*xi[2]*(xi[1]-xi[2]) +  3.0*2.0*xi[0]*(b[2]*xi[1] -b[1]*xi[2])*(xi[0] + 4.0*xi[1] + 4.0*xi[2]) + 6.0*xi[0]*xi[0]*(b[2]*xi[1] -b[1]*xi[2]) + 15*2.0*xi[1]*xi[2]*(b[2]*lamb[2]*xi[1] - b[1]*lamb_p[1]*xi[2]);
    psi2(0,2,0) = -6.0*c[0]*xi[1]*xi[2]*(xi[1]-xi[2]) - 3.0*2.0*xi[0]*(c[2]*xi[1] -c[1]*xi[2])*(xi[0] + 4.0*xi[1] + 4.0*xi[2]) - 6.0*xi[0]*xi[0]*(c[2]*xi[1] -c[1]*xi[2]) -15.0*2.0*xi[1]*xi[2]*(c[2]*lamb[2]*xi[1] -c[1]*lamb_p[1]*xi[2]);
    psi2(0,3,0) = 3.0*xi[0]*(b[2]*b[2]*xi[1]*xi[1] + b[1]*b[1]*xi[2]*xi[2]) + 2.0*xi[1]*xi[2]*(-b[1]*b[2]*xi[0] + b[2]*b[0]*xi[1] + b[0]*b[1]*xi[2]) - 4.0*xi[0]*xi[1]*xi[2]*(b[1]*b[2])
     + 5.0*xi[1]*xi[2]*(b[2]*b[2]*lamb[2]*xi[1] + b[1]*b[1]*lamb_p[1]*xi[2]);
    psi2(0,4,0) = 3.0*xi[0]*(c[2]*c[2]*xi[1]*xi[1] + c[1]*c[1]*xi[2]*xi[2]) + 2.0*xi[1]*xi[2]*(-c[1]*c[2]*xi[0] + c[2]*c[0]*xi[1] + c[0]*c[1]*xi[2]) - 4.0*xi[0]*xi[1]*xi[2]*(c[1]*c[2]) + 5.0*xi[1]*xi[2]*(c[2]*c[2]*lamb[2]*xi[1] + c[1]*c[1]*lamb_p[1]*xi[2]);
    psi2(0,5,0) = b[0]*c[0]*2.0*xi[1]*xi[2]*(xi[0] + xi[1] + xi[2]) + b[0]*c[0]*2.0*xi[0]*xi[1]*xi[2] + b[0]*c[0]*2.0*xi[0]*xi[1]*xi[2] + b[1]*c[1]*2.0*xi[2]*(xi[1]*xi[2] - xi[2]*xi[0] - xi[0]*xi[1] - xi[1]*xi[1]) - b[1]*c[1]*4.0*xi[0]*xi[2]*(xi[2] +xi[1]) + b[2]*c[2]*2.0*xi[1]*(xi[1]*xi[2] - xi[2]*xi[0] -xi[0]*xi[1] - xi[2]*xi[2]) - b[2]*c[2]*4.0*xi[0]*xi[1]*(xi[2]+xi[1]) - 5.0*2.0*xi[1]*xi[2]*(b[1]*c[1]*lamb_p[1]*xi[2] + b[2]*c[2]*lamb[2]*xi[1]);
    
    // compute for the second derivative wrt area coordinate1
    psi2(0,0,1) = 10.0*xi[0]*xi[0]*xi[0]*2.0 + 30.0*xi[0]*xi[0]*xi[2]*(lamb[2]) + 30.0*xi[0]*xi[0]*xi[2]*(lamb[2]);
    psi2(0,1,1) = 3.0*b[0]*xi[0]*xi[0]*xi[2] + 3.0*b[0]*xi[0]*xi[0]*xi[2] + xi[0]*xi[0]*xi[0]*(b[2])*(4.0) + xi[0]*xi[0]*xi[0]*(b[2])*(4.0) + 15*xi[0]*xi[0]*xi[2]*(b[2]*lamb[2]) + 15*xi[0]*xi[0]*xi[2]*(b[2]*lamb[2]);
    psi2(0,2,1) = -6.0*c[0]*xi[0]*xi[0]*xi[2] - 8.0*xi[0]*xi[0]*xi[0]*(c[2]) - 30.0*xi[0]*xi[0]*xi[2]*(c[2]*lamb[2]);
    psi2(0,3,1) = xi[0]*xi[0]*xi[0]*(b[2]*b[2]) + 2.0*xi[0]*xi[0]*xi[2]*(b[2]*b[0]) + 5.0*xi[0]*xi[0]*xi[2]*(b[2]*b[2]*lamb[2]);
    psi2(0,4,1) = xi[0]*xi[0]*xi[0]*(c[2]*c[2]) + 2.0*xi[0]*xi[0]*xi[2]*(c[2]*c[0]) + 5.0*xi[0]*xi[0]*xi[2]*(c[2]*c[2]*lamb[2]);
    psi2(0,5,1) = b[0]*c[0]*xi[0]*xi[0]*xi[2] + b[0]*c[0]*xi[0]*xi[0]*xi[2] - 2.0*b[1]*c[1]*xi[0]*xi[0]*xi[2] - 2.0*b[2]*c[2]*xi[0]*xi[0]*(xi[0]-xi[2])- 10.0*xi[0]*xi[0]*xi[2]*(b[2]*c[2]*lamb[2]);
     
    // compute for the second derivative wrt area coordinate2
    psi2(0,0,2) = 10.0*xi[0]*xi[0]*xi[0]*2.0 + 30.0*xi[0]*xi[0]*xi[1]*(lamb_p[1])  +30.0*xi[0]*xi[0]*xi[1]*(lamb_p[1]);
    psi2(0,1,2) = -6.0*b[0]*xi[0]*xi[0]*xi[1] -  8.0*xi[0]*xi[0]*xi[0]*(b[1]) - 30.0*xi[0]*xi[0]*xi[1]*(b[1]*lamb_p[1]);
    psi2(0,2,2) =  6.0*c[0]*xi[0]*xi[0]*xi[1] +  8.0*xi[0]*xi[0]*xi[0]*(c[1]) + 30.0*xi[0]*xi[0]*xi[1]*(c[1]*lamb_p[1]);
    psi2(0,3,2) = xi[0]*xi[0]*xi[0]*(b[1]*b[1]) + 2.0*xi[0]*xi[0]*xi[1]*(b[0]*b[1]) + 5.0*xi[0]*xi[0]*xi[1]*(b[1]*b[1]*lamb_p[1]);
    psi2(0,4,2) = xi[0]*xi[0]*xi[0]*(c[1]*c[1]) + 2.0*xi[0]*xi[0]*xi[1]*(c[0]*c[1]) + 5.0*xi[0]*xi[0]*xi[1]*(c[1]*c[1]*lamb_p[1]);
    psi2(0,5,2) = b[0]*c[0]*xi[0]*xi[0]*xi[1] + b[0]*c[0]*xi[0]*xi[0]*xi[1] + b[1]*c[1]*xi[0]*xi[0]*(xi[1] - xi[0]) + b[1]*c[1]*xi[0]*xi[0]*(xi[1]- xi[0]) + b[2]*c[2]*xi[0]*xi[0]*xi[1]*(-2.0) - 5.0*xi[0]*xi[0]*xi[1]*(b[1]*c[1]*lamb_p[1]) - 5.0*xi[0]*xi[0]*xi[1]*(b[1]*c[1]*lamb_p[1]); 
     
    // compute for the mixed-derivative wrt area coordinate0 and 1
    psi2(0,0,3) = 5.0*4.0*xi[0]*xi[0]*xi[0] + 10.0*3.0*xi[0]*xi[0]*2.0*(xi[1]+xi[2]) + 30.0*2.0*xi[0]*xi[2]*(lamb[2]*xi[1] + lamb_p[1]*xi[2]) + 30.0*2.0*xi[0]*xi[1]*xi[2]*(lamb[2]);
    psi2(0,1,3) = 3.0*b[0]*2.0*xi[0]*xi[2]*(xi[1]-xi[2]) + 3.0*b[0]*2.0*xi[0]*xi[1]*xi[2] +  3.0*xi[0]*xi[0]*(b[2])*(xi[0] + 4.0*xi[1] + 4.0*xi[2]) 
     +  3.0*xi[0]*xi[0]*(b[2]*xi[1] -b[1]*xi[2])*(4.0) + xi[0]*xi[0]*xi[0]*(b[2]) + 15*2.0*xi[0]*xi[2]*(b[2]*lamb[2]*xi[1] - b[1]*lamb_p[1]*xi[2]) + 15*2.0*xi[0]*xi[1]*xi[2]*(b[2]*lamb[2]);
    psi2(0,2,3) = -3.0*c[0]*2.0*xi[0]*xi[2]*(xi[1]-xi[2]) -3.0*c[0]*2.0*xi[0]*xi[1]*xi[2] - 3.0*xi[0]*xi[0]*(c[2])*(xi[0] + 4.0*xi[1] + 4.0*xi[2]) - 3.0*xi[0]*xi[0]*(c[2]*xi[1] -c[1]*xi[2])*(4.0) 
     - xi[0]*xi[0]*xi[0]*(c[2]) -15.0*2.0*xi[0]*xi[2]*(c[2]*lamb[2]*xi[1] -c[1]*lamb_p[1]*xi[2]) -15.0*2.0*xi[0]*xi[1]*xi[2]*(c[2]*lamb[2]);
    psi2(0,3,3) =  3.0*xi[0]*xi[0]*(b[2]*b[2]*xi[1]) + 2.0*xi[0]*xi[2]*(-b[1]*b[2]*xi[0] + b[2]*b[0]*xi[1] + b[0]*b[1]*xi[2]) + 2.0*xi[0]*xi[1]*xi[2]*(b[2]*b[0])
     + 5.0/2.0*2.0*xi[0]*xi[2]*(b[2]*b[2]*lamb[2]*xi[1] + b[1]*b[1]*lamb_p[1]*xi[2])+ 5.0/2.0*2.0*xi[0]*xi[1]*xi[2]*(b[2]*b[2]*lamb[2]) + xi[0]*xi[0]*xi[2]*(-b[1])*b[2];
    psi2(0,4,3) = 3.0*xi[0]*xi[0]*(c[2]*c[2]*xi[1]) + 2.0*xi[0]*xi[2]*(-c[1]*c[2]*xi[0] + c[2]*c[0]*xi[1] + c[0]*c[1]*xi[2]) + 2.0*xi[0]*xi[1]*xi[2]*(c[2]*c[0]) + 5.0*xi[0]*xi[2]*(c[2]*c[2]*lamb[2]*xi[1] + c[1]*c[1]*lamb_p[1]*xi[2]) + 5.0*xi[0]*xi[1]*xi[2]*(c[2]*c[2]*lamb[2])+ xi[0]*xi[0]*xi[2]*(-c[1])*c[2];
    psi2(0,5,3) = b[0]*c[0]*2.0*xi[0]*xi[2]*(xi[0] + xi[1] + xi[2]) + b[0]*c[0]*2.0*xi[0]*xi[1]*xi[2] + b[0]*c[0]*xi[0]*xi[0]*xi[2] + b[1]*c[1]*2.0*xi[0]*xi[2]*(xi[2] - xi[0] - 2.0*xi[1]) + b[1]*c[1]*xi[0]*xi[0]*xi[2]*(-1.0) + b[2]*c[2]*2.0*xi[0]*(xi[1]*xi[2] - xi[2]*xi[0] -xi[0]*xi[1] - xi[2]*xi[2])+ b[2]*c[2]*2.0*xi[0]*xi[1]*(xi[2]-xi[0]) + b[2]*c[2]*xi[0]*xi[0]*(-xi[2]-xi[1]) + b[2]*c[2]*xi[0]*xi[0]*xi[1]*(-1.0) - 5.0*2.0*xi[0]*xi[2]*(b[1]*c[1]*lamb_p[1]*xi[2] + b[2]*c[2]*lamb[2]*xi[1])- 5.0*2.0*xi[0]*xi[1]*xi[2]*(b[2]*c[2]*lamb[2]);
    
    // compute for the mixed-derivative wrt area coordinate0 and 2
    psi2(0,0,4) = 5.0*4.0*xi[0]*xi[0]*xi[0] + 10.0*3.0*xi[0]*xi[0]*2.0*(xi[1]+xi[2]) + 30.0*2.0*xi[0]*xi[1]*(lamb[2]*xi[1] + lamb_p[1]*xi[2]) + 30.0*2.0*xi[0]*xi[1]*xi[2]*(lamb_p[1]);
    psi2(0,1,4) = 3.0*b[0]*2.0*xi[0]*xi[1]*(xi[1]-xi[2]) + 3.0*b[0]*2.0*xi[0]*xi[1]*xi[2]*(-1.0) -  3.0*xi[0]*xi[0]*(b[1])*(xi[0] + 4.0*xi[1] + 4.0*xi[2])  
     +  3.0*xi[0]*xi[0]*(b[2]*xi[1] -b[1]*xi[2])*(4.0) + xi[0]*xi[0]*xi[0]*(-b[1]) + 15*2.0*xi[0]*xi[1]*(b[2]*lamb[2]*xi[1] - b[1]*lamb_p[1]*xi[2])
     - 15*2.0*xi[0]*xi[1]*xi[2]*(b[1]*lamb_p[1]);
    psi2(0,2,4) = -3.0*c[0]*2.0*xi[0]*xi[1]*(xi[1]-xi[2]) + 3.0*c[0]*2.0*xi[0]*xi[1]*xi[2] + 3.0*xi[0]*xi[0]*(c[1])*(xi[0] + 4.0*xi[1] + 4.0*xi[2])  
     - 3.0*xi[0]*xi[0]*(c[2]*xi[1] -c[1]*xi[2])*(4.0) + xi[0]*xi[0]*xi[0]*(c[1]) - 15.0*2.0*xi[0]*xi[1]*(c[2]*lamb[2]*xi[1] -c[1]*lamb_p[1]*xi[2]) 
     + 15.0*2.0*xi[0]*xi[1]*xi[2]*(c[1]*lamb_p[1]);
    psi2(0,3,4) = 3.0*xi[0]*xi[0]*(b[1]*b[1]*xi[2]) + 2.0*xi[0]*xi[1]*(-b[1]*b[2]*xi[0] + b[2]*b[0]*xi[1] + b[0]*b[1]*xi[2])
     + 2.0*xi[0]*xi[1]*xi[2]*(b[0]*b[1]) + 5.0/2.0*2.0*xi[0]*xi[1]*(b[2]*b[2]*lamb[2]*xi[1] + b[1]*b[1]*lamb_p[1]*xi[2]) + 5.0/2.0*2.0*xi[0]*xi[1]*xi[2]*(b[1]*b[1]*lamb_p[1]) + xi[0]*xi[0]*xi[1]*(-b[1])*b[2];
    psi2(0,4,4) = 3.0*xi[0]*xi[0]*(c[1]*c[1]*xi[2]) + 2.0*xi[0]*xi[1]*(-c[1]*c[2]*xi[0] + c[2]*c[0]*xi[1] + c[0]*c[1]*xi[2])  + 2.0*xi[0]*xi[1]*xi[2]*(c[0]*c[1]) + 5.0*xi[0]*xi[1]*(c[2]*c[2]*lamb[2]*xi[1] + c[1]*c[1]*lamb_p[1]*xi[2]) + 5.0*xi[0]*xi[1]*xi[2]*(c[1]*c[1]*lamb_p[1]) - xi[0]*xi[0]*xi[1]*(c[1])*c[2];
    psi2(0,5,4) = b[0]*c[0]*2.0*xi[0]*xi[1]*xi[2] + b[0]*c[0]*2.0*xi[0]*xi[1]*(xi[0] + xi[1] + xi[2]) + b[0]*c[0]*xi[0]*xi[0]*xi[1] + b[1]*c[1]*2.0*xi[0]*(xi[1]*xi[2] - xi[2]*xi[0] - xi[0]*xi[1] - xi[1]*xi[1]) 
     + b[1]*c[1]*2.0*xi[0]*xi[2]*(xi[1]- xi[0]) + b[1]*c[1]*xi[0]*xi[0]*(-xi[1] - xi[2])+ b[1]*c[1]*xi[0]*xi[0]*xi[2]*(-1.0)
     + b[2]*c[2]*2.0*xi[0]*xi[1]*(xi[1]-xi[0]- 2.0*xi[2]) + b[2]*c[2]*xi[0]*xi[0]*xi[1]*(-1.0)- 5.0*2.0*xi[0]*xi[1]*(b[1]*c[1]*lamb_p[1]*xi[2] + b[2]*c[2]*lamb[2]*xi[1]) - 5.0*2.0*xi[0]*xi[1]*xi[2]*(b[1]*c[1]*lamb_p[1]);
    
     // compute for the mixed-derivative wrt area coordinate1 and 2
    psi2(0,0,5) =  10.0*xi[0]*xi[0]*xi[0]*2.0 + 30.0*xi[0]*xi[0]*(lamb[2]*xi[1] + lamb_p[1]*xi[2]) + 30.0*xi[0]*xi[0]*xi[2]*(lamb_p[1]) + 30.0*xi[0]*xi[0]*xi[1]*(lamb[2]);
    psi2(0,1,5) = 3.0*b[0]*xi[0]*xi[0]*(xi[1]-xi[2]) - 3.0*b[0]*xi[0]*xi[0]*xi[2] + 3.0*b[0]*xi[0]*xi[0]*xi[1] + xi[0]*xi[0]*xi[0]*(-b[1])*(4.0)  +  xi[0]*xi[0]*xi[0]*(b[2])*(4.0)+ 15*xi[0]*xi[0]*(b[2]*lamb[2]*xi[1] - b[1]*lamb_p[1]*xi[2])+ 15*xi[0]*xi[0]*xi[2]*(-b[1]*lamb_p[1]) +15*xi[0]*xi[0]*xi[1]*(b[2]*lamb[2]);
    psi2(0,2,5) = -3.0*c[0]*xi[0]*xi[0]*xi[1] + 3.0*c[0]*xi[0]*xi[0]*xi[2] - 3.0*c[0]*xi[0]*xi[0]*(xi[1]-xi[2]) + xi[0]*xi[0]*xi[0]*(c[1])*(4.0) - xi[0]*xi[0]*xi[0]*(c[2])*(4.0) -15.0*xi[0]*xi[0]*xi[1]*(c[2]*lamb[2])
    + 15.0*xi[0]*xi[0]*xi[2]*(c[1]*lamb_p[1]) - 15.0*xi[0]*xi[0]*(c[2]*lamb[2]*xi[1] -c[1]*lamb_p[1]*xi[2]);
    psi2(0,3,5) =  xi[0]*xi[0]*xi[2]*(b[0]*b[1]) + xi[0]*xi[0]*(-b[1]*b[2]*xi[0] + b[2]*b[0]*xi[1] + b[0]*b[1]*xi[2]) + xi[0]*xi[0]*xi[1]*(b[2]*b[0]) + 5.0/2.0*xi[0]*xi[0]*xi[2]*(b[1]*b[1]*lamb_p[1]) + 5.0/2.0*xi[0]*xi[0]*(b[2]*b[2]*lamb[2]*xi[1] + b[1]*b[1]*lamb_p[1]*xi[2])+ 5.0/2.0*xi[0]*xi[0]*xi[1]*(b[2]*b[2]*lamb[2]);
    psi2(0,4,5) =  xi[0]*xi[0]*xi[1]*(c[2]*c[0]) + xi[0]*xi[0]*(-c[1]*c[2]*xi[0] + c[2]*c[0]*xi[1] + c[0]*c[1]*xi[2]) + xi[0]*xi[0]*xi[2]*(c[0]*c[1]) + 5.0/2.0*xi[0]*xi[0]*xi[1]*(c[2]*c[2]*lamb[2]) + 5.0/2.0*xi[0]*xi[0]*(c[2]*c[2]*lamb[2]*xi[1] + c[1]*c[1]*lamb_p[1]*xi[2]) + 5.0/2.0*xi[0]*xi[0]*xi[2]*(c[1]*c[1]*lamb_p[1]);
    psi2(0,5,5) = b[0]*c[0]*xi[0]*xi[0]*xi[1]+ b[0]*c[0]*xi[0]*xi[0]*(xi[0] + xi[1] + xi[2])  + b[0]*c[0]*xi[0]*xi[0]*xi[2] + b[1]*c[1]*xi[0]*xi[0]*(xi[2] - xi[0] - 2.0*xi[1]) 
     + b[1]*c[1]*xi[0]*xi[0]*xi[2] + b[2]*c[2]*xi[0]*xi[0]*(xi[1]-xi[0]-2.0*xi[2]) + b[2]*c[2]*xi[0]*xi[0]*xi[1] - 5.0*xi[0]*xi[0]*(b[1]*c[1]*lamb_p[1]*xi[2] + b[2]*c[2]*lamb[2]*xi[1]) 
     - 5.0*xi[0]*xi[0]*xi[2]*(b[1]*c[1]*lamb_p[1]) - 5.0*xi[0]*xi[0]*xi[1]*(b[2]*c[2]*lamb[2]);

    // by chain rule, we can obtain d2shape wrt s0s0 at node0
    d2psids(0,0,0) = (psi2(0,0,0)*dxids0[0] + psi2(0,0,3)*dxids0[1] + psi2(0,0,4)*dxids0[2])*dxids0[0] + 
                     (psi2(0,0,3)*dxids0[0] + psi2(0,0,1)*dxids0[1] + psi2(0,0,5)*dxids0[2])*dxids0[1] + 
                     (psi2(0,0,4)*dxids0[0] + psi2(0,0,5)*dxids0[1] + psi2(0,0,2)*dxids0[2])*dxids0[2];
    d2psids(0,1,0) = (psi2(0,1,0)*dxids0[0] + psi2(0,1,3)*dxids0[1] + psi2(0,1,4)*dxids0[2])*dxids0[0] + 
                     (psi2(0,1,3)*dxids0[0] + psi2(0,1,1)*dxids0[1] + psi2(0,1,5)*dxids0[2])*dxids0[1] + 
                     (psi2(0,1,4)*dxids0[0] + psi2(0,1,5)*dxids0[1] + psi2(0,1,2)*dxids0[2])*dxids0[2];
    d2psids(0,2,0) = (psi2(0,2,0)*dxids0[0] + psi2(0,2,3)*dxids0[1] + psi2(0,2,4)*dxids0[2])*dxids0[0] + 
                     (psi2(0,2,3)*dxids0[0] + psi2(0,2,1)*dxids0[1] + psi2(0,2,5)*dxids0[2])*dxids0[1] + 
                     (psi2(0,2,4)*dxids0[0] + psi2(0,2,5)*dxids0[1] + psi2(0,2,2)*dxids0[2])*dxids0[2];
    d2psids(0,3,0) = (psi2(0,3,0)*dxids0[0] + psi2(0,3,3)*dxids0[1] + psi2(0,3,4)*dxids0[2])*dxids0[0] + 
                     (psi2(0,3,3)*dxids0[0] + psi2(0,3,1)*dxids0[1] + psi2(0,3,5)*dxids0[2])*dxids0[1] + 
                     (psi2(0,3,4)*dxids0[0] + psi2(0,3,5)*dxids0[1] + psi2(0,3,2)*dxids0[2])*dxids0[2];
    d2psids(0,4,0) = (psi2(0,4,0)*dxids0[0] + psi2(0,4,3)*dxids0[1] + psi2(0,4,4)*dxids0[2])*dxids0[0] + 
                     (psi2(0,4,3)*dxids0[0] + psi2(0,4,1)*dxids0[1] + psi2(0,4,5)*dxids0[2])*dxids0[1] + 
                     (psi2(0,4,4)*dxids0[0] + psi2(0,4,5)*dxids0[1] + psi2(0,4,2)*dxids0[2])*dxids0[2];
    d2psids(0,5,0) = (psi2(0,5,0)*dxids0[0] + psi2(0,5,3)*dxids0[1] + psi2(0,5,4)*dxids0[2])*dxids0[0] + 
                     (psi2(0,5,3)*dxids0[0] + psi2(0,5,1)*dxids0[1] + psi2(0,5,5)*dxids0[2])*dxids0[1] + 
                     (psi2(0,5,4)*dxids0[0] + psi2(0,5,5)*dxids0[1] + psi2(0,5,2)*dxids0[2])*dxids0[2];
                     
    // by chain rule, we can obtain d2shape wrt s1s1 at node0
    d2psids(0,0,1) = (psi2(0,0,0)*dxids1[0] + psi2(0,0,3)*dxids1[1] + psi2(0,0,4)*dxids1[2])*dxids1[0] + 
                     (psi2(0,0,3)*dxids1[0] + psi2(0,0,1)*dxids1[1] + psi2(0,0,5)*dxids1[2])*dxids1[1] + 
                     (psi2(0,0,4)*dxids1[0] + psi2(0,0,5)*dxids1[1] + psi2(0,0,2)*dxids1[2])*dxids1[2];
    d2psids(0,1,1) = (psi2(0,1,0)*dxids1[0] + psi2(0,1,3)*dxids1[1] + psi2(0,1,4)*dxids1[2])*dxids1[0] + 
                     (psi2(0,1,3)*dxids1[0] + psi2(0,1,1)*dxids1[1] + psi2(0,1,5)*dxids1[2])*dxids1[1] + 
                     (psi2(0,1,4)*dxids1[0] + psi2(0,1,5)*dxids1[1] + psi2(0,1,2)*dxids1[2])*dxids1[2];
    d2psids(0,2,1) = (psi2(0,2,0)*dxids1[0] + psi2(0,2,3)*dxids1[1] + psi2(0,2,4)*dxids1[2])*dxids1[0] + 
                     (psi2(0,2,3)*dxids1[0] + psi2(0,2,1)*dxids1[1] + psi2(0,2,5)*dxids1[2])*dxids1[1] + 
                     (psi2(0,2,4)*dxids1[0] + psi2(0,2,5)*dxids1[1] + psi2(0,2,2)*dxids1[2])*dxids1[2];
    d2psids(0,3,1) = (psi2(0,3,0)*dxids1[0] + psi2(0,3,3)*dxids1[1] + psi2(0,3,4)*dxids1[2])*dxids1[0] + 
                     (psi2(0,3,3)*dxids1[0] + psi2(0,3,1)*dxids1[1] + psi2(0,3,5)*dxids1[2])*dxids1[1] + 
                     (psi2(0,3,4)*dxids1[0] + psi2(0,3,5)*dxids1[1] + psi2(0,3,2)*dxids1[2])*dxids1[2];
    d2psids(0,4,1) = (psi2(0,4,0)*dxids1[0] + psi2(0,4,3)*dxids1[1] + psi2(0,4,4)*dxids1[2])*dxids1[0] + 
                     (psi2(0,4,3)*dxids1[0] + psi2(0,4,1)*dxids1[1] + psi2(0,4,5)*dxids1[2])*dxids1[1] + 
                     (psi2(0,4,4)*dxids1[0] + psi2(0,4,5)*dxids1[1] + psi2(0,4,2)*dxids1[2])*dxids1[2];
    d2psids(0,5,1) = (psi2(0,5,0)*dxids1[0] + psi2(0,5,3)*dxids1[1] + psi2(0,5,4)*dxids1[2])*dxids1[0] + 
                     (psi2(0,5,3)*dxids1[0] + psi2(0,5,1)*dxids1[1] + psi2(0,5,5)*dxids1[2])*dxids1[1] + 
                     (psi2(0,5,4)*dxids1[0] + psi2(0,5,5)*dxids1[1] + psi2(0,5,2)*dxids1[2])*dxids1[2];
                     
    // by chain rule, we can obtain d2shape wrt s0s1 at node0
    d2psids(0,0,2) = (psi2(0,0,0)*dxids0[0] + psi2(0,0,3)*dxids0[1] + psi2(0,0,4)*dxids0[2])*dxids1[0] + 
                     (psi2(0,0,3)*dxids0[0] + psi2(0,0,1)*dxids0[1] + psi2(0,0,5)*dxids0[2])*dxids1[1] + 
                     (psi2(0,0,4)*dxids0[0] + psi2(0,0,5)*dxids0[1] + psi2(0,0,2)*dxids0[2])*dxids1[2];
    d2psids(0,1,2) = (psi2(0,1,0)*dxids0[0] + psi2(0,1,3)*dxids0[1] + psi2(0,1,4)*dxids0[2])*dxids1[0] + 
                     (psi2(0,1,3)*dxids0[0] + psi2(0,1,1)*dxids0[1] + psi2(0,1,5)*dxids0[2])*dxids1[1] + 
                     (psi2(0,1,4)*dxids0[0] + psi2(0,1,5)*dxids0[1] + psi2(0,1,2)*dxids0[2])*dxids1[2];
    d2psids(0,2,2) = (psi2(0,2,0)*dxids0[0] + psi2(0,2,3)*dxids0[1] + psi2(0,2,4)*dxids0[2])*dxids1[0] + 
                     (psi2(0,2,3)*dxids0[0] + psi2(0,2,1)*dxids0[1] + psi2(0,2,5)*dxids0[2])*dxids1[1] + 
                     (psi2(0,2,4)*dxids0[0] + psi2(0,2,5)*dxids0[1] + psi2(0,2,2)*dxids0[2])*dxids1[2];
    d2psids(0,3,2) = (psi2(0,3,0)*dxids0[0] + psi2(0,3,3)*dxids0[1] + psi2(0,3,4)*dxids0[2])*dxids1[0] + 
                     (psi2(0,3,3)*dxids0[0] + psi2(0,3,1)*dxids0[1] + psi2(0,3,5)*dxids0[2])*dxids1[1] + 
                     (psi2(0,3,4)*dxids0[0] + psi2(0,3,5)*dxids0[1] + psi2(0,3,2)*dxids0[2])*dxids1[2];
    d2psids(0,4,2) = (psi2(0,4,0)*dxids0[0] + psi2(0,4,3)*dxids0[1] + psi2(0,4,4)*dxids0[2])*dxids1[0] + 
                     (psi2(0,4,3)*dxids0[0] + psi2(0,4,1)*dxids0[1] + psi2(0,4,5)*dxids0[2])*dxids1[1] + 
                     (psi2(0,4,4)*dxids0[0] + psi2(0,4,5)*dxids0[1] + psi2(0,4,2)*dxids0[2])*dxids1[2];
    d2psids(0,5,2) = (psi2(0,5,0)*dxids0[0] + psi2(0,5,3)*dxids0[1] + psi2(0,5,4)*dxids0[2])*dxids1[0] + 
                     (psi2(0,5,3)*dxids0[0] + psi2(0,5,1)*dxids0[1] + psi2(0,5,5)*dxids0[2])*dxids1[1] + 
                     (psi2(0,5,4)*dxids0[0] + psi2(0,5,5)*dxids0[1] + psi2(0,5,2)*dxids0[2])*dxids1[2];
    //-------------------------------------------------------------------------------------
    // compute for all second derivatives at node 1
    //------------------------------------------------------------------------------------
    // compute for the second derivatives wrt area coordinate1 
    psi2(1,0,1) = 5.0*4.0*xi[1]*xi[1]*xi[1] +5.0*4.0*3.0*xi[1]*xi[1]*(xi[2]+xi[0]) + 10.0*3.0*2.0*xi[1]*(xi[2]+xi[0])*(xi[2]+xi[0]) +30.0*2.0*xi[2]*xi[0]*(lamb[0]*xi[2] + lamb_p[2]*xi[0]);
    psi2(1,1,1) = 3.0*b[1]*2.0*xi[2]*xi[0]*(xi[2]-xi[0]) +  3.0*2.0*xi[1]*(b[0]*xi[2] -b[2]*xi[0])*(xi[1] + 4.0*xi[2] + 4.0*xi[0])+ 3.0*xi[1]*xi[1]*(b[0]*xi[2] -b[2]*xi[0]) + 3.0*xi[1]*xi[1]*(b[0]*xi[2] -b[2]*xi[0]) + 15*2.0*xi[2]*xi[0]*(b[0]*lamb[0]*xi[2] - b[2]*lamb_p[2]*xi[0]);
    psi2(1,2,1) = -3.0*c[1]*2.0*xi[2]*xi[0]*(xi[2]-xi[0]) - 3.0*2.0*xi[1]*(c[0]*xi[2] -c[2]*xi[0])*(xi[1] + 4.0*xi[2] + 4.0*xi[0]) - 3.0*xi[1]*xi[1]*(c[0]*xi[2] -c[2]*xi[0]) - 3.0*xi[1]*xi[1]*(c[0]*xi[2] -c[2]*xi[0]) -15.0*2.0*xi[2]*xi[0]*(c[0]*lamb[0]*xi[2] -c[2]*lamb_p[2]*xi[0]);
    psi2(1,3,1) = 1.0/2.0*3.0*2.0*xi[1]*(b[0]*b[0]*xi[2]*xi[2] + b[2]*b[2]*xi[0]*xi[0]) + 2.0*xi[2]*xi[0]*(-b[2]*b[0]*xi[1] + b[0]*b[1]*xi[2] + b[1]*b[2]*xi[0]) - 4.0*xi[1]*xi[2]*xi[0]*(b[2]*b[0])+ 5.0*xi[2]*xi[0]*(b[0]*b[0]*lamb[0]*xi[2] + b[2]*b[2]*lamb_p[2]*xi[0]);
    psi2(1,4,1) = 1.0/2.0*3.0*2.0*xi[1]*(c[0]*c[0]*xi[2]*xi[2] + c[2]*c[2]*xi[0]*xi[0]) + 2.0*xi[2]*xi[0]*(-c[2]*c[0]*xi[1] + c[0]*c[1]*xi[2] + c[1]*c[2]*xi[0]) - 4.0*xi[1]*xi[2]*xi[0]*(c[2]*c[0])+ 5.0*xi[2]*xi[0]*(c[0]*c[0]*lamb[0]*xi[2] + c[2]*c[2]*lamb_p[2]*xi[0]);
    psi2(1,5,1) = b[1]*c[1]*2.0*xi[2]*xi[0]*(xi[1] + xi[2] + xi[0]) + b[1]*c[1]*2.0*xi[1]*xi[2]*xi[0] + b[1]*c[1]*2.0*xi[1]*xi[2]*xi[0] + b[2]*c[2]*2.0*xi[0]*(xi[2]*xi[0] - xi[0]*xi[1] - xi[1]*xi[2] - xi[2]*xi[2]) - 4.0*b[2]*c[2]*xi[1]*xi[0]*(xi[0]+xi[2]) + b[0]*c[0]*2.0*xi[2]*(xi[2]*xi[0] - xi[0]*xi[1] -xi[1]*xi[2] - xi[0]*xi[0]) - 4.0*b[0]*c[0]*2.0*xi[1]*xi[2]*(xi[0]+xi[2]) - 5.0*2.0*xi[2]*xi[0]*(b[2]*c[2]*lamb_p[2]*xi[0] + b[0]*c[0]*lamb[0]*xi[2]);
     
    // compute for the second derivatives wrt area coordinate2
    psi2(1,0,2) = 10.0*xi[1]*xi[1]*xi[1]*2.0 +30.0*xi[1]*xi[1]*xi[0]*(lamb[0]) +30.0*xi[1]*xi[1]*xi[0]*(lamb[0]);
    psi2(1,1,2) = 3.0*b[1]*xi[1]*xi[1]*xi[0]+ 3.0*b[1]*xi[1]*xi[1]*xi[0] +  xi[1]*xi[1]*xi[1]*(b[0])*(4.0)+  xi[1]*xi[1]*xi[1]*(b[0])*(4.0)+ 15*xi[1]*xi[1]*xi[0]*(b[0]*lamb[0]) + 15*xi[1]*xi[1]*xi[0]*(b[0]*lamb[0]);
    psi2(1,2,2) =  -3.0*c[1]*xi[1]*xi[1]*xi[0]- 3.0*c[1]*xi[1]*xi[1]*xi[0]- xi[1]*xi[1]*xi[1]*(c[0])*(4.0) - xi[1]*xi[1]*xi[1]*(c[0])*(4.0) -15.0*xi[1]*xi[1]*xi[0]*(c[0]*lamb[0])-15.0*xi[1]*xi[1]*xi[0]*(c[0]*lamb[0]);
    psi2(1,3,2) = 1.0/2.0*xi[1]*xi[1]*xi[1]*(b[0]*b[0]*2.0) + xi[1]*xi[1]*xi[0]*(b[0]*b[1]) + xi[1]*xi[1]*xi[0]*(b[0]*b[1]) + 5.0*xi[1]*xi[1]*xi[0]*(b[0]*b[0]*lamb[0]);
    psi2(1,4,2) = 1.0/2.0*xi[1]*xi[1]*xi[1]*(c[0]*c[0]*2.0) + xi[1]*xi[1]*xi[0]*(c[0]*c[1]) + xi[1]*xi[1]*xi[0]*(c[0]*c[1]) + 5.0*xi[1]*xi[1]*xi[0]*(c[0]*c[0]*lamb[0]);
    psi2(1,5,2) = b[1]*c[1]*xi[1]*xi[1]*xi[0] + b[1]*c[1]*xi[1]*xi[1]*xi[0] + b[2]*c[2]*xi[1]*xi[1]*xi[0]*(-2.0) + b[0]*c[0]*xi[1]*xi[1]*(xi[0]-xi[1]) + b[0]*c[0]*xi[1]*xi[1]*(xi[0]-xi[1]) - 5.0*xi[1]*xi[1]*xi[0]*( b[0]*c[0]*lamb[0]) - 5.0*xi[1]*xi[1]*xi[0]*(b[0]*c[0]*lamb[0]);
     
    // compute for the second derivatives wrt area coordinate0
    psi2(1,0,0) = 10.0*xi[1]*xi[1]*xi[1]*2.0 +30.0*xi[1]*xi[1]*xi[2]*(lamb_p[2])  +30.0*xi[1]*xi[1]*xi[2]*(lamb_p[2]);
    psi2(1,1,0) =  -6.0*b[1]*xi[1]*xi[1]*xi[2] +  xi[1]*xi[1]*xi[1]*(-b[2])*( 4.0)+  xi[1]*xi[1]*xi[1]*(-b[2])*(4.0) - 30*xi[1]*xi[1]*xi[2]*(b[2]*lamb_p[2]);
    psi2(1,2,0) =  3.0*c[1]*xi[1]*xi[1]*xi[2] +  3.0*c[1]*xi[1]*xi[1]*xi[2] + xi[1]*xi[1]*xi[1]*(c[2])*(4.0) + xi[1]*xi[1]*xi[1]*(c[2])*(4.0) + 30.0*xi[1]*xi[1]*xi[2]*(c[2]*lamb_p[2]);
    psi2(1,3,0) = xi[1]*xi[1]*xi[1]*(b[2]*b[2]) + 2.0*xi[1]*xi[1]*xi[2]*(b[1]*b[2]) + 5.0*xi[1]*xi[1]*xi[2]*(b[2]*b[2]*lamb_p[2]);
    psi2(1,4,0) = xi[1]*xi[1]*xi[1]*(c[2]*c[2]) + 2.0*xi[1]*xi[1]*xi[2]*(c[1]*c[2]) + 5.0*xi[1]*xi[1]*xi[2]*(c[2]*c[2]*lamb_p[2]);
    psi2(1,5,0) = 2.0*b[1]*c[1]*xi[1]*xi[1]*xi[2] + b[2]*c[2]*xi[1]*xi[1]*(xi[2] - xi[1]) + b[2]*c[2]*xi[1]*xi[1]*(xi[2]- xi[1]) + b[0]*c[0]*xi[1]*xi[1]*xi[2]*(-2.0) - 5.0*xi[1]*xi[1]*xi[2]*(b[2]*c[2]*lamb_p[2]) - 5.0*xi[1]*xi[1]*xi[2]*(b[2]*c[2]*lamb_p[2]);
    
    // compute for the second derivatives wrt area coordinate0 and 1
    psi2(1,0,3) = 5.0*4.0*xi[1]*xi[1]*xi[1] + 10.0*3.0*xi[1]*xi[1]*2.0*(xi[2]+xi[0])+ 30.0*2.0*xi[1]*xi[2]*xi[0]*(lamb_p[2])+30.0*2.0*xi[1]*xi[2]*(lamb[0]*xi[2] + lamb_p[2]*xi[0]);
    psi2(1,1,3) = 3.0*b[1]*2.0*xi[1]*xi[2]*(xi[2]-xi[0]) + 3.0*b[1]*2.0*xi[1]*xi[2]*xi[0]*(-1.0)+  3.0*xi[1]*xi[1]*(-b[2])*(xi[1] + 4.0*xi[2] + 4.0*xi[0]) + 3.0*xi[1]*xi[1]*(b[0]*xi[2] -b[2]*xi[0])*(4.0) + xi[1]*xi[1]*xi[1]*(-b[2]) + 15*2.0*xi[1]*xi[2]*(b[0]*lamb[0]*xi[2] - b[2]*lamb_p[2]*xi[0])+ 15*2.0*xi[1]*xi[2]*xi[0]*(-b[2]*lamb_p[2]);
    psi2(1,2,3) = 3.0*c[1]*2.0*xi[1]*xi[2]*xi[0]  -3.0*c[1]*2.0*xi[1]*xi[2]*(xi[2]-xi[0]) - 3.0*xi[1]*xi[1]*(c[0]*xi[2] - c[2]*xi[0])*(4.0) + 3.0*xi[1]*xi[1]*(c[2])*(xi[1] + 4.0*xi[2] + 4.0*xi[0]) + xi[1]*xi[1]*xi[1]*(c[2])  + 15.0*2.0*xi[1]*xi[2]*xi[0]*(c[2]*lamb_p[2]) - 15.0*2.0*xi[1]*xi[2]*(c[0]*lamb[0]*xi[2] -c[2]*lamb_p[2]*xi[0]);
    psi2(1,3,3) = 3.0*xi[1]*xi[1]*(b[2]*b[2]*xi[0]) + 2.0*xi[1]*xi[2]*(-b[2]*b[0]*xi[1] + b[0]*b[1]*xi[2] + b[1]*b[2]*xi[0])+ 2.0*xi[1]*xi[2]*xi[0]*(b[1]*b[2]) + 5.0/2.0*2.0*xi[1]*xi[2]*(b[0]*b[0]*lamb[0]*xi[2] + b[2]*b[2]*lamb_p[2]*xi[0])+ 5.0/2.0*2.0*xi[1]*xi[2]*xi[0]*(b[2]*b[2]*lamb_p[2]) + xi[1]*xi[1]*xi[2]*(-b[2])*b[0];
    psi2(1,4,3) = 3.0*xi[1]*xi[1]*(c[2]*c[2]*xi[0]) + 2.0*xi[1]*xi[2]*(-c[2]*c[0]*xi[1] + c[0]*c[1]*xi[2] + c[1]*c[2]*xi[0]) + 2.0*xi[1]*xi[2]*xi[0]*(c[1]*c[2])+ 5.0/2.0*2.0*xi[1]*xi[2]*(c[0]*c[0]*lamb[0]*xi[2] + c[2]*c[2]*lamb_p[2]*xi[0])+ 5.0/2.0*2.0*xi[1]*xi[2]*xi[0]*(c[2]*c[2]*lamb_p[2])+ xi[1]*xi[1]*xi[2]*(-c[2])*c[0];
    psi2(1,5,3) = b[1]*c[1]*2.0*xi[1]*xi[2]*xi[0] + b[1]*c[1]*2.0*xi[1]*xi[2]*(xi[1] + xi[2] + xi[0]) + b[1]*c[1]*xi[1]*xi[1]*xi[2] + b[2]*c[2]*2.0*xi[1]*(xi[2]*xi[0] - xi[0]*xi[1] - xi[1]*xi[2] - xi[2]*xi[2]) + b[2]*c[2]*2.0*xi[1]*xi[0]*(xi[2]- xi[1]) + b[2]*c[2]*xi[1]*xi[1]*(-xi[2] - xi[0])+ b[2]*c[2]*xi[1]*xi[1]*xi[0]*(-1.0)
     + b[0]*c[0]*2.0*xi[1]*xi[2]*(xi[2]-xi[1]- 2.0*xi[0]) + b[0]*c[0]*xi[1]*xi[1]*xi[2]*(-1.0)- 5.0*2.0*xi[1]*xi[2]*(b[2]*c[2]*lamb_p[2]*xi[0] + b[0]*c[0]*lamb[0]*xi[2]) - 5.0*2.0*xi[1]*xi[2]*xi[0]*(b[2]*c[2]*lamb_p[2]);
   
    // compute for the second derivatives wrt area coordinate0 and 2
    psi2(1,0,4) = 10.0*xi[1]*xi[1]*xi[1]*2.0 + 30.0*xi[1]*xi[1]*(lamb[0]*xi[2] + lamb_p[2]*xi[0])  +30.0*xi[1]*xi[1]*xi[0]*(lamb_p[2]) + 30.0*xi[1]*xi[1]*xi[2]*(lamb[0]);
    psi2(1,1,4) = 3.0*b[1]*xi[1]*xi[1]*(xi[2]-xi[0]) + 3.0*b[1]*xi[1]*xi[1]*xi[0]*(-1.0)+ 3.0*b[1]*xi[1]*xi[1]*xi[2] +  xi[1]*xi[1]*xi[1]*(-b[2])*(4.0)+  xi[1]*xi[1]*xi[1]*(b[0])*(4.0)  + 15*xi[1]*xi[1]*(b[0]*lamb[0]*xi[2] - b[2]*lamb_p[2]*xi[0]) + 15*xi[1]*xi[1]*xi[0]*(-b[2]*lamb_p[2]) + 15*xi[1]*xi[1]*xi[2]*(b[0]*lamb[0]);
    psi2(1,2,4) = 3.0*c[1]*xi[1]*xi[1]*xi[0]  - 3.0*c[1]*xi[1]*xi[1]*(xi[2]-xi[0]) - 3.0*c[1]*xi[1]*xi[1]*xi[2] - xi[1]*xi[1]*xi[1]*(c[0])*(4.0) + 4.0*xi[1]*xi[1]*xi[1]*(c[2]) + 15.0*xi[1]*xi[1]*xi[0]*(c[2]*lamb_p[2]) - 15.0*xi[1]*xi[1]*(c[0]*lamb[0]*xi[2] -c[2]*lamb_p[2]*xi[0]) -15.0*xi[1]*xi[1]*xi[2]*(c[0]*lamb[0]);
    psi2(1,3,4) =  xi[1]*xi[1]*xi[0]*(b[1]*b[2]) + xi[1]*xi[1]*(-b[2]*b[0]*xi[1] + b[0]*b[1]*xi[2] + b[1]*b[2]*xi[0]) + xi[1]*xi[1]*xi[2]*(b[0]*b[1]) + 5.0/2.0*xi[1]*xi[1]*xi[0]*(b[2]*b[2]*lamb_p[2]) + 5.0/2.0*xi[1]*xi[1]*(b[0]*b[0]*lamb[0]*xi[2] + b[2]*b[2]*lamb_p[2]*xi[0]) + 5.0/2.0*xi[1]*xi[1]*xi[2]*(b[0]*b[0]*lamb[0]);
    psi2(1,4,4) =  xi[1]*xi[1]*xi[2]*(c[0]*c[1]) + xi[1]*xi[1]*(-c[2]*c[0]*xi[1] + c[0]*c[1]*xi[2] + c[1]*c[2]*xi[0])+ xi[1]*xi[1]*xi[0]*(c[1]*c[2]) + 5.0/2.0*xi[1]*xi[1]*xi[2]*(c[0]*c[0]*lamb[0]) + 5.0/2.0*xi[1]*xi[1]*(c[0]*c[0]*lamb[0]*xi[2] + c[2]*c[2]*lamb_p[2]*xi[0]) + 5.0/2.0*xi[1]*xi[1]*xi[0]*(c[2]*c[2]*lamb_p[2]);
    psi2(1,5,4) = b[1]*c[1]*xi[1]*xi[1]*xi[2]+ b[1]*c[1]*xi[1]*xi[1]*(xi[1] + xi[2] + xi[0]) + b[1]*c[1]*xi[1]*xi[1]*xi[0] + b[2]*c[2]*xi[1]*xi[1]*(xi[0] - xi[1] - 2.0*xi[2]) + b[2]*c[2]*xi[1]*xi[1]*xi[0] + b[0]*c[0]*xi[1]*xi[1]*xi[2] + b[0]*c[0]*xi[1]*xi[1]*(xi[2]- xi[1] - 2.0*xi[0]) - 5.0*xi[1]*xi[1]*xi[2]*(b[0]*c[0]*lamb[0])- 5.0*xi[1]*xi[1]*(b[2]*c[2]*lamb_p[2]*xi[0] + b[0]*c[0]*lamb[0]*xi[2]) - 5.0*xi[1]*xi[1]*xi[0]*(b[2]*c[2]*lamb_p[2]);
  
    // compute for the second derivatives wrt area coordinate1 and 2
    psi2(1,0,5) = 5.0*4.0*xi[1]*xi[1]*xi[1] + 10.0*3.0*xi[1]*xi[1]*2.0*(xi[2]+xi[0]) +30.0*2.0*xi[1]*xi[0]*(lamb[0]*xi[2] + lamb_p[2]*xi[0]) + 30.0*2.0*xi[1]*xi[2]*xi[0]*(lamb[0]);
    psi2(1,1,5) = 3.0*b[1]*2.0*xi[1]*xi[0]*(xi[2]-xi[0])+ 3.0*b[1]*2.0*xi[1]*xi[2]*xi[0] +  3.0*xi[1]*xi[1]*(b[0])*(xi[1] + 4.0*xi[2] + 4.0*xi[0]) + 3.0*xi[1]*xi[1]*(b[0]*xi[2] -b[2]*xi[0])*(4.0) + xi[1]*xi[1]*xi[1]*(b[0])+ 15*2.0*xi[1]*xi[0]*(b[0]*lamb[0]*xi[2] - b[2]*lamb_p[2]*xi[0]) + 15*2.0*xi[1]*xi[2]*xi[0]*(b[0]*lamb[0]);
    psi2(1,2,5) = -3.0*c[1]*2.0*xi[1]*xi[0]*(xi[2]-xi[0]) -3.0*c[1]*2.0*xi[1]*xi[2]*xi[0] - 3.0*xi[1]*xi[1]*(c[0])*(xi[1] + 4.0*xi[2] + 4.0*xi[0]) - 3.0*xi[1]*xi[1]*(c[0]*xi[2] -c[2]*xi[0])*(4.0) - xi[1]*xi[1]*xi[1]*(c[0]) -15.0*2.0*xi[1]*xi[0]*(c[0]*lamb[0]*xi[2] -c[2]*lamb_p[2]*xi[0]) -15.0*2.0*xi[1]*xi[2]*xi[0]*(c[0]*lamb[0]);
    psi2(1,3,5) = 3.0*xi[1]*xi[1]*(b[0]*b[0]*xi[2]) + 2.0*xi[1]*xi[0]*(-b[2]*b[0]*xi[1] + b[0]*b[1]*xi[2] + b[1]*b[2]*xi[0]) + 2.0*xi[1]*xi[2]*xi[0]*(b[0]*b[1]) + 5.0/2.0*2.0*xi[1]*xi[0]*(b[0]*b[0]*lamb[0]*xi[2] + b[2]*b[2]*lamb_p[2]*xi[0])+ 5.0/2.0*2.0*xi[1]*xi[2]*xi[0]*(b[0]*b[0]*lamb[0]) + xi[1]*xi[1]*xi[0]*(-b[2])*b[0];
    psi2(1,4,5) = 3.0*xi[1]*xi[1]*(c[0]*c[0]*xi[2]) + 2.0*xi[1]*xi[0]*(-c[2]*c[0]*xi[1] + c[0]*c[1]*xi[2] + c[1]*c[2]*xi[0]) + 2.0*xi[1]*xi[2]*xi[0]*(c[0]*c[1]) + 5.0/2.0*2.0*xi[1]*xi[0]*(c[0]*c[0]*lamb[0]*xi[2] + c[2]*c[2]*lamb_p[2]*xi[0])+ 5.0/2.0*2.0*xi[1]*xi[2]*xi[0]*(c[0]*c[0]*lamb[0])+ xi[1]*xi[1]*xi[0]*(-c[2])*c[0];
    psi2(1,5,5) = b[1]*c[1]*2.0*xi[1]*xi[0]*(xi[1] + xi[2] + xi[0]) + b[1]*c[1]*2.0*xi[1]*xi[2]*xi[0] + b[1]*c[1]*xi[1]*xi[1]*xi[0] + b[2]*c[2]*2.0*xi[1]*xi[0]*(xi[0] - xi[1] - 2.0*xi[2]) + b[2]*c[2]*xi[1]*xi[1]*xi[0]*(-1.0) + b[0]*c[0]*2.0*xi[1]*(xi[2]*xi[0] - xi[0]*xi[1] -xi[1]*xi[2] - xi[0]*xi[0]) + b[0]*c[0]*2.0*xi[1]*xi[2]*(xi[0] -xi[1]) + b[0]*c[0]*xi[1]*xi[1]*(- xi[0]-xi[2]) + b[0]*c[0]*xi[1]*xi[1]*xi[2]*(-1.0) - 5.0*2.0*xi[1]*xi[0]*(b[2]*c[2]*lamb_p[2]*xi[0] + b[0]*c[0]*lamb[0]*xi[2]) - 5.0*2.0*xi[1]*xi[2]*xi[0]*(b[0]*c[0]*lamb[0]);
  
    // by chain rule, we can obtain d2shape wrt s0s0 at node1
    d2psids(1,0,0) = (psi2(1,0,0)*dxids0[0] + psi2(1,0,3)*dxids0[1] + psi2(1,0,4)*dxids0[2])*dxids0[0] + 
                     (psi2(1,0,3)*dxids0[0] + psi2(1,0,1)*dxids0[1] + psi2(1,0,5)*dxids0[2])*dxids0[1] + 
                     (psi2(1,0,4)*dxids0[0] + psi2(1,0,5)*dxids0[1] + psi2(1,0,2)*dxids0[2])*dxids0[2];
    d2psids(1,1,0) = (psi2(1,1,0)*dxids0[0] + psi2(1,1,3)*dxids0[1] + psi2(1,1,4)*dxids0[2])*dxids0[0] + 
                     (psi2(1,1,3)*dxids0[0] + psi2(1,1,1)*dxids0[1] + psi2(1,1,5)*dxids0[2])*dxids0[1] + 
                     (psi2(1,1,4)*dxids0[0] + psi2(1,1,5)*dxids0[1] + psi2(1,1,2)*dxids0[2])*dxids0[2];
    d2psids(1,2,0) = (psi2(1,2,0)*dxids0[0] + psi2(1,2,3)*dxids0[1] + psi2(1,2,4)*dxids0[2])*dxids0[0] + 
                     (psi2(1,2,3)*dxids0[0] + psi2(1,2,1)*dxids0[1] + psi2(1,2,5)*dxids0[2])*dxids0[1] + 
                     (psi2(1,2,4)*dxids0[0] + psi2(1,2,5)*dxids0[1] + psi2(1,2,2)*dxids0[2])*dxids0[2];
    d2psids(1,3,0) = (psi2(1,3,0)*dxids0[0] + psi2(1,3,3)*dxids0[1] + psi2(1,3,4)*dxids0[2])*dxids0[0] + 
                     (psi2(1,3,3)*dxids0[0] + psi2(1,3,1)*dxids0[1] + psi2(1,3,5)*dxids0[2])*dxids0[1] + 
                     (psi2(1,3,4)*dxids0[0] + psi2(1,3,5)*dxids0[1] + psi2(1,3,2)*dxids0[2])*dxids0[2];
    d2psids(1,4,0) = (psi2(1,4,0)*dxids0[0] + psi2(1,4,3)*dxids0[1] + psi2(1,4,4)*dxids0[2])*dxids0[0] + 
                     (psi2(1,4,3)*dxids0[0] + psi2(1,4,1)*dxids0[1] + psi2(1,4,5)*dxids0[2])*dxids0[1] + 
                     (psi2(1,4,4)*dxids0[0] + psi2(1,4,5)*dxids0[1] + psi2(1,4,2)*dxids0[2])*dxids0[2];
    d2psids(1,5,0) = (psi2(1,5,0)*dxids0[0] + psi2(1,5,3)*dxids0[1] + psi2(1,5,4)*dxids0[2])*dxids0[0] + 
                     (psi2(1,5,3)*dxids0[0] + psi2(1,5,1)*dxids0[1] + psi2(1,5,5)*dxids0[2])*dxids0[1] + 
                     (psi2(1,5,4)*dxids0[0] + psi2(1,5,5)*dxids0[1] + psi2(1,5,2)*dxids0[2])*dxids0[2];
                     
    // by chain rule, we can obtain d2shape wrt s1s1 at node1
    d2psids(1,0,1) = (psi2(1,0,0)*dxids1[0] + psi2(1,0,3)*dxids1[1] + psi2(1,0,4)*dxids1[2])*dxids1[0] + 
                     (psi2(1,0,3)*dxids1[0] + psi2(1,0,1)*dxids1[1] + psi2(1,0,5)*dxids1[2])*dxids1[1] + 
                     (psi2(1,0,4)*dxids1[0] + psi2(1,0,5)*dxids1[1] + psi2(1,0,2)*dxids1[2])*dxids1[2];
    d2psids(1,1,1) = (psi2(1,1,0)*dxids1[0] + psi2(1,1,3)*dxids1[1] + psi2(1,1,4)*dxids1[2])*dxids1[0] + 
                     (psi2(1,1,3)*dxids1[0] + psi2(1,1,1)*dxids1[1] + psi2(1,1,5)*dxids1[2])*dxids1[1] + 
                     (psi2(1,1,4)*dxids1[0] + psi2(1,1,5)*dxids1[1] + psi2(1,1,2)*dxids1[2])*dxids1[2];
    d2psids(1,2,1) = (psi2(1,2,0)*dxids1[0] + psi2(1,2,3)*dxids1[1] + psi2(1,2,4)*dxids1[2])*dxids1[0] + 
                     (psi2(1,2,3)*dxids1[0] + psi2(1,2,1)*dxids1[1] + psi2(1,2,5)*dxids1[2])*dxids1[1] + 
                     (psi2(1,2,4)*dxids1[0] + psi2(1,2,5)*dxids1[1] + psi2(1,2,2)*dxids1[2])*dxids1[2];
    d2psids(1,3,1) = (psi2(1,3,0)*dxids1[0] + psi2(1,3,3)*dxids1[1] + psi2(1,3,4)*dxids1[2])*dxids1[0] + 
                     (psi2(1,3,3)*dxids1[0] + psi2(1,3,1)*dxids1[1] + psi2(1,3,5)*dxids1[2])*dxids1[1] + 
                     (psi2(1,3,4)*dxids1[0] + psi2(1,3,5)*dxids1[1] + psi2(1,3,2)*dxids1[2])*dxids1[2];
    d2psids(1,4,1) = (psi2(1,4,0)*dxids1[0] + psi2(1,4,3)*dxids1[1] + psi2(1,4,4)*dxids1[2])*dxids1[0] + 
                     (psi2(1,4,3)*dxids1[0] + psi2(1,4,1)*dxids1[1] + psi2(1,4,5)*dxids1[2])*dxids1[1] + 
                     (psi2(1,4,4)*dxids1[0] + psi2(1,4,5)*dxids1[1] + psi2(1,4,2)*dxids1[2])*dxids1[2];
    d2psids(1,5,1) = (psi2(1,5,0)*dxids1[0] + psi2(1,5,3)*dxids1[1] + psi2(1,5,4)*dxids1[2])*dxids1[0] + 
                     (psi2(1,5,3)*dxids1[0] + psi2(1,5,1)*dxids1[1] + psi2(1,5,5)*dxids1[2])*dxids1[1] + 
                     (psi2(1,5,4)*dxids1[0] + psi2(1,5,5)*dxids1[1] + psi2(1,5,2)*dxids1[2])*dxids1[2];
    
    // by chain rule, we can obtain d2shape wrt s0s1 at node1
    d2psids(1,0,2) = (psi2(1,0,0)*dxids0[0] + psi2(1,0,3)*dxids0[1] + psi2(1,0,4)*dxids0[2])*dxids1[0] + 
                     (psi2(1,0,3)*dxids0[0] + psi2(1,0,1)*dxids0[1] + psi2(1,0,5)*dxids0[2])*dxids1[1] + 
                     (psi2(1,0,4)*dxids0[0] + psi2(1,0,5)*dxids0[1] + psi2(1,0,2)*dxids0[2])*dxids1[2];
    d2psids(1,1,2) = (psi2(1,1,0)*dxids0[0] + psi2(1,1,3)*dxids0[1] + psi2(1,1,4)*dxids0[2])*dxids1[0] + 
                     (psi2(1,1,3)*dxids0[0] + psi2(1,1,1)*dxids0[1] + psi2(1,1,5)*dxids0[2])*dxids1[1] + 
                     (psi2(1,1,4)*dxids0[0] + psi2(1,1,5)*dxids0[1] + psi2(1,1,2)*dxids0[2])*dxids1[2];
    d2psids(1,2,2) = (psi2(1,2,0)*dxids0[0] + psi2(1,2,3)*dxids0[1] + psi2(1,2,4)*dxids0[2])*dxids1[0] + 
                     (psi2(1,2,3)*dxids0[0] + psi2(1,2,1)*dxids0[1] + psi2(1,2,5)*dxids0[2])*dxids1[1] + 
                     (psi2(1,2,4)*dxids0[0] + psi2(1,2,5)*dxids0[1] + psi2(1,2,2)*dxids0[2])*dxids1[2];
    d2psids(1,3,2) = (psi2(1,3,0)*dxids0[0] + psi2(1,3,3)*dxids0[1] + psi2(1,3,4)*dxids0[2])*dxids1[0] + 
                     (psi2(1,3,3)*dxids0[0] + psi2(1,3,1)*dxids0[1] + psi2(1,3,5)*dxids0[2])*dxids1[1] + 
                     (psi2(1,3,4)*dxids0[0] + psi2(1,3,5)*dxids0[1] + psi2(1,3,2)*dxids0[2])*dxids1[2];
    d2psids(1,4,2) = (psi2(1,4,0)*dxids0[0] + psi2(1,4,3)*dxids0[1] + psi2(1,4,4)*dxids0[2])*dxids1[0] + 
                     (psi2(1,4,3)*dxids0[0] + psi2(1,4,1)*dxids0[1] + psi2(1,4,5)*dxids0[2])*dxids1[1] + 
                     (psi2(1,4,4)*dxids0[0] + psi2(1,4,5)*dxids0[1] + psi2(1,4,2)*dxids0[2])*dxids1[2];
    d2psids(1,5,2) = (psi2(1,5,0)*dxids0[0] + psi2(1,5,3)*dxids0[1] + psi2(1,5,4)*dxids0[2])*dxids1[0] + 
                     (psi2(1,5,3)*dxids0[0] + psi2(1,5,1)*dxids0[1] + psi2(1,5,5)*dxids0[2])*dxids1[1] + 
                     (psi2(1,5,4)*dxids0[0] + psi2(1,5,5)*dxids0[1] + psi2(1,5,2)*dxids0[2])*dxids1[2];
    //-------------------------------------------------------------------------------------
    // compute for all second derivatives at node 2
    //------------------------------------------------------------------------------------
    // compute for the second derivatives wrt area coordinate2
    psi2(2,0,2) = 5.0*4.0*xi[2]*xi[2]*xi[2] +5.0*4.0*3.0*xi[2]*xi[2]*(xi[0]+xi[1]) + 10.0*3.0*2.0*xi[2]*(xi[0]+xi[1])*(xi[0]+xi[1]) + 30.0*2.0*xi[0]*xi[1]*(lamb[1]*xi[0] + lamb_p[0]*xi[1]);
    psi2(2,1,2) =  3.0*b[2]*2.0*xi[0]*xi[1]*(xi[0]-xi[1]) +  6.0*xi[2]*xi[2]*(b[1]*xi[0] - b[0]*xi[1]) + 30.0*xi[0]*xi[1]*(b[1]*lamb[1]*xi[0] - b[0]*lamb_p[0]*xi[1]) +  3.0*2.0*xi[2]*(b[1]*xi[0] -b[0]*xi[1])*(xi[2] + 4.0*xi[0] + 4*xi[1]);
    psi2(2,2,2) = -3.0*c[2]*2.0*xi[0]*xi[1]*(xi[0]-xi[1]) - 3.0*2.0*xi[2]*(c[1]*xi[0] -c[0]*xi[1])*(xi[2] + 4.0*xi[0] + 4.0*xi[1]) - 6.0*xi[2]*xi[2]*(c[1]*xi[0] -c[0]*xi[1]) -15.0*2.0*xi[0]*xi[1]*(c[1]*lamb[1]*xi[0] -c[0]*lamb_p[0]*xi[1]);
    psi2(2,3,2) = 1.0/2.0*3.0*2.0*xi[2]*(b[1]*b[1]*xi[0]*xi[0] + b[0]*b[0]*xi[1]*xi[1]) + 2.0*xi[0]*xi[1]*(-b[0]*b[1]*xi[2] + b[1]*b[2]*xi[0] + b[2]*b[0]*xi[1]) + 2.0*xi[2]*xi[0]*xi[1]*(-b[0]*b[1])
     + 5.0/2.0*2.0*xi[0]*xi[1]*(b[1]*b[1]*lamb[1]*xi[0] + b[0]*b[0]*lamb_p[0]*xi[1]) + 2.0*xi[2]*xi[0]*xi[1]*(-b[0])*b[1];
    psi2(2,4,2) = 1.0/2.0*3.0*2.0*xi[2]*(c[1]*c[1]*xi[0]*xi[0] + c[0]*c[0]*xi[1]*xi[1]) + 2.0*xi[0]*xi[1]*(-c[0]*c[1]*xi[2] + c[1]*c[2]*xi[0] + c[2]*c[0]*xi[1]) + 2.0*xi[2]*xi[0]*xi[1]*(-c[0]*c[1])
     + 5.0/2.0*2.0*xi[0]*xi[1]*(c[1]*c[1]*lamb[1]*xi[0] + c[0]*c[0]*lamb_p[0]*xi[1])+ 2.0*xi[2]*xi[0]*xi[1]*(-c[0])*c[1];
    psi2(2,5,2) = b[2]*c[2]*2.0*xi[0]*xi[1]*(xi[2] + xi[0] + xi[1]) + b[2]*c[2]*2.0*xi[2]*xi[0]*xi[1] + b[2]*c[2]*2.0*xi[2]*xi[0]*xi[1] + b[0]*c[0]*2.0*xi[1]*(xi[0]*xi[1] - xi[1]*xi[2] - xi[2]*xi[0] - xi[0]*xi[0]) + b[0]*c[0]*2.0*xi[2]*xi[1]*(-1.0*xi[1] - 1.0*xi[0]) + b[0]*c[0]*2.0*xi[2]*xi[1]*(-xi[0] - xi[1])
     + b[1]*c[1]*2.0*xi[0]*(xi[0]*xi[1] - xi[1]*xi[2] -xi[2]*xi[0] - xi[1]*xi[1]) + b[1]*c[1]*2.0*xi[2]*xi[0]*(-xi[1] -xi[0])+ b[1]*c[1]*2.0*xi[2]*xi[0]*(- xi[1]-xi[0]) - 5.0*2.0*xi[0]*xi[1]*(b[0]*c[0]*lamb_p[0]*xi[1] + b[1]*c[1]*lamb[1]*xi[0]);
     
    // compute for the second derivatives wrt area coordinate0
    psi2(2,0,0) = 10.0*xi[2]*xi[2]*xi[2]*2.0 + 60.0*xi[2]*xi[2]*xi[1]*(lamb[1]);
    psi2(2,1,0) = 6.0*b[2]*xi[2]*xi[2]*xi[1] +  xi[2]*xi[2]*xi[2]*(b[1])*(8.0)   + 30*xi[2]*xi[2]*xi[1]*(b[1]*lamb[1]);
    psi2(2,2,0) =-6.0*c[2]*xi[2]*xi[2]*xi[1] -  xi[2]*xi[2]*xi[2]*(c[1])*(8.0)   - 30.0*xi[2]*xi[2]*xi[1]*(c[1]*lamb[1]);
    psi2(2,3,0) = 1.0/2.0*xi[2]*xi[2]*xi[2]*(b[1]*b[1]*2.0) + xi[2]*xi[2]*xi[1]*(b[1]*b[2]) + xi[2]*xi[2]*xi[1]*(b[1]*b[2])  + 5.0/2.0*xi[2]*xi[2]*xi[1]*(b[1]*b[1]*lamb[1]) + 5.0/2.0*xi[2]*xi[2]*xi[1]*(b[1]*b[1]*lamb[1]);
    psi2(2,4,0) = 1.0/2.0*xi[2]*xi[2]*xi[2]*(c[1]*c[1]*2.0) + xi[2]*xi[2]*xi[1]*( c[1]*c[2]) + xi[2]*xi[2]*xi[1]*(c[1]*c[2])+ 5.0/2.0*xi[2]*xi[2]*xi[1]*(c[1]*c[1]*lamb[1])  + 5.0/2.0*xi[2]*xi[2]*xi[1]*(c[1]*c[1]*lamb[1]);
    psi2(2,5,0) = b[2]*c[2]*xi[2]*xi[2]*xi[1] + b[2]*c[2]*xi[2]*xi[2]*xi[1] + b[0]*c[0]*xi[2]*xi[2]*xi[1]*(-2.0)
     + b[1]*c[1]*xi[2]*xi[2]*(xi[1] -xi[2]) + b[1]*c[1]*xi[2]*xi[2]*(xi[1] -xi[2]) - 5.0*xi[2]*xi[2]*xi[1]*( b[1]*c[1]*lamb[1]) - 5.0*xi[2]*xi[2]*xi[1]*(b[1]*c[1]*lamb[1]);
     
    // compute for the second derivatives wrt area coordinate1
    psi2(2,0,1) = 10.0*xi[2]*xi[2]*xi[2]*2.0 +30.0*xi[2]*xi[2]*xi[0]*(lamb_p[0])  +30.0*xi[2]*xi[2]*xi[0]*(lamb_p[0]);
    psi2(2,1,1) = -30.0*b[0]*lamb_p[0]*xi[0]*xi[2]*xi[2] - 6.0*b[2]*xi[2]*xi[2]*xi[0] -  xi[2]*xi[2]*xi[2]*(b[0])*(8.0);
    psi2(2,2,1) =  6.0*c[2]*xi[2]*xi[2]*xi[0] + xi[2]*xi[2]*xi[2]*(c[0])*(8.0)  + 30.0*xi[2]*xi[2]*xi[0]*(c[0]*lamb_p[0]);
    psi2(2,3,1) = 1.0/2.0*xi[2]*xi[2]*xi[2]*(b[0]*b[0]*2.0) + xi[2]*xi[2]*xi[0]*( b[2]*b[0]) + xi[2]*xi[2]*xi[0]*(b[2]*b[0]) + 5.0/2.0*xi[2]*xi[2]*xi[0]*( b[0]*b[0]*lamb_p[0])+ 5.0/2.0*xi[2]*xi[2]*xi[0]*(b[0]*b[0]*lamb_p[0]);
    psi2(2,4,1) = 1.0/2.0*xi[2]*xi[2]*xi[2]*(c[0]*c[0]*2.0) + xi[2]*xi[2]*xi[0]*(c[2]*c[0]) + xi[2]*xi[2]*xi[0]*(c[2]*c[0])  + 5.0/2.0*xi[2]*xi[2]*xi[0]*(c[0]*c[0]*lamb_p[0]) + 5.0/2.0*xi[2]*xi[2]*xi[0]*(c[0]*c[0]*lamb_p[0]);
    psi2(2,5,1) = b[2]*c[2]*xi[2]*xi[2]*xi[0] + b[2]*c[2]*xi[2]*xi[2]*xi[0] + b[0]*c[0]*xi[2]*xi[2]*(xi[0] - xi[2]) + b[0]*c[0]*xi[2]*xi[2]*(xi[0]- xi[2]) + b[1]*c[1]*xi[2]*xi[2]*xi[0]*(-2.0) - 5.0*xi[2]*xi[2]*xi[0]*(b[0]*c[0]*lamb_p[0]) - 5.0*xi[2]*xi[2]*xi[0]*(b[0]*c[0]*lamb_p[0]);
      
    // compute for the second derivatives wrt area coordinate0 and 1
    psi2(2,0,3) = 10.0*xi[2]*xi[2]*xi[2]*2.0 + 30.0*xi[2]*xi[2]*(lamb[1]*xi[0] + lamb_p[0]*xi[1]) + 30.0*xi[2]*xi[2]*xi[0]*(lamb[1]) + 30.0*xi[2]*xi[2]*xi[1]*(lamb_p[0]);
    psi2(2,1,3) = 3.0*b[2]*xi[2]*xi[2]*(xi[0]-xi[1])-3.0*b[2]*xi[2]*xi[2]*xi[1] + 3.0*b[2]*xi[2]*xi[2]*xi[0] +  xi[2]*xi[2]*xi[2]*(b[1])*(4.0)+  xi[2]*xi[2]*xi[2]*(-b[0])*(4.0) + 15*xi[2]*xi[2]*(b[1]*lamb[1]*xi[0] - b[0]*lamb_p[0]*xi[1]) + 15*xi[2]*xi[2]*xi[1]*(-b[0]*lamb_p[0]) + 15*xi[2]*xi[2]*xi[0]*(b[1]*lamb[1]);
    psi2(2,2,3) =  -3.0*c[2]*xi[2]*xi[2]*xi[0] + -3.0*c[2]*xi[2]*xi[2]*(xi[0]-xi[1])+ 3.0*c[2]*xi[2]*xi[2]*xi[1] + xi[2]*xi[2]*xi[2]*(c[0])*(4.0) - xi[2]*xi[2]*xi[2]*(c[1])*(4.0) - 15.0*xi[2]*xi[2]*xi[0]*(c[1]*lamb[1]) - 15.0*xi[2]*xi[2]*(c[1]*lamb[1]*xi[0] -c[0]*lamb_p[0]*xi[1]) + 15.0*xi[2]*xi[2]*xi[1]*(c[0]*lamb_p[0]);
    psi2(2,3,3) =  xi[2]*xi[2]*xi[0]*(b[1]*b[2])  + xi[2]*xi[2]*(-b[0]*b[1]*xi[2] + b[1]*b[2]*xi[0] + b[2]*b[0]*xi[1]) + xi[2]*xi[2]*xi[1]*(b[2]*b[0]) + 5.0/2.0*xi[2]*xi[2]*xi[0]*(b[1]*b[1]*lamb[1]) + 5.0/2.0*xi[2]*xi[2]*(b[1]*b[1]*lamb[1]*xi[0] + b[0]*b[0]*lamb_p[0]*xi[1]) + 5.0/2.0*xi[2]*xi[2]*xi[1]*( b[0]*b[0]*lamb_p[0]);
    psi2(2,4,3) =  xi[2]*xi[2]*xi[0]*(c[1]*c[2]) + xi[2]*xi[2]*(-c[0]*c[1]*xi[2] + c[1]*c[2]*xi[0] + c[2]*c[0]*xi[1]) + xi[2]*xi[2]*xi[1]*(c[2]*c[0])+ 5.0/2.0*xi[2]*xi[2]*xi[0]*(c[1]*c[1]*lamb[1])  + 5.0/2.0*xi[2]*xi[2]*(c[1]*c[1]*lamb[1]*xi[0] + c[0]*c[0]*lamb_p[0]*xi[1]) + 5.0/2.0*xi[2]*xi[2]*xi[1]*(c[0]*c[0]*lamb_p[0]);
    psi2(2,5,3) = b[2]*c[2]*xi[2]*xi[2]*xi[0] + b[2]*c[2]*xi[2]*xi[2]*(xi[2] + xi[0] + xi[1])+ b[2]*c[2]*xi[2]*xi[2]*xi[1] + b[0]*c[0]*xi[2]*xi[2]*(xi[1] - xi[2] - 2.0*xi[0])+ b[0]*c[0]*xi[2]*xi[2]*xi[1] + b[1]*c[1]*xi[2]*xi[2]*xi[0] + b[1]*c[1]*xi[2]*xi[2]*(xi[0] - xi[2] - 2.0*xi[1]) - 5.0*xi[2]*xi[2]*xi[0]*( b[1]*c[1]*lamb[1]) - 5.0*xi[2]*xi[2]*(b[0]*c[0]*lamb_p[0]*xi[1] + b[1]*c[1]*lamb[1]*xi[0]) - 5.0*xi[2]*xi[2]*xi[1]*(b[0]*c[0]*lamb_p[0]);
    
    // compute for the second derivatives wrt area coordinate0 and 2
    psi2(2,0,4) = 5.0*4.0*xi[2]*xi[2]*xi[2] + 10.0*3.0*xi[2]*xi[2]*2.0*(xi[0]+xi[1]) + 30.0*2.0*xi[2]*xi[1]*(lamb[1]*xi[0] + lamb_p[0]*xi[1]) + 30.0*2.0*xi[2]*xi[0]*xi[1]*(lamb[1]);
    psi2(2,1,4) = 3.0*b[2]*2.0*xi[2]*xi[1]*(xi[0]-xi[1]) + 3.0*b[2]*2.0*xi[2]*xi[0]*xi[1] +  3.0*xi[2]*xi[2]*(b[1])*(xi[2] + 4.0*xi[0] + 4.0*xi[1])+  xi[2]*xi[2]*xi[2]*(b[1]) + 12.0*xi[2]*xi[2]*(b[1]*xi[0] - b[0]*xi[1]) + 15*2.0*xi[2]*xi[1]*(b[1]*lamb[1]*xi[0] - b[0]*lamb_p[0]*xi[1]) + 15*2.0*xi[2]*xi[0]*xi[1]*(b[1]*lamb[1]);
    psi2(2,2,4) = -3.0*c[2]*2.0*xi[2]*xi[1]*(xi[0]-xi[1]) -3.0*c[2]*2.0*xi[2]*xi[0]*xi[1] - 3.0*xi[2]*xi[2]*(c[1])*(xi[2] + 4.0*xi[0] + 4.0*xi[1]) - 3.0*xi[2]*xi[2]*(c[1]*xi[0] -c[0]*xi[1])*(4.0) - xi[2]*xi[2]*xi[2]*(c[1]) -15.0*2.0*xi[2]*xi[1]*(c[1]*lamb[1]*xi[0] -c[0]*lamb_p[0]*xi[1]) -15.0*2.0*xi[2]*xi[0]*xi[1]*(c[1]*lamb[1]);
    psi2(2,3,4) = 1.0/2.0*3.0*xi[2]*xi[2]*(b[1]*b[1]*2.0*xi[0]) + 2.0*xi[2]*xi[1]*(-b[0]*b[1]*xi[2] + b[1]*b[2]*xi[0] + b[2]*b[0]*xi[1]) + 2.0*xi[2]*xi[0]*xi[1]*(b[1]*b[2])
     + 5.0/2.0*2.0*xi[2]*xi[1]*(b[1]*b[1]*lamb[1]*xi[0] + b[0]*b[0]*lamb_p[0]*xi[1])+ 5.0/2.0*2.0*xi[2]*xi[0]*xi[1]*(b[1]*b[1]*lamb[1]) + xi[2]*xi[2]*xi[1]*(-b[0])*b[1];
    psi2(2,4,4) = 1.0/2.0*3.0*xi[2]*xi[2]*(c[1]*c[1]*2.0*xi[0]) + 2.0*xi[2]*xi[1]*(-c[0]*c[1]*xi[2] + c[1]*c[2]*xi[0] + c[2]*c[0]*xi[1]) + 2.0*xi[2]*xi[0]*xi[1]*(c[1]*c[2])
     + 5.0/2.0*2.0*xi[2]*xi[1]*(c[1]*c[1]*lamb[1]*xi[0] + c[0]*c[0]*lamb_p[0]*xi[1])+ 5.0/2.0*2.0*xi[2]*xi[0]*xi[1]*(c[1]*c[1]*lamb[1])+ xi[2]*xi[2]*xi[1]*(-c[0])*c[1];
    psi2(2,5,4) = b[2]*c[2]*2.0*xi[2]*xi[1]*(xi[2] + xi[0] + xi[1]) + b[2]*c[2]*2.0*xi[2]*xi[0]*xi[1] + b[2]*c[2]*xi[2]*xi[2]*xi[1] + b[0]*c[0]*2.0*xi[2]*xi[1]*(xi[1] - xi[2] - 2.0*xi[0]) + b[0]*c[0]*xi[2]*xi[2]*xi[1]*(-1.0) + b[1]*c[1]*2.0*xi[2]*(xi[0]*xi[1] - xi[1]*xi[2] -xi[2]*xi[0] - xi[1]*xi[1])+ b[1]*c[1]*2.0*xi[2]*xi[0]*(xi[1] -xi[2]) + b[1]*c[1]*xi[2]*xi[2]*(- xi[1]-xi[0])+ b[1]*c[1]*xi[2]*xi[2]*xi[0]*(-1.0) - 5.0*2.0*xi[2]*xi[1]*(b[0]*c[0]*lamb_p[0]*xi[1] + b[1]*c[1]*lamb[1]*xi[0])- 5.0*2.0*xi[2]*xi[0]*xi[1]*(b[1]*c[1]*lamb[1]);
    
    // compute for the second derivatives wrt area coordinate1 and 2
    psi2(2,0,5) = 5.0*4.0*xi[2]*xi[2]*xi[2] + 10.0*3.0*xi[2]*xi[2]*2.0*(xi[0]+xi[1]) + 30.0*2.0*xi[2]*xi[0]*(lamb[1]*xi[0] + lamb_p[0]*xi[1]) + 60.0*lamb_p[0]*xi[0]*xi[1]*xi[2];
    psi2(2,1,5) = 3.0*b[2]*2.0*xi[2]*xi[0]*xi[1]*(-1.0) + 3.0*b[2]*2.0*xi[2]*xi[0]*(xi[0]-xi[1]) + 12.0*xi[2]*xi[2]*(b[1]*xi[0] -b[0]*xi[1])+  3.0*xi[2]*xi[2]*(-b[0])*(xi[2] + 4.0*xi[0] + 4*xi[1])+  xi[2]*xi[2]*xi[2]*(-b[0]) +  15*2.0*xi[2]*xi[0]*xi[1]*(- b[0]*lamb_p[0]) + 15*2.0*xi[2]*xi[0]*(b[1]*lamb[1]*xi[0] - b[0]*lamb_p[0]*xi[1]);
    psi2(2,2,5) =  3.0*c[2]*2.0*xi[2]*xi[0]*xi[1] +  -3.0*c[2]*2.0*xi[2]*xi[0]*(xi[0]-xi[1]) - 3.0*xi[2]*xi[2]*(c[1]*xi[0] - c[0]*xi[1])*( 4.0) + 3.0*xi[2]*xi[2]*(c[0])*(xi[2] + 4.0*xi[0] + 4.0*xi[1]) + xi[2]*xi[2]*xi[2]*(c[0]) + 15.0*2.0*xi[2]*xi[0]*xi[1]*(c[0]*lamb_p[0]) -15.0*2.0*xi[2]*xi[0]*(c[1]*lamb[1]*xi[0] -c[0]*lamb_p[0]*xi[1]);
    psi2(2,3,5) = 1.0/2.0*3.0*xi[2]*xi[2]*(b[0]*b[0]*2.0*xi[1]) + 2.0*xi[2]*xi[0]*xi[1]*( b[2]*b[0]) + 2.0*xi[2]*xi[0]*(-b[0]*b[1]*xi[2] + b[1]*b[2]*xi[0] + b[2]*b[0]*xi[1])+ xi[2]*xi[2]*xi[0]*(-b[0]*b[1]) + 5.0/2.0*2.0*xi[2]*xi[0]*xi[1]*( b[0]*b[0]*lamb_p[0])+ 5.0/2.0*2.0*xi[2]*xi[0]*(b[1]*b[1]*lamb[1]*xi[0] + b[0]*b[0]*lamb_p[0]*xi[1]);
    psi2(2,4,5) = 3.0*xi[2]*xi[2]*(c[0]*c[0]*xi[1]) + 2.0*xi[2]*xi[0]*xi[1]*(c[2]*c[0]) + 2.0*xi[2]*xi[0]*(-c[0]*c[1]*xi[2] + c[1]*c[2]*xi[0] + c[2]*c[0]*xi[1]) + xi[2]*xi[2]*xi[0]*(-c[0]*c[1])  + 5.0/2.0*2.0*xi[2]*xi[0]*xi[1]*(c[0]*c[0]*lamb_p[0]) + 5.0/2.0*2.0*xi[2]*xi[0]*(c[1]*c[1]*lamb[1]*xi[0] + c[0]*c[0]*lamb_p[0]*xi[1]);
    psi2(2,5,5) = b[2]*c[2]*2.0*xi[2]*xi[0]*xi[1] + b[2]*c[2]*2.0*xi[2]*xi[0]*(xi[2] + xi[0] + xi[1]) + b[2]*c[2]*xi[2]*xi[2]*xi[0] + b[0]*c[0]*xi[2]*xi[2]*xi[1]*(-1.0)+ b[0]*c[0]*2.0*xi[2]*xi[1]*(xi[0] - xi[2]) + b[0]*c[0]*2.0*xi[2]*(xi[0]*xi[1] - xi[1]*xi[2] - xi[2]*xi[0] - xi[0]*xi[0]) + b[0]*c[0]*xi[2]*xi[2]*( -xi[1] -xi[0]) + b[1]*c[1]*2.0*xi[2]*xi[0]*(xi[0] - xi[2] - 2.0*xi[1]) + b[1]*c[1]*xi[2]*xi[2]*xi[0]*(-1.0) - 5.0*2.0*xi[2]*xi[0]*xi[1]*(b[0]*c[0]*lamb_p[0]) - 5.0*2.0*xi[2]*xi[0]*(b[0]*c[0]*lamb_p[0]*xi[1] + b[1]*c[1]*lamb[1]*xi[0]);

    // by chain rule, we can obtain d2shape wrt s0s0 at node2
    d2psids(2,0,0) = (psi2(2,0,0)*dxids0[0] + psi2(2,0,3)*dxids0[1] + psi2(2,0,4)*dxids0[2])*dxids0[0] + 
                     (psi2(2,0,3)*dxids0[0] + psi2(2,0,1)*dxids0[1] + psi2(2,0,5)*dxids0[2])*dxids0[1] + 
                     (psi2(2,0,4)*dxids0[0] + psi2(2,0,5)*dxids0[1] + psi2(2,0,2)*dxids0[2])*dxids0[2];
    d2psids(2,1,0) = (psi2(2,1,0)*dxids0[0] + psi2(2,1,3)*dxids0[1] + psi2(2,1,4)*dxids0[2])*dxids0[0] + 
                     (psi2(2,1,3)*dxids0[0] + psi2(2,1,1)*dxids0[1] + psi2(2,1,5)*dxids0[2])*dxids0[1] + 
                     (psi2(2,1,4)*dxids0[0] + psi2(2,1,5)*dxids0[1] + psi2(2,1,2)*dxids0[2])*dxids0[2];
    d2psids(2,2,0) = (psi2(2,2,0)*dxids0[0] + psi2(2,2,3)*dxids0[1] + psi2(2,2,4)*dxids0[2])*dxids0[0] + 
                     (psi2(2,2,3)*dxids0[0] + psi2(2,2,1)*dxids0[1] + psi2(2,2,5)*dxids0[2])*dxids0[1] + 
                     (psi2(2,2,4)*dxids0[0] + psi2(2,2,5)*dxids0[1] + psi2(2,2,2)*dxids0[2])*dxids0[2];
    d2psids(2,3,0) = (psi2(2,3,0)*dxids0[0] + psi2(2,3,3)*dxids0[1] + psi2(2,3,4)*dxids0[2])*dxids0[0] + 
                     (psi2(2,3,3)*dxids0[0] + psi2(2,3,1)*dxids0[1] + psi2(2,3,5)*dxids0[2])*dxids0[1] + 
                     (psi2(2,3,4)*dxids0[0] + psi2(2,3,5)*dxids0[1] + psi2(2,3,2)*dxids0[2])*dxids0[2];
    d2psids(2,4,0) = (psi2(2,4,0)*dxids0[0] + psi2(2,4,3)*dxids0[1] + psi2(2,4,4)*dxids0[2])*dxids0[0] + 
                     (psi2(2,4,3)*dxids0[0] + psi2(2,4,1)*dxids0[1] + psi2(2,4,5)*dxids0[2])*dxids0[1] + 
                     (psi2(2,4,4)*dxids0[0] + psi2(2,4,5)*dxids0[1] + psi2(2,4,2)*dxids0[2])*dxids0[2];
    d2psids(2,5,0) = (psi2(2,5,0)*dxids0[0] + psi2(2,5,3)*dxids0[1] + psi2(2,5,4)*dxids0[2])*dxids0[0] + 
                     (psi2(2,5,3)*dxids0[0] + psi2(2,5,1)*dxids0[1] + psi2(2,5,5)*dxids0[2])*dxids0[1] + 
                     (psi2(2,5,4)*dxids0[0] + psi2(2,5,5)*dxids0[1] + psi2(2,5,2)*dxids0[2])*dxids0[2];
    
    // by chain rule, we can obtain d2shape wrt s1s1 at node2
    d2psids(2,0,1) = (psi2(2,0,0)*dxids1[0] + psi2(2,0,3)*dxids1[1] + psi2(2,0,4)*dxids1[2])*dxids1[0] + 
                     (psi2(2,0,3)*dxids1[0] + psi2(2,0,1)*dxids1[1] + psi2(2,0,5)*dxids1[2])*dxids1[1] + 
                     (psi2(2,0,4)*dxids1[0] + psi2(2,0,5)*dxids1[1] + psi2(2,0,2)*dxids1[2])*dxids1[2];
    d2psids(2,1,1) = (psi2(2,1,0)*dxids1[0] + psi2(2,1,3)*dxids1[1] + psi2(2,1,4)*dxids1[2])*dxids1[0] + 
                     (psi2(2,1,3)*dxids1[0] + psi2(2,1,1)*dxids1[1] + psi2(2,1,5)*dxids1[2])*dxids1[1] + 
                     (psi2(2,1,4)*dxids1[0] + psi2(2,1,5)*dxids1[1] + psi2(2,1,2)*dxids1[2])*dxids1[2];
    d2psids(2,2,1) = (psi2(2,2,0)*dxids1[0] + psi2(2,2,3)*dxids1[1] + psi2(2,2,4)*dxids1[2])*dxids1[0] + 
                     (psi2(2,2,3)*dxids1[0] + psi2(2,2,1)*dxids1[1] + psi2(2,2,5)*dxids1[2])*dxids1[1] + 
                     (psi2(2,2,4)*dxids1[0] + psi2(2,2,5)*dxids1[1] + psi2(2,2,2)*dxids1[2])*dxids1[2];
    d2psids(2,3,1) = (psi2(2,3,0)*dxids1[0] + psi2(2,3,3)*dxids1[1] + psi2(2,3,4)*dxids1[2])*dxids1[0] + 
                     (psi2(2,3,3)*dxids1[0] + psi2(2,3,1)*dxids1[1] + psi2(2,3,5)*dxids1[2])*dxids1[1] + 
                     (psi2(2,3,4)*dxids1[0] + psi2(2,3,5)*dxids1[1] + psi2(2,3,2)*dxids1[2])*dxids1[2];
    d2psids(2,4,1) = (psi2(2,4,0)*dxids1[0] + psi2(2,4,3)*dxids1[1] + psi2(2,4,4)*dxids1[2])*dxids1[0] + 
                     (psi2(2,4,3)*dxids1[0] + psi2(2,4,1)*dxids1[1] + psi2(2,4,5)*dxids1[2])*dxids1[1] + 
                     (psi2(2,4,4)*dxids1[0] + psi2(2,4,5)*dxids1[1] + psi2(2,4,2)*dxids1[2])*dxids1[2];
    d2psids(2,5,1) = (psi2(2,5,0)*dxids1[0] + psi2(2,5,3)*dxids1[1] + psi2(2,5,4)*dxids1[2])*dxids1[0] + 
                     (psi2(2,5,3)*dxids1[0] + psi2(2,5,1)*dxids1[1] + psi2(2,5,5)*dxids1[2])*dxids1[1] + 
                     (psi2(2,5,4)*dxids1[0] + psi2(2,5,5)*dxids1[1] + psi2(2,5,2)*dxids1[2])*dxids1[2];

    // by chain rule, we can obtain d2shape wrt s0s1 at node2
    d2psids(2,0,2) = (psi2(2,0,0)*dxids0[0] + psi2(2,0,3)*dxids0[1] + psi2(2,0,4)*dxids0[2])*dxids1[0] + 
                     (psi2(2,0,3)*dxids0[0] + psi2(2,0,1)*dxids0[1] + psi2(2,0,5)*dxids0[2])*dxids1[1] + 
                     (psi2(2,0,4)*dxids0[0] + psi2(2,0,5)*dxids0[1] + psi2(2,0,2)*dxids0[2])*dxids1[2];
    d2psids(2,1,2) = (psi2(2,1,0)*dxids0[0] + psi2(2,1,3)*dxids0[1] + psi2(2,1,4)*dxids0[2])*dxids1[0] + 
                     (psi2(2,1,3)*dxids0[0] + psi2(2,1,1)*dxids0[1] + psi2(2,1,5)*dxids0[2])*dxids1[1] + 
                     (psi2(2,1,4)*dxids0[0] + psi2(2,1,5)*dxids0[1] + psi2(2,1,2)*dxids0[2])*dxids1[2];
    d2psids(2,2,2) = (psi2(2,2,0)*dxids0[0] + psi2(2,2,3)*dxids0[1] + psi2(2,2,4)*dxids0[2])*dxids1[0] + 
                     (psi2(2,2,3)*dxids0[0] + psi2(2,2,1)*dxids0[1] + psi2(2,2,5)*dxids0[2])*dxids1[1] + 
                     (psi2(2,2,4)*dxids0[0] + psi2(2,2,5)*dxids0[1] + psi2(2,2,2)*dxids0[2])*dxids1[2];
    d2psids(2,3,2) = (psi2(2,3,0)*dxids0[0] + psi2(2,3,3)*dxids0[1] + psi2(2,3,4)*dxids0[2])*dxids1[0] + 
                     (psi2(2,3,3)*dxids0[0] + psi2(2,3,1)*dxids0[1] + psi2(2,3,5)*dxids0[2])*dxids1[1] + 
                     (psi2(2,3,4)*dxids0[0] + psi2(2,3,5)*dxids0[1] + psi2(2,3,2)*dxids0[2])*dxids1[2];
    d2psids(2,4,2) = (psi2(2,4,0)*dxids0[0] + psi2(2,4,3)*dxids0[1] + psi2(2,4,4)*dxids0[2])*dxids1[0] + 
                     (psi2(2,4,3)*dxids0[0] + psi2(2,4,1)*dxids0[1] + psi2(2,4,5)*dxids0[2])*dxids1[1] + 
                     (psi2(2,4,4)*dxids0[0] + psi2(2,4,5)*dxids0[1] + psi2(2,4,2)*dxids0[2])*dxids1[2];
    d2psids(2,5,2) = (psi2(2,5,0)*dxids0[0] + psi2(2,5,3)*dxids0[1] + psi2(2,5,4)*dxids0[2])*dxids1[0] + 
                     (psi2(2,5,3)*dxids0[0] + psi2(2,5,1)*dxids0[1] + psi2(2,5,5)*dxids0[2])*dxids1[1] + 
                     (psi2(2,5,4)*dxids0[0] + psi2(2,5,5)*dxids0[1] + psi2(2,5,2)*dxids0[2])*dxids1[2];  
   } 
 };

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
// C1CurvedElementsShape
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//========================================================================
/// A class for Linear triangular shape function with 3 vertex nodes
//========================================================================
template<unsigned DIM>
 class LinearTElement { };

template<>
 class LinearTElement<2>
 {
   public:
//=======================================================================
/// Return local coordinates of node j
//=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s) const
   {
    switch (j)
     {
     case 0:
      s[0]=1.0;
      s[1]=0.0;
      break;
      
     case 1:
      s[0]=0.0;
      s[1]=1.0;
      break;
      
     case 2:
      s[0]=0.0;
      s[1]=0.0;
      break;
      
     default:
      std::ostringstream error_message;
      error_message << "Element only has three nodes; called with node number " 
                    << j << std::endl;
      
      throw OomphLibError(error_message.str(),
                          "TElement::local_coordinate_of_node()",
                          OOMPH_EXCEPTION_LOCATION);
     }
   }


//=======================================================================
/// Shape function for specific TElement<2,2>
//=======================================================================
  void Lshape(const Vector<double> &s, Shape &psi) const
   {
    psi[0] = s[0];
    psi[1] = s[1];
    psi[2] = 1.0-s[0]-s[1];
   }
  

//=======================================================================
/// Derivatives of shape functions for specific TElement<2,2>
//=======================================================================
  void dLshape_local(const Vector<double> &s,
                    Shape &psi, DShape &dpsids) const
   {
    this->Lshape(s, psi);
    
    // Derivatives
    dpsids(0,0) = 1.0;
    dpsids(0,1) = 0.0;
    dpsids(1,0) = 0.0;
    dpsids(1,1) = 1.0;
    dpsids(2,0) = -1.0;
    dpsids(2,1) = -1.0;
   }
  
  
//=======================================================================
/// Second derivatives of shape functions for specific TElement<2,2>:
 /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
 /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
 /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
//=======================================================================
  void d2Lshape_local(const Vector<double> &s, 
                     Shape &psi, 
                     DShape &dpsids, 
                     DShape &d2psids) const
   {
    this->dLshape_local(s, psi,dpsids);
    
    for(unsigned i=0;i<3;i++)
     {
      d2psids(i,0) = 0.0;
      d2psids(i,1) = 0.0;
      d2psids(i,2) = 0.0;
     }
   }
 };

//=====================================================================
/// Define integration schemes that are required to exactly integrate
/// the mass matrices of the bubble-enriched elements. The enrichement
/// increases the polynomial order which means that higher-order Gauss
/// rules must be used.
//====================================================================
template<unsigned DIM, unsigned NNODE_1D>
 class CurvedTGauss
{
};

//====================================================================
///Specialisation for two-dimensional elements, in which the highest
///order polynomial is cubic, so we need the integration scheme
///for the unenriched cubic element
//====================================================================== 
template<>
class CurvedTGauss<2,2> : public TGauss<2,4>
{
  public:
  CurvedTGauss() : TGauss<2,4>() {}
};

//========================================================================
/// A class for subparametric shape functions of 
/// a curved triangular element with 3 vertex nodes
/// Affine mapping is used when dealing with a straight-boundary element
/// Nonlinear mapping is used when dealing with a curved-boundary element
/// Note that a cubic-Hermite polynomial is employed to approximate a
/// curved boundary
//========================================================================
template<unsigned DIM>
 class GeometricTElement{};

template<>
 class GeometricTElement<2>
 {
   public:
//=======================================================================
/// Return local coordinates of node j
//=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s) const
   {
    switch (j)
     {
     case 0:
      s[0]=1.0;
      s[1]=0.0;
      break;
      
     case 1:
      s[0]=0.0;
      s[1]=1.0;
      break;
      
     case 2:
      s[0]=0.0;
      s[1]=0.0;
      break;
      
     default:
      std::ostringstream error_message;
      error_message << "Element only has three nodes; called with node number " 
                    << j << std::endl;
      
      throw OomphLibError(error_message.str(),
                          "GeometricTElement::local_coordinate_of_node()",
                          OOMPH_EXCEPTION_LOCATION);
     }
   }
//=======================================================================
/// Geometric interpolation for specific C1CurvedElement<>
/// This function return the physical coordinates at the local coordinate s
/// rather than a value of shape function at the local coordinate s
//=======================================================================
   void Lshape(const Vector<double> &s, Shape &psi, Shape &phi, DenseMatrix<double> &position,
                    unsigned &bd_element, DenseMatrix<double> &bd_position, Vector<double> &x) const
   {
    // assign shape functions to the interior elements
    psi[0] = s[0];
    psi[1] = s[1];
    psi[2] = 1.0-s[0]-s[1];
    
    // assign shape functions to the boundary elements
    double angle_1 = atan2(bd_position(0,1),bd_position(0,0));
    double angle_2 = atan2(bd_position(1,1),bd_position(1,0));
    double angle_min=0.0;
    double angle_max=0.0;
    
    DenseMatrix<double> p(3,2);
    if(angle_1 < angle_2)
     {
      angle_min = angle_1;
      angle_max = angle_2;
      
      p(0,0) = bd_position(0,0); 
      p(0,1) = bd_position(0,1);
      
      p(1,0) = bd_position(1,0); 
      p(1,1) = bd_position(1,1);
     }
    else if(angle_1 > angle_2)
     {
      angle_min = angle_2;
      angle_max = angle_1;
      
      p(0,0) = bd_position(1,0); 
      p(0,1) = bd_position(1,1);
      
      p(1,0) = bd_position(0,0); 
      p(1,1) = bd_position(0,1);
     }
      
    Vector<double> b_fn_derivative_min(2), b_fn_derivative_max(2);
    b_fn_derivative_min[0] = -1.0*sin(angle_min);
    b_fn_derivative_min[1] = cos(angle_min);
    b_fn_derivative_max[0] = -1.0*sin(angle_max);
    b_fn_derivative_max[1] = cos(angle_max);
    
    // compute the physical coordinates at the local coordinate s
    if(bd_element == 0)
     {
      phi[0] = position(2,0) + (position(0,0) - position(2,0))*s[0] + (position(1,0) - position(2,0))*s[1];
      phi[1] = position(2,1) + (position(0,1) - position(2,1))*s[0] + (position(1,1) - position(2,1))*s[1];
     }
    else
     {
      Vector<double> psi_h(2);
      for(unsigned i=0;i<2;i++)
       {
        // polynomial of degree 3 to approximate boundary
	    psi_h[i] = ( (2.0*(p(1,i)-p(0,i))-(angle_max-angle_min)*(b_fn_derivative_min[i]+b_fn_derivative_max[i]))*(s[1]-s[0]) + (angle_max-angle_min)*(b_fn_derivative_min[i]-b_fn_derivative_max[i]) );
        phi[i] = x[i] + (p(0,i) - x[i])*s[0] + (p(1,i) - x[i])*s[1] + 1.0/2.0*s[0]*s[1]*psi_h[i];
       }
     }
   }
  

//=======================================================================
/// Derivatives of Geometric interpolation for specific C1CurvedElement<>
/// This function return the derivatives of physical coordinates at 
/// the local coordinate s rather than a value of the derivatives of 
/// shape function at the local coordinate s
//=======================================================================
  void dLshape_local(const Vector<double> &s,
                    Shape &psi, DShape &dpsids, Shape &phi, DShape &dphids, DenseMatrix<double> &position,
                     unsigned &bd_element, DenseMatrix<double> &bd_position, Vector<double> &x) const
   {
    this->Lshape(s,psi,phi,position,bd_element,bd_position,x);
    // Derivatives
    dpsids(0,0) = 1.0;
    dpsids(0,1) = 0.0;
    dpsids(1,0) = 0.0;
    dpsids(1,1) = 1.0;
    dpsids(2,0) = -1.0;
    dpsids(2,1) = -1.0;
    
    double angle_1 = atan2(bd_position(0,1),bd_position(0,0));
    double angle_2 = atan2(bd_position(1,1),bd_position(1,0));
    double angle_min=0.0;
    double angle_max=0.0;
    
    DenseMatrix<double> p(3,2);
    if(angle_1 < angle_2)
     {
      angle_min = angle_1;
      angle_max = angle_2;
      
      p(0,0) = bd_position(0,0); 
      p(0,1) = bd_position(0,1);
      
      p(1,0) = bd_position(1,0); 
      p(1,1) = bd_position(1,1);
     }
    else if(angle_1 > angle_2)
     {
      angle_min = angle_2;
      angle_max = angle_1;
      
      p(0,0) = bd_position(1,0); 
      p(0,1) = bd_position(1,1);
      
      p(1,0) = bd_position(0,0); 
      p(1,1) = bd_position(0,1);
     }
      
    Vector<double> b_fn_derivative_min(2), b_fn_derivative_max(2);
    b_fn_derivative_min[0] = -1.0*sin(angle_min);
    b_fn_derivative_min[1] = cos(angle_min);
    b_fn_derivative_max[0] = -1.0*sin(angle_max);
    b_fn_derivative_max[1] = cos(angle_max);
    
    // compute shape functions
    if(bd_element == 0)
     {
      dphids(0,0) = position(0,0) - position(2,0);
      dphids(0,1) = position(1,0) - position(2,0);
      dphids(1,0) = position(0,1) - position(2,1);
      dphids(1,1) = position(1,1) - position(2,1);
     }
    else
     {
      Vector<double> psi_h(2);
      for(unsigned i=0;i<2;i++)
       {
        psi_h[i] = ( (2.0*(p(1,i)-p(0,i))-(angle_max-angle_min)*(b_fn_derivative_min[i]+b_fn_derivative_max[i]))*(s[1]-s[0]) + (angle_max-angle_min)*(b_fn_derivative_min[i]-b_fn_derivative_max[i]) ); 
       }
      // compute shape functions derivatives
      DenseMatrix<double> dpsi_h(2,2);
      for(unsigned i=0;i<2;i++)
       {
        dpsi_h(i,0) = (2.0*(p(1,i)-p(0,i))-(angle_max-angle_min)*(b_fn_derivative_min[i]+b_fn_derivative_max[i]))*(-1.0);
        dpsi_h(i,1) = (2.0*(p(1,i)-p(0,i))-(angle_max-angle_min)*(b_fn_derivative_min[i]+b_fn_derivative_max[i]));
       }
      for(unsigned i=0;i<2;i++)
       {
        dphids(i,0) = p(0,i) - x[i] + 1.0/2.0*s[0]*s[1]*dpsi_h(i,0) + psi_h[i]*s[1]/2.0 ;
        dphids(i,1) = p(1,i) - x[i] + 1.0/2.0*s[0]*s[1]*dpsi_h(i,1) + psi_h[i]*s[0]/2.0 ;
       }
     }
   }
  
//=======================================================================
/// Second derivatives of Geometric interpolation for 
/// specific C1CurvedElement<>:
/// This function return the second-order derivatives of physical coordinates at 
/// the local coordinate s rather than a value of the second-order derivatives of 
/// shape function at the local coordinate s
///=======================================================================
  void d2Lshape_local(const Vector<double> &s, 
                     Shape &psi, 
                     DShape &dpsids, 
                     DShape &d2psids,
                     Shape &phi, 
                     DShape &dphids, 
                     DShape &d2phids,
                     DenseMatrix<double> &position,
                     unsigned &bd_element, 
                     DenseMatrix<double> &bd_position,
                     Vector<double> &x) const
   {
    this->dLshape_local(s,psi,dpsids,phi,dphids,position,bd_element,bd_position,x);
    // 2nd Derivatives
    for(unsigned i=0;i<3;i++)
     {
      d2psids(i,0) = 0.0;
      d2psids(i,1) = 0.0;
      d2psids(i,2) = 0.0;
     }
    double angle_1 = atan2(bd_position(0,1),bd_position(0,0));
    double angle_2 = atan2(bd_position(1,1),bd_position(1,0));
    double angle_min=0.0;
    double angle_max=0.0;
    
    DenseMatrix<double> p(3,2);
    if(angle_1 < angle_2)
     {
      angle_min = angle_1;
      angle_max = angle_2;
      
      p(0,0) = bd_position(0,0); 
      p(0,1) = bd_position(0,1);
      
      p(1,0) = bd_position(1,0); 
      p(1,1) = bd_position(1,1);
     }
    else if(angle_1 > angle_2)
     {
      angle_min = angle_2;
      angle_max = angle_1;
      
      p(0,0) = bd_position(1,0); 
      p(0,1) = bd_position(1,1);
      
      p(1,0) = bd_position(0,0); 
      p(1,1) = bd_position(0,1);
     }
    
    Vector<double> b_fn_derivative_min(2), b_fn_derivative_max(2);
    b_fn_derivative_min[0] = -1.0*sin(angle_min);
    b_fn_derivative_min[1] = cos(angle_min);
    b_fn_derivative_max[0] = -1.0*sin(angle_max);
    b_fn_derivative_max[1] = cos(angle_max);
    
    // compute the 2nd-order of derivatives of the  physical coordinates
    if(bd_element == 0)
     {
      for(unsigned i=0;i<2;i++)
       {
        d2phids(i,0) = 0.0;
        d2phids(i,1) = 0.0;
        d2phids(i,2) = 0.0;
       }
     }
    else
     {
      // compute the 2nd-order derivatives of the physical coordinates
      Vector<double> psi_h(2);
      DenseMatrix<double> dpsi_h(2,2), d2psi_h(2,3);
      
      for(unsigned i=0;i<2;i++)
       {
        psi_h[i] = ( (2.0*(p(1,i)-p(0,i))-(angle_max-angle_min)*(b_fn_derivative_min[i]+b_fn_derivative_max[i]))*(s[1]-s[0]) + (angle_max-angle_min)*(b_fn_derivative_min[i]-b_fn_derivative_max[i]) );
       }
      
      for(unsigned i=0;i<2;i++)
       {
        dpsi_h(i,0) = (2.0*(p(1,i)-p(0,i))-(angle_max-angle_min)*(b_fn_derivative_min[i]+b_fn_derivative_max[i]))*(-1.0);
        dpsi_h(i,1) = (2.0*(p(1,i)-p(0,i))-(angle_max-angle_min)*(b_fn_derivative_min[i]+b_fn_derivative_max[i]));
       }
      
      for(unsigned i=0;i<2;i++)
       {
        d2psi_h(i,0) = 0.0;
        d2psi_h(i,1) = 0.0;
        d2psi_h(i,2) = 0.0;
       }
      
      for(unsigned i=0;i<2;i++)
       {
        d2phids(i,0) = 1.0/2.0*s[0]*s[1]*d2psi_h(i,0) + dpsi_h(i,0)*s[1]/2.0 + 1.0/2.0*s[1]*dpsi_h(i,0);
        d2phids(i,1) = 1.0/2.0*s[0]*s[1]*d2psi_h(i,1) + 1.0/2.0*s[0]*dpsi_h(i,1) + 1.0/2.0*s[0]*dpsi_h(i,1);
        d2phids(i,2) = 1.0/2.0*s[0]*s[1]*d2psi_h(i,2) + 1.0/2.0*s[0]*dpsi_h(i,0) + psi_h[i]/2.0 + dpsi_h(i,1)*s[1]/2.0;
       }
     }
   }
 };

//========================================================================
/// A class for C1-curved triangular shape function with 3 vertex nodes and
/// 3 middle-side node
//========================================================================
template<unsigned DIM, unsigned NNODE_1D>
 class C1CurvedElementShape { };

 template<unsigned NNODE_1D>
 class C1CurvedElementShape<2,NNODE_1D>
 {
 public:
 //=======================================================================
 /// Return local coordinates of node j
 //=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s) const
   {
    if(NNODE_1D == 2)                                
     {
       switch (j)
        {
        case 0:
         s[0]=1.0;
         s[1]=0.0;
         break;

        case 1:
         s[0]=0.0;
         s[1]=1.0;
         break;

        case 2:
         s[0]=0.0;
         s[1]=0.0;
         break;

        case 3:
         s[0]=1.0/2.0;
         s[1]=1.0/4.0;
         break;

        case 4:
         s[0]=1.0/4.0;
         s[1]=1.0/2.0;
         break;

        case 5:
         s[0]=1.0/4.0;
         s[1]=1.0/4.0;
         break;

        default:
         std::ostringstream error_message;
         error_message << "Element only has three vertices and three internal nodes; called with node number "
                       << j << std::endl;

         throw OomphLibError(error_message.str(),
                             "CurvedTElement::local_coordinate_of_node()",
                             OOMPH_EXCEPTION_LOCATION);
        }      
     }
     
    else if(NNODE_1D == 3)                                
     {
       switch (j)
        {
        case 0:
         s[0]=1.0;
         s[1]=0.0;
         break;

        case 1:
         s[0]=0.0;
         s[1]=1.0;
         break;

        case 2:
         s[0]=0.0;
         s[1]=0.0;
         break;

        case 3:
         s[0]=0.5;
         s[1]=0.5;
         break;

        case 4:
         s[0]=0.0;
         s[1]=0.5;
         break;

        case 5:
         s[0]=0.5;
         s[1]=0.0;
         break;
          
        case 6:
         s[0]=1.0/2.0;
         s[1]=1.0/4.0;
         break;

        case 7:
         s[0]=1.0/4.0;
         s[1]=1.0/2.0;
         break;

        case 8:
         s[0]=1.0/4.0;
         s[1]=1.0/4.0;
         break;

        default:
         std::ostringstream error_message;
         error_message << "Element has maximum of six nodes and three internal nodes; called with node number "
                       << j << std::endl;

         throw OomphLibError(error_message.str(),
                             "CurvedTElement::local_coordinate_of_node()",
                             OOMPH_EXCEPTION_LOCATION);
        }      
     }
   }

  ///============================================================
  /// compute for the set of value in the reference triangle
  ///============================================================
  void set_of_value(DenseMatrix<double> &D, DenseMatrix<double> &B, DenseMatrix<double> &position,
                    unsigned &bd_element, DenseMatrix<double> &bd_position, Vector<double> &x) const
   {
    double angle_1 = atan2(bd_position(0,1),bd_position(0,0));
    double angle_2 = atan2(bd_position(1,1),bd_position(1,0));
    double angle_min=0.0;
    double angle_max=0.0;
    
    DenseMatrix<double> p(3,2);
    if(angle_1 < angle_2)
     {
      angle_min = angle_1;
      angle_max = angle_2;
      
      p(0,0) = bd_position(0,0); 
      p(0,1) = bd_position(0,1);
      
      p(1,0) = bd_position(1,0); 
      p(1,1) = bd_position(1,1);
     }
    else if(angle_1 > angle_2)
     {
      angle_min = angle_2;
      angle_max = angle_1;
      
      p(0,0) = bd_position(1,0); 
      p(0,1) = bd_position(1,1);
      
      p(1,0) = bd_position(0,0); 
      p(1,1) = bd_position(0,1);
     }
    p(2,0) = x[0];
    p(2,1) = x[1];

    Vector<double> fn_derivative1(2), fn_derivative2(2);
    fn_derivative1[0] = (angle_max-angle_min)*-1.0*sin(angle_min);
    fn_derivative1[1] = (angle_max-angle_min)*-1.0*sin(angle_max);
    fn_derivative2[0] = (angle_max-angle_min)*cos(angle_min);
    fn_derivative2[1] = (angle_max-angle_min)*cos(angle_max);
    
    // compute for the transformation matrix D from global to local coordinates
    //initialise the matrix first
    for(unsigned i=0;i<21;i++)
     {
      for(unsigned j=0;j<21;j++)
       {
        D(i,j) = 0.0;
       }
     }
    double x31, x23, x13, x32, y13 ,y31, y32, y23;
    x31 = p(2,0)-p(0,0);
    y31 = p(2,1)-p(0,1);
    x32 = p(2,0)-p(1,0);
    y32 = p(2,1)-p(1,1);
    x23 = p(1,0)-p(2,0);
    y23 = p(1,1)-p(2,1);
    x13 = p(0,0)-p(2,0);
    y13 = p(0,1)-p(2,1);
    
    // assign values to the matrix D
    D(0,0) = 1.0;
    D(1,1) = 1.0;
    D(2,2) = 1.0;
    D(3+0,3+0)=x31;
    D(3+0,3+1)=fn_derivative1[0];
    D(3+1,3+0)=y31;
    D(3+1,3+1)=fn_derivative2[0];
    // define submatrix d2
    D(5+0,5+0)=-1.0*fn_derivative1[1];
    D(5+0,5+1)=x32;
    D(5+1,5+0)=-1.0*fn_derivative2[1];
    D(5+1,5+1)=y32;
    // define submatrix d3
    D(7+0,7+0)=x23;
    D(7+0,7+1)=x13;
    D(7+1,7+0)=y23;
    D(7+1,7+1)=y13;
    // define submatrix d4
    D(9+0,9+0)=x31*x31;
    D(9+0,9+1)=fn_derivative1[0]*fn_derivative1[0];
    D(9+0,9+6)=x32*x32;
    D(9+1,9+0)=2.0*x31*y31;
    D(9+1,9+1)=2.0*fn_derivative1[0]*fn_derivative2[0];
    D(9+1,9+6)=2.0*x32*y32;
    D(9+2,9+0)=y31*y31;
    D(9+2,9+1)=fn_derivative2[0]*fn_derivative2[0];
    D(9+2,9+6)=y32*y32;
    D(9+3,9+2)=fn_derivative1[1]*fn_derivative1[1];
    D(9+3,9+3)=x32*x32;
    D(9+3,9+7)=x31*x31;
    D(9+4,9+2)=2.0*fn_derivative1[1]*fn_derivative2[1];
    D(9+4,9+3)=2.0*x32*y32;
    D(9+4,9+7)=2.0*x31*y31;
    D(9+5,9+2)=fn_derivative2[1]*fn_derivative2[1];
    D(9+5,9+3)=y32*y32;
    D(9+5,9+7)=y31*y31;
    D(9+6,9+4)=x32*x32;
    D(9+6,9+5)=x31*x31;
    D(9+6,9+8)=fn_derivative1[0]*fn_derivative1[1];
    D(9+7,9+4)=2.0*x32*y32;
    D(9+7,9+5)=2.0*x31*y31;
    D(9+7,9+8)=fn_derivative1[0]*fn_derivative2[1]+fn_derivative2[0]*fn_derivative1[1];
    D(9+8,9+4)=y32*y32;
    D(9+8,9+5)=y31*y31;
    D(9+8,9+8)=fn_derivative2[0]*fn_derivative2[1];
    
    D(18,18) = 1.0;
    D(19,19) = 1.0;
    D(20,20) = 1.0;
    //assign  the matrix of transformation from the dofs on curved element to the dofs on reference element
    DenseMatrix<double> Bt(36,21);
    //Initialize the matrix 
    for(unsigned i=0;i<36;i++)
     {
      for(unsigned j=0;j<21;j++)
       {
        Bt(i,j) = 0.0;
       }
     }
    // submatrix b1
    Bt(0,0)=1.0;
    Bt(1,1)=1.0;
    Bt(2,2)=1.0;
    // submatrix b2
    Bt(3+0,3+0)=-1.0;
    Bt(3+1,3+0)=-1.0;
    Bt(3+1,3+1)=1.0;
    Bt(3+2,3+2)=1.0;
    Bt(3+2,3+3)=-1.0;
    Bt(3+3,3+3)=-1.0;
    Bt(3+4,3+5)=1.0;
    Bt(3+5,3+4)=1.0;
    // submatrix b3
    double a1, a2, aa1, aa2, b1, b2, bb1, bb2, c1, c2, cc1, cc2;
    Vector<double> A1(2), A2(2), B1(2), B2(2), C1(2), C2(2);
    for(unsigned i=0;i<2;i++)
     {
      A1[i] = p(2,i)-p(0,i); 
      B2[i] = p(2,i)-p(1,i);
      C1[i] = p(1,i)-p(2,i);
      C2[i] = p(0,i)-p(2,i);
     }
    A2[0] = (angle_max-angle_min)*-1.0*sin(angle_min);
    A2[1] = (angle_max-angle_min)*cos(angle_min);
    B1[0] = -1.0*(angle_max-angle_min)*-1.0*sin(angle_max);
    B1[1] = -1.0*(angle_max-angle_min)*cos(angle_max);
    double B2xA2, A1xA2, A1xB2, B1xA2, A1xB1, B1xA1, A2xB2, B1xB2;
    B2xA2 = B2[0]*A2[1]-B2[1]*A2[0];
    A1xA2 = A1[0]*A2[1]-A1[1]*A2[0]; 
    A1xB2 = A1[0]*B2[1]-A1[1]*B2[0];
    B1xA2 = B1[0]*A2[1]-B1[1]*A2[0];
    A1xB1 = A1[0]*B1[1]-A1[1]*B1[0];
    A2xB2 = A2[0]*B2[1]-A2[1]*B2[0];
    B1xA1 = B1[0]*A1[1]-B1[1]*A1[0];
    B1xB2 = B1[0]*B2[1]-B1[1]*B2[0];
    a1 = B2xA2/A1xA2 - 1.0;
    a2 = A1xB2/A1xA2;
    aa1 = -1.0*B1xA2/A1xA2;
    aa2 = -1.0*A1xB1/A1xA2;
    b1 = A1xB2/B1xB2;
    b2 = B1xA1/B1xB2 - 1.0;
    bb1 = A2xB2/B1xB2;
    bb2 = B1xA2/B1xB2;
    c1 = -1.0/a2;
    c2 = -1.0*bb1/b1;
    cc1 = aa2/a2;
    cc2 = -1.0/b1;
   
    Bt(9+1,3+0)=2.0*a1+aa1/2.0;
    Bt(9+2,3+0)=-1.0*(2.0*a1+aa1);
    Bt(9+1,3+1)=3.0/2.0+2.0*a2+aa2/2.0;
    Bt(9+2,3+1)=-1.0*(1.0+2.0*a2+aa2);
    Bt(9+3,3+2)=-1.0*(1.0+2.0*b1-bb1);
    Bt(9+4,3+2)=3.0/2.0+2.0*b1-bb1/2.0;
    Bt(9+3,3+3)=-1.0*(2.0*b2-bb2);
    Bt(9+4,3+3)=2.0*b2-bb2/2.0;
    Bt(9+7,3+4)=(c1+cc1)/2.0;
    Bt(9+7,3+5)=(c2+cc2)/2.0;

    Bt(9+0,9+0)=1.0;
    Bt(9+1,9+0)=1.0+(1.0+a1)/(2.0*a2);
    Bt(9+2,9+0)=1.0+(1.0+a1)/(a2);
    Bt(9+1,9+1)=(a2)/(2.0*(1.0+a1));
    Bt(9+2,9+1)=1.0+(a2)/(1.0+a1);
    Bt(9+3,9+2)=1.0+(b1)/(1.0+b2);
    Bt(9+4,9+2)=(b1)/(2.0*(1.0+b2));
    Bt(9+3,9+3)=1.0+(1.0+b2)/(b1);
    Bt(9+4,9+3)=1.0+(1.0+b2)/(2.0*b1);
    Bt(9+5,9+3)=1.0;
    Bt(9+7,9+4)=-1.0*(c1*cc1)/(c1*cc2+c2*cc1);
    Bt(9+8,9+4)=1.0;
    Bt(9+6,9+5)=1.0;
    Bt(9+7,9+5)=-1.0*(c2*cc2)/(c1*cc2+c2*cc1);
    Bt(9+1,9+6)=(-1.0)/(2.0*a2*(1.0+a1));
    Bt(9+2,9+6)=(-1.0)/(a2*(1.0+a1));
    Bt(9+3,9+7)=(-1.0)/(b1*(1.0+b2));
    Bt(9+4,9+7)=(-1.0)/(2.0*b1*(1.0+b2));
    Bt(9+7,9+8)=(-1.0)/(c1*cc2+c2*cc1);
    
    double ata1, ata2;
    // assign the points of perpendicular for the sides a1a3 nd a2a3
    Vector<double> s1(2), s2(2);
    // find the point that the point a1(on the boundary) is perpendicular to the vector a2a3
    double m = (p(1,1) - p(2,1))/(p(1,0) - p(2,0));
    double k = p(2,1) - m*p(2,0);
    s1[0] = ( (p(1,0) - p(2,0))*p(0,0) + (p(1,1) - p(2,1))*(p(0,1)-k) )/((p(1,0) - p(2,0)) + (p(1,1) - p(2,1))*m);
    s1[1] = m*s1[0] + k;
    
    if((p(1,0) - p(2,0))==0)
     {
      m = (p(1,0) - p(2,0))/(p(1,1) - p(2,1));
      k = p(2,0) - m*p(2,1);
      s1[1] = ( (p(1,0) - p(2,0))*(p(0,0)-k) + (p(1,1) - p(2,1))*(p(0,1)) )/((p(1,0) - p(2,0))*m + (p(1,1) - p(2,1)));
      s1[0] = m*s1[1] + k;
     }

    // find the point that the point a2(on the boundary) is perpendicular to the vector a1a3
    m = (p(0,1) - p(2,1))/(p(0,0) - p(2,0));
    k = p(2,1) - m*p(2,0);
    s2[0] = ( (p(0,0) - p(2,0))*p(1,0) + (p(0,1) - p(2,1))*(p(1,1)-k) )/((p(0,0) - p(2,0)) + (p(0,1) - p(2,1))*m);
    s2[1] = m*s2[0] + k;
    
    if((p(0,0) - p(2,0))==0)
     {
      m = (p(0,0) - p(2,0))/(p(0,1) - p(2,1));
      k = p(2,0) - m*p(2,1);
      s2[1] = ( (p(0,0) - p(2,0))*(p(1,0)-k) + (p(0,1) - p(2,1))*(p(1,1)) )/((p(0,0) - p(2,0))*m + (p(0,1) - p(2,1)));
      s2[0] = m*s2[1] + k;
     }
    
    double len1, len2, len3;
    len1 = sqrt((p(1,0)-p(2,0))*(p(1,0)-p(2,0)) + (p(1,1)-p(2,1))*(p(1,1)-p(2,1)) );
    len2 = sqrt((p(0,0)-p(2,0))*(p(0,0)-p(2,0)) + (p(0,1)-p(2,1))*(p(0,1)-p(2,1)) );
    len3 = sqrt((p(1,0)-p(0,0))*(p(1,0)-p(0,0)) + (p(1,1)-p(0,1))*(p(1,1)-p(0,1)) );
    ata1 = (len3*len3-len2*len2)/(len1*len1);
    ata2 = (len1*len1-len3*len3)/(len2*len2);
    
    Vector<double> F1(21,0.0), F2(21,0.0), F3(21,0.0), H1(21,0.0), H2(21,0.0), H3(21,0.0);
    DenseMatrix<double> F1_div(21,2,0.0), F2_div(21,2,0.0);
    //Initialize the Vectors
    for(unsigned i=0;i<21;i++)
     {
      F1[i] = 0.0;
      F2[i] = 0.0;
      F3[i] = 0.0;
      H1[i] = 0.0;
      H2[i] = 0.0;
      H3[i] = 0.0;
      for(unsigned j=0;j<2;j++)
       {
        F1_div(i,j) = 0;
        F2_div(i,j) = 0;
       }
     }
    double e1,e2,f1,f2;
    double magnitude;
    Vector<double> t(2,0.0),aa(2,0.0),s(2,0.0);

    t[0] = p(2,0)-p(0,0) + 1.0/4.0*(p(0,0)-p(1,0))+1.0/8.0*(angle_max-angle_min)*(-3.0*sin(angle_max)+sin(angle_min));
    t[1] = p(2,1)-p(0,1) + 1.0/4.0*(p(0,1)-p(1,1))+1.0/8.0*(angle_max-angle_min)*(3.0*cos(angle_max)-cos(angle_min));
    magnitude = sqrt((p(1,0)-p(2,0))*(p(1,0)-p(2,0)) + (p(1,1)-p(2,1))*(p(1,1)-p(2,1)));
    aa[0] = (p(1,0)-p(2,0))/(magnitude*magnitude);
    aa[1] = (p(1,1)-p(2,1))/(magnitude*magnitude);
    e1 = (t[0]*aa[0] + t[1]*aa[1]);
    
    magnitude = sqrt((p(0,0)-s1[0])*(p(0,0)-s1[0]) + (p(0,1)-s1[1])*(p(0,1)-s1[1]));
    aa[0] = (p(0,0)-s1[0])/(magnitude*magnitude);
    aa[1] = (p(0,1)-s1[1])/(magnitude*magnitude);
    e2 = (t[0]*aa[0] + t[1]*aa[1]);
    
    s[1] = 1.0/2.0;
    F2_div(1,1) = 5.0*s[1]*s[1]*6.0*s[1]*s[1]-4.0*s[1]*s[1]*15.0*s[1]+3.0*s[1]*s[1]*10.0;
    F2_div(2,1) = (1.0-s[1])*(1.0-s[1])*(1.0-s[1])*(12.0*s[1]+3.0)-3.0*(1.0-s[1])*(1.0-s[1])*(6.0*s[1]*s[1]+3.0*s[1]+1.0);
    F2_div(6,1) = s[1]*s[1]*s[1]*(1.0-s[1])*(-3.0)+(4.0-3.0*s[1])*(-s[1]*s[1]*s[1]+3.0*s[1]*s[1]*(1.0-s[1]));
    F2_div(7,1) = s[1]*(1.0-s[1])*(1.0-s[1])*(1.0-s[1])*3.0 + ( -3.0*s[1]*(1.0-s[1])*(1.0-s[1]) + (1.0-s[1])*(1.0-s[1])*(1.0-s[1]) )*(1.0+3.0*s[1]);
    F2_div(12,1) = -1.0*s[1]*s[1]*s[1]*(1.0-s[1])+3.0/2.0*(1.0-s[1])*(1.0-s[1])*s[1]*s[1];
    F2_div(13,1) = -3.0/2.0*s[1]*s[1]*(1.0-s[1])*(1.0-s[1]) + 1.0/2.0*(1.0-s[1])*(1.0-s[1])*(1.0-s[1])*2.0*s[1];
    
    s[1] = 1.0/2.0;
    H2[5] = -1.0*b1*(3.0*s[1]*s[1]-2.0*s[1]*s[1]*s[1]);
    H2[6] = -1.0/2.0*(2.0*b2+1.0+ata1)*(3.0*s[1]*s[1]-2.0*s[1]*s[1]*s[1]);
    H2[7] = -1.0/2.0*(1.0-ata1)*(1.0-3.0*s[1]*s[1]+2.0*s[1]*s[1]*s[1]);
    H2[8] = (1.0-3.0*s[1]*s[1]+2.0*s[1]*s[1]*s[1]);
    H2[11] = -1.0/2.0*((b1*b1)/(1.0+b2))*(s[1]*s[1]*s[1]-s[1]*s[1]);
    H2[12] = 1.0/2.0*(b2+ata1)*(s[1]*s[1]*s[1]-s[1]*s[1]);
    H2[13] = -1.0/2.0*( (2.0*c1*cc1)/(c1*cc2+c2*cc1) +1.0-ata1)*(s[1]-2.0*s[1]*s[1]+s[1]*s[1]*s[1]);
    H2[14] = -1.0*((c2*cc2)/(c1*cc2+c2*cc1))*(s[1]-2.0*s[1]*s[1]+s[1]*s[1]*s[1]);
    H2[16] = 1.0/2.0*(1.0/(1.0+b2))*(s[1]*s[1]*s[1]-s[1]*s[1]);
    H2[17] = ((-1.0)/(c1*cc2+c2*cc1))*(s[1]-2.0*s[1]*s[1]+s[1]*s[1]*s[1]);

    for(unsigned i=0;i<21;i++)
     {
      Bt(18,i) = e1*F2_div(i,1)+e2*H2[i];
     }
     
    t[0] = p(2,0)-p(1,0) + 1.0/4.0*(p(1,0)-p(0,0))-1.0/8.0*(angle_max-angle_min)*(-3.0*sin(angle_min)+sin(angle_max));
    t[1] = p(2,1)-p(1,1) + 1.0/4.0*(p(1,1)-p(0,1))-1.0/8.0*(angle_max-angle_min)*(3.0*cos(angle_min)-cos(angle_max));
    magnitude = sqrt((p(0,0)-p(2,0))*(p(0,0)-p(2,0)) + (p(0,1)-p(2,1))*(p(0,1)-p(2,1)));
    aa[0] = (p(0,0)-p(2,0))/(magnitude*magnitude);
    aa[1] = (p(0,1)-p(2,1))/(magnitude*magnitude);
    f1 = (t[0]*aa[0] + t[1]*aa[1]);
    
    magnitude = sqrt((p(1,0)-s2[0])*(p(1,0)-s2[0]) + (p(1,1)-s2[1])*(p(1,1)-s2[1]));
    aa[0] = (p(1,0)-s2[0])/(magnitude*magnitude);
    aa[1] = (p(1,1)-s2[1])/(magnitude*magnitude);
    f2 = (t[0]*aa[0] + t[1]*aa[1]);
    
    s[0] = 1.0/2.0;
    F1_div(0,0) = 5.0*s[0]*s[0]*6.0*s[0]*s[0]-4.0*s[0]*s[0]*15.0*s[0]+3.0*s[0]*s[0]*10.0;
    F1_div(2,0) = (1.0-s[0])*(1.0-s[0])*(1.0-s[0])*(12.0*s[0]+3.0)-3.0*(1.0-s[0])*(1.0-s[0])*(6.0*s[0]*s[0]+3.0*s[0]+1.0);
    F1_div(3,0) = s[0]*s[0]*s[0]*(1.0-s[0])*(-3.0)+(4.0-3.0*s[0])*(-s[0]*s[0]*s[0]+3.0*s[0]*s[0]*(1.0-s[0]));
    F1_div(8,0) = s[0]*(1.0-s[0])*(1.0-s[0])*(1.0-s[0])*3.0+(-3.0*s[0]*(1.0-s[0])*(1.0-s[0])+(1.0-s[0])*(1.0-s[0])*(1.0-s[0]))*(1.0+3.0*s[0]);
    F1_div(9,0) = -1.0*s[0]*s[0]*s[0]*(1.0-s[0])+3.0/2.0*(1.0-s[0])*(1.0-s[0])*s[0]*s[0];
    F1_div(14,0) = -3.0/2.0*s[0]*s[0]*(1.0-s[0])*(1.0-s[0]) + 1.0/2.0*(1.0-s[0])*(1.0-s[0])*(1.0-s[0])*2.0*s[0];

    s[0] = 1.0/2.0;
    H1[3] = -1.0/2.0*(1.0-ata2+2.0*a1)*(3.0*s[0]*s[0]-2.0*s[0]*s[0]*s[0]);
    H1[4] = -1.0*a2*(3.0*s[0]*s[0]-2.0*s[0]*s[0]*s[0]);
    H1[7] = 1.0-3.0*s[0]*s[0]+2.0*s[0]*s[0]*s[0];
    H1[8] = -1.0/2.0*(1.0+ata2)*(1.0-3.0*s[0]*s[0]+2.0*s[0]*s[0]*s[0]);
    H1[9] = 1.0/2.0*(a1-ata2)*(s[0]*s[0]*s[0]-s[0]*s[0]);
    H1[10] = -1.0/2.0*(a2*a2/(1.0+a1))*(s[0]*s[0]*s[0]-s[0]*s[0]);
    H1[13] = ((-1.0*c1*cc1)/(c1*cc2+c2*cc1))*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H1[14] = -1.0*( 1.0/2.0*(1.0+ata2)+(c2*cc2/(c1*cc2+c2*cc1)) )*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H1[15] = (s[0]*s[0]*s[0]-s[0]*s[0])/(2.0*(1.0+a1));
    H1[17] = -1.0/(c1*cc2+c2*cc1)*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);

    for(unsigned i=0;i<21;i++)
     {
      Bt(19,i) = f1*F1_div(i,0)+f2*H1[i];
     }
    
    double A = a1 + 1.0/2.0*aa1;
    double BB = a2 + 1.0/2.0*aa2;
    double C = 2.0*b1-bb1;
    double E = 2.0*b2-bb2;
    s[0] = 1.0/2.0;
    H3[3] = (3.0*s[0]*s[0]-2.0*s[0]*s[0]*s[0]) - A*(-1.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[4] = -1.0/2.0*(3.0*s[0]*s[0]-2.0*s[0]*s[0]*s[0]) - (BB+1.0/2.0)*(-1.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[5] = -1.0/2.0*(1.0-3.0*s[0]*s[0]+2.0*s[0]*s[0]*s[0]) + 1.0/2.0*(C+1.0)*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[6] = (1.0-3.0*s[0]*s[0]+2.0*s[0]*s[0]*s[0]) + 1.0/2.0*E*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[9] = (1.0+a1)/(2.0*a2)*(s[0]*s[0]*s[0]-s[0]*s[0]);
    H3[10] = 1.0/2.0*(1.0+ a2/(1.0+a1))*(s[0]*s[0]*s[0]-s[0]*s[0]);
    H3[11] = -1.0/2.0*(1.0+ b1/(1.0+b2) )*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[12] = -1.0*(1.0+b2)/(2.0*b1)*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[15] = -1.0/(2.0*(1.0+a1)*a2)*(s[0]*s[0]*s[0]-s[0]*s[0]);
    H3[16] = 1.0/(2.0*b1*(1.0+b2))*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);

    for(unsigned i=0;i<21;i++)
     {
      Bt(20,i) = -1.0*sqrt(2.0)*H3[i];
     }

    s[1] = 3.0/4.0;
    F2[1] = s[1]*s[1]*s[1]*(6.0*s[1]*s[1]-15.0*s[1]+10.0);
    F2[2] = (1.0-s[1])*(1.0-s[1])*(1.0-s[1])*(6.0*s[1]*s[1]+3.0*s[1]+1.0);
    F2[6] = s[1]*s[1]*s[1]*(1.0-s[1])*(4.0-3.0*s[1]);
    F2[7] = s[1]*(1.0-s[1])*(1.0-s[1])*(1.0-s[1])*(1.0+3.0*s[1]);
    F2[12] = 1.0/2.0*s[1]*s[1]*s[1]*(1.0-s[1])*(1.0-s[1]);
    F2[13] = 1.0/2.0*s[1]*s[1]*(1.0-s[1])*(1.0-s[1])*(1.0-s[1]);
    for(unsigned i=0;i<21;i++)
     {
      Bt(21,i) = F2[i];
     }
      
    s[1] = 1.0/4.0;
    F2[1] = s[1]*s[1]*s[1]*(6.0*s[1]*s[1]-15.0*s[1]+10.0);
    F2[2] = (1.0-s[1])*(1.0-s[1])*(1.0-s[1])*(6.0*s[1]*s[1]+3.0*s[1]+1.0);
    F2[6] = s[1]*s[1]*s[1]*(1.0-s[1])*(4.0-3.0*s[1]);
    F2[7] = s[1]*(1.0-s[1])*(1.0-s[1])*(1.0-s[1])*(1.0+3.0*s[1]);
    F2[12] = 1.0/2.0*s[1]*s[1]*s[1]*(1.0-s[1])*(1.0-s[1]);
    F2[13] = 1.0/2.0*s[1]*s[1]*(1.0-s[1])*(1.0-s[1])*(1.0-s[1]);
    for(unsigned i=0;i<21;i++)
     {
      Bt(22,i) = F2[i];
     }

    s[0] = 1.0/4.0;
    F1[0] = s[0]*s[0]*s[0]*(6.0*s[0]*s[0]-15.0*s[0]+10.0);
    F1[2] = (1.0-s[0])*(1.0-s[0])*(1.0-s[0])*(6.0*s[0]*s[0]+3.0*s[0]+1.0);
    F1[3] = s[0]*s[0]*s[0]*(1.0-s[0])*(4.0-3.0*s[0]);
    F1[8] = s[0]*(1.0-s[0])*(1.0-s[0])*(1.0-s[0])*(1.0+3.0*s[0]);
    F1[9] = 1.0/2.0*s[0]*s[0]*s[0]*(1.0-s[0])*(1.0-s[0]);
    F1[14] = 1.0/2.0*s[0]*s[0]*(1.0-s[0])*(1.0-s[0])*(1.0-s[0]);
    for(unsigned i=0;i<21;i++)
     {
      Bt(23,i) = F1[i];
     }
    
    s[0] = 3.0/4.0;
    F1[0] = s[0]*s[0]*s[0]*(6.0*s[0]*s[0]-15.0*s[0]+10.0);
    F1[2] = (1.0-s[0])*(1.0-s[0])*(1.0-s[0])*(6.0*s[0]*s[0]+3.0*s[0]+1.0);
    F1[3] = s[0]*s[0]*s[0]*(1.0-s[0])*(4.0-3.0*s[0]);
    F1[8] = s[0]*(1.0-s[0])*(1.0-s[0])*(1.0-s[0])*(1.0+3.0*s[0]);
    F1[9] = 1.0/2.0*s[0]*s[0]*s[0]*(1.0-s[0])*(1.0-s[0]);
    F1[14] = 1.0/2.0*s[0]*s[0]*(1.0-s[0])*(1.0-s[0])*(1.0-s[0]);
    for(unsigned i=0;i<21;i++)
     {
      Bt(24,i) = F1[i];
     }

    s[0] = 3.0/4.0;
    F3[0] = s[0]*s[0]*s[0]*(6.0*s[0]*s[0]-15.0*s[0]+10.0);
    F3[1] = (1.0-s[0])*(1.0-s[0])*(1.0-s[0])*(6.0*s[0]*s[0]+3.0*s[0]+1.0);
    F3[3] = -1.0*(3.0*a1+aa1)*s[0]*s[0]*s[0]*(1.0-s[0])*(1.0-s[0]);
    F3[4] = s[0]*s[0]*s[0]*(1.0-s[0])*(2.0-s[0]-(1.0-s[0])*(3.0*a2+aa2));
    F3[5] = s[0]*(1.0-s[0])*(1.0-s[0])*(1.0-s[0])*(1.0+s[0]-s[0]*(3.0*b1-bb1));
    F3[6] = -1.0*s[0]*s[0]*(1.0-s[0])*(1.0-s[0])*(1.0-s[0])*(3.0*b2-bb2);
    F3[10] = 1.0/2.0*s[0]*s[0]*s[0]*(1.0-s[0])*(1.0-s[0]);
    F3[11] = 1.0/2.0*s[0]*s[0]*(1.0-s[0])*(1.0-s[0])*(1.0-s[0]);
    for(unsigned i=0;i<21;i++)
     {
      Bt(25,i) = F3[i];
     }
    
    s[0] = 1.0/4.0;
    F3[0] = s[0]*s[0]*s[0]*(6.0*s[0]*s[0]-15.0*s[0]+10.0);
    F3[1] = (1.0-s[0])*(1.0-s[0])*(1.0-s[0])*(6.0*s[0]*s[0]+3.0*s[0]+1.0);
    F3[3] = -1.0*(3.0*a1+aa1)*s[0]*s[0]*s[0]*(1.0-s[0])*(1.0-s[0]);
    F3[4] = s[0]*s[0]*s[0]*(1.0-s[0])*(2.0-s[0]-(1.0-s[0])*(3.0*a2+aa2));
    F3[5] = s[0]*(1.0-s[0])*(1.0-s[0])*(1.0-s[0])*(1.0+s[0]-s[0]*(3.0*b1-bb1));
    F3[6] = -1.0*s[0]*s[0]*(1.0-s[0])*(1.0-s[0])*(1.0-s[0])*(3.0*b2-bb2);
    F3[10] = 1.0/2.0*s[0]*s[0]*s[0]*(1.0-s[0])*(1.0-s[0]);
    F3[11] = 1.0/2.0*s[0]*s[0]*(1.0-s[0])*(1.0-s[0])*(1.0-s[0]);
    for(unsigned i=0;i<21;i++)
     {
      Bt(26,i) = F3[i];
     }

    double g1,g2,h1,h2,k1,k2,j1,j2;
    t[0] = p(0,0)-p(2,0) + 9.0/16.0*(p(1,0)-p(0,0))+3.0/32.0*(angle_max-angle_min)*(-sin(angle_min)+7.0*sin(angle_max));
    t[1] = p(0,1)-p(2,1) + 9.0/16.0*(p(1,1)-p(0,1))+3.0/32.0*(angle_max-angle_min)*(cos(angle_min)-7.0*cos(angle_max));
    magnitude = sqrt((p(1,0)-p(2,0))*(p(1,0)-p(2,0)) + (p(1,1)-p(2,1))*(p(1,1)-p(2,1)));
    aa[0] = (p(1,0)-p(2,0))/(magnitude*magnitude);
    aa[1] = (p(1,1)-p(2,1))/(magnitude*magnitude);
    g1 = -1.0*(t[0]*aa[0] + t[1]*aa[1]);
    
    magnitude = sqrt((p(0,0)-s1[0])*(p(0,0)-s1[0]) + (p(0,1)-s1[1])*(p(0,1)-s1[1]));
    aa[0] = (p(0,0)-s1[0])/(magnitude*magnitude);
    aa[1] = (p(0,1)-s1[1])/(magnitude*magnitude);
    g2 = -1.0*(t[0]*aa[0] + t[1]*aa[1]);
    
    s[1] = 3.0/4.0;
    F2_div(1,1) = 5.0*s[1]*s[1]*6.0*s[1]*s[1]-4.0*s[1]*s[1]*15.0*s[1]+3.0*s[1]*s[1]*10.0;
    F2_div(2,1) = (1.0-s[1])*(1.0-s[1])*(1.0-s[1])*(12.0*s[1]+3.0)-3.0*(1.0-s[1])*(1.0-s[1])*(6.0*s[1]*s[1]+3.0*s[1]+1.0);
    F2_div(6,1) = s[1]*s[1]*s[1]*(1.0-s[1])*(-3.0)+(4.0-3.0*s[1])*(-s[1]*s[1]*s[1]+3.0*s[1]*s[1]*(1.0-s[1]));
    F2_div(7,1) = s[1]*(1.0-s[1])*(1.0-s[1])*(1.0-s[1])*3.0+(-3.0*s[1]*(1.0-s[1])*(1.0-s[1])+(1.0-s[1])*(1.0-s[1])*(1.0-s[1]))*(1.0+3.0*s[1]);
    F2_div(12,1) = -1.0*s[1]*s[1]*s[1]*(1.0-s[1])+3.0/2.0*(1.0-s[1])*(1.0-s[1])*s[1]*s[1];
    F2_div(13,1) = -3.0/2.0*s[1]*s[1]*(1.0-s[1])*(1.0-s[1]) + 1.0/2.0*(1.0-s[1])*(1.0-s[1])*(1.0-s[1])*2.0*s[1];
    
    s[1] = 3.0/4.0;
    H2[5] = -1.0*b1*(3.0*s[1]*s[1]-2.0*s[1]*s[1]*s[1]);
    H2[6] = -1.0/2.0*(2.0*b2+1.0+ata1)*(3.0*s[1]*s[1]-2.0*s[1]*s[1]*s[1]);
    H2[7] = -1.0/2.0*(1.0-ata1)*(1.0-3.0*s[1]*s[1]+2.0*s[1]*s[1]*s[1]);
    H2[8] = (1.0-3.0*s[1]*s[1]+2.0*s[1]*s[1]*s[1]);
    H2[11] = -1.0/2.0*((b1*b1)/(1.0+b2))*(s[1]*s[1]*s[1]-s[1]*s[1]);
    H2[12] = 1.0/2.0*(b2+ata1)*(s[1]*s[1]*s[1]-s[1]*s[1]);
    H2[13] = -1.0/2.0*( (2.0*c1*cc1)/(c1*cc2+c2*cc1) +1.0-ata1)*(s[1]-2.0*s[1]*s[1]+s[1]*s[1]*s[1]);
    H2[14] = -1.0*((c2*cc2)/(c1*cc2+c2*cc1))*(s[1]-2.0*s[1]*s[1]+s[1]*s[1]*s[1]);
    H2[16] = 1.0/2.0*(1.0/(1.0+b2))*(s[1]*s[1]*s[1]-s[1]*s[1]);
    H2[17] = ((-1.0)/(c1*cc2+c2*cc1))*(s[1]-2.0*s[1]*s[1]+s[1]*s[1]*s[1]);
    for(unsigned i=0;i<21;i++)
     {
      Bt(27,i) = g1*F2_div(i,1)+g2*H2[i];
     }
     
    t[0] = p(0,0)-p(2,0) + 1.0/16.0*(p(1,0)-p(0,0))+1.0/32.0*(angle_max-angle_min)*(-3.0*sin(angle_min)+5.0*sin(angle_max));
    t[1] = p(0,1)-p(2,1) + 1.0/16.0*(p(1,1)-p(0,1))+1.0/32.0*(angle_max-angle_min)*(3.0*cos(angle_min)-5.0*cos(angle_max));
    magnitude = sqrt((p(1,0)-p(2,0))*(p(1,0)-p(2,0)) + (p(1,1)-p(2,1))*(p(1,1)-p(2,1)));
    aa[0] = (p(1,0)-p(2,0))/(magnitude*magnitude);
    aa[1] = (p(1,1)-p(2,1))/(magnitude*magnitude);
    h1 = -1.0*(t[0]*aa[0] + t[1]*aa[1]);
    
    magnitude = sqrt((p(0,0)-s1[0])*(p(0,0)-s1[0]) + (p(0,1)-s1[1])*(p(0,1)-s1[1]));
    aa[0] = (p(0,0)-s1[0])/(magnitude*magnitude);
    aa[1] = (p(0,1)-s1[1])/(magnitude*magnitude);
    h2 = -1.0*(t[0]*aa[0] + t[1]*aa[1]);
    
    s[1] = 1.0/4.0;
    F2_div(1,1) = 5.0*s[1]*s[1]*6.0*s[1]*s[1]-4.0*s[1]*s[1]*15.0*s[1]+3.0*s[1]*s[1]*10.0;
    F2_div(2,1) = (1.0-s[1])*(1.0-s[1])*(1.0-s[1])*(12.0*s[1]+3.0)-3.0*(1.0-s[1])*(1.0-s[1])*(6.0*s[1]*s[1]+3.0*s[1]+1.0);
    F2_div(6,1) = s[1]*s[1]*s[1]*(1.0-s[1])*(-3.0)+(4.0-3.0*s[1])*(-s[1]*s[1]*s[1]+3.0*s[1]*s[1]*(1.0-s[1]));
    F2_div(7,1) = s[1]*(1.0-s[1])*(1.0-s[1])*(1.0-s[1])*3.0+(-3.0*s[1]*(1.0-s[1])*(1.0-s[1])+(1.0-s[1])*(1.0-s[1])*(1.0-s[1]))*(1.0+3.0*s[1]);
    F2_div(12,1) = -1.0*s[1]*s[1]*s[1]*(1.0-s[1])+3.0/2.0*(1.0-s[1])*(1.0-s[1])*s[1]*s[1];
    F2_div(13,1) = -3.0/2.0*s[1]*s[1]*(1.0-s[1])*(1.0-s[1]) + 1.0/2.0*(1.0-s[1])*(1.0-s[1])*(1.0-s[1])*2.0*s[1];
    
    s[1] = 1.0/4.0;
    H2[5] = -1.0*b1*(3.0*s[1]*s[1]-2.0*s[1]*s[1]*s[1]);
    H2[6] = -1.0/2.0*(2.0*b2+1.0+ata1)*(3.0*s[1]*s[1]-2.0*s[1]*s[1]*s[1]);
    H2[7] = -1.0/2.0*(1.0-ata1)*(1.0-3.0*s[1]*s[1]+2.0*s[1]*s[1]*s[1]);
    H2[8] = (1.0-3.0*s[1]*s[1]+2.0*s[1]*s[1]*s[1]);
    H2[11] = -1.0/2.0*((b1*b1)/(1.0+b2))*(s[1]*s[1]*s[1]-s[1]*s[1]);
    H2[12] = 1.0/2.0*(b2+ata1)*(s[1]*s[1]*s[1]-s[1]*s[1]);
    H2[13] = -1.0/2.0*( (2.0*c1*cc1)/(c1*cc2+c2*cc1) +1.0-ata1)*(s[1]-2.0*s[1]*s[1]+s[1]*s[1]*s[1]);
    H2[14] = -1.0*((c2*cc2)/(c1*cc2+c2*cc1))*(s[1]-2.0*s[1]*s[1]+s[1]*s[1]*s[1]);
    H2[16] = 1.0/2.0*(1.0/(1.0+b2))*(s[1]*s[1]*s[1]-s[1]*s[1]);
    H2[17] = ((-1.0)/(c1*cc2+c2*cc1))*(s[1]-2.0*s[1]*s[1]+s[1]*s[1]*s[1]);

    for(unsigned i=0;i<21;i++)
     {
      Bt(28,i) = h1*F2_div(i,1)+h2*H2[i];
     }
     
    t[0] = p(1,0)-p(2,0) + 1.0/16.0*(p(0,0)-p(1,0))-1.0/32.0*(angle_max-angle_min)*(-3.0*sin(angle_max)+5.0*sin(angle_min));
    t[1] = p(1,1)-p(2,1) + 1.0/16.0*(p(0,1)-p(1,1))-1.0/32.0*(angle_max-angle_min)*(3.0*cos(angle_max)-5.0*cos(angle_min));
    magnitude = sqrt((p(0,0)-p(2,0))*(p(0,0)-p(2,0)) + (p(0,1)-p(2,1))*(p(0,1)-p(2,1)));
    aa[0] = (p(0,0)-p(2,0))/(magnitude*magnitude);
    aa[1] = (p(0,1)-p(2,1))/(magnitude*magnitude);
    j1 = -1.0*(t[0]*aa[0] + t[1]*aa[1]);
    
    magnitude = sqrt((p(1,0)-s2[0])*(p(1,0)-s2[0]) + (p(1,1)-s2[1])*(p(1,1)-s2[1]));
    aa[0] = (p(1,0)-s2[0])/(magnitude*magnitude);
    aa[1] = (p(1,1)-s2[1])/(magnitude*magnitude);
    j2 = -1.0*(t[0]*aa[0] + t[1]*aa[1]);
    
    s[0] = 1.0/4.0;
    F1_div(0,0) = 5.0*s[0]*s[0]*6.0*s[0]*s[0]-4.0*s[0]*s[0]*15.0*s[0]+3.0*s[0]*s[0]*10.0;
    F1_div(2,0) = (1.0-s[0])*(1.0-s[0])*(1.0-s[0])*(12.0*s[0]+3.0)-3.0*(1.0-s[0])*(1.0-s[0])*(6.0*s[0]*s[0]+3.0*s[0]+1.0);
    F1_div(3,0) = s[0]*s[0]*s[0]*(1.0-s[0])*(-3.0)+(4.0-3.0*s[0])*(-s[0]*s[0]*s[0]+3.0*s[0]*s[0]*(1.0-s[0]));
    F1_div(8,0) = s[0]*(1.0-s[0])*(1.0-s[0])*(1.0-s[0])*3.0+(-3.0*s[0]*(1.0-s[0])*(1.0-s[0])+(1.0-s[0])*(1.0-s[0])*(1.0-s[0]))*(1.0+3.0*s[0]);
    F1_div(9,0) = -1.0*s[0]*s[0]*s[0]*(1.0-s[0])+3.0/2.0*(1.0-s[0])*(1.0-s[0])*s[0]*s[0];
    F1_div(14,0) = -3.0/2.0*s[0]*s[0]*(1.0-s[0])*(1.0-s[0]) + 1.0/2.0*(1.0-s[0])*(1.0-s[0])*(1.0-s[0])*2.0*s[0];
    s[0] = 1.0/4.0;
    H1[3] = -1.0/2.0*(1.0-ata2+2.0*a1)*(3.0*s[0]*s[0]-2.0*s[0]*s[0]*s[0]);
    H1[4] = -1.0*a2*(3.0*s[0]*s[0]-2.0*s[0]*s[0]*s[0]);
    H1[7] = 1.0-3.0*s[0]*s[0]+2.0*s[0]*s[0]*s[0];
    H1[8] = -1.0/2.0*(1.0+ata2)*(1.0-3.0*s[0]*s[0]+2.0*s[0]*s[0]*s[0]);
    H1[9] = 1.0/2.0*(a1-ata2)*(s[0]*s[0]*s[0]-s[0]*s[0]);
    H1[10] = -1.0/2.0*(a2*a2/(1.0+a1))*(s[0]*s[0]*s[0]-s[0]*s[0]);
    H1[13] = ((-1.0*c1*cc1)/(c1*cc2+c2*cc1))*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H1[14] = -1.0*( 1.0/2.0*(1.0+ata2)+(c2*cc2/(c1*cc2+c2*cc1)) )*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H1[15] = (s[0]*s[0]*s[0]-s[0]*s[0])/(2.0*(1.0+a1));
    H1[17] = -1.0/(c1*cc2+c2*cc1)*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    for(unsigned i=0;i<21;i++)
     {
      Bt(29,i) = j1*F1_div(i,0)+j2*H1[i];
     }
    
    t[0] = p(1,0)-p(2,0) + 9.0/16.0*(p(0,0)-p(1,0))-3.0/32.0*(angle_max-angle_min)*(-sin(angle_max)+7.0*sin(angle_min));
    t[1] = p(1,1)-p(2,1) + 9.0/16.0*(p(0,1)-p(1,1))-3.0/32.0*(angle_max-angle_min)*(cos(angle_max)-7.0*cos(angle_min));
    magnitude = sqrt((p(0,0)-p(2,0))*(p(0,0)-p(2,0)) + (p(0,1)-p(2,1))*(p(0,1)-p(2,1)));
    aa[0] = (p(0,0)-p(2,0))/(magnitude*magnitude);
    aa[1] = (p(0,1)-p(2,1))/(magnitude*magnitude);
    k1 = -1.0*(t[0]*aa[0] + t[1]*aa[1]);
    
    magnitude = sqrt((p(1,0)-s2[0])*(p(1,0)-s2[0]) + (p(1,1)-s2[1])*(p(1,1)-s2[1]));
    aa[0] = (p(1,0)-s2[0])/(magnitude*magnitude);
    aa[1] = (p(1,1)-s2[1])/(magnitude*magnitude);
    k2 = -1.0*(t[0]*aa[0] + t[1]*aa[1]);
    
    s[0] = 3.0/4.0;
    F1_div(0,0) = 5.0*s[0]*s[0]*6.0*s[0]*s[0]-4.0*s[0]*s[0]*15.0*s[0]+3.0*s[0]*s[0]*10.0;
    F1_div(2,0) = (1.0-s[0])*(1.0-s[0])*(1.0-s[0])*(12.0*s[0]+3.0)-3.0*(1.0-s[0])*(1.0-s[0])*(6.0*s[0]*s[0]+3.0*s[0]+1.0);
    F1_div(3,0) = s[0]*s[0]*s[0]*(1.0-s[0])*(-3.0)+(4.0-3.0*s[0])*(-s[0]*s[0]*s[0]+3.0*s[0]*s[0]*(1.0-s[0]));
    F1_div(8,0) = s[0]*(1.0-s[0])*(1.0-s[0])*(1.0-s[0])*3.0+(-3.0*s[0]*(1.0-s[0])*(1.0-s[0])+(1.0-s[0])*(1.0-s[0])*(1.0-s[0]))*(1.0+3.0*s[0]);
    F1_div(9,0) = -1.0*s[0]*s[0]*s[0]*(1.0-s[0])+3.0/2.0*(1.0-s[0])*(1.0-s[0])*s[0]*s[0];
    F1_div(14,0) = -3.0/2.0*s[0]*s[0]*(1.0-s[0])*(1.0-s[0]) + 1.0/2.0*(1.0-s[0])*(1.0-s[0])*(1.0-s[0])*2.0*s[0];
    
    s[0] = 3.0/4.0;
    H1[3] = -1.0/2.0*(1.0-ata2+2.0*a1)*(3.0*s[0]*s[0]-2.0*s[0]*s[0]*s[0]);
    H1[4] = -1.0*a2*(3.0*s[0]*s[0]-2.0*s[0]*s[0]*s[0]);
    H1[7] = 1.0-3.0*s[0]*s[0]+2.0*s[0]*s[0]*s[0];
    H1[8] = -1.0/2.0*(1.0+ata2)*(1.0-3.0*s[0]*s[0]+2.0*s[0]*s[0]*s[0]);
    H1[9] = 1.0/2.0*(a1-ata2)*(s[0]*s[0]*s[0]-s[0]*s[0]);
    H1[10] = -1.0/2.0*(a2*a2/(1.0+a1))*(s[0]*s[0]*s[0]-s[0]*s[0]);
    H1[13] = ((-1.0*c1*cc1)/(c1*cc2+c2*cc1))*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H1[14] = -1.0*( 1.0/2.0*(1.0+ata2)+(c2*cc2/(c1*cc2+c2*cc1)) )*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H1[15] = (s[0]*s[0]*s[0]-s[0]*s[0])/(2.0*(1.0+a1));
    H1[17] = -1.0/(c1*cc2+c2*cc1)*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    for(unsigned i=0;i<21;i++)
     {
      Bt(30,i) = k1*F1_div(i,0)+k2*H1[i];
     }
    
    s[0] = 3.0/4.0;
    H3[3] = (3.0*s[0]*s[0]-2.0*s[0]*s[0]*s[0]) - A*(-1.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[4] = -1.0/2.0*(3.0*s[0]*s[0]-2.0*s[0]*s[0]*s[0]) - (BB+1.0/2.0)*(-1.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[5] = -1.0/2.0*(1.0-3.0*s[0]*s[0]+2.0*s[0]*s[0]*s[0]) + 1.0/2.0*(C+1.0)*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[6] = (1.0-3.0*s[0]*s[0]+2.0*s[0]*s[0]*s[0]) + 1.0/2.0*E*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[9] = (1.0+a1)/(2.0*a2)*(s[0]*s[0]*s[0]-s[0]*s[0]);
    H3[10] = 1.0/2.0*(1.0+ a2/(1.0+a1))*(s[0]*s[0]*s[0]-s[0]*s[0]);
    H3[11] = -1.0/2.0*(1.0+ b1/(1.0+b2) )*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[12] = -1.0*(1.0+b2)/(2.0*b1)*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[15] = -1.0/(2.0*(1.0+a1)*a2)*(s[0]*s[0]*s[0]-s[0]*s[0]);
    H3[16] = 1.0/(2.0*b1*(1.0+b2))*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);

    for(unsigned i=0;i<21;i++)
    for(unsigned i=0;i<21;i++)
     {
      Bt(31,i) = -1.0*sqrt(2.0)*H3[i];
     }
    
    s[0] = 1.0/4.0;
    H3[3] = (3.0*s[0]*s[0]-2.0*s[0]*s[0]*s[0]) - A*(-1.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[4] = -1.0/2.0*(3.0*s[0]*s[0]-2.0*s[0]*s[0]*s[0]) - (BB+1.0/2.0)*(-1.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[5] = -1.0/2.0*(1.0-3.0*s[0]*s[0]+2.0*s[0]*s[0]*s[0]) + 1.0/2.0*(C+1.0)*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[6] = (1.0-3.0*s[0]*s[0]+2.0*s[0]*s[0]*s[0]) + 1.0/2.0*E*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[9] = (1.0+a1)/(2.0*a2)*(s[0]*s[0]*s[0]-s[0]*s[0]);
    H3[10] = 1.0/2.0*(1.0+ a2/(1.0+a1))*(s[0]*s[0]*s[0]-s[0]*s[0]);
    H3[11] = -1.0/2.0*(1.0+ b1/(1.0+b2) )*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[12] = -1.0*(1.0+b2)/(2.0*b1)*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);
    H3[15] = -1.0/(2.0*(1.0+a1)*a2)*(s[0]*s[0]*s[0]-s[0]*s[0]);
    H3[16] = 1.0/(2.0*b1*(1.0+b2))*(s[0]-2.0*s[0]*s[0]+s[0]*s[0]*s[0]);

    for(unsigned i=0;i<21;i++)
     {
      Bt(32,i) = -1.0*sqrt(2.0)*H3[i];
     }
    // submatrix b7
    Bt(33,18)=1.0;
    Bt(34,19)=1.0;
    Bt(35,20)=1.0;
    for(unsigned i=0;i<21;i++)
     {
      for(unsigned j=0;j<36;j++)
       {
        B(i,j) = Bt(j,i);
       }            
     }
   }

 ///=========================================================================
 /// Compute C1-curved shape functions at the local coordinate s
 ///========================================================================
 void Cshape(const Vector<double> &s, Shape &psi_curve) const
  {
   // get basis
   Shape basis(36);
   basis_curve(s,basis);
   // get coefficient of the basis polynomial
   DenseMatrix<double> A(36,36);
   get_coefficient(A);

   Vector<double> psi(36,0.0);
   for(unsigned i=0;i<36;i++)
    {
     for(unsigned j=0;j<36;j++)
      {
       psi[i] += A(i,j)*basis[j];
      }
    }
   for(unsigned i=0;i<36;i++)
    {
     psi_curve[i] = psi[i];
    }
  }
 
 ///=========================================================================
 /// Compute the derivatives of C1-curved shape functions at the local 
 /// coordinate s
 ///=========================================================================
 void dCshape_local(const Vector<double> &s, Shape &psi_curve, DShape &dpsi_curve) const 
  {
   Cshape(s,psi_curve);
   // get dbasis
   Shape basis(36);
   DShape dbasis(36,2);
   dbasis_local_curve(s,basis,dbasis);
   // get coefficient of the basis polynomial
   DenseMatrix<double> A(36,36);
   get_coefficient(A);
   DenseMatrix<double> dpsi(36,2,0.0);
   for(unsigned i=0;i<36;i++)
    {
     for(unsigned j=0;j<36;j++)
      {
       for(unsigned k=0;k<2;k++)
        {
         dpsi(i,k) += A(i,j)*dbasis(j,k);
        }
      }
    }
   for(unsigned i=0;i<36;i++)
    {
     for(unsigned k=0;k<2;k++)
      {
       dpsi_curve(i,k) = dpsi(i,k);
      }
    }
  }

 ///=========================================================================
 /// Compute the second-order derivatives of C1-curved shape functions  
 /// at the local coordinate s
 ///=========================================================================
 void d2Cshape_local(const Vector<double> &s, Shape &psi_curve, DShape &dpsi_curve, DShape &d2psi_curve) const
  {
   dCshape_local(s,psi_curve,dpsi_curve);

   // get d2basis
   Shape basis(36);
   DShape dbasis(36,2), d2basis(36,3);
   d2basis_local_curve(s,basis,dbasis,d2basis);
   // get coefficient of the basis polynomial
   DenseMatrix<double> A(36,36,0.0);
   get_coefficient(A);
   DenseMatrix<double> d2psi(36,3,0.0);
   for(unsigned i=0;i<36;i++)
    {
     for(unsigned j=0;j<36;j++)
      {
       for(unsigned k=0;k<3;k++)
        {
         d2psi(i,k) += A(i,j)*d2basis(j,k);
        }
      }
    }
   for(unsigned i=0;i<36;i++)
    {
     for(unsigned k=0;k<3;k++)
      {
       d2psi_curve(i,k) = d2psi(i,k);
      }
    }
  }
 
 ///=========================================================================
 /// Compute coefficients of the bases of the C1-curved shape functions 
 ///=========================================================================
 void get_coefficient(DenseMatrix<double> &A) const
  {
   // initialize the matrix A
   for(unsigned i=0;i<36;i++)
    {
     for(unsigned j=0;j<36;j++)
      {A(i,j)=0.0;}
    }
   // 1
   A(1,0) = 6496.0/27.0;
   A(1,2) = 55376.0/27.0;
   A(1,3) = 15296.0/3.0;
   A(1,4) = 86464.0/27.0;
   A(1,5) = 464.0/3.0;
   A(1,8) = -6896.0/9.0;
   A(1,10) = -136424.0/27.0;
   A(1,11) = -187040.0/27.0;
   A(1,12) = -27880.0/27.0;
   A(1,15) = 7750.0/9.0;
   A(1,17) = 98371.0/27.0;
   A(1,18) = 41027.0/27.0;
   A(1,21) = -10501.0/27.0;
   A(1,23) = -17323.0/27.0;
   A(1,26) = 490.0/9.0;
   A(0,2) = 464.0/3.0;
   A(0,3) = 86464.0/27.0;
   A(0,4) = 15296.0/3.0;
   A(0,5) = 55376.0/27.0;
   A(0,7) = 6496.0/27.0;
   A(0,10) = -27880.0/27.0;
   A(0,11) = -187040.0/27.0;
   A(0,12) = -136424.0/27.0;
   A(0,14) = -6896.0/9.0;
   A(0,17) = 41027.0/27.0;
   A(0,18) = 98371.0/27.0;
   A(0,20) = 7750.0/9.00;
   A(0,23) = -17323.0/27.0;
   A(0,25) = -10501.0/27.0;
   A(0,29) = 490.00/9.0;
   A(2,0) = -6496.00/27.0;
   A(2,2) = 14176.00/27.00;
   A(2,3) = -2944.00/27.00;
   A(2,4) = -2944.00/27.00;
   A(2,5) = 14176.00/27.00;
   A(2,7) = -6496.00/27.00;
   A(2,8) = 24784.00/27.00;
   A(2,10) = -5680.00/27.00;
   A(2,11) = 12736.00/9.00;
   A(2,12) = -5680.00/27.00;
   A(2,14) = 24784.00/27.00;
   A(2,15) = -11846.00/9.00;
   A(2,17) = -26758.00/27.00;
   A(2,18) = -26758.00/27.00;
   A(2,20) = -11846.00/9.00;
   A(2,21) = 22789.00/27.00;
   A(2,23) = 18262.00/27.00;
   A(2,25) = 22789.00/27.00;
   A(2,26) = -5566.00/27.00;
   A(2,29) = -5566.00/27.00;
   A(2,35) = 1.00;
   A(6,0) = -400.00/9.00;
   A(6,2) = -3080.00/9.00;
   A(6,3) = -816.00;
   A(6,4) = -4496.00/9.00;
   A(6,5) = -232.00/9.00;
   A(6,8) = 416.00/3.00;
   A(6,10) = 7448.00/9.00;
   A(6,11) = 9872.00/9.00;
   A(6,12) = 1472.00/9.00;
   A(6,15) = -457.00/3.00;
   A(6,17) = -1177.00/2.00;
   A(6,18) = -4337.00/18.00;
   A(6,21) = 607.00/9.00;
   A(6,23) = 619.00/6.00;
   A(6,26) = -28.00/3.00;
   A(5,1) = -896.00/9.00;
   A(5,2) = -392.00/9.00;
   A(5,3) = 2384.00/9.00;
   A(5,4) = 2512.00/9.00;
   A(5,5) = 232.00/9.00;
   A(5,9) = 2336.00/9.00;
   A(5,10) = -8.00/9.00;
   A(5,11) = -3920.00/9.00;
   A(5,12) = -976.00/9.00;
   A(5,16) = -2104.00/9.00;
   A(5,17) = 123.00/2.00;
   A(5,18) = 1981.00/18.00;
   A(5,22) = 766.00/9.00;
   A(5,23) = -307.00/18.00;
   A(5,27) = -31.00/3.00;
   A(4,2) = 232.00/9.00;
   A(4,3) = 2512.00/9.00;
   A(4,4) = 2384.00/9.00;
   A(4,5) = -392.00/9.00;
   A(4,6) = -896.00/9.00;
   A(4,10) = -976.00/9.00;
   A(4,11) = -3920.00/9.00;
   A(4,12) = -8.00/9.00;
   A(4,13) = 2336.00/9.00;
   A(4,17) = 1981.00/18.00;
   A(4,18) = 123.00/2.00;
   A(4,19) = -2104.00/9.00;
   A(4,23) = -307.00/18.00;
   A(4,24) = 766.00/9.00;
   A(4,28) = -31.00/3.00;
   A(3,2) = -232.00/9.00;
   A(3,3) = -4496.00/9.00;
   A(3,4) = -816.00;
   A(3,5) = -3080.00/9.00;
   A(3,7) = -400.00/9.00;
   //------- 2
   A(3,10) = 1472.00/9.00;
   A(3,11) = 9872.00/9.00;
   A(3,12) = 7448.00/9.00;
   A(3,14) = 416.00/3.00;
   A(3,17) = -4337.00/18.00;
   A(3,18) = -1177.00/2.00;
   A(3,20) = -457.00/3.00;
   A(3,23) = 619.00/6.00;
   A(3,25) = 607.00/9.00;
   A(3,29) = -28.00/3.00;
   A(8,0) = -400.00/9.00;
   A(8,2) = 1456.00/9.00;
   A(8,3) = -992.00/9.00;
   A(8,4) = -5248.00/9.00;
   A(8,5) = -4096.00/9.00;
   A(8,6) = -896.00/9.00;
   A(8,8) = 1552.00/9.00;
   A(8,10) = -464.00/3.00;
   A(8,11) = 2464.00/3.00;
   A(8,12) = 3424.00/3.00;
   A(8,13) = 3040.00/9.00;
   A(8,15) = -761.00/3.00;
   A(8,17) = -1831.00/9.00;
   A(8,18) = -938.00;
   A(8,19) = -1288.00/3.00;
   A(8,21) = 1528.00/9.00;
   A(8,23) = 2266.00/9.00;
   A(8,24) = 2210.00/9.00;
   A(8,26) = -406.00/9.00;
   A(8,28) = -499.00/9.00;
   A(8,33) = 1.00;
   A(7,1) = -896.00/9.00;
   A(7,2) = -4096.00/9.00;
   A(7,3) = -5248.00/9.00;
   A(7,4) = -992.00/9.00;
   A(7,5) = 1456.00/9.00;
   A(7,7) = -400.00/9.00;
   A(7,9) = 3040.00/9.00;
   A(7,10) = 3424.00/3.00;
   A(7,11) = 2464.00/3.00;
   A(7,12) = -464.00/3.00;
   A(7,14) = 1552.00/9.00;
   A(7,16) = -1288.00/3.00;
   A(7,17) = -938.00;
   A(7,18) = -1831.00/9.00;
   A(7,20) = -761.00/3.00;
   A(7,22) = 2210.00/9.00;
   A(7,23) = 2266.00/9.00;
   A(7,25) = 1528.00/9.00;
   A(7,27) = -499.00/9.00;
   A(7,29) = -406.00/9.00;
   A(7,34) = 1.00;
   A(14,0) = 8.00/3.00;
   A(14,2) = 52.00/3.00;
   A(14,3) = 40.00;
   A(14,4) = 24.00;
   A(14,5) = 4.00/3.00;
   A(14,8) = -8.00;
   A(14,10) = -124.00/3.00;
   A(14,11) = -160.00/3.00;
   A(14,12) = -8.00;
   A(14,15) = 17.00/2.00;
   A(14,17) = 349.00/12.00;
   A(14,18) = 47.00/4.00;
   A(14,21) = -11.00/3.00;
   A(14,23) = -61.00/12.00;
   A(14,26) = 1.00/2.00;
   A(13,1) = 32.00/3.00;
   A(13,2) = 8.00/3.00;
   A(13,3) = -80.00/3.00;
   A(13,4) = -80.00/3.00;
   A(13,5) = -8.00/3.00;
   A(13,9) = -80.00/3.00;
   A(13,10) = 8.00/3.00;
   A(13,11) = 128.00/3.00;
   A(13,12) = 32.00/3.00;
   A(13,16) = 70.00/3.0;
   A(13,17) = -43.0/6.0;
   A(13,18) = -65.0/6.0;
   A(13,22) = -25.0/3.0;
   A(13,23) = 11.0/6.0;
   A(13,27) = 1.0;
   A(12,2) = 4.0;
   A(12,3) = 40.0/3.0;
   A(12,4) = 40.0/3.0;
   A(12,5) = 4.0/3.0;
   A(12,10) = -28.0/3.0;
   A(12,11) = -64.0/3.0;
   A(12,12) = -16.0/3.0;
   A(12,17) = 29.0/4.0;
   A(12,18) = 65.0/12.0;
   A(12,23) = -17.0/12.0;
   A(11,2) = 4.0/3.0;
   A(11,3) = 40.0/3.0;
   A(11,4) = 40.0/3.0;
   A(11,5) = 4.0;
   A(11,10) = -16.0/3.0;
   A(11,11) = -64.0/3.0;
   A(11,12) = -28.0/3.0;
   A(11,17) = 65.0/12.0;
   A(11,18) = 29.0/4.0;
   A(11,23) = -17.0/12.0;
   //------- 3
   A(10,2) = -8.0/3.0;
   A(10,3) = -80.0/3.0;
   A(10,4) = -80.0/3.0;
   A(10,5) = 8.0/3.0;
   A(10,6) = 32.0/3.0;
   A(10,10) = 32.0/3.0;
   A(10,11) = 128.0/3.0;
   A(10,12) = 8.0/3.0;
   A(10,13) = -80.0/3.0;
   A(10,17) = -65.0/6.0;
   A(10,18) = -43.0/6.0;
   A(10,19) = 70.0/3.0;
   A(10,23) = 11.0/6.0;
   A(10,24) = -25.0/3.0;
   A(10,28) = 1.0;
   A(9,2) = 4.0/3.0;
   A(9,3) = 24.0;
   A(9,4) = 40.0;
   A(9,5) = 52.0/3.0;
   A(9,7) = 8.0/3.0;
   A(9,10) = -8.0;
   A(9,11) = -160.0/3.0;
   A(9,12) = -124.0/3.0;
   A(9,14) = -8.0;
   A(9,17) = 47.0/4.0;
   A(9,18) = 349.0/12.0;
   A(9,20) = 17.0/2.0;
   A(9,23) = -61.0/12.0;
   A(9,25) = -11.0/3.0;
   A(9,29) = 1.0/2.0;
   A(17,0) = -8.0/3.0;
   A(17,2) = 56.0/3.0;
   A(17,3) = 80.0/3.0;
   A(17,4) = 32.0/3.0;
   A(17,8) = 32.0/3.0;
   A(17,10) = -40.0;
   A(17,11) = -32.0;
   A(17,12) = -8.0/3.0;
   A(17,15) = -33.0/2.0;
   A(17,17) = 51.0/2.0;
   A(17,18) = 19.0/3.0;
   A(17,21) = 73.0/6.0;
   A(17,23) = -25.0/6.0;
   A(17,26) = -25.0/6.0;
   A(17,30) = 1.0/2.0;
   A(16,1) = -32.0/3.0;
   A(16,2) = -160.0/3.0;
   A(16,3) = -320.0/3.0;
   A(16,4) = -320.0/3.0;
   A(16,5) = -160.0/3.0;
   A(16,6) = -32.0/3.0;
   A(16,9) = 112.0/3.0;
   A(16,10) = 448.0/3.0;
   A(16,11) = 224.0;
   A(16,12) = 448.0/3.0;
   A(16,13) = 112.0/3.0;
   A(16,16) = -50.0;
   A(16,17) = -150.0;
   A(16,18) = -150.0;
   A(16,19) = -50.0;
   A(16,22) = 95.0/3.0;
   A(16,23) = 190.0/3.0;
   A(16,24) = 95.0/3.0;
   A(16,27) = -28.0/3.0;
   A(16,28) = -28.0/3.0;
   A(16,31) = 1.0;
   A(15,3) = 32.0/3.0;
   A(15,4) = 80.0/3.0;
   A(15,5) = 56.0/3.0;
   A(15,7) = -8.0/3.0;
   A(15,10) = -8.0/3.0;
   A(15,11) = -32.0;
   A(15,12) = -40.0;
   A(15,14) = 32.0/3.0;
   A(15,17) = 19.0/3.0;
   A(15,18) = 51.0/2.0;
   A(15,20) = -33.0/2.0;
   A(15,23) = -25.0/6.0;
   A(15,25) = 73.0/6.0;
   A(15,29) = -25.0/6.0;
   A(15,32) = 1.0/2.0;
   A(19,3) = 256.0;
   A(19,4) = 768.0;
   A(19,5) = 768.0;
   A(19,6) = 256.0;
   A(19,10) = -64.0;
   A(19,11) = -896.0;
   A(19,12) = -1600.0;
   A(19,13) = -768.0;
   A(19,17) = 176.0;
   A(19,18) = 992.0;
   A(19,19) = 816.0;
   A(19,23) = -160.0;
   A(19,24) = -352.0;
   A(19,28) = 48.0;
   A(18,1) = 256.0;
   A(18,2) = 768.0;
   A(18,3) = 768.0;
   A(18,4) = 256.0;
   A(18,9) = -768.0;
   A(18,10) =-1600.0;
   A(18,11) = -896.0;

   //--------- 4
   A(18,12) = -64.0;
   A(18,16) = 816.0;
   A(18,17) = 992.0;
   A(18,18) = 176.0;
   A(18,22) = -352.0;
   A(18,23) = -160.0;
   A(18,27) = 48.0;
   A(20,3) = 128.0*sqrt(2.0);
   A(20,4) = 128.0*sqrt(2.0);
   A(20,10) = -32.0*sqrt(2.0);
   A(20,11) = -192.0*sqrt(2.0);
   A(20,12) = -32.0*sqrt(2.0);
   A(20,17) = 40.0*sqrt(2.0);
   A(20,18) = 40.0*sqrt(2.0);
   A(20,23) = -8.0*sqrt(2.0);
   A(24,3) = -65536.0/27.0;
   A(24,4) = -114688.0/27.0;
   A(24,5) = -40960.0/27.0;
   A(24,7) = -8192.0/27.0;
   A(24,10) = 16384.0/27.0;
   A(24,11) = 53248./9.0;
   A(24,12) = 38912.0/9.0;
   A(24,14) = 26624.0/27.0;
   A(24,17) = -32768.0/27.0;
   A(24,18) = -10240.0/3.0;
   A(24,20) = -10240.0/9.0;
   A(24,23) = 16384.0/27.0;
   A(24,25) = 14336.0/27.0;
   A(24,29) = -2048.0/27.0;
   A(23,2) = 53248.0/27.0;
   A(23,3) = 40960.0/9.0;
   A(23,4) = 69632.0/27.0;
   A(23,5) = -8192.0/27.0;
   A(23,7) = 8192.0/27.0;
   A(23,10) = -48128.0/9.0;
   A(23,11) = -22528.0/3.0;
   A(23,12) = -1024.0;
   A(23,14) = -10240.0/9.0;
   A(23,17) = 14336.0/3.0;
   A(23,18) = 8192.0/3.0;
   A(23,20) = 14336.0/9.0;
   A(23,23) = -37888.0/27.0;
   A(23,25) = -26624.0/27.0;
   A(23,29) = 2048.0/9.0;
   A(22,0) = 8192.0/27.0;
   A(22,2) = -8192.0/27.0;
   A(22,3) = 69632.0/27.0;
   A(22,4) = 40960.0/9.0;
   A(22,5) = 53248.0/27.0;
   A(22,8) = -10240.0/9.0;
   A(22,10) = -1024.0;
   A(22,11) = -22528.0/3.0;
   A(22,12) = -48128.0/9.0;
   A(22,15) = 14336.0/9.0;
   A(22,17) = 8192.0/3.0;
   A(22,18) = 14336.0/3.0;
   A(22,21) = -26624.0/27.0;
   A(22,23) = -37888.0/27.0;
   A(22,26) = 2048.0/9.0;
   A(21,0) = -8192.0/27.0;
   A(21,2) = -40960.0/27.0;
   A(21,3) = -114688.0/27.0;
   A(21,4) = -65536.0/27.0;
   A(21,8) = 26624.0/27.0;
   A(21,10) = 38912.0/9.0;
   A(21,11) = 53248.0/9.0;
   A(21,12) = 16384.0/27.0;
   A(21,15) = -10240.0/9.0;
   A(21,17) = -10240.0/3.0;
   A(21,18) = -32768.0/27.0;
   A(21,21) = 14336.0/27.0;
   A(21,23) = 16384.0/27.0;
   A(21,26) = -2048.0/27.0;
   A(26,2) = -71680.0/27.0;
   A(26,3) = -145408.0/27.0;
   A(26,4) = -88064.0/27.0;
   A(26,5) = -2048.0/9.0;
   A(26,10) = 150016.0/27.0;
   A(26,11) = 183296.0/27.0;
   A(26,12) = 31232.0/27.0;
   A(26,17) = -94208.0/27.0;
   A(26,18) = -40960.0/27.0;
   A(26,23) = 15872.0/27.0;
   A(25,2) = -2048.0/9.0;
   A(25,3) = -88064.0/27.0;
   A(25,4) = -145408.0/27.0;
   A(25,5) = -71680.0/27.0;
   A(25,10) = 31232.0/27.0;
   A(25,11) = 183296.0/27.0;
   A(25,12) = 150016.0/27.0;
   A(25,17) = -40960.0/27.0;
   A(25,18) = -94208.0/27.0;
   A(25,23) = 15872.0/27.0;
   A(30,4) = -2048.0/9.0;
   A(30,5) = -4096.0/9.0;
   A(30,6) = -2048.0/9.0;
   A(30,11) = 512.0/3.0;
   A(30,12) = 7168.0/9.0;
   A(30,13) = 5632.0/9.0;
   A(30,17) = -256.0/9.0;
   A(30,18) = -3584.0/9.0;
   A(30,19) = -1792.0/3.0;
 
   //-------- 5
   A(30,23) = 512.0/9.0;
   A(30,24) = 2048.0/9.0;
   A(30,28) = -256.0/9.0;
   A(29,2) = -2048.0/9.0;
   A(29,3) = -8192.0/9.0;
   A(29,4) = -4096.0/3.0;
   A(29,5) = -8192.0/9.0;
   A(29,6) = -2048.0/9.0;
   A(29,10) = 6656.0/9.0;
   A(29,11) = 6656.0/3.0;
   A(29,12) = 6656.0/3.0;
   A(29,13) = 6656.0/9.0;
   A(29,17) = -7936.0/9.0;
   A(29,18) = -15872.0/9.0;
   A(29,19) = -7936.0/9.0;
   A(29,23) = 4096.0/9.0;
   A(29,24) = 4096.0/9.0;
   A(29,28) = -256.0/3.0;
   A(28,1) = -2048.0/9.0;
   A(28,2) = -8192.0/9.0;
   A(28,3) = -4096.0/3.0;
   A(28,4) = -8192.0/9.0;
   A(28,5) = -2048.0/9.0;
   A(28,9) = 6656.0/9.0;
   A(28,10) = 6656.0/3.0;
   A(28,11) = 6656.0/3.0;
   A(28,12) = 6656.0/9.0;
   A(28,16) = -7936.0/9.0;
   A(28,17) = -15872.0/9.0;
   A(28,18) = -7936.0/9.0;
   A(28,22) = 4096.0/9.0;
   A(28,23) = 4096.0/9.0;
   A(28,27) = -256.0/3.0;
   A(27,1) = -2048.0/9.0;
   A(27,2) = -4096.0/9.0;
   A(27,3) = -2048.0/9.0;
   A(27,9) = 5632.0/9.0;
   A(27,10) = 7168.0/9.0;
   A(27,11) = 512.0/3.0;
   A(27,16) = -1792.0/3.0;
   A(27,17) = -3584.0/9.0;
   A(27,18) = -256.0/9.0;
   A(27,22) = 2048.0/9.0;
   A(27,23) = 512.0/9.0;
   A(27,27) = -256.0/9.0;
   A(32,2) = 1024.0*sqrt(2.0)/9.0;
   A(32,3) = 1024.0*sqrt(2.0)/9.0;
   A(32,10) = -1792.0*sqrt(2.0)/9.0;
   A(32,11) = -256.0*sqrt(2.0)/3.0;
   A(32,17) = 896*sqrt(2.0)/9.0;
   A(32,18) = 128.0*sqrt(2.0)/9.0;
   A(32,23) = -128.0*sqrt(2.0)/9.0;
   A(31,4) = 1024.0*sqrt(2.0)/9.0;
   A(31,5) = 1024.0*sqrt(2.0)/9.0;
   A(31,11) = -256.0*sqrt(2.0)/3.0;
   A(31,12) = -1792.0*sqrt(2.0)/9.0;
   A(31,17) = 128.0*sqrt(2.0)/9.0;
   A(31,18) = 896.0*sqrt(2.0)/9.0;
   A(31,23) = -128.0*sqrt(2.0)/9.0;
   A(34,2) = 4096.0;
   A(34,3) = 8192.0;
   A(34,4) = 4096.0;
   A(34,10) = -9216.0;
   A(34,11) = -10240.0;
   A(34,12) = -1024.0;
   A(34,17) = 6144.0;
   A(34,18) = 2048.0;
   A(34,23) = -1024.0;
   A(33,3) = 4096.0;
   A(33,4) = 8192.0;
   A(33,5) = 4096.0;
   A(33,10) = -1024.0;
   A(33,11) = -10240.0;
   A(33,12) = -9216.0;
   A(33,17) = 2048.0;
   A(33,18) = 6144.0;
   A(33,23) = -1024.0;
   A(35,2) = -4096.0;
   A(35,3) = -12288.0;
   A(35,4) = -12288.0;
   A(35,5) = -4096.0;
   A(35,10) = 11264.0;
   A(35,11) = 22528.0;
   A(35,12) = 11264.0;
   A(35,17) = -10240.0;
   A(35,18) = -10240.0;
   A(35,23) = 3072.0;
  }
 
 ///=========================================================================
 /// Bases of the C1-curved shape functions: 
 /// it is a complete polynomial of degree 7
 ///=========================================================================
 void basis_curve(const Vector<double> &s, Shape &psi_curve) const
  {
   //Get the shape function and derivatives
   psi_curve[7] = s[0]*s[0]*s[0]*s[0]*s[0]*s[0]*s[0];
   psi_curve[6] = s[0]*s[0]*s[0]*s[0]*s[0]*s[0]*s[1];
   psi_curve[5] = s[0]*s[0]*s[0]*s[0]*s[0]*s[1]*s[1];
   psi_curve[4] = s[0]*s[0]*s[0]*s[0]*s[1]*s[1]*s[1];
   psi_curve[3] = s[0]*s[0]*s[0]*s[1]*s[1]*s[1]*s[1];
   psi_curve[2] = s[0]*s[0]*s[1]*s[1]*s[1]*s[1]*s[1];
   psi_curve[1] = s[0]*s[1]*s[1]*s[1]*s[1]*s[1]*s[1];
   psi_curve[0] = s[1]*s[1]*s[1]*s[1]*s[1]*s[1]*s[1];
   psi_curve[14] = s[0]*s[0]*s[0]*s[0]*s[0]*s[0];
   psi_curve[13] = s[0]*s[0]*s[0]*s[0]*s[0]*s[1];
   psi_curve[12] = s[0]*s[0]*s[0]*s[0]*s[1]*s[1];
   psi_curve[11] = s[0]*s[0]*s[0]*s[1]*s[1]*s[1];
   psi_curve[10] = s[0]*s[0]*s[1]*s[1]*s[1]*s[1];
   psi_curve[9] = s[0]*s[1]*s[1]*s[1]*s[1]*s[1];
   psi_curve[8] = s[1]*s[1]*s[1]*s[1]*s[1]*s[1];
   psi_curve[20] = s[0]*s[0]*s[0]*s[0]*s[0];
   psi_curve[19] = s[0]*s[0]*s[0]*s[0]*s[1];
   psi_curve[18] = s[0]*s[0]*s[0]*s[1]*s[1];
   psi_curve[17] = s[0]*s[0]*s[1]*s[1]*s[1];
   psi_curve[16] = s[0]*s[1]*s[1]*s[1]*s[1];
   psi_curve[15] = s[1]*s[1]*s[1]*s[1]*s[1];
   psi_curve[25] = s[0]*s[0]*s[0]*s[0];
   psi_curve[24] = s[0]*s[0]*s[0]*s[1];
   psi_curve[23] = s[0]*s[0]*s[1]*s[1];
   psi_curve[22] = s[0]*s[1]*s[1]*s[1];
   psi_curve[21] = s[1]*s[1]*s[1]*s[1];
   psi_curve[29] = s[0]*s[0]*s[0];
   psi_curve[28] = s[0]*s[0]*s[1];
   psi_curve[27] = s[0]*s[1]*s[1];
   psi_curve[26] = s[1]*s[1]*s[1];
   psi_curve[32] = s[0]*s[0];
   psi_curve[31] = s[0]*s[1];
   psi_curve[30] = s[1]*s[1];
   psi_curve[34] = s[0];
   psi_curve[33] = s[1];
   psi_curve[35] = 1.0;
  }
   
 ///=========================================================================
 /// Derivatives of bases of the C1-curved shape functions
 /// it is a complete polynomial of degree 7
 ///=========================================================================
 void dbasis_local_curve(const Vector<double> &s, Shape &psi_curve, DShape &dpsi_curve) const
  {
   basis_curve(s,psi_curve);

   //Get the shape function and derivatives
   dpsi_curve(7,0) = 7.0*s[0]*s[0]*s[0]*s[0]*s[0]*s[0];
   dpsi_curve(6,0) = 6.0*s[0]*s[0]*s[0]*s[0]*s[0]*s[1];
   dpsi_curve(5,0) = 5.0*s[0]*s[0]*s[0]*s[0]*s[1]*s[1];
   dpsi_curve(4,0) = 4.0*s[0]*s[0]*s[0]*s[1]*s[1]*s[1];
   dpsi_curve(3,0) = 3.0*s[0]*s[0]*s[1]*s[1]*s[1]*s[1];
   dpsi_curve(2,0) = 2.0*s[0]*s[1]*s[1]*s[1]*s[1]*s[1];
   dpsi_curve(1,0) = 1.0*s[1]*s[1]*s[1]*s[1]*s[1]*s[1];
   dpsi_curve(0,0) = 0.0;
   dpsi_curve(14,0) = 6.0*s[0]*s[0]*s[0]*s[0]*s[0];
   dpsi_curve(13,0) = 5.0*s[0]*s[0]*s[0]*s[0]*s[1];
   dpsi_curve(12,0) = 4.0*s[0]*s[0]*s[0]*s[1]*s[1];
   dpsi_curve(11,0) = 3.0*s[0]*s[0]*s[1]*s[1]*s[1];
   dpsi_curve(10,0) = 2.0*s[0]*s[1]*s[1]*s[1]*s[1];
   dpsi_curve(9,0) = 1.0*s[1]*s[1]*s[1]*s[1]*s[1];
   dpsi_curve(8,0) = 0.0;
   dpsi_curve(20,0) = 5.0*s[0]*s[0]*s[0]*s[0];
   dpsi_curve(19,0) = 4.0*s[0]*s[0]*s[0]*s[1];
   dpsi_curve(18,0) = 3.0*s[0]*s[0]*s[1]*s[1];
   dpsi_curve(17,0) = 2.0*s[0]*s[1]*s[1]*s[1];
   dpsi_curve(16,0) = 1.0*s[1]*s[1]*s[1]*s[1];
   dpsi_curve(15,0) = 0.0;
   dpsi_curve(25,0) = 4.0*s[0]*s[0]*s[0];
   dpsi_curve(24,0) = 3.0*s[0]*s[0]*s[1];
   dpsi_curve(23,0) = 2.0*s[0]*s[1]*s[1];
   dpsi_curve(22,0) = 1.0*s[1]*s[1]*s[1];
   dpsi_curve(21,0) = 0.0;
   dpsi_curve(29,0) = 3.0*s[0]*s[0];
   dpsi_curve(28,0) = 2.0*s[0]*s[1];
   dpsi_curve(27,0) = 1.0*s[1]*s[1];
   dpsi_curve(26,0) = 0.0;
   dpsi_curve(32,0) = 2.0*s[0];
   dpsi_curve(31,0) = 1.0*s[1];
   dpsi_curve(30,0) = 0.0;
   dpsi_curve(34,0) = 1.0;
   dpsi_curve(33,0) = 0.0;
   dpsi_curve(35,0) = 0.0;
   
   dpsi_curve(7,1) = 0.0;
   dpsi_curve(6,1) = s[0]*s[0]*s[0]*s[0]*s[0]*s[0]*1.0;
   dpsi_curve(5,1) = s[0]*s[0]*s[0]*s[0]*s[0]*s[1]*2.0;
   dpsi_curve(4,1) = s[0]*s[0]*s[0]*s[0]*s[1]*s[1]*3.0;
   dpsi_curve(3,1) = s[0]*s[0]*s[0]*s[1]*s[1]*s[1]*4.0;
   dpsi_curve(2,1) = s[0]*s[0]*s[1]*s[1]*s[1]*s[1]*5.0;
   dpsi_curve(1,1) = s[0]*s[1]*s[1]*s[1]*s[1]*s[1]*6.0;
   dpsi_curve(0,1) = s[1]*s[1]*s[1]*s[1]*s[1]*s[1]*7.0;
   dpsi_curve(14,1) = 0.0;
   dpsi_curve(13,1) = s[0]*s[0]*s[0]*s[0]*s[0]*1.0;
   dpsi_curve(12,1) = s[0]*s[0]*s[0]*s[0]*s[1]*2.0;
   dpsi_curve(11,1) = s[0]*s[0]*s[0]*s[1]*s[1]*3.0;
   dpsi_curve(10,1) = s[0]*s[0]*s[1]*s[1]*s[1]*4.0;
   dpsi_curve(9,1) = s[0]*s[1]*s[1]*s[1]*s[1]*5.0;
   dpsi_curve(8,1) = s[1]*s[1]*s[1]*s[1]*s[1]*6.0;
   dpsi_curve(20,1) = 0.0;
   dpsi_curve(19,1) = s[0]*s[0]*s[0]*s[0]*1.0;
   dpsi_curve(18,1) = s[0]*s[0]*s[0]*s[1]*2.0;
   dpsi_curve(17,1) = s[0]*s[0]*s[1]*s[1]*3.0;
   dpsi_curve(16,1) = s[0]*s[1]*s[1]*s[1]*4.0;
   dpsi_curve(15,1) = s[1]*s[1]*s[1]*s[1]*5.0;
   dpsi_curve(25,1) = 0.0;
   dpsi_curve(24,1) = s[0]*s[0]*s[0]*1.0;
   dpsi_curve(23,1) = s[0]*s[0]*s[1]*2.0;
   dpsi_curve(22,1) = s[0]*s[1]*s[1]*3.0;
   dpsi_curve(21,1) = s[1]*s[1]*s[1]*4.0;
   dpsi_curve(29,1) = 0.0;
   dpsi_curve(28,1) = s[0]*s[0]*1.0;
   dpsi_curve(27,1) = s[0]*s[1]*2.0;
   dpsi_curve(26,1) = s[1]*s[1]*3.0;
   dpsi_curve(32,1) = 0.0;
   dpsi_curve(31,1) = s[0]*1.0;
   dpsi_curve(30,1) = s[1]*2.0;
   dpsi_curve(34,1) = 0.0;
   dpsi_curve(33,1) = 1.0;
   dpsi_curve(35,1) = 0.0;
  }
  
 ///=========================================================================
 /// The second derivatived of bases of the C1-curved shape functions
 /// it is a complete polynomial of degree 7
 ///=========================================================================
 void d2basis_local_curve(const Vector<double> &s, Shape &psi_curve, DShape &dpsi_curve, DShape &d2psi_curve) const
  {
   dbasis_local_curve(s,psi_curve,dpsi_curve);
   //Get the shape function and derivatives
   d2psi_curve(7,0) = 7.0*6.0*s[0]*s[0]*s[0]*s[0]*s[0];
   d2psi_curve(6,0) = 6.0*5.0*s[0]*s[0]*s[0]*s[0]*s[1];
   d2psi_curve(5,0) = 5.0*4.0*s[0]*s[0]*s[0]*s[1]*s[1];
   d2psi_curve(4,0) = 4.0*3.0*s[0]*s[0]*s[1]*s[1]*s[1];
   d2psi_curve(3,0) = 3.0*2.0*s[0]*s[1]*s[1]*s[1]*s[1];
   d2psi_curve(2,0) = 2.0*1.0*s[1]*s[1]*s[1]*s[1]*s[1];
   d2psi_curve(1,0) = 0.0;
   d2psi_curve(0,0) = 0.0;
   d2psi_curve(14,0) = 6.0*5.0*s[0]*s[0]*s[0]*s[0];
   d2psi_curve(13,0) = 5.0*4.0*s[0]*s[0]*s[0]*s[1];
   d2psi_curve(12,0) = 4.0*3.0*s[0]*s[0]*s[1]*s[1];
   d2psi_curve(11,0) = 3.0*2.0*s[0]*s[1]*s[1]*s[1];
   d2psi_curve(10,0) = 2.0*1.0*s[1]*s[1]*s[1]*s[1];
   d2psi_curve(9,0) = 0.0;
   d2psi_curve(8,0) = 0.0;
   d2psi_curve(20,0) = 5.0*4.0*s[0]*s[0]*s[0];
   d2psi_curve(19,0) = 4.0*3.0*s[0]*s[0]*s[1];
   d2psi_curve(18,0) = 3.0*2.0*s[0]*s[1]*s[1];
   d2psi_curve(17,0) = 2.0*1.0*s[1]*s[1]*s[1];
   d2psi_curve(16,0) = 0.0;
   d2psi_curve(15,0) = 0.0;
   d2psi_curve(25,0) = 4.0*3.0*s[0]*s[0];
   d2psi_curve(24,0) = 3.0*2.0*s[0]*s[1];
   d2psi_curve(23,0) = 2.0*1.0*s[1]*s[1];
   d2psi_curve(22,0) = 0.0;
   d2psi_curve(21,0) = 0.0;
   d2psi_curve(29,0) = 3.0*2.0*s[0];
   d2psi_curve(28,0) = 2.0*1.0*s[1];
   d2psi_curve(27,0) = 0.0;
   d2psi_curve(26,0) = 0.0;
   d2psi_curve(32,0) = 2.0*1.0;
   d2psi_curve(31,0) = 0.0;
   d2psi_curve(30,0) = 0.0;
   d2psi_curve(34,0) = 0.0;
   d2psi_curve(33,0) = 0.0;
   d2psi_curve(35,0) = 0.0;

   d2psi_curve(7,1) = 0.0;
   d2psi_curve(6,1) = 0.0;
   d2psi_curve(5,1) = s[0]*s[0]*s[0]*s[0]*s[0]*1.0*2.0;
   d2psi_curve(4,1) = s[0]*s[0]*s[0]*s[0]*s[1]*2.0*3.0;
   d2psi_curve(3,1) = s[0]*s[0]*s[0]*s[1]*s[1]*3.0*4.0;
   d2psi_curve(2,1) = s[0]*s[0]*s[1]*s[1]*s[1]*4.0*5.0;
   d2psi_curve(1,1) = s[0]*s[1]*s[1]*s[1]*s[1]*5.0*6.0;
   d2psi_curve(0,1) = s[1]*s[1]*s[1]*s[1]*s[1]*6.0*7.0;
   d2psi_curve(14,1) = 0.0;
   d2psi_curve(13,1) = 0.0;
   d2psi_curve(12,1) = s[0]*s[0]*s[0]*s[0]*1.0*2.0;
   d2psi_curve(11,1) = s[0]*s[0]*s[0]*s[1]*2.0*3.0;
   d2psi_curve(10,1) = s[0]*s[0]*s[1]*s[1]*3.0*4.0;
   d2psi_curve(9,1) = s[0]*s[1]*s[1]*s[1]*4.0*5.0;
   d2psi_curve(8,1) = s[1]*s[1]*s[1]*s[1]*5.0*6.0;
   d2psi_curve(20,1) = 0.0;
   d2psi_curve(19,1) = 0.0;
   d2psi_curve(18,1) = s[0]*s[0]*s[0]*1.0*2.0;
   d2psi_curve(17,1) = s[0]*s[0]*s[1]*2.0*3.0;
   d2psi_curve(16,1) = s[0]*s[1]*s[1]*3.0*4.0;
   d2psi_curve(15,1) = s[1]*s[1]*s[1]*4.0*5.0;
   d2psi_curve(25,1) = 0.0;
   d2psi_curve(24,1) = 0.0;
   d2psi_curve(23,1) = s[0]*s[0]*1.0*2.0;
   d2psi_curve(22,1) = s[0]*s[1]*2.0*3.0;
   d2psi_curve(21,1) = s[1]*s[1]*3.0*4.0;
   d2psi_curve(29,1) = 0.0;
   d2psi_curve(28,1) = 0.0;
   d2psi_curve(27,1) = s[0]*1.0*2.0;
   d2psi_curve(26,1) = s[1]*2.0*3.0;
   d2psi_curve(32,1) = 0.0;
   d2psi_curve(31,1) = 0.0;
   d2psi_curve(30,1) = 1.0*2.0;
   d2psi_curve(34,1) = 0.0;
   d2psi_curve(33,1) = 0.0;
   d2psi_curve(35,1) = 0.0;

   d2psi_curve(7,2) = 0.0;
   d2psi_curve(6,2) = 6.0*s[0]*s[0]*s[0]*s[0]*s[0]*1.0;
   d2psi_curve(5,2) = 5.0*s[0]*s[0]*s[0]*s[0]*s[1]*2.0;
   d2psi_curve(4,2) = 4.0*s[0]*s[0]*s[0]*s[1]*s[1]*3.0;
   d2psi_curve(3,2) = 3.0*s[0]*s[0]*s[1]*s[1]*s[1]*4.0;
   d2psi_curve(2,2) = 2.0*s[0]*s[1]*s[1]*s[1]*s[1]*5.0;
   d2psi_curve(1,2) = s[1]*s[1]*s[1]*s[1]*s[1]*6.0;
   d2psi_curve(0,2) = 0.0;
   d2psi_curve(14,2) = 0.0;
   d2psi_curve(13,2) = 5.0*s[0]*s[0]*s[0]*s[0]*1.0;
   d2psi_curve(12,2) = 4.0*s[0]*s[0]*s[0]*s[1]*2.0;
   d2psi_curve(11,2) = 3.0*s[0]*s[0]*s[1]*s[1]*3.0;
   d2psi_curve(10,2) = 2.0*s[0]*s[1]*s[1]*s[1]*4.0;
   d2psi_curve(9,2) = s[1]*s[1]*s[1]*s[1]*5.0;
   d2psi_curve(8,2) = 0.0;
   d2psi_curve(20,2) = 0.0;
   d2psi_curve(19,2) = 4.0*s[0]*s[0]*s[0]*1.0;
   d2psi_curve(18,2) = 3.0*s[0]*s[0]*s[1]*2.0;
   d2psi_curve(17,2) = 2.0*s[0]*s[1]*s[1]*3.0;
   d2psi_curve(16,2) = s[1]*s[1]*s[1]*4.0;
   d2psi_curve(15,2) = 0.0;
   d2psi_curve(25,2) = 0.0;
   d2psi_curve(24,2) = 3.0*s[0]*s[0]*1.0;
   d2psi_curve(23,2) = 2.0*s[0]*s[1]*2.0;
   d2psi_curve(22,2) = s[1]*s[1]*3.0;
   d2psi_curve(21,2) = 0.0;
   d2psi_curve(29,2) = 0.0;
   d2psi_curve(28,2) = 2.0*s[0]*1.0;
   d2psi_curve(27,2) = s[1]*2.0;
   d2psi_curve(26,2) = 0.0;
   d2psi_curve(32,2) = 0.0;
   d2psi_curve(31,2) = 1.0;
   d2psi_curve(30,2) = 0.0;
   d2psi_curve(34,2) = 0.0;
   d2psi_curve(33,2) = 0.0;
   d2psi_curve(35,2) = 0.0;
  }
 };

//========================================================================
/// Empty base class for the subparametric Bellelements (created so that 
/// we can use dynamic_cast<>() to figure out if a an element
/// is a C1Curvedelement). This element is sub-parametric which means
/// the geometry will be parametrised by the linear Lagrange functions,
/// while unknowns will be parametrised by two kinds of shape functions
/// basis : denotes C1-interpolations for c1-variables
/// basis_c0 : denotes C0-interpolations for c0-variables
//========================================================================

template<unsigned NNODE_1D>
class BellElementBase: public virtual FiniteElement
{
public:
  ///\short  Constructor: Call constructors for FiniteElement 
  BellElementBase() : FiniteElement(){}
 
 
 virtual void basis(const Vector<double> &s, Shape &psi) const
  {}
 
 
 virtual void dbasis_local(const Vector<double> &s, Shape &psi,
                            DShape &dpsids) const
  {}
 
 virtual void d2basis_local(const Vector<double> &s, 
                             Shape &psi, 
                             DShape &dpsids,
                             DShape &d2psids) const
  {}

 virtual void basis_c0(const Vector<double> &s, Shape &psi) const
  {}
 
 
 virtual void dbasis_c0_local(const Vector<double> &s, Shape &psi,
                            DShape &dpsids) const
  {}
 
 virtual void d2basis_c0_local(const Vector<double> &s, 
                             Shape &psi, 
                             DShape &dpsids,
                             DShape &d2psids) const
  {}

 virtual void test(const Vector<double> &s, Shape &phi) const
  {}
 
 
 virtual void dtest_local(const Vector<double> &s, Shape &phi,
                            DShape &dphids) const
  {}
 
 virtual void d2test_local(const Vector<double> &s, 
                             Shape &phi, 
                             DShape &dphids,
                             DShape &d2phids) const
  {}


 //=========================================================================
 /// \short Return the C1-basis function stored at the ipt-th integration
 /// point.
 //=========================================================================
  void basis_at_knot(const unsigned &ipt, Shape &psi) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function
   basis(s,psi);
  }
  
  //=========================================================================
 /// \short Return the C1-basis function and its derivatives w.r.t. the global
 /// coordinates at the ipt-th integration point.
 //=========================================================================
  void dbasis_local_at_knot(const unsigned &ipt, Shape &psi,
                                           DShape &dpsids) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}

   //Get the shape function and derivatives
   dbasis_local(s,psi,dpsids);
  }
 
 //=========================================================================
 /// Calculate the C1-basis function and its first and second derivatives 
 /// w.r.t. global coordinates at the ipt-th integration point.
 /// \n\n Numbering:
 //=========================================================================
  void d2basis_local_at_knot(const unsigned &ipt, Shape &psi, 
                                            DShape &dpsids, DShape &d2psids) 
   const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}

   //Get the shape function and first and second derivatives
   d2basis_local(s,psi,dpsids,d2psids);   
  }

   //=========================================================================
 /// \short Return the C0-basis function stored at the ipt-th integration
 /// point.
 //=========================================================================
  void basis_c0_at_knot(const unsigned &ipt, Shape &psi) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function
   basis_c0(s,psi);
  }
  
  //=========================================================================
 /// \short Return the C0-basis function and its derivatives w.r.t. the local
 /// coordinates at the ipt-th integration point.
 //=========================================================================
  void dbasis_c0_local_at_knot(const unsigned &ipt, Shape &psi,
                                           DShape &dpsids) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function and derivatives
   
   dbasis_c0_local(s,psi,dpsids);
   
  }
 
 //=========================================================================
 /// Calculate the C0-basis function and its first and second derivatives 
 /// w.r.t. local coordinates at the ipt-th integration point.
 /// \n\n Numbering:
 //=========================================================================
  void d2basis_c0_local_at_knot(const unsigned &ipt, Shape &psi, 
                                            DShape &dpsids, DShape &d2psids) 
   const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function and first and second derivatives
   d2basis_c0_local(s,psi,dpsids,d2psids);
   
  }

 //=========================================================================
 /// \short Return the test function stored at the ipt-th integration
 /// point.
 //=========================================================================
  void test_at_knot(const unsigned &ipt, Shape &phi) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function
   test(s,phi);
  }
  
  //=========================================================================
 /// \short Return the test function and its derivatives w.r.t. the local
 /// coordinates at the ipt-th integration point.
 //=========================================================================
  void dtest_local_at_knot(const unsigned &ipt, Shape &phi,
                                           DShape &dphids) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function and derivatives
   dtest_local(s,phi,dphids);
  }
 
 //=========================================================================
 /// Calculate the test function and its first and second derivatives 
 /// w.r.t. local coordinates at the ipt-th integration point.
 /// \n\n Numbering:
 //=========================================================================
  void d2test_local_at_knot(const unsigned &ipt, Shape &phi, 
                                            DShape &dphids, DShape &d2phids) 
   const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function and first and second derivatives
   d2test_local(s,phi,dphids,d2phids);
  }
  
  //=========================================================================
  /// \short Compute the curved-element shape functions and also
  /// first derivatives w.r.t. local coordinates at local coordinate s;
  /// Returns Jacobian of mapping from global to local coordinates.
  /// Most general form of the function, but may be over-loaded, if desired
  //=========================================================================
  double dbasis_c0_eulerian(const Vector<double> &s, 
                                        Shape &psi,
                                        DShape &dpsi) const
  {
   //Find the element dimension
   const unsigned el_dim = dim();
   //Get the values of the shape functions and their local derivatives
   //Temporarily stored in dpsi
   dbasis_c0_local(s,psi,dpsi);
   
    // assign shape functions for geometry
   unsigned n_node = 3;
   Shape psi_x(n_node);
   DShape dpsi_x(n_node,2);
   DShape d2psi_x(n_node,3);
   
   d2shape_local(s,psi_x,dpsi_x,d2psi_x);
   
   //Allocate memory for the jacobian and inverse jacobian 
   DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);

   //Calculate the jacobian and inverse jacobian
   const double det = this->local_to_eulerian_mapping2(dpsi_x,jacobian,inverse_jacobian);

   //Now set the values of the derivatives to be dpsidx
   transform_derivatives(inverse_jacobian,dpsi);

   //Return the determinant of the jacobian
   return det;
  }

  //===========================================================================
  /// \short Compute the c0-basis functions and also first
  /// and second derivatives w.r.t. local coordinates at ipt-th integration
  /// point
  //===========================================================================
  double d2basis_c0_eulerian(const Vector<double> &s, Shape &psi, 
                                      DShape &dpsi, 
                                      DShape &d2psi) const
  {
   //Find the element dimension
   const unsigned el_dim = dim();
   //Find the number of second derivatives required
   const unsigned n_deriv = N2deriv[el_dim];
   //Get the values of the shape function and local derivatives for unknowns
   d2basis_c0_local(s,psi,dpsi,d2psi);
     
   // assign shape functions for geometry
   unsigned n_node = 3;
   Shape psi_x(n_node);
   DShape dpsi_x(n_node,2);
   DShape d2psi_x(n_node,3);
   
   d2shape_local(s,psi_x,dpsi_x,d2psi_x);
   
   //Allocate memory for the jacobian and inverse jacobian 
   DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);

   //Calculate the jacobian and inverse jacobian
   const double det = local_to_eulerian_mapping2(dpsi_x,jacobian,inverse_jacobian);

   //Allocate memory for the jacobian of second derivatives
   DenseMatrix<double> jacobian2(n_deriv,el_dim,0.0);

   //Assemble the jacobian of second derivatives
   myassemble_local_to_eulerian_jacobian2(d2psi_x,jacobian2);  

   //Now set the value of the derivatives
   transform_second_derivatives(jacobian,inverse_jacobian,jacobian2,dpsi,d2psi);

   //Return the determinant of the jacobian
   return det;
  }

  //=========================================================================
  /// \short Compute the c1-basis functions and also
  /// first derivatives w.r.t. global coordinates at local coordinate s;
  /// Returns Jacobian of mapping from global to local coordinates.
  /// Most general form of the function, but may be over-loaded, if desired
  //=========================================================================
  double dbasis_eulerian(const Vector<double> &s, 
                                        Shape &psi,
                                        DShape &dpsi) const
  {
   //Find the element dimension
   const unsigned el_dim = dim();
   //Get the values of the shape functions and their local derivatives
   //Temporarily stored in dpsi
   dbasis_local(s,psi,dpsi);
   
    // assign shape functions for geometry
   unsigned n_node = 3;
   Shape psi_x(n_node);
   DShape dpsi_x(n_node,2);
   DShape d2psi_x(n_node,3);
   
   d2shape_local(s,psi_x,dpsi_x,d2psi_x);
   
   //Allocate memory for the jacobian and inverse jacobian 
   DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);

   //Calculate the jacobian and inverse jacobian
   const double det = this->local_to_eulerian_mapping2(dpsi_x,jacobian,inverse_jacobian);
   
   //Return the determinant of the jacobian
   return det;
  }

  //===========================================================================
  /// \short Compute the c1-basis functions and also first
  /// and second derivatives w.r.t. global coordinates at ipt-th integration
  /// point
  //===========================================================================
  double d2basis_eulerian(const Vector<double> &s, Shape &psi, 
                                      DShape &dpsi, 
                                      DShape &d2psi) const
  {
   //Find the element dimension
   const unsigned el_dim = dim();
   //Find the number of second derivatives required
   //const unsigned n_deriv = N2deriv[el_dim];
   //Get the values of the shape function and local derivatives for unknowns
   d2basis_local(s,psi,dpsi,d2psi);
     
   // assign shape functions for geometry
   unsigned n_node = 3;
   Shape psi_x(n_node);
   DShape dpsi_x(n_node,2);
   DShape d2psi_x(n_node,3);
   
   d2shape_local(s,psi_x,dpsi_x,d2psi_x);
   
   //Allocate memory for the jacobian and inverse jacobian 
   DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);
   
   //Calculate the jacobian and inverse jacobian
   const double det = local_to_eulerian_mapping2(dpsi_x,jacobian,inverse_jacobian);
   
   //Return the determinant of the jacobian
   return det;
  }
  
  //=========================================================================
  /// Calculate the c0-shape function and its first-order derivatives 
  /// w.r.t. local coordinates at the ipt-th integration point.
  /// \n\n Numbering:
  //=========================================================================
 
  double dshape_and_dtest_eulerian_at_knot(const unsigned &ipt, Shape &psi, DShape &dpsi, Shape &test, DShape &dtest)
   const 
  {
    //Find the element dimension
   const unsigned el_dim = dim();

   //Get the values of the c0-shape function for c0-unknowns
   //and local derivatives 
   //Temporarily store it in dpsi
   dbasis_c0_local_at_knot(ipt,psi,dpsi);
   
   // assign shape functions for geometry -> linear Lagrange
   unsigned n_node = 3;
   Shape psi_x(n_node);
   DShape dpsi_x(n_node,2);
   dshape_local_at_knot(ipt,psi_x,dpsi_x);
   
   // assign test function
   dtest_local_at_knot(ipt,test,dtest);
   
   //Allocate memory for the inverse jacobian
   DenseMatrix<double> inverse_jacobian(el_dim);
   //Now calculate the inverse jacobian
   const double det = local_to_eulerian_mapping2(dpsi_x,inverse_jacobian);
   
   //Now set the values of the derivatives to dpsidx
   transform_derivatives(inverse_jacobian,dpsi);
   
   //Return the determinant of the jacobian
   return det;
  }

  //===========================================================================
  /// \short Compute the c1-shape functions and also first and second 
  /// derivatives w.r.t. global coordinates at ipt-th integration points
  /// Returns Jacobian of mapping from global to local coordinates.
  //===========================================================================
  double d2shape_and_d2test_eulerian_at_knot(const unsigned &ipt, 
                                                 Shape &psi, 
                                                 DShape &dpsi, 
                                                 DShape &d2psi,
                                                 Shape &test, 
                                                 DShape &dtest, 
                                                 DShape &d2test) const
  {
   //Find the element dimension
   const unsigned el_dim = dim();
   
   //Get the values of the shape function and local derivatives for unknowns
   d2basis_local_at_knot(ipt,psi,dpsi,d2psi);
   
   // assign shape functions for geometry
   unsigned n_node = nnode();
   Shape psi_x(n_node);
   DShape dpsi_x(n_node,2);
   DShape d2psi_x(n_node,3);
   dshape_local_at_knot(ipt,psi_x,dpsi_x);

   // assign for test function
   d2test_local_at_knot(ipt,test,dtest,d2test);
   
   //Allocate memory for the jacobian and inverse jacobian 
   DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);

   //Calculate the jacobian and inverse jacobian
   const double det = local_to_eulerian_mapping2(dpsi_x,jacobian,inverse_jacobian);

   //Return the determinant of the mapping
   return det;
  }

  //===========================================================================
  /// \short Calculate the mapping from local to Eulerian coordinates,
  /// given the derivatives of the shape functions w.r.t. local coordinates,
  /// Return only the determinant of the jacobian and the inverse of the
  /// mapping (ds/dx).
  //===========================================================================
  double local_to_eulerian_mapping2(const DShape &dpsids,
                                   DenseMatrix<double> &inverse_jacobian) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Assign memory for the jacobian
   DenseMatrix<double> jacobian(el_dim);
   //Calculate the jacobian and inverse
   return local_to_eulerian_mapping2(dpsids,jacobian,inverse_jacobian);
  }

 ///////////////////////////////////////////////////////////////
 virtual double local_to_eulerian_mapping2(const DShape &dpsids,
                                           DenseMatrix<double> &jacobian,
                                           DenseMatrix<double> &inverse_jacobian) const
  {
    //Assemble the jacobian
    //Locally cache the elemental dimension
   const unsigned el_dim = dim();
   //The number of shape functions must be equal to the number
   //of nodes (by definition)
   const unsigned n_shape = 3;
   //The number of shape function types must be equal to the number
   //of nodal position types (by definition)
   const unsigned n_shape_type = 1;
  
   //Loop over the rows of the jacobian
   for(unsigned i=0;i<el_dim;i++)
    {
     //Loop over the columns of the jacobian
     for(unsigned j=0;j<el_dim;j++)
      {
       //Zero the entry
       jacobian(i,j) = 0.0;
       //Loop over the shape functions
       for(unsigned l=0;l<n_shape;l++)
        {
         for(unsigned k=0;k<n_shape_type;k++)
          {
           //Jacobian is dx_j/ds_i, which is represented by the sum
           //over the dpsi/ds_i of the nodal points X j
           //Call the Non-hanging version of positions
           //This is overloaded in refineable elements
           jacobian(i,j) += raw_nodal_position_gen(l,k,j)*dpsids(l,k,i);
          }
        }
      }
    }
  
   //Invert the jacobian (use the template-free interface)
   return invert_jacobian_mapping(jacobian,inverse_jacobian);
  }

 //========================================================================
 /// \short Calculate the Jacobian of the mapping between local and global
 /// coordinates at the position s
 //========================================================================
 double J_eulerian1(const Vector<double> &s) const
  {
   //Find the number of nodes and position types
   const unsigned n_node = 3;
   const unsigned n_position_type = 1;
   //Find the dimension of the node and element
   const unsigned n_dim_node = nodal_dimension();
   const unsigned n_dim_element = dim();
   
   
   //Set up dummy memory for the shape functions
   Shape psi(n_node,n_position_type);
   DShape dpsids(n_node,n_position_type,n_dim_element);
   //Get the shape functions and local derivatives
   this->dshape_local(s,psi,dpsids);
   
   //Right calculate the base vectors
   DenseMatrix<double> interpolated_G(n_dim_element,n_dim_node);
   
   //Loop over the dimensions and compute the entries of the 
   //base vector matrix
   for(unsigned i=0;i<n_dim_element;i++)
    {
     for(unsigned j=0;j<n_dim_node;j++)
      {
       //Initialise the j-th component of the i-th base vector to zero
       interpolated_G(i,j) = 0.0;
       for(unsigned l=0;l<n_node;l++)
        {
         for(unsigned k=0;k<n_position_type;k++)
          {
           interpolated_G(i,j) += raw_nodal_position_gen(l,k,j)*dpsids(l,k,i);
          }
        }
      }
    }

   //Calculate the metric tensor of the element
   DenseMatrix<double> G(n_dim_element);
   for(unsigned i=0;i<n_dim_element;i++)
    {
     for(unsigned j=0;j<n_dim_element;j++)
      {
       //Initialise to zero
       G(i,j) = 0.0;
       for(unsigned k=0;k<n_dim_node;k++) 
        {
         G(i,j) += interpolated_G(i,k)*interpolated_G(j,k);
        }
      }
    }
   
   //Calculate the determinant of the metric tensor
   double det = 0.0;
   switch(n_dim_element)
    {
    case 0:
     throw OomphLibError("Cannot calculate J_eulerian() for point element\n",
                         "FiniteElement::J_eulerian()",
                         OOMPH_EXCEPTION_LOCATION);
     break;
    case 1:
     det = G(0,0);
     break;
    case 2:
     det = G(0,0)*G(1,1) - G(0,1)*G(1,0);
     break;
    case 3:
     det = G(0,0)*G(1,1)*G(2,2) + G(0,1)*G(1,2)*G(2,0) + G(0,2)*G(1,0)*G(2,1)
      - G(0,0)*G(1,2)*G(2,1) - G(0,1)*G(1,0)*G(2,2) - G(0,2)*G(1,1)*G(2,0);
     break;
    default:
     oomph_info << "More than 3 dimensions in J_eulerian()" << std::endl;
     break;
    }
   
#ifdef PARANOID
   check_jacobian(det);
#endif
   
   //Return the Jacobian (square-root of the determinant of the metric tensor)
   return sqrt(det);
   
  }

 //=========================================================================
 /// Internal function that is used to assemble the jacobian of second
 /// derivatives of the the mapping from local coordinates (s) to the 
 /// eulerian coordinates (x), given the second derivatives of the 
 /// shape functions. 
 //=========================================================================
  void myassemble_local_to_eulerian_jacobian2(const DShape &d2psids,
                                       DenseMatrix<double> &jacobian2) const
  {
   //Find the the dimension of the element
   const unsigned el_dim = dim();
   //Find the number of shape functions and shape functions types
   //Must be equal to the number of nodes and their position types
   //by the definition of the shape function.
   const unsigned n_shape = 3;
   unsigned n_shape_type = 1;
   //Find the number of second derivatives
   const unsigned n_row = N2deriv[el_dim];
   //Assemble the "jacobian" (d^2 x_j/ds_i^2) for second derivatives of 
   //shape functions
   //Loop over the rows (number of second derivatives)
   for(unsigned i=0;i<n_row;i++)
    {
     //Loop over the columns (element dimension
     for(unsigned j=0;j<el_dim;j++)
      {
       //Zero the entry
       jacobian2(i,j) = 0.0;
       //Loop over the shape functions
       for(unsigned l=0;l<n_shape;l++)
        {
         //Loop over the shape function types
         for(unsigned k=0;k<n_shape_type;k++)
          {
           //Add the terms to the jacobian entry
           //Call the Non-hanging version of positions
           //This is overloaded in refineable elements
           jacobian2(i,j) += raw_nodal_position_gen(l,k,j)*d2psids(l,k,i);
          }
        }
      }
    }
  }

 //=======================================================================
 /// Return FE interpolated position x[] at local coordinate s as Vector
 // (using linear Lagrange interpolation)
 //=======================================================================
  void my_interpolated_x(const Vector<double> &s, Vector<double> &x)
   const
  {
   //Find the number of nodes
   const unsigned n_node = 3;
   //Find the number of positional types
   const unsigned n_position_type = 1;
   
   //Find the dimension stored in the node
   const unsigned nodal_dim = nodal_dimension();
   
   //Assign storage for the local shape function
   Shape psi(n_node);
   //Find the values of shape function
   shape(s,psi);
   
   //Loop over the dimensions
   for(unsigned i=0;i<nodal_dim;i++)
    {
     //Initilialise value of x[i] to zero
     x[i] = 0.0;
     //Loop over the local nodes
     for(unsigned l=0;l<n_node;l++) 
      {
       for(unsigned k=0;k<n_position_type;k++)
        {
         x[i] += nodal_position_gen(l,k,i)*psi[l];
        }
      }
    }
  }
};

/////////////////////////////////////////////////////////////////////////////
/// General BellElement class  ///
/// Empty, just establishes the template parameters
/////////////////////////////////////////////////////////////////////
template<unsigned DIM, unsigned NNODE_1D>
 class BellElement : public virtual BellElementBase<NNODE_1D>, public virtual TElement<DIM,NNODE_1D>, public virtual BellElementShape<DIM>, public virtual LinearTElement<DIM>
{ 
 public :

 ///\short  Constructor: Call constructors for BellElement 
  BellElement() : BellElementBase<NNODE_1D>(), TElement<DIM,NNODE_1D>(), BellElementShape<DIM>(), LinearTElement<DIM>()
  {
   //Set the number of types required to interpolate the coordinate
   this->set_nnodal_position_type(6);
   TGauss<2,4>* new_integral_pt = new TGauss<2,4>;
   this->set_integration_scheme(new_integral_pt);
  }

 /// Broken copy constructor
 BellElement(const BellElement&) 
  { 
   BrokenCopy::broken_copy("BellElement");
  } 
 
 /// Broken assignment operator
 void operator=(const BellElement&) 
  {
   BrokenCopy::broken_assign("BellElement");
  }

 /// Calculate the geometric shape functions at local coordinate s
 inline void shape(const Vector<double> &s, Shape &psi) const
  {
   LinearTElement<2>::Lshape(s,psi);
  }
 
 /// \short Compute the geometric shape functions and 
 /// derivatives w.r.t. local coordinates at local coordinate s
 inline void dshape_local(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids) const
  {
   LinearTElement<2>::dLshape_local(s,psi,dpsids);
  }
 
 /// \short Computer the geometric shape functions, derivatives and
 /// second derivatives w.r.t local coordinates at local coordinate s \n
 /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
 /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
 /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
 inline void d2shape_local(const Vector<double> &s, Shape &psi, 
                           DShape &dpsids, DShape &d2psids) const
  {
   LinearTElement<2>::d2Lshape_local(s,psi,dpsids,d2psids);
  }

 /// Calculate the c1-basis functions at local coordinate s
 inline void basis(const Vector<double> &s, Shape &psi) const
  {
   /// Number of nodes along each element edge
   unsigned n_node = 3;
   
   DenseMatrix<double> node_position(n_node,DIM);
   for(unsigned l=0;l<n_node;l++)
    {
     for(unsigned k=0;k<1;k++)
      {
       for(unsigned j=0;j<DIM;j++)
        {
         node_position(l,j) = this->raw_nodal_position_gen(l,k,j);
        }
      }
    }
   BellElementShape<2>::Bshape(s,psi,node_position);
  }
 
 /// \short Compute the c1-basis functions and 
 /// derivatives w.r.t. global coordinates at local coordinate s
 inline void dbasis_local(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids) const
  {
   /// Number of nodes along each element edge
   unsigned n_node = 3;
   
   DenseMatrix<double> node_position(3,DIM);
   
   for(unsigned l=0;l<n_node;l++)
    {
     for(unsigned k=0;k<1;k++)
      {
       for(unsigned j=0;j<DIM;j++)
        {
         node_position(l,j) = this->raw_nodal_position_gen(l,k,j);
        }
      }
    }
   BellElementShape<2>::dBshape_local(s,psi,dpsids,node_position);
  }
  
  /// \short Compute the c1-basis functions and 
 /// derivatives w.r.t. global coordinates at local coordinate s
 inline void d2basis_local(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids, DShape &d2psids) const
  {
   /// Number of nodes along each element edge
   unsigned n_node = 3;
   DenseMatrix<double> node_position(3,DIM);
   
   for(unsigned l=0;l<n_node;l++)
    {
     for(unsigned k=0;k<1;k++)
      {
       for(unsigned j=0;j<DIM;j++)
        {
         node_position(l,j) = this->raw_nodal_position_gen(l,k,j);
        }
      }
    }
   BellElementShape<2>::d2Bshape_local(s,psi,dpsids,d2psids,node_position);
  }

 /// Calculate the c0-basis functions at local coordinate s
 inline void basis_c0(const Vector<double> &s, Shape &psi) const
  {
   TElementShape<2,NNODE_1D>::shape(s,psi);
  }
 
 /// \short Compute the c0-basis functions and 
 /// derivatives w.r.t. local coordinates at local coordinate s
 inline void dbasis_c0_local(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids) const
  {
   TElementShape<2,NNODE_1D>::dshape_local(s,psi,dpsids);
  }
 
 /// \short Computer the c0-basis functions, derivatives and
 /// second derivatives w.r.t local coordinates at local coordinate s \n
 /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
 /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
 /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
 inline void d2basis_c0_local(const Vector<double> &s, Shape &psi, 
                           DShape &dpsids, DShape &d2psids) const
  {
   TElementShape<2,NNODE_1D>::d2shape_local(s,psi,dpsids,d2psids);
  }
 
 /// Calculate the test functions at local coordinate s
 inline void test(const Vector<double> &s, Shape &psi) const
  {
   TElementShape<2,NNODE_1D>::shape(s,psi);
  }
 
 /// \short Compute the  test functions and 
 /// derivatives w.r.t. local coordinates at local coordinate s
 inline void dtest_local(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids) const
  {
   TElementShape<2,NNODE_1D>::dshape_local(s,psi,dpsids);
  }
 
 /// \short Computer the test functions, derivatives and
 /// second derivatives w.r.t local coordinates at local coordinate s \n
 /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
 /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
 /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
 inline void d2test_local(const Vector<double> &s, Shape &psi, 
                           DShape &dpsids, DShape &d2psids) const
  {
   TElementShape<2,NNODE_1D>::d2shape_local(s,psi,dpsids,d2psids);
  }
 
};


//========================================================================
/// Empty base class for C1Curvedelements (created so that 
/// we can use dynamic_cast<>() to figure out if a an element
/// is a C1Curvedelement). This element is sup-parametric
/// Note that this type of element carries three kinds of shape functions
/// shape_straight : denotes C1-shape functions for straight-edged triangle
/// shape_curve : denotes C1-shape functions for curve-edged triangle
/// shape_geom : denotes C0-shape functions for geometry
//========================================================================
template<unsigned NNODE_1D>
class C1CurvedElementBase: public virtual FiniteElement
{
public:
  ///\short  Constructor: Call constructors for FiniteElement 
  C1CurvedElementBase() : FiniteElement(){}
 virtual void get_value_transform_matrix(DenseMatrix<double> &D, DenseMatrix<double> &B, DenseMatrix<double> &node_position, 
                                          unsigned &bd_element, DenseMatrix<double> &bd_node_position, Vector<double> &x) const
  {}

 virtual void classify_boundary_node(DenseMatrix<double> &node_position,unsigned &bd_element, 
                                     DenseMatrix<double> &bd_node_position, Vector<double> &x) const
  {}

 virtual void basis_straight(const Vector<double> &s, Shape &psi) const
  {}
 
 
 virtual void dbasis_local_straight(const Vector<double> &s, Shape &psi,
                            DShape &dpsids) const
  {}
 
 virtual void d2basis_local_straight(const Vector<double> &s, 
                             Shape &psi, 
                             DShape &dpsids,
                             DShape &d2psids) const
  {}

 virtual void shape_geom(const Vector<double> &s, Shape &psi, Shape &phi) const
  {}
 
 
 virtual void dshape_local_geom(const Vector<double> &s, Shape &psi,
                            DShape &dpsids, Shape &phi,
                            DShape &dphids) const
  {}
 
 virtual void d2shape_local_geom(const Vector<double> &s, 
                             Shape &psi, 
                             DShape &dpsids,
                             DShape &d2psids,
                             Shape &phi, 
                             DShape &dphids,
                             DShape &d2phids) const
  {}

 virtual void basis_curve(const Vector<double> &s, Shape &psi) const
  {}
 
 
 virtual void dbasis_local_curve(const Vector<double> &s, Shape &psi,
                            DShape &dpsids) const
  {}
 
 virtual void d2basis_local_curve(const Vector<double> &s, 
                             Shape &psi, 
                             DShape &dpsids,
                             DShape &d2psids) const
  {}

  virtual void basis_c0(const Vector<double> &s, Shape &psi) const
  {}
 
 
 virtual void dbasis_c0_local(const Vector<double> &s, Shape &psi,
                            DShape &dpsids) const
  {}
 
 virtual void d2basis_c0_local(const Vector<double> &s, 
                             Shape &psi, 
                             DShape &dpsids,
                             DShape &d2psids) const
  {}


 virtual void test(const Vector<double> &s, Shape &phi) const
  {}
 
 
 virtual void dtest_local(const Vector<double> &s, Shape &phi,
                            DShape &dphids) const
  {}
 
 virtual void d2test_local(const Vector<double> &s, 
                             Shape &phi, 
                             DShape &dphids,
                             DShape &d2phids) const
  {}


  //=========================================================================
  /// \short Return the c1-shape function associated with a straight-sided 
 /// boundary stored at the ipt-th integration point.
 //=========================================================================
  void basis_at_knot_straight(const unsigned &ipt, Shape &psi) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function
   basis_straight(s,psi);
  }
  
  //=========================================================================
 /// \short Return the c1-shape function associated with a straight-sided 
 /// boundary and its derivatives w.r.t. the global
 /// coordinates at the ipt-th integration point.
 //=========================================================================
  void dbasis_local_at_knot_straight(const unsigned &ipt, Shape &psi,
                                           DShape &dpsids) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function and derivatives
   dbasis_local_straight(s,psi,dpsids);
   
  }
 
 //=========================================================================
 /// Calculate the c1-shape function associated with a straight-sided 
 /// boundary and its first and second derivatives 
 /// w.r.t. global coordinates at the ipt-th integration point.
 /// \n\n Numbering:
 //=========================================================================
  void d2basis_local_at_knot_straight(const unsigned &ipt, Shape &psi, 
                                            DShape &dpsids, DShape &d2psids) 
   const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function and first and second derivatives
   d2basis_local_straight(s,psi,dpsids,d2psids);
   
  }
 
 //=========================================================================
 /// \short Return the c1-shape function  associated with a curvilinear 
 /// boundary stored at the ipt-th integration point.
 //=========================================================================
 void basis_at_knot_curve(const unsigned &ipt, Shape &psi) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function
   basis_curve(s,psi);
  }
  
 //=========================================================================
 /// Return the c1-shape function associated with a curvilinear boundary 
 /// and its derivatives w.r.t. the local coordinates at the ipt-th 
 /// integration point.
 //=========================================================================
  void dbasis_local_at_knot_curve(const unsigned &ipt, Shape &psi,
                                           DShape &dpsids) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function and derivatives
   dbasis_local_curve(s,psi,dpsids);
  }
 
 //=========================================================================
 /// Calculate the c1-shape function associated with a curvilinear boundary 
 /// and its first and second derivatives w.r.t. local coordinates at the 
 /// ipt-th integration point.
 /// \n\n Numbering:
 //=========================================================================
  void d2basis_local_at_knot_curve(const unsigned &ipt, Shape &psi, 
                                            DShape &dpsids, DShape &d2psids) 
   const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function and first and second derivatives
   d2basis_local_curve(s,psi,dpsids,d2psids);  
  }

  //=========================================================================
  /// \short Return the c0-shape function stored at the ipt-th integration
 /// point.
 //=========================================================================
  void basis_c0_at_knot(const unsigned &ipt, Shape &psi) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function
   basis_c0(s,psi);
  }
  
  //=========================================================================
 /// \short Return the c0-shape function and its derivatives w.r.t. the local
 /// coordinates at the ipt-th integration point.
 //=========================================================================
  void dbasis_c0_local_at_knot(const unsigned &ipt, Shape &psi,
                                           DShape &dpsids) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function and derivatives
   dbasis_c0_local(s,psi,dpsids);   
  }
 
 //=========================================================================
 /// Calculate the c0-shape function and its first and second derivatives 
 /// w.r.t. local coordinates at the ipt-th integration point.
 /// \n\n Numbering:
 //=========================================================================
  void d2basis_c0_local_at_knot(const unsigned &ipt, Shape &psi, 
                                            DShape &dpsids, DShape &d2psids) 
   const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function and first and second derivatives
   d2basis_c0_local(s,psi,dpsids,d2psids);  
  }
 
 //=========================================================================
 /// \short Return the geometric shape function stored at the ipt-th integration
 /// point.
 //=========================================================================
  void shape_at_knot_geom(const unsigned &ipt, Shape &psi, Shape &phi) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function
   shape_geom(s,psi,phi);
  }
  
 //=========================================================================
 /// \short Return the geometric shape function and its derivatives w.r.t. the local
 /// coordinates at the ipt-th integration point.
 //=========================================================================
 void dshape_local_at_knot_geom(const unsigned &ipt, Shape &psi,
                            DShape &dpsids, Shape &phi,
                            DShape &dphids) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function and derivatives
   
   dshape_local_geom(s,psi,dpsids,phi,dphids);
  }
 
 //=========================================================================
 /// Calculate the geometric shape function and its first and second derivatives 
 /// w.r.t. local coordinates at the ipt-th integration point.
 /// \n\n Numbering:
 //=========================================================================
 void d2shape_local_at_knot_geom(const unsigned &ipt, Shape &psi, 
                             DShape &dpsids, DShape &d2psids, Shape &phi, 
                             DShape &dphids, DShape &d2phids) 
  const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function and first and second derivatives
   d2shape_local_geom(s,psi,dpsids,d2psids,phi,dphids,d2phids);
  }

 //=========================================================================
 /// \short Return the test function stored at the ipt-th integration
 /// point.
 //=========================================================================
  void test_at_knot(const unsigned &ipt, Shape &phi) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function
   test(s,phi);
  }
  
  //=========================================================================
 /// \short Return the test function and its derivatives w.r.t. the local
 /// coordinates at the ipt-th integration point.
 //=========================================================================
  void dtest_local_at_knot(const unsigned &ipt, Shape &phi,
                                           DShape &dphids) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function and derivatives
   dtest_local(s,phi,dphids);
  }
 
 //=========================================================================
 /// Calculate the test function and its first and second derivatives 
 /// w.r.t. local coordinates at the ipt-th integration point.
 /// \n\n Numbering:
 //=========================================================================
  void d2test_local_at_knot(const unsigned &ipt, Shape &phi, 
                                            DShape &dphids, DShape &d2phids) 
   const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Storage for the local coordinates of the integration point
   Vector<double> s(el_dim); 
   //Set the local coordinate
   for(unsigned i=0;i<el_dim;i++) {s[i] = integral_pt()->knot(ipt,i);}
   //Get the shape function and first and second derivatives
   d2test_local(s,phi,dphids,d2phids);
  }
  
  //=========================================================================
 /// Calculate the shape function and its first and second derivatives 
 /// w.r.t. local coordinates at the ipt-th integration point.
 /// \n\n Numbering:
 //=========================================================================
  double dshape_and_dtest_eulerian_at_knot(const unsigned &ipt, Shape &psi, DShape &dpsi, Shape &test, DShape &dtest)
   const 
  {
 
    //Find the element dimension
   const unsigned el_dim = dim();
   //Get the values of the shape function and local derivatives
   //Temporarily store it in dpsi
   // assign shape functions for unknowns
   dshape_local_at_knot(ipt,psi,dpsi);
   
   // assign shape functions for geometry -> Lagrange family
   unsigned n_node = 3;
   Shape psi_x(n_node);
   DShape dpsi_x(n_node,2);
   Shape phi(2);
   DShape dphi(2,2);
   
   // assign 'linear' shape function to geometry
   dshape_local_at_knot_geom(ipt,psi_x,dpsi_x,phi,dphi);

   // assign test function
   dtest_local_at_knot(ipt,test,dtest);

   //Allocate memory for the inverse jacobian
   DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);

   //Now calculate the inverse jacobian
   const double det = local_to_eulerian_mapping2(dpsi_x,dphi,jacobian,inverse_jacobian);
   
   //Now set the values of the derivatives to dpsidx
   transform_derivatives(inverse_jacobian,dpsi);
   
   //Return the determinant of the jacobian
   return det;
  }

  //===========================================================================
  /// \short Compute the  c1-shape functions that associated with the straight-
  /// boundary element and also first and second derivatives w.r.t. global 
  /// coordinates at ipt-th integration point
  /// Returns Jacobian of mapping from global to local coordinates.
  //===========================================================================
  double d2shape_and_d2test_eulerian_at_knot(const unsigned &ipt, 
                                                 Shape &psi, 
                                                 DShape &dpsi, 
                                                 DShape &d2psi,
                                                 Shape &test, 
                                                 DShape &dtest, 
                                                 DShape &d2test) const
  {
   //Find the values of the indices of the shape functions
   //Locally cached
   //Find the element dimension
   const unsigned el_dim = dim();
   //Get the values of the shape function and local derivatives for unknowns
   d2basis_local_at_knot_straight(ipt,psi,dpsi,d2psi);

   // assign shape functions for geometry
   unsigned n_node = 3;
   Shape psi_x(n_node);
   DShape dpsi_x(n_node,2);
   DShape d2psi_x(n_node,3);
   Shape phi(2);
   DShape dphi(2,2);
   DShape d2phi(2,3);
   d2shape_local_at_knot_geom(ipt,psi_x,dpsi_x,d2psi_x,phi,dphi,d2phi);

   // assign for test function
   d2test_local_at_knot(ipt,test,dtest,d2test);
   
   //Allocate memory for the jacobian and inverse jacobian 
   DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);

   //Calculate the jacobian and inverse jacobian
   const double det = local_to_eulerian_mapping2(dpsi_x,dphi,jacobian,inverse_jacobian);

   //Return the determinant of the mapping
   return det;
  }

  //===========================================================================
  /// \short Calculate the mapping from local to Eulerian coordinates,
  /// given the derivatives of the shape functions w.r.t. local coordinates,
  /// Return only the determinant of the jacobian and the inverse of the
  /// mapping (ds/dx).
  //===========================================================================
 double local_to_eulerian_mapping2(const DShape &dpsids, DShape &dphids,
                                   DenseMatrix<double> &inverse_jacobian) const
  {
   //Find the dimension of the element
   const unsigned el_dim = dim();
   //Assign memory for the jacobian
   DenseMatrix<double> jacobian(el_dim);
   //Calculate the jacobian and inverse
   return local_to_eulerian_mapping2(dpsids,dphids,jacobian,inverse_jacobian);
  }

  ///////////////////////////////////////////////////////////////
 virtual double local_to_eulerian_mapping2(const DShape &dpsids,
                                           DShape &dphids,
                                           DenseMatrix<double> &jacobian,
                                           DenseMatrix<double> &inverse_jacobian) const
  {
    //Assemble the jacobian
    //Locally cache the elemental dimension
   const unsigned el_dim = dim();
   
   //Loop over the rows of the jacobian
   for(unsigned i=0;i<el_dim;i++)
    {
     //Loop over the columns of the jacobian
     for(unsigned j=0;j<el_dim;j++)
      {
       //Zero the entry
       jacobian(i,j) = 0.0;
       jacobian(i,j) = dphids(j,i);
      }
    } 
   //Invert the jacobian (use the template-free interface)
   return invert_jacobian_mapping(jacobian,inverse_jacobian);
  }

 //=========================================================================
 /// Internal function that is used to assemble the jacobian of second
 /// derivatives of the the mapping from local coordinates (s) to the 
 /// eulerian coordinates (x), given the second derivatives of the 
 /// shape functions. 
 //=========================================================================
  void myassemble_local_to_eulerian_jacobian2(const DShape &d2psids,
                                       DenseMatrix<double> &jacobian2) const
  {
   //Find the the dimension of the element
   const unsigned el_dim = dim();
   //Find the number of second derivatives
   const unsigned n_row = N2deriv[el_dim];
   //Assemble the "jacobian" (d^2 x_j/ds_i^2) for second derivatives of 
   //shape functions
   //Loop over the rows (number of second derivatives)
   for(unsigned i=0;i<n_row;i++)
    {
     //Loop over the columns (element dimension
     for(unsigned j=0;j<el_dim;j++)
      {
       //Zero the entry
       jacobian2(i,j) = 0.0;
       jacobian2(i,j) = d2psids(j,i);
      }
    }
  }

 //=======================================================================
 /// Return FE interpolated position x[] at local coordinate s as Vector
 // (using Hermite interpolation)
 //=======================================================================
  void my_interpolated_x(const Vector<double> &s, Vector<double> &x)
   const
  {
   //Find the number of nodes
   const unsigned n_node = 3;
   //Assign storage for the local shape function
   Shape psi(n_node);
   Shape phi(2);
   //Find the values of shape function
   shape_geom(s,psi,phi);
   
   x[0] = phi[0];
   x[1] = phi[1];
  }
  
 //========================================================================
 /// \short Calculate the Jacobian of the mapping between local and global
 /// coordinates at the position s
 //========================================================================
 double J_eulerian1(const Vector<double> &s) const
  {
    //Find the number of nodes and position types
   const unsigned n_node = 3;
   //Find the dimension of the node and element
   const unsigned n_dim_node = this->nodal_dimension();
   const unsigned n_dim_element = this->dim();
 
   //Set up dummy memory for the shape functions
   // compute the jacobian of mapping matrix
   Shape psi(n_node), phi(2);
   DShape dpsids(n_node,n_dim_element), dphi(2,2);
   //Get the shape functions and local derivatives for geometry
   this->dshape_local_geom(s,psi,dpsids,phi,dphi);
   
   //Right calculate the base vectors
   DenseMatrix<double> interpolated_G(n_dim_element,n_dim_node);
   
   //Loop over the dimensions and compute the entries of the 
   //base vector matrix
   for(unsigned i=0;i<n_dim_element;i++)
    {
     for(unsigned j=0;j<n_dim_node;j++)
      {
       interpolated_G(i,j) = dphi(j,i);
      }
    }
  
   //Calculate the metric tensor of the element
   DenseMatrix<double> G(n_dim_element);
   for(unsigned i=0;i<n_dim_element;i++)
    {
     for(unsigned j=0;j<n_dim_element;j++)
      {
       //Initialise to zero
       G(i,j) = 0.0;
       for(unsigned k=0;k<n_dim_node;k++) 
        {
         G(i,j) += interpolated_G(i,k)*interpolated_G(j,k);
        }
      }
    }
 
   //Calculate the determinant of the metric tensor
   double det = 0.0;
   switch(n_dim_element)
    {
    case 0:
     throw OomphLibError("Cannot calculate J_eulerian() for point element\n",
                         "FiniteElement::J_eulerian()",
                         OOMPH_EXCEPTION_LOCATION);
     break;
    case 1:
     det = G(0,0);
     break;
    case 2:
     det = G(0,0)*G(1,1) - G(0,1)*G(1,0);
     break;
    case 3:
     det = G(0,0)*G(1,1)*G(2,2) + G(0,1)*G(1,2)*G(2,0) + G(0,2)*G(1,0)*G(2,1)
      - G(0,0)*G(1,2)*G(2,1) - G(0,1)*G(1,0)*G(2,2) - G(0,2)*G(1,1)*G(2,0);
     break;
    default:
     oomph_info << "More than 3 dimensions in J_eulerian()" << std::endl;
     break;
    }
 
#ifdef PARANOID
   this->check_jacobian(det);
#endif
   
   //Return the Jacobian (square-root of the determinant of the metric tensor)
   return det; 
  }
  
  // =======================================================================
  // Check whether this element is a boundary element or not
  //========================================================================
 unsigned is_boundary_element()const
  {
   unsigned n_node = 3;
   int count=0;
   // check whether this element is on boundary or not
   for(unsigned i=0;i<n_node;i++)
    {
     // check whether this node is on 1st boundary (curve boundary)
     bool bd_node1 = node_pt(i)->is_on_boundary(1);
     if(bd_node1==1)
      {
       count += 1;
      }
    }
   unsigned bd_element;
   if(count == 2)
    {
     bd_element = 1;
    }          
   else
    {
     bd_element = 0;           
    }
   return bd_element;
   }

 //=========================================================================
 /// \short Compute the c0-shape functions and also
 /// first derivatives w.r.t. global coordinates at local coordinate s;
 /// Returns Jacobian of mapping from global to local coordinates.
 /// Most general form of the function, but may be over-loaded, if desired
 //=========================================================================
 double dbasis_c0_eulerian(const Vector<double> &s, 
                           Shape &psi,
                           DShape &dpsi) const
  {
   //Find the element dimension
   const unsigned el_dim = dim();
   //Get the values of the shape functions and their local derivatives
   //Temporarily stored in dpsi
   dbasis_c0_local(s,psi,dpsi);
   
    // assign shape functions for geometry
   unsigned n_node = 3;
   Shape psi_x(n_node);
   DShape dpsi_x(n_node,2);
   DShape d2psi_x(n_node,3);
   Shape phi(2);
   DShape dphi(2,2);
   DShape d2phi(2,3);
   d2shape_local_geom(s,psi_x,dpsi_x,d2psi_x,phi,dphi,d2phi);
   
   //Allocate memory for the jacobian and inverse jacobian 
   DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);
   //Calculate the jacobian and inverse jacobian
   const double det = this->local_to_eulerian_mapping2(dpsi_x,dphi,jacobian,inverse_jacobian);
   //Now set the values of the derivatives to be dpsidx
   transform_derivatives(inverse_jacobian,dpsi);
   //Return the determinant of the jacobian
   return det;
  }

  //=========================================================================
 /// \short Compute the c0-shape functions and also the first and the
 /// second derivatives w.r.t.global coordinates at local coordinate s;
 /// Returns Jacobian of mapping from global to local coordinates.
 /// Most general form of the function, but may be over-loaded, if desired
 //=========================================================================
 double d2basis_c0_eulerian(const Vector<double> &s, 
                           Shape &psi,
                           DShape &dpsi,
                           DShape &d2psi) const
  {
   //Find the element dimension
   const unsigned el_dim = dim();
   //Find the number of second derivatives required
   const unsigned n_deriv = N2deriv[el_dim];
   //Get the values of the shape function and local derivatives for unknowns
   d2basis_c0_local(s,psi,dpsi,d2psi);
     
   // assign shape functions for geometry
   unsigned n_node = 3;
   Shape psi_x(n_node);
   DShape dpsi_x(n_node,2);
   DShape d2psi_x(n_node,3);
   Shape phi(2);
   DShape dphi(2,2);
   DShape d2phi(2,3);
   d2shape_local_geom(s,psi_x,dpsi_x,d2psi_x,phi,dphi,d2phi);
   
   //Allocate memory for the jacobian and inverse jacobian 
   DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);
   //Calculate the jacobian and inverse jacobian
   const double det = local_to_eulerian_mapping2(dpsi_x,dphi,jacobian,inverse_jacobian);
   //Allocate memory for the jacobian of second derivatives
   DenseMatrix<double> jacobian2(n_deriv,el_dim,0.0);
   //Assemble the jacobian of second derivatives
   myassemble_local_to_eulerian_jacobian2(d2phi,jacobian2);  
   //Now set the value of the derivatives
   transform_second_derivatives(jacobian,inverse_jacobian,jacobian2,dpsi,d2psi);
   //Return the determinant of the jacobian
   return det;
  }
 
 //=========================================================================
 /// \short Compute the curved-element shape functions and also
 /// first derivatives w.r.t. global coordinates at local coordinate s;
 /// Returns Jacobian of mapping from global to local coordinates.
 /// Most general form of the function, but may be over-loaded, if desired
 //=========================================================================
 double dbasis_eulerian_curve(const Vector<double> &s, 
                              Shape &psi,
                              DShape &dpsi) const
  {
   //Find the element dimension
   const unsigned el_dim = dim();
   //Get the values of the shape functions and their local derivatives
   //Temporarily stored in dpsi
   dbasis_local_curve(s,psi,dpsi);
   
    // assign shape functions for geometry
   unsigned n_node = 3;
   Shape psi_x(n_node);
   DShape dpsi_x(n_node,2);
   DShape d2psi_x(n_node,3);
   Shape phi(2);
   DShape dphi(2,2);
   DShape d2phi(2,3);
   d2shape_local_geom(s,psi_x,dpsi_x,d2psi_x,phi,dphi,d2phi);
   
   //Allocate memory for the jacobian and inverse jacobian 
   DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);
   //Calculate the jacobian and inverse jacobian
   const double det = this->local_to_eulerian_mapping2(dpsi_x,dphi,jacobian,inverse_jacobian);
   //Now set the values of the derivatives to be dpsidx
   transform_derivatives(inverse_jacobian,dpsi);
   //Return the determinant of the jacobian
   return det;
  }

  //===========================================================================
  /// \short Compute the cuved-element shape functions and also first
  /// and second derivatives w.r.t. global coordinates at ipt-th integration
  /// point
  //===========================================================================
  double d2basis_eulerian_curve(const Vector<double> &s, Shape &psi, 
                                      DShape &dpsi, 
                                      DShape &d2psi) const
  {
   //Find the element dimension
   const unsigned el_dim = dim();
   //Find the number of second derivatives required
   const unsigned n_deriv = N2deriv[el_dim];
   //Get the values of the shape function and local derivatives for unknowns
   d2basis_local_curve(s,psi,dpsi,d2psi);
     
   // assign shape functions for geometry
   unsigned n_node = 3;
   Shape psi_x(n_node);
   DShape dpsi_x(n_node,2);
   DShape d2psi_x(n_node,3);
   Shape phi(2);
   DShape dphi(2,2);
   DShape d2phi(2,3);
   d2shape_local_geom(s,psi_x,dpsi_x,d2psi_x,phi,dphi,d2phi);
   
   //Allocate memory for the jacobian and inverse jacobian 
   DenseMatrix<double> jacobian(el_dim), inverse_jacobian(el_dim);
   //Calculate the jacobian and inverse jacobian
   const double det = local_to_eulerian_mapping2(dpsi_x,dphi,jacobian,inverse_jacobian);
   //Allocate memory for the jacobian of second derivatives
   DenseMatrix<double> jacobian2(n_deriv,el_dim,0.0);
   //Assemble the jacobian of second derivatives
   myassemble_local_to_eulerian_jacobian2(d2phi,jacobian2);  
   //Now set the value of the derivatives
   transform_second_derivatives(jacobian,inverse_jacobian,jacobian2,dpsi,d2psi);
   //Return the determinant of the jacobian
   return det;
  }

 //=======================================================================
 /// Return raw nodal value for nodes specified on the reference triangle
 //=======================================================================
 void get_nodal_value_curve1(Vector<double> &u_value,  DenseMatrix<double> &M) 
  {
   // assign degrees of freedom to the reference element
   DenseMatrix<double> D(21,21), B(21,36);
   Vector<double> temp(21,0.0);
   DenseMatrix<double> position(3,2);
   unsigned bd_element;
   DenseMatrix<double> bd_position(20,2);
   Vector<double> x(2);
   
   // Get the nodal values of the unknown
   Vector<double> value(21);
  
   value[0] = raw_nodal_value(0,0);
   value[1] = raw_nodal_value(1,0);
   value[2] = raw_nodal_value(2,0);
   value[3] = raw_nodal_value(0,1);
   value[4] = raw_nodal_value(0,2);
   value[5] = raw_nodal_value(1,1);
   value[6] = raw_nodal_value(1,2);
   value[7] = raw_nodal_value(2,1);
   value[8] = raw_nodal_value(2,2);
   value[9] = raw_nodal_value(0,3);
   value[10] = raw_nodal_value(0,5);
   value[11] = raw_nodal_value(0,4);
   value[12] = raw_nodal_value(1,3);
   value[13] = raw_nodal_value(1,5);
   value[14] = raw_nodal_value(1,4);
   value[15] = raw_nodal_value(2,3);
   value[16] = raw_nodal_value(2,5);
   value[17] = raw_nodal_value(2,4); 
   value[18] = raw_nodal_value(3,0);
   value[19] = raw_nodal_value(4,0);
   value[20] = raw_nodal_value(5,0);
  
   // Transformation metrix associating nodal values between the reference 
   // and the physical curved triangle
   get_value_transform_matrix(D,B,position,bd_element,bd_position,x);
   
   for(unsigned i=0;i<21;i++)
    {
     for(unsigned j=0;j<36;j++)
      {
       for(unsigned k=0;k<21;k++)
        {
         M(i,j) += D(i,k)*B(k,j);
        }
      }
    }
 
   for(unsigned i=0;i<21;i++)
    {
     for(unsigned j=0;j<21;j++)
      {
       // get values wrt local coordinates
       temp[i] += value[j]*D(j,i);
      }
    }
   
   for(unsigned i=0;i<36;i++)
    {
     for(unsigned j=0;j<21;j++)
      {
       u_value[i] += temp[j]*B(j,i);
      }
    }
  }

 //=======================================================================
 /// Return raw nodal equations for nodes specified on the curved triangle
 ///  This function will be employed for the post-permutation as
 /// the nodal values defined on the element doesn't match with the defined 
 /// shape functions
 //=======================================================================
 void get_nodal_eqn_curve(DenseMatrix<int> &nodal_eqn) 
  {
   // assign degrees of freedom to the reference element
   DenseMatrix<double> D(21,21), B(21,36);
   DenseMatrix<double> position(3,2);
   unsigned bd_element;
   DenseMatrix<double> bd_position(20,2);
   Vector<double> x(2);
   unsigned n_position_type = 6;
   
   // Get nodal values at nodes on the reference element
   get_value_transform_matrix(D,B,position,bd_element,bd_position,x);
   
   double angle_1 = atan(bd_position(0,1)/bd_position(0,0));
   double angle_2 = atan(bd_position(1,1)/bd_position(1,0));
   if(angle_1 > angle_2)
    {
     for(unsigned k=0;k<n_position_type;k++)
      {
       unsigned i = 2+k;
       nodal_eqn(0,k) = nodal_local_eqn(2,i);
       nodal_eqn(1,k) = nodal_local_eqn(0,i);
       nodal_eqn(2,k) = nodal_local_eqn(1,i);
       nodal_eqn(3,k) = nodal_local_eqn(5,i);
       nodal_eqn(4,k) = nodal_local_eqn(3,i);
       nodal_eqn(5,k) = nodal_local_eqn(4,i);
       nodal_eqn(nnode()-3,k) = nodal_local_eqn(nnode()-3,i);
       nodal_eqn(nnode()-2,k) = nodal_local_eqn(nnode()-2,i);
       nodal_eqn(nnode()-1,k) = nodal_local_eqn(nnode()-1,i);
      }
    }
   else if(angle_1 < angle_2)
    {
     if(position(0,0)==bd_position(0,0) && position(0,1)==bd_position(0,1))
      {
       for(unsigned k=0;k<n_position_type;k++)
        {
         nodal_eqn(0,k) = nodal_local_eqn(0,2+k);
         nodal_eqn(1,k) = nodal_local_eqn(1,2+k);
         nodal_eqn(2,k) = nodal_local_eqn(2,2+k);
         nodal_eqn(3,k) = nodal_local_eqn(3,2+k);
         nodal_eqn(4,k) = nodal_local_eqn(4,2+k);
         nodal_eqn(5,k) = nodal_local_eqn(5,2+k);
         nodal_eqn(nnode()-3,k) = nodal_local_eqn(nnode()-2,2+k);
         nodal_eqn(nnode()-2,k) = nodal_local_eqn(nnode()-1,2+k);
         nodal_eqn(nnode()-1,k) = nodal_local_eqn(nnode()-3,2+k);
        }
      }
     else 
      {
       for(unsigned k=0;k<n_position_type;k++)
        {
         nodal_eqn(0,k) = nodal_local_eqn(1,2+k);
         nodal_eqn(1,k) = nodal_local_eqn(2,2+k);
         nodal_eqn(2,k) = nodal_local_eqn(0,2+k);
         nodal_eqn(3,k) = nodal_local_eqn(4,2+k);
         nodal_eqn(4,k) = nodal_local_eqn(5,2+k);
         nodal_eqn(5,k) = nodal_local_eqn(3,2+k);
         nodal_eqn(nnode()-3,k) = nodal_local_eqn(nnode()-1,2+k);
         nodal_eqn(nnode()-2,k) = nodal_local_eqn(nnode()-3,2+k);
         nodal_eqn(nnode()-1,k) = nodal_local_eqn(nnode()-2,2+k);
        }
      }
    }
  }

 //=======================================================================
 /// Return FE interpolated value u[] at local coordinate s as Vector
 /// using Bell interpolations for the straight-edges triangle
 /// using C1-curved interpolations for the curve-edges triangle
 // This one is for the pre-permutation
 //=======================================================================
 void my_interpolated_u_normal1(const Vector<double> s, Vector<double> &interpolated_u, DenseMatrix<double> &interpolated_dudxi, DenseMatrix<double> &interpolated_d2udxi, DenseMatrix<double> &M) 
  {
   // To check whether this element is on the boundary
   unsigned bd_element = is_boundary_element();
   //Find the number of positional types
   const unsigned n_position_type = nnodal_position_type();
   if(bd_element==0)
    {
     //Assign storage for the local shape function
     Shape psi(3,6);
     DShape dpsi(3,6,2), d2psi(3,6,3);
     
     //Assign shape functions and their derivatives
     d2basis_local_straight(s,psi,dpsi,d2psi);
     
     // Loop over nodes
     for(unsigned l=0;l<3;l++) 
      {
       for(unsigned k=0;k<n_position_type;k++)
        {
         //Get the nodal value of the unknown
         double u_val = raw_nodal_value(l,k);
         interpolated_u[0] += u_val*psi(l,k);
         
         // Loop over directions
         for(unsigned j=0;j<2;j++)
          {
           interpolated_dudxi(0,j) += u_val*dpsi(l,k,j);
          }
         for(unsigned j=0;j<3;j++)
          {
           interpolated_d2udxi(0,j) += u_val*d2psi(l,k,j);
          }
        }
      }
    }  
   // if it is the boundary element
   else if(bd_element==1)
    {  
     Vector<double> u_value(36,0.0);
     // Get nodal values at nodes on the reference element
     get_nodal_value_curve1(u_value,M);

     // Assign storage for the local shape functio to a curved element
     Shape psi_curve(36),basis(36);
     DShape dpsi_curve(36,2), d2psi_curve(36,3), dbasis(36,2), d2basis(36,3);

     // derivative have to be wrt global coor.
     d2basis_eulerian_curve(s,psi_curve,dpsi_curve,d2psi_curve); 
     for(unsigned i=0;i<36;i++) 
      {
       interpolated_u[0] += u_value[i]*psi_curve[i];
       // Loop over directions
       for(unsigned j=0;j<2;j++)
        {
         interpolated_dudxi(0,j) += u_value[i]*dpsi_curve(i,j);
        }
       for(unsigned j=0;j<3;j++)
        {
         interpolated_d2udxi(0,j) += u_value[i]*d2psi_curve(i,j);
        }
      }
    }
  }
 
 //=======================================================================
 /// Return FE interpolated value u[] at local coordinate s as Vector
 /// using Bell interpolations for the straight-edges triangle
 /// using C1-curved interpolations for the curve-edges triangle
 // This one is for post-permutation
 //=======================================================================
  void my_interpolated_u_normal(const Vector<double> s, Vector<double> &interpolated_u, DenseMatrix<double> &interpolated_dudxi, DenseMatrix<double> &interpolated_d2udxi)
   const
  {
   // To check whether this element is on the boundary
   unsigned bd_element = is_boundary_element();
   
   //Find the number of positional types
   const unsigned n_position_type = nnodal_position_type();
  
   if(bd_element==0)
    {
     //Assign storage for the local shape function
     Shape psi(3,6);
     DShape dpsi(3,6,2), d2psi(3,6,3);
     //Assign shape functions and their derivatives
     d2basis_local_straight(s,psi,dpsi,d2psi);
   
     // Loop over nodes
     for(unsigned l=0;l<3;l++) 
      {
       for(unsigned k=0;k<n_position_type;k++)
        {
         //Get the nodal value of the poisson unknown
         double u_val = raw_nodal_value(l,2+k);
         interpolated_u[0] += u_val*psi(l,k);
         // Loop over directions
         for(unsigned j=0;j<2;j++)
          {
           interpolated_dudxi(0,j) += u_val*dpsi(l,k,j);
          }
         for(unsigned j=0;j<3;j++)
          {
           interpolated_d2udxi(0,j) += u_val*d2psi(l,k,j);
          }
        }
      }
    }  
   // if it is the boundary element
   else if(bd_element==1)
    {
     // assign degrees of freedom to the reference element
     DenseMatrix<double> D(21,21), B(21,36);
     Vector<double> temp(21,0.0);
     Vector<double> u_value(36,0.0);
     DenseMatrix<double> position(3,2);
     unsigned bd_element;
     DenseMatrix<double> bd_position(20,2);
     Vector<double> x(2);
     // Get nodal values at nodes on the reference element
     get_value_transform_matrix(D,B,position,bd_element,bd_position,x);
 
     Vector<double> value(21);
    
     double angle_1 = atan(bd_position(0,1)/bd_position(0,0));
     double angle_2 = atan(bd_position(1,1)/bd_position(1,0));
     if(angle_1 > angle_2)
      {
       DenseMatrix<double> nodal_value(3,n_position_type);
       for(unsigned k=0;k<n_position_type;k++)
        {
         nodal_value(0,k) = raw_nodal_value(2,2+k);
         nodal_value(1,k) = raw_nodal_value(0,2+k);
         nodal_value(2,k) = raw_nodal_value(1,2+k);
        }
       value[0] = nodal_value(0,0);
       value[1] = nodal_value(1,0);
       value[2] = nodal_value(2,0);
       value[3] = nodal_value(0,1);
       value[4] = nodal_value(0,2);
       value[5] = nodal_value(1,1);
       value[6] = nodal_value(1,2);
       value[7] = nodal_value(2,1);
       value[8] = nodal_value(2,2);
       value[9] = nodal_value(0,3);
       value[10] = nodal_value(0,5);
       value[11] = nodal_value(0,4);
       value[12] = nodal_value(1,3);
       value[13] = nodal_value(1,5);
       value[14] = nodal_value(1,4);
       value[15] = nodal_value(2,3);
       value[16] = nodal_value(2,5);
       value[17] = nodal_value(2,4);
       value[18] = raw_nodal_value(nnode()-3,2+0);
       value[19] = raw_nodal_value(nnode()-2,2+0);
       value[20] = raw_nodal_value(nnode()-1,2+0);
      }
     else if(angle_1 < angle_2)
      {
       if(position(0,0)==bd_position(0,0) && position(0,1)==bd_position(0,1))
        {
         value[0] = raw_nodal_value(0,2+0);
         value[1] = raw_nodal_value(1,2+0);
         value[2] = raw_nodal_value(2,2+0);
         value[3] = raw_nodal_value(0,2+1);
         value[4] = raw_nodal_value(0,2+2);
         value[5] = raw_nodal_value(1,2+1);
         value[6] = raw_nodal_value(1,2+2);
         value[7] = raw_nodal_value(2,2+1);
         value[8] = raw_nodal_value(2,2+2);
         value[9] = raw_nodal_value(0,2+3);
         value[10] = raw_nodal_value(0,2+5);
         value[11] = raw_nodal_value(0,2+4);
         value[12] = raw_nodal_value(1,2+3);
         value[13] = raw_nodal_value(1,2+5);
         value[14] = raw_nodal_value(1,2+4);
         value[15] = raw_nodal_value(2,2+3);
         value[16] = raw_nodal_value(2,2+5);
         value[17] = raw_nodal_value(2,2+4);
         value[18] = raw_nodal_value(nnode()-2,2+0);
         value[19] = raw_nodal_value(nnode()-1,2+0);
         value[20] = raw_nodal_value(nnode()-3,2+0);
        }
       else 
        {
         DenseMatrix<double> nodal_value(3,n_position_type);
         for(unsigned k=0;k<n_position_type;k++)
          {
           nodal_value(2,k) = raw_nodal_value(0,2+k);
           nodal_value(0,k) = raw_nodal_value(1,2+k);
           nodal_value(1,k) = raw_nodal_value(2,2+k);
          }
         value[0] = nodal_value(0,0);
         value[1] = nodal_value(1,0);
         value[2] = nodal_value(2,0);
         value[3] = nodal_value(0,1);
         value[4] = nodal_value(0,2);
         value[5] = nodal_value(1,1);
         value[6] = nodal_value(1,2);
         value[7] = nodal_value(2,1);
         value[8] = nodal_value(2,2);
         value[9] = nodal_value(0,3);
         value[10] = nodal_value(0,5);
         value[11] = nodal_value(0,4);
         value[12] = nodal_value(1,3);
         value[13] = nodal_value(1,5);
         value[14] = nodal_value(1,4);
         value[15] = nodal_value(2,3);
         value[16] = nodal_value(2,5);
         value[17] = nodal_value(2,4);
         value[18] = raw_nodal_value(nnode()-1,2+0);
         value[19] = raw_nodal_value(nnode()-3,2+0);
         value[20] = raw_nodal_value(nnode()-2,2+0);
        }
      }
     
     for(unsigned i=0;i<21;i++)
      {
       for(unsigned j=0;j<21;j++)
        {
         // get values wrt local coordinates
         temp[i] += value[j]*D(j,i);
        }
      }
     
     for(unsigned i=0;i<36;i++)
      {
       for(unsigned j=0;j<21;j++)
        {
         u_value[i] += temp[j]*B(j,i);
        }
      }
     
     // Assign storage for the local shape functio to a curved element
     Shape psi_curve(36),basis(36);
     DShape dpsi_curve(36,2), d2psi_curve(36,3), dbasis(36,2), d2basis(36,3);
     // derivative have to be wrt global coor.
     d2basis_eulerian_curve(s,psi_curve,dpsi_curve,d2psi_curve); 
         
     for(unsigned i=0;i<36;i++) 
      {
       interpolated_u[0] += u_value[i]*psi_curve[i];
       // Loop over directions
       for(unsigned j=0;j<2;j++)
        {
         interpolated_dudxi(0,j) += u_value[i]*dpsi_curve(i,j);
        }
       for(unsigned j=0;j<3;j++)
        {
         interpolated_d2udxi(0,j) += u_value[i]*d2psi_curve(i,j);
        }
      }
    } 
  }

 //=======================================================================
 /// Return FE interpolated value u[] at local coordinate s as Vector
 // (using Lagrange interpolations)
 //=======================================================================
  void my_interpolated_u_tangential(const Vector<double> s, Vector<double> &interpolated_u, DenseMatrix<double> &interpolated_dudxi)
   const
  {
   unsigned n_node = nnode()-3;

   //Local shape function
   Shape psi(n_node);
   DShape dpsi(n_node,2);
   this->dbasis_c0_eulerian(s,psi,dpsi);

   //Interpolated in tangential direction
   for(unsigned l=0;l<n_node;l++) 
    {
     interpolated_u[0] += this->raw_nodal_value(l,0)*psi[l];
     interpolated_u[1] += this->raw_nodal_value(l,1)*psi[l]; 
     // Loop over directions
     for(unsigned j=0;j<2;j++)
      {
       interpolated_dudxi(0,j) += this->raw_nodal_value(l,0)*dpsi(l,j);
       interpolated_dudxi(1,j) += this->raw_nodal_value(l,1)*dpsi(l,j);
      } 
    }
  }

};

/////////////////////////////////////////////////////////////////////////////
/// General C1CurvedElement class  ///
/// Empty, just establishes the template parameters
/////////////////////////////////////////////////////////////////////
template<unsigned DIM, unsigned NNODE_1D>
class C1CurvedElement {};

//=======================================================================
/// C1CurvedElement elements, specialised to two spatial dimensions
//=======================================================================
template<unsigned NNODE_1D>
class C1CurvedElement<2,NNODE_1D> : public virtual C1CurvedElementBase<NNODE_1D>, public virtual TElement<2,NNODE_1D>, public virtual GeometricTElement<2>, public virtual C1CurvedElementShape<2,NNODE_1D>, public virtual BellElementShape<2>
{
 private:
 /// Nodal translation scheme for use when generating face elements
 static const unsigned NodeOnFace[3][NNODE_1D];

 public :

 ///\short  Constructor: Call constructors for C1CurvedElement 
 C1CurvedElement() : C1CurvedElementBase<NNODE_1D>(), TElement<2,NNODE_1D>(), 
  GeometricTElement<2>(), C1CurvedElementShape<2,NNODE_1D>(),BellElementShape<2>()
  {
   // Number of nodes
   switch (NNODE_1D)
    {
    case 2:
    case 3:
     break;
     
    default:
     std::string error_message =
      "Triangles are currently only implemented for\n";
     error_message +=
      "three vertices and three internal nodes, i.e. NNODE_1D=2,3 only\n";
     
     throw OomphLibError(error_message,
                         "CurvedTElement::CurvedTElement()",
                         OOMPH_EXCEPTION_LOCATION);
    }

   // Set the number of nodes
   unsigned n_node = (NNODE_1D*(NNODE_1D+1))/2 + 3;
   this->set_n_node(n_node);
   // Set the elemental and nodal dimension
   this->set_dimension(2);
   //Set the number of types required to interpolate the coordinate
   this->set_nnodal_position_type(6);
   TGauss<2,5>* new_integral_pt = new TGauss<2,5>;
   this->set_integration_scheme(new_integral_pt); 
  }

 /// Broken copy constructor
 C1CurvedElement(const C1CurvedElement&) 
  { 
   BrokenCopy::broken_copy("C1CurvedElement");
  } 
 
 /// Broken assignment operator
 void operator=(const C1CurvedElement&) 
  {
   BrokenCopy::broken_assign("C1CurvedElement");
  }
 /// Destructor
 ~C1CurvedElement() {}
 
 /// Number of nodes along each element edge
 unsigned nnode_1d() const {return NNODE_1D;}

 /// \short Number of vertex nodes in the element: One more
 /// than spatial dimension
 unsigned nvertex_node() const {return 3;}

 /// Number of internal nodes 
 unsigned ninternal_node() const {return 3;}
 
 /// \short Pointer to the j-th vertex node in the element
 Node* vertex_node_pt(const unsigned& j) const
  {
   // Vertex nodes come first:
#ifdef PARANOID
   if (j>2)
    {
     std::ostringstream error_message;
     error_message 
      << "Element only has three vertex nodes; called with node number " 
      << j << std::endl;     
     throw OomphLibError(error_message.str(),
                         "TElement::vertex_node_pt()",
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   return this->node_pt(j);
  }

 // Classify nodes on the element: boundary nodes and non-boundary nodes
 inline void classify_boundary_node(DenseMatrix<double> &node_position,
                                    unsigned &bd_element, DenseMatrix<double> &bd_node_position, Vector<double> &x) const
  {
   /// Number of nodes along each element edge: Just for the three vertices not the internal points
   unsigned n_node = 3;
   /// Loop over vertices
   for(unsigned l=0;l<n_node;l++)
    {
     for(unsigned k=0;k<1;k++)
      {
       for(unsigned j=0;j<2;j++)
        {
         node_position(l,j) = this->raw_nodal_position_gen(l,k,j);
        }
      }
    }
   
   int count=0;
     
   // check whether this element is on boundary or not
   for(unsigned i=0;i<n_node;i++)
    {
     // check whether this node is on 1st boundary (curve boundary)
     bool bd_node1 = this->node_pt(i)->is_on_boundary(1);
     if(bd_node1==1)
      {
       count += 1;
       for(unsigned k=0;k<1;k++)
        {
         for(unsigned j=0;j<2;j++)
          {
           bd_node_position(count-1,j) = this->raw_nodal_position_gen(i,k,j);
          }
        }
      }
     else
      {
       for(unsigned k=0;k<1;k++)
        {
         for(unsigned j=0;j<2;j++)
          {
           x[j] = this->raw_nodal_position_gen(i,k,j);
          }
        }
      }
    }
   if(count == 2)// this case is a boundary element
    {
     bd_element = 1;
    }          
   else
    {
     bd_element = 0;           
    }               
  }
 
 // assign the set of value for a curved element
 inline void get_value_transform_matrix(DenseMatrix<double> &D, DenseMatrix<double> &B, DenseMatrix<double> &node_position,
                                          unsigned &bd_element, DenseMatrix<double> &bd_node_position, Vector<double> &x) const
  {
   /// classify nodes in the element
   classify_boundary_node(node_position,bd_element,bd_node_position,x);
   /// compute the set of value of degree of freedom
   C1CurvedElementShape<2,NNODE_1D>::set_of_value(D,B,node_position,bd_element,bd_node_position,x); 
  }

 /// Return local coordinates of node j
 inline void local_coordinate_of_node(const unsigned& j,Vector<double>& s) const
  {C1CurvedElementShape<2,NNODE_1D>::local_coordinate_of_node(j,s);}

 /// Calculate the c1-shape functions associated with a straight-sided 
 /// boundary at local coordinate s
 inline void basis_straight(const Vector<double> &s, Shape &psi) const
  {
   /// classify nodes in the element
   DenseMatrix<double> node_position(3,2);
   DenseMatrix<double> bd_node_position(20,2);
   Vector<double> x(2);
   unsigned bd_element;
   classify_boundary_node(node_position,bd_element,bd_node_position,x);
   BellElementShape<2>::Bshape(s,psi,node_position);
  }
 
 /// \short Compute the c1-shape functions associated with a straight-sided 
 /// boundary and derivatives w.r.t. global coordinates at local coordinate s
 inline void dbasis_local_straight(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids) const
  {
   /// classify nodes in the element
   DenseMatrix<double> node_position(3,2);
   DenseMatrix<double> bd_node_position(20,2);
   Vector<double> x(2);
   unsigned bd_element;
   classify_boundary_node(node_position,bd_element,bd_node_position,x);
   BellElementShape<2>::dBshape_local(s,psi,dpsids,node_position);
  }
  
  /// \short Compute the c1-shape functions associated with a straight-sided 
 /// boundary and derivatives w.r.t. global coordinates at local coordinate s
 inline void d2basis_local_straight(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids, DShape &d2psids) const
  {
   /// classify nodes in the element
   DenseMatrix<double> node_position(3,2);
   DenseMatrix<double> bd_node_position(20,2);
   Vector<double> x(2);
   unsigned bd_element;
   classify_boundary_node(node_position,bd_element,bd_node_position,x);
   BellElementShape<2>::d2Bshape_local(s,psi,dpsids,d2psids,node_position);
  }

 /// Calculate the c1-shape functions associated with a curved-sided 
 /// boundary at local coordinate s
 inline void basis_curve(const Vector<double> &s, Shape &psi) const
  {
   C1CurvedElementShape<2,NNODE_1D>::Cshape(s,psi); 
  }
 
 /// \short Compute the c1-shape functions associated with a curved-sided 
 /// boundary and derivatives w.r.t. local coordinates at local coordinate s
 inline void dbasis_local_curve(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids) const
  {
   C1CurvedElementShape<2,NNODE_1D>::dCshape_local(s,psi,dpsids);
  }
  
  /// \short Compute the c1-shape functions associated with a curved-sided 
 /// boundary and derivatives w.r.t. local coordinates at local coordinate s
 inline void d2basis_local_curve(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids, DShape &d2psids) const
  {
   C1CurvedElementShape<2,NNODE_1D>::d2Cshape_local(s,psi,dpsids,d2psids);
  }

 /// Calculate the linear shape functions at local coordinate s
 inline void shape_geom(const Vector<double> &s, Shape &psi, Shape &phi) const
  {
   /// classify nodes in the element
   DenseMatrix<double> node_position(3,2);
   DenseMatrix<double> bd_node_position(20,2);
   Vector<double> x(2);
   unsigned bd_element;
   classify_boundary_node(node_position,bd_element,bd_node_position,x);
   // Calculate the geometric shape functions at local coordinate s
   GeometricTElement<2>::Lshape(s,psi,phi,node_position,bd_element,bd_node_position,x);
  }
 
 /// \short Compute the linear functions and 
 /// derivatives w.r.t. local coordinates at local coordinate s
 inline void dshape_local_geom(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids, Shape &phi, 
                          DShape &dphids) const
  {
   /// classify nodes in the element
   DenseMatrix<double> node_position(3,2);
   DenseMatrix<double> bd_node_position(20,2);
   Vector<double> x(2);
   unsigned bd_element;
   classify_boundary_node(node_position,bd_element,bd_node_position,x);
   GeometricTElement<2>::dLshape_local(s,psi,dpsids,phi,dphids,node_position,bd_element,bd_node_position,x);
  }

 /// \short Compute the linear functions and 
 /// derivatives w.r.t. local coordinates at local coordinate s
 inline void d2shape_local_geom(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids, DShape &d2psids, Shape &phi, 
                          DShape &dphids, DShape &d2phids) const
  {
   /// classify nodes in the element
   DenseMatrix<double> node_position(3,2);
   DenseMatrix<double> bd_node_position(20,2);
   Vector<double> x(2);
   unsigned bd_element;
   classify_boundary_node(node_position,bd_element,bd_node_position,x);
   GeometricTElement<2>::d2Lshape_local(s,psi,dpsids,d2psids,phi,dphids,d2phids,node_position,bd_element,bd_node_position,x);
  }
  
 /// Calculate the c0-shape functions at local coordinate s
 inline void basis_c0(const Vector<double> &s, Shape &psi) const
  {
   TElementShape<2,NNODE_1D>::shape(s,psi);
  }
 
 /// \short Compute the c0-shape functions and 
 /// derivatives w.r.t. local coordinates at local coordinate s
 inline void dbasis_c0_local(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids) const
  {
   TElementShape<2,NNODE_1D>::dshape_local(s,psi,dpsids);
  }
 
 /// \short Computer the c0-shape functions, derivatives and
 /// second derivatives w.r.t local coordinates at local coordinate s \n
 /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
 /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
 /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
 inline void d2basis_c0_local(const Vector<double> &s, Shape &psi, 
                           DShape &dpsids, DShape &d2psids) const
  {
   TElementShape<2,NNODE_1D>::d2shape_local(s,psi,dpsids,d2psids);
  }

 /// Calculate the test functions at local coordinate s
 inline void test(const Vector<double> &s, Shape &psi) const
  {
   TElementShape<2,NNODE_1D>::shape(s,psi);
  }
 
 /// \short Compute the  test functions and 
 /// derivatives w.r.t. local coordinates at local coordinate s
 inline void dtest_local(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids) const
  {
   TElementShape<2,NNODE_1D>::dshape_local(s,psi,dpsids);
  }
 
 /// \short Computer the geometric shape functions, derivatives and
 /// second derivatives w.r.t local coordinates at local coordinate s \n
 /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
 /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
 /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
 inline void d2test_local(const Vector<double> &s, Shape &psi, 
                           DShape &dpsids, DShape &d2psids) const
  {
   TElementShape<2,NNODE_1D>::d2shape_local(s,psi,dpsids,d2psids);
  }
 
 /// \short Build the lower-dimensional FaceElement (an element of type
 /// SolidTElement<1,NNODE_1D>). The face index takes three possible values:
 /// 0 (Left)         s[0] = 0.0
 /// 1 (Bottom)       s[1] = 0.0
 /// 2 (Sloping face) s[0] = 1.0 - s[1]
 void build_face_element(const int &face_index,
                                FaceElement* face_element_pt);

};

//===========================================================
/// Function to setup geometrical information for lower-dimensional
/// FaceElements (which are of type TElement<1,NNODE_1D>).
//===========================================================
template<unsigned NNODE_1D>
void C1CurvedElement<2,NNODE_1D>::
build_face_element(const int &face_index, FaceElement *face_element_pt)
{
 //Build the standard non-solid FaceElement
 TElement<2,NNODE_1D>::build_face_element(face_index,face_element_pt);
}

//=======================================================================
/// Face geometry for the 2D C1CurvedElement elements is exactly
/// the same as for the corresponding TElement. The spatial 
/// dimension of the face elements is one lower than that of the
/// bulk element but they have the same number of points
/// along their 1D edges.
//=======================================================================
template<unsigned NNODE_1D>
class FaceGeometry<C1CurvedElement<2,NNODE_1D> >: 
public virtual TElement<1,NNODE_1D>
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional QElement
 FaceGeometry() : TElement<1,NNODE_1D>() {}

};


}
#endif
